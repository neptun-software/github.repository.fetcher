{
  "metadata": {
    "timestamp": 1736568297263,
    "page": 196,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zsh-users/zsh-history-substring-search",
      "stars": 2683,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0537109375,
          "content": "# zsh word code files (zcompile and zrecompile)\n*.zwc*\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.0927734375,
          "content": "# zsh-history-substring-search\n\nThis is a clean-room implementation of the [Fish shell][1]'s history search\nfeature, where you can type in any part of any command from history and then\npress chosen keys, such as the UP and DOWN arrows, to cycle through matches.\n\n[1]: http://fishshell.com\n[2]: http://www.zsh.org/mla/users/2009/msg00818.html\n[3]: http://sourceforge.net/projects/fizsh/\n[4]: https://github.com/robbyrussell/oh-my-zsh/pull/215\n[5]: https://github.com/zsh-users/zsh-history-substring-search\n[6]: https://github.com/zsh-users/zsh-syntax-highlighting\n\n\nRequirements\n------------------------------------------------------------------------------\n\n* [ZSH](http://zsh.sourceforge.net) 4.3 or newer\n\nInstall\n------------------------------------------------------------------------------\n\nUsing the [Homebrew]( https://brew.sh ) package manager:\n\n    brew install zsh-history-substring-search\n    echo 'source $(brew --prefix)/share/zsh-history-substring-search/zsh-history-substring-search.zsh' >> ~/.zshrc\n\nUsing [Fig](https://fig.io):\n\nFig adds apps, shortcuts, and autocomplete to your existing terminal.\n\nInstall `zsh-history-substring-search` in just one click.\n\n<a href=\"https://fig.io/plugins/other/zsh-history-substring-search\" target=\"_blank\"><img src=\"https://fig.io/badges/install-with-fig.svg\" /></a>\n\nUsing [Oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh):\n\n1. Clone this repository in oh-my-zsh's plugins directory:\n\n        git clone https://github.com/zsh-users/zsh-history-substring-search ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search\n\n2. Activate the plugin in `~/.zshrc`:\n\n        plugins=( [plugins...] zsh-history-substring-search)\n\n3. Run `exec zsh`  to take changes into account:\n\n        exec zsh\n\nUsing [zplug](https://github.com/zplug/zplug):\n\n1. Add this repo to `~/.zshrc`:\n\n        zplug \"zsh-users/zsh-history-substring-search\", as: plugin\n\nUsing [antigen](https://github.com/zsh-users/antigen):\n\n1. Add the `antigen bundle` command just before `antigen apply`, like this:\n\n``` \nantigen bundle zsh-users/zsh-history-substring-search\nantigen apply\n```\n \n2. Then, **after** `antigen apply`, add the key binding configurations, like this:\n \n```\n# zsh-history-substring-search configuration\nbindkey '^[[A' history-substring-search-up # or '\\eOA'\nbindkey '^[[B' history-substring-search-down # or '\\eOB'\nHISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE=1\n```\n\nUsing [Zinit](https://github.com/zdharma-continuum/zinit):\n\n1. Use the `Oh-my-zsh` Zinit snippet in `~/.zshrc`:\n\n        zinit snippet OMZ::plugins/git/git.plugin.zsh`\n\n2. Load the plugin in `~/.zshrc`:\n\n        zinit load 'zsh-users/zsh-history-substring-search\n        zinit ice wait atload'_history_substring_search_config'\n\n3. Run `exec zsh` to take changes into account:\n\n        exec zsh\n\nUsage\n------------------------------------------------------------------------------\n\n1.  Load this script into your interactive ZSH session:\n\n        source zsh-history-substring-search.zsh\n\n    If you want to use [zsh-syntax-highlighting][6] along with this script,\n    then make sure that you load it *before* you load this script:\n\n        source zsh-syntax-highlighting.zsh\n        source zsh-history-substring-search.zsh\n\n2.  Bind keyboard shortcuts to this script's functions.\n\n    Users typically bind their UP and DOWN arrow keys to this script, thus:\n    * Run `cat -v` in your favorite terminal emulator to observe key codes.\n      (**NOTE:** In some cases, `cat -v` shows the wrong key codes.  If the\n      key codes shown by `cat -v` don't work for you, press `<C-v><UP>` and\n      `<C-v><DOWN>` at your ZSH command line prompt for correct key codes.)\n    * Press the UP arrow key and observe what is printed in your terminal.\n    * Press the DOWN arrow key and observe what is printed in your terminal.\n    * Press the Control and C keys simultaneously to terminate the `cat -v`.\n    * Use your observations from the previous steps to create key bindings.\n      For example, if you observed `^[[A` for UP and `^[[B` for DOWN, then:\n\n          bindkey '^[[A' history-substring-search-up\n          bindkey '^[[B' history-substring-search-down\n\n      However, if the observed values don't work, you can try using terminfo:\n\n          bindkey \"$terminfo[kcuu1]\" history-substring-search-up\n          bindkey \"$terminfo[kcud1]\" history-substring-search-down\n\n      Users have also observed that `[OA` and `[OB` are correct values, \n      _even if_ these were not the observed values. If you are having trouble\n      with the observed values, give these a try.\n\n      You might also want to bind the Control-P/N keys for use in EMACS mode:\n\n          bindkey -M emacs '^P' history-substring-search-up\n          bindkey -M emacs '^N' history-substring-search-down\n\n      You might also want to bind the `k` and `j` keys for use in VI mode:\n\n          bindkey -M vicmd 'k' history-substring-search-up\n          bindkey -M vicmd 'j' history-substring-search-down\n\n3.  Type any part of any previous command and then:\n\n    * Press the `history-substring-search-up` key, which was configured in\n      step 2 above, to select the nearest command that (1) contains your query\n      and (2) is also older than the current command in your command history.\n\n    * Press the `history-substring-search-down` key, which was configured in\n      step 2 above, to select the nearest command that (1) contains your query\n      and (2) is also newer than the current command in your command history.\n\n    * Press `^U` the Control and U keys simultaneously to abort the search.\n\n4.  If a matching command spans more than one line of text, press the LEFT\n    arrow key to move the cursor away from the end of the command, and then:\n\n    * Press the `history-substring-search-up` key, which was configured in\n      step 2 above, to move the cursor to the line above the cursored line.\n      When the cursor reaches the first line of the command, pressing the\n      `history-substring-search-up` key again will cause this script to\n      perform another search.\n\n    * Press the `history-substring-search-down` key, which was configured in\n      step 2 above, to move the cursor to the line below the cursored line.\n      When the cursor reaches the last line of the command, pressing the\n      `history-substring-search-down` key, which was configured in step 2\n      above, again will cause this script to perform another search.\n\n\nConfiguration\n------------------------------------------------------------------------------\n\nThis script defines the following global variables. You may override their\ndefault values.\n\n* `HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND` is a global variable that defines\n  how the query should be highlighted inside a matching command. Its default\n  value causes this script to highlight using bold, white text on a magenta\n  background. See the \"Character Highlighting\" section in the zshzle(1) man\n  page to learn about the kinds of values you may assign to this variable.\n\n* `HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND` is a global variable that\n  defines how the query should be highlighted when no commands in the\n  history match it. Its default value causes this script to highlight using\n  bold, white text on a red background. See the \"Character Highlighting\"\n  section in the zshzle(1) man page to learn about the kinds of values you\n  may assign to this variable.\n\n* `HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS` is a global variable that defines\n  how the command history will be searched for your query. Its default value\n  causes this script to perform a case-insensitive search. See the \"Globbing\n  Flags\" section in the zshexpn(1) man page to learn about the kinds of\n  values you may assign to this variable.\n\n* `HISTORY_SUBSTRING_SEARCH_FUZZY` is a global variable that defines\n  how the command history will be searched for your query. If set to a non-empty\n  value, causes this script to perform a fuzzy search by words, matching in\n  given order e.g. `ab c` will match `*ab*c*`\n\n* `HISTORY_SUBSTRING_SEARCH_PREFIXED` is a global variable that defines how\n  the command history will be searched for your query. If set to a non-empty\n  value, your query will be matched against the start of each history entry.\n  For example, if this variable is empty, `ls` will match `ls -l` and `echo\n  ls`; if it is non-empty, `ls` will only match `ls -l`.\n\n* `HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE` is a global variable that defines\n  whether all search results returned are _unique_. If set to a non-empty\n  value, then only unique search results are presented. This behaviour is off\n  by default. An alternative way to ensure that search results are unique is\n  to use `setopt HIST_IGNORE_ALL_DUPS`. If this configuration variable is off\n  and `setopt HIST_IGNORE_ALL_DUPS` is unset, then `setopt HIST_FIND_NO_DUPS`\n  is still respected and it makes this script skip duplicate _adjacent_ search\n  results as you cycle through them, but this does not guarantee that search\n  results are unique: if your search results were \"Dog\", \"Dog\", \"HotDog\",\n  \"Dog\", then cycling them gives \"Dog\", \"HotDog\", \"Dog\". Notice that the \"Dog\"\n  search result appeared twice as you cycled through them. If you wish to\n  receive globally unique search results only once, then use this\n  configuration variable, or use `setopt HIST_IGNORE_ALL_DUPS`.\n\n* `HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_TIMEOUT` is a global variable that\n  defines a timeout in seconds for clearing the search highlight.\n\n\nHistory\n------------------------------------------------------------------------------\n\n* September 2009: [Peter Stephenson][2] originally wrote this script and it\n  published to the zsh-users mailing list.\n\n* January 2011: Guido van Steen (@guidovansteen) revised this script and\n  released it under the 3-clause BSD license as part of [fizsh][3], the\n  Friendly Interactive ZSHell.\n\n* January 2011: Suraj N. Kurapati (@sunaku) extracted this script from\n  [fizsh][3] 1.0.1, refactored it heavily, and finally repackaged it as an\n  [oh-my-zsh plugin][4] and as an independently loadable [ZSH script][5].\n\n* July 2011: Guido van Steen, Suraj N. Kurapati, and Sorin Ionescu\n  (@sorin-ionescu) [further developed it][4] with Vincent Guerci (@vguerci).\n\n* March 2016: Geza Lore (@gezalore) greatly refactored it in pull request #55.\n"
        },
        {
          "name": "zsh-history-substring-search.plugin.zsh",
          "type": "blob",
          "size": 0.060546875,
          "content": "0=${(%):-%N}\nsource ${0:A:h}/zsh-history-substring-search.zsh\n"
        },
        {
          "name": "zsh-history-substring-search.zsh",
          "type": "blob",
          "size": 28.99609375,
          "content": "#!/usr/bin/env zsh\n##############################################################################\n#\n# Copyright (c) 2009 Peter Stephenson\n# Copyright (c) 2011 Guido van Steen\n# Copyright (c) 2011 Suraj N. Kurapati\n# Copyright (c) 2011 Sorin Ionescu\n# Copyright (c) 2011 Vincent Guerci\n# Copyright (c) 2016 Geza Lore\n# Copyright (c) 2017 Bengt Brodersen\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n#  * Redistributions in binary form must reproduce the above\n#    copyright notice, this list of conditions and the following\n#    disclaimer in the documentation and/or other materials provided\n#    with the distribution.\n#\n#  * Neither the name of the FIZSH nor the names of its contributors\n#    may be used to endorse or promote products derived from this\n#    software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n#\n##############################################################################\n\n#-----------------------------------------------------------------------------\n# declare global configuration variables\n#-----------------------------------------------------------------------------\n\n: ${HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='bg=magenta,fg=white,bold'}\n: ${HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND='bg=red,fg=white,bold'}\n: ${HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS='i'}\n: ${HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE=''}\n: ${HISTORY_SUBSTRING_SEARCH_FUZZY=''}\n: ${HISTORY_SUBSTRING_SEARCH_PREFIXED=''}\n\n#-----------------------------------------------------------------------------\n# declare internal global variables\n#-----------------------------------------------------------------------------\n\ntypeset -g BUFFER MATCH MBEGIN MEND CURSOR\ntypeset -g _history_substring_search_refresh_display\ntypeset -g _history_substring_search_query_highlight\ntypeset -g _history_substring_search_result\ntypeset -g _history_substring_search_query\ntypeset -g -a _history_substring_search_query_parts\ntypeset -g -a _history_substring_search_raw_matches\ntypeset -g -i _history_substring_search_raw_match_index\ntypeset -g -a _history_substring_search_matches\ntypeset -g -i _history_substring_search_match_index\ntypeset -g -A _history_substring_search_unique_filter\ntypeset -g -i _history_substring_search_zsh_5_9\n\n#-----------------------------------------------------------------------------\n# the main ZLE widgets\n#-----------------------------------------------------------------------------\n\nhistory-substring-search-up() {\n  _history-substring-search-begin\n\n  _history-substring-search-up-history ||\n  _history-substring-search-up-buffer ||\n  _history-substring-search-up-search\n\n  _history-substring-search-end\n}\n\nhistory-substring-search-down() {\n  _history-substring-search-begin\n\n  _history-substring-search-down-history ||\n  _history-substring-search-down-buffer ||\n  _history-substring-search-down-search\n\n  _history-substring-search-end\n}\n\nzle -N history-substring-search-up\nzle -N history-substring-search-down\n\n#-----------------------------------------------------------------------------\n# implementation details\n#-----------------------------------------------------------------------------\n\nzmodload -F zsh/parameter\nautoload -Uz is-at-least\n\nif is-at-least 5.9 $ZSH_VERSION; then\n  _history_substring_search_zsh_5_9=1\nfi\n\n#\n# We have to \"override\" some keys and widgets if the\n# zsh-syntax-highlighting plugin has not been loaded:\n#\n# https://github.com/nicoulaj/zsh-syntax-highlighting\n#\nif [[ $+functions[_zsh_highlight] -eq 0 ]]; then\n  #\n  # Dummy implementation of _zsh_highlight() that\n  # simply removes any existing highlights when the\n  # user inserts printable characters into $BUFFER.\n  #\n  _zsh_highlight() {\n    if [[ $KEYS == [[:print:]] ]]; then\n      region_highlight=()\n    fi\n  }\n\n  #\n  # Check if $1 denotes the name of a callable function, i.e. it is fully\n  # defined or it is marked for autoloading and autoloading it at the first\n  # call to it will succeed. In particular, if $1 has been marked for\n  # autoloading but is not available in $fpath, then it will return 1 (false).\n  #\n  # This is based on the zsh-syntax-highlighting plugin.\n  #\n  _history-substring-search-function-callable() {\n    if (( ${+functions[$1]} )) && ! [[ \"$functions[$1]\" == *\"builtin autoload -X\"* ]]; then\n      return 0 # already fully loaded\n    else\n      # \"$1\" is either an autoload stub, or not a function at all.\n      # We expect 'autoload +X' to return non-zero if it fails to fully load\n      # the function.\n      ( autoload -U +X -- \"$1\" 2>/dev/null )\n      return $?\n    fi\n  }\n\n  #\n  # The zsh-syntax-highlighting plugin uses zle-line-pre-redraw hook instead\n  # of the legacy \"bind all widgets\" if 1) zsh has the memo= feature (added in\n  # version 5.9) and 2) add-zle-hook-widget is available.\n  #\n  if [[ $_history_substring_search_zsh_5_9 -eq 1 ]] && _history-substring-search-function-callable add-zle-hook-widget; then\n    #\n    # The following code is based on the zsh-syntax-highlighting plugin.\n    #\n    autoload -U add-zle-hook-widget\n\n    _history-substring-search-zle-line-finish() {\n      #\n      # Reset $WIDGET since the 'main' highlighter depends on it.\n      #\n      # Since $WIDGET is declared by zle as read-only in this function's scope,\n      # a nested function is required in order to shadow its built-in value;\n      # see \"User-defined widgets\" in zshall.\n      #\n      () {\n        local -h -r WIDGET=zle-line-finish\n        _zsh_highlight\n      }\n    }\n\n    _history-substring-search-zle-line-pre-redraw() {\n      #\n      # If the zsh-syntax-highlighting plugin has been loaded (after our plugin\n      # plugin, otherwise this hook wouldn't be called), remove our hooks.\n      #\n      if [[ $+ZSH_HIGHLIGHT_VERSION -eq 1 ]]; then\n        autoload -U add-zle-hook-widget\n        add-zle-hook-widget -d zle-line-pre-redraw _history-substring-search-zle-line-pre-redraw\n        add-zle-hook-widget -d zle-line-finish _history-substring-search-zle-line-finish\n        return 0\n      fi\n      #\n      # Set $? to 0 for _zsh_highlight.  Without this, subsequent\n      # zle-line-pre-redraw hooks won't run, since add-zle-hook-widget happens to\n      # call us with $? == 1 in the common case.\n      #\n      true && _zsh_highlight \"$@\"\n    }\n\n    if [[ -o zle ]]; then\n      add-zle-hook-widget zle-line-pre-redraw _history-substring-search-zle-line-pre-redraw\n      add-zle-hook-widget zle-line-finish _history-substring-search-zle-line-finish\n    fi\n  else\n    #\n    # The following snippet was taken from the zsh-syntax-highlighting project:\n    # https://github.com/zsh-users/zsh-syntax-highlighting/blob/56b134f5d62ae3d4e66c7f52bd0cc2595f9b305b/zsh-syntax-highlighting.zsh#L126-161\n    #\n    # SPDX-SnippetBegin\n    # SPDX-License-Identifier: BSD-3-Clause\n    # SPDX-SnippetCopyrightText: 2010-2011 zsh-syntax-highlighting contributors\n    #--------------8<-------------------8<-------------------8<-----------------\n    # Rebind all ZLE widgets to make them invoke _zsh_highlights.\n    _zsh_highlight_bind_widgets()\n    {\n      # Load ZSH module zsh/zleparameter, needed to override user defined widgets.\n      zmodload zsh/zleparameter 2>/dev/null || {\n        echo 'zsh-syntax-highlighting: failed loading zsh/zleparameter.' >&2\n        return 1\n      }\n\n      # Override ZLE widgets to make them invoke _zsh_highlight.\n      local cur_widget\n      for cur_widget in ${${(f)\"$(builtin zle -la)\"}:#(.*|_*|orig-*|run-help|which-command|beep|yank*)}; do\n        case $widgets[$cur_widget] in\n\n          # Already rebound event: do nothing.\n          user:$cur_widget|user:_zsh_highlight_widget_*);;\n\n          # User defined widget: override and rebind old one with prefix \"orig-\".\n          user:*) eval \"zle -N orig-$cur_widget ${widgets[$cur_widget]#*:}; \\\n                        _zsh_highlight_widget_$cur_widget() { builtin zle orig-$cur_widget -- \\\"\\$@\\\" && _zsh_highlight }; \\\n                        zle -N $cur_widget _zsh_highlight_widget_$cur_widget\";;\n\n          # Completion widget: override and rebind old one with prefix \"orig-\".\n          completion:*) eval \"zle -C orig-$cur_widget ${${widgets[$cur_widget]#*:}/:/ }; \\\n                              _zsh_highlight_widget_$cur_widget() { builtin zle orig-$cur_widget -- \\\"\\$@\\\" && _zsh_highlight }; \\\n                              zle -N $cur_widget _zsh_highlight_widget_$cur_widget\";;\n\n          # Builtin widget: override and make it call the builtin \".widget\".\n          builtin) eval \"_zsh_highlight_widget_$cur_widget() { builtin zle .$cur_widget -- \\\"\\$@\\\" && _zsh_highlight }; \\\n                         zle -N $cur_widget _zsh_highlight_widget_$cur_widget\";;\n\n          # Default: unhandled case.\n          *) echo \"zsh-syntax-highlighting: unhandled ZLE widget '$cur_widget'\" >&2 ;;\n        esac\n      done\n    }\n    #-------------->8------------------->8------------------->8-----------------\n    # SPDX-SnippetEnd\n\n    _zsh_highlight_bind_widgets\n  fi\n\n  unfunction _history-substring-search-function-callable\nfi\n\n_history-substring-search-begin() {\n  setopt localoptions extendedglob\n\n  _history_substring_search_refresh_display=\n  _history_substring_search_query_highlight=\n\n  #\n  # If the buffer is the same as the previously displayed history substring\n  # search result, then just keep stepping through the match list. Otherwise\n  # start a new search.\n  #\n  if [[ -n $BUFFER && $BUFFER == ${_history_substring_search_result:-} ]]; then\n    return;\n  fi\n\n  #\n  # Clear the previous result.\n  #\n  _history_substring_search_result=''\n\n  if [[ -z $BUFFER ]]; then\n    #\n    # If the buffer is empty, we will just act like up-history/down-history\n    # in ZSH, so we do not need to actually search the history. This should\n    # speed things up a little.\n    #\n    _history_substring_search_query=\n    _history_substring_search_query_parts=()\n    _history_substring_search_raw_matches=()\n\n  else\n    #\n    # For the purpose of highlighting we keep a copy of the original\n    # query string.\n    #\n    _history_substring_search_query=$BUFFER\n\n    #\n    # compose search pattern\n    #\n    if [[ -n $HISTORY_SUBSTRING_SEARCH_FUZZY ]]; then\n      #\n      # `=` split string in arguments\n      #\n      _history_substring_search_query_parts=(${=_history_substring_search_query})\n    else\n      _history_substring_search_query_parts=(${==_history_substring_search_query})\n    fi\n\n    #\n    # Escape and join query parts with wildcard character '*' as seperator\n    # `(j:CHAR:)` join array to string with CHAR as seperator\n    #\n    local search_pattern=\"${(j:*:)_history_substring_search_query_parts[@]//(#m)[\\][()|\\\\*?#<>~^]/\\\\$MATCH}*\"\n\n    #\n    # Support anchoring history search to the beginning of the command\n    #\n    if [[ -z $HISTORY_SUBSTRING_SEARCH_PREFIXED ]]; then\n      search_pattern=\"*${search_pattern}\"\n    fi\n\n    #\n    # Find all occurrences of the search pattern in the history file.\n    #\n    # (k) returns the \"keys\" (history index numbers) instead of the values\n    # (R) returns values in reverse older, so the index of the youngest\n    # matching history entry is at the head of the list.\n    #\n    _history_substring_search_raw_matches=(${(k)history[(R)(#$HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS)${search_pattern}]})\n  fi\n\n  #\n  # In order to stay as responsive as possible, we will process the raw\n  # matches lazily (when the user requests the next match) to choose items\n  # that need to be displayed to the user.\n  # _history_substring_search_raw_match_index holds the index of the last\n  # unprocessed entry in _history_substring_search_raw_matches. Any items\n  # that need to be displayed will be added to\n  # _history_substring_search_matches.\n  #\n  # We use an associative array (_history_substring_search_unique_filter) as\n  # a 'set' data structure to ensure uniqueness of the results if desired.\n  # If an entry (key) is in the set (non-empty value), then we have already\n  # added that entry to _history_substring_search_matches.\n  #\n  _history_substring_search_raw_match_index=0\n  _history_substring_search_matches=()\n  _history_substring_search_unique_filter=()\n\n  #\n  # If $_history_substring_search_match_index is equal to\n  # $#_history_substring_search_matches + 1, this indicates that we\n  # are beyond the end of $_history_substring_search_matches and that we\n  # have also processed all entries in\n  # _history_substring_search_raw_matches.\n  #\n  # If $#_history_substring_search_match_index is equal to 0, this indicates\n  # that we are beyond the beginning of $_history_substring_search_matches.\n  #\n  # If we have initially pressed \"up\" we have to initialize\n  # $_history_substring_search_match_index to 0 so that it will be\n  # incremented to 1.\n  #\n  # If we have initially pressed \"down\" we have to initialize\n  # $_history_substring_search_match_index to 1 so that it will be\n  # decremented to 0.\n  #\n  if [[ $WIDGET == history-substring-search-down ]]; then\n     _history_substring_search_match_index=1\n  else\n    _history_substring_search_match_index=0\n  fi\n}\n\n_history-substring-search-end() {\n  setopt localoptions extendedglob\n\n  local highlight_memo=\n  _history_substring_search_result=$BUFFER\n\n  if [[ $_history_substring_search_zsh_5_9 -eq 1 ]]; then\n    highlight_memo='memo=history-substring-search'\n  fi\n\n  # the search was successful so display the result properly by clearing away\n  # existing highlights and moving the cursor to the end of the result buffer\n  if [[ $_history_substring_search_refresh_display -eq 1 ]]; then\n    if [[ -n $highlight_memo ]]; then\n      region_highlight=( \"${(@)region_highlight:#*${highlight_memo}*}\" )\n    else\n      region_highlight=()\n    fi\n    CURSOR=${#BUFFER}\n  fi\n\n  # highlight command line using zsh-syntax-highlighting\n  _zsh_highlight\n\n  # highlight the search query inside the command line\n  if [[ -n $_history_substring_search_query_highlight ]]; then\n    # highlight first matching query parts\n    local highlight_start_index=0\n    local highlight_end_index=0\n    local query_part\n    for query_part in $_history_substring_search_query_parts; do\n      local escaped_query_part=${query_part//(#m)[\\][()|\\\\*?#<>~^]/\\\\$MATCH}\n      # (i) get index of pattern\n      local query_part_match_index=\"${${BUFFER:$highlight_start_index}[(i)(#$HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS)${escaped_query_part}]}\"\n      if [[ $query_part_match_index -le ${#BUFFER:$highlight_start_index} ]]; then\n        highlight_start_index=$(( $highlight_start_index + $query_part_match_index ))\n        highlight_end_index=$(( $highlight_start_index + ${#query_part} ))\n        region_highlight+=(\n          \"$(($highlight_start_index - 1)) $(($highlight_end_index - 1)) ${_history_substring_search_query_highlight}${highlight_memo:+,$highlight_memo}\"\n        )\n      fi\n    done\n  fi\n\n  # For debugging purposes:\n  # zle -R \"mn: \"$_history_substring_search_match_index\" m#: \"${#_history_substring_search_matches}\n  # read -k -t 200 && zle -U -- \"$REPLY\"\n\n  #\n  # When this function returns, z-sy-h runs its line-pre-redraw hook. It has no\n  # logic for determining highlight priority, when two different memo= marked\n  # region highlights overlap; instead, it always prioritises itself. Below is\n  # a workaround for dealing with it.\n  #\n  if [[ $_history_substring_search_zsh_5_9 -eq 1 ]]; then\n    zle -R\n    #\n    # After line redraw with desired highlight, wait for timeout or user input\n    # before removing search highlight and exiting. This ensures no highlights\n    # are left lingering after search is finished.\n    #\n    read -k -t ${HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_TIMEOUT:-1} && zle -U -- \"$REPLY\"\n    region_highlight=( \"${(@)region_highlight:#*${highlight_memo}*}\" )\n  fi\n\n  # Exit successfully from the history-substring-search-* widgets.\n  return 0\n}\n\n_history-substring-search-up-buffer() {\n  #\n  # Check if the UP arrow was pressed to move the cursor within a multi-line\n  # buffer. This amounts to three tests:\n  #\n  # 1. $#buflines -gt 1.\n  #\n  # 2. $CURSOR -ne $#BUFFER.\n  #\n  # 3. Check if we are on the first line of the current multi-line buffer.\n  #    If so, pressing UP would amount to leaving the multi-line buffer.\n  #\n  #    We check this by adding an extra \"x\" to $LBUFFER, which makes\n  #    sure that xlbuflines is always equal to the number of lines\n  #    until $CURSOR (including the line with the cursor on it).\n  #\n  local buflines XLBUFFER xlbuflines\n  buflines=(${(f)BUFFER})\n  XLBUFFER=$LBUFFER\"x\"\n  xlbuflines=(${(f)XLBUFFER})\n\n  if [[ $#buflines -gt 1 && $CURSOR -ne $#BUFFER && $#xlbuflines -ne 1 ]]; then\n    zle up-line-or-history\n    return 0\n  fi\n\n  return 1\n}\n\n_history-substring-search-down-buffer() {\n  #\n  # Check if the DOWN arrow was pressed to move the cursor within a multi-line\n  # buffer. This amounts to three tests:\n  #\n  # 1. $#buflines -gt 1.\n  #\n  # 2. $CURSOR -ne $#BUFFER.\n  #\n  # 3. Check if we are on the last line of the current multi-line buffer.\n  #    If so, pressing DOWN would amount to leaving the multi-line buffer.\n  #\n  #    We check this by adding an extra \"x\" to $RBUFFER, which makes\n  #    sure that xrbuflines is always equal to the number of lines\n  #    from $CURSOR (including the line with the cursor on it).\n  #\n  local buflines XRBUFFER xrbuflines\n  buflines=(${(f)BUFFER})\n  XRBUFFER=\"x\"$RBUFFER\n  xrbuflines=(${(f)XRBUFFER})\n\n  if [[ $#buflines -gt 1 && $CURSOR -ne $#BUFFER && $#xrbuflines -ne 1 ]]; then\n    zle down-line-or-history\n    return 0\n  fi\n\n  return 1\n}\n\n_history-substring-search-up-history() {\n  #\n  # Behave like up in ZSH, except clear the $BUFFER\n  # when beginning of history is reached like in Fish.\n  #\n  if [[ -z $_history_substring_search_query ]]; then\n\n    # we have reached the absolute top of history\n    if [[ $HISTNO -eq 1 ]]; then\n      BUFFER=\n\n    # going up from somewhere below the top of history\n    else\n      zle up-line-or-history\n    fi\n\n    return 0\n  fi\n\n  return 1\n}\n\n_history-substring-search-down-history() {\n  #\n  # Behave like down-history in ZSH, except clear the\n  # $BUFFER when end of history is reached like in Fish.\n  #\n  if [[ -z $_history_substring_search_query ]]; then\n\n    # going down from the absolute top of history\n    if [[ $HISTNO -eq 1 && -z $BUFFER ]]; then\n      BUFFER=${history[1]}\n      _history_substring_search_refresh_display=1\n\n    # going down from somewhere above the bottom of history\n    else\n      zle down-line-or-history\n    fi\n\n    return 0\n  fi\n\n  return 1\n}\n\n_history_substring_search_process_raw_matches() {\n  #\n  # Process more outstanding raw matches and append any matches that need to\n  # be displayed to the user to _history_substring_search_matches.\n  # Return whether there were any more results appended.\n  #\n\n  #\n  # While we have more raw matches. Process them to see if there are any more\n  # matches that need to be displayed to the user.\n  #\n  while [[ $_history_substring_search_raw_match_index -lt $#_history_substring_search_raw_matches ]]; do\n    #\n    # Move on to the next raw entry and get its history index.\n    #\n    _history_substring_search_raw_match_index+=1\n    local index=${_history_substring_search_raw_matches[$_history_substring_search_raw_match_index]}\n\n    #\n    # If HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE is set to a non-empty value,\n    # then ensure that only unique matches are presented to the user.\n    # When HIST_IGNORE_ALL_DUPS is set, ZSH already ensures a unique history,\n    # so in this case we do not need to do anything.\n    #\n    if [[ ! -o HIST_IGNORE_ALL_DUPS && -n $HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE ]]; then\n      #\n      # Get the actual history entry at the new index, and check if we have\n      # already added it to _history_substring_search_matches.\n      #\n      local entry=${history[$index]}\n\n      if [[ -z ${_history_substring_search_unique_filter[$entry]} ]]; then\n        #\n        # This is a new unique entry. Add it to the filter and append the\n        # index to _history_substring_search_matches.\n        #\n        _history_substring_search_unique_filter[$entry]=1\n        _history_substring_search_matches+=($index)\n\n        #\n        # Indicate that we did find a match.\n        #\n        return 0\n      fi\n\n    else\n      #\n      # Just append the new history index to the processed matches.\n      #\n      _history_substring_search_matches+=($index)\n\n      #\n      # Indicate that we did find a match.\n      #\n      return 0\n    fi\n\n  done\n\n  #\n  # We are beyond the end of the list of raw matches. Indicate that no\n  # more matches are available.\n  #\n  return 1\n}\n\n_history-substring-search-has-next() {\n  #\n  # Predicate function that returns whether any more older matches are\n  # available.\n  #\n\n  if  [[ $_history_substring_search_match_index -lt $#_history_substring_search_matches ]]; then\n    #\n    # We did not reach the end of the processed list, so we do have further\n    # matches.\n    #\n    return 0\n\n  else\n    #\n    # We are at the end of the processed list. Try to process further\n    # unprocessed matches. _history_substring_search_process_raw_matches\n    # returns whether any more matches were available, so just return\n    # that result.\n    #\n    _history_substring_search_process_raw_matches\n    return $?\n  fi\n}\n\n_history-substring-search-has-prev() {\n  #\n  # Predicate function that returns whether any more younger matches are\n  # available.\n  #\n\n  if [[ $_history_substring_search_match_index -gt 1 ]]; then\n    #\n    # We did not reach the beginning of the processed list, so we do have\n    # further matches.\n    #\n    return 0\n\n  else\n    #\n    # We are at the beginning of the processed list. We do not have any more\n    # matches.\n    #\n    return 1\n  fi\n}\n\n_history-substring-search-found() {\n  #\n  # A match is available. The index of the match is held in\n  # $_history_substring_search_match_index\n  #\n  # 1. Make $BUFFER equal to the matching history entry.\n  #\n  # 2. Use $HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND\n  #    to highlight the current buffer.\n  #\n  BUFFER=$history[$_history_substring_search_matches[$_history_substring_search_match_index]]\n  _history_substring_search_query_highlight=$HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND\n}\n\n_history-substring-search-not-found() {\n  #\n  # No more matches are available.\n  #\n  # 1. Make $BUFFER equal to $_history_substring_search_query so the user can\n  #    revise it and search again.\n  #\n  # 2. Use $HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND\n  #    to highlight the current buffer.\n  #\n  BUFFER=$_history_substring_search_query\n  _history_substring_search_query_highlight=$HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND\n}\n\n_history-substring-search-up-search() {\n  _history_substring_search_refresh_display=1\n\n  #\n  # Select history entry during history-substring-down-search:\n  #\n  # The following variables have been initialized in\n  # _history-substring-search-up/down-search():\n  #\n  # $_history_substring_search_matches is the current list of matches that\n  # need to be displayed to the user.\n  # $_history_substring_search_match_index is the index of the current match\n  # that is being displayed to the user.\n  #\n  # The range of values that $_history_substring_search_match_index can take\n  # is: [0, $#_history_substring_search_matches + 1].  A value of 0\n  # indicates that we are beyond the beginning of\n  # $_history_substring_search_matches. A value of\n  # $#_history_substring_search_matches + 1 indicates that we are beyond\n  # the end of $_history_substring_search_matches and that we have also\n  # processed all entries in _history_substring_search_raw_matches.\n  #\n  # If $_history_substring_search_match_index equals\n  # $#_history_substring_search_matches and\n  # $_history_substring_search_raw_match_index is not greater than\n  # $#_history_substring_search_raw_matches, then we need to further process\n  # $_history_substring_search_raw_matches to see if there are any more\n  # entries that need to be displayed to the user.\n  #\n  # In _history-substring-search-up-search() the initial value of\n  # $_history_substring_search_match_index is 0. This value is set in\n  # _history-substring-search-begin(). _history-substring-search-up-search()\n  # will initially increment it to 1.\n  #\n\n  if [[ $_history_substring_search_match_index -gt $#_history_substring_search_matches ]]; then\n    #\n    # We are beyond the end of $_history_substring_search_matches. This\n    # can only happen if we have also exhausted the unprocessed matches in\n    # _history_substring_search_raw_matches.\n    #\n    # 1. Update display to indicate search not found.\n    #\n    _history-substring-search-not-found\n    return\n  fi\n\n  if _history-substring-search-has-next; then\n    #\n    # We do have older matches.\n    #\n    # 1. Move index to point to the next match.\n    # 2. Update display to indicate search found.\n    #\n    _history_substring_search_match_index+=1\n    _history-substring-search-found\n\n  else\n    #\n    # We do not have older matches.\n    #\n    # 1. Move the index beyond the end of\n    #    _history_substring_search_matches.\n    # 2. Update display to indicate search not found.\n    #\n    _history_substring_search_match_index+=1\n    _history-substring-search-not-found\n  fi\n\n  #\n  # When HIST_FIND_NO_DUPS is set, meaning that only unique command lines from\n  # history should be matched, make sure the new and old results are different.\n  #\n  # However, if the HIST_IGNORE_ALL_DUPS shell option, or\n  # HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE is set, then we already have a\n  # unique history, so in this case we do not need to do anything.\n  #\n  if [[ -o HIST_IGNORE_ALL_DUPS || -n $HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE ]]; then\n    return\n  fi\n\n  if [[ -o HIST_FIND_NO_DUPS && $BUFFER == $_history_substring_search_result ]]; then\n    #\n    # Repeat the current search so that a different (unique) match is found.\n    #\n    _history-substring-search-up-search\n  fi\n}\n\n_history-substring-search-down-search() {\n  _history_substring_search_refresh_display=1\n\n  #\n  # Select history entry during history-substring-down-search:\n  #\n  # The following variables have been initialized in\n  # _history-substring-search-up/down-search():\n  #\n  # $_history_substring_search_matches is the current list of matches that\n  # need to be displayed to the user.\n  # $_history_substring_search_match_index is the index of the current match\n  # that is being displayed to the user.\n  #\n  # The range of values that $_history_substring_search_match_index can take\n  # is: [0, $#_history_substring_search_matches + 1].  A value of 0\n  # indicates that we are beyond the beginning of\n  # $_history_substring_search_matches. A value of\n  # $#_history_substring_search_matches + 1 indicates that we are beyond\n  # the end of $_history_substring_search_matches and that we have also\n  # processed all entries in _history_substring_search_raw_matches.\n  #\n  # In _history-substring-search-down-search() the initial value of\n  # $_history_substring_search_match_index is 1. This value is set in\n  # _history-substring-search-begin(). _history-substring-search-down-search()\n  # will initially decrement it to 0.\n  #\n\n  if [[ $_history_substring_search_match_index -lt 1 ]]; then\n    #\n    # We are beyond the beginning of $_history_substring_search_matches.\n    #\n    # 1. Update display to indicate search not found.\n    #\n    _history-substring-search-not-found\n    return\n  fi\n\n  if _history-substring-search-has-prev; then\n    #\n    # We do have younger matches.\n    #\n    # 1. Move index to point to the previous match.\n    # 2. Update display to indicate search found.\n    #\n    _history_substring_search_match_index+=-1\n    _history-substring-search-found\n\n  else\n    #\n    # We do not have younger matches.\n    #\n    # 1. Move the index beyond the beginning of\n    #    _history_substring_search_matches.\n    # 2. Update display to indicate search not found.\n    #\n    _history_substring_search_match_index+=-1\n    _history-substring-search-not-found\n  fi\n\n  #\n  # When HIST_FIND_NO_DUPS is set, meaning that only unique command lines from\n  # history should be matched, make sure the new and old results are different.\n  #\n  # However, if the HIST_IGNORE_ALL_DUPS shell option, or\n  # HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE is set, then we already have a\n  # unique history, so in this case we do not need to do anything.\n  #\n  if [[ -o HIST_IGNORE_ALL_DUPS || -n $HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE ]]; then\n    return\n  fi\n\n  if [[ -o HIST_FIND_NO_DUPS && $BUFFER == $_history_substring_search_result ]]; then\n    #\n    # Repeat the current search so that a different (unique) match is found.\n    #\n    _history-substring-search-down-search\n  fi\n}\n\n# -*- mode: zsh; sh-indentation: 2; indent-tabs-mode: nil; sh-basic-offset: 2; -*-\n# vim: ft=zsh sw=2 ts=2 et\n"
        }
      ]
    }
  ]
}