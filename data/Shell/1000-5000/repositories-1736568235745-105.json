{
  "metadata": {
    "timestamp": 1736568235745,
    "page": 105,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jeffreytse/zsh-vi-mode",
      "stars": 3424,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2020 Jeffrey Tse\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.013671875,
          "content": "<div align=\"center\">\n  <a href=\"https://github.com/jeffreytse/zsh-vi-mode\">\n    <img alt=\"vi-mode ‚Üí~ zsh\" src=\"https://user-images.githubusercontent.com/9413601/103399068-46bfcb80-4b7a-11eb-8741-86cff3d85a69.png\" width=\"600\">\n  </a>\n  <p> üíª A better and friendly vi(vim) mode plugin for ZSH.  </p>\n\n  <br> <h1>‚öíÔ∏è  Zsh Vi Mode ‚öíÔ∏è</h1>\n\n</div>\n\n\n\n<h4 align=\"center\">\n  <a href=\"https://www.zsh.org/\" target=\"_blank\"><code>ZSH</code></a> plugin for Agnosticism.\n</h4>\n\n<p align=\"center\">\n\n  <a href=\"https://github.com/sponsors/jeffreytse\">\n    <img src=\"https://img.shields.io/static/v1?label=sponsor&message=%E2%9D%A4&logo=GitHub&link=&color=greygreen\"\n      alt=\"Donate (GitHub Sponsor)\" />\n  </a>\n\n  <a href=\"https://github.com/jeffreytse/zsh-vi-mode/releases\">\n    <img src=\"https://img.shields.io/github/v/release/jeffreytse/zsh-vi-mode?color=brightgreen\"\n      alt=\"Release Version\" />\n  </a>\n\n  <a href=\"https://opensource.org/licenses/MIT\">\n    <img src=\"https://img.shields.io/badge/License-MIT-brightgreen.svg\"\n      alt=\"License: MIT\" />\n  </a>\n\n  <a href=\"https://liberapay.com/jeffreytse\">\n    <img src=\"http://img.shields.io/liberapay/goal/jeffreytse.svg?logo=liberapay\"\n      alt=\"Donate (Liberapay)\" />\n  </a>\n\n  <a href=\"https://patreon.com/jeffreytse\">\n    <img src=\"https://img.shields.io/badge/support-patreon-F96854.svg?style=flat-square\"\n      alt=\"Donate (Patreon)\" />\n  </a>\n\n  <a href=\"https://ko-fi.com/jeffreytse\">\n    <img height=\"20\" src=\"https://www.ko-fi.com/img/githubbutton_sm.svg\"\n      alt=\"Donate (Ko-fi)\" />\n  </a>\n\n</p>\n\n<div align=\"center\">\n  <h4>\n    <a href=\"#-features\">Features</a> |\n    <a href=\"#%EF%B8%8F-installation\">Install</a> |\n    <a href=\"#-usage\">Usage</a> |\n    <a href=\"#-credits\">Credits</a> |\n    <a href=\"#-license\">License</a>\n  </h4>\n</div>\n\n<div align=\"center\">\n  <sub>Built with ‚ù§Ô∏é by\n  <a href=\"https://jeffreytse.net\">jeffreytse</a> and\n  <a href=\"https://github.com/jeffreytse/zsh-vi-mode/graphs/contributors\">contributors </a>\n</div>\n<br>\n\n<img alt=\"Zsh Vi-mode Demo\" src=\"https://user-images.githubusercontent.com/9413601/105746868-f3734a00-5f7a-11eb-8db5-22fcf50a171b.gif\" />\n\n## ü§î Why ZVM?\n\nMaybe you have experienced the default Vi mode in Zsh, after turning on\nthe default Vi mode, you gradually found that it had many problems, some\nfeatures were not perfect or non-existent, and some behaviors even were\ndifferent from the native Vi(Vim) mode.\n\nAlthough the default Vi mode was a bit embarrassing and unpleasant, you\nkept on using it and gradually lost your interest on it after using for\na period of time. Eventually, you disappointedly gave up.\n\nYou never think of the Vi mode for a long time, one day you accidentally\ndiscovered this plugin, you read here and realize that this plugin is to\nsolve the above problems and make you fall in love to Vi mode again. A\nsmile suddenly appeared on your face like regaining a good life.\n\n> If winter comes, can spring be far behind?\n\n\n## ‚ú® Features\n\n- üåü Pure Zsh's script without any third-party dependencies.\n- üéâ Better experience with the near-native vi(vim) mode.\n- ‚åõ Lower delay and better response (Mode switching speed, etc.).\n- ‚úèÔ∏è  Mode indication with different cursor styles.\n- üßÆ Cursor movement (Navigation).\n- üìù Insert & Replace (Insert mode).\n- üí° Text Objects (A word, inner word, etc.).\n- üîé Searching history.\n- ‚ùáÔ∏è  Undo, Redo, Cut, Copy, Paste, and Delete.\n- ü™ê Better surrounds functionality (Add, Replace, Delete, Move Around, and Highlight).\n- üßΩ Switch keywords (Increase/Decrease Number, Boolean, Weekday, Month, etc.).\n- ‚öôÔ∏è  Better functionality in command mode (**In progress**).\n- ü™Ä Repeating command such as `10p` and `4fa` (**In progress**).\n- üìí System clipboard (**In progress**).\n\n## üíº Requirements\n\nZSH: >= 5.1.0\n\n## üõ†Ô∏è Installation\n\n#### Using [Antigen](https://github.com/zsh-users/antigen)\n\nBundle `zsh-vi-mode` in your `.zshrc`\n\n```shell\nantigen bundle jeffreytse/zsh-vi-mode\n```\n\n#### Using [zplug](https://github.com/b4b4r07/zplug)\nLoad `zsh-vi-mode` as a plugin in your `.zshrc`\n\n```shell\nzplug \"jeffreytse/zsh-vi-mode\"\n```\n\n#### Using [zgen](https://github.com/tarjoilija/zgen)\n\nInclude the load command in your `.zshrc`\n\n```shell\nzgen load jeffreytse/zsh-vi-mode\n```\n\n#### Using [zinit](https://github.com/zdharma-continuum/zinit)\n\nInclude the load command in your `.zshrc`\n\n```shell\nzinit ice depth=1\nzinit light jeffreytse/zsh-vi-mode\n```\n\nNote: the use of `depth=1` ice is optional, other types of ice are neither\nrecommended nor officially supported by this plugin.\n\n#### As an [Oh My Zsh!](https://github.com/robbyrussell/oh-my-zsh) custom plugin\n\nClone `zsh-vi-mode` into your custom plugins repo\n\n```shell\ngit clone https://github.com/jeffreytse/zsh-vi-mode \\\n  $ZSH_CUSTOM/plugins/zsh-vi-mode\n```\nThen load as a plugin in your `.zshrc`\n\n```shell\nplugins+=(zsh-vi-mode)\n```\n\nKeep in mind that plugins need to be added before `oh-my-zsh.sh` is sourced.\n\n#### Using [Antibody](https://getantibody.github.io/)\n\nAdd `zsh-vi-mode` to your plugins file (e.g. `~/.zsh_plugins.txt`)\n\n```shell\njeffreytse/zsh-vi-mode\n```\n\n#### Using [Zap](https://github.com/zap-zsh/zap)\n\nLoad `zsh-vi-mode` as a plugin in your `.zshrc`\n\n```shell\nplug \"jeffreytse/zsh-vi-mode\"\n```\n\n#### Using [Zim](https://github.com/zimfw/zimfw)\n\nLoad `zsh-vi-mode` as a plugin in your `.zimrc`\n\n```shell\nzmodule jeffreytse/zsh-vi-mode\n```\n  \n#### Using [Homebrew](https://brew.sh/)\n\nFor Homebrew users, you can install it through the following command\n\n```shell\nbrew install zsh-vi-mode\n```\n\nThen source it in your `.zshrc` (or `.bashrc`)\n\n```shell\nsource $(brew --prefix)/opt/zsh-vi-mode/share/zsh-vi-mode/zsh-vi-mode.plugin.zsh\n```\n\n#### Arch Linux (AUR)\n\nFor Arch Linux users, you can install it through the following command\n\n```shell\nyay -S zsh-vi-mode\n```\n\nor the latest update (unstable)\n\n```shell\nyay -S zsh-vi-mode-git\n```\n\nThen source it in your `.zshrc` (or `.bashrc`)\n\n```shell\nsource /usr/share/zsh/plugins/zsh-vi-mode/zsh-vi-mode.plugin.zsh\n```\n\n#### Nix\n\nFor users of Nix, as of [e7e3480530b34a9fe8cb52963ec2cf66e6707e15](https://github.com/NixOS/nixpkgs/commit/e7e3480530b34a9fe8cb52963ec2cf66e6707e15) you can source the plugin through the following configuration\n\n```nix\nprograms = {\n  zsh = {\n    interactiveShellInit = ''\n      source ${pkgs.zsh-vi-mode}/share/zsh-vi-mode/zsh-vi-mode.plugin.zsh\n    '';\n  };\n};\n```\n  \nOr if you prefer `home-manager`:\n\n```nix\nhome-manager.users.[your username] = { pkgs, ... }: {\n  programs = {\n    zsh = {\n      initExtra = ''\n        source ${pkgs.zsh-vi-mode}/share/zsh-vi-mode/zsh-vi-mode.plugin.zsh\n      '';\n    };\n  };\n};\n```\n\nYou can also use `home-manager`'s built-in \"plugin\" feature:\n\n```nix\nhome-manager.users.[your username] = { pkgs, ... }: {\n  programs = {\n    zsh = {\n      plugins = [\n        {\n          name = \"vi-mode\";\n          src = pkgs.zsh-vi-mode;\n          file = \"share/zsh-vi-mode/zsh-vi-mode.plugin.zsh\";\n        }\n      ];\n    };\n  };\n};\n```\n\n#### Using [Fig](https://fig.io)\n\nFig adds apps, shortcuts, and autocomplete to your existing terminal.\n\nInstall `zsh-vi-mode` in just one click.\n\n<a href=\"https://fig.io/plugins/other/zsh-vi-mode\" target=\"_blank\"><img src=\"https://fig.io/badges/install-with-fig.svg\" /></a>\n\n#### Gentoo Linux\n\nAvailable in [dm9pZCAq overlay](https://github.com/gentoo-mirror/dm9pZCAq)\n\n```shell\neselect repository enable dm9pZCAq\nemerge --sync dm9pZCAq\nemerge app-shells/zsh-vi-mode\n```\n\nThen source it in your `.zshrc` (or `.bashrc`)\n\n```shell\nsource /usr/share/zsh/site-contrib/zsh-vi-mode/zsh-vi-mode.plugin.zsh\n```\n\n#### Manually\n\nClone this repository somewhere (`$HOME/.zsh-vi-mode` for example)\n\n```shell\ngit clone https://github.com/jeffreytse/zsh-vi-mode.git $HOME/.zsh-vi-mode\n```\nThen source it in your `.zshrc` (or `.bashrc`)\n\n```shell\nsource $HOME/.zsh-vi-mode/zsh-vi-mode.plugin.zsh\n```\n\n## Packaging Status\n\n[![Packaging status](https://repology.org/badge/vertical-allrepos/zsh-vi-mode.svg)](https://repology.org/project/zsh-vi-mode/versions)\n\n## üìö Usage\n\nUse `ESC` or `CTRL-[` to enter `Normal mode`.\n\nBut some people may like the custom escape key such as `jj`, `jk` and so on,\nif you want to custom the escape key, you can learn more from [here](#custom-escape-key).\n\nHistory\n-------\n\n- `ctrl-p` : Previous command in history\n- `ctrl-n` : Next command in history\n- `/`      : Search backward in history\n- `n`      : Repeat the last `/`\n\n\nMode indicators\n---------------\n\n`Normal mode` is indicated with block style cursor, and `Insert mode` with\nbeam style cursor by default.\n\nVim edition\n-----------\n\nIn `Normal mode` you can use `vv` to edit current command line in an editor\n(e.g. `vi`/`vim`/`nvim`...), because it is bound to the `Visual mode`.\n\nYou can change the editor by `ZVM_VI_EDITOR` option, by default it is\n`$EDITOR`.\n\nMovement\n--------\n\n- `$`   : To the end of the line\n- `^`   : To the first non-blank character of the line\n- `0`   : To the first character of the line\n- `w`   : [count] words forward\n- `W`   : [count] WORDS forward\n- `e`   : Forward to the end of word [count] inclusive\n- `E`   : Forward to the end of WORD [count] inclusive\n- `b`   : [count] words backward\n- `B`   : [count] WORDS backward\n- `t{char}`   : Till before [count]'th occurrence of {char} to the right\n- `T{char}`   : Till before [count]'th occurrence of {char} to the left\n- `f{char}`   : To [count]'th occurrence of {char} to the right\n- `F{char}`   : To [count]'th occurrence of {char} to the left\n- `;`   : Repeat latest f, t, F or T [count] times\n- `,`   : Repeat latest f, t, F or T in opposite direction\n\n\nInsertion\n---------\n\n- `i`   : Insert text before the cursor\n- `I`   : Insert text before the first character in the line\n- `a`   : Append text after the cursor\n- `A`   : Append text at the end of the line\n- `o`   : Insert new command line below the current one\n- `O`   : Insert new command line above the current one\n\nSurround\n--------\n\nThere are 2 kinds of keybinding mode for surround operating, default is\n`classic` mode, you can choose the mode by setting `ZVM_VI_SURROUND_BINDKEY`\noption.\n\n1. `classic` mode (verb->s->surround)\n\n- `S\"`    : Add `\"` for visual selection\n- `ys\"`   : Add `\"` for visual selection\n- `cs\"'`  : Change `\"` to `'`\n- `ds\"`   : Delete `\"`\n\n 2. `s-prefix` mode (s->verb->surround)\n- `sa\"`   : Add `\"` for visual selection\n- `sd\"`   : Delete `\"`\n- `sr\"'`  : Change `\"` to `'`\n\nNote that key sequences must be pressed in fairly quick succession to avoid a timeout. You may extend this timeout with the [`ZVM_KEYTIMEOUT` option](#readkey-engine).\n  \n#### How to select surround text object?\n\n- `vi\"`   : Select the text object inside the quotes\n- `va(`   : Select the text object including the brackets\n\nThen you can do any operation for the selection:\n\n1. Add surrounds for text object\n\n- `vi\"` -> `S[` or `sa[` => `\"object\"` -> `\"[object]\"`\n- `va\"` -> `S[` or `sa[` => `\"object\"` -> `[\"object\"]`\n\n2. Delete/Yank/Change text object\n\n- `di(` or `vi(` -> `d`\n- `ca(` or `va(` -> `c`\n- `yi(` or `vi(` -> `y`\n\nIncrement and Decrement\n--------\n\nIn normal mode, typing `ctrl-a` will increase to the next keyword, and typing\n`ctrl-x` will decrease to the next keyword. The keyword can be at the cursor,\nor to the right of the cursor (on the same line). The keyword could be as\nbelow:\n\n- Number (Decimal, Hexadecimal, Binary...)\n- Boolean (True or False, Yes or No, On or Off...)\n- Weekday (Sunday, Monday, Tuesday, Wednesday...)\n- Month (January, February, March, April, May...)\n- Operator (&&, ||, ++, --, ==, !==, and, or...)\n- ...\n\nFor example:\n\n1. Increment\n\n- `9` => `10`\n- `aa99bb` => `aa100bb`\n- `aa100bc` => `aa101bc`\n- `0xDe` => `0xdf`\n- `0Xdf` => `0Xe0`\n- `0b101` => `0b110`\n- `0B11` => `0B101`\n- `true` => `false`\n- `yes` => `no`\n- `on` => `off`\n- `T` => `F`\n- `Fri` => `Sat`\n- `Oct` => `Nov`\n- `Monday` => `Tuesday`\n- `January` => `February`\n- `+` => `-`\n- `++` => `--`\n- `==` => `!=`\n- `!==` => `===`\n- `&&` => `||`\n- `and` => `or`\n- ...\n\n2. Decrement:\n\n- `100` => `99`\n- `aa100bb` => `aa99bb`\n- `0` => `-1`\n- `0xdE0` => `0xDDF`\n- `0xffFf0` => `0xfffef`\n- `0xfffF0` => `0xFFFEF`\n- `0x0` => `0xffffffffffffffff`\n- `0Xf` => `0Xe`\n- `0b100` => `0b010`\n- `0B100` => `0B011`\n- `True` => `False`\n- `On` => `Off`\n- `Sun` => `Sat`\n- `Jan` => `Dec`\n- `Monday` => `Sunday`\n- `August` => `July`\n- `/` => `*`\n- `++` => `--`\n- `==` => `!=`\n- `!==` => `===`\n- `||` => `&&`\n- `or` => `and`\n- ...\n\nCustom Escape Key\n--------\n\nYou can use below options to custom the escape key which could better match\nyour flavor, such as `jj` or `jk` and so on.\n\n- `ZVM_VI_ESCAPE_BINDKEY`: The vi escape key in all modes (default is `^[`\n  => `ESC`)\n- `ZVM_VI_INSERT_ESCAPE_BINDKEY`: The vi escape key in insert mode (default\n  is `$ZVM_VI_ESCAPE_BINDKEY`)\n- `ZVM_VI_VISUAL_ESCAPE_BINDKEY`: The vi escape key in visual mode (default\n  is `$ZVM_VI_ESCAPE_BINDKEY`)\n- `ZVM_VI_OPPEND_ESCAPE_BINDKEY`: The vi escape key in operator pending mode\n  (default is `$ZVM_VI_ESCAPE_BINDKEY`)\n\nFor example:\n\n```zsh\n# Only changing the escape key to `jk` in insert mode, we still\n# keep using the default keybindings `^[` in other modes\nZVM_VI_INSERT_ESCAPE_BINDKEY=jk\n```\n\nReadkey Engine\n--------\n\nThis plugin has supported to choose the readkey engine for reading and\nprocessing the key events. It easy to do by the `ZVM_READKEY_ENGINE`option,\ncurrently the below engines are supported:\n\n- `ZVM_READKEY_ENGINE_NEX`: It is a better readkey engine to replace ZLE (Beta).\n- `ZVM_READKEY_ENGINE_ZLE`: It is Zsh's default readkey engine (ZLE).\n- `ZVM_READKEY_ENGINE_DEFAULT`: It is the default engine of this plugin\n  (It's the NEX engine now).\n\nThe NEX is a better engine for reading and handling the key events than the\nZsh's ZLE engine, currently the NEX engine is still at beta stage, you can\nchange back to Zsh's ZLE engine if you want.\n\nFor example:\n\n```zsh\n# Change to Zsh's default readkey engine\nZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE_ZLE\n```\n\nYou can use `ZVM_KEYTIMEOUT` option to adjust the key input timeout for\nwaiting for next key, default is `0.4` seconds.\n\nThe escape key is a special case, it can be used standalone. NEX engine\nwaits for a period after receiving the escape character, to determine\nwhether it is standalone or part of an escape sequence. While waiting,\nadditional key presses make the escape key behave as a meta key. If no\nother key presses come in, it is handled as a standalone escape.\n\nFor the NEX engine, we can use `ZVM_ESCAPE_KEYTIMEOUT` option to adjust\nthe waiting timeout for the escape key, default is `0.03` seconds.\n\nConfiguration Function\n--------\n\nSince there are some config options relied to some variables defined in\nthe plugin, however, some not. We need to provide an unified config entry\nfunction. The name of entry function is stored in an option called\n`ZVM_CONFIG_FUNC` and default value is `zvm_config`, you can change to\nothers for fitting your flavor.\n\nIf this config function exists, it will be called automatically, you can\ndo some configurations in this aspect before you source this plugin. For\nexample:\n\n```zsh\nfunction zvm_config() {\n  ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT\n  ZVM_VI_INSERT_ESCAPE_BINDKEY=jk\n}\n\nsource ~/zsh-vi-mode.zsh\n```\n\nExecute Extra Commands\n--------\n\nThis plugin has provided a mechanism to execute extra commands, and now\nyou have the below aspects for executing something:\n\n```zsh\nzvm_before_init_commands=()\nzvm_after_init_commands=()\nzvm_before_select_vi_mode_commands=()\nzvm_after_select_vi_mode_commands=()\nzvm_before_lazy_keybindings_commands=()\nzvm_after_lazy_keybindings_commands=()\n```\n\nSince the default [initialization mode](#initialization-mode), this plugin\nwill overwrite the previous key bindings, this causes the key bindings of\nother plugins (i.e. `fzf`, `zsh-autocomplete`, etc.) to fail.\n\nYou can solve the compatibility issue as below:\n\n```zsh\n# Append a command directly\nzvm_after_init_commands+=('[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh')\n```\n\nor\n\n```zsh\n# Define an init function and append to zvm_after_init_commands\nfunction my_init() {\n  [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh\n}\nzvm_after_init_commands+=(my_init)\n```\n\nor\n\n```zsh\n# The plugin will auto execute this zvm_after_init function\nfunction zvm_after_init() {\n  [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh\n}\n```\n\nor if you are using the `zinit`:\n\n```zsh\n# For postponing loading `fzf`\nzinit ice lucid wait\nzinit snippet OMZP::fzf\n```\n\nBy default, [the lazy keybindings feature](#lazy-keybindings) is enabled, all\nthe keybindings of `normal` and `visual` mode should be executed by the\n`zvm_after_lazy_keybindings_commands`. For example:\n\n```zsh\n# The plugin will auto execute this zvm_after_lazy_keybindings function\nfunction zvm_after_lazy_keybindings() {\n  bindkey -M vicmd 's' your_normal_widget\n  bindkey -M visual 'n' your_visual_widget\n}\n```\n\nCustom widgets and keybindings\n--------\n\nThis plugin has two functions for you to define custom widgets and keybindings.\nIn case of unnecessary problems, it is better to use them, especially when you\nmeet the key conflicts.\n\nTo define a custom widget, you should:\n\n```zsh\n# If [your_custom_widget] were ignored, it will be the same with <your_custom_widget>\nzvm_define_widget <your_custom_widget> [your_custom_function]\n```\n\nTo define a keybinding, you should:\n\n```zsh\nzvm_bindkey <keymap> <keys> <widget>\n```\n\nFor example:\n\n```zsh\n# Your custom widget\nfunction my_custom_widget() {\n  echo 'Hello, ZSH!'\n}\n\n# The plugin will auto execute this zvm_after_lazy_keybindings function\nfunction zvm_after_lazy_keybindings() {\n  # Here we define the custom widget\n  zvm_define_widget my_custom_widget\n\n  # In normal mode, press Ctrl-E to invoke this widget\n  zvm_bindkey vicmd '^E' my_custom_widget\n}\n```\n\nVi Mode Indicator\n--------\n\nThis plugin has provided a `ZVM_MODE` variable for you to retrieve\ncurrent vi mode and better show the indicator.\n\nAnd currently the below modes are supported:\n\n```zsh\nZVM_MODE_NORMAL\nZVM_MODE_INSERT\nZVM_MODE_VISUAL\nZVM_MODE_VISUAL_LINE\nZVM_MODE_REPLACE\n```\n\nFor updating the vi mode indicator, we should add our commands to \n`zvm_after_select_vi_mode_commands`. For example:\n\n```zsh\n# The plugin will auto execute this zvm_after_select_vi_mode function\nfunction zvm_after_select_vi_mode() {\n  case $ZVM_MODE in\n    $ZVM_MODE_NORMAL)\n      # Something you want to do...\n    ;;\n    $ZVM_MODE_INSERT)\n      # Something you want to do...\n    ;;\n    $ZVM_MODE_VISUAL)\n      # Something you want to do...\n    ;;\n    $ZVM_MODE_VISUAL_LINE)\n      # Something you want to do...\n    ;;\n    $ZVM_MODE_REPLACE)\n      # Something you want to do...\n    ;;\n  esac\n}\n```\n\nCustom Cursor Style\n--------\n\nThis plugin has provided some options for users to custom the cursor\nstyle for better terminal compatibility.\n\n- You can disable this feature by the `ZVM_CURSOR_STYLE_ENABLED`\n  option (Default is `true`)\n\n```zsh\n# Disable the cursor style feature\nZVM_CURSOR_STYLE_ENABLED=false\n```\n\n- You can set your cursor style for different vi mode:\n\n```zsh\n# The prompt cursor in normal mode\nZVM_NORMAL_MODE_CURSOR\n\n# The prompt cursor in insert mode\nZVM_INSERT_MODE_CURSOR\n\n# The prompt cursor in visual mode\nZVM_VISUAL_MODE_CURSOR\n\n# The prompt cursor in visual line mode\nZVM_VISUAL_LINE_MODE_CURSOR\n\n# The prompt cursor in operator pending mode\nZVM_OPPEND_MODE_CURSOR\n```\n\n- And the below cursor styles are supported:\n\n```zsh\nZVM_CURSOR_USER_DEFAULT\nZVM_CURSOR_BLOCK\nZVM_CURSOR_UNDERLINE\nZVM_CURSOR_BEAM\nZVM_CURSOR_BLINKING_BLOCK\nZVM_CURSOR_BLINKING_UNDERLINE\nZVM_CURSOR_BLINKING_BEAM\n```\n\n- Custom your cursor style is easy as below:\n\n```zsh\nZVM_INSERT_MODE_CURSOR=$ZVM_CURSOR_BEAM\nZVM_NORMAL_MODE_CURSOR=$ZVM_CURSOR_BLOCK\nZVM_OPPEND_MODE_CURSOR=$ZVM_CURSOR_UNDERLINE\n```\n\n- Also, custom your colorful cursor style as below:\n\n```zsh\n# The plugin will auto execute this zvm_config function\nzvm_config() {\n  # Retrieve default cursor styles\n  local ncur=$(zvm_cursor_style $ZVM_NORMAL_MODE_CURSOR)\n  local icur=$(zvm_cursor_style $ZVM_INSERT_MODE_CURSOR)\n\n  # Append your custom color for your cursor\n  ZVM_INSERT_MODE_CURSOR=$icur'\\e\\e]12;red\\a'\n  ZVM_NORMAL_MODE_CURSOR=$ncur'\\e\\e]12;#008800\\a'\n}\n```\n\nWe can use `ZVM_TERM` option to set the term type for plugin to handle\nterminal escape sequences, default is `$TERM`. It could be `xterm-256color`,\n`alacritty-256color`, `st-256color`, etc. It's important for some\nterminal emulators to show cursor properly.\n\nHighlight Behavior\n--------\n\nYou can use `ZVM_VI_HIGHLIGHT_BACKGROUND`, `ZVM_VI_HIGHLIGHT_FOREGROUND`\nand `ZVM_VI_HIGHLIGHT_EXTRASTYLE` to change the highlight behaviors (\nsurrounds, visual-line, etc.), the color value could be _a color name_ or\n_a hex color value_.\n\nFor example:\n\n```zsh\nZVM_VI_HIGHLIGHT_FOREGROUND=green             # Color name\nZVM_VI_HIGHLIGHT_FOREGROUND=#008800           # Hex value\nZVM_VI_HIGHLIGHT_BACKGROUND=red               # Color name\nZVM_VI_HIGHLIGHT_BACKGROUND=#ff0000           # Hex value\nZVM_VI_HIGHLIGHT_EXTRASTYLE=bold,underline    # bold and underline\n```\n\nCommand Line Initial Mode\n--------\n\nYou can set the command line initial mode by the `ZVM_LINE_INIT_MODE`\noption.\n\nCurrently the below modes are supported:\n\n- `ZVM_MODE_LAST`   : Starting with last mode (Default).\n- `ZVM_MODE_INSERT` : Starting with insert mode.\n- `ZVM_MODE_NORMAL` : Starting with normal mode.\n\nFor example:\n\n```zsh\n# Always starting with insert mode for each command line\nZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT\n```\n\nLazy Keybindings\n--------\n\nThis plugin has supported the lazy keybindings feature, and it is enabled\nby default. To disable it, you can set the option `ZVM_LAZY_KEYBINDINGS`\nto `false` before this plugin is loaded. This feature will postpone all\nthe keybindings of `normal` and `visual` mode to the first time you enter\nthe normal mode.\n\nIt can greatly improve the startup speed, especially you open the terminal\nand just want to execute a simple command.\n\nInitialization Mode\n--------\n\nIn order to prevent various problems related to keybindings caused by the\nplugin sourcing sequence, and also keep the same functionality for this\nplugin, the initialization of this plugin was postponed to the first\ncommand line starting.\n\nHowever, almost all plugins are initialized when the script is sourced.\nTherefore, this plugin provides an option `ZVM_INIT_MODE` to change the\ninitialization mode.\n\nFor example:\n\n```zsh\n# Do the initialization when the script is sourced (i.e. Initialize instantly)\nZVM_INIT_MODE=sourcing\n```\n\n## üíé Credits\n\n- [Zsh](https://www.zsh.org/) - A powerful shell that operates as both an interactive shell and as a scripting language interpreter.\n- [Oh-My-Zsh](https://github.com/ohmyzsh/ohmyzsh) - A delightful, open source, community-driven framework for managing your ZSH configuration.\n- [vim-surround](https://github.com/tpope/vim-surround) - A vim plugin that all about \"surroundings\": parentheses, brackets, quotes, XML tags, and more.\n- [vim-sandwich](https://github.com/machakann/vim-sandwich) - A set of operator and textobject plugins to add/delete/replace surroundings of a sandwiched textobject.\n\n## üî´ Contributing\n\nIssues and Pull Requests are greatly appreciated. If you've never contributed to an open source project before I'm more than happy to walk you through how to create a pull request.\n\nYou can start by [opening an issue](https://github.com/jeffreytse/zsh-vi-mode/issues/new) describing the problem that you're looking to resolve and we'll go from there.\n\n## üåà License\n\nThis theme is licensed under the [MIT license](https://opensource.org/licenses/mit-license.php) ¬© Jeffrey Tse.\n"
        },
        {
          "name": "zsh-vi-mode.plugin.zsh",
          "type": "blob",
          "size": 0.2138671875,
          "content": "# According to the standard:\n# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html\n0=\"${ZERO:-${${0:#$ZSH_ARGZERO}:-${(%):-%N}}}\"\n0=\"${${(M)0:#/*}:-$PWD/$0}\"\n\nsource ${0:h}/zsh-vi-mode.zsh\n"
        },
        {
          "name": "zsh-vi-mode.zsh",
          "type": "blob",
          "size": 92.4951171875,
          "content": "# zsh-vi-mode.zsh -- A better and friendly vi(vim) mode for Zsh\n# https://github.com/jeffreytse/zsh-vi-mode\n#\n# Copyright (c) 2020 Jeffrey Tse\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n# All Settings\n# Some of these variables should be set before sourcing this file.\n#\n# ZVM_CONFIG_FUNC\n# the config function (default is `zvm_config`), if this config function\n# exists, it will be called automatically, you can do some configurations\n# in this aspect before you source this plugin.\n#\n# For example:\n#\n# ```zsh\n# function zvm_config() {\n#   ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT\n#   ZVM_VI_INSERT_ESCAPE_BINDKEY=jk\n# }\n#\n# source ~/zsh-vi-mode.zsh\n# ```\n#\n# ZVM_INIT_MODE\n# the plugin initial mode (default is doing the initialization when the first\n# new command line is starting. For doing the initialization instantly, you\n# can set it to `sourcing`.\n#\n# ZVM_VI_ESCAPE_BINDKEY\n# the vi escape key for all modes (default is ^[ => <ESC>), you can set it\n# to whatever you like, such as `jj`, `jk` and so on.\n#\n# ZVM_VI_INSERT_ESCAPE_BINDKEY\n# the vi escape key of insert mode (default is $ZVM_VI_ESCAPE_BINDKEY), you\n# can set it to whatever, such as `jj`, `jk` and so on.\n#\n# ZVM_VI_VISUAL_ESCAPE_BINDKEY\n# the vi escape key of visual mode (default is $ZVM_VI_ESCAPE_BINDKEY), you\n# can set it to whatever, such as `jj`, `jk` and so on.\n#\n# ZVM_VI_OPPEND_ESCAPE_BINDKEY\n# the vi escape key of operator pendding mode (default is\n# $ZVM_VI_ESCAPE_BINDKEY), you can set it to whatever, such as `jj`, `jk`\n# and so on.\n#\n# ZVM_VI_INSERT_MODE_LEGACY_UNDO:\n# using legacy undo behavior in vi insert mode\n#\n# ZVM_VI_HIGHLIGHT_FOREGROUND:\n# the behavior of highlight foreground (surrounds, visual-line, etc) in vi mode\n#\n# ZVM_VI_HIGHLIGHT_BACKGROUND:\n# the behavior of highlight background (surrounds, visual-line, etc) in vi mode\n#\n# ZVM_VI_HIGHLIGHT_EXTRASTYLE:\n# the behavior of highlight extra style (i.e. bold, underline) in vi mode\n#\n# For example:\n#   ZVM_VI_HIGHLIGHT_FOREGROUND=green           # Color name\n#   ZVM_VI_HIGHLIGHT_FOREGROUND=#008800         # Hex value\n#   ZVM_VI_HIGHLIGHT_BACKGROUND=red             # Color name\n#   ZVM_VI_HIGHLIGHT_BACKGROUND=#ff0000         # Hex value\n#   ZVM_VI_HIGHLIGHT_EXTRASTYLE=bold,underline  # bold and underline\n#\n# ZVM_VI_SURROUND_BINDKEY\n# the key binding mode for surround operating (default is 'classic')\n#\n# 1. 'classic' mode (verb->s->surround):\n#   S\"    Add \" for visual selection\n#   ys\"   Add \" for visual selection\n#   cs\"'  Change \" to '\n#   ds\"   Delete \"\n#\n# 2. 's-prefix' mode (s->verb->surround):\n#   sa\"   Add \" for visual selection\n#   sd\"   Delete \"\n#   sr\"'  Change \" to '\n#\n# How to select surround text object?\n#   vi\"   Select the text object inside the quotes\n#   va(   Select the text object including the brackets\n#\n# Then you can do any operation for the selection:\n#\n# 1. Add surrounds for text object\n#   vi\" -> S[ or sa[ => \"object\" -> \"[object]\"\n#\n# 2. Delete/Yank/Change text object\n#   di( or vi( -> d\n#   ca( or va( -> c\n#   yi( or vi( -> y\n#\n# ZVM_READKEY_ENGINE\n# the readkey engine for reading and processing the key events, and the\n# below engines are supported:\n#  ZVM_READKEY_ENGINE_NEX (Default)\n#  ZVM_READKEY_ENGINE_ZLE\n#\n# the NEX is a better engine for reading and handling the key events than\n# the Zsh's ZLE engine, currently the NEX engine is at beta stage, and\n# you can change to Zsh's ZLE engine if you want.\n#\n# ZVM_KEYTIMEOUT:\n# the key input timeout for waiting for next key (default is 0.4 seconds)\n#\n# ZVM_ESCAPE_KEYTIMEOUT:\n# the key input timeout for waiting for next key if it is beginning with\n# an escape character (default is 0.03 seconds), and this option is just\n# available for the NEX readkey engine\n#\n# ZVM_LINE_INIT_MODE\n# the setting for init mode of command line (default is empty), empty will\n# keep the last command mode, for the first command line it will be insert\n# mode, you can also set it to a specific vi mode to alway keep the mode\n# for each command line\n#\n# For example:\n#   ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT\n#   ZVM_LINE_INIT_MODE=$ZVM_MODE_NORMAL\n#\n# ZVM_LAZY_KEYBINDINGS:\n# the setting for lazy keybindings (default is true), and lazy keybindings\n# will postpone the keybindings of vicmd and visual keymaps to the first\n# time entering normal mode\n#\n# ZVM_NORMAL_MODE_CURSOR:\n# the prompt cursor in normal mode\n#\n# ZVM_INSERT_MODE_CURSOR:\n# the prompt cursor in insert mode\n#\n# ZVM_VISUAL_MODE_CURSOR:\n# the prompt cursor in visual mode\n#\n# ZVM_VISUAL_LINE_MODE_CURSOR:\n# the prompt cursor in visual line mode\n#\n# ZVM_OPPEND_MODE_CURSOR:\n# the prompt cursor in operator pending mode\n#\n# You can change the cursor style by below:\n#  ZVM_INSERT_MODE_CURSOR=$ZVM_CURSOR_BLOCK\n#\n# and the below cursor style are supported:\n#  ZVM_CURSOR_USER_DEFAULT\n#  ZVM_CURSOR_BLOCK\n#  ZVM_CURSOR_UNDERLINE\n#  ZVM_CURSOR_BEAM\n#  ZVM_CURSOR_BLINKING_BLOCK\n#  ZVM_CURSOR_BLINKING_UNDERLINE\n#  ZVM_CURSOR_BLINKING_BEAM\n#\n# ZVM_VI_EDITOR\n# the editor to edit your command line (default is $EDITOR)\n#\n# ZVM_TMPDIR\n# the temporary directory (default is $TMPDIR, otherwise it's /tmp)\n#\n# ZVM_TERM\n# the term for handling terminal sequences, it's important for some\n# terminal emulators to show cursor properly (default is $TERM)\n#\n# ZVM_CURSOR_STYLE_ENABLED\n# enable the cursor style feature (default is true)\n#\n\n# Avoid sourcing plugin multiple times\ncommand -v 'zvm_version' >/dev/null && return\n\n# Plugin information\ntypeset -gr ZVM_NAME='zsh-vi-mode'\ntypeset -gr ZVM_DESCRIPTION='üíª A better and friendly vi(vim) mode plugin for ZSH.'\ntypeset -gr ZVM_REPOSITORY='https://github.com/jeffreytse/zsh-vi-mode'\ntypeset -gr ZVM_VERSION='0.11.0'\n\n# Plugin initial status\nZVM_INIT_DONE=false\n\n# Postpone reset prompt (i.e. postpone the widget `reset-prompt`)\n# -1 (No postponing)\n# >=0 (Postponing, the decimal value stands for calling times of `reset-prompt`)\nZVM_POSTPONE_RESET_PROMPT=-1\n\n# Disable reset prompt (i.e. postpone the widget `reset-prompt`)\nZVM_RESET_PROMPT_DISABLED=false\n\n# Operator pending mode\nZVM_OPPEND_MODE=false\n\n# Insert mode could be\n# `i` (insert)\n# `a` (append)\n# `I` (insert at the non-blank beginning of current line)\n# `A` (append at the end of current line)\nZVM_INSERT_MODE='i'\n\n# The mode could be the below value:\n# `n` (normal)\n# `i` (insert)\n# `v` (visual)\n# `vl` (visual-line)\nZVM_MODE=''\n\n# The keys typed to invoke this widget, as a literal string\nZVM_KEYS=''\n\n# The region hilight information\nZVM_REGION_HIGHLIGHT=()\n\n# Default zvm readkey engines\nZVM_READKEY_ENGINE_NEX='nex'\nZVM_READKEY_ENGINE_ZLE='zle'\nZVM_READKEY_ENGINE_DEFAULT=$ZVM_READKEY_ENGINE_NEX\n\n# Default alternative character for escape characters\nZVM_ESCAPE_SPACE='\\s'\nZVM_ESCAPE_NEWLINE='^J'\n\n# Default vi modes\nZVM_MODE_LAST=''\nZVM_MODE_NORMAL='n'\nZVM_MODE_INSERT='i'\nZVM_MODE_VISUAL='v'\nZVM_MODE_VISUAL_LINE='vl'\nZVM_MODE_REPLACE='r'\n\n# Default cursor styles\nZVM_CURSOR_USER_DEFAULT='ud'\nZVM_CURSOR_BLOCK='bl'\nZVM_CURSOR_UNDERLINE='ul'\nZVM_CURSOR_BEAM='be'\nZVM_CURSOR_BLINKING_BLOCK='bbl'\nZVM_CURSOR_BLINKING_UNDERLINE='bul'\nZVM_CURSOR_BLINKING_BEAM='bbe'\n\n# The commands need to be repeated\nZVM_REPEAT_MODE=false\nZVM_REPEAT_RESET=false\nZVM_REPEAT_COMMANDS=($ZVM_MODE_NORMAL i)\n\n##########################################\n# Initial all default settings\n\n# Default config function\n: ${ZVM_CONFIG_FUNC:='zvm_config'}\n\n# Set the readkey engine (default is NEX engine)\n: ${ZVM_READKEY_ENGINE:=$ZVM_READKEY_ENGINE_DEFAULT}\n\n# Set key input timeout (default is 0.4 seconds)\n: ${ZVM_KEYTIMEOUT:=0.4}\n\n# Set the escape key timeout (default is 0.03 seconds)\n: ${ZVM_ESCAPE_KEYTIMEOUT:=0.03}\n\n# Set keybindings mode (default is true)\n# The lazy keybindings will post the keybindings of vicmd and visual\n# keymaps to the first time entering the normal mode\n: ${ZVM_LAZY_KEYBINDINGS:=true}\n\n# All keybindings for lazy loading\nif $ZVM_LAZY_KEYBINDINGS; then\n  ZVM_LAZY_KEYBINDINGS_LIST=()\nfi\n\n# Set the cursor style in defferent vi modes, the value you could use\n# the predefined value, such as $ZVM_CURSOR_BLOCK, $ZVM_CURSOR_BEAM,\n# $ZVM_CURSOR_BLINKING_BLOCK and so on.\n: ${ZVM_INSERT_MODE_CURSOR:=$ZVM_CURSOR_BEAM}\n: ${ZVM_NORMAL_MODE_CURSOR:=$ZVM_CURSOR_BLOCK}\n: ${ZVM_VISUAL_MODE_CURSOR:=$ZVM_CURSOR_BLOCK}\n: ${ZVM_VISUAL_LINE_MODE_CURSOR:=$ZVM_CURSOR_BLOCK}\n\n# Operator pending mode cursor style (default is underscore)\n: ${ZVM_OPPEND_MODE_CURSOR:=$ZVM_CURSOR_UNDERLINE}\n\n# Set the vi escape key (default is ^[ => <ESC>)\n: ${ZVM_VI_ESCAPE_BINDKEY:=^[}\n: ${ZVM_VI_INSERT_ESCAPE_BINDKEY:=$ZVM_VI_ESCAPE_BINDKEY}\n: ${ZVM_VI_VISUAL_ESCAPE_BINDKEY:=$ZVM_VI_ESCAPE_BINDKEY}\n: ${ZVM_VI_OPPEND_ESCAPE_BINDKEY:=$ZVM_VI_ESCAPE_BINDKEY}\n\n# Set the line init mode (empty will keep the last mode)\n# you can also set it to others, such as $ZVM_MODE_INSERT.\n: ${ZVM_LINE_INIT_MODE:=$ZVM_MODE_LAST}\n\n: ${ZVM_VI_INSERT_MODE_LEGACY_UNDO:=false}\n: ${ZVM_VI_SURROUND_BINDKEY:=classic}\n: ${ZVM_VI_HIGHLIGHT_BACKGROUND:=#cc0000}\n: ${ZVM_VI_HIGHLIGHT_FOREGROUND:=#eeeeee}\n: ${ZVM_VI_HIGHLIGHT_EXTRASTYLE:=default}\n: ${ZVM_VI_EDITOR:=${EDITOR:-vim}}\n: ${ZVM_TMPDIR:=${TMPDIR:-/tmp}}\n\n# Set the term for handling terminal sequences, it's important for some\n# terminal emulators to show cursor properly (default is $TERM)\n: ${ZVM_TERM:=${TERM:-xterm-256color}}\n\n# Enable the cursor style feature\n: ${ZVM_CURSOR_STYLE_ENABLED:=true}\n\n# All the extra commands\ncommands_array_names=(\n  zvm_before_init_commands\n  zvm_after_init_commands\n  zvm_before_select_vi_mode_commands\n  zvm_after_select_vi_mode_commands\n  zvm_before_lazy_keybindings_commands\n  zvm_after_lazy_keybindings_commands\n)\nfor commands_array_name in $commands_array_names; do\n  # Ensure commands set to an empty array, if not already set.\n  if [[ -z \"${(P)commands_array_name}\" ]]; then\n    typeset -g -a $commands_array_name\n  fi\ndone\n\n# All the handlers for switching keyword\nzvm_switch_keyword_handlers=(\n  zvm_switch_number\n  zvm_switch_boolean\n  zvm_switch_operator\n  zvm_switch_weekday\n  zvm_switch_month\n)\n\n# History for switching keyword\nzvm_switch_keyword_history=()\n\n# Display version information\nfunction zvm_version() {\n  local git_info=$(git show -s --format=\"(%h, %ci)\" 2>/dev/null)\n  echo -e \"$ZVM_NAME $ZVM_VERSION $git_info\"\n  echo -e \"\\e[4m$ZVM_REPOSITORY\\e[0m\"\n  echo -e \"$ZVM_DESCRIPTION\"\n}\n\n# The widget wrapper\nfunction zvm_widget_wrapper() {\n  local rawfunc=$1;\n  local func=$2;\n  local called=$3;\n  local -i retval\n  $called || { $rawfunc \"${@:4}\" }\n  $func \"${@:4}\"\n  return retval\n}\n\n# Define widget function\nfunction zvm_define_widget() {\n  local widget=$1\n  local func=$2 || $1\n  local result=($(zle -l -L \"${widget}\"))\n\n  # Check if existing the same name\n  if [[ ${#result[@]} == 4 ]]; then\n    local rawfunc=${result[4]}\n    local wrapper=\"zvm_${widget}-wrapper\"\n\n    # To avoid double calling, we need to check if the raw function\n    # has been called already in the custom widget function\n    local rawcode=$(declare -f $func 2>/dev/null)\n    local called=false\n    [[ \"$rawcode\" == *\"\\$rawfunc\"* ]] && { called=true }\n\n    eval \"$wrapper() { zvm_widget_wrapper $rawfunc $func $called \\\"\\$@\\\" }\"\n    func=$wrapper\n  fi\n\n  zle -N $widget $func\n}\n\n# Get the keys typed to invoke this widget, as a literal string\nfunction zvm_keys() {\n  local keys=${ZVM_KEYS:-$KEYS}\n\n  # Append the prefix of keys if it is visual or visual-line mode\n  case \"${ZVM_MODE}\" in\n    $ZVM_MODE_VISUAL)\n      if [[ \"$keys\" != v* ]]; then\n        keys=\"v${keys}\"\n      fi\n      ;;\n    $ZVM_MODE_VISUAL_LINE)\n      if [[ \"$keys\" != V* ]]; then\n        keys=\"V${keys}\"\n      fi\n      ;;\n  esac\n\n  # Escape the newline and space characters, otherwise, we can't\n  # get the output from subshell correctly.\n  keys=${keys//$'\\n'/$ZVM_ESCAPE_NEWLINE}\n  keys=${keys// /$ZVM_ESCAPE_SPACE}\n\n  echo $keys\n}\n\n# Find the widget on a specified bindkey\nfunction zvm_find_bindkey_widget() {\n  local keymap=$1\n  local keys=$2\n  local prefix_mode=${3:-false}\n  retval=()\n\n  if $prefix_mode; then\n    local pos=0\n    local spos=3\n    local prefix_keys=\n\n    # Get the prefix keys\n    if [[ $prefix_keys ]]; then\n      prefix_keys=${prefix_keys:0:-1}\n\n      # If the last key is an escape key (e.g. \\\", \\`, \\\\) we still\n      # need to remove the escape backslash `\\`\n      if [[ ${prefix_keys: -1} == '\\' ]]; then\n        prefix_keys=${prefix_keys:0:-1}\n      fi\n    fi\n\n    local result=$(bindkey -M ${keymap} -p \"$prefix_keys\")$'\\n'\n\n    # Split string to array by newline\n    for ((i=$spos;i<$#result;i++)); do\n\n      # Save the last whitespace character of the line\n      # and continue continue handling while meeting `\\n`\n      case \"${result:$i:1}\" in\n        ' ') spos=$i; i=$i+1; continue;;\n        [$'\\n']);;\n        *) continue;;\n      esac\n\n      # Check if it has the same prefix keys and retrieve the widgets\n      if [[ \"${result:$((pos+1)):$#keys}\" == \"$keys\" ]]; then\n\n        # Get the binding keys\n        local k=${result:$((pos+1)):$((spos-pos-2))}\n\n        # Escape spaces in key bindings (space -> $ZVM_ESCAPE_SPACE)\n        k=${k// /$ZVM_ESCAPE_SPACE}\n        retval+=($k ${result:$((spos+1)):$((i-spos-1))})\n      fi\n\n      # Save as new position\n      pos=$i+1\n\n      # Skip 3 characters\n      # One key and quotes at least (i.e \\n\"_\" )\n      i=$i+3\n    done\n  else\n    local result=$(bindkey -M ${keymap} \"$keys\")\n    if [[ \"${result: -14}\" == ' undefined-key' ]]; then\n      return\n    fi\n\n    # Escape spaces in key bindings (space -> $ZVM_ESCAPE_SPACE)\n    for ((i=$#result;i>=0;i--)); do\n\n      # Backward find the first whitespace character\n      [[ \"${result:$i:1}\" == ' ' ]] || continue\n\n      # Retrieve the keys and widget\n      local k=${result:1:$i-2}\n\n      # Escape spaces in key bindings (space -> $ZVM_ESCAPE_SPACE)\n      k=${k// /$ZVM_ESCAPE_SPACE}\n      retval+=($k ${result:$i+1})\n\n      break\n    done\n  fi\n}\n\n# Read keys for retrieving widget\nfunction zvm_readkeys() {\n  local keymap=$1\n  local key=${2:-$(zvm_keys)}\n  local keys=\n  local widget=\n  local result=\n  local pattern=\n  local timeout=\n\n  while :; do\n    # Keep reading key for escape character\n    if [[ \"$key\" == $'\\e' ]]; then\n      while :; do\n        local k=\n        read -t $ZVM_ESCAPE_KEYTIMEOUT -k 1 k || break\n        key=\"${key}${k}\"\n      done\n    fi\n\n    keys=\"${keys}${key}\"\n\n    # Handle the pattern\n    if [[ -n \"$key\" ]]; then\n      # Transform the non-printed characters\n      local k=$(zvm_escape_non_printed_characters \"${key}\")\n\n      # Escape keys\n      # \" -> \\\" It's a special character in bash syntax\n      # ` -> \\` It's a special character in bash syntax\n      # <space> -> ` ` It's a special character in bash syntax\n      k=${k//\\\"/\\\\\\\"}\n      k=${k//\\`/\\\\\\`}\n      k=${k//$ZVM_ESCAPE_SPACE/ }\n\n      pattern=\"${pattern}${k}\"\n    fi\n\n    # Find out widgets that match this key pattern\n    zvm_find_bindkey_widget $keymap \"$pattern\" true\n    result=(${retval[@]})\n\n    # Exit key input if there is only one widget matched\n    # or no more widget matched.\n    case ${#result[@]} in\n      2) key=; widget=${result[2]}; break;;\n      0) break;;\n    esac\n\n    # Evaluate the readkey timeout\n    # Special timeout for the escape sequence\n    if [[ \"${keys}\" == $'\\e' ]]; then\n      timeout=$ZVM_ESCAPE_KEYTIMEOUT\n      # Check if there is any one custom escape sequence\n      for ((i=1; i<=${#result[@]}; i=i+2)); do\n        if [[ \"${result[$i]}\" =~ '^\\^\\[\\[?[A-Z0-9]*~?\\^\\[' ]]; then\n          timeout=$ZVM_KEYTIMEOUT\n          break\n        fi\n      done\n    else\n      timeout=$ZVM_KEYTIMEOUT\n    fi\n\n    # Wait for reading next key, and we should save the widget\n    # as the final widget if it is full matching\n    key=\n    if [[ \"${result[1]}\" == \"${pattern}\" ]]; then\n      widget=${result[2]}\n      # Get current widget as final widget when reading key timeout\n      read -t $timeout -k 1 key || break\n    else\n      zvm_enter_oppend_mode\n      read -k 1 key\n    fi\n  done\n\n  # Exit operator pending mode\n  if $ZVM_OPPEND_MODE; then\n    zvm_exit_oppend_mode\n  fi\n\n  if [[ -z \"$key\" ]]; then\n    retval=(${keys} $widget)\n  else\n    retval=(${keys:0:-$#key} $widget $key)\n  fi\n}\n\n# Add key bindings\nfunction zvm_bindkey() {\n  local keymap=$1\n  local keys=$2\n  local widget=$3\n  local params=$4\n  local key=\n\n  # We should bind keys with an existing widget\n  [[ -z $widget ]] && return\n\n  # If lazy keybindings is enabled, we need to add to the lazy list\n  if [[ ${ZVM_LAZY_KEYBINDINGS_LIST+x} && ${keymap} != viins ]]; then\n    keys=${keys//\\\"/\\\\\\\"}\n    keys=${keys//\\`/\\\\\\`}\n    ZVM_LAZY_KEYBINDINGS_LIST+=(\n      \"${keymap} \\\"${keys}\\\" ${widget} \\\"${params}\\\"\"\n    )\n    return\n  fi\n\n  # Hanle the keybinding of NEX readkey engine\n  if [[ $ZVM_READKEY_ENGINE == $ZVM_READKEY_ENGINE_NEX ]]; then\n    # Get the first key (especially check if ctrl characters)\n    if [[ $#keys -gt 1 && \"${keys:0:1}\" == '^' ]]; then\n      key=${keys:0:2}\n    else\n      key=${keys:0:1}\n\n      # As any character that is not bound to one of the history control\n      # related functions, or self-insert or self-insert-unmeta, will\n      # cause the mode to be exited To prevent history search, so that\n      # we need to bind keys explicitly.\n      if [[ \"$keymap\" == \"viins\" ]]; then\n        bindkey -M isearch \"${key}\" self-insert\n      fi\n    fi\n    bindkey -M $keymap \"${key}\" zvm_readkeys_handler\n  fi\n\n  # Wrap params to a new widget\n  if [[ -n $params ]]; then\n    local suffix=$(zvm_string_to_hex $params)\n    eval \"$widget:$suffix() { $widget $params }\"\n    widget=\"$widget:$suffix\"\n    zvm_define_widget $widget\n  fi\n\n  # Bind keys with with a widget\n  bindkey -M $keymap \"${keys}\" $widget\n}\n\n# Convert string to hexadecimal\nfunction zvm_string_to_hex() {\n  local str=\n  for ((i=1;i<=$#1;i++)); do\n    str+=$(printf '%x' \"'${1[$i]}\")\n  done\n  echo \"$str\"\n}\n\n# Escape non-printed characters\nfunction zvm_escape_non_printed_characters() {\n  local str=\n  for ((i=0;i<$#1;i++)); do\n    local c=${1:$i:1}\n    if [[ \"$c\" < ' ' ]]; then\n      local ord=$(($(printf '%d' \"'$c\")+64))\n      c=$(printf \\\\$(printf '%03o' $ord))\n      str=\"${str}^${c}\"\n    elif [[ \"$c\" == '' ]]; then\n      str=\"${str}^?\"\n    elif [[ \"$c\" == '\u0000' ]]; then\n      str=\"${str}^@\"\n    else\n      str=\"${str}${c}\"\n    fi\n  done\n\n  # Escape the newline and space characters, otherwise, we can't\n  # get the output from subshell correctly.\n  str=${str// /$ZVM_ESCAPE_SPACE}\n  str=${str//$'\\n'/$ZVM_ESCAPE_NEWLINE}\n\n  echo -n $str\n}\n\n# Backward remove characters of an emacs region in the line\nfunction zvm_backward_kill_region() {\n  local bpos=$CURSOR-1 epos=$CURSOR\n\n  # Backward search the boundary of current region\n  for ((; bpos >= 0; bpos--)); do\n    # Break when cursor is at the beginning of line\n    [[ \"${BUFFER:$bpos:1}\" == $'\\n' ]] && break\n\n    # Break when cursor is at the boundary of a word region\n    [[ \"${BUFFER:$bpos:2}\" =~ ^\\ [^\\ $'\\n']$ ]] && break\n  done\n\n  bpos=$bpos+1\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}\n  BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n  CURSOR=$bpos\n}\n\n# Remove all characters between the cursor position and the\n# beginning of the line.\nfunction zvm_backward_kill_line() {\n  BUFFER=${BUFFER:$CURSOR:$#BUFFER}\n  CURSOR=0\n}\n\n# Remove all characters between the cursor position and the\n# end of the line.\nfunction zvm_forward_kill_line() {\n  BUFFER=${BUFFER:0:$CURSOR}\n}\n\n# Remove all characters of the line.\nfunction zvm_kill_line() {\n  local ret=($(zvm_calc_selection $ZVM_MODE_VISUAL_LINE))\n  local bpos=${ret[1]} epos=${ret[2]}\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}$'\\n'\n  BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n  CURSOR=$bpos\n}\n\n# Remove all characters of the whole line.\nfunction zvm_kill_whole_line() {\n  local ret=($(zvm_calc_selection $ZVM_MODE_VISUAL_LINE))\n  local bpos=$ret[1] epos=$ret[2] cpos=$ret[3]\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}$'\\n'\n\n  # Adjust region range of deletion\n  if (( $epos < $#BUFFER )); then\n    epos=$epos+1\n  fi\n\n  BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n  CURSOR=$cpos\n}\n\n# Exchange the point and mark\nfunction zvm_exchange_point_and_mark() {\n  cursor=$MARK\n  MARK=$CURSOR CURSOR=$cursor\n  zvm_highlight\n}\n\n# Open line below\nfunction zvm_open_line_below() {\n  local i=$CURSOR\n\n  # If there is a completion suffix, we should break at the\n  # postion of suffix begin, otherwise, it should break when\n  # forward finding out the first newline character.\n  for ((; i<$#BUFFER; i++)); do\n    if ((SUFFIX_ACTIVE == 1)) && ((i >= SUFFIX_BEGIN)); then\n      break\n    fi\n    if [[ \"${BUFFER[$i]}\" == $'\\n' ]]; then\n      i=$((i-1))\n      break\n    fi\n  done\n\n  CURSOR=$i\n  LBUFFER+=$'\\n'\n\n  zvm_reset_repeat_commands $ZVM_MODE_NORMAL o\n  zvm_select_vi_mode $ZVM_MODE_INSERT\n}\n\n# Open line above\nfunction zvm_open_line_above() {\n  local i=$CURSOR\n\n  # Break when backward finding out the first newline character.\n  for ((; i>0; i--)); do\n    if [[ \"${BUFFER[$i]}\" == $'\\n' ]]; then\n      break\n    fi\n  done\n\n  CURSOR=$i\n  LBUFFER+=$'\\n'\n  CURSOR=$((CURSOR-1))\n\n  zvm_reset_repeat_commands $ZVM_MODE_NORMAL O\n  zvm_select_vi_mode $ZVM_MODE_INSERT\n}\n\n# Replace characters one by one (Replacing mode)\nfunction zvm_vi_replace() {\n  if [[ $ZVM_MODE == $ZVM_MODE_NORMAL ]]; then\n    local cursor=$CURSOR\n    local cache=()\n    local cmds=()\n    local key=\n\n    zvm_select_vi_mode $ZVM_MODE_REPLACE\n\n    while :; do\n      # Read a character for replacing\n      zvm_update_cursor\n\n      # Redisplay the command line, this is to be called from within\n      # a user-defined widget to allow changes to become visible\n      zle -R\n\n      read -k 1 key\n\n      # Escape key will break the replacing process, and enter key\n      # will repace with a newline character.\n      case $(zvm_escape_non_printed_characters $key) in\n        '^['|$ZVM_VI_OPPEND_ESCAPE_BINDKEY) break;;\n        '^M') key=$'\\n';;\n      esac\n\n      # If the key is backspace, we should move backward the cursor\n      if [[ $key == '' ]]; then\n        # Cursor position should not be less than zero\n        if ((cursor > 0)); then\n          cursor=$((cursor-1))\n        fi\n\n        # We should recover the character when cache size is not zero\n        if ((${#cache[@]} > 0)); then\n          key=${cache[-1]}\n\n          if [[ $key == '<I>' ]]; then\n            key=\n          fi\n\n          cache=(${cache[@]:0:-1})\n          BUFFER[$cursor+1]=$key\n\n          # Remove from commands\n          cmds=(${cmds[@]:0:-1})\n        fi\n      else\n        # If the key or the character at cursor is a newline character,\n        # or the cursor is at the end of buffer, we should insert the\n        # key instead of replacing with the key.\n        if [[ $key == $'\\n' ||\n          $BUFFER[$cursor+1] == $'\\n' ||\n          $BUFFER[$cursor+1] == ''\n        ]]; then\n          cache+=('<I>')\n          LBUFFER+=$key\n        else\n          cache+=(${BUFFER[$cursor+1]})\n          BUFFER[$cursor+1]=$key\n        fi\n\n        cursor=$((cursor+1))\n\n        # Push to commands\n        cmds+=($key)\n      fi\n\n      # Update next cursor position\n      CURSOR=$cursor\n\n      zle redisplay\n    done\n\n    # The cursor position should go back one character after\n    # exiting the replace mode\n    zle vi-backward-char\n\n    zvm_select_vi_mode $ZVM_MODE_NORMAL\n    zvm_reset_repeat_commands $ZVM_MODE R $cmds\n  elif [[ $ZVM_MODE == $ZVM_MODE_VISUAL ]]; then\n    zvm_enter_visual_mode V\n    zvm_vi_change\n  elif [[ $ZVM_MODE == $ZVM_MODE_VISUAL_LINE ]]; then\n    zvm_vi_change\n  fi\n}\n\n# Replace characters in one time\nfunction zvm_vi_replace_chars() {\n  local cmds=()\n  local key=\n\n  # Read a character for replacing\n  zvm_enter_oppend_mode\n\n  # Redisplay the command line, this is to be called from within\n  # a user-defined widget to allow changes to become visible\n  zle redisplay\n  zle -R\n\n  read -k 1 key\n\n  zvm_exit_oppend_mode\n\n  # Escape key will break the replacing process\n  case $(zvm_escape_non_printed_characters $key) in\n    $ZVM_VI_OPPEND_ESCAPE_BINDKEY)\n      zvm_exit_visual_mode\n      return\n  esac\n\n  if [[ $ZVM_MODE == $ZVM_MODE_NORMAL ]]; then\n    cmds+=($key)\n    BUFFER[$CURSOR+1]=$key\n  else\n    local ret=($(zvm_calc_selection))\n    local bpos=${ret[1]} epos=${ret[2]}\n    for ((bpos=bpos+1; bpos<=epos; bpos++)); do\n      # Newline character is no need to be replaced\n      if [[ $BUFFER[$bpos] == $'\\n' ]]; then\n        cmds+=($'\\n')\n        continue\n      fi\n\n      cmds+=($key)\n      BUFFER[$bpos]=$key\n    done\n    zvm_exit_visual_mode\n  fi\n\n  # Reset the repeat commands\n  zvm_reset_repeat_commands $ZVM_MODE r $cmds\n}\n\n# Substitute characters of selection\nfunction zvm_vi_substitute() {\n  # Substitute one character in normal mode\n  if [[ $ZVM_MODE == $ZVM_MODE_NORMAL ]]; then\n    BUFFER=\"${BUFFER:0:$CURSOR}${BUFFER:$((CURSOR+1))}\"\n    zvm_reset_repeat_commands $ZVM_MODE c 0 1\n    zvm_select_vi_mode $ZVM_MODE_INSERT\n  else\n    zvm_vi_change\n  fi\n}\n\n# Substitute all characters of a line\nfunction zvm_vi_substitute_whole_line() {\n  zvm_select_vi_mode $ZVM_MODE_VISUAL_LINE false\n  zvm_vi_substitute\n}\n\n# Check if cursor is at an empty line\nfunction zvm_is_empty_line() {\n  local cursor=${1:-$CURSOR}\n  if [[ ${BUFFER:$cursor:1} == $'\\n' &&\n    ${BUFFER:$((cursor-1)):1} == $'\\n' ]]; then\n    return\n  fi\n  return 1\n}\n\n# Get the beginning and end position of selection\nfunction zvm_selection() {\n  local bpos= epos=\n  if (( MARK > CURSOR )) ; then\n    bpos=$CURSOR epos=$((MARK+1))\n  else\n    bpos=$MARK epos=$((CURSOR+1))\n  fi\n  echo $bpos $epos\n}\n\n# Calculate the region of selection\nfunction zvm_calc_selection() {\n  local ret=($(zvm_selection))\n  local bpos=${ret[1]} epos=${ret[2]} cpos=\n\n  # Save the current cursor position\n  cpos=$bpos\n\n  # Check if it is visual-line mode\n  if [[ \"${1:-$ZVM_MODE}\" == $ZVM_MODE_VISUAL_LINE ]]; then\n\n    # Extend the selection to whole line\n    for ((bpos=$bpos-1; $bpos>0; bpos--)); do\n      if [[ \"${BUFFER:$bpos:1}\" == $'\\n' ]]; then\n        bpos=$((bpos+1))\n        break\n      fi\n    done\n    for ((epos=$epos-1; $epos<$#BUFFER; epos++)); do\n      if [[ \"${BUFFER:$epos:1}\" == $'\\n' ]]; then\n        break\n      fi\n    done\n\n    # The begin position must not be less than zero\n    if (( bpos < 0 )); then\n      bpos=0\n    fi\n\n    ###########################################\n    # Calculate the new cursor position, here we consider that\n    # the selection will be delected.\n\n    # Calculate the indent of current cursor line\n    for ((cpos=$((CURSOR-1)); $cpos>=0; cpos--)); do\n      [[ \"${BUFFER:$cpos:1}\" == $'\\n' ]] && break\n    done\n\n    local indent=$((CURSOR-cpos-1))\n\n    # If the selection includes the last line, the cursor\n    # will move up to above line. Otherwise the cursor will\n    # keep in the same line.\n\n    local hpos= # Line head position\n    local rpos= # Reference position\n\n    if (( $epos < $#BUFFER )); then\n      # Get the head position of next line\n      hpos=$((epos+1))\n      rpos=$bpos\n    else\n      # Get the head position of above line\n      for ((hpos=$((bpos-2)); $hpos>0; hpos--)); do\n        if [[ \"${BUFFER:$hpos:1}\" == $'\\n' ]]; then\n          break\n        fi\n      done\n      if (( $hpos < -1 )); then\n        hpos=-1\n      fi\n      hpos=$((hpos+1))\n      rpos=$hpos\n    fi\n\n    # Calculate the cursor postion, the indent must be\n    # less than the line characters.\n    for ((cpos=$hpos; $cpos<$#BUFFER; cpos++)); do\n      if [[ \"${BUFFER:$cpos:1}\" == $'\\n' ]]; then\n        break\n      fi\n      if (( $hpos + $indent <= $cpos )); then\n        break\n      fi\n    done\n\n    cpos=$((rpos+cpos-hpos))\n  fi\n\n  echo $bpos $epos $cpos\n}\n\n# Yank characters of the marked region\nfunction zvm_yank() {\n  local ret=($(zvm_calc_selection $1))\n  local bpos=$ret[1] epos=$ret[2] cpos=$ret[3]\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}\n  if [[ ${1:-$ZVM_MODE} == $ZVM_MODE_VISUAL_LINE ]]; then\n    CUTBUFFER=${CUTBUFFER}$'\\n'\n  fi\n  CURSOR=$bpos MARK=$epos\n}\n\n# Up case of the visual selection\nfunction zvm_vi_up_case() {\n  local ret=($(zvm_selection))\n  local bpos=${ret[1]} epos=${ret[2]}\n  local content=${BUFFER:$bpos:$((epos-bpos))}\n  BUFFER=\"${BUFFER:0:$bpos}${(U)content}${BUFFER:$epos}\"\n  zvm_exit_visual_mode\n}\n\n# Down case of the visual selection\nfunction zvm_vi_down_case() {\n  local ret=($(zvm_selection))\n  local bpos=${ret[1]} epos=${ret[2]}\n  local content=${BUFFER:$bpos:$((epos-bpos))}\n  BUFFER=\"${BUFFER:0:$bpos}${(L)content}${BUFFER:$epos}\"\n  zvm_exit_visual_mode\n}\n\n# Opposite case of the visual selection\nfunction zvm_vi_opp_case() {\n  local ret=($(zvm_selection))\n  local bpos=${ret[1]} epos=${ret[2]}\n  local content=${BUFFER:$bpos:$((epos-bpos))}\n  for ((i=1; i<=$#content; i++)); do\n    if [[ ${content[i]} =~ [A-Z] ]]; then\n      content[i]=${(L)content[i]}\n    elif [[ ${content[i]} =~ [a-z] ]]; then\n      content[i]=${(U)content[i]}\n    fi\n  done\n  BUFFER=\"${BUFFER:0:$bpos}${content}${BUFFER:$epos}\"\n  zvm_exit_visual_mode\n}\n\n# Yank characters of the visual selection\nfunction zvm_vi_yank() {\n  zvm_yank\n  zvm_exit_visual_mode ${1:-true}\n}\n\n# Put cutbuffer after the cursor\nfunction zvm_vi_put_after() {\n  local head= foot=\n  local content=${CUTBUFFER}\n  local offset=1\n\n  if [[ ${content: -1} == $'\\n' ]]; then\n    local pos=${CURSOR}\n\n    # Find the end of current line\n    for ((; $pos<$#BUFFER; pos++)); do\n      if [[ ${BUFFER:$pos:1} == $'\\n' ]]; then\n        pos=$pos+1\n        break\n      fi\n    done\n\n    # Special handling if cursor at an empty line\n    if zvm_is_empty_line; then\n      head=${BUFFER:0:$pos}\n      foot=${BUFFER:$pos}\n    else\n      head=${BUFFER:0:$pos}\n      foot=${BUFFER:$pos}\n      if [[ $pos == $#BUFFER ]]; then\n        content=$'\\n'${content:0:-1}\n        pos=$pos+1\n      fi\n    fi\n\n    offset=0\n    BUFFER=\"${head}${content}${foot}\"\n    CURSOR=$pos\n  else\n    # Special handling if cursor at an empty line\n    if zvm_is_empty_line; then\n      head=\"${BUFFER:0:$((CURSOR-1))}\"\n      foot=\"${BUFFER:$CURSOR}\"\n    else\n      head=\"${BUFFER:0:$CURSOR}\"\n      foot=\"${BUFFER:$((CURSOR+1))}\"\n    fi\n\n    BUFFER=\"${head}${BUFFER:$CURSOR:1}${content}${foot}\"\n    CURSOR=$CURSOR+$#content\n  fi\n\n  # Reresh display and highlight buffer\n  zvm_highlight clear\n  zvm_highlight custom $(($#head+$offset)) $(($#head+$#content+$offset))\n}\n\n# Put cutbuffer before the cursor\nfunction zvm_vi_put_before() {\n  local head= foot=\n  local content=${CUTBUFFER}\n\n  if [[ ${content: -1} == $'\\n' ]]; then\n    local pos=$CURSOR\n\n    # Find the beginning of current line\n    for ((; $pos>0; pos--)); do\n      if [[ \"${BUFFER:$pos:1}\" == $'\\n' ]]; then\n        pos=$pos+1\n        break\n      fi\n    done\n\n    # Check if it is an empty line\n    if zvm_is_empty_line; then\n      head=${BUFFER:0:$((pos-1))}\n      foot=$'\\n'${BUFFER:$pos}\n      pos=$((pos-1))\n    else\n      head=${BUFFER:0:$pos}\n      foot=${BUFFER:$pos}\n    fi\n\n    BUFFER=\"${head}${content}${foot}\"\n    CURSOR=$pos\n  else\n    head=\"${BUFFER:0:$CURSOR}\"\n    foot=\"${BUFFER:$((CURSOR+1))}\"\n    BUFFER=\"${head}${content}${BUFFER:$CURSOR:1}${foot}\"\n    CURSOR=$CURSOR+$#content\n    CURSOR=$((CURSOR-1))\n  fi\n\n  # Reresh display and highlight buffer\n  zvm_highlight clear\n  zvm_highlight custom $#head $(($#head+$#content))\n}\n\n# Replace a selection\nfunction zvm_replace_selection() {\n  local ret=($(zvm_calc_selection))\n  local bpos=$ret[1] epos=$ret[2] cpos=$ret[3]\n  local cutbuf=$1\n\n  # If there's a replacement, we need to calculate cursor position\n  if (( $#cutbuf > 0 )); then\n    cpos=$(($bpos + $#cutbuf - 1))\n  fi\n\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}\n\n  # Check if it is visual line mode\n  if [[ $ZVM_MODE == $ZVM_MODE_VISUAL_LINE ]]; then\n    if (( $epos < $#BUFFER )); then\n      epos=$epos+1\n    elif (( $bpos > 0 )); then\n      bpos=$bpos-1\n    fi\n    CUTBUFFER=${CUTBUFFER}$'\\n'\n  fi\n\n  BUFFER=\"${BUFFER:0:$bpos}${cutbuf}${BUFFER:$epos}\"\n  CURSOR=$cpos\n}\n\n# Replace characters of the visual selection\nfunction zvm_vi_replace_selection() {\n  zvm_replace_selection $CUTBUFFER\n  zvm_exit_visual_mode ${1:-true}\n}\n\n# Delete characters of the visual selection\nfunction zvm_vi_delete() {\n  zvm_replace_selection\n  zvm_exit_visual_mode ${1:-true}\n}\n\n# Yank characters of the visual selection\nfunction zvm_vi_change() {\n  local ret=($(zvm_calc_selection))\n  local bpos=$ret[1] epos=$ret[2]\n\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}\n\n  # Check if it is visual line mode\n  if [[ $ZVM_MODE == $ZVM_MODE_VISUAL_LINE ]]; then\n    CUTBUFFER=${CUTBUFFER}$'\\n'\n  fi\n\n  BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n  CURSOR=$bpos\n\n  # Return when it's repeating mode\n  $ZVM_REPEAT_MODE && return\n\n  # Reset the repeat commands\n  if [[ $ZVM_MODE != $ZVM_MODE_NORMAL ]]; then\n    local npos=0 ncount=0 ccount=0\n    # Count the amount of newline character and the amount of\n    # characters after the last newline character.\n    while :; do\n      # Forward find the last newline character's position\n      npos=$(zvm_substr_pos $CUTBUFFER $'\\n' $npos)\n      if [[ $npos == -1 ]]; then\n        if (($ncount == 0)); then\n          ccount=$#CUTBUFFER\n        fi\n        break\n      fi\n      npos=$((npos+1))\n      ncount=$(($ncount + 1))\n      ccount=$(($#CUTBUFFER - $npos))\n    done\n    zvm_reset_repeat_commands $ZVM_MODE c $ncount $ccount\n  fi\n\n  zvm_exit_visual_mode false\n  zvm_select_vi_mode $ZVM_MODE_INSERT ${1:-true}\n}\n\n# Change characters from cursor to the end of current line\nfunction zvm_vi_change_eol() {\n  local bpos=$CURSOR epos=$CURSOR\n\n  # Find the end of current line\n  for ((; $epos<$#BUFFER; epos++)); do\n    if [[ \"${BUFFER:$epos:1}\" == $'\\n' ]]; then\n      break\n    fi\n  done\n\n  CUTBUFFER=${BUFFER:$bpos:$((epos-bpos))}\n  BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n\n  zvm_reset_repeat_commands $ZVM_MODE c 0 $#CUTBUFFER\n  zvm_select_vi_mode $ZVM_MODE_INSERT\n}\n\n# Default handler for unhandled key events\nfunction zvm_default_handler() {\n  local keys=$(zvm_keys)\n  local extra_keys=$1\n\n  # Exit vi mode if keys is the escape keys\n  case $(zvm_escape_non_printed_characters \"$keys\") in\n    '^['|$ZVM_VI_INSERT_ESCAPE_BINDKEY)\n      zvm_exit_insert_mode false\n      zvm_reset_prompt\n      ZVM_KEYS=${extra_keys}\n      return\n      ;;\n    [vV]'^['|[vV]$ZVM_VI_VISUAL_ESCAPE_BINDKEY)\n      zvm_exit_visual_mode false\n      zvm_reset_prompt\n      ZVM_KEYS=${extra_keys}\n      return\n      ;;\n  esac\n\n  case \"$KEYMAP\" in\n    vicmd)\n      case \"$keys\" in\n        [vV]c) zvm_vi_change false;;\n        [vV]d) zvm_vi_delete false;;\n        [vV]y) zvm_vi_yank false;;\n        [vV]S) zvm_change_surround S;;\n        [cdyvV]*)\n          # We must loop util we meet a valid range action\n          while :; do\n            zvm_range_handler \"${keys}${extra_keys}\"\n            case $? in\n              0) break;;\n              1)\n                # Continue to ask to provide the action when we're\n                # still in visual mode\n                keys='v'; extra_keys=\n                ;;\n              2)\n                # Pushe the keys onto the input stack of ZLE, it's\n                # handled in zvm_readkeys_handler function\n                zvm_exit_visual_mode false\n                zvm_reset_prompt\n                return\n                ;;\n              3)\n                zvm_exit_visual_mode false\n                zvm_reset_prompt\n                break\n                ;;\n            esac\n          done\n          ;;\n        *)\n          for ((i=0;i<$#keys;i++)) do\n            zvm_navigation_handler ${keys:$i:1}\n            zvm_highlight\n          done\n          ;;\n      esac\n      ;;\n    viins|main)\n      if [[ \"${keys:0:1}\" =~ [a-zA-Z0-9\\ ] ]]; then\n        zvm_self_insert \"${keys:0:1}\"\n        zle redisplay\n        ZVM_KEYS=\"${keys:1}${extra_keys}\"\n        return\n      elif [[ \"${keys:0:1}\" == $'\\e' ]]; then\n        zvm_exit_insert_mode false\n        ZVM_KEYS=\"${keys:1}${extra_keys}\"\n        return\n      fi\n      ;;\n    visual)\n      ;;\n  esac\n\n  ZVM_KEYS=\n}\n\n# Read keys for retrieving and executing a widget\nfunction zvm_readkeys_handler() {\n  local keymap=${1}\n  local keys=${2:-$KEYS}\n  local key=\n  local widget=\n\n  # Get the keymap if keymap is empty\n  if [[ -z $keymap ]]; then\n    case \"$ZVM_MODE\" in\n      $ZVM_MODE_INSERT) keymap=viins;;\n      $ZVM_MODE_NORMAL) keymap=vicmd;;\n      $ZVM_MODE_VISUAL|$ZVM_MODE_VISUAL_LINE) keymap=visual;;\n    esac\n  fi\n\n  # Read keys and retrieve the widget\n  zvm_readkeys $keymap $keys\n  keys=${retval[1]}\n  widget=${retval[2]}\n  key=${retval[3]}\n\n  # Escape space in keys\n  keys=${keys//$ZVM_ESCAPE_SPACE/ }\n  key=${key//$ZVM_ESCAPE_SPACE/ }\n\n  ZVM_KEYS=\"${keys}\"\n\n  # If the widget is current handler, we should call the default handler\n  if [[ \"${widget}\" == \"${funcstack[1]}\" ]]; then\n    widget=\n  fi\n\n  # If the widget isn't matched, we should call the default handler\n  if [[ -z ${widget} ]]; then\n    # Disable reset prompt action, as multiple calling this function\n    # will cause potential line eaten issue.\n    ZVM_RESET_PROMPT_DISABLED=true\n\n    zle zvm_default_handler \"$key\"\n\n    ZVM_RESET_PROMPT_DISABLED=false\n\n    # Push back to the key input stack, and postpone reset prompt\n    if [[ -n \"$ZVM_KEYS\" ]]; then\n      # To prevent ZLE from error \"not enough arguments for -U\", the\n      # parameter should be put after `--` symbols.\n      zle -U -- \"${ZVM_KEYS}\"\n    else\n      # If there is any reset prompt, we need to execute for\n      # prompt resetting.\n      zvm_postpone_reset_prompt false\n    fi\n  else\n    zle $widget\n  fi\n\n  ZVM_KEYS=\n}\n\n# Find and move cursor to next character\nfunction zvm_find_and_move_cursor() {\n  local char=$1\n  local count=${2:-1}\n  local forward=${3:-true}\n  local skip=${4:-false}\n  local cursor=$CURSOR\n\n  [[ -z $char ]] && return 1\n\n  # Find the specific character\n  while :; do\n    if $forward; then\n      cursor=$((cursor+1))\n      ((cursor > $#BUFFER)) && break\n    else\n      cursor=$((cursor-1))\n      ((cursor < 0)) && break\n    fi\n    if [[ ${BUFFER[$cursor+1]} == $char ]]; then\n      count=$((count-1))\n    fi\n    ((count == 0)) && break\n  done\n\n  [[ $count > 0 ]] && return 1\n\n  # Skip the character\n  if $skip; then\n    if $forward; then\n      cursor=$((cursor-1))\n    else\n      cursor=$((cursor+1))\n    fi\n  fi\n\n  CURSOR=$cursor\n}\n\n# Handle the navigation action\nfunction zvm_navigation_handler() {\n  # Return if no keys provided\n  [[ -z $1 ]] && return 1\n\n  local keys=$1\n  local count=\n  local cmd=\n\n  # Retrieve the calling command\n  if [[ $keys =~ '^([1-9][0-9]*)?([fFtT].?)$' ]]; then\n    count=${match[1]:-1}\n\n    # The length of keys must be 2\n    if (( ${#match[2]} < 2)); then\n      zvm_enter_oppend_mode\n\n      read -k 1 cmd\n      keys+=$cmd\n\n      case \"$(zvm_escape_non_printed_characters ${keys[-1]})\" in\n        $ZVM_VI_OPPEND_ESCAPE_BINDKEY) return 1;;\n      esac\n\n      zvm_exit_oppend_mode\n    fi\n\n    local forward=true\n    local skip=false\n\n    [[ ${keys[-2]} =~ '[FT]' ]] && forward=false\n    [[ ${keys[-2]} =~ '[tT]' ]] && skip=true\n\n    # Escape special characters (e.g. ', \", `, ~, ^, |, &, <space>)\n    local key=${keys[-1]}\n    if [[ $key =~ \"['\\\\\\\"\\`\\~\\^\\|\\#\\&\\*\\;\\}\\(\\)\\<\\>\\ ]\" ]]; then\n      key=\\\\${key}\n    fi\n\n    cmd=(zvm_find_and_move_cursor $key $count $forward $skip)\n    count=1\n  else\n    count=${keys:0:-1}\n    case ${keys: -1} in\n      '^') cmd=(zle vi-first-non-blank);;\n      '$') cmd=(zle vi-end-of-line);;\n      ' ') cmd=(zle vi-forward-char);;\n      '0') cmd=(zle vi-digit-or-beginning-of-line);;\n      'h') cmd=(zle vi-backward-char);;\n      'j') cmd=(zle down-line-or-history);;\n      'k') cmd=(zle up-line-or-history);;\n      'l') cmd=(zle vi-forward-char);;\n      'w') cmd=(zle vi-forward-word);;\n      'W') cmd=(zle vi-forward-blank-word);;\n      'e') cmd=(zle vi-forward-word-end);;\n      'E') cmd=(zle vi-forward-blank-word-end);;\n      'b') cmd=(zle vi-backward-word);;\n      'B') cmd=(zle vi-backward-blank-word);;\n    esac\n  fi\n\n  # Check widget if the widget is empty\n  if [[ -z $cmd ]]; then\n    return 0\n  fi\n\n  # Check if keys includes the count\n  if [[ ! $count =~ ^[0-9]+$ ]]; then\n    count=1\n  fi\n\n  zvm_repeat_command \"$cmd\" $count\n  local exit_code=$?\n\n  if [[ $exit_code == 0 ]]; then\n    retval=$keys\n  fi\n\n  return $exit_code\n}\n\n# Handle a range of characters\nfunction zvm_range_handler() {\n  local keys=$1\n  local cursor=$CURSOR\n  local key=\n  local mode=\n  local cmds=($ZVM_MODE)\n  local count=1\n  local exit_code=0\n\n  # Enter operator pending mode\n  zvm_enter_oppend_mode false\n\n  # If the keys is less than 2 keys, we should read more\n  # keys (e.g. d, c, y, etc.)\n  while (( ${#keys} < 2 )); do\n    zvm_update_cursor\n    read -k 1 key\n    keys=\"${keys}${key}\"\n  done\n\n  # If the keys ends in numbers, we should read more\n  # keys (e.g. d2, c3, y10, etc.)\n  while [[ ${keys: 1} =~ ^[1-9][0-9]*$ ]]; do\n    zvm_update_cursor\n    read -k 1 key\n    keys=\"${keys}${key}\"\n  done\n\n  # If the 2nd character is `i` or `a`, we should read\n  # one more key\n  if [[ ${keys} =~ '^.[ia]$' ]]; then\n    zvm_update_cursor\n    read -k 1 key\n    keys=\"${keys}${key}\"\n  fi\n\n  # Exit operator pending mode\n  zvm_exit_oppend_mode\n\n  # Handle escape in operator pending mode\n  # escape non-printed characters (e.g. ^[)\n  if [[ $(zvm_escape_non_printed_characters \"$keys\") =~\n    ${ZVM_VI_OPPEND_ESCAPE_BINDKEY/\\^\\[/\\\\^\\\\[} ]]; then\n    return 1\n  fi\n\n  # Enter visual mode or visual line mode\n  if [[ $ZVM_MODE != $ZVM_MODE_VISUAL &&\n    $ZVM_MODE != $ZVM_MODE_VISUAL_LINE ]]; then\n    case \"${keys}\" in\n      [cdy][jk]) mode=$ZVM_MODE_VISUAL_LINE;;\n      cc|dd|yy) mode=$ZVM_MODE_VISUAL_LINE;;\n      *) mode=$ZVM_MODE_VISUAL;;\n    esac\n    # Select the mode\n    if [[ ! -z $mode ]]; then\n      zvm_select_vi_mode $mode false\n    fi\n  fi\n\n  #######################################\n  # Selection Cases:\n  #\n  # 1. SAMPLE: `word1  word2  w`, CURSOR: at `w` of `word1`\n  #\n  #  c[we] -> `word1`\n  #  c2[we] -> `word1  word2`\n  #  ve -> `word1`\n  #  v2e -> `word1  word2`\n  #  vw -> `word1  w`\n  #  v2w -> `word1  word2  w`\n  #  [dy]e -> `word1`\n  #  [dy]2e -> `word1  word2`\n  #  [dy]w -> `word1  `\n  #  [dy]2w -> `word1  word2  `\n  #  [cdyv]iw -> `word1`\n  #  [cdyv]aw -> `word1  `\n  #  [cdyv]2iw -> `word1  `\n  #  [cdyv]2aw -> `word1  word2  `\n  #\n  # 2. SAMPLE: `a  bb  c  dd`, CURSOR: at `a`\n  #\n  #  cw -> `a`\n  #  c2w -> `a bb`\n  #  ce -> `a bb`\n  #  c2e -> `a bb c`\n  #\n  # 3. SAMPLE: ` .foo.  bar.  baz.`, CURSOR: at `f`\n  #\n  #  c[WE] -> `foo.`\n  #  c2[WE] -> `foo.  bar.`\n  #  vE -> `foo.`\n  #  v2E -> `foo.  bar.`\n  #  vW -> `foo.  b`\n  #  v2W -> `foo.  bar.  b`\n  #  d2W -> `foo.  bar.  b`\n  #  [dy]E -> `foo.`\n  #  [dy]2E -> `foo.  bar.`\n  #  [dy]W -> `foo.  `\n  #  [dy]2W -> `foo.  bar.  `\n  #  [cdyv]iW -> `.foo.`\n  #  [cdyv]aW -> `.foo.  `\n  #  [cdyv]2iW -> `.foo.  `\n  #  [cdyv]2aW -> `.foo.  bar.  `\n  #\n  # 4. SAMPLE: ` .foo.bar.baz.`, CURSOR: at `r`\n  #\n  #  [cdy]b -> `ba`\n  #  [cdy]B -> `.foo.ba`\n  #  vb -> `bar`\n  #  vB -> `.foo.bar`\n  #  vFf -> `foo.bar`\n  #  vTf -> `oo.bar`\n  #  [cdyv]fz -> `r.baz`\n  #  [cdy]Ff -> `foo.ba`\n  #  [cdyv]tz -> `r.ba`\n  #  [cdy]Tf -> `oo.ba`\n  #\n\n  # Pre navigation handling\n  local navkey=\n\n  if [[ $keys =~ '^c([1-9][0-9]*)?[ia][wW]$' ]]; then\n    count=${match[1]:-1}\n    navkey=${keys: -2}\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?[ia][eE]$' ]]; then\n    navkey=\n  elif [[ $keys =~ '^c([1-9][0-9]*)?[eEwW]$' ]]; then\n    count=${match[1]:-1}\n    navkey=c${keys: -1}\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?[bB]$' ]]; then\n    MARK=$((MARK-1))\n    count=${match[1]:-1}\n    navkey=${keys: -1}\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?([FT].?)$' ]]; then\n    MARK=$((MARK-1))\n    count=${match[1]:-1}\n    navkey=${match[2]}\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?j$' ]]; then\n    # Exit if there is no line below\n    count=${match[1]:-1}\n    for ((i=$((CURSOR+1)); i<=$#BUFFER; i++)); do\n      [[ ${BUFFER[$i]} == $'\\n' ]] && navkey='j'\n    done\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?k$' ]]; then\n    # Exit if there is no line above\n    count=${match[1]:-1}\n    for ((i=$((CURSOR+1)); i>0; i--)); do\n      [[ ${BUFFER[$i]} == $'\\n' ]] && navkey='k'\n    done\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?[\\^h0]$' ]]; then\n    MARK=$((MARK-1))\n    count=${match[1]:-1}\n    navkey=${keys: -1}\n\n    # Exit if the cursor is at the beginning of a line\n    if ((MARK < 0)); then\n      navkey=\n    elif [[ ${BUFFER[$MARK+1]} == $'\\n' ]]; then\n      navkey=\n    fi\n  elif [[ $keys =~ '^[cdy]([1-9][0-9]*)?l$' ]]; then\n    count=${match[1]:-1}\n    count=$((count-1))\n    navkey=${count}l\n  elif [[ $keys =~ '^.([1-9][0-9]*)?([^0-9]+)$' ]]; then\n    count=${match[1]:-1}\n    navkey=${match[2]}\n  else\n    navkey=\n  fi\n\n  # Handle navigation\n  case $navkey in\n    '') exit_code=1;;\n    *[ia]?)\n      # At least 1 time\n      if [[ -z $count ]]; then\n        count=1\n      fi\n\n      # Retrieve the widget\n      cmd=\n      case ${navkey: -2} in\n        iw) cmd=(zle select-in-word);;\n        aw) cmd=(zle select-a-word);;\n        iW) cmd=(zle select-in-blank-word);;\n        aW) cmd=(zle select-a-blank-word);;\n      esac\n\n      if [[ -n \"$cmd\" ]]; then\n        zvm_repeat_command \"$cmd\" $count\n      elif [[ -n \"$(zvm_match_surround \"${keys[-1]}\")\" ]]; then\n        ZVM_KEYS=\"${keys}\"\n        exit_code=2\n      elif [[ \"${keys[1]}\" == 'v' ]]; then\n        exit_code=1\n      else\n        exit_code=3\n      fi\n      ;;\n    c[eEwW])\n      #######################################\n      # Selection Cases:\n      #\n      # 1. SAMPLE: `word1  word2  w`, CURSOR: at `1` of `word1`\n      #\n      #  c[weWE] -> `1`\n      #  c2[weWE] -> `1  word2`\n      #\n      # 2. SAMPLE: `word1  word2  w`, CURSOR: at ` ` after `word1`\n      #\n      #  cw -> `  `\n      #  c2w -> `  word2  `\n      #  ce -> `  word2`\n      #  c2e -> `  word2  w`\n      #\n\n      if [[ \"${BUFFER[$((CURSOR + 1))]}\" == ' ' ]]; then\n        case ${navkey: -1} in\n          w) cmd=(zle vi-forward-word);;\n          W) cmd=(zle vi-forward-blank-word);;\n          e) cmd=(zle vi-forward-word-end);;\n          E) cmd=(zle vi-forward-blank-word-end);;\n        esac\n\n        zvm_repeat_command \"$cmd\" $count\n\n        case ${navkey: -1} in\n          w|W) CURSOR=$((CURSOR-1));;\n        esac\n      else\n        if [[ \"${BUFFER[$((CURSOR + 2))]}\" == ' ' ]]; then\n          count=$((count - 1))\n        fi\n\n        case ${navkey: -1} in\n          e|w) cmd=(zle vi-forward-word-end);;\n          E|W) cmd=(zle vi-forward-blank-word-end);;\n        esac\n\n        zvm_repeat_command \"$cmd\" $count\n      fi\n      ;;\n    *)\n      local retval=\n\n      # Prevent some actions(e.g. w, e) from affecting the auto\n      # suggestion suffix\n      BUFFER+=$'\\0'\n\n      if zvm_navigation_handler \"${count}${navkey}\"; then\n        keys=\"${keys[1]}${retval}\"\n      else\n        exit_code=1\n      fi\n\n      BUFFER[-1]=''\n      ;;\n  esac\n\n  # Check if there is no range selected\n  # For the exit code:\n  # 1) Loop in visual mode\n  # 2) Loop by ZVM_KEYS\n  # 3) Exit loop\n  if [[ $exit_code != 0 ]]; then\n    return $exit_code\n  fi\n\n  # Post navigation handling\n  if [[ $keys =~ '^[cdy]([1-9][0-9]*)?[ia][wW]$' ]]; then\n    cursor=$MARK\n  elif [[ $keys =~ '[dy]([1-9][0-9]*)?[wW]' ]]; then\n    CURSOR=$((CURSOR-1))\n    # If the CURSOR is at the newline character, we should\n    # move backward a character\n    if [[ \"${BUFFER:$CURSOR:1}\" == $'\\n' ]]; then\n      CURSOR=$((CURSOR-1))\n    fi\n  else\n    cursor=$CURSOR\n  fi\n\n  # Handle operation\n  case \"${keys}\" in\n    c*) zvm_vi_change false; cursor=;;\n    d*) zvm_vi_delete false; cursor=;;\n    y*) zvm_vi_yank false; cursor=;;\n    [vV]*) cursor=;;\n  esac\n\n  # Reset the repeat commands when it's changing or deleting\n  if $ZVM_REPEAT_MODE; then\n    zvm_exit_visual_mode false\n  elif [[ $keys =~ '^[cd].*' ]]; then\n    cmds+=($keys)\n    zvm_reset_repeat_commands $cmds\n  fi\n\n  # Change the cursor position if the cursor is not null\n  if [[ ! -z $cursor ]]; then\n    CURSOR=$cursor\n  fi\n}\n\n# Repeat executing command\nfunction zvm_repeat_command {\n  local cmd=$1\n  local count=${2:-1}\n\n  # check if it's a zle command\n  local is_zle_cmd=false\n  if [[ ${cmd} =~ '^zle .*' ]]; then\n    is_zle_cmd=true\n  fi\n\n  # Execute the command for `count` times. We can not use\n  # variable `i`, since some widgets will affect the variable\n  # `i`, and it will cause an infinite loop.\n  local init_cursor=$CURSOR\n  local last_cursor=$CURSOR\n  local exit_code=0\n  for ((c=0; c<count; c++)); do\n    eval $cmd\n\n    exit_code=$?\n\n    if $is_zle_cmd; then\n      exit_code=0\n    elif [[ $exit_code != 0 ]]; then\n      CURSOR=$init_cursor\n      break\n    fi\n\n    # If the cursor position is no change, we can break\n    # the loop and no need to loop so many times, thus\n    # when the count is quite large, it will not be\n    # stuck for a long time.\n    [[ $last_cursor == $CURSOR ]] && break\n\n    last_cursor=$CURSOR\n  done\n\n  return $exit_code\n}\n\n# Edit command line in EDITOR\nfunction zvm_vi_edit_command_line() {\n  # Create a temporary file and save the BUFFER to it\n  local tmp_file=$(mktemp ${ZVM_TMPDIR}/zshXXXXXX)\n\n  # Some users may config the noclobber option to prevent from\n  # overwriting existing files with the > operator, we should\n  # use >! operator to ignore the noclobber.\n  echo \"$BUFFER\" >! \"$tmp_file\"\n\n  # Edit the file with the specific editor, in case of\n  # the warning about input not from a terminal (e.g.\n  # vim), we should tell the editor input is from the\n  # terminal and not from standard input.\n  \"${(@Q)${(z)${ZVM_VI_EDITOR}}}\" $tmp_file </dev/tty\n\n  # Reload the content to the BUFFER from the temporary\n  # file after editing, and delete the temporary file.\n  BUFFER=$(cat $tmp_file)\n  rm \"$tmp_file\"\n\n  # Exit the visual mode\n  case $ZVM_MODE in\n    $ZVM_MODE_VISUAL|$ZVM_MODE_VISUAL_LINE)\n      zvm_exit_visual_mode\n      ;;\n  esac\n}\n\n# Get the substr position in a string\nfunction zvm_substr_pos() {\n  local pos=-1\n  local len=${#1}\n  local slen=${#2}\n  local i=${3:-0}\n  local forward=${4:-true}\n  local init=${i:-$($forward && echo \"$i\" || echo \"i=$len-1\")}\n  local condition=$($forward && echo \"i<$len\" || echo \"i>=0\")\n  local step=$($forward && echo 'i++' || echo 'i--')\n  for (($init;$condition;$step)); do\n    if [[ ${1:$i:$slen} == \"$2\" ]]; then\n      pos=$i\n      break\n    fi\n  done\n  echo $pos\n}\n\n# Parse surround from keys\nfunction zvm_parse_surround_keys() {\n  local keys=${1:-${$(zvm_keys)//$ZVM_ESCAPE_SPACE/ }}\n  local action=\n  local surround=\n  case \"${keys}\" in\n    vS*) action=S; surround=${keys:2};;\n    vsa*) action=a; surround=${keys:3};;\n    vys*) action=y; surround=${keys:3};;\n    s[dr]*) action=${keys:1:1}; surround=${keys:2};;\n    [acd]s*) action=${keys:0:1}; surround=${keys:2};;\n    [cdvy][ia]*) action=${keys:0:2}; surround=${keys:2};;\n  esac\n  echo $action ${surround// /$ZVM_ESCAPE_SPACE}\n}\n\n# Move around code structure (e.g. (..), {..})\nfunction zvm_move_around_surround() {\n  local slen=\n  local bpos=-1\n  local epos=-1\n  for ((i=$CURSOR;i>=0;i--)); do\n    # Check if it's one of the surrounds\n    for s in {\\',\\\",\\`,\\(,\\[,\\{,\\<}; do\n      slen=${#s}\n      if [[ ${BUFFER:$i:$slen} == \"$s\" ]]; then\n        bpos=$i\n        break\n      fi\n    done\n    if (($bpos == -1)); then\n      continue\n    fi\n    # Search the nearest surround\n    local ret=($(zvm_search_surround \"$s\"))\n    if [[ -z ${ret[@]} ]]; then\n      continue\n    fi\n    bpos=${ret[1]}\n    epos=${ret[2]}\n    # Move between the openning and close surrounds\n    if (( $CURSOR > $((bpos-1)) )) && (( $CURSOR < $((bpos+slen)) )); then\n      CURSOR=$epos\n    else\n      CURSOR=$bpos\n    fi\n    break\n  done\n}\n\n# Match the surround pair from the part\nfunction zvm_match_surround() {\n  local bchar=${1// /$ZVM_ESCAPE_SPACE}\n  local echar=$bchar\n  case $bchar in\n    '(') echar=')';;\n    '[') echar=']';;\n    '{') echar='}';;\n    '<') echar='>';;\n    ')') bchar='(';echar=')';;\n    ']') bchar='[';echar=']';;\n    '}') bchar='{';echar='}';;\n    '>') bchar='<';echar='>';;\n    \"'\") ;;\n    '\"') ;;\n    '`') ;;\n    *) return;;\n  esac\n  echo $bchar $echar\n}\n\n# Search surround from the string\nfunction zvm_search_surround() {\n  local ret=($(zvm_match_surround \"$1\"))\n  local bchar=${${ret[1]//$ZVM_ESCAPE_SPACE/ }:- }\n  local echar=${${ret[2]//$ZVM_ESCAPE_SPACE/ }:- }\n  local bpos=$(zvm_substr_pos $BUFFER $bchar $CURSOR false)\n  local epos=$(zvm_substr_pos $BUFFER $echar $CURSOR true)\n  if [[ $bpos == $epos ]]; then\n      epos=$(zvm_substr_pos $BUFFER $echar $((CURSOR+1)) true)\n      if [[ $epos == -1 ]]; then\n        epos=$(zvm_substr_pos $BUFFER $echar $((CURSOR-1)) false)\n        if [[ $epos != -1 ]]; then\n          local tmp=$epos; epos=$bpos; bpos=$tmp\n        fi\n      fi\n  fi\n  if [[ $bpos == -1 ]] || [[ $epos == -1 ]]; then\n    return\n  fi\n  echo $bpos $epos $bchar $echar\n}\n\n# Select surround and highlight it in visual mode\nfunction zvm_select_surround() {\n  local ret=($(zvm_parse_surround_keys))\n  local action=${1:-${ret[1]}}\n  local surround=${2:-${ret[2]//$ZVM_ESCAPE_SPACE/ }}\n  ret=($(zvm_search_surround ${surround}))\n  if [[ ${#ret[@]} == 0 ]]; then\n    zvm_exit_visual_mode\n    return\n  fi\n  local bpos=${ret[1]}\n  local epos=${ret[2]}\n  if [[ ${action:1:1} == 'i' ]]; then\n    ((bpos++))\n  else\n    ((epos++))\n  fi\n  MARK=$bpos; CURSOR=$epos-1\n\n  # refresh for highlight redraw\n  zle redisplay\n}\n\n# Change surround in vicmd or visual mode\nfunction zvm_change_surround() {\n  local ret=($(zvm_parse_surround_keys))\n  local action=${1:-${ret[1]}}\n  local surround=${2:-${ret[2]//$ZVM_ESCAPE_SPACE/ }}\n  local bpos=${3} epos=${4}\n  local is_appending=false\n  case $action in\n    S|y|a) is_appending=true;;\n  esac\n  if $is_appending; then\n    if [[ -z $bpos && -z $epos ]]; then\n      ret=($(zvm_selection))\n      bpos=${ret[1]} epos=${ret[2]}\n    fi\n  else\n    ret=($(zvm_search_surround \"$surround\"))\n    (( ${#ret[@]} )) || return\n    bpos=${ret[1]} epos=${ret[2]}\n    zvm_highlight custom $bpos $(($bpos+1))\n    zvm_highlight custom $epos $(($epos+1))\n  fi\n  local key=\n  case $action in\n    c|r)\n      zvm_enter_oppend_mode\n      read -k 1 key\n      zvm_exit_oppend_mode\n      ;;\n    S|y|a)\n      if [[ -z $surround ]]; then\n        zvm_enter_oppend_mode\n        read -k 1 key\n        zvm_exit_oppend_mode\n      else\n        key=$surround\n      fi\n      if [[ $ZVM_MODE == $ZVM_MODE_VISUAL ]]; then\n        zle visual-mode\n      fi\n      ;;\n  esac\n\n  # Check if it is ESCAPE key (<ESC> or ZVM_VI_ESCAPE_BINDKEY)\n  case \"$key\" in\n    $'\\e'|\"${ZVM_VI_ESCAPE_BINDKEY//\\^\\[/$'\\e'}\")\n      zvm_highlight clear\n      return\n  esac\n\n  # Start changing surround\n  ret=($(zvm_match_surround \"$key\"))\n  local bchar=${${ret[1]//$ZVM_ESCAPE_SPACE/ }:-$key}\n  local echar=${${ret[2]//$ZVM_ESCAPE_SPACE/ }:-$key}\n  local value=$($is_appending && echo 0 || echo 1 )\n  local head=${BUFFER:0:$bpos}\n  local body=${BUFFER:$((bpos+value)):$((epos-(bpos+value)))}\n  local foot=${BUFFER:$((epos+value))}\n  BUFFER=\"${head}${bchar}${body}${echar}${foot}\"\n\n  # Clear highliht\n  zvm_highlight clear\n\n  case $action in\n    S|y|a) zvm_select_vi_mode $ZVM_MODE_NORMAL;;\n  esac\n}\n\n# Change surround text object\nfunction zvm_change_surround_text_object() {\n  local ret=($(zvm_parse_surround_keys))\n  local action=${1:-${ret[1]}}\n  local surround=${2:-${ret[2]//$ZVM_ESCAPE_SPACE/ }}\n  ret=($(zvm_search_surround \"${surround}\"))\n  if [[ ${#ret[@]} == 0 ]]; then\n    zvm_select_vi_mode $ZVM_MODE_NORMAL\n    return\n  fi\n  local bpos=${ret[1]}\n  local epos=${ret[2]}\n  if [[ ${action:1:1} == 'i' ]]; then\n    ((bpos++))\n  else\n    ((epos++))\n  fi\n  CUTBUFFER=${BUFFER:$bpos:$(($epos-$bpos))}\n  case ${action:0:1} in\n    c)\n      BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n      CURSOR=$bpos\n      zvm_select_vi_mode $ZVM_MODE_INSERT\n      ;;\n    d)\n      BUFFER=\"${BUFFER:0:$bpos}${BUFFER:$epos}\"\n      CURSOR=$bpos\n      ;;\n  esac\n}\n\n# Repeat last change\nfunction zvm_repeat_change() {\n  ZVM_REPEAT_MODE=true\n  ZVM_RESET_PROMPT_DISABLED=true\n\n  local cmd=${ZVM_REPEAT_COMMANDS[2]}\n\n  # Handle repeat command\n  case $cmd in\n    [aioAIO]) zvm_repeat_insert;;\n    c) zvm_repeat_vi_change;;\n    [cd]*) zvm_repeat_range_change;;\n    R) zvm_repeat_replace;;\n    r) zvm_repeat_replace_chars;;\n    *) zle vi-repeat-change;;\n  esac\n\n  zle redisplay\n\n  ZVM_RESET_PROMPT_DISABLED=false\n  ZVM_REPEAT_MODE=false\n}\n\n# Repeat inserting characters\nfunction zvm_repeat_insert() {\n  local cmd=${ZVM_REPEAT_COMMANDS[2]}\n  local cmds=(${ZVM_REPEAT_COMMANDS[3,-1]})\n\n  # Pre-handle the command\n  case $cmd in\n    a) CURSOR+=1;;\n    o)\n      zle vi-backward-char\n      zle vi-end-of-line\n      LBUFFER+=$'\\n'\n      ;;\n    A)\n      zle vi-end-of-line\n      CURSOR=$((CURSOR+1))\n      ;;\n    I) zle vi-first-non-blank;;\n    O)\n      zle vi-digit-or-beginning-of-line\n      LBUFFER+=$'\\n'\n      CURSOR=$((CURSOR-1))\n      ;;\n  esac\n\n  # Insert characters\n  for ((i=1; i<=${#cmds[@]}; i++)); do\n    cmd=\"${cmds[$i]}\"\n\n    # Hanlde the backspace command\n    if [[ $cmd == '' ]]; then\n      if (($#LBUFFER > 0)); then\n        LBUFFER=${LBUFFER:0:-1}\n      fi\n      continue\n    fi\n\n    # The length of character should be 1\n    if (($#cmd == 1)); then\n      LBUFFER+=$cmd\n    fi\n  done\n}\n\n# Repeat changing visual characters\nfunction zvm_repeat_vi_change() {\n  local mode=${ZVM_REPEAT_COMMANDS[1]}\n  local cmds=(${ZVM_REPEAT_COMMANDS[3,-1]})\n\n  # Backward move cursor to the beginning of line\n  if [[ $mode == $ZVM_MODE_VISUAL_LINE ]]; then\n    zle vi-digit-or-beginning-of-line\n  fi\n\n  local ncount=${cmds[1]}\n  local ccount=${cmds[2]}\n  local pos=$CURSOR epos=$CURSOR\n\n  # Forward expand the characters to the Nth newline character\n  for ((i=0; i<$ncount; i++)); do\n    pos=$(zvm_substr_pos $BUFFER $'\\n' $pos)\n    if [[ $pos == -1 ]]; then\n      epos=$#BUFFER\n      break\n    fi\n    pos=$((pos+1))\n    epos=$pos\n  done\n\n  # Forward expand the remaining characters\n  for ((i=0; i<$ccount; i++)); do\n    local char=${BUFFER[$epos+i]}\n    if [[ $char == $'\\n' || $char == '' ]]; then\n      ccount=$i\n      break\n    fi\n  done\n\n  epos=$((epos+ccount))\n  RBUFFER=${RBUFFER:$((epos-CURSOR))}\n}\n\n# Repeat changing a range of characters\nfunction zvm_repeat_range_change() {\n  local cmd=${ZVM_REPEAT_COMMANDS[2]}\n\n  # Remove characters\n  zvm_range_handler $cmd\n\n  # Insert characters\n  zvm_repeat_insert\n}\n\n# Repeat replacing\nfunction zvm_repeat_replace() {\n  local cmds=(${ZVM_REPEAT_COMMANDS[3,-1]})\n  local cmd=\n  local cursor=$CURSOR\n\n  for ((i=1; i<=${#cmds[@]}; i++)); do\n    cmd=\"${cmds[$i]}\"\n\n    # If the cmd or the character at cursor is a newline character,\n    # or the cursor is at the end of buffer, we should insert the\n    # cmd instead of replacing with the cmd.\n    if [[ $cmd == $'\\n' ||\n      $BUFFER[$cursor+1] == $'\\n' ||\n      $BUFFER[$cursor+1] == ''\n    ]]; then\n      LBUFFER+=$cmd\n    else\n      BUFFER[$cursor+1]=$cmd\n    fi\n\n    cursor=$((cursor+1))\n    CURSOR=$cursor\n  done\n\n  # The cursor position should go back one character after\n  # exiting the replace mode\n  zle vi-backward-char\n}\n\n# Repeat replacing characters\nfunction zvm_repeat_replace_chars() {\n  local mode=${ZVM_REPEAT_COMMANDS[1]}\n  local cmds=(${ZVM_REPEAT_COMMANDS[3,-1]})\n  local cmd=\n\n  # Replacment of visual mode should move backward cursor to the\n  # begin of current line, and replacing to the end of last line.\n  if [[ $mode == $ZVM_MODE_VISUAL_LINE ]]; then\n    zle vi-digit-or-beginning-of-line\n    cmds+=($'\\n')\n  fi\n\n  local cursor=$((CURSOR+1))\n\n  for ((i=1; i<=${#cmds[@]}; i++)); do\n    cmd=\"${cmds[$i]}\"\n\n    # If we meet a newline character in the buffer, we should keep\n    # stop replacing, util we meet next newline character command.\n    if [[ ${BUFFER[$cursor]} == $'\\n' ]]; then\n      if [[ $cmd == $'\\n' ]]; then\n        cursor=$((cursor+1))\n      fi\n      continue\n    fi\n\n    # A newline character command should keep replacing with last\n    # character, until we meet a newline character in the buffer,\n    # then we use next command.\n    if [[ $cmd == $'\\n' ]]; then\n      i=$((i-1))\n      cmd=\"${cmds[$i]}\"\n    fi\n\n    # The length of character should be 1\n    if (($#cmd == 1)); then\n      BUFFER[$cursor]=\"${cmd}\"\n    fi\n\n    cursor=$((cursor+1))\n\n    # Break when it reaches the end\n    if ((cursor > $#BUFFER)); then\n      break\n    fi\n  done\n}\n\n# Select a word under the cursor\nfunction zvm_select_in_word() {\n  local cursor=${1:-$CURSOR}\n  local buffer=${2:-$BUFFER}\n  local bpos=$cursor epos=$cursor\n  local pattern='[0-9a-zA-Z_]'\n\n  if ! [[ \"${buffer:$cursor:1}\" =~ $pattern ]]; then\n    pattern=\"[^${pattern:1:-1} ]\"\n  fi\n\n  for ((; $bpos>=0; bpos--)); do\n    [[ \"${buffer:$bpos:1}\" =~ $pattern ]] || break\n  done\n  for ((; $epos<$#buffer; epos++)); do\n    [[ \"${buffer:$epos:1}\" =~ $pattern ]] || break\n  done\n\n  bpos=$((bpos+1))\n\n  # The ending position must be greater than 0\n  if (( epos > 0 )); then\n    epos=$((epos-1))\n  fi\n\n  echo $bpos $epos\n}\n\n# Switch keyword\nfunction zvm_switch_keyword() {\n  local bpos= epos= cpos=$CURSOR\n\n  # Cursor position cases:\n  #\n  # 1. Cursor on symbol:\n  # 2+2   => +\n  # 2-2   => -\n  # 2 + 2 => +\n  # 2 +2  => +2\n  # 2 -2  => -2\n  # 2 -a  => -a\n  #\n  # 2. Cursor on number or alpha:\n  # 2+2   => +2\n  # 2-2   => -2\n  # 2 + 2 => 2\n  # 2 +2  => +2\n  # 2 -2  => -2\n  # 2 -a  => -a\n\n  # If cursor is on the `+` or `-`, we need to check if it is a\n  # number with a sign or an operator, only the number needs to\n  # forward the cursor.\n  if [[ ${BUFFER:$cpos:2} =~ [+-][0-9] ]]; then\n    if [[ $cpos == 0 || ${BUFFER:$((cpos-1)):1} =~ [^0-9] ]]; then\n      cpos=$((cpos+1))\n    fi\n\n  # If cursor is on the `+` or `-`, we need to check if it is a\n  # short option, only the short option needs to forward the cursor.\n  elif [[ ${BUFFER:$cpos:2} =~ [+-][a-zA-Z] ]]; then\n    if [[ $cpos == 0 || ${BUFFER:$((cpos-1)):1} == ' ' ]]; then\n      cpos=$((cpos+1))\n    fi\n  fi\n\n  local result=($(zvm_select_in_word $cpos))\n  bpos=${result[1]} epos=$((${result[2]}+1))\n\n  # Move backward the cursor\n  if [[ $bpos != 0 && ${BUFFER:$((bpos-1)):1} == [+-] ]]; then\n    bpos=$((bpos-1))\n  fi\n\n  local word=${BUFFER:$bpos:$((epos-bpos))}\n  local keys=$(zvm_keys)\n\n  if [[ $keys == '\u0001' ]]; then\n    local increase=true\n  else\n    local increase=false\n  fi\n\n  # Execute extra commands\n  for handler in $zvm_switch_keyword_handlers; do\n    if ! zvm_exist_command ${handler}; then\n      continue\n    fi\n\n    result=($($handler $word $increase));\n\n    if (( $#result == 0 )); then\n      continue\n    fi\n\n    epos=$(( bpos + ${result[3]} ))\n    bpos=$(( bpos + ${result[2]} ))\n\n    if (( cpos < bpos )) || (( cpos >= epos )); then\n      continue\n    fi\n\n    # Save to history and only keep some recent records\n    zvm_switch_keyword_history+=(\"${handler}:${word}\")\n    zvm_switch_keyword_history=(\"${zvm_switch_keyword_history[@]: -10}\")\n\n    BUFFER=\"${BUFFER:0:$bpos}${result[1]}${BUFFER:$epos}\"\n    CURSOR=$((bpos + ${#result[1]} - 1))\n\n    zle reset-prompt\n    return\n  done\n}\n\n# Switch number keyword\nfunction zvm_switch_number {\n  local word=$1\n  local increase=${2:-true}\n  local result= bpos= epos=\n\n  # Hexadecimal\n  if [[ $word =~ [^0-9]?(0[xX][0-9a-fA-F]*) ]]; then\n    local number=${match[1]}\n    local prefix=${number:0:2}\n    bpos=$((mbegin-1)) epos=$mend\n\n    # Hexadecimal cases:\n    #\n    # 1. Increment:\n    # 0xDe => 0xdf\n    # 0xdE => 0xDF\n    # 0xde0 => 0xddf\n    # 0xffffffffffffffff => 0x0000000000000000\n    # 0X9 => 0XA\n    # 0Xdf => 0Xe0\n    #\n    # 2. Decrement:\n    # 0xdE0 => 0xDDF\n    # 0xffFf0 => 0xfffef\n    # 0xfffF0 => 0xFFFEF\n    # 0x0 => 0xffffffffffffffff\n    # 0X0 => 0XFFFFFFFFFFFFFFFF\n    # 0Xf => 0Xe\n\n    local lower=true\n    if [[ $number =~ [A-Z][0-9]*$ ]]; then\n      lower=false\n    fi\n\n    # Fix the number truncated after 15 digits issue\n    if (( $#number > 17 )); then\n      local d=$(($#number - 15))\n      local h=${number:0:$d}\n      number=\"0x${number:$d}\"\n    fi\n\n    local p=$(($#number - 2))\n\n    if $increase; then\n      if (( $number == 0x${(l:15::f:)} )); then\n        h=$(([##16]$h+1))\n        h=${h: -1}\n        number=${(l:15::0:)}\n      else\n        h=${h:2}\n        number=$(([##16]$number + 1))\n      fi\n    else\n      if (( $number == 0 )); then\n        if (( ${h:-0} == 0 )); then\n          h=f\n        else\n          h=$(([##16]$h-1))\n          h=${h: -1}\n        fi\n        number=${(l:15::f:)}\n      else\n        h=${h:2}\n        number=$(([##16]$number - 1))\n      fi\n    fi\n\n    # Padding with zero\n    if (( $#number < $p )); then\n      number=${(l:$p::0:)number}\n    fi\n\n    result=\"${h}${number}\"\n\n    # Transform the case\n    if $lower; then\n      result=\"${(L)result}\"\n    fi\n\n    result=\"${prefix}${result}\"\n\n  # Binary\n  elif [[ $word =~ [^0-9]?(0[bB][01]*) ]]; then\n    # Binary cases:\n    #\n    # 1. Increment:\n    # 0b1 => 0b10\n    # 0x1111111111111111111111111111111111111111111111111111111111111111 =>\n    # 0x0000000000000000000000000000000000000000000000000000000000000000\n    # 0B0 => 0B1\n    #\n    # 2. Decrement:\n    # 0b1 => 0b0\n    # 0b100 => 0b011\n    # 0B010 => 0B001\n    # 0b0 =>\n    # 0x1111111111111111111111111111111111111111111111111111111111111111\n\n    local number=${match[1]}\n    local prefix=${number:0:2}\n    bpos=$((mbegin-1)) epos=$mend\n\n    # Fix the number truncated after 63 digits issue\n    if (( $#number > 65 )); then\n      local d=$(($#number - 63))\n      local h=${number:0:$d}\n      number=\"0b${number:$d}\"\n    fi\n\n    local p=$(($#number - 2))\n\n    if $increase; then\n      if (( $number == 0b${(l:63::1:)} )); then\n        h=$(([##2]$h+1))\n        h=${h: -1}\n        number=${(l:63::0:)}\n      else\n        h=${h:2}\n        number=$(([##2]$number + 1))\n      fi\n    else\n      if (( $number == 0b0 )); then\n        if (( ${h:-0} == 0 )); then\n          h=1\n        else\n          h=$(([##2]$h-1))\n          h=${h: -1}\n        fi\n        number=${(l:63::1:)}\n      else\n        h=${h:2}\n        number=$(([##2]$number - 1))\n      fi\n    fi\n\n    # Padding with zero\n    if (( $#number < $p )); then\n      number=${(l:$p::0:)number}\n    fi\n\n    result=\"${prefix}${number}\"\n\n  # Decimal\n  elif [[ $word =~ ([-+]?[0-9]+) ]]; then\n    # Decimal cases:\n    #\n    # 1. Increment:\n    # 0 => 1\n    # 99 => 100\n    #\n    # 2. Decrement:\n    # 0 => -1\n    # 10 => 9\n    # aa1230xa => aa1231xa\n    # aa1230bb => aa1231bb\n    # aa123a0bb => aa124a0bb\n\n    local number=${match[1]}\n    bpos=$((mbegin-1)) epos=$mend\n\n    if $increase; then\n      result=$(($number + 1))\n    else\n      result=$(($number - 1))\n    fi\n\n    # Check if need the plus sign prefix\n    if [[ ${word:$bpos:1} == '+' ]]; then\n      result=\"+${result}\"\n    fi\n  fi\n\n  if [[ $result ]]; then\n    echo $result $bpos $epos\n  fi\n}\n\n# Switch boolean keyword\nfunction zvm_switch_boolean() {\n  local word=$1\n  local increase=$2\n  local result=\n  local bpos=0 epos=$#word\n\n  # Remove option prefix\n  if [[ $word =~ (^[+-]{0,2}) ]]; then\n    local prefix=${match[1]}\n    bpos=$mend\n    word=${word:$bpos}\n  fi\n\n  case ${(L)word} in\n    true) result=false;;\n    false) result=true;;\n    yes) result=no;;\n    no) result=yes;;\n    on) result=off;;\n    off) result=on;;\n    y) result=n;;\n    n) result=y;;\n    t) result=f;;\n    f) result=t;;\n    *) return;;\n  esac\n\n  # Transform the case\n  if [[ $word =~ ^[A-Z]+$ ]]; then\n    result=${(U)result}\n  elif [[ $word =~ ^[A-Z] ]]; then\n    result=${(U)result:0:1}${result:1}\n  fi\n\n  echo $result $bpos $epos\n}\n\n# Switch weekday keyword\nfunction zvm_switch_weekday() {\n  local word=$1\n  local increase=$2\n  local result=${(L)word}\n  local weekdays=(\n    sunday\n    monday\n    tuesday\n    wednesday\n    thursday\n    friday\n    saturday\n  )\n\n  local i=1\n\n  for ((; i<=${#weekdays[@]}; i++)); do\n    if [[ ${weekdays[i]:0:$#result} == ${result} ]]; then\n      result=${weekdays[i]}\n      break\n    fi\n  done\n\n  # Return if no match\n  if (( i > ${#weekdays[@]} )); then\n    return\n  fi\n\n  if $increase; then\n    if (( i == ${#weekdays[@]} )); then\n      i=1\n    else\n      i=$((i+1))\n    fi\n  else\n    if (( i == 1 )); then\n      i=${#weekdays[@]}\n    else\n      i=$((i-1))\n    fi\n  fi\n\n  # Abbreviation\n  if (( $#result == $#word )); then\n    result=${weekdays[i]}\n  else\n    result=${weekdays[i]:0:$#word}\n  fi\n\n  # Transform the case\n  if [[ $word =~ ^[A-Z]+$ ]]; then\n    result=${(U)result}\n  elif [[ $word =~ ^[A-Z] ]]; then\n    result=${(U)result:0:1}${result:1}\n  fi\n\n  echo $result 0 $#word\n}\n\n# Switch operator keyword\nfunction zvm_switch_operator() {\n  local word=$1\n  local increase=$2\n  local result=\n\n  case ${(L)word} in\n    '&&') result='||';;\n    '||') result='&&';;\n    '++') result='--';;\n    '--') result='++';;\n    '==') result='!=';;\n    '!=') result='==';;\n    '===') result='!==';;\n    '!==') result='===';;\n    '+') result='-';;\n    '-') result='*';;\n    '*') result='/';;\n    '/') result='+';;\n    'and') result='or';;\n    'or') result='and';;\n    *) return;;\n  esac\n\n  # Transform the case\n  if [[ $word =~ ^[A-Z]+$ ]]; then\n    result=${(U)result}\n  elif [[ $word =~ ^[A-Z] ]]; then\n    result=${(U)result:0:1}${result:1}\n  fi\n\n  # Since the `echo` command can not print the character\n  # `-`, here we use `printf` command alternatively.\n  printf \"%s 0 $#word\" \"${result}\"\n}\n\n# Switch month keyword\nfunction zvm_switch_month() {\n  local word=$1\n  local increase=$2\n  local result=${(L)word}\n  local months=(\n    january\n    february\n    march\n    april\n    may\n    june\n    july\n    august\n    september\n    october\n    november\n    december\n  )\n\n  local i=1\n\n  for ((; i<=${#months[@]}; i++)); do\n    if [[ ${months[i]:0:$#result} == ${result} ]]; then\n      result=${months[i]}\n      break\n    fi\n  done\n\n  # Return if no match\n  if (( i > ${#months[@]} )); then\n    return\n  fi\n\n  if $increase; then\n    if (( i == ${#months[@]} )); then\n      i=1\n    else\n      i=$((i+1))\n    fi\n  else\n    if (( i == 1 )); then\n      i=${#months[@]}\n    else\n      i=$((i-1))\n    fi\n  fi\n\n  #####################\n  # Abbreviation\n  local lastlen=0\n  local last=\"${zvm_switch_keyword_history[-1]}\"\n  local funcmark=\"${funcstack[1]}:\"\n  if [[ \"$last\" =~ \"^${funcmark}\" ]]; then\n    lastlen=$(($#last - $#funcmark))\n  fi\n\n  # Use cases:\n  #\n  #  May -> June\n  #  Apr -> May -> Jun\n  #  April -> May -> June\n  #  January -> Feb(Munual changing) -> Mar\n  #  Jan -> February(Munual changing) -> March\n  #\n  if [[ \"$result\" == \"may\" ]]; then\n    if (($lastlen == 3)); then\n      result=${months[i]:0:3}\n    else\n      result=${months[i]}\n    fi\n  else\n    if (($#word == 3)); then\n      result=${months[i]:0:3}\n    else\n      result=${months[i]}\n    fi\n  fi\n\n  #####################\n  # Transform the case\n  if [[ $word =~ ^[A-Z]+$ ]]; then\n    result=${(U)result}\n  elif [[ $word =~ ^[A-Z] ]]; then\n    result=${(U)result:0:1}${result:1}\n  fi\n\n  echo $result 0 $#word\n}\n\n# Highlight content\nfunction zvm_highlight() {\n  local opt=${1:-mode}\n  local region=()\n  local redraw=false\n\n  # Hanlde region by the option\n  case \"$opt\" in\n    mode)\n      case \"$ZVM_MODE\" in\n        $ZVM_MODE_VISUAL|$ZVM_MODE_VISUAL_LINE)\n          local ret=($(zvm_calc_selection))\n          local bpos=$((ret[1])) epos=$((ret[2]))\n          local bg=$ZVM_VI_HIGHLIGHT_BACKGROUND\n          local fg=$ZVM_VI_HIGHLIGHT_FOREGROUND\n          local es=$ZVM_VI_HIGHLIGHT_EXTRASTYLE\n          region=(\"$bpos $epos fg=$fg,bg=$bg,$es\")\n          ;;\n      esac\n      redraw=true\n      ;;\n    custom)\n      local bpos=$2 epos=$3\n      local bg=${4:-$ZVM_VI_HIGHLIGHT_BACKGROUND}\n      local fg=${5:-$ZVM_VI_HIGHLIGHT_FOREGROUND}\n      local es=${6:-$ZVM_VI_HIGHLIGHT_EXTRASTYLE}\n      region=(\"${ZVM_REGION_HIGHLIGHT[@]}\")\n      region+=(\"$bpos $epos fg=$fg,bg=$bg,$es\")\n      redraw=true\n      ;;\n    clear)\n      zle redisplay\n      redraw=true\n      ;;\n    redraw) redraw=true;;\n  esac\n\n  # Update region highlight\n  if (( $#region > 0 )) || [[ \"$opt\" == 'clear' ]]; then\n\n    # Remove old region highlight\n    local rawhighlight=()\n    for ((i=1; i<=${#region_highlight[@]}; i++)); do\n      local raw=true\n      local spl=(${(@s/ /)region_highlight[i]})\n      local pat=\"${spl[1]} ${spl[2]}\"\n      for ((j=1; j<=${#ZVM_REGION_HIGHLIGHT[@]}; j++)); do\n        if [[ \"$pat\" == \"${ZVM_REGION_HIGHLIGHT[j]:0:$#pat}\" ]]; then\n          raw=false\n          break\n        fi\n      done\n      if $raw; then\n        rawhighlight+=(\"${region_highlight[i]}\")\n      fi\n    done\n\n    # Assign new region highlight\n    ZVM_REGION_HIGHLIGHT=(\"${region[@]}\")\n    region_highlight=(\"${rawhighlight[@]}\" \"${ZVM_REGION_HIGHLIGHT[@]}\")\n  fi\n\n  # Check if we need to refresh the region highlight\n  if $redraw; then\n    zle -R\n  fi\n}\n\n# Enter the visual mode\nfunction zvm_enter_visual_mode() {\n  local mode=\n  local last_mode=$ZVM_MODE\n  local last_region=\n\n  # Exit the visual mode\n  case $last_mode in\n    $ZVM_MODE_VISUAL|$ZVM_MODE_VISUAL_LINE)\n      last_region=($MARK $CURSOR)\n      zvm_exit_visual_mode\n      ;;\n  esac\n\n  case \"${1:-$(zvm_keys)}\" in\n    v) mode=$ZVM_MODE_VISUAL;;\n    V) mode=$ZVM_MODE_VISUAL_LINE;;\n    *) mode=$last_mode;;\n  esac\n\n  # We should just exit the visual mdoe if current mode\n  # is the same with last visual mode\n  if [[ $last_mode == $mode ]]; then\n    return\n  fi\n\n  zvm_select_vi_mode $mode\n\n  # Recover the region when changing to another visual mode\n  if [[ -n $last_region ]]; then\n    MARK=$last_region[1]\n    CURSOR=$last_region[2]\n    zle redisplay\n  fi\n}\n\n# Exit the visual mode\nfunction zvm_exit_visual_mode() {\n  case \"$ZVM_MODE\" in\n    $ZVM_MODE_VISUAL) zle visual-mode;;\n    $ZVM_MODE_VISUAL_LINE) zle visual-line-mode;;\n  esac\n  zvm_highlight clear\n  zvm_select_vi_mode $ZVM_MODE_NORMAL ${1:-true}\n}\n\n# Enter the vi insert mode\nfunction zvm_enter_insert_mode() {\n  local keys=${1:-$(zvm_keys)}\n\n  if [[ $keys == 'i' ]]; then\n    ZVM_INSERT_MODE='i'\n  elif [[ $keys == 'a' ]]; then\n    ZVM_INSERT_MODE='a'\n    if ! zvm_is_empty_line; then\n      CURSOR=$((CURSOR+1))\n    fi\n  fi\n\n  zvm_reset_repeat_commands $ZVM_MODE_NORMAL $ZVM_INSERT_MODE\n  zvm_select_vi_mode $ZVM_MODE_INSERT\n}\n\n# Exit the vi insert mode\nfunction zvm_exit_insert_mode() {\n  ZVM_INSERT_MODE=\n  zvm_select_vi_mode $ZVM_MODE_NORMAL ${1:-true}\n}\n\n# Enter the vi operator pending mode\nfunction zvm_enter_oppend_mode() {\n  ZVM_OPPEND_MODE=true\n  ${1:-true} && zvm_update_cursor\n}\n\n# Exit the vi operator pending mode\nfunction zvm_exit_oppend_mode() {\n  ZVM_OPPEND_MODE=false\n  ${1:-true} && zvm_update_cursor\n}\n\n# Insert at the beginning of the line\nfunction zvm_insert_bol() {\n  ZVM_INSERT_MODE='I'\n  zle vi-first-non-blank\n  zvm_select_vi_mode $ZVM_MODE_INSERT\n  zvm_reset_repeat_commands $ZVM_MODE_NORMAL $ZVM_INSERT_MODE\n}\n\n# Append at the end of the line\nfunction zvm_append_eol() {\n  ZVM_INSERT_MODE='A'\n  zle vi-end-of-line\n  CURSOR=$((CURSOR+1))\n  zvm_select_vi_mode $ZVM_MODE_INSERT\n  zvm_reset_repeat_commands $ZVM_MODE_NORMAL $ZVM_INSERT_MODE\n}\n\n# Self insert content to cursor position\nfunction zvm_self_insert() {\n  local keys=${1:-$KEYS}\n\n  # Update the autosuggestion\n  if [[ ${POSTDISPLAY:0:$#keys} == $keys ]]; then\n    POSTDISPLAY=${POSTDISPLAY:$#keys}\n  else\n    POSTDISPLAY=\n  fi\n\n  LBUFFER+=${keys}\n}\n\n# Reset the repeat commands\nfunction zvm_reset_repeat_commands() {\n  ZVM_REPEAT_RESET=true\n  ZVM_REPEAT_COMMANDS=($@)\n}\n\n# Select vi mode\nfunction zvm_select_vi_mode() {\n  local mode=$1\n  local reset_prompt=${2:-true}\n\n  # Check if current mode is the same with the new mode\n  if [[ $mode == \"$ZVM_MODE\" ]]; then\n    zvm_update_cursor\n    return\n  fi\n\n  zvm_exec_commands 'before_select_vi_mode'\n\n  # Some plugins would reset the prompt when we select the\n  # keymap, so here we postpone executing reset-prompt.\n  zvm_postpone_reset_prompt true\n\n  # Exit operator pending mode\n  if $ZVM_OPPEND_MODE; then\n    zvm_exit_oppend_mode false\n  fi\n\n  case $mode in\n    $ZVM_MODE_NORMAL)\n      ZVM_MODE=$ZVM_MODE_NORMAL\n      zvm_update_cursor\n      zle vi-cmd-mode\n      ;;\n    $ZVM_MODE_INSERT)\n      ZVM_MODE=$ZVM_MODE_INSERT\n      zvm_update_cursor\n      zle vi-insert\n      ;;\n    $ZVM_MODE_VISUAL)\n      ZVM_MODE=$ZVM_MODE_VISUAL\n      zvm_update_cursor\n      zle visual-mode\n      ;;\n    $ZVM_MODE_VISUAL_LINE)\n      ZVM_MODE=$ZVM_MODE_VISUAL_LINE\n      zvm_update_cursor\n      zle visual-line-mode\n      ;;\n    $ZVM_MODE_REPLACE)\n      ZVM_MODE=$ZVM_MODE_REPLACE\n      zvm_enter_oppend_mode\n      ;;\n  esac\n\n  # This aspect provides you a moment to do something, such as\n  # update the cursor, prompt and so on.\n  zvm_exec_commands 'after_select_vi_mode'\n\n  # Stop and trigger reset-prompt\n  $reset_prompt && zvm_postpone_reset_prompt false true\n\n  # Start the lazy keybindings when the first time entering the\n  # normal mode, when the mode is the same as last mode, we get\n  # empty value for $mode.\n  if [[ $mode == $ZVM_MODE_NORMAL ]] &&\n    (( $#ZVM_LAZY_KEYBINDINGS_LIST > 0 )); then\n\n    zvm_exec_commands 'before_lazy_keybindings'\n\n    # Here we should unset the list for normal keybindings\n    local list=(\"${ZVM_LAZY_KEYBINDINGS_LIST[@]}\")\n    unset ZVM_LAZY_KEYBINDINGS_LIST\n\n    for r in \"${list[@]}\"; do\n      eval \"zvm_bindkey ${r}\"\n    done\n\n    zvm_exec_commands 'after_lazy_keybindings'\n  fi\n}\n\n# Postpone reset prompt\nfunction zvm_postpone_reset_prompt() {\n  local toggle=$1\n  local force=${2:-false}\n\n  if $force; then\n    ZVM_POSTPONE_RESET_PROMPT=1\n  fi\n\n  if $toggle; then\n    ZVM_POSTPONE_RESET_PROMPT=0\n  else\n    if (($ZVM_POSTPONE_RESET_PROMPT > 0)); then\n      ZVM_POSTPONE_RESET_PROMPT=-1\n      zle reset-prompt\n    else\n      ZVM_POSTPONE_RESET_PROMPT=-1\n    fi\n  fi\n}\n\n# Reset prompt\nfunction zvm_reset_prompt() {\n  # Return if postponing is enabled\n  if (($ZVM_POSTPONE_RESET_PROMPT >= 0)); then\n    ZVM_POSTPONE_RESET_PROMPT=$(($ZVM_POSTPONE_RESET_PROMPT + 1))\n    return\n  fi\n\n  # Return if reset prompt is disabled\n  if [[ $ZVM_RESET_PROMPT_DISABLED == true ]]; then\n    return\n  fi\n\n  local -i retval\n  if [[ -z \"$rawfunc\" ]]; then\n    zle .reset-prompt -- \"$@\"\n  else\n    $rawfunc -- \"$@\"\n  fi\n\n  return retval\n}\n\n# Undo action in vi insert mode\n#\n# CTRL-U  Remove all characters between the cursor position and\n#         the beginning of the line.  Previous versions of vim\n#         deleted all characters on the line.\nfunction zvm_viins_undo() {\n  if [[ $ZVM_VI_INS_LEGACY_UNDO ]]; then\n    zvm_kill_line\n  else\n    zvm_backward_kill_line\n  fi\n}\n\nfunction zvm_set_cursor() {\n  # Term of vim isn't supported\n  if [[ -n $VIMRUNTIME ]]; then\n    return\n  fi\n\n  echo -ne \"$1\"\n}\n\n# Get the escape sequence of cursor style\nfunction zvm_cursor_style() {\n  local style=${(L)1}\n  local term=${2:-$ZVM_TERM}\n\n  case $term in\n    # For xterm and rxvt and their derivatives use the same escape\n    # sequences as the VT520 terminal. And screen, konsole, alacritty,\n    # st and foot implement a superset of VT100 and VT100, they support\n    # 256 colors the same way xterm does.\n    xterm*|rxvt*|screen*|tmux*|konsole*|alacritty*|st*|foot*|wezterm)\n      case $style in\n        $ZVM_CURSOR_BLOCK) style='\\e[2 q';;\n        $ZVM_CURSOR_UNDERLINE) style='\\e[4 q';;\n        $ZVM_CURSOR_BEAM) style='\\e[6 q';;\n        $ZVM_CURSOR_BLINKING_BLOCK) style='\\e[1 q';;\n        $ZVM_CURSOR_BLINKING_UNDERLINE) style='\\e[3 q';;\n        $ZVM_CURSOR_BLINKING_BEAM) style='\\e[5 q';;\n        $ZVM_CURSOR_USER_DEFAULT) style='\\e[0 q';;\n      esac\n      ;;\n    *) style='\\e[0 q';;\n  esac\n\n  # Restore default cursor color\n  if [[ $style == '\\e[0 q' ]]; then\n    local old_style=\n\n    case $ZVM_MODE in\n      $ZVM_MODE_INSERT) old_style=$ZVM_INSERT_MODE_CURSOR;;\n      $ZVM_MODE_NORMAL) old_style=$ZVM_NORMAL_MODE_CURSOR;;\n      $ZVM_MODE_OPPEND) old_style=$ZVM_OPPEND_MODE_CURSOR;;\n    esac\n\n    if [[ $old_style =~ '\\e\\][0-9]+;.+\\a' ]]; then\n      style=$style'\\e\\e]112\\a'\n    fi\n  fi\n\n  echo $style\n}\n\n# Update the cursor according current vi mode\nfunction zvm_update_cursor() {\n\n  # Check if we need to update the cursor style\n  $ZVM_CURSOR_STYLE_ENABLED || return\n\n  local mode=$1\n  local shape=\n\n  # Check if it is operator pending mode\n  if $ZVM_OPPEND_MODE; then\n    mode=opp\n    shape=$(zvm_cursor_style $ZVM_OPPEND_MODE_CURSOR)\n  fi\n\n  # Get cursor shape by the mode\n  case \"${mode:-$ZVM_MODE}\" in\n    $ZVM_MODE_NORMAL)\n      shape=$(zvm_cursor_style $ZVM_NORMAL_MODE_CURSOR)\n      ;;\n    $ZVM_MODE_INSERT)\n      shape=$(zvm_cursor_style $ZVM_INSERT_MODE_CURSOR)\n      ;;\n    $ZVM_MODE_VISUAL)\n      shape=$(zvm_cursor_style $ZVM_VISUAL_MODE_CURSOR)\n      ;;\n    $ZVM_MODE_VISUAL_LINE)\n      shape=$(zvm_cursor_style $ZVM_VISUAL_LINE_MODE_CURSOR)\n      ;;\n  esac\n\n  if [[ $shape ]]; then\n    zvm_set_cursor $shape\n  fi\n}\n\n# Updates highlight region\nfunction zvm_update_highlight() {\n  case \"$ZVM_MODE\" in\n    $ZVM_MODE_VISUAL|$ZVM_MODE_VISUAL_LINE)\n      zvm_highlight\n      ;;\n  esac\n}\n\n# Updates repeat commands\nfunction zvm_update_repeat_commands() {\n  # We don't need to update the repeat commands if current\n  # mode is already the repeat mode.\n  $ZVM_REPEAT_MODE && return\n\n  # We don't need to update the repeat commands if it is\n  # reseting the repeat commands.\n  if $ZVM_REPEAT_RESET; then\n    ZVM_REPEAT_RESET=false\n    return\n  fi\n\n  # We update the repeat commands when it's the insert mode\n  [[ $ZVM_MODE == $ZVM_MODE_INSERT ]] || return\n\n  local char=$KEYS\n\n  # If current key is an arrow key, we should do something\n  if [[ \"$KEYS\" =~ '\u001b\\[[ABCD]' ]]; then\n    # If last key is also an arrow key, we just replace it\n    if [[ ${ZVM_REPEAT_COMMANDS[-1]} =~ '\u001b\\[[ABCD]' ]]; then\n      ZVM_REPEAT_COMMANDS=(${ZVM_REPEAT_COMMANDS[@]:0:-1})\n    fi\n  else\n    # If last command is arrow key movement, we should reset\n    # the repeat commands with i(nsert) command\n    if [[ ${ZVM_REPEAT_COMMANDS[-1]} =~ '\u001b\\[[ABCD]' ]]; then\n      zvm_reset_repeat_commands $ZVM_MODE_NORMAL i\n    fi\n    char=${BUFFER[$CURSOR]}\n  fi\n\n  # If current key is backspace key, we should remove last\n  # one, until it has only the mode and inital command\n  if [[ \"$KEYS\" == '' ]]; then\n    if ((${#ZVM_REPEAT_COMMANDS[@]} > 2)) &&\n      [[ ${ZVM_REPEAT_COMMANDS[-1]} != '' ]]; then\n      ZVM_REPEAT_COMMANDS=(${ZVM_REPEAT_COMMANDS[@]:0:-1})\n    elif (($#LBUFFER > 0)); then\n      ZVM_REPEAT_COMMANDS+=($KEYS)\n    fi\n  else\n    ZVM_REPEAT_COMMANDS+=($char)\n  fi\n}\n\n# Updates editor information when line pre redraw\nfunction zvm_zle-line-pre-redraw() {\n  # Fix cursor style is not updated in tmux environment, when\n  # there are one more panel in the same window, the program\n  # in other panel could change the cursor shape, we need to\n  # update cursor style when line is redrawing.\n  if [[ -n $TMUX ]]; then\n    zvm_update_cursor\n    # Fix display is not updated in the terminal of IntelliJ IDE.\n    [[ \"$TERMINAL_EMULATOR\" == \"JetBrains-JediTerm\" ]] && zle redisplay\n  fi\n  zvm_update_highlight\n  zvm_update_repeat_commands\n}\n\n# Start every prompt in the correct vi mode\nfunction zvm_zle-line-init() {\n  # Save last mode\n  local mode=${ZVM_MODE:-$ZVM_MODE_INSERT}\n\n  # It's neccessary to set to insert mode when line init\n  # and we don't need to reset prompt.\n  zvm_select_vi_mode $ZVM_MODE_INSERT false\n\n  # Select line init mode and reset prompt\n  case ${ZVM_LINE_INIT_MODE:-$mode} in\n    $ZVM_MODE_INSERT) zvm_select_vi_mode $ZVM_MODE_INSERT;;\n    *) zvm_select_vi_mode $ZVM_MODE_NORMAL;;\n  esac\n}\n\n# Restore the user default cursor style after prompt finish\nfunction zvm_zle-line-finish() {\n  # When we start a program (e.g. vim, bash, etc.) from the\n  # command line, the cursor style is inherited by other\n  # programs, so that we need to reset the cursor style to\n  # default before executing a command and set the custom\n  # style again when the command exits. This way makes any\n  # other interactive CLI application would not be affected\n  # by it.\n  local shape=$(zvm_cursor_style $ZVM_CURSOR_USER_DEFAULT)\n  zvm_set_cursor $shape\n  zvm_switch_keyword_history=()\n}\n\n# Initialize vi-mode for widgets, keybindings, etc.\nfunction zvm_init() {\n  # Check if it has been initalized\n  if $ZVM_INIT_DONE; then\n    return;\n  fi\n\n  # Mark plugin initial status\n  ZVM_INIT_DONE=true\n\n  zvm_exec_commands 'before_init'\n\n  # Correct the readkey engine\n  case $ZVM_READKEY_ENGINE in\n    $ZVM_READKEY_ENGINE_NEX|$ZVM_READKEY_ENGINE_ZLE);;\n    *)\n      echo -n \"Warning: Unsupported readkey engine! \"\n      echo \"ZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE\"\n      ZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE_DEFAULT\n      ;;\n  esac\n\n  # Reduce ESC delay (zle default is 0.4 seconds)\n  # Set to 0.01 second delay for taking over the key input processing\n  case $ZVM_READKEY_ENGINE in\n    $ZVM_READKEY_ENGINE_NEX) KEYTIMEOUT=1;;\n    $ZVM_READKEY_ENGINE_ZLE) KEYTIMEOUT=$(($ZVM_KEYTIMEOUT*100));;\n  esac\n\n  # Create User-defined widgets\n  zvm_define_widget zvm_default_handler\n  zvm_define_widget zvm_readkeys_handler\n  zvm_define_widget zvm_backward_kill_region\n  zvm_define_widget zvm_backward_kill_line\n  zvm_define_widget zvm_forward_kill_line\n  zvm_define_widget zvm_kill_line\n  zvm_define_widget zvm_viins_undo\n  zvm_define_widget zvm_select_surround\n  zvm_define_widget zvm_change_surround\n  zvm_define_widget zvm_move_around_surround\n  zvm_define_widget zvm_change_surround_text_object\n  zvm_define_widget zvm_enter_insert_mode\n  zvm_define_widget zvm_exit_insert_mode\n  zvm_define_widget zvm_enter_visual_mode\n  zvm_define_widget zvm_exit_visual_mode\n  zvm_define_widget zvm_enter_oppend_mode\n  zvm_define_widget zvm_exit_oppend_mode\n  zvm_define_widget zvm_exchange_point_and_mark\n  zvm_define_widget zvm_open_line_below\n  zvm_define_widget zvm_open_line_above\n  zvm_define_widget zvm_insert_bol\n  zvm_define_widget zvm_append_eol\n  zvm_define_widget zvm_self_insert\n  zvm_define_widget zvm_vi_replace\n  zvm_define_widget zvm_vi_replace_chars\n  zvm_define_widget zvm_vi_substitute\n  zvm_define_widget zvm_vi_substitute_whole_line\n  zvm_define_widget zvm_vi_change\n  zvm_define_widget zvm_vi_change_eol\n  zvm_define_widget zvm_vi_delete\n  zvm_define_widget zvm_vi_yank\n  zvm_define_widget zvm_vi_put_after\n  zvm_define_widget zvm_vi_put_before\n  zvm_define_widget zvm_vi_replace_selection\n  zvm_define_widget zvm_vi_up_case\n  zvm_define_widget zvm_vi_down_case\n  zvm_define_widget zvm_vi_opp_case\n  zvm_define_widget zvm_vi_edit_command_line\n  zvm_define_widget zvm_repeat_change\n  zvm_define_widget zvm_switch_keyword\n\n  # Override standard widgets\n  zvm_define_widget zle-line-pre-redraw zvm_zle-line-pre-redraw\n\n  # Ensure the correct cursor style when an interactive program\n  # (e.g. vim, bash, etc.) starts and exits\n  zvm_define_widget zle-line-init zvm_zle-line-init\n  zvm_define_widget zle-line-finish zvm_zle-line-finish\n\n  # Override reset-prompt widget\n  zvm_define_widget reset-prompt zvm_reset_prompt\n\n  # All Key bindings\n  # Emacs-like bindings\n  # Normal editing\n  zvm_bindkey viins '^A' beginning-of-line\n  zvm_bindkey viins '^E' end-of-line\n  zvm_bindkey viins '^B' backward-char\n  zvm_bindkey viins '^F' forward-char\n  zvm_bindkey viins '^K' zvm_forward_kill_line\n  zvm_bindkey viins '^W' backward-kill-word\n  zvm_bindkey viins '^U' zvm_viins_undo\n  zvm_bindkey viins '^Y' yank\n  zvm_bindkey viins '^_' undo\n\n  # Mode agnostic editing\n  zvm_bindkey viins '^[[H'  beginning-of-line\n  zvm_bindkey vicmd '^[[H'  beginning-of-line\n  zvm_bindkey viins '^[[F'  end-of-line\n  zvm_bindkey vicmd '^[[F'  end-of-line\n  zvm_bindkey viins '^[[3~' delete-char\n  zvm_bindkey vicmd '^[[3~' delete-char\n\n  # History search\n  zvm_bindkey viins '^R' history-incremental-search-backward\n  zvm_bindkey viins '^S' history-incremental-search-forward\n  zvm_bindkey viins '^P' up-line-or-history\n  zvm_bindkey viins '^N' down-line-or-history\n\n  # Insert mode\n  zvm_bindkey vicmd 'i'  zvm_enter_insert_mode\n  zvm_bindkey vicmd 'a'  zvm_enter_insert_mode\n  zvm_bindkey vicmd 'I'  zvm_insert_bol\n  zvm_bindkey vicmd 'A'  zvm_append_eol\n\n  # Other key bindings\n  zvm_bindkey vicmd  'v' zvm_enter_visual_mode\n  zvm_bindkey vicmd  'V' zvm_enter_visual_mode\n  zvm_bindkey visual 'o' zvm_exchange_point_and_mark\n  zvm_bindkey vicmd  'o' zvm_open_line_below\n  zvm_bindkey vicmd  'O' zvm_open_line_above\n  zvm_bindkey vicmd  'r' zvm_vi_replace_chars\n  zvm_bindkey vicmd  'R' zvm_vi_replace\n  zvm_bindkey vicmd  's' zvm_vi_substitute\n  zvm_bindkey vicmd  'S' zvm_vi_substitute_whole_line\n  zvm_bindkey vicmd  'C' zvm_vi_change_eol\n  zvm_bindkey visual 'c' zvm_vi_change\n  zvm_bindkey visual 'd' zvm_vi_delete\n  zvm_bindkey visual 'x' zvm_vi_delete\n  zvm_bindkey visual 'y' zvm_vi_yank\n  zvm_bindkey vicmd  'p' zvm_vi_put_after\n  zvm_bindkey vicmd  'P' zvm_vi_put_before\n  zvm_bindkey visual 'p' zvm_vi_replace_selection\n  zvm_bindkey visual 'P' zvm_vi_replace_selection\n  zvm_bindkey visual 'U' zvm_vi_up_case\n  zvm_bindkey visual 'u' zvm_vi_down_case\n  zvm_bindkey visual '~' zvm_vi_opp_case\n  zvm_bindkey visual 'v' zvm_vi_edit_command_line\n  zvm_bindkey vicmd  '.' zvm_repeat_change\n\n  zvm_bindkey vicmd '^A' zvm_switch_keyword\n  zvm_bindkey vicmd '^X' zvm_switch_keyword\n\n  # Keybindings for escape key and some specials\n  local exit_oppend_mode_widget=\n  local exit_insert_mode_widget=\n  local exit_visual_mode_widget=\n  local default_handler_widget=\n\n  case $ZVM_READKEY_ENGINE in\n    $ZVM_READKEY_ENGINE_NEX)\n      exit_oppend_mode_widget=zvm_readkeys_handler\n      exit_insert_mode_widget=zvm_readkeys_handler\n      exit_visual_mode_widget=zvm_readkeys_handler\n      ;;\n    $ZVM_READKEY_ENGINE_ZLE)\n      exit_insert_mode_widget=zvm_exit_insert_mode\n      exit_visual_mode_widget=zvm_exit_visual_mode\n      default_handler_widget=zvm_default_handler\n      ;;\n  esac\n\n  # Bind custom escape key\n  zvm_bindkey vicmd  \"$ZVM_VI_OPPEND_ESCAPE_BINDKEY\" $exit_oppend_mode_widget\n  zvm_bindkey viins  \"$ZVM_VI_INSERT_ESCAPE_BINDKEY\" $exit_insert_mode_widget\n  zvm_bindkey visual \"$ZVM_VI_VISUAL_ESCAPE_BINDKEY\" $exit_visual_mode_widget\n\n  # Bind the default escape key if the escape key is not the default\n  case \"$ZVM_VI_OPPEND_ESCAPE_BINDKEY\" in\n    '^['|'\\e') ;;\n    *) zvm_bindkey vicmd '^[' $exit_oppend_mode_widget;;\n  esac\n  case \"$ZVM_VI_INSERT_ESCAPE_BINDKEY\" in\n    '^['|'\\e') ;;\n    *) zvm_bindkey viins '^[' $exit_insert_mode_widget;;\n  esac\n  case \"$ZVM_VI_VISUAL_ESCAPE_BINDKEY\" in\n    '^['|'\\e') ;;\n    *) zvm_bindkey visual '^[' $exit_visual_mode_widget;;\n  esac\n\n  # Bind and overwrite original y/d/c of vicmd\n  for c in {y,d,c}; do\n    zvm_bindkey vicmd \"$c\" $default_handler_widget\n  done\n\n  # Surround text-object\n  # Enable surround text-objects (quotes, brackets)\n  local surrounds=()\n\n  # Append brackets\n  for s in ${(s..)^:-'()[]{}<>'}; do\n    surrounds+=($s)\n  done\n\n  # Append quotes\n  for s in {\\',\\\",\\`,\\ ,'^['}; do\n    surrounds+=($s)\n  done\n\n  # Append for escaping visual mode\n  if $is_custom_escape_key; then\n    surrounds+=(\"$ZVM_VI_ESCAPE_BINDKEY\")\n  fi\n\n  # Surround key bindings\n  for s in $surrounds; do\n    for c in {a,i}${s}; do\n      zvm_bindkey visual \"$c\" zvm_select_surround\n    done\n    for c in {c,d,y}{a,i}${s}; do\n      zvm_bindkey vicmd \"$c\" zvm_change_surround_text_object\n    done\n    if [[ $ZVM_VI_SURROUND_BINDKEY == 's-prefix' ]]; then\n      for c in s{d,r}${s}; do\n        zvm_bindkey vicmd \"$c\" zvm_change_surround\n      done\n      for c in sa${s}; do\n        zvm_bindkey visual \"$c\" zvm_change_surround\n      done\n    else\n      for c in {d,c}s${s}; do\n        zvm_bindkey vicmd \"$c\" zvm_change_surround\n      done\n      for c in {S,ys}${s}; do\n        zvm_bindkey visual \"$c\" zvm_change_surround\n      done\n    fi\n  done\n\n  # Moving around surrounds\n  zvm_bindkey vicmd '%' zvm_move_around_surround\n\n  # Fix BACKSPACE was stuck in zsh\n  # Since normally '^?' (backspace) is bound to vi-backward-delete-char\n  zvm_bindkey viins '^?' backward-delete-char\n\n  # Initialize ZVM_MODE value\n  case ${ZVM_LINE_INIT_MODE:-$ZVM_MODE_INSERT} in\n    $ZVM_MODE_INSERT) ZVM_MODE=$ZVM_MODE_INSERT;;\n    *) ZVM_MODE=$ZVM_MODE_NORMAL;;\n  esac\n\n  # Enable vi keymap\n  bindkey -v\n\n  zvm_exec_commands 'after_init'\n}\n\n# Check if a command is existed\nfunction zvm_exist_command() {\n  command -v \"$1\" >/dev/null\n}\n\n# Execute commands\nfunction zvm_exec_commands() {\n  local commands=\"zvm_${1}_commands\"\n  commands=(${(P)commands})\n\n  # Execute the default command\n  if zvm_exist_command \"zvm_$1\"; then\n    eval \"zvm_$1\" ${@:2}\n  fi\n\n  # Execute extra commands\n  for cmd in $commands; do\n    if zvm_exist_command ${cmd}; then\n      cmd=\"$cmd ${@:2}\"\n    fi\n    eval $cmd\n  done\n}\n\n# Generate system report\nfunction zvm_system_report() {\n  # OS\n  local os_info=\n  case \"$(uname -s)\" in\n    Darwin)\n      local product=\"$(sw_vers -productName)\"\n      local version=\"$(sw_vers -productVersion) ($(sw_vers -buildVersion))\"\n      os_info=\"${product} ${version}\"\n      ;;\n    *) os_info=\"$(uname -s) ($(uname -r) $(uname -v) $(uname -m) $(uname -o))\";;\n  esac\n\n  # Terminal Program\n  local term_info=\"${TERM_PROGRAM:-unknown} ${TERM_PROGRAM_VERSION:-unknown}\"\n  term_info=\"${term_info} (${TERM})\"\n\n  # ZSH Frameworks\n  local zsh_frameworks=()\n\n  if zvm_exist_command \"omz\"; then\n    zsh_framworks+=(\"oh-my-zsh $(omz version)\")\n  fi\n\n  if zvm_exist_command \"starship\"; then\n    zsh_framworks+=(\"$(starship --version | head -n 1)\")\n  fi\n\n  if zvm_exist_command \"antigen\"; then\n    zsh_framworks+=(\"$(antigen version | head -n 1)\")\n  fi\n\n  if zvm_exist_command \"zplug\"; then\n    zsh_framworks+=(\"zplug $(zplug --version | head -n 1)\")\n  fi\n\n  if zvm_exist_command \"zinit\"; then\n    # As `zinit version` information includes term style, in order\n    # to acquire the pure text, we need to elimindate all the escape\n    # sequences.\n    local version=$(zinit version \\\n      | head -n 1 \\\n      | sed -E $'s/(\\033\\[[a-zA-Z0-9;]+ ?m)//g')\n    zsh_framworks+=(\"${version}\")\n  fi\n\n  # Shell\n  local shell=$SHELL\n  if [[ -z $shell ]]; then\n    shell=zsh\n  fi\n\n  #################\n  # System Report\n  #################\n  print - \"- Terminal program: ${term_info}\"\n  print - \"- Operating system: ${os_info}\"\n  print - \"- ZSH framework: ${(j:, :)zsh_framworks}\"\n  print - \"- ZSH version: $($shell --version)\"\n  print - \"- ZVM version: $(zvm_version | head -n 1)\"\n}\n\n# Load config by calling the config function\nif zvm_exist_command \"$ZVM_CONFIG_FUNC\"; then\n  $ZVM_CONFIG_FUNC\nfi\n\n# Initialize this plugin according to the mode\ncase $ZVM_INIT_MODE in\n  sourcing) zvm_init;;\n  *) precmd_functions+=(zvm_init);;\nesac\n\n"
        }
      ]
    }
  ]
}