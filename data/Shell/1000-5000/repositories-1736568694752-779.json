{
  "metadata": {
    "timestamp": 1736568694752,
    "page": 779,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc4OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nvie/git-toolbelt",
      "stars": 1253,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".envrc",
          "type": "blob",
          "size": 0.0107421875,
          "content": "PATH_add .\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.974609375,
          "content": "# Unreleased\n\n# v1.9.3\n\n- Fix: use main branch in `git-merged` (instead of hardcoding `master`)\n\n# v1.9.2\n\n- `git-shatter-by-file` will still work when there are \"skipped\" files\n- Various internal shell script improvements\n\n# v1.9.1\n\n- `git-main-branch` will now also recognize `mainline` as a main branch name,\n  for users migrating from Perforce.\n- `git-shatter-by-file` will still work when there are \"skipped\" files\n- Various internal shell script improvements\n\n# v1.9.0\n\n- git-cleave will now prefix commit messages (instead of suffix them) wth the\n  path matches it cleaves off\n- git-cleave now takes a `-t <prefix>` flag, which will be used instead of the\n  path matches\n- git-cleave will now prevent empty commits from being destroyed\n\n# v1.8.4\n\n- Fix issue where the probe for \"(g)realpath\" can fail\n\n# v1.8.3\n\n- Hide possible warnings displayed by `which` on some platforms\n\n# v1.8.2\n\n- Fix the fix from 1.8.1, which broke some Linux distros.\n\n# v1.8.1\n\n- Fix to be compatible with `coreutils` 9.2+, which renamed `realpath` → `grealpath`\n\n# v1.8.0\n\n- New command: `git-diff-since`\n- New command: `git-sync-commit-date`\n- `git-cleanup` will now only remove branches after explicit `-l` (local) or `-r` (remote) flag\n\n# v1.7.1\n\n- Add `-m` option to `git-modified` to only show locally modified files\n- Fix: make `git-merges-cleanly` work when there are skipped files\n\n# v1.7.0\n\n- New command: `git-cleave` to split a commit by file paths.\n\n# v1.6.0\n\n- New command: `git-wip`. This will create quick save point\n  commits for Work In Progress (WIP). This creates quick commits\n  without writing a commit message.\n\n- `git-initial-commit` will now report the more user-friendly error \"No commits\n  yet\" for an empty repo (#46, thanks @Shea690901 and @ernstki!)\n\n- `git active-branches` now supports a `-s <date>` option (for `--since`),\n  where you can specify the threshold for what is considered \"active\" (#36,\n  thanks @ernstki!)\n\n# v1.5.1\n\n- Fixes an issue where `git-local-branches` could report \"HEAD detached at ...\"\n  message (#44, thanks @asford!)\n\n# v1.5.0\n\n- Add support for repos with a default branch named main (not master)\n- Adds a new script git main-branch\n- Drop deprecated scripts:\n  - `git-assume`\n  - `git-unassume`\n  - `git-show-assumed`\n  - `git-cleanup-squashed`\n\n# v1.4.2\n\n- Support `git-active-branches` on Windows (thanks @ernstki!)\n\n# v1.4.1\n\n- Added LICENSE\n\n# v1.4.0\n\n- New commands:\n\n  - `git-skip`\n  - `git-unskip`\n  - `git-show-skipped`\n\n- Deprecated commands:\n  - `git-assume` (use `git-skip` now)\n  - `git-unassume` (use `git-unskip` now)\n  - `git-show-assumed` (use `git-show-skipped` now)\n  - `git-cleanup-squashed` (use `git cleanup -s` now)\n\n# v1.3.0\n\n- New commands:\n  - `git spinoff <new-branch> [<base>]` (inspired by Magit's spinoff command),\n    will create a new branch from the current branch and will reset the current\n    branch back to its upstream. Most useful when you have already committed\n    work on master, but really wanted that to be a new local branch instead.\n  - `git remote-tracking-branch [<branch>]` will print the name of the remote\n    tracking branch of the current or given branch (if any)\n\n# v1.2.4\n\n- Added new utility `git-cleanup-squashed` which can detect and clean up\n  branches that have been squashed-merged into master (thank you,\n  @jonathanchu)!\n\n# v1.2.3\n\n- New script:\n\n  - Add `git-branches-containing`, returning a list of branches containing the\n    specified commit (thanks @RMGiroux!)\n\n- Improvement:\n  - Make `git-sha` work without further arguments (thanks @RMGiroux!)\n\n# v1.2.2\n\n- Bugfixes:\n  - Make `git-fixup` not use `--no-verify` by default and instead respect\n    existing pre-commit hooks\n\n# v1.2.1\n\n- Fix: don't verify when fixing up\n- Fix: autostash when rebasing interactively after fixups\n- Fix: docs for `git-workon`\n\n# v1.2.0\n\n- New command: `git-fixup-with`\n- Fixes some bugs in `git-shatter-by-file` that happened when not called from\n  the git root\n\n# v1.1.5\n\n- Add `git-separator`\n- Add `git-shatter-by-file`\n\n# v1.1.4 and older\n\nNo changelog kept here yet.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.48828125,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2020, Vincent Driessen\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "PUBLISHING.md",
          "type": "blob",
          "size": 0.404296875,
          "content": "Personal notes for publishing a new version:\n\n1. Update/check CHANGELOG.md\n1. Tag the version with Git (e.g. `git tag v1.2.3`)\n1. Push the tag out (`git push --tags`)\n1. Go to https://github.com/nvie/git-toolbelt/tags\n1. Create a release from a tag\n1. Compute the SHA1 hash:  \n    `wget -O - https://github.com/nvie/git-toolbelt/archive/vX.X.X.tar.gz | sha256sum`\n1. `cd homebrew-tap`\n1. Update URL + sha256 value\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.4345703125,
          "content": "<div align=\"center\">\n  <img src=\"./img/git-toolbelt.png\" width=\"376\" height=\"409\" alt=\"git-toolbelt logo\" /><br>\n</div>\n\n# Installation instructions\n\n    $ brew tap nvie/tap\n    $ brew install nvie/tap/git-toolbelt\n\nIf not using Homebrew, you will need to have [GNU coreutils][coreutils]\ninstalled, for the `realpath` utility. Git for Windows users see [#29](https://github.com/nvie/git-toolbelt/issues/29).\n\n# git-toolbelt\n\nHelper tools to make everyday life with Git much easier.  Commands marked with\n⭐️ are my personal favorites and are commands I use almost every day.\n\nEveryday helpful commands:\n\n* ⭐️ [git-cleanup](#git-cleanup)\n* [git-current-branch](#git-current-branch)\n* [git-main-branch](#git-main-branch)\n* ⭐️ [git-fixup](#git-fixup)\n* ⭐️ [git-fixup-with](#git-fixup-with)\n* ⭐️ [git-active-branches](#git-local-branches--git-remote-branches--git-active-branches)\n- ⭐️ [git-diff-since](#git-diff-since)\n* [git-local-branches](#git-local-branches--git-remote-branches--git-active-branches)\n* [git-local-commits](#git-local-commits)\n* [git-merged / git-unmerged / git-merge-status](#git-merged--git-unmerged--git-merge-status)\n* [git-branches-containing](#git-branches-containing)\n* [git-recent-branches](#git-recent-branches)\n* [git-remote-branches](#git-local-branches--git-remote-branches--git-active-branches)\n* [git-remote-tracking-branch](#git-remote-tracking-branch)\n* [git-repo](#git-repo)\n* [git-root](#git-root)\n* [git-initial-commit](#git-initial-commit)\n* ⭐️ [git-sha](#git-sha)\n* [git-stage-all](#git-stage-all)\n* [git-unstage-all](#git-unstage-all)\n* [git-update-all](#git-update-all)\n* [git-workon](#git-workon)\n* ⭐️ [git-modified](#git-modified)\n* ⭐️ [git-modified-since](#git-modified-since)\n* ⭐️ [git-separator](#git-separator)\n* ⭐️ [git-spinoff](#git-spinoff)\n* ⭐️ [git-wip](#git-wip)\n\nStatistics:\n\n* [git-committer-info](#git-committer-info)\n\nCommands to help novices out:\n\n* [git-drop-local-changes](#git-drop-local-changes)\n* [git-stash-everything](#git-stash-everything)\n* ⭐️ [git-push-current](#git-push-current)\n* [git-undo-commit](#git-undo-commit)\n* [git-undo-merge](#git-undo-merge)\n\nCommands that simplify scripting. These commands typically only return exit\ncodes and have no output.\n\n* [git-is-repo](#git-is-repo)\n* [git-is-headless](#git-is-headless)\n* [git-has-local-changes / git-is-clean / git-is-dirty](#git-has-local-changes--git-is-clean--git-is-dirty)\n* [git-has-local-commits](#git-has-local-commits)\n* [git-contains / git is-ancestor](#git-contains--git-is-ancestor)\n* [git-local-branch-exists](#git-local-branch-exists)\n* [git-remote-branch-exists](#git-remote-branch-exists)\n* [git-tag-exists](#git-tag-exists)\n\nAdvanced usage:\n\n* [git-skip / git-unskip / git-show-skipped](#git-skip--git-unskip--git-show-skipped)\n* [git-commit-to](#git-commit-to)\n* [git-cherry-pick-to](#git-cherry-pick-to)\n* ⭐️ [git-delouse](#git-delouse)\n* ⭐️ [git-shatter-by-file](#git-shatter-by-file)\n* ⭐️ [git-cleave](#git-cleave)\n\n\n\n### git current-branch\n\nReturns the name of the current branch, if any.  Why doesn't this come with git?\n\n```console\n$ git current-branch\nmaster\n```\n\nAlias to `git rev-parse --abbrev-ref HEAD`.\n\n\n### git main-branch\n\nReturns the name of the default main branch for this repository.  Historically\n`master`, but could also be `main` if you've changed the default branch name.\nSince there's no way of reliably telling what the default branch name is for\na repo, this script will probe for the existence of local branches named either\n`main` or `master`.  The first one found is used.\n\n```console\n$ git main-branch\nmaster\n```\n\n\n### git sha\n\nReturns the SHA value for the specified object, or the current branch head, if\nnothing is provided.\n\n```console\n$ git sha <some-object>\n```\n\nTypical example:\n\n```console\n$ git sha HEAD\nf688d7543c5d52f5f78b3db1b0dd1616059299a4\n$ git sha -s HEAD\nf688d75\n```\n\nShows the commit SHA for the latest commit.\n\n\n### git modified\n\nReturns a list of locally modified files.  In contrast to git status, it does\nnot include any detailed file status, and never includes non-existing files.\n\nThis makes it ideal for the following use-case:\n\n```console\n$ vim (git modified)\n```\n\nIf you want to locally modified files that are already staged, too, use:\n\n```console\n$ vim (git modified -i)\n```\n\n\n### git modified-since\n\nLike git-modified, but for printing a list of files that have been modified\nsince master (or whatever commit specified).  In contrast to git status, it\ndoes not include any detailed file status, and never includes non-existing\nfiles.\n\nOpens all files modified on your branch (since you branched off `master`).\n\n```console\n$ vim (git modified-since)\n```\n\n\n### git separator\n\nAdds a commit with a message of only ---'s, so that it visually separates\ncommits in the history.  This is incredibly useful when doing more complex\nrebase operations.  (They should be used as a temporary measure, and ideally\ntaken out of the history again when done rebasing.)\n\n\n### git spinoff\n\nInspired by Magit's `spinoff` command.  Creates and checks out\na new branch starting at and tracking the current branch.  That\nbranch in turn is reset to the last commit it shares with its\nupstream.  If the current branch has no upstream or no unpushed\ncommits, then the new branch is created anyway and the previously\ncurrent branch is not touched.\n\nThis is useful to create a feature branch after work has already\nbegan on the old branch (likely but not necessarily \"master\").\n\n\n### git push-current\n\nPushed the current branch out to `origin`, and makes sure to setup tracking of\nthe remote branch.  Shorthand for `git push -u origin <current-branch>`.\n\nAccepts options, too, so you can use\n\n```console\n$ git push-current -f\n```\n\nto force-push.\n\n\n### git is-headless\n\nTests if `HEAD` is pointing to a branch head, or is detached.\n\n### git diff-since\n\nShows the differences made on the current branch, compared to the main branch\n(or the given branch).\n\n### git local-branches / git remote-branches / git active-branches\n\nReturns a list of local or remote branches, but contrary to Git's default\ncommands for this, returns them machine-processable.  In the case of remote\nbranches, can be asked to return only the branches in a specific remote.\n\nFor `git active-branches`, a branch is deemed \"active\" if its head points to\na commit authored in the last 3 weeks, by default. An arbitrary date can be\nspecified using either `git active-branches -s <date>` or `-a <date>`\n(mnemonic: \"since\" or \"after\"), using any date format\n[supported by `git log`][gitlog].\n\n\n### git local-branch-exists / git remote-branch-exists / git tag-exists\n\nTests if the given local branch, remote branch, or tag exists.\n\n\n### git recent-branches\n\nReturns a list of local branches, ordered by recency:\n\n    $ git recent-branches\n    foo\n    master\n    bar\n    qux\n\n\n### git remote-tracking-branch\n\nPrint the name of the remote tracking branch of the current or\ngiven local branch name, if one exists.  Errors otherwise.\n\n\n### git local-commits / git has-local-commits\n\nReturns a list of commits that are still in your local repo, but haven't been\npushed to `origin`.  `git has-local-commits` is the scriptable equivalent that\nonly returns an exit code if such commits exist.\n\n\n### git contains / git is-ancestor\n\nTests if X is merged into Y:\n\n    $ git contains X Y  # does X contain Y?\n    $ git is-ancestor X Y  # is X an ancestor of Y?\n\n**CAVEAT:**\nEven though they might look like opposites, `X contains Y` does not mean `not\n(X is-ancestor Y)`, since (1) X and Y can point to the same commit, or the\nbranches may have no common history and thus be unrelated completely.\n\n\n### git stage-all\n\nMimics the index / staging area to match the working tree exactly.  Adds files,\nremoves files, etc.\n\nAlias to `git add --all`.\n\n\n### git unstage-all\n\nUnstages everything.  Leaves the working tree intact.\n\nAlias to `git reset HEAD`.\n\n\n### git undo-merge\n\nEver created a merge accidentally, or decided that you didn't want to merge\nafter all?  You can undo the last merge using `git undo-merge`.\n\n\n### git undo-commit\n\nEver committed too soon, or by accident?  Or on the wrong branch?  You can now\nundo your last commit and you won't lose any data.  All the changes in the\ncommit will be staged (like right before the commit) and the commit itself is\ngone.\n\n\n### git cleanup\n\nDeletes all branches that have already been merged into the main branch. Keeps\nother branches lying around.  Removes branches both locally and in the origin\nremote.  Will be most conservative with deletions.\n\n\n### git fixup\n\nAmend all local staged changes into the last commit. Ideal for fixing typo's,\nwhen you don't want to re-edit the commit message.\n\n    $ git commit -m \"Something cool.\"\n    $ vim somefile.txt  # fix typo\n    $ git add somefile.txt\n    $ git fixup  # merge this little change back into the last commit\n\n\n### git fixup-with\n\nInteractively lets you pick a commit to fixup with.  (Uses `fzf` for the\ninteractive picking.  Use `brew install fzf` to install this tool separately.)\nUse `-r` to trigger an interactive rebase right afterwards.\n\n\n### git workon\n\nConvenience command for quickly switching to a branch `<name>`. If such local\nbranch does not exist, but there is a remote branch named `origin/<name>`, then\na local branch is created and the remote is tracked.\n\n\n### git delouse\n\nSay you want to rebuild your last commit, but want to keep the commit message.\ngit delouse empties the last commit on the current branch and places all\nchanges back into the working tree.\n\nSince the commit remains in history, you can now rebuild the commit by \"git\namend\"'ing or \"git fixup\"'ing, instead of making new commits.\n\n\n### git shatter-by-file\n\nSplits the last commit into N+1 commits, where N is the number of files in the\nlast commit.  The first commit is an empty commit with the original commit\nmessage and author details, and the following commits add (or delete) one file\neach, keeping the subject line of the original commit message.\n\nAfter running `git shatter-by-file`, you'll typically want to run `git rebase\n--interactive` to start fixing up changes to files, etc.  For that purpose, the\noriginal commit message is kept in there (in the empty first commit), so make\nsure to use it.\n\n\n### git cleave\n\nSplits the last commit into 2 or more commits. Takes one or more regex values\n(which are fed to `grep -Ee`), and will split the last commit by file paths\nmatching each of the regexes.\n\nFor example:\n\n    $ git cleave client/ server/\n\nWill split the last commit into 2 (or 3) commits. The first one will contain\nall the files containing `client/`, the second will contain all the files\nmatching `server/`. If there are files that don't match either of those, then\na 3rd commit will be made with the \"remainder\".\n\nAnother example:\n\n    $ git cleave '.*\\.js$'\n\nThis will split off all Javascript files from a commit.\n\n\n### git commit-to\n\nEver been on a branch and really wanted to quickly commit a change to\na different branch?  Given that this is possible without merge conflicts, git\ncommit-to will allow you to do so, without checking out the branch necessarily.\n\n    $ git branch\n      master\n    * mybranch\n    $ git status\n    M foo.txt\n    M bar.txt\n    $ git add foo.txt\n    $ git commit-to master -m \"Add foo to master.\"\n    $ git add bar.txt\n    $ git commit -m \"Add bar to mybranch.\"\n\n\n### git cherry-pick-to\n\nEvery been on a branch, just made a commit, but really want that commit\navailable on other branches as well? You can now cherry-pick this commit to any\nbranch, staying on the current branch. (Given the change won't lead to a merge\nconflict.)\n\n    $ git branch\n      master\n    * mybranch\n    $ git add foo.txt\n    $ git commit -m \"Really useful thing.\"\n    $ git cherry-pick-to master HEAD\n    $ git branch  # did not switch branches\n      master\n    * mybranch\n\n\n### git is-repo\n\nHelper function that determines whether the current directory has a Git repo\nassociated to it.  Scriptable equivalent of `git repo`.\n\n\n### git root / git repo\n\n`git root` prints the root location of the working tree.\n\n    $ cd /path/to/worktree\n    $ cd some/dir/in/worktree\n    $ pwd\n    /path/to/worktree/some/project/dir\n    $ git root\n    /path/to/worktree\n\n`git repo` prints the location of the Git directory, typically `.git`, but\ncould differ based on your setup.  Will return with a non-zero exit code if not\nin a repo.\n\n    $ cd /path/to/my/worktree\n    $ git repo\n    .git\n    $ cd /tmp\n    $ git repo\n    fatal: Not a git repository (or any of the parent directories): .git\n\n\n### git initial-commit\n\n`git initial-commit` prints the initial commit for the repo.\n\n    $ git initial-commit\n    48c94a6a29e9e52ab63ce0fab578101ddc56a04f\n\n\n### git has-local-changes / git is-clean / git is-dirty\n\nHelper function that determines whether there are local changes in the working\ntree, by returning a 0 (local changes) or 1 (no local changes) exit code.\n\n\n### git drop-local-changes\n\nDon't care about your local working copy's state and really want to revert back\nto whatever is recorded in the history? git drop-local-changes lets you do\nthis.\n\nThis covers aborting rebases, undoing partial merges, resetting the index and\nremoving any unknown local files from the work tree. Anything that is already\ncommitted remains safe.\n\n??? issue a git pull, too? Typical beginners will want this.\n\n\n### git stash-everything\n\nThe stash behaviour you (probably) always wanted.  This actually stashes\neverything what's in your index, in your working tree, and even stashes away\nyour untracked files, leaving a totally clean working tree.\n\nUsing \"git stash pop\" will recover all changes, including index state, locally\nmodified files, and untracked files.\n\n\n### git update-all\n\nUpdates all local branch heads to the remote's equivalent.  This is the same as\nchecking out all local branches one-by-one and pulling the latest upstream\nchanges.  Will only update if a pull succeeds cleanly (i.e. is a fast-forward\npull).\n\n\n### git-merged / git-unmerged / git-merge-status\n\nThis trio of subcommands makes it easy to inspect merge status of local\nbranches.  Use them to check whether any local branches have or haven't been\nmerged into the target branch (defaults to master).\n\ngit-merge-status is a useful command that presents both lists in a single\noverview (not for machine processing).\n\n\n### git-branches-containing\n\nThis command, \"git branches-containing [<object>]\" returns a list of branches\nwhich contain the specified '<object>' (defaults to 'HEAD').\n\ngit-branches-containing is useful to see if a branch has been merged, and,\nif so, which releases contain the feature/fix (if you use release\nbranches).\n\n\n### git-committer-info\n\nShows contribution stats for the given committer, like \"most productive day\",\n\"most productive hour\", \"average commit size\", etc.\n\n\n### TODO: git force-checkout\n\nDon't care about your local working copy's state and really want to switch to\nanother branch? git force-checkout lets you do this.\n\nSwitching branches can be prevented by git. For good reasons, mostly. Git is\ndesigned to prevent you from losing data potentially. Examples are there are\nlocal unmerged files, or some files that would be overwritten by doing the\ncheckout.\n\nBy using force-checkout you basically give git the finger, and check out\na branch anyway. **You do agree to lose data when using this command.**\n\n    $ git checkout master\n    error: Your local changes to the following files would be overwritten by checkout:\n        foo/bar.txt\n    Please, commit your changes or stash them before you can switch branches.\n    Aborting\n    $ git force-checkout master\n    Switched to branch 'master'\n\n\n### git conflicts\n\nGenerates a summary for all local branches that will merge uncleanly—i.e. will\nlead to merge conflicts later on.\n\n    $ git branch\n      develop\n    * mybranch\n      master\n      other-branch\n    $ git conflicts\n    develop... merges cleanly\n    master...  merges cleanly\n    other-branch... CONFLICTS AHEAD\n\n\n### git-skip / git-unskip / git-show-skipped\n\nGit supports marking files \"skip worktree\", meaning any change in the file\nlocally will not be shown in status reports, or be added when you stage all\nfiles.  This feature can be useful to toggle some switches locally, or\nexperiment with different settings, without running the risk of accidentally\ncommitting this local data (that should remain untouched in the repo).\n\nNotice that status reports won't show these files anymore, so it's also easily\nto lose track of these marked assumptions, and you probably run into weird\nissues if you don't remember this. (This is the reason why I put these scripts\nin the \"advanced\" category.)\n\nBasic usage:\n\n    $ git status\n     M foo.txt\n     M bar.txt\n     M qux.txt\n    $ git skip foo.txt\n    $ git status\n     M bar.txt\n     M qux.txt\n    $ git show-skipped\n    foo.txt\n    $ git commit -am 'Commit everything.'\n    $ git status\n    nothing to commit, working directory clean\n    $ git is-clean && echo \"clean\" || echo \"not clean\"\n    not clean\n    $ git unskip -a\n    $ git status\n     M foo.txt\n\nAs you can see, `git-is-clean` is aware of any lurking \"skipped\" files, and\nwon't report a clean working tree, as these assumed unchanged files often block\nthe ability to check out different branches.\n\n\n### git wip\n\nCommits all local changes under a commit message of \"WIP\". Great for quickly\ncreating \"savepoint\" commits.  If there is a mix of staged changes, and\nunstaged changes, and new files, will commit each of these as a separate\ncommit, all titled \"WIP\". Effectively, running `git-wip` once will potentially\nlead to anywhere between 0 and 3 \"WIP\" commits being created.\n\n\n[coreutils]: https://www.gnu.org/software/coreutils/\n[gitlog]: https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History#_limiting_log_output\n"
        },
        {
          "name": "git-active-branches",
          "type": "blob",
          "size": 1.3017578125,
          "content": "#!/bin/sh\nset -eu\n\nDEFAULT_SINCE='3.weeks.ago'\nsince=$DEFAULT_SINCE\n\nusage() {\n    echo \"usage: git active-branches [-s|-a <date>]\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-s      show branches active since <date> (as in 'git log --since')\" >&2\n    echo \"-a      (an alias for '-s')\" >&2\n    echo \"<date>  any date format recognized by 'git log'\" >&2\n    echo >&2\n    echo \"Unless specified, <date> defaults to \\\"$DEFAULT_SINCE\\\". For examples see:\" >&2\n    echo \"https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History\" >&2\n}\n\nwhile [ $# -gt 0 ]; do\n    if ! getopts a:s:h flag; then usage; exit 2; fi\n    case \"$flag\" in\n        a|s) since=$OPTARG; shift ;;\n        \\?)  usage; exit 2 ;;  # argument missing its option\n        h)   usage; exit 2 ;;\n    esac\n    shift\ndone\n\ngit local-branches | while read branch; do\n    # '--no-patch' = suppress diff output (long form of '-s')\n    maybebranch=$(\n        git log -1 --since=\"$since\" --no-patch \"refs/heads/$branch\" --\n    )\n    if [ -n \"$maybebranch\" ]; then\n        echo \"$branch\"\n    fi\ndone\n\ngit remote-branches | while read branch; do\n    # '--no-patch' = suppress diff output (long form of '-s')\n    maybebranch=$(\n        git log -1 --since=\"$since\" --no-patch \"$branch\" --\n    )\n    if [ -n \"$maybebranch\" ]; then\n        echo \"$branch\"\n    fi\ndone\n"
        },
        {
          "name": "git-autofixup",
          "type": "blob",
          "size": 0.5078125,
          "content": "#!/bin/sh\nset -e\n\nmake_relative () {\n    while read f; do\n        git relative-path \"$f\"\n    done\n}\n\nFILES=\"$(git diff --no-prefix --cached -U0 | awk '/^--- / { print $2 }' | grep -vF /dev/null | make_relative)\"\nif [ -z \"$FILES\" ]; then\n  echo \"No staged files found that have previously been committed.\" >&2\n  exit 2\nfi\n\nSHA=\"$(git last-commit-to-file $FILES)\"\n\nif [ -n \"$SHA\" ]; then\n  git commit --fixup \"$SHA\" --no-verify\nelse\n  echo \"Could not determine which commit last touched the staged files.\" >&2\n  exit 3\nfi\n"
        },
        {
          "name": "git-branches-containing",
          "type": "blob",
          "size": 0.0400390625,
          "content": "#!/bin/sh\n\ngit branch -a --contains \"$@\"\n"
        },
        {
          "name": "git-cherry-pick-to",
          "type": "blob",
          "size": 0.6220703125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git cherry-pick-to <branch> ...\" >&2\n}\n\nif [ $# -eq 0 ]; then\n    usage\n    exit 2\nfi\n\nbranch=\"$1\"\nshift 1\n\nif git is-dirty -a; then\n    echo 'Cannot use this command safely when you have local files marked \"skipped\".' >&2\n    exit 2\nfi\n\n# TODO: FIXME: There is a lot that can go wrong here.  Basically, that's not\n# a problem at all in itself, but we need a mechanism to reliably recover back\n# to the starting position.\ngit stash-everything\ncommit=$(git sha HEAD)\norig_branch=$(git current-branch)\ngit checkout \"$branch\"\ngit cherry-pick \"$commit\"\ngit checkout \"$orig_branch\"\ngit stash pop\n"
        },
        {
          "name": "git-cleanup",
          "type": "blob",
          "size": 6.029296875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git cleanup [-lr] [-nsvh]\" >&2\n    echo >&2\n    echo \"Deletes all branches that have already been merged into the main branch.\" >&2\n    echo \"Removes those branches both locally or in the origin remote (or both).\" >&2\n    echo \"Will be most conservative with deletions.\" >&2\n    echo >&2\n    echo \"Minimally requires either (or both) of these flags to be set:\" >&2\n    echo \"-l    Remove local branches\" >&2\n    echo \"-r    Remove remote branches (in \\`origin\\`)\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-n    Dry-run\" >&2\n    echo \"-s    Also consider squash merges (implies -l)\" >&2\n    echo \"-v    Be verbose (show what's skipped)\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\ndryrun=0\nlocals=0\nremotes=0\nsquashed=0\nverbose=0\nwhile getopts nlrsvh flag; do\n    case \"$flag\" in\n        n) dryrun=1;;\n        l) locals=1;;\n        r) remotes=1;;\n        s) squashed=1; locals=1;;\n        v) verbose=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $remotes -eq 0 ] && [ $locals -eq 0 ]; then\n    usage\n    exit 1\nfi\n\n#\n# This will clean up any branch (both locally and remotely) that has been\n# merged into any of the known \"trunks\".  Trunks are any of:\n#\n#   - main (local) + origin/main\n#   - master (local) + origin/master\n#\n\nsafegit () {\n    if [ \"$dryrun\" -eq 1 ]; then\n        echo git \"$@\"\n    else\n        git \"$@\"\n    fi\n}\n\n#\n# The Algorithm[tm]:\n# - Find the smallest set of common ancestors for those trunks.  (There can\n#   actually be multiple, although unlikely.)\n# - For each local branch, check if any of the common ancestors contains it,\n#   but not vice-versa (prevents newly-created branches from being deleted)\n# - Idem for each remote branch\n#\n\nfind_common_base () {\n    if [ $# -eq 1 ]; then\n        git sha \"$1\"\n    else\n        git merge-base \"$1\" \"$2\"\n    fi\n}\n\nfind_branch_base () {\n    branch=\"$1\"\n    base_point=\"\"\n\n    if git local-branch-exists \"$branch\"; then\n        base_point=$(find_common_base \"$branch\" $base_point)\n    fi\n\n    if git remote-branch-exists origin \"$branch\"; then\n        base_point=$(find_common_base \"origin/$branch\" $base_point)\n    fi\n\n    if [ -n \"$base_point\" ]; then\n        echo \"$base_point\"\n    fi\n}\n\nmain=\"$(git main-branch)\"\n\nfind_bases () {\n    find_branch_base \"$main\"\n}\n\nbases=$(find_bases)\n\n#\n# The Clean Squashed Algorithm[tm]\n# - Create a temporary dangling squashed commit with git commit-tree\n# - Then use git cherry to check if the squashed commit has already been\n#   applied to the main branch\n# - If it has, then delete the branch\n#\n\nclean_squashed () {\n    branch=\"$1\"\n\n    # Find the merge base for this branch\n    merge_base=$(git merge-base \"$main\" \"$branch\")\n\n    # Get the tree object of the branch\n    branch_tree=\"$(git rev-parse \"$branch^{tree}\")\"\n\n    # Create a squashed commit object of the branch tree with parent\n    # of $base with a commit message of \"_\"\n    dangling_squashed_commit=\"$(git commit-tree \"$branch_tree\" -p \"$merge_base\" -m _)\"\n\n    # Show a summary of what has yet to be applied\n    cherry_commit=\"$(git cherry \"$main\" \"$dangling_squashed_commit\")\"\n\n    if [ \"$cherry_commit\" = \"- $dangling_squashed_commit\" ]; then\n        # If \"- <commit-sha>\", (ex. - \"- 851cb44727\") this means the\n        # commit is in main and can be dropped if you rebased\n        # against main\n        safegit branch -D \"$branch\"\n    elif [ $verbose -eq 1 ]; then\n        # If \"+ <commit-sha>\", (ex. - \"+ 851cb44727\") this means the\n        # commit still needs to be kept so that it will be applied to\n        # main\n        echo \"Skipped $branch (no similar squash found)\"\n    fi\n}\n\nif [ $locals -eq 1 ]; then\n    for branch in $(git local-branches \\\n                    | grep -vxF \"$main\"); do\n        for base in $bases; do\n            if git contains \"$base\" \"$branch\"; then\n                if ! git contains \"$branch\" \"$base\"; then\n                    # Actually delete\n                    if ! safegit branch -D \"$branch\"; then\n                        echo \"Errors deleting local branch $branch\" >&2\n                    fi\n                    break\n                fi\n            else\n                # This is the case where the branches are in fact legit\n                # local WIP branches or they are squashed merges, and we\n                # need to check if they have been squashed-merged into\n                # main. NOTE - this assumes main is up-to-date locally\n                if [ \"$squashed\" -eq 1 ]; then\n                    clean_squashed \"$branch\"\n                fi\n            fi\n        done\n    done\nfi\n\n# Pruning first will remove any remote tracking branches that don't exist in\n# the remote anymore anyway.\nif [ $remotes -eq 1 ]; then\n    remote=origin\n    safegit remote prune \"$remote\" >/dev/null 2>/dev/null\n\n    if [ $remotes -eq 1 ]; then\n        branches_to_remove=\"\"\n        for branch in $(git remote-branches \"$remote\" | grep -vEe \"/($main)\\$\"); do\n            for base in $bases; do\n                if git contains \"$base\" \"$branch\"; then\n                    if ! git contains \"$branch\" \"$base\"; then\n                        branchname=$(echo \"$branch\" | cut -d/ -f2-)\n                        branches_to_remove=\"$branches_to_remove $branchname\"\n                        break\n                    fi\n                fi\n            done\n        done\n\n        if [ -n \"$branches_to_remove\" ]; then\n            if ! safegit push \"$remote\" --delete $branches_to_remove; then\n                echo \"Errors deleting branches $branches_to_remove from remote '$remote'\" >&2\n            fi\n        fi\n    fi\nfi\n\n# Delete any remaining local remote-tracking branches of remotes that are gone.\nif [ $locals -eq 1 ]; then\n    branches_to_remove=\"\"\n    for branch in $(git remote-branches); do\n        for base in $bases; do\n            if git contains \"$base\" \"$branch\"; then\n                if ! git contains \"$branch\" \"$base\"; then\n                    branches_to_remove=\"$branches_to_remove $branch\"\n                    break\n                fi\n            fi\n        done\n    done\n\n    if [ -n \"$branches_to_remove\" ]; then\n        safegit branch -dr $branches_to_remove\n    fi\nfi\n"
        },
        {
          "name": "git-cleave",
          "type": "blob",
          "size": 2.67578125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git cleave [-h] [-t <prefix>] <path1> [<path2> ...]\" >&2\n    echo >&2\n    echo \"Splits the last commit into two or more commits. Takes one or more regex values\" >&2\n    echo \"that are matched against the paths of the files from the commit.\" >&2\n    echo \"\" >&2\n    echo \"Options:\" >&2\n    echo \"-t <prefix>  Use this tag to prefix to commit messages\" >&2\n    echo \"-h           Show this help\" >&2\n}\n\nlocally_changed_files () {\n  # New files\n  git status --porcelain | grep -Ee '^\\?' | cut -c4-\n  # Changes/deleted files\n  git diff --name-only --relative\n}\n\nprefix=\nwhile getopts t:h flag; do\n    case \"$flag\" in\n        t) prefix=$OPTARG; shift ;;\n        h) usage; exit 2;;\n        *) usage; exit 2;;\n    esac\ndone\n\nmain () {\n  if [ \"$#\" -lt 1 ]; then\n    usage\n    exit 2\n  fi\n\n  # Ensure we have a clean working tree\n  git is-clean -v\n\n  ORIG_SHA=\"$(git sha HEAD)\"\n  echo \"Original commit is: $ORIG_SHA\"\n\n  LAST_COMMIT_MSG=\"$(git log --pretty='%s' -1)\"\n  git reset HEAD~1\n  BASE_SHA=\"$(git sha HEAD)\"\n\n  for expr in \"$@\"; do\n    locally_changed_files | grep -Ee \"$expr\" | while read f; do\n      git add \"$f\"\n    done\n\n    # If not using a fixed prefix, use the path match as the prefix\n    if [ -z \"$prefix\" ]; then\n      if git is-dirty -i; then\n        # This weird construct is to keep the original commit date intact\n        git commit --no-verify -C \"$ORIG_SHA\"\n        git commit --amend --no-verify -m \"[$expr] $LAST_COMMIT_MSG\"\n      fi\n    fi\n  done\n\n  # Else, if using the prefix strategy, add a single commit combining all of\n  # the path's matched\n  if [ -n \"$prefix\" ]; then\n    if git is-dirty -i; then\n      # This weird construct is to keep the original commit date intact\n      git commit --no-verify -C \"$ORIG_SHA\"\n      git commit --amend --no-verify -m \"[$prefix] $LAST_COMMIT_MSG\"\n    fi\n  fi\n\n  locally_changed_files | while read f; do\n    git add \"$f\"\n  done\n\n  # If there are leftover changes (or cleave didn't commit anything yet, in the\n  # case of an empty original commit), commit it now\n  if git is-dirty -i || [ \"$BASE_SHA\" = \"$(git sha HEAD)\" ]; then\n    git commit --allow-empty --no-verify -C \"$ORIG_SHA\"\n    git commit --allow-empty --amend --no-verify -m \"$LAST_COMMIT_MSG\"\n  fi\n\n  # Sanity check. No files may get lost during this process!\n  if ! git diff --exit-code \"$ORIG_SHA\" \"$(git sha HEAD)\"; then\n    echo \"Warning! There were differences found between the current state and the\" >&2\n    echo \"original commit.  You may want to revert back to the original commit:\" >&2\n    echo \"\" >&2\n    echo \"    git reset --hard $ORIG_SHA\" >&2\n    echo \"\" >&2\n  else\n    echo \"Success! Original commit was: $ORIG_SHA\"\n  fi\n}\n\n( cd \"$(git root)\" && main \"$@\" )\n"
        },
        {
          "name": "git-commit-to",
          "type": "blob",
          "size": 0.5205078125,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git commit-to <branch> ...\" >&2\n}\n\nif [ $# -eq 0 ]; then\n    usage\n    exit 2\nfi\n\nbranch=\"$1\"\nshift 1\n\nif git is-dirty -a; then\n    echo 'Cannot use this command safely when you have local files marked \"skipped\".' >&2\n    exit 2\nfi\n\n# TODO: FIXME: There is a lot that can go wrong here.  Basically, that's not\n# a problem at all in itself, but we need a mechanism to reliably recover back\n# to the starting position.\ngit commit \"$@\"\ngit cherry-pick-to \"$branch\"\ngit reset --hard HEAD~1\n"
        },
        {
          "name": "git-committer-info",
          "type": "blob",
          "size": 2.80078125,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git committer-info [-aAh] <pattern> [<pattern> ...]\" >&2\n    echo >&2\n    echo \"Show contribution stats for any committer matching the given pattern.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-A    Consider all branches (instead of only the current branch)\" >&2\n    echo \"-a    Print for all committers\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nall_branches=0\nall_committers=0\nwhile getopts aAh flag; do\n    case \"$flag\" in\n        a) all_committers=1;;\n        A) all_branches=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $all_committers -eq 1 ]; then\n    committers=$(git shortlog -s | cut -f2-)\nelse\n    if [ $# -eq 0 ]; then\n        usage\n        exit 2\n    fi\n    committers=$(for item in \"$@\"; do echo \"$item\"; done)\nfi\n\ncount_by_dow () {\n    awk '\n    BEGIN {\n        map[\"Mon\"] = 0\n        map[\"Tue\"] = 0\n        map[\"Wed\"] = 0\n        map[\"Thu\"] = 0\n        map[\"Fri\"] = 0\n        map[\"Sat\"] = 0\n        map[\"Sun\"] = 0\n    }\n\n    {\n        map[$1] += 1\n    }\n\n    function round(x, ival, aval, fraction)\n    {\n        ival = int(x)    # integer part, int() truncates\n     \n        # see if fractional part\n        if (ival == x)   # no fraction\n           return ival   # ensure no decimals\n     \n        if (x < 0) {\n           aval = -x     # absolute value\n           ival = int(aval)\n           fraction = aval - ival\n           if (fraction >= .5)\n              return int(x) - 1   # -2.5 --> -3\n           else\n              return int(x)       # -2.3 --> -2\n        } else {\n           fraction = x - ival\n           if (fraction >= .5)\n              return ival + 1\n           else\n              return ival\n        }\n    }\n     \n    END {\n        total = map[\"Mon\"] + map[\"Tue\"] + map[\"Wed\"] + map[\"Thu\"] + map[\"Fri\"] + map[\"Sat\"] + map[\"Sun\"]\n        printf(\"%s %6s %4s%%\\n\", \"Mon\", map[\"Mon\"], round(map[\"Mon\"] / total * 100))\n        printf(\"%s %6s %4s%%\\n\", \"Tue\", map[\"Tue\"], round(map[\"Tue\"] / total * 100))\n        printf(\"%s %6s %4s%%\\n\", \"Wed\", map[\"Wed\"], round(map[\"Wed\"] / total * 100))\n        printf(\"%s %6s %4s%%\\n\", \"Thu\", map[\"Thu\"], round(map[\"Thu\"] / total * 100))\n        printf(\"%s %6s %4s%%\\n\", \"Fri\", map[\"Fri\"], round(map[\"Fri\"] / total * 100))\n        printf(\"%s %6s %4s%%\\n\", \"Sat\", map[\"Sat\"], round(map[\"Sat\"] / total * 100))\n        printf(\"%s %6s %4s%%\\n\", \"Sun\", map[\"Sun\"], round(map[\"Sun\"] / total * 100))\n        printf(\"     -----\\n\");\n        printf(\"    %6s\\n\", total);\n    }\n    '\n}\n\nindent () {\n    sed -Ee 's/^/    /'\n}\n\nopts=\"\"\nif [ $all_branches -eq 1 ]; then\n    opts=\"--all\"\nfi\n\nfirst=1\necho \"$committers\" | while read committer; do\n    if [ $first -ne 1 ]; then\n        echo \"\"\n    else\n        first=0\n    fi\n    echo \"$committer:\"\n    git log $opts --author=\"$committer\" --format=\"%ad\" | count_by_dow | indent\ndone\n"
        },
        {
          "name": "git-conflicts",
          "type": "blob",
          "size": 1.0087890625,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git conflicts [-rqh]\" >&2\n    echo >&2\n    echo \"Compares merge outcomes against all local branches and display \" >&2\n    echo \"whether a merge would cause merge conflicts.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-r    Remote branches (default is only local branches)\" >&2\n    echo \"-q    Be quiet (only report about conflicts)\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nquiet=0\nremotes=0\nwhile getopts rqh flag; do\n    case \"$flag\" in\n        r) remotes=1;;\n        q) quiet=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif git is-dirty; then\n    echo \"Can't check when you have local changes.\" >&2\n    exit 2\nfi\n\nif [ \"$remotes\" -eq 1 ]; then\n    branches=\"$(git remote-branches)\"\nelse\n    branches=\"$(git local-branches)\"\nfi\nfor branch in $branches; do\n    if git merges-cleanly \"$branch\"; then\n        if [ $quiet -eq 0 ]; then\n            echo \"$branch... merges cleanly\"\n        fi\n    else\n        echo \"$branch... CONFLICTS AHEAD\"\n    fi\ndone\n"
        },
        {
          "name": "git-contains",
          "type": "blob",
          "size": 0.41015625,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git contains <branch> <branch>\" >&2\n    echo >&2\n    echo \"Returns whether the first branch contains the second.\" >&2\n    echo \"Will return with an exit code of 0 or 1.\" >&2\n}\n\nif [ $# -eq 2 ]; then\n    first=$1\n    second=$2\nelse\n    usage\n    exit 2\nfi\n\nsecond_sha=$(git sha \"$second\")\nancestor_sha=$(git merge-base \"$first\" \"$second\")\n[ \"$ancestor_sha\" = \"$second_sha\" ]\n"
        },
        {
          "name": "git-current-branch",
          "type": "blob",
          "size": 0.162109375,
          "content": "#!/bin/sh\nset -e\ncurr=$(git rev-parse --abbrev-ref HEAD)\nif [ \"$curr\" = \"HEAD\" ]; then\n    echo \"Not on a branch.\" >&2\n    exit 1\nelse\n    echo \"$curr\"\n    exit 0\nfi\n"
        },
        {
          "name": "git-delouse",
          "type": "blob",
          "size": 0.109375,
          "content": "#!/bin/sh\nset -e\ncurr_sha=$(git sha HEAD)\n\ngit reset HEAD~1\ngit commit --allow-empty --no-verify -C \"$curr_sha\"\n"
        },
        {
          "name": "git-diff-since",
          "type": "blob",
          "size": 0.126953125,
          "content": "#!/bin/sh\nset -e\n\nif [ $# -gt 0 ]; then\n    base=\"$1\"\n    shift 1\nelse\n    base=\"$(git main-branch)\"\nfi\n\ngit diff \"$base\"... \"$@\"\n"
        },
        {
          "name": "git-drop-local-changes",
          "type": "blob",
          "size": 0.1484375,
          "content": "#!/bin/sh\nif git is-clean; then\n    echo \"Nothing to do.\" >&2\n    exit 0\nfi\n\ngit rebase --abort 2>/dev/null || true\ngit reset --hard HEAD\ngit clean -df\n"
        },
        {
          "name": "git-fixup",
          "type": "blob",
          "size": 0.064453125,
          "content": "#!/bin/sh\nset -eu\ngit commit --amend --no-edit --allow-empty \"$@\"\n"
        },
        {
          "name": "git-fixup-with",
          "type": "blob",
          "size": 1.29296875,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git fixup-with [-r] [<base>]\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-r    When done, trigger an interactive rebase right after.\" >&2\n    echo >&2\n    echo \"Interactively lets you pick a commit from a list to fixup.\" >&2\n    echo \"\" >&2\n    echo \"The list of commits shown display commits between <base> to HEAD).\" >&2\n    echo \"<base> defaults to main branch if you're on a different branch, and\" >&2\n    echo \"defaults to \\\"origin/main\\\" when you're on main branch currently.\" >&2\n    echo \"\" >&2\n}\n\nrebase=0\nwhile getopts rh flag; do\n    case \"$flag\" in\n        r) rebase=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\n# Make sure the index is dirty, otherwise there isn\\'t anything to fixup\ngit is-dirty -i\n\nif [ $# -eq 1 ]; then\n    base=\"$1\"\nelif [ $# -eq 0 ]; then\n    main=\"$(git main-branch)\"\n    if [ \"$(git current-branch)\" = \"$main\" ]; then\n        base=\"origin/$main\"\n    else\n        base=\"$main\"\n    fi\nelse\n    usage\n    exit 2\nfi\n\nsha=\"$(git log \"${base}..\" --pretty='%h %s' | fzf | cut -d' ' -f1)\"\nif [ -z \"$sha\" ]; then\n    echo 'No commit picked' >&2\n    exit 3\nfi\n\ngit commit --fixup \"$sha\" --no-verify --allow-empty\nif [ $rebase -eq 1 ]; then\n    git rebase --interactive --autosquash --autostash --keep-empty \"$sha\"~\nfi\n"
        },
        {
          "name": "git-has-local-changes",
          "type": "blob",
          "size": 0.029296875,
          "content": "#!/bin/sh\nset -e\ngit is-clean\n"
        },
        {
          "name": "git-has-local-commits",
          "type": "blob",
          "size": 0.0966796875,
          "content": "#!/bin/sh\nset -e\n\nnum_commits=$(git local-commits --pretty=oneline | wc -l)\n[ $num_commits -gt 0 ]\n"
        },
        {
          "name": "git-initial-commit",
          "type": "blob",
          "size": 0.1513671875,
          "content": "#!/bin/sh\n\nif ! main=$(git main-branch 2>/dev/null); then\n    echo \"No commits yet\" >&2\n    exit 2\nfi\n\ngit rev-list --max-parents=0 --first-parent \"$main\"\n"
        },
        {
          "name": "git-is-ancestor",
          "type": "blob",
          "size": 0.3388671875,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git is-ancestor <branch> <branch>\" >&2\n    echo >&2\n    echo \"Returns whether the first branch is an ancestor of the second.\" >&2\n    echo \"Will return with an exit code of 0 or 1.\" >&2\n}\n\nif [ $# -eq 2 ]; then\n    first=$1\n    second=$2\nelse\n    usage\n    exit 2\nfi\n\ngit contains \"$second\" \"$first\"\n"
        },
        {
          "name": "git-is-clean",
          "type": "blob",
          "size": 2.0224609375,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git is-{clean,dirty} [-wih]\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-w    Check if worktree is {clean,dirty}\" >&2\n    echo \"-i    Check if index is {clean,dirty}\" >&2\n    echo \"-a    Check if any files are marked (un)skipped\" >&2\n    echo \"-v    Be verbose, print errors to stderr\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nis_index_clean () {\n    git diff-index --cached --quiet --ignore-submodules --exit-code HEAD --\n}\n\nhas_unstaged_changes () {\n    # As per this discussion[1], picking the 'git diff' solution over the other\n    # alternatives.  This does mean, however, that we need to check explicitly\n    # for any untracked files in the repo in another function.\n    # [1]: https://gist.github.com/sindresorhus/3898739\n    ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code\n}\n\nhas_untracked_files () {\n    num_untracked_files=$(git ls-files --other --exclude-standard | wc -l)\n    [ $num_untracked_files -gt 0 ]\n}\n\nis_worktree_clean () {\n    ! has_unstaged_changes && ! has_untracked_files\n}\n\nis_skipped () {\n    git show-skipped -q\n}\n\ncheck_index=0\ncheck_worktree=0\ncheck_skipped=0\nverbose=0\nwhile getopts iwavh flag; do\n    case \"$flag\" in\n        i) check_index=1;;\n        w) check_worktree=1;;\n        a) check_skipped=1;;\n        v) verbose=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\n# If nothing is explicitly specified, check everything\nif [ $check_index -eq 0 ] && [ $check_worktree -eq 0 ] && [ $check_skipped -eq 0 ]; then\n    check_index=1\n    check_worktree=1\n    check_skipped=1\nfi\n\nif [ $check_index -eq 1 ]; then\n    if ! is_index_clean; then\n        [ $verbose -eq 1 ] && echo \"git index not clean\" >&2\n        exit 2\n    fi\nfi\n\nif [ $check_worktree -eq 1 ]; then\n    if ! is_worktree_clean; then\n        [ $verbose -eq 1 ] && echo \"git work tree not clean\" >&2\n        exit 3\n    fi\nfi\n\nif [ $check_skipped -eq 1 ]; then\n    if ! is_skipped; then\n        [ $verbose -eq 1 ] && echo \"there are skipped files\" >&2\n        exit 4\n    fi\nfi\n\nexit 0\n"
        },
        {
          "name": "git-is-dirty",
          "type": "blob",
          "size": 0.037109375,
          "content": "#!/bin/sh\nset -eu\n! git is-clean \"$@\"\n"
        },
        {
          "name": "git-is-headless",
          "type": "blob",
          "size": 0.0498046875,
          "content": "#!/bin/sh\nset -eu\n! git current-branch 2>/dev/null\n"
        },
        {
          "name": "git-is-repo",
          "type": "blob",
          "size": 0.029296875,
          "content": "#!/bin/sh\nset -eu\ngit repo -q\n"
        },
        {
          "name": "git-last-commit-to-file",
          "type": "blob",
          "size": 0.58203125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git last-commit-to-file [-h] <file> [<file> ...]\" >&2\n    echo >&2\n    echo \"Returns the SHA of the commit that last touched the given file.\" >&2\n    echo \"If multiple files are given, will return the SHA that most-recently\" >&2\n    echo \"changed _any_ of the files.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $# -lt 1 ]; then\n    usage\n    exit 2\nfi\n\ngit log -1 --format='%H' -- \"$@\" 2>/dev/null\n"
        },
        {
          "name": "git-local-branch-exists",
          "type": "blob",
          "size": 0.27734375,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git local-branch-exists <branch>\" >&2\n    echo >&2\n    echo \"Will return with an exit code of 0 or 1.\" >&2\n}\n\nif [ $# -eq 1 ]; then\n    branch=$1\nelse\n    usage\n    exit 2\nfi\n\ngit show-ref --heads --quiet --verify -- \"refs/heads/$branch\"\n"
        },
        {
          "name": "git-local-branches",
          "type": "blob",
          "size": 0.078125,
          "content": "#!/bin/sh\nset -e\ngit branch --no-color | grep -v '(HEAD detached at' | cut -c3-\n"
        },
        {
          "name": "git-local-commits",
          "type": "blob",
          "size": 0.2197265625,
          "content": "#!/bin/sh\nset -e\n\ncurr=$(git current-branch)\nif ! git remote-branch-exists origin \"$curr\"; then\n    echo \"Branch not pushed to remote yet.\" >&2\n    exit 1\nfi\n\ngit log \"$(git merge-base origin/\"$curr\" \"$curr\")\"...\"$curr\" \"$@\"\n"
        },
        {
          "name": "git-main-branch",
          "type": "blob",
          "size": 0.1875,
          "content": "#!/bin/sh\nset -eu\n\nfor probe in main mainline master; do\n    if git local-branch-exists \"$probe\"; then\n        echo \"$probe\"\n        exit 0\n    fi\ndone\n\necho \"No main branch found\" >&2\nexit 2\n"
        },
        {
          "name": "git-merge-status",
          "type": "blob",
          "size": 0.865234375,
          "content": "#!/bin/sh\nset -eu\n    \nusage () {\n    echo \"usage: git merge-status [-h] [<branch>]\" >&2\n    echo >&2\n    echo \"Shows merge status of all local branches against branch (defaults to\" >&2\n    echo \"the main branch).\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nbulletize () {\n    sed -Ee 's/^/  - &/'\n}\n\nfail_if_empty () {\n    empty=1\n    while read line; do\n        echo \"$line\"\n        empty=0\n    done\n    test $empty -eq 0\n}\n\nif [ $# -gt 0 ]; then\n    base=\"$1\"\nelse\n    base=\"$(git main-branch)\"\nfi\n\necho \"Merged into $base:\"\nif ! git merged \"$base\" | bulletize | fail_if_empty; then\n    echo \"(no branches)\"\nfi\n\necho\necho \"Not merged into $base:\"\nif ! git merged -u \"$base\" | bulletize | fail_if_empty; then\n    echo \"(no branches)\"\nfi\n"
        },
        {
          "name": "git-merged",
          "type": "blob",
          "size": 0.6943359375,
          "content": "#!/bin/sh\nset -eu\n    \nusage () {\n    echo \"usage: git merged [-uh] [<branch>]\" >&2\n    echo >&2\n    echo \"Shows what local branches have been merged into branch (defaults to main branch).\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-u    Show unmerged branches instead of merged branches\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nunmerged=0\nwhile getopts uh flag; do\n    case \"$flag\" in\n        u) unmerged=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $unmerged -eq 1 ]; then\n    opts=\"--no-merged\"\nelse\n    opts=\"--merged\"\nfi\n\nif [ $# -gt 0 ]; then\n    base=\"$1\"\n    shift 1\nelse\n    base=\"$(git main-branch)\"\nfi\n\ngit branch $opts \"$base\" | cut -c3- | grep -vxF \"$base\"\n"
        },
        {
          "name": "git-merges-cleanly",
          "type": "blob",
          "size": 0.9814453125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git merges-cleanly [-vh] <branch>\" >&2\n    echo >&2\n    echo \"Performes a temporal merge against the given branch (but aborts or undoes\" >&2\n    echo \"the merge) and reports success or failure through the exit code.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n    echo \"-l    List conflicting files\" >&2\n}\n\nshowlist=0\nwhile getopts lh flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n        l) showlist=1;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $# -ne 1 ]; then\n    usage\n    exit 2\nfi\n\nbranch=$1\n\ngit sha -q \"$1\"\n\nif git is-dirty -iw; then\n  echo \"Can't check when you have local changes.\" >&2\n  exit 2\nfi\n\nif git merge --quiet \"$branch\" >/dev/null 2>/dev/null; then\n  git undo-merge >/dev/null 2>/dev/null\n  exit 0\nelse\n  if [ $showlist -eq 1 ]; then\n    git diff --name-only --diff-filter=U\n  fi\n\n  git merge --abort >/dev/null 2>/dev/null\n\n  if [ $showlist -eq 1 ]; then\n    exit 0\n  else\n    exit 1\n  fi\nfi\n"
        },
        {
          "name": "git-modified",
          "type": "blob",
          "size": 3.4755859375,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git modified [-iuqh] [<commit>]\" >&2\n    echo >&2\n    echo \"Prints list of files that are locally modified (and exist).  The index is not \" >&2\n    echo \"considered, unless the -i flag is provided.\" >&2\n    echo \"\" >&2\n    echo \"If a commit is provided, opens all files that locally exist that have been \" >&2\n    echo \"changed in that commit.\" >&2\n    echo >&2\n    echo \"This script is ideal for passing all locally modified files into your editor, like:\" >&2\n    echo '    $ vim `git modified`' >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-m    Modified files only (excludes untracked files)\" >&2\n    echo \"-i    Consider the index, too\" >&2\n    echo \"-u    Print only files that are unmerged (files with conflicts)\" >&2\n    echo \"-q    Be quiet, only return with 0 exit code when files are modified\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nmodified=0\nindex=0\nunmerged=0\nquiet=0\nwhile getopts miuqh flag; do\n    case \"$flag\" in\n        m) modified=1;;\n        i) index=1;;\n        u) unmerged=1;;\n        q) quiet=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\ncommit=\"\"\nif [ $# -ge 1 ]; then\n    commit=\"$1\"\nfi\n\n#\n# git status cheat sheet:\n#\n# X          Y     Meaning\n# -------------------------------------------------\n#           [MD]   not updated\n# M        [ MD]   updated in index\n# A        [ MD]   added to index\n# D         [ M]   deleted from index\n# R        [ MD]   renamed in index\n# C        [ MD]   copied in index\n# [MARC]           index and work tree matches\n# [ MARC]     M    work tree changed since index\n# [ MARC]     D    deleted in work tree\n# -------------------------------------------------\n# D           D    unmerged, both deleted\n# A           U    unmerged, added by us\n# U           D    unmerged, deleted by them\n# U           A    unmerged, added by them\n# D           U    unmerged, deleted by us\n# A           A    unmerged, both added\n# U           U    unmerged, both modified\n# -------------------------------------------------\n# ?           ?    untracked\n# !           !    ignored\n# -------------------------------------------------\n\nstatus () {\n    git status --porcelain | grep -vEe '^.D' | grep -vEe '^D '\n}\n\nfix_rename_notation () {\n    sed -Ee 's/.* -> (.*)/\\1/'\n}\n\nmake_relative () {\n    while read f; do\n        git relative-path \"$f\"\n    done\n}\n\nmodified_in_index () {\n    status | cut -c 4- | fix_rename_notation | make_relative\n}\n\nmodified_unmerged () {\n    status | grep -Ee '^(U.|.U)' | cut -c 4- | fix_rename_notation | make_relative\n}\n\nmodified_only_locally () {\n    status | cut -c 2- | grep -Ee '^M' | cut -c 3- | fix_rename_notation | make_relative\n}\n\nmodified_locally () {\n    status | cut -c 2- | grep -vEe '^[ ]' | cut -c 3- | fix_rename_notation | make_relative\n}\n\nfail_if_empty () {\n    empty=1\n    while read line; do\n        if [ $quiet -eq 0 ]; then\n            echo \"$line\"\n        fi\n        empty=0\n    done\n    test $empty -eq 0\n}\n\nif [ -z \"$commit\" ]; then\n    if [ $unmerged -eq 1 ]; then\n        modified_unmerged | fail_if_empty\n    elif [ $index -eq 1 ]; then\n        modified_in_index | fail_if_empty\n    elif [ $modified -eq 1 ]; then\n        modified_only_locally | fail_if_empty\n    else\n        modified_locally | fail_if_empty\n    fi\nelse\n    TAB=\"\t\" # literal tab char\n    git log -1 --name-status --pretty=format:\"\" \"$commit\" | cut -f2- | rev | cut -d\"$TAB\" -f1 | rev | make_relative | while read f; do\n        if [ -f \"$f\" ]; then\n            echo \"$f\"\n        fi\n    done | fail_if_empty\nfi\n"
        },
        {
          "name": "git-modified-since",
          "type": "blob",
          "size": 1.1259765625,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git modified-since [-iuqh] [<commit>]\" >&2\n    echo >&2\n    echo \"Prints list of files that have been modified since the given branch.\" >&2\n    echo \"Defaults to the repo's default branch.\" >&2\n    echo \"\" >&2\n    echo \"This script is ideal for passing all locally modified files into your editor, like:\" >&2\n    echo '    $ vim `git modified-since`' >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-q    Be quiet, only return with 0 exit code when files are modified\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nquiet=0\nwhile getopts qh flag; do\n    case \"$flag\" in\n        q) quiet=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\ncommit=\"$(git main-branch)\"\nif [ $# -ge 1 ]; then\n    commit=\"$1\"\nfi\n\nmake_relative () {\n    while read f; do\n        git relative-path \"$f\"\n    done\n}\n\nget_changed_files () {\n    git diff --stat --name-only \"$commit\"... -- | make_relative\n}\n\nfail_if_empty () {\n    empty=1\n    while read line; do\n        if [ $quiet -eq 0 ]; then\n            echo \"$line\"\n        fi\n        empty=0\n    done\n    test $empty -eq 0\n}\n\nget_changed_files | fail_if_empty\n"
        },
        {
          "name": "git-push-current",
          "type": "blob",
          "size": 0.59765625,
          "content": "#!/bin/sh\nset -e\n    \nusage () {\n    echo \"usage: git push-current [-fh] [<remote>]\" >&2\n    echo >&2\n    echo \"Pushes the current branch to the given remote.  Assumes 'origin' by default.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-f    Force push (will use a lease)\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nforce=0\nwhile getopts fh flag; do\n    case \"$flag\" in\n        f) force=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\ncurr=$(git current-branch)\nremote=${1-origin}\n\nopts=\"\"\nif [ $force -eq 1 ]; then\n    opts=\"--force-with-lease\"\nfi\n\ngit push $opts -u \"$remote\" \"$curr\"\n"
        },
        {
          "name": "git-recent-branches",
          "type": "blob",
          "size": 0.419921875,
          "content": "#!/bin/sh\nset -eu\n    \nusage () {\n    echo \"usage: git recent-branches [-h]\" >&2\n    echo >&2\n    echo \"Shows a list of local branches, ordered by their date (most recent one first).\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\n\ngit for-each-ref --sort=-committerdate refs/heads/ --format='%(refname:short)'\n"
        },
        {
          "name": "git-relative-path",
          "type": "blob",
          "size": 0.5810546875,
          "content": "#!/bin/sh\nset -e\n\nroot=\"$(git root)\"\nrealpath_bin=\"$(which grealpath realpath 2>/dev/null | head -n1 || true)\"\n\nif [ ! -x \"$realpath_bin\" ]; then\n    echo \"'realpath' or 'grealpath' utility not found. Please install GNU coreutils.\" >&2\n    exit 1\nfi\n\nif ! \"$realpath_bin\" --version 2>/dev/null | grep -q GNU; then\n    echo \"I expected the 'realpath' utility to be the GNU version.\" >&2\n    echo \"$realpath_bin: not the GNU version\" >&2\n    echo \"Please install GNU coreutils and try again.\" >&2\n    exit 2\nfi\n\nwhile [ $# -gt 0 ]; do\n    \"$realpath_bin\" --relative-to=. \"$root/$1\"\n    shift\ndone\n"
        },
        {
          "name": "git-remote-branch-exists",
          "type": "blob",
          "size": 0.359375,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git remote-branch-exists [<remote>] <branch>\" >&2\n    echo >&2\n    echo \"Will return with an exit code of 0 or 1.\" >&2\n}\n\nif [ $# -eq 1 ]; then\n    remote=origin\n    branch=$1\nelif [ $# -eq 2 ]; then\n    remote=$1\n    branch=$2\nelse\n    usage\n    exit 2\nfi\n\ngit show-ref --quiet --verify -- \"refs/remotes/$remote/$branch\"\n"
        },
        {
          "name": "git-remote-branches",
          "type": "blob",
          "size": 0.3076171875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"git remote-branches [<remote>]\"\n}\n\nremote_branches () {\n    git branch --remotes --no-color \\\n        | grep -v ' -> ' \\\n        | cut -c3-\n}\n\nif [ $# -eq 1 ]; then\n    remote_branches | grep -Ee \"^$1/\"\nelif [ $# -eq 0 ]; then\n    remote_branches\nelse\n    usage\n    exit 2\nfi\n"
        },
        {
          "name": "git-remote-tracking-branch",
          "type": "blob",
          "size": 0.697265625,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git remote-tracking-branch [-h] [<branch>]\" >&2\n    echo >&2\n    echo \"Prints the fully qualified name of the remote tracking\" >&2\n    echo \"branch for the given local branch name.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $# -gt 1 ]; then\n  usage\n  exit 2\nfi\n\nbranch=\"${1:-}\"\n\n# This result is constructed so that it only prints the output of\n# git-rev-parse if the command succeeded, and is silent otherwise\nresult=\"$(git rev-parse --symbolic-full-name --abbrev-ref \"${branch}@{u}\" 2>/dev/null)\"\necho \"$result\"\n"
        },
        {
          "name": "git-repo",
          "type": "blob",
          "size": 0.4658203125,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git repo [-qh]\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-q    Quiet (only return with exit code 0 if a git repo is found)\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nquiet=0\nwhile getopts qh flag; do\n    case \"$flag\" in\n        q) quiet=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $quiet -eq 1 ]; then\n    git rev-parse --git-dir >/dev/null 2>/dev/null\nelse\n    git rev-parse --git-dir\nfi\n"
        },
        {
          "name": "git-root",
          "type": "blob",
          "size": 0.046875,
          "content": "#!/bin/sh\nset -eu\ngit rev-parse --show-toplevel\n"
        },
        {
          "name": "git-separator",
          "type": "blob",
          "size": 0.216796875,
          "content": "#!/bin/sh\nset -e\n\n# Make sure we don't accidentally commit staged files\ngit is-clean -i\n\ngit commit \\\n    --allow-empty \\\n    --no-verify \\\n    -m '------------------------------------------------------------------------'\n"
        },
        {
          "name": "git-sha",
          "type": "blob",
          "size": 0.8203125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git sha [-sq] [<object>]\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-s    Output short SHAs\" >&2\n    echo \"-q    Be quiet (only return exit code 0 when object exists)\" >&2\n    echo \"-h    Show this help\" >&2\n    echo >&2\n    echo \"<object> defaults to HEAD\"\n}\n\nshort=0\nquiet=0\nwhile getopts sqh flag; do\n    case \"$flag\" in\n        s) short=1;;\n        q) quiet=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $# -eq 1 ]; then\n    object=$1\nelse\n    object=\"HEAD\"\nfi\n\nopts=\"\"\nif [ $short -eq 1 ]; then\n    opts=\"--short\"\nfi\n\nset +e\noutput=$(git rev-parse $opts \"$object\" 2>/dev/null)\nstatus=$?\nset -e\nif [ $status -ne 0 ]; then\n    echo \"Invalid object: '$object'\" >&2\n    exit 1\nelse\n    if [ $quiet -eq 0 ]; then\n        echo \"$output\"\n    fi\n    exit 0\nfi\n"
        },
        {
          "name": "git-shatter-by-file",
          "type": "blob",
          "size": 0.9580078125,
          "content": "#!/bin/sh\nset -e\n\nlocally_changed_files () {\n  # New files\n  git status --porcelain | grep -Ee '^\\?' | cut -c4-\n  # Changes/deleted files\n  git diff --name-only --relative\n}\n\nmain () {\n  # Ensure we have a clean working tree\n  git is-clean -wiv\n\n  ORIG_SHA=\"$(git sha HEAD)\"\n  echo \"Original commit is: $ORIG_SHA\"\n\n  LAST_COMMIT_MSG=\"$(git log --pretty='%s' -1)\"\n  git delouse\n\n  locally_changed_files | while read f; do\n    git add \"$f\"\n    git commit --no-verify -C \"$ORIG_SHA\"\n    git commit --amend --no-verify -m \"$LAST_COMMIT_MSG @ $f\"\n  done\n\n  # Sanity check\n  if ! git diff --exit-code \"$ORIG_SHA\" \"$(git sha HEAD)\"; then\n    echo \"Warning! There were differences found between the current state and the\" >&2\n    echo \"original commit.  You may want to revert back to the original commit:\" >&2\n    echo \"\" >&2\n    echo \"    git reset --hard $ORIG_SHA\" >&2\n    echo \"\" >&2\n  else\n    echo \"Success! Original commit was: $ORIG_SHA\"\n  fi\n}\n\n( cd \"$(git root)\" && main \"$@\" )\n"
        },
        {
          "name": "git-show-skipped",
          "type": "blob",
          "size": 0.6435546875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git show-skipped [-qh] <file> [<file> ...]\" >&2\n    echo >&2\n    echo \"Lists all files that are skipped from the index.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-q    Be quiet (just return a non-zero exit code when files are skipped)\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nquiet=0\nwhile getopts qh flag; do\n    case \"$flag\" in\n        q) quiet=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nlist_skipped () {\n    git ls-files -v | grep \"^S\" | cut -c3-\n}\n\nif [ $quiet -eq 0 ]; then\n    list_skipped\nelse \n    num_changed=$(list_skipped | wc -l)\n    test $num_changed -eq 0\nfi\n"
        },
        {
          "name": "git-skip",
          "type": "blob",
          "size": 0.9296875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git skip [-ah] <file> [<file> ...]\" >&2\n    echo >&2\n    echo \"Skip (ignore) local changes to git-aware files to prevent them from\" >&2\n    echo \"showing up in status reports or diffs, as if they haven't been changed\" >&2\n    echo \"locally at all.\" >&2\n    echo >&2\n    echo \"To reset, use git-unskip.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-a    Skip all locally modified files\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nall=0\nwhile getopts ah flag; do\n    case \"$flag\" in\n        a) all=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nlocally_modified_files () {\n    git status --porcelain --untracked-files=no | cut -c 2- | grep -Ee '^[MD]' | cut -c 3-\n}\n\nif [ $all -eq 1 ]; then\n    git update-index --skip-worktree $(locally_modified_files)\nelse\n    if [ $# -gt 0 ]; then\n        git update-index --skip-worktree \"$@\"\n    else\n        usage\n        exit 2\n    fi\nfi\n"
        },
        {
          "name": "git-spinoff",
          "type": "blob",
          "size": 1.65234375,
          "content": "#!/bin/sh\nset -eu\n\n#\n# Inspired by Magit's super useful `magit-branch-spinoff` command.\n# See also https://magit.vc/manual/magit/Branch-Commands.html\n#\n\nusage () {\n    echo \"usage: git spinoff [-h] <new-name> [<base>]\" >&2\n    echo >&2\n    echo \"Creates and checks out a new branch starting at and tracking the\" >&2\n    echo \"current branch.  That branch in turn is reset to the last commit it\" >&2\n    echo \"shares with its upstream.  If the current branch has no upstream or no\" >&2\n    echo \"unpushed commits, then the new branch is created anyway and the\" >&2\n    echo \"previously current branch is not touched.\" >&2\n    echo >&2\n    echo \"This is useful to create a feature branch after work has already\" >&2\n    echo \"began on the old branch (likely but not necessarily \\\"main\\\").\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $# -lt 1 ] || [ $# -gt 2 ]; then\n  usage\n  exit 2\nfi\n\nnew_name=\"$1\"\nrawbase=\"${2:-}\"\nif [ -z \"$rawbase\" ]; then\n    base=\"$(git current-branch)\"\nelse\n    base=\"$rawbase\"\nfi\n\nbase_sha=\"$(git sha -s \"$base\")\"\n\n#\n# NOTE:\n# The flag -B is the transactional equivalent of\n#     $ git branch -f <branch> [<start point>]\n#     $ git checkout <branch>\n#\ngit checkout -q --track -B \"$new_name\" \"$base\"\n\nrtb=\"$(git remote-tracking-branch \"$base\")\"\nif [ -n \"$rtb\" ]; then\n    merge_base=\"$(git merge-base \"$base\" \"$rtb\")\"\n    git branch -vf \"$base\" \"$merge_base\"\nfi\n\nif [ \"$(git sha -s \"$base\")\" != \"$base_sha\" ]; then\n    echo \"$base reset to $(git sha -s \"$base\") (was $base_sha)\"\nelse\n    echo \"$base not touched\"\nfi\n"
        },
        {
          "name": "git-stage-all",
          "type": "blob",
          "size": 0.03515625,
          "content": "#!/bin/sh\nset -e\ngit add --all \"$@\"\n"
        },
        {
          "name": "git-stash-everything",
          "type": "blob",
          "size": 0.0732421875,
          "content": "#!/bin/sh\nset -eu\n\ngit stash push --no-keep-index --include-untracked \"$@\"\n"
        },
        {
          "name": "git-sync-commit-date",
          "type": "blob",
          "size": 1.169921875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git sync-commit-date [-fq]\" >&2\n    echo >&2\n    echo \"Rewrites the HEAD commit by setting the commit date to the author date.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-f    Don't verify\" >&2\n    echo \"-q    Be quiet\" >&2\n    echo \"-h    Show this help\" >&2\n    echo >&2\n    echo \"<commit> defaults to HEAD\"\n}\n\nverbose=1\nforce=0\nwhile getopts fqh flag; do\n    case \"$flag\" in\n        f) force=1;;\n        q) verbose=0;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\n# Enforce we're in a clean work tree\ngit is-clean -iv\n\nauthor_date=$(git log --pretty='%aI' -1 HEAD)\ncommit_date=$(git log --pretty='%cI' -1 HEAD)\n\nif [ \"$author_date\" = \"$commit_date\" ]; then\n    if [ $verbose -eq 1 ]; then\n        echo \"Already the same\" >&2\n    fi\n    exit 0\nfi\n\nif [ $force = 0 ]; then\n    echo \"Reset last commit date to $author_date? [yN] \" >&2\n    read answer\n    if [ \"$answer\" != \"y\" ]; then\n        exit 1\n    fi\nfi\n\nOLD_SHA=$(git sha -s)\nGIT_COMMITTER_DATE=\"$author_date\" git commit --quiet --no-verify --amend --allow-empty -C HEAD\n\nif [ $verbose -eq 1 ]; then\n    echo \"Created $(git sha -s) (previous was ${OLD_SHA})\" >&2\nfi\n"
        },
        {
          "name": "git-tag-exists",
          "type": "blob",
          "size": 0.2578125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git tag-exists <tag>\" >&2\n    echo >&2\n    echo \"Will return with an exit code of 0 or 1.\" >&2\n}\n\nif [ $# -eq 1 ]; then\n    tag=$1\nelse\n    usage\n    exit 2\nfi\n\ngit show-ref --tags --quiet --verify -- \"refs/tags/$tag\"\n"
        },
        {
          "name": "git-trash",
          "type": "blob",
          "size": 0.3642578125,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git trash\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif git-is-clean; then\n    echo \"Nothing to trash.\"\n    exit 0\nfi\n\ngit add --all\ngit commit -m 'Trash'\ngit reset --hard HEAD^\n"
        },
        {
          "name": "git-undo-commit",
          "type": "blob",
          "size": 0.6376953125,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git undo-commit [-fh] <file> [<file> ...]\" >&2\n    echo >&2\n    echo \"Remove the last commit, but keep its changes staged (like right before the commit).\" >&2\n    echo \"If you specify the -f flag, it removes the changes too.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-f    Don't keep the commit's changes (destructive)\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nforce=0\nwhile getopts fh flag; do\n    case \"$flag\" in\n        f) force=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $force -eq 1 ]; then\n    opts=\"--hard\"\nelse\n    opts=\"--soft\"\nfi\n\ngit reset $opts HEAD~1\n"
        },
        {
          "name": "git-undo-merge",
          "type": "blob",
          "size": 0.04296875,
          "content": "#!/bin/sh\nset -e\ngit reset --hard ORIG_HEAD\n"
        },
        {
          "name": "git-unmerged",
          "type": "blob",
          "size": 0.0361328125,
          "content": "#!/bin/sh\nset -eu\ngit merged -u \"$@\"\n"
        },
        {
          "name": "git-unskip",
          "type": "blob",
          "size": 0.6796875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git unskip [-ah] <file> [<file> ...]\" >&2\n    echo >&2\n    echo \"Stop skipping local changes to files known to git.\" >&2\n    echo \"This resets the result of git-skip to normal again.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-a    Unskip all files\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nall=0\nwhile getopts ah flag; do\n    case \"$flag\" in\n        a) all=1;;\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif [ $all -eq 1 ]; then\n    git update-index --no-skip-worktree $(git show-skipped)\nelse\n    if [ $# -gt 0 ]; then\n        git update-index --no-skip-worktree \"$@\"\n    else\n        usage\n        exit 2\n    fi\nfi\n"
        },
        {
          "name": "git-unstage-all",
          "type": "blob",
          "size": 0.037109375,
          "content": "#!/bin/sh\nset -eu\ngit reset HEAD \"$@\"\n"
        },
        {
          "name": "git-update-all",
          "type": "blob",
          "size": 1.529296875,
          "content": "#!/bin/sh\nset -e\n\nusage () {\n    echo \"usage: git update-all [-h] [remote]\" >&2\n    echo >&2\n    echo \"Updates (pulls) upstream changes on all local branches.\" >&2\n    echo \"remote defaults to origin.\" >&2\n    echo >&2\n    echo \"Options:\" >&2\n    echo \"-h    Show this help\" >&2\n}\n\nwhile getopts h flag; do\n    case \"$flag\" in\n        h) usage; exit 2;;\n    esac\ndone\nshift $(($OPTIND - 1))\n\nif git is-dirty; then\n    echo \"Cannot do this while your working copy has local changes.  Stash or commit them first.\" >&2\n    exit 2\nfi\n\nremote=${1:-origin}\n\ncurr=$(git current-branch)\ngit fetch --quiet\n\nfor branch in $(git local-branches); do\n    if git remote-branch-exists \"$remote\" \"$branch\"; then\n        if [ \"$branch\" != \"$(git current-branch)\" ]; then\n            git checkout --quiet \"$branch\" >/dev/null 2>/dev/null\n        fi\n\n        orig_sha=$(git sha -s \"$branch\")\n        new_sha=$(git sha -s \"$remote\"/\"$branch\")\n        if [ \"$orig_sha\" != \"$new_sha\" ] && git contains \"$remote\"/\"$branch\" \"$branch\"; then\n            if git merge --quiet --ff-only \"$remote/$branch\"; then\n                echo \"updated '$branch' to latest '$remote/$branch' ($orig_sha...$new_sha)\"\n            else\n                echo \"warning: could not fast-forward '$branch' to '$remote/$branch': branches have diverged.\" >&2\n            fi\n        else\n            echo \"skipping: branch '$branch' is already up-to-date or newer than '$remote/$branch'\" >&2\n        fi\n    else\n        echo \"skipping: branch '$branch' is not on '$remote'\" >&2\n    fi\ndone\ngit checkout --quiet \"$curr\"\n"
        },
        {
          "name": "git-wip",
          "type": "blob",
          "size": 0.25,
          "content": "#!/bin/sh\nset -e\n\ncreate_wip_commit () {\n    if git is-dirty -i; then\n        git commit -m WIP\n    fi\n}\n\ncreate_wip_commit\n\nif git is-dirty -w; then\n    git add -u\n    create_wip_commit\nfi\n\nif git is-dirty -w; then\n    git add -A\n    create_wip_commit\nfi\n"
        },
        {
          "name": "git-workon",
          "type": "blob",
          "size": 0.5361328125,
          "content": "#!/bin/sh\nset -eu\n\nusage () {\n    echo \"usage: git workon <branch>\" >&2\n}\n\nif [ $# -eq 1 ]; then\n    branch=$1\nelse\n    usage\n    exit 2\nfi\n\nif git local-branch-exists \"$branch\"; then\n    git checkout \"$branch\"\nelse\n    if git remote-branch-exists origin \"$branch\"; then\n        git checkout -b \"$branch\" \"origin/$branch\"\n    else\n        echo \"Unknown branch '$branch'.\" >&2\n        exit 1\n    fi\nfi\n\n# Set upstream if remote tracking branch exists\nif git remote-branch-exists origin \"$branch\"; then\n    git branch -u \"origin/$branch\" \"$branch\"\nfi\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}