{
  "metadata": {
    "timestamp": 1736568430935,
    "page": 389,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "silinternational/ecs-deploy",
      "stars": 1973,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.056640625,
          "content": "*.aes\nlocal.env\ndef\nnewdef\nresults\ntasks\n.idea/\ndockercfg\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.056640625,
          "content": "*.aes\nlocal.env\ndef\nnewdef\nresults\ntasks\n.idea/\ndockercfg\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3701171875,
          "content": "FROM alpine:3.13\n\n# Install required packages\nRUN apk --no-cache add ca-certificates curl bash jq py3-pip && \\\n    pip install awscli\n\nCOPY ecs-deploy /usr/local/bin/ecs-deploy\nRUN chmod a+x /usr/local/bin/ecs-deploy\nRUN ln -s /usr/local/bin/ecs-deploy /ecs-deploy\n\nCOPY test.bats /test.bats\nCOPY run-tests.sh /run-tests.sh\nRUN chmod a+x /run-tests.sh\n\nENTRYPOINT [\"ecs-deploy\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 SIL International\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.189453125,
          "content": "# ecs-deploy\n\n![Status for silinternational/ecs-deploy](https://github.com/silinternational/ecs-deploy/actions/workflows/ci.yml/badge.svg?branch=master)\n\nThis script uses the Task Definition and Service entities in Amazon's ECS to instigate an automatic blue/green deployment.\n\n## NOTE: Maintenance Only\n\n`ecs-deploy` is now in maintenance mode. In other words, we are considering it\n\"feature complete\" and will generally only consider PRs if they are bugfixes or\nare to add support for new AWS CLI features.\n\n## Usage\n\n    One of the following is required:\n        -n | --service-name     Name of service to deploy\n        -d | --task-definition  Name of task definition to deploy\n\n    Required arguments:\n        -k | --aws-access-key         AWS Access Key ID. May also be set as environment variable AWS_ACCESS_KEY_ID\n        -s | --aws-secret-key         AWS Secret Access Key. May also be set as environment variable AWS_SECRET_ACCESS_KEY\n        -r | --region                 AWS Region Name. May also be set as environment variable AWS_DEFAULT_REGION\n        -p | --profile                AWS Profile to use - If you set this aws-access-key, aws-secret-key and region are not needed\n           | --aws-instance-profile   Use the IAM role associated with the current AWS instance. Can only be used from within a running AWS instance. If you set this, aws-access-key and aws-secret-key are not needed\n        -c | --cluster                Name of ECS cluster\n        -n | --service-name           Name of service to deploy\n        -i | --image                  Name of Docker image to run, ex: repo/image:latest\n                                      Format: [domain][:port][/repo][/][image][:tag]\n                                      Examples: mariadb, mariadb:latest, private.registry.com:8000/repo/image:tag\n\n    Optional arguments:\n        -a | --aws-assume-role        ARN for AWS Role to assume for ecs-deploy operations.\n        -D | --desired-count          The number of instantiations of the task to place and keep running in your service.\n        -m | --min                    minumumHealthyPercent: The lower limit on the number of running tasks during a deployment. (default: 100)\n        -M | --max                    maximumPercent: The upper limit on the number of running tasks during a deployment. (default: 200)\n        -t | --timeout                Default is 90s. Script monitors ECS Service for new task definition to be running.\n        -e | --tag-env-var            Get image tag name from environment variable. If provided this will override value specified in image name argument.\n        -to | --tag-only              New tag to apply to all images defined in the task (multi-container task). If provided this will override value specified in image name argument.\n        --max-definitions             Number of Task Definition Revisions to persist before deregistering oldest revisions.\n                                      Note: This number must be 1 or higher (i.e. keep only the current revision ACTIVE).\n                                            Max definitions causes all task revisions not matching criteria to be deregistered, even if they're created manually.\n                                            Script will only perform deregistration if deployment succeeds.\n        --task-definition-file        File used as task definition to deploy\n        --enable-rollback             Rollback task definition if new version is not running before TIMEOUT\n        --use-latest-task-def         Will use the most recently created task definition as it's base, rather than the last used.\n        --force-new-deployment        Force a new deployment of the service. Default is false.\n        --skip-deployments-check      Skip deployments check for services that take too long to drain old tasks\n        --run-task                    Run created task now. If you set this, service-name are not needed.\n        --wait-for-success            Wait for task execution to complete and to receive the exitCode 0.\n        --launch-type                 The launch type on which to run your task. (https://docs.aws.amazon.com/cli/latest/reference/ecs/run-task.html)\n        --platform-version            The Fargate platform version on which to run your task. (https://docs.aws.amazon.com/cli/latest/reference/ecs/run-task.html)\n        --network-configuration       The network configuration for the task. This parameter is required for task definitions that use\n                                          the awsvpc network mode to receive their own elastic network interface, and it is not supported\n                                          for other network modes. (https://docs.aws.amazon.com/cli/latest/reference/ecs/run-task.html)\n        --copy-task-definition-tags   Copy the existing task definition tags to the new task definition revision\n        -v | --verbose                Verbose output\n             --version                Display the version\n\n    Requirements:\n        aws:  AWS Command Line Interface\n        jq:   Command-line JSON processor\n\n    Examples:\n      Simple deployment of a service (Using env vars for AWS settings):\n\n        ecs-deploy -c my-cluster-name -n my-service-name -i my.private.repo.com/frontend_container:latest\n\n      All options:\n\n        ecs-deploy -k ABC123 -s SECRETKEY -r us-east-1 -c my-cluster-name -n my-service-name -i my.private.repo.com/frontend_container -m 50 -M 100 -t 240 -D 2 -e CI_TIMESTAMP -v\n\n      Updating a task definition with a new image:\n\n        ecs-deploy -d my-task-definition -i my.private.repo.com/frontend_container:17\n\n      Using profiles (for STS delegated credentials, for instance):\n\n        ecs-deploy -p my-profile -c my-cluster-name -n my-service-name -i my.private.repo.com/frontend_container -t 240 -e CI_TIMESTAMP -v\n\n      Update just the tag on whatever image is found in ECS Task (supports multi-container tasks):\n\n        ecs-deploy -c staging -n core-service -to 0.1.899 -i ignore\n\n    Notes:\n      - If a tag is not found in image and an ENV var is not used via -e, it will default the tag to \"latest\"\n\n## Installation\n\n- Install and configure [aws-cli](http://docs.aws.amazon.com/cli/latest/userguide/tutorial-ec2-ubuntu.html#install-cli)\n- Install [jq](https://github.com/stedolan/jq/wiki/Installation)\n- Install ecs-deploy:\n\n```\ncurl https://raw.githubusercontent.com/silinternational/ecs-deploy/master/ecs-deploy | sudo tee /usr/bin/ecs-deploy\nsudo chmod +x /usr/bin/ecs-deploy\n\n```\n\n## How it works\n\n_Note: Some nouns in the next paragraphs are capitalized to indicate that they are words which have specific meanings in AWS_\n\nRemember that in the EC2 Container Service, the relationship between the group of containers which together provide a\nuseful application (e.g. a database, web frontend, and perhaps some for maintenance/cron) is specified in a Task Definition.\nThe Task Definition then acts a sort of template for actually running the containers in that group. That resulting group of\ncontainers is known as a Task. Due to the way docker implements networking, generally you can only run one Task per Task\nDefinition per Container Instance (the virtual machines providing the cluster infrastructure).\n\nTask Definitions are automatically version controlled---the actual name of a Task Definition is composed of two parts, the\nFamily name, and a version number, like so: `phpMyAdmin:3`\n\nSince a Task is supposed to be a fully self-contained \"worker unit\" of a broader application, Amazon uses another configuration\nentity, Services, to manage the number of Tasks running at any given time. As Tasks are just instantiations of Task Definitions,\na Service is just a binding between a specified revision of a Task Definition, and the number of Tasks which should be run from\nit.\n\nConveniently, Amazon allows this binding to be updated, either to change the number of Tasks running or to change the Task\nDefinition they are built from. In the former case, the Service will respond by building or killing Tasks to bring the count to\nspecifications. In the latter case, however, it will do a blue/green deployment, that is, before killing any of the old Tasks,\nit will first ensure that a new Task is brought up and ready to use, so that there is no loss of service.\n\n_Naturally, enough computing resources must be available in the ECS cluster for any of this to work._\n\nConsequently, all that is needed to deploy a new version of an application is to update the Service which is running its\nTasks to point at a new version of the Task Definition. `ecs-deploy` uses the python `aws` utility to do this. It,\n\n- Pulls the JSON representation of the in-use Task Definition; or the most recently created if using `--use-latest-task-def`\n- Edits it\n- Defines a new version, with the changes\n- Updates the Service to use the new version\n- Waits, querying Amazon's API to make sure that the Service has been able to create a new Task\n\nThe second step merits more explanation: since a Task Definition [may] define multiple containers, the question arises, \"what\nmust be changed to create a new revision?\" Empirically, the surprising answer is nothing; Amazon allows you to create a new\nbut identical version of a Task Definition, and the Service will still do a blue/green deployment of identical tasks.\n\nNevertheless, since the system uses docker, the assumption is that improvements to the application are built into\nits container images, which are then pushed into a repository (public or private), to then be pulled down for use by ECS. This\nscript therefore uses the specified `image` parameter as a modification key to change the tag used by a container's image. It\nlooks for images with the same repository name as the specified parameter, and updates its tag to the one in the specified\nparameter.\n\n_A direct consequence of this is that if you define more than one container in your Task Definition to use the same image, all\nof them will be updated to the specified tag, even if you set them to use different tags initially. But this is considered to\nbe an unlikely use case._\n\nThis behavior allows two possible process to specify which images, and therefore which configurations, to deploy. First, you\nmay set the tag to always be `latest` (or some other static value), like so:\n\n    ecs-deploy -c my-cluster-name -n my-service-name -i my.private.repo.com/frontend_container:latest\n\nThis will result in identical new versions of the Task Definition being created, but the Service will still do a blue/green\ndeployment, and will so will pull down the latest version (if you previously pushed it into the registry).\n\nAlternatively, you may specify some other means of obtaining the tag, since the script `eval`s the image string. You could use\ngit tags as a map to docker tags:\n\n    ecs-deploy -c my-cluster-name -n my-service-name -i 'my.private.repo.com/frontend_container:`git describe`'\n\nOr perhaps just obtain read the docker tag from another file in your development:\n\n    ecs-deploy -c my-cluster-name -n my-service-name -i 'my.private.repo.com/frontend_container:$(< VERSION)'\n\nIn any case, just make sure your process builds, tags, and pushes the docker image you use to the repository before running\nthis script.\n\n## Use Environment Variable for tag name value\n\nIn some cases you may want to use an environment variable for the tag name of your image.\nFor example, we want to use a unique docker image/tag for each task definition. This\ngives us the ability to revert/rollback changes by just selecting a previous task\ndefinition and updating the service.\n\nUsing the `-e` argument you can provide the name of an environment variable that\nholds the value you wish to use for the tag.\n\nFor example:\n\n    ecs-deploy -c my-cluster-name -n my-service-name -i my.private.repo.com/frontend_container -e CI_TIMESTAMP\n\n## AWS IAM Policy Configuration\n\nHere's an example of a suitable custom policy for [AWS IAM](https://aws.amazon.com/documentation/iam/):\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecs:DeregisterTaskDefinition\",\n        \"ecs:DescribeServices\",\n        \"ecs:DescribeTaskDefinition\",\n        \"ecs:DescribeTasks\",\n        \"ecs:ListTasks\",\n        \"ecs:ListTaskDefinitions\",\n        \"ecs:RegisterTaskDefinition\",\n        \"ecs:StartTask\",\n        \"ecs:StopTask\",\n        \"ecs:UpdateService\",\n        \"iam:PassRole\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}\n```\n\n## Troubleshooting\n\n- You must provide AWS credentials in one of the supported formats. If you do\n  not, you'll see some error output from the AWS CLI, something like:\n\n       You must specify a region. You can also configure your region by running \"aws configure\".\n\n## Testing\n\nAutomated tests are performed using [bats](https://github.com/sstephenson/bats).\nThe goal of testing is to ensure that updates/changes do not break core functionality.\nUnfortunately not all of `ecs-deploy` is testable since portions interact with\nAWS APIs to perform actions. So for now any parsing/processing of data locally\nis tested.\n\nAny new functionality and pull requests should come with tests as well (if possible).\n\n## Github Actions Support\n\nGithub Actions support is available. Add a code block similar to that below to your actions yaml file. Parameters are passed to the ecs-deploy tool under 'with' section. For each parameter, the parameter name followed by \\_cmd must be called with the appropriate parameter option like '--aws-access-key' in addition to supplying the parameter aws_access_key with the appropriate value.\n\n```\ndeploy_to_ecs:\n  name: 'Deploy updated container image via blue/green deployment to ECS service.'\n  runs-on: ubuntu-18.04\n  steps:\n  - uses: silinternational/ecs-deploy@master\n    env:\n      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n      AWS_DEFAULT_REGION: 'us-east-1'\n    with:\n      aws_access_key_cmd: '--aws-access-key'\n      aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}\n      aws_secret_key_cmd: '--aws-secret-key'\n      aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n      cluster_cmd: '--cluster'\n      cluster: 'cluster-name'\n      image_cmd: '--image'\n      image: '{amazon_id}.dkr.ecr.us-east-1.amazonaws.com/cluster-name/image_name:latest'\n      region_cmd: '--region'\n      region: 'us-east-1'\n      service_name_cmd: '--service-name'\n      service_name: 'aws-service-name'\n      timeout_cmd: '--timeout'\n      timeout: '360'\n```\n"
        },
        {
          "name": "action-services.yml",
          "type": "blob",
          "size": 0.0634765625,
          "content": "services:\n  test:\n    build: .\n    entrypoint: [\"/run-tests.sh\"]\n"
        },
        {
          "name": "action.yml",
          "type": "blob",
          "size": 6.109375,
          "content": "name: 'ECS-Deploy'\ndescription: 'Simple shell script for initiating blue-green deployments on Amazon EC2 Container Service (ECS)'\ninputs:\n  aws_access_key_cmd:\n    description: '--aws-access-key'\n    required: true\n  aws_access_key:\n    description: 'AWS Access Key ID. May also be set as environment variable AWS_ACCESS_KEY_ID'\n    required: true\n  aws_secret_key_cmd:\n    description: '--aws-secret-key'\n    required: true\n  aws_secret_key:\n    description: 'AWS Secret Access Key. May also be set as environment variable AWS_SECRET_ACCESS_KEY'\n    required: true\n  service_name_cmd:\n    description: '--service-name'\n  service_name:\n    description: 'Name of service to deploy'\n    required: false\n  task_definition_cmd:\n    description: '--task-definition'\n  task_definition:\n    description: 'Name of task definition to deploy'\n    required: false\n  region_cmd:\n    description: '--region'\n  region:\n    description: 'AWS Region Name. May also be set as environment variable AWS_DEFAULT_REGION'\n    required: true\n  profile_cmd:\n    description: '--profile'\n  profile:\n    description: 'AWS Profile to use - If you set this aws-access-key, aws-secret-key and region are not needed'\n    required: true\n  cluster_cmd:\n    description: '--cluster'\n  cluster:\n    description: 'Name of ECS cluster'\n    required: true\n  image_cmd:\n    description: '--image'\n  image:\n    description: 'Name of Docker image to run, ex: repo/image:latest'\n    required: true\n  aws_assume_role_cmd:\n    description: '--aws-assume-role'\n  aws_assume_role:\n    description: 'ARN for AWS Role to assume for ecs-deploy operations.'\n    required: false\n  desired_count_cmd:\n    description: '--desired-count'\n  desired_count:\n    description: 'The number of instantiations of the task to place and keep running in your service.'\n    required: false\n  min_cmd:\n    description: '--min'\n    default: '--min'\n  min:\n    description: 'minumumHealthyPercent: The lower limit on the number of running tasks during a deployment.'\n    required: false\n    default: '100'\n  max_cmd:\n    description: '--max'\n    default: '--max'\n  max:\n    description: 'maximumPercent: The upper limit on the number of running tasks during a deployment.'\n    required: false\n    default: '200'\n  timeout_cmd:\n    description: '--timeout'\n    default: '--timeout'\n  timeout:\n    description: 'Script monitors ECS Service for new task definition to be running.'\n    required: false\n    default: '90'\n  tag_env_var_cmd:\n    description: '--tag-env-var'\n  tag_env_var:\n    description: 'Get image tag name from environment variable. If provided this will override value specified in image name argument.'\n    required: false\n  tag_only_cmd:\n    description: '--tag-only'\n  tag_only:\n    description: 'New tag to apply to all images defined in the task (multi-container task). If provided this will override value specified in image name argument.'\n    required: false\n  max_definitions_cmd:\n    description: '--max-definition'\n  max_definitions:\n    description: 'Number of Task Definition Revisions to persist before deregistering oldest revisions.'\n    required: false\n  enable_rollback_cmd:\n    description: '--enable-rollback'\n  enable_rollback:\n    description: 'Rollback task definition if new version is not running before TIMEOUT'\n    required: false\n  use_latest_task_def_cmd:\n    description: '--use-latest-task-def'\n  use_latest_task_def:\n    description: 'Will use the most recently created task definition as its base, rather than the last used.'\n    required: false\n  force_new_deployment_cmd:\n    description: '--force-new-deployment'\n  force_new_deployment:\n    description: 'Force a new deployment of the service.'\n    required: false\n  run_task_cmd:\n    description: '--run-task'\n  run_task:\n    description: 'Run created task now. If you set this, service-name are not needed.'\n    required: false\n  wait_for_success_cmd:\n    description: '--wait-for-success'\n  wait_for_success:\n    description: 'Wait for task execution to complete and to receive the exitCode 0.'\n    required: false\n  skip_deployments_check_cmd:\n    description: '--skip-deployments-check'\n  skip_deployments_check:\n    description: 'Skip deployments check for services that take too long to drain old tasks'\n  copy_task_definition_tags_cmd:\n    description: '--copy-task-definition-tags'\n  copy_task_definition_tags:\n    description: 'Copy the existing task definition tags to the new task definition revision'\n    required: false\n  verbose:\n    description: 'Verbose output'\n    required: false\noutputs:\n  status:\n    description: 'status'\nbranding:\n  icon: 'codesandbox'\n  color: 'blue'\nruns:\n  using: 'docker'\n  image: 'Dockerfile'\n  args: [\n    '${{ inputs.aws_access_key_cmd }}', '${{ inputs.aws_access_key }}',\n    '${{ inputs.aws_secret_key_cmd }}', '${{ inputs.aws_secret_key }}',\n    '${{ inputs.region_cmd }}', '${{ inputs.region }}',\n    '${{ inputs.service_name_cmd }}', '${{ inputs.service_name }}',\n    '${{ inputs.task_definition_cmd }}', '${{ inputs.task_definition }}',\n    '${{ inputs.enable_rollback_cmd }}', '${{ inputs.enable_rollback }}',\n    '${{ inputs.force_new_deployment_cmd }}', '${{ inputs.force_new_deployment }}',\n    '${{ inputs.cluster_cmd }}', '${{ inputs.cluster }}',\n    '${{ inputs.image_cmd }}', '${{ inputs.image }}',\n    '${{ inputs.aws_assume_role_cmd }}', '${{ inputs.aws_assume_role }}',\n    '${{ inputs.desired_count_cmd }}', '${{ inputs.desired_count }}',\n    '${{ inputs.min_cmd }}', '${{ inputs.min }}',\n    '${{ inputs.max_cmd }}', '${{ inputs.max }}',\n    '${{ inputs.profile_cmd }}', '${{ inputs.profile }}',\n    '${{ inputs.timeout_cmd }}', '${{ inputs.timeout }}',\n    '${{ inputs.tag_env_var_cmd }}', '${{ inputs.tag_env_var }}',\n    '${{ inputs.tag_only_cmd }}', '${{ inputs.tag_only }}',\n    '${{ inputs.use_latest_task_def_cmd }}', '${{ inputs.use_latest_task_def }}',\n    '${{ inputs.max_definitions_cmd }}', '${{ inputs.max_definitions }}',\n    '${{ inputs.run_task_cmd }}', '${{ inputs.run_task }}',\n    '${{ inputs.wait_for_success_cmd }}', '${{ inputs.wait_for_success }}',\n    '${{ inputs.copy_task_definition_tags_cmd }}', '${{ inputs.copy_task_definition_tags }}',\n    '${{ inputs.skip_deployments_check_cmd }}', '${{ inputs.skip_deployments_check }}'\n  ]\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.462890625,
          "content": "{\n    \"name\": \"silinternational/ecs-deploy\",\n    \"description\": \"Simple shell script for initiated blue-green deployments on Amazon Elastic Container Service (ECS)\",\n    \"type\": \"library\",\n    \"keywords\": [\n        \"aws\",\n        \"ec2\",\n        \"ecs\",\n        \"docker\",\n        \"elastic container service\",\n        \"amazon web services\"\n    ],\n    \"homepage\": \"https://github.com/silinternational/ecs-deploy\",\n    \"license\": \"MIT\",\n    \"bin\": [\n        \"ecs-deploy\"\n    ]\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.400390625,
          "content": "services:\n    ecsdeploy:\n        build: .\n        env_file:\n            - local.env\n        volumes:\n            - ./ecs-deploy:/ecs-deploy\n\n    test:\n        build: .\n        env_file:\n            - local.env\n        entrypoint: [\"bash\"]\n        command: [\"/run-tests.sh\"]\n        volumes:\n            - ./ecs-deploy:/ecs-deploy\n            - ./run-tests.sh:/run-tests.sh\n            - ./test.bats:/test.bats\n"
        },
        {
          "name": "ecs-deploy",
          "type": "blob",
          "size": 27.998046875,
          "content": "#!/usr/bin/env bash\n\n# Setup default values for variables\nVERSION=\"3.10.19\"\nCLUSTER=false\nSERVICE=false\nTASK_DEFINITION=false\nTASK_DEFINITION_FILE=false\nMAX_DEFINITIONS=0\nAWS_ASSUME_ROLE=false\nIMAGE=false\nMIN=false\nMAX=false\nTIMEOUT=90\nVERBOSE=false\nTAGVAR=false\nTAGONLY=\"\"\nENABLE_ROLLBACK=false\nUSE_MOST_RECENT_TASK_DEFINITION=false\nAWS_CLI=$(which aws)\nAWS_ECS=\"$AWS_CLI --output json ecs\"\nFORCE_NEW_DEPLOYMENT=false\nSKIP_DEPLOYMENTS_CHECK=false\nRUN_TASK=false\nRUN_TASK_LAUNCH_TYPE=false\nRUN_TASK_PLATFORM_VERSION=false\nRUN_TASK_NETWORK_CONFIGURATION=false\nRUN_TASK_WAIT_FOR_SUCCESS=false\nTASK_DEFINITION_TAGS=false\nCOPY_TASK_DEFINITION_TAGS=false\n\nfunction usage() {\n    cat <<EOM\n##### ecs-deploy #####\nSimple script for triggering blue/green deployments on Amazon Elastic Container Service\nhttps://github.com/silinternational/ecs-deploy\n\nOne of the following is required:\n    -n | --service-name          Name of service to deploy\n    -d | --task-definition       Name of task definition to deploy\n\nRequired arguments:\n    -k | --aws-access-key        AWS Access Key ID. May also be set as environment variable AWS_ACCESS_KEY_ID\n    -s | --aws-secret-key        AWS Secret Access Key. May also be set as environment variable AWS_SECRET_ACCESS_KEY\n    -r | --region                AWS Region Name. May also be set as environment variable AWS_DEFAULT_REGION\n    -p | --profile               AWS Profile to use - If you set this, then aws-access-key, aws-secret-key and region are not needed\n    -c | --cluster               Name of ECS cluster\n    -i | --image                 Name of Docker image to run, ex: repo/image:latest\n                                 Format: [domain][:port][/repo][/][image][:tag]\n                                 Examples: mariadb, mariadb:latest, private.registry.com:8000/repo/image:tag\n    --aws-instance-profile       Use the IAM role associated with this instance\n\nOptional arguments:\n    -a | --aws-assume-role       ARN for AWS Role to assume for ecs-deploy operations.\n    -D | --desired-count         The number of instantiations of the task to place and keep running in your service.\n    -m | --min                   minumumHealthyPercent: The lower limit on the number of running tasks during a deployment.\n    -M | --max                   maximumPercent: The upper limit on the number of running tasks during a deployment.\n    -t | --timeout               Default is 90s. Script monitors ECS Service for new task definition to be running.\n    -e | --tag-env-var           Get image tag name from environment variable. If provided this will override value\n                                       specified in image name argument.\n    -to | --tag-only             New tag to apply to all images defined in the task (multi-container task).\n                                       If provided this will override value specified in image name argument.\n    --max-definitions            Number of Task Definition Revisions to persist before deregistering oldest revisions.\n    --task-definition-file       File used as task definition to deploy\n    --enable-rollback            Rollback task definition if new version is not running before TIMEOUT\n    --force-new-deployment       Force a new deployment of the service. Default is false.\n    --use-latest-task-def        Will use the most recently created task definition as it's base, rather than the last used.\n    --skip-deployments-check     Skip deployments check for services that take too long to drain old tasks\n    --run-task                   Run created task now. If you set this, service-name are not needed.\n    --wait-for-success           Wait for task execution to complete and to receive the exitCode 0.\n    --launch-type                The launch type on which to run your task.\n                                       (https://docs.aws.amazon.com/cli/latest/reference/ecs/run-task.html)\n    --platform-version           The Fargate platform version on which to run your task.\n                                       (https://docs.aws.amazon.com/cli/latest/reference/ecs/run-task.html)\n    --network-configuration      The network configuration for the task. This parameter is required for task definitions that use\n                                       the awsvpc network mode to receive their own elastic network interface, and it is not supported\n                                       for other network modes. (https://docs.aws.amazon.com/cli/latest/reference/ecs/run-task.html)\n    --copy-task-definition-tags  Copy the existing task definition tags to the new task definition revision\n    -v | --verbose               Verbose output\n         --version               Display the version\n\nRequirements:\n    aws:  AWS Command Line Interface\n    jq:   Command-line JSON processor\n\nExamples:\n  Simple deployment of a service (Using env vars for AWS settings):\n\n    ecs-deploy -c production1 -n doorman-service -i docker.repo.com/doorman:latest\n\n  All options:\n\n    ecs-deploy -k ABC123 -s SECRETKEY -r us-east-1 -c production1 -n doorman-service -i docker.repo.com/doorman -t 240 -e CI_TIMESTAMP -v\n\n  Updating a task definition with a new image:\n\n    ecs-deploy -d open-door-task -i docker.repo.com/doorman:17\n\n  Using profiles (for STS delegated credentials, for instance):\n\n    ecs-deploy -p PROFILE -c production1 -n doorman-service -i docker.repo.com/doorman -t 240 -e CI_TIMESTAMP -v\n\n  Update just the tag on whatever image is found in ECS Task (supports multi-container tasks):\n\n    ecs-deploy -c staging -n core-service -to 0.1.899 -i ignore\n\nNotes:\n  - If a tag is not found in image and an ENV var is not used via -e and a tag is not provided with -to, it will default the tag to \"latest\"\nEOM\n\n    exit 3\n}\n\n\n\n\n# Check requirements\nfunction require() {\n    command -v \"$1\" > /dev/null 2>&1 || {\n        echo \"Some of the required software is not installed:\"\n        echo \"    please install $1\" >&2;\n        exit 4;\n    }\n}\n\nfunction assumeRole() {\n\n   temp_role=$(aws sts assume-role \\\n                    --role-arn \"${AWS_ASSUME_ROLE}\" \\\n                    --role-session-name \"$(date +\"%s\")\")\n\n   export AWS_ACCESS_KEY_ID=$(echo $temp_role | jq .Credentials.AccessKeyId | xargs)\n   export AWS_SECRET_ACCESS_KEY=$(echo $temp_role | jq .Credentials.SecretAccessKey | xargs)\n   export AWS_SESSION_TOKEN=$(echo $temp_role | jq .Credentials.SessionToken | xargs)\n}\n\n\nfunction assumeRoleClean() {\n   unset AWS_ACCESS_KEY_ID\n   unset AWS_SECRET_ACCESS_KEY\n   unset AWS_SESSION_TOKEN\n}\n\n\n# Check that all required variables/combinations are set\nfunction assertRequiredArgumentsSet() {\n\n    # AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_DEFAULT_REGION and AWS_PROFILE can be set as environment variables\n    if [ -z ${AWS_ACCESS_KEY_ID+x} ]; then unset AWS_ACCESS_KEY_ID; fi\n    if [ -z ${AWS_SECRET_ACCESS_KEY+x} ]; then unset AWS_SECRET_ACCESS_KEY; fi\n    if [ -z ${AWS_DEFAULT_REGION+x} ];\n      then unset AWS_DEFAULT_REGION\n      else\n              AWS_ECS=\"$AWS_ECS --region $AWS_DEFAULT_REGION\"\n    fi\n    if [ -z ${AWS_PROFILE+x} ];\n      then unset AWS_PROFILE\n      else\n              AWS_ECS=\"$AWS_ECS --profile $AWS_PROFILE\"\n    fi\n\n    if [ $SERVICE == false ] && [ $TASK_DEFINITION == false ]; then\n        echo \"One of SERVICE or TASK DEFINITION is required. You can pass the value using -n / --service-name for a service, or -d / --task-definition for a task\"\n        exit 5\n    fi\n    if [ $SERVICE != false ] && [ $TASK_DEFINITION != false ]; then\n        echo \"Only one of SERVICE or TASK DEFINITION may be specified, but you supplied both\"\n        exit 6\n    fi\n    if [ $SERVICE != false ] && [ $CLUSTER == false ]; then\n        echo \"CLUSTER is required. You can pass the value using -c or --cluster\"\n        exit 7\n    fi\n    if [ $IMAGE == false ] && [ $FORCE_NEW_DEPLOYMENT == false ]; then\n        echo \"IMAGE is required. You can pass the value using -i or --image\"\n        exit 8\n    fi\n    if ! [[ $MAX_DEFINITIONS =~ ^-?[0-9]+$ ]]; then\n        echo \"MAX_DEFINITIONS must be numeric, or not defined.\"\n        exit 9\n    fi\n\n    if [ $RUN_TASK == false ] && [ $RUN_TASK_LAUNCH_TYPE != false ]; then\n        echo 'LAUNCH TYPE requires setting RUN TASK argument. You can set it using --run-task flag.'\n        exit 10\n    fi\n\n    if [ $RUN_TASK == false ] && [ $RUN_TASK_NETWORK_CONFIGURATION != false ]; then\n        echo 'NETWORK CONFIGURATION requires setting RUN TASK argument. You can set it using --run-task flag.'\n        exit 11\n    fi\n\n    if [ $RUN_TASK == false ] && [ $RUN_TASK_WAIT_FOR_SUCCESS != false ]; then\n        echo 'WAIT FOR SUCCESS requires setting RUN TASK argument. You can set it using --run-task flag.'\n        exit 11\n    fi\n\n    if [ $RUN_TASK == false ] && [ $RUN_TASK_PLATFORM_VERSION != false ]; then\n        echo 'PLATFORM VERSION requires setting RUN TASK argument. You can set it using --run-task flag.'\n        exit 12\n    fi\n\n}\n\nfunction parseImageName() {\n\n    # Define regex for image name\n    # This regex will create groups for:\n    # - domain\n    # - port\n    # - repo\n    # - image\n    # - tag\n    # If a group is missing it will be an empty string\n    if [[ \"x$TAGONLY\" == \"x\" ]]; then\n       imageRegex=\"^([a-zA-Z0-9\\.\\-]+):?([0-9]+)?/([a-zA-Z0-9\\._\\-]+)(/[\\/a-zA-Z0-9\\._\\-]+)?:?([a-zA-Z0-9\\._\\-]+)?$\"\n    else\n       imageRegex=\"^:?([a-zA-Z0-9\\._-]+)?$\"\n    fi\n\n    if [[ $IMAGE =~ $imageRegex ]]; then\n      # Define variables from matching groups\n      if [[ \"x$TAGONLY\" == \"x\" ]]; then\n        domain=${BASH_REMATCH[1]}\n        port=${BASH_REMATCH[2]}\n        repo=${BASH_REMATCH[3]}\n        img=${BASH_REMATCH[4]/#\\//}\n        tag=${BASH_REMATCH[5]}\n\n        # Validate what we received to make sure we have the pieces needed\n        if [[ \"x$domain\" == \"x\" ]]; then\n          echo \"Image name does not contain a domain or repo as expected. See usage for supported formats.\"\n          exit 10;\n        fi\n        if [[ \"x$repo\" == \"x\" ]]; then\n          echo \"Image name is missing the actual image name. See usage for supported formats.\"\n          exit 11;\n        fi\n\n        # When a match for image is not found, the image name was picked up by the repo group, so reset variables\n        if [[ \"x$img\" == \"x\" ]]; then\n         img=$repo\n         repo=\"\"\n        fi\n      else\n        tag=${BASH_REMATCH[1]}\n        domain=\"\"\n        port=\"\"\n        repo=\"\"\n        img=\"\"\n      fi\n    else\n      # check if using root level repo with format like mariadb or mariadb:latest\n      rootRepoRegex=\"^([a-zA-Z0-9\\-]+):?([a-zA-Z0-9\\.\\-_]+)?$\"\n      if [[ $IMAGE =~ $rootRepoRegex ]]; then\n        img=${BASH_REMATCH[1]}\n        if [[ \"x$img\" == \"x\" ]]; then\n          echo \"Invalid image name. See usage for supported formats.\"\n          exit 12\n        fi\n        tag=${BASH_REMATCH[2]}\n\n        # for root level repo, initialize unused variables for checks when rebuilding image below\n        domain=\"\"\n        port=\"\"\n        repo=\"\"\n\n      else\n        echo \"Unable to parse image name: $IMAGE, check the format and try again\"\n        exit 13\n      fi\n    fi\n\n    # If tag is missing make sure we can get it from env var, or use latest as default\n    if [[ \"x$tag\" == \"x\" ]]; then\n      if [[ $TAGVAR == false ]]; then\n        tag=\"latest\"\n      else\n        tag=${!TAGVAR}\n        if [[ \"x$tag\" == \"x\" ]]; then\n          tag=\"latest\"\n        fi\n      fi\n    fi\n\n    # Reassemble image name\n    useImage=\"\"\n    if [[ \"x$TAGONLY\" == \"x\" ]]; then\n\n      if [[ ! -z \"$domain\" ]]; then\n        useImage=\"$domain\"\n      fi\n      if [[ ! -z \"$port\" ]]; then\n        useImage=\"$useImage:$port\"\n      fi\n      if [[ ! -z \"$repo\" ]]; then\n        useImage=\"$useImage/$repo\"\n      fi\n      if [[ ! -z \"$img\" ]]; then\n        if [[ -z \"$useImage\" ]]; then\n          useImage=\"$img\"\n        else\n          useImage=\"$useImage/$img\"\n        fi\n      fi\n      imageWithoutTag=\"$useImage\"\n      if [[ ! -z \"$tag\" ]]; then\n        useImage=\"$useImage:$tag\"\n      fi\n\n    else\n      useImage=\"$TAGONLY\"\n    fi\n\n    # If in test mode output $useImage\n    if [ \"$BASH_SOURCE\" != \"$0\" ]; then\n      echo $useImage\n    fi\n}\n\nfunction getCurrentTaskDefinition() {\n    if [ $SERVICE != false ]; then\n      # Get current task definition arn from service\n      TASK_DEFINITION_ARN=`$AWS_ECS describe-services --services $SERVICE --cluster $CLUSTER | jq -r .services[0].taskDefinition`\n      TASK_DEFINITION=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION_ARN`\n\n      # For rollbacks\n      LAST_USED_TASK_DEFINITION_ARN=$TASK_DEFINITION_ARN\n\n      if [ $USE_MOST_RECENT_TASK_DEFINITION != false ]; then\n        # Use the most recently created TD of the family; rather than the most recently used.\n        TASK_DEFINITION_FAMILY=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION_ARN | jq -r .taskDefinition.family`\n        TASK_DEFINITION=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION_FAMILY`\n        TASK_DEFINITION_ARN=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION_FAMILY | jq -r .taskDefinition.taskDefinitionArn`\n      fi\n    elif [ $TASK_DEFINITION != false ]; then\n      # Get current task definition arn from family[:revision] (or arn)\n      TASK_DEFINITION_ARN=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION | jq -r .taskDefinition.taskDefinitionArn`\n    fi\n\n    # Get task definition using current task definition arn\n    # If we're copying task definition tags to the new revision, also get current task definition tags\n    if [[ \"$COPY_TASK_DEFINITION_TAGS\" == true ]]; then\n      TASK_DEFINITION=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION_ARN --include TAGS`\n      TASK_DEFINITION_TAGS=$( echo \"$TASK_DEFINITION\" | jq \".tags\" )\n    else\n      TASK_DEFINITION=`$AWS_ECS describe-task-definition --task-def $TASK_DEFINITION_ARN`\n    fi\n}\n\nfunction createNewTaskDefJson() {\n\n    if [ $TASK_DEFINITION_FILE == false ]; then\n        taskDefinition=\"$TASK_DEFINITION\"\n    else\n        taskDefinition=\"$(cat $TASK_DEFINITION_FILE)\"\n    fi\n\n    # Get a JSON representation of the current task definition\n    # + Update definition to use new image name\n    # + Filter the def\n    if [[ \"x$TAGONLY\" == \"x\" ]]; then\n      DEF=$( echo \"$taskDefinition\" \\\n            | sed -e 's~\"image\":.*'\"${imageWithoutTag}\"'.*,~\"image\": \"'\"${useImage}\"'\",~g' \\\n            | jq '.taskDefinition' )\n    else\n      DEF=$( echo \"$taskDefinition\" \\\n            | sed -e \"s|\\(\\\"image\\\": *\\\".*:\\)\\(.*\\)\\\"|\\1${useImage}\\\"|g\" \\\n            | jq '.taskDefinition' )\n    fi\n\n    # Default JQ filter for new task definition\n    NEW_DEF_JQ_FILTER=\"family: .family, volumes: .volumes, containerDefinitions: .containerDefinitions, placementConstraints: .placementConstraints\"\n\n    # Some options in task definition should only be included in new definition if present in\n    # current definition. If found in current definition, append to JQ filter.\n    CONDITIONAL_OPTIONS=(networkMode taskRoleArn placementConstraints executionRoleArn runtimePlatform ephemeralStorage proxyConfiguration)\n    for i in \"${CONDITIONAL_OPTIONS[@]}\"; do\n      re=\".*${i}.*\"\n      if [[ \"$DEF\" =~ $re ]]; then\n        NEW_DEF_JQ_FILTER=\"${NEW_DEF_JQ_FILTER}, ${i}: .${i}\"\n      fi\n    done\n\n    # Updated jq filters for AWS Fargate\n    REQUIRES_COMPATIBILITIES=$(echo \"${DEF}\" | jq -r '. | select(.requiresCompatibilities != null) | .requiresCompatibilities[]')\n    if `echo ${REQUIRES_COMPATIBILITIES[@]} | grep -q \"FARGATE\"`; then\n      FARGATE_JQ_FILTER='requiresCompatibilities: .requiresCompatibilities, cpu: .cpu, memory: .memory'\n\n      if [[ ! \"$NEW_DEF_JQ_FILTER\" =~ \".*executionRoleArn.*\" ]]; then\n        FARGATE_JQ_FILTER=\"${FARGATE_JQ_FILTER}, executionRoleArn: .executionRoleArn\"\n      fi\n      NEW_DEF_JQ_FILTER=\"${NEW_DEF_JQ_FILTER}, ${FARGATE_JQ_FILTER}\"\n    fi\n\n    # Build new DEF with jq filter\n    NEW_DEF=$(echo \"$DEF\" | jq \"{${NEW_DEF_JQ_FILTER}}\")\n\n    # If in test mode output $NEW_DEF\n    if [ \"$BASH_SOURCE\" != \"$0\" ]; then\n      echo \"$NEW_DEF\"\n    fi\n}\n\nfunction registerNewTaskDefinition() {\n    # Register the new task definition, and store its ARN\n    if [[ \"$COPY_TASK_DEFINITION_TAGS\" == true && \"$TASK_DEFINITION_TAGS\" != false && \"$TASK_DEFINITION_TAGS\" != \"[]\" ]]; then\n      NEW_TASKDEF=`$AWS_ECS register-task-definition --cli-input-json \"$NEW_DEF\" --tags \"$TASK_DEFINITION_TAGS\" | jq -r .taskDefinition.taskDefinitionArn`\n    else\n      NEW_TASKDEF=`$AWS_ECS register-task-definition --cli-input-json \"$NEW_DEF\" | jq -r .taskDefinition.taskDefinitionArn`\n    fi\n}\n\nfunction rollback() {\n    echo \"Rolling back to ${LAST_USED_TASK_DEFINITION_ARN}\"\n    $AWS_ECS update-service --cluster $CLUSTER --service $SERVICE --task-definition $LAST_USED_TASK_DEFINITION_ARN > /dev/null\n}\n\nfunction updateServiceForceNewDeployment() {\n    echo 'Force a new deployment of the service'\n    $AWS_ECS update-service --cluster $CLUSTER --service $SERVICE --force-new-deployment > /dev/null\n}\n\nfunction updateService() {\n    if [[ $(echo ${NEW_DEF} | jq \".containerDefinitions[0].healthCheck != null\") == true ]]; then\n        checkFieldName=\"healthStatus\"\n        checkFieldValue='\"HEALTHY\"'\n    else\n        checkFieldName=\"lastStatus\"\n        checkFieldValue='\"RUNNING\"'\n    fi\n\n    UPDATE_SERVICE_SUCCESS=\"false\"\n    DEPLOYMENT_CONFIG=\"\"\n    if [ $MAX != false ]; then\n        DEPLOYMENT_CONFIG=\",maximumPercent=$MAX\"\n    fi\n    if [ $MIN != false ]; then\n        DEPLOYMENT_CONFIG=\"$DEPLOYMENT_CONFIG,minimumHealthyPercent=$MIN\"\n    fi\n    if [ ! -z \"$DEPLOYMENT_CONFIG\" ]; then\n        DEPLOYMENT_CONFIG=\"--deployment-configuration ${DEPLOYMENT_CONFIG:1}\"\n    fi\n\n    DESIRED_COUNT=\"\"\n    if [ ! -z ${DESIRED+undefined-guard} ]; then\n        DESIRED_COUNT=\"--desired-count $DESIRED\"\n    fi\n\n    # Update the service\n    UPDATE=`$AWS_ECS update-service --cluster $CLUSTER --service $SERVICE $DESIRED_COUNT --task-definition $NEW_TASKDEF $DEPLOYMENT_CONFIG`\n\n    # Only excepts RUNNING state from services whose desired-count > 0\n    SERVICE_DESIREDCOUNT=`$AWS_ECS describe-services --cluster $CLUSTER --service $SERVICE | jq '.services[]|.desiredCount'`\n    if [ $SERVICE_DESIREDCOUNT -gt 0 ]; then\n        # See if the service is able to come up again\n        every=10\n        i=0\n        while [ $i -lt $TIMEOUT ]\n        do\n            # Scan the list of running tasks for that service, and see if one of them is the\n            # new version of the task definition\n\n            RUNNING_TASKS=$($AWS_ECS list-tasks --cluster \"$CLUSTER\"  --service-name \"$SERVICE\" --desired-status RUNNING \\\n                | jq -r '.taskArns[]')\n\n            if [[ ! -z $RUNNING_TASKS ]] ; then\n                RUNNING=$($AWS_ECS describe-tasks --cluster \"$CLUSTER\" --tasks $RUNNING_TASKS \\\n                    | jq \".tasks[]| if .taskDefinitionArn == \\\"$NEW_TASKDEF\\\" then . else empty end|.${checkFieldName}\" \\\n                    | grep -e \"${checkFieldValue}\") || :\n\n                if [ \"$RUNNING\" ]; then\n                    echo \"Service updated successfully, new task definition running.\";\n\n                    if [[ $MAX_DEFINITIONS -gt 0 ]]; then\n                        FAMILY_PREFIX=${TASK_DEFINITION_ARN##*:task-definition/}\n                        FAMILY_PREFIX=${FAMILY_PREFIX%*:[0-9]*}\n                        TASK_REVISIONS=`$AWS_ECS list-task-definitions --family-prefix $FAMILY_PREFIX --status ACTIVE --sort ASC`\n                        NUM_ACTIVE_REVISIONS=$(echo \"$TASK_REVISIONS\" | jq \".taskDefinitionArns|length\")\n                        if [[ $NUM_ACTIVE_REVISIONS -gt $MAX_DEFINITIONS ]]; then\n                            LAST_OUTDATED_INDEX=$(($NUM_ACTIVE_REVISIONS - $MAX_DEFINITIONS - 1))\n                            for i in $(seq 0 $LAST_OUTDATED_INDEX); do\n                                OUTDATED_REVISION_ARN=$(echo \"$TASK_REVISIONS\" | jq -r \".taskDefinitionArns[$i]\")\n\n                                echo \"Deregistering outdated task revision: $OUTDATED_REVISION_ARN\"\n\n                              $AWS_ECS deregister-task-definition --task-definition \"$OUTDATED_REVISION_ARN\" > /dev/null\n                            done\n                        fi\n\n                    fi\n                    UPDATE_SERVICE_SUCCESS=\"true\"\n                    break\n                fi\n            fi\n\n            sleep $every\n            i=$(( $i + $every ))\n        done\n\n        if [[ \"${UPDATE_SERVICE_SUCCESS}\" != \"true\" ]]; then\n            # Timeout\n            echo \"ERROR: New task definition not running within $TIMEOUT seconds\"\n            if [[ \"${ENABLE_ROLLBACK}\" != \"false\" ]]; then\n              rollback\n            fi\n            exit 1\n        fi\n    else\n        echo \"Skipping check for running task definition, as desired-count <= 0\"\n    fi\n}\n\nfunction waitForGreenDeployment {\n  DEPLOYMENT_SUCCESS=\"false\"\n  every=2\n  i=0\n  echo \"Waiting for service deployment to complete...\"\n  while [ $i -lt $TIMEOUT ]\n  do\n    NUM_DEPLOYMENTS=$($AWS_ECS describe-services --services $SERVICE --cluster $CLUSTER | jq \"[.services[].deployments[]] | length\")\n\n    # Wait until 1 deployment stays running\n    # If the wait time has passed, we need to roll back\n    if [ $NUM_DEPLOYMENTS -eq 1 ]; then\n      echo \"Service deployment successful.\"\n      DEPLOYMENT_SUCCESS=\"true\"\n      # Exit the loop.\n      i=$TIMEOUT\n    else\n      sleep $every\n      i=$(( $i + $every ))\n    fi\n  done\n\n  if [[ \"${DEPLOYMENT_SUCCESS}\" != \"true\" ]]; then\n    if [[ \"${ENABLE_ROLLBACK}\" != \"false\" ]]; then\n      rollback\n    fi\n    exit 1\n  fi\n}\n\nfunction runTask {\n  echo \"Run task: $NEW_TASKDEF\";\n  AWS_ECS_RUN_TASK=\"$AWS_ECS run-task --cluster $CLUSTER --task-definition $NEW_TASKDEF\"\n  if [ $RUN_TASK_LAUNCH_TYPE != false ]; then\n    AWS_ECS_RUN_TASK=\"$AWS_ECS_RUN_TASK --launch-type $RUN_TASK_LAUNCH_TYPE\"\n  fi\n\n  if [ $RUN_TASK_PLATFORM_VERSION != false ]; then\n    AWS_ECS_RUN_TASK=\"$AWS_ECS_RUN_TASK --platform-version $RUN_TASK_PLATFORM_VERSION\"\n  fi\n\n  if [ $RUN_TASK_NETWORK_CONFIGURATION != false ]; then\n    AWS_ECS_RUN_TASK=\"$AWS_ECS_RUN_TASK --network-configuration \\\"$RUN_TASK_NETWORK_CONFIGURATION\\\"\"\n  fi\n\n  TASK_ARN=$(eval $AWS_ECS_RUN_TASK | jq -r '.tasks[0].taskArn')\n  echo \"Executed task: $TASK_ARN\"\n\n  if [ $RUN_TASK_WAIT_FOR_SUCCESS == true ]; then\n    RUN_TASK_SUCCESS=false\n    every=10\n    i=0\n    while [ $i -lt $TIMEOUT ]\n    do\n\n        TASK_JSON=$($AWS_ECS describe-tasks --cluster \"$CLUSTER\"  --tasks \"$TASK_ARN\")\n\n        TASK_STATUS=$(echo $TASK_JSON | jq -r  '.tasks[0].lastStatus')\n        TASK_EXIT_CODE=$(echo $TASK_JSON | jq -r  '.tasks[0].containers[0].exitCode')\n\n        if [ $TASK_STATUS == \"STOPPED\" ]; then\n            echo \"Task finished with status: $TASK_STATUS\"\n            if [ $TASK_EXIT_CODE != 0 ]; then\n                echo \"Task execution failed with exit code: $TASK_EXIT_CODE\"\n                exit 1\n            fi\n            RUN_TASK_SUCCESS=true\n            break;\n        fi\n\n        echo \"Checking task status every $every seconds. Status: $TASK_STATUS\"\n\n        sleep $every\n        i=$(( $i + $every ))\n    done\n\n    if [ $RUN_TASK_SUCCESS == false ]; then\n      echo \"ERROR: New task run took longer than $TIMEOUT seconds\"\n      exit 1\n    fi\n  fi\n\n\n\n  echo \"Task $TASK_ARN executed successfully!\"\n  exit 0\n\n}\n\n######################################################\n# When not being tested, run application as expected #\n######################################################\nif [ \"$BASH_SOURCE\" == \"$0\" ]; then\n    set -o errexit\n    set -o pipefail\n    set -u\n    set -e\n    # If no args are provided, display usage information\n    if [ $# == 0 ]; then usage; fi\n\n    # Check for AWS, AWS Command Line Interface\n    require aws\n    # Check for jq, Command-line JSON processor\n    require jq\n\n    # Loop through arguments, two at a time for key and value\n    while [[ $# -gt 0 ]]\n    do\n        key=\"$1\"\n\n        case $key in\n            -k|--aws-access-key)\n                AWS_ACCESS_KEY_ID=\"$2\"\n                shift # past argument\n                ;;\n            -s|--aws-secret-key)\n                AWS_SECRET_ACCESS_KEY=\"$2\"\n                shift # past argument\n                ;;\n            -r|--region)\n                AWS_DEFAULT_REGION=\"$2\"\n                shift # past argument\n                ;;\n            -p|--profile)\n                AWS_PROFILE=\"$2\"\n                shift # past argument\n                ;;\n            --aws-instance-profile)\n                echo \"--aws-instance-profile is not yet in use\"\n                AWS_IAM_ROLE=true\n                ;;\n            -a|--aws-assume-role)\n                AWS_ASSUME_ROLE=\"$2\"\n                shift\n                ;;\n            -c|--cluster)\n                CLUSTER=\"$2\"\n                shift # past argument\n                ;;\n            -n|--service-name)\n                SERVICE=\"$2\"\n                shift # past argument\n                ;;\n            -d|--task-definition)\n                TASK_DEFINITION=\"$2\"\n                shift\n                ;;\n            -i|--image)\n                IMAGE=\"$2\"\n                shift\n                ;;\n            -t|--timeout)\n                TIMEOUT=\"$2\"\n                shift\n                ;;\n            -m|--min)\n                MIN=\"$2\"\n                shift\n                ;;\n            -M|--max)\n                MAX=\"$2\"\n                shift\n                ;;\n            -D|--desired-count)\n                DESIRED=\"$2\"\n                shift\n                ;;\n            -e|--tag-env-var)\n                TAGVAR=\"$2\"\n                shift\n                ;;\n            -to|--tag-only)\n                TAGONLY=\"$2\"\n                shift\n                ;;\n            --max-definitions)\n                MAX_DEFINITIONS=\"$2\"\n                shift\n                ;;\n            --task-definition-file)\n                TASK_DEFINITION_FILE=\"$2\"\n                shift\n                ;;\n            --enable-rollback)\n                ENABLE_ROLLBACK=true\n                ;;\n            --use-latest-task-def)\n                USE_MOST_RECENT_TASK_DEFINITION=true\n                ;;\n            --force-new-deployment)\n                FORCE_NEW_DEPLOYMENT=true\n                ;;\n            --skip-deployments-check)\n                SKIP_DEPLOYMENTS_CHECK=true\n                ;;\n            --run-task)\n                RUN_TASK=true\n                ;;\n            --launch-type)\n                RUN_TASK_LAUNCH_TYPE=\"$2\"\n                shift\n                ;;\n            --platform-version)\n                RUN_TASK_PLATFORM_VERSION=\"$2\"\n                shift\n                ;;\n            --wait-for-success)\n                RUN_TASK_WAIT_FOR_SUCCESS=true\n                ;;\n            --network-configuration)\n                RUN_TASK_NETWORK_CONFIGURATION=\"$2\"\n                shift\n                ;;\n            --copy-task-definition-tags)\n                COPY_TASK_DEFINITION_TAGS=true\n                ;;\n            -v|--verbose)\n                VERBOSE=true\n                ;;\n            --version)\n                echo ${VERSION}\n                exit 0\n                ;;\n            *)\n                #If another key was given that is not empty display usage.\n                if [[ ! -z \"$key\" ]]; then\n                  usage\n                  exit 2\n                fi\n            ;;\n        esac\n        shift # past argument or value\n    done\n\n    if [ $VERBOSE == true ]; then\n        set -x\n    fi\n\n    # Check that required arguments are provided\n    assertRequiredArgumentsSet\n\n    if [[ \"$AWS_ASSUME_ROLE\" != false ]]; then\n        assumeRole\n    fi\n\n    # Not required creation of new a task definition\n    if [ $FORCE_NEW_DEPLOYMENT == true ]; then\n        updateServiceForceNewDeployment\n        if [[ $SKIP_DEPLOYMENTS_CHECK != true ]]; then\n          waitForGreenDeployment\n        fi\n        exit 0\n    fi\n\n    # Determine image name\n    parseImageName\n    echo \"Using image name: $useImage\"\n\n    # Get current task definition\n    getCurrentTaskDefinition\n    echo \"Current task definition: $TASK_DEFINITION_ARN\";\n\n    # create new task definition json\n    createNewTaskDefJson\n\n    # register new task definition\n    registerNewTaskDefinition\n    echo \"New task definition: $NEW_TASKDEF\";\n\n    # update service if needed\n    if [ $SERVICE == false ]; then\n        if [ $RUN_TASK == true ]; then\n            runTask\n        fi\n        echo \"Task definition updated successfully\"\n    else\n        updateService\n\n        if [[ $SKIP_DEPLOYMENTS_CHECK != true ]]; then\n          waitForGreenDeployment\n        fi\n    fi\n\n    if [[ \"$AWS_ASSUME_ROLE\" != false ]]; then\n        assumeRoleClean\n    fi\n\n    exit 0\n\nfi\n#############################\n# End application run logic #\n#############################\n"
        },
        {
          "name": "local.env.dist",
          "type": "blob",
          "size": 0.0595703125,
          "content": "AWS_ACCESS_KEY_ID=\nAWS_SECRET_ACCESS_KEY=\nAWS_DEFAULT_REGION="
        },
        {
          "name": "run-tests.sh",
          "type": "blob",
          "size": 0.1435546875,
          "content": "#!/usr/bin/env bash\n\napk add bats --update-cache --repository http://dl-3.alpinelinux.org/alpine/edge/community/ --allow-untrusted\n\nbats test.bats\n"
        },
        {
          "name": "test.bats",
          "type": "blob",
          "size": 25.7333984375,
          "content": "#!/usr/bin/env bats\n\n# Tests dont run on linux properly, something to do with set -u\n# See: https://github.com/sstephenson/bats/issues/171\n\nBATS_TEST_SKIPPED=0\n#BATS_ERROR_STACK_TRACE=()\n\nsetup() {\n    # Source in ecs-deploy\n    . \"ecs-deploy\"\n}\n\n@test \"check that usage() returns string and exits with status code 20\" {\n   run usage\n   [ $status -eq 3 ]\n}\n\n@test \"test assertRequiredArgumentsSet success\" {\n  SERVICE=true\n  TASK_DEFINITION=false\n  run assertRequiredArgumentsSet\n  [ ! -z $status ]\n}\n@test \"test assertRequiredArgumentsSet status=5\" {\n  SERVICE=false\n  TASK_DEFINITION=false\n  run assertRequiredArgumentsSet\n  [ $status -eq 5 ]\n}\n@test \"test assertRequiredArgumentsSet status=6\" {\n  SERVICE=true\n  TASK_DEFINITION=true\n  run assertRequiredArgumentsSet\n  [ $status -eq 6 ]\n}\n@test \"test assertRequiredArgumentsSet status=7\" {\n  SERVICE=true\n  CLUSTER=false\n  run assertRequiredArgumentsSet\n  [ $status -eq 7 ]\n}\n@test \"test assertRequiredArgumentsSet status=8\" {\n  SERVICE=true\n  CLUSTER=true\n  IMAGE=false\n  FORCE_NEW_DEPLOYMENT=false\n  run assertRequiredArgumentsSet\n  [ $status -eq 8 ]\n}\n@test \"test assertRequiredArgumentsSet status=9\" {\n  SERVICE=true\n  CLUSTER=true\n  IMAGE=true\n  MAX_DEFINITIONS=\"not a number\"\n  run assertRequiredArgumentsSet\n  [ $status -eq 9 ]\n}\n\n# Image name parsing tests\n# Reference image name format: [domain][:port][/repo][/][image][:tag]\n\n@test \"test parseImageName missing image name\" {\n  IMAGE=\"\"\n  run parseImageName\n  [ $status -eq 13 ]\n}\n\n@test \"test parseImageName invalid image name 1\" {\n  IMAGE=\"/something\"\n  run parseImageName\n  [ $status -eq 13 ]\n}\n\n@test \"test parseImageName invalid port\" {\n  IMAGE=\"domain.com:abc/repo/image\"\n  run parseImageName\n  [ $status -eq 13 ]\n}\n\n@test \"test parseImageName root image no tag\" {\n  IMAGE=\"mariadb\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"mariadb:latest\" ]\n}\n\n@test \"test parseImageName root image with tag\" {\n  IMAGE=\"mariadb:1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"mariadb:1.2.3\" ]\n}\n\n@test \"test parseImageName repo image no tag\" {\n  IMAGE=\"repo/image\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"repo/image:latest\" ]\n}\n\n@test \"test parseImageName repo image with tag\" {\n  IMAGE=\"repo/image:v1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"repo/image:v1.2.3\" ]\n}\n\n@test \"test parseImageName repo multilevel image no tag\" {\n  IMAGE=\"repo/multi/level/image\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"repo/multi/level/image:latest\" ]\n}\n\n@test \"test parseImageName repo multilevel image with tag\" {\n  IMAGE=\"repo/multi/level/image:v1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"repo/multi/level/image:v1.2.3\" ]\n}\n\n@test \"test parseImageName domain plus repo image no tag\" {\n  IMAGE=\"docker.domain.com/repo/image\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com/repo/image:latest\" ]\n}\n\n@test \"test parseImageName domain plus repo image with tag\" {\n  IMAGE=\"docker.domain.com/repo/image:1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com/repo/image:1.2.3\" ]\n}\n\n@test \"test parseImageName domain plus repo multilevel image no tag\" {\n  IMAGE=\"docker.domain.com/repo/multi/level/image\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com/repo/multi/level/image:latest\" ]\n}\n\n@test \"test parseImageName domain plus repo multilevel image with tag\" {\n  IMAGE=\"docker.domain.com/repo/multi/level/image:1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com/repo/multi/level/image:1.2.3\" ]\n}\n\n@test \"test parseImageName domain plus port plus repo image no tag\" {\n  IMAGE=\"docker.domain.com:8080/repo/image\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com:8080/repo/image:latest\" ]\n}\n\n@test \"test parseImageName domain plus port plus repo image with tag\" {\n  IMAGE=\"docker.domain.com:8080/repo/image:1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com:8080/repo/image:1.2.3\" ]\n}\n\n@test \"test parseImageName domain plus port plus repo multilevel image no tag\" {\n  IMAGE=\"docker.domain.com:8080/repo/multi/level/image\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com:8080/repo/multi/level/image:latest\" ]\n}\n\n@test \"test parseImageName domain plus port plus repo multilevel image with tag\" {\n  IMAGE=\"docker.domain.com:8080/repo/multi/level/image:1.2.3\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com:8080/repo/multi/level/image:1.2.3\" ]\n}\n\n@test \"test parseImageName domain plus port plus repo image with tag from var\" {\n  IMAGE=\"docker.domain.com:8080/repo/image\"\n  TAGVAR=\"CI_TIMESTAMP\"\n  CI_TIMESTAMP=\"1487623908\"\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com:8080/repo/image:1487623908\" ]\n}\n\n@test \"test parseImageName domain plus port plus repo multilevel image with tag from var\" {\n  IMAGE=\"docker.domain.com:8080/repo/multi/level/image\"\n  TAGVAR=\"CI_TIMESTAMP\"\n  CI_TIMESTAMP=\"1487623908\"\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"docker.domain.com:8080/repo/multi/level/image:1487623908\" ]\n}\n\n@test \"test parseImageName using ecr style domain\" {\n  IMAGE=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:latest\" ]\n}\n\n@test \"test parseImageName using ecr style image name and tag from var\" {\n  IMAGE=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  TAGVAR=\"CI_TIMESTAMP\"\n  CI_TIMESTAMP=\"1487623908\"\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\" ]\n}\n\n@test \"test createNewTaskDefJson with single container in definition\" {\n  imageWithoutTag=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  useImage=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\"\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"bridge\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value * \"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"placementConstraints\": null,\n        \"revision\": 123\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value * \" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"bridge\" }'\n  run createNewTaskDefJson\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test createNewTaskDefJson with single container in definition for AWS Fargate\" {\n  imageWithoutTag=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  useImage=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\"\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"awsvpc\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"revision\": 123,\n        \"executionRoleArn\": \"arn:aws:iam::121212345678:role/ecsTaskExecutionRole\",\n        \"compatibilities\": [\n            \"EC2\",\n            \"FARGATE\"\n        ],\n        \"requiresCompatibilities\": [\n            \"FARGATE\"\n        ],\n        \"cpu\": \"256\",\n        \"memory\": \"512\"\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"awsvpc\", \"executionRoleArn\": \"arn:aws:iam::121212345678:role/ecsTaskExecutionRole\", \"requiresCompatibilities\": [ \"FARGATE\" ], \"cpu\": \"256\", \"memory\": \"512\" }'\n  run createNewTaskDefJson\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test createNewTaskDefJson with multiple containers in definition\" {\n  imageWithoutTag=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  useImage=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\"\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"bridge\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            },\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"cache\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"redis:latest\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 6376,\n                        \"hostPort\": 10376\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"placementConstraints\": null,\n        \"revision\": 123\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] }, { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"cache\", \"links\": [], \"mountPoints\": [], \"image\": \"redis:latest\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 6376, \"hostPort\": 10376 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"bridge\" }'\n  run createNewTaskDefJson\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test createNewTaskDefJson with single container in definition and different repository\" {\n  imageWithoutTag=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  useImage=\"111222333444.dkr.ecr.eu-west-1.amazonaws.com/acct/repo:1111111111\"\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"bridge\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"placementConstraints\": null,\n        \"revision\": 123\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"111222333444.dkr.ecr.eu-west-1.amazonaws.com/acct/repo:1111111111\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"bridge\" }'\n  run createNewTaskDefJson\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test createNewTaskDefJson with multiple containers in definition and different repository\" {\n  imageWithoutTag=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  useImage=\"111222333444.dkr.ecr.eu-west-1.amazonaws.com/acct/repo:1111111111\"\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"bridge\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            },\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"cache\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"redis:latest\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 6376,\n                        \"hostPort\": 10376\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"placementConstraints\": null,\n        \"revision\": 123\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"111222333444.dkr.ecr.eu-west-1.amazonaws.com/acct/repo:1111111111\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] }, { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"cache\", \"links\": [], \"mountPoints\": [], \"image\": \"redis:latest\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 6376, \"hostPort\": 10376 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"bridge\" }'\n  run createNewTaskDefJson\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test parseImageName with tagonly option\" {\n  TAGONLY=\"newtag\"\n  IMAGE=\"ignore\"\n\n  expected=$TAGONLY\n\n  run parseImageName\n\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test createNewTaskDefJson with multiple containers in definition and replace only tags\" {\n  TAGONLY=\"newtag\"\n  useImage=$TAGONLY\n\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"bridge\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            },\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value\"\n                    }\n                ],\n                \"name\": \"cache\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"redis:latest\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 6376,\n                        \"hostPort\": 10376\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"placementConstraints\": null,\n        \"revision\": 123\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:newtag\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] }, { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value\" } ], \"name\": \"cache\", \"links\": [], \"mountPoints\": [], \"image\": \"redis:newtag\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 6376, \"hostPort\": 10376 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"bridge\" }'\n  run createNewTaskDefJson\n  echo $output\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n\n@test \"test parseImageName using image starting with underscore\" {\n  IMAGE=\"_something:tag123\"\n  TAGVAR=false\n  run parseImageName\n  [ $status -eq 13 ]\n}\n\n@test \"test parseImageName using image containing an underscore in tag name\" {\n  IMAGE=\"something:tag_123\"\n  TAGVAR=false\n  run parseImageName\n  [ ! -z $status ]\n  [ \"$output\" == \"something:tag_123\" ]\n  echo \"output = $output\" 1>&2\n}\n\n@test \"test createNewTaskDefJson with existing proxyConfiguration value\" {\n  imageWithoutTag=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo\"\n  useImage=\"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\"\n  TASK_DEFINITION=$(cat <<EOF\n{\n    \"taskDefinition\": {\n        \"status\": \"ACTIVE\",\n        \"networkMode\": \"bridge\",\n        \"family\": \"app-task-def\",\n        \"requiresAttributes\": [\n            {\n                \"name\": \"com.amazonaws.ecs.capability.ecr-auth\"\n            }\n        ],\n        \"volumes\": [],\n        \"taskDefinitionArn\": \"arn:aws:ecs:us-east-1:121212345678:task-definition/app-task-def:123\",\n        \"containerDefinitions\": [\n            {\n                \"environment\": [\n                    {\n                        \"name\": \"KEY\",\n                        \"value\": \"value * \"\n                    }\n                ],\n                \"name\": \"API\",\n                \"links\": [],\n                \"mountPoints\": [],\n                \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1487623908\",\n                \"essential\": true,\n                \"portMappings\": [\n                    {\n                        \"protocol\": \"tcp\",\n                        \"containerPort\": 80,\n                        \"hostPort\": 10080\n                    }\n                ],\n                \"entryPoint\": [],\n                \"memory\": 128,\n                \"command\": [\n                    \"/data/run.sh\"\n                ],\n                \"cpu\": 200,\n                \"volumesFrom\": []\n            }\n        ],\n        \"placementConstraints\": null,\n        \"proxyConfiguration\": {\n            \"containerName\": \"example\"\n        },\n        \"revision\": 123\n    }\n}\nEOF\n)\n  expected='{ \"family\": \"app-task-def\", \"volumes\": [], \"containerDefinitions\": [ { \"environment\": [ { \"name\": \"KEY\", \"value\": \"value * \" } ], \"name\": \"API\", \"links\": [], \"mountPoints\": [], \"image\": \"121212345678.dkr.ecr.us-east-1.amazonaws.com/acct/repo:1111111111\", \"essential\": true, \"portMappings\": [ { \"protocol\": \"tcp\", \"containerPort\": 80, \"hostPort\": 10080 } ], \"entryPoint\": [], \"memory\": 128, \"command\": [ \"/data/run.sh\" ], \"cpu\": 200, \"volumesFrom\": [] } ], \"placementConstraints\": null, \"networkMode\": \"bridge\", \"proxyConfiguration\": { \"containerName\": \"example\" } }'\n  run createNewTaskDefJson\n  [ ! -z $status ]\n  [ \"$(echo \"$output\" | jq .)\" == \"$(echo \"$expected\" | jq .)\" ]\n}\n"
        }
      ]
    }
  ]
}