{
  "metadata": {
    "timestamp": 1736568810432,
    "page": 964,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk2OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sdushantha/tmpsms",
      "stars": 1045,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "MIT License\n\nCopyright (c) 2021 Siddharth Dushantha\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.294921875,
          "content": "# tmpsms no longer works\n\ntmpsms was pretty much a wrapper around [Upmasked's](https://upmasked.com/) temporary SMS service but Upmasked seems to have taken down their website as well as their [GitHub account](https://github.com/upmasked/). `tmpsms` may come back in the future if I can find another reliable SMS service. But even if I do find one sometime soon, it unlikely I will further develop `tmpsms` to use that service as I have other priorities.\n\n----\n\n<h1 align=\"center\">\n  <img src=\"images/logo.png\">\n</h1>\n\n<p align=\"center\">A temporary SMS right from your terminal written in POSIX sh</p>\n<p align=\"center\">\n<img src=\"images/demo.gif\"> \n</p>\n\n`tmpsms` is a command line utility written in POSIX `sh` that allows you to get a\ntemporary phone number and receive SMSes. It uses [Upmasked](https://upmasked.com/) temporary SMS service in order to receive the messages. This is a very useful\ntool for those testing applications during bug bounty hunting or who just need some privacy and don't want to use a personal phone number.\nThis is easy to use with simple outputs. `tmpsms` can be integrated with other scripts to improve your workflow.\n\n## Dependencies\n- `curl`\n- [`jq`](https://github.com/stedolan/jq)\n- [`fzf`](https://github.com/junegunn/fzf)\n\n## Installation\n```bash\n# Download the tmpsms file and make it executable\n$ curl -L \"https://git.io/tmpsms\" > tmpsms && chmod +x tmpsms\n\n# Then move it somewhere in your $PATH. Here is an example:\n$ mv tmpsms ~/bin/\n```\n\n## Usage\n```console\n$ tmpsms --help\ntmpsms [--count <count>]\ntmpsms init [--fzf <arguments>]\ntmpsms -h | --version\n\nWhen called with no options or commands, tmpsms lists\nthe 3 newest messages.\n\nOptions\n-h, --help     Show this help message\n-c, --count    Only show the <count> newest messages\n--version      Show version\n\nCommands\ninit           Initialize a new phone number by selecting one\n               from the available ones using 'fzf'\n  --fzf        Extra arguments to use for 'fzf'\n```\n\n## Examples\nInitialize a new phone number\n```console\n$ tmpsms init\n```\n\nView the 5 newest messages. By default `tmpsms` shows the 3 newest messages.\n```console\n$ tmpsms --count 5\n```\n\nIf you find it a hassle to rerun `tmpsms` every few seconds, use `watch` with a delay of 5 seconds. Upmasked only updates messages every 5 seconds.\n```console\n$ watch -n 5 \"tmpsms\"\n```\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "tmpsms",
          "type": "blob",
          "size": 8.2685546875,
          "content": "#!/usr/bin/env sh\n#\n# by Siddharth Dushantha\n#\n\nVERSION=\"1.0.0\"\n\n# Everything related to 'tmpsms' will be stored in this directory. Once the\n# computer get restarted, this directory gets deleted.\nTMPSMS_DIR=\"/tmp/tmpsms\"\n\n# The phone number that the user has selected gets stored in this file so that\n# the do not have reselect at ever run.\nTMPSMS_PHONE_NUMBER=\"$TMPSMS_DIR/phonenumber.txt\"\n\n# 'fzf' is used to allow the user to select a phone number. This variable\n# stores extra arguments which the user might to provide, so that 'fzf'\n# behaves to their liking.\nFZF_ARGUMENTS=\"\"\n\n# The temporary SMS service is provided by Upmasked\nAPI=\"https://upmasked.com\"\n\nusage(){\n    # Using 'cat << EOF' we can easily output a multiline text. This is much\n    # better than using 'echo' for each line or using '\\n' to create a new line.\n    cat <<EOF\ntmpsms [--count <count>]\ntmpsms init [--fzf <arguments>]\ntmpsms -h | --version\n\nWhen called with no options or commands, tmpsms lists\nthe 3 newest messages.\n\nOptions\n-h, --help     Show this help message\n-c, --count    Only show the <count> newest messages\n--version      Show version\n\nCommands\ninit           Initialize a new phone number by selecting one\n               from the available ones using 'fzf'\n  --fzf        Extra arguments to use for 'fzf'\nEOF\n}\n\nprint_error(){\n    # Print error message\n    #\n    # The first argument provided to this function will be the error message.\n    # Script will exit after printing the error message.\n    printf \"%s\\n\" \"Error: $1\" >&2\n    exit 1\n}\n\n\nselect_phone_number(){\n    # There are 2 ways which this function is called in this script.\n    # [1] The user wants to initilize a new phone number by running 'tmpsms init'\n    # [2] The user runs 'tmpsms' to check for new messages, but $TMPSMS_PHONE_NUMBER\n    #     does't exist. Therefore they have to select phone number before we can \n    #     show them the messages.\n    #\n    # When the function 'select_phone_number()' is called with the argument 'true'\n    # that means this function was called becaues the user ran 'tmpsms init'\n    #\n    # We need this variable so we can know whether or not we need to show the user\n    # the phone number they have selected. If they ran 'tmpsms init', then we will\n    # show them the phone number they selected. This is so that they can easily\n    # copy and paste it to whatever site that needs the phone number.\n    EXTERNALLY=${1:-false}\n    \n    # Fetch the available phone numbers\n    DATA=$(curl -s \"$API/api/sms/numbers\")\n\n    # Using 'jq' we are able to get the length of the JSON data retreived from\n    # API. The length indicates the the total number of phone numbers available.\n    DATA_LENGTH=$(printf %s \"$DATA\" | jq length)\n\n    # This is where we store the phone numbers which then gets shown to the user\n    # through 'fzf' so that they can select one.\n    PHONE_NUMBERS=\"\"\n\n    index=1\n    while [ $index -le \"$DATA_LENGTH\" ]; do\n        # Since arrays in JSON data start at 0, we must subtract\n        # the value of $index by 1 so that we dont miss one of the\n        # phone numbers in the array\n        PHONE_NUMBER_INFO=$(printf %s \"$DATA\" | jq -r \".[$index-1]\")\n        PHONE_NUMBER=$(printf %s \"$PHONE_NUMBER_INFO\" | jq -r \".number\")\n        COUNTRY_CODE=$(printf %s \"$PHONE_NUMBER_INFO\" | jq -r \".country\")\n\n        PHONE_NUMBERS=\"$PHONE_NUMBERS$COUNTRY_CODE +$PHONE_NUMBER\\n\"\n        index=$((index+1))\n    done\n    \n    # By default we use 'fzf' without any arguments in order to display the\n    # phone numbers they can use. If the '--fzf' argument is passed along with\n    # 'fzf' arguments, 'tmpsms' will make sure to use them.\n    FZF_COMMAND=\"fzf\"\n    [ -n \"$FZF_ARGUMENTS\" ] && FZF_COMMAND=\"fzf $FZF_ARGUMENTS\"\n\n    # If the user did not select a phone number then quit 'tmpsms' as the\n    # user might have just wanted to check if there were any new number\n    # that they could use.\n    SELECTION=$(printf %b \"$PHONE_NUMBERS\" | $FZF_COMMAND)\n    [ -z \"$SELECTION\" ] && print_error \"Phone number was not selected\"\n\n    # Store the selected phone number in $TMPSMS_PHONE_NUMBER for later use \n    printf %s \"$SELECTION\" > \"$TMPSMS_PHONE_NUMBER\"\n\n    # If the user ran 'tmpsms init', then show them their selection\n    [ \"$EXTERNALLY\" = true ] && printf \"%s\\n\" \"$SELECTION\"\n}\n\nlist_messages(){\n    # By default, the 3 newest messages are shown. But if the user would like\n    # to see more of the messages, they can provide how many they want to see\n    # by using the '--count' option.\n    COUNT=\"${1:-3}\"\n\n    # The provided value to '--count' must be an interger. We can verify that it is\n    # an integer by checking if $COUNT matches the regex.\n    REGEX='^[0-9]+$'\n    if ! printf %s \"$COUNT\" | grep -Eq \"$REGEX\";then\n        print_error \"'$COUNT' is not an integer\"\n    fi\n\n    # If /tmp/tmpsms/phonenumber.txt does not exist or is empty that means that\n    # the user has not initialized a phone number yet.\n    [ ! -s \"$TMPSMS_PHONE_NUMBER\" ] && print_error \"A phone number must be initilzied in order to view the messages\"\n\n    # The country code is needed because it gets displayed to the user. It may\n    # be useful for the user to know which country the phone number is from\n    # so that they dont have to guess by looking at the area code.\n    COUNTRY_CODE=$(awk -F\" \" '{print $1}' < $TMPSMS_PHONE_NUMBER)\n    PHONE_NUMBER=$(awk -F\"+\" '{print $2}' < $TMPSMS_PHONE_NUMBER)\n    DATA=$(curl -s \"$API/api/sms/messages/$PHONE_NUMBER\")\n\n    # Even though we are using the phone numbers that are available on\n    # upmasked.com, there is a chance that they might remove one of the numbers.\n    # The checking needs to be done in case the phone number that is stored in\n    # $TMPSMS_PHONE_NUMBER has been removed.\n    if printf %s \"$DATA\" | grep -Eq \"Not Found\"; then\n        print_error \"Looks like the phone number '+$PHONE_NUMBER' no longer exists. Initialize a new one and try again.\"\n    fi\n\n    DATA_LENGTH=$(printf %s \"$DATA\" | jq length)\n\n    # If the number of messages the user wants to view is greater than the\n    # number of messages that are available, then make sure to show\n    # all the messages that are available.\n    [ \"$COUNT\" -gt \"$DATA_LENGTH\" ] && COUNT=\"$DATA_LENGTH\"\n\n    # Show a nice little header before showing the messages\n    printf \"%s\\n\\n\" \"[ Messages for +$PHONE_NUMBER ($COUNTRY_CODE) ]\"\n\n    # All the messages get stored in here\n    MESSAGES=\"\"\n\n    index=1\n    while [ $index -le \"$COUNT\" ]; do\n        # Since arrays in JSON data start at 0, we must subtract\n        # the value of $index by 1 so that we dont miss one of the\n        # messages in the array\n        MESSAGE_DATA=$(printf %s \"$DATA\" | jq -r \".[$index-1]\")\n        BODY=$(printf %s \"$MESSAGE_DATA\" | jq -r \".body\" | tr \"\\n\" \" \")\n        SENDER=$(printf %s \"$MESSAGE_DATA\" | jq -r \".originator\")\n        \n        # The '||' is used as a divider for 'column'. 'column' will use this\n        # divider as a point of reference to create the division. By default\n        # 'column' uses a blank space but that would not work in our case as the\n        # message could have multiple white spaces and 'column' would\n        # split the words that are seperated by white space, in different columns.\n        MESSAGES=\"$MESSAGES$SENDER ||$BODY\\n\"\n\n        index=$((index+1))\n    done\n\n    # Show the messages cleanly\n    printf \"%b\" \"$MESSAGES\" | column -t -s \"||\"\n}\n\nmain(){\n    # Iterate the array of dependencies and check if the user has them installed.\n    for dependency in jq curl fzf; do\n        if ! command -v \"$dependency\" >/dev/null 2>&1; then\n            print_error \"Could not find '$dependency', is it installed?\"\n        fi\n    done\n\n    # Create the $TMPSMS_DIR directory and dont throw any errors\n    # if it already exists\n    mkdir -p \"$TMPSMS_DIR\"\n\n    # If no arguments are provided just show the messages \n    [ $# -eq 0 ] && list_messages && exit 0\n\n    while [ \"$1\" ]; do\n        case \"$1\" in\n            init)\n                case \"$2\" in\n                    --fzf) FZF_ARGUMENTS=\"$3\" && select_phone_number true ;;\n                    \"\") select_phone_number true ;;\n                esac ;;\n            --help | -h) usage && exit ;;\n            --count | -c) list_messages \"$2\" && shift 2;;\n            --version) printf %s \"$VERSION\" && exit ;;\n            -*) print_error \"option '$1' does not exist\" ;;\n            *) print_error \"command '$1' does not exist\" ;;\n        esac\n        shift\n    done\n}\n\nmain \"$@\"\n"
        }
      ]
    }
  ]
}