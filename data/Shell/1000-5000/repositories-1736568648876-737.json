{
  "metadata": {
    "timestamp": 1736568648876,
    "page": 737,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lamw/ghettoVCB",
      "stars": 1301,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0322265625,
          "content": "Copyright (c) 2008-2023 WilliamLam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 66.1533203125,
          "content": "# ghettoVCB\n\n## Table of Contents\n\n* [Description](#description)\n* [Features](#features)\n* [Requirements](#requirements)\n* [Download](#download)\n* [Install](#install)\n* [Uninstall](#uninstall)\n* [Build VIB and Offline Bundle](#build-vib-and-offline-bundle)\n* [Configuration Options](#configuration-options)\n* [Usage](#usage)\n* [Sample Execution](#sample-execution)\n    * [Dry Run](#dry-run)\n    * [Debug](#debug)\n    * [Backup VMs stored in a list](#backup-vms-stored-in-a-list)\n    * [Backup Single VM using CLI](#backup-single-vm-using-cli)\n    * [Backup All VMs residing on specific host](#backup-all-vms-residing-on-specific-host)\n    * [Backup VMs based on individual VM backup policies](#backup-vms-based-on-individual-vm-backup-policies)\n* [Stopping ghettoVCB Process](#stopping-ghettovcb-process)\n* [Scheduling Backups using Cron](#scheduling-backups-using-cron)\n* [Restore Backups](#restore-backups)\n\n\n## Description\n\nThe ghettoVCB script performs backups of virtual machines residing on ESX(i) 3.x, 4.x, 5.x, 6.x, 7.x & 8.x servers using methodology similar to VMware's VCB tool. The script takes snapshots of live running virtual machines, backs up the  master VMDK(s) and then upon completion, deletes the snapshot until the next backup. The only caveat is that it utilizes resources available to the ESXi Shell running the backups as opposed to following the traditional method of offloading virtual machine backups through a VCB proxy.\n\nThis script has been tested on ESX 3.5/4.x/5.x and ESXi 3.5/4.x/5.x/6.x/7.x/8.x and supports the following backup mediums: LOCAL STORAGE, SAN and NFS. The script is non-interactive and can be setup to run via cron. Currently, this script accepts a text file that lists the display names of virtual machine(s) that are to be backed up. Additionally, one can specify a folder containing configuration files on a per VM basis for  granular control over backup policies.\n\nAdditionally, for ESX(i) environments that don't have persistent NFS datastores designated for backups, the script offers the ability to automatically connect the ESX(i) server to a NFS exported folder and then upon backup completion, disconnect it from the ESX(i) server. The connection is established by creating an NFS datastore link which enables monolithic (or thick) VMDK backups as opposed to using the usual  *nix mount command which necessitates breaking VMDK files into the 2gbsparse format for backup. Enabling this mode is self-explanatory and will evidently be so when editing the script (Note: `VM_BACKUP_VOLUME` variable is ignored if `ENABLE_NON_PERSISTENT_NFS=1`).\n\nIn its current configuration, the script will allow up to 3 unique backups of the Virtual Machine before it will overwrite the previous backups; this however, can be modified to fit procedures if need be. Please be diligent in running the script in a test or staging environment before using it on production live Virtual Machines; this script functions well within our environment but there is a chance that  it may not fit well into other environments.\n\n**Note:** If you have found this script to be useful and would like to contribute back, feel free to [donate a cup of coffee](https://www.buymeacoffee.com/lamw) â˜•ðŸ˜\n\n## Features\n* Online back up of VM(s)\n* Support for multiple VMDK disk(s) backup per VM\n    * Only valid VMDK(s) presented to the VM will be backed up\n* Ability to shutdown guestOS and initiate backup process and power on VM afterwards with the option of hard power timeout\n* Allow spaces in VM(s) backup list (not recommended and not a best practice)\n* Ensure that snapshot removal process completes prior to to continuing onto the next VM backup\n    * VM(s) that intially contain snapshots will not be backed up and will be ignored\n* Ability to specify the number of backup rotations for VM\n* Output back up VMDK(s) in either ZEROEDTHICK (default behavior) or 2GB SPARSE or THIN or EAGERZEROEDTHICK format\n* Support for both SCSI and IDE disks\n* Non-persistent NFS backup\n* Fully support VMDK(s) stored across multiple datastores\n* Ability to compress backups\n* Ability to configure individual VM backup policies\n* Ability to include/exclude specific VMDK(s) per VM (requires individual VM backup policy setup)\n* Ability to configure logging output to file\n* Independent disk awareness (will ignore VMDK)\n* New timeout variables for shutdown and snapshot creations\n* Ability to configure snapshots with both memory and/or quiesce options\n* Ability to configure disk adapter format\n* Additional debugging information including dry run execution\n* Support for VMs with both virtual/physical RDM (pRDM will be ignored and not backed up)\n* Support for global ghettoVCB configuration file\n* Support for VM exclusion list\n* Ability to backup all VMs residing on a specific host w/o specifying VM list\n* Implemented simple locking mechenism to ensure only 1 instance of ghettoVCB is running per host\n* Updated backup directory structure - rsync friendly\n* Additional logging and final status output\n* Logging of ghettoVCB PID (proces id)\n* Email backup logs\n* Rsync \"Link\" Support (Experimental Suppport)\n* Enhanced \"dryrun\" details including configuration and/or VMDK(s) issues\n* New storage debugging details pre/post backup\n* Quick email status summary\n* Support for individual VM backup via command-line\n* Support VM(s) with existing snapshots\n* Support mulitple running instances of ghettoVCB\n* Configure VM shutdown/startup order\n* Support changing custom VM name during restore\n\n## Requirements:\n* VMs running on ESX(i) 3.5/4.x+/5.x/6.x/7.x/8.x\n* SSH console access to ESX(i) host\n\n## Download\n\nLatest ghettoVCB VIB and Offline Bundle can be downloaded from [here](https://github.com/lamw/ghettoVCB/releases)\n\n## Install\n\nYou can quickly install/update ghettoVCB by downloading and installing either the [VIB or offline bundle](https://github.com/lamw/ghettoVCB/releases) using the following commands. If you wish to update to latest ghettoVCB release and are using the ghettovcb.conf file and wish to have your settings persist, make sure to use the *update* command instead of *install*\n\nOnce installed, you will find all ghettoVCB configuration files located in:\n```console\n/opt/ghettovcb/ghettoVCB.conf\n/opt/ghettovcb/ghettoVCB-restore_vm_restore_configuration_template\n/opt/ghettovcb/ghettoVCB-vm_backup_configuration_template\n```\n\nBoth ghettoVCB and ghettoVCB-restore scripts are located in:\n```console\n/opt/ghettovcb/bin/ghettoVCB.sh\n/opt/ghettovcb/bin/ghettoVCB-restore.sh\n```\n\n### For ESXi 5.x to 6.x\n\nInstall VIB\n```\nesxcli software vib install -v /vghetto-ghettoVCB-7x.vib -f\n```\n\nUpdate VIB\n```\nesxcli software vib update -v /vghetto-ghettoVCB-7x.vib -f\n```\n\nRetrieve installation\n```console\nesxcli software vib get -n ghettoVCB\n```\n\n### For ESXi 7.x\n\nInstall VIB\n```\nesxcli software vib install -v /vghetto-ghettoVCB-7x.vib -f\n```\n\nInstall offline bundle\n```\nesxcli software vib install -d /vghetto-ghettoVCB-offline-bundle-7x.zip -f\n```\n\nUpdate VIB\n```\nesxcli software vib update -v /vghetto-ghettoVCB-7x.vib -f\n```\n\nUpdate offline bundle\n```\nesxcli software vib update -d /vghetto-ghettoVCB-offline-bundle-7x.zip -f\n```\n\nRetrieve installation\n```console\nesxcli software vib get -n ghettoVCB\n```\n\n### For ESXi 8.x and later\n\nInstall VIB\n```\nesxcli software vib install -v /vghetto-ghettoVCB-8x.vib -f\n```\n\nInstall offline bundle\n```\nesxcli software vib install -d /vghetto-ghettoVCB-offline-bundle-8x.zip -f\n```\n\nUpdate VIB\n```\nesxcli software vib update -v /vghetto-ghettoVCB-8x.vib -f\n```\n\nUpdate offline bundle\n```\nesxcli software vib update -d /vghetto-ghettoVCB-offline-bundle-8x.zip -f\n```\n\nRetrieve installation\n```console\nesxcli software vib get -n ghettoVCB\n```\n\n## Uninstall\n\nRemove ghettoVCB\n\n```console\nesxcli software vib remove -n ghettoVCB\n```\n\n> **Note:** If the installation takes some time. Just wait. This is normal.\n\n## Build VIB and Offline Bundle\n\nSee the build documentation [here](build/README.md)\n\n## Configuration Options\n\nThe following variables need to be defined within the script or in VM backup policy prior to execution.\n\nDefining the backup datastore and folder in which the backups are stored (if folder does not exist, it will automatically be created):\n\n```console\nVM_BACKUP_VOLUME=/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\n```\n\nDefining the backup disk format (zeroedthick, eagerzeroedthick, thin, and 2gbsparse are available):\n```console\nDISK_BACKUP_FORMAT=thin\n```\n\n> **Note:** If you are using the 2gbsparse on an ESXi 5.1 host, backups may fail. Please download the latest version of the ghettoVCB script which automatically resolves this or take a look at [this article](https://williamlam.com/2012/09/2gbsparse-disk-format-no-longer-working.html) for the details.\n\nDefining the backup rotation per VM:\n```console\nVM_BACKUP_ROTATION_COUNT=3\n```\n\nDefining whether the VM is powered down or not prior to backup (1 = enable, 0 = disable):\n```console\nPOWER_VM_DOWN_BEFORE_BACKUP=0\n```\n\n> **Note:** VM(s) that are powered off will not require snapshoting\n\nDefining whether the VM can be hard powered off when `POWER_VM_DOWN_BEFORE_BACKUP` is enabled and VM does not have VMware Tools installed\n```console\nENABLE_HARD_POWER_OFF=0\n```\n\nIf `ENABLE_HARD_POWER_OFF` is enabled, then this defines the number of (60sec) iterations the script will before executing a hard power off when:\n```console\nITER_TO_WAIT_SHUTDOWN=3\n```\n\nThe number (60sec) iterations the script will wait when powering off the VM and will give up and ignore the particular VM for backup:\n```console\nPOWER_DOWN_TIMEOUT=5\n```\n\nThe number (60sec) iterations the script will wait when taking a snapshot of a VM and will give up and ignore the particular VM for  backup:\n```console\nSNAPSHOT_TIMEOUT=15\n```\n\nDefining whether or not to enable compression (1 = enable, 0 = disable):\n```console\nENABLE_COMPRESSION=0\n```\n\n> **Note:** With ESXi 3.x/4.x/5.x, there is a limitation of the maximum size of a VM for compression within the unsupported Busybox Console which _should_ not affect backups running classic ESX 3.x,4.x or 5.x. On ESXi 3.x the largest supported VM is 4GB for compression and on ESXi 4.x the largest supported VM is 8GB. If you try to compress a larger VM, you may run into issues when trying to extract upon a restore. **PLEASE TEST THE RESTORE PROCESS BEFORE MOVING TO PRODUCTION SYSTEMS!**. Please note, do not mix uncompressed backups with  compressed backups. Ensure that directories selected for backups do not contain any backups with previous versions of ghettoVCB before enabling  and implementing the compressed backups feature.\n\nDefining whether virtual machine memory is snapped and if quiescing is enabled (1 = enable, 0 = disable):\n```console\nVM_SNAPSHOT_MEMORY=0\nVM_SNAPSHOT_QUIESCE=0\n```\n\n> **Note:** `VM_SNAPSHOT_MEMORY` is only used to ensure when the snapshot is taken, it's memory contents  are also captured. This is only relevant to the actual snapshot and it's  not used in any shape/way/form in regards to the backup. All backups  taken whether your VM is running or offline will result in an offline VM  backup when you restore. This was originally added for debugging  purposes and in generally should be left disabled\n\nDefining VMDK(s) to backup from a particular VM either a list of vmdks or \"all\"\n```console\nVMDK_FILES_TO_BACKUP=\"myvmdk.vmdk\"\n```\n\nDefining whether or not VM(s) with existing snapshots can be backed up. This flag means it will **CONSOLIDATE ALL EXISTING SNAPSHOTS** for a VM prior to starting the backup (1 = yes, 0 = no):\n```console\nALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP=0\n```\n\nDefining the order of which VM(s) should be shutdown first, especially if there is a dependency between multiple VM(s). This should be a comma seperate list of VM(s)\n```console\nVM_SHUTDOWN_ORDER=vm1,vm2,vm3\n```\n\nDefining the order of VM(s) that should be started up first after backups have completed, especially if there is a dependency between multiple VM(s). This should be a comma seperate list of VM(s)\n```console\nVM_STARTUP_ORDER=vm3,vm2,vm1\n```\n\nDefining NON-PERSISTENT NFS Backup Volume (1 = yes, 0 = no):\n```console\nENABLE_NON_PERSISTENT_NFS=0\n```\n\n> **Note:** This is meant for environments that do not want a persisted connection to their NFS backup volume and allows the NFS volume to only be mounted during backups. The script expects the following 5 variables to be defined if this is to be used: `UNMOUNT_NFS`, `NFS_SERVER`, `NFS_MOUN`T`, `NFS_LOCAL_NAME` and `NFS_VM_BACKUP_DIR`\n\nDefining whether or not to unmount the NFS backup volume (1 = yes, 0 = no):\n```console\nUNMOUNT_NFS=0\n```\n\nDefining the NFS server address (IP/hostname):\n```console\nNFS_SERVER=172.51.0.192\n```\n\nDefining the NFS export path:\n```console\nNFS_MOUNT=/upload\n```\n\nDefining the NFS datastore name:\n```console\nNFS_LOCAL_NAME=backup\n```\n\nDefining the NFS backup directory for VMs:\n```console\nNFS_VM_BACKUP_DIR=mybackups\n```\n\n> **Note:** Only supported if you are running vSphere 4. and later. If you are having issues with sending mail, please take a look at Email Backup Log section\n\nDefining whether or not to email backup logs (1 = yes, 0 = no):\n```console\nEMAIL_LOG=1\n```\n\nDefining whether or not to email message will be deleted off the host  whether it is successful in sending, this is used for debugging  purposes. (1 = yes, 0 = no):\n```console\nEMAIL_DEBUG=1\n```\n\nDefining email server:\n```console\nEMAIL_SERVER=auroa.primp-industries.com\n```\n\nDefining email server port:\n```console\nEMAIL_SERVER_PORT=25\n```\n\nDefining email delay interval (useful if you have slow SMTP server and would like to include a delay in netcat using -i param, default is 1second):\n```console\nEMAIL_DELAY_INTERVAL=1\n```\n\nDefining recipient of the email (comma separated):\n```console\nEMAIL_TO=auroa@primp-industries.com\n```\n\nDefining from user which may require specific domain entry depending on email server configurations:\n```console\nEMAIL_FROM=root@ghettoVCB\n```\n\n> **Note:** nc (netcat) utility must be present for email support to function, this utility is a now a default with the release of vSphere 4.1 or greater, previous releases of VI 3.5 and/or vSphere 4.0 does not contain this utility. The reason this is listed as experimental is it may not be compatible with all email servers as the script utlizes nc (netcat) utility to communicate to an email server. This feature is  provided as-is with no guarantees. If you enable this feature, a  separate log will be generated along side  any normal logging which will be used to email recipient. If for whatever reason, the email fails to  send, an entry will appear per the normal logging mechanism.\n\nIf you are running ESXi 5.1 and later, you will need to create a custom firewall rule to allow your email traffic to go out which I will assume is default port 25. Here are the steps for creating a custom email rule.\n\nStep 1 - Create a file called /etc/vmware/firewall/email.xml with contains the following:\n```console\n<ConfigRoot>\n  <service>\n    <id>email</id>\n    <rule id=\"0000\">\n      <direction>outbound</direction>\n      <protocol>tcp</protocol>\n      <porttype>dst</porttype>\n      <port>25</port>\n    </rule>\n    <enabled>true</enabled>\n    <required>false</required>\n  </service>\n</ConfigRoot>\n```\n\nStep 2 - Reload the ESXi firewall by running the following ESXCLI command:\n```console\n# esxcli network firewall refresh\n```\n\nStep 3 - Confirm that your email rule has been loaded by running the following ESXCLI command:\n```console\n# esxcli network firewall ruleset list | grep email\nemail                  true\n```\n\nStep 4 - Connect to your email server by usingn nc (netcat) by running the following command and specifying the IP Address/Port of your email server:\n```console\n\n# nc 172.30.0.107 25\n220 mail.primp-industries.com ESMTP Postfix\n```\n\nYou should recieve a response from your email server and you can enter Ctrl+C to exit. This custom ESXi firewall rule will not persist after a reboot, so you should create a custom VIB to ensure it persists after a system reboot. Please take a look at [this article](https://williamlam.com/2023/07/creating-a-custom-vib-for-esxi-8-x.html) for the details.\n\n\nDefining to support RSYNC symbolic link creation (1 = yes, 0 = no):\n```console\nRSYNC_LINK=0\n```\n\nTo make use of this feature, modify the variable RSYNC_LINK from 0  to 1. Please note, this is an experimental feature request from users that rely on rsync to replicate changes from one datastore volume to  another datastore volume. The premise of this feature is to have a standardized folder that rsync can monitor for changes to replicate to  another backup datastore. When this feature is enabled, a symbolic link  will be generated with the format of \"<VMNAME>-symlink\" and will  reference the latest successful VM backup. You can then rely on this  symbolic link to watch for changes and replicate to your backup  datastore.\n\nHere is an example of what this would look like:\n```console\n[root@himalaya ghettoVCB]# ls -la /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/vcma/\ntotal 0\ndrwxr-xr-x 1 nobody nobody 110 Sep 27 08:08 .\ndrwxr-xr-x 1 nobody nobody  17 Sep 16 14:01 ..\nlrwxrwxrwx 1 nobody nobody  89 Sep 27 08:08 vcma-symlink -> /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/vcma/vcma-2010-09-27_08-07-37\ndrwxr-xr-x 1 nobody nobody  58 Sep 27 08:04 vcma-2010-09-27_08-04-26\ndrwxr-xr-x 1 nobody nobody  58 Sep 27 08:06 vcma-2010-09-27_08-05-55\ndrwxr-xr-x 1 nobody nobody  58 Sep 27 08:08 vcma-2010-09-27_08-07-37\n```\n\n> **Note:** This enables an automatic creation of a generic symbolic link (both a  relative & absolution path) in which users can refer to run  replication backups using rsync from a remote host. This does not  actually support rsync backups with ghettoVCB. Please take a look at the  Rsync Section of the documentation for more details.\n\nA sample global ghettoVCB configuration file is included with the download called ghettoVCB.conf. It contains the same variables as defined from above and allows a user  to customize and define multiple global configurations based on a user's environment.\n\n```console\n# cat ghettoVCB.conf\nVM_BACKUP_VOLUME=/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\nDISK_BACKUP_FORMAT=thin\nVM_BACKUP_ROTATION_COUNT=3\nPOWER_VM_DOWN_BEFORE_BACKUP=0\nENABLE_HARD_POWER_OFF=0\nITER_TO_WAIT_SHUTDOWN=3\nPOWER_DOWN_TIMEOUT=5\nENABLE_COMPRESSION=0\nVM_SNAPSHOT_MEMORY=0\nVM_SNAPSHOT_QUIESCE=0\nALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP=0\nENABLE_NON_PERSISTENT_NFS=0\nUNMOUNT_NFS=0\nNFS_SERVER=172.30.0.195\nNFS_MOUNT=/nfsshare\nNFS_LOCAL_NAME=nfs_storage_backup\nNFS_VM_BACKUP_DIR=mybackups\nSNAPSHOT_TIMEOUT=15\nEMAIL_LOG=0\nEMAIL_SERVER=auroa.primp-industries.com\nEMAIL_SERVER_PORT=25\nEMAIL_DELAY_INTERVAL=1\nEMAIL_TO=auroa@primp-industries.com\nEMAIL_FROM=root@ghettoVCB\nWORKDIR_DEBUG=0\nVM_SHUTDOWN_ORDER=\nVM_STARTUP_ORDER=\n```\n\nTo override any existing configurations within the ghettoVCB.sh script and to use a global configuration file, user just needs to specify the -g flag and path to global configuration file.\n\nRunning multiple instances of ghettoVCB is now supported with the latest release by specifying the working directory (-w) flag.\n\nBy default, the working directory of the ghettoVCB instance is /tmp/ghettoVCB.work and you can run another instance by providing an alternate working directory. You should try to minimize the number of ghettoVCB instances running on your ESXi host as it does consume some amount of resources when running in the ESXi Shell. This is considered an experimental feature, so please test in a development environment to ensure everything is working prior to moving to production system.\n\n## Usage\n\n```\n# /opt/ghettovcb/bin/ghettoVCB.sh\n###############################################################################\n#\n# ghettoVCB for ESX/ESXi 3.5, 4.x, 5.x, 6.x, 7.x & 8.x\n# Author: William Lam\n# http://www.virtuallyghetto.com/\n# Documentation: http://communities.vmware.com/docs/DOC-8760\n# Created: 11/17/2008\n# Last modified: 2023_09_29 Version 1\n#\n###############################################################################\n\nUsage: ghettoVCB.sh [options]\n\nOPTIONS:\n   -a     Backup all VMs on host\n   -f     List of VMs to backup\n   -m     Name of VM to backup (overrides -f)\n   -j     Job name to show in email report subject (makes sense only in conjunction with -f)\n   -c     VM configuration directory for VM backups\n   -g     Path to global ghettoVCB configuration file\n   -l     File to output logging\n   -w     ghettoVCB work directory (default: /tmp/ghettoVCB.work)\n   -d     Debug level [info|debug|dryrun] (default: info)\n\n(e.g.)\n\nBackup list of VMs from a file (optionally include a job name for the email report)\n\t/opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup [ -j myJob ]\n\nBackup a single VM\n\t/opt/ghettovcb/bin/ghettoVCB.sh -m vm_to_backup\n\nBackup all VMs residing on this host\n\t/opt/ghettovcb/bin/ghettoVCB.sh -a\n\nBackup all VMs residing on this host except for the VMs in the exclusion list\n\t/opt/ghettovcb/bin/ghettoVCB.sh -a -e vm_exclusion_list\n\nBackup VMs based on specific configuration located in directory\n\t/opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -c vm_backup_configs\n\nBackup VMs using global ghettoVCB configuration file\n\t/opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -g /global/ghettoVCB.conf\n\nOutput will log to /tmp/ghettoVCB.log (consider logging to local or remote datastore to persist logs)\n\t/opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -l /vmfs/volume/local-storage/ghettoVCB.log\n\nDry run (no backup will take place)\n\t/opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -d dryrun\n```\n\nThe input to this script is a file that contains the display name of the  virtual machine(s) separated by a newline. When creating this file on a non-Linux/UNIX system, you may introduce ^M character which can cause  the script to miss-behave. To ensure this does not occur, plesae create  the file on the ESX/ESXi host.\n\nHere is a sample of what the file would look like:\n```console\n[root@himalaya ~]# cat vms_to_backup\nvCOPS\nvMA\nvCloudConnector\n```\n\n## Sample Execution:\n\n### Dry Run\n\nThis execution mode provides a quick summary of details on whether a given set of VM(s)/VMDK(s) will be backed up. It provides additional information such as VMs that may have snapshots, VMDK(s) that are configured as independent disks, or other issues that may cause a VM or VMDK to not backed up.\n\n* Log verbosity: dryrun\n* Log output: stdout & /tmp (default)\n    * Logs by default will be stored in /tmp, these log files may not persist through reboots, especially when dealing with ESXi. You should log to either a local or remote datastore to ensure that logs are kept upon a reboot.\n\n```console\n[root@himalaya]# /opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -d dryrun\nLogging output to \"/tmp/ghettoVCB-2011-03-13_15-19-57.log\" ...\n2011-03-13 15:19:57 -- info: ============================== ghettoVCB LOG START ==============================\n\n2011-03-13 15:19:57 -- info: CONFIG - VERSION = 2011_03_13_1\n2011-03-13 15:19:57 -- info: CONFIG - GHETTOVCB_PID = 30157\n2011-03-13 15:19:57 -- info: CONFIG - VM_BACKUP_VOLUME = /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\n2011-03-13 15:19:57 -- info: CONFIG - VM_BACKUP_ROTATION_COUNT = 3\n2011-03-13 15:19:57 -- info: CONFIG - VM_BACKUP_DIR_NAMING_CONVENTION = 2011-03-13_15-19-57\n2011-03-13 15:19:57 -- info: CONFIG - DISK_BACKUP_FORMAT = thin\n2011-03-13 15:19:57 -- info: CONFIG - POWER_VM_DOWN_BEFORE_BACKUP = 0\n2011-03-13 15:19:57 -- info: CONFIG - ENABLE_HARD_POWER_OFF = 0\n2011-03-13 15:19:57 -- info: CONFIG - ITER_TO_WAIT_SHUTDOWN = 3\n2011-03-13 15:19:57 -- info: CONFIG - POWER_DOWN_TIMEOUT = 5\n2011-03-13 15:19:57 -- info: CONFIG - SNAPSHOT_TIMEOUT = 15\n2011-03-13 15:19:57 -- info: CONFIG - LOG_LEVEL = dryrun\n2011-03-13 15:19:57 -- info: CONFIG - BACKUP_LOG_OUTPUT = /tmp/ghettoVCB-2011-03-13_15-19-57.log\n2011-03-13 15:19:57 -- info: CONFIG - VM_SNAPSHOT_MEMORY = 0\n2011-03-13 15:19:57 -- info: CONFIG - VM_SNAPSHOT_QUIESCE = 0\n2011-03-13 15:19:57 -- info: CONFIG - VMDK_FILES_TO_BACKUP = all\n2011-03-13 15:19:57 -- info: CONFIG - EMAIL_LOG = 0\n2011-03-13 15:19:57 -- info:\n2011-03-13 15:19:57 -- dryrun: ###############################################\n2011-03-13 15:19:57 -- dryrun: Virtual Machine: scofield\n2011-03-13 15:19:57 -- dryrun: VM_ID: 704\n2011-03-13 15:19:57 -- dryrun: VMX_PATH: /vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield.vmx\n2011-03-13 15:19:57 -- dryrun: VMX_DIR: /vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield\n2011-03-13 15:19:57 -- dryrun: VMX_CONF: scofield/scofield.vmx\n2011-03-13 15:19:57 -- dryrun: VMFS_VOLUME: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:19:57 -- dryrun: VMDK(s):\n2011-03-13 15:19:58 -- dryrun:  scofield_3.vmdk 3 GB\n2011-03-13 15:19:58 -- dryrun:  scofield_2.vmdk 2 GB\n2011-03-13 15:19:58 -- dryrun:  scofield_1.vmdk 1 GB\n2011-03-13 15:19:58 -- dryrun:  scofield.vmdk   5 GB\n2011-03-13 15:19:58 -- dryrun: INDEPENDENT VMDK(s):\n2011-03-13 15:19:58 -- dryrun: TOTAL_VM_SIZE_TO_BACKUP: 11 GB\n2011-03-13 15:19:58 -- dryrun: ###############################################\n\n2011-03-13 15:19:58 -- dryrun: ###############################################\n2011-03-13 15:19:58 -- dryrun: Virtual Machine: vMA\n2011-03-13 15:19:58 -- dryrun: VM_ID: 1440\n2011-03-13 15:19:58 -- dryrun: VMX_PATH: /vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vMA/vMA.vmx\n2011-03-13 15:19:58 -- dryrun: VMX_DIR: /vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vMA\n2011-03-13 15:19:58 -- dryrun: VMX_CONF: vMA/vMA.vmx\n2011-03-13 15:19:58 -- dryrun: VMFS_VOLUME: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:19:58 -- dryrun: VMDK(s):\n2011-03-13 15:19:58 -- dryrun:  vMA-000002.vmdk 5 GB\n2011-03-13 15:19:58 -- dryrun: INDEPENDENT VMDK(s):\n2011-03-13 15:19:58 -- dryrun: TOTAL_VM_SIZE_TO_BACKUP: 5 GB\n2011-03-13 15:19:58 -- dryrun: Snapshots found for this VM, please commit all snapshots before continuing!\n2011-03-13 15:19:58 -- dryrun: THIS VIRTUAL MACHINE WILL NOT BE BACKED UP DUE TO EXISTING SNAPSHOTS!\n2011-03-13 15:19:58 -- dryrun: ###############################################\n\n2011-03-13 15:19:58 -- dryrun: ###############################################\n2011-03-13 15:19:58 -- dryrun: Virtual Machine: vCloudConnector\n2011-03-13 15:19:58 -- dryrun: VM_ID: 2064\n2011-03-13 15:19:58 -- dryrun: VMX_PATH: /vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vCloudConnector/vCloudConnector.vmx\n2011-03-13 15:19:58 -- dryrun: VMX_DIR: /vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vCloudConnector\n2011-03-13 15:19:58 -- dryrun: VMX_CONF: vCloudConnector/vCloudConnector.vmx\n2011-03-13 15:19:58 -- dryrun: VMFS_VOLUME: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:19:58 -- dryrun: VMDK(s):\n2011-03-13 15:19:59 -- dryrun:  vCloudConnector.vmdk    3 GB\n2011-03-13 15:19:59 -- dryrun: INDEPENDENT VMDK(s):\n2011-03-13 15:19:59 -- dryrun:  vCloudConnector_1.vmdk  40 GB\n2011-03-13 15:19:59 -- dryrun: TOTAL_VM_SIZE_TO_BACKUP: 3 GB\n2011-03-13 15:19:59 -- dryrun: Snapshots can not be taken for indepdenent disks!\n2011-03-13 15:19:59 -- dryrun: THIS VIRTUAL MACHINE WILL NOT HAVE ALL ITS VMDKS BACKED UP!\n2011-03-13 15:19:59 -- dryrun: ###############################################\n\n2011-03-13 15:19:59 -- info: ###### Final status: OK, only a dryrun. ######\n\n2011-03-13 15:19:59 -- info: ============================== ghettoVCB LOG END ================================\n```\n\nIn the example above, we have 3 VMs to be backed up:\n\n* scofield has 4 VMDK(s) that total up to 11GB and does not contain any snapshots/independent disks and this VM should backup without any issues\n* vMA has 1 VMDK but it also contains a snapshot and clearly this VM will not be backed up until the snapshot has been committed\n* vCloudConnector has 2 VMDK(s), one which is 3GB and another which is 40GB and configured as an independent disk. Since snapshots do not affect independent disk, only the 3GB VMDK will be backed up for this VM as denoted by the \"TOTAL_VM_SIZE_TO_BACKUP\"\n\n### Debug\n\nThis execution modes provides more in-depth information about environment/backup process including additional storage debugging information which provides information about both the source/destination datastore pre and post backups. This can be very useful in troubleshooting backups\n\n* Log verbosity: debug\n* Log output: stdout & /tmp (default)\n    * Logs by default will be stored in /tmp, these log files may not persist  through reboots, especially when dealing with ESXi. You should log to  either a local or remote datastore to ensure that logs are kept upon a reboot.\n\n```console\n[root@himalaya]# /opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -d debug\nLogging output to \"/tmp/ghettoVCB-2011-03-13_15-27-59.log\" ...\n2011-03-13 15:27:59 -- info: ============================== ghettoVCB LOG START ==============================\n\n2011-03-13 15:27:59 -- debug: Succesfully acquired lock directory - /tmp/ghettoVCB.lock\n\n2011-03-13 15:27:59 -- debug: HOST VERSION: VMware ESX 4.1.0 build-260247\n2011-03-13 15:27:59 -- debug: HOST LEVEL: VMware ESX 4.1.0 GA\n2011-03-13 15:27:59 -- debug: HOSTNAME: himalaya.primp-industries.com\n\n2011-03-13 15:27:59 -- info: CONFIG - VERSION = 2011_03_13_1\n2011-03-13 15:27:59 -- info: CONFIG - GHETTOVCB_PID = 31074\n2011-03-13 15:27:59 -- info: CONFIG - VM_BACKUP_VOLUME = /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\n2011-03-13 15:27:59 -- info: CONFIG - VM_BACKUP_ROTATION_COUNT = 3\n2011-03-13 15:27:59 -- info: CONFIG - VM_BACKUP_DIR_NAMING_CONVENTION = 2011-03-13_15-27-59\n2011-03-13 15:27:59 -- info: CONFIG - DISK_BACKUP_FORMAT = thin\n2011-03-13 15:27:59 -- info: CONFIG - POWER_VM_DOWN_BEFORE_BACKUP = 0\n2011-03-13 15:27:59 -- info: CONFIG - ENABLE_HARD_POWER_OFF = 0\n2011-03-13 15:27:59 -- info: CONFIG - ITER_TO_WAIT_SHUTDOWN = 3\n2011-03-13 15:27:59 -- info: CONFIG - POWER_DOWN_TIMEOUT = 5\n2011-03-13 15:27:59 -- info: CONFIG - SNAPSHOT_TIMEOUT = 15\n2011-03-13 15:27:59 -- info: CONFIG - LOG_LEVEL = debug\n2011-03-13 15:27:59 -- info: CONFIG - BACKUP_LOG_OUTPUT = /tmp/ghettoVCB-2011-03-13_15-27-59.log\n2011-03-13 15:27:59 -- info: CONFIG - VM_SNAPSHOT_MEMORY = 0\n2011-03-13 15:27:59 -- info: CONFIG - VM_SNAPSHOT_QUIESCE = 0\n2011-03-13 15:27:59 -- info: CONFIG - VMDK_FILES_TO_BACKUP = all\n2011-03-13 15:27:59 -- info: CONFIG - EMAIL_LOG = 0\n2011-03-13 15:27:59 -- info:\n2011-03-13 15:28:01 -- debug: Storage Information before backup:\n2011-03-13 15:28:01 -- debug: SRC_DATASTORE: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:28:01 -- debug: SRC_DATASTORE_CAPACITY: 1830.5 GB\n2011-03-13 15:28:01 -- debug: SRC_DATASTORE_FREE: 539.4 GB\n2011-03-13 15:28:01 -- debug: SRC_DATASTORE_BLOCKSIZE: 4\n2011-03-13 15:28:01 -- debug: SRC_DATASTORE_MAX_FILE_SIZE: 1024 GB\n2011-03-13 15:28:01 -- debug:\n2011-03-13 15:28:01 -- debug: DST_DATASTORE: dlgCore-NFS-bigboi.VM-Backups\n2011-03-13 15:28:01 -- debug: DST_DATASTORE_CAPACITY: 1348.4 GB\n2011-03-13 15:28:01 -- debug: DST_DATASTORE_FREE: 296.8 GB\n2011-03-13 15:28:01 -- debug: DST_DATASTORE_BLOCKSIZE: NA\n2011-03-13 15:28:01 -- debug: DST_DATASTORE_MAX_FILE_SIZE: NA\n2011-03-13 15:28:01 -- debug:\n2011-03-13 15:28:02 -- info: Initiate backup for scofield\n2011-03-13 15:28:02 -- debug: /usr/sbin/vmkfstools -i \"/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_3.vmdk\" -a \"buslogic\" -d \"thin\" \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/scofield/scofield-2011-03-13_15-27-59/scofield_3.vmdk\"\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_3.vmdk'...\nClone: 37% done.\n2011-03-13 15:28:04 -- debug: /usr/sbin/vmkfstools -i \"/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_2.vmdk\" -a \"buslogic\" -d \"thin\" \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/scofield/scofield-2011-03-13_15-27-59/scofield_2.vmdk\"\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_2.vmdk'...\nClone: 85% done.\n2011-03-13 15:28:05 -- debug: /usr/sbin/vmkfstools -i \"/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_1.vmdk\" -a \"buslogic\" -d \"thin\" \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/scofield/scofield-2011-03-13_15-27-59/scofield_1.vmdk\"\n\n2011-03-13 15:28:06 -- debug: /usr/sbin/vmkfstools -i \"/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield.vmdk\" -a \"buslogic\" -d \"thin\" \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/scofield/scofield-2011-03-13_15-27-59/scofield.vmdk\"\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield.vmdk'...\nClone: 78% done.\n2011-03-13 15:29:52 -- info: Backup Duration: 1.83 Minutes\n2011-03-13 15:29:52 -- info: Successfully completed backup for scofield!\n\n2011-03-13 15:29:54 -- debug: Storage Information after backup:\n2011-03-13 15:29:54 -- debug: SRC_DATASTORE: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:29:54 -- debug: SRC_DATASTORE_CAPACITY: 1830.5 GB\n2011-03-13 15:29:54 -- debug: SRC_DATASTORE_FREE: 539.4 GB\n2011-03-13 15:29:54 -- debug: SRC_DATASTORE_BLOCKSIZE: 4\n2011-03-13 15:29:54 -- debug: SRC_DATASTORE_MAX_FILE_SIZE: 1024 GB\n2011-03-13 15:29:54 -- debug:\n2011-03-13 15:29:54 -- debug: DST_DATASTORE: dlgCore-NFS-bigboi.VM-Backups\n2011-03-13 15:29:54 -- debug: DST_DATASTORE_CAPACITY: 1348.4 GB\n2011-03-13 15:29:54 -- debug: DST_DATASTORE_FREE: 296.8 GB\n2011-03-13 15:29:54 -- debug: DST_DATASTORE_BLOCKSIZE: NA\n2011-03-13 15:29:54 -- debug: DST_DATASTORE_MAX_FILE_SIZE: NA\n2011-03-13 15:29:54 -- debug:\n2011-03-13 15:29:55 -- debug: Storage Information before backup:\n2011-03-13 15:29:55 -- debug: SRC_DATASTORE: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:29:55 -- debug: SRC_DATASTORE_CAPACITY: 1830.5 GB\n2011-03-13 15:29:55 -- debug: SRC_DATASTORE_FREE: 539.4 GB\n2011-03-13 15:29:55 -- debug: SRC_DATASTORE_BLOCKSIZE: 4\n2011-03-13 15:29:55 -- debug: SRC_DATASTORE_MAX_FILE_SIZE: 1024 GB\n2011-03-13 15:29:55 -- debug:\n2011-03-13 15:29:55 -- debug: DST_DATASTORE: dlgCore-NFS-bigboi.VM-Backups\n2011-03-13 15:29:55 -- debug: DST_DATASTORE_CAPACITY: 1348.4 GB\n2011-03-13 15:29:55 -- debug: DST_DATASTORE_FREE: 296.8 GB\n2011-03-13 15:29:55 -- debug: DST_DATASTORE_BLOCKSIZE: NA\n2011-03-13 15:29:55 -- debug: DST_DATASTORE_MAX_FILE_SIZE: NA\n2011-03-13 15:29:55 -- debug:\n2011-03-13 15:29:55 -- info: Snapshot found for vMA, backup will not take place\n\n2011-03-13 15:29:57 -- debug: Storage Information before backup:\n2011-03-13 15:29:57 -- debug: SRC_DATASTORE: himalaya-local-SATA.RE4-GP:Storage\n2011-03-13 15:29:57 -- debug: SRC_DATASTORE_CAPACITY: 1830.5 GB\n2011-03-13 15:29:57 -- debug: SRC_DATASTORE_FREE: 539.4 GB\n2011-03-13 15:29:57 -- debug: SRC_DATASTORE_BLOCKSIZE: 4\n2011-03-13 15:29:57 -- debug: SRC_DATASTORE_MAX_FILE_SIZE: 1024 GB\n2011-03-13 15:29:57 -- debug:\n2011-03-13 15:29:57 -- debug: DST_DATASTORE: dlgCore-NFS-bigboi.VM-Backups\n2011-03-13 15:29:57 -- debug: DST_DATASTORE_CAPACITY: 1348.4 GB\n2011-03-13 15:29:57 -- debug: DST_DATASTORE_FREE: 296.8 GB\n2011-03-13 15:29:57 -- debug: DST_DATASTORE_BLOCKSIZE: NA\n2011-03-13 15:29:57 -- debug: DST_DATASTORE_MAX_FILE_SIZE: NA\n2011-03-13 15:29:57 -- debug:\n2011-03-13 15:29:58 -- info: Initiate backup for vCloudConnector\n2011-03-13 15:29:58 -- debug: /usr/sbin/vmkfstools -i \"/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vCloudConnector/vCloudConnector.vmdk\" -a \"buslogic\" -d \"thin\" \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/vCloudConnector/vCloudConnector-2011-03-13_15-27-59/vCloudConnector.vmdk\"\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vCloudConnector/vCloudConnector.vmdk'...\nClone: 97% done.\n2011-03-13 15:30:45 -- info: Backup Duration: 47 Seconds\n2011-03-13 15:30:45 -- info: WARN: vCloudConnector has some Independent VMDKs that can not be backed up!\n\n2011-03-13 15:30:45 -- info: ###### Final status: ERROR: Only some of the VMs backed up, and some disk(s) failed! ######\n\n2011-03-13 15:30:45 -- debug: Succesfully removed lock directory - /tmp/ghettoVCB.lock\n\n2011-03-13 15:30:45 -- info: ============================== ghettoVCB LOG END ================================\n```\n\n### Backup VMs stored in a list\n\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup\n```\n\n### Backup Single VM using CLI\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB.sh -m MyVM\n```\n\n### Backup All VMs residing on specific host\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB.sh -a\n```\n\n### Backup All VMs residing on specific host and exclude the VMs in the exclusion list\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB.sh -a -e vm_exclusion_list\n```\n\n### Backup VMs based on individual VM backup policies\n\n* Log verbosity: info (default)\n* Log output: /tmp/ghettoVCB.log\n * Logs by default will be stored in /tmp, these log files may not persist through reboots, especially when dealing with ESXi. You should log to  either a local or remote datastore to ensure that logs are kept upon a  reboot.\n\n1. Create folder to hold individual VM backup policies (can be named anything):\n```console\n[root@himalaya ~]# mkdir backup_config\n```\n\n2. Create individual VM backup policies for each VM that ensure each  file is named exactly as the display name of the VM being backed up (use  provided template to create duplicates):\n```console\n[root@himalaya]# cp /opt/ghettovcb/ghettoVCB-vm_backup_configuration_template scofield\n[root@himalaya]# cp /opt/ghettovcb/ghettoVCB-vm_backup_configuration_template vCloudConnector\n```\n\nListing of VM backup policy within backup configuration directory\n```console\n[root@himalaya backup_config]# ls\nghettoVCB-vm_backup_configuration_template  scofield  vCloudConnector\n```\n\nBackup policy for \"scofield\" (backup only 2 specific VMDKs)\n```console\n[root@himalaya backup_config]# cat scofield\nVM_BACKUP_VOLUME=/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\nDISK_BACKUP_FORMAT=thin\nVM_BACKUP_ROTATION_COUNT=3\nPOWER_VM_DOWN_BEFORE_BACKUP=0\nENABLE_HARD_POWER_OFF=0\nITER_TO_WAIT_SHUTDOWN=4\nPOWER_DOWN_TIMEOUT=5\nSNAPSHOT_TIMEOUT=15\nENABLE_COMPRESSION=0\nVM_SNAPSHOT_MEMORY=0\nVM_SNAPSHOT_QUIESCE=0\nVMDK_FILES_TO_BACKUP=\"scofield_2.vmdk,scofield_1.vmdk\"\n```\n\nBackup policy for VM \"vCloudConnector\" (backup all VMDKs found)\n```console\n[root@himalaya backup_config]# cat vCloudConnector\nVM_BACKUP_VOLUME=/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\nDISK_BACKUP_FORMAT=thin\nVM_BACKUP_ROTATION_COUNT=3\nPOWER_VM_DOWN_BEFORE_BACKUP=0\nENABLE_HARD_POWER_OFF=0\nITER_TO_WAIT_SHUTDOWN=4\nPOWER_DOWN_TIMEOUT=5\nSNAPSHOT_TIMEOUT=15\nENABLE_COMPRESSION=0\nVM_SNAPSHOT_MEMORY=0\nVM_SNAPSHOT_QUIESCE=0\nVMDK_FILES_TO_BACKUP=\"vCloudConnector.vmdk\"\n```\n\n> **Note:** When specifying -c option (individual VM backup policy mode) if a VM is listed in the backup list but DOES NOT have a corresponding backup policy, the VM will be backed up using the default configuration found within the ghettoVCB.sh script.\n\nExecution of backup\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB.sh -f vms_to_backup -c backup_config -l /tmp/ghettoVCB.log\n\n2011-03-13 15:40:50 -- info: ============================== ghettoVCB LOG START ==============================\n\n2011-03-13 15:40:51 -- info: CONFIG - USING CONFIGURATION FILE = backup_config//scofield\n2011-03-13 15:40:51 -- info: CONFIG - VERSION = 2011_03_13_1\n2011-03-13 15:40:51 -- info: CONFIG - GHETTOVCB_PID = 2967\n2011-03-13 15:40:51 -- info: CONFIG - VM_BACKUP_VOLUME = /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\n2011-03-13 15:40:51 -- info: CONFIG - VM_BACKUP_ROTATION_COUNT = 3\n2011-03-13 15:40:51 -- info: CONFIG - VM_BACKUP_DIR_NAMING_CONVENTION = 2011-03-13_15-40-50\n2011-03-13 15:40:51 -- info: CONFIG - DISK_BACKUP_FORMAT = thin\n2011-03-13 15:40:51 -- info: CONFIG - POWER_VM_DOWN_BEFORE_BACKUP = 0\n2011-03-13 15:40:51 -- info: CONFIG - ENABLE_HARD_POWER_OFF = 0\n2011-03-13 15:40:51 -- info: CONFIG - ITER_TO_WAIT_SHUTDOWN = 4\n2011-03-13 15:40:51 -- info: CONFIG - POWER_DOWN_TIMEOUT = 5\n2011-03-13 15:40:51 -- info: CONFIG - SNAPSHOT_TIMEOUT = 15\n2011-03-13 15:40:51 -- info: CONFIG - LOG_LEVEL = info\n2011-03-13 15:40:51 -- info: CONFIG - BACKUP_LOG_OUTPUT = /tmp/ghettoVCB.log\n2011-03-13 15:40:51 -- info: CONFIG - VM_SNAPSHOT_MEMORY = 0\n2011-03-13 15:40:51 -- info: CONFIG - VM_SNAPSHOT_QUIESCE = 0\n2011-03-13 15:40:51 -- info: CONFIG - VMDK_FILES_TO_BACKUP = scofield_2.vmdk,scofield_1.vmdk\n2011-03-13 15:40:51 -- info: CONFIG - EMAIL_LOG = 0\n2011-03-13 15:40:51 -- info:\n2011-03-13 15:40:53 -- info: Initiate backup for scofield\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_2.vmdk'...\nClone: 100% done.\n\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/scofield/scofield_1.vmdk'...\nClone: 100% done.\n\n2011-03-13 15:40:55 -- info: Backup Duration: 2 Seconds\n2011-03-13 15:40:55 -- info: Successfully completed backup for scofield!\n\n2011-03-13 15:40:57 -- info: CONFIG - VERSION = 2011_03_13_1\n2011-03-13 15:40:57 -- info: CONFIG - GHETTOVCB_PID = 2967\n2011-03-13 15:40:57 -- info: CONFIG - VM_BACKUP_VOLUME = /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\n2011-03-13 15:40:57 -- info: CONFIG - VM_BACKUP_ROTATION_COUNT = 3\n2011-03-13 15:40:57 -- info: CONFIG - VM_BACKUP_DIR_NAMING_CONVENTION = 2011-03-13_15-40-50\n2011-03-13 15:40:57 -- info: CONFIG - DISK_BACKUP_FORMAT = thin\n2011-03-13 15:40:57 -- info: CONFIG - POWER_VM_DOWN_BEFORE_BACKUP = 0\n2011-03-13 15:40:57 -- info: CONFIG - ENABLE_HARD_POWER_OFF = 0\n2011-03-13 15:40:57 -- info: CONFIG - ITER_TO_WAIT_SHUTDOWN = 3\n2011-03-13 15:40:57 -- info: CONFIG - POWER_DOWN_TIMEOUT = 5\n2011-03-13 15:40:57 -- info: CONFIG - SNAPSHOT_TIMEOUT = 15\n2011-03-13 15:40:57 -- info: CONFIG - LOG_LEVEL = info\n2011-03-13 15:40:57 -- info: CONFIG - BACKUP_LOG_OUTPUT = /tmp/ghettoVCB.log\n2011-03-13 15:40:57 -- info: CONFIG - VM_SNAPSHOT_MEMORY = 0\n2011-03-13 15:40:57 -- info: CONFIG - VM_SNAPSHOT_QUIESCE = 0\n2011-03-13 15:40:57 -- info: CONFIG - VMDK_FILES_TO_BACKUP = all\n2011-03-13 15:40:57 -- info: CONFIG - EMAIL_LOG = 0\n2011-03-13 15:40:57 -- info:\n2011-03-13 15:40:59 -- info: Snapshot found for vMA, backup will not take place\n\n2011-03-13 15:40:59 -- info: CONFIG - USING CONFIGURATION FILE = backup_config//vCloudConnector\n2011-03-13 15:40:59 -- info: CONFIG - VERSION = 2011_03_13_1\n2011-03-13 15:40:59 -- info: CONFIG - GHETTOVCB_PID = 2967\n2011-03-13 15:40:59 -- info: CONFIG - VM_BACKUP_VOLUME = /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\n2011-03-13 15:40:59 -- info: CONFIG - VM_BACKUP_ROTATION_COUNT = 3\n2011-03-13 15:40:59 -- info: CONFIG - VM_BACKUP_DIR_NAMING_CONVENTION = 2011-03-13_15-40-50\n2011-03-13 15:40:59 -- info: CONFIG - DISK_BACKUP_FORMAT = thin\n2011-03-13 15:40:59 -- info: CONFIG - POWER_VM_DOWN_BEFORE_BACKUP = 0\n2011-03-13 15:40:59 -- info: CONFIG - ENABLE_HARD_POWER_OFF = 0\n2011-03-13 15:40:59 -- info: CONFIG - ITER_TO_WAIT_SHUTDOWN = 4\n2011-03-13 15:40:59 -- info: CONFIG - POWER_DOWN_TIMEOUT = 5\n2011-03-13 15:40:59 -- info: CONFIG - SNAPSHOT_TIMEOUT = 15\n2011-03-13 15:40:59 -- info: CONFIG - LOG_LEVEL = info\n2011-03-13 15:40:59 -- info: CONFIG - BACKUP_LOG_OUTPUT = /tmp/ghettoVCB.log\n2011-03-13 15:40:59 -- info: CONFIG - VM_SNAPSHOT_MEMORY = 0\n2011-03-13 15:40:59 -- info: CONFIG - VM_SNAPSHOT_QUIESCE = 0\n2011-03-13 15:40:59 -- info: CONFIG - VMDK_FILES_TO_BACKUP = vCloudConnector.vmdk\n2011-03-13 15:40:59 -- info: CONFIG - EMAIL_LOG = 0\n2011-03-13 15:40:59 -- info:\n2011-03-13 15:41:01 -- info: Initiate backup for vCloudConnector\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage/vCloudConnector/vCloudConnector.vmdk'...\nClone: 100% done.\n\n2011-03-13 15:41:51 -- info: Backup Duration: 50 Seconds\n2011-03-13 15:41:51 -- info: WARN: vCloudConnector has some Independent VMDKs that can not be backed up!\n\n2011-03-13 15:41:51 -- info: ###### Final status: ERROR: Only some of the VMs backed up, and some disk(s) failed! ######\n\n2011-03-13 15:41:51 -- info: ============================== ghettoVCB LOG END ================================\n```\n## Enable compression for backups\n\nTo make use of this feature, modify the variable ENABLE_COMPRESSION from 0 to 1. Please note, do not mix uncompressed backups with  compressed backups. Ensure that directories selected for backups do not contain any backups with previous versions of ghettoVCB before enabling  and implementing the compressed backups feature.\n\n## Stopping ghettoVCB Process\n\nThere may be a situation where you need to stop the ghettoVCB process and entering Ctrl+C will only kill off the main ghettoVCB process, however there may still be other spawn processes that you may need to identify and stop. Below are two scenarios you may encounter and the process to completely stop all processes related to ghettoVCB.\n\n**Interactively running ghettoVCB:**\n\nStep 1 - Press Ctrl+C which will kill off the main ghettoVCB instance\n\nStep 2 - Search for any existing ghettoVCB process by running the following:\n```console\n# ps -c | grep ghettoVCB | grep -v grep\n3360136 3360136 tail                 tail -f /tmp/ghettoVCB.work/ghettovcb.Cs1M1x\n```\n\nStep 3 - Here we can see there is a tail command that was used in the script. We need to stop this process by using the kill command which accepts the PID (Process ID) which is identified by the first value on the far left hand side of the command. In this example, it is 3360136.\n```console\n# kill -9 3360136\n```\n\n> **Note:** Make sure you identify the correct PID, else you could accidently impact a running VM or worse your ESXi host.\n\nStep 4 - Depending on where you stopped the ghettoVCB process, you may need to consolidate or remove any existing snapshots that may exist on the VM that was being backed up. You can easily do so by using the vSphere Client.\n\n**Non-Interactively running ghettoVCB:**\n\nStep 1 - Search for the ghettoVCB process (you can also validate the PID from the logs)\n```console\n~ # ps -c | grep ghettoVCB | grep -v grep\n3360393 3360393 busybox              ash ./ghettoVCB.sh -f list -d debug\n3360790 3360790 tail                 tail -f /tmp/ghettoVCB.work/ghettovcb.deGeB7\n```\n\nStep 2 - Stop both the main ghettoVCB instance & tail command by using the kill command and specifying their respective PID IDs:\n```console\nkill -9 3360393\nkill -9 3360790\n```\n\nStep 3 - If a VM was in the process of being backed up, there is an additional process for the actual vmkfstools copy. You will need to identify the process for that and kill that as well. We will again use ps -c command and search for any vmkfstools that are running:\n```console\n# ps -c | grep vmkfstools | grep -v grep\n3360796 3360796 vmkfstools           /sbin/vmkfstools -i /vmfs/volumes/himalaya-temporary/VC-Windows/VC-Windows.vmdk -a lsilogic -d thin /vmfs/volumes/test-dont-use-this-volume/backups/VC-Windows/VC-Windows-2013-01-26_16-45-35/VC-Windows.vmdk\n```\n\nStep 4 - In case there is someone manually running a vmkfstools, make sure you take a look at the command itself and that it maps back to the current VM that was being backed up before kill the process. Once you have identified the proper PID, go ahead and use the kill command:\n```console\n# kill -9 3360796\n```\n\nStep 5 - Depending on where you stopped the  ghettoVCB process, you may need to consolidate or remove any existing  snapshots that may exist on the VM that was being backed up. You can  easily do so by using the vSphere Client.\n\n## Scheduling Backups using Cron\n\nFirst, please review this [primer on what is cronjob](https://web.archive.org/web/20231110163544/http://www.cyberciti.biz/faq/how-do-i-add-jobs-to-cron-under-linux-or-unix-oses/)\n\nThe task of configuring cronjobs on classic ESX servers (with Service Console) is no different than traditional cronjobs on *nix operating  systems (this procedure is outlined in the link above). With ESXi on the  other hand, additional factors need to be taken into account when  setting up cronjobs in the limited shell console called Busybox because changes made do not persist through a system reboot. The following document will outline steps to ensure that cronjob configurations are saved and present upon a reboot.\n\n> **Note:** Always redirect the ghettoVCB output to /dev/null and/or to a log when automating via cron, this becomes very important as one user has identified a limited amount of buffer capacity in which once filled, may cause ghettoVCB to stop in the middle of a backup. This primarily only affects users on ESXi, but it is good practice to always redirect the output. Also ensure you are specifying the FULL PATH when referencing the ghettoVCB script, input or log files.\n\ne.g.\n```console\n0 0 * * 1-5 /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/ghettoVCB.sh -f /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/backuplist > /dev/null\n```\nor\n\n```copnsole\n0 0 * * 1-5 /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/ghettoVCB.sh -f /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/backuplist > /tmp/ghettoVCB.log\n```\n\nExample - Configure ghettoVCB.sh to execute a backup five days a week (M-F) at 12AM (midnight) everyday and send output to a unique log file\n\n\n### Configure on ESX:\n\n1. As root, you'll install your cronjob by issuing:\n```console\n[root@himalaya ~]# crontab -e\n```\n\n2. Append the following entry:\n```console\n0 0 * * 1-5 /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/ghettoVCB.sh -f /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/backuplist > /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/ghettoVCB-backup-$(date +\\%s).log\n```\n\n3. Save and exit\n```console\n[root@himalaya dlgCore-NFS-bigboi.VM-Backups]# crontab -e\nno crontab for root - using an empty one\ncrontab: installing new crontab\n```\n\n4. List out and verify the cronjob that was just created:\n```console\n[root@himalaya dlgCore-NFS-bigboi.VM-Backups]# crontab -l\n0 0 * * 1-5 /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/ghettoVCB.sh -f /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/backuplist > /vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/ghettoVCB-backup-$(date +\\%s).log\n```\n\n### Configure on ESXi:\n\n1. Setup the cronjob by appending the following line to `/var/spool/cron/crontabs/root`:\n```console\n0 0 * * 1-5 /vmfs/volumes/simplejack-local-storage/ghettoVCB.sh -f /vmfs/volumes/simplejack-local-storage/backuplist > /vmfs/volumes/simplejack-local-storage/ghettoVCB-backup-$(date +\\%s).log\n```\n\nIf you are unable to edit/modify `/var/spool/cron/crontabs/root`, please make a copy and then edit the copy with the changes\n```console\ncp /var/spool/cron/crontabs/root /var/spool/cron/crontabs/root.backup\n```\nOnce your changes have been made, then \"mv\" the backup to the original file. This may occur on ESXi 4.x or 5.x hosts\n```console\nmv /var/spool/cron/crontabs/root.backup /var/spool/cron/crontabs/root\n```\nYou can now verify the crontab entry has been updated by using \"cat\" utility.\n\n\n2. Kill the current crond (cron daemon) and then restart the crond for the changes to take affect:\n\nOn ESXi < 3.5u3\n```console\nkill $(ps | grep crond | cut -f 1 -d ' ')\n```\n\nOn ESXi 3.5u3+\n```console\n~ # kill $(pidof crond)\n~ # crond\n```\n\nOn ESXi 4.x/5.0\n```console\n~ # kill $(cat /var/run/crond.pid)\n~ # busybox crond\n```\n\nOn ESXi 5.1 to 6.x\n```console\n~ # kill $(cat /var/run/crond.pid)\n~ # crond\n```\n\nOn ESXi 7.x\n```console\n~ # kill $(cat /var/run/crond.pid)\n~ # /usr/lib/vmware/busybox/bin/busybox crond\n```\n\n3. Now that the cronjob is ready to go, you need to ensure that this  cronjob will persist through a reboot. You'll need to add the following two lines to /etc/rc.local (ensure that the cron entry matches what was defined above). In ESXi 5.1, you will need to edit /etc/rc.local.d/local.sh instead of /etc/rc.local as that is no longer valid.\n\nOn ESXi 3.5\n```console\n/bin/kill $(pidof crond)\n/bin/echo \"0 0 * * 1-5 /vmfs/volumes/simplejack-local-storage/ghettoVCB.sh -f /vmfs/volumes/simplejack-local-storage/backuplist > /vmfs/volumes/simplejack-local-storage/ghettoVCB-backup-\\$(date +\\\\%s).log\" >> /var/spool/cron/crontabs/root\ncrond\n```\n\nOn ESXi 4.x/5.0\n```console\n/bin/kill $(cat /var/run/crond.pid)\n/bin/echo \"0 0 * * 1-5 /vmfs/volumes/simplejack-local-storage/ghettoVCB.sh -f /vmfs/volumes/simplejack-local-storage/backuplist > /vmfs/volumes/simplejack-local-storage/ghettoVCB-backup-\\$(date +\\\\%s).log\" >> /var/spool/cron/crontabs/root\n/bin/busybox crond\n```\n\nOn ESXi 5.1 to 6.x\n```console\n/bin/kill $(cat /var/run/crond.pid)\n/bin/echo \"0 0 * * 1-5 /vmfs/volumes/simplejack-local-storage/ghettoVCB.sh -f /vmfs/volumes/simplejack-local-storage/backuplist > /vmfs/volumes/simplejack-local-storage/ghettoVCB-backup-\\$(date +\\\\%s).log\" >> /var/spool/cron/crontabs/root\ncrond\n```\n\nOn ESXi 7.x and later\n```console\n/bin/kill $(cat /var/run/crond.pid) > /dev/null 2>&1\n/bin/echo \"0 0 * * 1-5 /vmfs/volumes/simplejack-local-storage/ghettoVCB.sh -f /vmfs/volumes/simplejack-local-storage/backuplist > /vmfs/volumes/simplejack-local-storage/ghettoVCB-backup-\\$(date +\\\\%s).log\" >> /var/spool/cron/crontabs/root\n/usr/lib/vmware/busybox/bin/busybox crond\n```\n\nAfterwards the file should look like the following:\n```console\n~ # cat /etc/rc.local\n#! /bin/ash\nexport PATH=/sbin:/bin\n\nlog() {\n   echo \"$1\"\n   logger init \"$1\"\n}\n\n#execute all service retgistered in /etc/rc.local.d\nif [http:// -d /etc/rc.local.d |http:// -d /etc/rc.local.d ]; then\n   for filename in `find /etc/rc.local.d/ | sort`\n      do\n         if [ -f $filename ] && [ -x $filename ]; then\n            log \"running $filename\"\n            $filename\n         fi\n      done\nfi\n\n/bin/kill $(cat /var/run/crond.pid)\n/bin/echo \"0 0 * * 1-5 /vmfs/volumes/simplejack-local-storage/ghettoVCB.sh -f /vmfs/volumes/simplejack-local-storage/backuplist > /vmfs/volumes/simplejack-local-storage/ghettoVCB-backup-\\$(date +\\\\%s).log\" >> /var/spool/cron/crontabs/root\n/bin/busybox crond\n```\n\nThis will ensure that the cronjob is re-created upon a reboot of the system through a startup script\n\n2. To ensure that this is saved in the ESXi configuration, we need to manually initiate an ESXi backup by running:\n```console\n~ # /sbin/auto-backup.sh\nconfig implicitly loaded\nlocal.tgz\netc/vmware/vmkiscsid/vmkiscsid.db\netc/dropbear/dropbear_dss_host_key\netc/dropbear/dropbear_rsa_host_key\netc/opt/vmware/vpxa/vpxa.cfg\netc/opt/vmware/vpxa/dasConfig.xml\netc/sysconfig/network\netc/vmware/hostd/authorization.xml\netc/vmware/hostd/hostsvc.xml\netc/vmware/hostd/pools.xml\netc/vmware/hostd/vmAutoStart.xml\netc/vmware/hostd/vmInventory.xml\netc/vmware/hostd/proxy.xml\netc/vmware/ssl/rui.crt\netc/vmware/ssl/rui.key\netc/vmware/vmkiscsid/initiatorname.iscsi\netc/vmware/vmkiscsid/iscsid.conf\netc/vmware/vmware.lic\netc/vmware/config\netc/vmware/dvsdata.db\netc/vmware/esx.conf\netc/vmware/license.cfg\netc/vmware/locker.conf\netc/vmware/snmp.xml\netc/group\netc/hosts\netc/inetd.conf\netc/rc.local\netc/chkconfig.db\netc/ntp.conf\netc/passwd\netc/random-seed\netc/resolv.conf\netc/shadow\netc/sfcb/repository/root/interop/cim_indicationfilter.idx\netc/sfcb/repository/root/interop/cim_indicationhandlercimxml.idx\netc/sfcb/repository/root/interop/cim_listenerdestinationcimxml.idx\netc/sfcb/repository/root/interop/cim_indicationsubscription.idx\nBinary files /etc/vmware/dvsdata.db and /tmp/auto-backup.31345.dir/etc/vmware/dvsdata.db differ\nconfig implicitly loaded\nSaving current state in /bootbank\nClock updated.\nTime: 20:40:36   Date: 08/14/2009   UTC\n```\n\nNow you're really done!\n\nIf you're still having trouble getting the cronjob to work, ensure that  you've specified the correct parameters and there arenâ€™t any typos in  any part of the syntax.\n\nEnsure crond (cron daemon) is running:\n\nESX 3.x/4.0:\n```console\n[root@himalaya dlgCore-NFS-bigboi.VM-Backups]# ps -ef | grep crond | grep -v grep\nroot      2625     1  0 Aug13 ?        00:00:00 crond\n```\n\nESXi 3.x/4.x/5.x:\n```console\n~ # ps | grep crond | grep -v grep\n5196 5196 busybox              crond\n```\n\nEnsure that the date/time on your ESX(i) host is setup correctly:\n\nESX(i):\n```console\n[root@himalaya dlgCore-NFS-bigboi.VM-Backups]# date\nFri Aug 14 23:44:47 PDT 2009\n```\n\nNote: Careful attention must be noted if more than one backup is performed per day. Backup windows  should be staggered to avoid contention or saturation of resources  during these periods.\n\n## Restore Backups\n\nThe [ghettoVCB-restore.sh]() script performs a restore of virtual machines backed up using ghettoVCB. Tasks are performed directly within the service console of the ESX(i) server involved in the restore process. Two main use cases are supported:\n\n1) Restore a VM that contains ALL VMDKs on one datastore\n2) Restore a VM that has VMDKs located on multiple datastores\n\nIn all cases, restored VMs will have VMDKs that reside on the SAME  datastore chosen for the restore process. Please ensure that there is  sufficient space on the target datastore before attempting a restore  operation. In the near future, restoration of VMs backed up using the compression feature of ghettoVCB will be implemented.\n\nFeatures\n* Support for logging output\n* Support for various debugging output\n* Allow spaces in VM(s) backup list (not recommended and not a best practice)\n* Support for restore in the following formats: ZEROEDTHICK (default behavior), 2GB SPARSE, THIN or EAGERZEROEDTHICK\n* Support changing custom VM name during restore\n\n### Usage\n\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB-restore.sh\n###############################################################################\n#\n# ghettoVCB-restore for ESX/ESXi 3.5, 4.x and 5.x\n# Author: William Lam\n# http://www.virtuallyghetto.com/\n# Created: 08/18/2009\n# Last modified: 2011_11_19_1\n#\n###############################################################################\n\nUsage: ./ghettoVCB-restore.sh -c [VM_BACKUP_UP_LIST] -l [LOG_FILE] -d [DRYRUN_DEBUG_INFO]\n\nOPTIONS:\n   -c     VM backup list\n   -l     File ot output logging\n   -d     Dryrun/Debug Info [1|2]\n\n(e.g.)\n\nOutput will go to stdout\n        ./ghettoVCB-restore.sh -c vms_to_restore\n\nOutput will log to /tmp/ghettoVCB-restore.log\n        ./ghettoVCB-restore.sh -c vms_to_restore -l /tmp/ghettoVCB-restore.log\n\nDryrun/Debug Info (dryrun only)\n        ./ghettoVCB-restore.sh -c vms_to_restore -d 1\n        ./ghettoVCB-restore.sh -c vms_to_restore -d 2\n```\n\nStandard input for script is a file that contains:\n\n1) Full path to the backed up VM\n2) Full restore path\n3) Restoration disk format\n4) Restored VM Display Name (NEW!)\n\nReminder: When creating this file on a non-Linux/UNIX system, one may  introduce ^M characters that will cause the script to misbehave. To  ensure that this does not occur, please create the file on the ESX/ESXi  host.\n\nHere is a sample of what the file should look like:\n```console\n[root@himalaya ~]# cat vms_to_restore\n#\"<DIRECTORY or .TGZ>;<DATASTORE_TO_RESTORE_TO>;<DISK_FORMAT_TO_RESTORE>;<OPTIONAL_RESTORED_VM_DISPLAY_NAME>\"\n# DISK_FORMATS\n# 1 = zeroedthick\n# 2 = 2gbsparse\n# 3 = thin\n# 4 = eagerzeroedthick\n# e.g.\n# \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/VCAP/VCAP-2009-08-18--1;/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage;1\"\n\"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36;/vmfs/volumes/mini-local-datastore-1;3\"\n\"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36;/vmfs/volumes/mini-local-datastore-1;1;VCSA-RESTORE\"\n```\n\nComments in the input file is acceptable so long as the intended line is preceded by a #.\n\nThe above sample VM restore file, vms_to_restore, describes the following backup:\n| VM to restore                                                                      | Datastore to restore to              | VMDK format | Restore VM Name |\n|------------------------------------------------------------------------------------|--------------------------------------|-------------|-----------------|\n| /vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36 | /vmfs/volumes/mini-local-datastore-1 | thin        | VCSA-5.1        |\n| /vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36 | /vmfs/volumes/mini-local-datastore-1 | zeroedthick | VCSA-RESTORE    |\n\n### Sample Execution:\nPerform a dryrun by displaying debug information ( restore will not take place)\n\nDisplay debug information level 1:\n```console\n# /opt/ghettovcb/bin/ghettoVCB-restore.sh -c vms_to_restore -d 1\n\n################ DEBUG MODE ##############\nVirtual Machine: \"VCSA-5.1\"\nVM_ORIG_VMX: \"VCSA-5.1.vmx\"\nVM_ORG_FOLDER: \"VCSA-5.1-2012-12-25_01-30-36\"\nVM_RESTORE_VMX: \"VCSA-5.1.vmx\"\nVM_RESTORE_FOLDER: \"VCSA-5.1\"\nVMDK_LIST_TO_MODIFY:\nscsi0:0.fileName = \"VCSA-5.1.vmdk\"\nscsi0:0.fileName  = \"VCSA-5.1-0.vmdk\"\nscsi0:1.fileName = \"VCSA-5.1_1.vmdk\"\nscsi0:1.fileName  = \"VCSA-5.1-1.vmdk\"\n##########################################\n\n\n################ DEBUG MODE ##############\nVirtual Machine: \"VCSA-RESTORE\"\nVM_ORIG_VMX: \"VCSA-5.1.vmx\"\nVM_ORG_FOLDER: \"VCSA-5.1-2012-12-25_01-30-36\"\nVM_RESTORE_VMX: \"VCSA-RESTORE.vmx\"\nVM_RESTORE_FOLDER: \"VCSA-RESTORE\"\nVMDK_LIST_TO_MODIFY:\nscsi0:0.fileName = \"VCSA-5.1.vmdk\"\nscsi0:0.fileName  = \"VCSA-RESTORE-0.vmdk\"\nscsi0:1.fileName = \"VCSA-5.1_1.vmdk\"\nscsi0:1.fileName  = \"VCSA-RESTORE-1.vmdk\"\n##########################################\n\n\nStart time: Sun Jan 13 16:45:12 UTC 2013\nEnd   time: Sun Jan 13 16:45:14 UTC 2013\nDuration  : 2 Seconds\n```\n\nDisplay debug information level 2:\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB-restore.sh -c vms_to_restore -d 2\n\n\n################## Restoring VM: VCSA-5.1  #####################\n==========> DEBUG MODE LEVEL 2 ENABLED <==========\nStart time: Sun Jan 13 16:45:35 UTC 2013\nRestoring VM from: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36\"\nRestoring VM to Datastore: \"/vmfs/volumes/mini-local-datastore-1\" using Disk Format: \"thin\"\nCreating VM directory: \"/vmfs/volumes/mini-local-datastore-1/VCSA-5.1\" ...\nCopying \"VCSA-5.1.vmx\" file ...\nRestoring VM's VMDK(s) ...\nUpdating VMDK entry in \"VCSA-5.1.vmx\" file ...\n\nSOURCE: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1.vmdk\"\n    ORIGINAL_VMX_LINE: -->scsi0:0.fileName = \"VCSA-5.1.vmdk\"<--\nDESTINATION: \"/vmfs/volumes/mini-local-datastore-1/VCSA-5.1/VCSA-5.1-0.vmdk\"\n    MODIFIED_VMX_LINE: -->scsi0:0.fileName  = \"VCSA-5.1-0.vmdk\"<--\nUpdating VMDK entry in \"VCSA-5.1.vmx\" file ...\n\nSOURCE: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1_1.vmdk\"\n    ORIGINAL_VMX_LINE: -->scsi0:1.fileName = \"VCSA-5.1_1.vmdk\"<--\nDESTINATION: \"/vmfs/volumes/mini-local-datastore-1/VCSA-5.1/VCSA-5.1-1.vmdk\"\n    MODIFIED_VMX_LINE: -->scsi0:1.fileName  = \"VCSA-5.1-1.vmdk\"<--\nRegistering VCSA-5.1 ...\nEnd time: Sun Jan 13 16:45:35 UTC 2013\n################## Completed restore for VCSA-5.1! #####################\n\n################## Restoring VM: VCSA-RESTORE  #####################\n==========> DEBUG MODE LEVEL 2 ENABLED <==========\nStart time: Sun Jan 13 16:45:35 UTC 2013\nRestoring VM from: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36\"\nRestoring VM to Datastore: \"/vmfs/volumes/mini-local-datastore-1\" using Disk Format: \"zeroedthick\"\nCreating VM directory: \"/vmfs/volumes/mini-local-datastore-1/VCSA-RESTORE\" ...\nCopying \"VCSA-5.1.vmx\" file ...\nRestoring VM's VMDK(s) ...\nUpdating VMDK entry in \"VCSA-RESTORE.vmx\" file ...\n\nSOURCE: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1.vmdk\"\n    ORIGINAL_VMX_LINE: -->scsi0:0.fileName = \"VCSA-5.1.vmdk\"<--\nDESTINATION: \"/vmfs/volumes/mini-local-datastore-1/VCSA-RESTORE/VCSA-RESTORE-0.vmdk\"\n    MODIFIED_VMX_LINE: -->scsi0:0.fileName  = \"VCSA-RESTORE-0.vmdk\"<--\nUpdating VMDK entry in \"VCSA-RESTORE.vmx\" file ...\n\nSOURCE: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1_1.vmdk\"\n    ORIGINAL_VMX_LINE: -->scsi0:1.fileName = \"VCSA-5.1_1.vmdk\"<--\nDESTINATION: \"/vmfs/volumes/mini-local-datastore-1/VCSA-RESTORE/VCSA-RESTORE-1.vmdk\"\n    MODIFIED_VMX_LINE: -->scsi0:1.fileName  = \"VCSA-RESTORE-1.vmdk\"<--\nRegistering VCSA-RESTORE ...\nEnd time: Sun Jan 13 16:45:35 UTC 2013\n################## Completed restore for VCSA-RESTORE! #####################\n\n\nStart time: Sun Jan 13 16:45:34 UTC 2013\nEnd   time: Sun Jan 13 16:45:35 UTC 2013\nDuration  : 1 Seconds\n\n---------------------------------------------------------------------------------------------------------------\n```\n\nExecute restore with output going to stdout (restore the first two VMs listed from above):\n\nInput file:\n```console\n[root@himalaya ~]# cat vms_to_restore\n\n\"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36;/vmfs/volumes/mini-local-datastore-1;3\"\n\"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36;/vmfs/volumes/mini-local-datastore-1;1;VCSA-RESTORE\"\n```\n\n```console\n[root@himalaya ~]# /opt/ghettovcb/bin/ghettoVCB-restore.sh -c vms_to_restore\n\n################## Restoring VM: VCSA-5.1  #####################\nStart time: Sun Jan 13 16:46:41 UTC 2013\nRestoring VM from: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36\"\nRestoring VM to Datastore: \"/vmfs/volumes/mini-local-datastore-1\" using Disk Format: \"thin\"\nCreating VM directory: \"/vmfs/volumes/mini-local-datastore-1/VCSA-5.1\" ...\nCopying \"VCSA-5.1.vmx\" file ...\nRestoring VM's VMDK(s) ...\nUpdating VMDK entry in \"VCSA-5.1.vmx\" file ...\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1.vmdk'...\nClone: 100% done.\nUpdating VMDK entry in \"VCSA-5.1.vmx\" file ...\nDestination disk format: VMFS thin-provisioned\nCloning disk '/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1_1.vmdk'...\nClone: 100% done.\nRegistering VCSA-5.1 ...\n34\nEnd time: Sun Jan 13 16:48:51 UTC 2013\n################## Completed restore for VCSA-5.1! #####################\n\n################## Restoring VM: VCSA-RESTORE  #####################\nStart time: Sun Jan 13 16:48:52 UTC 2013\nRestoring VM from: \"/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36\"\nRestoring VM to Datastore: \"/vmfs/volumes/mini-local-datastore-1\" using Disk Format: \"zeroedthick\"\nCreating VM directory: \"/vmfs/volumes/mini-local-datastore-1/VCSA-RESTORE\" ...\nCopying \"VCSA-5.1.vmx\" file ...\nRestoring VM's VMDK(s) ...\nUpdating VMDK entry in \"VCSA-RESTORE.vmx\" file ...\nDestination disk format: VMFS zeroedthick\nCloning disk '/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1.vmdk'...\nClone: 100% done.\nUpdating VMDK entry in \"VCSA-RESTORE.vmx\" file ...\nFailed to clone disk: There is not enough space on the file system for the selected operation (13).\nDestination disk format: VMFS zeroedthick\nCloning disk '/vmfs/volumes/mini-local-datastore-2/backups/VCSA-5.1/VCSA-5.1-2012-12-25_01-30-36/VCSA-5.1_1.vmdk'...\nRegistering VCSA-RESTORE ...\n35\nEnd time: Sun Jan 13 16:50:19 UTC 2013\n################## Completed restore for VCSA-RESTORE! #####################\n\n\nStart time: Sun Jan 13 16:46:40 UTC 2013\nEnd   time: Sun Jan 13 16:50:19 UTC 2013\nDuration  : 3.65 Minutes\n\n\n---------------------------------------------------------------------------------------------------------------\n```\n\nExecute restore with output going to log file\n\n/tmp/ghettoVCB-restore.log (restore the last two VMs listed from above):\n```console\n[root@himalaya ~]# ./ghettoVCB-restore.sh -c vms_to_restore -l /tmp/ghettoVCB-restore.log\nLogging output to \"/tmp/ghettoVCB-restore.log\" ...\n```"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "ghettoVCB-restore.sh",
          "type": "blob",
          "size": 17.5888671875,
          "content": "#!/bin/sh\n# Author: William Lam \n# 08/18/2009\n# http://www.virtuallyghetto.com/\n##################################################################\n\n###### DO NOT EDIT PASS THIS LINE ######\n\nLAST_MODIFIED_DATE=2024_06_30\nVERSION=1\nVERSION_STRING=${LAST_MODIFIED_DATE}_${VERSION}\n\nprintUsage() {\n    echo \"###############################################################################\"\n    echo \"#\"\n    echo \"# ghettoVCB-restore for ESX/ESXi 3.5, 4.x, 5.x, 6.x, 7.x & 8.x\"\n    echo \"# Author: William Lam\"\n    echo \"# http://www.virtuallyghetto.com/\"\n    echo \"# Documentation: http://communities.vmware.com/docs/DOC-8760\"\n    echo \"# Created: 08/18/2009\"\n    echo \"# Last modified: ${VERSION_STRING}\"\n    echo \"#\"\n    echo \"###############################################################################\"\n    echo\n    echo \"Usage: $0 -c [VM_BACKUP_UP_LIST] -l [LOG_FILE] -d [DRYRUN_DEBUG_INFO]\"\n    echo\n    echo \"OPTIONS:\"\n    echo \"   -c     VM backup list\"\n    echo \"   -l     File ot output logging\"\n    echo \"   -d     Dryrun/Debug Info [1|2]\"\n    echo\n    echo \"(e.g.)\"\n    echo -e \"\\nOutput will go to stdout\"\n    echo -e \"\\t$0 -c vms_to_restore \"\n    echo -e \"\\nOutput will log to /tmp/ghettoVCB-restore.log\"\n    echo -e \"\\t$0 -c vms_to_restore -l /tmp/ghettoVCB-restore.log\"\n    echo -e \"\\nDryrun/Debug Info (dryrun only)\"\n    echo -e \"\\t$0 -c vms_to_restore -d 1\"\n    echo -e \"\\t$0 -c vms_to_restore -d 2\"\n    echo\n    exit 1\n}\n\nlogger() {\n    MSG=$1\n    if [ \"${LOG_TO_STDOUT}\" -eq 1 ]; then\n        echo -e \"${MSG}\"\n    else\n        echo -e \"${MSG}\" >> \"${LOG_OUTPUT}\"\n    fi\n}\n\nsanityCheck() {\n    NUM_OF_ARGS=$1\n\n    # ensure root user is running the script\n    if [ ! $(env | grep -e \"^USER=\" | awk -F = '{print $2}') == \"root\" ]; then\n        logger \"info\" \"This script needs to be executed by \\\"root\\\"!\"\n        echo \"ERROR: This script needs to be executed by \\\"root\\\"!\"\n        exit 1\n    fi\n\n    if [[ ${NUM_OF_ARGS} -ne 2 ]] && [[ ${NUM_OF_ARGS} -ne 4 ]] && [[ ${NUM_OF_ARGS} -ne 6 ]]; then\n        printUsage\n    fi\n\n    #log to stdout or to logfile\n    if [ -z \"${LOG_OUTPUT}\" ]; then\n        LOG_TO_STDOUT=1\n        REDIRECT=/dev/null\n    else\n        LOG_TO_STDOUT=0\n        REDIRECT=${LOG_OUTPUT}\n        echo \"Logging output to \\\"${LOG_OUTPUT}\\\" ...\"\n        touch \"${LOG_OUTPUT}\"\n    fi\n\n    if [[ \"${DEVEL_MODE}\" == \"1\" ]] && [[ \"${DEVEL_MODE}\" == \"2\" ]] && [[ \"${DEVEL_MODE}\" == \"0\" ]]; then\n        DEVEL_MODE=0\n    fi\n\n    if [ -f /usr/bin/vmware-vim-cmd ]; then\n        VMWARE_CMD=/usr/bin/vmware-vim-cmd\n        VMKFSTOOLS_CMD=/usr/sbin/vmkfstools\n    elif [ -f /bin/vim-cmd ]; then\n        VMWARE_CMD=/bin/vim-cmd\n        VMKFSTOOLS_CMD=/sbin/vmkfstools\n    else\n        logger \"ERROR: Unable to locate *vimsh*!\"\n        echo \"ERROR: Unable to locate *vimsh*!\"\n        exit\n    fi\n\n    ESX_VERSION=$(vmware -v | awk '{print $3}')\n\n    case \"${ESX_VERSION}\" in\n        8.0.0|8.0.1|8.0.2|8.0.3)    VER=8; break;;\n        7.0.0|7.0.1|7.0.2|7.0.3)    VER=7; break;;\n        6.0.0|6.5.0|6.7.0)          VER=6; break;;\n        5.0.0|5.1.0|5.5.0)          VER=5; break;;\n        4.0.0|4.1.0)                VER=4; break;;\n        3.5.0|3i)                   VER=3; break;;\n        *)              echo \"ESX(i) version not supported!\"; exit 1; break;;\n    esac\n\n    TAR=\"tar\"\n    [[ ! -f /bin/tar ]] && TAR=\"busybox tar\"\n\n    #ensure input file exists\n    if [ ! -f \"${CONFIG_FILE}\" ]; then\n        logger \"ERROR: \\\"${CONFIG_FILE}\\\" input file does not exists\\n\"\n        echo -e \"ERROR: \\\"${CONFIG_FILE}\\\" input file does not exists\\n\"\n        exit 1\n    fi\n}\n\nstartTimer() {\n    START_TIME=$(date)\n    S_TIME=$(date +%s)\n}\n\nendTimer() {\n    END_TIME=$(date)\n    E_TIME=$(date +%s)\n    logger \"\\nStart time: ${START_TIME}\"\n    logger \"End   time: ${END_TIME}\"\n    DURATION=$(echo $((E_TIME - S_TIME)))\n\n    #calculate overall completion time\n    if [ ${DURATION} -le 60 ]; then\n        logger \"Duration  : ${DURATION} Seconds\"\n    else\n        logger \"Duration  : $(awk 'BEGIN{ printf \"%.2f\\n\", '${DURATION}'/60}') Minutes\\n\"\n    fi\n    logger \"\\n---------------------------------------------------------------------------------------------------------------\\n\"\n    echo\n}\n\nghettoVCBrestore() {\n    VM_FILE=$1\n\n    startTimer\n\n    ORIG_IFS=${IFS}\n    IFS='\n'\n\n    for LINE in $(cat \"${VM_FILE}\" | sed '/^$/d' | sed -e '/^#/d' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//'); do\n        VM_TO_RESTORE=$(echo \"${LINE}\" | awk -F ';' '{print $1}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n        DATASTORE_TO_RESTORE_TO=$(echo \"${LINE}\" | awk -F ';' '{print $2}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n        RESTORE_DISK_FORMAT=$(echo \"${LINE}\" | awk -F ';' '{print $3}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n        RESTORE_VM_NAME=$(echo \"${LINE}\" | awk -F ';' '{print $4}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n\n        #figure the disk format to use\n        if [ \"${RESTORE_DISK_FORMAT}\" -eq 1 ]; then\n            FORMAT_STRING=zeroedthick\n        elif [ \"${RESTORE_DISK_FORMAT}\" -eq 2 ]; then\n            FORMAT_STRING=2gbsparse\n        elif [ \"${RESTORE_DISK_FORMAT}\" -eq 3 ]; then\n            FORMAT_STRING=thin\n        elif [ \"${RESTORE_DISK_FORMAT}\" -eq 4 ]; then\n            FORMAT_STRING=eagerzeroedthick\n        fi\n\n        #supports DIR or .TGZ from ghettoVCB.sh ONLY!\n        if [ ${VM_TO_RESTORE##*.} == 'gz' ]; then\n            logger \"GZ found, extracting ...\"\n            ${TAR} -xzf $VM_TO_RESTORE -C `dirname $VM_TO_RESTORE`\n            VM_TO_RESTORE=${VM_TO_RESTORE%.*}\n        fi\n        if [ -d \"${VM_TO_RESTORE}\" ]; then\n            #figure out the contents of the directory (*.vmdk,*-flat.vmdk,*.vmx)\n            VM_ORIG_VMX=$(ls \"${VM_TO_RESTORE}\" | grep \".vmx\")\n            VM_ORIG_NVRAM=$(ls \"${VM_TO_RESTORE}\" | grep \".nvram\")\n            VM_VMDK_DESCRS=$(ls \"${VM_TO_RESTORE}\" | grep \".vmdk\" | grep -v \"\\-flat.vmdk\")\n            VMDKS_FOUND=$(grep -iE '(scsi|ide|sata)' \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\" | grep -i fileName | awk -F \" \" '{print $1}')\n            VM_FOLDER_NAME=$(echo \"${VM_TO_RESTORE##*/}\")\n\n            # Default to original VM Display Name if custom name is not specified\n            if [ -z ${RESTORE_VM_NAME} ]; then\n                VM_DISPLAY_NAME=$(grep -i \"displayName\" \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\" | awk -F '=' '{print $2}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n                VM_ORIG_FOLDER_NAME=$(echo \"${VM_FOLDER_NAME}\" | sed 's/-[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-1].*//g')\n                VM_VMX_NAME=${VM_ORIG_VMX}\n                VM_RESTORE_FOLDER_NAME=${VM_ORIG_FOLDER_NAME}\n                VM_RESTORE_VMX=${VM_ORIG_VMX}\n                VM_RESTORE_NVRAM=${VM_DISPLAY_NAME}.nvram\n            else\n                VM_DISPLAY_NAME=${RESTORE_VM_NAME}\n                VM_RESTORE_FOLDER_NAME=${RESTORE_VM_NAME}\n                VM_RESTORE_VMX=${RESTORE_VM_NAME}.vmx\n                VM_RESTORE_NVRAM=${RESTORE_VM_NAME}.nvram\n            fi\n\n            #figure out the VMDK rename, esepcially important if original backup had VMDKs spread across multiple datastores\n            #restoration will not support that since I can't assume the original system will be availabl with same ds/etc.\n            #files will be restored to single VMFS volume without disrupting original backup\n\n            NUM_OF_VMDKS=0\n            TMP_IFS=${IFS}\n            IFS=${ORIG_IFS}\n            for VMDK in ${VMDKS_FOUND}; do\n                #extract the SCSI ID and use it to check for valid vmdk disk\n                SCSI_ID=$(echo ${VMDK%%.*})\n                grep -i \"${SCSI_ID}.present\" \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\" | grep -i \"true\" > /dev/null 2>&1\n                #if valid, then we use the vmdk file\n                if [ $? -eq 0 ]; then\n                    grep -i \"${SCSI_ID}.deviceType\" \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\" | grep -i \"scsi-hardDisk\" > /dev/null 2>&1\n                    #if we find the device type is of scsi-disk, then proceed\n                    if [ $? -eq 0 ]; then\n                        DISK=$(grep -i ${SCSI_ID}.fileName \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\")\n                    else\n                        #if the deviceType is NULL for IDE which it is, thanks for the inconsistency VMware\n                        #we'll do one more level of verification by checking to see if an ext. of .vmdk exists\n                        #since we can not rely on the deviceType showing \"ide-hardDisk\"\n                        grep -i ${SCSI_ID}.fileName \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\" | grep -i \".vmdk\" > /dev/null 2>&1\n                        if [ $? -eq 0 ]; then\n                            DISK=$(grep -i ${SCSI_ID}.fileName \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\")\n                        fi\n                    fi\n\n                    if [ \"${DISK}\" != \"\" ]; then \n                        SCSI_CONTROLLER=$(echo ${DISK} | awk -F '=' '{print $1}')\n                        RENAME_DESTINATION_LINE_VMDK_DISK=\"${SCSI_CONTROLLER} = \\\"${VM_DISPLAY_NAME}-${NUM_OF_VMDKS}.vmdk\\\"\"\n                        if [ -z \"${VMDK_LIST_TO_MODIFY}\" ]; then\n                            VMDK_LIST_TO_MODIFY=\"${DISK},${RENAME_DESTINATION_LINE_VMDK_DISK}\"\n                        else\n                            VMDK_LIST_TO_MODIFY=\"${VMDK_LIST_TO_MODIFY};${DISK},${RENAME_DESTINATION_LINE_VMDK_DISK}\"\n                        fi\n                        DISK=''\n                    fi\n                fi\n                NUM_OF_VMDKS=$((NUM_OF_VMDKS+1))\n            done\n            IFS=${TMP_IFS}\n        else \n            logger \"Support for .tgz not supported - \\\"${VM_TO_RESTORE}\\\" will not be backed up!\"\n            IS_TGZ=1\n        fi\n\nif [ ! \"${IS_TGZ}\" == \"1\" ]; then\n    if [ \"${DEVEL_MODE}\" == \"1\" ]; then\n        logger \"\\n################ DEBUG MODE ##############\"\n        logger \"Virtual Machine: \\\"${VM_DISPLAY_NAME}\\\"\"\n        logger \"VM_ORIG_VMX: \\\"${VM_ORIG_VMX}\\\"\"\n        logger \"VM_ORG_FOLDER: \\\"${VM_FOLDER_NAME}\\\"\"\n        logger \"VM_RESTORE_VMX: \\\"${VM_RESTORE_VMX}\\\"\"\n        logger \"VM_RESTORE_FOLDER: \\\"${VM_RESTORE_FOLDER_NAME}\\\"\"\n        logger \"VMDK_LIST_TO_MODIFY:\"\n        OLD_IFS=\"${IFS}\"\n        IFS=\";\"\n        for i in ${VMDK_LIST_TO_MODIFY}; do\n            VMDK_1=$(echo $i | awk -F ',' '{print $1}')\n            VMDK_2=$(echo $i | awk -F ',' '{print $2}')\n            logger \"${VMDK_1}\"\n            logger \"${VMDK_2}\"\n        done\n        unset IFS\n        IFS=\"${OLD_IFS}\"\n        logger \"##########################################\\n\"\n    else\n        #validates the datastore to restore is valid and available\n        if [ ! -d \"${DATASTORE_TO_RESTORE_TO}\" ]; then\n            logger \"ERROR: Unable to verify datastore location: \\\"${DATASTORE_TO_RESTORE_TO}\\\"! Ensure this exists\"\n            #validates that all 4 required variables are defined before continuing \n\n        elif [[ -z \"${VM_RESTORE_VMX}\" ]] && [[ -z \"${VM_VMDK_DESCRS}\" ]] && [[ -z \"${VM_DISPLAY_NAME}\" ]] && [[ -z \"${VM_RESTORE_FOLDER_NAME}\" ]]; then\t\t\t     \t    \n            logger \"ERROR: Unable to define all required variables: VM_RESTORE_VMX, VM_VMDK_DESCR and VM_DISPLAY_NAME!\"\t\n            #validates that a directory with the same VM does not already exists\n\n        elif [ -d \"${DATASTORE_TO_RESTORE_TO}/${VM_RESTORE_FOLDER_NAME}\" ]; then\n            logger \"ERROR: Directory \\\"${DATASTORE_TO_RESTORE_TO}/${VM_RESTORE_FOLDER_NAME}\\\" looks like it already exists, please check contents and remove directory before trying to restore!\" \n\n        else\t\t\n            logger \"################## Restoring VM: $VM_DISPLAY_NAME  #####################\"\n            if [ \"${DEVEL_MODE}\" == \"2\" ]; then\n                logger \"==========> DEBUG MODE LEVEL 2 ENABLED <==========\"\n            fi\n\n            logger \"Start time: $(date)\"\n            logger \"Restoring VM from: \\\"${VM_TO_RESTORE}\\\"\"\n            logger \"Restoring VM to Datastore: \\\"${DATASTORE_TO_RESTORE_TO}\\\" using Disk Format: \\\"${FORMAT_STRING}\\\"\"\n\n            VM_RESTORE_DIR=\"${DATASTORE_TO_RESTORE_TO}/${VM_RESTORE_FOLDER_NAME}\"\n\n            #create VM folder on datastore if it doesn't already exists\n            logger \"Creating VM directory: \\\"${VM_RESTORE_DIR}\\\" ...\"\n            if [ ! \"${DEVEL_MODE}\" == \"2\" ]; then\t\n                mkdir -p \"${VM_RESTORE_DIR}\"\n            fi\n\n            #copy .vmx & .nvram file\n            logger \"Copying \\\"${VM_ORIG_VMX}\\\" file ...\"\n            if [ ! \"${DEVEL_MODE}\" == \"2\" ]; then\n                cp \"${VM_TO_RESTORE}/${VM_ORIG_VMX}\" \"${VM_RESTORE_DIR}/${VM_RESTORE_VMX}\"\n                sed -i \"s/displayName =.*/displayName = \\\"${VM_DISPLAY_NAME}\\\"/g\" \"${VM_RESTORE_DIR}/${VM_RESTORE_VMX}\"\n\n                cp \"${VM_TO_RESTORE}/${VM_ORIG_NVRAM}\" \"${VM_RESTORE_DIR}/${VM_RESTORE_NVRAM}\"\n                sed -i \"s/nvram =.*/nvram = \\\"${VM_RESTORE_NVRAM}\\\"/g\" \"${VM_RESTORE_DIR}/${VM_RESTORE_VMX}\"\n            fi\n\n            #loop through all VMDK(s) and vmkfstools copy to destination\n            logger \"Restoring VM's VMDK(s) ...\"\n            #MAX=${#ORIGINAL_VMX_VMDK_LINES[*]}\n\n            OLD_IFS=\"${IFS}\"\n            IFS=\";\"\n            for i in ${VMDK_LIST_TO_MODIFY}; do\n                #retrieve individual VMDKs\n                SOURCE_LINE_VMDK=$(echo \"${i}\" | awk -F ',' '{print $1}' | awk -F '=' '{print $2}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n                DESTINATION_LINE_VMDK=$(echo \"${i}\" | awk -F ',' '{print $2}' | awk -F '=' '{print $2}' | sed 's/\"//g' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n                #retrieve individual VMDK lines in .vmx file to update\n                ORIGINAL_VMX_LINE=$(echo \"${i}\" | awk -F ',' '{print $1}')\n                MODIFIED_VMX_LINE=$(echo \"${i}\" | awk -F ',' '{print $2}')\n\n                #update restored VM to match VMDKs\n                logger \"Updating VMDK entry in \\\"${VM_RESTORE_VMX}\\\" file ...\"\n                if [ ! \"${DEVEL_MODE}\" == \"2\" ]; then\n                    sed -i \"s#${ORIGINAL_VMX_LINE}#${MODIFIED_VMX_LINE}#g\" \"${VM_RESTORE_DIR}/${VM_RESTORE_VMX}\"\n                fi\n\n                echo \"${SOURCE_LINE_VMDK}\" | grep \"/vmfs/volumes\" > /dev/null 2>&1\n                if [ $? -eq 0 ]; then\n                    #SOURCE_VMDK=\"${SOURCE_LINE_VMDK}\"\n                    DS_VMDK_PATH=$(echo \"${SOURCE_LINE_VMDK}\" | sed 's/\\/vmfs\\/volumes\\///g')\n                    VMDK_DATASTORE=$(echo \"${DS_VMDK_PATH%%/*}\")\n                    VMDK_VM=$(echo \"${DS_VMDK_PATH##*/}\")\n                    SOURCE_VMDK=\"${VM_TO_RESTORE}/${VMDK_DATASTORE}/${VMDK_VM}\"\n                else\n                    SOURCE_VMDK=\"${VM_TO_RESTORE}/${SOURCE_LINE_VMDK}\"\n                fi\n                DESTINATION_VMDK=\"${VM_RESTORE_DIR}/${DESTINATION_LINE_VMDK}\"\n\n                if [ ! \"${DEVEL_MODE}\" == \"2\" ]; then\n                    ADAPTER_FORMAT=$(grep -i \"ddb.adapterType\" \"${SOURCE_VMDK}\" | awk -F \"=\" '{print $2}' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//;s/\"//g')\n\n                    if [ ${RESTORE_DISK_FORMAT} -eq 1 ]; then\n                        if [[ \"${VER}\" == \"4\" ]] || [[ \"${VER}\" == \"5\" ]] || [[ \"${VER}\" == \"6\" ]] ; then\n                            ${VMKFSTOOLS_CMD} -i \"${SOURCE_VMDK}\" -a \"${ADAPTER_FORMAT}\" -d zeroedthick \"${DESTINATION_VMDK}\" 2>&1 | tee \"${REDIRECT}\"\n                        else\n                            ${VMKFSTOOLS_CMD} -i \"${SOURCE_VMDK}\" -a \"${ADAPTER_FORMAT}\" \"${DESTINATION_VMDK}\" 2>&1 | tee \"${REDIRECT}\"\n                        fi\n\n                    elif [ ${RESTORE_DISK_FORMAT} -eq 2 ]; then\n                        ${VMKFSTOOLS_CMD} -i \"${SOURCE_VMDK}\" -a \"${ADAPTER_FORMAT}\" -d 2gbsparse \"${DESTINATION_VMDK}\" 2>&1 | tee \"${REDIRECT}\"\n\n                    elif [ ${RESTORE_DISK_FORMAT} -eq 3 ]; then\n                        ${VMKFSTOOLS_CMD} -i \"${SOURCE_VMDK}\" -a \"${ADAPTER_FORMAT}\" -d thin \"${DESTINATION_VMDK}\" 2>&1 | tee \"${REDIRECT}\"\n\n                    elif [ ${RESTORE_DISK_FORMAT} -eq 4 ]; then\n                        if [[ \"${VER}\" == \"4\" ]] || [[ \"${VER}\" == \"5\" ]] || [[ \"${VER}\" == \"6\" ]] ; then\n                            ${VMKFSTOOLS_CMD} -i \"${SOURCE_VMDK}\" -a \"${ADAPTER_FORMAT}\" -d eagerzeroedthick \"${DESTINATION_VMDK}\" 2>&1 | tee \"${REDIRECT}\"\n                        else\n                            ${VMKFSTOOLS_CMD} -i \"${SOURCE_VMDK}\" -a \"${ADAPTER_FORMAT}\" \"${DESTINATION_VMDK}\" 2>&1 | tee \"${REDIRECT}\"\n                        fi\n                    fi\n                else\n                    logger \"\\nSOURCE: \\\"${SOURCE_VMDK}\\\"\"\n                    logger \"\\tORIGINAL_VMX_LINE: -->${ORIGINAL_VMX_LINE}<--\"\n                    logger \"DESTINATION: \\\"${DESTINATION_VMDK}\\\"\"\n                    logger \"\\tMODIFIED_VMX_LINE: -->${MODIFIED_VMX_LINE}<--\"\n                fi\n            done\n            unset IFS\n            IFS=\"${OLD_IFS}\"\t\t\t\t\n\n            #register VM on ESX(i) host\n            logger \"Registering $VM_DISPLAY_NAME ...\"\n\n            if [ ! \"${DEVEL_MODE}\" == \"2\" ]; then\n                ${VMWARE_CMD} solo/registervm \"${VM_RESTORE_DIR}/${VM_RESTORE_VMX}\"\n            fi\n\n            logger \"End time: $(date)\"\n            logger \"################## Completed restore for $VM_DISPLAY_NAME! #####################\\n\"\n        fi\n    fi\nfi\n\nVMDK_LIST_TO_MODIFY=''\n    done\n    unset IFS\t\n\n    endTimer\n}\n\n####################\n#                  #\n# Start of Script  #\n#                  #\n####################\n\n#read user input\nwhile getopts \":c:l:d:\" ARGS; do\n    case $ARGS in\n        c) \n            CONFIG_FILE=\"${OPTARG}\"\n            ;;\n        l)\n            LOG_OUTPUT=\"${OPTARG}\"\n            ;;\n        d)\n            DEVEL_MODE=\"${OPTARG}\"\n            ;;\n        :)\n            echo \"Option -${OPTARG} requires an argument.\"\n            exit 1\n            ;;\n        *)\n            printUsage\n            exit 1\n            ;;\n    esac\ndone\n\n#performs a check on the number of commandline arguments + verifies $2 is a valid file\nsanityCheck $#\n\nghettoVCBrestore ${CONFIG_FILE}\n"
        },
        {
          "name": "ghettoVCB-restore_vm_restore_configuration_template",
          "type": "blob",
          "size": 0.3017578125,
          "content": "#\"<DIRECTORY or .TGZ>;<DATASTORE_TO_RESTORE_TO>;<DISK_FORMAT_TO_RESTORE>\"\n# DISK_FORMATS\n# 1 = zeroedthick\n# 2 = 2gbsparse\n# 3 = thin\n# 4 = eagerzeroedthick\n# e.g.\n# \"/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS/STA202I/STA202I-2009-08-18--1;/vmfs/volumes/himalaya-local-SATA.RE4-GP:Storage;1\"\n"
        },
        {
          "name": "ghettoVCB-vm_backup_configuration_template",
          "type": "blob",
          "size": 0.34765625,
          "content": "VM_BACKUP_VOLUME=/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\nDISK_BACKUP_FORMAT=thin\nVM_BACKUP_ROTATION_COUNT=3\nPOWER_VM_DOWN_BEFORE_BACKUP=0\nENABLE_HARD_POWER_OFF=0\nITER_TO_WAIT_SHUTDOWN=4\nPOWER_DOWN_TIMEOUT=5\nSNAPSHOT_TIMEOUT=15\nENABLE_COMPRESSION=0\nVM_SNAPSHOT_MEMORY=0\nVM_SNAPSHOT_QUIESCE=0\nVMDK_FILES_TO_BACKUP=\"VCAP.vmdk,VCAP_2.vmdk\"\n"
        },
        {
          "name": "ghettoVCB.conf",
          "type": "blob",
          "size": 0.7783203125,
          "content": "VM_BACKUP_VOLUME=/vmfs/volumes/dlgCore-NFS-bigboi.VM-Backups/WILLIAM_BACKUPS\nDISK_BACKUP_FORMAT=thin\nVM_BACKUP_ROTATION_COUNT=3\nPOWER_VM_DOWN_BEFORE_BACKUP=0\nENABLE_HARD_POWER_OFF=0\nITER_TO_WAIT_SHUTDOWN=3\nPOWER_DOWN_TIMEOUT=5\nENABLE_COMPRESSION=0\nVM_SNAPSHOT_MEMORY=0\nVM_SNAPSHOT_QUIESCE=0\nALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP=0\nENABLE_NON_PERSISTENT_NFS=0\nUNMOUNT_NFS=0\nNFS_SERVER=172.30.0.195\nNFS_VERSION=nfs\nNFS_MOUNT=/nfsshare\nNFS_LOCAL_NAME=nfs_storage_backup\nNFS_VM_BACKUP_DIR=mybackups\nSNAPSHOT_TIMEOUT=15\nEMAIL_ALERT=0\nEMAIL_LOG=0\nEMAIL_SERVER=auroa.primp-industries.com\nEMAIL_SERVER_PORT=25\nEMAIL_DELAY_INTERVAL=1\nEMAIL_USER_NAME=\nEMAIL_USER_PASSWORD=\nEMAIL_TO=auroa@primp-industries.com\nEMAIL_ERRORS_TO=\nEMAIL_FROM=root@ghettoVCB\nWORKDIR_DEBUG=0\nVM_SHUTDOWN_ORDER=\nVM_STARTUP_ORDER=\n"
        },
        {
          "name": "ghettoVCB.sh",
          "type": "blob",
          "size": 73.45703125,
          "content": "#!/bin/sh\n# Author: William Lam\n# Created Date: 11/17/2008\n# http://www.williamlam.com/\n# https://github.com/lamw/ghettoVCB\n# http://communities.vmware.com/docs/DOC-8760\n\n##################################################################\n#                   User Definable Parameters\n##################################################################\n\nLAST_MODIFIED_DATE=2024_06_30\nVERSION=1\n\n# directory that all VM backups should go (e.g. /vmfs/volumes/SAN_LUN1/mybackupdir)\nVM_BACKUP_VOLUME=/vmfs/volumes/mini-local-datastore-hdd/backups\n\n# Format output of VMDK backup\n# zeroedthick\n# 2gbsparse\n# thin\n# eagerzeroedthick\nDISK_BACKUP_FORMAT=thin\n\n# Number of backups for a given VM before deleting\nVM_BACKUP_ROTATION_COUNT=3\n\n# Shutdown guestOS prior to running backups and power them back on afterwards\n# This feature assumes VMware Tools are installed, else they will not power down and loop forever\n# 1=on, 0 =off\nPOWER_VM_DOWN_BEFORE_BACKUP=0\n\n# enable shutdown code 1=on, 0 = off\nENABLE_HARD_POWER_OFF=0\n\n# if the above flag \"ENABLE_HARD_POWER_OFF \"is set to 1, then will look at this flag which is the # of iterations\n# the script will wait before executing a hard power off, this will be a multiple of 60seconds\n# (e.g) = 3, which means this will wait up to 180seconds (3min) before it just powers off the VM\nITER_TO_WAIT_SHUTDOWN=3\n\n# Number of iterations the script will wait before giving up on powering down the VM and ignoring it for backup\n# this will be a multiple of 60 (e.g) = 5, which means this will wait up to 300secs (5min) before it gives up\nPOWER_DOWN_TIMEOUT=5\n\n# enable compression with gzip+tar 1=on, 0=off\nENABLE_COMPRESSION=0\n\n# Include VMs memory when taking snapshot\nVM_SNAPSHOT_MEMORY=0\n\n# Quiesce VM when taking snapshot (requires VMware Tools to be installed)\nVM_SNAPSHOT_QUIESCE=0\n\n# default 15min timeout\nSNAPSHOT_TIMEOUT=15\n\n# Allow VMs with snapshots to be backed up, this WILL CONSOLIDATE EXISTING SNAPSHOTS!\nALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP=0\n\n##########################################################\n# NON-PERSISTENT NFS-BACKUP ONLY\n#\n# ENABLE NON PERSISTENT NFS BACKUP 1=on, 0=off\n\nENABLE_NON_PERSISTENT_NFS=0\n\n# umount NFS datastore after backup is complete 1=yes, 0=no\nUNMOUNT_NFS=0\n\n# IP Address of NFS Server\nNFS_SERVER=172.51.0.192\n\n# NFS Version (v3=nfs v4=nfsv41) - Only v3 is valid for 5.5\nNFS_VERSION=nfs\n\n# Path of exported folder residing on NFS Server (e.g. /some/mount/point )\nNFS_MOUNT=/upload\n\n# Non-persistent NFS datastore display name of choice\nNFS_LOCAL_NAME=backup\n\n# Name of backup directory for VMs residing on the NFS volume\nNFS_VM_BACKUP_DIR=mybackups\n\n##########################################################\n# EMAIL CONFIGURATIONS\n#\n\n# Email Alerting 1=yes, 0=no\nEMAIL_ALERT=0\n# Email log 1=yes, 0=no\nEMAIL_LOG=0\n\n# Email Delay Interval from NC (netcat) - default 1\nEMAIL_DELAY_INTERVAL=1\n\n# Email SMTP server\nEMAIL_SERVER=auroa.primp-industries.com\n\n# Email SMTP server port\nEMAIL_SERVER_PORT=25\n\n# Email SMTP username\nEMAIL_USER_NAME=\n\n# Email SMTP password\nEMAIL_USER_PASSWORD=\n\n# Email FROM\nEMAIL_FROM=root@ghettoVCB\n\n# Comma seperated list of receiving email addresses\nEMAIL_TO=auroa@primp-industries.com\n\n# Comma seperated list of additional receiving email addresses if status is not \"OK\"\nEMAIL_ERRORS_TO=\n\n# Comma separated list of VM startup/shutdown ordering\nVM_SHUTDOWN_ORDER=\nVM_STARTUP_ORDER=\n\n# RSYNC LINK 1=yes, 0 = no\nRSYNC_LINK=0\n\n# DO NOT USE - UNTESTED CODE\n# Path to another location that should have backups rotated,\n# this is useful when your backups go to a temporary location\n# then are rsync'd to a final destination.  You can specify the final\n# destination as the ADDITIONAL_ROTATION_PATH which will be rotated after\n# all VMs have been restarted\nADDITIONAL_ROTATION_PATH=\n\n##########################################################\n# SLOW NAS CONFIGURATIONS - By Rapitharian\n##########################################################\n#This Feature was added to the program to provide a fix for slow NAS devices similar to the Drobo and Synology devices.  SMB and Home NAS devices.\n#This Feature enables the device to perform tasks (Deletes/data save for large files) and has the script wait for the NAS to catchup.\n#This code has been in production on the authors systems for the last 2 years.\n\n# Enable use of the NFS IO HACK for all NAS commands 1=yes, 0=no\n# 0 uses the script in it's original state.\nENABLE_NFS_IO_HACK=0\n\n# Set this value to determine how many times the script tries to work arround I/O errors each time the NAS slows down.\n# The script will skip past this loop if the NAS is responsive.\nNFS_IO_HACK_LOOP_MAX=10\n\n# This value determines the  number of seconds to sleep, when the NFS device is unresponsive.\nNFS_IO_HACK_SLEEP_TIMER=60\n\n# ONLY USE THIS WITH EXTREMELY SLOW NAS DEVICES!\n# This is a Brute-force/Mandatory delay added on top of any delay imposed by the NFS_IO_Hack.\n# Set a delay timer to allow the NFS server to catch up to GhettoVCB's stream, when the NAS isn't responding timely.\n# This acts like a cooldown period for the NAS.\n# The value is measured in seconds.  This causes the script to pause between each VM.\nNFS_BACKUP_DELAY=0\n\n##################################################################\n#                   End User Definable Parameters\n##################################################################\n\n########################## DO NOT MODIFY PAST THIS LINE ##########################\n\n# Do not remove workdir on exit: 1=yes, 0=no\nWORKDIR_DEBUG=0\nLOG_LEVEL=\"info\"\nVMDK_FILES_TO_BACKUP=\"all\"\n\nVERSION_STRING=${LAST_MODIFIED_DATE}_${VERSION}\n\n# Directory naming convention for backup rotations (please ensure there are no spaces!)\n# If set to \"0\", VMs will be rotated via an index, beginning at 0, ending at\n# VM_BACKUP_ROTATION_COUNT-1\nVM_BACKUP_DIR_NAMING_CONVENTION=\"$(date +%F_%H-%M-%S)\"\n\n\nprintUsage() {\n        echo \"###############################################################################\"\n        echo \"#\"\n        echo \"# ghettoVCB for ESX/ESXi 3.5, 4.x, 5.x, 6.x, 7.x & 8.x\"\n        echo \"# Author: William Lam\"\n        echo \"# http://www.virtuallyghetto.com/\"\n        echo \"# Documentation: http://communities.vmware.com/docs/DOC-8760\"\n        echo \"# Created: 11/17/2008\"\n        echo \"# Last modified: ${LAST_MODIFIED_DATE} Version ${VERSION}\"\n        echo \"#\"\n        echo \"###############################################################################\"\n        echo\n        echo \"Usage: $(basename $0) [options]\"\n        echo\n        echo \"OPTIONS:\"\n        echo \"   -a     Backup all VMs on host\"\n        echo \"   -f     List of VMs to backup\"\n        echo \"   -m     Name of VM to backup (overrides -f)\"\n        echo \"   -j     Job name to show in email report subject (makes sense only in conjunction with -f)\"\n        echo \"   -c     VM configuration directory for VM backups\"\n        echo \"   -g     Path to global ghettoVCB configuration file\"\n        echo \"   -l     File to output logging\"\n        echo \"   -w     ghettoVCB work directory (default: /tmp/ghettoVCB.work)\"\n        echo \"   -d     Debug level [info|debug|dryrun] (default: info)\"\n        echo\n        echo \"(e.g.)\"\n        echo -e \"\\nBackup list of VMs from a file (optionally include a job name for the email report)\"\n        echo -e \"\\t$0 -f vms_to_backup [ -j myJob ]\"\n        echo -e \"\\nBackup a single VM\"\n        echo -e \"\\t$0 -m vm_to_backup\"\n        echo -e \"\\nBackup all VMs residing on this host\"\n        echo -e \"\\t$0 -a\"\n        echo -e \"\\nBackup all VMs residing on this host except for the VMs in the exclusion list\"\n        echo -e \"\\t$0 -a -e vm_exclusion_list\"\n        echo -e \"\\nBackup VMs based on specific configuration located in directory\"\n        echo -e \"\\t$0 -f vms_to_backup -c vm_backup_configs\"\n        echo -e \"\\nBackup VMs using global ghettoVCB configuration file\"\n        echo -e \"\\t$0 -f vms_to_backup -g /global/ghettoVCB.conf\"\n        echo -e \"\\nOutput will log to /tmp/ghettoVCB.log (consider logging to local or remote datastore to persist logs)\"\n        echo -e \"\\t$0 -f vms_to_backup -l /vmfs/volume/local-storage/ghettoVCB.log\"\n        echo -e \"\\nDry run (no backup will take place)\"\n        echo -e \"\\t$0 -f vms_to_backup -d dryrun\"\n        echo\n}\n\nlogger() {\n    LOG_TYPE=$1\n    MSG=$2\n\n    if [[ \"${LOG_LEVEL}\" == \"debug\" ]] && [[ \"${LOG_TYPE}\" == \"debug\" ]] || [[ \"${LOG_TYPE}\" == \"info\" ]] || [[ \"${LOG_TYPE}\" == \"dryrun\" ]]; then\n        TIME=$(date +%F\" \"%H:%M:%S)\n        if [[ \"${LOG_TO_STDOUT}\" -eq 1 ]] ; then\n            echo -e \"${TIME} -- ${LOG_TYPE}: ${MSG}\"\n        fi\n\n        if [[ -n \"${LOG_OUTPUT}\" ]] ; then\n            echo -e \"${TIME} -- ${LOG_TYPE}: ${MSG}\" >> \"${LOG_OUTPUT}\"\n        fi\n\n        if [[ \"${EMAIL_LOG}\" -eq 1 ]] ; then\n            echo -ne \"${TIME} -- ${LOG_TYPE}: ${MSG}\\r\\n\" >> \"${EMAIL_LOG_OUTPUT}\"\n        fi\n    fi\n}\n\nsanityCheck() {\n    # ensure root user is running the script\n    if [ ! $(env | grep -e \"^USER=\" | awk -F = '{print $2}') == \"root\" ]; then\n        logger \"info\" \"This script needs to be executed by \\\"root\\\"!\"\n        echo \"ERROR: This script needs to be executed by \\\"root\\\"!\"\n        exit 1\n    fi\n\n    # use of global ghettoVCB configuration\n    if [[ \"${USE_GLOBAL_CONF}\" -eq 1 ]] ; then\n        reConfigureGhettoVCBConfiguration \"${GLOBAL_CONF}\"\n    fi\n\n    # always log to STDOUT, use \"> /dev/null\" to ignore output\n    LOG_TO_STDOUT=1\n\n    #if no logfile then provide default logfile in /tmp\n\n    if [[ -z \"${LOG_OUTPUT}\" ]] ; then\n        LOG_OUTPUT=\"/tmp/ghettoVCB-$(date +%F_%H-%M-%S)-$$.log\"\n        echo \"Logging output to \\\"${LOG_OUTPUT}\\\" ...\"\n    fi\n\n    touch \"${LOG_OUTPUT}\"\n    # REDIRECT is used by the \"tail\" trick, use REDIRECT=/dev/null to redirect vmkfstool to STDOUT only\n    REDIRECT=${LOG_OUTPUT}\n\n    if [[ ! -f \"${VM_FILE}\" ]] && [[ \"${USE_VM_CONF}\" -eq 0 ]] && [[ \"${BACKUP_ALL_VMS}\" -eq 0 ]]; then\n        logger \"info\" \"ERROR: \\\"${VM_FILE}\\\" is not valid VM input file!\"\n        printUsage\n\texit 1\n    fi\n\n    if [[ ! -f \"${VM_EXCLUSION_FILE}\" ]] && [[ \"${EXCLUDE_SOME_VMS}\" -eq 1 ]]; then\n        logger \"info\" \"ERROR: \\\"${VM_EXCLUSION_FILE}\\\" is not valid VM exclusion input file!\"\n        printUsage\n\texit 1\n    fi\n\n    if [[ ! -d \"${CONFIG_DIR}\" ]] && [[ \"${USE_VM_CONF}\" -eq 1 ]]; then\n        logger \"info\" \"ERROR: \\\"${CONFIG_DIR}\\\" is not valid directory!\"\n        printUsage\n\texit 1\n    fi\n\n    if [[ ! -f \"${GLOBAL_CONF}\" ]] && [[ \"${USE_GLOBAL_CONF}\" -eq 1 ]]; then\n        logger \"info\" \"ERROR: \\\"${GLOBAL_CONF}\\\" is not valid global configuration file!\"\n        printUsage\n\texit 1\n    fi\n\n    if [[ -f /usr/bin/vmware-vim-cmd ]]; then\n        VMWARE_CMD=/usr/bin/vmware-vim-cmd\n        VMKFSTOOLS_CMD=/usr/sbin/vmkfstools\n    elif [[ -f /bin/vim-cmd ]]; then\n        VMWARE_CMD=/bin/vim-cmd\n        VMKFSTOOLS_CMD=/sbin/vmkfstools\n    else\n        logger \"info\" \"ERROR: Unable to locate *vimsh*!\"\n        echo \"ERROR: Unable to locate *vimsh*!\"\n        exit 1\n    fi\n    if ${VMKFSTOOLS_CMD} 2>&1 -h | grep -F -e '--adaptertype' | grep -qF 'deprecated' || ! ${VMKFSTOOLS_CMD} 2>&1 -h | grep -F -e '--adaptertype'; then\n        ADAPTERTYPE_DEPRECATED=1\n    fi\n\n    ESX_VERSION=$(vmware -v | awk '{print $3}')\n    ESX_RELEASE=$(uname -r)\n\n    case \"${ESX_VERSION}\" in\n        8.0.0|8.0.1|8.0.2|8.0.3)    VER=8; break;;\n        7.0.0|7.0.1|7.0.2|7.0.3)    VER=7; break;;\n        6.0.0|6.5.0|6.7.0)          VER=6; break;;\n        5.0.0|5.1.0|5.5.0)          VER=5; break;;\n        4.0.0|4.1.0)                VER=4; break;;\n        3.5.0|3i)                   VER=3; break;;\n        *)              echo \"ESX(i) version not supported!\"; exit 1; break;;\n    esac\n\n    NEW_VIMCMD_SNAPSHOT=\"no\"\n    ${VMWARE_CMD} vmsvc/snapshot.remove 2>&1 | grep -q \"snapshotId\"\n    [[ $? -eq 0 ]] && NEW_VIMCMD_SNAPSHOT=\"yes\"\n\n    if [[ \"${EMAIL_LOG}\" -eq 1 ]] && [[ -f /usr/bin/nc ]] || [[ -f /bin/nc ]]; then\n        if [[ -f /usr/bin/nc ]] ; then\n            NC_BIN=/usr/bin/nc\n        elif [[ -f /bin/nc ]] ; then\n            NC_BIN=/bin/nc\n        fi\n    else\n        EMAIL_LOG=0\n    fi\n\n    TAR=\"tar\"\n    [[ ! -f /bin/tar ]] && TAR=\"busybox tar\"\n\n    # Enable multiextent VMkernel module if disk format is 2gbsparse (disabled by default in 5.1)\n    if [[ \"${DISK_BACKUP_FORMAT}\" == \"2gbsparse\" ]] && [[ \"${VER}\" -eq 5 || \"${VER}\" == \"6\" || \"${VER}\" == \"7\" ]]; then\n        esxcli system module list | grep multiextent > /dev/null 2>&1\n\tif [ $? -eq 1 ]; then\n            logger \"info\" \"multiextent VMkernel module is not loaded & is required for 2gbsparse, enabling ...\"\n            esxcli system module load -m multiextent\n        fi\n    fi\n}\n\nstartTimer() {\n    START_TIME=$(date)\n    S_TIME=$(date +%s)\n}\n\nendTimer() {\n    END_TIME=$(date)\n    E_TIME=$(date +%s)\n    DURATION=$(echo $((E_TIME - S_TIME)))\n\n    #calculate overall completion time\n    if [[ ${DURATION} -le 60 ]] ; then\n        logger \"info\" \"Backup Duration: ${DURATION} Seconds\"\n    else\n        logger \"info\" \"Backup Duration: $(awk 'BEGIN{ printf \"%.2f\\n\", '${DURATION}'/60}') Minutes\"\n    fi\n}\n\ncaptureDefaultConfigurations() {\n    DEFAULT_VM_BACKUP_VOLUME=\"${VM_BACKUP_VOLUME}\"\n    DEFAULT_DISK_BACKUP_FORMAT=\"${DISK_BACKUP_FORMAT}\"\n    DEFAULT_VM_BACKUP_ROTATION_COUNT=\"${VM_BACKUP_ROTATION_COUNT}\"\n    DEFAULT_POWER_VM_DOWN_BEFORE_BACKUP=\"${POWER_VM_DOWN_BEFORE_BACKUP}\"\n    DEFAULT_ENABLE_HARD_POWER_OFF=\"${ENABLE_HARD_POWER_OFF}\"\n    DEFAULT_ITER_TO_WAIT_SHUTDOWN=\"${ITER_TO_WAIT_SHUTDOWN}\"\n    DEFAULT_POWER_DOWN_TIMEOUT=\"${POWER_DOWN_TIMEOUT}\"\n    DEFAULT_SNAPSHOT_TIMEOUT=\"${SNAPSHOT_TIMEOUT}\"\n    DEFAULT_ENABLE_COMPRESSION=\"${ENABLE_COMPRESSION}\"\n    DEFAULT_VM_SNAPSHOT_MEMORY=\"${VM_SNAPSHOT_MEMORY}\"\n    DEFAULT_VM_SNAPSHOT_QUIESCE=\"${VM_SNAPSHOT_QUIESCE}\"\n    DEFAULT_ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP=\"${ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP}\"\n    DEFAULT_VMDK_FILES_TO_BACKUP=\"${VMDK_FILES_TO_BACKUP}\"\n    DEFAULT_EMAIL_LOG=\"${EMAIL_LOG}\"\n    DEFAULT_WORKDIR_DEBUG=\"${WORKDIR_DEBUG}\"\n    DEFAULT_VM_SHUTDOWN_ORDER=\"${VM_SHUTDOWN_ORDER}\"\n    DEFAULT_VM_STARTUP_ORDER=\"${VM_STARTUP_ORDER}\"\n    DEFAULT_RSYNC_LINK=\"${RSYNC_LINK}\"\n    DEFAULT_BACKUP_FILES_CHMOD=\"${BACKUP_FILES_CHMOD}\"\n    # Added the NFS_IO_HACK values below\n    DEFAULT_NFS_IO_HACK_LOOP_MAX=\"${NFS_IO_HACK_LOOP_MAX}\"\n    DEFAULT_NFS_IO_HACK_SLEEP_TIMER=\"${NFS_IO_HACK_SLEEP_TIMER}\"\n    DEFAULT_NFS_BACKUP_DELAY=\"${NFS_BACKUP_DELAY}\"\n    DEFAULT_ENABLE_NFS_IO_HACK=\"${ENABLE_NFS_IO_HACK}\"\n}\n\nuseDefaultConfigurations() {\n    VM_BACKUP_VOLUME=\"${DEFAULT_VM_BACKUP_VOLUME}\"\n    DISK_BACKUP_FORMAT=\"${DEFAULT_DISK_BACKUP_FORMAT}\"\n    VM_BACKUP_ROTATION_COUNT=\"${DEFAULT_VM_BACKUP_ROTATION_COUNT}\"\n    POWER_VM_DOWN_BEFORE_BACKUP=\"${DEFAULT_POWER_VM_DOWN_BEFORE_BACKUP}\"\n    ENABLE_HARD_POWER_OFF=\"${DEFAULT_ENABLE_HARD_POWER_OFF}\"\n    ITER_TO_WAIT_SHUTDOWN=\"${DEFAULT_ITER_TO_WAIT_SHUTDOWN}\"\n    POWER_DOWN_TIMEOUT=\"${DEFAULT_POWER_DOWN_TIMEOUT}\"\n    SNAPSHOT_TIMEOUT=\"${DEFAULT_SNAPSHOT_TIMEOUT}\"\n    ENABLE_COMPRESSION=\"${DEFAULT_ENABLE_COMPRESSION}\"\n    VM_SNAPSHOT_MEMORY=\"${DEFAULT_VM_SNAPSHOT_MEMORY}\"\n    VM_SNAPSHOT_QUIESCE=\"${DEFAULT_VM_SNAPSHOT_QUIESCE}\"\n    ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP=\"${DEFAULT_ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP}\"\n    VMDK_FILES_TO_BACKUP=\"${DEFAULT_VMDK_FILES_TO_BACKUP}\"\n    EMAIL_LOG=\"${DEFAULT_EMAIL_LOG}\"\n    WORKDIR_DEBUG=\"${DEFAULT_WORKDIR_DEBUG}\"\n    VM_SHUTDOWN_ORDER=\"${DEFAULT_VM_SHUTDOWN_ORDER}\"\n    VM_STARTUP_ORDER=\"${DEFAULT_VM_STARTUP_ORDER}\"\n    RSYNC_LINK=\"${RSYNC_LINK}\"\n    BACKUP_FILES_CHMOD=\"${BACKUP_FILES_CHMOD}\"\n\t  # Added the NFS_IO_HACK values below\n    ENABLE_NFS_IO_HACK=\"${DEFAULT_ENABLE_NFS_IO_HACK}\"\n    NFS_IO_HACK_LOOP_MAX=\"${DEFAULT_NFS_IO_HACK_LOOP_MAX}\"\n    NFS_IO_HACK_SLEEP_TIMER=\"${DEFAULT_NFS_IO_HACK_SLEEP_TIMER}\"\n    NFS_BACKUP_DELAY=\"${DEFAULT_NFS_BACKUP_DELAY}\"\n}\n\nreConfigureGhettoVCBConfiguration() {\n    GLOBAL_CONF=$1\n\n    if [[ -f \"${GLOBAL_CONF}\" ]]; then\n        source \"${GLOBAL_CONF}\"\n    else\n        useDefaultConfigurations\n    fi\n}\n\nreConfigureBackupParam() {\n    VM=$1\n\n    if [[ -e \"${CONFIG_DIR}/${VM}\" ]]; then\n        logger \"info\" \"CONFIG - USING CONFIGURATION FILE = ${CONFIG_DIR}/${VM}\"\n        source \"${CONFIG_DIR}/${VM}\"\n    else\n        useDefaultConfigurations\n    fi\n}\n\ndumpHostInfo() {\n    VERSION=$(vmware -v)\n    logger \"debug\" \"HOST VERSION: ${VERSION}\"\n    echo ${VERSION} | grep \"Server 3i\" > /dev/null 2>&1\n    [[ $? -eq 1 ]] && logger \"debug\" \"HOST LEVEL: $(vmware -l)\"\n    logger \"debug\" \"HOSTNAME: $(hostname)\\n\"\n}\n\nfindVMDK() {\n    VMDK_TO_SEARCH_FOR=$1\n\n    #if [[ \"${USE_VM_CONF}\" -eq 1 ]] ; then\n    logger \"debug\" \"findVMDK() - Searching for VMDK: \\\"${VMDK_TO_SEARCH_FOR}\\\" to backup\"\n\n    OLD_IFS2=\"${IFS}\"\n    IFS=\",\"\n    for k in ${VMDK_FILES_TO_BACKUP}; do\n        VMDK_FILE=$(echo $k | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n        if [[ \"${VMDK_FILE}\" == \"${VMDK_TO_SEARCH_FOR}\" ]] ; then\n            logger \"debug\" \"findVMDK() - Found VMDK! - \\\"${VMDK_TO_SEARCH_FOR}\\\" to backup\"\n            isVMDKFound=1\n        fi\n    done\n    IFS=\"${OLD_IFS2}\"\n    #fi\n}\n\ngetVMDKs() {\n    #get all VMDKs listed in .vmx file\n    VMDKS_FOUND=$(grep -iE '(^scsi|^ide|^sata|^nvme)' \"${VMX_PATH}\" | grep -i fileName | awk -F \" \" '{print $1}')\n\n    VMDKS=\n    INDEP_VMDKS=\n\n    TMP_IFS=${IFS}\n    IFS=${ORIG_IFS}\n    #loop through each disk and verify that it's currently present and create array of valid VMDKS\n    for DISK in ${VMDKS_FOUND}; do\n        #extract the SCSI ID and use it to check for valid vmdk disk\n        SCSI_ID=$(echo ${DISK%%.*})\n        grep -i \"^${SCSI_ID}.present\" \"${VMX_PATH}\" | grep -i \"true\" > /dev/null 2>&1\n\n        #if valid, then we use the vmdk file\n        if [[ $? -eq 0 ]]; then\n            #verify disk is not independent\n            grep -i \"^${SCSI_ID}.mode\" \"${VMX_PATH}\" | grep -i \"independent\" > /dev/null 2>&1\n            if [[ $? -eq 1 ]]; then\n                grep -i \"^${SCSI_ID}.deviceType\" \"${VMX_PATH}\" | grep -i \"scsi-hardDisk\" > /dev/null 2>&1\n\n                #if we find the device type is of scsi-disk, then proceed\n                if [[ $? -eq 0 ]]; then\n                    DISK=$(grep -i \"^${SCSI_ID}.fileName\" \"${VMX_PATH}\" | awk -F \"\\\"\" '{print $2}')\n                    echo \"${DISK}\" | grep \"\\/vmfs\\/volumes\" > /dev/null 2>&1\n\n                    if [[ $? -eq 0 ]]; then\n                        DISK_SIZE_IN_SECTORS=$(cat \"${DISK}\" | grep \"VMFS\" | grep \".vmdk\" | awk '{print $2}')\n                    else\n                        DISK_SIZE_IN_SECTORS=$(cat \"${VMX_DIR}/${DISK}\" | grep \"VMFS\" | grep \".vmdk\" | awk '{print $2}')\n                    fi\n\n                    DISK_SIZE=$(echo \"${DISK_SIZE_IN_SECTORS}\" | awk '{printf \"%.0f\\n\",$1*512/1024/1024/1024}')\n                    VMDKS=\"${DISK}###${DISK_SIZE}:${VMDKS}\"\n                    TOTAL_VM_SIZE=$((TOTAL_VM_SIZE+DISK_SIZE))\n                else\n                    #if the deviceType is NULL for IDE which it is, thanks for the inconsistency VMware\n                    #we'll do one more level of verification by checking to see if an ext. of .vmdk exists\n                    #since we can not rely on the deviceType showing \"ide-hardDisk\"\n                    grep -i \"^${SCSI_ID}.fileName\" \"${VMX_PATH}\" | grep -i \".vmdk\" > /dev/null 2>&1\n\n                    if [[ $? -eq 0 ]]; then\n                        DISK=$(grep -i \"^${SCSI_ID}.fileName\" \"${VMX_PATH}\" | awk -F \"\\\"\" '{print $2}')\n                        echo \"${DISK}\" | grep \"\\/vmfs\\/volumes\" > /dev/null 2>&1\n                        if [[ $? -eq 0 ]]; then\n                            DISK_SIZE_IN_SECTORS=$(cat \"${DISK}\" | grep \"VMFS\" | grep \".vmdk\" | awk '{print $2}')\n                        else\n                            DISK_SIZE_IN_SECTORS=$(cat \"${VMX_DIR}/${DISK}\" | grep \"VMFS\" | grep \".vmdk\" | awk '{print $2}')\n                        fi\n                        DISK_SIZE=$(echo \"${DISK_SIZE_IN_SECTORS}\" | awk '{printf \"%.0f\\n\",$1*512/1024/1024/1024}')\n                        VMDKS=\"${DISK}###${DISK_SIZE}:${VMDKS}\"\n                        TOTAL_VM_SIZE=$((TOTAL_VM_SIZE_IN+DISK_SIZE))\n                    fi\n                fi\n\n            else\n                #independent disks are not affected by snapshots, hence they can not be backed up\n                DISK=$(grep -i \"^${SCSI_ID}.fileName\" \"${VMX_PATH}\" | awk -F \"\\\"\" '{print $2}')\n                echo \"${DISK}\" | grep \"\\/vmfs\\/volumes\" > /dev/null 2>&1\n                if [[ $? -eq 0 ]]; then\n                    DISK_SIZE_IN_SECTORS=$(cat \"${DISK}\" | grep \"VMFS\" | grep \".vmdk\" | awk '{print $2}')\n                else\n                    DISK_SIZE_IN_SECTORS=$(cat \"${VMX_DIR}/${DISK}\" | grep \"VMFS\" | grep \".vmdk\" | awk '{print $2}')\n                fi\n                DISK_SIZE=$(echo \"${DISK_SIZE_IN_SECTORS}\" | awk '{printf \"%.0f\\n\",$1*512/1024/1024/1024}')\n                INDEP_VMDKS=\"${DISK}###${DISK_SIZE}:${INDEP_VMDKS}\"\n            fi\n        fi\n    done\n    IFS=${TMP_IFS}\n    logger \"debug\" \"getVMDKs() - ${VMDKS}\"\n}\n\ndumpVMConfigurations() {\n    logger \"info\" \"CONFIG - VERSION = ${VERSION_STRING}\"\n    logger \"info\" \"CONFIG - GHETTOVCB_PID = ${GHETTOVCB_PID}\"\n    logger \"info\" \"CONFIG - VM_BACKUP_VOLUME = ${VM_BACKUP_VOLUME}\"\n    logger \"info\" \"CONFIG - ENABLE_NON_PERSISTENT_NFS = ${ENABLE_NON_PERSISTENT_NFS}\"\n    if [[ \"${ENABLE_NON_PERSISTENT_NFS}\" -eq 1 ]]; then\n        logger \"info\" \"CONFIG - UNMOUNT_NFS = ${UNMOUNT_NFS}\"\n        logger \"info\" \"CONFIG - NFS_SERVER = ${NFS_SERVER}\"\n        logger \"info\" \"CONFIG - NFS_VERSION = ${NFS_VERSION}\"\n        logger \"info\" \"CONFIG - NFS_MOUNT = ${NFS_MOUNT}\"\n    fi\n    logger \"info\" \"CONFIG - VM_BACKUP_ROTATION_COUNT = ${VM_BACKUP_ROTATION_COUNT}\"\n    logger \"info\" \"CONFIG - VM_BACKUP_DIR_NAMING_CONVENTION = ${VM_BACKUP_DIR_NAMING_CONVENTION}\"\n    logger \"info\" \"CONFIG - DISK_BACKUP_FORMAT = ${DISK_BACKUP_FORMAT}\"\n    logger \"info\" \"CONFIG - POWER_VM_DOWN_BEFORE_BACKUP = ${POWER_VM_DOWN_BEFORE_BACKUP}\"\n    logger \"info\" \"CONFIG - ENABLE_HARD_POWER_OFF = ${ENABLE_HARD_POWER_OFF}\"\n    logger \"info\" \"CONFIG - ITER_TO_WAIT_SHUTDOWN = ${ITER_TO_WAIT_SHUTDOWN}\"\n    logger \"info\" \"CONFIG - POWER_DOWN_TIMEOUT = ${POWER_DOWN_TIMEOUT}\"\n    logger \"info\" \"CONFIG - SNAPSHOT_TIMEOUT = ${SNAPSHOT_TIMEOUT}\"\n    logger \"info\" \"CONFIG - LOG_LEVEL = ${LOG_LEVEL}\"\n    logger \"info\" \"CONFIG - BACKUP_LOG_OUTPUT = ${LOG_OUTPUT}\"\n    logger \"info\" \"CONFIG - ENABLE_COMPRESSION = ${ENABLE_COMPRESSION}\"\n    logger \"info\" \"CONFIG - VM_SNAPSHOT_MEMORY = ${VM_SNAPSHOT_MEMORY}\"\n    logger \"info\" \"CONFIG - VM_SNAPSHOT_QUIESCE = ${VM_SNAPSHOT_QUIESCE}\"\n    logger \"info\" \"CONFIG - ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP = ${ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP}\"\n    logger \"info\" \"CONFIG - VMDK_FILES_TO_BACKUP = ${VMDK_FILES_TO_BACKUP}\"\n    logger \"info\" \"CONFIG - VM_SHUTDOWN_ORDER = ${VM_SHUTDOWN_ORDER}\"\n    logger \"info\" \"CONFIG - VM_STARTUP_ORDER = ${VM_STARTUP_ORDER}\"\n    logger \"info\" \"CONFIG - RSYNC_LINK = ${RSYNC_LINK}\"\n    logger \"info\" \"CONFIG - BACKUP_FILES_CHMOD = ${BACKUP_FILES_CHMOD}\"\n    logger \"info\" \"CONFIG - EMAIL_LOG = ${EMAIL_LOG}\"\n    if [[ \"${EMAIL_LOG}\" -eq 1 ]]; then\n        logger \"info\" \"CONFIG - EMAIL_SERVER = ${EMAIL_SERVER}\"\n        logger \"info\" \"CONFIG - EMAIL_SERVER_PORT = ${EMAIL_SERVER_PORT}\"\n        logger \"info\" \"CONFIG - EMAIL_DELAY_INTERVAL = ${EMAIL_DELAY_INTERVAL}\"\n        logger \"info\" \"CONFIG - EMAIL_FROM = ${EMAIL_FROM}\"\n        logger \"info\" \"CONFIG - EMAIL_TO = ${EMAIL_TO}\"\n        logger \"info\" \"CONFIG - WORKDIR_DEBUG = ${WORKDIR_DEBUG}\"\n    fi\n    if [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then\n        logger \"info\" \"CONFIG - ENABLE_NFS_IO_HACK = ${ENABLE_NFS_IO_HACK}\"\n        logger \"info\" \"CONFIG - NFS_IO HACK_LOOP_MAX = ${NFS_IO_HACK_LOOP_MAX}\"\n        logger \"info\" \"CONFIG - NFS_IO HACK_SLEEP_TIMER = ${NFS_IO_HACK_SLEEP_TIMER}\"\n        logger \"info\" \"CONFIG - NFS_BACKUP_DELAY = ${NFS_BACKUP_DELAY}\"\n    else\n        logger \"info\" \"CONFIG - ENABLE_NFS_IO_HACK = ${ENABLE_NFS_IO_HACK}\"\n    fi\n}\n\n# Added the function below to allow reuse of the basics of the original hack in more places in the script.\n# Rewrote the code to reduce the calls to the NAS when it slows.  Why make a bad situation worse with extra calls? \nNfsIoHack() {\n    # NFS I/O error handling hack\n    NFS_IO_HACK_COUNTER=0\n    NFS_IO_HACK_STATUS=0\n    NFS_IO_HACK_FILECHECK=\"$BACKUP_DIR_PATH/nfs_io.check\"\n\n    while [[ \"${NFS_IO_HACK_STATUS}\" -eq 0 ]] && [[ \"${NFS_IO_HACK_COUNTER}\" -lt \"${NFS_IO_HACK_LOOP_MAX}\" ]]; do\n        touch \"${NFS_IO_HACK_FILECHECK}\"\n        if [[ $? -ne 0 ]] ; then\n            sleep \"${NFS_IO_HACK_SLEEP_TIMER}\"\n            NFS_IO_HACK_COUNTER=$((NFS_IO_HACK_COUNTER+1))\n        fi\n        [[ $? -eq 0 ]] && NFS_IO_HACK_STATUS=1\n    done\n\n    NFS_IO_HACK_SLEEP_TIME=$((NFS_IO_HACK_COUNTER*NFS_IO_HACK_SLEEP_TIMER))\n\n    rm -rf \"${NFS_IO_HACK_FILECHECK}\"\n\n    if [[ \"${NFS_IO_HACK_SLEEP_TIME}\" -ne 0 ]] ; then\n        if [[ \"${NFS_IO_HACK_STATUS}\" -eq 1 ]] ; then\n            logger \"info\" \"Slept ${NFS_IO_HACK_SLEEP_TIME} seconds to work around NFS I/O error\"\n        else\n            logger \"info\" \"Slept ${NFS_IO_HACK_SLEEP_TIME} seconds but failed work around for NFS I/O error\"\n        fi\n    fi\n}\n\n# Converted the section of code below to a function to be able to call it when a failed backup occurs.\nGet_Final_Status_Sendemail() {\n    getFinalStatus\n\n    logger \"debug\" \"Succesfully removed lock directory - ${WORKDIR}\\n\"\n    logger \"info\" \"============================== ghettoVCB LOG END ================================\\n\"\n\n    sendMail\n}\n\nindexedRotate() {\n    local BACKUP_DIR_PATH=\"$1\"\n    local VM_TO_SEARCH_FOR=\"$2\"\n\n    #default rotation if variable is not defined\n    if [[ -z ${VM_BACKUP_ROTATION_COUNT} ]]; then\n        VM_BACKUP_ROTATION_COUNT=1\n    fi\n\n    #LIST_BACKUPS=$(ls -t \"${BACKUP_DIR_PATH}\" | grep \"${VM_TO_SEARCH_FOR}-[0-9]*\")\n    i=${VM_BACKUP_ROTATION_COUNT}\n    while [[ $i -ge 0 ]]; do\n        if [[ -f \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz\" ]]; then\n            if [[ $i -eq $((VM_BACKUP_ROTATION_COUNT-1)) ]]; then\n                rm -f \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz\"\n                # Added the NFS_IO_HACK check and function call here.  Some NAS devices slow at this step.\n                if [[ $? -ne 0 ]]  && [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then\n                    NfsIoHack\n                fi\n                if [[ $? -eq 0 ]]; then\n                    logger \"info\" \"Deleted ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz\"\n                else\n                    logger \"info\" \"Failure deleting ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz\"\n                fi\n            else\n                mv -f \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz\" \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$((i+1)).gz\"\n                # Added the NFS_IO_HACK check and function call here.  Some NAS devices slow at this step.\n                if [[ $? -ne 0 ]]  && [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then\n                    NfsIoHack\n                fi\n                if [[ $? -eq 0 ]]; then\n                    logger \"info\" \"Moved ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz to ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$((i+1)).gz\"\n                else\n                    logger \"info\" \"Failure moving ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i.gz to ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$((i+1)).gz\"\n                fi\n            fi\n        fi\n        if [[ -d \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i\" ]]; then\n            if [[ $i -eq $((VM_BACKUP_ROTATION_COUNT-1)) ]]; then\n                rm -rf \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i\"\n                # Added the NFS_IO_HACK check and function call here.  Some NAS devices slow at this step.\n                if [[ $? -ne 0 ]]  && [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then\n                    NfsIoHack\n                fi\n                if [[ $? -eq 0 ]]; then\n                    logger \"info\" \"Deleted ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i\"\n                else\n                    logger \"info\" \"Failure deleting ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i\"\n                fi\n            else\n                mv -f \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i\" \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$((i+1))\"\n                # Added the NFS_IO_HACK check and function call here.  Some NAS devices slow at this step.\n                if [[ $? -ne 0 ]]  && [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then\n                    NfsIoHack\n                fi\n                if [[ $? -eq 0 ]]; then\n                    logger \"info\" \"Moved ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i to ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$((i+1))\"\n                else\n                    logger \"info\" \"Failure moving ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i to ${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$((i+1))\"\n                fi\n                if [[ $i -eq 0 ]]; then\n                    mkdir \"${BACKUP_DIR_PATH}/${VM_TO_SEARCH_FOR}-$i\"\n                fi\n            fi\n        fi\n\n        i=$((i-1))\n    done\n}\n\ncheckVMBackupRotation() {\n    local BACKUP_DIR_PATH=\"$1\"\n    local VM_TO_SEARCH_FOR=\"$2\"\n\n    #default rotation if variable is not defined\n    if [[ -z ${VM_BACKUP_ROTATION_COUNT} ]]; then\n        VM_BACKUP_ROTATION_COUNT=1\n    fi\n\n    LIST_BACKUPS=$(ls -t \"${BACKUP_DIR_PATH}\" | grep \"${VM_TO_SEARCH_FOR}-[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}_[0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\")\n    BACKUPS_TO_KEEP=$(ls -t \"${BACKUP_DIR_PATH}\" | grep \"${VM_TO_SEARCH_FOR}-[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}_[0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\" | head -\"${VM_BACKUP_ROTATION_COUNT}\")\n\n    ORIG_IFS=${IFS}\n    IFS='\n'\n    for i in ${LIST_BACKUPS}; do\n        FOUND=0\n        for j in ${BACKUPS_TO_KEEP}; do\n            [[ $i == $j ]] && FOUND=1\n        done\n\n        if [[ $FOUND -eq 0 ]]; then\n            logger \"debug\" \"Removing $BACKUP_DIR_PATH/$i\"\n            rm -rf \"$BACKUP_DIR_PATH/$i\"\n\t    RETVAL=$?\n\n            # Added the NFS_IO_HACK check and function call here.  Also set the script to function the same, if the new feature is turned off.\n            # Added variables to the code to control the timers and loops.\n            # This code could be optimized based on the work in the NFS_IO_HACK function or that code could be used all the time with a few minor changes.\n            if [[ $RETVAL -ne 0 ]] && [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then \n                NfsIoHack\n            else\n                #NFS I/O error handling hack\n                if [[ $RETVAL -ne 0 ]] ; then\n                  NFS_IO_HACK_COUNTER=0\n                  NFS_IO_HACK_STATUS=0\n                  NFS_IO_HACK_FILECHECK=\"$BACKUP_DIR_PATH/nfs_io.check\"\n\n                  while [[ \"${NFS_IO_HACK_STATUS}\" -eq 0 ]] && [[ \"${NFS_IO_HACK_COUNTER}\" -lt \"${NFS_IO_HACK_LOOP_MAX}\" ]]; do\n                    sleep \"${NFS_IO_HACK_SLEEP_TIMER}\"\n                    NFS_IO_HACK_COUNTER=$((NFS_IO_HACK_COUNTER+1))\n                    touch \"${NFS_IO_HACK_FILECHECK}\"\n\n                    [[ $? -eq 0 ]] && NFS_IO_HACK_STATUS=1\n                  done\n\n                  NFS_IO_HACK_SLEEP_TIME=$((NFS_IO_HACK_COUNTER*NFS_IO_HACK_SLEEP_TIMER))\n\n                  rm -rf \"${NFS_IO_HACK_FILECHECK}\"\n\n                  if [[ \"${NFS_IO_HACK_STATUS}\" -eq 1 ]] ; then\n                    logger \"info\" \"Slept ${NFS_IO_HACK_SLEEP_TIME} seconds to work around NFS I/O error\"\n                  else\n                    logger \"info\" \"Slept ${NFS_IO_HACK_SLEEP_TIME} seconds but failed work around for NFS I/O error\"\n                  fi\n                fi\n            fi\n        fi\n    done\n    IFS=${ORIG_IFS}\n}\n\nstorageInfo() {\n    SECTION=$1\n\n    #SOURCE DATASTORE\n    SRC_DATASTORE_CAPACITY=$($VMWARE_CMD hostsvc/datastore/info \"${VMFS_VOLUME}\" | grep -i \"capacity\" | awk '{print $3}' | sed 's/,//g')\n    SRC_DATASTORE_FREE=$($VMWARE_CMD hostsvc/datastore/info \"${VMFS_VOLUME}\" | grep -i \"freespace\" | awk '{print $3}' | sed 's/,//g')\n    SRC_DATASTORE_BLOCKSIZE=$($VMWARE_CMD hostsvc/datastore/info \"${VMFS_VOLUME}\" | grep -i blockSizeMb | awk '{print $3}' | sed 's/,//g')\n    if [[ -z ${SRC_DATASTORE_BLOCKSIZE} ]] ; then\n        SRC_DATASTORE_BLOCKSIZE=\"NA\"\n        SRC_DATASTORE_MAX_FILE_SIZE=\"NA\"\n    else\n        case ${SRC_DATASTORE_BLOCKSIZE} in\n            1)SRC_DATASTORE_MAX_FILE_SIZE=\"256 GB\";;\n            2)SRC_DATASTORE_MAX_FILE_SIZE=\"512 GB\";;\n            4)SRC_DATASTORE_MAX_FILE_SIZE=\"1024 GB\";;\n            8)SRC_DATASTORE_MAX_FILE_SIZE=\"2048 GB\";;\n        esac\n    fi\n    SRC_DATASTORE_CAPACITY_GB=$(echo \"${SRC_DATASTORE_CAPACITY}\" | awk '{printf \"%.1f\\n\",$1/1024/1024/1024}')\n    SRC_DATASTORE_FREE_GB=$(echo \"${SRC_DATASTORE_FREE}\" | awk '{printf \"%.1f\\n\",$1/1024/1024/1024}')\n\n    #DESTINATION DATASTORE\n    DST_VOL_1=$(echo \"${VM_BACKUP_VOLUME#/*/*/}\")\n    DST_DATASTORE=$(echo \"${DST_VOL_1%%/*}\")\n    DST_DATASTORE_CAPACITY=$($VMWARE_CMD hostsvc/datastore/info \"${DST_DATASTORE}\" | grep -i \"capacity\" | awk '{print $3}' | sed 's/,//g')\n    DST_DATASTORE_FREE=$($VMWARE_CMD hostsvc/datastore/info \"${DST_DATASTORE}\" | grep -i \"freespace\" | awk '{print $3}' | sed 's/,//g')\n    DST_DATASTORE_BLOCKSIZE=$($VMWARE_CMD hostsvc/datastore/info \"${DST_DATASTORE}\" | grep -i blockSizeMb | awk '{print $3}' | sed 's/,//g')\n\n    if [[ -z ${DST_DATASTORE_BLOCKSIZE} ]] ; then\n        DST_DATASTORE_BLOCKSIZE=\"NA\"\n        DST_DATASTORE_MAX_FILE_SIZE=\"NA\"\n    else\n        case ${DST_DATASTORE_BLOCKSIZE} in\n            1)DST_DATASTORE_MAX_FILE_SIZE=\"256 GB\";;\n            2)DST_DATASTORE_MAX_FILE_SIZE=\"512 GB\";;\n            4)DST_DATASTORE_MAX_FILE_SIZE=\"1024 GB\";;\n            8)DST_DATASTORE_MAX_FILE_SIZE=\"2048 GB\";;\n        esac\n    fi\n\n    DST_DATASTORE_CAPACITY_GB=$(echo \"${DST_DATASTORE_CAPACITY}\" | awk '{printf \"%.1f\\n\",$1/1024/1024/1024}')\n    DST_DATASTORE_FREE_GB=$(echo \"${DST_DATASTORE_FREE}\" | awk '{printf \"%.1f\\n\",$1/1024/1024/1024}')\n\n    logger \"debug\" \"Storage Information ${SECTION} backup: \"\n    logger \"debug\" \"SRC_DATASTORE: ${VMFS_VOLUME}\"\n    logger \"debug\" \"SRC_DATASTORE_CAPACITY: ${SRC_DATASTORE_CAPACITY_GB} GB\"\n    logger \"debug\" \"SRC_DATASTORE_FREE: ${SRC_DATASTORE_FREE_GB} GB\"\n    logger \"debug\" \"SRC_DATASTORE_BLOCKSIZE: ${SRC_DATASTORE_BLOCKSIZE}\"\n    logger \"debug\" \"SRC_DATASTORE_MAX_FILE_SIZE: ${SRC_DATASTORE_MAX_FILE_SIZE}\"\n    logger \"debug\" \"\"\n    logger \"debug\" \"DST_DATASTORE: ${DST_DATASTORE}\"\n    logger \"debug\" \"DST_DATASTORE_CAPACITY: ${DST_DATASTORE_CAPACITY_GB} GB\"\n    logger \"debug\" \"DST_DATASTORE_FREE: ${DST_DATASTORE_FREE_GB} GB\"\n    logger \"debug\" \"DST_DATASTORE_BLOCKSIZE: ${DST_DATASTORE_BLOCKSIZE}\"\n    logger \"debug\" \"DST_DATASTORE_MAX_FILE_SIZE: ${DST_DATASTORE_MAX_FILE_SIZE}\"\n    if [[ \"${SRC_DATASTORE_BLOCKSIZE}\" != \"NA\" ]] && [[ \"${DST_DATASTORE_BLOCKSIZE}\" != \"NA\" ]]; then\n        if [[ \"${SRC_DATASTORE_BLOCKSIZE}\" -lt \"${DST_DATASTORE_BLOCKSIZE}\" ]]; then\n            logger \"debug\" \"\"\n            logger \"debug\" \"SRC VMFS blocksze of ${SRC_DATASTORE_BLOCKSIZE}MB is less than DST VMFS blocksize of ${DST_DATASTORE_BLOCKSIZE}MB which can be an issue for VM snapshots\"\n        fi\n    fi\n\nlogger \"debug\" \"\"\n}\n\npowerOff() {\n    VM_NAME=\"$1\"\n    VM_ID=\"$2\"\n    POWER_OFF_EC=0\n\n    START_ITERATION=0\n    logger \"info\" \"Powering off initiated for ${VM_NAME}, backup will not begin until VM is off...\"\n\n    ${VMWARE_CMD} vmsvc/power.shutdown ${VM_ID} > /dev/null 2>&1\n    while ${VMWARE_CMD} vmsvc/power.getstate ${VM_ID} | grep -i \"Powered on\" > /dev/null 2>&1; do\n        #enable hard power off code\n        if [[ ${ENABLE_HARD_POWER_OFF} -eq 1 ]] ; then\n            if [[ ${START_ITERATION} -ge ${ITER_TO_WAIT_SHUTDOWN} ]] ; then\n                logger \"info\" \"Hard power off occured for ${VM_NAME}, waited for $((ITER_TO_WAIT_SHUTDOWN*60)) seconds\"\n                ${VMWARE_CMD} vmsvc/power.off ${VM_ID} > /dev/null 2>&1\n                #this is needed for ESXi, even the hard power off did not take affect right away\n                sleep 60\n                break\n            fi\n        fi\n\n        logger \"info\" \"VM is still on - Iteration: ${START_ITERATION} - sleeping for 60secs (Duration: $((START_ITERATION*60)) seconds)\"\n        sleep 60\n\n        #logic to not backup this VM if unable to shutdown\n        #after certain timeout period\n        if [[ ${START_ITERATION} -ge ${POWER_DOWN_TIMEOUT} ]] ; then\n            logger \"info\" \"Unable to power off ${VM_NAME}, waited for $((POWER_DOWN_TIMEOUT*60)) seconds! Ignoring ${VM_NAME} for backup!\"\n            POWER_OFF_EC=1\n            break\n        fi\n        START_ITERATION=$((START_ITERATION + 1))\n    done\n    if [[ ${POWER_OFF_EC} -eq 0 ]] ; then\n        logger \"info\" \"VM is powerdOff\"\n    fi\n}\n\npowerOn() {\n    VM_NAME=\"$1\"\n    VM_ID=\"$2\"\n    POWER_ON_EC=0\n\n    START_ITERATION=0\n    logger \"info\" \"Powering on initiated for ${VM_NAME}\"\n\n    ${VMWARE_CMD} vmsvc/power.on ${VM_ID} > /dev/null 2>&1\n    while ${VMWARE_CMD} vmsvc/get.guest ${VM_ID} | grep -i \"toolsNotRunning\" > /dev/null 2>&1; do\n        logger \"info\" \"VM is still not booted - Iteration: ${START_ITERATION} - sleeping for 60secs (Duration: $((START_ITERATION*60)) seconds)\"\n        sleep 60\n\n        #logic to not backup this VM if unable to shutdown\n        #after certain timeout period\n        if [[ ${START_ITERATION} -ge ${POWER_DOWN_TIMEOUT} ]] ; then\n            logger \"info\" \"Unable to detect started tools on ${VM_NAME}, waited for $((POWER_DOWN_TIMEOUT*60)) seconds!\"\n            POWER_ON_EC=1\n            break\n        fi\n        START_ITERATION=$((START_ITERATION + 1))\n    done\n    if [[ ${POWER_ON_EC} -eq 0 ]] ; then\n        logger \"info\" \"VM is powerdOn\"\n    fi\n}\n\nghettoVCB() {\n    VM_INPUT=$1\n    VM_OK=0\n    VM_FAILED=0\n    VMDK_FAILED=0\n    PROBLEM_VMS=\n\n    dumpHostInfo\n\n    if [[ ${ENABLE_NON_PERSISTENT_NFS} -eq 1 ]] ; then\n        VM_BACKUP_VOLUME=\"/vmfs/volumes/${NFS_LOCAL_NAME}/${NFS_VM_BACKUP_DIR}\"\n        if [[ \"${LOG_LEVEL}\" !=  \"dryrun\" ]] ; then\n            #1 = readonly\n            #0 = readwrite\n            logger \"debug\" \"Mounting NFS: ${NFS_SERVER}:${NFS_MOUNT} to /vmfs/volume/${NFS_LOCAL_NAME}\"\n        if [[ ${ESX_RELEASE} != \"3i\" ]] || [[ ${ESX_RELEASE} != \"3.5.0\" || ${ESX_RELEASE} != \"4.0.0\" || ${ESX_RELEASE} != \"4.1.0\" || ${ESX_RELEASE} != \"5.0.0\" || ${ESX_RELEASE} != \"5.1.0\" ]] ; then\n                ${VMWARE_CMD} hostsvc/datastore/nas_create \"${NFS_LOCAL_NAME}\" \"${NFS_VERSION}\" \"${NFS_MOUNT}\" 0 \"${NFS_SERVER}\"\n            else\n                ${VMWARE_CMD} hostsvc/datastore/nas_create \"${NFS_LOCAL_NAME}\" \"${NFS_SERVER}\" \"${NFS_MOUNT}\" 0\n            fi\n\tfi\n    fi\n\n    captureDefaultConfigurations\n\n    if [[ \"${USE_GLOBAL_CONF}\" -eq 1 ]] ; then\n        logger \"info\" \"CONFIG - USING GLOBAL GHETTOVCB CONFIGURATION FILE = ${GLOBAL_CONF}\"\n    fi\n\n    if [[ \"${USE_VM_CONF}\" -eq 0 ]] ; then\n        dumpVMConfigurations\n    fi\n\n    #dump out all virtual machines allowing for spaces now\n    ${VMWARE_CMD} vmsvc/getallvms | sed 's/[[:blank:]]\\{3,\\}/   /g' | fgrep \"[\" | fgrep \"vmx-\" | fgrep \".vmx\" | fgrep \"/\" | awk -F'   ' '{print \"\\\"\"$1\"\\\";\\\"\"$2\"\\\";\\\"\"$3\"\\\"\"}' |  sed 's/\\] /\\]\\\";\\\"/g' > ${WORKDIR}/vms_list\n\n    if [[ \"${BACKUP_ALL_VMS}\" -eq 1 ]] ; then\n        ${VMWARE_CMD} vmsvc/getallvms | sed 's/[[:blank:]]\\{3,\\}/   /g' | fgrep \"[\" | fgrep \"vmx-\" | fgrep \".vmx\" | fgrep \"/\" | awk -F'   ' '{print \"\"$2\"\"}' | sed '/^$/d' > \"${VM_INPUT}\"\n    fi\n\n    ORIG_IFS=${IFS}\n    IFS='\n'\n    if [[ ${#VM_SHUTDOWN_ORDER} -gt 0 ]] && [[ \"${LOG_LEVEL}\" != \"dryrun\" ]]; then\n        logger \"debug\" \"VM Shutdown Order: ${VM_SHUTDOWN_ORDER}\\n\"\n        IFS2=\"${IFS}\"\n        IFS=\",\"\n        for VM_NAME in ${VM_SHUTDOWN_ORDER}; do\n            VM_ID=$(grep -E \"\\\"${VM_NAME}\\\"\" ${WORKDIR}/vms_list | awk -F \";\" '{print $1}' | sed 's/\"//g')\n            powerOff \"${VM_NAME}\" \"${VM_ID}\"\n            if [[ ${POWER_OFF_EC} -eq 1 ]]; then\n                logger \"debug\" \"Error unable to shutdown VM ${VM_NAME}\\n\"\n                PROBLEM_VMS=\"${PROBLEM_VMS} ${VM_NAME}\"\n            fi\n        done\n\n        IFS=\"${IFS2}\"\n    fi\n\n    for VM_NAME in $(cat \"${VM_INPUT}\" | grep -v \"^#\" | sed '/^$/d' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//'); do\n        IGNORE_VM=0\n        if [[ \"${EXCLUDE_SOME_VMS}\" -eq 1 ]] ; then\n            grep -E \"^${VM_NAME}\\$\" \"${VM_EXCLUSION_FILE}\" > /dev/null 2>&1\n            if [[ $? -eq 0 ]] ; then\n                IGNORE_VM=1\n                #VM_FAILED=0   #Excluded VM is NOT a failure. No need to set here, but listed for clarity\n            fi\n        fi\n\n        if [[ \"${IGNORE_VM}\" -eq 0 ]] && [[ -n \"${PROBLEM_VMS}\" ]] ; then\n            if [[ \"$(echo $PROBLEM_VMS | sed \"s@$VM_NAME@@\")\" != \"$PROBLEM_VMS\" ]] ; then\n                logger \"info\" \"Ignoring ${VM_NAME} as a problem VM\\n\"\n                IGNORE_VM=1\n                #A VM ignored due to a problem, should be treated as a failure\n                VM_FAILED=1\n            fi\n        fi\n\n        VM_ID=$(grep -E \"\\\"${VM_NAME}\\\"\" ${WORKDIR}/vms_list | awk -F \";\" '{print $1}' | sed 's/\"//g')\n\n        #ensure default value if one is not selected or variable is null\n        if [[ -z ${VM_BACKUP_DIR_NAMING_CONVENTION} ]] ; then\n            VM_BACKUP_DIR_NAMING_CONVENTION=\"$(date +%F_%k-%M-%S)\"\n        fi\n\n        if [[ \"${USE_VM_CONF}\" -eq 1 ]] && [[ ! -z ${VM_ID} ]]; then\n            reConfigureBackupParam \"${VM_NAME}\"\n            dumpVMConfigurations\n        fi\n\n        VMFS_VOLUME=$(grep -E \"\\\"${VM_NAME}\\\"\" ${WORKDIR}/vms_list | awk -F \";\" '{print $3}' | sed 's/\\[//;s/\\]//;s/\"//g')\n        VMX_CONF=$(grep -E \"\\\"${VM_NAME}\\\"\" ${WORKDIR}/vms_list | awk -F \";\" '{print $4}' | sed 's/\\[//;s/\\]//;s/\"//g')\n        VMX_PATH=\"/vmfs/volumes/${VMFS_VOLUME}/${VMX_CONF}\"\n        VMX_DIR=$(dirname \"${VMX_PATH}\")\n\n        #storage info\n        if [[ ! -z ${VM_ID} ]] && [[ \"${LOG_LEVEL}\" != \"dryrun\" ]]; then\n            storageInfo \"before\"\n        fi\n\n        #ignore VM as it's in the exclusion list or was on problem list\n        if [[ \"${IGNORE_VM}\" -eq 1 ]] ; then\n            logger \"debug\" \"Ignoring ${VM_NAME} for backup since it is located in exclusion file or problem list\\n\"\n        #checks to see if we can pull out the VM_ID\n        elif [[ -z ${VM_ID} ]] ; then\n            logger \"info\" \"ERROR: failed to locate and extract VM_ID for ${VM_NAME}!\\n\"\n            VM_FAILED=1\n\n        elif [[ \"${LOG_LEVEL}\" == \"dryrun\" ]] ; then\n            logger \"dryrun\" \"###############################################\"\n            logger \"dryrun\" \"Virtual Machine: $VM_NAME\"\n            logger \"dryrun\" \"VM_ID: $VM_ID\"\n            logger \"dryrun\" \"VMX_PATH: $VMX_PATH\"\n            logger \"dryrun\" \"VMX_DIR: $VMX_DIR\"\n            logger \"dryrun\" \"VMX_CONF: $VMX_CONF\"\n            logger \"dryrun\" \"VMFS_VOLUME: $VMFS_VOLUME\"\n            logger \"dryrun\" \"VMDK(s): \"\n\n            TOTAL_VM_SIZE=0\n            getVMDKs\n\n            OLD_IFS=\"${IFS}\"\n            IFS=\":\"\n            for j in ${VMDKS}; do\n                J_VMDK=$(echo \"${j}\" | awk -F \"###\" '{print $1}')\n                J_VMDK_SIZE=$(echo \"${j}\" | awk -F \"###\" '{print $2}')\n                logger \"dryrun\" \"\\t${J_VMDK}\\t${J_VMDK_SIZE} GB\"\n            done\n\n            HAS_INDEPENDENT_DISKS=0\n            logger \"dryrun\" \"INDEPENDENT VMDK(s): \"\n            for k in ${INDEP_VMDKS}; do\n                HAS_INDEPENDENT_DISKS=1\n                K_VMDK=$(echo \"${k}\" | awk -F \"###\" '{print $1}')\n                K_VMDK_SIZE=$(echo \"${k}\" | awk -F \"###\" '{print $2}')\n                logger \"dryrun\" \"\\t${K_VMDK}\\t${K_VMDK_SIZE} GB\"\n            done\n\n            IFS=\"${OLD_IFS}\"\n            VMDKS=\"\"\n            INDEP_VMDKS=\"\"\n\n            logger \"dryrun\" \"TOTAL_VM_SIZE_TO_BACKUP: ${TOTAL_VM_SIZE} GB\"\n            if [[ ${HAS_INDEPENDENT_DISKS} -eq 1 ]] ; then\n                logger \"dryrun\" \"Snapshots can not be taken for independent disks!\"\n                logger \"dryrun\" \"THIS VIRTUAL MACHINE WILL NOT HAVE ALL ITS VMDKS BACKED UP!\"\n            fi\n\n            ls \"${VMX_DIR}\" | grep -q \"\\-delta\\.vmdk\" > /dev/null 2>&1;\n            if [[ $? -eq 0 ]]; then\n                if [ ${ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP} -eq 0 ]; then\n                    logger \"dryrun\" \"Snapshots found for this VM, please commit all snapshots before continuing!\"\n                    logger \"dryrun\" \"THIS VIRTUAL MACHINE WILL NOT BE BACKED UP DUE TO EXISTING SNAPSHOTS!\"\n                else\n                    logger \"dryrun\" \"Snapshots found for this VM, ALL EXISTING SNAPSHOTS WILL BE CONSOLIDATED PRIOR TO BACKUP!\"\n                fi\n            fi\n\n            if [[ ${TOTAL_VM_SIZE} -eq 0 ]] ; then\n                logger \"dryrun\" \"THIS VIRTUAL MACHINE WILL NOT BE BACKED UP DUE TO EMPTY VMDK LIST!\"\n            fi\n            logger \"dryrun\" \"###############################################\\n\"\n\n        #checks to see if the VM has any snapshots to start with\n        elif [[ -f \"${VMX_PATH}\" ]] && [[ ! -z \"${VMX_PATH}\" ]]; then\n            if ls \"${VMX_DIR}\" | grep -q \"\\-delta\\.vmdk\" > /dev/null 2>&1; then\n                if [ ${ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP} -eq 0 ]; then\n                    logger \"info\" \"Snapshot found for ${VM_NAME}, backup will not take place\\n\"\n                    VM_FAILED=1\n                    continue\n                elif [ ${ALLOW_VMS_WITH_SNAPSHOTS_TO_BE_BACKEDUP} -eq 1 ]; then\n                    logger \"info\" \"Snapshot found for ${VM_NAME}, consolidating ALL snapshots now (this can take awhile) ...\\n\"\n                    $VMWARE_CMD vmsvc/snapshot.removeall ${VM_ID} > /dev/null 2>&1\n                fi\n            fi\n    \t    #nfs case and backup to root path of your NFS mount\n            if [[ ${ENABLE_NON_PERSISTENT_NFS} -eq 1 ]] ; then\n                BACKUP_DIR=\"/vmfs/volumes/${NFS_LOCAL_NAME}/${NFS_VM_BACKUP_DIR}/${VM_NAME}\"\n                if [[ -z \"${VM_NAME}\" ]] || [[ -z \"${NFS_LOCAL_NAME}\" ]] || [[ -z \"${NFS_VM_BACKUP_DIR}\" ]]; then\n                    logger \"info\" \"ERROR: Variable BACKUP_DIR was not set properly, please ensure all required variables for non-persistent NFS backup option has been defined\"\n                    exit 1\n                fi\n\n                #non-nfs (SAN,LOCAL)\n            else\n                BACKUP_DIR=\"${VM_BACKUP_VOLUME}/${VM_NAME}\"\n                if [[ -z \"${VM_BACKUP_VOLUME}\" ]]; then\n                    logger \"info\" \"ERROR: Variable VM_BACKUP_VOLUME was not defined\"\n                    exit 1\n                fi\n            fi\n\n            #initial root VM backup directory\n            if [[ ! -d \"${BACKUP_DIR}\" ]] ; then\n                mkdir -p \"${BACKUP_DIR}\"\n                if [[ ! -d \"${BACKUP_DIR}\" ]] ; then\n                    logger \"info\" \"Unable to create \\\"${BACKUP_DIR}\\\"! - Ensure VM_BACKUP_VOLUME was defined correctly\"\n                    exit 1\n                fi\n            fi\n\n            # directory name of the individual Virtual Machine backup followed by naming convention followed by count\n            VM_BACKUP_DIR=\"${BACKUP_DIR}/${VM_NAME}-${VM_BACKUP_DIR_NAMING_CONVENTION}\"\n\n            # Rsync relative path variable if needed\n            RSYNC_LINK_DIR=\"./${VM_NAME}-${VM_BACKUP_DIR_NAMING_CONVENTION}\"\n\n            # Do indexed rotation if naming convention is set for it\n            if [[ ${VM_BACKUP_DIR_NAMING_CONVENTION} = \"0\" ]]; then\n                indexedRotate \"${BACKUP_DIR}\" \"${VM_NAME}\"\n            fi\n\n            mkdir -p \"${VM_BACKUP_DIR}\"\n\n            cp \"${VMX_PATH}\" \"${VM_BACKUP_DIR}\"\n\n            # Retrieve nvram file from VMX and back up\n            VM_NVRAM_FILE=$(grep \"nvram\" \"${VMX_PATH}\" | awk -F \"\\\"\" '{print $2}')\n            VM_NVRAM_PATH=\"${VMX_DIR}/${VM_NVRAM_FILE}\"\n\n            if [ -e ${VM_NVRAM_PATH} ]; then\n                cp \"${VM_NVRAM_PATH}\" \"${VM_BACKUP_DIR}\"\n            fi\n\n            #new variable to keep track on whether VM has independent disks\n            VM_HAS_INDEPENDENT_DISKS=0\n\n            #extract all valid VMDK(s) from VM\n            getVMDKs\n\n            CONTINUE_TO_BACKUP=1\n            VM_VMDK_FAILED=0\n\n            if [[ ${VMDK_FILES_TO_BACKUP} != \"all\" ]]; then\n            # check if requested VMDKs exist at all\n                OLD_IFS=\"${IFS}\"\n                IFS=\",\"\n                VMDK_FILES_TO_BACKUP_NEW=\"\"\n                for k in ${VMDK_FILES_TO_BACKUP}; do\n                    # this list is comma separated: \"DISK1,DISK2,...\"\n                    VMDK_FILE_TO_BACKUP=$(echo \"${k}\" | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n                    OLD_IFS2=\"${IFS}\"\n                    IFS=\":\"\n                    VMDK_FOUND=0\n                    for j in ${VMDKS}; do\n                        # this list is colon separated: \"${DISK}###${DISK_SIZE}:${VMDKS}\"\n                        VMDK=$(echo \"${j}\" | awk -F \"###\" '{print $1}')\n                        if [[ \"${VMDK_FILE_TO_BACKUP}\" == \"${VMDK}\" ]]; then\n                            VMDK_FILES_TO_BACKUP_NEW=\"${VMDK_FILES_TO_BACKUP_NEW},${VMDK_FILE_TO_BACKUP}\"\n                            VMDK_FOUND=1\n                            break\n                        fi\n                    done\n                    IFS=\"${OLD_IFS2}\"\n                    if [[ \"${VMDK_FOUND}\" -ne 1 ]]; then\n                    \tlogger \"info\" \"WARNING: ${VMDK_FILE_TO_BACKUP} not found in VMDKs for ${VM_NAME}\"\n                    \tVM_VMDK_FAILED=1\n                    \tbreak\n                    fi\n                done\n                IFS=\"${OLD_IFS}\"\n                if [ -z \"${VMDK_FILES_TO_BACKUP_NEW}\" ]; then\n                    logger \"info\" \"ERROR: No valid VMDKs in list of VMDKs to backup for ${VM_NAME}\"\n                    VM_FAILED=1\n                    CONTINUE_TO_BACKUP=0\n                else\n                    VMDK_FILES_TO_BACKUP=\"${VMDK_FILES_TO_BACKUP_NEW}\"\n                fi\n            fi\n\n            if [[ ! -z ${INDEP_VMDKS} ]] ; then\n                VM_HAS_INDEPENDENT_DISKS=1\n            fi\n\n            ORGINAL_VM_POWER_STATE=$(${VMWARE_CMD} vmsvc/power.getstate ${VM_ID} | tail -1)\n\n            #section that will power down a VM prior to taking a snapshot and backup and power it back on\n            if [[ ${CONTINUE_TO_BACKUP} -eq 1 ]] && [[ ${POWER_VM_DOWN_BEFORE_BACKUP} -eq 1 ]] ; then\n                powerOff \"${VM_NAME}\" \"${VM_ID}\"\n                if [[ ${POWER_OFF_EC} -eq 1 ]]; then\n                    VM_FAILED=1\n                    CONTINUE_TO_BACKUP=0\n                fi\n            fi\n\n            if [[ ${CONTINUE_TO_BACKUP} -eq 1 ]] ; then\n                logger \"info\" \"Initiate backup for ${VM_NAME}\"\n                startTimer\n\n                SNAP_SUCCESS=1\n\n                #powered on VMs only\n                if [[ ! ${POWER_VM_DOWN_BEFORE_BACKUP} -eq 1 ]] && [[ \"${ORGINAL_VM_POWER_STATE}\" != \"Powered off\" ]]; then\n                    SNAPSHOT_NAME=\"ghettoVCB-snapshot-$(date +%F)\"\n                    logger \"info\" \"Creating Snapshot \\\"${SNAPSHOT_NAME}\\\" for ${VM_NAME}\"\n                    ${VMWARE_CMD} vmsvc/snapshot.create ${VM_ID} \"${SNAPSHOT_NAME}\" \"${SNAPSHOT_NAME}\" \"${VM_SNAPSHOT_MEMORY}\" \"${VM_SNAPSHOT_QUIESCE}\" > /dev/null 2>&1\n\n                    logger \"debug\" \"Waiting for snapshot \\\"${SNAPSHOT_NAME}\\\" to be created\"\n                    logger \"debug\" \"Snapshot timeout set to: $((SNAPSHOT_TIMEOUT*60)) seconds\"\n                    START_ITERATION=0\n                    while [[ $(${VMWARE_CMD} vmsvc/snapshot.get ${VM_ID} | wc -l) -eq 1 ]]; do\n                        if [[ ${START_ITERATION} -ge ${SNAPSHOT_TIMEOUT} ]] ; then\n                            logger \"info\" \"Snapshot timed out, failed to create snapshot: \\\"${SNAPSHOT_NAME}\\\" for ${VM_NAME}\"\n                            SNAP_SUCCESS=0\n                            echo \"ERROR: Unable to backup ${VM_NAME} due to snapshot creation\" >> ${VM_BACKUP_DIR}/STATUS.error\n                            break\n                        fi\n\n                        logger \"debug\" \"Waiting for snapshot creation to be completed - Iteration: ${START_ITERATION} - sleeping for 60secs (Duration: $((START_ITERATION*30)) seconds)\"\n                        sleep 60\n\n                        START_ITERATION=$((START_ITERATION + 1))\n                    done\n                fi\n\n                if [[ ${SNAP_SUCCESS} -eq 1 ]] ; then\n                    OLD_IFS=\"${IFS}\"\n                    IFS=\":\"\n                    for j in ${VMDKS}; do\n                        VMDK=$(echo \"${j}\" | awk -F \"###\" '{print $1}')\n                        isVMDKFound=0\n\n                        findVMDK \"${VMDK}\"\n\n                        if [[ $isVMDKFound -eq 1 ]] || [[ \"${VMDK_FILES_TO_BACKUP}\" == \"all\" ]]; then\n                            #added this section to handle VMDK(s) stored in different datastore than the VM\n                            echo ${VMDK} | grep \"^/vmfs/volumes\" > /dev/null 2>&1\n                            if [[ $? -eq 0 ]] ; then\n                                SOURCE_VMDK=\"${VMDK}\"\n                                DS_UUID=\"$(echo ${VMDK#/vmfs/volumes/*})\"\n                                DS_UUID=\"$(echo ${DS_UUID%/*/*})\"\n                                VMDK_DISK=\"$(echo ${VMDK##/*/})\"\n                                mkdir -p \"${VM_BACKUP_DIR}/${DS_UUID}\"\n                                DESTINATION_VMDK=\"${VM_BACKUP_DIR}/${DS_UUID}/${VMDK_DISK}\"\n                            else\n                                SOURCE_VMDK=\"${VMX_DIR}/${VMDK}\"\n                                DESTINATION_VMDK=\"${VM_BACKUP_DIR}/${VMDK}\"\n                            fi\n\n                            #support for vRDM and deny pRDM\n                            grep \"vmfsPassthroughRawDeviceMap\" \"${SOURCE_VMDK}\" > /dev/null 2>&1\n                            if [[ $? -eq 1 ]] ; then\n                                FORMAT_OPTION=\"UNKNOWN\"\n                                if [[ \"${DISK_BACKUP_FORMAT}\" == \"zeroedthick\" ]] ; then\n                                    if [[ \"${VER}\" == \"4\" ]] || [[ \"${VER}\" == \"5\" ]] || [[ \"${VER}\" == \"6\" ]] || [[ \"${VER}\" == \"7\" ]] ; then\n                                        FORMAT_OPTION=\"-d zeroedthick\"\n                                    else\n                                        FORMAT_OPTION=\"\"\n                                    fi\n                                elif [[ \"${DISK_BACKUP_FORMAT}\" == \"2gbsparse\" ]] ; then\n                                    FORMAT_OPTION=\"-d 2gbsparse\"\n                                elif [[ \"${DISK_BACKUP_FORMAT}\" == \"thin\" ]] ; then\n                                    FORMAT_OPTION=\"-d thin\"\n                                elif [[ \"${DISK_BACKUP_FORMAT}\" == \"eagerzeroedthick\" ]] ; then\n                                    if [[ \"${VER}\" == \"4\" ]] || [[ \"${VER}\" == \"5\" ]] || [[ \"${VER}\" == \"6\" ]] || [[ \"${VER}\" == \"7\" ]]; then\n                                        FORMAT_OPTION=\"-d eagerzeroedthick\"\n                                    else\n                                        FORMAT_OPTION=\"\"\n                                    fi\n                                fi\n\n                                if  [[ \"${FORMAT_OPTION}\" == \"UNKNOWN\" ]] ; then\n                                    logger \"info\" \"ERROR: wrong DISK_BACKUP_FORMAT \\\"${DISK_BACKUP_FORMAT}\\ specified for ${VM_NAME}\"\n                                    VM_VMDK_FAILED=1\n                                else\n                                    VMDK_OUTPUT=$(mktemp ${WORKDIR}/ghettovcb.XXXXXX)\n                                    tail -f \"${VMDK_OUTPUT}\" &\n                                    TAIL_PID=$!\n\n                                    [[ -z \"$ADAPTERTYPE_DEPRECATED\" ]] && ADAPTER_FORMAT=$(grep -i \"ddb.adapterType\" \"${SOURCE_VMDK}\" | awk -F \"=\" '{print $2}' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//;s/\"//g')\n                                    [[ -n \"${ADAPTER_FORMAT}\" ]] && ADAPTER_FORMAT=\"-a ${ADAPTER_FORMAT}\"\n\n                                    logger \"debug\" \"${VMKFSTOOLS_CMD} -i \\\"${SOURCE_VMDK}\\\" ${ADAPTER_FORMAT} ${FORMAT_OPTION} \\\"${DESTINATION_VMDK}\\\"\"\n                                    eval ${VMKFSTOOLS_CMD} -i '\"${SOURCE_VMDK}\"' ${ADAPTER_FORMAT} ${FORMAT_OPTION} '\"${DESTINATION_VMDK}\"' > \"${VMDK_OUTPUT}\" 2>&1\n\n                                    VMDK_EXIT_CODE=$?\n                                    kill \"${TAIL_PID}\"\n                                    cat \"${VMDK_OUTPUT}\" >> \"${REDIRECT}\"\n                                    echo >> \"${REDIRECT}\"\n                                    echo\n                                    rm \"${VMDK_OUTPUT}\"\n\n                                    if [[ \"${VMDK_EXIT_CODE}\" != 0 ]] ; then\n                                        logger \"info\" \"ERROR: error in backing up of \\\"${SOURCE_VMDK}\\\" for ${VM_NAME}\"\n                                        VM_VMDK_FAILED=1\n                                    fi\n                                fi\n                            else\n                                logger \"info\" \"WARNING: A physical RDM \\\"${SOURCE_VMDK}\\\" was found for ${VM_NAME}, which will not be backed up\"\n                                VM_VMDK_FAILED=1\n                            fi\n                        fi\n                    done\n                    IFS=\"${OLD_IFS}\"\n                fi\n\n                #powered on VMs only w/snapshots\n                if [[ ${SNAP_SUCCESS} -eq 1 ]] && [[ ! ${POWER_VM_DOWN_BEFORE_BACKUP} -eq 1 ]] && [[ \"${ORGINAL_VM_POWER_STATE}\" == \"Powered on\" ]] || [[ \"${ORGINAL_VM_POWER_STATE}\" == \"Suspended\" ]]; then\n                    if [[ \"${NEW_VIMCMD_SNAPSHOT}\" == \"yes\" ]] ; then\n                        SNAPSHOT_ID=$(${VMWARE_CMD} vmsvc/snapshot.get ${VM_ID} | grep -E '(Snapshot Name|Snapshot Id)' | grep -A1 ${SNAPSHOT_NAME} | grep \"Snapshot Id\" | awk -F \":\" '{print $2}' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//')\n                        ${VMWARE_CMD} vmsvc/snapshot.remove ${VM_ID} ${SNAPSHOT_ID} > /dev/null 2>&1\n                    else\n                        ${VMWARE_CMD} vmsvc/snapshot.remove ${VM_ID} > /dev/null 2>&1\n                    fi\n\n                    #do not continue until all snapshots have been committed\n                    logger \"info\" \"Removing snapshot from ${VM_NAME} ...\"\n                    while ls \"${VMX_DIR}\" | grep -q \"\\-delta\\.vmdk\"; do\n                        sleep 5\n                    done\n                fi\n\n                if [[ ${POWER_VM_DOWN_BEFORE_BACKUP} -eq 1 ]] && [[ \"${ORGINAL_VM_POWER_STATE}\" == \"Powered on\" ]]; then\n                    #power on vm that was powered off prior to backup\n                    logger \"info\" \"Powering back on ${VM_NAME}\"\n                    ${VMWARE_CMD} vmsvc/power.on ${VM_ID} > /dev/null 2>&1\n                fi\n\n                TMP_IFS=${IFS}\n                IFS=${ORIG_IFS}\n                if [[ ${ENABLE_COMPRESSION} -eq 1 ]] ; then\n                    COMPRESSED_ARCHIVE_FILE=\"${BACKUP_DIR}/${VM_NAME}-${VM_BACKUP_DIR_NAMING_CONVENTION}.gz\"\n\n                    logger \"info\" \"Compressing VM backup \\\"${COMPRESSED_ARCHIVE_FILE}\\\"...\"\n                    ${TAR} -cz -C \"${BACKUP_DIR}\" \"${VM_NAME}-${VM_BACKUP_DIR_NAMING_CONVENTION}\" -f \"${COMPRESSED_ARCHIVE_FILE}\"\n\n                    # verify compression\n                    if [[ $? -eq 0 ]] && [[ -f \"${COMPRESSED_ARCHIVE_FILE}\" ]]; then\n                        logger \"info\" \"Successfully compressed backup for ${VM_NAME}!\\n\"\n                        COMPRESSED_OK=1\n                    else\n                        logger \"info\" \"Error in compressing ${VM_NAME}!\\n\"\n                        COMPRESSED_OK=0\n                    fi\n                    rm -rf \"${VM_BACKUP_DIR}\"\n                    checkVMBackupRotation \"${BACKUP_DIR}\" \"${VM_NAME}\"\n                else\n                    checkVMBackupRotation \"${BACKUP_DIR}\" \"${VM_NAME}\"\n                fi\n                IFS=${TMP_IFS}\n                VMDKS=\"\"\n                INDEP_VMDKS=\"\"\n\n                endTimer\n                if [[ ${SNAP_SUCCESS} -ne 1 ]] ; then\n                    logger \"info\" \"ERROR: Unable to backup ${VM_NAME} due to snapshot creation!\\n\"\n                    [[ ${ENABLE_COMPRESSION} -eq 1 ]] && [[ $COMPRESSED_OK -eq 1 ]] || echo \"ERROR: Unable to backup ${VM_NAME} due to snapshot creation\" >> ${VM_BACKUP_DIR}/STATUS.error\n                    VM_FAILED=1\n                elif [[ ${VM_VMDK_FAILED} -ne 0 ]] ; then\n                    logger \"info\" \"ERROR: Unable to backup ${VM_NAME} due to error in VMDK backup!\\n\"\n                    [[ ${ENABLE_COMPRESSION} -eq 1 ]] && [[ $COMPRESSED_OK -eq 1 ]] || echo \"ERROR: Unable to backup ${VM_NAME} due to error in VMDK backup\" >> ${VM_BACKUP_DIR}/STATUS.error\n                    VMDK_FAILED=1\n                elif [[ ${VM_HAS_INDEPENDENT_DISKS} -eq 1 ]] ; then\n                    logger \"info\" \"WARN: ${VM_NAME} has some Independent VMDKs that can not be backed up!\\n\";\n                    [[ ${ENABLE_COMPRESSION} -eq 1 ]] && [[ $COMPRESSED_OK -eq 1 ]] || echo \"WARN: ${VM_NAME} has some Independent VMDKs that can not be backed up\" > ${VM_BACKUP_DIR}/STATUS.warn\n                    VMDK_FAILED=1\n\n                    #create symlink for the very last backup to support rsync functionality for additinal replication\n                    if [[ \"${RSYNC_LINK}\" -eq 1 ]] ; then\n                        SYMLINK_DST=${VM_BACKUP_DIR}\n                        if [[ ${ENABLE_COMPRESSION} -eq 1 ]]; then\n                            SYMLINK_DST1=\"${RSYNC_LINK_DIR}.gz\"\n                        else\n                            SYMLINK_DST1=\"${RSYNC_LINK_DIR}\"\n                        fi\n                        SYMLINK_SRC=\"${BACKUP_DIR}/${VM_NAME}-symlink\"\n                        logger \"info\" \"Creating symlink \\\"${SYMLINK_SRC}\\\" to \\\"${SYMLINK_DST1}\\\"\"\n                        rm -f \"${SYMLINK_SRC}\"\n                        ln -sfn \"${SYMLINK_DST1}\" \"${SYMLINK_SRC}\"\n                    fi\n\n                    #storage info after backup\n                    storageInfo \"after\"\n                else\n                    logger \"info\" \"Successfully completed backup for ${VM_NAME}!\\n\"\n                    [[ ${ENABLE_COMPRESSION} -eq 1 ]] && [[ $COMPRESSED_OK -eq 1 ]] || echo \"Successfully completed backup\" > ${VM_BACKUP_DIR}/STATUS.ok\n                    VM_OK=1\n\n                    #create symlink for the very last backup to support rsync functionality for additinal replication\n                    if [[ \"${RSYNC_LINK}\" -eq 1 ]] ; then\n                        SYMLINK_DST=${VM_BACKUP_DIR}\n                        if [[ ${ENABLE_COMPRESSION} -eq 1 ]] ; then\n                            SYMLINK_DST1=\"${RSYNC_LINK_DIR}.gz\"\n                        else\n                            SYMLINK_DST1=\"${RSYNC_LINK_DIR}\"\n                        fi\n                        SYMLINK_SRC=\"${BACKUP_DIR}/${VM_NAME}-symlink\"\n                        logger \"info\" \"Creating symlink \\\"${SYMLINK_SRC}\\\" to \\\"${SYMLINK_DST1}\\\"\"\n                        rm -f \"${SYMLINK_SRC}\"\n                        ln -sfn \"${SYMLINK_DST1}\" \"${SYMLINK_SRC}\"\n                    fi\n\n                    if [[ \"${BACKUP_FILES_CHMOD}\" != \"\" ]]\n                    then\n                        chmod -R \"${BACKUP_FILES_CHMOD}\" \"${VM_BACKUP_DIR}\"\n                    fi\n\n                    #storage info after backup\n                    storageInfo \"after\"\n                fi\n            else\n                if [[ ${CONTINUE_TO_BACKUP} -eq 0 ]] ; then\n                    logger \"info\" \"ERROR: Failed to backup ${VM_NAME}!\\n\"\n                    VM_FAILED=1\n                else\n                    logger \"info\" \"ERROR: Failed to lookup ${VM_NAME}!\\n\"\n                    VM_FAILED=1\n                fi\n            fi\n        fi\n\n\t# Added the NFS_IO_HACK check and function call here.  Some NAS devices slow during the write of the files.\n\t# Added the Brute-force delay in case it is needed.\n\tif [[ \"${ENABLE_NFS_IO_HACK}\" -eq 1 ]]; then\n\t\tNfsIoHack\n\t\tsleep \"${NFS_BACKUP_DELAY}\" \n\tfi \n    done\n    # UNTESTED CODE\n    # Why is this outside of the main loop & it looks like checkVMBackupRotation() could be called twice?\n    #if [[ -n ${ADDITIONAL_ROTATION_PATH} ]]; then\n    #    for VM_NAME in $(cat \"${VM_INPUT}\" | grep -v \"#\" | sed '/^$/d' | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//'); do\n    #        BACKUP_DIR=\"${ADDITIONAL_ROTATION_PATH}/${VM_NAME}\"\n    #        # Do indexed rotation if naming convention is set for it\n    #        if [[ ${VM_BACKUP_DIR_NAMING_CONVENTION} = \"0\" ]]; then\n    #            indexedRotate \"${BACKUP_DIR}\" \"${VM_NAME}\"\n    #        else\n    #            checkVMBackupRotation \"${BACKUP_DIR}\" \"${VM_NAME}\"\n    #        fi\n    #    done\n    #fi\n    unset IFS\n\n    if [[ ${#VM_STARTUP_ORDER} -gt 0 ]] && [[ \"${LOG_LEVEL}\" != \"dryrun\" ]]; then\n        logger \"debug\" \"VM Startup Order: ${VM_STARTUP_ORDER}\\n\"\n        IFS=\",\"\n        for VM_NAME in ${VM_STARTUP_ORDER}; do\n            VM_ID=$(grep -E \"\\\"${VM_NAME}\\\"\" ${WORKDIR}/vms_list | awk -F \";\" '{print $1}' | sed 's/\"//g')\n            powerOn \"${VM_NAME}\" \"${VM_ID}\"\n            if [[ ${POWER_ON_EC} -eq 1 ]]; then\n                logger \"info\" \"Unable to detect fully powered on VM ${VM_NAME}\\n\"\n            fi\n        done\n        unset IFS\n    fi\n\n    if [[ ${ENABLE_NON_PERSISTENT_NFS} -eq 1 ]] && [[ ${UNMOUNT_NFS} -eq 1 ]] && [[ \"${LOG_LEVEL}\" != \"dryrun\" ]]; then\n        logger \"debug\" \"Sleeping for 30seconds before unmounting NFS volume\"\n        sleep 30\n        ${VMWARE_CMD} hostsvc/datastore/destroy ${NFS_LOCAL_NAME}\n    fi\n}\n\ngetFinalStatus() {\n    if [[ \"${LOG_TYPE}\" == \"dryrun\" ]]; then\n        FINAL_STATUS=\"###### Final status: OK, only a dryrun. ######\"\n        LOG_STATUS=\"OK\"\n        EXIT=0\n    elif [[ $VM_OK == 1 ]] && [[ $VM_FAILED == 0 ]] && [[ $VMDK_FAILED == 0 ]]; then\n        FINAL_STATUS=\"###### Final status: All VMs backed up OK! ######\"\n        LOG_STATUS=\"OK\"\n        EXIT=0\n    elif [[ $VM_OK == 1 ]] && [[ $VM_FAILED == 0 ]] && [[ $VMDK_FAILED == 1 ]]; then\n        FINAL_STATUS=\"###### Final status: WARNING: All VMs backed up, but some disk(s) failed! ######\"\n        LOG_STATUS=\"WARNING\"\n        EXIT=3\n    elif [[ $VM_OK == 1 ]] && [[ $VM_FAILED == 1 ]] && [[ $VMDK_FAILED == 0 ]]; then\n        FINAL_STATUS=\"###### Final status: ERROR: Only some of the VMs backed up! ######\"\n        LOG_STATUS=\"ERROR\"\n        EXIT=4\n    elif [[ $VM_OK == 1 ]] && [[ $VM_FAILED == 1 ]] && [[ $VMDK_FAILED == 1 ]]; then\n        FINAL_STATUS=\"###### Final status: ERROR: Only some of the VMs backed up, and some disk(s) failed! ######\"\n        LOG_STATUS=\"ERROR\"\n        EXIT=5\n    elif [[ $VM_OK == 0 ]] && [[ $VM_FAILED == 1 ]]; then # $VMDK_FAILED doesn't matter in this case\n        FINAL_STATUS=\"###### Final status: ERROR: All VMs failed! ######\"\n        LOG_STATUS=\"ERROR\"\n        EXIT=6\n    elif [[ $VM_OK == 0 ]] && [[ $VM_FAILED == 0 ]] && [[ $VMDK_FAILED == 0 ]]; then\n        FINAL_STATUS=\"###### Final status: ERROR: No VMs backed up! ######\"\n        LOG_STATUS=\"ERROR\"\n        EXIT=7\n    elif [[ $VM_OK == 0 ]] && [[ $VM_FAILED == 0 ]] && [[ $VMDK_FAILED == 1 ]]; then\n        FINAL_STATUS=\"###### Final status: ERROR: All VMs experienced at least a partial failure! ######\"\n        LOG_STATUS=\"ERROR\"\n        EXIT=8\n    fi\n    logger \"debug\" \"VM_OK:${VM_OK}, VM_FAILED:${VM_FAILED}, VMDK_FAILED:${VMDK_FAILED}\"\n    logger \"info\" \"$FINAL_STATUS\\n\"\n}\n\nbuildHeaders() {\n    EMAIL_ADDRESS=$1\n\n    echo -ne \"HELO $(hostname -s)\\r\\n\" > \"${EMAIL_LOG_HEADER}\"\n    if [[ ! -z \"${EMAIL_USER_NAME}\" ]]; then\n        echo -ne \"EHLO $(hostname -s)\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n        echo -ne \"AUTH LOGIN\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n        echo -ne \"$(echo -n \"${EMAIL_USER_NAME}\" |openssl enc -A -base64 2>&1 |tail -1)\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n        echo -ne \"$(echo -n \"${EMAIL_USER_PASSWORD}\" |openssl enc -A -base64 2>&1 |tail -1)\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    fi\n    echo -ne \"MAIL FROM: <${EMAIL_FROM}>\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"RCPT TO: <${EMAIL_ADDRESS}>\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"DATA\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"From: ${EMAIL_FROM}\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"To: ${EMAIL_ADDRESS}\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"Subject: ghettoVCB - $(hostname -s) ${JOBNAME} ${FINAL_STATUS}\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"Date: $( date +\"%a, %d %b %Y %T %z\" )\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"Message-Id: <$( date -u +%Y%m%d%H%M%S ).$( dd if=/dev/urandom bs=6 count=1 2>/dev/null | hexdump -e '/1 \"%02X\"' )@$( hostname -f )>\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -ne \"XMailer: ghettoVCB ${VERSION_STRING}\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n    echo -en \"\\r\\n\" >> \"${EMAIL_LOG_HEADER}\"\n\n    echo -en \".\\r\\n\" >> \"${EMAIL_LOG_OUTPUT}\"\n    echo -en \"QUIT\\r\\n\" >> \"${EMAIL_LOG_OUTPUT}\"\n\n    cat \"${EMAIL_LOG_HEADER}\" > \"${EMAIL_LOG_CONTENT}\"\n    cat \"${EMAIL_LOG_OUTPUT}\" >> \"${EMAIL_LOG_CONTENT}\"\n}\n\nsendDelay() {\n    c=0\n    while read L; do\n    \t[ $c -lt 4 ] && sleep ${EMAIL_DELAY_INTERVAL}\n    \tc=$((c+1))\n    \techo $L\n    done\n}\n\nsendMail() {\n    SMTP=0\n    #close email message\n    if [[ \"${EMAIL_LOG}\" -eq 1 ]] || [[ \"${EMAIL_ALERT}\" -eq 1 ]] ; then\n        SMTP=1\n        #validate firewall has email port open for ESXi 5\n        if [[ \"${VER}\" == \"5\" ]] || [[ \"${VER}\" == \"6\" ]] || [[ \"${VER}\" == \"7\" ]]; then\n            /sbin/esxcli network firewall ruleset rule list | awk -F'[ ]{2,}' '{print $5}' | grep \"^${EMAIL_SERVER_PORT}$\" > /dev/null 2>&1\n            if [[ $? -eq 1 ]] ; then\n                logger \"info\" \"ERROR: Please enable firewall rule for email traffic on port ${EMAIL_SERVER_PORT}\\n\"\n                logger \"info\" \"Please refer to ghettoVCB documentation for ESXi 5 firewall configuration\\n\"\n                SMTP=0\n            fi\n        fi\n    fi\n\n    if [[ \"${SMTP}\" -eq 1 ]] ; then\n        if [ \"${EXIT}\" -ne 0 ] && [ \"${LOG_STATUS}\" = \"OK\" ] ; then\n            LOG_STATUS=\"ERROR\"\n        #    for i in ${EMAIL_TO}; do\n        #        buildHeaders ${i}\n        #        cat \"${EMAIL_LOG_CONTENT}\" | sendDelay| \"${NC_BIN}\" \"${EMAIL_SERVER}\" \"${EMAIL_SERVER_PORT}\" > /dev/null 2>&1\n        #        #\"${NC_BIN}\" -i \"${EMAIL_DELAY_INTERVAL}\" \"${EMAIL_SERVER}\" \"${EMAIL_SERVER_PORT}\" < \"${EMAIL_LOG_CONTENT}\" > /dev/null 2>&1\n        #        if [[ $? -eq 1 ]] ; then\n        #            logger \"info\" \"ERROR: Failed to email log output to ${EMAIL_SERVER}:${EMAIL_SERVER_PORT} to ${EMAIL_TO}\\n\"\n        #        fi\n        #    done\n        fi\n\n\n        if [ \"${EMAIL_ERRORS_TO}\" != \"\" ] && [ \"${LOG_STATUS}\" != \"OK\" ] ; then\n            if [ \"${EMAIL_TO}\" == \"\" ] ; then\n                EMAIL_TO=\"${EMAIL_ERRORS_TO}\"\n            else\n                EMAIL_TO=\"${EMAIL_TO},${EMAIL_ERRORS_TO}\"\n            fi\n        fi\n\n        echo \"${EMAIL_TO}\" | grep \",\" > /dev/null 2>&1\n        if [[ $? -eq 0 ]] ; then\n            ORIG_IFS=${IFS}\n            IFS=','\n            for i in ${EMAIL_TO}; do\n                buildHeaders ${i}\n                cat \"${EMAIL_LOG_CONTENT}\" | sendDelay| \"${NC_BIN}\" \"${EMAIL_SERVER}\" \"${EMAIL_SERVER_PORT}\" > /dev/null 2>&1\n                #\"${NC_BIN}\" -i \"${EMAIL_DELAY_INTERVAL}\" \"${EMAIL_SERVER}\" \"${EMAIL_SERVER_PORT}\" < \"${EMAIL_LOG_CONTENT}\" > /dev/null 2>&1\n                if [[ $? -eq 1 ]] ; then\n                    logger \"info\" \"ERROR: Failed to email log output to ${EMAIL_SERVER}:${EMAIL_SERVER_PORT} to ${EMAIL_TO}\\n\"\n                fi\n            done\n            unset IFS\n        else\n            buildHeaders ${EMAIL_TO}\n            cat \"${EMAIL_LOG_CONTENT}\" | sendDelay| \"${NC_BIN}\" \"${EMAIL_SERVER}\" \"${EMAIL_SERVER_PORT}\" > /dev/null 2>&1\n            #\"${NC_BIN}\" -i \"${EMAIL_DELAY_INTERVAL}\" \"${EMAIL_SERVER}\" \"${EMAIL_SERVER_PORT}\" < \"${EMAIL_LOG_CONTENT}\" > /dev/null 2>&1\n            if [[ $? -eq 1 ]] ; then\n                logger \"info\" \"ERROR: Failed to email log output to ${EMAIL_SERVER}:${EMAIL_SERVER_PORT} to ${EMAIL_TO}\\n\"\n            fi\n        fi\n    fi\n}\n\n#########################\n#                       #\n# Start of Main Script  #\n#                       #\n#########################\n\n# If the NFS_IO_HACK is disabled, this restores the original script settings.\nif [[ \"${ENABLE_NFS_IO_HACK}\" -eq 0 ]]; then\n    NFS_IO_HACK_LOOP_MAX=60\n    NFS_IO_HACK_SLEEP_TIMER=1\nfi\n\nUSE_VM_CONF=0\nUSE_GLOBAL_CONF=0\nBACKUP_ALL_VMS=0\nEXCLUDE_SOME_VMS=0\n\n# quick sanity check on the number of arguments\nif [[ $# -lt 1 ]] || [[ $# -gt 12 ]]; then\n    printUsage\n    LOG_TO_STDOUT=1 logger \"info\" \"ERROR: Incorrect number of arguments!\"\n    exit 1\nfi\n\n#Quick sanity check for the VM_BACKUP_ROTATION_COUNT configuration setting.\nif [[ \"$VM_BACKUP_ROTATION_COUNT\" -lt 1 ]]; then\n\tVM_BACKUP_ROTATION_COUNT=1\nfi\n\n#Sanity check for full qualified email and adjust EMAIL_FROM to be hostname@domain.com if username is missing.\nif [[ \"${EMAIL_FROM%%@*}\" == \"\" ]] ; then\n    EMAIL_FROM=\"`hostname -s`$EMAIL_FROM\"\nfi\n\n#read user input\nwhile getopts \":af:c:g:w:m:l:d:e:j:\" ARGS; do\n    case $ARGS in\n        w)\n            WORKDIR=\"${OPTARG}\"\n            ;;\n        a)\n            BACKUP_ALL_VMS=1\n            VM_FILE='${WORKDIR}/vm-input-list'\n            ;;\n        f)\n            VM_FILE=\"${OPTARG}\"\n            ;;\n        j)\n            JOBNAME=\"${OPTARG}\"\n            ;;\n        m)\n            VM_FILE='${WORKDIR}/vm-input-list'\n            VM_ARG=\"${OPTARG}\"\n            ;;\n        e)\n            VM_EXCLUSION_FILE=\"${OPTARG}\"\n            EXCLUDE_SOME_VMS=1\n            ;;\n        c)\n            CONFIG_DIR=\"${OPTARG}\"\n            USE_VM_CONF=1\n            ;;\n        g)\n            GLOBAL_CONF=\"${OPTARG}\"\n            USE_GLOBAL_CONF=1\n            ;;\n        l)\n            LOG_OUTPUT=\"${OPTARG}\"\n            ;;\n        d)\n            LOG_LEVEL=\"${OPTARG}\"\n            ;;\n        :)\n            echo \"Option -${OPTARG} requires an argument.\"\n            exit 1\n            ;;\n        *)\n            printUsage\n            ;;\n    esac\ndone\n\nWORKDIR=${WORKDIR:-\"/tmp/ghettoVCB.work\"}\n\nEMAIL_LOG_HEADER=${WORKDIR}/ghettoVCB-email-$$.header\nEMAIL_LOG_OUTPUT=${WORKDIR}/ghettoVCB-email-$$.log\nEMAIL_LOG_CONTENT=${WORKDIR}/ghettoVCB-email-$$.content\n\n#expand VM_FILE\n[[ -n \"${VM_FILE}\" ]] && VM_FILE=$(eval \"echo $VM_FILE\")\n\n# refuse to run with an unsafe workdir\nif [[ \"${WORKDIR}\" == \"/\" ]]; then\n    echo \"ERROR: Refusing to run with unsafe workdir ${WORKDIR}\"\n    exit 1\nfi\n\nif mkdir \"${WORKDIR}\"; then\n    # create VM_FILE if we're backing up everything/specified a vm on the command line\n    [[ $BACKUP_ALL_VMS -eq 1 ]] && touch ${VM_FILE}\n    [[ -n \"${VM_ARG}\" ]] && echo \"${VM_ARG}\" > \"${VM_FILE}\"\n\n    if [[ \"${WORKDIR_DEBUG}\" -eq 1 ]] ; then\n        LOG_TO_STDOUT=1 logger \"info\" \"Workdir: ${WORKDIR} will not! be removed on exit\"\n    else\n        # remove workdir when script finishes\n        trap 'rm -rf \"${WORKDIR}\"' 0\n    fi\n\n    # verify that we're running in a sane environment\n    sanityCheck\n\n    GHETTOVCB_PID=$$\n    echo $GHETTOVCB_PID > \"${WORKDIR}/pid\"\n\n    logger \"info\" \"============================== ghettoVCB LOG START ==============================\\n\"\n    logger \"debug\" \"Succesfully acquired lock directory - ${WORKDIR}\\n\"\n\n    # terminate script and remove workdir when a signal is received\n    trap 'rm -rf \"${WORKDIR}\" ; exit 2' 1 2 3 13 15\n\n    ghettoVCB ${VM_FILE}\n\n    Get_Final_Status_Sendemail\n\n    # practically redundant\n    [[ \"${WORKDIR_DEBUG}\" -eq 0 ]] && rm -rf \"${WORKDIR}\"\n    exit $EXIT\nelse\n    logger \"info\" \"Failed to acquire lock, another instance of script may be running, giving up on ${WORKDIR}\\n\"\n\tGet_Final_Status_Sendemail\n    exit 1\nfi\n"
        }
      ]
    }
  ]
}