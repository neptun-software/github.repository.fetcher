{
  "metadata": {
    "timestamp": 1736568186289,
    "page": 15,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "masonr/yet-another-bench-script",
      "stars": 4641,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.4814453125,
          "content": "            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\r\n                    Version 2, December 2004\r\n\r\n Copyright (C) 2019 Mason Rowe <mason@rowe.sh>\r\n\r\n Everyone is permitted to copy and distribute verbatim or modified\r\n copies of this license document, and changing it is allowed as long\r\n as the name is changed.\r\n\r\n            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\r\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\r\n\r\n  0. You just DO WHAT THE FUCK YOU WANT TO.\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.58203125,
          "content": "# Yet-Another-Bench-Script\n\nPresenting an attempt to create _yet another_ Linux server *bench*marking _script_...\n\n![](https://user-images.githubusercontent.com/8313125/106475387-e1f6da00-6473-11eb-918c-c785ebeef8b9.jpg)\nLogo design by [Dian Pratama](https://github.com/dianp)\n\nThis script automates the execution of the best benchmarking tools in the industry. Included are several tests to check the performance of critical areas of a server: disk performance with [fio](https://github.com/axboe/fio), network performance with [iperf3](https://github.com/esnet/iperf), and CPU/memory performance with [Geekbench](https://www.geekbench.com/). The script is designed to not require any external dependencies to be installed nor elevated privileges to run. If there are any features that you would like to see added, feel free to submit an issue describing your feature request or fork the project and submit a PR!\n\n### **What's New With YABS?**\n* [27 Feb 2023](https://github.com/masonr/yet-another-bench-script/commit/06eaa2ab3b32355bec8278c51c4be93b3662a96d) - Newly released [Geekbench 6](https://www.geekbench.com/) is added as the default Geekbench test.\n* [26 Feb 2023](https://github.com/masonr/yet-another-bench-script/commit/f075baf59c3057983fff0a30ea0c746b5ea88d91) - Network information added to YABS output using [ip-api](https://ip-api.com/).\n* [15 Aug 2022](https://github.com/masonr/yet-another-bench-script/commit/ae24e70fbf7a4848e81a70cf829ec44e060e63d5) - Added JSON output/upload support to export or auto-upload of YABS results for sharing.\n\n## How to Run\n\n```\ncurl -sL https://yabs.sh | bash\n```\n\nor \n\n```\nwget -qO- yabs.sh | bash\n```\n\n**Local fio/iperf3 Packages**: If the tested system has fio and/or iperf3 already installed, the local package will take precedence over the precompiled binary.\n\n**Experimental ARM Compatibility**: Initial ARM compatibility has been introduced, however, is not considered entirely stable due to limited testing on distinct ARM devices. Report any errors or issues.\n\n**High Bandwidth Usage Notice**: By default, this script will perform many iperf network tests, which will try to max out the network port for ~20s per location (10s in each direction). Low-bandwidth servers (such as a NAT VPS) should consider running this script with the `-r` flag (for reduced iperf locations) or the `-i` flag (to disable network tests entirely).\n\n**Windows Users**: This script can be run on Windows systems by using [Windows Subsystem for Linux v2 (WSL 2)](https://learn.microsoft.com/en-us/windows/wsl/about). WSLv1 will not run the script and binaries correctly.\n\n### Flags (Skipping Tests, Reducing iperf Locations, Geekbench 4/5/6, etc.)\n\n```\ncurl -sL https://yabs.sh | bash -s -- -flags\n```\n\n| Flag | Description |\n| ---- | ----------- |\n| -b | Forces use of pre-compiled binaries from repo over local packages |\n| -f/-d | Disables the fio (disk performance) test |\n| -i | Disables the iperf (network performance) test |\n| -g | Disables the Geekbench (system performance) test |\n| -n | Skips the network information lookup and print out |\n| -h | Prints the help message with usage, flags detected, and local package (fio/iperf) status |\n| -r | Reduces the number of iperf locations (Scaleway/Clouvider LON+NYC) to lessen bandwidth usage |\n| -4 | Runs a Geekbench 4 test and disables the Geekbench 6 test |\n| -5 | Runs a Geekbench 5 test and disables the Geekbench 6 test |\n| -9 | Runs both the Geekbench 4 and 5 tests instead of the Geekbench 6 test |\n| -6 | Re-enables the Geekbench 6 test if any of the following were used: -4, -5, or -9 (-6 flag must be last to not be overridden) |\n| -j | Prints a JSON representation of the results to the screen |\n| -w \\<filename\\> | Writes the JSON results to a file using the file name provided |\n| -s \\<url\\> | Sends a JSON representation of the results to the designated URL(s) (see section below) |\n\nOptions can be grouped together to skip multiple tests, i.e. `-fg` to skip the disk and system performance tests (effectively only testing network performance).\n\n**Geekbench License Key**: A Geekbench license key can be utilized during the Geekbench test to unlock all features. Simply put the email and key for the license in a file called _geekbench.license_. `echo \"email@domain.com ABCDE-12345-FGHIJ-57890\" > geekbench.license`\n\n### Submitting JSON Results\n\nResults from running this script can be sent to your benchmark results website of choice in JSON format. Invoke the `-s` flag and pass the URL to where the results should be submitted to:\n\n```\ncurl -sL https://yabs.sh | bash -s -- -s \"https://example.com/yabs/post\"\n```\n\nJSON results can be sent to multiple endpoints by entering each site joined by a comma (e.g. \"https://example.com/yabs/post,http://example.com/yabs2/post\").\n\nSites supporting submission of YABS JSON results:\n\n| Website | Example Command |\n| --- | --- |\n| [YABSdb](https://yabsdb.com/) | `curl -sL https://yabs.sh \\| bash -s -- -s \"https://yabsdb.com/add\"` |\n| [VPSBenchmarks](https://www.vpsbenchmarks.com/yabs/get_started) | `curl -sL https://yabs.sh \\| bash -s -- -s https://www.vpsbenchmarks.com/yabs/upload` |\n\nExample JSON output: [example.json](bin/example.json).\n\n## Tests Conducted\n\n* **[fio](https://github.com/axboe/fio)** - the most comprehensive I/O testing software available, fio grants the ability to evaluate disk performance in a variety of methods with a variety of options. Four random read and write fio disk tests are conducted as part of this script with 4k, 64k, 512k, and 1m block sizes. The tests are designed to evaluate disk throughput in near-real world (using random) scenarios with a 50/50 split (50% reads and 50% writes per test).\n* **[iperf3](https://github.com/esnet/iperf)** - the industry standard for testing download and upload speeds to various locations. This script utilizes iperf3 with 8 parallel threads and tests both download and upload speeds. If an iperf server is busy after 5 tries, the speed test for that location/direction is skipped.\n* **[Geekbench](https://www.geekbench.com/)** - Geekbench is a benchmarking program that measures system performance, which is widely used in the tech community. The web URL is displayed to be able to see complete test and individual benchmark results and allow comparison to other geekbench'd systems. The claim URL to add the Geekbench result to your Geekbench profile is written to a file in the directory that this script is executed from. By default, Geekbench 6 is the only Geekbench test performed, however, Geekbench 4 and/or 5 can also be toggled on by passing the appropriate flag.\n\n### Security Notice\n\nThis script relies on external binaries in order to complete the performance tests. The network (iperf3) and disk (fio) tests use binaries that are compiled by myself utilizing a [Holy Build Box](https://github.com/phusion/holy-build-box) compilation environment to ensure binary portability. The reasons for doing this include ensuring standardized (parsable) output, allowing support of both 32-bit and 64-bit architectures, bypassing the need for prerequisites to be compiled and/or installed, among other reasons. For the system test, a Geekbench tarball is downloaded, extracted, and the resulting binary is run. Use this script at your own risk as you would with any script publicly available on the net. Additional information regarding the binaries, including compilation notes and steps, can be found in the bin directory's [README page](bin/README.md).\n\n## Example Output\n\n```\n# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## #\n#              Yet-Another-Bench-Script              #\n#                     v2023-04-23                    #\n# https://github.com/masonr/yet-another-bench-script #\n# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## #\n\nSun 23 Apr 2023 01:41:14 PM EDT\n\nBasic System Information:\n---------------------------------\nUptime     : 342 days, 18 hours, 35 minutes\nProcessor  : Intel(R) Xeon(R) E-2276G CPU @ 3.80GHz\nCPU cores  : 12 @ 4693.667 MHz\nAES-NI     : ✔ Enabled\nVM-x/AMD-V : ✔ Enabled\nRAM        : 15.5 GiB\nSwap       : 14.9 GiB\nDisk       : 864.5 GiB\nDistro     : Ubuntu 20.04.6 LTS\nKernel     : 5.4.0-110-generic\nVM Type    : NONE\nIPv4/IPv6  : ✔ Online / ✔ Online\n\nIPv6 Network Information:\n---------------------------------\nISP        : Clouvider Limited\nASN        : AS62240 Clouvider\nHost       : USA Network\nLocation   : New York, New York (NY)\nCountry    : United States\n\nfio Disk Speed Tests (Mixed R/W 50/50):\n---------------------------------\nBlock Size | 4k            (IOPS) | 64k           (IOPS)\n  ------   | ---            ----  | ----           ----\nRead       | 405.41 MB/s (101.3k) | 407.96 MB/s   (6.3k)\nWrite      | 406.48 MB/s (101.6k) | 410.11 MB/s   (6.4k)\nTotal      | 811.90 MB/s (202.9k) | 818.08 MB/s  (12.7k)\n           |                      |\nBlock Size | 512k          (IOPS) | 1m            (IOPS)\n  ------   | ---            ----  | ----           ----\nRead       | 380.21 MB/s    (742) | 394.55 MB/s    (385)\nWrite      | 400.41 MB/s    (782) | 420.82 MB/s    (410)\nTotal      | 780.62 MB/s   (1.5k) | 815.37 MB/s    (795)\n\niperf3 Network Speed Tests (IPv4):\n---------------------------------\nProvider        | Location (Link)           | Send Speed      | Recv Speed      | Ping\n-----           | -----                     | ----            | ----            | ----\nClouvider       | London, UK (10G)          | 1.61 Gbits/sec  | 2.39 Gbits/sec  | 77.5 ms\nScaleway        | Paris, FR (10G)           | busy            | 2.25 Gbits/sec  | 83.3 ms\nClouvider       | NYC, NY, US (10G)         | 9.10 Gbits/sec  | 8.85 Gbits/sec  | 1.21 ms\n\niperf3 Network Speed Tests (IPv6):\n---------------------------------\nProvider        | Location (Link)           | Send Speed      | Recv Speed      | Ping\n-----           | -----                     | ----            | ----            | ----\nClouvider       | London, UK (10G)          | 2.00 Gbits/sec  | 21.1 Mbits/sec  | 76.7 ms\nScaleway        | Paris, FR (10G)           | 2.66 Gbits/sec  | 1.56 Gbits/sec  | 75.9 ms\nClouvider       | NYC, NY, US (10G)         | 3.42 Gbits/sec  | 7.80 Gbits/sec  | 1.15 ms\n\nGeekbench 4 Benchmark Test:\n---------------------------------\nTest            | Value\n                |\nSingle Core     | 5949\nMulti Core      | 23425\nFull Test       | https://browser.geekbench.com/v4/cpu/16746501\n\nGeekbench 5 Benchmark Test:\n---------------------------------\nTest            | Value\n                |\nSingle Core     | 1317\nMulti Core      | 5529\nFull Test       | https://browser.geekbench.com/v5/cpu/21102444\n\nGeekbench 6 Benchmark Test:\n---------------------------------\nTest            | Value\n                |\nSingle Core     | 1549\nMulti Core      | 5278\nFull Test       | https://browser.geekbench.com/v6/cpu/1021916\n\nYABS completed in 12 min 49 sec\n\n```\n\n## Acknowledgements\n\nThis script was inspired by several great benchmarking scripts out there, including, but not limited to, [bench.sh](https://bench.sh/), [nench.sh](https://github.com/n-st/nench), [ServerBench](https://github.com/K4Y5/ServerBench), among others. Members of the [HostBalls](https://hostballs.com), [LowEndSpirit](https://lowendspirit.com), and [LowEndTalk](https://lowendtalk.com) hosting-related communities play a pivotal role in testing, evaluating, and shaping this script as it matures.\n\n## License\n```\n            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n                    Version 2, December 2004\n\n Copyright (C) 2019 Mason Rowe <mason@rowe.sh>\n\n Everyone is permitted to copy and distribute verbatim or modified\n copies of this license document, and changing it is allowed as long\n as the name is changed.\n\n            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. You just DO WHAT THE FUCK YOU WANT TO.\n```\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "yabs.sh",
          "type": "blob",
          "size": 44.2646484375,
          "content": "#!/bin/bash\n\n# Yet Another Bench Script by Mason Rowe\n# Initial Oct 2019; Last update Jan 2025\n\n# Disclaimer: This project is a work in progress. Any errors or suggestions should be\n#             relayed to me via the GitHub project page linked below.\n#\n# Purpose:    The purpose of this script is to quickly gauge the performance of a Linux-\n#             based server by benchmarking network performance via iperf3, CPU and\n#             overall system performance via Geekbench 4/5, and random disk\n#             performance via fio. The script is designed to not require any dependencies\n#             - either compiled or installed - nor admin privileges to run.\n\nYABS_VERSION=\"v2025-01-01\"\n\necho -e '# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## #'\necho -e '#              Yet-Another-Bench-Script              #'\necho -e '#                     '$YABS_VERSION'                    #'\necho -e '# https://github.com/masonr/yet-another-bench-script #'\necho -e '# ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## #'\n\necho -e\ndate\nTIME_START=$(date '+%Y%m%d-%H%M%S')\nYABS_START_TIME=$(date +%s)\n\n# override locale to eliminate parsing errors (i.e. using commas as delimiters rather than periods)\nif locale -a 2>/dev/null | grep ^C$ > /dev/null; then\n\t# locale \"C\" installed\n\texport LC_ALL=C\nelse\n\t# locale \"C\" not installed, display warning\n\techo -e \"\\nWarning: locale 'C' not detected. Test outputs may not be parsed correctly.\"\nfi\n\n# determine architecture of host\nARCH=$(uname -m)\nif [[ $ARCH = *x86_64* ]]; then\n\t# host is running a 64-bit kernel\n\tARCH=\"x64\"\nelif [[ $ARCH = *i?86* ]]; then\n\t# host is running a 32-bit kernel\n\tARCH=\"x86\"\nelif [[ $ARCH = *aarch* || $ARCH = *arm* ]]; then\n\tKERNEL_BIT=$(getconf LONG_BIT)\n\tif [[ $KERNEL_BIT = *64* ]]; then\n\t\t# host is running an ARM 64-bit kernel\n\t\tARCH=\"aarch64\"\n\telse\n\t\t# host is running an ARM 32-bit kernel\n\t\tARCH=\"arm\"\n\tfi\n\techo -e \"\\nARM compatibility is considered *experimental*\"\nelse\n\t# host is running a non-supported kernel\n\techo -e \"Architecture not supported by YABS.\"\n\texit 1\nfi\n\n# flags to skip certain performance tests\nunset PREFER_BIN SKIP_FIO SKIP_IPERF SKIP_GEEKBENCH SKIP_NET PRINT_HELP REDUCE_NET GEEKBENCH_4 GEEKBENCH_5 GEEKBENCH_6 DD_FALLBACK IPERF_DL_FAIL JSON JSON_SEND JSON_RESULT JSON_FILE\nGEEKBENCH_6=\"True\" # gb6 test enabled by default\n\n# get any arguments that were passed to the script and set the associated skip flags (if applicable)\nwhile getopts 'bfdignhr4596jw:s:' flag; do\n\tcase \"${flag}\" in\n\t\tb) PREFER_BIN=\"True\" ;;\n\t\tf) SKIP_FIO=\"True\" ;;\n\t\td) SKIP_FIO=\"True\" ;;\n\t\ti) SKIP_IPERF=\"True\" ;;\n\t\tg) SKIP_GEEKBENCH=\"True\" ;;\n\t\tn) SKIP_NET=\"True\" ;;\n\t\th) PRINT_HELP=\"True\" ;;\n\t\tr) REDUCE_NET=\"True\" ;;\n\t\t4) GEEKBENCH_4=\"True\" && unset GEEKBENCH_6 ;;\n\t\t5) GEEKBENCH_5=\"True\" && unset GEEKBENCH_6 ;;\n\t\t9) GEEKBENCH_4=\"True\" && GEEKBENCH_5=\"True\" && unset GEEKBENCH_6 ;;\n\t\t6) GEEKBENCH_6=\"True\" ;;\n\t\tj) JSON+=\"j\" ;; \n\t\tw) JSON+=\"w\" && JSON_FILE=${OPTARG} ;;\n\t\ts) JSON+=\"s\" && JSON_SEND=${OPTARG} ;; \n\t\t*) exit 1 ;;\n\tesac\ndone\n\n# check for local fio/iperf installs\nif command -v fio >/dev/null 2>&1; then\n    LOCAL_FIO=true\nelse\n    unset LOCAL_FIO\nfi\n\nif command -v iperf3 >/dev/null 2>&1; then\n    LOCAL_IPERF=true\nelse\n    unset LOCAL_IPERF\nfi\n\n# check for ping\nif command -v ping >/dev/null 2>&1; then\n    LOCAL_PING=true\nelse\n    unset LOCAL_PING\nfi\n\n# check for curl/wget\nif command -v curl >/dev/null 2>&1; then\n    LOCAL_CURL=true\nelse\n    unset LOCAL_CURL\nfi\n\n\n# test if the host has IPv4/IPv6 connectivity\n[[ -n $LOCAL_CURL ]] && IP_CHECK_CMD=\"curl -s -m 4\" || IP_CHECK_CMD=\"wget -qO- -T 4\"\nIPV4_CHECK=$( (ping -4 -c 1 -W 4 ipv4.google.com >/dev/null 2>&1 && echo true) || $IP_CHECK_CMD -4 icanhazip.com 2> /dev/null)\nIPV6_CHECK=$( (ping -6 -c 1 -W 4 ipv6.google.com >/dev/null 2>&1 && echo true) || $IP_CHECK_CMD -6 icanhazip.com 2> /dev/null)\nif [[ -z \"$IPV4_CHECK\" && -z \"$IPV6_CHECK\" ]]; then\n\techo -e\n\techo -e \"Warning: Both IPv4 AND IPv6 connectivity were not detected. Check for DNS issues...\"\nfi\n\n# print help and exit script, if help flag was passed\nif [ -n \"$PRINT_HELP\" ]; then\n\techo -e\n\techo -e \"Usage: ./yabs.sh [-flags]\"\n\techo -e \"       curl -sL yabs.sh | bash\"\n\techo -e \"       curl -sL yabs.sh | bash -s -- -flags\"\n\techo -e \"       wget -qO- yabs.sh | bash\"\n\techo -e \"       wget -qO- yabs.sh | bash -s -- -flags\"\n\techo -e\n\techo -e \"Flags:\"\n\techo -e \"       -b : prefer pre-compiled binaries from repo over local packages\"\n\techo -e \"       -f/d : skips the fio disk benchmark test\"\n\techo -e \"       -i : skips the iperf network test\"\n\techo -e \"       -g : skips the geekbench performance test\"\n\techo -e \"       -n : skips the network information lookup and print out\"\n\techo -e \"       -h : prints this lovely message, shows any flags you passed,\"\n\techo -e \"            shows if fio/iperf3 local packages have been detected,\"\n\techo -e \"            then exits\"\n\techo -e \"       -r : reduce number of iperf3 network locations (to only three)\"\n\techo -e \"            to lessen bandwidth usage\"\n\techo -e \"       -4 : use geekbench 4 instead of geekbench 6\"\n\techo -e \"       -5 : use geekbench 5 instead of geekbench 6\"\n\techo -e \"       -9 : use both geekbench 4 AND geekbench 5 instead of geekbench 6\"\n\techo -e \"       -6 : use geekbench 6 in addition to 4 and/or 5 (only needed if -4, -5, or -9 are set; -6 must come last)\"\n\techo -e \"       -j : print jsonified YABS results at conclusion of test\"\n\techo -e \"       -w <filename> : write jsonified YABS results to disk using file name provided\"\n\techo -e \"       -s <url> : send jsonified YABS results to URL\"\n\techo -e\n\techo -e \"Detected Arch: $ARCH\"\n\techo -e\n\techo -e \"Detected Flags:\"\n\t[[ -n $PREFER_BIN ]] && echo -e \"       -b, force using precompiled binaries from repo\"\n\t[[ -n $SKIP_FIO ]] && echo -e \"       -f/d, skipping fio disk benchmark test\"\n\t[[ -n $SKIP_IPERF ]] && echo -e \"       -i, skipping iperf network test\"\n\t[[ -n $SKIP_GEEKBENCH ]] && echo -e \"       -g, skipping geekbench test\"\n\t[[ -n $SKIP_NET ]] && echo -e \"       -n, skipping network info lookup and print out\"\n\t[[ -n $REDUCE_NET ]] && echo -e \"       -r, using reduced (3) iperf3 locations\"\n\t[[ -n $GEEKBENCH_4 ]] && echo -e \"       running geekbench 4\"\n\t[[ -n $GEEKBENCH_5 ]] && echo -e \"       running geekbench 5\"\n\t[[ -n $GEEKBENCH_6 ]] && echo -e \"       running geekbench 6\"\n\techo -e\n\techo -e \"Local Binary Check:\"\n\t[[ -z $LOCAL_FIO ]] && echo -e \"       fio not detected, will download precompiled binary\" ||\n\t\t[[ -z $PREFER_BIN ]] && echo -e \"       fio detected, using local package\" ||\n\t\techo -e \"       fio detected, but using precompiled binary instead\"\n\t[[ -z $LOCAL_IPERF ]] && echo -e \"       iperf3 not detected, will download precompiled binary\" ||\n\t\t[[ -z $PREFER_BIN ]] && echo -e \"       iperf3 detected, using local package\" ||\n\t\techo -e \"       iperf3 detected, but using precompiled binary instead\"\n\techo -e\n\techo -e \"Detected Connectivity:\"\n\t[[ -n $IPV4_CHECK ]] && echo -e \"       IPv4 connected\" ||\n\t\techo -e \"       IPv4 not connected\"\n\t[[ -n $IPV6_CHECK ]] && echo -e \"       IPv6 connected\" ||\n\t\techo -e \"       IPv6 not connected\"\n\techo -e\n\techo -e \"JSON Options:\"\n\t[[ -z $JSON ]] && echo -e \"       none\"\n\t[[ $JSON = *j* ]] && echo -e \"       printing json to screen after test\"\n\t[[ $JSON = *w* ]] && echo -e \"       writing json to file ($JSON_FILE) after test\"\n\t[[ $JSON = *s* ]] && echo -e \"       sharing json YABS results to $JSON_SEND\" \n\techo -e\n\techo -e \"Exiting...\"\n\n\texit 0\nfi\n\n# format_size\n# Purpose: Formats raw disk and memory sizes from kibibytes (KiB) to largest unit\n# Parameters:\n#          1. RAW - the raw memory size (RAM/Swap) in kibibytes\n# Returns:\n#          Formatted memory size in KiB, MiB, GiB, or TiB\nfunction format_size {\n\tRAW=$1 # mem size in KiB\n\tRESULT=$RAW\n\tlocal DENOM=1\n\tlocal UNIT=\"KiB\"\n\n\t# ensure the raw value is a number, otherwise return blank\n\tre='^[0-9]+$'\n\tif ! [[ $RAW =~ $re ]] ; then\n\t\techo \"\" \n\t\treturn 0\n\tfi\n\n\tif [ \"$RAW\" -ge 1073741824 ]; then\n\t\tDENOM=1073741824\n\t\tUNIT=\"TiB\"\n\telif [ \"$RAW\" -ge 1048576 ]; then\n\t\tDENOM=1048576\n\t\tUNIT=\"GiB\"\n\telif [ \"$RAW\" -ge 1024 ]; then\n\t\tDENOM=1024\n\t\tUNIT=\"MiB\"\n\tfi\n\n\t# divide the raw result to get the corresponding formatted result (based on determined unit)\n\tRESULT=$(awk -v a=\"$RESULT\" -v b=\"$DENOM\" 'BEGIN { print a / b }')\n\t# shorten the formatted result to two decimal places (i.e. x.x)\n\tRESULT=$(echo \"$RESULT\" | awk -F. '{ printf \"%0.1f\",$1\".\"substr($2,1,2) }')\n\t# concat formatted result value with units and return result\n\tRESULT=\"$RESULT $UNIT\"\n\techo \"$RESULT\"\n}\n\n# gather basic system information (inc. CPU, AES-NI/virt status, RAM + swap + disk size)\necho -e \necho -e \"Basic System Information:\"\necho -e \"---------------------------------\"\nUPTIME=$(uptime | awk -F'( |,|:)+' '{d=h=m=0; if ($7==\"min\") m=$6; else {if ($7~/^day/) {d=$6;h=$8;m=$9} else {h=$6;m=$7}}} {print d+0,\"days,\",h+0,\"hours,\",m+0,\"minutes\"}')\necho -e \"Uptime     : $UPTIME\"\n# check for local lscpu installs\nif command -v lscpu >/dev/null 2>&1; then\n  LOCAL_LSCPU=true\nelse\n  unset LOCAL_LSCPU\nfi\nif [[ $ARCH = *aarch64* || $ARCH = *arm* ]] && [[ -n $LOCAL_LSCPU ]]; then\n\tCPU_PROC=$(lscpu | grep \"Model name\" | sed 's/Model name: *//g')\nelse\n\tCPU_PROC=$(awk -F: '/model name/ {name=$2} END {print name}' /proc/cpuinfo | sed 's/^[ \\t]*//;s/[ \\t]*$//')\nfi\necho -e \"Processor  : $CPU_PROC\"\nif [[ $ARCH = *aarch64* || $ARCH = *arm* ]] && [[ -n $LOCAL_LSCPU ]]; then\n\tCPU_CORES=$(lscpu | grep \"^[[:blank:]]*CPU(s):\" | sed 's/CPU(s): *//g')\n\tCPU_FREQ=$(lscpu | grep \"CPU max MHz\" | sed 's/CPU max MHz: *//g')\n\t[[ -z \"$CPU_FREQ\" ]] && CPU_FREQ=\"???\"\n\tCPU_FREQ=\"${CPU_FREQ} MHz\"\nelse\n\tCPU_CORES=$(awk -F: '/model name/ {core++} END {print core}' /proc/cpuinfo)\n\tCPU_FREQ=$(awk -F: ' /cpu MHz/ {freq=$2} END {print freq \" MHz\"}' /proc/cpuinfo | sed 's/^[ \\t]*//;s/[ \\t]*$//')\nfi\necho -e \"CPU cores  : $CPU_CORES @ $CPU_FREQ\"\nCPU_AES=$(grep aes /proc/cpuinfo)\n[[ -z \"$CPU_AES\" ]] && CPU_AES=\"\\xE2\\x9D\\x8C Disabled\" || CPU_AES=\"\\xE2\\x9C\\x94 Enabled\"\necho -e \"AES-NI     : $CPU_AES\"\nCPU_VIRT=$(grep 'vmx\\|svm' /proc/cpuinfo)\n[[ -z \"$CPU_VIRT\" ]] && CPU_VIRT=\"\\xE2\\x9D\\x8C Disabled\" || CPU_VIRT=\"\\xE2\\x9C\\x94 Enabled\"\necho -e \"VM-x/AMD-V : $CPU_VIRT\"\nTOTAL_RAM_RAW=$(free | awk 'NR==2 {print $2}')\nTOTAL_RAM=$(format_size \"$TOTAL_RAM_RAW\")\necho -e \"RAM        : $TOTAL_RAM\"\nTOTAL_SWAP_RAW=$(free | grep Swap | awk '{ print $2 }')\nTOTAL_SWAP=$(format_size \"$TOTAL_SWAP_RAW\")\necho -e \"Swap       : $TOTAL_SWAP\"\n# total disk size is calculated by adding all partitions of the types listed below (after the -t flags)\nTOTAL_DISK_RAW=$(df -t simfs -t ext2 -t ext3 -t ext4 -t btrfs -t xfs -t vfat -t ntfs -t swap --total 2>/dev/null | grep total | awk '{ print $2 }')\nTOTAL_DISK=$(format_size \"$TOTAL_DISK_RAW\")\necho -e \"Disk       : $TOTAL_DISK\"\nDISTRO=$(grep 'PRETTY_NAME' /etc/os-release | cut -d '\"' -f 2 )\necho -e \"Distro     : $DISTRO\"\nKERNEL=$(uname -r)\necho -e \"Kernel     : $KERNEL\"\nVIRT=$(systemd-detect-virt 2>/dev/null)\nVIRT=${VIRT^^} || VIRT=\"UNKNOWN\"\necho -e \"VM Type    : $VIRT\"\n[[ -z \"$IPV4_CHECK\" ]] && ONLINE=\"\\xE2\\x9D\\x8C Offline / \" || ONLINE=\"\\xE2\\x9C\\x94 Online / \"\n[[ -z \"$IPV6_CHECK\" ]] && ONLINE+=\"\\xE2\\x9D\\x8C Offline\" || ONLINE+=\"\\xE2\\x9C\\x94 Online\"\necho -e \"IPv4/IPv6  : $ONLINE\"\n\n# Function to get information from IP Address using ip-api.com free API\nfunction ip_info() {\n\t# check for curl vs wget\n\t[[ -n $LOCAL_CURL ]] && DL_CMD=\"curl -s\" || DL_CMD=\"wget -qO-\"\n\n\t# declare local vars\n\tlocal ip6me_resp net_type net_ip response country region region_code city isp org as\n \n\tip6me_resp=\"$($DL_CMD http://ip6.me/api/)\"\n\tnet_type=\"$(echo \"$ip6me_resp\" | cut -d, -f1)\"\n\tnet_ip=\"$(echo \"$ip6me_resp\" | cut -d, -f2)\"\n\n\tresponse=$($DL_CMD http://ip-api.com/json/\"$net_ip\")\n\n\t# if no response, skip output\n\tif [[ -z $response ]]; then\n\t\treturn\n\tfi\n\n\tcountry=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^country/ {print $2}' | head -1 | sed 's/^\"\\(.*\\)\"$/\\1/')\n\tregion=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^regionName/ {print $2}' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\tregion_code=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^region/ {print $2}' | head -1 | sed 's/^\"\\(.*\\)\"$/\\1/')\n\tcity=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^city/ {print $2}' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\tisp=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^isp/ {print $2}' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\torg=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^org/ {print $2}' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\tas=$(echo \"$response\" | sed -e 's/[{}]/''/g' | awk -v RS=',\"' -F: '/^as/ {print $2}' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\t\n\techo\n\techo \"$net_type Network Information:\"\n\techo \"---------------------------------\"\n\n\tif [[ -n \"$isp\" ]]; then\n\t\techo \"ISP        : $isp\"\n\telse\n\t\techo \"ISP        : Unknown\"\n\tfi\n\tif [[ -n \"$as\" ]]; then\n\t\techo \"ASN        : $as\"\n\telse\n\t\techo \"ASN        : Unknown\"\n\tfi\n\tif [[ -n \"$org\" ]]; then\n\t\techo \"Host       : $org\"\n\tfi\n\tif [[ -n \"$city\" && -n \"$region\" ]]; then\n\t\techo \"Location   : $city, $region ($region_code)\"\n\tfi\n\tif [[ -n \"$country\" ]]; then\n\t\techo \"Country    : $country\"\n\tfi \n\n\t[[ -n $JSON ]] && JSON_RESULT+=',\"ip_info\":{\"protocol\":\"'$net_type'\",\"isp\":\"'$isp'\",\"asn\":\"'$as'\",\"org\":\"'$org'\",\"city\":\"'$city'\",\"region\":\"'$region'\",\"region_code\":\"'$region_code'\",\"country\":\"'$country'\"}'\n}\n\nif [[ -n $JSON ]]; then\n\tUPTIME_S=$(awk '{print $1}' /proc/uptime)\n\tIPV4=$([ -n \"$IPV4_CHECK\" ] && echo \"true\" || echo \"false\")\n\tIPV6=$([ -n \"$IPV6_CHECK\" ] && echo \"true\" || echo \"false\")\n\tAES=$([[ \"$CPU_AES\" = *Enabled* ]] && echo \"true\" || echo \"false\")\n\tCPU_VIRT_BOOL=$([[ \"$CPU_VIRT\" = *Enabled* ]] && echo \"true\" || echo \"false\")\n\tJSON_RESULT='{\"version\":\"'$YABS_VERSION'\",\"time\":\"'$TIME_START'\",\"os\":{\"arch\":\"'$ARCH'\",\"distro\":\"'$DISTRO'\",\"kernel\":\"'$KERNEL'\",'\n\tJSON_RESULT+='\"uptime\":'$UPTIME_S',\"vm\":\"'$VIRT'\"},\"net\":{\"ipv4\":'$IPV4',\"ipv6\":'$IPV6'},\"cpu\":{\"model\":\"'$CPU_PROC'\",\"cores\":'$CPU_CORES','\n\tJSON_RESULT+='\"freq\":\"'$CPU_FREQ'\",\"aes\":'$AES',\"virt\":'$CPU_VIRT_BOOL'},\"mem\":{\"ram\":'$TOTAL_RAM_RAW',\"ram_units\":\"KiB\",\"swap\":'$TOTAL_SWAP_RAW',\"swap_units\":\"KiB\",\"disk\":'$TOTAL_DISK_RAW',\"disk_units\":\"KB\"}'\nfi\n\nif [ -z $SKIP_NET ]; then\n\tip_info\nfi\n\n# create a directory in the same location that the script is being run to temporarily store YABS-related files\nDATE=$(date -Iseconds | sed -e \"s/:/_/g\")\nYABS_PATH=./$DATE\ntouch \"$DATE.test\" 2> /dev/null\n# test if the user has write permissions in the current directory and exit if not\nif [ ! -f \"$DATE.test\" ]; then\n\techo -e\n\techo -e \"You do not have write permission in this directory. Switch to an owned directory and re-run the script.\\nExiting...\"\n\texit 1\nfi\nrm \"$DATE.test\"\nmkdir -p \"$YABS_PATH\"\n\n# trap CTRL+C signals to exit script cleanly\ntrap catch_abort INT\n\n# catch_abort\n# Purpose: This method will catch CTRL+C signals in order to exit the script cleanly and remove\n#          yabs-related files.\nfunction catch_abort() {\n\techo -e \"\\n** Aborting YABS. Cleaning up files...\\n\"\n\trm -rf \"$YABS_PATH\"\n\tunset LC_ALL\n\texit 0\n}\n\n# format_speed\n# Purpose: This method is a convenience function to format the output of the fio disk tests which\n#          always returns a result in KB/s. If result is >= 1 GB/s, use GB/s. If result is < 1 GB/s\n#          and >= 1 MB/s, then use MB/s. Otherwise, use KB/s.\n# Parameters:\n#          1. RAW - the raw disk speed result (in KB/s)\n# Returns:\n#          Formatted disk speed in GB/s, MB/s, or KB/s\nfunction format_speed {\n\tRAW=$1 # disk speed in KB/s\n\tRESULT=$RAW\n\tlocal DENOM=1\n\tlocal UNIT=\"KB/s\"\n\n\t# ensure raw value is not null, if it is, return blank\n\tif [ -z \"$RAW\" ]; then\n\t\techo \"\"\n\t\treturn 0\n\tfi\n\n\t# check if disk speed >= 1 GB/s\n\tif [ \"$RAW\" -ge 1000000 ]; then\n\t\tDENOM=1000000\n\t\tUNIT=\"GB/s\"\n\t# check if disk speed < 1 GB/s && >= 1 MB/s\n\telif [ \"$RAW\" -ge 1000 ]; then\n\t\tDENOM=1000\n\t\tUNIT=\"MB/s\"\n\tfi\n\n\t# divide the raw result to get the corresponding formatted result (based on determined unit)\n\tRESULT=$(awk -v a=\"$RESULT\" -v b=\"$DENOM\" 'BEGIN { print a / b }')\n\t# shorten the formatted result to two decimal places (i.e. x.xx)\n\tRESULT=$(echo \"$RESULT\" | awk -F. '{ printf \"%0.2f\",$1\".\"substr($2,1,2) }')\n\t# concat formatted result value with units and return result\n\tRESULT=\"$RESULT $UNIT\"\n\techo \"$RESULT\"\n}\n\n# format_iops\n# Purpose: This method is a convenience function to format the output of the raw IOPS result\n# Parameters:\n#          1. RAW - the raw IOPS result\n# Returns:\n#          Formatted IOPS (i.e. 8, 123, 1.7k, 275.9k, etc.)\nfunction format_iops {\n\tRAW=$1 # iops\n\tRESULT=$RAW\n\n\t# ensure raw value is not null, if it is, return blank\n\tif [ -z \"$RAW\" ]; then\n\t\techo \"\"\n\t\treturn 0\n\tfi\n\n\t# check if IOPS speed > 1k\n\tif [ \"$RAW\" -ge 1000 ]; then\n\t\t# divide the raw result by 1k\n\t\tRESULT=$(awk -v a=\"$RESULT\" 'BEGIN { print a / 1000 }')\n\t\t# shorten the formatted result to one decimal place (i.e. x.x)\n\t\tRESULT=$(echo \"$RESULT\" | awk -F. '{ printf \"%0.1f\",$1\".\"substr($2,1,1) }')\n\t\tRESULT=\"$RESULT\"k\n\tfi\n\n\techo \"$RESULT\"\n}\n\n# disk_test\n# Purpose: This method is designed to test the disk performance of the host using the partition that the\n#          script is being run from using fio random read/write speed tests.\n# Parameters:\n#          - (none)\nfunction disk_test {\n\tif [[ \"$ARCH\" = \"aarch64\" || \"$ARCH\" = \"arm\" ]]; then\n\t\tFIO_SIZE=512M\n\telse\n\t\tFIO_SIZE=2G\n\tfi\n\n\t# run a quick test to generate the fio test file to be used by the actual tests\n\techo -en \"Generating fio test file...\"\n\t$FIO_CMD --name=setup --ioengine=libaio --rw=read --bs=64k --iodepth=64 --numjobs=2 --size=$FIO_SIZE --runtime=1 --gtod_reduce=1 --filename=\"$DISK_PATH/test.fio\" --direct=1 --minimal &> /dev/null\n\techo -en \"\\r\\033[0K\"\n\n\t# get array of block sizes to evaluate\n\tBLOCK_SIZES=(\"$@\")\n\n\tfor BS in \"${BLOCK_SIZES[@]}\"; do\n\t\t# run rand read/write mixed fio test with block size = $BS\n\t\techo -en \"Running fio random mixed R+W disk test with $BS block size...\"\n\t\tDISK_TEST=$(timeout 35 \"$FIO_CMD\" --name=rand_rw_\"$BS\" --ioengine=libaio --rw=randrw --rwmixread=50 --bs=\"$BS\" --iodepth=64 --numjobs=2 --size=\"$FIO_SIZE\" --runtime=30 --gtod_reduce=1 --direct=1 --filename=\"$DISK_PATH/test.fio\" --group_reporting --minimal 2> /dev/null | grep rand_rw_\"$BS\")\n\t\tDISK_IOPS_R=$(echo \"$DISK_TEST\" | awk -F';' '{print $8}')\n\t\tDISK_IOPS_W=$(echo \"$DISK_TEST\" | awk -F';' '{print $49}')\n\t\tDISK_IOPS=$(awk -v a=\"$DISK_IOPS_R\" -v b=\"$DISK_IOPS_W\" 'BEGIN { print a + b }')\n\t\tDISK_TEST_R=$(echo \"$DISK_TEST\" | awk -F';' '{print $7}')\n\t\tDISK_TEST_W=$(echo \"$DISK_TEST\" | awk -F';' '{print $48}')\n\t\tDISK_TEST=$(awk -v a=\"$DISK_TEST_R\" -v b=\"$DISK_TEST_W\" 'BEGIN { print a + b }')\n\t\tDISK_RESULTS_RAW+=( \"$DISK_TEST\" \"$DISK_TEST_R\" \"$DISK_TEST_W\" \"$DISK_IOPS\" \"$DISK_IOPS_R\" \"$DISK_IOPS_W\" )\n\n\t\tDISK_IOPS=$(format_iops \"$DISK_IOPS\")\n\t\tDISK_IOPS_R=$(format_iops \"$DISK_IOPS_R\")\n\t\tDISK_IOPS_W=$(format_iops \"$DISK_IOPS_W\")\n\t\tDISK_TEST=$(format_speed \"$DISK_TEST\")\n\t\tDISK_TEST_R=$(format_speed \"$DISK_TEST_R\")\n\t\tDISK_TEST_W=$(format_speed \"$DISK_TEST_W\")\n\n\t\tDISK_RESULTS+=( \"$DISK_TEST\" \"$DISK_TEST_R\" \"$DISK_TEST_W\" \"$DISK_IOPS\" \"$DISK_IOPS_R\" \"$DISK_IOPS_W\" )\n\t\techo -en \"\\r\\033[0K\"\n\tdone\n}\n\n# dd_test\n# Purpose: This method is invoked if the fio disk test failed. dd sequential speed tests are\n#          not indiciative or real-world results, however, some form of disk speed measure \n#          is better than nothing.\n# Parameters:\n#          - (none)\nfunction dd_test {\n\tI=0\n\tDISK_WRITE_TEST_RES=()\n\tDISK_READ_TEST_RES=()\n\tDISK_WRITE_TEST_AVG=0\n\tDISK_READ_TEST_AVG=0\n\n\t# run the disk speed tests (write and read) thrice over\n\twhile [ $I -lt 3 ]\n\tdo\n\t\t# write test using dd, \"direct\" flag is used to test direct I/O for data being stored to disk\n\t\tDISK_WRITE_TEST=$(dd if=/dev/zero of=\"$DISK_PATH/$DATE.test\" bs=64k count=16k oflag=direct |& grep copied | awk '{ print $(NF-1) \" \" $(NF)}')\n\t\tVAL=$(echo \"$DISK_WRITE_TEST\" | cut -d \" \" -f 1)\n\t\t[[ \"$DISK_WRITE_TEST\" == *\"GB\"* ]] && VAL=$(awk -v a=\"$VAL\" 'BEGIN { print a * 1000 }')\n\t\tDISK_WRITE_TEST_RES+=( \"$DISK_WRITE_TEST\" )\n\t\tDISK_WRITE_TEST_AVG=$(awk -v a=\"$DISK_WRITE_TEST_AVG\" -v b=\"$VAL\" 'BEGIN { print a + b }')\n\n\t\t# read test using dd using the 1G file written during the write test\n\t\tDISK_READ_TEST=$(dd if=\"$DISK_PATH/$DATE.test\" of=/dev/null bs=8k |& grep copied | awk '{ print $(NF-1) \" \" $(NF)}')\n\t\tVAL=$(echo \"$DISK_READ_TEST\" | cut -d \" \" -f 1)\n\t\t[[ \"$DISK_READ_TEST\" == *\"GB\"* ]] && VAL=$(awk -v a=\"$VAL\" 'BEGIN { print a * 1000 }')\n\t\tDISK_READ_TEST_RES+=( \"$DISK_READ_TEST\" )\n\t\tDISK_READ_TEST_AVG=$(awk -v a=\"$DISK_READ_TEST_AVG\" -v b=\"$VAL\" 'BEGIN { print a + b }')\n\n\t\tI=$(( I + 1 ))\n\tdone\n\t# calculate the write and read speed averages using the results from the three runs\n\tDISK_WRITE_TEST_AVG=$(awk -v a=\"$DISK_WRITE_TEST_AVG\" 'BEGIN { print a / 3 }')\n\tDISK_READ_TEST_AVG=$(awk -v a=\"$DISK_READ_TEST_AVG\" 'BEGIN { print a / 3 }')\n}\n\n# check if disk performance is being tested and the host has required space (2G)\nAVAIL_SPACE=$(df -k . | awk 'NR==2{print $4}')\nif [[ -z \"$SKIP_FIO\" && \"$AVAIL_SPACE\" -lt 2097152 && \"$ARCH\" != \"aarch64\" && \"$ARCH\" != \"arm\" ]]; then # 2GB = 2097152KB\n\techo -e \"\\nLess than 2GB of space available. Skipping disk test...\"\nelif [[ -z \"$SKIP_FIO\" && \"$AVAIL_SPACE\" -lt 524288 && (\"$ARCH\" = \"aarch64\" || \"$ARCH\" = \"arm\") ]]; then # 512MB = 524288KB\n\techo -e \"\\nLess than 512MB of space available. Skipping disk test...\"\n# if the skip disk flag was set, skip the disk performance test, otherwise test disk performance\nelif [ -z \"$SKIP_FIO\" ]; then\n\t# Perform ZFS filesystem detection and determine if we have enough free space according to spa_asize_inflation\n\tZFSCHECK=\"/sys/module/zfs/parameters/spa_asize_inflation\"\n\tif [[ -f \"$ZFSCHECK\" ]];then\n\t\tmul_spa=$(( $(cat /sys/module/zfs/parameters/spa_asize_inflation) * 2 ))\n\t\twarning=0\n\t\tposs=()\n\n\t\tfor pathls in $(df -Th | awk '{print $7}' | tail -n +2)\n\t\tdo\n\t\t\tif [[ \"${PWD##\"$pathls\"}\" != \"$PWD\" ]]; then\n\t\t\t\tposs+=(\"$pathls\")\n\t\t\tfi\n\t\tdone\n\n\t\tlong=\"\"\n\t\tm=-1\n\t\tfor x in \"${poss[@]}\"\n\t\tdo\n\t\t\tif [ \"${#x}\" -gt \"$m\" ];then\n\t\t\t\tm=${#x}\n\t\t\t\tlong=$x\n\t\t\tfi\n\t\tdone\n\n\t\tsize_b=$(df -Th | grep -w \"$long\" | grep -i zfs | awk '{print $5}' | tail -c -2 | head -c 1)\n\t\tfree_space=$(df -Th | grep -w \"$long\" | grep -i zfs | awk '{print $5}' | head -c -2)\n\n\t\tif [[ $size_b == 'T' ]]; then\n\t\t\tfree_space=$(awk \"BEGIN {print int($free_space * 1024)}\")\n\t\t\tsize_b='G'\n\t\tfi\n\n\t\tif [[ $(df -Th | grep -w \"$long\") == *\"zfs\"* ]];then\n\n\t\t\tif [[ $size_b == 'G' ]]; then\n\t\t\t\tif ((free_space < mul_spa)); then\n\t\t\t\t\twarning=1\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\twarning=1\n\t\t\tfi\n\n\t\tfi\n\n\t\tif [[ $warning -eq 1 ]];then\n\t\t\techo -en \"\\nWarning! You are running YABS on a ZFS Filesystem and your disk space is too low for the fio test. Your test results will be inaccurate. You need at least $mul_spa GB free in order to complete this test accurately. For more information, please see https://github.com/masonr/yet-another-bench-script/issues/13\\n\"\n\t\tfi\n\tfi\n\t\n\techo -en \"\\nPreparing system for disk tests...\"\n\n\t# create temp directory to store disk write/read test files\n\tDISK_PATH=$YABS_PATH/disk\n\tmkdir -p \"$DISK_PATH\"\n\n\tif [[ -z \"$PREFER_BIN\" && -n \"$LOCAL_FIO\" ]]; then # local fio has been detected, use instead of pre-compiled binary\n\t\tFIO_CMD=fio\n\telse\n\t\t# download fio binary\n\t\tif [[ -n $LOCAL_CURL ]]; then\n\t\t\tcurl -s --connect-timeout 5 --retry 5 --retry-delay 0 https://raw.githubusercontent.com/masonr/yet-another-bench-script/master/bin/fio/fio_$ARCH -o \"$DISK_PATH/fio\"\n\t\telse\n\t\t\twget -q -T 5 -t 5 -w 0 https://raw.githubusercontent.com/masonr/yet-another-bench-script/master/bin/fio/fio_$ARCH -O \"$DISK_PATH/fio\"\n\t\tfi\n\n\t\tif [ ! -f \"$DISK_PATH/fio\" ]; then # ensure fio binary download successfully\n\t\t\techo -en \"\\r\\033[0K\"\n\t\t\techo -e \"Fio binary download failed. Running dd test as fallback....\"\n\t\t\tDD_FALLBACK=True\n\t\telse\n\t\t\tchmod +x \"$DISK_PATH/fio\"\n\t\t\tFIO_CMD=$DISK_PATH/fio\n\t\tfi\n\tfi\n\n\tif [ -z \"$DD_FALLBACK\" ]; then # if not falling back on dd tests, run fio test\n\t\techo -en \"\\r\\033[0K\"\n\n\t\t# init global array to store disk performance values\n\t\tdeclare -a DISK_RESULTS DISK_RESULTS_RAW\n\t\t# disk block sizes to evaluate\n\t\tBLOCK_SIZES=( \"4k\" \"64k\" \"512k\" \"1m\" )\n\n\t\t# execute disk performance test\n\t\tdisk_test \"${BLOCK_SIZES[@]}\"\n\tfi\n\n\tif [[ -n \"$DD_FALLBACK\" || ${#DISK_RESULTS[@]} -eq 0 ]]; then # fio download failed or test was killed or returned an error, run dd test instead\n\t\tif [ -z \"$DD_FALLBACK\" ]; then # print error notice if ended up here due to fio error\n\t\t\techo -e \"fio disk speed tests failed. Run manually to determine cause.\\nRunning dd test as fallback...\"\n\t\tfi\n\n\t\tdd_test\n\n\t\t# format the speed averages by converting to GB/s if > 1000 MB/s\n\t\tif [ \"$(echo \"$DISK_WRITE_TEST_AVG\" | cut -d \".\" -f 1)\" -ge 1000 ]; then\n\t\t\tDISK_WRITE_TEST_AVG=$(awk -v a=\"$DISK_WRITE_TEST_AVG\" 'BEGIN { print a / 1000 }')\n\t\t\tDISK_WRITE_TEST_UNIT=\"GB/s\"\n\t\telse\n\t\t\tDISK_WRITE_TEST_UNIT=\"MB/s\"\n\t\tfi\n\t\tif [ \"$(echo \"$DISK_READ_TEST_AVG\" | cut -d \".\" -f 1)\" -ge 1000 ]; then\n\t\t\tDISK_READ_TEST_AVG=$(awk -v a=\"$DISK_READ_TEST_AVG\" 'BEGIN { print a / 1000 }')\n\t\t\tDISK_READ_TEST_UNIT=\"GB/s\"\n\t\telse\n\t\t\tDISK_READ_TEST_UNIT=\"MB/s\"\n\t\tfi\n\n\t\t# print dd sequential disk speed test results\n\t\techo -e\n\t\techo -e \"dd Sequential Disk Speed Tests:\"\n\t\techo -e \"---------------------------------\"\n\t\tprintf \"%-6s | %-6s %-4s | %-6s %-4s | %-6s %-4s | %-6s %-4s\\n\" \"\" \"Test 1\" \"\" \"Test 2\" \"\"  \"Test 3\" \"\" \"Avg\" \"\"\n\t\tprintf \"%-6s | %-6s %-4s | %-6s %-4s | %-6s %-4s | %-6s %-4s\\n\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n\t\tprintf \"%-6s | %-11s | %-11s | %-11s | %-6.2f %-4s\\n\" \"Write\" \"${DISK_WRITE_TEST_RES[0]}\" \"${DISK_WRITE_TEST_RES[1]}\" \"${DISK_WRITE_TEST_RES[2]}\" \"${DISK_WRITE_TEST_AVG}\" \"${DISK_WRITE_TEST_UNIT}\" \n\t\tprintf \"%-6s | %-11s | %-11s | %-11s | %-6.2f %-4s\\n\" \"Read\" \"${DISK_READ_TEST_RES[0]}\" \"${DISK_READ_TEST_RES[1]}\" \"${DISK_READ_TEST_RES[2]}\" \"${DISK_READ_TEST_AVG}\" \"${DISK_READ_TEST_UNIT}\" \n\telse # fio tests completed successfully, print results\n\t\tCURRENT_PARTITION=$(df -P . 2>/dev/null | tail -1 | cut -d' ' -f 1)\n\t\t[[ -n $JSON ]] && JSON_RESULT+=',\"partition\":\"'$CURRENT_PARTITION'\",\"fio\":['\n\t\tDISK_RESULTS_NUM=$((${#DISK_RESULTS[@]} / 6))\n\t\tDISK_COUNT=0\n\n\t\t# print disk speed test results\n\t\techo -e \"fio Disk Speed Tests (Mixed R/W 50/50) (Partition $CURRENT_PARTITION):\"\n\t\techo -e \"---------------------------------\"\n\n\t\twhile [[ $DISK_COUNT -lt $DISK_RESULTS_NUM ]] ; do\n\t\t\tif [[ $DISK_COUNT -gt 0 ]]; then printf \"%-10s | %-20s | %-20s\\n\" \"\" \"\" \"\"; fi\n\t\t\tprintf \"%-10s | %-11s %8s | %-11s %8s\\n\" \"Block Size\" \"${BLOCK_SIZES[DISK_COUNT]}\" \"(IOPS)\" \"${BLOCK_SIZES[DISK_COUNT+1]}\" \"(IOPS)\"\n\t\t\tprintf \"%-10s | %-11s %8s | %-11s %8s\\n\" \"  ------\" \"---\" \"---- \" \"----\" \"---- \"\n\t\t\tprintf \"%-10s | %-11s %8s | %-11s %8s\\n\" \"Read\" \"${DISK_RESULTS[DISK_COUNT*6+1]}\" \"(${DISK_RESULTS[DISK_COUNT*6+4]})\" \"${DISK_RESULTS[(DISK_COUNT+1)*6+1]}\" \"(${DISK_RESULTS[(DISK_COUNT+1)*6+4]})\"\n\t\t\tprintf \"%-10s | %-11s %8s | %-11s %8s\\n\" \"Write\" \"${DISK_RESULTS[DISK_COUNT*6+2]}\" \"(${DISK_RESULTS[DISK_COUNT*6+5]})\" \"${DISK_RESULTS[(DISK_COUNT+1)*6+2]}\" \"(${DISK_RESULTS[(DISK_COUNT+1)*6+5]})\"\n\t\t\tprintf \"%-10s | %-11s %8s | %-11s %8s\\n\" \"Total\" \"${DISK_RESULTS[DISK_COUNT*6]}\" \"(${DISK_RESULTS[DISK_COUNT*6+3]})\" \"${DISK_RESULTS[(DISK_COUNT+1)*6]}\" \"(${DISK_RESULTS[(DISK_COUNT+1)*6+3]})\"\n\t\t\tif [[ -n $JSON ]]; then\n\t\t\t\tJSON_RESULT+='{\"bs\":\"'${BLOCK_SIZES[DISK_COUNT]}'\",\"speed_r\":'${DISK_RESULTS_RAW[DISK_COUNT*6+1]}',\"iops_r\":'${DISK_RESULTS_RAW[DISK_COUNT*6+4]}\n\t\t\t\tJSON_RESULT+=',\"speed_w\":'${DISK_RESULTS_RAW[DISK_COUNT*6+2]}',\"iops_w\":'${DISK_RESULTS_RAW[DISK_COUNT*6+5]}',\"speed_rw\":'${DISK_RESULTS_RAW[DISK_COUNT*6]}\n\t\t\t\tJSON_RESULT+=',\"iops_rw\":'${DISK_RESULTS_RAW[DISK_COUNT*6+3]}',\"speed_units\":\"KBps\"},'\n\t\t\t\tJSON_RESULT+='{\"bs\":\"'${BLOCK_SIZES[DISK_COUNT+1]}'\",\"speed_r\":'${DISK_RESULTS_RAW[(DISK_COUNT+1)*6+1]}',\"iops_r\":'${DISK_RESULTS_RAW[(DISK_COUNT+1)*6+4]}\n\t\t\t\tJSON_RESULT+=',\"speed_w\":'${DISK_RESULTS_RAW[(DISK_COUNT+1)*6+2]}',\"iops_w\":'${DISK_RESULTS_RAW[(DISK_COUNT+1)*6+5]}',\"speed_rw\":'${DISK_RESULTS_RAW[(DISK_COUNT+1)*6]}\n\t\t\t\tJSON_RESULT+=',\"iops_rw\":'${DISK_RESULTS_RAW[(DISK_COUNT+1)*6+3]}',\"speed_units\":\"KBps\"},'\n\t\t\tfi\n\t\t\tDISK_COUNT=$((DISK_COUNT + 2))\n\t\tdone\n\t\t[[ -n $JSON ]] && JSON_RESULT=${JSON_RESULT::${#JSON_RESULT}-1} && JSON_RESULT+=']'\n\tfi\nfi\n\n# iperf_test\n# Purpose: This method is designed to test the network performance of the host by executing an\n#          iperf3 test to/from the public iperf server passed to the function. Both directions \n#          (send and receive) are tested.\n# Parameters:\n#          1. URL - URL/domain name of the iperf server\n#          2. PORTS - the range of ports on which the iperf server operates\n#          3. HOST - the friendly name of the iperf server host/owner\n#          4. FLAGS - any flags that should be passed to the iperf command\nfunction iperf_test {\n\tURL=$1\n\tPORTS=$2\n\tHOST=$3\n\tFLAGS=$4\n\t\n\t# attempt the iperf send test 3 times, allowing for a slot to become available on the\n\t#   server or to throw out any bad/error results\n\tI=1\n\twhile [ $I -le 3 ]\n\tdo\n\t\techo -en \"Performing $MODE iperf3 send test to $HOST (Attempt #$I of 3)...\"\n\t\t# select a random iperf port from the range provided\n\t\tPORT=$(shuf -i \"$PORTS\" -n 1)\n\t\t# run the iperf test sending data from the host to the iperf server; includes\n\t\t#   a timeout of 15s in case the iperf server is not responding; uses 8 parallel\n\t\t#   threads for the network test\n\t\tIPERF_RUN_SEND=\"$(timeout 15 \"$IPERF_CMD\" \"$FLAGS\" -c \"$URL\" -p \"$PORT\" -P 8 2> /dev/null)\"\n\t\t# check if iperf exited cleanly and did not return an error\n\t\tif [[ \"$IPERF_RUN_SEND\" == *\"receiver\"* && \"$IPERF_RUN_SEND\" != *\"error\"* ]]; then\n\t\t\t# test did not result in an error, parse speed result\n\t\t\tSPEED=$(echo \"${IPERF_RUN_SEND}\" | grep SUM | grep receiver | awk '{ print $6 }')\n\t\t\t# if speed result is blank or bad (0.00), rerun, otherwise set counter to exit loop\n\t\t\t[[ -z $SPEED || \"$SPEED\" == \"0.00\" ]] && I=$(( I + 1 )) || I=11\n\t\telse\n\t\t\t# if iperf server is not responding, set counter to exit, otherwise increment, sleep, and rerun\n\t\t\t[[ \"$IPERF_RUN_SEND\" == *\"unable to connect\"* ]] && I=11 || I=$(( I + 1 )) && sleep 2\n\t\tfi\n\t\techo -en \"\\r\\033[0K\"\n\tdone\n\n\t# small sleep necessary to give iperf server a breather to get ready for a new test\n\tsleep 1\n\n\t# attempt the iperf receive test 3 times, allowing for a slot to become available on\n\t#   the server or to throw out any bad/error results\n\tJ=1\n\twhile [ $J -le 3 ]\n\tdo\n\t\techo -n \"Performing $MODE iperf3 recv test from $HOST (Attempt #$J of 3)...\"\n\t\t# select a random iperf port from the range provided\n\t\tPORT=$(shuf -i \"$PORTS\" -n 1)\n\t\t# run the iperf test receiving data from the iperf server to the host; includes\n\t\t#   a timeout of 15s in case the iperf server is not responding; uses 8 parallel\n\t\t#   threads for the network test\n\t\tIPERF_RUN_RECV=\"$(timeout 15 \"$IPERF_CMD\" \"$FLAGS\" -c \"$URL\" -p \"$PORT\" -P 8 -R 2> /dev/null)\"\n\t\t# check if iperf exited cleanly and did not return an error\n\t\tif [[ \"$IPERF_RUN_RECV\" == *\"receiver\"* && \"$IPERF_RUN_RECV\" != *\"error\"* ]]; then\n\t\t\t# test did not result in an error, parse speed result\n\t\t\tSPEED=$(echo \"${IPERF_RUN_RECV}\" | grep SUM | grep receiver | awk '{ print $6 }')\n\t\t\t# if speed result is blank or bad (0.00), rerun, otherwise set counter to exit loop\n\t\t\t[[ -z $SPEED || \"$SPEED\" == \"0.00\" ]] && J=$(( J + 1 )) || J=11\n\t\telse\n\t\t\t# if iperf server is not responding, set counter to exit, otherwise increment, sleep, and rerun\n\t\t\t[[ \"$IPERF_RUN_RECV\" == *\"unable to connect\"* ]] && J=11 || J=$(( J + 1 )) && sleep 2\n\t\tfi\n\t\techo -en \"\\r\\033[0K\"\n\tdone\n\t\n\t# Run a latency test via ping -c1 command -> will return \"xx.x ms\"\n\t[[ -n $LOCAL_PING ]] && LATENCY_RUN=\"$(ping -c1 \"$URL\" 2>/dev/null | grep -o 'time=.*' | sed s/'time='//)\" \n\t[[ -z $LATENCY_RUN ]] && LATENCY_RUN=\"--\"\n\n\t# parse the resulting send and receive speed results\n\tIPERF_SENDRESULT=\"$(echo \"${IPERF_RUN_SEND}\" | grep SUM | grep receiver)\"\n\tIPERF_RECVRESULT=\"$(echo \"${IPERF_RUN_RECV}\" | grep SUM | grep receiver)\"\n\tLATENCY_RESULT=\"${LATENCY_RUN}\"\n}\n\n# launch_iperf\n# Purpose: This method is designed to facilitate the execution of iperf network speed tests to\n#          each public iperf server in the iperf server locations array.\n# Parameters:\n#          1. MODE - indicates the type of iperf tests to run (IPv4 or IPv6)\nfunction launch_iperf {\n\tMODE=$1\n\t[[ \"$MODE\" == *\"IPv6\"* ]] && IPERF_FLAGS=\"-6\" || IPERF_FLAGS=\"-4\"\n\n\t# print iperf3 network speed results as they are completed\n\techo -e\n\techo -e \"iperf3 Network Speed Tests ($MODE):\"\n\techo -e \"---------------------------------\"\n\tprintf \"%-15s | %-25s | %-15s | %-15s | %-15s\\n\" \"Provider\" \"Location (Link)\" \"Send Speed\" \"Recv Speed\" \"Ping\"\n\tprintf \"%-15s | %-25s | %-15s | %-15s | %-15s\\n\" \"-----\" \"-----\" \"----\" \"----\" \"----\"\n\t\n\t# loop through iperf locations array to run iperf test using each public iperf server\n\tfor (( i = 0; i < IPERF_LOCS_NUM; i++ )); do\n\t\t# test if the current iperf location supports the network mode being tested (IPv4/IPv6)\n\t\tif [[ \"${IPERF_LOCS[i*5+4]}\" == *\"$MODE\"* ]]; then\n\t\t\t# call the iperf_test function passing the required parameters\n\t\t\tiperf_test \"${IPERF_LOCS[i*5]}\" \"${IPERF_LOCS[i*5+1]}\" \"${IPERF_LOCS[i*5+2]}\" \"$IPERF_FLAGS\"\n\t\t\t# parse the send and receive speed results\n\t\t\tIPERF_SENDRESULT_VAL=$(echo \"$IPERF_SENDRESULT\" | awk '{ print $6 }')\n\t\t\tIPERF_SENDRESULT_UNIT=$(echo \"$IPERF_SENDRESULT\" | awk '{ print $7 }')\n\t\t\tIPERF_RECVRESULT_VAL=$(echo \"$IPERF_RECVRESULT\" | awk '{ print $6 }')\n\t\t\tIPERF_RECVRESULT_UNIT=$(echo \"$IPERF_RECVRESULT\" | awk '{ print $7 }')\n\t\t\tLATENCY_VAL=\"${LATENCY_RESULT}\"\n\t\t\t# if the results are blank, then the server is \"busy\" and being overutilized\n\t\t\t[[ -z $IPERF_SENDRESULT_VAL || \"$IPERF_SENDRESULT_VAL\" == *\"0.00\"* ]] && IPERF_SENDRESULT_VAL=\"busy\" && IPERF_SENDRESULT_UNIT=\"\"\n\t\t\t[[ -z $IPERF_RECVRESULT_VAL || \"$IPERF_RECVRESULT_VAL\" == *\"0.00\"* ]] && IPERF_RECVRESULT_VAL=\"busy\" && IPERF_RECVRESULT_UNIT=\"\"\n\t\t\t# print the speed results for the iperf location currently being evaluated\n\t\t\tprintf \"%-15s | %-25s | %-15s | %-15s | %-15s\\n\" \"${IPERF_LOCS[i*5+2]}\" \"${IPERF_LOCS[i*5+3]}\" \"$IPERF_SENDRESULT_VAL $IPERF_SENDRESULT_UNIT\" \"$IPERF_RECVRESULT_VAL $IPERF_RECVRESULT_UNIT\" \"$LATENCY_VAL\"\n\t\t\tif [[ -n $JSON ]]; then\n\t\t\t\tJSON_RESULT+='{\"mode\":\"'$MODE'\",\"provider\":\"'${IPERF_LOCS[i*5+2]}'\",\"loc\":\"'${IPERF_LOCS[i*5+3]}\n\t\t\t\tJSON_RESULT+='\",\"send\":\"'$IPERF_SENDRESULT_VAL' '$IPERF_SENDRESULT_UNIT'\",\"recv\":\"'$IPERF_RECVRESULT_VAL' '$IPERF_RECVRESULT_UNIT'\",\"latency\":\"'$LATENCY_VAL'\"},'\n\t\t\tfi\n\t\tfi\n\tdone\n}\n\n# if the skip iperf flag was set, skip the network performance test, otherwise test network performance\nif [ -z \"$SKIP_IPERF\" ]; then\n\n\tif [[ -z \"$PREFER_BIN\" && -n \"$LOCAL_IPERF\" ]]; then # local iperf has been detected, use instead of pre-compiled binary\n\t\tIPERF_CMD=iperf3\n\telse\n\t\t# create a temp directory to house the required iperf binary and library\n\t\tIPERF_PATH=$YABS_PATH/iperf\n\t\tmkdir -p \"$IPERF_PATH\"\n\n\t\t# download iperf3 binary\n\t\tif [[ -n $LOCAL_CURL ]]; then\n\t\t\tcurl -s --connect-timeout 5 --retry 5 --retry-delay 0 https://raw.githubusercontent.com/masonr/yet-another-bench-script/master/bin/iperf/iperf3_$ARCH -o \"$IPERF_PATH/iperf3\"\n\t\telse\n\t\t\twget -q -T 5 -t 5 -w 0 https://raw.githubusercontent.com/masonr/yet-another-bench-script/master/bin/iperf/iperf3_$ARCH -O \"$IPERF_PATH/iperf3\"\n\t\tfi\n\n\t\tif [ ! -f \"$IPERF_PATH/iperf3\" ]; then # ensure iperf3 binary downloaded successfully\n\t\t\tIPERF_DL_FAIL=True\n\t\telse\n\t\t\tchmod +x \"$IPERF_PATH/iperf3\"\n\t\t\tIPERF_CMD=$IPERF_PATH/iperf3\n\t\tfi\n\tfi\n\t\n\t# array containing all currently available iperf3 public servers to use for the network test\n\t# format: \"1\" \"2\" \"3\" \"4\" \"5\" \\\n\t#   1. domain name of the iperf server\n\t#   2. range of ports that the iperf server is running on (lowest-highest)\n\t#   3. friendly name of the host/owner of the iperf server\n\t#   4. location and advertised speed link of the iperf server\n\t#   5. network modes supported by the iperf server (IPv4 = IPv4-only, IPv4|IPv6 = IPv4 + IPv6, etc.)\n\tIPERF_LOCS=( \\\n\t\t\"lon.speedtest.clouvider.net\" \"5200-5209\" \"Clouvider\" \"London, UK (10G)\" \"IPv4|IPv6\" \\\n\t\t\"iperf-ams-nl.eranium.net\" \"5201-5210\" \"Eranium\" \"Amsterdam, NL (100G)\" \"IPv4|IPv6\" \\\n\t\t#\"speedtest.extra.telia.fi\" \"5201-5208\" \"Telia\" \"Helsinki, FI (10G)\" \"IPv4\"\n\t\t# AFR placeholder\n\t\t\"speedtest.uztelecom.uz\" \"5200-5209\" \"Uztelecom\" \"Tashkent, UZ (10G)\" \"IPv4|IPv6\" \\\n\t\t\"speedtest.sin1.sg.leaseweb.net\" \"5201-5210\" \"Leaseweb\" \"Singapore, SG (10G)\" \"IPv4|IPv6\" \\\n\t\t\"la.speedtest.clouvider.net\" \"5200-5209\" \"Clouvider\" \"Los Angeles, CA, US (10G)\" \"IPv4|IPv6\" \\\n\t\t\"speedtest.nyc1.us.leaseweb.net\" \"5201-5210\" \"Leaseweb\" \"NYC, NY, US (10G)\" \"IPv4|IPv6\" \\\n\t\t\"speedtest.sao1.edgoo.net\" \"9204-9240\" \"Edgoo\" \"Sao Paulo, BR (1G)\" \"IPv4|IPv6\"\n\t)\n\n\t# if the \"REDUCE_NET\" flag is activated, then do a shorter iperf test with only three locations\n\t# (Clouvider London, Clouvider NYC, and Online.net France)\n\tif [ -n \"$REDUCE_NET\" ]; then\n\t\tIPERF_LOCS=( \\\n\t\t\t\"lon.speedtest.clouvider.net\" \"5200-5209\" \"Clouvider\" \"London, UK (10G)\" \"IPv4|IPv6\" \\\n\t\t\t\"speedtest.sin1.sg.leaseweb.net\" \"5201-5210\" \"Leaseweb\" \"Singapore, SG (10G)\" \"IPv4|IPv6\" \\\n\t\t\t\"speedtest.nyc1.us.leaseweb.net\" \"5201-5210\" \"Leaseweb\" \"NYC, NY, US (10G)\" \"IPv4|IPv6\" \\\n\t\t)\n\tfi\n\t\n\t# get the total number of iperf locations (total array size divided by 5 since each location has 5 elements)\n\tIPERF_LOCS_NUM=${#IPERF_LOCS[@]}\n\tIPERF_LOCS_NUM=$((IPERF_LOCS_NUM / 5))\n\t\n\tif [ -z \"$IPERF_DL_FAIL\" ]; then\n\t\t[[ -n $JSON ]] && JSON_RESULT+=',\"iperf\":['\n\t\t# check if the host has IPv4 connectivity, if so, run iperf3 IPv4 tests\n\t\t[ -n \"$IPV4_CHECK\" ] && launch_iperf \"IPv4\"\n\t\t# check if the host has IPv6 connectivity, if so, run iperf3 IPv6 tests\n\t\t[ -n \"$IPV6_CHECK\" ] && launch_iperf \"IPv6\"\n\t\t[[ -n $JSON ]] && JSON_RESULT=${JSON_RESULT::${#JSON_RESULT}-1} && JSON_RESULT+=']'\n\telse\n\t\techo -e \"\\niperf3 binary download failed. Skipping iperf network tests...\"\n\tfi\nfi\n\n# launch_geekbench\n# Purpose: This method is designed to run the Primate Labs' Geekbench 4/5 Cross-Platform Benchmark utility\n# Parameters:\n#          1. VERSION - indicates which Geekbench version to run\nfunction launch_geekbench {\n\tVERSION=$1\n\n\t# create a temp directory to house all geekbench files\n\tGEEKBENCH_PATH=$YABS_PATH/geekbench_$VERSION\n\tmkdir -p \"$GEEKBENCH_PATH\"\n\n\tGB_URL=\"\"\n\tGB_CMD=\"\"\n\tGB_RUN=\"\"\n\n\t# check for curl vs wget\n\t[[ -n $LOCAL_CURL ]] && DL_CMD=\"curl -s\" || DL_CMD=\"wget -qO-\"\n\n\tif [[ $VERSION == *4* && ($ARCH = *aarch64* || $ARCH = *arm*) ]]; then\n\t\techo -e \"\\nARM architecture not supported by Geekbench 4, use Geekbench 5 or 6.\"\n\telif [[ $VERSION == *4* && $ARCH != *aarch64* && $ARCH != *arm* ]]; then # Geekbench v4\n\t\tGB_URL=\"https://cdn.geekbench.com/Geekbench-4.4.4-Linux.tar.gz\"\n\t\t[[ \"$ARCH\" == *\"x86\"* ]] && GB_CMD=\"geekbench_x86_32\" || GB_CMD=\"geekbench4\"\n\t\tGB_RUN=\"True\"\n\telif [[ $VERSION == *5* || $VERSION == *6* ]]; then # Geekbench v5/6\n\t\tif [[ $ARCH = *x86* && $GEEKBENCH_4 == *False* ]]; then # don't run Geekbench 5 if on 32-bit arch\n\t\t\techo -e \"\\nGeekbench $VERSION cannot run on 32-bit architectures. Re-run with -4 flag to use\"\n\t\t\techo -e \"Geekbench 4, which can support 32-bit architectures. Skipping Geekbench $VERSION.\"\n\t\telif [[ $ARCH = *x86* && $GEEKBENCH_4 == *True* ]]; then\n\t\t\techo -e \"\\nGeekbench $VERSION cannot run on 32-bit architectures. Skipping test.\"\n\t\telse\n\t\t\tif [[ $VERSION == *5* ]]; then # Geekbench v5\n\t\t\t\t[[ $ARCH = *aarch64* || $ARCH = *arm* ]] && GB_URL=\"https://cdn.geekbench.com/Geekbench-5.5.1-LinuxARMPreview.tar.gz\" \\\n\t\t\t\t\t|| GB_URL=\"https://cdn.geekbench.com/Geekbench-5.5.1-Linux.tar.gz\"\n\t\t\t\tGB_CMD=\"geekbench5\"\n\t\t\telse # Geekbench v6\n\t\t\t\t[[ $ARCH = *aarch64* || $ARCH = *arm* ]] && GB_URL=\"https://cdn.geekbench.com/Geekbench-6.3.0-LinuxARMPreview.tar.gz\" \\\n\t\t\t\t\t|| GB_URL=\"https://cdn.geekbench.com/Geekbench-6.3.0-Linux.tar.gz\"\n\t\t\t\tGB_CMD=\"geekbench6\"\n\t\t\tfi\n\t\t\tGB_RUN=\"True\"\n\t\tfi\n\tfi\n\n\tif [[ $GB_RUN == *True* ]]; then # run GB test\n\t\techo -en \"\\nRunning GB$VERSION benchmark test... *cue elevator music*\"\n\n\t\t# check for local geekbench installed\n\t\tif command -v \"$GB_CMD\" &>/dev/null; then\n\t\t\tGEEKBENCH_PATH=$(dirname \"$(command -v \"$GB_CMD\")\")\n\t\telse\n\t\t\t# download the desired Geekbench tarball and extract to geekbench temp directory\n\t\t\t$DL_CMD $GB_URL | tar xz --strip-components=1 -C \"$GEEKBENCH_PATH\" &>/dev/null\n\t\tfi\n\n\t\t# unlock if license file detected\n\t\ttest -f \"geekbench.license\" && \"$GEEKBENCH_PATH/$GB_CMD\" --unlock \"$(cat geekbench.license)\" > /dev/null 2>&1\n\n\t\t# run the Geekbench test and grep the test results URL given at the end of the test\n\t\tGEEKBENCH_TEST=$(\"$GEEKBENCH_PATH/$GB_CMD\" --upload 2>/dev/null | grep \"https://browser\")\n\n\t\t# ensure the test ran successfully\n\t\tif [ -z \"$GEEKBENCH_TEST\" ]; then\n\t\t\t# detect if CentOS 7 and print a more helpful error message\n\t\t\tif grep -q \"CentOS Linux 7\" /etc/os-release; then\n\t\t\t\techo -e \"\\r\\033[0K CentOS 7 and Geekbench have known issues relating to glibc (see issue #71 for details)\"\n\t\t\tfi\n\t\t\tif [[ -z \"$IPV4_CHECK\" ]]; then\n\t\t\t\t# Geekbench test failed to download because host lacks IPv4 (cdn.geekbench.com = IPv4 only)\n\t\t\t\techo -e \"\\r\\033[0KGeekbench releases can only be downloaded over IPv4. FTP the Geekbench files and run manually.\"\n\t\t\telif [[ $VERSION != *4* && $TOTAL_RAM_RAW -le 1048576 ]]; then\n\t\t\t\t# Geekbench 5/6 test failed with low memory (<=1GB)\n\t\t\t\techo -e \"\\r\\033[0KGeekbench test failed and low memory was detected. Add at least 1GB of SWAP or use GB4 instead (higher compatibility with low memory systems).\"\n\t\t\telif [[ $ARCH != *x86* ]]; then\n\t\t\t\t# if the Geekbench test failed for any other reason, exit cleanly and print error message\n\t\t\t\techo -e \"\\r\\033[0KGeekbench $VERSION test failed. Run manually to determine cause.\"\n\t\t\tfi\n\t\telse\n\t\t\t# if the Geekbench test succeeded, parse the test results URL\n\t\t\tGEEKBENCH_URL=$(echo -e \"$GEEKBENCH_TEST\" | head -1 | awk '{ print $1 }')\n\t\t\tGEEKBENCH_URL_CLAIM=$(echo -e \"$GEEKBENCH_TEST\" | tail -1 | awk '{ print $1 }')\n\t\t\t# sleep a bit to wait for results to be made available on the geekbench website\n\t\t\tsleep 10\n\t\t\t# parse the public results page for the single and multi core geekbench scores\n\t\t\t[[ $VERSION == *4* ]] && GEEKBENCH_SCORES=$($DL_CMD \"$GEEKBENCH_URL\" | grep \"span class='score'\") || \\\n\t\t\t\tGEEKBENCH_SCORES=$($DL_CMD \"$GEEKBENCH_URL\" | grep \"div class='score'\")\n\t\t\t\t\n\t\t\tGEEKBENCH_SCORES_SINGLE=$(echo \"$GEEKBENCH_SCORES\" | awk -v FS=\"(>|<)\" '{ print $3 }' | head -n 1)\n\t\t\tGEEKBENCH_SCORES_MULTI=$(echo \"$GEEKBENCH_SCORES\" | awk -v FS=\"(>|<)\" '{ print $3 }' | tail -n 1)\n\t\t\n\t\t\t# print the Geekbench results\n\t\t\techo -en \"\\r\\033[0K\"\n\t\t\techo -e \"Geekbench $VERSION Benchmark Test:\"\n\t\t\techo -e \"---------------------------------\"\n\t\t\tprintf \"%-15s | %-30s\\n\" \"Test\" \"Value\"\n\t\t\tprintf \"%-15s | %-30s\\n\" \"\" \"\"\n\t\t\tprintf \"%-15s | %-30s\\n\" \"Single Core\" \"$GEEKBENCH_SCORES_SINGLE\"\n\t\t\tprintf \"%-15s | %-30s\\n\" \"Multi Core\" \"$GEEKBENCH_SCORES_MULTI\"\n\t\t\tprintf \"%-15s | %-30s\\n\" \"Full Test\" \"$GEEKBENCH_URL\"\n\n\t\t\tif [[ -n $JSON ]]; then\n\t\t\t\tJSON_RESULT+='{\"version\":'$VERSION',\"single\":'$GEEKBENCH_SCORES_SINGLE',\"multi\":'$GEEKBENCH_SCORES_MULTI\n\t\t\t\tJSON_RESULT+=',\"url\":\"'$GEEKBENCH_URL'\"},'\n\t\t\tfi\n\n\t\t\t# write the geekbench claim URL to a file so the user can add the results to their profile (if desired)\n\t\t\t[ -n \"$GEEKBENCH_URL_CLAIM\" ] && echo -e \"$GEEKBENCH_URL_CLAIM\" >> geekbench_claim.url 2> /dev/null\n\t\tfi\n\tfi\n}\n\n# if the skip geekbench flag was set, skip the system performance test, otherwise test system performance\nif [ -z \"$SKIP_GEEKBENCH\" ]; then\n\t[[ -n $JSON ]] && JSON_RESULT+=\",\\\"geekbench\\\":[\"\n\tif [[ $GEEKBENCH_4 == *True* ]]; then\n\t\tlaunch_geekbench 4\n\tfi\n\n\tif [[ $GEEKBENCH_5 == *True* ]]; then\n\t\tlaunch_geekbench 5\n\tfi\n\n\tif [[ $GEEKBENCH_6 == *True* ]]; then\n\t\tlaunch_geekbench 6\n\tfi\n\t[[ -n $JSON ]] && [[ \"${JSON_RESULT: -1}\" == ',' ]] && JSON_RESULT=\"${JSON_RESULT%,}\"\n\t[[ -n $JSON ]] && JSON_RESULT+=\"]\"\nfi\n\n# finished all tests, clean up all YABS files and exit\necho -e\nrm -rf \"$YABS_PATH\"\n\nYABS_END_TIME=$(date +%s)\n\n# calculate_time_taken\n# Purpose: This method is designed to find the time taken for the completion of a YABS run.\n# Parameters:\n#          1. YABS_END_TIME - time when GB has completed and all files are removed\n#          2. YABS_START_TIME - time when YABS is started\nfunction calculate_time_taken() {\n\tend_time=$1\n\tstart_time=$2\n\n\ttime_taken=$(( end_time - start_time ))\n\tif [ ${time_taken} -gt 60 ]; then\n\t\tmin=$(( time_taken / 60 ))\n\t\tsec=$(( time_taken % 60 ))\n\t\techo \"YABS completed in ${min} min ${sec} sec\"\n\telse\n\t\techo \"YABS completed in ${time_taken} sec\"\n\tfi\n\t[[ -n $JSON ]] && JSON_RESULT+=\",\\\"runtime\\\":{\\\"start\\\":$start_time,\\\"end\\\":$end_time,\\\"elapsed\\\":$time_taken}\"\n}\n\ncalculate_time_taken \"$YABS_END_TIME\" \"$YABS_START_TIME\"\n\nif [[ -n $JSON ]]; then\n\tJSON_RESULT+=\"}\"\n\n\t# write json results to file\n\tif [[ $JSON = *w* ]]; then\n\t\techo \"$JSON_RESULT\" > \"$JSON_FILE\"\n\tfi\n\n\t# send json results\n\tif [[ $JSON = *s* ]]; then\n\t\tIFS=',' read -r -a JSON_SITES <<< \"$JSON_SEND\"\n\t\tfor JSON_SITE in \"${JSON_SITES[@]}\"\n\t\tdo\n\t\t\tif [[ -n $LOCAL_CURL ]]; then\n\t\t\t\tcurl -s -H \"Content-Type:application/json\" -X POST --data ''\"$JSON_RESULT\"'' \"$JSON_SITE\"\n\t\t\telse\n\t\t\t\twget -qO- --post-data=''\"$JSON_RESULT\"'' --header='Content-Type:application/json' \"$JSON_SITE\"\n\t\t\tfi\n\t\tdone\n\tfi\n\n\t# print json result to screen\n\tif [[ $JSON = *j* ]]; then\n\t\techo -e\n\t\techo \"$JSON_RESULT\"\n\tfi\nfi\n\n# reset locale settings\nunset LC_ALL\n"
        }
      ]
    }
  ]
}