{
  "metadata": {
    "timestamp": 1736568196986,
    "page": 37,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jpetazzo/pipework",
      "stars": 4235,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0029296875,
          "content": "*~\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.0654296875,
          "content": "⚠️  **WARNING: this project is not maintained.**\n\nIt was written in the early days of Docker, when people needed a way to\n\"plumb\" Docker containers into arbitrary network topologies. If you want\nto use it today (post-2020), you can, but it's at your own risk.\nSmall contributions (of a few lines) are welcome, but I don't have\nthe time to review and test bigger contributions, so don't expect any\nnew features or significant fixes (for instance, if Docker changes the\nway it handles container networking, this will break, and I will not fix it).\n\nProceed at your own risk! :)\n\n# Pipework\n\n**_Software-Defined Networking for Linux Containers_**\n\nPipework lets you connect together containers in arbitrarily complex scenarios.\nPipework uses cgroups and namespace and works with \"plain\" LXC containers\n(created with `lxc-start`), and with the awesome [Docker](http://www.docker.io/).\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [Things to note](#things-to-note)\n  - [vCenter / vSphere / ESX / ESXi](#vcenter--vsphere--esx--esxi)\n  - [Virtualbox](#virtualbox)\n  - [Docker](#docker)\n- [LAMP stack with a private network between the MySQL and Apache containers](#lamp-stack-with-a-private-network-between-the-mysql-and-apache-containers)\n- [Docker integration](#docker-integration)\n- [Peeking inside the private network](#peeking-inside-the-private-network)\n- [Setting container internal interface](#setting-container-internal-interface)\n- [Setting host interface name](#setting-host-interface-name)\n- [Using a different netmask](#using-a-different-netmask)\n- [Setting a default gateway](#setting-a-default-gateway)\n- [Connect a container to a local physical interface](#connect-a-container-to-a-local-physical-interface)\n- [Use MAC address to specify physical interface](#use-mac-address-to-specify-physical-interface)\n- [Let the Docker host communicate over macvlan interfaces](#let-the-docker-host-communicate-over-macvlan-interfaces)\n- [Wait for the network to be ready](#wait-for-the-network-to-be-ready)\n- [Add the interface without an IP address](#add-the-interface-without-an-ip-address)\n- [Add a dummy interface](#add-a-dummy-interface)\n- [DHCP](#dhcp)\n- [DHCP Options](#dhcp-options)\n- [Specify a custom MAC address](#specify-a-custom-mac-address)\n- [Virtual LAN (VLAN)](#virtual-lan-vlan)\n- [Control routes](#routes)\n- [Support Open vSwitch](#support-open-vswitch)\n- [Support InfiniBand IPoIB](#support-infiniband-ipoib)\n- [Cleanup](#cleanup)\n- [Integrating pipework with other tools](#integrating-pipework-with-other-tools)\n- [About this file](#about-this-file)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n### Things to note\n\n#### vCenter / vSphere / ESX / ESXi\n**If you use vCenter / VSphere / ESX / ESXi,** set or ask your administrator\nto set *Network Security Policies* of the vSwitch as below:\n\n- Promiscuous mode:    **Accept**\n- MAC address changes: **Accept**\n- Forged transmits:    **Accept**\n\nAfter starting the guest OS and creating a bridge, you might also need to\nfine-tune the `br1` interface as follows:\n\n- `brctl stp br1 off` (to disable the STP protocol and prevent the switch\n  from disabling ports)\n- `brctl setfd br1 2` (to reduce the time taken by the `br1` interface to go\n  from *blocking* to *forwarding* state)\n- `brctl setmaxage br1 0`\n\n#### Virtualbox\n**If you use VirtualBox**, you will have to update your VM network settings.\nOpen the settings panel for the VM, go the the \"Network\" tab, pull down the\n\"Advanced\" settings. Here, the \"Adapter Type\" should be `pcnet` (the full\nname is something like \"PCnet-FAST III\"), instead of the default `e1000`\n(Intel PRO/1000). Also, \"Promiscuous Mode\" should be set to \"Allow All\".\n\nIf you don't do that, bridged containers won't work, because the virtual\nNIC will filter out all packets with a different MAC address.  If you are\nrunning VirtualBox in headless mode, the command line equivalent of the above\nis `modifyvm --nicpromisc1 allow-all`.  If you are using Vagrant, you can add\nthe following to the config for the same effect:\n\n```Ruby\nconfig.vm.provider \"virtualbox\" do |v|\n  v.customize ['modifyvm', :id, '--nictype1', 'Am79C973']\n  v.customize ['modifyvm', :id, '--nicpromisc1', 'allow-all']\nend\n```\n\nNote: it looks like some operating systems (e.g. CentOS 7) do not support\n`pcnet` anymore. You might want to use the `virtio-net` (Paravirtualized\nNetwork) interface with those.\n\n\n#### Docker\n\n**Before using Pipework, please ask on the [docker-user mailing list](\nhttps://groups.google.com/forum/#!forum/docker-user) if there is a \"native\"\nway to achieve what you want to do *without* Pipework.**\n\nIn the long run, Docker will allow complex scenarios, and Pipework should\nbecome obsolete.\n\nIf there is really no other way to plumb your containers together with\nthe current version of Docker, then okay, let's see how we can help you!\n\nThe following examples show what Pipework can do for you and your containers.\n\n\n### LAMP stack with a private network between the MySQL and Apache containers\n\nLet's create two containers, running the web tier and the database tier:\n\n    APACHE=$(docker run -d apache /usr/sbin/httpd -D FOREGROUND)\n    MYSQL=$(docker run -d mysql /usr/sbin/mysqld_safe)\n\nNow, bring superpowers to the web tier:\n\n    pipework br1 $APACHE 192.168.1.1/24\n\nThis will:\n\n- create a bridge named `br1` in the docker host;\n- add an interface named `eth1` to the `$APACHE` container;\n- assign IP address 192.168.1.1 to this interface,\n- connect said interface to `br1`.\n\nNow (drum roll), let's do this:\n\n    pipework br1 $MYSQL 192.168.1.2/24\n\nThis will:\n\n- not create a bridge named `br1`, since it already exists;\n- add an interface named `eth1` to the `$MYSQL` container;\n- assign IP address 192.168.1.2 to this interface,\n- connect said interface to `br1`.\n\nNow, both containers can ping each other on the 192.168.1.0/24 subnet.\n\n\n### Docker integration\n\nPipework can resolve Docker containers names. If the container ID that\nyou gave to Pipework cannot be found, Pipework will try to resolve it\nwith `docker inspect`. This makes it even simpler to use:\n\n    docker run -name web1 -d apache\n    pipework br1 web1 192.168.12.23/24\n\n\n### Peeking inside the private network\n\nWant to connect to those containers using their private addresses? Easy:\n\n    ip addr add 192.168.1.254/24 dev br1\n\nVoilà!\n\n\n### Setting container internal interface ##\nBy default pipework creates a new interface `eth1` inside the container. In case you want to change this interface name like `eth2`, e.g., to have more than one interface set by pipework, use:\n\n`pipework br1 -i eth2 ...`\n\n**Note:**: for InfiniBand IPoIB interfaces, the default interface name is `ib0` and not `eth1`.\n\n\n### Setting host interface name ##\nBy default pipework will create a host-side interface with a fixed prefix but random suffix. If you would like to specify this interface name use the `-l` flag (for local):\n\n`pipework br1 -i eth2 -l hostapp1 ...`\n\n\n### Using a different netmask\n\nThe IP addresses given to `pipework` are directly passed to the `ip addr`\ntool; so you can append a subnet size using traditional CIDR notation.\n\nI.e.:\n\n    pipework br1 $CONTAINERID 192.168.4.25/20\n\nDon't forget that all containers should use the same subnet size;\npipework is not clever enough to use your specified subnet size for\nthe first container, and retain it to use it for the other containers.\n\n\n### Setting a default gateway\n\nIf you want *outbound* traffic (i.e. when the containers connects\nto the outside world) to go through the interface managed by\nPipework, you need to change the default route of the container.\n\nThis can be useful in some usecases, like traffic shaping, or if\nyou want the container to use a specific outbound IP address.\n\nThis can be automated by Pipework, by adding the gateway address\nafter the IP address and subnet mask:\n\n    pipework br1 $CONTAINERID 192.168.4.25/20@192.168.4.1\n\n\n### Connect a container to a local physical interface\n\nLet's pretend that you want to run two Hipache instances, listening on real\ninterfaces eth2 and eth3, using specific (public) IP addresses. Easy!\n\n    pipework eth2 $(docker run -d hipache /usr/sbin/hipache) 50.19.169.157/24\n    pipework eth3 $(docker run -d hipache /usr/sbin/hipache) 107.22.140.5/24\n\nNote that this will use `macvlan` subinterfaces, so you can actually put\nmultiple containers on the same physical interface.  If you don't want to\nvirtualize the interface, you can use the `--direct-phys` option to namespace\nan interface exclusively to a container without using a macvlan bridge.\n\n    pipework --direct-phys eth1 $CONTAINERID 192.168.1.2/24\n\nThis is useful for assigning SR-IOV VFs to containers, but be aware of added\nlatency when using the NIC to switch packets between containers on the same host.\n\n\n### Use MAC address to specify physical interface\n\nIn case you want to connect a local physical interface with a specific name inside\nthe container, it will also rename the physical one, this behaviour is not\nidempotent:\n\n    pipework --direct-phys eth1 -i container0 $CONTAINERID 0/0\n    # second call would fail because physical interface eth1 has been renamed\n\nWe can use the interface MAC address to identify the interface the same way\nany time (udev networking rules use a similar method for interfaces persistent\nnaming):\n\n    pipework --direct-phys mac:00:f3:15:4a:42:c8 -i container0 $CONTAINERID 0/0\n\n\n### Let the Docker host communicate over macvlan interfaces\n\nIf you use macvlan interfaces as shown in the previous paragraph, you\nwill notice that the host will not be able to reach the containers over\ntheir macvlan interfaces. This is because traffic going in and out of\nmacvlan interfaces is segregated from the \"root\" interface.\n\nIf you want to enable that kind of communication, no problem: just\ncreate a macvlan interface in your host, and move the IP address from\nthe \"normal\" interface to the macvlan interface.\n\nFor instance, on a machine where `eth0` is the main interface, and has\naddress `10.1.1.123/24`, with gateway `10.1.1.254`, you would do this:\n\n    ip addr del 10.1.1.123/24 dev eth0\n    ip link add link eth0 dev eth0m type macvlan mode bridge\n    ip link set eth0m up\n    ip addr add 10.1.1.123/24 dev eth0m\n    route add default gw 10.1.1.254\n\nThen, you would start a container and assign it a macvlan interface\nthe usual way:\n\n    CID=$(docker run -d ...)\n    pipework eth0 $CID 10.1.1.234/24@10.1.1.254\n\n\n### Wait for the network to be ready\n\nSometimes, you want the extra network interface to be up and running *before*\nstarting your service. A dirty (and unreliable) solution would be to add\na `sleep` command before starting your service; but that could break in\n\"interesting\" ways if the server happens to be a bit slower at one point.\n\nThere is a better option: add the `pipework` script to your Docker image,\nand before starting the service, call `pipework --wait`. It will wait\nuntil the `eth1` interface is present and in `UP` operational state,\nthen exit gracefully.\n\nIf you need to wait on an interface other than eth1, pass the -i flag like\nthis:\n\n    pipework --wait -i ib0\n\n\n### Add the interface without an IP address\n\nIf for some reason you want to set the IP address from within the\ncontainer, you can use `0/0` as the IP address. The interface will\nbe created, connected to the network, and assigned to the container,\nbut without configuring an IP address:\n\n    pipework br1 $CONTAINERID 0/0\n\n\n### Add a dummy interface\n\nIf for some reason you want a dummy interface inside the container, you can add it like any other interface. Just set the host interface to the keyword dummy. All other options - IP, CIDR, gateway - function as normal.\n\n    pipework dummy $CONTAINERID 192.168.21.101/24@192.168.21.1\n\nOf course, a gateway does not mean much in the context of a dummy interface, but there it is.\n\n### DHCP\n\nYou can use DHCP to obtain the IP address of the new interface. Just\nspecify the name of the DHCP client that you want to use instead\non an IP address; for instance:\n\n    pipework eth1 $CONTAINERID dhclient\n\nYou can specify the following DHCP clients:\n\n- dhclient\n- udhcpc\n- dhcpcd\n- dhcp\n\nThe first three are \"normal\" DHCP clients. They have to be installed\non your host for this option to work. The last one works\ndifferently: it will run a DHCP client *in a Docker container*\nsharing its network namespace with your container. This allows\nto use DHCP configuration without worrying about installing the\nright DHCP client on your host. It will use the Docker `busybox`\nimage and its embedded `udhcpc` client.\n\nThe value of $CONTAINERID will be provided to the DHCP client to use\nas the hostname in the DHCP request. Depending on the configuration of\nyour network's DHCP server, this may enable other machines on the network\nto access the container using the $CONTAINERID as a hostname; therefore,\nspecifying $CONTAINERID as a container name rather than a container id\nmay be more appropriate in this use-case.\n\nYou need three things for this to work correctly:\n\n- obviously, a DHCP server (in the example above, a DHCP server should\n  be listening on the network to which we are connected on `eth1`);\n- a DHCP client (either `udhcpc`, `dhclient` or `dhcpcp`) must be installed\n  on your Docker *host* (you don't have to install it in your containers,\n  but it must be present on the host), unless you specify `dhcp` as\n  the client, in which case the Docker `busybox` image should be\n  available;\n- the underlying network must support bridged frames.\n\nThe last item might be particularly relevant if you are trying to\nbridge your containers with a WPA-protected WiFi network. I'm not 100%\nsure about this, but I think that the WiFi access point will drop frames\noriginating from unknown MAC addresses; meaning that you have to go\nthrough extra hoops if you want it to work properly.\n\nIt works fine on plain old wired Ethernet, though.\n\n#### Lease Renewal\n\nAll of the DHCP options - udhcpc, dhcp, dhclient, dhcpcd - exit or are killed by pipework when they are done assigning a lease. This is to prevent zombie processes from existing after a container exits, but the dhcp client still exists.\n\nHowever, if the container is long-running - longer than the life of the lease - then the lease will expire, no dhcp client renews the lease, and the container is stuck without a valid IP address.\n\nTo resolve this problem, you can cause the dhcp client to remain alive. The method depends on the dhcp client you use.\n\n* dhcp: see the next section [DHCP Options](#dhcp-options)\n* dhclient: use DHCP client `dhclient-f`\n* udhcpc: use DHCP client `udhcpc-f`\n* dhcpcd: not yet supported.\n\n\n**Note:** If you use this option *you* will be responsible for finding and killing those dhcp client processes in the future. pipework is a one-time script; it is not intended to manage long-running processes for you.\n\nIn order to find the processes, you can look for pidfiles in the following locations:\n\n* dhcp: see the next section [DHCP Options](#dhcp-options)\n* dhclient: pidfiles in `/var/run/dhclient.$GUESTNAME.pid`\n* udhcpc: pidfiles in `/var/run/udhcpc.$GUESTNAME.pid`\n* dhcpcd: not yet supported\n\n`$GUESTNAME` is the name or ID of the guest as you passed it to pipework on instantiation.\n\n\n### DHCP Options\n\nYou can specify extra DHCP options to be passed to the DHCP client\nby adding them with a colon. For instance:\n\n    pipework eth1 $CONTAINERID dhcp:-f\n\nThis will tell Pipework to setup the interface using the DHCP client\nof the Docker `busybox` image, and pass `-f` as an extra flag to this\nDHCP client. This flag instructs the client to remain in the foreground\ninstead of going to the background. Let's see what this means.\n\n*Without* this flag, a new container is started, in which the DHCP\nclient is executed. The DHCP client obtains a lease, then goes to\nthe background. When it goes to the background, the PID 1 in this\ncontainer exits, causing the whole container to be terminated.\nAs a result, the \"pipeworked\" container has its IP address, but\nthe DHCP client has gone. On the up side, you don't have any\ncleanup to do; on the other, the DHCP lease will not be renewed,\nwhich could be problematic if you have short leases and the\nserver and other clients don't validate their leases before using\nthem.\n\n*With* this flag, a new container is started, it runs the DHCP\nclient just like before; but when it obtains the lease, it\nremains in the foreground. As a result, the lease will be\nproperly renewed. However, when you terminate the \"pipeworked\"\ncontainer, you should also take care of removing the container\nthat runs the DHCP client. This can be seen as an advantage\nif you want to reuse this network stack even if the initial\ncontainer is terminated.\n\n\n### Specify a custom MAC address\n\nIf you need to specify the MAC address to be used (either by the `macvlan`\nsubinterface, or the `veth` interface), no problem. Just add it as the\ncommand-line, as the last argument:\n\n    pipework eth0 $(docker run -d haproxy) 192.168.1.2/24 26:2e:71:98:60:8f\n\nThis can be useful if your network environment requires whitelisting\nyour hardware addresses (some hosting providers do that), or if you want\nto obtain a specific address from your DHCP server. Also, some projects like\n[Orchestrator](https://github.com/cvlc/orchestrator) rely on static\nMAC-IPv6 bindings for DHCPv6:\n\n    pipework br0 $(docker run -d zerorpcworker) dhcp fa:de:b0:99:52:1c\n\n**Note:** if you generate your own MAC addresses, try remember those two\nsimple rules:\n\n- the lowest bit of the first byte should be `0`, otherwise, you are\n  defining a multicast address;\n- the second lowest bit of the first byte should be `1`, otherwise,\n  you are using a globally unique (OUI enforced) address.\n\nIn other words, if your MAC address is `?X:??:??:??:??:??`, `X` should\nbe `2`, `6`, `a`, or `e`. You can check [Wikipedia](\nhttp://en.wikipedia.org/wiki/MAC_address) if you want even more details.\n\nIf you want a consistent MAC address across container restarts, but don't want to have to keep track of the messy MAC addresses, ask pipework to generate an address for you based on a specified string, e.g. the hostname. This guarantees a consistent MAC address:\n\n    pipework eth0 <container> dhcp U:<some_string>\n\npipework will take *some_string* and hash it using MD5. It will then take the first 40 bits of the MD5 hash, add those to the locally administered prefix of 0x02, and create a unique MAC address.\n\nFor example, if your unique string is \"myhost.foo.com\", then the MAC address will **always** be `02:72:6c:cd:9b:8d`.\n\nThis is particularly useful in the case of DHCP, where you might want the container to stop and start, but always get the same address. Most DHCP servers will keep giving you a consistent IP address if the MAC address is consistent.\n\n**Note:**  Setting the MAC address of an IPoIB interface is not supported.\n\n### Virtual LAN (VLAN)\n\nIf you want to attach the container to a specific VLAN, the VLAN ID can be\nspecified using the `[MAC]@VID` notation in the MAC address parameter.\n\n**Note:** VLAN attachment is currently only supported for containers to be\nattached to either an Open vSwitch bridge or a physical interface. Linux\nbridges are currently not supported.\n\nThe following will attach container zerorpcworker to the Open vSwitch bridge\novs0 and attach the container to VLAN ID 10.\n\n    pipework ovsbr0 $(docker run -d zerorpcworker) dhcp @10\n\n### Control Routes\n\nIf you want to add/delete/replace routes in the container, you can run any iproute2 route command via pipework.\n\nAll you have to do is set the interface to be `route`, followed by the container ID or name, followed by the route command.\n\nHere are some examples.\n\n    pipework route $CONTAINERID add 10.0.5.6/24 via 192.168.2.1\n    pipework route $CONTAINERID replace default via 10.2.3.5.78\n\nEverything after the container ID (or name) will be run as an argument to `ip route` inside the container's namespace. Use the iproute2 man page.\n\n### Control Rules\n\nIf you want to add/delete/replace IP rules in the container, you can do the same thing with `ip rule` that you can with\n`ip route`.\n\nSpecify the interface to be `rule`, followed by the container ID or name, followed by the rule command.\n\nHere are some examples, to specify a route table:\n\n    pipework rule $CONTAINERID add from 172.19.0.2/32 table 1\n    pipework rule $CONTAINERID add to 172.19.0.2/32 table 1\n\nNote that for these rules to work you first need to execute the following in your container:\n\n  echo \"1 admin\" >> /etc/iproute2/rt_tables\n\nYou can read more on using route tables, specifically to setup multiple NICs with different default gateways,\nhere: https://kindlund.wordpress.com/2007/11/19/configuring-multiple-default-routes-in-linux/\n\n### Control `tc`\n\nIf you want to use `tc` from within the container namespace, you can do so with the command\n`pipework tc $CONTAINERID <tc_args>`.\n\nExample, to simulate 30% packet loss on `eth0` within the container:\n\n    pipework tc $CONTAINERID qdisc add dev eth0 root netem loss 30%\n\n\n### Support Open vSwitch\n\nIf you want to attach a container to the Open vSwitch bridge, no problem.\n\n    ovs-vsctl list-br\n    ovsbr0\n    pipework ovsbr0 $(docker run -d mysql /usr/sbin/mysqld_safe) 192.168.1.2/24\n\nIf the ovs bridge doesn't exist, it will be automatically created\n\n\n### Support InfiniBand IPoIB\n\nPassing an IPoIB interface to a container is supported.  The IPoIB device is\ncreated as a virtual device, similarly to how macvlan devices work.  The\ninterface also supports setting a partition key for the created virtual device.\n\nThe following will attach a container to ib0\n\n    pipework ib0 $CONTAINERID 10.10.10.10/24\n\nThe following will do the same but connect it to ib0 with pkey 0x8001\n\n    pipework ib0 $CONTAINERID 10.10.10.10/24 @8001\n\n### Gratuitous ARP\n\nIf `arping` is installed, it will be used to send a gratuitous ARP reply\nto the container's neighbors. This can be useful if the container doesn't\nemit any network traffic at all, and seems unreachable (but suddenly becomes\nreachable after it generates some traffic).\n\nNote, however, that Ubuntu/Debian distributions contain two different `arping`\npackages. The one you want is `iputils-arping`.\n\n\n### Cleanup\n\nWhen a container is terminated (the last process of the net namespace exits),\nthe network interfaces are garbage collected. The interface in the container\nis automatically destroyed, and the interface in the docker host (part of the\nbridge) is then destroyed as well.\n\n\n### Integrating pipework with other tools\n\n@dreamcat4 has built an amazing fork of pipework that can be integrated\nwith other tools in the Docker ecosystem, like Compose or Crane.\nIt can be used in \"one shot,\" to create a bunch of network connections\nbetween containers; it can run in the background as a daemon, watching\nthe Docker events API, and automatically invoke pipework when containers\nare started, and it can also expose pipework itself through an API.\n\nFor more info, check the [dreamcat4/pipework](https://hub.docker.com/r/dreamcat4/pipework/)\nimage on the Docker Hub.\n\n\n### About this file\n\nThis README file is currently the only documentation for pipework. When\nupdating it (specifically, when adding/removing/moving sections), please\nupdate the table of contents. This can be done very easily by just running:\n\n    docker-compose up\n\nThis will build a container with `doctoc` and run it to regenerate the\ntable of contents. That's it!\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.0732421875,
          "content": "doctoc:\n  build: doctoc\n  volumes:\n    - .:/src\n  command: /src/README.md\n\n"
        },
        {
          "name": "doctoc",
          "type": "tree",
          "content": null
        },
        {
          "name": "pipework",
          "type": "blob",
          "size": 15.72265625,
          "content": "#!/bin/sh\n# This code should (try to) follow Google's Shell Style Guide\n# (https://google.github.io/styleguide/shell.xml)\nset -e\n\ncase \"$1\" in\n  --wait)\n    WAIT=1\n    ;;\n  --direct-phys)\n    DIRECT_PHYS=1\n    shift\n    ;;\nesac\n\nIFNAME=$1\n\n# default value set further down if not set here\nCONTAINER_IFNAME=\nif [ \"$2\" = \"-i\" ]; then\n  CONTAINER_IFNAME=$3\n  shift 2\nfi\n\nif [ \"$2\" = \"-l\" ]; then\n  LOCAL_IFNAME=$3\n  shift 2\nfi\n\n#inet or inet6\nFAMILY_FLAG=\"-4\"\nif [ \"$2\" = \"-a\" ]; then\n  FAMILY_FLAG=\"-$3\"\n  shift 2\nfi\n\nGUESTNAME=$2\nIPADDR=$3\nMACADDR=$4\n\ncase \"$MACADDR\" in\n  *@*)\n    VLAN=\"${MACADDR#*@}\"\n    VLAN=\"${VLAN%%@*}\"\n    MACADDR=\"${MACADDR%%@*}\"\n    ;;\n  *)\n    VLAN=\n    ;;\nesac\n\n# did they ask to generate a custom MACADDR?\n# generate the unique string\ncase \"$MACADDR\" in\n  U:*)\n    macunique=\"${MACADDR#*:}\"\n    # now generate a 48-bit hash string from $macunique\n    MACADDR=$(echo $macunique|md5sum|sed 's/^\\(..\\)\\(..\\)\\(..\\)\\(..\\)\\(..\\).*$/02:\\1:\\2:\\3:\\4:\\5/')\n   ;;\nesac\n\n\n[ \"$IPADDR\" ] || [ \"$WAIT\" ] || {\n  echo \"Syntax:\"\n  echo \"pipework <hostinterface> [-i containerinterface] [-l localinterfacename] [-a addressfamily] <guest> <ipaddr>/<subnet>[@default_gateway] [macaddr][@vlan]\"\n  echo \"pipework <hostinterface> [-i containerinterface] [-l localinterfacename] <guest> dhcp [macaddr][@vlan]\"\n  echo \"pipework mac:<hostinterface_macaddress> [-i containerinterface] [-l localinterfacename] [-a addressfamily] <guest> <ipaddr>/<subnet>[@default_gateway] [macaddr][@vlan]\"\n  echo \"pipework mac:<hostinterface_macaddress> [-i containerinterface] [-l localinterfacename] <guest> dhcp [macaddr][@vlan]\"\n  echo \"pipework route <guest> <route_command>\"\n  echo \"pipework rule <guest> <rule_command>\"\n  echo \"pipework tc <guest> <tc_command>\"\n  echo \"pipework --wait [-i containerinterface]\"\n  exit 1\n}\n\n# Succeed if the given utility is installed. Fail otherwise.\n# For explanations about `which` vs `type` vs `command`, see:\n# http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/677212#677212\n# (Thanks to @chenhanxiao for pointing this out!)\ninstalled () {\n  command -v \"$1\" >/dev/null 2>&1\n}\n\n# Google Styleguide says error messages should go to standard error.\nwarn () {\n  echo \"$@\" >&2\n}\ndie () {\n  status=\"$1\"\n  shift\n  warn \"$@\"\n  exit \"$status\"\n}\n\nif echo $IFNAME | grep -q '^mac:'; then\n  mac_address=$(echo $IFNAME | cut -c5-)\n  ifmatch=\n  for iftest in /sys/class/net/*; do\n    if [ -f $iftest/address ] && [ \"$mac_address\" = \"$(cat $iftest/address)\" ]; then\n      ifmatch=\"$(basename $iftest)\"\n      break\n    fi\n  done\n\n  if [ -z \"$ifmatch\" ]; then\n    die 1 \"Mac address $mac_address specified for interface but no host interface matched.\"\n  else\n    IFNAME=$ifmatch\n  fi\nfi\n\n# First step: determine type of first argument (bridge, physical interface...),\n# Unless \"--wait\" is set (then skip the whole section)\nif [ -z \"$WAIT\" ]; then\n  if [ -d \"/sys/class/net/$IFNAME\" ]\n  then\n    if [ -d \"/sys/class/net/$IFNAME/bridge\" ]; then\n      IFTYPE=bridge\n      BRTYPE=linux\n    elif installed ovs-vsctl && ovs-vsctl list-br|grep -q \"^${IFNAME}$\"; then\n      IFTYPE=bridge\n      BRTYPE=openvswitch\n    elif [ \"$(cat \"/sys/class/net/$IFNAME/type\")\" -eq 32 ]; then # InfiniBand IPoIB interface type 32\n      IFTYPE=ipoib\n      # The IPoIB kernel module is fussy, set device name to ib0 if not overridden\n      CONTAINER_IFNAME=${CONTAINER_IFNAME:-ib0}\n      PKEY=$VLAN\n    else IFTYPE=phys\n    fi\n  else\n    case \"$IFNAME\" in\n      br*)\n        IFTYPE=bridge\n        BRTYPE=linux\n        ;;\n      ovs*)\n        if ! installed ovs-vsctl; then\n          die 1 \"Need OVS installed on the system to create an ovs bridge\"\n        fi\n        IFTYPE=bridge\n        BRTYPE=openvswitch\n        ;;\n      route*)\n        IFTYPE=route\n        ;;\n      rule*)\n        IFTYPE=rule\n        ;;\n      tc*)\n        IFTYPE=tc\n        ;;\n      dummy*)\n        IFTYPE=dummy\n        ;;\n      *) die 1 \"I do not know how to setup interface $IFNAME.\" ;;\n    esac\n  fi\nfi\n\n# Set the default container interface name to eth1 if not already set\nCONTAINER_IFNAME=${CONTAINER_IFNAME:-eth1}\n\n[ \"$WAIT\" ] && {\n  while true; do\n    # This first method works even without `ip` or `ifconfig` installed,\n    # but doesn't work on older kernels (e.g. CentOS 6.X). See #128.\n    grep -q '^1$' \"/sys/class/net/$CONTAINER_IFNAME/carrier\" && break\n    # This method hopefully works on those older kernels.\n    ip link ls dev \"$CONTAINER_IFNAME\" && break\n    sleep 1\n  done > /dev/null 2>&1\n  exit 0\n}\n\n[ \"$IFTYPE\" = bridge ] && [ \"$BRTYPE\" = linux ] && [ \"$VLAN\" ] && {\n  die 1 \"VLAN configuration currently unsupported for Linux bridge.\"\n}\n\n[ \"$IFTYPE\" = ipoib ] && [ \"$MACADDR\" ] && {\n  die 1 \"MACADDR configuration unsupported for IPoIB interfaces.\"\n}\n\nif grep cgroup2 /proc/filesystems > /dev/null ; then \n  N=0\nelse\n  # Second step: find the guest (for now, we only support LXC containers)\n  while read _ mnt fstype options _; do\n    [ \"$fstype\" != \"cgroup\" ] && continue\n    echo \"$options\" | grep -qw devices || continue\n    CGROUPMNT=$mnt\n  done < /proc/mounts\n\n  [ \"$CGROUPMNT\" ] || {\n    die 1 \"Could not locate cgroup mount point.\"\n  }\n\n  # Try to find a cgroup matching exactly the provided name.\n  M=$(find \"$CGROUPMNT\" -name \"$GUESTNAME\")\n  N=$(echo \"$M\" | wc -l)\n  if [ -z \"$M\" ] ; then\n    N=0\n  fi\nfi\ncase \"$N\" in\n  0)\n    # If we didn't find anything, try to lookup the container with Docker.\n    if installed docker; then\n      RETRIES=3\n      while [ \"$RETRIES\" -gt 0 ]; do\n        DOCKERPID=$(docker inspect --format='{{ .State.Pid }}' \"$GUESTNAME\")\n        DOCKERCID=$(docker inspect --format='{{ .ID }}' \"$GUESTNAME\")\n        DOCKERCNAME=$(docker inspect --format='{{ .Name }}' \"$GUESTNAME\")\n\n        [ \"$DOCKERPID\" != 0 ] && break\n        sleep 1\n        RETRIES=$((RETRIES - 1))\n      done\n\n      [ \"$DOCKERPID\" = 0 ] && {\n        die 1 \"Docker inspect returned invalid PID 0\"\n      }\n\n      [ \"$DOCKERPID\" = \"<no value>\" ] && {\n        die 1 \"Container $GUESTNAME not found, and unknown to Docker.\"\n      }\n    else\n      die 1 \"Container $GUESTNAME not found, and Docker not installed.\"\n    fi\n    ;;\n  1) true ;;\n  2)  # LXC >=3.1.0 returns two entries from the cgroups mount instead of one.\n      echo \"$M\" | grep -q \"lxc\\.monitor\" || die 1 \"Found more than one container matching $GUESTNAME.\"\n      ;;\n  *) die 1 \"Found more than one container matching $GUESTNAME.\" ;;\nesac\n\n# only check IPADDR if we are not in a route mode\n[ \"$IFTYPE\" != route ] && [ \"$IFTYPE\" != rule ] && [ \"$IFTYPE\" != tc ] && {\n  case \"$IPADDR\" in\n\t  # Let's check first if the user asked for DHCP allocation.\n\t  dhcp|dhcp:*)\n\t    # Use Docker-specific strategy to run the DHCP client\n\t    # from the busybox image, in the network namespace of\n\t    # the container.\n\t    if ! [ \"$DOCKERPID\" ]; then\n\t      warn \"You asked for a Docker-specific DHCP method.\"\n\t      warn \"However, $GUESTNAME doesn't seem to be a Docker container.\"\n\t      warn \"Try to replace 'dhcp' with another option?\"\n\t      die 1 \"Aborting.\"\n\t    fi\n\t    DHCP_CLIENT=${IPADDR%%:*}\n\t    ;;\n\t  udhcpc|udhcpc:*|udhcpc-f|udhcpc-f:*|dhcpcd|dhcpcd:*|dhclient|dhclient:*|dhclient-f|dhclient-f:*)\n\t    DHCP_CLIENT=${IPADDR%%:*}\n\t    # did they ask for the client to remain?\n\t    DHCP_FOREGROUND=\n\t    [ \"${DHCP_CLIENT%-f}\" != \"${DHCP_CLIENT}\" ] && {\n\t      DHCP_FOREGROUND=true\n\t    }\n\t    DHCP_CLIENT=${DHCP_CLIENT%-f}\n\t    if ! installed \"$DHCP_CLIENT\"; then\n\t      die 1 \"You asked for DHCP client $DHCP_CLIENT, but I can't find it.\"\n\t    fi\n\t    ;;\n\t  # Alright, no DHCP? Then let's see if we have a subnet *and* gateway.\n\t  */*@*)\n\t    GATEWAY=\"${IPADDR#*@}\" GATEWAY=\"${GATEWAY%%@*}\"\n\t    IPADDR=\"${IPADDR%%@*}\"\n\t    ;;\n\t  # No gateway? We need at least a subnet, anyway!\n\t  */*) : ;;\n\t  # ... No? Then stop right here.\n\t  *)\n\t    warn \"The IP address should include a netmask.\"\n\t    die 1 \"Maybe you meant $IPADDR/24 ?\"\n\t    ;;\n  esac\n}\n\n# If a DHCP method was specified, extract the DHCP options.\nif [ \"$DHCP_CLIENT\" ]; then\n  case \"$IPADDR\" in\n    *:*) DHCP_OPTIONS=\"${IPADDR#*:}\" ;;\n  esac\nfi\n\nif [ \"$DOCKERPID\" ]; then\n  NSPID=$DOCKERPID\nelse\n  NSPID=$(head -n 1 \"$(find \"$CGROUPMNT\" -name \"$GUESTNAME\" | head -n 1)/tasks\")\n  [ \"$NSPID\" ] || {\n    # it is an alternative way to get the pid\n    NSPID=$(lxc-info -n  \"$GUESTNAME\" | grep PID | grep -Eo '[0-9]+')\n    [ \"$NSPID\" ] || {\n      die 1 \"Could not find a process inside container $GUESTNAME.\"\n    }\n  }\nfi\n\n# Check if an incompatible VLAN device already exists\n[ \"$IFTYPE\" = phys ] && [ \"$VLAN\" ] && [ -d \"/sys/class/net/$IFNAME.VLAN\" ] && {\n  ip -d link show \"$IFNAME.$VLAN\" | grep -q \"vlan.*id $VLAN\" || {\n    die 1 \"$IFNAME.VLAN already exists but is not a VLAN device for tag $VLAN\"\n  }\n}\n\n[ ! -d /var/run/netns ] && mkdir -p /var/run/netns\nrm -f \"/var/run/netns/$NSPID\"\nln -s \"/proc/$NSPID/ns/net\" \"/var/run/netns/$NSPID\"\n\n# Check if we need to create a bridge.\n[ \"$IFTYPE\" = bridge ] && [ ! -d \"/sys/class/net/$IFNAME\" ] && {\n  [ \"$BRTYPE\" = linux ] && {\n    (ip link add dev \"$IFNAME\" type bridge > /dev/null 2>&1) || (brctl addbr \"$IFNAME\")\n    ip link set \"$IFNAME\" up\n  }\n  [ \"$BRTYPE\" = openvswitch ] && {\n    ovs-vsctl add-br \"$IFNAME\"\n  }\n}\n\n[ \"$IFTYPE\" != \"route\" ] && [ \"$IFTYPE\" != \"dummy\" ] && [ \"$IFTYPE\" != \"rule\" ] && [ \"$IFTYPE\" != \"tc\" ] && MTU=$(ip link show \"$IFNAME\" | awk '$4==\"mtu\"{print $5}')\n\n# If it's a bridge, we need to create a veth pair\n[ \"$IFTYPE\" = bridge ] && {\n  if [ -z \"$LOCAL_IFNAME\" ]; then\n    LOCAL_IFNAME=\"v${CONTAINER_IFNAME}pl${NSPID}\"\n  fi\n  GUEST_IFNAME=\"v${CONTAINER_IFNAME}pg${NSPID}\"\n  # Does the link already exist?\n  if ip link show \"$LOCAL_IFNAME\" >/dev/null 2>&1; then\n    # link exists, is it in use?\n    if ip link show \"$LOCAL_IFNAME\" up | grep -q \"UP\"; then\n      echo \"Link $LOCAL_IFNAME exists and is up\"\n      exit 1\n    fi\n    # delete the link so we can re-add it afterwards\n    ip link del \"$LOCAL_IFNAME\"\n  fi\n  ip link add name \"$LOCAL_IFNAME\" mtu \"$MTU\" type veth peer name \"$GUEST_IFNAME\" mtu \"$MTU\"\n  case \"$BRTYPE\" in\n    linux)\n      (ip link set \"$LOCAL_IFNAME\" master \"$IFNAME\" > /dev/null 2>&1) || (brctl addif \"$IFNAME\" \"$LOCAL_IFNAME\")\n      ;;\n    openvswitch)\n      if ! ovs-vsctl list-ports \"$IFNAME\" | grep -q \"^${LOCAL_IFNAME}$\"; then\n        ovs-vsctl add-port \"$IFNAME\" \"$LOCAL_IFNAME\" ${VLAN:+tag=\"$VLAN\"} \\\n            -- set Interface \"$LOCAL_IFNAME\" \\\n                external-ids:pipework.interface=\"$LOCAL_IFNAME\" \\\n                external-ids:pipework.bridge=\"$IFNAME\" \\\n                ${DOCKERCID:+external-ids:pipework.containerid=\"$DOCKERCID\"} \\\n                ${DOCKERCNAME:+external-ids:pipework.containername=\"$DOCKERCNAME\"} \\\n                ${NSPID:+external-ids:pipework.nspid=\"$NSPID\"} \\\n                ${VLAN:+external-ids:pipework.vlan=\"$VLAN\"}\n      fi\n      ;;\n  esac\n  ip link set \"$LOCAL_IFNAME\" up\n}\n\n# If it's a physical interface, create a macvlan subinterface\n[ \"$IFTYPE\" = phys ] && {\n  [ \"$VLAN\" ] && {\n    [ ! -d \"/sys/class/net/${IFNAME}.${VLAN}\" ] && {\n      ip link add link \"$IFNAME\" name \"$IFNAME.$VLAN\" mtu \"$MTU\" type vlan id \"$VLAN\"\n    }\n    ip link set \"$IFNAME\" up\n    IFNAME=$IFNAME.$VLAN\n  }\n\n  if [ ! -z \"$DIRECT_PHYS\" ]; then\n    GUEST_IFNAME=$IFNAME\n  else\n    GUEST_IFNAME=ph$NSPID$CONTAINER_IFNAME\n    GUEST_IFNAME=$(echo $GUEST_IFNAME | cut -c 1-15)\n    ip link add link \"$IFNAME\" dev \"$GUEST_IFNAME\" mtu \"$MTU\" type macvlan mode bridge\n  fi\n\n  ip link set \"$IFNAME\" up\n}\n\n# If it's an IPoIB interface, create a virtual IPoIB interface (the IPoIB\n# equivalent of a macvlan device)\n#\n# Note: no macvlan subinterface nor Ethernet bridge can be created on top of an\n# IPoIB interface. InfiniBand is not Ethernet. IPoIB is an IP layer on top of\n# InfiniBand, without an intermediate Ethernet layer.\n[ \"$IFTYPE\" = ipoib ] && {\n  GUEST_IFNAME=\"${IFNAME}.${NSPID}\"\n\n  # If a partition key is provided, use it\n  [ \"$PKEY\" ] && {\n    GUEST_IFNAME=\"${IFNAME}.${PKEY}.${NSPID}\"\n    PKEY=\"pkey 0x$PKEY\"\n  }\n\n  ip link add link \"$IFNAME\" name \"$GUEST_IFNAME\" type ipoib $PKEY\n  ip link set \"$IFNAME\" up\n}\n\n# If its a dummy interface, create a dummy interface.\n[ \"$IFTYPE\" = dummy ] && {\n  GUEST_IFNAME=du$NSPID$CONTAINER_IFNAME\n  ip link add dev \"$GUEST_IFNAME\" type dummy\n}\n\n# If the `route` command was specified ...\nif [ \"$IFTYPE\" = route ]; then\n  # ... discard the first two arguments and pass the rest to the route command.\n  shift 2\n  ip netns exec \"$NSPID\" ip route \"$@\"\nelif [ \"$IFTYPE\" = rule ] ; then\n  shift 2\n  ip netns exec \"$NSPID\" ip rule \"$@\"\nelif [ \"$IFTYPE\" = tc ] ; then\n  shift 2\n  ip netns exec \"$NSPID\" tc \"$@\"\nelse\n  # Otherwise, run normally.\n  if command -v iw > /dev/null && iw dev | awk '$1==\"Interface\"{print $2}' | grep $GUEST_IFNAME > /dev/null; then\n    iw phy $(iw dev | grep -B 1 $GUEST_IFNAME | grep phy# | sed 's/#//g') set netns $NSPID\n  else\n    ip link set \"$GUEST_IFNAME\" netns \"$NSPID\"\n  fi\n  ip netns exec \"$NSPID\" ip link set \"$GUEST_IFNAME\" name \"$CONTAINER_IFNAME\"\n  [ \"$MACADDR\" ] && ip netns exec \"$NSPID\" ip link set dev \"$CONTAINER_IFNAME\" address \"$MACADDR\"\n\n\t# When using any of the DHCP methods, we start a DHCP client in the\n\t# network namespace of the container. With the 'dhcp' method, the\n\t# client used is taken from the Docker busybox image (therefore\n\t# requiring no specific client installed on the host). Other methods\n\t# use a locally installed client.\n\tcase \"$DHCP_CLIENT\" in\n\t  dhcp)\n\t    docker run -d --net container:$GUESTNAME --cap-add NET_ADMIN \\\n\t           busybox udhcpc -i \"$CONTAINER_IFNAME\" -x \"hostname:$GUESTNAME\" \\\n\t           $DHCP_OPTIONS \\\n\t           >/dev/null\n\t    ;;\n\t  udhcpc)\n\t    DHCP_Q=\"-q\"\n\t    [ \"$DHCP_FOREGROUND\" ] && {\n\t      DHCP_OPTIONS=\"$DHCP_OPTIONS -f\"\n\t    }\n\t    ip netns exec \"$NSPID\" \"$DHCP_CLIENT\" -qi \"$CONTAINER_IFNAME\" \\\n\t                                          -x \"hostname:$GUESTNAME\" \\\n\t                                          -p \"/var/run/udhcpc.$GUESTNAME.pid\" \\\n\t                                          $DHCP_OPTIONS\n\t    [ ! \"$DHCP_FOREGROUND\" ] && {\n\t      rm \"/var/run/udhcpc.$GUESTNAME.pid\"\n\t    }\n\t    ;;\n\t  dhclient)\n\t    ip netns exec \"$NSPID\" \"$DHCP_CLIENT\" \"$CONTAINER_IFNAME\" \\\n\t                                          -pf \"/var/run/dhclient.$GUESTNAME.pid\" \\\n\t                                          -lf \"/etc/dhclient/dhclient.$GUESTNAME.leases\" \\\n\t                                          $DHCP_OPTIONS\n\t    # kill dhclient after get ip address to prevent device be used after container close\n\t    [ ! \"$DHCP_FOREGROUND\" ] && {\n\t      kill \"$(cat \"/var/run/dhclient.$GUESTNAME.pid\")\"\n\t      rm \"/var/run/dhclient.$GUESTNAME.pid\"\n\t    }\n\t    ;;\n\t  dhcpcd)\n\t    ip netns exec \"$NSPID\" \"$DHCP_CLIENT\" -q \"$CONTAINER_IFNAME\" -h \"$GUESTNAME\"\n\t    ;;\n\t  \"\")\n\t    # Note: expected busybox ipcalc! CK\n\t    if installed busybox; then\n\t      eval $(busybox ipcalc -b $IPADDR)\n\t      ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" addr add \"$IPADDR\" brd \"$BROADCAST\" dev \"$CONTAINER_IFNAME\"\n\t    else\n\t      ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" addr add \"$IPADDR\" dev \"$CONTAINER_IFNAME\"\n\t    fi\n\n\t    [ \"$GATEWAY\" ] && {\n\t      ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" route delete default >/dev/null 2>&1 && true\n\t    }\n\t    ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" link set \"$CONTAINER_IFNAME\" up\n\t    [ \"$GATEWAY\" ] && {\n\t      ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" route get \"$GATEWAY\" >/dev/null 2>&1 || \\\n\t      ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" route add \"$GATEWAY/32\" dev \"$CONTAINER_IFNAME\"\n\t      ip netns exec \"$NSPID\" ip \"$FAMILY_FLAG\" route replace default via \"$GATEWAY\" dev \"$CONTAINER_IFNAME\"\n\t    }\n\t    ;;\n\tesac\n\n  # Give our ARP neighbors a nudge about the new interface\n  if installed arping; then\n    IPADDR=$(echo \"$IPADDR\" | cut -d/ -f1)\n    ip netns exec \"$NSPID\" arping -c 1 -A -I \"$CONTAINER_IFNAME\" \"$IPADDR\" > /dev/null 2>&1 || true\n  else\n    echo \"Warning: arping not found; interface may not be immediately reachable\"\n  fi\nfi\n# Remove NSPID to avoid `ip netns` catch it.\nrm -f \"/var/run/netns/$NSPID\"\n\n# vim: set tabstop=2 shiftwidth=2 softtabstop=2 expandtab :\n"
        },
        {
          "name": "pipework.spec",
          "type": "blob",
          "size": 0.8076171875,
          "content": "Name: pipework\nVersion: 20150123\nRelease: 1%{?dist}\nSummary: Software-Defined Networking for Linux Containers\nLicense: Apache License, Version 2.0\nURL: https://github.com/jpetazzo/pipework\nSource0: https://github.com/jpetazzo/pipework/archive/master.zip\n\nBuildArch: noarch\nRequires: /bin/sh\nRequires: iproute\nRequires: docker-io\n\n%description\nPipework lets you connect together containers in arbitrarily complex scenarios.\nPipework uses cgroups and namespace and works with \"plain\" LXC containers\n(created with lxc-start), and with the awesome Docker.\n\n%prep\n%setup -q -n pipework-master\n\n%install\nrm -rf $RPM_BUILD_ROOT\nmkdir -p $RPM_BUILD_ROOT/usr/bin\ninstall -m 755 pipework $RPM_BUILD_ROOT/usr/bin/pipework\n\n%files\n/usr/bin/pipework\n\n%changelog\n* Fri Jan 23 2015 Oleg Gashev <oleg@gashev.net> - 20150123\n- Initial package.\n"
        }
      ]
    }
  ]
}