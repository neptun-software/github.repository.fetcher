{
  "metadata": {
    "timestamp": 1736568506871,
    "page": 502,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "complexorganizations/wireguard-manager",
      "stars": 1700,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "code_of_conduct.md",
          "type": "blob",
          "size": 6.1005859375,
          "content": "# Citizen Code of Conduct\n\n## 1. Purpose\n\nThis repository's primary goal is to be inclusive to the most significant number of contributors, with the most varied and diverse backgrounds possible. As such, we are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, ability, ethnicity, socioeconomic status, and religion (or lack thereof).\n\nThis code of conduct outlines our expectations for all those who participate in our community, as well as the consequences for unacceptable behavior.\n\nWe invite all those who participate in this repository to help us create safe and positive experiences.\n\n## 2. Open [Source/Culture/Tech] Citizenship\n\nA supplemental goal of this Code of Conduct is to increase open [source/culture/tech] citizenship by encouraging participants to recognize and strengthen the relationships between our actions and their effects on our community.\n\nCommunities mirror the societies in which they exist, and affirmative action is essential to counteract the many forms of inequality and abuses of power in society.\n\nIf you see someone who is making an extra effort to ensure our community is welcoming, friendly, and encourages all participants to contribute to the fullest extent, we want to know.\n\n## 3. Expected Behavior\n\nThe following behaviors are expected and requested of all community members:\n\n- Participate authentically and actively. In doing so, you contribute to the health and longevity of this community.\n- Exercise consideration and respect in your speech and actions.\n- Attempt collaboration before conflict.\n- Refrain from demeaning, discriminatory, or harassing behavior and speech.\n- Be mindful of your surroundings and your fellow participants. Alert community leaders if you notice a dangerous situation, someone in distress, or violations of this Code of Conduct, even if they seem inconsequential.\n- Remember that community event venues may be shared with members of the public; please be respectful to all patrons of these locations.\n\n## 4. Unacceptable Behavior\n\nThe following behaviors are considered harassment and are unacceptable within our community:\n\n- Violence, threats of violence or violent language directed against another person.\n- Sexist, racist, homophobic, transphobic, ableist, or otherwise discriminatory jokes and language.\n- Posting or displaying sexually explicit or violent material.\n- Posting or threatening to post other people's personally identifying information (\"doxing\").\n- Personal insults, particularly those related to gender, sexual orientation, race, religion, or disability.\n- Inappropriate photography or recording.\n- Inappropriate physical contact. You should have someone's consent before touching them.\n- Unwelcome sexual attention. This includes sexualized comments or jokes, inappropriate touching, groping, and unwelcome sexual advances.\n- Deliberate intimidation, stalking or following (online or in-person).\n- Advocating for, or encouraging, any of the above behavior.\n- Sustained disruption of community events, including talks and presentations.\n\n## 5. Weapons Policy\n\nNo weapons will be allowed at these repository events, community spaces, or in other areas covered by the scope of this Code of Conduct. Weapons include but are not limited to guns, explosives (including fireworks), and large knives such as those used for hunting or display and any other item used to cause injury or harm to others. Anyone seen in possession of one of these items will be asked to leave immediately, and will only be allowed to return without the weapon. Community members are further expected to comply with all state and local laws on this matter.\n\n## 6. Consequences of Unacceptable Behavior\n\nUnacceptable behavior from any community member, including sponsors and those with decision-making authority, will not be tolerated.\n\nAnyone asked to stop unacceptable behavior is expected to comply immediately.\n\nIf a community member engages in unacceptable behavior, the community organizers may take any action they deem appropriate, including a temporary ban or permanent expulsion from the community without warning (and without a refund in the case of a paid event).\n\n## 7. Reporting Guidelines\n\nIf you are subject to or witness unacceptable behavior, or have any other concerns, please notify a community organizer as soon as possible. support@complexorganizations.com.\n\nAdditionally, community organizers are available to help community members engage with local law enforcement or to help otherwise those experiencing unacceptable behavior feel safe. In the context of in-person events, organizers will also provide escorts as desired by the person experiencing distress.\n\n## 8. Addressing Grievances\n\nIf you feel you have been falsely or unfairly accused of violating this Code of Conduct, you should notify complexorganizations with a concise description of your grievance. Your grievance will be handled following our existing governing policies.\n\n## 9. Scope\n\nWe expect all community participants (contributors, paid or otherwise; sponsors; and other guests) to abide by this Code of Conduct in all community venues--online and in-person--as well as in all one-on-one communications about community business.\n\nThis code of conduct and its related procedures also applies to unacceptable behavior occurring outside the scope of community activities when such action can adversely affect the safety and well-being of community members.\n\n## 10. Contact info\n\nsupport@complexorganizations.com\n\n## 11. License and attribution\n\nThe Citizen Code of Conduct is distributed by [Stumptown Syndicate](http://stumptownsyndicate.org) under a [Creative Commons Attribution-ShareAlike license](http://creativecommons.org/licenses/by-sa/3.0/).\n\nPortions of text derived from the [Django Code of Conduct](https://www.djangoproject.com/conduct/) and the [Geek Feminism Anti-Harassment Policy](http://geekfeminism.wikia.com/wiki/Conference_anti-harassment/Policy).\n\n_Revision 2.3. Posted 6 March 2017._\n\n_Revision 2.2. Posted 4 February 2016._\n\n_Revision 2.1. Posted 23 June 2014._\n\n_Revision 2.0, adopted by the [Stumptown Syndicate](http://stumptownsyndicate.org) board on 10 January 2013. Posted 17 March 2013._\n"
        },
        {
          "name": "license.md",
          "type": "blob",
          "size": 1.1484375,
          "content": "**MIT License**\n\n**Copyright (c) 2023 ComplexOrganizations**\n\nThis license grants everyone a free permission to obtain, use, modify, and distribute this software, referred to as the \"Software,\" along with its documentation. This is allowed without any restrictions, encompassing but not limited to the rights for using, copying, modifying, merging, publishing, distributing, sublicensing, and/or selling copies of the Software. It also permits the Software to be provided to other individuals under these terms.\n\nThese conditions must be followed:\n\n- Every distribution of the Software or its substantial portions must include the above copyright notice and this permission notice.\n\n**Disclaimer:**\n\nThe Software is provided \"as is,\" without any warranty of any kind, either expressed or implied. This includes, but is not limited to, implied warranties of merchantability and fitness for a particular purpose. The authors or copyright holders bear no liability for any claims, damages, or other liabilities, whether in an action of contract, tort or otherwise, that arise from, are related to, or are connected with the Software or the use or other dealings in the Software.\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 25.451171875,
          "content": "# WireGuard-Manager: Secure Your Network 💻 🖥!\n\n## 🔰 Introduction\n\nWelcome to WireGuard-Manager, your solution for setting up WireGuard, a cutting-edge VPN protocol. WireGuard is known for its speed, security, and ease of use, making it an ideal choice for both personal and professional VPN needs. This tool is designed to simplify the installation and management of WireGuard, ensuring a secure and efficient networking experience.\n\n## Quality and Reliability\n\n### Project Information and Status\n\n- **Latest Releases**: Stay on top of our newest versions:\n  [![Latest Release](https://img.shields.io/github/v/release/complexorganizations/wireguard-manager)](https://github.com/complexorganizations/wireguard-manager/releases/latest)\n\n- **Monthly App Release**: Track our regular monthly releases:\n  [![Monthly App Release](https://github.com/complexorganizations/wireguard-manager/actions/workflows/monthly-application-release.yml/badge.svg)](https://github.com/complexorganizations/wireguard-manager/actions/workflows/monthly-application-release.yml)\n\n### Build Statuses\n\n- **Code Quality Assurance**: Verified by ShellCheck for reliability:\n  [![ShellCheck WireGuard Manager](https://github.com/complexorganizations/wireguard-manager/actions/workflows/shell-check-wireguard-manager.yml/badge.svg)](https://github.com/complexorganizations/wireguard-manager/actions/workflows/shell-check-wireguard-manager.yml)\n\n- **Blocked Hosts**: Monitor the status of blocked host updates:\n  [![Blocked Hosts Update Status](https://github.com/complexorganizations/wireguard-manager/actions/workflows/auto-update-blocked-hosts.yaml/badge.svg)](https://github.com/complexorganizations/wireguard-manager/actions/workflows/auto-update-blocked-hosts.yaml)\n\n- **Named Cache**: Check updates for named cache:\n  [![Named Cache Update Status](https://github.com/complexorganizations/wireguard-manager/actions/workflows/auto-update-named-cache.yml/badge.svg)](https://github.com/complexorganizations/wireguard-manager/actions/workflows/auto-update-named-cache.yml)\n\n- **Software Updates**: Keep track of the latest software builds:\n  [![Software Build Status](https://github.com/complexorganizations/wireguard-manager/actions/workflows/build-latest-version.yml/badge.svg)](https://github.com/complexorganizations/wireguard-manager/actions/workflows/build-latest-version.yml)\n\n### Contribution and Issues\n\n- **Open Issues Tracking**: View and address current open issues:\n  [![Open Issues](https://img.shields.io/github/issues/complexorganizations/wireguard-manager)](https://github.com/complexorganizations/wireguard-manager/issues)\n\n- **Contribution Opportunities**: Dive into open pull requests and contribute:\n  [![Active Pull Requests](https://img.shields.io/github/issues-pr/complexorganizations/wireguard-manager)](https://github.com/complexorganizations/wireguard-manager/pulls)\n\n### Licensing\n\n- **Project License**: Our work is under the Apache 2.0 License:\n  [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://github.com/complexorganizations/wireguard-manager/blob/main/license.md)\n\n## ✊ Show Your Support\n\nIf you've found this project useful, please consider giving it a star and forking it. Your support is greatly appreciated!\n\n## 🤷 What is VPN?\n\nA Virtual Private Network (VPN) allows users to send and receive data through shared or public networks as if their computing devices were directly connected to the private network. Thus, applications running on an end-system (PC, smartphone, etc.) over a VPN may benefit from individual network features, protection, and management. Encryption is a standard aspect of a VPN connection but not an intrinsic one.\n\n## 📶 What is WireGuard?\n\nWireGuard is a straightforward yet fast and modern VPN that utilizes state-of-the-art cryptography. It aims to be faster, simpler, leaner, and more useful than IPsec while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general-purpose VPN for running on embedded interfaces and super computers alike, fit for many circumstances. Initially released for the Linux kernel, it is now cross-platform (Windows, macOS, BSD, iOS, Android) and widely deployable. It is currently under a massive development, but it already might be regarded as the most secure, most comfortable to use, and the simplest VPN solution in the industry.\n\n## Why WireGuard-Manager?\n\n- **Security First**: With top-notch encryption and privacy features.\n- **User-Friendly**: Easy to install and manage, regardless of your tech-savviness.\n- **High Performance**: Enjoy fast and reliable connections.\n- **Open Source**: Built and improved by the community.\n\n## ⛳ Goals\n\n- Robust and modern security as a standard.\n- Minimal configuration with essential management tools.\n- Optimal performance for both low-latency and high-bandwidth operations.\n- Simplified command-line interface for easy integration with system networking.\n\n## 🌲 Prerequisite\n\n- Supported on a variety of systems including Alma, Alpine, Arch, CentOS, Debian, Fedora, FreeBSD, Kali, Mint, Manjaro, Neon, Oracle, Pop, Raspbian, RHEL, Rocky, Ubuntu, and more.\n- Requires Linux Kernel 3.1 or newer.\n- Superuser access or a user account with `sudo` privileges is necessary.\n\n## 🚦 Getting Started\n\n1. **Installation**: Simple and quick installation process.\n2. **Configuration**: Easy-to-follow configuration steps.\n3. **Management**: User-friendly interface for managing your VPN.\n\n## Installation Guide\n\nhttps://github.com/complexorganizations/wireguard-manager/assets/102563715/dd539835-2c30-4146-b4f8-940329aa6070\n\n## 🐧 Installation\n\nTo ensure the successful installation of the WireGuard Manager script on various Linux systems, it's crucial to have `curl` and `bash` installed. Here's an expanded installation guide that includes instructions for installing `curl` and `bash` on different Linux distributions:\n\n### Installing `curl` & `bash` & `resolvconf` on Linux Systems\n\n#### Debian/Ubuntu-based Systems (e.g., Ubuntu, Debian, Linux Mint):\n\n```bash\nsudo apt update\nsudo apt install curl bash resolvconf\n```\n\n#### Red Hat-based Systems (e.g., CentOS, RHEL, Fedora):\n\n```bash\nsudo yum install curl bash resolvconf\n```\n\nor\n\n```bash\nsudo dnf install curl bash resolvconf\n```\n\n#### Arch-based Systems (e.g., Arch Linux, Manjaro):\n\n```bash\nsudo pacman -Sy curl bash resolvconf\n```\n\n#### Alpine Linux:\n\n```bash\nsudo apk update\nsudo apk add curl bash resolvconf\n```\n\n#### Other Distributions:\n\nFor other Linux distributions, you can use the package manager specific to that distribution to install `curl` & `bash` & `resolvconf`. The package names may vary slightly.\n\n### Installing WireGuard Manager Script\n\nNow that you have `curl` and `bash` installed, you can proceed with installing the WireGuard Manager script using the provided instructions:\n\n1. First, use `curl` to download the script and save it in `/usr/local/bin/`:\n\n   ```bash\n   curl https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/wireguard-manager.sh --create-dirs -o /usr/local/bin/wireguard-manager.sh\n   ```\n\n2. Next, make the script user executable:\n\n   ```bash\n   chmod +x /usr/local/bin/wireguard-manager.sh\n   ```\n\n3. Finally, execute the script:\n\n   ```bash\n   bash /usr/local/bin/wireguard-manager.sh\n   ```\n\n### Connecting to WireGuard Interface\n\nIn your `/etc/wireguard/clients` directory, you will find `.conf` files. These are the peer configuration files. Download them from your WireGuard Interface and connect using your favorite WireGuard Peer.\n\n## 🔑 Usage\n\n```md\nusage: bash /usr/local/bin/wireguard-manager.sh # --install\n  --install     Installs the WireGuard interface on your system\n  --start       Starts the WireGuard interface if it's not already running\n  --stop        Stops the WireGuard interface if it's currently running\n  --restart     Restarts the WireGuard interface\n  --list        Lists all the peers currently connected to the WireGuard interface\n  --add         Adds a new peer to the WireGuard interface\n  --remove      Removes a specified peer from the WireGuard interface\n  --reinstall   Reinstalls the WireGuard interface, keeping the current configuration\n  --uninstall   Uninstalls the WireGuard interface from your system\n  --update      Updates the WireGuard Manager to the latest version\n  --ddns        Updates the IP address of the WireGuard interface using Dynamic DNS\n  --backup      Creates a backup of your current WireGuard configuration\n  --restore     Restores the WireGuard configuration from a previous backup\n  --purge       Removes all peers from the WireGuard interface\n  --help        Displays this usage guide\n```\n\n## 🥰 Features\n\n- Seamless installation and configuration of WireGuard Interface\n- Convenient backup and restoration of WireGuard\n- Automatic expiration of peer configurations\n- Support for both IPv4 and IPv6, with leak protection\n- Variety of public DNS options available for peers\n- Option to use a self-hosted resolver with Unbound for DNS leak prevention and DNSSEC support\n- Effortless management of Nftables rules and forwarding\n- Easy removal and uninstallation of WireGuard Interface\n- Mandatory preshared-key for an additional layer of security\n- Numerous other minor features for enhanced user experience\n\n## 💡 Configuration Options\n\n- `PRIVATE_SUBNET_V4_SETTINGS`: This defines the private IPv4 subnet used within the VPN. The default is `10.0.0.0/8`, a standard private IP range.\n- `PRIVATE_SUBNET_V6_SETTINGS`: This sets the private IPv6 subnet. The default `fd00:00:00::0/8` is a typical private IPv6 range.\n- `SERVER_HOST_V4_SETTINGS`: This is used to detect the public IPv4 address of the server, crucial for establishing connections from outside the local network.\n- `SERVER_HOST_V6_SETTINGS`: This is the IPv6 counterpart to the previous setting, used for detecting the server's public IPv6 address.\n- `SERVER_PUB_NIC_SETTINGS`: This determines the local public network interface using the `ip` command, essential for server communication on the public network.\n- `SERVER_PORT_SETTINGS`: This specifies the default public port (`51820`) for the WireGuard interface, the port through which VPN traffic will pass.\n- `NAT_CHOICE_SETTINGS`: This configures the use of the VPN tunnel's keep-alive feature, which helps keep the connection active.\n- `MTU_CHOICE_SETTINGS`: This sets the Maximum Transmission Unit (MTU) for WireGuard peers, impacting the size of packets transmitted over the network.\n- `SERVER_HOST_SETTINGS`: This is a general setting for defining server-specific configurations.\n- `CLIENT_ALLOWED_IP_SETTINGS`: This defines the IP range allowed for clients connecting to the VPN, restricting which devices can connect.\n- `AUTOMATIC_UPDATES_SETTINGS`: This likely relates to whether the system will automatically update software or configurations.\n- `AUTOMATIC_BACKUP_SETTINGS`: This pertains to the automatic backup of system configurations or data.\n- `DNS_PROVIDER_SETTINGS`: This involves setting up a DNS provider for the network. If you're not using Unbound, you'll need to specify another DNS service.\n- `CONTENT_BLOCKER_SETTINGS`: This might relate to settings for blocking certain types of content through the network.\n- `CLIENT_NAME`: This is the name assigned to a WireGuard peer (client) in the VPN.\n- `AUTOMATIC_CONFIG_REMOVER`: This is possibly a setting to automatically remove certain configurations after they are no longer needed or after a set period.\n\n## 👉👈 Compatibility with Linux Distributions\n\n| Operating System    | i386 Support | amd64 Support | armhf Support | arm64 Support |\n| ------------------- | ------------ | ------------- | ------------- | ------------- |\n| Ubuntu 14 and below | No           | No            | No            | No            |\n| Ubuntu 16 and above | Yes          | Yes           | Yes           | Yes           |\n| Debian 7 and below  | No           | No            | No            | No            |\n| Debian 8 and above  | Yes          | Yes           | Yes           | Yes           |\n| CentOS 6 and below  | No           | No            | No            | No            |\n| CentOS 7 and above  | Yes          | Yes           | Yes           | Yes           |\n| Fedora 29 and below | No           | No            | No            | No            |\n| Fedora 30 and above | Yes          | Yes           | Yes           | Yes           |\n| RedHat 6 and below  | No           | No            | No            | No            |\n| RedHat 7 and above  | Yes          | Yes           | Yes           | Yes           |\n| Kali 1.0 and below  | No           | No            | No            | No            |\n| Kali 1.1 and above  | Yes          | Yes           | Yes           | Yes           |\n| Arch Linux          | Yes          | Yes           | Yes           | Yes           |\n| Raspbian            | Yes          | Yes           | Yes           | Yes           |\n| PopOS               | Yes          | Yes           | Yes           | Yes           |\n| Manjaro             | Yes          | Yes           | Yes           | Yes           |\n| Mint                | Yes          | Yes           | Yes           | Yes           |\n| AlmaLinux           | Yes          | Yes           | Yes           | Yes           |\n| Alpine              | Yes          | Yes           | Yes           | Yes           |\n| FreeBSD             | Yes          | Yes           | Yes           | Yes           |\n| KDE Neon            | Yes          | Yes           | Yes           | Yes           |\n| Rocky Linux         | Yes          | Yes           | Yes           | Yes           |\n| Oracle Linux        | Yes          | Yes           | Yes           | Yes           |\n\n## ☁️ Compatibility with Cloud Providers\n\n| Cloud           | Supported |\n| --------------- | --------- |\n| AWS             | Yes       |\n| Google Cloud    | Yes       |\n| Linode          | Yes       |\n| Digital Ocean   | Yes       |\n| Vultr           | Yes       |\n| Microsoft Azure | Yes       |\n| OpenStack       | Yes       |\n| Rackspace       | Yes       |\n| Scaleway        | Yes       |\n| EuroVPS         | Yes       |\n| Hetzner Cloud   | No        |\n| Strato          | No        |\n\n## 🛡️ Compatibility with Virtualization\n\n| Virtualization | Supported |\n| -------------- | --------- |\n| KVM            | Yes       |\n| None           | Yes       |\n| Qemu           | Yes       |\n| LXC            | Yes       |\n| Microsoft      | Yes       |\n| Vmware         | Yes       |\n| OpenVZ         | No        |\n| Docker         | No        |\n| WSL            | No        |\n\n## 💻 Compatibility with Linux Kernel\n\n| Kernel                     | Compatibility |\n| -------------------------- | ------------- |\n| Linux Kernel 3.0 and below | No            |\n| Linux Kernel 3.1 and above | Yes           |\n\n## 🙋 Frequently Asked Questions\n\n**Which hosting providers do you recommend?**\n\n- **Google Cloud**: Provides global locations and IPv4 support, with prices starting at $3.50/month. [Visit Google Cloud](https://cloud.google.com)\n- **Amazon Web Services (AWS)**: Offers global locations and IPv4 support, with plans starting from $5.00/month. [Visit AWS](https://aws.amazon.com)\n- **Microsoft Azure**: Features worldwide locations and IPv4 support, with plans beginning at $5.00/month. [Visit Azure](https://azure.microsoft.com)\n- **Linode**: Includes global locations, supports both IPv4 & IPv6, starting at $5.00/month. [Visit Linode](https://www.linode.com)\n- **Vultr**: Provides worldwide locations, supports IPv4 & IPv6, with prices starting at $3.50/month. [Visit Vultr](https://www.vultr.com)\n\n**Which WireGuard clients do you recommend?**\n\n- **Windows**: You can download WireGuard from their [official website](https://www.wireguard.com/install).\n- **Android**: WireGuard is available on the [Google Play Store](https://play.google.com/store/apps/details?id=com.wireguard.android).\n- **macOS**: You can download WireGuard from the [Mac App Store](https://itunes.apple.com/us/app/wireguard/id1451685025).\n- **iOS**: WireGuard is available on the [App Store](https://itunes.apple.com/us/app/wireguard/id1441195209).\n\n## Additional Information\n\n**Where can I access comprehensive WireGuard documentation?**\n\n- The [WireGuard Manual](https://www.wireguard.com) provides detailed information on all available options.\n\n**How can I install WireGuard without interactive prompts for a headless installation?**\n\n- Execute the command: `./wireguard-manager.sh --install`\n\n**Are there any alternatives to self-hosting a VPN?**\n\n- Yes, [CloudFlare Warp](https://1.1.1.1) is a viable alternative.\n\n**Why is all the code centralized in one place?**\n\n- Consider it like a universal remote: it's more efficient to have a single device (or codebase) that performs all functions than having multiple specialized ones.\n\n**Which port and protocol does WireGuard require?**\n\n- You need to forward your chosen port or the default port `51820` using the UDP protocol.\n\n**Do I need to forward any ports for Unbound?**\n\n- No, port forwarding isn't necessary for Unbound as DNS traffic is routed through the VPN (`port 53`).\n\n**What does the content blocker restrict?**\n\n- The content blocker restricts ads, trackers, malware, and phishing attempts.\n\n**What information is collected and how is it used?**\n\n- No logs or data are collected or retained. All operations are performed within the system, with no external log transmission.\n\n## Setting Up Your Own VPN Server\n\nTo set up your own VPN server, you will need the following items:\n\n### Raspberry Pi 5 Setup Components\n\n- **Raspberry Pi 5**: [View Product](https://www.raspberrypi.com/products/raspberry-pi-5/)\n- **Raspberry Pi Case**: [View Product](https://www.raspberrypi.com/products/raspberry-pi-5-case/)\n- **Raspberry Pi Active Cooler**: [View Product](https://www.raspberrypi.com/products/active-cooler)\n- **Raspberry Pi USB-C Power Supply**: [View Product](https://www.raspberrypi.com/products/27w-power-supply/)\n- **Micro SD Card**: [View on Amazon](https://www.amazon.com/dp/B06XWMQ81P)\n- **Ethernet Cable**: [View on Amazon](https://www.amazon.com/dp/B00N2VIALK)\n- **SD Card Reader**: [View on Amazon](https://www.amazon.com/dp/B0957HQ4D1)\n\n### Estimated Cost for Building Your Own VPN\n\n- The estimated one-time hardware cost is around $100 USD. Please note that there will be ongoing costs for electricity and internet.\n\n## WireGuard Resources\n\n- Homepage: [WireGuard Official Site](https://www.wireguard.com)\n- Installation Guide: [Install WireGuard](https://www.wireguard.com/install/)\n- Quick Start: [WireGuard QuickStart](https://www.wireguard.com/quickstart/)\n- Compilation Instructions: [Compile WireGuard](https://www.wireguard.com/compilation/)\n- Whitepaper: [WireGuard Whitepaper](https://www.wireguard.com/papers/wireguard.pdf)\n\n## VPN Speed Comparison\n\nThis section compares the internet speed differences between using no VPN, WireGuard, and OpenVPN.\n\n### No VPN (Normal Connection)\n\n![No VPN Speed Test](https://www.speedtest.net/result/15776043000.png)\n\n### WireGuard Speed Test\n\n![Wireguard Speed Test](https://www.speedtest.net/result/15776045897.png)\n\n### OpenVPN Speed Test\n\n![OpenVPN Speed Test](https://www.speedtest.net/result/15593895433.png)\n\n## 🙅 Content-Blocking vs. No Content-Blocking\n\nhttps://user-images.githubusercontent.com/16564273/125283630-9845d180-e2e6-11eb-8b7d-f30a8f2eae8a.mp4\n\n## 📐 Architecture\n\n![Wireguard Manager Architecture](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/Wireguard-Manager.png)\n\n## 🤝 Code Development\n\n**Develop Code Without Cloning the Repository**\n\nYou can directly work on the code without the need to clone the repository. This is facilitated by Visual Studio Code's online platform. By clicking the link below, you can preview and edit the code in your browser, leveraging the intuitive interface of Visual Studio Code. This method streamlines the development process, particularly for those who want to make quick modifications or do not wish to set up the entire repository on their local machine.\n\n[![Open in Visual Studio Code](https://img.shields.io/badge/preview%20in-vscode.dev-blue)](https://open.vscode.dev/complexorganizations/wireguard-manager)\n\n## 🐛 Code Debugging\n\n**Detailed Debugging Process After Cloning the Repository**\n\nFor a comprehensive debugging process, you might want to clone the repository to your local system. This method allows you to thoroughly test and debug the code in your environment. Follow these steps to clone the repository and start the debugging process:\n\n1. **Clone the Repository**: Use the Git command to clone the repository to your preferred directory, such as `/root/` in this example. This step copies all the code from the online repository to your local machine.\n\n```bash\ngit clone https://github.com/complexorganizations/wireguard-manager /root/\n```\n\n2. **Start Debugging**: After cloning, navigate to the script's directory and initiate the debugging process. The script will be executed in debug mode, providing detailed output of each step. This output is redirected to a log file for easier examination. The log file, located in the same directory, stores all the debugging information, making it easy to trace any issues or understand the script's behavior.\n\n```bash\nbash -x /root/wireguard-manager/wireguard-manager.sh >>/root/wireguard-manager/wireguard-manager.log\n```\n\nFollowing these steps, you can either quickly modify the code online without cloning or perform a more comprehensive debugging process by cloning the repository to your local machine. Each method offers different benefits depending on your needs and the extent of your work with the WireGuard Manager script.\n\n### Detailed Debugging Guide for WireGuard Manager\n\n1. **Setting Up the Environment**\n\n   - Ensure that all necessary software, including Git, Bash, and any dependencies required by WireGuard Manager, are installed on your system.\n   - While Visual Studio Code is used in this example, you can use any IDE that supports Git and Bash.\n\n2. **Cloning the Repository**\n\n   - Use Git to clone the WireGuard Manager repository to a local directory: `git clone https://github.com/complexorganizations/wireguard-manager /path/to/local-directory`\n   - Avoid using root directories for development. Choose a user directory for better safety and permission management.\n\n3. **Understanding the Codebase**\n\n   - Review the code to understand its structure, conventions, and documentation.\n   - Check for a README file or wiki pages in the repository that might provide insights into the codebase.\n\n4. **Setting Up Debugging Tools**\n\n   - Configure the debugging tools in your IDE. Set breakpoints, watch variables, and use step-through debugging features.\n   - Ensure that logging is correctly set up in the script to capture sufficient details for debugging.\n\n5. **Running the Script in Debug Mode**\n\n   - Run the script with `bash -x` to get detailed trace outputs: `bash -x /path/to/local-directory/wireguard-manager/wireguard-manager.sh >> /path/to/local-directory/wireguard-manager.log`\n   - Regularly check the log file for errors or unexpected behavior.\n\n6. **Testing in Different Environments**\n\n   - Test the script in isolated environments like Docker containers or VMs to understand its behavior in different settings.\n   - If possible, test on different operating systems to ensure compatibility.\n\n7. **Collaborating and Seeking Feedback**\n\n   - Commit changes to a new branch and use pull requests for reviews.\n   - Request code reviews from peers to get different perspectives on potential issues.\n\n8. **Documenting Your Findings**\n\n   - If you discover undocumented behavior or fixes, update the project documentation.\n   - Use the repository's issue tracker to report bugs or suggest enhancements.\n\n9. **Automating Testing**\n\n   - Create automated tests for critical functionalities to catch bugs early.\n   - Use CI tools to automate testing with every commit or pull request.\n\n10. **Staying Updated with the Repository**\n    - Regularly update your local repository with changes from the main project to stay in sync and avoid conflicts.\n\nBy following these steps and adapting them to their own development environment and workflow, developers can more effectively debug and contribute to the WireGuard Manager project. This comprehensive approach caters to various skill levels and preferences, thereby facilitating a more inclusive and efficient development process.\n\n## 💋 Acknowledgements\n\nThis project is made possible thanks to the Open Source Community.\n\n## 📱 Community and Contributions\n\nJoin our community on [![Discord](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/images/icons/discord.svg)](https://discord.gg/CdjBYMScMS) and [![Slack](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/images/icons/slack.svg)](https://join.slack.com/t/complexorgani-w5b4873/shared_invite/zt-2e9gz2wh2-dWuylZLgaEgFywNKF_iQRQ) to contribute to the project, share ideas, and get help.\n\n## 🤝 Sponsors\n\nThis project is sponsored by\n\n[![Digital Ocean](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/images/icons/digitalocean.svg)](https://www.digitalocean.com) [![Google Cloud](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/images/icons/gcp.svg)](https://cloud.google.com) [![AWS](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/images/icons/aws.svg)](https://aws.amazon.com) [![Linode](https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/images/icons/linode.svg)](https://linode.com)\n\n## Backup\n\nhttps://gitlab.com/complexorganizations/wireguard-manager\n\n## 📝 License\n\nWireGuard-Manager is licensed under the Apache License Version 2.0. For more details, please refer to our [License File](https://github.com/complexorganizations/wireguard-manager/blob/main/license.md).\n"
        },
        {
          "name": "security.md",
          "type": "blob",
          "size": 1.0556640625,
          "content": "# Security Policy\n\n### Reporting a Vulnerability\n\nIt is difficult to underestimate the essential importance of Responsible Disclosure when it comes to private communications within the public network area. The lives of some people rely on keeping their experiences secret. On a larger scale than the individual level, entire countries will depend on the protection and dignity of people who manage these projects. Please be prompt in documentation and vulnerability disclosures.\n\nWe'll seek to reach a 90-day turnaround on vulnerabilities that have been reported responsibly. When we haven't updated the repository in 90 days from the audit, disclosing the vulnerability on the GitHub Issues is necessary so others know they can no longer trust this repository to effectively protect their security.\n\nBy default rationale on how software releases should be delivered, we aim for the highest possible level on protection without compromising on the works. Unless the guard may be removed between now and the time you passed away, we believe that this is not enough for our designs.\n"
        },
        {
          "name": "wireguard-manager.sh",
          "type": "blob",
          "size": 107.814453125,
          "content": "#!/bin/bash\n\n# WireGuard-Manager Installation Script\n# Purpose: This script automates the installation of WireGuard-Manager, a comprehensive tool for managing WireGuard VPN configurations.\n# Author: ComplexOrganizations\n# Repository: https://github.com/complexorganizations/wireguard-manager\n\n# Usage Instructions:\n# 1. System Requirements: Ensure you have 'curl' installed on your system. This script is compatible with most Linux distributions.\n# 2. Downloading the Script:\n#    - Use the following command to download the script:\n#      curl https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/wireguard-manager.sh --create-dirs -o /usr/local/bin/wireguard-manager.sh\n# 3. Making the Script Executable:\n#    - Grant execution permissions to the script:\n#      chmod +x /usr/local/bin/wireguard-manager.sh\n# 4. Running the Script:\n#    - Execute the script with root privileges:\n#      bash /usr/local/bin/wireguard-manager.sh\n# 5. Follow the on-screen instructions to complete the installation of WireGuard-Manager.\n\n# Advanced Usage:\n# - The script supports various command-line arguments for custom installations. Refer to the repository's readme.md for more details.\n# - For automated deployments, environment variables can be set before running this script.\n\n# Troubleshooting:\n# - If you encounter issues, ensure your system is up-to-date and retry the installation.\n# - For specific errors, refer to the 'Troubleshooting' section in the repository's documentation.\n\n# Contributing:\n# - Contributions to the script are welcome. Please follow the contributing guidelines in the repository.\n\n# Contact Information:\n# - For support, feature requests, or bug reports, please open an issue on the GitHub repository.\n\n# License: MIT License\n\n# Note: This script is provided 'as is', without warranty of any kind. The user is responsible for understanding the operations and risks involved.\n\n# Check if the script is running as root\nfunction check_root() {\n  if [ \"$(id -u)\" -ne 0 ]; then\n    echo \"Error: This script must be run as root.\"\n    exit 1\n  fi\n}\n\n# Call the function to check root privileges\ncheck_root\n\n# Function to gather current system details\nfunction system-information() {\n  # This function fetches the ID, version, and major version of the current system\n  if [ -f /etc/os-release ]; then\n    # If /etc/os-release file is present, source it to obtain system details\n    # shellcheck source=/dev/null\n    source /etc/os-release\n    CURRENT_DISTRO=${ID}                                                                              # CURRENT_DISTRO holds the system's ID\n    CURRENT_DISTRO_VERSION=${VERSION_ID}                                                              # CURRENT_DISTRO_VERSION holds the system's VERSION_ID\n    CURRENT_DISTRO_MAJOR_VERSION=$(echo \"${CURRENT_DISTRO_VERSION}\" | cut --delimiter=\".\" --fields=1) # CURRENT_DISTRO_MAJOR_VERSION holds the major version of the system (e.g., \"16\" for Ubuntu 16.04)\n  fi\n}\n\n# Invoke the system-information function\nsystem-information\n\n# Define a function to check system requirements\nfunction installing-system-requirements() {\n  # Check if the current Linux distribution is supported\n  if { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ] || [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ] || [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ] || [ \"${CURRENT_DISTRO}\" == \"alpine\" ] || [ \"${CURRENT_DISTRO}\" == \"freebsd\" ] || [ \"${CURRENT_DISTRO}\" == \"ol\" ]; }; then\n    # Check if required packages are already installed\n    if { [ ! -x \"$(command -v curl)\" ] || [ ! -x \"$(command -v cut)\" ] || [ ! -x \"$(command -v jq)\" ] || [ ! -x \"$(command -v ip)\" ] || [ ! -x \"$(command -v lsof)\" ] || [ ! -x \"$(command -v cron)\" ] || [ ! -x \"$(command -v awk)\" ] || [ ! -x \"$(command -v ps)\" ] || [ ! -x \"$(command -v grep)\" ] || [ ! -x \"$(command -v qrencode)\" ] || [ ! -x \"$(command -v sed)\" ] || [ ! -x \"$(command -v zip)\" ] || [ ! -x \"$(command -v unzip)\" ] || [ ! -x \"$(command -v openssl)\" ] || [ ! -x \"$(command -v nft)\" ] || [ ! -x \"$(command -v ifup)\" ] || [ ! -x \"$(command -v chattr)\" ] || [ ! -x \"$(command -v gpg)\" ] || [ ! -x \"$(command -v systemd-detect-virt)\" ]; }; then\n      # Install required packages depending on the Linux distribution\n      if { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n        apt-get update\n        apt-get install curl coreutils jq iproute2 lsof cron gawk procps grep qrencode sed zip unzip openssl nftables ifupdown e2fsprogs gnupg systemd -y\n      elif { [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n        yum check-update\n        if [ \"${CURRENT_DISTRO}\" == \"centos\" ] && [ \"${CURRENT_DISTRO_MAJOR_VERSION}\" -ge 7 ]; then\n          yum install epel-release elrepo-release -y\n        fi\n        if [ \"${CURRENT_DISTRO}\" == \"centos\" ] && [ \"${CURRENT_DISTRO_MAJOR_VERSION}\" == 7 ]; then\n          yum install yum-plugin-elrepo -y\n        fi\n        yum install curl coreutils jq iproute lsof cronie gawk procps-ng grep qrencode sed zip unzip openssl nftables NetworkManager e2fsprogs gnupg systemd -y\n      elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n        pacman -Sy --noconfirm archlinux-keyring\n        pacman -Su --noconfirm --needed curl coreutils jq iproute2 lsof cronie gawk procps-ng grep qrencode sed zip unzip openssl nftables ifupdown e2fsprogs gnupg systemd\n      elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n        apk update\n        apk add curl coreutils jq iproute2 lsof cronie gawk procps grep sed zip unzip openssl nftables e2fsprogs gnupg\n        # apk add curl coreutils jq iproute2 lsof cronie gawk procps grep qrencode sed zip unzip openssl nftables ifupdown e2fsprogs gnupg systemd\n      elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n        pkg update\n        pkg install curl coreutils jq iproute2 lsof cronie gawk procps grep qrencode sed zip unzip openssl nftables ifupdown e2fsprogs gnupg systemd\n      elif [ \"${CURRENT_DISTRO}\" == \"ol\" ]; then\n        yum check-update\n        yum install curl coreutils jq iproute lsof cronie gawk procps-ng grep qrencode sed zip unzip openssl nftables NetworkManager e2fsprogs gnupg systemd -y\n      fi\n    fi\n  else\n    echo \"Error: Your current distribution ${CURRENT_DISTRO} version ${CURRENT_DISTRO_VERSION} is not supported by this script. Please consider updating your distribution or using a supported one.\"\n    exit\n  fi\n}\n\n# Call the function to check for system requirements and install necessary packages if needed\ninstalling-system-requirements\n\n# Checking For Virtualization\nfunction virt-check() {\n  # This code checks if the system is running in a supported virtualization.\n  # It returns the name of the virtualization if it is supported, or \"none\" if\n  # it is not supported. This code is used to check if the system is running in\n  # a virtual machine, and if so, if it is running in a supported virtualization.\n  # systemd-detect-virt is a utility that detects the type of virtualization\n  # that the system is running on. It returns a string that indicates the name\n  # of the virtualization, such as \"kvm\" or \"vmware\".\n  CURRENT_SYSTEM_VIRTUALIZATION=$(systemd-detect-virt)\n  # This case statement checks if the virtualization that the system is running\n  # on is supported. If it is not supported, the script will print an error\n  # message and exit.\n  case ${CURRENT_SYSTEM_VIRTUALIZATION} in\n  \"kvm\" | \"none\" | \"qemu\" | \"lxc\" | \"microsoft\" | \"vmware\" | \"xen\" | \"amazon\" | \"docker\") ;;\n  *)\n    echo \"Error: the ${CURRENT_SYSTEM_VIRTUALIZATION} virtualization is currently not supported. Please stay tuned for future updates.\"\n    exit\n    ;;\n  esac\n}\n\n# Call the virt-check function to check for supported virtualization.\nvirt-check\n\n# The following function checks the kernel version.\nfunction kernel-check() {\n  CURRENT_KERNEL_VERSION=$(uname --kernel-release | cut --delimiter=\".\" --fields=1-2)\n  # Get the current kernel version and extract the major and minor version numbers.\n  CURRENT_KERNEL_MAJOR_VERSION=$(echo \"${CURRENT_KERNEL_VERSION}\" | cut --delimiter=\".\" --fields=1)\n  # Extract the major version number from the current kernel version.\n  CURRENT_KERNEL_MINOR_VERSION=$(echo \"${CURRENT_KERNEL_VERSION}\" | cut --delimiter=\".\" --fields=2)\n  # Extract the minor version number from the current kernel version.\n  ALLOWED_KERNEL_VERSION=\"3.1\"\n  # Set the minimum allowed kernel version to 3.1.0.\n  ALLOWED_KERNEL_MAJOR_VERSION=$(echo ${ALLOWED_KERNEL_VERSION} | cut --delimiter=\".\" --fields=1)\n  # Extract the major version number from the allowed kernel version.\n  ALLOWED_KERNEL_MINOR_VERSION=$(echo ${ALLOWED_KERNEL_VERSION} | cut --delimiter=\".\" --fields=2)\n  # Extract the minor version number from the allowed kernel version.\n  if [ \"${CURRENT_KERNEL_MAJOR_VERSION}\" -lt \"${ALLOWED_KERNEL_MAJOR_VERSION}\" ]; then\n    # If the current major version is less than the allowed major version, show an error message and exit.\n    echo \"Error: Your current kernel version ${CURRENT_KERNEL_VERSION} is not supported. Please update to version ${ALLOWED_KERNEL_VERSION} or later.\"\n    exit\n  fi\n  if [ \"${CURRENT_KERNEL_MAJOR_VERSION}\" == \"${ALLOWED_KERNEL_MAJOR_VERSION}\" ]; then\n    # If the current major version is equal to the allowed major version, check the minor version.\n    if [ \"${CURRENT_KERNEL_MINOR_VERSION}\" -lt \"${ALLOWED_KERNEL_MINOR_VERSION}\" ]; then\n      # If the current minor version is less than the allowed minor version, show an error message and exit.\n      echo \"Error: Your current kernel version ${CURRENT_KERNEL_VERSION} is not supported. Please update to version ${ALLOWED_KERNEL_VERSION} or later.\"\n      exit\n    fi\n  fi\n}\n\n# Call the kernel-check function to verify the kernel version.\nkernel-check\n\n# The following function checks if the current init system is one of the allowed options.\nfunction check-current-init-system() {\n  # This function checks if the current init system is systemd or sysvinit.\n  # If it is neither, the script exits.\n  CURRENT_INIT_SYSTEM=$(ps --no-headers -o comm 1)\n  # This line retrieves the current init system by checking the process name of PID 1.\n  case ${CURRENT_INIT_SYSTEM} in\n  # The case statement checks if the retrieved init system is one of the allowed options.\n  *\"systemd\"* | *\"init\"* | *\"bash\"* | *\"sh\"*)\n    # If the init system is systemd or sysvinit (init), continue with the script.\n    ;;\n  *)\n    # If the init system is not one of the allowed options, display an error message and exit.\n    echo \"Error: The ${CURRENT_INIT_SYSTEM} initialization system is currently not supported. Please stay tuned for future updates.\"\n    exit\n    ;;\n  esac\n}\n\n# The check-current-init-system function is being called.\n\ncheck-current-init-system\n# Calls the check-current-init-system function.\n\n# The following function checks if there's enough disk space to proceed with the installation.\nfunction check-disk-space() {\n  # This function checks if there is more than 1 GB of free space on the drive.\n  FREE_SPACE_ON_DRIVE_IN_MB=$(df -m / | tr --squeeze-repeats \" \" | tail -n1 | cut --delimiter=\" \" --fields=4)\n  # This line calculates the available free space on the root partition in MB.\n  if [ \"${FREE_SPACE_ON_DRIVE_IN_MB}\" -le 1024 ]; then\n    # If the available free space is less than or equal to 1024 MB (1 GB), display an error message and exit.\n    echo \"Error: You need more than 1 GB of free space to install everything. Please free up some space and try again.\"\n    exit\n  fi\n}\n\n# The check-disk-space function is being called.\n\ncheck-disk-space\n# Calls the check-disk-space function.\n\n# Global variables\n# Assigns the path of the current script to a variable\nCURRENT_FILE_PATH=$(realpath \"${0}\")\n# Assigns the WireGuard website URL to a variable\nWIREGUARD_WEBSITE_URL=\"https://www.wireguard.com\"\n# Assigns a path for WireGuard\nWIREGUARD_PATH=\"/etc/wireguard\"\n# Assigns a path for WireGuard clients\nWIREGUARD_CLIENT_PATH=\"${WIREGUARD_PATH}/clients\"\n# Assigns a public network interface name for WireGuard\nWIREGUARD_PUB_NIC=\"wg0\"\n# Assigns a path for the WireGuard configuration file\nWIREGUARD_CONFIG=\"${WIREGUARD_PATH}/${WIREGUARD_PUB_NIC}.conf\"\n# Assigns a path for the WireGuard additional peer configuration file\nWIREGUARD_ADD_PEER_CONFIG=\"${WIREGUARD_PATH}/${WIREGUARD_PUB_NIC}-add-peer.conf\"\n# Assigns a path for system backups\nSYSTEM_BACKUP_PATH=\"/var/backups\"\n# Assigns a path for the WireGuard configuration backup file\nWIREGUARD_CONFIG_BACKUP=\"${SYSTEM_BACKUP_PATH}/wireguard-manager.zip\"\n# Assigns a path for the WireGuard backup password file\nWIREGUARD_BACKUP_PASSWORD_PATH=\"${HOME}/.wireguard-manager\"\n# Assigns a path for the DNS resolver configuration file\nRESOLV_CONFIG=\"/etc/resolv.conf\"\n# Assigns a path for the old DNS resolver configuration file\nRESOLV_CONFIG_OLD=\"${RESOLV_CONFIG}.old\"\n# Assigns a path for Unbound DNS resolver\nUNBOUND_ROOT=\"/etc/unbound\"\n# Assigns a path for the WireGuard Manager script\nUNBOUND_MANAGER=\"${UNBOUND_ROOT}/wireguard-manager\"\n# Assigns a path for the Unbound configuration file\nUNBOUND_CONFIG=\"${UNBOUND_ROOT}/unbound.conf\"\n# Assigns a path for the Unbound root hints file\nUNBOUND_ROOT_HINTS=\"${UNBOUND_ROOT}/root.hints\"\n# Assigns a path for the Unbound anchor file\nUNBOUND_ANCHOR=\"/var/lib/unbound/root.key\"\nif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n  UNBOUND_ANCHOR=\"${UNBOUND_ROOT}/root.key\"\nfi\n# Assigns a path for the Unbound configuration directory\nUNBOUND_CONFIG_DIRECTORY=\"${UNBOUND_ROOT}/unbound.conf.d\"\n# Assigns a path for the Unbound hosts configuration file\nUNBOUND_CONFIG_HOST=\"${UNBOUND_CONFIG_DIRECTORY}/hosts.conf\"\ncase $(shuf --input-range=1-5 --head-count=1) in\n1)\n  UNBOUND_ROOT_SERVER_CONFIG_URL=\"https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/assets/named.cache\"\n  ;;\n2)\n  UNBOUND_ROOT_SERVER_CONFIG_URL=\"https://cdn.statically.io/gh/complexorganizations/wireguard-manager/main/assets/named.cache\"\n  ;;\n3)\n  UNBOUND_ROOT_SERVER_CONFIG_URL=\"https://cdn.jsdelivr.net/gh/complexorganizations/wireguard-manager/assets/named.cache\"\n  ;;\n4)\n  UNBOUND_ROOT_SERVER_CONFIG_URL=\"https://www.internic.net/domain/named.cache\"\n  ;;\n5)\n  UNBOUND_ROOT_SERVER_CONFIG_URL=\"https://gitlab.com/complex-organizations/wireguard-manager/-/raw/main/assets/named.cache\"\n  ;;\nesac\ncase $(shuf --input-range=1-5 --head-count=1) in\n1)\n  UNBOUND_CONFIG_HOST_URL=\"https://raw.githubusercontent.com/complexorganizations/content-blocker/main/assets/hosts\"\n  ;;\n2)\n  UNBOUND_CONFIG_HOST_URL=\"https://cdn.statically.io/gh/complexorganizations/content-blocker/main/assets/hosts\"\n  ;;\n3)\n  UNBOUND_CONFIG_HOST_URL=\"https://cdn.jsdelivr.net/gh/complexorganizations/content-blocker/assets/hosts\"\n  ;;\n4)\n  UNBOUND_CONFIG_HOST_URL=\"https://combinatronics.io/complexorganizations/content-blocker/main/assets/hosts\"\n  ;;\n5)\n  UNBOUND_CONFIG_HOST_URL=\"https://gitlab.com/complex-organizations/wireguard-manager/-/raw/main/assets/hosts\"\n  ;;\nesac\ncase $(shuf --input-range=1-5 --head-count=1) in\n1)\n  WIREGUARD_MANAGER_UPDATE=\"https://raw.githubusercontent.com/complexorganizations/wireguard-manager/main/wireguard-manager.sh\"\n  ;;\n2)\n  WIREGUARD_MANAGER_UPDATE=\"https://cdn.statically.io/gh/complexorganizations/wireguard-manager/main/wireguard-manager.sh\"\n  ;;\n3)\n  WIREGUARD_MANAGER_UPDATE=\"https://cdn.jsdelivr.net/gh/complexorganizations/wireguard-manager/wireguard-manager.sh\"\n  ;;\n4)\n  WIREGUARD_MANAGER_UPDATE=\"https://combinatronics.io/complexorganizations/wireguard-manager/main/wireguard-manager.sh\"\n  ;;\n5)\n  WIREGUARD_MANAGER_UPDATE=\"https://gitlab.com/complex-organizations/wireguard-manager/-/raw/main/wireguard-manager.sh\"\n  ;;\nesac\n# Check if the CURRENT_DISTRO variable matches any of the following distros:\n# fedora, centos, rhel, almalinux, or rocky\nif { [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n  # If the condition is true, set the SYSTEM_CRON_NAME variable to \"crond\"\n  SYSTEM_CRON_NAME=\"crond\"\n# If the CURRENT_DISTRO variable matches any of the following distros:\n# arch, archarm, or manjaro\nelif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n  # If the condition is true, set the SYSTEM_CRON_NAME variable to \"cronie\"\n  SYSTEM_CRON_NAME=\"cronie\"\nelse\n  # If none of the above conditions are met, set the SYSTEM_CRON_NAME variable to \"cron\"\n  SYSTEM_CRON_NAME=\"cron\"\nfi\n\n# This is a Bash function named \"get-network-information\" that retrieves network information.\nfunction get-network-information() {\n  # This variable will store the IPv4 address of the default network interface by querying the \"ipengine\" API using \"curl\" command and extracting it using \"jq\" command.\n  DEFAULT_INTERFACE_IPV4=\"$(curl --ipv4 --connect-timeout 5 --tlsv1.2 --silent 'https://checkip.amazonaws.com')\"\n  # If the IPv4 address is empty, try getting it from another API.\n  if [ -z \"${DEFAULT_INTERFACE_IPV4}\" ]; then\n    DEFAULT_INTERFACE_IPV4=\"$(curl --ipv4 --connect-timeout 5 --tlsv1.3 --silent 'https://icanhazip.com')\"\n  fi\n  # This variable will store the IPv6 address of the default network interface by querying the \"ipengine\" API using \"curl\" command and extracting it using \"jq\" command.\n  DEFAULT_INTERFACE_IPV6=\"$(curl --ipv6 --connect-timeout 5 --tlsv1.3 --silent 'https://ifconfig.co')\"\n  # If the IPv6 address is empty, try getting it from another API.\n  if [ -z \"${DEFAULT_INTERFACE_IPV6}\" ]; then\n    DEFAULT_INTERFACE_IPV6=\"$(curl --ipv6 --connect-timeout 5 --tlsv1.3 --silent 'https://icanhazip.com')\"\n  fi\n}\n\n# Usage Guide of the application\nfunction usage-guide() {\n  echo \"Usage: ./$(basename \"${0}\") <command>\"\n  echo \"  --install     Installs the WireGuard interface on your system\"\n  echo \"  --start       Starts the WireGuard interface if it's not already running\"\n  echo \"  --stop        Stops the WireGuard interface if it's currently running\"\n  echo \"  --restart     Restarts the WireGuard interface\"\n  echo \"  --list        Lists all the peers currently connected to the WireGuard interface\"\n  echo \"  --add         Adds a new peer to the WireGuard interface\"\n  echo \"  --remove      Removes a specified peer from the WireGuard interface\"\n  echo \"  --reinstall   Reinstalls the WireGuard interface, keeping the current configuration\"\n  echo \"  --uninstall   Uninstalls the WireGuard interface from your system\"\n  echo \"  --update      Updates the WireGuard Manager to the latest version\"\n  echo \"  --ddns        Updates the IP address of the WireGuard interface using Dynamic DNS\"\n  echo \"  --backup      Creates a backup of your current WireGuard configuration\"\n  echo \"  --restore     Restores the WireGuard configuration from a previous backup\"\n  echo \"  --purge       Removes all peers from the WireGuard interface\"\n  echo \"  --help        Displays this usage guide\"\n}\n\n# Define a function that takes command line arguments as input\nfunction usage() {\n  # Check if there are any command line arguments left\n  while [ $# -ne 0 ]; do\n    # Use a switch-case statement to check the value of the first argument\n    case ${1} in\n    --install) # If it's \"--install\", set the variable HEADLESS_INSTALL to \"true\"\n      shift\n      HEADLESS_INSTALL=${HEADLESS_INSTALL=true}\n      ;;\n    --start) # If it's \"--start\", set the variable WIREGUARD_OPTIONS to 2\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=2}\n      ;;\n    --stop) # If it's \"--stop\", set the variable WIREGUARD_OPTIONS to 3\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=3}\n      ;;\n    --restart) # If it's \"--restart\", set the variable WIREGUARD_OPTIONS to 4\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=4}\n      ;;\n    --list) # If it's \"--list\", set the variable WIREGUARD_OPTIONS to 1\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=1}\n      ;;\n    --add) # If it's \"--add\", set the variable WIREGUARD_OPTIONS to 5\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=5}\n      ;;\n    --remove) # If it's \"--remove\", set the variable WIREGUARD_OPTIONS to 6\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=6}\n      ;;\n    --reinstall) # If it's \"--reinstall\", set the variable WIREGUARD_OPTIONS to 7\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=7}\n      ;;\n    --uninstall) # If it's \"--uninstall\", set the variable WIREGUARD_OPTIONS to 8\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=8}\n      ;;\n    --update) # If it's \"--update\", set the variable WIREGUARD_OPTIONS to 9\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=9}\n      ;;\n    --backup) # If it's \"--backup\", set the variable WIREGUARD_OPTIONS to 10\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=10}\n      ;;\n    --restore) # If it's \"--restore\", set the variable WIREGUARD_OPTIONS to 11\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=11}\n      ;;\n    --ddns) # If it's \"--ddns\", set the variable WIREGUARD_OPTIONS to 12\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=12}\n      ;;\n    --purge) # If it's \"--purge\", set the variable WIREGUARD_OPTIONS to 14\n      shift\n      WIREGUARD_OPTIONS=${WIREGUARD_OPTIONS=14}\n      ;;\n    --help) # If it's \"--help\", call the function usage-guide\n      shift\n      usage-guide\n      ;;\n    *) # If it's anything else, print an error message and call the function usage-guide, then exit\n      echo \"Invalid argument: ${1}\"\n      usage-guide\n      exit\n      ;;\n    esac\n  done\n}\n\n# Call the function usage with all the command line arguments\nusage \"$@\"\n\n# The function defines default values for configuration variables when installing WireGuard in headless mode.\n# These variables include private subnet settings, server host settings, NAT choice, MTU choice, client allowed IP settings, automatic updates, automatic backup, DNS provider settings, content blocker settings, client name, and automatic config remover.\nfunction headless-install() {\n  # If headless installation is specified, set default values for configuration variables.\n  if [ \"${HEADLESS_INSTALL}\" == true ]; then\n    PRIVATE_SUBNET_V4_SETTINGS=${PRIVATE_SUBNET_V4_SETTINGS=1} # Default to 1 if not specified\n    PRIVATE_SUBNET_V6_SETTINGS=${PRIVATE_SUBNET_V6_SETTINGS=1} # Default to 1 if not specified\n    SERVER_HOST_V4_SETTINGS=${SERVER_HOST_V4_SETTINGS=1}       # Default to 1 if not specified\n    SERVER_HOST_V6_SETTINGS=${SERVER_HOST_V6_SETTINGS=1}       # Default to 1 if not specified\n    SERVER_PUB_NIC_SETTINGS=${SERVER_PUB_NIC_SETTINGS=1}       # Default to 1 if not specified\n    SERVER_PORT_SETTINGS=${SERVER_PORT_SETTINGS=1}             # Default to 1 if not specified\n    NAT_CHOICE_SETTINGS=${NAT_CHOICE_SETTINGS=1}               # Default to 1 if not specified\n    MTU_CHOICE_SETTINGS=${MTU_CHOICE_SETTINGS=1}               # Default to 1 if not specified\n    SERVER_HOST_SETTINGS=${SERVER_HOST_SETTINGS=1}             # Default to 1 if not specified\n    CLIENT_ALLOWED_IP_SETTINGS=${CLIENT_ALLOWED_IP_SETTINGS=1} # Default to 1 if not specified\n    AUTOMATIC_UPDATES_SETTINGS=${AUTOMATIC_UPDATES_SETTINGS=1} # Default to 1 if not specified\n    AUTOMATIC_BACKUP_SETTINGS=${AUTOMATIC_BACKUP_SETTINGS=1}   # Default to 1 if not specified\n    DNS_PROVIDER_SETTINGS=${DNS_PROVIDER_SETTINGS=1}           # Default to 1 if not specified\n    CONTENT_BLOCKER_SETTINGS=${CONTENT_BLOCKER_SETTINGS=1}     # Default to 1 if not specified\n    CLIENT_NAME=${CLIENT_NAME=$(openssl rand -hex 25)}         # Generate a random client name if not specified\n    AUTOMATIC_CONFIG_REMOVER=${AUTOMATIC_CONFIG_REMOVER=1}     # Default to 1 if not specified\n  fi\n}\n\n# Call the headless-install function to set default values for configuration variables in headless mode.\nheadless-install\n\n# Set up the wireguard, if config it isn't already there.\nif [ ! -f \"${WIREGUARD_CONFIG}\" ]; then\n\n  # Define a function to set a custom IPv4 subnet\n  function set-ipv4-subnet() {\n    # Prompt the user for the desired IPv4 subnet\n    echo \"Please specify the IPv4 subnet you want to use for the WireGuard interface. This should be a private subnet that is not in use elsewhere on your network. For example, you might choose '10.0.0.0/24' if it's not already in use.\"\n    echo \"  1) 10.0.0.0/8 (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Keep prompting the user until they enter a valid subnet choice\n    until [[ \"${PRIVATE_SUBNET_V4_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      read -rp \"Subnet Choice [1-2]:\" -e -i 1 PRIVATE_SUBNET_V4_SETTINGS\n    done\n    # Based on the user's choice, set the private IPv4 subnet\n    case ${PRIVATE_SUBNET_V4_SETTINGS} in\n    1)\n      PRIVATE_SUBNET_V4=\"10.0.0.0/8\" # Set a default IPv4 subnet\n      ;;\n    2)\n      read -rp \"Custom IPv4 Subnet:\" PRIVATE_SUBNET_V4 # Prompt user for custom subnet\n      if [ -z \"${PRIVATE_SUBNET_V4}\" ]; then           # If the user did not enter a subnet, set default\n        PRIVATE_SUBNET_V4=\"10.0.0.0/8\"\n      fi\n      ;;\n    esac\n  }\n\n  # Call the function to set the custom IPv4 subnet\n  set-ipv4-subnet\n\n  # Define a function to set a custom IPv6 subnet\n  function set-ipv6-subnet() {\n    # Ask the user which IPv6 subnet they want to use\n    echo \"Please specify the IPv6 subnet you want to use for the WireGuard interface. This should be a private subnet that is not in use elsewhere on your network. For example, you might choose 'fd00::/64' if it's not already in use.\"\n    echo \"  1) fd00:00:00::0/8 (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Use a loop to ensure the user inputs a valid option\n    until [[ \"${PRIVATE_SUBNET_V6_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      read -rp \"Please choose the IPv6 subnet for your WireGuard interface [Option 1-2]: \" -e -i 1 PRIVATE_SUBNET_V6_SETTINGS\n    done\n    # Use a case statement to set the IPv6 subnet based on the user's choice\n    case ${PRIVATE_SUBNET_V6_SETTINGS} in\n    1)\n      # Use the recommended IPv6 subnet if the user chooses option 1\n      PRIVATE_SUBNET_V6=\"fd00:00:00::0/8\"\n      ;;\n    2)\n      # Ask the user for a custom IPv6 subnet if they choose option 2\n      read -rp \"Please enter a custom IPv6 subnet for your WireGuard interface: \" PRIVATE_SUBNET_V6\n      # If the user does not input a subnet, use the recommended one\n      if [ -z \"${PRIVATE_SUBNET_V6}\" ]; then\n        PRIVATE_SUBNET_V6=\"fd00:00:00::0/8\"\n      fi\n      ;;\n    esac\n  }\n\n  # Call the set-ipv6-subnet function to set the custom IPv6 subnet\n  set-ipv6-subnet\n\n  # Define the private subnet mask for the IPv4 network used by the WireGuard interface\n  PRIVATE_SUBNET_MASK_V4=$(echo \"${PRIVATE_SUBNET_V4}\" | cut --delimiter=\"/\" --fields=2) # Get the subnet mask of IPv4\n  # Define the IPv4 gateway for the WireGuard interface\n  GATEWAY_ADDRESS_V4=$(echo \"${PRIVATE_SUBNET_V4}\" | cut --delimiter=\".\" --fields=1-3).1 # Get the gateway address of IPv4\n  # Define the private subnet mask for the IPv6 network used by the WireGuard interface\n  PRIVATE_SUBNET_MASK_V6=$(echo \"${PRIVATE_SUBNET_V6}\" | cut --delimiter=\"/\" --fields=2) # Get the subnet mask of IPv6\n  # Define the IPv6 gateway for the WireGuard interface\n  GATEWAY_ADDRESS_V6=$(echo \"${PRIVATE_SUBNET_V6}\" | cut --delimiter=\":\" --fields=1-3)::1 # Get the gateway address of IPv6\n  # Retrieve the networking configuration details\n  get-network-information\n  # Call a function to get the networking data\n\n  # Define a function to retrieve the IPv4 address of the WireGuard interface\n  function test-connectivity-v4() {\n    # Prompt the user to choose the method for detecting the IPv4 address\n    echo \"How would you like to detect IPv4?\"\n    echo \"  1) Curl (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Loop until the user provides a valid input\n    until [[ \"${SERVER_HOST_V4_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      read -rp \"IPv4 Choice [1-2]:\" -e -i 1 SERVER_HOST_V4_SETTINGS\n    done\n    # Choose the method for detecting the IPv4 address based on the user's input\n    case ${SERVER_HOST_V4_SETTINGS} in\n    1)\n      SERVER_HOST_V4=${DEFAULT_INTERFACE_IPV4} # Use the default IPv4 address\n      ;;\n    2)\n      # Prompt the user to enter a custom IPv4 address\n      read -rp \"Custom IPv4:\" SERVER_HOST_V4\n      # If the user doesn't provide an input, use the default IPv4 address\n      if [ -z \"${SERVER_HOST_V4}\" ]; then\n        SERVER_HOST_V4=${DEFAULT_INTERFACE_IPV4}\n      fi\n      ;;\n    esac\n  }\n\n  # Call the function to retrieve the IPv4 address\n  test-connectivity-v4\n  # Invoke the function to get the IPv4 address\n\n  # Define a function to retrieve the IPv6 address of the WireGuard interface\n  function test-connectivity-v6() {\n    # Prompt the user to choose the method for detecting the IPv6 address\n    echo \"How would you like to detect IPv6?\"\n    echo \"  1) Curl (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Loop until the user provides a valid input\n    until [[ \"${SERVER_HOST_V6_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      read -rp \"IPv6 Choice [1-2]:\" -e -i 1 SERVER_HOST_V6_SETTINGS\n    done\n    # Choose the method for detecting the IPv6 address based on the user's input\n    case ${SERVER_HOST_V6_SETTINGS} in\n    1)\n      SERVER_HOST_V6=${DEFAULT_INTERFACE_IPV6} # Use the default IPv6 address\n      ;;\n    2)\n      # Prompt the user to enter a custom IPv6 address\n      read -rp \"Custom IPv6:\" SERVER_HOST_V6\n      # If the user doesn't provide an input, use the default IPv6 address\n      if [ -z \"${SERVER_HOST_V6}\" ]; then\n        SERVER_HOST_V6=${DEFAULT_INTERFACE_IPV6}\n      fi\n      ;;\n    esac\n  }\n\n  # Call the function to retrieve the IPv6 address\n  test-connectivity-v6\n\n  # Define a function to identify the public Network Interface Card (NIC).\n  function server-pub-nic() {\n    # Prompt the user to select the method for identifying the NIC.\n    echo \"How would you like to identify the Network Interface Card (NIC)?\"\n    echo \"  1) IP Route (Recommended)\"\n    echo \"  2) Custom Input (Advanced)\"\n    # Loop until the user provides a valid input (either 1 or 2).\n    until [[ \"${SERVER_PUB_NIC_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      read -rp \"NIC Choice [1-2]:\" -e -i 1 SERVER_PUB_NIC_SETTINGS\n    done\n    # Execute a case statement based on the user's choice.\n    case ${SERVER_PUB_NIC_SETTINGS} in\n    1)\n      # Use the IP route command to automatically identify the NIC.\n      SERVER_PUB_NIC=\"$(ip route | grep default | head --lines=1 | cut --delimiter=\" \" --fields=5)\"\n      # If no NIC is found, exit the script with an error message.\n      if [ -z \"${SERVER_PUB_NIC}\" ]; then\n        echo \"Error: Unable to identify your server's public network interface.\"\n        exit\n      fi\n      ;;\n    2)\n      # Prompt the user to manually input the NIC.\n      read -rp \"Custom NIC:\" SERVER_PUB_NIC\n      # If the user doesn't provide an input, use the IP route command to identify the NIC.\n      if [ -z \"${SERVER_PUB_NIC}\" ]; then\n        SERVER_PUB_NIC=\"$(ip route | grep default | head --lines=1 | cut --delimiter=\" \" --fields=5)\"\n      fi\n      ;;\n    esac\n  }\n\n  # Call the function to identify the public NIC.\n  server-pub-nic\n\n  # Define a function to configure the WireGuard server's listening port\n  function set-port() {\n    # Prompt the user to specify the port for the WireGuard server\n    echo \"What port do you want WireGuard server to listen to?\"\n    # Provide the user with options for setting the port\n    echo \"  1) 51820 (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Continue prompting the user until a valid option (1 or 2) is selected\n    until [[ \"${SERVER_PORT_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Ask the user for their port choice, with 1 as the default option\n      read -rp \"Port Choice [1-2]:\" -e -i 1 SERVER_PORT_SETTINGS\n    done\n    # Set the SERVER_PORT variable based on the user's choice\n    case ${SERVER_PORT_SETTINGS} in\n    1)\n      SERVER_PORT=\"51820\"\n      # If the chosen port is already in use, display an error message and exit the script\n      if [ \"$(lsof -i UDP:\"${SERVER_PORT}\")\" ]; then\n        echo \"Error: Please use a different port because ${SERVER_PORT} is already in use.\"\n        exit\n      fi\n      ;;\n    2)\n      # Continue prompting the user until a valid custom port number (between 1 and 65535) is entered\n      until [[ \"${SERVER_PORT}\" =~ ^[0-9]+$ ]] && [ \"${SERVER_PORT}\" -ge 1 ] && [ \"${SERVER_PORT}\" -le 65535 ]; do\n        read -rp \"Custom port [1-65535]:\" SERVER_PORT\n      done\n      # If no custom port is entered, set the SERVER_PORT variable to the default of 51820\n      if [ -z \"${SERVER_PORT}\" ]; then\n        SERVER_PORT=\"51820\"\n      fi\n      # If the chosen port is already in use, display an error message and exit the script\n      if [ \"$(lsof -i UDP:\"${SERVER_PORT}\")\" ]; then\n        echo \"Error: The port ${SERVER_PORT} is already used by a different application, please use a different port.\"\n        exit\n      fi\n      ;;\n    esac\n  }\n\n  # Invoke the set-port function to configure the WireGuard server's listening port\n  set-port\n\n  # Define a function to set the NAT keepalive interval.\n  function nat-keepalive() {\n    # Prompt the user to specify the NAT keepalive interval.\n    echo \"What do you want your NAT keepalive interval to be?\"\n    # Provide the user with options for setting the interval.\n    echo \"  1) 25 seconds (Default)\"\n    echo \"  2) Custom (Advanced)\"\n    # Continue prompting the user until a valid option (1 or 2) is selected.\n    until [[ \"${NAT_CHOICE_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Ask the user for their interval choice, with 1 as the default option.\n      read -rp \"Keepalive Choice [1-2]:\" -e -i 1 NAT_CHOICE_SETTINGS\n    done\n    # Set the NAT_CHOICE variable based on the user's choice.\n    case ${NAT_CHOICE_SETTINGS} in\n    1)\n      # If the user chose the default option, set the NAT_CHOICE to 25 seconds.\n      NAT_CHOICE=\"25\"\n      ;;\n    2)\n      # If the user chose the custom option, prompt them to enter a custom interval.\n      until [[ \"${NAT_CHOICE}\" =~ ^[0-9]+$ ]] && [ \"${NAT_CHOICE}\" -ge 1 ] && [ \"${NAT_CHOICE}\" -le 65535 ]; do\n        read -rp \"Custom NAT [1-65535]:\" NAT_CHOICE\n      done\n      # If no custom interval is entered, set the NAT_CHOICE variable to the default of 25 seconds.\n      if [ -z \"${NAT_CHOICE}\" ]; then\n        NAT_CHOICE=\"25\"\n      fi\n      ;;\n    esac\n  }\n  # Invoke the nat-keepalive function to set the NAT keepalive interval.\n  nat-keepalive\n\n  # Define a function to configure the Maximum Transmission Unit (MTU) settings.\n  function mtu-set() {\n    # Ask the user to specify the MTU settings.\n    echo \"What MTU do you want to use?\"\n    # Provide the user with options for setting the MTU.\n    echo \"  1) 1420 for Interface, 1280 for Peer (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Continue prompting the user until a valid option (1 or 2) is selected.\n    until [[ \"${MTU_CHOICE_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Ask the user for their MTU choice, with 1 as the default option.\n      read -rp \"MTU Choice [1-2]:\" -e -i 1 MTU_CHOICE_SETTINGS\n    done\n    # Set the MTU variables based on the user's choice.\n    case ${MTU_CHOICE_SETTINGS} in\n    1)\n      # If the user chose the default option, set the Interface MTU to 1420 and Peer MTU to 1280.\n      INTERFACE_MTU_CHOICE=\"1420\"\n      PEER_MTU_CHOICE=\"1280\"\n      ;;\n    2)\n      # If the user chose the custom option, prompt them to enter a custom MTU for Interface and Peer.\n      until [[ \"${INTERFACE_MTU_CHOICE}\" =~ ^[0-9]+$ ]] && [ \"${INTERFACE_MTU_CHOICE}\" -ge 1 ] && [ \"${INTERFACE_MTU_CHOICE}\" -le 65535 ]; do\n        read -rp \"Custom Interface MTU [1-65535]:\" INTERFACE_MTU_CHOICE\n      done\n      # If no custom Interface MTU is entered, set the INTERFACE_MTU_CHOICE variable to the default of 1420.\n      if [ -z \"${INTERFACE_MTU_CHOICE}\" ]; then\n        INTERFACE_MTU_CHOICE=\"1420\"\n      fi\n      until [[ \"${PEER_MTU_CHOICE}\" =~ ^[0-9]+$ ]] && [ \"${PEER_MTU_CHOICE}\" -ge 1 ] && [ \"${PEER_MTU_CHOICE}\" -le 65535 ]; do\n        read -rp \"Custom Peer MTU [1-65535]:\" PEER_MTU_CHOICE\n      done\n      # If no custom Peer MTU is entered, set the PEER_MTU_CHOICE variable to the default of 1280.\n      if [ -z \"${PEER_MTU_CHOICE}\" ]; then\n        PEER_MTU_CHOICE=\"1280\"\n      fi\n      ;;\n    esac\n  }\n\n  # Invoke the mtu-set function to configure the MTU settings.\n  mtu-set\n\n  # Define a function to select the IP version for the WireGuard server.\n  function ipvx-select() {\n    # Ask the user to specify the IP version to use for connecting to the WireGuard server.\n    echo \"Which IP version do you want to use for the WireGuard server?\"\n    # Provide the user with options for setting the IP version.\n    echo \"  1) IPv4 (Recommended)\"\n    echo \"  2) IPv6\"\n    # Continue prompting the user until a valid option (1 or 2) is selected.\n    until [[ \"${SERVER_HOST_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Ask the user for their IP version choice, with 1 as the default option.\n      read -rp \"IP Version Choice [1-2]:\" -e -i 1 SERVER_HOST_SETTINGS\n    done\n    # Set the SERVER_HOST variable based on the user's choice.\n    case ${SERVER_HOST_SETTINGS} in\n    1)\n      # If the user chose IPv4 and a default IPv4 interface is available, use it.\n      if [ -n \"${DEFAULT_INTERFACE_IPV4}\" ]; then\n        SERVER_HOST=\"${DEFAULT_INTERFACE_IPV4}\"\n      else\n        # If no default IPv4 interface is available, use the default IPv6 interface.\n        SERVER_HOST=\"[${DEFAULT_INTERFACE_IPV6}]\"\n      fi\n      ;;\n    2)\n      # If the user chose IPv6 and a default IPv6 interface is available, use it.\n      if [ -n \"${DEFAULT_INTERFACE_IPV6}\" ]; then\n        SERVER_HOST=\"[${DEFAULT_INTERFACE_IPV6}]\"\n      else\n        # If no default IPv6 interface is available, use the default IPv4 interface.\n        SERVER_HOST=\"${DEFAULT_INTERFACE_IPV4}\"\n      fi\n      ;;\n    esac\n  }\n\n  # Invoke the ipvx-select function to select the IP version for the WireGuard server.\n  ipvx-select\n\n  # Define a function to configure the type of traffic the client is allowed to forward through WireGuard.\n  function client-allowed-ip() {\n    # Ask the user to specify the type of traffic to be forwarded.\n    echo \"What type of traffic do you want the client to forward through WireGuard?\"\n    # Provide the user with options for setting the traffic type.\n    echo \"  1) All Traffic (Recommended)\"\n    echo \"  2) Custom Traffic (Advanced)\"\n    # Continue prompting the user until a valid option (1 or 2) is selected.\n    until [[ \"${CLIENT_ALLOWED_IP_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Ask the user for their traffic type choice, with 1 as the default option.\n      read -rp \"Traffic Type Choice [1-2]:\" -e -i 1 CLIENT_ALLOWED_IP_SETTINGS\n    done\n    # Set the CLIENT_ALLOWED_IP variable based on the user's choice.\n    case ${CLIENT_ALLOWED_IP_SETTINGS} in\n    1)\n      # If the user chose the default option, set the CLIENT_ALLOWED_IP to allow all traffic.\n      CLIENT_ALLOWED_IP=\"0.0.0.0/0,::/0\"\n      ;;\n    2)\n      # If the user chose the custom option, prompt them to enter a custom IP range.\n      read -rp \"Custom IP Range:\" CLIENT_ALLOWED_IP\n      # If no custom IP range is entered, set the CLIENT_ALLOWED_IP variable to allow all traffic.\n      if [ -z \"${CLIENT_ALLOWED_IP}\" ]; then\n        CLIENT_ALLOWED_IP=\"0.0.0.0/0,::/0\"\n      fi\n      ;;\n    esac\n  }\n\n  # Invoke the client-allowed-ip function to configure the type of traffic the client is allowed to forward.\n  client-allowed-ip\n\n  # Function to configure automatic updates\n  function enable-automatic-updates() {\n    # Prompt the user to decide if they want to enable automatic updates\n    echo \"Would you like to setup real-time updates?\"\n    # Option 1: Enable automatic updates\n    echo \"  1) Yes (Recommended)\"\n    # Option 2: Disable automatic updates\n    echo \"  2) No (Advanced)\"\n    # Loop until a valid choice (1 or 2) is made\n    until [[ \"${AUTOMATIC_UPDATES_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Read user input for automatic updates setting\n      read -rp \"Automatic Updates [1-2]:\" -e -i 1 AUTOMATIC_UPDATES_SETTINGS\n    done\n    # Evaluate user choice for automatic updates\n    case ${AUTOMATIC_UPDATES_SETTINGS} in\n    1)\n      # If user chose to enable automatic updates, set up a cron job\n      crontab -l | {\n        cat\n        # Add a cron job to run the script with --update option every day at midnight\n        echo \"0 0 * * * ${CURRENT_FILE_PATH} --update\"\n      } | crontab -\n      # Check the init system in use\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        # If systemd is in use, enable and start the cron service\n        systemctl enable --now ${SYSTEM_CRON_NAME}\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        # If initd is in use, start the cron service\n        service ${SYSTEM_CRON_NAME} start\n      fi\n      ;;\n    2)\n      # If user chose to disable automatic updates, display a confirmation message\n      echo \"Real-time Updates Disabled\"\n      ;;\n    esac\n  }\n\n  # Invoke the function to configure automatic updates\n  enable-automatic-updates\n\n  # Function to configure automatic backup\n  function enable-automatic-backup() {\n    # Prompt the user to decide if they want to enable automatic backup\n    echo \"Would you like to setup real-time backup?\"\n    # Option 1: Enable automatic backup\n    echo \"  1) Yes (Recommended)\"\n    # Option 2: Disable automatic backup\n    echo \"  2) No (Advanced)\"\n    # Loop until a valid choice (1 or 2) is made\n    until [[ \"${AUTOMATIC_BACKUP_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Read user input for automatic backup setting\n      read -rp \"Automatic Backup [1-2]:\" -e -i 1 AUTOMATIC_BACKUP_SETTINGS\n    done\n    # Evaluate user choice for automatic backup\n    case ${AUTOMATIC_BACKUP_SETTINGS} in\n    1)\n      # If user chose to enable automatic backup, set up a cron job\n      crontab -l | {\n        cat\n        # Add a cron job to run the script with --backup option every day at midnight\n        echo \"0 0 * * * ${CURRENT_FILE_PATH} --backup\"\n      } | crontab -\n      # Check the init system in use\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        # If systemd is in use, enable and start the cron service\n        systemctl enable --now ${SYSTEM_CRON_NAME}\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        # If initd is in use, start the cron service\n        service ${SYSTEM_CRON_NAME} start\n      fi\n      ;;\n    2)\n      # If user chose to disable automatic backup, display a confirmation message\n      echo \"Real-time Backup Disabled\"\n      ;;\n    esac\n  }\n\n  # Invoke the function to configure automatic backup\n  enable-automatic-backup\n\n  # Function to prompt the user for their preferred DNS provider.\n  function ask-install-dns() {\n    # Display the DNS provider options to the user.\n    echo \"Which DNS provider would you like to use?\"\n    echo \"  1) Unbound (Recommended)\"\n    echo \"  2) Custom (Advanced)\"\n    # Continue prompting until the user enters a valid choice (1 or 2).\n    until [[ \"${DNS_PROVIDER_SETTINGS}\" =~ ^[1-2]$ ]]; do\n      # Read the user's DNS provider choice and store it in DNS_PROVIDER_SETTINGS.\n      read -rp \"DNS provider [1-2]:\" -e -i 1 DNS_PROVIDER_SETTINGS\n    done\n    # Set variables based on the user's DNS provider choice.\n    case ${DNS_PROVIDER_SETTINGS} in\n    1)\n      # If the user chose Unbound, set INSTALL_UNBOUND to true.\n      INSTALL_UNBOUND=true\n      # Ask the user if they want to install a content-blocker.\n      echo \"Do you want to prevent advertisements, tracking, malware, and phishing using the content-blocker?\"\n      echo \"  1) Yes (Recommended)\"\n      echo \"  2) No\"\n      # Continue prompting until the user enters a valid choice (1 or 2).\n      until [[ \"${CONTENT_BLOCKER_SETTINGS}\" =~ ^[1-2]$ ]]; do\n        # Read the user's content blocker choice and store it in CONTENT_BLOCKER_SETTINGS.\n        read -rp \"Content Blocker Choice [1-2]:\" -e -i 1 CONTENT_BLOCKER_SETTINGS\n      done\n      # Set INSTALL_BLOCK_LIST based on the user's content blocker choice.\n      case ${CONTENT_BLOCKER_SETTINGS} in\n      1)\n        # If the user chose to install the content blocker, set INSTALL_BLOCK_LIST to true.\n        INSTALL_BLOCK_LIST=true\n        ;;\n      2)\n        # If the user chose not to install the content blocker, set INSTALL_BLOCK_LIST to false.\n        INSTALL_BLOCK_LIST=false\n        ;;\n      esac\n      ;;\n    2)\n      # If the user chose to use a custom DNS provider, set CUSTOM_DNS to true.\n      CUSTOM_DNS=true\n      ;;\n    esac\n  }\n\n  # Invoke the ask-install-dns function to begin the DNS provider selection process.\n  ask-install-dns\n\n  # Function to allow users to select a custom DNS provider.\n  function custom-dns() {\n    # If the custom DNS option is enabled, proceed with the DNS selection.\n    if [ \"${CUSTOM_DNS}\" == true ]; then\n      # Present the user with a list of DNS providers to choose from.\n      echo \"Select the DNS provider you wish to use with your WireGuard connection:\"\n      echo \"  1) Cloudflare (Recommended)\"\n      echo \"  2) AdGuard\"\n      echo \"  3) NextDNS\"\n      echo \"  4) OpenDNS\"\n      echo \"  5) Google\"\n      echo \"  6) Verisign\"\n      echo \"  7) Quad9\"\n      echo \"  8) FDN\"\n      echo \"  9) Custom (Advanced)\"\n      # If Pi-Hole is installed, add it as an option.\n      if [ -x \"$(command -v pihole)\" ]; then\n        echo \"  10) Pi-Hole (Advanced)\"\n      fi\n      # Prompt the user to make a selection from the list of DNS providers.\n      until [[ \"${CLIENT_DNS_SETTINGS}\" =~ ^[0-9]+$ ]] && [ \"${CLIENT_DNS_SETTINGS}\" -ge 1 ] && [ \"${CLIENT_DNS_SETTINGS}\" -le 10 ]; do\n        read -rp \"DNS [1-10]:\" -e -i 1 CLIENT_DNS_SETTINGS\n      done\n      # Based on the user's selection, set the DNS addresses.\n      case ${CLIENT_DNS_SETTINGS} in\n      1)\n        # Set DNS addresses for Cloudflare.\n        CLIENT_DNS=\"1.1.1.1,1.0.0.1,2606:4700:4700::1111,2606:4700:4700::1001\"\n        ;;\n      2)\n        # Set DNS addresses for AdGuard.\n        CLIENT_DNS=\"94.140.14.14,94.140.15.15,2a10:50c0::ad1:ff,2a10:50c0::ad2:ff\"\n        ;;\n      3)\n        # Set DNS addresses for NextDNS.\n        CLIENT_DNS=\"45.90.28.167,45.90.30.167,2a07:a8c0::12:cf53,2a07:a8c1::12:cf53\"\n        ;;\n      4)\n        # Set DNS addresses for OpenDNS.\n        CLIENT_DNS=\"208.67.222.222,208.67.220.220,2620:119:35::35,2620:119:53::53\"\n        ;;\n      5)\n        # Set DNS addresses for Google.\n        CLIENT_DNS=\"8.8.8.8,8.8.4.4,2001:4860:4860::8888,2001:4860:4860::8844\"\n        ;;\n      6)\n        # Set DNS addresses for Verisign.\n        CLIENT_DNS=\"64.6.64.6,64.6.65.6,2620:74:1b::1:1,2620:74:1c::2:2\"\n        ;;\n      7)\n        # Set DNS addresses for Quad9.\n        CLIENT_DNS=\"9.9.9.9,149.112.112.112,2620:fe::fe,2620:fe::9\"\n        ;;\n      8)\n        # Set DNS addresses for FDN.\n        CLIENT_DNS=\"80.67.169.40,80.67.169.12,2001:910:800::40,2001:910:800::12\"\n        ;;\n      9)\n        # Prompt the user to enter a custom DNS address.\n        read -rp \"Custom DNS:\" CLIENT_DNS\n        # If the user doesn't provide a custom DNS, default to Google's DNS.\n        if [ -z \"${CLIENT_DNS}\" ]; then\n          CLIENT_DNS=\"8.8.8.8,8.8.4.4,2001:4860:4860::8888,2001:4860:4860::8844\"\n        fi\n        ;;\n      10)\n        # If Pi-Hole is installed, use its DNS. Otherwise, install Unbound and enable the block list.\n        if [ -x \"$(command -v pihole)\" ]; then\n          CLIENT_DNS=\"${GATEWAY_ADDRESS_V4},${GATEWAY_ADDRESS_V6}\"\n        else\n          INSTALL_UNBOUND=true\n          INSTALL_BLOCK_LIST=true\n        fi\n        ;;\n      esac\n    fi\n  }\n\n  # Invoke the custom-dns function to allow the user to select a DNS provider.\n  custom-dns\n\n  # Function to prompt for the name of the first WireGuard peer.\n  function client-name() {\n    # If CLIENT_NAME variable is not set, prompt the user for input.\n    if [ -z \"${CLIENT_NAME}\" ]; then\n      # Display naming rules to the user.\n      echo \"Please provide a name for the WireGuard Peer. The name should be a single word, without special characters or spaces.\"\n      # Read the user's input, offering a random string as the default name.\n      read -rp \"Client name:\" -e -i \"$(openssl rand -hex 25)\" CLIENT_NAME\n    fi\n    # If no name is provided by the user, assign a random string as the name.\n    if [ -z \"${CLIENT_NAME}\" ]; then\n      CLIENT_NAME=\"$(openssl rand -hex 25)\"\n    fi\n  }\n\n  # Invoke the function to prompt for the first WireGuard peer's name.\n  client-name\n\n  # Function to set up automatic deletion of WireGuard peers.\n  function auto-remove-config() {\n    # Ask the user if they want to set an expiration date for the peer.\n    echo \"Do you want to set an expiration date for the peer?\"\n    echo \"  1) Yes, expire after one year (Recommended)\"\n    echo \"  2) No, do not expire\"\n    # Keep asking until the user enters 1 or 2.\n    until [[ \"${AUTOMATIC_CONFIG_REMOVER}\" =~ ^[1-2]$ ]]; do\n      read -rp \"Choose an option for peer expiration [1-2]:\" -e -i 1 AUTOMATIC_CONFIG_REMOVER\n    done\n    # Execute actions based on the user's choice.\n    case ${AUTOMATIC_CONFIG_REMOVER} in\n    1)\n      # If the user chose to expire the peer, set the expiration flag to true.\n      AUTOMATIC_WIREGUARD_EXPIRATION=true\n      # Depending on the init system, enable and start the cron service.\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        systemctl enable --now ${SYSTEM_CRON_NAME}\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        service ${SYSTEM_CRON_NAME} start\n      fi\n      ;;\n    2)\n      # If the user chose not to expire the peer, set the expiration flag to false.\n      AUTOMATIC_WIREGUARD_EXPIRATION=false\n      ;;\n    esac\n  }\n\n  # Invoke the function to set up automatic deletion of WireGuard peers.\n  auto-remove-config\n\n  # Function to verify kernel version and install necessary kernel headers.\n  function install-kernel-headers() {\n    # Define the minimum kernel version required and extract its major and minor version numbers.\n    MINIMUM_KERNEL_VERSION=\"5.6\"\n    MINIMUM_KERNEL_MAJOR_VERSION=$(echo ${MINIMUM_KERNEL_VERSION} | cut --delimiter=\".\" --fields=1)\n    MINIMUM_KERNEL_MINOR_VERSION=$(echo ${MINIMUM_KERNEL_VERSION} | cut --delimiter=\".\" --fields=2)\n    # Check if the current kernel version is less than or equal to the minimum required version.\n    if [ \"${CURRENT_KERNEL_MAJOR_VERSION}\" -le \"${MINIMUM_KERNEL_MAJOR_VERSION}\" ]; then\n      INSTALL_LINUX_HEADERS=true\n    fi\n    # If the current kernel major version matches the minimum required major version, compare minor versions.\n    if [ \"${CURRENT_KERNEL_MAJOR_VERSION}\" == \"${MINIMUM_KERNEL_MAJOR_VERSION}\" ]; then\n      # If the current minor version is less than the required, set flag to install headers.\n      if [ \"${CURRENT_KERNEL_MINOR_VERSION}\" -lt \"${MINIMUM_KERNEL_MINOR_VERSION}\" ]; then\n        INSTALL_LINUX_HEADERS=true\n      fi\n      # If the current minor version is greater than or equal to the required, set flag to not install headers.\n      if [ \"${CURRENT_KERNEL_MINOR_VERSION}\" -ge \"${MINIMUM_KERNEL_MINOR_VERSION}\" ]; then\n        INSTALL_LINUX_HEADERS=false\n      fi\n    fi\n    # If the flag to install headers is set, install appropriate headers based on the Linux distribution.\n    if [ \"${INSTALL_LINUX_HEADERS}\" == true ]; then\n      if { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n        apt-get update\n        apt-get install linux-headers-\"$(uname --kernel-release)\" -y\n      elif [ \"${CURRENT_DISTRO}\" == \"raspbian\" ]; then\n        apt-get update\n        apt-get install raspberrypi-kernel-headers -y\n      elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n        pacman -Su --noconfirm --needed linux-headers\n      elif { [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"ol\" ]; }; then\n        yum check-update\n        yum install kernel-headers-\"$(uname --kernel-release)\" kernel-devel-\"$(uname --kernel-release)\" -y\n      elif { [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n        yum check-update\n        yum install kernel-headers-\"$(uname --kernel-release)\" kernel-devel-\"$(uname --kernel-release)\" -y\n      fi\n    fi\n  }\n\n  # Invoke the function to verify kernel version and install necessary kernel headers.\n  install-kernel-headers\n\n  # Function to install either resolvconf or openresolv, depending on the distribution.\n  function install-resolvconf-or-openresolv() {\n    # Check if resolvconf is already installed on the system.\n    if [ ! -x \"$(command -v resolvconf)\" ]; then\n      # If resolvconf is not installed, install it for Ubuntu, Debian, Raspbian, Pop, Kali, Linux Mint, and Neon distributions.\n      if { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n        apt-get install resolvconf -y\n      # For CentOS, RHEL, AlmaLinux, and Rocky distributions, install openresolv.\n      elif { [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n        # If the distribution is CentOS 7, enable the copr repository before installing openresolv.\n        if [ \"${CURRENT_DISTRO}\" == \"centos\" ] && [ \"${CURRENT_DISTRO_MAJOR_VERSION}\" == 7 ]; then\n          yum copr enable macieks/openresolv -y\n        fi\n        yum install openresolv -y\n      # For Fedora and Oracle Linux distributions, install openresolv.\n      elif { [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"ol\" ]; }; then\n        yum install openresolv -y\n      # For Arch, Arch ARM, and Manjaro distributions, install resolvconf.\n      elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n        pacman -Su --noconfirm --needed resolvconf\n      # For Alpine Linux, install resolvconf.\n      elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n        apk add resolvconf\n      # For FreeBSD, install resolvconf.\n      elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n        pkg install resolvconf\n      fi\n    fi\n  }\n\n  # Invoke the function to install either resolvconf or openresolv, depending on the distribution.\n  install-resolvconf-or-openresolv\n\n  # Function to install the WireGuard server if it's not already installed.\n  function install-wireguard-server() {\n    # Verify if the WireGuard command (wg) is available on the system.\n    if [ ! -x \"$(command -v wg)\" ]; then\n      # For Debian-based distributions, update the package list and install WireGuard.\n      if { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n        apt-get update\n        apt-get install wireguard -y\n      # For Arch-based distributions, update the package list and install WireGuard tools.\n      elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n        pacman -Su --noconfirm --needed wireguard-tools\n      elif [ \"${CURRENT_DISTRO}\" = \"fedora\" ]; then\n        dnf check-update\n        dnf copr enable jdoss/wireguard -y\n        dnf install wireguard-tools -y\n      # For CentOS, update the package list and install WireGuard tools and kernel module.\n      elif [ \"${CURRENT_DISTRO}\" == \"centos\" ]; then\n        yum check-update\n        yum install kmod-wireguard wireguard-tools -y\n      # For RHEL, install necessary repositories and then install WireGuard tools and kernel module.\n      elif [ \"${CURRENT_DISTRO}\" == \"rhel\" ]; then\n        yum check-update\n        yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-\"${CURRENT_DISTRO_MAJOR_VERSION}\".noarch.rpm https://www.elrepo.org/elrepo-release-\"${CURRENT_DISTRO_MAJOR_VERSION}\".el\"${CURRENT_DISTRO_MAJOR_VERSION}\".elrepo.noarch.rpm\n        yum check-update\n        yum install kmod-wireguard wireguard-tools -y\n      # For Alpine Linux, update the package list and install WireGuard tools.\n      elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n        apk update\n        apk add wireguard-tools\n      # For FreeBSD, update the package list and install WireGuard.\n      elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n        pkg update\n        pkg install wireguard\n      # For AlmaLinux and Rocky, update the package list and install WireGuard tools and kernel module.\n      elif { [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n        yum check-update\n        yum install kmod-wireguard wireguard-tools -y\n      # For Oracle Linux, configure necessary repositories and then install WireGuard tools.\n      elif [ \"${CURRENT_DISTRO}\" == \"ol\" ]; then\n        yum check-update\n        yum install oraclelinux-developer-release-el\"${CURRENT_DISTRO_MAJOR_VERSION}\" -y\n        yum config-manager --disable ol\"${CURRENT_DISTRO_MAJOR_VERSION}\"_developer\n        yum config-manager --enable ol\"${CURRENT_DISTRO_MAJOR_VERSION}\"_developer_UEKR6\n        yum config-manager --save --setopt=ol\"${CURRENT_DISTRO_MAJOR_VERSION}\"_developer_UEKR6.includepkgs='wireguard-tools*'\n        yum install wireguard-tools -y\n      fi\n    fi\n  }\n\n  # Invoke the function to install the WireGuard server.\n  install-wireguard-server\n\n  # Function to install Unbound, a DNS resolver, if required and not already installed.\n  function install-unbound() {\n    # If INSTALL_UNBOUND is true and Unbound is not installed, proceed with installation.\n    if [ \"${INSTALL_UNBOUND}\" == true ]; then\n      if [ ! -x \"$(command -v unbound)\" ]; then\n        # Installation commands for Unbound vary based on the Linux distribution.\n        # The following checks the distribution and installs Unbound accordingly.\n        # For Debian-based distributions:\n        if { [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n          apt-get install unbound unbound-host unbound-anchor -y\n          # If the distribution is Ubuntu, disable systemd-resolved.\n          if [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ]; then\n            if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n              systemctl disable --now systemd-resolved\n            elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n              service systemd-resolved stop\n            fi\n          fi\n        # For CentOS, RHEL, AlmaLinux, and Rocky:\n        elif { [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n          yum install unbound unbound-host unbound-anchor -y\n        # For Fedora:\n        elif [ \"${CURRENT_DISTRO}\" == \"fedora\" ]; then\n          dnf install unbound unbound-host unbound-anchor -y\n        # For Arch-based distributions:\n        elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n          pacman -Su --noconfirm --needed unbound\n        # For Alpine Linux:\n        elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n          apk add unbound unbound-host unbound-anchor\n        # For FreeBSD:\n        elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n          pkg install unbound unbound-host unbound-anchor\n        # For Oracle Linux:\n        elif [ \"${CURRENT_DISTRO}\" == \"ol\" ]; then\n          yum install unbound unbound-host unbound-anchor -y\n        fi\n      fi\n      # Configure Unbound using anchor and root hints.\n      unbound-anchor -a ${UNBOUND_ANCHOR}\n      # Download root hints.\n      curl \"${UNBOUND_ROOT_SERVER_CONFIG_URL}\" --create-dirs -o ${UNBOUND_ROOT_HINTS}\n      # Configure Unbound settings.\n      # The settings are stored in a temporary variable and then written to the Unbound configuration file.\n      # If INSTALL_BLOCK_LIST is true, include a block list in the Unbound configuration.\n      # Configure Unbound settings.\n      UNBOUND_TEMP_INTERFACE_INFO=\"server:\n\\tnum-threads: $(nproc)\n\\tverbosity: 0\n\\troot-hints: ${UNBOUND_ROOT_HINTS}\n\\tauto-trust-anchor-file: ${UNBOUND_ANCHOR}\n\\tinterface: 0.0.0.0\n\\tinterface: ::0\n\\tport: 53\n\\tmax-udp-size: 3072\n\\taccess-control: 0.0.0.0/0\\trefuse\n\\taccess-control: ::0\\trefuse\n\\taccess-control: ${PRIVATE_SUBNET_V4}\\tallow\n\\taccess-control: ${PRIVATE_SUBNET_V6}\\tallow\n\\taccess-control: 127.0.0.1\\tallow\n\\taccess-control: ::1\\tallow\n\\tprivate-address: ${PRIVATE_SUBNET_V4}\n\\tprivate-address: ${PRIVATE_SUBNET_V6}\n\\tprivate-address: 10.0.0.0/8\n\\tprivate-address: 127.0.0.0/8\n\\tprivate-address: 169.254.0.0/16\n\\tprivate-address: 172.16.0.0/12\n\\tprivate-address: 192.168.0.0/16\n\\tprivate-address: ::ffff:0:0/96\n\\tprivate-address: fd00::/8\n\\tprivate-address: fe80::/10\n\\tdo-ip4: yes\n\\tdo-ip6: yes\n\\tdo-udp: yes\n\\tdo-tcp: yes\n\\tchroot: \\\"\\\"\n\\thide-identity: yes\n\\thide-version: yes\n\\tharden-glue: yes\n\\tharden-dnssec-stripped: yes\n\\tharden-referral-path: yes\n\\tunwanted-reply-threshold: 10000000\n\\tcache-min-ttl: 86400\n\\tcache-max-ttl: 2592000\n\\tprefetch: yes\n\\tqname-minimisation: yes\n\\tprefetch-key: yes\"\n      echo -e \"${UNBOUND_TEMP_INTERFACE_INFO}\" | awk '!seen[$0]++' >${UNBOUND_CONFIG}\n      # Configure block list if INSTALL_BLOCK_LIST is true.\n      if [ \"${INSTALL_BLOCK_LIST}\" == true ]; then\n        echo -e \"\\tinclude: ${UNBOUND_CONFIG_HOST}\" >>${UNBOUND_CONFIG}\n        if [ ! -d \"${UNBOUND_CONFIG_DIRECTORY}\" ]; then\n          mkdir --parents \"${UNBOUND_CONFIG_DIRECTORY}\"\n        fi\n        curl \"${UNBOUND_CONFIG_HOST_URL}\" | awk '{print \"local-zone: \\\"\"$1\"\\\" always_refuse\"}' >${UNBOUND_CONFIG_HOST}\n      fi\n      # Update ownership of Unbound's root directory.\n      chown --recursive \"${USER}\":\"${USER}\" ${UNBOUND_ROOT}\n      # Update the resolv.conf file to use Unbound.\n      if [ -f \"${RESOLV_CONFIG_OLD}\" ]; then\n        rm --force ${RESOLV_CONFIG_OLD}\n      fi\n      if [ -f \"${RESOLV_CONFIG}\" ]; then\n        chattr -i ${RESOLV_CONFIG}\n        mv ${RESOLV_CONFIG} ${RESOLV_CONFIG_OLD}\n      fi\n      echo \"nameserver 127.0.0.1\" >${RESOLV_CONFIG}\n      echo \"nameserver ::1\" >>${RESOLV_CONFIG}\n      chattr +i ${RESOLV_CONFIG}\n      # Save Unbound status to UNBOUND_MANAGER file.\n      echo \"Unbound: true\" >${UNBOUND_MANAGER}\n      # Set CLIENT_DNS to use gateway addresses.\n      CLIENT_DNS=\"${GATEWAY_ADDRESS_V4},${GATEWAY_ADDRESS_V6}\"\n    fi\n  }\n\n  # Call the function to install Unbound.\n  install-unbound\n\n  # Function to configure WireGuard settings\n  function wireguard-setconf() {\n    # Generate server private and public keys\n    SERVER_PRIVKEY=$(wg genkey)\n    SERVER_PUBKEY=$(echo \"${SERVER_PRIVKEY}\" | wg pubkey)\n    # Generate client private and public keys\n    CLIENT_PRIVKEY=$(wg genkey)\n    CLIENT_PUBKEY=$(echo \"${CLIENT_PRIVKEY}\" | wg pubkey)\n    # Assign client IPv4 and IPv6 addresses\n    CLIENT_ADDRESS_V4=$(echo \"${PRIVATE_SUBNET_V4}\" | cut --delimiter=\".\" --fields=1-3).2\n    CLIENT_ADDRESS_V6=$(echo \"${PRIVATE_SUBNET_V6}\" | cut --delimiter=\":\" --fields=1-4):2\n    # Generate pre-shared key and random port for the client\n    PRESHARED_KEY=$(wg genpsk)\n    PEER_PORT=$(shuf --input-range=1024-65535 --head-count=1)\n    # Create the wireguard directory\n    mkdir --parents ${WIREGUARD_PATH}\n    # Create the client configuration directory\n    mkdir --parents ${WIREGUARD_CLIENT_PATH}\n    # Set up nftables rules depending on whether Unbound is installed\n    if [ \"${INSTALL_UNBOUND}\" == true ]; then\n      # Set up nftables rules for when Unbound is installed\n      NFTABLES_POSTUP=\"sysctl --write net.ipv4.ip_forward=1; sysctl --write net.ipv6.conf.all.forwarding=1; nft add table inet wireguard-${WIREGUARD_PUB_NIC}; nft add chain inet wireguard-${WIREGUARD_PUB_NIC} wireguard_chain {type nat hook postrouting priority srcnat\\;}; nft add rule inet wireguard-${WIREGUARD_PUB_NIC} wireguard_chain oifname ${SERVER_PUB_NIC} masquerade\"\n      NFTABLES_POSTDOWN=\"sysctl --write net.ipv4.ip_forward=0; sysctl --write net.ipv6.conf.all.forwarding=0; nft delete table inet wireguard-${WIREGUARD_PUB_NIC}\"\n    else\n      # Set up nftables rules for when Unbound is not installed\n      NFTABLES_POSTUP=\"sysctl --write net.ipv4.ip_forward=1; sysctl --write net.ipv6.conf.all.forwarding=1; nft add table inet wireguard-${WIREGUARD_PUB_NIC}; nft add chain inet wireguard-${WIREGUARD_PUB_NIC} PREROUTING {type nat hook prerouting priority 0\\;}; nft add chain inet wireguard-${WIREGUARD_PUB_NIC} POSTROUTING {type nat hook postrouting priority 100\\;}; nft add rule inet wireguard-${WIREGUARD_PUB_NIC} POSTROUTING ip saddr ${PRIVATE_SUBNET_V4} oifname ${SERVER_PUB_NIC} masquerade; nft add rule inet wireguard-${WIREGUARD_PUB_NIC} POSTROUTING ip6 saddr ${PRIVATE_SUBNET_V6} oifname ${SERVER_PUB_NIC} masquerade\"\n      NFTABLES_POSTDOWN=\"sysctl --write net.ipv4.ip_forward=0; sysctl --write net.ipv6.conf.all.forwarding=0; nft delete table inet wireguard-${WIREGUARD_PUB_NIC}\"\n    fi\n    # Create server WireGuard configuration file\n    echo \"# ${PRIVATE_SUBNET_V4} ${PRIVATE_SUBNET_V6} ${SERVER_HOST}:${SERVER_PORT} ${SERVER_PUBKEY} ${CLIENT_DNS} ${PEER_MTU_CHOICE} ${NAT_CHOICE} ${CLIENT_ALLOWED_IP}\n[Interface]\nAddress = ${GATEWAY_ADDRESS_V4}/${PRIVATE_SUBNET_MASK_V4},${GATEWAY_ADDRESS_V6}/${PRIVATE_SUBNET_MASK_V6}\nListenPort = ${SERVER_PORT}\nMTU = ${INTERFACE_MTU_CHOICE}\nPrivateKey = ${SERVER_PRIVKEY}\nPostUp = ${NFTABLES_POSTUP}\nPostDown = ${NFTABLES_POSTDOWN}\nSaveConfig = false\n# ${CLIENT_NAME} start\n[Peer]\nPublicKey = ${CLIENT_PUBKEY}\nPresharedKey = ${PRESHARED_KEY}\nAllowedIPs = ${CLIENT_ADDRESS_V4}/32,${CLIENT_ADDRESS_V6}/128\n# ${CLIENT_NAME} end\" >>${WIREGUARD_CONFIG}\n\n    # Generate client-specific WireGuard configuration file\n    echo \"# ${WIREGUARD_WEBSITE_URL}\n[Interface]\nAddress = ${CLIENT_ADDRESS_V4}/${PRIVATE_SUBNET_MASK_V4},${CLIENT_ADDRESS_V6}/${PRIVATE_SUBNET_MASK_V6}\nDNS = ${CLIENT_DNS}\nListenPort = ${PEER_PORT}\nMTU = ${PEER_MTU_CHOICE}\nPrivateKey = ${CLIENT_PRIVKEY}\n[Peer]\nAllowedIPs = ${CLIENT_ALLOWED_IP}\nEndpoint = ${SERVER_HOST}:${SERVER_PORT}\nPersistentKeepalive = ${NAT_CHOICE}\nPresharedKey = ${PRESHARED_KEY}\nPublicKey = ${SERVER_PUBKEY}\" >>${WIREGUARD_CLIENT_PATH}/\"${CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n    # Update ownership of the WireGuard configuration directory to root\n    chown --recursive root:root ${WIREGUARD_PATH}\n    # Apply appropriate permissions to the WireGuard configuration directory\n    find ${WIREGUARD_PATH} -type d -exec chmod 700 {} +\n    # Apply appropriate permissions to the WireGuard configuration files\n    find ${WIREGUARD_PATH} -type f -exec chmod 600 {} +\n    # Schedule automatic WireGuard expiration if enabled\n    if [ \"${AUTOMATIC_WIREGUARD_EXPIRATION}\" == true ]; then\n      crontab -l | {\n        cat\n        echo \"$(date +%M) $(date +%H) $(date +%d) $(date +%m) * echo -e \\\"${CLIENT_NAME}\\\" | ${CURRENT_FILE_PATH} --remove\"\n      } | crontab -\n    fi\n    # Initiate and set the necessary services to run at startup, depending on the init system (either systemd or init)\n    if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n      systemctl enable --now nftables\n      systemctl enable --now wg-quick@${WIREGUARD_PUB_NIC}\n      if [ \"${INSTALL_UNBOUND}\" == true ]; then\n        systemctl enable --now unbound\n        systemctl restart unbound\n      fi\n    elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n      service nftables start\n      service wg-quick@${WIREGUARD_PUB_NIC} start\n      if [ \"${INSTALL_UNBOUND}\" == true ]; then\n        service unbound restart\n      fi\n    fi\n    # Create a QR code for the client configuration for easy scanning\n    qrencode -t ansiutf8 <${WIREGUARD_CLIENT_PATH}/\"${CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n    # Display the client configuration details in the terminal\n    cat ${WIREGUARD_CLIENT_PATH}/\"${CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n    # Show the path where the client configuration file is stored\n    echo \"Client Config --> ${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\"\n  }\n\n  # Configuring WireGuard settings\n  wireguard-setconf\n\n# After WireGuard Install\nelse\n\n  # What to do if the software is already installed?\n  function wireguard-next-questions-interface() {\n    echo \"Please select an action:\"\n    echo \"   1) Display WireGuard configuration\"\n    echo \"   2) Initiate WireGuard service\"\n    echo \"   3) Terminate WireGuard service\"\n    echo \"   4) Restart WireGuard service\"\n    echo \"   5) Add a new WireGuard peer (client)\"\n    echo \"   6) Remove a WireGuard peer (client)\"\n    echo \"   7) Reinstall WireGuard service\"\n    echo \"   8) Uninstall WireGuard service\"\n    echo \"   9) Update this management script\"\n    echo \"   10) Backup WireGuard configuration\"\n    echo \"   11) Restore WireGuard configuration\"\n    echo \"   12) Update WireGuard interface IP\"\n    echo \"   13) Update WireGuard interface port\"\n    echo \"   14) Purge all WireGuard peers\"\n    echo \"   15) Generate a QR code for WireGuard configuration\"\n    echo \"   16) Verify WireGuard configurations\"\n    until [[ \"${WIREGUARD_OPTIONS}\" =~ ^[0-9]+$ ]] && [ \"${WIREGUARD_OPTIONS}\" -ge 1 ] && [ \"${WIREGUARD_OPTIONS}\" -le 16 ]; do\n      read -rp \"Select an Option [1-16]:\" -e -i 0 WIREGUARD_OPTIONS\n    done\n    case ${WIREGUARD_OPTIONS} in\n    1) # Display WireGuard configuration\n      wg show ${WIREGUARD_PUB_NIC}\n      ;;\n    2) # Initiate WireGuard service\n      wg-quick up ${WIREGUARD_PUB_NIC}\n      ;;\n    3) # Terminate WireGuard service\n      wg-quick down ${WIREGUARD_PUB_NIC}\n      ;;\n    4) # Restart the WireGuard service\n      # The script first identifies the init system (either \"systemd\" or \"init\")\n      # Then, it restarts the WireGuard service based on the identified init system\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        systemctl restart wg-quick@${WIREGUARD_PUB_NIC}\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        service wg-quick@${WIREGUARD_PUB_NIC} restart\n      fi\n      ;;\n    5) # Adding a new peer to WireGuard\n      # If a client name isn't supplied, the script will request one\n      if [ -z \"${NEW_CLIENT_NAME}\" ]; then\n        echo \"Let's name the WireGuard Peer. Use one word only, no special characters, no spaces.\"\n        read -rp \"New client peer:\" -e -i \"$(openssl rand -hex 25)\" NEW_CLIENT_NAME\n      fi\n      # If no client name is provided, use openssl to generate a random name\n      if [ -z \"${NEW_CLIENT_NAME}\" ]; then\n        NEW_CLIENT_NAME=\"$(openssl rand -hex 25)\"\n      fi\n      # Extract the last IPv4 address used in the WireGuard configuration file\n      LASTIPV4=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=4 | tail --lines=1)\n      # Extract the last IPv6 address used in the WireGuard configuration file\n      LASTIPV6=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\",\" --fields=2 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=5 | tail --lines=1)\n      # If no IPv4 and IPv6 addresses are found in the configuration file, set the initial values to 1\n      if { [ -z \"${LASTIPV4}\" ] && [ -z \"${LASTIPV6}\" ]; }; then\n        LASTIPV4=1\n        LASTIPV6=1\n      fi\n      # Find the smallest used IPv4 address in the WireGuard configuration file\n      SMALLEST_USED_IPV4=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=4 | sort --numeric-sort | head --lines=1)\n      # Find the largest used IPv4 address in the WireGuard configuration file\n      LARGEST_USED_IPV4=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=4 | sort --numeric-sort | tail --lines=1)\n      # Create a list of used IPv4 addresses in the WireGuard configuration file\n      USED_IPV4_LIST=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=4 | sort --numeric-sort)\n      # Loop through IPv4 addresses and find an unused one\n      while [ \"${SMALLEST_USED_IPV4}\" -le \"${LARGEST_USED_IPV4}\" ]; do\n        if [[ ! ${USED_IPV4_LIST[*]} =~ ${SMALLEST_USED_IPV4} ]]; then\n          FIND_UNUSED_IPV4=${SMALLEST_USED_IPV4}\n          break\n        fi\n        SMALLEST_USED_IPV4=$((SMALLEST_USED_IPV4 + 1))\n      done\n      # Find the smallest used IPv6 address in the WireGuard configuration file\n      SMALLEST_USED_IPV6=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\",\" --fields=2 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=5 | sort --numeric-sort | head --lines=1)\n      # Find the largest used IPv6 address in the WireGuard configuration file\n      LARGEST_USED_IPV6=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\",\" --fields=2 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=5 | sort --numeric-sort | tail --lines=1)\n      # Create a list of used IPv6 addresses in the WireGuard configuration file\n      USED_IPV6_LIST=$(grep \"AllowedIPs\" ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\",\" --fields=2 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=5 | sort --numeric-sort)\n      # Loop through IPv6 addresses and find an unused one\n      while [ \"${SMALLEST_USED_IPV6}\" -le \"${LARGEST_USED_IPV6}\" ]; do\n        if [[ ! ${USED_IPV6_LIST[*]} =~ ${SMALLEST_USED_IPV6} ]]; then\n          FIND_UNUSED_IPV6=${SMALLEST_USED_IPV6}\n          break\n        fi\n        SMALLEST_USED_IPV6=$((SMALLEST_USED_IPV6 + 1))\n      done\n      # If unused IPv4 and IPv6 addresses are found, set them as the last IPv4 and IPv6 addresses\n      if { [ -n \"${FIND_UNUSED_IPV4}\" ] && [ -n \"${FIND_UNUSED_IPV6}\" ]; }; then\n        LASTIPV4=$(echo \"${FIND_UNUSED_IPV4}\" | head --lines=1)\n        LASTIPV6=$(echo \"${FIND_UNUSED_IPV6}\" | head --lines=1)\n      fi\n      if { [ \"${LASTIPV4}\" -ge 255 ] && [ \"${LASTIPV6}\" -ge 255 ]; }; then\n        # Get the current IPv4 and IPv6 ranges from the WireGuard config file\n        CURRENT_IPV4_RANGE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2)\n        CURRENT_IPV6_RANGE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3)\n        # Get the last octet of the IPv4 range and the fifth hextet of the IPv6 range\n        IPV4_BEFORE_BACKSLASH=$(echo \"${CURRENT_IPV4_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=4)\n        IPV6_BEFORE_BACKSLASH=$(echo \"${CURRENT_IPV6_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=5)\n        # Get the second octet of the IPv4 range and the second hextet of the IPv6 range\n        IPV4_AFTER_FIRST=$(echo \"${CURRENT_IPV4_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=2)\n        IPV6_AFTER_FIRST=$(echo \"${CURRENT_IPV6_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=2)\n        # Get the second and third octets of the IPv4 range and the third and fourth hextets of the IPv6 range\n        SECOND_IPV4_IN_RANGE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=2)\n        SECOND_IPV6_IN_RANGE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=2)\n        THIRD_IPV4_IN_RANGE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=3)\n        THIRD_IPV6_IN_RANGE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=3)\n        # Calculate the next IPv4 and IPv6 ranges\n        NEXT_IPV4_RANGE=$((THIRD_IPV4_IN_RANGE + 1))\n        NEXT_IPV6_RANGE=$((THIRD_IPV6_IN_RANGE + 1))\n        # Get the CIDR notation for the current IPv4 and IPv6 ranges\n        CURRENT_IPV4_RANGE_CIDR=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2 | cut --delimiter=\"/\" --fields=2)\n        CURRENT_IPV6_RANGE_CIDR=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3 | cut --delimiter=\"/\" --fields=2)\n        FINAL_IPV4_RANGE=$(echo \"${CURRENT_IPV4_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=1,2)\".${NEXT_IPV4_RANGE}.${IPV4_BEFORE_BACKSLASH}/${CURRENT_IPV4_RANGE_CIDR}\"\n        FINAL_IPV6_RANGE=$(echo \"${CURRENT_IPV6_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=1,2)\":${NEXT_IPV6_RANGE}::${IPV6_BEFORE_BACKSLASH}/${CURRENT_IPV6_RANGE_CIDR}\"\n        if { [ \"${THIRD_IPV4_IN_RANGE}\" -ge 255 ] && [ \"${THIRD_IPV6_IN_RANGE}\" -ge 255 ]; }; then\n          if { [ \"${SECOND_IPV4_IN_RANGE}\" -ge 255 ] && [ \"${SECOND_IPV6_IN_RANGE}\" -ge 255 ] && [ \"${THIRD_IPV4_IN_RANGE}\" -ge 255 ] && [ \"${THIRD_IPV6_IN_RANGE}\" -ge 255 ] && [ \"${LASTIPV4}\" -ge 255 ] && [ \"${LASTIPV6}\" -ge 255 ]; }; then\n            # If all IP ranges are at their maximum value, then exit with an error message\n            echo \"Error: You are unable to add any more peers.\"\n            exit\n          fi\n          # Calculate the next IPv4 and IPv6 ranges\n          NEXT_IPV4_RANGE=$((SECOND_IPV4_IN_RANGE + 1))\n          NEXT_IPV6_RANGE=$((SECOND_IPV6_IN_RANGE + 1))\n          # Calculate the final IPv4 and IPv6 ranges\n          FINAL_IPV4_RANGE=$(echo \"${CURRENT_IPV4_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\".\" --fields=1)\".${NEXT_IPV4_RANGE}.${IPV4_AFTER_FIRST}.${IPV4_BEFORE_BACKSLASH}/${CURRENT_IPV4_RANGE_CIDR}\"\n          FINAL_IPV6_RANGE=$(echo \"${CURRENT_IPV6_RANGE}\" | cut --delimiter=\"/\" --fields=1 | cut --delimiter=\":\" --fields=1)\":${NEXT_IPV6_RANGE}:${IPV6_AFTER_FIRST}::${IPV6_BEFORE_BACKSLASH}/${CURRENT_IPV6_RANGE_CIDR}\"\n        fi\n        # Replace the current IPv4 and IPv6 ranges with the final IPv4 and IPv6 ranges in the WireGuard config file\n        sed --in-place \"1s|${CURRENT_IPV4_RANGE}|${FINAL_IPV4_RANGE}|\" ${WIREGUARD_CONFIG}\n        sed --in-place \"1s|${CURRENT_IPV6_RANGE}|${FINAL_IPV6_RANGE}|\" ${WIREGUARD_CONFIG}\n        # Set LASTIPV4 and LASTIPV6 to their maximum values to indicate that no more peers can be added\n        LASTIPV4=1\n        LASTIPV6=1\n      fi\n      # Generate a private key for the client\n      CLIENT_PRIVKEY=$(wg genkey)\n      # Derive the public key from the private key\n      CLIENT_PUBKEY=$(echo \"${CLIENT_PRIVKEY}\" | wg pubkey)\n      # Generate a preshared key for the client and server to use\n      PRESHARED_KEY=$(wg genpsk)\n      # Choose a random port number for the peer\n      PEER_PORT=$(shuf --input-range=1024-65535 --head-count=1)\n      # Get the private subnet and subnet mask from the WireGuard config file\n      PRIVATE_SUBNET_V4=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2)\n      PRIVATE_SUBNET_MASK_V4=$(echo \"${PRIVATE_SUBNET_V4}\" | cut --delimiter=\"/\" --fields=2)\n      PRIVATE_SUBNET_V6=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=3)\n      PRIVATE_SUBNET_MASK_V6=$(echo \"${PRIVATE_SUBNET_V6}\" | cut --delimiter=\"/\" --fields=2)\n      # Get the server host and public key from the WireGuard config file\n      SERVER_HOST=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=4)\n      SERVER_PUBKEY=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=5)\n      # Get the client DNS server, MTU choice, NAT choice, and allowed IP address from the WireGuard config file\n      CLIENT_DNS=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=6)\n      MTU_CHOICE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=7)\n      NAT_CHOICE=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=8)\n      CLIENT_ALLOWED_IP=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=9)\n      # Calculate the client's IP addresses based on the last IP addresses used\n      CLIENT_ADDRESS_V4=$(echo \"${PRIVATE_SUBNET_V4}\" | cut --delimiter=\".\" --fields=1-3).$((LASTIPV4 + 1))\n      CLIENT_ADDRESS_V6=$(echo \"${PRIVATE_SUBNET_V6}\" | cut --delimiter=\":\" --fields=1-4):$((LASTIPV6 + 1))\n      # Check if there are any unused IP addresses available\n      if { [ -n \"${FIND_UNUSED_IPV4}\" ] && [ -n \"${FIND_UNUSED_IPV6}\" ]; }; then\n        CLIENT_ADDRESS_V4=$(echo \"${CLIENT_ADDRESS_V4}\" | cut --delimiter=\".\" --fields=1-3).${LASTIPV4}\n        CLIENT_ADDRESS_V6=$(echo \"${CLIENT_ADDRESS_V6}\" | cut --delimiter=\":\" --fields=1-4):${LASTIPV6}\n      fi\n      # Create a temporary file to store the new client information\n      WIREGUARD_TEMP_NEW_CLIENT_INFO=\"# ${NEW_CLIENT_NAME} start\n[Peer]\nPublicKey = ${CLIENT_PUBKEY}\nPresharedKey = ${PRESHARED_KEY}\nAllowedIPs = ${CLIENT_ADDRESS_V4}/32,${CLIENT_ADDRESS_V6}/128\n# ${NEW_CLIENT_NAME} end\"\n      # Write the temporary new client information to the 'add peer' configuration file\n      echo \"${WIREGUARD_TEMP_NEW_CLIENT_INFO}\" >${WIREGUARD_ADD_PEER_CONFIG}\n      # Add the new peer configuration to the WireGuard interface\n      wg addconf ${WIREGUARD_PUB_NIC} ${WIREGUARD_ADD_PEER_CONFIG}\n      # If there are no unused IPv4 and IPv6 addresses, append the new client information to the WireGuard configuration file\n      if { [ -z \"${FIND_UNUSED_IPV4}\" ] && [ -z \"${FIND_UNUSED_IPV6}\" ]; }; then\n        echo \"${WIREGUARD_TEMP_NEW_CLIENT_INFO}\" >>${WIREGUARD_CONFIG}\n      # If there are unused IPv4 and IPv6 addresses, modify the 'add peer' configuration file and insert the new client information into the WireGuard configuration file\n      elif { [ -n \"${FIND_UNUSED_IPV4}\" ] && [ -n \"${FIND_UNUSED_IPV6}\" ]; }; then\n        sed --in-place \"s|$|\\\\\\n|\" \"${WIREGUARD_ADD_PEER_CONFIG}\"\n        sed --in-place \"6s|\\\\\\n||\" \"${WIREGUARD_ADD_PEER_CONFIG}\"\n        # Remove newline characters from the 'add peer' configuration file\n        WIREGUARD_TEMPORARY_PEER_DATA=$(tr --delete \"\\n\" <\"${WIREGUARD_ADD_PEER_CONFIG}\")\n        # Calculate the line number where the new client information should be inserted\n        TEMP_WRITE_LINE=$((LASTIPV4 - 2))\n        # Insert the new client information into the WireGuard configuration file\n        sed --in-place $((TEMP_WRITE_LINE * 6 + 11))i\"${WIREGUARD_TEMPORARY_PEER_DATA}\" ${WIREGUARD_CONFIG}\n      fi\n      # Remove the wireguard add peer config file\n      rm --force ${WIREGUARD_ADD_PEER_CONFIG}\n      # Create the client configuration file\n      echo \"# ${WIREGUARD_WEBSITE_URL}\n[Interface]\nAddress = ${CLIENT_ADDRESS_V4}/${PRIVATE_SUBNET_MASK_V4},${CLIENT_ADDRESS_V6}/${PRIVATE_SUBNET_MASK_V6}\nDNS = ${CLIENT_DNS}\nListenPort = ${PEER_PORT}\nMTU = ${MTU_CHOICE}\nPrivateKey = ${CLIENT_PRIVKEY}\n[Peer]\nAllowedIPs = ${CLIENT_ALLOWED_IP}\nEndpoint = ${SERVER_HOST}\nPersistentKeepalive = ${NAT_CHOICE}\nPresharedKey = ${PRESHARED_KEY}\nPublicKey = ${SERVER_PUBKEY}\" >>${WIREGUARD_CLIENT_PATH}/\"${NEW_CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n      # Add the WireGuard interface configuration, stripping any unnecessary fields\n      wg addconf ${WIREGUARD_PUB_NIC} <(wg-quick strip ${WIREGUARD_PUB_NIC})\n      # Check if automatic WireGuard expiration is enabled, and if so, set the expiration date\n      if crontab -l | grep -q \"${CURRENT_FILE_PATH} --remove\"; then\n        crontab -l | {\n          cat\n          # Add a new cron job to remove the new client at the specified expiration date\n          echo \"$(date +%M) $(date +%H) $(date +%d) $(date +%m) * echo -e \\\"${NEW_CLIENT_NAME}\\\" | ${CURRENT_FILE_PATH} --remove\"\n        } | crontab -\n      fi\n      # Generate and display a QR code for the new client configuration\n      qrencode -t ansiutf8 <${WIREGUARD_CLIENT_PATH}/\"${NEW_CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n      # Output the new client configuration file content\n      cat ${WIREGUARD_CLIENT_PATH}/\"${NEW_CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n      # Display the path of the new client configuration file\n      echo \"Client config --> ${WIREGUARD_CLIENT_PATH}/${NEW_CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\"\n      ;;\n    6) # Remove WireGuard Peer\n      # Prompt the user to choose a WireGuard peer to remove\n      echo \"Which WireGuard peer would you like to remove?\"\n      # List all the peers' names in the WireGuard configuration file\n      grep start ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2\n      # Read the user input for the peer's name\n      read -rp \"Peer's name:\" REMOVECLIENT\n      # Extract the public key of the selected peer from the configuration file\n      CLIENTKEY=$(sed -n \"/\\# ${REMOVECLIENT} start/,/\\# ${REMOVECLIENT} end/p\" ${WIREGUARD_CONFIG} | grep PublicKey | cut --delimiter=\" \" --fields=3)\n      # Remove the selected peer from the WireGuard interface using the extracted public key\n      wg set ${WIREGUARD_PUB_NIC} peer \"${CLIENTKEY}\" remove\n      # Remove the selected peer's configuration block from the WireGuard configuration file\n      sed --in-place \"/\\# ${REMOVECLIENT} start/,/\\# ${REMOVECLIENT} end/d\" ${WIREGUARD_CONFIG}\n      # If the selected peer has a configuration file in the client path, remove it\n      if [ -f \"${WIREGUARD_CLIENT_PATH}/${REMOVECLIENT}-${WIREGUARD_PUB_NIC}.conf\" ]; then\n        rm --force ${WIREGUARD_CLIENT_PATH}/\"${REMOVECLIENT}\"-${WIREGUARD_PUB_NIC}.conf\n      fi\n      # Reload the WireGuard interface configuration to apply the changes\n      wg addconf ${WIREGUARD_PUB_NIC} <(wg-quick strip ${WIREGUARD_PUB_NIC})\n      # Remove any cronjobs associated with the removed peer\n      crontab -l | grep --invert-match \"${REMOVECLIENT}\" | crontab -\n      ;;\n    7) # Reinstall WireGuard\n      # Check if the current init system is systemd, and if so, disable and stop the WireGuard service\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        systemctl disable --now wg-quick@${WIREGUARD_PUB_NIC}\n      # Check if the current init system is init, and if so, stop the WireGuard service\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        service wg-quick@${WIREGUARD_PUB_NIC} stop\n      fi\n      # Bring down the WireGuard interface\n      wg-quick down ${WIREGUARD_PUB_NIC}\n      # Reinstall or update WireGuard based on the current Linux distribution\n      if { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n        dpkg-reconfigure wireguard-dkms\n        modprobe wireguard\n      elif { [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n        yum reinstall wireguard-tools -y\n      elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n        pacman -Su --noconfirm wireguard-tools\n      elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n        apk fix wireguard-tools\n      elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n        pkg check wireguard\n      elif [ \"${CURRENT_DISTRO}\" == \"ol\" ]; then\n        yum reinstall wireguard-tools -y\n      fi\n      # Enable and start the WireGuard service based on the current init system\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        systemctl enable --now wg-quick@${WIREGUARD_PUB_NIC}\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        service wg-quick@${WIREGUARD_PUB_NIC} restart\n      fi\n      ;;\n    8) # Uninstall WireGuard and purging files\n      # Check if the current init system is systemd and disable the WireGuard service\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        systemctl disable --now wg-quick@${WIREGUARD_PUB_NIC}\n        # If the init system is not systemd, check if it is init and stop the WireGuard service\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        service wg-quick@${WIREGUARD_PUB_NIC} stop\n      fi\n      # Bring down the WireGuard interface\n      wg-quick down ${WIREGUARD_PUB_NIC}\n      # Removing Wireguard Files\n      # Check if the WireGuard directory exists and remove it\n      if [ -d \"${WIREGUARD_PATH}\" ]; then\n        rm --recursive --force ${WIREGUARD_PATH}\n      fi\n      # Remove WireGuard and qrencode packages based on the current distribution\n      # For CentOS, AlmaLinux, and Rocky Linux distributions\n      if { [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n        yum remove wireguard qrencode -y\n        # For Ubuntu, Debian, Raspbian, Pop!_OS, Kali Linux, Linux Mint, and KDE Neon distributions\n      elif { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n        apt-get remove --purge wireguard qrencode -y\n        # Remove backports repository and keys if they exist\n        if [ -f \"/etc/apt/sources.list.d/backports.list\" ]; then\n          rm --force /etc/apt/sources.list.d/backports.list\n          apt-key del 648ACFD622F3D138\n          apt-key del 0E98404D386FA1D9\n        fi\n        # For Arch, Arch ARM, and Manjaro distributions\n      elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n        pacman -Rs --noconfirm wireguard-tools qrencode\n        # For Fedora distribution\n      elif [ \"${CURRENT_DISTRO}\" == \"fedora\" ]; then\n        dnf remove wireguard qrencode -y\n        # Remove WireGuard repository if it exists\n        if [ -f \"/etc/yum.repos.d/wireguard.repo\" ]; then\n          rm --force /etc/yum.repos.d/wireguard.repo\n        fi\n        # For RHEL distribution\n      elif [ \"${CURRENT_DISTRO}\" == \"rhel\" ]; then\n        yum remove wireguard qrencode -y\n        # Remove WireGuard repository if it exists\n        if [ -f \"/etc/yum.repos.d/wireguard.repo\" ]; then\n          rm --force /etc/yum.repos.d/wireguard.repo\n        fi\n        # For Alpine Linux distribution\n      elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n        apk del wireguard-tools libqrencode\n        # For FreeBSD distribution\n      elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n        pkg delete wireguard libqrencode\n      # For Oracle Linux distribution\n      elif [ \"${CURRENT_DISTRO}\" == \"ol\" ]; then\n        yum remove wireguard qrencode -y\n      fi\n      # Delete WireGuard backup\n      if [ -f \"${WIREGUARD_CONFIG_BACKUP}\" ]; then\n        rm --force ${WIREGUARD_CONFIG_BACKUP}\n        if [ -f \"${WIREGUARD_BACKUP_PASSWORD_PATH}\" ]; then\n          rm --force \"${WIREGUARD_BACKUP_PASSWORD_PATH}\"\n        fi\n      fi\n      # Uninstall unbound\n      # Check if the 'unbound' command is available on the system\n      if [ -x \"$(command -v unbound)\" ]; then\n        # Check if the current init system is systemd and disable the Unbound service\n        if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n          systemctl disable --now unbound\n        # If the init system is not systemd, check if it is init and stop the Unbound service\n        elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n          service unbound stop\n        fi\n        # If a backup of the resolv.conf file exists, restore it and set the immutable flag\n        if [ -f \"${RESOLV_CONFIG_OLD}\" ]; then\n          chattr -i ${RESOLV_CONFIG}\n          rm --force ${RESOLV_CONFIG}\n          mv ${RESOLV_CONFIG_OLD} ${RESOLV_CONFIG}\n          chattr +i ${RESOLV_CONFIG}\n        fi\n        # Remove Unbound package based on the current distribution\n        # For CentOS, RHEL, AlmaLinux, and Rocky Linux distributions\n        if { [ \"${CURRENT_DISTRO}\" == \"centos\" ] || [ \"${CURRENT_DISTRO}\" == \"rhel\" ] || [ \"${CURRENT_DISTRO}\" == \"almalinux\" ] || [ \"${CURRENT_DISTRO}\" == \"rocky\" ]; }; then\n          yum remove unbound -y\n        # For Ubuntu, Debian, Raspbian, Pop!_OS, Kali Linux, Linux Mint, and KDE Neon distributions\n        elif { [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ] || [ \"${CURRENT_DISTRO}\" == \"debian\" ] || [ \"${CURRENT_DISTRO}\" == \"raspbian\" ] || [ \"${CURRENT_DISTRO}\" == \"pop\" ] || [ \"${CURRENT_DISTRO}\" == \"kali\" ] || [ \"${CURRENT_DISTRO}\" == \"linuxmint\" ] || [ \"${CURRENT_DISTRO}\" == \"neon\" ]; }; then\n          # If the distribution is Ubuntu, restart systemd-resolved service based on the init system\n          if [ \"${CURRENT_DISTRO}\" == \"ubuntu\" ]; then\n            if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n              systemctl enable --now systemd-resolved\n            elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n              service systemd-resolved restart\n            fi\n          fi\n          apt-get remove --purge unbound -y\n        # For Arch, Arch ARM, and Manjaro distributions\n        elif { [ \"${CURRENT_DISTRO}\" == \"arch\" ] || [ \"${CURRENT_DISTRO}\" == \"archarm\" ] || [ \"${CURRENT_DISTRO}\" == \"manjaro\" ]; }; then\n          pacman -Rs --noconfirm unbound\n        # For Fedora and Oracle Linux distributions\n        elif { [ \"${CURRENT_DISTRO}\" == \"fedora\" ] || [ \"${CURRENT_DISTRO}\" == \"ol\" ]; }; then\n          yum remove unbound -y\n        # For Alpine Linux distribution\n        elif [ \"${CURRENT_DISTRO}\" == \"alpine\" ]; then\n          apk del unbound\n        # For FreeBSD distribution\n        elif [ \"${CURRENT_DISTRO}\" == \"freebsd\" ]; then\n          pkg delete unbound\n        fi\n        # Remove Unbound root directory if it exists\n        if [ -d \"${UNBOUND_ROOT}\" ]; then\n          rm --recursive --force ${UNBOUND_ROOT}\n        fi\n        # Remove Unbound root anchor file if it exists\n        if [ -f \"${UNBOUND_ANCHOR}\" ]; then\n          rm --force ${UNBOUND_ANCHOR}\n        fi\n      fi\n      # If any cronjobs are identified, they should be removed.\n      crontab -l | grep --invert-match \"${CURRENT_FILE_PATH}\" | crontab -\n      ;;\n    9) # Update WireGuard Manager script.\n      # Calculate the SHA3-512 hash of the current WireGuard Manager script\n      CURRENT_WIREGUARD_MANAGER_HASH=$(openssl dgst -sha3-512 \"${CURRENT_FILE_PATH}\" | cut --delimiter=\" \" --fields=2)\n      # Calculate the SHA3-512 hash of the latest WireGuard Manager script from the remote source\n      NEW_WIREGUARD_MANAGER_HASH=$(curl --silent \"${WIREGUARD_MANAGER_UPDATE}\" | openssl dgst -sha3-512 | cut --delimiter=\" \" --fields=2)\n      # If the hashes don't match, update the local WireGuard Manager script\n      if [ \"${CURRENT_WIREGUARD_MANAGER_HASH}\" != \"${NEW_WIREGUARD_MANAGER_HASH}\" ]; then\n        curl \"${WIREGUARD_MANAGER_UPDATE}\" -o \"${CURRENT_FILE_PATH}\"\n        chmod +x \"${CURRENT_FILE_PATH}\"\n        echo \"Updating WireGuard Manager script...\"\n      fi\n      # Update the unbound configs if the unbound command is available on the system\n      if [ -x \"$(command -v unbound)\" ]; then\n        # Update the unbound root hints file if it exists\n        if [ -f \"${UNBOUND_ROOT_HINTS}\" ]; then\n          CURRENT_ROOT_HINTS_HASH=$(openssl dgst -sha3-512 \"${UNBOUND_ROOT_HINTS}\" | cut --delimiter=\" \" --fields=2)\n          NEW_ROOT_HINTS_HASH=$(curl --silent \"${UNBOUND_ROOT_SERVER_CONFIG_URL}\" | openssl dgst -sha3-512 | cut --delimiter=\" \" --fields=2)\n          if [ \"${CURRENT_ROOT_HINTS_HASH}\" != \"${NEW_ROOT_HINTS_HASH}\" ]; then\n            curl \"${UNBOUND_ROOT_SERVER_CONFIG_URL}\" -o ${UNBOUND_ROOT_HINTS}\n            echo \"Updating root hints file...\"\n          fi\n        fi\n        # Update the unbound config host file if it exists\n        if [ -f \"${UNBOUND_CONFIG_HOST}\" ]; then\n          CURRENT_UNBOUND_HOSTS_HASH=$(openssl dgst -sha3-512 \"${UNBOUND_CONFIG_HOST}\" | cut --delimiter=\" \" --fields=2)\n          NEW_UNBOUND_HOSTS_HASH=$(curl --silent \"${UNBOUND_CONFIG_HOST_URL}\" | awk '{print \"local-zone: \\\"\"$1\"\\\" always_refuse\"}' | openssl dgst -sha3-512 | cut --delimiter=\" \" --fields=2)\n          if [ \"${CURRENT_UNBOUND_HOSTS_HASH}\" != \"${NEW_UNBOUND_HOSTS_HASH}\" ]; then\n            curl \"${UNBOUND_CONFIG_HOST_URL}\" | awk '{print \"local-zone: \\\"\"$1\"\\\" always_refuse\"}' >${UNBOUND_CONFIG_HOST}\n            echo \"Updating unbound config host file...\"\n          fi\n        fi\n        # Once everything is completed, restart the unbound service\n        if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n          systemctl restart unbound\n          echo \"Restarting unbound service...\"\n        elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n          service unbound restart\n          echo \"Restarting unbound service...\"\n        fi\n      fi\n      ;;\n    10) # Backup WireGuard Config\n      # If the WireGuard config backup file exists, remove it\n      if [ -f \"${WIREGUARD_CONFIG_BACKUP}\" ]; then\n        rm --force ${WIREGUARD_CONFIG_BACKUP}\n        echo \"Removing existing backup...\"\n      fi\n      # If the system backup path directory does not exist, create it along with any necessary parent directories\n      if [ ! -d \"${SYSTEM_BACKUP_PATH}\" ]; then\n        mkdir --parents ${SYSTEM_BACKUP_PATH}\n        echo \"Creating backup directory...\"\n      fi\n      # If the WireGuard path directory exists, proceed with the backup process\n      if [ -d \"${WIREGUARD_PATH}\" ]; then\n        # Generate a random 50-character hexadecimal backup password and store it in a file\n        BACKUP_PASSWORD=\"$(openssl rand -hex 25)\"\n        echo \"${BACKUP_PASSWORD}\" >\"${WIREGUARD_BACKUP_PASSWORD_PATH}\"\n        # Zip the WireGuard config file using the generated backup password and save it as a backup\n        zip -P \"${BACKUP_PASSWORD}\" -rj ${WIREGUARD_CONFIG_BACKUP} ${WIREGUARD_CONFIG}\n        # Echo the backup password and path to the terminal\n        echo \"Backup Password: ${BACKUP_PASSWORD}\"\n        echo \"Backup Path: ${WIREGUARD_CONFIG_BACKUP}\"\n        echo \"Please save the backup password and path in a secure location.\"\n      fi\n      ;;\n    11) # Restore WireGuard Config\n      # Check if the WireGuard config backup file does not exist, and if so, exit the script\n      if [ ! -f \"${WIREGUARD_CONFIG_BACKUP}\" ]; then\n        echo \"Error: The WireGuard configuration backup file could not be found. Please ensure it exists and try again.\"\n        exit\n      fi\n      # Prompt the user to enter the backup password and store it in the WIREGUARD_BACKUP_PASSWORD variable\n      read -rp \"Backup Password: \" -e -i \"$(cat \"${WIREGUARD_BACKUP_PASSWORD_PATH}\")\" WIREGUARD_BACKUP_PASSWORD\n      # If the WIREGUARD_BACKUP_PASSWORD variable is empty, exit the script\n      if [ -z \"${WIREGUARD_BACKUP_PASSWORD}\" ]; then\n        echo \"Error: The backup password field is empty. Please provide a valid password.\"\n        exit\n      fi\n      # Unzip the backup file, overwriting existing files, using the specified backup password, and extract the contents to the WireGuard path\n      unzip -o -P \"${WIREGUARD_BACKUP_PASSWORD}\" \"${WIREGUARD_CONFIG_BACKUP}\" -d \"${WIREGUARD_PATH}\"\n      # If the current init system is systemd, enable and start the wg-quick service\n      if [[ \"${CURRENT_INIT_SYSTEM}\" == *\"systemd\"* ]]; then\n        systemctl enable --now wg-quick@${WIREGUARD_PUB_NIC}\n      # If the current init system is init, restart the wg-quick service\n      elif [[ \"${CURRENT_INIT_SYSTEM}\" == *\"init\"* ]]; then\n        service wg-quick@${WIREGUARD_PUB_NIC} restart\n      fi\n      ;;\n    12) # Change the IP address of your wireguard interface.\n      get-network-information\n      # Extract the current IP address method from the WireGuard config file\n      CURRENT_IP_METHORD=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=4)\n      # If the current IP address method is IPv4, extract the old server host and set the new server host to DEFAULT_INTERFACE_IPV4\n      if [[ ${CURRENT_IP_METHORD} != *\"[\"* ]]; then\n        OLD_SERVER_HOST=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=4 | cut --delimiter=\":\" --fields=1)\n        NEW_SERVER_HOST=${DEFAULT_INTERFACE_IPV4}\n      fi\n      # If the current IP address method is IPv6, extract the old server host and set the new server host to DEFAULT_INTERFACE_IPV6\n      if [[ ${CURRENT_IP_METHORD} == *\"[\"* ]]; then\n        OLD_SERVER_HOST=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=4 | cut --delimiter=\"[\" --fields=2 | cut --delimiter=\"]\" --fields=1)\n        NEW_SERVER_HOST=${DEFAULT_INTERFACE_IPV6}\n      fi\n      # If the old server host is different from the new server host, update the server host in the WireGuard config file\n      if [ \"${OLD_SERVER_HOST}\" != \"${NEW_SERVER_HOST}\" ]; then\n        sed --in-place \"1s/${OLD_SERVER_HOST}/${NEW_SERVER_HOST}/\" ${WIREGUARD_CONFIG}\n      fi\n      # Create a list of existing WireGuard clients from the WireGuard config file\n      COMPLETE_CLIENT_LIST=$(grep start ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2)\n      # Add the clients to the USER_LIST array\n      for CLIENT_LIST_ARRAY in ${COMPLETE_CLIENT_LIST}; do\n        USER_LIST[ADD_CONTENT]=${CLIENT_LIST_ARRAY}\n        ADD_CONTENT=$((\"${ADD_CONTENT}\" + 1))\n      done\n      # Loop through the clients in the USER_LIST array\n      for CLIENT_NAME in \"${USER_LIST[@]}\"; do\n        # Check if the client's config file exists\n        if [ -f \"${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\" ]; then\n          # Update the server host in the client's config file\n          sed --in-place \"s/${OLD_SERVER_HOST}/${NEW_SERVER_HOST}/\" \"${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\"\n        fi\n      done\n      ;;\n    13) # Change the wireguard interface's port number.\n      # Extract the old server port from the WireGuard config file\n      OLD_SERVER_PORT=$(head --lines=1 ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=4 | cut --delimiter=\":\" --fields=2)\n      # Prompt the user to enter a valid custom port (between 1 and 65535) and store it in NEW_SERVER_PORT\n      until [[ \"${NEW_SERVER_PORT}\" =~ ^[0-9]+$ ]] && [ \"${NEW_SERVER_PORT}\" -ge 1 ] && [ \"${NEW_SERVER_PORT}\" -le 65535 ]; do\n        read -rp \"Enter a custom port number (between 1 and 65535): \" -e -i 51820 NEW_SERVER_PORT\n      done\n      # Check if the chosen port is already in use by another application\n      if [ \"$(lsof -i UDP:\"${NEW_SERVER_PORT}\")\" ]; then\n        # If the port is in use, print an error message and exit the script\n        echo \"Error: The port number ${NEW_SERVER_PORT} is already in use by another application. Please try a different port number.\"\n        exit\n      fi\n      # If the old server port is different from the new server port, update the server port in the WireGuard config file\n      if [ \"${OLD_SERVER_PORT}\" != \"${NEW_SERVER_PORT}\" ]; then\n        sed --in-place \"s/${OLD_SERVER_PORT}/${NEW_SERVER_PORT}/g\" ${WIREGUARD_CONFIG}\n        echo \"The server port has changed from ${OLD_SERVER_PORT} to ${NEW_SERVER_PORT} in ${WIREGUARD_CONFIG}.\"\n      fi\n      # Create a list of existing WireGuard clients from the WireGuard config file\n      COMPLETE_CLIENT_LIST=$(grep start ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2)\n      # Add the clients to the USER_LIST array\n      for CLIENT_LIST_ARRAY in ${COMPLETE_CLIENT_LIST}; do\n        USER_LIST[ADD_CONTENT]=${CLIENT_LIST_ARRAY}\n        ADD_CONTENT=$((\"${ADD_CONTENT}\" + 1))\n      done\n      # Loop through the clients in the USER_LIST array\n      for CLIENT_NAME in \"${USER_LIST[@]}\"; do\n        # Check if the client's config file exists\n        if [ -f \"${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\" ]; then\n          # Update the server port in the client's config file\n          sed --in-place \"s/${OLD_SERVER_PORT}/${NEW_SERVER_PORT}/\" \"${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\"\n          echo \"The server port has changed from ${OLD_SERVER_PORT} to ${NEW_SERVER_PORT} in ${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf.\"\n        fi\n      done\n      ;;\n    14) # Remove all the peers from the interface.\n      COMPLETE_CLIENT_LIST=$(grep start ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2)\n      # This line gets the list of clients in the config file by searching for the string \"start\" and then extracting the second field (the client name) from each line.\n      for CLIENT_LIST_ARRAY in ${COMPLETE_CLIENT_LIST}; do\n        USER_LIST[ADD_CONTENT]=${CLIENT_LIST_ARRAY}\n        ADD_CONTENT=$((\"${ADD_CONTENT}\" + 1))\n      done\n      # This loop iterates over each client in the list and adds it to an array called USER_LIST.\n      for CLIENT_NAME in \"${USER_LIST[@]}\"; do\n        CLIENTKEY=$(sed -n \"/\\# ${CLIENT_NAME} start/,/\\# ${CLIENT_NAME} end/p\" ${WIREGUARD_CONFIG} | grep PublicKey | cut --delimiter=\" \" --fields=3)\n        # This line extracts the client's public key from the config file.\n        wg set ${WIREGUARD_PUB_NIC} peer \"${CLIENTKEY}\" remove\n        # This line removes the client from the server.\n        sed --in-place \"/\\# ${CLIENT_NAME} start/,/\\# ${CLIENT_NAME} end/d\" ${WIREGUARD_CONFIG}\n        # This line removes the client's config from the server.\n        if [ -f \"${WIREGUARD_CLIENT_PATH}/${CLIENT_NAME}-${WIREGUARD_PUB_NIC}.conf\" ]; then\n          rm --force ${WIREGUARD_CLIENT_PATH}/\"${CLIENT_NAME}\"-${WIREGUARD_PUB_NIC}.conf\n        else\n          echo \"The client config file for ${CLIENT_NAME} does not exist.\"\n        fi\n        # This line removes the client's config file from the server.\n        wg addconf ${WIREGUARD_PUB_NIC} <(wg-quick strip ${WIREGUARD_PUB_NIC})\n        # This line removes the client's config from the running server.\n        crontab -l | grep --invert-match \"${CLIENT_NAME}\" | crontab -\n        # This line removes the client from the cron job.\n      done\n      ;;\n    15) # Generate a QR code for a WireGuard peer.\n      # Print a prompt asking the user to choose a WireGuard peer for generating a QR code\n      echo \"Which WireGuard peer would you like to generate a QR code for?\"\n      # Extract and display a list of peer names from the WireGuard config file\n      grep start ${WIREGUARD_CONFIG} | cut --delimiter=\" \" --fields=2\n      # Prompt the user to enter the desired peer's name and store it in the VIEW_CLIENT_INFO variable\n      read -rp \"Enter the name of the peer you want to view information for: \" VIEW_CLIENT_INFO\n      # Check if the config file for the specified peer exists\n      if [ -f \"${WIREGUARD_CLIENT_PATH}/${VIEW_CLIENT_INFO}-${WIREGUARD_PUB_NIC}.conf\" ]; then\n        # Generate a QR code for the specified peer's config file and display it in the terminal\n        qrencode -t ansiutf8 <${WIREGUARD_CLIENT_PATH}/\"${VIEW_CLIENT_INFO}\"-${WIREGUARD_PUB_NIC}.conf\n        # Print the file path of the specified peer's config file\n        echo \"Peer's config --> ${WIREGUARD_CLIENT_PATH}/${VIEW_CLIENT_INFO}-${WIREGUARD_PUB_NIC}.conf\"\n      else\n        # If the config file for the specified peer does not exist, print an error message\n        echo \"Error: The peer you specified could not be found. Please ensure you've entered the correct information.\"\n        exit\n      fi\n      ;;\n    16)\n      # Check if the `unbound` command is available on the system by checking if it is executable\n      if [ -x \"$(command -v unbound)\" ]; then\n        # Check if the output of `unbound-checkconf` run on `UNBOUND_CONFIG` contains \"no errors\"\n        if [[ \"$(unbound-checkconf ${UNBOUND_CONFIG})\" != *\"no errors\"* ]]; then\n          # If \"no errors\" was not found in output of previous command, print an error message\n          \"$(unbound-checkconf ${UNBOUND_CONFIG})\"\n          echo \"Error: We found an error on your unbound config file located at ${UNBOUND_CONFIG}\"\n          exit\n        fi\n        # Check if output of `unbound-host` run on `UNBOUND_CONFIG` with arguments `-C`, `-v`, and `cloudflare.com` contains \"secure\"\n        if [[ \"$(unbound-host -C ${UNBOUND_CONFIG} -v cloudflare.com)\" != *\"secure\"* ]]; then\n          # If \"secure\" was not found in output of previous command, print an error message\n          \"$(unbound-host -C ${UNBOUND_CONFIG} -v cloudflare.com)\"\n          echo \"Error: We found an error on your unbound DNS-SEC config file loacted at ${UNBOUND_CONFIG}\"\n          exit\n        fi\n        echo \"Your unbound config file located at ${UNBOUND_CONFIG} is valid.\"\n      fi\n      # Check if the `wg` command is available on the system by checking if it is executable\n      if [ -x \"$(command -v wg)\" ]; then\n        # Check if the output of `wg` contains \"interface\" and \"public key\"\n        if [[ \"$(wg)\" != *\"interface\"* ]] && [[ \"$(wg)\" != *\"public key\"* ]]; then\n          # If \"interface\" and \"public key\" were not found in output of previous command, print an error message\n          echo \"Error: We found an error on your WireGuard interface.\"\n          exit\n        fi\n        echo \"Your WireGuard interface is valid.\"\n      fi\n      ;;\n    esac\n  }\n\n  # Running Questions Command\n  wireguard-next-questions-interface\n\nfi\n"
        }
      ]
    }
  ]
}