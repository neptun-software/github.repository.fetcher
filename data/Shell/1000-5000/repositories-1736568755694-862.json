{
  "metadata": {
    "timestamp": 1736568755694,
    "page": 862,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg2OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "progrium/gitreceive",
      "stars": 1135,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.009765625,
          "content": ".DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 3.23046875,
          "content": "sudo: required\nservices:\n  - docker\nbranches:\n  only:\n    - master\nbefore_install:\n  - sudo apt-get install -y rsync\n  - echo -n $travisci_{1..30} >> ~/.ssh/id_rsa_base64\n  - base64 --decode --ignore-garbage ~/.ssh/id_rsa_base64 > ~/.ssh/id_rsa\n  - chmod 600 ~/.ssh/id_rsa\n  - echo -e \"Host ci.progrium.com\\n\\tStrictHostKeyChecking no\\n\" >> ~/.ssh/config\nscript: \n  - rsync -avz --exclude \".git\" -e \"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\" . gitreceive@ci.progrium.com:.\n  - ssh gitreceive@ci.progrium.com make test\n\n#notifications:\n#  irc: \"chat.freenode.net#dokku\"\nenv:\n  global:\n    - secure: \"CnUscGcLAp70E0Ok8mYjvRwbixG7SXA0wSqWCUH4L7bWr+anqtARFyIrPJXX\\nTA0IfjqwhrJ72ToD3srmBKt+cp1vWaOnVbyUoGviMg2dLRayJxF/24/F5ROZ\\ntuUinUlRTo3h0zu03lmcJVN1yl9jVi/7aukBUSQQNEcW52dB3a4=\"\n    - secure: \"Dx2tppnkY4wDiOU+vsQF860/t8du67YzhDm3Yb8e90R7bD7bnJ444/I0Ezel\\noCO0u/RzQsaS2Ms6QO1xDcle2Cl6p+Il78nAdPdpePWlMhVzKXIYvAbDJCP3\\nXl04CVY4svyCLIk3Gga9T9/21O7NoDLZXwg4sg4bOaAB+G0nNkY=\"\n    - secure: \"GcBV4OoIMUgE4kAOEdI+EPuGdGjsloRuDL0EjI1Lc7PoT3icf3xLr2FB+l+g\\nvJTG4CHEY4aLfOkCOA44vJZ0cvHUisqv/mC08yCg39jtw6KUQSg18HcfTX/u\\nX0HXKPXWMcIEmjhvUgUONmBonV2gwcPMYkENhQy3l0Uec3jwomc=\"\n    - secure: \"F932CiYdF76bzMDBwPFPHDJhfNkAEIJe98YNPQxgyj59SHlVHvgs2ySmdZZy\\n/lIqxD1CgFeewMmYrTnUM5BKHjoLOKJqYI3KkSoRy1aUpKb5o1jtNS/049mj\\ntG01VMT/Lk0r37+a7tYCXhbJ81z/mmWVucIKjASO5Pyb8NieLRI=\"\n    - secure: \"CfR2n51kb5KPdqYCUtXA/sM2BPF6XcWltX1MPQiQmU690RaYGThNM+y1Uhub\\nMBjc7s85ejmX23b7TgY6biVheu/EWSBlnkUt88aubQZTZ4LZDCKyHpaJB4hU\\nWEVKUUVG1M2VI6atV1VMzI/VOe6KhZ9OhWMvQBkXTSCijTtYDO0=\"\n    - secure: \"IZBTzMB/hV/d8cspbu+Lm+J/70slbJP7VFXh007zJZtBabQvQAJMyu9RGy1A\\nAW425UKC/3ogQ/xNPGaBsgeoDpwpIR8iZXAOrlzAKc3vKnv3YYAfZ7o9J1Y2\\nTO1RLEmosO4PFPKkVFzsJJjbtiTz508Ak5fHokXY9nT8ouVOs48=\"\n    - secure: \"amC03pSIqrIUx92Yap39FggdXxgA9QOtslXeIeZJMWerCR8/J8FYA78KZzvV\\ngftT6yM8z6sq3Z4Rpu13Ci9OGUsFEz2FYUITze8rVAZXTBOy9ht4XzDlV+kA\\n/NJ5OICev3o+Ra5WnSJw1rGoWzVWn4sJBPWss1s3mYas+6zdaE8=\"\n    - secure: \"cs2+mY/ITTGHOp4W4FDbDRbtlyFkHGiyoMSWG4qLj3++ks//HTg7We39TkgR\\nGZbgityJdeltN9t8D6i6ScxrFb6Rgcehq1ep735VCXlvq+0zYk2jUegdWLSp\\n7cHuvSmICpT9UBLygdgrO4gaAaEXmsLMjqtkWwPZcv6kj0rMNvg=\"\n    - secure: \"Y5V/H1IKTJUtELAZrAqVi6eF+lQJ6poDUAZm9uq9dO2bnqSg0XncH4EXOWeZ\\nljqxyZxJKrUTMWpG+wDT6YZkoCvq3w9Zxo9Fo1GSpSwjpUxGv0skJHE+sJw9\\n2huXswmDXAdV7kRCLOBC/rvfzy9P/r4xOYG4meqIo/wb01LJ284=\"\n    - secure: \"QXvf5yWs6dUP0JOpK1Revpbho5/oEhJa0lmYxZYP+b+YU66Pf6SoXSX2Dunj\\n4kr0LqtUhq0JOkkJnNvop1dWiUf65RNkNKEr423GSu6Ic1d9xxBhuRnZaocQ\\niCEJbPQSlX/nSwRDxkvDdNyQxKwXDB2Vj/cIbVyAa+cuiXooGbM=\"\n    - secure: \"YP6RtpAjkFHih66jPRyyosLGXITPrvnubkpAyVYghn+cs9jA8/nWujrERqtL\\nkYwIe5Evzhyc1GvMyDRWAWh7mY6F9gp5Q1TEwfFGRZlN2n7iTb6dQNcE8Kbk\\nJhFbI1AzyyYAe+Iwokj1jjHwfVfsTHC6lwyPoEPXeOjIC4B2lwk=\"\n    - secure: \"WUQL8me3Eyp8dpix7ERgJeUTUOZPbsqWY82uJ6PtiCROF1axriEfw+VtnNrF\\nq3QvHBXFWj568afPaJ8a3Lv8mdnZYgr3RWWbT04zyF3fW2XHbTRGNDJfqIG6\\n/qzMRBgFJHbwBjzyFyYQlYx6HbsphUQRVtAbmhzKdC0oZsDigHw=\"\n    - secure: \"YPScmVVUr7qEQZMd1/J5/lwETAgOvpgb77nAJIWStwsZ/Iq73Jh4grAFxAV+\\nJttuw4AZOTqz5l5ggNtvBxKfSrYOYWCY7x+91IZb8Fo6MbzAETi2j7ho3Eh2\\n1XbCWUTkv5RtLkO2gT8Fahtfc9x4zTnJuk02HC5f/0R+zMAZ01U=\"\n    - secure: \"ggRiVqKFZ5bu/5tBMvJ7AECeDSN1BYU/hObC3MjZCGVn6uQwtLK081CHRWXz\\nnQCNm0F1yksGUOiVbsqqOVJ/nn3TtS3SVbETeiCW7QrIHfYK6+P4a6Z4MhWX\\nI4SnlxYSRW5IQHkmo40n8Xg/d8167wjlsoeIoMkZAb4RFP3xRIg=\""
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3037109375,
          "content": "VERSION = 0.2.0\n\ninstall:\n\tcp gitreceive /usr/local/bin/gitreceive\n\tchmod +x /usr/local/bin/gitreceive\n\ncheck-docker:\n\twhich docker || exit 1\n\ntest: check-docker\n\tcp gitreceive tests\n\tdocker build -t gitreceive-test tests\n\trm tests/gitreceive\n\tdocker run --rm gitreceive-test\n\nclean:\n\tdocker rmi gitreceive-test"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6494140625,
          "content": "gitreceive\n==========\n[![Build Status](https://travis-ci.org/progrium/gitreceive.png?branch=master)](https://travis-ci.org/progrium/gitreceive)\n\nCreates an ssh+git user that accepts on the fly repository pushes and triggers a hook script. \n\nPush code anywhere. Extend your Git workflow.\n\ngitreceive dynamically creates bare repositories with a special `pre-receive` hook that triggers your own general gitreceive hook giving you easy access to the code that was pushed while still being able to send output back to the git user.\n\n## Requirements\n\nYou need a Linux server with `git` and `sshd` installed.\n\n## Installing\n\nOn your server, download https://raw.github.com/progrium/gitreceive/master/gitreceive to a location on your $PATH and make it executable.\n\n## Using gitreceive\n\n#### Set up a git user on the server\n\nThis automatically makes a user and home directory if it doesn't exist. \n\n    $ sudo gitreceive init\n    Created receiver script in /home/git for user 'git'.\n\nYou use a different user by setting `GITUSER=somethingelse` in the\nenvironment before using `gitreceive`.\n\n#### Modify the receiver script\n\nAs an example receiver script, it will POST all the data to a RequestBin:\n\n    $ cat /home/git/receiver\n    #!/bin/bash\n    URL=http://requestb.in/rlh4znrl\n    echo \"----> Posting to $URL ...\"\n    curl \\\n      -X 'POST' \\\n      -F \"repository=$1\" \\\n      -F \"revision=$2\" \\\n      -F \"username=$3\" \\\n      -F \"fingerprint=$4\" \\\n      -F contents=@- \\\n      --silent $URL\n    \nThe username is just a name associated with a public key. The\nfingerprint of the key is sent so you can authenticate against the\npublic key that you may have for that user. \n\nCommands do not have access to environment variables from the `/etc/profile` directory, so if you need access to them, you will need to maually `source /etc/profile` - or any other configuration file - within your receiver script.\n\nThe repo contents are streamed into `STDIN` as an uncompressed archive (tar file). You can extract them into a directory on the server with a line like this in your receiver script:\n\n    mkdir -p /some/path && cat | tar -x -C /some/path\n\n\n#### Create a user by uploading a public key from your laptop\n\nWe just pipe our local SSH key into the `gitreceive upload-key` command via SSH:\n\n    $ cat ~/.ssh/id_rsa.pub | ssh you@yourserver.com \"sudo gitreceive upload-key <username>\"\n\nThe `username` argument is just an arbitrary name associated with the key, mostly\nfor use in your system for auth, etc.\n\n`gitreceive upload-key` will authorize this key for use on the `$GITUSER`\naccount on the server, and use the SSH \"forced commands\" syntax in the remote\n`.ssh/authorized_keys` file,  causing the internal `gitreceive run` command to\nbe called when this key is used with the remote git account. This allows us to\nintercept the `git` requests and set up a `pre-receive` hook to run on the\nrepo, which triggers the custom receiver script.\n\n#### Add a remote to a local repository\n\n    $ git remote add demo git@yourserver.com:example\n\nThe repository `example` will be created on the fly when you push.\n\n#### Push!!\n\n    $ git push demo master\n    Counting objects: 5, done.\n    Delta compression using up to 4 threads.\n    Compressing objects: 100% (3/3), done.\n    Writing objects: 100% (3/3), 332 bytes, done.\n    Total 3 (delta 1), reused 0 (delta 0)\n    ----> Receiving progrium/gitreceive.git ... \n    ----> Posting to http://requestb.in/rlh4znrl ...\n    ok\n    To git@gittest:progrium/gitreceive.git\n       59aa541..6eafb55  master -> master\n\nThe receiver script did not attempt to silence the output of curl, so\nthe respones of \"ok\" from RequestBin is shown. Use this to your\nadvantage! You can even use chunked-transfer encoding to stream back\nprogress in realtime if you wanted to keep using HTTP. Alternatively, you can have the\nreceiver script run any other script on the server.\n\n#### Handling submodules\nSubmodules are not included when you do a `git push`, if you want them to be part of your workflow, have a look at [Handling Submodules](https://github.com/progrium/gitreceive/wiki/TipsAndTricks#handling-submodules).\n\n## So what?\n\nYou can use `gitreceive` not only to trigger code on `git push`, but to provide\nfeedback to the user and affect workflow. Use `gitreceive` to:\n\n* Put a `git push` deploy interface in front of App Engine\n* Run your company build/test system as a separate remote\n* Integrate custom systems into your workflow\n* Build your own Heroku\n* Push code anywhere\n\nI used to work at Twilio. Imagine pushing a repo with a TwiML file to a\ngitreceive repo with a phone number for a name. And then it runs that\nTwiML on Twilio and shows you the result, all from the `git push`. \n\n\n## Big Thanks\n\nDotCloud, DigitalOcean\n\n## License\n\nMIT\n"
        },
        {
          "name": "gitreceive",
          "type": "blob",
          "size": 6.359375,
          "content": "#!/bin/bash\n\nreadonly GITUSER=\"${GITUSER:-git}\"\nreadonly GITHOME=\"/home/$GITUSER\"\n\n# Given a relative path, calculate the absolute path\nabsolute_path() {\n  pushd \"$(dirname $1)\" > /dev/null\n  local abspath=\"$(pwd -P)\"\n  popd > /dev/null\n  echo \"$abspath/$(basename $1)\"\n}\n\n# Create a Git user on the system, with home directory and an `.authorized_keys' file that contains the public keys\n# for all users that are allowed to push their repos here. User defaults to $GITUSER, which defaults to 'git'.\nsetup_git_user() {\n  declare home_dir=\"$1\" git_user=\"$2\"\n  useradd -d \"$home_dir\" \"$git_user\" || true\n  mkdir -p \"$home_dir/.ssh\"\n  touch \"$home_dir/.ssh/authorized_keys\"\n  chown -R \"$git_user\" \"$home_dir\"\n}\n\n# Creates a sample receiver script. This is the script that is triggered after a successful push.\nsetup_receiver_script() {\n  declare home_dir=\"$1\" git_user=\"$2\"\n  local receiver_path=\"$home_dir/receiver\"\n  cat > \"$receiver_path\" <<EOF\n#!/bin/bash\n#URL=http://requestb.in/rlh4znrl\n#echo \"----> Posting to \\$URL ...\"\n#curl \\\\\n#  -X 'POST' \\\\\n#  -F \"repository=\\$1\" \\\\\n#  -F \"revision=\\$2\" \\\\\n#  -F \"username=\\$3\" \\\\\n#  -F \"fingerprint=\\$4\" \\\\\n#  -F contents=@- \\\\\n#  --silent \\$URL\nEOF\n  chmod +x \"$receiver_path\"\n  chown \"$git_user\" \"$receiver_path\"\n}\n\n# Generate a shorter, but still unique, version of the public key associated with the user doing `git push'\ngenerate_fingerprint() {\n  awk '{print $2}' | base64 -d | md5sum | awk '{print $1}' | sed -e 's/../:&/2g'\n}\n\n# Given a public key, add it to the .authorized_keys file with a 'forced command'. The 'forced command' is a syntax\n# specific to SSH's `.authorized_keys' file that allows you to specify a command that is run as soon as a user logs in.\n# Note that even though `git push' does not explicitly mention SSH, it is nevertheless using the SSH protocol under the\n# hood.\n# See: http://man.finalrewind.org/1/ssh-forcecommand/\ninstall_authorized_key() {\n  declare key=\"$1\" name=\"$2\" home_dir=\"$3\" git_user=\"$4\" self=\"$5\"\n  local fingerprint=\"$(echo \"$key\" | generate_fingerprint)\"\n  local forced_command=\"GITUSER=$git_user $self run $name $fingerprint\"\n  local key_options=\"command=\\\"$forced_command\\\",no-agent-forwarding,no-pty,no-user-rc,no-X11-forwarding,no-port-forwarding\"\n  echo \"$key_options $key\" >> \"$home_dir/.ssh/authorized_keys\"\n}\n\n# Remove the slash from the beginning of a path. Eg; '/twbs/bootstrap' becomes 'twbs/bootstrap'\nstrip_root_slash() {\n  local str=\"$(cat)\"\n  if [ \"${str:0:1}\" == \"/\" ]; then\n    echo \"$str\" | cut -c 2-\n  else\n    echo \"$str\"\n  fi\n}\n\n# Get the repo from the incoming SSH command. This is needed as the original intended response to `git push' is\n# overridden by the use of a 'forced command' (see install_authorized_key()). The forced command needs to know what repo\n# to act on.\nparse_repo_from_ssh_command() {\n  awk '{print $2}' | sed -e \"s/'\\(.*\\)'/\\1/\" | sed 's/\\\\'\\''/'\\''/g' | strip_root_slash\n}\n\n# Create a git-enabled folder ready to receive git activity, like `git push'\nensure_bare_repo() {\n  declare repo_path=\"$1\"\n  if [ ! -d \"$repo_path\" ]; then\n    mkdir -p \"$repo_path\"\n    cd \"$repo_path\"\n    git init --bare > /dev/null\n    cd - > /dev/null\n  fi\n}\n\n# Create a Git pre-receive hook in a git repo that runs `gitreceive hook' when the repo receives a new git push\nensure_prereceive_hook() {\n  declare repo_path=\"$1\" home_dir=\"$2\" self=\"$3\"\n  local hook_path=\"$repo_path/hooks/pre-receive\"\n  cd \"$home_dir\"\n  cat > \"$hook_path\" <<EOF\n#!/bin/bash\ncat | $self hook\nEOF\n  chmod +x \"$hook_path\"\n  cd - > /dev/null\n}\n\n# When a repo receives a push, its pre-receive hook is triggered. This in turn executes `gitreceive hook', which is a\n# wrapper around this function. The repo is updated and its working tree tarred so that it can be piped to\n# `$home_dir/receiver'. The receiver script is setup by `setup_receiver_script()'.\ntrigger_receiver() {\n  declare repo=\"$1\" user=\"$2\" fingerprint=\"$3\" home_dir=\"$4\"\n  # oldrev, newrev, refname are a feature of the way in which Git executes the pre-receive hook.\n  # See https://www.kernel.org/pub/software/scm/git/docs/githooks.html\n  while read oldrev newrev refname; do\n    # Only run this script for the master branch. You can remove this\n    # if block if you wish to run it for others as well.\n    [[ \"$refname\" == \"refs/heads/master\" ]] && \\\n      git archive \"$newrev\" | \"$home_dir/receiver\" \"$repo\" \"$newrev\" \"$user\" \"$fingerprint\"\n  done\n}\n\n# Places cursor at start of line, so that subsequent text replaces existing text. For example;\n# \"remote: Updated branch 'master' of 'repo'. Deploying to dev.\" becomes\n# \"------> Updated branch 'master' of 'repo'. Deploying to dev.\"\nstrip_remote_prefix() {\n  sed -u \"s/^/\"$'\\e[1G'\"/\"\n}\n\nmain() {\n  # Be unforgiving about errors\n  set -euo pipefail\n\n  readonly SELF=\"$(absolute_path $0)\"\n\n  case \"$1\" in\n  # Public commands\n\n    init) # gitreceive init\n      setup_git_user \"$GITHOME\" \"$GITUSER\"\n      setup_receiver_script \"$GITHOME\" \"$GITUSER\"\n      echo \"Created receiver script in $GITHOME for user '$GITUSER'.\"\n      ;;\n\n    upload-key) # sudo gitreceive upload-key <username>\n      declare name=\"$2\"\n      local key=\"$(cat)\"\n      install_authorized_key \"$key\" \"$name\" \"$GITHOME\" \"$GITUSER\" \"$SELF\"\n      echo \"$key\" | generate_fingerprint\n      ;;\n\n  # Internal commands\n\n    # Called by the 'forced command' when the git user first authenticates against the server\n    run)\n      declare user=\"$2\" fingerprint=\"$3\"\n      export RECEIVE_USER=\"$user\"\n      export RECEIVE_FINGERPRINT=\"$fingerprint\"\n      export RECEIVE_REPO=\"$(echo \"$SSH_ORIGINAL_COMMAND\" | parse_repo_from_ssh_command)\"\n      if [ ! $RECEIVE_REPO ]; then\n        echo \"ERROR: Arbitrary ssh prohibited!\"\n        exit 1\n      fi\n      local repo_path=\"$GITHOME/$RECEIVE_REPO\"\n      ensure_bare_repo \"$repo_path\"\n      ensure_prereceive_hook \"$repo_path\" \"$GITHOME\" \"$SELF\"\n      cd \"$GITHOME\"\n      # $SSH_ORIGINAL_COMMAND is set by `sshd'. It stores the originally intended command to be run by `git push'. In\n      # our case it is overridden by the 'forced command', so we need to reinstate it now that the 'forced command' has\n      # run.\n      git-shell -c \"$(echo \"$SSH_ORIGINAL_COMMAND\" | awk '{print $1}') '$RECEIVE_REPO'\"\n      ;;\n\n    # Called by the pre-receive hook\n    hook)\n      trigger_receiver \"$RECEIVE_REPO\" \"$RECEIVE_USER\" \"$RECEIVE_FINGERPRINT\" \"$GITHOME\" | strip_remote_prefix\n      ;;\n\n    *)\n      echo \"Usage: gitreceive <command> [options]\"\n      ;;\n  esac\n}\n\n[[ \"$0\" == \"$BASH_SOURCE\" ]] && main $@\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.19140625,
          "content": "{\n  \"name\": \"gitreceive\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Easily accept and handle arbitrary git pushes\",\n  \"global\": \"true\",\n  \"install\": \"make install\",\n  \"scripts\": [ \"gitreceive\" ]\n}\n\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}