{
  "metadata": {
    "timestamp": 1736568552617,
    "page": 577,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU3OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "drduh/pwd.sh",
      "stars": 1552,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "pwd.*.tar\npwd.index*\npwd.pepper\nsafe/\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 drduh\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.34765625,
          "content": "pwd.sh is a Bash shell script to manage passwords and other text-based secrets.\n\nIt uses GnuPG to symmetrically (i.e., using a passphrase) encrypt and decrypt plaintext files.\n\nEach password is encrypted individually as a randomly-named file in the \"safe\" directory. An encrypted index is used to map usernames to the respective password file. Both the index and password files can also be decrypted directly with GnuPG without this script.\n\n# Install\n\nFor the latest version, clone the repository or download the script directly:\n\n```console\ngit clone https://github.com/drduh/pwd.sh\n\nwget https://raw.githubusercontent.com/drduh/pwd.sh/master/pwd.sh\n```\n\nVersioned [Releases](https://github.com/drduh/pwd.sh/releases) are also available.\n\n# Use\n\nRun the script interactively using `./pwd.sh` or symlink to a directory in `PATH`:\n\n- `w` to write a password\n- `r` to read a password\n- `l` to list passwords\n- `b` to create an archive for backup\n- `h` to print the help text\n\nOptions can also be passed on the command line.\n\nCreate a 20-character password for `userName`:\n\n```console\n./pwd.sh w userName 20\n```\n\nRead password for `userName`:\n\n```console\n./pwd.sh r userName\n```\n\nPasswords are stored with an epoch timestamp for revision control. The most recent version is copied to clipboard on read. To list all passwords or read a specific version of a password:\n\n```console\n./pwd.sh l\n\n./pwd.sh r userName@1574723600\n```\n\nCreate an archive for backup:\n\n```console\n./pwd.sh b\n```\n\nRestore an archive from backup:\n\n```console\ntar xvf pwd*tar\n```\n\n# Configure\n\nSeveral customizable options and features are also available, and can be configured with environment variables, for example in the [shell rc](https://github.com/drduh/config/blob/master/zshrc) file:\n\nVariable | Description | Default | Available options\n-|-|-|-\n`PWDSH_CLIP` | clipboard to use | `xclip` | `pbcopy` on macOS\n`PWDSH_CLIP_ARGS` | arguments to pass to clipboard command | unset (disabled) | `-i -selection clipboard` to use primary (control-v) clipboard with xclip\n`PWDSH_TIME` | seconds to clear password from clipboard/screen | `10` | any valid integer\n`PWDSH_LEN` | default password length | `14` | any valid integer\n`PWDSH_COPY` | copy password to clipboard before write | unset (disabled) | `1` or `true` to enable\n`PWDSH_DAILY` | create daily backup archive on write | unset (disabled) | `1` or `true` to enable\n`PWDSH_CHARS` | character set for passwords | `[:alnum:]!?@#$%^&*();:+=` | any valid characters\n`PWDSH_COMMENT` | **unencrypted** comment to include in index and safe files | unset | any valid string\n`PWDSH_DEST` | password output destination, will set to `screen` without clipboard | `clipboard` | `clipboard` or `screen`\n`PWDSH_ECHO` | character used to echo password input | `*` | any valid character\n`PWDSH_SAFE` | safe directory name | `safe` | any valid string\n`PWDSH_INDEX` | index file name | `pwd.index` | any valid string\n`PWDSH_BACKUP` | backup archive file name | `pwd.$hostname.$today.tar` | any valid string\n`PWDSH_PEPPER` | file containing \"pepper\" value, see [Detail 1](#Details#1) | unset (disabled) | any valid file path\n\nSee [config/gpg.conf](https://github.com/drduh/config/blob/master/gpg.conf) for additional GnuPG options.\n\nAlso see [drduh/Purse](https://github.com/drduh/Purse) - a fork which integrates with [YubiKey](https://github.com/drduh/YubiKey-Guide) instead of using a passphrase.\n\n# Details\n\n1. The [\"pepper\"](https://en.wikipedia.org/wiki/Pepper_(cryptography)) is an additional string appended to the main passphrase to improve its strength. When the `PWDSH_PEPPER` option is enabled, a secret value is generated and displayed once, then saved to the respective file.\n\n    The pepper should be written down (can be transcribed with either [passphrase.html](https://github.com/drduh/YubiKey-Guide/blob/master/passphrase.html) or [passphrase.csv](https://raw.githubusercontent.com/drduh/YubiKey-Guide/master/passphrase.csv) template) and stored in a durable location for backup.\n\n    It is the opinion of the author this feature allows the use of a more memorable, weaker main passphrase without compromising overall security, provided the pepper is backed up separately from the safe.\n\n    **Warning** The pepper file is **not** included in backup archives - without the pepper, the safe will **not** be accessible with the main passphrase alone! This feature is opt-in and the pepper has no effect unless explicitly enabled.\n"
        },
        {
          "name": "pwd.sh",
          "type": "blob",
          "size": 8.623046875,
          "content": "#!/usr/bin/env bash\n# https://github.com/drduh/pwd.sh/blob/master/pwd.sh\n#set -x  # uncomment to debug\nset -o errtrace\nset -o nounset\nset -o pipefail\numask 077\nexport LC_ALL=\"C\"\n\nnow=\"$(date +%s)\"\ntoday=\"$(date +%F)\"\ngpg=\"$(command -v gpg || command -v gpg2)\"\ngpg_conf=\"${HOME}/.gnupg/gpg.conf\"\n\nclip=\"${PWDSH_CLIP:=xclip}\"           # clipboard, 'pbcopy' on macOS\nclip_args=\"${PWDSH_CLIP_ARGS:=}\"      # args to pass to clip command\nclip_dest=\"${PWDSH_DEST:=clipboard}\"  # cb type, 'screen' for stdout\nclip_timeout=\"${PWDSH_TIME:=10}\"      # seconds to clear cb/screen\ncomment=\"${PWDSH_COMMENT:=}\"          # *unencrypted* comment in files\ndaily_backup=\"${PWDSH_DAILY:=}\"       # daily backup archive on write\npass_copy=\"${PWDSH_COPY:=}\"           # copy password before write\npass_echo=\"${PWDSH_ECHO:=*}\"          # show \"*\" when typing passwords\npass_len=\"${PWDSH_LEN:=14}\"           # default password length\npepper=\"${PWDSH_PEPPER:=}\"            # additional secret file name\nsafe_dir=\"${PWDSH_SAFE:=safe}\"        # safe directory name\nsafe_ix=\"${PWDSH_INDEX:=pwd.index}\"   # index file name\nsafe_backup=\"${PWDSH_BACKUP:=pwd.$(hostname).${today}.tar}\"\npass_chars=\"${PWDSH_CHARS:='[:alnum:]!?@#$%^&*();:+='}\"\n\ntrap cleanup EXIT INT TERM\ncleanup () {\n  # \"Lock\" files on trapped exits.\n\n  ret=$?\n  chmod -R 0000 \"${pepper}\" \"${safe_dir}\" \"${safe_ix}\" 2>/dev/null\n  exit ${ret}\n}\n\nfail () {\n  # Print an error in red and exit.\n\n  tput setaf 1 ; printf \"\\nERROR: %s\\n\" \"${1}\" ; tput sgr0\n  exit 1\n}\n\nwarn () {\n  # Print a warning in yellow.\n  tput setaf 3 ; printf \"\\nWARNING: %s\\n\" \"${1}\" ; tput sgr0\n}\n\ngenerate_pepper () {\n  # Generate pepper, avoid ambiguous characters.\n\n  warn \"${pepper} created\"\n  printf \"%s\" \"$(tr -dc 'A-Z1-9' < /dev/urandom | \\\n    tr -d \"1IOS5U\" | fold -w 30 | sed \"-es/./ /\"{1..26..5} | \\\n    cut -c2- | tr \" \" \"-\" | head -1)\" | \\\n    tee \"${pepper}\" || fail \"Failed to create ${pepper}\"\n  printf \"\\n\"\n}\n\nget_pass () {\n  # Prompt for a password.\n\n  password=\"\"\n  prompt=\"  ${1}\"\n  printf \"\\n\"\n\n  while IFS= read -p \"${prompt}\" -r -s -n 1 char ; do\n    if [[ ${char} == $'\\0' ]] ; then break\n    elif [[ ${char} == $'\\177' ]] ; then\n      if [[ -z \"${password}\" ]] ; then prompt=\"\"\n      else\n        prompt=$'\\b \\b'\n        password=\"${password%?}\"\n      fi\n    else\n      prompt=\"${pass_echo}\"\n      password+=\"${char}\"\n    fi\n  done\n}\n\ndecrypt () {\n  # Decrypt with GPG.\n\n  printf \"%s\" \"${1}${pep}\" | \\\n    ${gpg} --armor --batch --no-symkey-cache \\\n    --decrypt --passphrase-fd 0 \"${2}\" 2>/dev/null\n}\n\nencrypt () {\n  # Encrypt with GPG.\n\n  ${gpg} --armor --batch --comment \"${comment}\" \\\n    --symmetric --yes --passphrase-fd 3 \\\n    --output \"${2}\" \"${3}\" 3< \\\n    <(printf \"%s\" \"${1}${pep}\") 2>/dev/null\n}\n\nread_pass () {\n  # Read a password from safe.\n\n  if [[ ! -s \"${safe_ix}\" ]] ; then fail \"${safe_ix} not found\" ; fi\n\n  while [[ -z \"${username}\" ]] ; do\n    if [[ -z \"${2+x}\" ]] ; then read -r -p \"\n  Username: \" username\n    else username=\"${2}\" ; fi\n  done\n\n  get_pass \"Password to access ${safe_ix}: \" ; printf \"\\n\"\n\n  spath=$(decrypt \"${password}\" \"${safe_ix}\" | \\\n    grep -F \"${username}\" | tail -1 | cut -d \":\" -f2) || \\\n      fail \"Secret not available\"\n\n  emit_pass <(decrypt \"${password}\" \"${spath}\") || \\\n    fail \"Failed to decrypt ${spath}\"\n}\n\ngenerate_pass () {\n  # Generate a password from urandom.\n\n  if [[ -z \"${3+x}\" ]] ; then read -r -p \"\n  Password length (default: ${pass_len}): \" length\n  else length=\"${3}\" ; fi\n\n  if [[ \"${length}\" =~ ^[0-9]+$ ]] ; then\n    pass_len=\"${length}\"\n  fi\n\n  tr -dc \"${pass_chars}\" < /dev/urandom | \\\n    fold -w \"${pass_len}\" | head -1\n}\n\ngenerate_user () {\n  # Generate a username.\n\n  printf \"%s%s\\n\" \\\n    \"$(awk 'length > 2 && length < 12 {print(tolower($0))}' \\\n    /usr/share/dict/words | grep -v \"'\" | sort -R | head -n2 | \\\n    tr \"\\n\" \"_\" | iconv -f utf-8 -t ascii//TRANSLIT)\" \\\n    \"$(tr -dc \"[:digit:]\" < /dev/urandom | fold -w 4 | head -1)\"\n}\n\nwrite_pass () {\n  # Write a password and update the index.\n\n  spath=\"${safe_dir}/$(tr -dc \"[:lower:]\" < /dev/urandom | \\\n    fold -w10 | head -1)\"\n\n  if [[ -n \"${pass_copy}\" ]] ; then\n    emit_pass <(printf '%s' \"${userpass}\") ; fi\n\n  get_pass \"Password to access ${safe_ix}: \" ; printf \"\\n\"\n\n  printf '%s\\n' \"${userpass}\" | \\\n    encrypt \"${password}\" \"${spath}\" - || \\\n      fail \"Failed saving ${spath}\"\n\n  ( if [[ -f \"${safe_ix}\" ]] ; then\n      decrypt \"${password}\" \"${safe_ix}\" || return ; fi\n    printf \"%s@%s:%s\\n\" \"${username}\" \"${now}\" \"${spath}\") | \\\n    encrypt \"${password}\" \"${safe_ix}.${now}\" - && \\\n      mv \"${safe_ix}.${now}\" \"${safe_ix}\" || \\\n        fail \"Failed saving ${safe_ix}.${now}\"\n}\n\nlist_entry () {\n  # Decrypt the index to list entries.\n\n  if [[ ! -s \"${safe_ix}\" ]] ; then fail \"${safe_ix} not found\" ; fi\n  get_pass \"Password to access ${safe_ix}: \" ; printf \"\\n\\n\"\n  decrypt \"${password}\" \"${safe_ix}\" || fail \"${safe_ix} not available\"\n}\n\nbackup () {\n  # Archive index, safe and configuration.\n\n  if [[ ! -f \"${safe_backup}\" ]] ; then\n    if [[ -f \"${safe_ix}\" && -d \"${safe_dir}\" ]] ; then\n      cp \"${gpg_conf}\" \"gpg.conf.${today}\"\n      tar cf \"${safe_backup}\" \"${safe_dir}\" \"${safe_ix}\" \\\n        \"${BASH_SOURCE}\" \"gpg.conf.${today}\" && \\\n          printf \"\\nArchived %s\\n\" \"${safe_backup}\"\n      rm -f \"gpg.conf.${today}\"\n    else fail \"Nothing to archive\" ; fi\n  else warn \"${safe_backup} exists, skipping archive\" ; fi\n}\n\nemit_pass () {\n  # Use clipboard or stdout and clear after timeout.\n\n  if [[ \"${clip_dest}\" = \"screen\" ]] ; then\n    printf '\\n%s\\n' \"$(cat ${1})\"\n  else ${clip} < \"${1}\" ; fi\n\n  printf \"\\n\"\n  while [[ \"${clip_timeout}\" -gt 0 ]] ; do\n    printf \"\\r\\033[K  Password on %s! Clearing in %.d\" \\\n      \"${clip_dest}\" \"$((clip_timeout--))\" ; sleep 1\n  done\n  printf \"\\r\\033[K  Clearing password from %s ...\" \"${clip_dest}\"\n\n  if [[ \"${clip_dest}\" = \"screen\" ]] ; then clear\n  else printf \"\\n\" ; printf \"\" | ${clip} ; fi\n}\n\nnew_entry () {\n  # Prompt for username and password.\n\n  if [[ -z \"${2+x}\" ]] ; then read -r -p \"\n  Username (Enter to generate): \" username\n  else username=\"${2}\" ; fi\n\n  if [[ -z \"${username}\" ]] ; then\n    username=$(generate_user \"$@\") ; fi\n\n  if [[ -z \"${3+x}\" ]] ; then\n    get_pass \"Password for \\\"${username}\\\" (Enter to generate): \"\n    userpass=\"${password}\"\n  fi\n\n  printf \"\\n\"\n  if [[ -z \"${password}\" ]] ; then\n    userpass=$(generate_pass \"$@\") ; fi\n}\n\nprint_help () {\n  # Print help text.\n\n  printf \"\"\"\n  pwd.sh is a Bash shell script to manage passwords and other text-based secrets.\\n\n  It uses GnuPG to symmetrically (i.e., using a master password) encrypt and decrypt plaintext files.\\n\n  Each password is encrypted as a unique, randomly-named file in the 'safe' directory. An encrypted index is used to map usernames to the respective password file. Both the index and password files can also be decrypted directly with GnuPG without this script.\\n\n  Run the script interactively using ./pwd.sh or symlink to a directory in PATH:\n    * 'w' to write a password\n    * 'r' to read a password\n    * 'l' to list passwords\n    * 'b' to create an archive for backup\\n\n  Options can also be passed on the command line.\\n\n  * Create a 20-character password for userName:\n    ./pwd.sh w userName 20\\n\n  * Read password for userName:\n    ./pwd.sh r userName\\n\n  * Passwords are stored with an epoch timestamp for revision control. The most recent version is copied to clipboard on read. To list all passwords or read a specific version of a password:\n    ./pwd.sh l\n    ./pwd.sh r userName@1574723625\\n\n  * Create an archive for backup:\n    ./pwd.sh b\\n\n  * Restore an archive from backup:\n    tar xvf pwd*tar\\n\"\"\"\n}\n\nif [[ -z \"${gpg}\" ]] ; then fail \"GnuPG is not available\" ; fi\n\nif [[ ! -f \"${gpg_conf}\" ]] ; then fail \"GnuPG config is not available\" ; fi\n\nif [[ ! -d \"${safe_dir}\" ]] ; then mkdir -p \"${safe_dir}\" ; fi\n\nif [[ -n \"${pepper}\" && ! -f \"${pepper}\" ]] ; then generate_pepper ; fi\n\nchmod -R 0700 \"${pepper}\" \"${safe_dir}\" \"${safe_ix}\" 2>/dev/null\n\nif [[ -f \"${pepper}\" ]] ; then pep=\"$(cat ${pepper})\" ; else pep=\"\" ; fi\n\nif [[ -z \"$(command -v ${clip})\" ]] ; then\n  warn \"Clipboard not available, passwords will print to screen/stdout!\"\n  clip_dest=\"screen\"\nelif [[ -n \"${clip_args}\" ]] ; then\n  clip+=\" ${clip_args}\"\nfi\n\nusername=\"\"\npassword=\"\"\naction=\"\"\n\nif [[ -n \"${1+x}\" ]] ; then action=\"${1}\" ; fi\n\nwhile [[ -z \"${action}\" ]] ; do read -r -n 1 -p \"\n  Read or Write (or Help for more options): \" action\n  printf \"\\n\"\ndone\n\nif [[ \"${action}\" =~ ^([rR])$ ]] ; then read_pass \"$@\"\nelif [[ \"${action}\" =~ ^([wW])$ ]] ; then\n  new_entry \"$@\"\n  write_pass\n  if [[ -n \"${daily_backup}\" ]] ; then backup ; fi\nelif [[ \"${action}\" =~ ^([lL])$ ]] ; then list_entry\nelif [[ \"${action}\" =~ ^([bB])$ ]] ; then backup\nelse print_help ; fi\n\ntput setaf 2 ; printf \"\\nDone\\n\" ; tput sgr0\n"
        }
      ]
    }
  ]
}