{
  "metadata": {
    "timestamp": 1736568579468,
    "page": 626,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "easychen/openai-gpt-dev-notes-for-cn-developer",
      "stars": 1473,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".DS_Store",
          "type": "blob",
          "size": 6.00390625,
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0048828125,
          "content": "book\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.0634765625,
          "content": "在写了一堆应用以后，我们打算[众筹一个GPT课程](https://subdeer.cn/product/3)。之前我以为现在GPT应用已经是红海了，但实际测试下来发现，GPT应用其实可以是非标准品。独有的提示词、独有的知识库、独有的工作流都可以做出独一无二的GPT体验。\n\n在课程中我们将讲解如何设计、搭建和开发一个与众不同的商业GPT应用。<https://subdeer.cn/product/3>\n\n# 如何快速开发一个OpenAI/GPT应用\n\n> 一个国内开发者的OpenAI/GPT的笔记\n\n\n最近都在问，于是写个文档。本文希望用尽可能少的内容，讲清楚开发一个OpenAI/GPT应用必然用到的知识，内容主要聚焦在免费应用开发，商业化方案可以看看这篇文章：[《十分钟，给你开发的免费GPT应用加上收费功能》](https://a.ftqq.com/2023/04/18/api2d-developer-program/)\n\n欢迎PR补充。\n\n### AI/Automation开发交流群\n\n1. 电报群 <https://t.me/+s-5piM3koEphNDY1>\n1. 微信群 \n\n![](images/20230322123451.jpeg)\n\n\n目录\n=================\n\n* [如何快速开发一个OpenAI/GPT应用](#如何快速开发一个openaigpt应用)\n   * [ChatGPT &amp;&amp; OpenAI 的关系](#chatgpt--openai-的关系)\n   * [OpenAI API 接口能做什么](#openai-api-接口能做什么)\n   * [chat completions 接口如何使用？](#chat-completions-接口如何使用)\n      * [Stream 参数](#stream-参数)\n      * [其他参数](#其他参数)\n   * [Chat completions 接口如何计费？](#chat-completions-接口如何计费)\n   * [chat completions 接口能做什么 ①](#chat-completions-接口能做什么-)\n   * [chat completions 接口能做什么 ②](#chat-completions-接口能做什么--1)\n   * [国内是否可以上线运营GPT相关业务？](#国内是否可以上线运营gpt相关业务)\n   * [如何解决国内用户无法注册OpenAI账号、无法访问OpenAI接口的问题？](#如何解决国内用户无法注册openai账号无法访问openai接口的问题)\n      * [注册OpenAI](#注册openai)\n      * [访问OpenAI API](#访问openai-api)\n      * [通过第三方接口访问](#通过第三方接口访问)\n   * [如何避免 OpenAI 封禁账号 API权限](#如何避免-openai-封禁账号-api权限)\n   * [如何知道 OpenAI 接口状态](#如何知道-openai-接口状态)\n\n\n## ChatGPT && OpenAI 的关系\n\nChatGPT 是 OpenAI 推出的应用，使用的是最新的模型；而 OpenAI 开放接口的模型是 gpt-3.5-turbo ，这个模型比 ChatGPT 应用要笨。但 ChatGPT 用的最新模型没有接口，只能通过无头浏览器等方式来使用（不稳定）。\n\n> 更新：目前已经开放了 gpt-4 ，当前尚未提供图片输入接口，使用方式和 gpt-3.5-turbo 一致，只需要将 model 参数更换为 gpt-4 ，注意 gpt-4 的 max tokens 为 8k （gpt-4-32k 为 32k），Token 价格是 3.5 的 15~30 倍。\n\n## OpenAI API 接口能做什么\n\n能做的事情很多，可以查看[官方文档](https://platform.openai.com/docs)，但这个文档中国网络目前无法访问。\n\n![](images/20230307155346.png)\n\n具体来讲，OpenAI 所有的可用的接口都在里边，包括语音识别和图片生成。但真正智能的其实只有 `gpt-3.5-turbo`，因此刚开始不用看其他内容。\n\n目前大家看到的绝大部分GPT类应用都是由 `gpt-3.5-turbo` 模型的 `chat completions` 对话补全接口实现的。\n\n![](images/20230307150247.png)\n\n## chat completions 接口如何使用？\n\n可以通过很多方式来使用，比如使用官方SDK，第三方项目，但其实只需要一个HTTP请求就可以。以下是官方文档给出的例子：\n\n```bash\ncurl https://api.openai.com/v1/chat/completions \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer YOUR_API_KEY' \\\n  -d '{\n  \"model\": \"gpt-3.5-turbo\",\n  \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n}'\n```\n\n从里边可以看到，需要的信息有：\n\n① 请求地址： `https://api.openai.com/v1/chat/completions` 这个地址目前在国内大部分地区已经无法访问了，后边会讲解决办法 \n\n② 最常用的接口参数包括：\n\n1. model: 必填，建议使用 `gpt-3.5-turbo`，便宜。计费后边会讲。\n1. messages: AI 进行提问的问题或信息。\n1. max_tokens: 选填，指定生成回答的最大Token数。\n1. stream: 选填，是否按流的方式发送内容。\n\n其中 messages的格式为：`{\"role\",\"content\"}`。一般用 `user` 发送用户问题；`system` 发送给模型提示信息。\n\n例如：\n```json\n[\n  {\"role\": \"system\", \"content\": \"You are a helpful assistant that translates English to French.\"},\n  {\"role\": \"user\", \"content\": \"Translate the following English text to French: {text}\"}\n]\n```\n知道了这些基本就可以跑通GPT流程了，其他role可以稍后优化时来做。\n\n### Stream 参数\n\n这里单独说一下 stream 参数，当它设置为 true 时，API 会以 SSE（ Server Side Event ）方式返回内容。\n\nSSE 本质上还是 HTTP 协议，只不过它是一个长链接，先输出一个 `header(\"Content-Type: text/event-stream\")` ， 然后持续不断地输出内容直到完成。如果不是做实时聊天，建议直接false掉。\n\n需要注意的是，开启stream 后，将不会返回 usage 信息，这对精准计费有影响\n\n```\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"我\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"没有\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"当前\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"日期\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"的\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"实\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"时\"},\"index\":0,\"finish_reason\":null}]}\n{\"id\":\"chatcmpl-6s3hNohxOliHi8zR7m5UTrLm4cWWc\",\"object\":\"chat.completion.chunk\",\"created\":1678341949,\"model\":\"gpt-3.5-turbo-0301\",\"choices\":[{\"delta\":{\"content\":\"信息\"},\"index\":0,\"finish_reason\":null}]}\n```\n\n\n### 其他参数\n\n接口的其他参数可以看[官方文档](https://platform.openai.com/docs/api-reference/chat)，访问不了的同学可以看我做的截图。\n\n![](images/20230307143748.png)\n![](images/20230307143831.png)\n\n## Chat completions 接口如何计费？\n\n`chat completions` 接口按 token 计费，有一个专门的算法来计算 token。输入和输出全部都会计入到 token 里边，在 `chat completions` 接口的 `usage` 里边会有具体消耗的 token 数。\n\n如果你要自己计算，可以用这个[在线表单](https://tiktokenizer.vercel.app)，程序计算可以看看这两个项目：\n\n1. https://github.com/dqbd/tiktokenizer\n2. https://github.com/openai/tiktoken\n\n\n除了 `gpt-3.5-turbo` 模型的 `chat completions` 接口，还有 `text-davinci-003` 模型的 `text completions` 接口可以用，但是价格更贵，效果更差 🤣\n\n你可以在 <https://openai.com/pricing> 查询到价格，以下是3月中旬的定价\n \n| Model | Usage |\n| --- | --- |\n| gpt-3.5-turbo (ChatGPT) | $0.002 / 1K tokens |\n| Davinci (InstructGPT) | $0.0200 / 1K tokens |\n| Ada (InstructGPT) | $0.0004 / 1K tokens |\n| Babbage (InstructGPT) | $0.0005 / 1K tokens |\n| Curie (InstructGPT) | $0.0020 / 1K tokens |\n\n\n## chat completions 接口能做什么 ①\n\n虽然 `chat completions` 看起来像是一个聊天接口，但接口设计上并没有为聊天优化，因为这个接口是记不住上下文的。\n\n为了让对话具有连续性，我们每次请求需要带上上次的聊天记录。有多种方式解决这个问题，一个是直接在messages参数中加上聊天记录。其中，GPT返回的内容用 `assistant` role。\n\n```json\n[\n     {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n     {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n     {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n     {\"role\": \"user\", \"content\": \"Where was it played?\"}\n ]\n```\n\n另一个方式是使用第三方库，比如`chatgpt-api`，它可以自动帮你发送聊天记录（通过指定对话的`parentMessageId`实现）：\n\n1. <https://github.com/transitive-bullshit/chatgpt-api>\n\n![](images/20230307150942.png)\n\n在加上对话记录后，`chat completions` 接口就可以制作一个看起来有智能的聊天应用了。\n\n\n\n> 如果你要在国内运营聊天机器人之类的话，请记得将内容通过文本内容审核接口进行审核，否则很可能导致被封。\n\n## chat completions 接口能做什么 ②\n\n其实除了对话，GPT有很强的内容总结归纳能力，另外由于它能理解内容结构，同时本身又是语言模型，因此对结构化翻译很擅长。\n\n比如，我经常用它翻译JSON和Markdown，大部分情况下效果很好。在自用体验很好的情况下，我们可以将其制作为应用。\n\n![](images/20230307151810.png)\n\n应用开发非常简单，我只用一天时间开发了[AiBox](https://ai.ftqq.com/)，按基本的web应用开发就可以，重点说几个细节：\n\n1. 提示词：直接把提示词以 system 的 role 提交就可以。\n1. Key问题：开发者的Key肯定是不够用的，因此一般会让使用者填写自己的Key。但是国内用户没有海外手机号，无法申请key;申请下来API直接访问也不通，解决方案有几种，后边专门讲\n1. Token计算和限制问题：如果使用者用自己的Key，为了提升体验，我们可以提供一个Token计算，让用户知道自己的会花多少钱。另外如果你没有用第三方那个库来分拆，那么一次请求的内容不要超过 max_tokens 的限制。这个值一般是 4096。\n\n## 国内是否可以上线运营GPT相关业务？\n\n就目前而言，我了解到的情况是大部分企业没有收到明确禁止运营GPT相关业务的通知，但在国内运营要做好内容安全，比如对接口返回的内容再过一层内容审核。否则如果在应用中出现违规内容被举报，就会被封禁。\n\n但这是一个随时可能变化的情况，我们准备了[一个issue](https://github.com/easychen/openai-api-proxy/issues/11)供大家反馈。\n\n## 如何解决国内用户无法注册OpenAI账号、无法访问OpenAI接口的问题？\n\n两个思路，一个是绕道海外去注册，通过代理使用服务；另一个是直接使用第三方代理API服务。前者可以暂时解决当前的问题；后者更方便省心。\n\n### 注册OpenAI\n\n1. 准备一个海外的网络\n1. 准备一个海外手机号来接收验证短信，可以用[海外虚拟号码](https://sms-activate.org/?ref=4207095)\n\n注册完成后，进入[API页面](https://openai.com/api/) 创建Key，然后就可以使用了。\n\n这个方案目前可行，是因为OpenAI给每个新用户提供了18美金的免费额度。但是一旦不再提供，就会面临充值的问题。目前OpenAI不接受中国信用卡，因此还必须准备一个海外信用卡。也就是说，要长久稳定的使用，必须有海外信用卡。\n\n以前有财付通的海外虚拟信用卡，后来服务下线了。最近看了下，很多500RMB起，还只支持电商网站，感觉不太靠谱 🤣\n\n### 访问OpenAI API\n\n3月3日开始，国内大部分网络不再能直接访问 OpenAI 接口。\n\n![](images/20230307153602.png)\n\n因此你需要架设代理来访问OpenAI 接口。你可以将整个服务器代理到海外网络，或者只是简单的通过 Cloudflare 或者 腾讯云函数来部署API代理。\n\n如果你准备使用腾讯云函数，[教程可以看这里](https://github.com/easychen/openai-api-proxy/blob/master/FUNC.md)\n\n![](images/20230307155459.png)\n\n需要注意的是，腾讯云API代理会将长连接内容一次性返回，因此流式体验不明显。当然，有同学说腾讯云的 ApiGateway 直接就能代理，但我测试了下没成功。\n\n### 通过第三方接口访问\n\n如果你搞不定海外手机号和信用卡，或者自己不想架设代理，那么可以考虑用像[API2D](https://api2d.com)这样的第三方代理API。\n\n主要的优点：\n\n1. 基本兼容原有接口，只需要改下 API endpoint 和 Key\n1. 接口国内直接可以访问，无需架设代理\n1. 支持微信和国内卡充值，提供最小0.5美金/3.5人民币的测试档位，GitHub注册还有50点免费额度试用\n1. 添加 moderation 参数，可以返回内容审核结果，省事\n1. 推荐可以获得点数，这里是我的[推荐链接](https://api2d.com/r/186008)\n\n缺点：\n\n1. ~~不支持 stream 参数~~，已经支持 stream\n1. 目前只支持 chat 和 embeddings 接口\n1. 价格比官方略高，大概1.5倍，当然这个包含了流量中转的成本\n\n> 利益相关：api2d这个产品是作者加拿大的朋友做的，而且作为早期用户一直在重度使用\n\n## 如何避免 OpenAI 封禁账号 API权限\n\n最近得到反馈，很多架设香港代理的账号收到了邮件被禁用了权限。经过群里大家的讨论，总结的经验如下：\n\n1. 不要使用 OpenAI 不服务地区的代理\n1. 虚拟海外手机号更可能导致账号被封\n1. 绑定信用卡可以大幅提升账号存活率\n\n## 如何知道 OpenAI 接口状态\n\nOpenAI官方提供了一个[状态页](https://status.openai.com/)，虽然小故障不怎么显示，但大面积宕机时能看到公告。\n\n![image](https://user-images.githubusercontent.com/1294760/223604103-4093bdd4-4455-4f55-a294-fb7003325000.png)\n\n\n\n\n\n\n\n\n"
        },
        {
          "name": "book.toml",
          "type": "blob",
          "size": 0.10546875,
          "content": "[book]\nauthors = [\"Easy\"]\nlanguage = \"en\"\nmultilingual = false\nsrc = \"src\"\ntitle = \"OpenAI/GPT开发笔记\"\n"
        },
        {
          "name": "gh-md-toc",
          "type": "blob",
          "size": 12.087890625,
          "content": "#!/usr/bin/env bash\n\n#\n# Steps:\n#\n#  1. Download corresponding html file for some README.md:\n#       curl -s $1\n#\n#  2. Discard rows where no substring 'user-content-' (github's markup):\n#       awk '/user-content-/ { ...\n#\n#  3.1 Get last number in each row like ' ... </span></a>sitemap.js</h1'.\n#      It's a level of the current header:\n#       substr($0, length($0), 1)\n#\n#  3.2 Get level from 3.1 and insert corresponding number of spaces before '*':\n#       sprintf(\"%*s\", (level-1)*'\"$nb_spaces\"', \"\")\n#\n#  4. Find head's text and insert it inside \"* [ ... ]\":\n#       substr($0, match($0, /a>.*<\\/h/)+2, RLENGTH-5)\n#\n#  5. Find anchor and insert it inside \"(...)\":\n#       substr($0, match($0, \"href=\\\"[^\\\"]+?\\\" \")+6, RLENGTH-8)\n#\n\ngh_toc_version=\"0.8.0\"\n\ngh_user_agent=\"gh-md-toc v$gh_toc_version\"\n\n#\n# Download rendered into html README.md by its url.\n#\n#\ngh_toc_load() {\n    local gh_url=$1\n\n    if type curl &>/dev/null; then\n        curl --user-agent \"$gh_user_agent\" -s \"$gh_url\"\n    elif type wget &>/dev/null; then\n        wget --user-agent=\"$gh_user_agent\" -qO- \"$gh_url\"\n    else\n        echo \"Please, install 'curl' or 'wget' and try again.\"\n        exit 1\n    fi\n}\n\n#\n# Converts local md file into html by GitHub\n#\n# -> curl -X POST --data '{\"text\": \"Hello world github/linguist#1 **cool**, and #1!\"}' https://api.github.com/markdown\n# <p>Hello world github/linguist#1 <strong>cool</strong>, and #1!</p>'\"\ngh_toc_md2html() {\n    local gh_file_md=$1\n    local skip_header=$2\n\n    URL=https://api.github.com/markdown/raw\n\n    if [ ! -z \"$GH_TOC_TOKEN\" ]; then\n        TOKEN=$GH_TOC_TOKEN\n    else\n        TOKEN_FILE=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)/token.txt\"\n        if [ -f \"$TOKEN_FILE\" ]; then\n            TOKEN=\"$(cat $TOKEN_FILE)\"\n        fi\n    fi\n    if [ ! -z \"${TOKEN}\" ]; then\n        AUTHORIZATION=\"Authorization: token ${TOKEN}\"\n    fi\n\n    local gh_tmp_file_md=$gh_file_md\n    if [ \"$skip_header\" = \"yes\" ]; then\n        if grep -Fxq \"<!--te-->\" \"$gh_src\"; then\n          # cut everything before the toc\n          gh_tmp_file_md=$gh_file_md~~\n          sed '1,/<!--te-->/d' $gh_file_md > $gh_tmp_file_md\n        fi\n    fi\n\n    # echo $URL 1>&2\n    OUTPUT=$(curl -s \\\n        --user-agent \"$gh_user_agent\" \\\n        --data-binary @\"$gh_tmp_file_md\" \\\n        -H \"Content-Type:text/plain\" \\\n        -H \"$AUTHORIZATION\" \\\n        \"$URL\")\n\n    rm -f $gh_file_md~~\n\n    if [ \"$?\" != \"0\" ]; then\n        echo \"XXNetworkErrorXX\"\n    fi\n    if [ \"$(echo \"${OUTPUT}\" | awk '/API rate limit exceeded/')\" != \"\" ]; then\n        echo \"XXRateLimitXX\"\n    else\n        echo \"${OUTPUT}\"\n    fi\n}\n\n\n#\n# Is passed string url\n#\ngh_is_url() {\n    case $1 in\n        https* | http*)\n            echo \"yes\";;\n        *)\n            echo \"no\";;\n    esac\n}\n\n#\n# TOC generator\n#\ngh_toc(){\n    local gh_src=$1\n    local gh_src_copy=$1\n    local gh_ttl_docs=$2\n    local need_replace=$3\n    local no_backup=$4\n    local no_footer=$5\n    local indent=$6\n    local skip_header=$7\n\n    if [ \"$gh_src\" = \"\" ]; then\n        echo \"Please, enter URL or local path for a README.md\"\n        exit 1\n    fi\n\n\n    # Show \"TOC\" string only if working with one document\n    if [ \"$gh_ttl_docs\" = \"1\" ]; then\n\n        echo \"Table of Contents\"\n        echo \"=================\"\n        echo \"\"\n        gh_src_copy=\"\"\n\n    fi\n\n    if [ \"$(gh_is_url \"$gh_src\")\" == \"yes\" ]; then\n        gh_toc_load \"$gh_src\" | gh_toc_grab \"$gh_src_copy\" \"$indent\"\n        if [ \"${PIPESTATUS[0]}\" != \"0\" ]; then\n            echo \"Could not load remote document.\"\n            echo \"Please check your url or network connectivity\"\n            exit 1\n        fi\n        if [ \"$need_replace\" = \"yes\" ]; then\n            echo\n            echo \"!! '$gh_src' is not a local file\"\n            echo \"!! Can't insert the TOC into it.\"\n            echo\n        fi\n    else\n        local rawhtml=$(gh_toc_md2html \"$gh_src\" \"$skip_header\")\n        if [ \"$rawhtml\" == \"XXNetworkErrorXX\" ]; then\n             echo \"Parsing local markdown file requires access to github API\"\n             echo \"Please make sure curl is installed and check your network connectivity\"\n             exit 1\n        fi\n        if [ \"$rawhtml\" == \"XXRateLimitXX\" ]; then\n             echo \"Parsing local markdown file requires access to github API\"\n             echo \"Error: You exceeded the hourly limit. See: https://developer.github.com/v3/#rate-limiting\"\n             TOKEN_FILE=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)/token.txt\"\n             echo \"or place GitHub auth token here: ${TOKEN_FILE}\"\n             exit 1\n        fi\n        local toc=`echo \"$rawhtml\" | gh_toc_grab \"$gh_src_copy\" \"$indent\"`\n        echo \"$toc\"\n        if [ \"$need_replace\" = \"yes\" ]; then\n            if grep -Fxq \"<!--ts-->\" \"$gh_src\" && grep -Fxq \"<!--te-->\" \"$gh_src\"; then\n                echo \"Found markers\"\n            else\n                echo \"You don't have <!--ts--> or <!--te--> in your file...exiting\"\n                exit 1\n            fi\n            local ts=\"<\\!--ts-->\"\n            local te=\"<\\!--te-->\"\n            local dt=`date +'%F_%H%M%S'`\n            local ext=\".orig.${dt}\"\n            local toc_path=\"${gh_src}.toc.${dt}\"\n            local toc_createdby=\"<!-- Created by https://github.com/ekalinin/github-markdown-toc -->\"\n            local toc_footer=\"<!-- Added by: `whoami`, at: `date` -->\"\n            # http://fahdshariff.blogspot.ru/2012/12/sed-mutli-line-replacement-between-two.html\n            # clear old TOC\n            sed -i${ext} \"/${ts}/,/${te}/{//!d;}\" \"$gh_src\"\n            # create toc file\n            echo \"${toc}\" > \"${toc_path}\"\n            if [ \"${no_footer}\" != \"yes\" ]; then\n                echo -e \"\\n${toc_createdby}\\n${toc_footer}\\n\" >> \"$toc_path\"\n            fi\n\n            # insert toc file\n            if ! sed --version > /dev/null 2>&1; then\n                sed -i \"\" \"/${ts}/r ${toc_path}\" \"$gh_src\"\n            else\n                sed -i \"/${ts}/r ${toc_path}\" \"$gh_src\"\n            fi\n            echo\n            if [ \"${no_backup}\" = \"yes\" ]; then\n                rm \"$toc_path\" \"$gh_src$ext\"\n            fi\n            echo \"!! TOC was added into: '$gh_src'\"\n            if [ -z \"${no_backup}\" ]; then\n                echo \"!! Origin version of the file: '${gh_src}${ext}'\"\n                echo \"!! TOC added into a separate file: '${toc_path}'\"\n        fi\n            echo\n        fi\n    fi\n}\n\n#\n# Grabber of the TOC from rendered html\n#\n# $1 - a source url of document.\n#      It's need if TOC is generated for multiple documents.\n# $2 - number of spaces used to indent.\n#\ngh_toc_grab() {\n    common_awk_script='\n                     modified_href = \"\"\n                     split(href, chars, \"\")\n                     for (i=1;i <= length(href); i++) {\n                         c = chars[i]\n                         res = \"\"\n                         if (c == \"+\") {\n                             res = \" \"\n                         } else {\n                             if (c == \"%\") {\n                                 res = \"\\\\x\"\n                             } else {\n                                 res = c \"\"\n                             }\n                         }\n                         modified_href = modified_href res\n                    }\n                    print sprintf(\"%*s\", (level-1)*'\"$2\"', \"\") \"* [\" text \"](\" gh_url  modified_href \")\"\n                    '\n    if [ `uname -s` == \"OS/390\" ]; then\n        grepcmd=\"pcregrep -o\"\n        echoargs=\"\"\n        awkscript='{\n                     level = substr($0, length($0), 1)\n                     text = substr($0, match($0, /a>.*<\\/h/)+2, RLENGTH-5)\n                     href = substr($0, match($0, \"href=\\\"([^\\\"]+)?\\\"\")+6, RLENGTH-7)\n                     '\"$common_awk_script\"'\n                }'\n    else\n        grepcmd=\"grep -Eo\"\n        echoargs=\"-e\"\n        awkscript='{\n                     level = substr($0, length($0), 1)\n                     text = substr($0, match($0, /a>.*<\\/h/)+2, RLENGTH-5)\n                     href = substr($0, match($0, \"href=\\\"[^\\\"]+?\\\"\")+6, RLENGTH-7)\n                     '\"$common_awk_script\"'\n                }'\n    fi\n    href_regex='href=\\\"[^\\\"]+?\\\"'\n\n    # if closed <h[1-6]> is on the new line, then move it on the prev line\n    # for example:\n    #   was: The command <code>foo1</code>\n    #        </h1>\n    #   became: The command <code>foo1</code></h1>\n    sed -e ':a' -e 'N' -e '$!ba' -e 's/\\n<\\/h/<\\/h/g' |\n\n    # find strings that corresponds to template\n    $grepcmd '<a.*id=\"user-content-[^\"]*\".*</h[1-6]' |\n\n    # remove code tags\n    sed 's/<code>//g' | sed 's/<\\/code>//g' |\n\n    # remove g-emoji\n    sed 's/<g-emoji[^>]*[^<]*<\\/g-emoji> //g' |\n\n    # now all rows are like:\n    #   <a id=\"user-content-...\" href=\"...\"><span ...></span></a> ... </h1\n    # format result line\n    #   * $0 - whole string\n    #   * last element of each row: \"</hN\" where N in (1,2,3,...)\n    echo $echoargs \"$(awk -v \"gh_url=$1\" \"$awkscript\")\"\n}\n\n        # perl -lpE 's/(\\[[^\\]]*\\]\\()(.*?)(\\))/my ($pre, $in, $post)=($1, $2, $3) ; $in =~ s{\\+}{ }g; $in =~ s{%}{\\\\x}g; $pre.$in.$post/ems')\"\n\n#\n# Returns filename only from full path or url\n#\ngh_toc_get_filename() {\n    echo \"${1##*/}\"\n}\n\nshow_version() {\n    echo \"$gh_toc_version\"\n    echo\n    echo \"os:     `uname -s`\"\n    echo \"arch:   `uname -m`\"\n    echo \"kernel: `uname -r`\"\n    echo \"shell:  `$SHELL --version`\"\n    echo\n    for tool in curl wget grep awk sed; do\n        printf \"%-5s: \" $tool\n        if `type $tool &>/dev/null`; then\n            echo `$tool --version | head -n 1`\n        else\n            echo \"not installed\"\n        fi\n    done\n}\n\nshow_help() {\n    local app_name=$(basename \"$0\")\n    echo \"GitHub TOC generator ($app_name): $gh_toc_version\"\n    echo \"\"\n    echo \"Usage:\"\n    echo \"  $app_name [options] src [src]   Create TOC for a README file (url or local path)\"\n    echo \"  $app_name -                     Create TOC for markdown from STDIN\"\n    echo \"  $app_name --help                Show help\"\n    echo \"  $app_name --version             Show version\"\n    echo \"\"\n    echo \"Options:\"\n    echo \"  --indent <NUM>      Set indent size. Default: 3.\"\n    echo \"  --insert            Insert new TOC into original file. For local files only. Default: false.\"\n    echo \"                      See https://github.com/ekalinin/github-markdown-toc/issues/41 for details.\"\n    echo \"  --no-backup         Remove backup file. Set --insert as well. Default: false.\"\n    echo \"  --hide-footer       Do not write date & author of the last TOC update. Set --insert as well. Default: false.\"\n    echo \"  --skip-header       Hide entry of the topmost headlines. Default: false.\"\n    echo \"                      See https://github.com/ekalinin/github-markdown-toc/issues/125 for details.\"\n    echo \"\"\n}\n\n#\n# Options handlers\n#\ngh_toc_app() {\n    local need_replace=\"no\"\n    local indent=3\n\n    if [ \"$1\" = '--help' ] || [ $# -eq 0 ] ; then\n        show_help\n        return\n    fi\n\n    if [ \"$1\" = '--version' ]; then\n        show_version\n        return\n    fi\n\n    if [ \"$1\" = '--indent' ]; then\n        indent=\"$2\"\n        shift 2\n    fi\n\n    if [ \"$1\" = \"-\" ]; then\n        if [ -z \"$TMPDIR\" ]; then\n            TMPDIR=\"/tmp\"\n        elif [ -n \"$TMPDIR\" -a ! -d \"$TMPDIR\" ]; then\n            mkdir -p \"$TMPDIR\"\n        fi\n        local gh_tmp_md\n        if [ `uname -s` == \"OS/390\" ]; then\n            local timestamp=$(date +%m%d%Y%H%M%S)\n            gh_tmp_md=\"$TMPDIR/tmp.$timestamp\"\n        else\n            gh_tmp_md=$(mktemp $TMPDIR/tmp.XXXXXX)\n        fi\n        while read input; do\n            echo \"$input\" >> \"$gh_tmp_md\"\n        done\n        gh_toc_md2html \"$gh_tmp_md\" | gh_toc_grab \"\" \"$indent\"\n        return\n    fi\n\n    if [ \"$1\" = '--insert' ]; then\n        need_replace=\"yes\"\n        shift\n    fi\n\n    if [ \"$1\" = '--no-backup' ]; then\n        need_replace=\"yes\"\n        no_backup=\"yes\"\n        shift\n    fi\n\n    if [ \"$1\" = '--hide-footer' ]; then\n        need_replace=\"yes\"\n        no_footer=\"yes\"\n        shift\n    fi\n\n    if [ \"$1\" = '--skip-header' ]; then\n        skip_header=\"yes\"\n        shift\n    fi\n\n\n    for md in \"$@\"\n    do\n        echo \"\"\n        gh_toc \"$md\" \"$#\" \"$need_replace\" \"$no_backup\" \"$no_footer\" \"$indent\" \"$skip_header\"\n    done\n\n    echo \"\"\n    echo \"<!-- Created by https://github.com/ekalinin/github-markdown-toc -->\"\n}\n\n#\n# Entry point\n#\ngh_toc_app \"$@\"\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}