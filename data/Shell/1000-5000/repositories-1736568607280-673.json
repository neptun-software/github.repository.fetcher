{
  "metadata": {
    "timestamp": 1736568607280,
    "page": 673,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "frankiejun/serv00-play",
      "stars": 1398,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.123046875,
          "content": "*.log\r\n*.json\r\n*.out\r\n*.js\r\n*test\r\na.*\r\n*.swp\r\nvmess/node_modules\r\nvmess/list\r\nvmess/cloudflared\r\nvless/node_modules\r\ntools/\r\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.556640625,
          "content": "Copyright [2024] [饭奇骏]\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.943359375,
          "content": "# serv00 上的一些应用，包括 argo+vmess/vmess+ws/hy2/socks5/mtproto/alist/哪吒探针/sun-panel/webssh 等, 自动化部署、批量保号、进程防杀、消息推送\r\n\r\n💖 如果你在用这个项目，请给我打个 star，好让我知道有多少人从这个项目中受益。\r\n\r\n## 前置工作\r\n\r\n1. 你需要有一个 serv00 帐号\r\n2. 首次运行，无需使用面板，选 1 安装 serv00-play, 它会自动重新登录，输入 ss 回车进入界面。(以后都是输入 ss 回车进入界面)\r\n\r\n## 安装说明\r\n\r\n```s\r\nbash <(curl -Ls https://raw.githubusercontent.com/frankiejun/serv00-play/main/start.sh)\r\n```\r\n\r\n## 变量说明\r\n\r\n| 变量名          | 示例   | 备注                                                                             |\r\n| --------------- | ------ | -------------------------------------------------------------------------------- |\r\n| HOSTS_JSON      | 见示例 | 可存放 n 个服务器信息 (必选)                                                     |\r\n| TELEGRAM_TOKEN  | 略     | telegram 机器人的 token (发送 TG 消息必选)                                       |\r\n| TELEGRAM_USERID | 略     | 待通知的 teltegram 用户 ID (发送 TG 消息必选)                                    |\r\n| WXSENDKEY       | 略     | server 酱的 sendkey，用于接收微信消息 (发送微信消息必选)                         |\r\n| SENDTYPE        | 3      | 选择推送方式，1.Telegram, 2.微信, 3.都有 (发送消息必选)                          |\r\n| BUTTON_URL      | 略     | 设置 TG 推送消息中的按钮链接 (发送 TG 消息可选),支持#HOST，#USER，#PASS 等变量。 |\r\n| AUTOUPDATE      | Y/N    | 设置是否自动更新服务器上的代码,设置在 variable 变量中，值为 Y/N(默认: Y)         |\r\n| LOGININFO       | Y/N    | 在 variable 变量中设置(默认为 N)，Y:发送登录汇总消息 N:只在登录失败时发送        |\r\n\r\n各主机保活时可不必输入消息通知参数，由 github 同一配置参数。\r\n\r\n如果主机上配置了消息推送参数，则优先级大于 github 上的配置。\r\n\r\n## action 保活内容\r\n\r\n1.定时自动登录各个主机，起到保号作用(因 serv00 需要每 3 个月登录一次)  \r\n2.执行兜底保活策略  \r\n3.检查主机上保活用的 cronjob 是否被删，若被删重建保活 cronjob  \r\n4.自动更新 serv00-play 代码  \r\n5.同步更新 telegram、微信等参数  \r\n6.默认情况下只有登录失败才有 TG 消息通知，提醒可能封号(平时正常不会给你发消息，发消息之时便是你封号之日)\r\n\r\n## 消息推送\r\n\r\n支持向 Telegram 和微信用户发送通知\r\n\r\n关于如何配置 Telegram 以实现消息推送，可以看 [这个视频](https://www.youtube.com/watch?v=l8fPnMfq86c&t=3s)\r\n\r\n关于微信的配置，目前使用第三方平台提供的功能，可以到 [这里](https://sct.ftqq.com/r/13223) 注册并登录 server 酱，取得 sendKey\r\n\r\n## HOSTS_JSON 的配置实例\r\n\r\n```js\r\n {\r\n   \"info\": [\r\n    {\r\n      \"host\": \"s2.serv00.com\",\r\n      \"username\": \"kkk\",\r\n      \"port\": 22,\r\n      \"password\": \"fdsafjijgn\"\r\n    },\r\n    {\r\n      \"host\": \"s2.serv00.com\",\r\n      \"username\": \"bbb\",\r\n      \"port\": 22,\r\n      \"password\": \"fafwwwwazcs\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## 安装说明视频\r\n\r\n安装使用说明可以看[这里](https://youtu.be/ZCr7YiQX8Qs)  \r\n临时隧道已失效，请使用固定隧道名，[如何申请固定隧道名](https://youtu.be/KyMvtWknu-k)  \r\nargo+vmess 的搭建教学看[这里](https://youtu.be/nmb2F6uBKsg?si=v8twWIkIjsN8UYb-)\r\n\r\n由于本项目一直在迭代开发，界面会有些变化，想详细了解，可以看这一系列视频[serv00-play 系列](https://www.youtube.com/playlist?list=PLaMnUIjE3d5zArqlLzTU2oMZ0h-5VP6C0)\r\n\r\n## 赞助\r\n\r\n<left><details><summary><strong> [点击展开] 请作者喝杯咖啡 ~🧧</strong></summary>\r\n_捐赠将是对我最大的支持，它将激励我持续的创新和创作。_\r\n\r\n![](https://look.pics.cloudns.ch/img/%E6%AC%A7%E6%98%93%E8%B5%9E%E5%8A%A9%E7%A0%81.png)\r\n\r\n- **USDT-TRC20:** `TUa2hLirmyq6tUPpfxHuMmWJExR91vHo5t`\r\n\r\n</details></left>\r\n\r\n## 项目鸣谢\r\n\r\n[nekohasekai](https://github.com/SagerNet/sing-box)、[AlistGo](https://github.com/AlistGo/alist)、[9seconds](https://github.com/9seconds/mtg)、[eooce](https://github.com/eooce)、[nrootconauto](https://github.com/nrootconauto/MrChrootBSD)、[nezhahq](https://github.com/nezhahq/agent)、[huashengdun](https://github.com/huashengdun/webssh)、[hslr-s](https://github.com/hslr-s/sun-panel)  \r\n[yangtb2024](https://github.com/yangtb2024/OneTimeMessagePHP)\r\n\r\n## 免责声明\r\n\r\n本程序仅供学习了解, 非盈利目的，请于下载后 24 小时内删除, 不得用作任何商业用途, 代码、数据及图片均有所属版权, 如转载须注明来源。\r\n使用本程序必循遵守部署免责声明。使用本程序必循遵守部署服务器所在地、所在国家和用户所在国家的法律法规, 程序作者不对使用者任何不当行为负责。\r\n"
        },
        {
          "name": "keepalive.sh",
          "type": "blob",
          "size": 8.2626953125,
          "content": "#!/bin/bash\n\ninstallpath=\"$HOME\"\nsource ${installpath}/serv00-play/utils.sh\n\nautoUp=$1\nsendtype=$2\nTELEGRAM_TOKEN=\"$3\"\nTELEGRAM_USERID=\"$4\"\nWXSENDKEY=\"$5\"\nBUTTON_URL=\"$6\"\nPASS=\"$7\"\n\n#echo \"TELEGRAM_TOKEN=$TELEGRAM_TOKEN, TELEGRAM_USERID=$TELEGRAM_USERID,WXSENDKEY=$WXSENDKEY,BUTTON_URL=$BUTTON_URL,pass=$PASS\"\n\ncheckHy2Alive() {\n  if ps aux | grep serv00sb | grep -v \"grep\" >/dev/null; then\n    return 0\n  else\n    return 1\n  fi\n\n}\n\nsendMsg() {\n  local msg=$1\n  if [ -n \"$msg\" ]; then\n    cd $installpath/serv00-play\n    msg=\"Host:$host, user:$user, $msg\"\n    if [ \"$sendtype\" == \"1\" ]; then\n      ./tgsend.sh \"$msg\"\n    elif [ \"$sendtype\" == \"2\" ]; then\n      ./wxsend.sh \"$msg\"\n    elif [ \"$sendtype\" == \"3\" ]; then\n      ./tgsend.sh \"$msg\"\n      ./wxsend.sh \"$msg\"\n    fi\n  fi\n}\n\ncheckResetCron() {\n  echo \"run checkResetCron\"\n  local msg=\"\"\n  cd ${installpath}/serv00-play/\n  crontab -l | grep keepalive\n  if ! crontab -l | grep keepalive; then\n    msg=\"crontab记录被删过,并且已重建。\"\n    tm=$(jq -r \".chktime\" config.json)\n    addCron \"$tm\"\n    sendMsg $msg\n  fi\n}\n\n#构建消息配置文件\nmakeMsgConfig() {\n  if [ -n \"$TELEGRAM_TOKEN\" ] || [ -n \"$WXSENDKEY\" ]; then\n    if [[ \"$TELEGRAM_TOKEN\" != \"null\" || \"$WXSENDKEY\" != \"null\" ]]; then\n      cat >msg.json <<EOF\n   {\n      \"telegram_token\": \"$TELEGRAM_TOKEN\",\n      \"telegram_userid\": \"$TELEGRAM_USERID\",\n      \"wxsendkey\": \"$WXSENDKEY\",\n      \"sendtype\": \"$sendtype\",\n      \"button_url\": \"$BUTTON_URL\",\n      \"password\": \"$PASS\"\n   }\nEOF\n    fi\n  else\n    echo \"TELEGRAM_TOKEN 和 WXSENDKEY 变量均未设置\"\n  fi\n}\n\nautoUpdate() {\n  echo \"正在自动更新代码...\"\n  if [ -d ${installpath}/serv00-play ]; then\n    cd ${installpath}/serv00-play/\n    git stash\n    timeout 15s git pull\n    echo \"更新完毕\"\n\n    #重新给各个脚本赋权限\n    chmod +x ./start.sh\n    chmod +x ./keepalive.sh\n    chmod +x ./tgsend.sh\n    chmod +x ./wxsend.sh\n    chmod +x ${installpath}/serv00-play/singbox/start.sh\n    chmod +x ${installpath}/serv00-play/singbox/killsing-box.sh\n    chmod +x ${installpath}/serv00-play/ssl/cronSSL.sh\n  fi\n\n}\n\nstartNeZhaAgent() {\n  local workedir=\"${installpath}/serv00-play/nezha\"\n  cd ${workedir}\n  local config=\"nezha.json\"\n  if [[ ! -e \"$config\" ]]; then\n    red \"未安装哪吒探针，请先进行安装！\"\n    return 1\n  fi\n  nezha_domain=$(jq -r \".nezha_domain\" $config)\n  nezha_port=$(jq -r \".nezha_port\" $config)\n  nezha_pwd=$(jq -r \".nezha_pwd\" $config)\n  tls=$(jq -r \".tls\" $config)\n\n  if checknezhaAgentAlive; then\n    stopNeZhaAgent\n  fi\n\n  local args=\"--report-delay 4 --disable-auto-update --disable-force-update \"\n  if [[ \"$tls\" == \"y\" ]]; then\n    args=\"${args} --tls \"\n  fi\n\n  nohup ./nezha-agent ${args} -s \"${nezha_domain}:${nezha_port}\" -p \"${nezha_pwd}\" >/dev/null 2>&1 &\n\n}\n\nstartMtg() {\n  cd ${installpath}/serv00-play/dmtg\n\n  config=\"config.json\"\n\n  secret=$(jq -r \".secret\" $config)\n  port=$(jq -r \".port\" $config)\n  cmd=\"nohup ./mtg simple-run -n 1.1.1.1 -t 30s -a 1MB 0.0.0.0:$port $secret -c 8192 --prefer-ip=\\\"prefer-ipv6\\\" >/dev/null 2>&1 &\"\n  eval \"$cmd\"\n  sleep 3\n  if checkMtgAlive; then\n    echo \"启动成功\"\n  else\n    echo \"启动失败，请检查进程\"\n  fi\n\n}\n\nstartAlist() {\n  alistpath=\"${installpath}/serv00-play/alist\"\n\n  if [[ -d \"$alistpath/data\" && -e \"$alistpath/alist\" ]]; then\n    echo \"正在启动alist...\"\n    cd $alistpath\n    domain=$(jq -r \".domain\" config.json)\n\n    if checkProcAlive \"alist\"; then\n      echo \"alist已启动，请勿重复启动!\"\n    else\n      nohup ./alist server >/dev/null 2>&1 &\n      sleep 3\n      if ! checkProcAlive \"alist\"; then\n        red \"启动失败，请检查!\"\n        return 1\n      else\n        echo \"启动成功!\"\n      fi\n    fi\n  else\n    red \"请先行安装再启动!\"\n    return\n  fi\n\n}\n\nstartSunPanel() {\n  cd ${installpath}/serv00-play/sunpanel\n  cmd=\"nohup ./sun-panel >/dev/null 2>&1 &\"\n  eval \"$cmd\"\n}\n\nstartWebSSH() {\n  cd ${installpath}/serv00-play/webssh\n  ssh_port=$(jq -r \".port\" config.json)\n  cmd=\"nohup ./wssh --port=$ssh_port  --fbidhttp=False --xheaders=False --encoding='utf-8' --delay=10  >/dev/null 2>&1 &\"\n  eval \"$cmd\"\n}\n\n#main\nhost=$(hostname)\nuser=$(whoami)\n\necho \"正在调用keepalive.sh\"\nif [[ \"$autoUp\" == \"autoupdate\" ]]; then\n  echo \"run autoUpdate\"\n  autoUpdate\nfi\n\necho \"Host:$host, user:$user\"\ncd ${installpath}/serv00-play/\n\nif [[ -n \"$autoUp\" ]]; then\n  makeMsgConfig\nfi\nif [ ! -f config.json ]; then\n  echo \"未配置保活项目，请先行配置!\"\n  exit 0\nfi\n\nmonitor=($(jq -r \".item[]\" config.json))\n\ntg_token=$(jq -r \".telegram_token // empty\" config.json)\n\nif [[ -z \"$tg_token\" ]]; then\n  echo \"从msg.json获取 telegram_token\"\n  TELEGRAM_TOKEN=$(jq -r '.telegram_token // empty' msg.json)\nelse\n  TELEGRAM_TOKEN=$tg_token\nfi\n\ntg_userid=$(jq -r \".telegram_userid // empty\" config.json)\n\nif [[ -z \"$tg_userid\" ]]; then\n  echo \"从msg.json获取telegram_userid\"\n  if [[ -e \"msg.json\" ]]; then\n    TELEGRAM_USERID=$(jq -r \".telegram_userid // empty\" msg.json)\n  fi\nelse\n  TELEGRAM_USERID=$tg_userid\nfi\n\nwx_sendkey=$(jq -r \".wxsendkey // empty\" config.json)\n\nif [[ -z \"$wx_sendkey\" ]]; then\n  echo \"从msg.json获取wxsendkey\"\n  if [[ -e \"msg.json\" ]]; then\n    WXSENDKEY=$(jq -r \".wxsendkey // empty\" msg.json)\n  fi\nelse\n  WXSENDKEY=$wx_sendkey\nfi\n\nsend_type=$(jq -r \".sendtype // empty\" config.json)\nif [ -z \"$send_type\" ]; then\n  echo \"从msg.json获取 sendtype\"\n  if [[ -e \"msg.json\" ]]; then\n    sendtype=$(jq -r \".sendtype // empty\" msg.json)\n  fi\nelse\n  sendtype=$send_type\nfi\n\nif [ -z \"$BUTTON_URL\" ]; then\n  echo \"从msg.json获取 button_url\"\n  BUTTON_URL=$(jq -r \".button_url // empty\" msg.json)\nfi\n\nif [ -z \"$PASS\" ]; then\n  echo \"从msg.json获取 password\"\n  PASS=$(jq -r \".password // empty\" msg.json)\nfi\n\nexport TELEGRAM_TOKEN TELEGRAM_USERID WXSENDKEY sendtype BUTTON_URL PASS\n\n#echo \"最终TELEGRAM_TOKEN=$TELEGRAM_TOKEN,TELEGRAM_USERID=$TELEGRAM_USERID\"\n\nfor obj in \"${monitor[@]}\"; do\n  msg=\"\"\n  #   echo \"obj= $obj\"\n  if [ \"$obj\" == \"sun-panel\" ]; then\n    if ! checkProcAlive \"sun-panel\"; then\n      startSunPanel\n      sleep 3\n      if ! checkProcAlive \"sun-panel\"; then\n        msg=\"sun-panel restarted failure.\"\n      else\n        msg=\"sun-panel restarted successfully.\"\n      fi\n    fi\n  elif [ \"$obj\" == \"webssh\" ]; then\n    if ! checkProcAlive \"wssh\"; then\n      startWebSSH\n      sleep 5\n      if ! checkProcAlive \"wssh\"; then\n        msg=\"webssh restarted failure.\"\n      else\n        msg=\"webssh restarted successfully.\"\n      fi\n    fi\n  elif [ \"$obj\" == \"vmess\" ]; then\n    if ! checkvmessAlive; then\n      cd ${installpath}/serv00-play/singbox\n      chmod +x ./start.sh && ./start.sh 1 keep\n      sleep 5\n      if ! checkvmessAlive; then\n        msg=\"vmess restarted failure.\"\n      else\n        msg=\"vmess restarted successfully.\"\n      fi\n    fi\n    #hy2和vmess+ws都只需要启动serv00sb，所以可以这么写\n  elif [[ \"$obj\" == \"hy2/vmess+ws\" || \"$obj\" == \"hy2\" ]]; then\n    if ! checkHy2Alive; then\n      #echo \"重启serv00sb中...\"\n      cd ${installpath}/serv00-play/singbox\n      chmod +x ./start.sh && ./start.sh 2 keep\n      sleep 5\n      if ! checkHy2Alive; then\n        msg=\"hy2 restarted failure.\"\n      else\n        msg=\"hy2 restarted successfully.\"\n      fi\n    fi\n  elif [ \"$obj\" == \"nezha-agent\" ]; then\n    if ! checknezhaAgentAlive; then\n      cd ${installpath}/serv00-play/nezha\n      startNeZhaAgent\n      sleep 5\n      if ! checknezhaAgentAlive; then\n        msg=\"nezha-agent restarted failure.\"\n      else\n        msg=\"nezha-agent restarted successfully.\"\n      fi\n    fi\n  elif [ \"$obj\" == \"mtg\" ]; then\n    if ! checkMtgAlive; then\n      cd ${installpath}/serv00-play/dmtg\n      startMtg\n      sleep 5\n      if ! checkMtgAlive; then\n        msg=\"mtproto restarted failure.\"\n      else\n        msg=\"mtproto restarted successfully.\"\n      fi\n    fi\n  elif [ \"$obj\" == \"alist\" ]; then\n    if ! checkProcAlive \"alist\"; then\n      startAlist\n      sleep 5\n      if ! checkProcAlive \"alist\"; then\n        msg=\"alist restarted failure.\"\n      else\n        msg=\"alist restarted successfully.\"\n      fi\n    fi\n  elif [ \"$obj\" == \"wssh\" ]; then\n    if ! checkProcAlive wssh; then\n      startAlist\n      sleep 5\n      if ! checkAlistAlive; then\n        msg=\"alist restarted failure.\"\n      else\n        msg=\"alist restarted successfully.\"\n      fi\n    fi\n  else\n    continue\n  fi\n\n  sendMsg \"$msg\"\n\ndone\n\nif [ ${#monitor[@]} -gt 0 ]; then\n  checkResetCron\nfi\n"
        },
        {
          "name": "mkprofile.pl",
          "type": "blob",
          "size": 0.541015625,
          "content": "#!/bin/perl\n\n$addflag=0;\n$flag=0;\n$content=qq{\n#added by serv00-play begin\nexport TZ=Asia/Shanghai\nexport EDITOR=vim\nexport VISUAL=vim\nexport LANG=en_US.UTF-8\nexport LC_ALL=en_US.UTF-8\nalias l='ls -ltr'\nalias pp='ps aux'\nalias ss='cd ~/serv00-play && ./start.sh'\n#added by serv00-play end\n};\n\nwhile(<>){\n  if( /^#added by serv00-play begin/){\n    $addflag=1;\n    $flag=1;\n    print $content, \"\\n\";\n  }else{\n    if (/^#added by serv00-play end/){\n      $flag=0;\n    }else{\n      print if $flag==0;\n    }\n  }\n}\n\nif( $addflag==0 ){\n  print $content, \"\\n\";\n}"
        },
        {
          "name": "revive.sh",
          "type": "blob",
          "size": 1.5634765625,
          "content": "#!/bin/bash\n\nAUTOUPDATE=${AUTOUPDATE:-Y}\nSENDTYPE=${SENDTYPE:-null}\nTELEGRAM_TOKEN=${TELEGRAM_TOKEN:-null}\nTELEGRAM_USERID=${TELEGRAM_USERID:-null}\nWXSENDKEY=${WXSENDKEY:-null}\nBUTTON_URL=${BUTTON_URL:-null}\nLOGININFO=${LOGININFO:-N}\nexport TELEGRAM_TOKEN TELEGRAM_USERID BUTTON_URL\n\n# 使用 jq 提取 JSON 数组，并将其加载为 Bash 数组\nhosts_info=($(echo \"${HOSTS_JSON}\" | jq -c \".info[]\"))\nsummary=\"\"\nfor info in \"${hosts_info[@]}\"; do\n  user=$(echo $info | jq -r \".username\")\n  host=$(echo $info | jq -r \".host\")\n  port=$(echo $info | jq -r \".port\")\n  pass=$(echo $info | jq -r \".password\")\n\n  if [[ \"$AUTOUPDATE\" == \"Y\" ]]; then\n    script=\"/home/$user/serv00-play/keepalive.sh autoupdate ${SENDTYPE} \\\"${TELEGRAM_TOKEN}\\\" \\\"${TELEGRAM_USERID}\\\" \\\"${WXSENDKEY}\\\" \\\"${BUTTON_URL}\\\" \\\"${pass}\\\"\"\n  else\n    script=\"/home/$user/serv00-play/keepalive.sh noupdate ${SENDTYPE} \\\"${TELEGRAM_TOKEN}\\\" \\\"${TELEGRAM_USERID}\\\" \\\"${WXSENDKEY}\\\" \\\"${BUTTON_URL}\\\" \\\"${pass}\\\"\"\n  fi\n  output=$(sshpass -p \"$pass\" ssh -o StrictHostKeyChecking=no -p \"$port\" \"$user@$host\" \"bash -s\" <<<\"$script\")\n\n  echo \"output:$output\"\n\n  if echo \"$output\" | grep -q \"keepalive.sh\"; then\n    echo \"登录成功\"\n    msg=\"🟢主机 ${host}, 用户 ${user}， 登录成功!\\n\"\n  else\n    echo \"登录失败\"\n    msg=\"🔴主机 ${host}, 用户 ${user}， 登录失败!\\n\"\n    chmod +x ./tgsend.sh\n    export PASS=$pass\n    ./tgsend.sh \"Host:$host, user:$user, 登录失败，请检查!\"\n  fi\n  summary=$summary$(echo -n $msg)\ndone\n\nif [[ \"$LOGININFO\" == \"Y\" ]]; then\n  chmod +x ./tgsend.sh\n  ./tgsend.sh \"$summary\"\nfi\n"
        },
        {
          "name": "singbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "ssl",
          "type": "tree",
          "content": null
        },
        {
          "name": "start.sh",
          "type": "blob",
          "size": 66.087890625,
          "content": "#!/bin/bash\n\nRED='\\033[0;91m'\nGREEN='\\033[0;92m'\nYELLOW='\\033[0;33m'\nBLUE='\\033[0;34m'\nMAGENTA='\\033[0;35m'\nCYAN='\\033[0;96m'\nWHITE='\\033[0;37m'\nRESET='\\033[0m'\nyellow() {\n  echo -e \"${YELLOW}$1${RESET}\"\n}\ngreen() {\n  echo -e \"${GREEN}$1${RESET}\"\n}\nred() {\n  echo -e \"${RED}$1${RESET}\"\n}\ninstallpath=\"$HOME\"\nUSER=\"$(whoami)\"\nif [[ -e \"$installpath/serv00-play\" ]]; then\n  source ${installpath}/serv00-play/utils.sh\nfi\n\nPS3=\"请选择(输入0退出): \"\ninstall() {\n  cd ${installpath}\n  if [ -d serv00-play ]; then\n    cd \"serv00-play\"\n    git stash\n    if git pull; then\n      echo \"更新完毕\"\n      #重新给各个脚本赋权限\n      chmod +x ./start.sh\n      chmod +x ./keepalive.sh\n      chmod +x ./tgsend.sh\n      chmod +x ./wxsend.sh\n      chmod +x ${installpath}/serv00-play/singbox/start.sh\n      chmod +x ${installpath}/serv00-play/singbox/killsing-box.sh\n      chmod +x ${installpath}/serv00-play/ssl/cronSSL.sh\n      red \"请重新启动脚本!\"\n      exit 0\n    fi\n  fi\n\n  cd ${installpath}\n  echo \"正在安装...\"\n  if ! git clone https://github.com/frankiejun/serv00-play.git; then\n    echo -e \"${RED}安装失败!${RESET}\"\n    exit 1\n  fi\n  devil binexec on\n  touch .profile\n  cat .profile | perl ./serv00-play/mkprofile.pl >tmp_profile\n  mv -f tmp_profile .profile\n  if [[ ! -e \"${installpath}/serv00-play\" ]]; then\n    red \"安装不成功！\"\n    return\n  fi\n\n  cd ${installpath}/serv00-play\n  chmod +x ./start.sh\n  chmod +x ./keepalive.sh\n  chmod +x ./tgsend.sh\n  chmod +x ./wxsend.sh\n  chmod +x ${installpath}/serv00-play/singbox/start.sh\n  chmod +x ${installpath}/serv00-play/singbox/killsing-box.sh\n  chmod +x ${installpath}/serv00-play/ssl/cronSSL.sh\n  read -p \"$(yellow 设置完毕,需要重新登录才能生效，是否重新登录？[y/n] [y]:)\" input\n  input=${input:-y}\n\n  if [ \"$input\" = \"y\" ]; then\n    kill -9 $PPID\n  fi\n  echo -e \"${YELLOW}安装成功${RESET}\"\n}\n\nshowSingBoxInfo() {\n  cd ${installpath}/serv00-play/singbox\n\n  if [ ! -f singbox.json ]; then\n    red \"配置文件不存在，请先行配置!\"\n    return\n  fi\n  if [ ! -e list ]; then\n    red \"请先运行sing-box\"\n  fi\n  config=\"singbox.json\"\n  type=$(jq -r \".TYPE\" $config)\n  chmod +x ./start.sh && ./start.sh $type list\n\n}\n\nchooseSingbox() {\n  echo \"保活sing-box中哪个项目: \"\n  echo \" 1.hy2/vmess+ws/socks5 \"\n  echo \" 2.argo+vmess \"\n  echo \" 3.all \"\n  read -p \"请选择:\" input\n\n  if [ \"$input\" = \"1\" ]; then\n    item+=(\"hy2/vmess+ws\")\n  elif [ \"$input\" = \"2\" ]; then\n    item+=(\"vmess\")\n  elif [ \"$input\" = \"3\" ]; then\n    item+=(\"hy2/vmess+ws\")\n    item+=(\"vmess\")\n  else\n    red \"无效选择!\"\n    return 1\n  fi\n\n}\n\nsetConfig() {\n  cd ${installpath}/serv00-play/\n\n  if [ -f config.json ]; then\n    echo \"目前已有配置:\"\n    config_content=$(cat config.json)\n    echo $config_content\n    read -p \"是否修改? [y/n] [y]:\" input\n    input=${input:-y}\n    if [ \"$input\" != \"y\" ]; then\n      return\n    fi\n  fi\n  createConfigFile\n}\n\ncreateConfigFile() {\n  echo \"选择你要保活的项目（可多选，用空格分隔）:\"\n  echo \"1. sun-panel \"\n  echo \"2. sing-box(包含hy2，vmess，socks5) \"\n  echo \"3. 哪吒探针 \"\n  echo \"4. mtproto代理\"\n  echo \"5. alist\"\n  echo \"6. webssh\"\n  echo \"88. 暂停所有保活功能\"\n  echo \"99. 复通所有保活功能(之前有配置的情况下)\"\n  echo \"0. 返回主菜单\"\n  item=()\n\n  read -p \"请选择: \" choices\n  choices=($choices)\n\n  if [[ \"${choices[@]}\" =~ \"88\" && ${#choices[@]} -gt 1 ]]; then\n    red \"选择出现了矛盾项，请重新选择!\"\n    return 1\n  fi\n\n  #过滤重复\n  choices=($(echo \"${choices[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n\n  # 根据选择来询问对应的配置\n  for choice in \"${choices[@]}\"; do\n    case \"$choice\" in\n    0)\n      showMenu\n      break\n      ;;\n    1)\n      item+=(\"sun-panel\")\n      ;;\n    2)\n      if ! chooseSingbox; then\n        return\n      fi\n      ;;\n    3)\n      item+=(\"nezha-agent\")\n      ;;\n    4)\n      item+=(\"mtg\")\n      ;;\n    5)\n      item+=(\"alist\")\n      ;;\n    6)\n      item+=(\"webssh\")\n      ;;\n    88)\n      delCron\n      backupConfig \"config.json\"\n      green \"设置完毕!\"\n      return 0\n      ;;\n    99)\n      if [[ ! -e config.bak ]]; then\n        red \"之前未有配置，未能复通!\"\n        return 1\n      fi\n      restoreConfig \"config.bak\"\n      tm=$(jq -r \".chktime\" config.json)\n      addCron $tm\n      green \"设置完毕!\"\n      return 0\n      ;;\n    *)\n      echo \"无效选择\"\n      return 1\n      ;;\n    esac\n  done\n\n  json_content=\"{\\n\"\n  json_content+=\"   \\\"item\\\": [\\n\"\n\n  for item in \"${item[@]}\"; do\n    json_content+=\"      \\\"$item\\\",\"\n  done\n\n  # 删除最后一个逗号并换行\n  json_content=\"${json_content%,}\\n\"\n  json_content+=\"   ],\\n\"\n\n  if [ \"$num\" = \"4\" ]; then\n    json_content+=\"   \\\"chktime\\\": \\\"null\\\"\"\n    json_content+=\"}\\n\"\n    printf \"$json_content\" >./config.json\n    echo -e \"${YELLOW} 设置完成! ${RESET} \"\n    delCron\n    return\n  fi\n\n  read -p \"配置保活检查的时间间隔(单位分钟，默认5分钟):\" tm\n  tm=${tm:-\"5\"}\n\n  json_content+=\"   \\\"chktime\\\": \\\"$tm\\\",\"\n\n  read -p \"是否需要配置消息推送? [y/n] [n]:\" input\n  input=${input:-n}\n\n  if [ \"${input}\" == \"y\" ]; then\n    json_content+=\"\\n\"\n\n    echo \"选择要推送的app:\"\n    echo \"1) Telegram \"\n    echo \"2) 微信 \"\n    echo \"3) 以上皆是\"\n\n    read -p \"请选择:\" sendtype\n\n    if [ \"$sendtype\" == \"1\" ]; then\n      writeTG\n    elif [ \"$sendtype\" == \"2\" ]; then\n      writeWX\n    elif [ \"$sendtype\" == \"3\" ]; then\n      writeTG\n      writeWX\n    else\n      echo \"无效选择\"\n      return\n    fi\n  else\n    sendtype=${sendtype:-\"null\"}\n  fi\n  json_content+=\"\\n \\\"sendtype\\\": $sendtype \\n\"\n  json_content+=\"}\\n\"\n\n  # 使用 printf 生成文件\n  printf \"$json_content\" >./config.json\n  addCron $tm\n  chmod +x ${installpath}/serv00-play/keepalive.sh\n  echo -e \"${YELLOW} 设置完成! ${RESET} \"\n\n}\n\nbackupConfig() {\n  local filename=$1\n  if [[ -e \"$filename\" ]]; then\n    if [[ \"$filename\" =~ \".json\" ]]; then\n      local basename=${filename%.json}\n      mv $filename $basename.bak\n    fi\n  fi\n}\n\nrestoreConfig() {\n  local filename=$1\n  if [[ -e \"$filename\" ]]; then\n    if [[ \"$filename\" =~ \".bak\" ]]; then\n      local basename=${filename%.bak}\n      mv $filename $basename.json\n    fi\n  fi\n}\n\nmake_vmess_config() {\n  cat >tempvmess.json <<EOF\n  {\n      \"tag\": \"vmess-ws-in\",\n      \"type\": \"vmess\",\n      \"listen\": \"::\",\n      \"listen_port\": $vmport,\n      \"users\": [\n      {\n        \"uuid\": \"$uuid\"\n      }\n    ],\n    \"transport\": {\n      \"type\": \"ws\",\n      \"path\": \"/$wspath\",\n      \"early_data_header_name\": \"Sec-WebSocket-Protocol\"\n      }\n    }\nEOF\n}\nmake_outbound_wireguard() {\n  cat <<EOF\n     {\n        \"type\": \"wireguard\",\n        \"tag\": \"wireguard-out\",\n        \"server\": \"162.159.195.100\",\n        \"server_port\": 4500,\n        \"local_address\": [\n                \"172.16.0.2/32\",\n                \"2606:4700:110:83c7:b31f:5858:b3a8:c6b1/128\"\n        ],\n        \"private_key\": \"mPZo+V9qlrMGCZ7+E6z2NI6NOV34PD++TpAR09PtCWI=\",\n        \"peer_public_key\": \"bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo=\",\n        \"reserved\": [\n                26,\n                21,\n                228\n        ]\n    },\nEOF\n}\n\nmake_outbound_socks5() {\n  local server=$1\n  local serv_port=$2\n  local user=$3\n  local pass=$4\n\n  cat >temp_outbound_socks5.json <<EOF\n  {\n     \"type\": \"socks\",\n     \"tag\": \"socks5_outbound\",\n     \"server\": \"$server\",\n     \"server_port\": $serv_port,   \n     \"version\": \"5\",              \n     \"username\": \"$user\",           \n     \"password\": \"$pass\"                  \n  },\nEOF\n}\n\nmake_hy2_config() {\n  cat >temphy2.json <<EOF\n   {\n       \"tag\": \"hysteria-in\",\n       \"type\": \"hysteria2\",\n       \"listen\": \"$hy2_ip\",\n       \"listen_port\": $hy2_port,\n       \"users\": [\n         {\n             \"password\": \"$uuid\"\n         }\n     ],\n     \"masquerade\": \"https://www.bing.com\",\n     \"tls\": {\n         \"enabled\": true,\n         \"alpn\": [\n             \"h3\"\n         ],\n         \"certificate_path\": \"cert.pem\",\n         \"key_path\": \"private.key\"\n        }\n    }\nEOF\n}\n\nmake_socks5_config() {\n  cat >tmpsocks5.json <<EOF\n  {\n      \"type\": \"socks\",\n      \"tag\": \"socks-in\",\n\n       \"listen\": \"::\",\n       \"listen_port\": $socks5_port,\n\n        \"users\": [\n        {\n          \"username\": \"$username\",\n          \"password\": \"$password\"\n        }\n        ]\n    }\nEOF\n}\n\ngenerate_config() {\n  local outbound=$1\n  comma=\"\"\n  comma0=\"\"\n  if [[ ! -e \"private.key\" || ! -e \"cert.pem\" ]]; then\n    openssl ecparam -genkey -name prime256v1 -out \"private.key\"\n    openssl req -new -x509 -days 3650 -key \"private.key\" -out \"cert.pem\" -subj \"/CN=www.bing.com\"\n  fi\n  if [[ \"$type\" == \"1.1\" || \"$type\" == \"1.2\" ]]; then\n    make_vmess_config\n  elif [ \"$type\" = \"2\" ]; then\n    make_hy2_config\n  elif [ \"$type\" = \"1.3\" ]; then\n    make_socks5_config\n  elif [[ \"$type\" =~ ^(2.4|2.5)$ ]]; then\n    make_vmess_config\n    comma0=\",\"\n    make_socks5_config\n  elif [[ \"$type\" =~ ^(3.1|3.2)$ ]]; then\n    make_vmess_config\n    comma=\",\"\n    make_hy2_config\n  elif [[ \"$type\" == \"3.3\" ]]; then\n    make_hy2_config\n    make_socks5_config\n    comma0=\",\"\n  else\n    make_socks5_config\n    make_vmess_config\n    make_hy2_config\n    comma=\",\"\n    comma0=\",\"\n  fi\n\n  if [[ \"$outbound\" == \"1\" ]]; then\n    outboundType=\"wireguard-out\"\n  elif [[ \"$outbound\" == \"2\" ]]; then\n    outboundType=\"socks5_outbound\"\n  else\n    outboundType=\"direct\"\n  fi\n\n  cat >config.json <<EOF\n {\n  \"log\": {\n    \"disabled\": true,\n    \"level\": \"info\",\n    \"timestamp\": true\n  },\n  \"dns\": {\n    \"servers\": [\n      {\n        \"tag\": \"google\",\n        \"address\": \"tls://8.8.8.8\",\n        \"strategy\": \"ipv4_only\",\n        \"detour\": \"direct\"\n      }\n    ],\n    \"rules\": [\n      {\n        \"rule_set\": [\n          \"geosite-category-ads-all\"\n        ],\n        \"server\": \"block\"\n      }\n    ],\n    \"final\": \"google\",\n    \"strategy\": \"\",\n    \"disable_cache\": false,\n    \"disable_expire\": false\n  },\n    \"inbounds\": [\n    $([[ \"$type\" =~ ^(1.3|3.3|2.4|2.5|3.3|4.4|4.5)$ ]] && cat tmpsocks5.json)\n    $comma0\n    $([[ \"$type\" == \"1.1\" || \"$type\" == \"1.2\" || \"$type\" =~ ^(2.4|2.5|3.1|3.2|4.4|4.5)$ ]] && cat tempvmess.json)\n    $comma\n    $([[ \"$type\" == \"2\" || \"$type\" =~ ^(3|4)\\.[0-9]+$ ]] && cat temphy2.json)\n   ],\n    \"outbounds\": [\n    $([[ \"$outbound\" == \"1\" ]] && make_outbound_wireguard) \n    $([[ \"$outbound\" == \"2\" ]] && cat temp_outbound_socks5.json && rm -rf temp_outbound_socks5.json)\n    {\n      \"type\": \"direct\",\n      \"tag\": \"direct\"\n    },\n    {\n      \"type\": \"block\",\n      \"tag\": \"block\"\n    },\n    {\n      \"type\": \"dns\",\n      \"tag\": \"dns-out\"\n    }\n  ],\n  \"route\": {\n    \"rules\": [\n    {\n     \"domain\": [\n             \"usher.ttvnw.net\",\n             \"jnn-pa.googleapis.com\"\n            ],\n     \"outbound\": \"$outboundType\"\n    },\n      {\n        \"protocol\": \"dns\",\n        \"outbound\": \"dns-out\"\n      },\n      { \n        \"ip_is_private\": true,\n        \"outbound\": \"direct\"\n      },\n      {\n        \"rule_set\": [\n          \"geosite-category-ads-all\"\n        ],\n        \"outbound\": \"block\"\n      }\n    ],\n    \"rule_set\": [\n      {\n        \"tag\": \"geosite-category-ads-all\",\n        \"type\": \"remote\",\n        \"format\": \"binary\",\n        \"url\": \"https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-category-ads-all.srs\",\n        \"download_detour\": \"direct\"\n      }\n    ],\n    \"final\": \"direct\"\n   }\n}\nEOF\n  rm -rf tempvmess.json temphy2.json tmpsocks5.json\n}\n\ngenerate_random_string() {\n  local num=$1\n  LC_CTYPE=C xxd </dev/urandom -p | tr -dc 'a-z' | head -c \"$num\"\n  echo\n}\n\nlocalArgo() {\n  local configPath=\"${installpath}/.cloudflared\"\n  if [[ -e \"$configPath/cert.pem\" ]]; then\n    read -p \"已有配置，是否删除重建? [y/n] [n]:\" input\n    input=${input:-n}\n    if [[ \"$input\" == \"y\" ]]; then\n      #ls -l \"$configPath\"\n      rm -rf \"$configPath\"/*\n    fi\n  fi\n  sleep 1\n  if ! checkDownload \"cloudflared\"; then\n    return\n  fi\n  echo \"请把以下链接copy到浏览器打开，并选择你要作为隧道用的域名(如需中断，请按ctrl+c):\"\n  rt=$(./cloudflared login)\n  echo \"$rt\"\n  read -p \"告诉我你选了哪个域名:\" domain\n  if [[ -z \"$domain\" ]]; then\n    red \"未有输入!\"\n    return 1\n  fi\n  read -p \"是否自动配置隧道信息？[y/n] [y]:\" autoflag\n  autoflag=${autoflag:-y}\n\n  tunname=\"\"\n  if [[ \"$autoflag\" == \"y\" ]]; then\n    tunname=$(printf \"tun-%s\" $(generate_random_string 3))\n  else\n    read -p \"请输入隧道名称:\" tunname\n    if [[ -z \"$tunname\" ]]; then\n      red \"未有输入!\"\n      return 1\n    fi\n  fi\n  green \"你所创建的隧道为 $tunname\"\n  if [[ \"$autoflag\" == \"y\" ]]; then\n    subname=$(generate_random_string 3)\n    domain=\"$subname\"\".\"\"$domain\"\n  else\n    read -p \"请输入隧道的cname域名:\" domain\n    if [[ -z \"$domain\" ]]; then\n      red \"未有输入!\"\n      return 1\n    fi\n  fi\n  green \"你的cname域名为: $domain\"\n  port=\"\"\n  randomPort tcp vmess\n  if [[ -n \"$port\" ]]; then\n    vmport=\"$port\"\n  fi\n\n  echo \"正在创建本地tunnel...\"\n  local output=$(./cloudflared tunnel create $tunname)\n  if echo \"$output\" | grep -q \"Created\"; then\n    green \"名为 $tunname 的tunnel创建成功!.\"\n    # 提取 .json 文件名\n    tunnelid=$(echo \"$output\" | sed -n 's/.*\\/\\([a-zA-Z0-9\\-]*\\)\\.json.*/\\1/p')\n    json_file=$tunnelid\".json\"\n    echo \"JSON file: $json_file\"\n  else\n    red \"创建隧道名失败! [ $output ].\"\n  fi\n\n  echo \"正在添加隧道的cname域名...\"\n  ./cloudflared tunnel route dns $tunname $domain\n  if [ $? -eq 0 ]; then\n    echo \"隧道绑定成功！\"\n  else\n    echo \"隧道绑定失败！\"\n  fi\n\n  makeTunnelConfig $tunname $tunnelid $domain $port\n}\n\nmakeTunnelConfig() {\n  local tunnelName=$1\n  local tunnelID=$2\n  local Domain=$3\n  local port=$4\n  cat >~/.cloudflared/config.yml <<EOF\ntunnel: $tunnelName\ncredentials-file: ${installpath}/.cloudflared/$tunnelID.json\n\ningress:\n  - hostname: ${Domain}\n    service: http://127.0.0.1:${port}\n  - service: http_status:404\nEOF\n}\n\nconfigSingBox() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  cd ${installpath}/serv00-play/singbox\n\n  loadPort\n  if [ -e singbox.json ]; then\n    red \"目前已有配置如下:\"\n    cat singbox.json\n    read -p \"$(echo -e \"${RED}继续配置将会覆盖原有配置:[y/n] [n]${RESET}\") \" input\n    input=${input:-n}\n    if [ \"$input\" != \"y\" ]; then\n      return 1\n    fi\n  fi\n  echo \"选择你要配置的项目（可多选，用空格分隔）:\"\n  echo \"1. vmess\"\n  echo \"2. hy2\"\n  echo \"3. socks5\"\n  echo \"4. all\"\n\n  read -p \"请选择: \" choices\n  choices=($choices)\n\n  if [[ \"${choices[@]}\" =~ \"4\" ]]; then\n    choices=(\"4\")\n  fi\n\n  #过滤重复\n  choices=($(echo \"${choices[@]}\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '))\n  type=\"0\"\n  # 根据选择来询问对应的配置\n  for choice in \"${choices[@]}\"; do\n    case \"$choice\" in\n    1)\n      echo \"请选择协议(2选1):\"\n      echo \"1. argo+vmess\"\n      echo \"2. vmess+ws \"\n      read -p \"请选择:\" co\n\n      if [[ \"$co\" != \"1\" && \"$co\" != \"2\" ]]; then\n        echo \"无效输入!\"\n        return 1\n      fi\n\n      if [[ \"$co\" == \"1\" ]]; then\n        echo \"1.本地创建隧道的方式\"\n        echo \"2.到CF建固定隧道方式\"\n        read -p \"请选择:\" co\n\n        if [[ \"$co\" != \"1\" && \"$co\" != \"2\" ]]; then\n          echo \"无效输入!\"\n          return 1\n        fi\n\n        type=$(echo \"$type + 1.1\" | bc)\n        if [[ \"$co\" == \"1\" ]]; then\n          tunname=\"\"\n          domain=\"\"\n          localArgo\n        else\n          randomPort tcp vmess\n          if [[ -n \"$port\" ]]; then\n            vmport=\"$port\"\n          fi\n          read -p \"请输入WSPATH,默认是[serv00]: \" wspath\n          read -p \"请输入ARGO隧道token: \" token\n          read -p \"请输入ARGO隧道的域名: \" domain\n        fi\n        read -p \"是否使用自己的优选域名? [y/n] [n]:\" input\n        input=${input:-n}\n        if [[ \"$input\" == \"y\" ]]; then\n          read -p \"请输入优选域名:\" goodDomain\n          if [[ -z \"$goodDomain\" ]]; then\n            red \"未有输入!\"\n            return 1\n          fi\n        fi\n      else\n        type=$(echo \"$type + 1.2\" | bc)\n        randomPort tcp vmess\n        if [[ -n \"$port\" ]]; then\n          vmport=\"$port\"\n        else\n          red \"未输入端口号\"\n          return 1\n        fi\n        read -p \"请输入WSPATH,默认是[serv00]: \" wspath\n        read -p \"请输入优选域名:\" goodDomain\n      fi\n      ;;\n    2)\n      type=$(echo \"$type + 2\" | bc)\n      randomPort udp hy2\n      if [[ -n \"$port\" ]]; then\n        hy2_port=\"$port\"\n      else\n        red \"未输入端口号\"\n        return 1\n      fi\n      echo \"自动选择未封ip...\"\n      hy2_ip=$(get_ip)\n      if [[ -n \"$hy2_ip\" ]]; then\n        green \"选中未封ip为 $hy2_ip\"\n      else\n        red \"未能找到未封IP,保持默认值！\"\n      fi\n      ;;\n    3)\n      type=$(echo \"$type + 1.3\" | bc)\n      randomPort tcp socks5\n      if [[ -n \"$port\" ]]; then\n        socks5_port=\"$port\"\n      else\n        red \"未输入端口号\"\n        return 1\n      fi\n      read -p \"请输入socks5用户名:\" username\n      read -p \"请输入socks5密码:\" password\n      ;;\n    4)\n      echo \"请选择协议(2选1):\"\n      echo \"1. argo+vmess\"\n      echo \"2. vmess+ws \"\n      read -p \"请选择:\" co\n\n      if [[ \"$co\" != \"1\" && \"$co\" != \"2\" ]]; then\n        echo \"无效输入!\"\n        return 1\n      fi\n\n      if [[ \"$co\" == \"1\" ]]; then\n        echo \"1.本地创建隧道的方式\"\n        echo \"2.到CF建固定隧道方式\"\n        read -p \"请选择:\" co\n\n        if [[ \"$co\" != \"1\" && \"$co\" != \"2\" ]]; then\n          echo \"无效输入!\"\n          return 1\n        fi\n        type=\"3.1\"\n        if [[ \"$co\" == \"1\" ]]; then\n          tunname=\"\"\n          domain=\"\"\n          localArgo\n        else\n          randomPort tcp vmess\n          if [[ -n \"$port\" ]]; then\n            vmport=\"$port\"\n          else\n            red \"未输入端口号\"\n            return 1\n          fi\n          read -p \"请输入WSPATH,默认是[serv00]: \" wspath\n          read -p \"请输入ARGO隧道token: \" token\n          read -p \"请输入ARGO隧道的域名: \" domain\n        fi\n        read -p \"是否使用自己的优选域名? [y/n] [n]:\" input\n        input=${input:-n}\n        if [[ \"$input\" == \"y\" ]]; then\n          read -p \"请输入优选域名:\" goodDomain\n          if [[ -z \"$goodDomain\" ]]; then\n            red \"未有输入!\"\n            return 1\n          fi\n        fi\n      else\n        type=\"3.2\"\n        randomPort tcp vmess\n        if [[ -n \"$port\" ]]; then\n          vmport=\"$port\"\n        else\n          red \"未输入端口号\"\n          return 1\n        fi\n        read -p \"请输入WSPATH,默认是[serv00]: \" wspath\n        read -p \"请输入优选域名:\" goodDomain\n      fi\n      # 配置 hy2\n      randomPort udp hy2\n      if [[ -n \"$port\" ]]; then\n        hy2_port=\"$port\"\n      else\n        red \"未输入端口号\"\n        return 1\n      fi\n      echo \"自动选择未封ip...\"\n      hy2_ip=$(get_ip)\n      if [[ -n \"$hy2_ip\" ]]; then\n        green \"选中未封ip为 $hy2_ip\"\n      else\n        red \"未能找到未封IP,保持默认值！\"\n      fi\n      #配置socks5\n      type=$(echo \"$type + 1.3\" | bc)\n      randomPort tcp socks5\n      if [[ -n \"$port\" ]]; then\n        socks5_port=\"$port\"\n      else\n        red \"未输入端口号\"\n        return 1\n      fi\n      read -p \"请输入socks5用户名:\" username\n      read -p \"请输入socks5密码:\" password\n      ;;\n    *)\n      echo \"无效的选择: $choice\"\n      ;;\n    esac\n  done\n\n  #socks5 不需要uuid\n  if [[ \"$type\" != \"1.3\" ]]; then\n    wspath=${wspath:-serv00}\n    read -p \"是否自动分配UUID? [y/n] [y]:\" input\n    input=${input:-y}\n    if [[ \"$input\" == \"y\" ]]; then\n      uuid=$(uuidgen -r)\n    else\n      read -p \"请输入UUID:\" uuid\n    fi\n  fi\n\n  read -p \"是否配置出站? [y/n] [n]:\" input\n  input=${input:-n}\n  outbound=\"\"\n  if [[ \"$input\" == \"y\" ]]; then\n    echo \"选择出站协议:\"\n    echo \"1.wireguard \"\n    echo \"2.socks5 \"\n    read -p \"请选择:\" co\n\n    if [[ \"$co\" != \"1\" && \"$co\" != \"2\" ]]; then\n      echo \"无效输入!\"\n      return 1\n    fi\n    outbound=$co\n\n    if [[ \"$outbound\" == \"2\" ]]; then\n      read -p \"请输入socks5服务器域名或IP:\" tmpinput\n      local out_server=$tmpinput\n      if [[ -z \"$out_server\" ]]; then\n        red \"未输入内容!\"\n        return 1\n      fi\n      read -p \"请输入socks5的端口:\" tmpinput\n      local out_port=$tmpinput\n      if [[ -z \"$out_port\" ]]; then\n        red \"未输入内容!\"\n        return 1\n      fi\n      read -p \"请输入socks5的用户名:\" tmpinput\n      local out_user=$tmpinput\n      if [[ -z \"$out_user\" ]]; then\n        red \"未输入内容!\"\n        return 1\n      fi\n      read -p \"请输入socks5的密码:\" tmpinput\n      local out_pass=$tmpinput\n      if [[ -z \"$out_pass\" ]]; then\n        red \"未输入内容!\"\n        return 1\n      fi\n\n      make_outbound_socks5 $out_server $out_port $out_user $out_pass\n    fi\n  fi\n  cat >singbox.json <<EOF\n  {\n     \"TYPE\": \"$type\",\n     \"VMPORT\": ${vmport:-null},\n     \"HY2IP\": \"${hy2_ip:-'::'}\",\n     \"HY2PORT\": ${hy2_port:-null},\n     \"UUID\": \"$uuid\",\n     \"WSPATH\": \"${wspath}\",\n     \"ARGO_AUTH\": \"${token:-null}\",\n     \"ARGO_DOMAIN\": \"${domain:-null}\",\n     \"GOOD_DOMAIN\": \"${goodDomain:-null}\",\n     \"SOCKS5_PORT\": \"${socks5_port:-null}\",\n     \"SOCKS5_USER\": \"${username:-null}\",\n     \"SOCKS5_PASS\": \"${password:-null}\",\n     \"TUNNEL_NAME\": \"${tunname:-null}\"\n  }\n\nEOF\n\n  generate_config $outbound\n  yellow \"sing-box配置完毕!\"\n\n}\n\nstartSingBox() {\n  cd ${installpath}/serv00-play/singbox\n\n  if [[ ! -e \"singbox.json\" ]]; then\n    red \"请先进行配置!\"\n    return 1\n  fi\n\n  # if [[ ! -e ${installpath}/serv00-play/singbox/serv00sb ]] || [[ ! -e ${installpath}/serv00-play/singbox/cloudflared ]]; then\n  #   read -p \"请输入使用密码:\" password\n  # fi\n\n  if ! checkDownload \"serv00sb\"; then\n    return\n  fi\n  if ! checkDownload \"cloudflared\"; then\n    return\n  fi\n\n  if checkSingboxAlive; then\n    red \"sing-box 已在运行，请勿重复操作!\"\n    return 1\n  else #启动可能需要cloudflare，此处表示cloudflare和sb有一个不在线，所以干脆先杀掉再重启。\n    chmod 755 ./killsing-box.sh\n    ./killsing-box.sh\n  fi\n\n  if chmod +x start.sh && ! ./start.sh; then\n    red \"sing-box启动失败！\"\n    exit 1\n  fi\n  sleep 1\n  if checkProcAlive \"serv00sb\"; then\n    yellow \"启动成功!\"\n  else\n    red \"启动失败!\"\n  fi\n\n}\n\nstopSingBox() {\n  cd ${installpath}/serv00-play/singbox\n  if [ -f killsing-box.sh ]; then\n    chmod 755 ./killsing-box.sh\n    ./killsing-box.sh\n  else\n    echo \"请先安装serv00-play!!!\"\n    return\n  fi\n  echo \"已停掉sing-box!\"\n}\n\nkillUserProc() {\n  local user=$(whoami)\n  pkill -kill -u $user\n}\n\nImageRecovery() {\n  cd ${installpath}/backups/local\n  # 定义一个关联数组\n  declare -A snapshot_paths\n\n  # 遍历每个符号链接，并将文件夹名称及真实路径保存到数组中\n  while read -r line; do\n    # 提取文件夹名称和对应的真实路径\n    folder=$(echo \"$line\" | awk '{print $9}')\n    real_path=$(echo \"$line\" | awk '{print $11}')\n\n    # 将文件夹名称和真实路径存入数组\n    snapshot_paths[\"$folder\"]=\"$real_path\"\n  done < <(ls -trl | grep -F \"lrwxr\")\n\n  size=${#snapshot_paths[@]}\n  sorted_keys=($(echo \"${!snapshot_paths[@]}\" | tr ' ' '\\n' | sort -r))\n  if [ $size -eq 0 ]; then\n    echo \"未有备份快照!\"\n    return\n  fi\n  echo \"选择你需要恢复的内容:\"\n  echo \"1. 完整快照恢复 \"\n  echo \"2. 恢复某个文件或目录\"\n  read -p \"请选择:\" input\n\n  if [ \"$input\" = \"1\" ]; then\n    local i=1\n    declare -a folders\n    for folder in \"${sorted_keys[@]}\"; do\n      echo \"${i}. ${folder} \"\n      i=$((i + 1))\n    done\n    retries=3\n    while [ $retries -gt 0 ]; do\n      read -p \"请选择恢复到哪一天(序号)？\" input\n      # 检查输入是否有效\n      if [[ $input =~ ^[0-9]+$ ]] && [ \"$input\" -gt 0 ] && [ \"$input\" -le $size ]; then\n        # 输入有效，退出循环\n        targetFolder=\"${sorted_keys[@]:$input-1:1}\"\n        echo \"你选择的恢复日期是：${targetFolder}\"\n        break\n      else\n        # 输入无效，减少重试次数\n        retries=$((retries - 1))\n        echo \"输入有误，请重新输入！你还有 $retries 次机会。\"\n      fi\n      if [ $retries -eq 0 ]; then\n        echo \"输入错误次数过多，操作已取消。\"\n        return\n      fi\n    done\n    killUserProc\n    srcpath=${snapshot_paths[\"${targetFolder}\"]}\n    #echo \"srcpath:$srcpath\"\n    rm -rf ~/* >/dev/null 2>&1\n    rsync -a $srcpath/ ~/ 2>/dev/null\n    yellow \"快照恢复完成!\"\n    return\n  elif [ \"$input\" = \"2\" ]; then\n    declare -A foundArr\n    read -p \"输入你要恢复到文件或目录:\" infile\n\n    for folder in \"${!snapshot_paths[@]}\"; do\n      path=\"${snapshot_paths[$folder]}\"\n      results=$(find \"${path}\" -name \"$infile\" 2>/dev/null)\n      # echo \"111results:|$results|\"\n      if [[ -n \"$results\" ]]; then\n        #echo \"put |$results| to folder:$folder\"\n        foundArr[\"$folder\"]=\"$results\"\n      fi\n    done\n    local i=1\n    sortedFoundArr=($(echo \"${!foundArr[@]}\" | tr ' ' '\\n' | sort -r))\n    declare -A indexPathArr\n    for folder in \"${sortedFoundArr[@]}\"; do\n      echo \"$i. $folder:\"\n      results=\"${foundArr[${folder}]}\"\n      IFS=$'\\n' read -r -d '' -a paths <<<\"$results\"\n      local j=1\n      for path in \"${paths[@]}\"; do\n        indexPathArr[\"$i\".\"$j\"]=\"$path\"\n        echo \"  $j. $path\"\n\n        j=$((j + 1))\n      done\n      i=$((i + 1))\n    done\n\n    while [ true ]; do\n      read -p \"输入要恢复的文件序号，格式:日期序号.文件序号, 多个以逗号分隔.(如输入 1.2,3.2)[按enter返回]:\" input\n      regex='^([0-9]+\\.[0-9]+)(,[0-9]+\\.[0-9]+)*$'\n\n      if [ -z \"$input\" ]; then\n        return\n      fi\n\n      if [[ \"$input\" =~ $regex ]]; then\n        declare -a pairNos\n        declare -a fileNos\n        IFS=',' read -r -a pairNos <<<\"$input\"\n\n        echo \"请选择文件恢复的目标路径:\"\n        echo \"1.原路返回 \"\n        echo \"2.${installpath}/restore \"\n        read -p \"请选择:\" targetDir\n\n        if [[ \"$targetDir\" != \"1\" ]] && [[ \"$targetDir\" != \"2\" ]]; then\n          red \"无效输入!\"\n          return\n        fi\n\n        for pairNo in \"${pairNos[@]}\"; do\n          srcpath=\"${indexPathArr[$pairNo]}\"\n\n          if [ \"$targetDir\" = \"1\" ]; then\n            local user=$(whoami)\n            targetPath=${srcpath#*${user}}\n            if [ -d $srcpath ]; then\n              targetPath=${targetPath%/*}\n            fi\n            echo \"cp -r $srcpath $HOME/$targetPath\"\n            cp -r ${srcpath} $HOME/${targetPath}\n\n          elif [ \"$targetDir\" = \"2\" ]; then\n            targetPath=\"${installpath}/restore\"\n            if [ ! -e \"$targetPath\" ]; then\n              mkdir -p \"$targetPath\"\n            fi\n            cp -r $srcpath $targetPath/\n          fi\n        done\n        green \"完成文件恢复\"\n\n      else\n        red \"输入格式不对，请重新输入！\"\n      fi\n    done\n  fi\n\n}\n\nuninstall() {\n  read -p \"确定卸载吗? [y/n] [n]:\" input\n  input=${input:-n}\n\n  if [ \"$input\" == \"y\" ]; then\n    delCron\n    stopSingBox\n    cd $HOME\n    rm -rf serv00-play\n    echo \"bye!\"\n  fi\n}\n\nInitServer() {\n  read -p \"$(red \"将初始化帐号系统，要继续？[y/n] [n]:\")\" input\n  input=${input:-n}\n  read -p \"是否保留用户配置？[y/n] [y]:\" saveProfile\n  saveProfile=${saveProfile:-y}\n\n  if [[ \"$input\" == \"y\" ]] || [[ \"$input\" == \"Y\" ]]; then\n    cleanCron\n    green \"清理进程中...\"\n    killUserProc\n    green \"清理磁盘中...\"\n    if [[ \"$saveProfile\" == \"y\" ]] || [[ \"$saveProfile\" == \"Y\" ]]; then\n      rm -rf ~/* 2>/dev/null\n    else\n      rm -rf ~/* ~/.* 2>/dev/null\n    fi\n    cleanPort\n    yellow \"初始化完毕\"\n\n    exit 0\n  fi\n}\n\nmanageNeZhaAgent() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  while true; do\n    yellow \"-------------------------\"\n    echo \"探针管理：\"\n    echo \"1.安装探针\"\n    echo \"2.升级探针\"\n    echo \"3.启动/重启探针\"\n    echo \"4.停止探针\"\n    echo \"9.返回主菜单\"\n    echo \"0.退出脚本\"\n    yellow \"-------------------------\"\n\n    read -p \"请选择:\" choice\n    case $choice in\n    1)\n      installNeZhaAgent\n      ;;\n    2)\n      updateAgent\n      ;;\n    3)\n      startAgent\n      exit 0\n      ;;\n    4)\n      stopNeZhaAgent\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\nupdateAgent() {\n  red \"暂不提供在线升级, 只适配哪吒面板v0版本系列。\"\n  return 1\n  exepath=\"${installpath}/serv00-play/nezha/nezha-agent\"\n  if [ ! -e \"$exepath\" ]; then\n    red \"未安装探针，请先安装！！!\"\n    return\n  fi\n\n  local workedir=\"${installpath}/serv00-play/nezha\"\n  cd $workedir\n\n  local_version=\"v\"$(./nezha-agent -v)\n  latest_version=$(curl -sL https://github.com/nezhahq/agent/releases/latest | sed -n 's/.*tag\\/\\(v[0-9.]*\\).*/\\1/p' | head -1)\n\n  if [[ \"$local_version\" != \"$latest_version\" ]]; then\n    echo \"发现新版本: $latest_version，当前版本: $local_version。正在更新...\"\n    download_url=\"https://github.com/nezhahq/agent/releases/download/$latest_version/nezha-agent_freebsd_amd64.zip\"\n\n    local filezip=\"nezha-agent_latest.zip\"\n    curl -sL -o \"$filezip\" \"$download_url\"\n    if [[ ! -e \"$filezip\" || -n $(file \"$filezip\" | grep \"text\") ]]; then\n      echo \"下载探针文件失败!\"\n      return\n    fi\n    local agent_runing=0\n    if checknezhaAgentAlive; then\n      stopNeZhaAgent\n      agent_runing=1\n    fi\n    unzip -o $filezip -d .\n    chmod +x ./nezha-agent\n    if [ $agent_runing -eq 1 ]; then\n      startAgent\n    fi\n    rm -rf $filezip\n    green \"更新完成！新版本: $latest_version\"\n  else\n    echo \"已经是最新版本: $local_version\"\n  fi\n  if [[ $agent_runing -eq 1 ]]; then\n    exit 0\n  fi\n}\n\nstartAgent() {\n  local workedir=\"${installpath}/serv00-play/nezha\"\n  if [ ! -e \"${workedir}\" ]; then\n    red \"未安装探针，请先安装！！!\"\n    return\n  fi\n  cd $workedir\n\n  local configfile=\"./nezha.json\"\n  if [ ! -e \"$configfile\" ]; then\n    red \"未安装探针，请先安装！！!\"\n    return\n  fi\n\n  nezha_domain=$(jq -r \".nezha_domain\" $configfile)\n  nezha_port=$(jq -r \".nezha_port\" $configfile)\n  nezha_pwd=$(jq -r \".nezha_pwd\" $configfile)\n  tls=$(jq -r \".tls\" $configfile)\n\n  if checknezhaAgentAlive; then\n    stopNeZhaAgent\n  fi\n\n  local args=\"--report-delay 4 --disable-auto-update --disable-force-update \"\n  if [[ \"$tls\" == \"y\" ]]; then\n    args=\"${args} --tls \"\n  fi\n\n  #echo \"./nezha-agent ${args} -s ${nezha_domain}:${nezha_port} -p ${nezha_pwd}\"\n  nohup ./nezha-agent ${args} -s ${nezha_domain}:${nezha_port} -p ${nezha_pwd} >/dev/null 2>&1 &\n\n  if checknezhaAgentAlive; then\n    green \"启动成功!\"\n  else\n    red \"启动失败!\"\n  fi\n  #即便使用nohup放后台，此处如果使用ctrl+c退出脚本，nezha-agent进程也会退出。非常奇葩，因此startAgent后只能exit退出脚本，避免用户使用ctrl+c退出。\n\n}\n\ninstallNeZhaAgent() {\n  local workedir=\"${installpath}/serv00-play/nezha\"\n  if [ ! -e \"${workedir}\" ]; then\n    mkdir -p \"${workedir}\"\n  fi\n  cd ${workedir}\n  if [[ ! -e nezha-agent ]]; then\n    echo \"正在下载哪吒探针...\"\n    local url=\"https://github.com/nezhahq/agent/releases/download/v0.20.3/nezha-agent_freebsd_amd64.zip\"\n    agentZip=\"nezha-agent.zip\"\n    if ! wget -qO \"$agentZip\" \"$url\"; then\n      red \"下载哪吒探针失败\"\n      return 1\n    fi\n    unzip $agentZip >/dev/null 2>&1\n    chmod +x ./nezha-agent\n    green \"下载完毕\"\n  fi\n\n  local config=\"nezha.json\"\n  local input=\"y\"\n  if [[ -e \"$config\" ]]; then\n    echo \"哪吒探针配置如下:\"\n    cat \"$config\"\n    read -p \"是否修改？ [y/n] [n]:\" input\n    input=${input:-n}\n  fi\n\n  if [[ \"$input\" == \"y\" ]]; then\n    read -p \"请输入哪吒面板的域名或ip:\" nezha_domain\n    read -p \"请输入哪吒面板RPC端口(默认 5555):\" nezha_port\n    nezha_port=${nezha_port:-5555}\n    read -p \"请输入服务器密钥(从哪吒面板中获取):\" nezha_pwd\n    read -p \"是否启用针对 gRPC 端口的 SSL/TLS加密 (--tls)，需要请按 [y]，默认是不需要，不理解用户可回车跳过: \" tls\n    tls=${tls:-\"N\"}\n  else\n    nezha_domain=$(jq -r \".nezha_domain\" $config)\n    nezha_port=$(jq -r \".nezha_port\" $config)\n    nezha_pwd=$(jq -r \".nezha_pwd\" $config)\n    tls=$(jq -r \".tls\" $config)\n  fi\n\n  if [[ -z \"$nezha_domain\" || -z \"$nezha_port\" || -z \"$nezha_pwd\" ]]; then\n    red \"以上参数都不能为空！\"\n    return 1\n  fi\n\n  cat >$config <<EOF\n    {\n      \"nezha_domain\": \"$nezha_domain\",\n      \"nezha_port\": \"$nezha_port\",\n      \"nezha_pwd\": \"$nezha_pwd\",\n      \"tls\": \"$tls\"\n    }\nEOF\n\n  local args=\"--report-delay 4 --disable-auto-update --disable-force-update \"\n  if [[ \"$tls\" == \"y\" ]]; then\n    args=\"${args} --tls \"\n  fi\n\n  if checknezhaAgentAlive; then\n    stopNeZhaAgent\n  fi\n\n  nohup ./nezha-agent ${args} -s \"${nezha_domain}:${nezha_port}\" -p \"${nezha_pwd}\" >/dev/null 2>&1 &\n  green \"哪吒探针成功启动!\"\n\n}\n\nuninstallAgent() {\n  read -p \"确定卸载哪吒探针? [y/n] [n]:\" input\n  input=${input:-n}\n\n  if [[ \"$input\" == \"y\" ]]; then\n    if checknezhaAgentAlive; then\n      stopNeZhaAgent\n    fi\n    local workedir=\"${installpath}/serv00-play/nezha\"\n    rm -rf $workedir\n    green \"卸载完毕!\"\n  fi\n\n}\n\nsetCnTimeZone() {\n  read -p \"确定设置中国上海时区? [y/n] [y]:\" input\n  input=${input:-y}\n\n  cd ${installpath}\n  if [ \"$input\" = \"y\" ]; then\n    devil binexec on\n    touch .profile\n    cat .profile | perl ./serv00-play/mkprofile.pl >tmp_profile\n    mv -f tmp_profile .profile\n\n    read -p \"$(yellow 设置完毕,需要重新登录才能生效，是否重新登录？[y/n] [y]:)\" input\n    input=${input:-y}\n\n    if [ \"$input\" = \"y\" ]; then\n      kill -9 $PPID\n    fi\n  fi\n\n}\n\nsetColorWord() {\n  cd ${installpath}\n  # 定义颜色编码\n  bright_black=\"\\033[1;90m\"\n  bright_red=\"\\033[1;91m\"\n  bright_green=\"\\033[1;92m\"\n  bright_yellow=\"\\033[1;93m\"\n  bright_blue=\"\\033[1;94m\"\n  bright_magenta=\"\\033[1;95m\"\n  bright_cyan=\"\\033[1;96m\"\n  bright_white=\"\\033[1;97m\"\n  reset=\"\\033[0m\"\n\n  # 显示颜色选项列表，并使用颜色着色\n  echo -e \"请选择一个颜色来输出你的签名:\"\n  echo -e \"1) ${bright_black}明亮黑色${reset}\"\n  echo -e \"2) ${bright_red}明亮红色${reset}\"\n  echo -e \"3) ${bright_green}明亮绿色${reset}\"\n  echo -e \"4) ${bright_yellow}明亮黄色${reset}\"\n  echo -e \"5) ${bright_blue}明亮蓝色${reset}\"\n  echo -e \"6) ${bright_magenta}明亮紫色${reset}\"\n  echo -e \"7) ${bright_cyan}明亮青色${reset}\"\n  echo -e \"8) ${bright_white}明亮白色${reset}\"\n\n  # 读取用户输入的选择\n  read -p \"请输入你的选择(1-8): \" color_choice\n\n  read -p \"请输入你的大名(仅支持ascii字符):\" name\n\n  # 根据用户的选择设置颜色\n  case $color_choice in\n  1) color_code=\"90\" ;; # 明亮黑色\n  2) color_code=\"91\" ;; # 明亮红色\n  3) color_code=\"92\" ;; # 明亮绿色\n  4) color_code=\"93\" ;; # 明亮黄色\n  5) color_code=\"94\" ;; # 明亮蓝色\n  6) color_code=\"95\" ;; # 明亮紫色\n  7) color_code=\"96\" ;; # 明亮青色\n  8) color_code=\"97\" ;; # 明亮白色\n  *)\n    echo \"无效选择，使用默认颜色 (明亮白色)\"\n    color_code=\"97\"\n    ;;\n  esac\n\n  if grep \"chAngEYourName\" .profile >/dev/null; then\n    cat .profile | grep -v \"chAngEYourName\" >tmp_profile\n    echo \"echo -e \\\"\\033[1;${color_code}m\\$(figlet \\\"${name}\\\")\\033[0m\\\"  #chAngEYourName\" >>tmp_profile\n    mv -f tmp_profile .profile\n  else\n    echo \"echo -e \\\"\\033[1;${color_code}m\\$(figlet \\\"${name}\\\")\\033[0m\\\" #chAngEYourName\" >>.profile\n  fi\n\n  read -p \"设置完毕! 重新登录看效果? [y/n] [y]:\" input\n  input=${input:-y}\n  if [[ \"$input\" == \"y\" ]]; then\n    kill -9 $PPID\n  fi\n\n}\n\nshowIP() {\n  myip=\"$(curl -s icanhazip.com)\"\n  green \"本机IP: $myip\"\n}\n\nuninstallMtg() {\n  read -p \"确定卸载? [y/n] [n]:\" input\n  input=${input:-n}\n\n  if [[ \"$input\" == \"n\" ]]; then\n    return 1\n  fi\n\n  if [[ -e \"mtg\" ]]; then\n    if checkProcAlive mtg; then\n      stopMtg\n    fi\n    cd ${installpath}/serv00-play\n    rm -rf dmtg\n    green \"卸载完毕！\"\n  fi\n}\n\ninstallMtg() {\n  if [ ! -e \"mtg\" ]; then\n    # read -p \"请输入使用密码:\" password\n    if ! checkDownload \"mtg\"; then\n      return 1\n    fi\n  fi\n\n  chmod +x ./mtg\n  if [ -e \"config.json\" ]; then\n    echo \"已存在配置如下:\"\n    cat config.json\n    read -p \"是否重新生成配置? [y/n] [n]:\" input\n    input=${input:-n}\n    if [ \"$input\" == \"n\" ]; then\n      return 0\n    fi\n  fi\n\n  #自动生成密钥\n  head=$(hostname | cut -d '.' -f 1)\n  no=${head#s}\n  host=\"panel${no}.serv00.com\"\n  secret=$(./mtg generate-secret --hex $host)\n  loadPort\n  randomPort tcp mtg\n  if [[ -n \"$port\" ]]; then\n    mtpport=\"$port\"\n  fi\n\n  cat >config.json <<EOF\n   {\n      \"secret\": \"$secret\",\n      \"port\": \"$mtpport\"\n   }\nEOF\n  yellow \"安装完成!\"\n}\n\nstartMtg() {\n  cd ${installpath}/serv00-play\n\n  if [ ! -e \"dmtg\" ]; then\n    ehco \"未安装mtproto，请先行安装配置!\"\n    return 1\n  fi\n  cd dmtg\n  config=\"config.json\"\n  if [ ! -e $config ]; then\n    red \"未安装mtproto，请先行安装配置!\"\n    return 1\n  fi\n\n  if checkMtgAlive; then\n    echo \"已在运行,请勿重复启动\"\n    return 0\n  fi\n\n  read -p \"是否需要日志？: [y/n] [n]:\" input\n  input=${input:-n}\n\n  if [ \"$input\" == \"y\" ]; then\n    green \"日志文件名称为:mtg.log\"\n    logfile=\"-d >mtg.log\"\n  else\n    logfile=\" >/dev/null \"\n  fi\n\n  host=\"$(hostname | cut -d '.' -f 1)\"\n\n  secret=$(jq -r \".secret\" $config)\n  port=$(jq -r \".port\" $config)\n\n  cmd=\"nohup ./mtg simple-run -n 1.1.1.1 -t 30s -a 1MB 0.0.0.0:${port} ${secret} -c 8192 --prefer-ip=\\\"prefer-ipv6\\\" ${logfile} 2>&1 &\"\n  eval \"$cmd\"\n  sleep 3\n  if checkMtgAlive; then\n    mtproto=\"https://t.me/proxy?server=${host}.serv00.com&port=${port}&secret=${secret}\"\n    echo \"$mtproto\"\n    green \"启动成功\"\n  else\n    echo \"启动失败，请检查进程\"\n  fi\n\n}\n\nstopMtg() {\n  r=$(ps aux | grep mtg | grep -v \"grep\" | awk '{print $2}')\n  if [ -z \"$r\" ]; then\n    echo \"没有运行!\"\n    return\n  else\n    kill -9 $r\n  fi\n  echo \"已停掉mtproto!\"\n\n}\n\nmtprotoServ() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  cd ${installpath}/serv00-play\n\n  if [ ! -e \"dmtg\" ]; then\n    mkdir -p dmtg\n  fi\n  cd dmtg\n\n  while true; do\n    yellow \"---------------------\"\n    echo \"服务状态: $(checkProcStatus mtg)\"\n    echo \"mtproto管理:\"\n    echo \"1. 安装\"\n    echo \"2. 启动\"\n    echo \"3. 停止\"\n    echo \"4. 卸载\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"---------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      installMtg\n      ;;\n    2)\n      startMtg\n      ;;\n    3)\n      stopMtg\n      ;;\n    4)\n      uninstallMtg\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n\n}\n\nextract_user_and_password() {\n  output=$1\n\n  username=$(echo \"$output\" | grep \"username:\" | sed 's/.*username: //')\n  password=$(echo \"$output\" | grep \"password:\" | sed 's/.*password: //')\n  echo \"生成用户密码如下，请谨记! 只会出现一次:\"\n  green \"Username: $username\"\n  green \"Password: $password\"\n}\n\nupdate_http_port() {\n  cd data || return 1\n  local port=$1\n  local config_file=\"config.json\"\n\n  if [ -z \"$port\" ]; then\n    echo \"Error: No port number provided.\"\n    return 1\n  fi\n  # 使用 jq 来更新配置文件中的 http_port\n  jq --argjson new_port \"$port\" '.scheme.http_port = $new_port' \"$config_file\" >tmp.$$.json && mv tmp.$$.json \"$config_file\"\n\n  echo \"配置文件处理完毕.\"\n\n}\n\ninstallAlist() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  cd ${installpath}/serv00-play/ || return 1\n  alistpath=\"${installpath}/serv00-play/alist\"\n\n  if [[ ! -e \"$alistpath\" ]]; then\n    mkdir -p $alistpath\n  fi\n  if [[ -d \"$alistpath/data\" && -e \"$alistpath/alist\" ]]; then\n    echo \"已安装，请勿重复安装。\"\n    return\n  else\n    cd \"alist\" || return 1\n    if [ ! -e \"alist\" ]; then\n      # read -p \"请输入使用密码:\" password\n      if ! checkDownload \"alist\"; then\n        return 1\n      fi\n    fi\n  fi\n\n  loadPort\n  randomPort tcp alist\n  if [[ -n \"$port\" ]]; then\n    alist_port=\"$port\"\n  fi\n  echo \"正在安装alist，请等待...\"\n  domain=\"\"\n  webIp=\"\"\n  if ! makeWWW alist $alist_port; then\n    echo \"绑定域名失败!\"\n    return 1\n  fi\n  if ! applyLE $domain $webIp; then\n    echo \"申请证书失败!\"\n    return 1\n  fi\n  cd $alistpath\n  rt=$(chmod +x ./alist && ./alist admin random 2>&1)\n  extract_user_and_password \"$rt\"\n  update_http_port \"$alist_port\"\n\n  green \"安装完毕\"\n\n}\n\nstartAlist() {\n  alistpath=\"${installpath}/serv00-play/alist\"\n  cd $alistpath\n  domain=$(jq -r \".domain\" config.json)\n\n  if [[ -d \"$alistpath/data\" && -e \"$alistpath/alist\" ]]; then\n    cd $alistpath\n    echo \"正在启动alist...\"\n    if checkProcAlive alist; then\n      echo \"alist已启动，请勿重复启动!\"\n    else\n      nohup ./alist server >/dev/null 2>&1 &\n      sleep 3\n      if ! checkProcAlive alist; then\n        red \"启动失败，请检查!\"\n        return 1\n      else\n        green \"启动成功!\"\n        green \"alist管理地址: https://$domain\"\n      fi\n    fi\n  else\n    red \"请先行安装再启动!\"\n    return\n  fi\n}\n\nstopAlist() {\n  if checkProcAlive \"alist\"; then\n    stopProc \"alist\"\n    sleep 3\n  fi\n\n}\n\n# uninstallPHP(){\n#   local domain=$1\n#   initialize_phpjson\n#   delete_domain $domain\n#   yellow \"已删除域名 $domain 的相关服务!\"\n# }\n\nuninstallProc() {\n  local path=$1\n  local procname=$2\n\n  if [ ! -e \"$path\" ]; then\n    red \"未安装$procname!!!\"\n    return 1\n  fi\n  cd $path\n  read -p \"确定卸载${procname}吗? [y/n] [n]:\" input\n  input=${input:-n}\n  if [[ \"$input\" == \"y\" ]]; then\n    stopProc \"$procname\"\n    domain=$(jq -r \".domain\" config.json)\n    webip=$(jq -r \".webip\" config.json)\n    resp=$(devil ssl www del $webIp $domain)\n    resp=$(devil www del $domain --remove)\n    cd ${installpath}/serv00-play\n    rm -rf $path\n    green \"卸载完毕!\"\n  fi\n\n}\n\nuninstallAlist() {\n  alistpath=\"${installpath}/serv00-play/alist\"\n  uninstallProc \"$alistpath\" alist\n\n}\n\nresetAdminPass() {\n  alistpath=\"${installpath}/serv00-play/alist\"\n  cd $alistpath\n\n  output=$(./alist admin random 2>&1)\n  extract_user_and_password \"$output\"\n}\n\nalistServ() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  while true; do\n    yellow \"----------------------\"\n    echo \"alist:\"\n    echo \"服务状态: $(checkProcStatus alist)\"\n    echo \"1. 安装部署alist \"\n    echo \"2. 启动alist\"\n    echo \"3. 停掉alist\"\n    echo \"4. 重置admin密码\"\n    echo \"8. 卸载alist\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"----------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      installAlist\n      ;;\n    2)\n      startAlist\n      ;;\n    3)\n      stopAlist\n      ;;\n    4)\n      resetAdminPass\n      ;;\n    8)\n      uninstallAlist\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\ndeclare -a indexPorts\nloadIndexPorts() {\n  output=$(devil port list)\n\n  indexPorts=()\n  # 解析输出内容\n  index=0\n  while read -r port typ opis; do\n    # 跳过标题行\n    if [[ \"$port\" =~ \"Port\" ]]; then\n      continue\n    fi\n    #echo \"port:$port,typ:$typ, opis:$opis\"\n    if [[ \"$port\" =~ \"Brak\" || \"$port\" =~ \"No\" ]]; then\n      echo \"未分配端口\"\n      return 0\n    fi\n\n    if [[ -n \"$port\" ]]; then\n      opis=${opis:-\"\"}\n      indexPorts[$index]=\"$port|$typ|$opis\"\n      ((index++))\n    fi\n  done <<<\"$output\"\n\n}\n\nprintIndexPorts() {\n  local i=1\n  echo \"  Port   | Type  |  Description\"\n  for entry in \"${indexPorts[@]}\"; do\n    # 使用 | 作为分隔符拆分 port、typ 和 opis\n\n    IFS='|' read -r port typ opis <<<\"$entry\"\n    echo \"${i}. $port |  $typ | $opis\"\n    ((i++))\n  done\n}\n\ndelPortMenu() {\n  loadIndexPorts\n\n  if [[ ${#indexPorts[@]} -gt 0 ]]; then\n    printIndexPorts\n    read -p \"请选择要删除的端口记录编号(输入0删除所有端口记录, 回车返回):\" number\n    number=${number:-99}\n\n    if [[ $number -eq 99 ]]; then\n      return\n    elif [[ $number -gt 3 || $number -lt 0 ]]; then\n      echo \"非法输入!\"\n      return\n    elif [[ $number -eq 0 ]]; then\n      cleanPort\n    else\n      idx=$((number - 1))\n      IFS='|' read -r port typ opis <<<${indexPorts[$idx]}\n      devil port del $typ $port >/dev/null 2>&1\n    fi\n    echo \"删除完毕!\"\n  else\n    red \"未有分配任何端口!\"\n  fi\n\n}\n\naddPortMenu() {\n  echo \"选择端口类型:\"\n  echo \"1. tcp\"\n  echo \"2. udp\"\n  read -p \"请选择:\" co\n\n  if [[ \"$co\" != \"1\" && \"$co\" != \"2\" ]]; then\n    red \"非法输入\"\n    return\n  fi\n  local type=\"\"\n  if [[ \"$co\" == \"1\" ]]; then\n    type=\"tcp\"\n  else\n    type=\"udp\"\n  fi\n  loadPort\n  read -p \"请输入端口备注(如hy2，vmess，用于脚本自动获取端口):\" opts\n  local port=$(getPort $type $opts)\n  if [[ \"$port\" == \"failed\" ]]; then\n    red \"分配端口失败,请重新操作!\"\n  else\n    green \"分配出来的端口是:$port\"\n  fi\n}\n\nportServ() {\n  while true; do\n    yellow \"----------------------\"\n    echo \"端口管理:\"\n    echo \"1. 删除某条端口记录\"\n    echo \"2. 增加一条端口记录\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"----------------------\"\n    read -p \"请选择:\" input\n    case $input in\n    1)\n      delPortMenu\n      ;;\n    2)\n      addPortMenu\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\ncronLE() {\n  read -p \"请输入定时运行的时间间隔(小时[1-23]):\" tm\n  tm=${tm:-\"\"}\n  if [[ -z \"$tm\" ]]; then\n    red \"时间不能为空\"\n    return 1\n  fi\n  if [[ $tm -lt 1 || $tm -gt 23 ]]; then\n    red \"输入非法!\"\n    return 1\n  fi\n  crontab -l >le.cron\n  echo \"0 */$tm * * * $workpath/cronSSL.sh $domain > /dev/null 2>&1 \" >>le.cron\n  crontab le.cron >/dev/null 2>&1\n  rm -rf le.cron\n  echo \"设置完毕!\"\n}\n\nget_default_webip() {\n  local host=\"$(hostname | cut -d '.' -f 1)\"\n  local sno=${host/s/web}\n  local webIp=$(devil vhost list public | grep \"$sno\" | awk '{print $1}')\n  echo \"$webIp\"\n}\n\napplyLE() {\n  local domain=$1\n  local webIp=$2\n  workpath=\"${installpath}/serv00-play/ssl\"\n  cd \"$workpath\"\n\n  if [[ -z \"$domain\" ]]; then\n    read -p \"请输入待申请证书的域名:\" domain\n    domain=${domain:-\"\"}\n    if [[ -z \"$domain\" ]]; then\n      red \"域名不能为空\"\n      return 1\n    fi\n  fi\n  inCron=\"0\"\n  if crontab -l | grep -F \"$domain\" >/dev/null 2>&1; then\n    inCron=\"1\"\n    echo \"该域名已配置定时申请证书，是否删除定时配置记录，改为手动申请？[y/n] [n]:\" input\n    input=${input:-n}\n\n    if [[ \"$input\" == \"y\" ]]; then\n      crontab -l | grep -v \"$domain\" | crontab -\n    fi\n  fi\n  if [[ -z \"$webIp\" ]]; then\n    read -p \"是否指定webip? [y/n] [n]:\" input\n    input=${input:-n}\n    if [[ \"$input\" == \"y\" ]]; then\n      read -p \"请输入webip:\" webIp\n      if [[ -z \"webIp\" ]]; then\n        red \"webip 不能为空!!!\"\n        return 1\n      fi\n    else\n      host=\"$(hostname | cut -d '.' -f 1)\"\n      sno=${host/s/web}\n      webIp=$(devil vhost list public | grep \"$sno\" | awk '{print $1}')\n    fi\n  fi\n  #echo \"申请证书时，webip是: $webIp\"\n  resp=$(devil ssl www add $webIp le le $domain)\n  if [[ ! \"$resp\" =~ .*succesfully.*$ ]]; then\n    red \"申请ssl证书失败！$resp\"\n    if [[ \"$inCron\" == \"0\" ]]; then\n      read -p \"是否配置定时任务自动申请SSL证书？ [y/n] [n]:\" input\n      input=${input:-n}\n      if [[ \"$input\" == \"y\" ]]; then\n        cronLE\n      fi\n    fi\n  else\n    green \"证书申请成功!\"\n  fi\n}\n\nselfSSL() {\n  workpath=\"${installpath}/serv00-play/ssl\"\n  cd \"$workpath\"\n\n  read -p \"请输入待申请证书的域名:\" self_domain\n  self_domain=${self_domain:-\"\"}\n  if [[ -z \"$self_domain\" ]]; then\n    red \"域名不能为空\"\n    return 1\n  fi\n\n  echo \"正在生成证书...\"\n\n  cat >openssl.cnf <<EOF\n    [req]\n    distinguished_name = req_distinguished_name\n    req_extensions = req_ext\n    x509_extensions = v3_ca # For self-signed certs\n    prompt = no\n\n    [req_distinguished_name]\n    C = US\n    ST = ca\n    L = ca\n    O = ca\n    OU = ca\n    CN = $self_domain\n\n    [req_ext]\n    subjectAltName = @alt_names\n\n    [v3_ca]\n    subjectAltName = @alt_names\n\n    [alt_names]\n    DNS.1 = $self_domain\n\nEOF\n  openssl req -new -newkey rsa:2048 -nodes -keyout _private.key -x509 -days 3650 -out _cert.crt -config openssl.cnf -extensions v3_ca >/dev/null 2>&1\n  if [ $? -ne 0 ]; then\n    echo \"生成证书失败!\"\n    return 1\n  fi\n\n  echo \"已生成证书:\"\n  green \"_private.key\"\n  green \"_cert.crt\"\n\n  echo \"正在导入证书..\"\n  host=\"$(hostname | cut -d '.' -f 1)\"\n  sno=${host/s/web}\n  webIp=$(devil vhost list public | grep \"$sno\" | awk '{print $1}')\n  resp=$(devil ssl www add \"$webIp\" ./_cert.crt ./_private.key \"$self_domain\")\n\n  if [[ ! \"$resp\" =~ .*succesfully.*$ ]]; then\n    echo \"导入证书失败:$resp\"\n    return 1\n  fi\n\n  echo \"导入成功！\"\n\n}\n\ndomainSSLServ() {\n  while true; do\n    yellow \"---------------------\"\n    echo \"域名证书管理:\"\n    echo \"1. 抢域名证书\"\n    echo \"2. 配置自签证书\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"---------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      applyLE\n      ;;\n    2)\n      selfSSL\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\ninstallRoot() {\n  workpath=\"${installpath}/serv00-play/root\"\n  if [[ ! -e $workpath ]]; then\n    mkdir -p \"$workpath\"\n  fi\n\n  if [[ -e \"$workpath/MrChrootBSD/mrchroot\" ]]; then\n    echo \"检测到已经安装mrchroot，请勿重复安装!\"\n    return\n  fi\n  echo \"正在安装...\"\n  cd $workpath\n  git clone https://github.com/nrootconauto/MrChrootBSD.git\n  cd MrChrootBSD\n  wget https://download.freebsd.org/releases/amd64/14.1-RELEASE/base.txz\n  wget https://download.freebsd.org/releases/amd64/14.1-RELEASE/lib32.txz #Needed for gdb for some reason\n  mkdir chroot\n  cd chroot\n  tar xvf ../base.txz\n  tar xvf ../lib32.txz\n  cd ..\n  cmake .\n  make\n  cp /etc/resolv.conf chroot/etc\n  if screen -S rootsession -dm ./mrchroot chroot /bin/sh; then\n    echo \"安装成功!\"\n  else\n    echo \"安装失败!\"\n  fi\n\n}\n\nenterRoot() {\n  workpath=\"${installpath}/serv00-play/root/MrChrootBSD\"\n  if [[ ! -e \"$workpath/mrchroot\" ]]; then\n    red \"未安装mrchroot，请先行安装!\"\n    return\n  fi\n\n  SESSION_NAME=\"rootsession\"\n  if screen -list | grep -q \"\\.$SESSION_NAME\"; then\n    echo \"进入root...\"\n    screen -r \"$SESSION_NAME\"\n  else\n    echo \"未发现root进程，尝试创建井进入root...\"\n    cd $workpath\n    if screen -S $SESSION_NAME -dm ./mrchroot chroot /bin/sh; then\n      echo \"创建成功!\"\n      screen -r \"$SESSION_NAME\"\n    else\n      echo \"创建失败!\"\n    fi\n\n  fi\n}\n\nuninstallRoot() {\n  SESSION_NAME=\"rootsession\"\n\n  if [[ ! -e \"${installpath}/serv00-play/root\" ]]; then\n    echo \"未安装root，无需卸载!\"\n    return\n  fi\n\n  read -p \"确定卸载root吗？[y/n] [n]:\" input\n  input=${input:-n}\n\n  if [[ \"$input\" == \"y\" ]]; then\n\n    if screen -list | grep -q \"\\.${SESSION_NAME}\"; then\n      screen -S \"$SESSION_NAME\" -X quit\n    fi\n\n    workpath=\"${installpath}/serv00-play/\"\n    cd $workpath\n    rm -rf ./root\n  fi\n\n  green \"卸载完毕!\"\n}\n\nrootServ() {\n  while true; do\n    yellow \"---------------------\"\n    echo \"一键root:\"\n    echo \"1. 安装root\"\n    echo \"2. 进入root\"\n    echo \"3. 卸载root\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"---------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      installRoot\n      ;;\n    2)\n      enterRoot\n      ;;\n    3)\n      uninstallRoot\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\ngetUnblockIP() {\n  local hostname=$(hostname)\n  local host_number=$(echo \"$hostname\" | awk -F'[s.]' '{print $2}')\n  local hosts=(\"cache${host_number}.serv00.com\" \"web${host_number}.serv00.com\" \"$hostname\")\n\n  yellow \"----------------------------------------------\"\n  green \"  主机名称          |      IP        |  状态\"\n  yellow \"----------------------------------------------\"\n  # 遍历主机名称数组\n  for host in \"${hosts[@]}\"; do\n    # 获取 API 返回的数据\n    local response=$(curl -s \"https://ss.botai.us.kg/api/getip?host=$host\")\n\n    # 检查返回的结果是否包含 \"not found\"\n    if [[ \"$response\" =~ \"not found\" ]]; then\n      echo \"未识别主机${host}, 请联系作者饭奇骏!\"\n      return\n    fi\n    local ip=$(echo \"$response\" | awk -F \"|\" '{print $1 }')\n    local status=$(echo \"$response\" | awk -F \"|\" '{print $2 }')\n    printf \"%-20s | %-15s | %-10s\\n\" \"$host\" \"$ip\" \"$status\"\n  done\n\n}\n\ncheckProcStatus() {\n  local procname=$1\n  if checkProcAlive $procname; then\n    green \"运行\"\n  else\n    red \"未运行\"\n  fi\n\n}\n\nsunPanelServ() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  while true; do\n    yellow \"---------------------\"\n    echo \"sun-panel:\"\n    echo \"服务状态: $(checkProcStatus sun-panel)\"\n    echo \"1. 安装\"\n    echo \"2. 启动\"\n    echo \"3. 停止\"\n    echo \"4. 初始化密码\"\n    echo \"8. 卸载\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"---------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      installSunPanel\n      ;;\n    2)\n      startSunPanel\n      ;;\n    3)\n      stopSunPanel\n      ;;\n    4)\n      resetSunPanelPwd\n      ;;\n    8)\n      uninstallSunPanel\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\nuninstallSunPanel() {\n  local workdir=\"${installpath}/serv00-play/sunpanel\"\n  uninstallProc \"$workdir\" \"sun-panel\"\n}\n\nresetSunPanelPwd() {\n  local exepath=\"${installpath}/serv00-play/sunpanel/sun-panel\"\n  if [[ ! -e $exepath ]]; then\n    echo \"未安装，请先安装!\"\n    return\n  fi\n  read -p \"确定初始化密码? [y/n][n]:\" input\n  input=${input:-n}\n\n  if [[ \"$input\" == \"y\" ]]; then\n    local workdir=\"${installpath}/serv00-play/sunpanel\"\n    cd $workdir\n    ./sun-panel -password-reset\n  fi\n\n}\n\nstopSunPanel() {\n  stopProc \"sun-panel\"\n  if checkProcAlive \"sun-panel\"; then\n    echo \"未能停止，请手动杀进程!\"\n  fi\n\n}\n\ninstallSunPanel() {\n  local workdir=\"${installpath}/serv00-play/sunpanel\"\n  local exepath=\"${installpath}/serv00-play/sunpanel/sun-panel\"\n  if [[ -e $exepath ]]; then\n    echo \"已安装，请勿重复安装!\"\n    return\n  fi\n  mkdir -p $workdir\n  cd $workdir\n\n  if ! checkDownload \"sun-panel\"; then\n    return 1\n  fi\n  if ! checkDownload \"panelweb\" 1; then\n    return 1\n  fi\n\n  if [[ ! -e \"sun-panel\" ]]; then\n    echo \"下载文件解压失败！\"\n    return 1\n  fi\n  #初始化密码，并且生成相关目录文件\n  ./sun-panel -password-reset\n\n  if [[ ! -e \"conf/conf.ini\" ]]; then\n    echo \"无配置文件生成!\"\n    return 1\n  fi\n\n  loadPort\n  port=\"\"\n  randomPort \"tcp\" \"sun-panel\"\n  if [ -n \"$port\" ]; then\n    sunPanelPort=$port\n  else\n    echo \"未输入端口!\"\n    return 1\n  fi\n  cd conf\n  sed -i.bak -E \"s/^http_port=[0-9]+$/http_port=${sunPanelPort}/\" conf.ini\n  cd ..\n\n  domain=\"\"\n  webIp=\"\"\n  if ! makeWWW panel $sunPanelPort; then\n    echo \"绑定域名失败!\"\n    return 1\n  fi\n  # 自定义域名时申请证书的webip可以从2个ip中选择\n  if [ $is_self_domain -eq 1 ]; then\n    if ! applyLE $domain $webIp; then\n      echo \"申请证书失败!\"\n      return 1\n    fi\n  else # 没有自定义域名时，webip是内置固定的，就是web(x).serv00.com\n    if ! applyLE $domain; then\n      echo \"申请证书失败!\"\n      return 1\n    fi\n  fi\n  green \"安装完毕!\"\n\n}\n\nmakeWWW() {\n  local proc=$1\n  local port=$2\n  local www_type=${3:-\"proxy\"}\n\n  echo \"正在处理服务IP,请等待...\"\n  is_self_domain=0\n  webIp=$(get_webip)\n  default_webip=$(get_default_webip)\n  green \"可用webip是: $webIp, 默认webip是: $default_webip\"\n  read -p \"是否使用自定义域名? [y/n] [n]:\" input\n  input=${input:-n}\n  if [[ \"$input\" == \"y\" ]]; then\n    is_self_domain=1\n    read -p \"请输入域名(确保此前域名已指向webip):\" domain\n  else\n    user=\"$(whoami)\"\n    if isServ00; then\n      domain=\"${proc}.$user.serv00.net\"\n    else\n      domain=\"$proc.$user.ct8.pl\"\n    fi\n  fi\n\n  if [[ -z \"$domain\" ]]; then\n    red \"输入无效域名!\"\n    return 1\n  fi\n\n  domain=${domain,,}\n  echo \"正在绑定域名,请等待...\"\n  if [[ \"$www_type\" == \"proxy\" ]]; then\n    resp=$(devil www add $domain proxy localhost $port)\n  else\n    resp=$(devil www add $domain php)\n  fi\n  #echo \"resp:$resp\"\n  if [[ ! \"$resp\" =~ .*succesfully.*$ && ! \"$resp\" =~ .*Ok.*$ ]]; then\n    if [[ ! \"$resp\" =~ \"This domain already exists\" ]]; then\n      red \"申请域名$domain 失败！\"\n      return 1\n    fi\n  fi\n\n  # 自定义域名的特殊处理\n  if [[ $is_self_domain -eq 1 ]]; then\n    host=\"$(hostname | cut -d '.' -f 1)\"\n    sno=${host/s/web}\n    default_webIp=$(devil vhost list public | grep \"$sno\" | awk '{print $1}')\n    rid=$(devil dns list \"$domain\" | grep \"$default_webIp\" | awk '{print $1}')\n    resp=$(echo \"y\" | devil dns del \"$domain\" $rid)\n    #echo \"resp:$resp\"\n  else\n    webIp=$(get_default_webip)\n  fi\n  # 保存信息\n  if [[ \"$www_type\" == \"proxy\" ]]; then\n    cat >config.json <<EOF\n  {\n     \"webip\": \"$webIp\",\n     \"domain\": \"$domain\",\n     \"port\": \"$port\"\n  }\nEOF\n  fi\n\n  green \"域名绑定成功,你的域名是:$domain\"\n  green \"你的webip是:$webIp\"\n}\n\nstartSunPanel() {\n  local workdir=\"${installpath}/serv00-play/sunpanel\"\n  local exepath=\"${installpath}/serv00-play/sunpanel/sun-panel\"\n  if [[ ! -e $exepath ]]; then\n    red \"未安装，请先安装!\"\n    return\n  fi\n  cd $workdir\n  if checkProcAlive \"sun-panel\"; then\n    stopProc \"sun-panel\"\n  fi\n  read -p \"是否需要日志($workdir/running.log)? [y/n] [n]:\" input\n  input=${input:-n}\n  local args=\"\"\n  if [[ \"$input\" == \"y\" ]]; then\n    args=\" > running.log 2>&1 \"\n  else\n    args=\" > /dev/null 2>&1 \"\n  fi\n  cmd=\"nohup ./sun-panel $args &\"\n  eval \"$cmd\"\n  sleep 1\n  if checkProcAlive \"sun-panel\"; then\n    green \"启动成功\"\n  else\n    red \"启动失败\"\n  fi\n\n}\n\nburnAfterReadingServ() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  while true; do\n    yellow \"---------------------\"\n    echo \"1. 安装\"\n    echo \"2. 卸载\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"---------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      installBurnReading\n      ;;\n    2)\n      uninstallBurnReading\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\ninstallBurnReading() {\n  local workdir=\"${installpath}/serv00-play/burnreading\"\n\n  if [[ ! -e \"$workdir\" ]]; then\n    mkdir -p $workdir\n  fi\n  cd $workdir\n\n  if ! check_domains_empty; then\n    red \"已有安装如下服务，是否继续安装?\"\n    print_domains\n    read -p \"继续安装? [y/n] [n]:\" input\n    input=${input:-n}\n    if [[ \"$input\" == \"n\" ]]; then\n      return 0\n    fi\n  fi\n\n  domain=\"\"\n  webIp=\"\"\n  if ! makeWWW burnreading \"null\" php; then\n    echo \"绑定域名失败!\"\n    return 1\n  fi\n\n  domainPath=\"$installpath/domains/$domain/public_html\"\n  cd $domainPath\n  echo \"正在下载并安装 OneTimeMessagePHP ...\"\n  if ! download_from_github_release frankiejun OneTimeMessagePHP OneTimeMessagePHP; then\n    red \"下载失败!\"\n    return 1\n  fi\n  passwd=$(uuidgen -r)\n  sed -i '' -e \"s/^ENCRYPTION_KEY=.*/ENCRYPTION_KEY=\\\"$passwd\\\"/\" \\\n    -e \"s|^SITE_DOMAIN=.*|SITE_DOMAIN=\\\"$domain\\\"|\" \"env\"\n  mv env .env\n  echo \"已更新配置文件!\"\n\n  read -p \"是否申请证书? [y/n] [n]:\" input\n  input=${input:-'n'}\n  if [[ \"$input\" == \"y\" ]]; then\n    echo \"正在申请证书，请等待...\"\n    if ! applyLE $domain $webIp; then\n      echo \"申请证书失败!\"\n      return 1\n    fi\n  fi\n  cd $workdir\n  add_domain $domain $webIp\n\n  echo \"安装完成!\"\n}\n\nuninstallBurnReading() {\n  local workdir=\"${installpath}/serv00-play/burnreading\"\n\n  if [[ ! -e \"$workdir\" ]]; then\n    echo \"已没有可以卸载的服务!\"\n    return 1\n  fi\n\n  cd $workdir\n\n  if ! check_domains_empty; then\n    echo \"目前已安装服务的域名有:\"\n    print_domains\n  fi\n  read -p \"是否删除所有域名服务? [y/n] [n]:\" input\n  input=${input:-n}\n  if [[ \"$input\" == \"y\" ]]; then\n    delete_all_domains\n    rm -rf \"${installpath}/serv00-play/burnreading\"\n  else\n    read -p \"请输入要删除的服务的域名:\" domain\n    delete_domain \"$domain\"\n  fi\n\n}\n\nwebsshServ() {\n  if ! checkInstalled \"serv00-play\"; then\n    return 1\n  fi\n  while true; do\n    yellow \"---------------------\"\n    echo \"webssh:\"\n    echo \"服务状态: $(checkProcStatus wssh)\"\n    echo \"1. 安装/修改配置\"\n    echo \"2. 启动\"\n    echo \"3. 停止\"\n    echo \"8. 卸载\"\n    echo \"9. 返回主菜单\"\n    echo \"0. 退出脚本\"\n    yellow \"---------------------\"\n    read -p \"请选择:\" input\n\n    case $input in\n    1)\n      installWebSSH\n      ;;\n    2)\n      startWebSSH\n      ;;\n    3)\n      stopWebSSH\n      ;;\n    8)\n      uninstallWebSSH\n      ;;\n    9)\n      break\n      ;;\n    0)\n      exit 0\n      ;;\n    *)\n      echo \"无效选项，请重试\"\n      ;;\n    esac\n  done\n  showMenu\n}\n\nuninstallWebSSH() {\n  local workdir=\"${installpath}/serv00-play/webssh\"\n  uninstallProc \"$workdir\" \"wssh\"\n}\n\ninstallWebSSH() {\n  local workdir=\"${installpath}/serv00-play/webssh\"\n  if [[ ! -e \"$workdir\" ]]; then\n    mkdir -p $workdir\n  fi\n  cd $workdir\n  configfile=\"./config.json\"\n  local is_installed=0\n  if [ -e \"$configfile\" ]; then\n    is_installed=1\n    echo \"已安装，配置如下:\"\n    cat $configfile\n\n    read -p \"是否修改配置? [y/n] [n]:\" input\n    input=${input:-n}\n    if [[ \"$input\" == \"n\" ]]; then\n      return\n    fi\n  fi\n\n  port=\"\"\n  loadPort\n  randomPort tcp \"webssh\"\n  if [ -n \"$port\" ]; then\n    websshPort=$port\n  else\n    echo \"未输入端口!\"\n    return 1\n  fi\n\n  #   cat > $configfile <<EOF\n  #   {\n  #     \"port\": $websshPort\n  #   }\n  # EOF\n\n  if [[ $is_installed -eq 0 ]]; then\n    echo \"正在安装webssh...\"\n    pip install webssh\n  fi\n\n  user=\"$(whoami)\"\n  target_path=\"/home/$user/.local/bin\"\n  wsshpath=\"$target_path/wssh\"\n  if [[ ! -e \"$wsshpath\" ]]; then\n    red \"安装webssh失败 !\"\n    return 1\n  fi\n  cp $wsshpath $workdir\n  profile=\"${installpath}/.profile\"\n\n  if ! grep -q \"export PATH=.*$target_path\" \"$profile\"; then\n    echo \"export PATH=$target_path:\\$PATH\" >>\"$profile\"\n    source $profile\n  fi\n  domain=\"\"\n  webIp=\"\"\n  if ! makeWWW ssh $websshPort; then\n    echo \"绑定域名失败!\"\n    return 1\n  fi\n  if ! applyLE $domain $webIp; then\n    echo \"申请证书失败!\"\n    return 1\n  fi\n  echo \"安装完成!\"\n\n}\n\nstopWebSSH() {\n  stopProc \"wssh\"\n  sleep 2\n  if ! checkProcAlive \"wssh\"; then\n    echo \"wssh已停止！\"\n  else\n    echo \"未能停止，请手动杀进程!\"\n  fi\n}\n\nstartWebSSH() {\n  local workdir=\"${installpath}/serv00-play/webssh\"\n  local configfile=\"$workdir/config.json\"\n  if [ ! -e \"$configfile\" ]; then\n    echo \"未安装，请先安装!\"\n    return\n  fi\n  cd $workdir\n  read -p \"是否需要日志($workdir/running.log)? [y/n] [n]:\" input\n  input=${input:-n}\n  args=\"\"\n  if [[ \"$input\" == \"y\" ]]; then\n    args=\" > running.log 2>&1 \"\n  else\n    args=\" > /dev/null 2>&1 \"\n  fi\n  port=$(jq -r \".port\" $configfile)\n  if checkProcAlive \"wssh\"; then\n    stopProc \"wssh\"\n  fi\n  echo \"正在启动中...\"\n  cmd=\"nohup ./wssh --port=$port --fbidhttp=False --xheaders=False --encoding='utf-8' --delay=10  $args &\"\n  eval \"$cmd\"\n  sleep 2\n  if checkProcAlive wssh; then\n    green \"启动成功！\"\n  else\n    echo \"启动失败!\"\n  fi\n}\n\nnonServ() {\n  cat <<EOF\n   占坑位，未开发功能，敬请期待！\n   如果你知道有好的项目，可以到我的频道进行留言投稿，\n   我会分析可行性，择优取录，所以你喜欢的项目有可能会集成到serv00-play的项目中。\n   留言板：https://t.me/fanyou_channel/40\nEOF\n}\n\ncheckInstalled() {\n  local model=$1\n  if [[ \"$model\" == \"serv00-play\" ]]; then\n    if [[ ! -d \"${installpath}/$model\" ]]; then\n      red \"请先安装$model !!!\"\n      return 1\n    else\n      return 0\n    fi\n  else\n    if [[ ! -d \"${installpath}/serv00-play/$model\" ]]; then\n      red \"请先安装$model !!!\"\n      return 1\n    else\n      return 0\n    fi\n  fi\n  return 1\n}\n\nchangeHy2IP() {\n  read -p \"是否让程序为HY2选择可用的IP？[y/n] [y]:\" input\n  input=${input:-y}\n\n  if [[ \"$input\" == \"y\" ]]; then\n    cd ${installpath}/serv00-play/singbox\n    if [[ ! -e \"singbox.json\" || ! -e \"config.json\" ]]; then\n      red \"未安装节点，请先安装!\"\n      return 1\n    fi\n    hy2_ip=$(get_ip)\n    if [[ -z \"hy2_ip\" ]]; then\n      red \"很遗憾，已无可用IP!\"\n      return 1\n    fi\n    if ! upInsertFd singbox.json HY2IP \"$hy2_ip\"; then\n      red \"更新singbox.json配置文件失败!\"\n      return 1\n    fi\n\n    if ! upSingboxFd config.json \"inbounds\" \"tag\" \"hysteria-in\" \"listen\" \"$hy2_ip\"; then\n      red \"更新config.json配置文件失败!\"\n      return 1\n    fi\n    green \"HY2 更换IP成功，当前IP为 $hy2_ip\"\n\n    echo \"正在重启sing-box...\"\n    stopSingBox\n    startSingBox\n  fi\n\n}\n\nshowMenu() {\n  art_wrod=$(figlet \"serv00-play\")\n  echo \"<------------------------------------------------------------------>\"\n  echo -e \"${CYAN}${art_wrod}${RESET}\"\n  echo -e \"${GREEN} 饭奇骏频道:https://www.youtube.com/@frankiejun8965 ${RESET}\"\n  echo -e \"${GREEN} TG交流群:https://t.me/fanyousuiqun ${RESET}\"\n  echo \"<------------------------------------------------------------------>\"\n  echo \"请选择一个选项:\"\n\n  options=(\"安装/更新serv00-play项目\" \"sun-panel\" \"webssh\" \"阅后即焚\" \"待开发\" \"设置保活的项目\" \"配置sing-box\"\n    \"运行sing-box\" \"停止sing-box\" \"显示sing-box节点信息\" \"快照恢复\" \"系统初始化\" \"前置工作及设置中国时区\" \"管理哪吒探针\" \"卸载探针\" \"设置彩色开机字样\" \"显示本机IP\"\n    \"mtproto代理\" \"alist管理\" \"端口管理\" \"域名证书管理\" \"一键root\" \"自动检测主机IP状态\" \"一键更换hy2的IP\" \"卸载\")\n\n  select opt in \"${options[@]}\"; do\n    case $REPLY in\n    1)\n      install\n      ;;\n    2)\n      sunPanelServ\n      ;;\n    3)\n      websshServ\n      ;;\n    4)\n      burnAfterReadingServ\n      ;;\n    5)\n      nonServ\n      ;;\n    6)\n      setConfig\n      ;;\n    7)\n      configSingBox\n      ;;\n    8)\n      startSingBox\n      ;;\n    9)\n      stopSingBox\n      ;;\n    10)\n      showSingBoxInfo\n      ;;\n    11)\n      ImageRecovery\n      ;;\n    12)\n      InitServer\n      ;;\n    13)\n      setCnTimeZone\n      ;;\n    14)\n      manageNeZhaAgent\n      ;;\n    15)\n      uninstallAgent\n      ;;\n    16)\n      setColorWord\n      ;;\n    17)\n      showIP\n      ;;\n    18)\n      mtprotoServ\n      ;;\n    19)\n      alistServ\n      ;;\n    20)\n      portServ\n      ;;\n    21)\n      domainSSLServ\n      ;;\n    22)\n      rootServ\n      ;;\n    23)\n      getUnblockIP\n      ;;\n    24)\n      changeHy2IP\n      ;;\n    25)\n      uninstall\n      ;;\n    0)\n      echo \"退出\"\n      exit 0\n      ;;\n    *)\n      echo \"无效的选项 \"\n      ;;\n    esac\n\n  done\n\n}\n\nshowMenu\n"
        },
        {
          "name": "tgsend.sh",
          "type": "blob",
          "size": 3.2783203125,
          "content": "#!/bin/bash\n\nmessage_text=$1\n\nreplaceValue() {\n  local url=$1\n  local target=$2\n  local value=$3\n  local result\n  result=$(printf '%s' \"$url\" | sed \"s|#${target}|${value//&/\\\\&}|g\")\n  echo \"$result\"\n}\n\ntoBase64() {\n  echo -n \"$1\" | base64\n}\n\nurlencode() {\n  local input=\"$1\"\n  local output=\"\"\n  local length=${#input}\n  for ((i = 0; i < length; i++)); do\n    local char=\"${input:i:1}\"\n    case \"$char\" in\n    [a-zA-Z0-9.~_-]) output+=\"$char\" ;;\n    *) output+=\"$(printf '%%%02X' \"'$char\")\" ;;\n    esac\n  done\n  echo \"$output\"\n}\n\ntoTGMsg() {\n  local msg=$1\n  local title=\"*Serv00-play通知*\"\n  local host_icon=\"🖥️\"\n  local user_icon=\"👤\"\n  local time_icon=\"⏰\"\n  local notify_icon=\"📢\"\n\n  # 获取当前时间\n  local current_time=$(date \"+%Y-%m-%d %H:%M:%S\")\n\n  if [[ \"$msg\" != Host:* ]]; then\n    local formatted_msg=\"${title}  \\n\\n\"\n    formatted_msg+=\"${time_icon} *时间：* ${current_time}  \\n\"\n    formatted_msg+=\"${notify_icon} *通知内容：*    \\n$msg  \\n\\n\"\n    echo -e \"$formatted_msg\"\n    return\n  fi\n\n  local host=$(echo \"$msg\" | sed -n 's/.*Host:\\([^,]*\\).*/\\1/p' | xargs)\n  local user=$(echo \"$msg\" | sed -n 's/.*user:\\([^,]*\\).*/\\1/p' | xargs)\n  local notify_content=$(echo \"$msg\" | sed -E 's/.*user:[^,]*,//' | xargs)\n\n  # 格式化消息内容，Markdown 换行使用两个空格 + 换行\n  local formatted_msg=\"${title}  \\n\\n\"\n  formatted_msg+=\"${host_icon} *主机：* ${host}  \\n\"\n  formatted_msg+=\"${user_icon} *用户：* ${user}  \\n\"\n  formatted_msg+=\"${time_icon} *时间：* ${current_time}  \\n\\n\"\n  formatted_msg+=\"${notify_icon} *通知内容：* ${notify_content}  \\n\\n\"\n\n  echo -e \"$formatted_msg|${host}|${user}\" # 使用 -e 选项以确保换行符生效\n}\n\ntelegramBotToken=${TELEGRAM_TOKEN}\ntelegramBotUserId=${TELEGRAM_USERID}\nresult=$(toTGMsg \"$message_text\")\nformatted_msg=$(echo \"$result\" | awk -F'|' '{print $1}')\nhost=$(echo \"$result\" | awk -F'|' '{print $2}')\nuser=$(echo \"$result\" | awk -F'|' '{print $3}')\n\nif [[ \"$BUTTON_URL\" == \"null\" ]]; then\n  button_url=\"https://www.youtube.com/@frankiejun8965\"\nelse\n  button_url=${BUTTON_URL:-\"https://www.youtube.com/@frankiejun8965\"}\nfi\n\nURL=\"https://api.telegram.org/bot${telegramBotToken}/sendMessage\"\n\nif [[ -n \"$PASS\" ]]; then\n  pass=$(toBase64 $PASS)\n  button_url=$(replaceValue $button_url HOST $host)\n  button_url=$(replaceValue $button_url USER $user)\n  button_url=$(replaceValue $button_url PASS $pass)\nfi\nencoded_url=$(urlencode \"$button_url\")\n#echo \"encoded_url: $encoded_url\"\nreply_markup='{\n    \"inline_keyboard\": [\n      [\n        {\"text\": \"点击查看\", \"url\": \"'\"${encoded_url}\"'\"}\n      ]\n    ]\n  }'\n#echo \"reply_markup: $reply_markup\"\n#echo \"telegramBotToken:$telegramBotToken,telegramBotUserId:$telegramBotUserId\"\nif [[ -z ${telegramBotToken} ]]; then\n  echo \"未配置TG推送\"\nelse\n  res=$(curl -s -X POST \"https://api.telegram.org/bot${telegramBotToken}/sendMessage\" \\\n    -d chat_id=\"${telegramBotUserId}\" \\\n    -d parse_mode=\"Markdown\" \\\n    -d text=\"$formatted_msg\" \\\n    -d reply_markup=\"$reply_markup\")\n  if [ $? == 124 ]; then\n    echo 'TG_api请求超时,请检查网络是否重启完成并是否能够访问TG'\n    exit 1\n  fi\n  #echo \"res:$res\"\n  resSuccess=$(echo \"$res\" | jq -r \".ok\")\n  if [[ $resSuccess = \"true\" ]]; then\n    echo \"TG推送成功\"\n  else\n    echo \"TG推送失败，请检查TG机器人token和ID\"\n  fi\nfi\n"
        },
        {
          "name": "utils.sh",
          "type": "blob",
          "size": 13.1923828125,
          "content": "#!/bin/bash\n\nRED='\\033[0;91m'\nGREEN='\\033[0;92m'\nYELLOW='\\033[0;33m'\nBLUE='\\033[0;34m'\nMAGENTA='\\033[0;35m'\nCYAN='\\033[0;96m'\nWHITE='\\033[0;37m'\nRESET='\\033[0m'\nyellow() {\n  echo -e \"${YELLOW}$1${RESET}\"\n}\ngreen() {\n  echo -e \"${GREEN}$1${RESET}\"\n}\nred() {\n  echo -e \"${RED}$1${RESET}\"\n}\ninstallpath=\"$HOME\"\n\nchecknezhaAgentAlive() {\n  if ps aux | grep nezha-agent | grep -v \"grep\" >/dev/null; then\n    return 0\n  else\n    return 1\n  fi\n}\n\ncheckvmessAlive() {\n  local c=0\n  if ps aux | grep serv00sb | grep -v \"grep\" >/dev/null; then\n    ((c++))\n  fi\n\n  if ps aux | grep cloudflared | grep -v \"grep\" >/dev/null; then\n    ((c++))\n  fi\n\n  if [ $c -eq 2 ]; then\n    return 0\n  fi\n\n  return 1 # 有一个或多个进程不在运行\n\n}\n\n#返回0表示成功， 1表示失败\n#在if条件中，0会执行，1不会执行\ncheckProcAlive() {\n  local procname=$1\n  if ps aux | grep \"$procname\" | grep -v \"grep\" >/dev/null; then\n    return 0\n  else\n    return 1\n  fi\n}\n\nstopProc() {\n  local procname=$1\n  r=$(ps aux | grep \"$procname\" | grep -v \"grep\" | awk '{print $2}')\n  if [ -z \"$r\" ]; then\n    return 0\n  else\n    kill -9 $r\n  fi\n  echo \"已停掉$procname!\"\n}\n\ncheckSingboxAlive() {\n  local c=0\n  if ps aux | grep serv00sb | grep -v \"grep\" >/dev/null; then\n    ((c++))\n  fi\n\n  if ps aux | grep cloudflare | grep -v \"grep\" >/dev/null; then\n    ((c++))\n  fi\n\n  if [ $c -eq 2 ]; then\n    return 0\n  fi\n\n  return 1 # 有一个或多个进程不在运行\n\n}\n\ncheckMtgAlive() {\n  if ps aux | grep mtg | grep -v \"grep\" >/dev/null; then\n    return 0\n  else\n    return 1\n  fi\n}\n\nstopNeZhaAgent() {\n  r=$(ps aux | grep nezha-agent | grep -v \"grep\" | awk '{print $2}')\n  if [ -z \"$r\" ]; then\n    return 0\n  else\n    kill -9 $r\n  fi\n  echo \"已停掉nezha-agent!\"\n}\n\nwriteWX() {\n  has_fd=$(echo \"$config_content\" | jq 'has(\"wxsendkey\")')\n  if [ \"$has_fd\" == \"true\" ]; then\n    wx_sendkey=$(echo \"$config_content\" | jq -r \".wxsendkey\")\n    read -p \"已有 WXSENDKEY ($wx_sendkey), 是否修改? [y/n] [n]:\" input\n    input=${input:-n}\n    if [ \"$input\" == \"y\" ]; then\n      read -p \"请输入 WXSENDKEY:\" wx_sendkey\n    fi\n    json_content+=\"  \\\"wxsendkey\\\": \\\"${wx_sendkey}\\\", \\n\"\n  else\n    read -p \"请输入 WXSENDKEY:\" wx_sendkey\n    json_content+=\"  \\\"wxsendkey\\\": \\\"${wx_sendkey}\\\", \\n\"\n  fi\n\n}\n\nwriteTG() {\n  has_fd=$(echo \"$config_content\" | jq 'has(\"telegram_token\")')\n  if [ \"$has_fd\" == \"true\" ]; then\n    tg_token=$(echo \"$config_content\" | jq -r \".telegram_token\")\n    read -p \"已有 TELEGRAM_TOKEN ($tg_token), 是否修改? [y/n] [n]:\" input\n    input=${input:-n}\n    if [ \"$input\" == \"y\" ]; then\n      read -p \"请输入 TELEGRAM_TOKEN:\" tg_token\n    fi\n    json_content+=\"  \\\"telegram_token\\\": \\\"${tg_token}\\\", \\n\"\n  else\n    read -p \"请输入 TELEGRAM_TOKEN:\" tg_token\n    json_content+=\"  \\\"telegram_token\\\": \\\"${tg_token}\\\", \\n\"\n  fi\n\n  has_fd=$(echo \"$config_content\" | jq 'has(\"telegram_userid\")')\n  if [ \"$has_fd\" == \"true\" ]; then\n    tg_userid=$(echo \"$config_content\" | jq -r \".telegram_userid\")\n    read -p \"已有 TELEGRAM_USERID ($tg_userid), 是否修改? [y/n] [n]:\" input\n    input=${input:-n}\n    if [ \"$input\" == \"y\" ]; then\n      read -p \"请输入 TELEGRAM_USERID:\" tg_userid\n    fi\n    json_content+=\"  \\\"telegram_userid\\\": \\\"${tg_userid}\\\", \\n\"\n  else\n    read -p \"请输入 TELEGRAM_USERID:\" tg_userid\n    json_content+=\"  \\\"telegram_userid\\\": \\\"${tg_userid}\\\",\\n\"\n  fi\n}\n\ncleanCron() {\n  echo \"\" >null\n  crontab null\n  rm null\n}\n\ndelCron() {\n  crontab -l | grep -v \"keepalive\" >mycron\n  crontab mycron >/dev/null 2>&1\n  rm mycron\n}\n\naddCron() {\n  local tm=$1\n  crontab -l | grep -v \"keepalive\" >mycron\n  echo \"*/$tm * * * * bash ${installpath}/serv00-play/keepalive.sh > /dev/null 2>&1 \" >>mycron\n  crontab mycron >/dev/null 2>&1\n  rm mycron\n\n}\n\nget_webip() {\n  # 获取主机名称，例如：s2.serv00.com\n  local hostname=$(hostname)\n\n  # 提取主机名称中的数字，例如：2\n  local host_number=$(echo \"$hostname\" | awk -F'[s.]' '{print $2}')\n\n  # 构造主机名称的数组\n  local hosts=(\"web${host_number}.serv00.com\" \"cache${host_number}.serv00.com\")\n\n  # 初始化最终 IP 变量\n  local final_ip=\"\"\n\n  # 遍历主机名称数组\n  for host in \"${hosts[@]}\"; do\n    # 获取 API 返回的数据\n    local response=$(curl -s \"https://ss.botai.us.kg/api/getip?host=$host\")\n\n    # 检查返回的结果是否包含 \"not found\"\n    if [[ \"$response\" =~ \"not found\" ]]; then\n      continue\n    fi\n\n    # 提取第一个字段作为 IP，并检查第二个字段是否为 \"Accessible\"\n    local ip=$(echo \"$response\" | awk -F \"|\" '{ if ($2 == \"Accessible\") print $1 }')\n    # webxx.serv00.com域名对应的ip作为兜底ip\n    if [[ \"$host\" == \"web${host_number}.serv00.com\" ]]; then\n      final_ip=$(echo \"$response\" | awk -F \"|\" '{print $1}')\n    fi\n\n    # 如果找到了 \"Accessible\"，返回 IP\n    if [[ -n \"$ip\" ]]; then\n      echo \"$ip\"\n      return\n    fi\n  done\n\n  echo \"$final_ip\"\n}\n\nget_ip() {\n  # 获取主机名称，例如：s2.serv00.com\n  local hostname=$(hostname)\n\n  # 提取主机名称中的数字，例如：2\n  local host_number=$(echo \"$hostname\" | awk -F'[s.]' '{print $2}')\n\n  # 构造主机名称的数组\n  local hosts=(\"cache${host_number}.serv00.com\" \"web${host_number}.serv00.com\" \"$hostname\")\n\n  # 初始化最终 IP 变量\n  local final_ip=\"\"\n\n  # 遍历主机名称数组\n  for host in \"${hosts[@]}\"; do\n    # 获取 API 返回的数据\n    local response=$(curl -s \"https://ss.botai.us.kg/api/getip?host=$host\")\n\n    # 检查返回的结果是否包含 \"not found\"\n    if [[ \"$response\" =~ \"not found\" ]]; then\n      continue\n    fi\n\n    # 提取第一个字段作为 IP，并检查第二个字段是否为 \"Accessible\"\n    local ip=$(echo \"$response\" | awk -F \"|\" '{ if ($2 == \"Accessible\") print $1 }')\n\n    # 如果找到了 \"Accessible\"，返回 IP\n    if [[ -n \"$ip\" ]]; then\n      echo \"$ip\"\n      return\n    fi\n\n    final_ip=$ip\n  done\n\n  echo \"$final_ip\"\n}\n\nisServ00() {\n  [[ $(hostname) == *\"serv00\"* ]]\n}\n\n#获取端口\ngetPort() {\n  local type=$1\n  local opts=$2\n\n  local key=\"$type|$opts\"\n  #echo \"key: $key\"\n  #port list中查找，如果没有随机分配一个\n  if [[ -n \"${port_array[\"$key\"]}\" ]]; then\n    #echo \"找到list中的port\"\n    echo \"${port_array[\"$key\"]}\"\n  else\n    # echo \"devil port add $type random $opts\"\n    rt=$(devil port add $type random $opts)\n    if [[ \"$rt\" =~ .*succesfully.*$ || \"$rt\" =~ .*Ok.*$ ]]; then\n      loadPort\n      if [[ -n \"$port_array[\"$key\"]\" ]]; then\n        echo \"${port_array[\"$key\"]}\"\n      else\n        echo \"failed\"\n      fi\n    else\n      echo \"failed\"\n    fi\n  fi\n}\n\nrandomPort() {\n  local type=$1\n  local opts=$2\n  port=\"\"\n  #echo \"type:$type, opts:$opts\"\n  read -p \"是否自动分配${opts}端口($type)？[y/n] [y]:\" input\n  input=${input:-y}\n  if [[ \"$input\" == \"y\" ]]; then\n    port=$(getPort $type $opts)\n    if [[ \"$port\" == \"failed\" ]]; then\n      read -p \"自动分配端口失败，请手动输入${opts}端口:\" port\n    else\n      green \"自动分配${opts}端口为:${port}\"\n    fi\n  else\n    read -p \"请输入${opts}端口($type):\" port\n  fi\n}\n\ndeclare -A port_array\n#检查是否可以自动分配端口\nloadPort() {\n  output=$(devil port list)\n\n  port_array=()\n  # 解析输出内容\n  index=0\n  while read -r port typ opis; do\n    # 跳过标题行\n    if [[ \"$port\" =~ \"Port\" ]]; then\n      continue\n    fi\n    #echo \"port:$port,typ:$typ, opis:$opis\"\n    if [[ \"$port\" =~ \"Brak\" || \"$port\" == \"No\" ]]; then\n      echo \"未分配端口\"\n      return 0\n    fi\n    # 将 Typ 和 Opis 合并并存储到数组中\n    if [[ -n \"$typ\" ]]; then\n      # 如果 Opis 为空则用空字符串代替\n      opis=${opis:-\"\"}\n      combined=\"${typ}|${opis}\"\n      port_array[\"$combined\"]=\"$port\"\n      # echo \"port_array 读入 key=$combined, value=$port\"\n      ((index++))\n    fi\n  done <<<\"$output\"\n\n  return 0\n}\n\ncleanPort() {\n  output=$(devil port list)\n  while read -r port typ opis; do\n    # 跳过标题行\n    if [[ \"$typ\" == \"Type\" ]]; then\n      continue\n    fi\n    if [[ \"$port\" == \"Brak\" || \"$port\" == \"No\" ]]; then\n      return 0\n    fi\n    if [[ -n \"$typ\" ]]; then\n      devil port del $typ $port >/dev/null 2>&1\n    fi\n  done <<<\"$output\"\n  return 0\n}\n\ncheckDownload() {\n  local file=$1\n  local filegz=\"$file.gz\"\n  local is_dir=${2:-0}\n\n  if [[ $is_dir -eq 1 ]]; then\n    filegz=\"$file.tar.gz\"\n  fi\n\n  #检查并下载核心程序\n  if [[ ! -e $file ]] || [[ $(file $file) == *\"text\"* ]]; then\n    echo \"正在下载 $file...\"\n    url=\"https://gfg.fkj.pp.ua/app/serv00/$filegz?pwd=fkjyyds666\"\n    curl -L -sS --max-time 20 -o $filegz \"$url\"\n\n    if file $filegz | grep -q \"text\"; then\n      echo \"无法正确下载!!!\"\n      rm -f $filegz\n      return 1\n    fi\n    if [ -e $filegz ]; then\n      if [[ $is_dir -eq 1 ]]; then\n        tar -zxf $filegz\n      else\n        gzip -d $filegz\n      fi\n    else\n      echo \"下载失败，可能是网络问题.\"\n      return 1\n    fi\n    #下载失败\n    if [[ $is_dir -eq 0 && ! -e $file ]]; then\n      echo \"无法下载核心程序，可能网络问题，请检查！\"\n      return 1\n    fi\n    # 设置可执行权限\n    if [[ $is_dir -eq 0 ]]; then\n      chmod +x \"$file\"\n    fi\n    echo \"下载完毕!\"\n  fi\n  return 0\n}\n\n# 对json文件字段进行插入或修改\n# usage: upInsertFd jsonfile fieldname value\nupInsertFd() {\n  local jsonfile=$1\n  local field=$2\n  local value=$3\n\n  jq --arg field \"$field\" --arg value \"$value\" '\n        if has($field) then \n                .[$field] = $value\n        else \n                . + {($field): $value}\n        end\n        ' \"$jsonfile\" >tmp.json && mv tmp.json \"$jsonfile\"\n\n  return $?\n}\n\n# 针对singbox.json, 对指定字段进行修改\nupSingboxFd() {\n  local jsonfile=$1\n  local array_name=$2\n  local selector_key=$3\n  local selector_value=$4\n  local field_path=$5\n  local value=$6\n\n  jq --arg selector_key \"$selector_key\" \\\n    --arg selector_value \"$selector_value\" \\\n    --arg field_path \"$field_path\" \\\n    --arg value \"$value\" \"\n         (.$array_name[] | select(.$selector_key == \\$selector_value) | .[\\$field_path]) = \\$value\n     \" \"$jsonfile\" >tmp.json && mv tmp.json \"$jsonfile\"\n\n  return $?\n}\n\n# php默认配置文件操作\nPHPCONFIG_FILE=\"phpconfig.json\"\n# 判断JSON文件是否存在，若不存在则创建并初始化\ninitialize_json() {\n  if [ ! -f \"$PHPCONFIG_FILE\" ]; then\n    echo '{\"domains\": []}' >\"$PHPCONFIG_FILE\"\n  fi\n}\n\n# 添加新域名\nadd_domain() {\n  local new_domain=\"$1\"\n  local webip=\"$2\"\n\n  # 初始化JSON文件（如果不存在的话）\n  initialize_json\n\n  # 读取当前的JSON配置文件并检查域名是否已存在\n  if grep -q \"\\\"$new_domain\\\"\" \"$PHPCONFIG_FILE\"; then\n    echo \"域名 '$new_domain' 已存在！\"\n    return 1\n  fi\n\n  # 使用jq来处理JSON，添加新的域名到domains数组\n  #jq --arg domain \"$new_domain\" '.domains += [$domain]' \"$PHPCONFIG_FILE\" >temp.json && mv temp.json \"$PHPCONFIG_FILE\"\n  jq \".domains += [{\\\"domain\\\": \\\"$domain\\\", \\\"webip\\\": \\\"$webip\\\"}]\" \"$PHPCONFIG_FILE\" >\"$PHPCONFIG_FILE.tmp\" && mv \"$PHPCONFIG_FILE.tmp\" \"$PHPCONFIG_FILE\"\n  #echo \"域名 '$new_domain' 添加成功！\"\n  return 0\n}\n\n# 删除域名\ndelete_domain() {\n  local domain_to_delete=\"$1\"\n\n  # 初始化JSON文件（如果不存在的话）\n  initialize_json\n\n  # 读取当前的JSON配置文件并检查域名是否存在\n  if ! grep -q \"\\\"$domain_to_delete\\\"\" \"$PHPCONFIG_FILE\"; then\n    echo \"域名 '$domain_to_delete' 不存在！\"\n    return 1\n  fi\n\n  local webip=$(jq -r \".domains[] | select(.domain == \\\"$domain\\\") | .webip\" \"$PHPCONFIG_FILE\")\n  # 使用jq来处理JSON，删除指定的域名\n  jq \"del(.domains[] | select(.domain == \\\"$domain\\\"))\" \"$PHPCONFIG_FILE\" >\"$PHPCONFIG_FILE.tmp\" && mv \"$PHPCONFIG_FILE.tmp\" \"$PHPCONFIG_FILE\"\n  local domainPath=\"$installpath/domains/$domain\"\n  echo \"正在删除域名相关服务,请等待...\"\n  rm -rf \"$domainPath\"\n  resp=$(devil ssl www del $webip $domain)\n  resp=$(devil www del $domain --remove)\n  echo \"已卸载域名[$domain_to_delete]相关服务!\"\n  return 0\n}\n\n# 判断domains数组是否为空\ncheck_domains_empty() {\n  initialize_json\n\n  local domains_count=$(jq '.domains | length' \"$PHPCONFIG_FILE\")\n\n  if [ \"$domains_count\" -eq 0 ]; then\n    return 0\n  else\n    return 1\n  fi\n}\nprint_domains() {\n  yellow \"----------------------------\"\n  green \"域名\\t\\t|\\t服务IP\"\n  yellow \"----------------------------\"\n\n  # 使用jq格式化输出\n  jq -r '.domains[] | \"\\(.domain)\\t|\\(.webip)\"' \"$PHPCONFIG_FILE\"\n}\n\ndelete_all_domains() {\n  initialize_json\n\n  jq -r '.domains[] | \"\\(.domain)\\t\\(.webip)\"' \"$PHPCONFIG_FILE\" | while read -r domain webip; do\n    echo \"域名: $domain, 服务IP: $webip\"\n    delete_domain \"$domain\"\n  done\n}\n\ndownload_from_github_release() {\n  local user=$1\n  local repository=$2\n  local package=$3\n  local zippackage=\"$package.zip\"\n\n  local url=\"https://github.com/${user}/${repository}\"\n  local latestUrl=\"$url/releases/latest\"\n\n  local latest_version=$(curl -sL $latestUrl | sed -n 's/.*tag\\/\\(v[0-9.]*\\).*/\\1/p' | head -1)\n\n  local download_url=\"${url}/releases/download/$latest_version/$zippackage\"\n  curl -sL -o \"$zippackage\" \"$download_url\"\n  if [[ ! -e \"$zippackage\" || -n $(file \"$zippackage\" | grep \"text\") ]]; then\n    echo \"下载 $zippackage 文件失败!\"\n    return 1\n  fi\n  # 原地解压缩\n  unzip -o \"$zippackage\" -d .\n  if [[ $? -ne 0 ]]; then\n    echo \"解压 $zippackage 文件失败!\"\n    return 1\n  fi\n  rm -rf \"$zippackage\"\n  echo \"下载并解压 $zippackage 成功!\"\n  return 0\n}\n"
        },
        {
          "name": "wxsend.sh",
          "type": "blob",
          "size": 0.5947265625,
          "content": "#!/bin/bash\r\n\r\ntext=$1\r\n\r\nsendKey=${WXSENDKEY}\r\ntitle=\"msg_from_serv00-play\"\r\nURL=\"https://sctapi.ftqq.com/$sendKey.send?\"\r\n\r\nif [[ -z ${sendKey} ]]; then\r\n  echo \"未配置微信推送的sendKey,通过 https://sct.ftqq.com/r/13223 注册并登录server酱，取得sendKey\"\r\nelse\r\n  res=$(timeout 20s curl -s -X POST $URL -d title=${title} -d desp=\"${text}\")\r\n  if [ $? == 124 ]; then\r\n    echo \"发送消息超时\"\r\n    exit 1\r\n  fi\r\n\r\n  err=$(echo \"$res\" | jq -r \".data.error\")\r\n  if [ \"$err\" == \"SUCCESS\" ]; then\r\n    echo \"微信推送成功\"\r\n  else\r\n    echo \"微信推送失败, error:$err\"\r\n  fi\r\nfi\r\n"
        }
      ]
    }
  ]
}