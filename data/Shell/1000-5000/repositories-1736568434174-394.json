{
  "metadata": {
    "timestamp": 1736568434174,
    "page": 394,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "boredazfcuk/docker-icloudpd",
      "stars": 1955,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0166015625,
          "content": "*.sh text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "*.env\n.env\n.bak\n"
        },
        {
          "name": "CONFIGURATION.md",
          "type": "blob",
          "size": 41.443359375,
          "content": "## Environment variables\nEnvironment variables can, for the time being, be used to configure the Docker container. However, configuring containers by using variables is deprecated and will be removed in future versions.\nWhen the container is first started, it will write a default configuration file \"/config/icloudpd.conf\" and the variables will be loaded from there. I you find that some things are still being set, even though you have removed the variables from the container, it could be that they are still located in the configuration file.\n\n## CONFIGURATION OPTIONS\n**apple_id**: This is the Apple ID that will be used when downloading files. This option is mandatory\n\n**user**: This is name of the user account that you wish to create within the container. This can be anything you choose, but ideally you would set this to match the name of the user on the host system for which you want to download files for. This user will be set as the owner of all downloaded files. Default: 'user'. This option is also used as the trigger for remotly initiated sync. Simply send your user name as a message to the Telegram chat, icoudpd will see it, and start a manual sync.\n\n**user_id**: This is the User ID number of the above user account. This can be any number that isn't already in use. Ideally, you should set this to be the same ID number as the user's ID on the host system. This will avoid permissions issues if syncing to your host's home directory. Default: '1000'.\n\n**group**: This is name of the group account that you wish to create within the container. This can be anything you choose, but ideally you would set this to match the name of the user's primary group on the host system. This group will be set as the group for all downloaded files. Default: 'group'.\n\n**group_id**: This is the Group ID number of the above group. This can be any number that isn't already in use. Ideally, you should set this to be the same Group ID number as the user's primary group on the host system. Default: '1000'.\n\n**force_gid**: If this configuration option is set it will allow the group to be created with a pre-existing group id. This may be handy if your group id clashes with a system group insude the docker container, however, if may have undesired permissions issues. Please use with caution.\n\n**TZ**: Sets the local timezone and is required to calculate timestamps. Default: 'UTC'. If you are unsure of your timezone, the list can be found here: https://nodatime.org/TimeZones. The value you need to set is listed in the \"Zone ID\" column of the table.\n\n**download_path**: This is the directory to which files will be downloaded from iCloud. Default: \"/home/${user}/iCloud\".\n\n**synchronisation_interval**: This is the number of seconds between synchronisations. It can be set to the following periods: 21600 (6hrs), 43200 (12hrs), 86400 (24hrs), 129600 (36hrs), 172800 (48hrs) and 604800 (7 days). If this configuration option is not set to one of these values, it will default to 86400 seconds. Be careful if setting a short synchronisation period. Apple have a tendency to throttle connections that are hitting their server too often. I find that every 24hrs is fine. My phone will upload files to the cloud immediately, so if I lose my phone the photos I've taken that day will still be safe in the cloud, and the container will download those photos when it runs in the evening. Setting a value less than 12 hours will display a warning as Apple may throttle you.\n\n**synchronisation_delay**: This is the number of minutes to delay the first synchronisation. This is so that you can stagger the synchronisations of multiple containers. Default: 0. It has a maximum setting of 60.\n\n**notification_days**: When your cookie is nearing expiration, this is the number of days in advance it should notify you. You will receive a single notification, per day, in the days running up to cookie expiration. Default: 7.\n\n**authentication_type**: This is the type of authentication that is enabled on your iCloud account. Valid values are 'MFA' if you have multifactor authentication enabled or 'Web' if you do not. If 'Web' is specified, then cookie generation is not required. Default: 'MFA'.\n\n**directory_permissions**: This specifies the permissions to set on the directories in your download destination. Default: 750.\n\n**file_permissions**: This specifies the permissions to set on the files in your download destination. Default: 640.\n\n**folder_structure**: This specifies the folder structure to use in your download destination directory. If this configuration option is not set, it will set {:%Y/%m/%d} as the default. Use **none** to download to a flat file structure. Changing this value will not re-organise your currently downloaded files. It will leave your current folder structure intact and download your entire stream again. I do not recommend using **none** or {:%Y} as these two may result in images not being downloaded. In iCloud, you can have two identically named files and it will be fine. Using this downloader, the first file downloaded will take that name and the second file will be ignored.\n\n**albums_with_dates**: When albums are downloaded, they are downloaded into directories of the same name as the album. Setting this variable to **true** will then create sub folders according to the **folder_structure** variable. Default: false\n\n**libraries_with_dates**: When libraries are downloaded, they are downloaded into directories of the same name as the library. Setting this variable to **true** will then create sub folders according to the **folder_structure** variable. Default: false\n\n**skip_check**: Set this to **true** skip the check for new files. The check can have issues with large libraries, please set to **true** if you have more than a few thousand photos. Default: false.\n\n**download_notifications**: specifies whether notifications with a short summary should be sent for file downloads. Default: true.\n\n**delete_notifications**: Specifies whether notifications with a short summary should be sent for file deletions. Default: true.\n\n**startup_notification**: Specifies whether the startup notification should be sent. Default: true.\n\n**delete_accompanying**: Tells the script to delete files which accompany the HEIC files that are downloaded. These are the JPG files which are created if you have HEIC to JPG conversion enabled. They are also the \\_HEVC.MOV files which make up part of a live photo. This feature deletes files from your disk. I'm not responsible for any data loss.\n\n**delete_empty_directories**: Tells the script to delete any empty directories it finds in the download path. It will only run if **folder_structure** isn't set to 'none'\n\n**set_exif_datetime**: Write the DateTimeOriginal exif tag from file creation date. Warning: Setting this option will alter the local file and result in the original being downloaded again, with a de-duplication suffix added to the name. Default: false.\n\n**auto_delete**: Scans the \"Recently Deleted\" folder and deletes any files found in there. (If you restore the photo in iCloud, it will be downloaded again). Default: false.\n\n**delete_after_download**: After a file is successfully downloaded it is moved to the Recenlty Deleted folder. This configuration option cannot be used in conjunction with **auto_delete**. Default: false.\n\n**keep_recent_days**: Used with **delete_after_download**. Set this to an integer number to only keep the most recent *n* number of days. Default: 0 (keep all).\n\n**photo_size**: Image size to download. Can be set to **original**, **medium**, **thumb**, **adjusted**, **alternative** or any combination of those five in a comma-separated string if multiple size types are to be downloaded e.g. **photo_size=original,adjusted**. Adjusted are the edited photos that can be made by using filters, or by using the markup tool in the Photos app. Alternative are RAW file types. Default: original.\n\n**skip_live_photos**: If this is set, it will skip downloading live photos. Default: false.\n\n**live_photo_size**: Live photo file size to download. Can be set to **original**, **medium** or **thumb**. If skip_live_photos is set, this setting is redundant. Default: original.\n\n**skip_videos**: If this is set, it will skip downloading videos. Default: false.\n\n**recent_only**: Set this to an integer number to only download this many recently added photos. Default: download all photos.\n\n**until_found**: Set this to an integer number to only download the most recently added photos, until *n* number of previously downloaded consecutive photos are found. Default: download all photos.\n\n**photo_album**: Set this to a comma delimited field to download photos from a photo album. Please note, if downloading from multiple albums, you need to enclose them in quotes in your /config/icloudpd.conf file e.g. photo_album=\"one,two,three and four\" will download photos from three albums named \"one\", \"two\" and \"three and four\". When downloading photo albums, the folder structure will be set to be the name of the album eg \"/home/boredazfcuk/iCloud/one/IMG_0001.HEIC\", \"/home/boredazfcuk/iCloud/two/IMG_0002.HEIC\" and \"/home/boredazfcuk/iCloud/three and four/IMG_0003.HEIC\". Set  **photo_album=\"all albums\"** in your configuration file /config/icloudpd.conf to download all albums. Please note: Due to a limitation in an upstream package, downloading from multiple albums will trigger multiple download runs. When Apple detect this, they may force a multifactor re-authentication. \n\n**photo_library**: Set this to a comma delimited field to download photos from a shared library. Please note, if downloading from multiple libraries, you need to enclose them in quotes in your /config/icloudpd.conf file e.g. photo_library=\"one,two,three and four\" will download photos from three libraries named \"one\", \"two\" and \"three and four\". When downloading photo libraries, the folder structure will be set to be the name of the library eg \"/home/boredazfcuk/iCloud/one/IMG_0001.HEIC\", \"/home/boredazfcuk/iCloud/two/IMG_0002.HEIC\" and \"/home/boredazfcuk/iCloud/three and four/IMG_0003.HEIC\". Set  **photo_library=\"all libraries\"** in your configuration file /config/icloudpd.conf to download all libraries. Please note: Due to a limitation in an upstream package, downloading from multiple libraries will trigger multiple download runs, and Apple may force a multifactor re-authentication.\n\n**skip_album**: Use this option in conjunction with **photo_album** to skip certain albums e.g. **skip_album=\"All Photos,Time-lapse,Videos,Slo-mo,Bursts,Favorites,Panoramas,Screenshots,Live,Recently Deleted,Hidden\"**\n\n**skip_library**: Use this option in conjunction with **photo_library** to skip certain libraries e.g. **skip_libraries=\"PrimarySync,SharedSync-########-####-####-####-############\"**\n\n**photo_library**: Set this to the name of an iOS 16 shared library to download photos from that shared library.\n\n**convert_heic_to_jpeg**: Set this to **true** to convert downloaded HEIC files to JPEG, while also retaining the original.\n\n**jpeg_path**: Set this configuration option to specify a different location for the converted JPEGs. Default: \"/home/${user}/iCloud\", or **download_path** if not set, thereby placing the JPEG files alongside the HEIC files.\n\n**jpeg_quality**: If HEIC to JPEG conversion is enabled, this configuration option will let you set the quality of the converted file by specifying a number from 0 (lowest quality) to 100 (highest quality). Default: 90.\n\n**icloud_china**: Set this to **true** to use icloud.com.cn instead of icloud.com as the download source. Default: false.\n\n**auth_china**: Set this to **true** to use icloud.com.cn instead of icloud.com for cookie generation. Default: false.\n\n**fake_user_agent**: Set this to **true** to tell curl to use a fake user agent. This is required for some notification sites which do not allow curl to send notifications, IYUU for one. Sets user agent to: \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0\"\n\n**synology_photos_app_fix**: Set this to **true** to touch files after download and trigger the Synology Photos app to index any newly created files.\n\n**synology_ignore_path**: Set this to **true** to avoid warnings when trying to change **@eaDir** permissions for the extended attributes directories under Synology system.\n\n**single_pass**: Set this to **true** to exit out after a single pass instead of looping as per the synchronisation_interval. This way, the script can be scheduled to lauch on the host system using cron or another scheduling agent. If this option is used, it will automatically disable the download check. If using this configuration option, the restart policy of the container must be set to \"no\". If it is set to \"always\" then the container will instantly relaunch after the first run and you will hammer Apple's website.\n\n**keep_unicode**: Set this to **true** to keep unicode chars in file names or set it to **false** to remove all non-ascii chars. Default: false.\n\n**live_photo_mov_filename_policy**: Set this to **suffix** to add _HEVC to the suffix of the file name. Set it to **original** to set the filename the same as the photo. Default: suffix.\n\n**align_raw**: For photo assets with raw and jpeg, treat raw always in the specified size: **original** (raw+jpeg), **alternative** (jpeg+raw) or **as-is** (unchanged). Default: as-is.\n\n**file_match_policy**: Policy to identify existing files and de-duplicate. **name-size-dedup-with-suffix** appends file size to deduplicate. **name-id7**\nadds asset id from iCloud to all file names and does not need de-duplication. Default: name-size-dedup-with-suffix.\n\n# NEXTCLOUD CONFIGURATION VARIABLES\n\n**nextcloud_delete**: Set this variable to **true** if you want to remove files from Nextcloud. This setting requires **auto_delete** to also be set to true. When a file is found in the 'Recently Deleted', the **auto_delete** function will remove the local file. If **nextcloud_delete** is also set to **true**, then it will remove that file from the Nextcloud server.\n\n**nextcloud_password**: This is the password for the Nextcloud account you are syncing to\n\n**nextcloud_target_dir**: This is the name of the root folder that you want to place files in. Please note, it is not possible to upload files to the root of a Nextcloud server at this time.\n\n**nextcloud_upload**: Set this to **true** to upload files to a Nextcloud server\n\n**nextcloud_url**: This is the URL of your Nextcloud server e.g. https://my.server.local/ or https://my.server.local/nextcloud/\n\n**nextcloud_username**: This is the user name of the account that you want to upload the files to.\n\n## NOTIFICATION CONFIGURATION VARIABLES\n\n**notification_type**: This specifies the method that is used to send notifications. These are the options available **Prowl**, **Pushover**, **Telegram**, **Webhook**, **openhab**, **Dingtalk**, **Discord**, **IYUU**, **WeCom**, **Gotify**, **Bark**, **msmtp**. When the multifactor authentication cookie is within 7 days (default) of expiry, a notification will be sent upon synchronisation. No more than a single notification will be sent within a 24 hour period unless the container is restarted. This does not include the notification that is sent each time the container is started.\n\n**notification_title**: This allows you to change the title which is sent on the notifications. This variable will default to **boredazfcuk/iCloudPD**.\n\n**prowl_api_key**: Mandatory if notification_type set to 'Prowl'. This is the API key for your account as generated by the Prowl website.\n\n**pushover_user**: Mandatory if notification_type set to 'Pushover'. This is the Pushover user key associated with your account.\n\n**pushover_token**: Mandatory if notification_type set to 'Pushover'. This is the application API token. You will need to create an application by logging into your Pushover account and creating an application.\n\n**pushover_sound**: Mandatory if notification_type set to 'Pushover' this variable can be set to customise the sound of the notification. Values for this variable can be found here: https://pushover.net/api#sounds\n\n**telegram_token**: Mandatory if notification_type set to 'Telegram'. This is the token that was assigned to your account by The Botfather.\n\n**telegram_chat_id**: Mandatory if notification_type set to 'Telegram'. This is the chat_id for your Telegram bot. If the bot is a standard user that messages you, the chat ID will be a positive integer number. If the bot is a member of a group, and sends messages to the group, the chat ID will be prefixed with a hyphen '-' character.\n\n**telegram_silent_file_notifications**: Optional if notification_type set to 'Telegram'. Set this to **true** for the file download notifications to be sent silently. Default = false\n\n**telegram_polling**: Optional if notification_type set to 'Telegram'. Set this to true to enable Telegram polling. This will check the Telegram chat for messages every 60 seconds. If the latest message is the user name, it will synchronise immediately\n\n**telegram_server**: Optional if notification_type set to 'Telegram'. If Telegram is blocked in your country and you need to use a proxy server to access it, put the fully qualified domain name of the server here. e.g. proxy.server.com\n\n**telegram_http**: Optional if notification_type set to 'Telegram'. If Telegram is retricted to HTTP only in your country, set this to **true** so that HTTP is used instead of HTTPS. Default = false\n\n**webhook_server**: Mandatory if notification_type set to 'Webhook' or 'openhab' then this is the name of the server to connect to when sending webhook notifications.\n\n**webhook_port**: Mandatory if notification_type set to 'Webhook' or 'openhab' then this is the port number to use when connecting to the webhook server. If this is not set, it will default to 8123.\n\n**webhook_path**: Mandatory if notification_type set to 'Webhook' or 'openhab' then this is the path to use when connectiong to the webhook server. The path must start and end with a forward slash character. If this is not set, it will default to **/api/webhook/**. Openhab uses **\"/rest/items/<itemname>/\"**.\n\n**webhook_id**: Mandatory if notification_type set to 'Webhook' or 'openhab' then this is the Webhook ID to use. Openhab uses \"state\".\n\n**webhook_https**: If this is set to 'True' then the Webhook or openhab notification URL will use HTTPS, otherwise it will default to HTTP.\n\n**webhook_body**: Adapt to different services. Homeassistant uses \"data\" in the body of the webhook request, Discord uses \"content\", IFTTT uses \"value1\", etc.. Defaults to \"data\".\n\n**webhook_insecure**: Set to **true** to allow insecure https certificates, such as self-signed.\n\n**dingtalk_token**: Mandatory if notification_type set to 'Dingtalk' then this is the access token generated by the Dingtalk application. In the Dingtalk application, go to 'Security Settings', select 'Custom Keywords' and set to to the same value as **notification_title**.\n\n**discord_id**: This is the first half of the URL generated by Discord's webhook integration.  It will be all numbers.  Do not include any /\n\n**discord_token**: This is the second half of the URL generated by Discords webhook integration.  Do no include any /\n\n**iyuu_token**: Mandatory if notification_type set to 'IYUU'. This is the access token required to send messages.\n\n**wecom_id**: Mandatory if notification_type set to 'WeCom'.企业微信通知，企业微信通知，企业ID / This is the CORPID associated with your account。企业微信通知配置也可参见[此项目链接](https://github.com/Alano-i/wecom-notification/tree/main/iCloudPD)\n\n**wecom_secret**: Mandatory if notification_type set to 'WeCom'.企业微信通知，企业应用的Secret / This is the CORPSECRET associated with your account\n\n**agentid**: Mandatory if notification_type set to 'WeCom'.企业微信通知，企业应用的id / Enterprise application id\n\n**touser**: Mandatory if notification_type set to 'WeCom'.企业微信通知，接收通知的对象 / who receives notifications\n\n**content_source_url**: Mandatory if notification_type set to 'WeCom'.企业微信通知，阅读原文跳转链接 / Click on the page link after \"reading the original text\"\n\n**name**: Mandatory if notification_type set to 'WeCom'.企业微信通知，当前 Apple ID 所有人 / Current Apple ID owner\n\n**wecom_proxy**: Optional. 企业微信通知，企业微信的代理,非必填,用来绕过企业微信的IP白名单 / Optional,Used to bypass the ip whitelist of WeCom\n\n**media_id_startup**: Mandatory if notification_type set to 'WeCom'.企业微信通知，启动成功通知封面 / Image for Startup success\n\n**media_id_download**: Mandatory if notification_type set to 'WeCom'.企业微信通知，下载通知封面 / Image for downloaded files\n\n**media_id_delete**: Mandatory if notification_type set to 'WeCom'.企业微信通知，删除文件通知封面 / Image for deleted files\n\n**media_id_expiration**: Mandatory if notification_type set to 'WeCom'.企业微信通知，cookie即将过期通知封面 / Image for cookie expiration\n\n**media_id_warning**: Mandatory if notification_type set to 'WeCom'.企业微信通知，同步失败、cookiey已过期通知封面 / Image for cookie expired or failure\n\n**gotify_app_token**: Mandatory if notification_type set to 'Gotify'. This is the app_token associated with your account.\n\n**gotify_https**: If this is set to 'True' then the Gotify server URL will use HTTPS, otherwise it will default to HTTP.\n\n**gotify_server_url**: Mandatory if notification_type set to 'Gotify'. This is the server name of your Gotify server e.g. server.domain.tld\n\n**bark_device_key**: Mandatory if notification_type set to 'Bark'. This is the device key associated with your device.\n\n**bark_server**: Mandatory if notification_type set to 'Bark'. This is the name of your Bark server. Please note that the port should not be included and currently the project only supports http.\nIf you use the official Bark server, please fill the field with `api.day.app`.\n\n**msmtp_host**: Mandatory if notification_type set to `msmtp`. The domain of your smtp server\n\n**msmtp_port**: Mandatory if notification_type set to `msmtp`. The port of the smtp service. Normally 465 or 587\n\n**msmtp_tls**: Mandatory if notification_type set to `msmtp`. Set to `on` or `off` to enable or disable TLS encryption.\n\n**msmtp_from**: Mandatory if notification_type set to `msmtp`. The sender's email address\n\n**msmtp_user**: Mandatory if notification_type set to `msmtp`. The login username for your SMTP provider.\n\n**msmtp_pass**: Mandatory if notification_type set to `msmtp`. The password for the login user\n\n**msmtp_args**: Optional extra arguments for `msmtp` in case your mail provider has specific requirements. For example, `--tls-starttls=off`.\n\n## VOLUME CONFIGURATION\n\nThis container requires a named volume mapped to /config. This is where is stores the authentication cookie. Without it, it will lose the cookie information each time the container is recreated.\nIt will download the photos to the \"/home/${user}/iCloud\" photos directory. You need to create a bind mount into the container at this point.\n\n## FAILSAFE FEATURE\n\nI have added a failsafe feature to this container so that it doesn't make any changes to the filesystem unless it can verify the volume it is writing to is mounted correctly. The container will look for a file called \"/home/${user}/iCloud/.mounted\" (please note the capitalisation of iCloud) in the download destination directory inside the container. If this file is not present, it will not download anything from iCloud. This way, if underlying disk/volume/whatever gets unmounted, sync will not occur and this prevents the script from filling up the root volume of the host. This file **MUST** be created manually and sync will not start without it.\n\n## CREATING A CONTAINER\n\nFirst off, create a dedicated network for your iCloudPD conter(s) as this overcomes some DNS and routing issues may occur if you use the legacy default network bridge that Docker creates. In this example, I've have told it to use the IP address subnet 192.168.115.1 - 192.168.115.254 and configured the gateway to be 192.168.115.254. You can use any subnet you like:\n\n```\ndocker network create \\\n   --driver=bridge \\\n   --subnet=192.168.115.0/24 \\\n   --gateway=192.168.115.254 \\\n   --opt com.docker.network.bridge.name=icloudpd_br0 \\\n   icloudpd_bridge\n```\nThen create the container, connecting it to the new icloudpd network bridge. It should look something like this:\n\n```\ndocker create \\\n   --name iCloudPD_boredazfcuk \\\n   --hostname icloudpd_boredazfcuk \\\n   --network icloudpd_bridge \\\n   --restart=always \\\n   --env TZ=Europe/London \\\n   --volume icloudpd_boredazfcuk_config:/config \\\n   --volume /home/boredazfcuk/iCloud:/home/boredazfcuk/iCloud \\\n   boredazfcuk/icloudpd\n```\n\nNote: Raspberry Pi users have reported that the container only functions correctly when the containes is created with the `--privileged` parameter.\n\nOnce you have created your container. The configurable environment variables will be listed in the configuration file located in `/config/icloudpd.conf`\n\n## CONFIGURING A PASSWORD\n\nOnce the container has been created, you should connect to it and run `/usr/local/bin/sync-icloud.sh --Initialise`. This will then take you through the process of adding your password to the container's keyring. It will also take you through generating a cookie that will allow the container to download the photos.\n\nIf you launch a container without initialising it first, you will receive this error message:\n```\nERROR    Keyring file /config/python_keyring/keyring_pass.cfg does not exist.\nINFO      - Please add the your password to the system keyring using the --Initialise script command line option.\nINFO      - Syntax: docker exec -it <container name> sync-icloud.sh --Initialise\nINFO      - Example: docker exec -it icloudpd sync-icloud.sh --Initialise\nINFO     Restarting in 5 minutes...\n```\n\nAs per the error, the container needs to be initialised by using the --Initialise command line option. With the first container still running, connect to it and launch the initialisation process by running the following at the terminal prompt (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Initialise`\n\nYou will then be asked to log in to icloud.com, with your current Apple ID and password, and will be prompted to enter a multifactor authentication code which will be sent via SMS. Once that is confirmed, the password will be added to the keyring.\n\nIf you do not have an authentication cookie, and you have multifactor authentication enabled on your account, you will be taken to the cookie generation process immediately after.\n\n## MULTIFACTOR AUTHENTICATION\n\nIf your Apple ID account has multifactor authentication enabled, you will see that the container waits for a multifactor authentication cookie to be created:\n```\nERROR    Cookie does not exist.\"\nINFO      - Please create your cookie using the --Initialise script command line option.\"\nINFO      - Syntax: docker exec -it <container name> sync-icloud.sh --Initialise\"\nINFO      - Example: docker exec -it icloudpd sync-icloud.sh --Initialise\"\nINFO     Restarting in 5 minutes...\"\n```\n\nWithout this cookie, synchronisation cannot be started.\n\nAs per the error, the container needs to be initialised by using the --Initialise command line option. With the first container still running, connect to it and launch the initialisation process by running the following at the terminal prompt (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Initialise`\n\nAfter that, the script will log into the icloud.com website and save the MFA cookie. Your iDevice will ask you if you want to allow or deny the login. When you allow the login, you will be give a 6-digit approval code. Enter the approval code when prompted.\n\nThe process should look similar to this:\n\n```\n2020-08-06 16:45:58 INFO     ***** boredazfcuk/icloudpd container for icloud_photo_downloader started *****\n2020-08-06 16:45:58 INFO     Alpine Linux v3.12\n2020-08-06 16:45:58 INFO     Interactive session: true\n2020-08-06 16:45:58 INFO     Local user: user:1000\n2020-08-06 16:45:58 INFO     Local group: group:1000\n2020-08-06 16:45:58 INFO     LAN IP Address: 192.168.20.1\n2020-08-06 16:45:58 INFO     Apple ID: email@address.com\n2020-08-06 16:45:58 INFO     Authentication Type: MFA\n2020-08-06 16:45:58 INFO     Cookie path: /config/emailaddresscom\n2020-08-06 16:45:58 INFO     Cookie expiry notification period: 7\n2020-08-06 16:45:58 INFO     Download destination directory: /home/user/iCloud\n2020-08-06 16:45:58 INFO     Folder structure: {:%Y}\n2020-08-06 16:45:58 INFO     Directory permissions: 750\n2020-08-06 16:45:58 INFO     File permissions: 640\n2020-08-06 16:45:58 INFO     Synchronisation interval: 43200\n2020-08-06 16:45:58 INFO     Time zone: Europe/London\n2020-08-06 16:45:58 INFO     Adding password to keyring...\nEnter iCloud password for email@address.com:\nSave password in keyring?  [y/N]: y\nTwo-step authentication required. Your trusted devices are:\n  0: SMS to 07********\nWhich device would you like to use? [0]: 0\nPlease enter validation code: 123456\n2020-08-06 16:47:04 INFO     Using password stored in keyring\n2020-08-06 16:47:04 INFO     Generate MFA cookie with password: usekeyring\n2020-08-06 16:47:04 INFO     Check for new files using password stored in keyring...\n  0: SMS to 07********\n  1: Enter two-factor authentication code\nPlease choose an option: [0]: 1\nPlease enter two-factor authentication code: 123456\n2020-08-06 16:47:30 INFO     Multifactor authentication cookie generated. Sync should now be successful.\n```\n\nThis will then place a multifactor authentication cookie into the /config folder of the container. This cookie will expire after three months. After it has expired, you will need to re-initialise the container again.\n\nAfter this, the container should start downloading your photos.\n\nDockerfile has a health check which will change the status of the container to 'unhealthy' if the cookie is due to expire within a set number of days (notification_days) and also if the download fails.\n\n## MULTIFACTOR RE-AUTHENTICATION\nEvery 30 days, the cookie will expire and need to be re-authenticated. This can be done by running the re-authentication script:\n\n```\ndocker container exec -it reauth.sh\n```\n\nIt will then launch the re-authentication process, presenting you with an MFA code on your iDevice and asking for this new code on the command line. e.g:\n\n```\n2024-03-27 22:21:33 DEBUG    Authenticating...\n2024-03-27 22:21:35 INFO     Two-step/two-factor authentication is required (2fa)\nPlease enter two-factor authentication code: 123456\n2024-03-27 22:21:55 WARNING  Failed to parse response with JSON mimetype\n2024-03-27 22:21:57 INFO     Great, you're all set up. The script can now be run without user interaction until 2SA expires.\nYou can set up email notifications for when the two-step authentication expires.\n(Use --help to view information about SMTP options.)\n2024-03-27 22:21:57 INFO     Authentication completed successfully\n```\n\n# TELEGRAM 2-WAY COMMUNICATIONS\n## Remote Synchronisation\nIf you are using Telegram as your notification application, you can now send messages to the chat bot, which the container will read, and then take the appropriate action. If you simply message the chatbot with the user that you have configured in the **user** variable, it will pick that up and force a synchronisation. So if you're down the pub with your mates, take a bunch of pics that you really like, simply message `boredazfcuk` (or whatever you've configured your user variable to be) to the Telegram bot and it will force a synchronisation, downloading your new photos within the next few minutes.\n\n## Remote Re-authentication\nApple have recently reduced the re-authentication tim from 90 days to 30 days. This means connecting to your container, re-initialising it and completing multi-factor authentication. If I am out of the house and my cookie expires, I would need to wait until I get home, faff about with the whole process I just described. Now, you can message your container in a similar manner to the remote syncronisation, but adding `auth` to the end of the message, so for example `boredazfcuk auth`. After you have done this, I find it is best to start typing another message starting `boredazfcuk ` (note the space) and then changing the keyboard to number input. The container should pick up this instruction within a minute and it will message you back asking for the MFA code. It will start the re-authentication process and your iDevice will display a popup to `allow` or `deny` the connection. Click `allow` and you will be presented with your multi-factor authentication code. Memorise this code and add it to the end of your message, like `boredazfcuk 123456` and hit send. The container will then use this code to re-initialise your cookie and start downloading your photos again. One word of caution though... Literally every company on the planet tells you never to share this code with anyone. I put this feature in because... well... I trust me. I don't believe in putting blind faith in other though. So neither should you. Feel free to read the source code, so you can make sure it's not doing anything nefarious, by checking it yourself. I understand that not everyone can code though, so if you don't trust it, that's totally OK, probably a good choice on your behalf. To be fair, I'm just a dude with an IT hobby. I couldn't care less about your iCloud account, your contacts, or the pictures of your cat/dog. I just hope this makes you life better in some tiny way.\n\n## COMMAND LINE PARAMETERS\n\nThere are currently a number of command line parameters are available to use with the sync-icloud.sh script. These are:\n\n**--Convert-All-HEICs**\nThis command line option will check for HEIC files that do not have an accompanying JPEG file. If it finds a HEIC that does not have an accompaying JPEG file, it will create it. This can be used to add JPEGs for previously downloaded libraries. The easiest way to run this is to connect to the running container and executing the script.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Convert-All-HEICs`\n\n**--Force-Convert-All-HEICs**\nThis command line option is the same as the above option but it will overwrite any JPEG files that are already there. This will result in data loss if the downloaded JPEG files have been edited. For this reason, there is a 2 minute delay before this option runs. This gives you time to stop the container, or cancel the script, before it runs. This option is required as the heif-tools conversion utility had a bug that over-rotates the JPEG files. This means the orientation does not match the HEIC file. The heif-tools package has now been replaced by the ImageMagick package which doesn't have this problem. This command line option can be used to re-convert all your HEIC files to JPEG, overwriting the incorrectly oriented files with correctly oriented ones.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Force-Convert-All-HEICs`\n\n**--Force-Convert-All-mnt-HEICs**\nThis command line option is the same as the above option but it will overwrite any JPEG files that it finds in the /mnt subdirectory. This will result in data loss if the downloaded JPEG files have been edited. For this reason, there is a 2 minute delay before this option runs. This gives you time to stop the container, or cancel the script, before it runs. This option is required as the heif-tools conversion utility had a bug that over-rotates the JPEG files. This means the orientation does not match the HEIC file. The heif-tools package has now been replaced by the ImageMagick package which doesn't have this problem. This command line option can be used to re-convert all your HEIC files to JPEG, overwriting the incorrectly oriented files with correctly oriented ones. This option can be used to correct JPG files that have been archived and removed from your iCloud photostream. Just mount the target directory (or directories) into the /mnt subdirectoy and the script with this command.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Force-Convert-All-mnt-HEICs`\n\n**--Remove-All-JPGs**\nThis command line option removes all the JPEG files which have a matching HEIC. My day-2-day laptop is Windows 11 and HEIC support is now baked into the OS. I've no need for JPGs anymore as I can view the HEICs and their thumbnails without issue. I created this to just purge all the JPEGs which have a HEIC with a matching filename. This could well remove JPEGs that have matching named HEICs, but are actually different photos. Oh well.\n\n**--Correct-JPEG-Time-Stamps**\nThis command line option will correct the timestamps of JPEG files that do not match their accompanying HEIC files. Due to an omission, previous versions of my script never set the time stamp. This command line option will correct this issue.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Correct-JPEG-Time-Stamps`\n\n**--Initialise** | **--Initialize** | **--init**\nThis command line option will allow you to add your password to the system keyring. It will also force the creation of a new two-factor authentication cookie.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Initialise`\n\n**--Remove-Keyring**\nThis command line option will delete the system keyring file. You will need to run this if you change your Apple ID password.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Remove-Keyring`\n\n**--Enable-Debugging**\nThis command line option will edit the config file so that debugging is enabled. This will automatically be picked up the next time a synchronisation takes place. There should be no need to restart the container\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Enable-Degugging`\n\n**--Disable-Debugging**\nThis command line option will edit the config file so that debugging is disabled. This will automatically be picked up the next time a synchronisation takes place. There should be no need to restart the container\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Disable-Degugging`\n\n**--Upload-Library-To-Nextcloud**\nThis command line option will upload your entire library to the Nextcloud server. First, it will scan your download directory, then replicate the directory structure on the Nextcloud server. Once this is complete, it will proceed upload the files to these directories.\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --Upload-Library-To-Nextcloud`\n\n**--List-Albums**\nThis commmand will list the names of the albums available to download\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --List-Albums`\n\n**--List-Libraries**\nThis command will list the names of the libraries available to download\nTo run the script inside the currently running container, issue this command (assuming the container name is 'icloudpd'):\n`docker exec -it icloudpd sync-icloud.sh --List-Libraries`\n\n## HEALTH CHECK\n\nI have built in a health check for this container. If the script detects a download error the container will be marked as unhealthy. You can then configure this container: https://hub.docker.com/r/willfarrell/autoheal/ to monitor iCloudPD and restart the unhealthy container. Please note, if your MFA cookie expires, the container will be marked as unhealthy, and will be restarted by the authoheal container every five minutes or so... This can lead to a lot of notifications if it happens while you're asleep!\n\n## TROUBLESHOOTING\n\nThe app which runs inside this container connects to iCloud.com website and downloads the files it finds in there. Basically the same way as you would if you were downloading the files in your web browser, as Apple does not provide the capability to do this via an API (gotta love Apple's walled-garden). This is problematic because if the website changes at all, it throws the downloader out due to the website is doing something unexpected. There are many reasons that the website can change, for example, if somebody attempts to brute-force your account, you will be prompted to confirm your security questions the next time you log in. Accounts without two-factor authentication enabled will periodically receive a prompt upon login about upgrading the account's security.\n\nIf you have enabled Apple's Advanced Data Protection feature in iOS 16.2, you will need to disable it. This feature encrypts your photos on Apples servers and disables photo access on icloud.com which is required for this container. This results in you only being able to access your photos from your trusted Apple devices. There is an option to allow access to icloud.com for an hour at a time, but currently, an upstream dependency does not support this.\n\nIf your container starts erroring out all of a sudden, the first thing to do is to log into iCloud.com and check that there isn't some pop-up notification which needs clearing. If that doens't work, then try re-initialising your container. For larger libraries with thousands of images, disabling the download check is also a requirement, so please try that.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.232421875,
          "content": "# docker-icloudpd\nAn Alpine Linux Docker container for iCloud Photos Downloader. I use it for syncing the photo streams of all the iDevices in my house back to my server because it's the only way of backing up multiple devices to a single location. It uses the system keyring to securely store credentials, has HEIC to JPG conversion capability, and can send Telegram, Prowl, Pushover, WebHook, DingTalk, Discord, openhab, IYUU and WeCom notifications. Please note, Apple's Advanced Data Protection (ADP) is not supported. ADP must be disabled for this container to work.\n\n# Now with remote re-authentication!\nTaking advantage of the Telegram 2-way communications, it is now possible to re-authenticate your cookie by messaging the Telegram Chat Bot! Simply send a message to Telegram telling it you want to re-authenticate (see the CONFIGURATION.MD link below for details). When it's ready, it will message you back asking for the multi-factor authentication code. Send that to Telegram and it will complete the login process. No more re-initialising from the container command line!\n\n# Now with easier local re-authentication too!\nNow you can simply run reauth.sh from the Docker command line to renew you Multi-Factor Authentication cookie (again, see the CONFIGURATION.MD link below for details).\n\n# Now with 2-way comms via Telegram!\nJust send a message to the Telegram chat and the container will pick that up and sync immediately.\n\n# Also with built-in Nextcloud upload/delete!\nJust configure the Nextcloud settings and every file downloaded will be uploaded to a nextcloud server. It will also upload the JPGs it creates from HSIC file conversions. It will also sync deletes too.\n\n## CONFIGURING ICLOUDPD\n\nThe README on Dockerhub has a hard limit of 25,000 characters, and I've hit this limit too many times now. All in all, I'm up at about 37k characters for the documentation, so this README is just a placeholder. Please see CONFIGURATION.md for info on how to configure this container. It is available here: https://github.com/boredazfcuk/docker-icloudpd/blob/master/CONFIGURATION.md\n\nLitecoin: LfmogjcqJXHnvqGLTYri5M8BofqqXQttk4\n\nEthereum: 0x752F0Fc9c1D1a10Ae3ea429505a0bbe259D60C6c\n\nBitcoin: 1E8kUsm3qouXdVYvLMjLbw7rXNmN2jZesL or bc1q7mpp4253xeqsyafl4zkak6kpnfcsslakuscrzw"
        },
        {
          "name": "authenticate.exp",
          "type": "blob",
          "size": 4.7041015625,
          "content": "#!/usr/bin/expect -f\r\n\r\n# Enable debugging\r\n#exp_internal 1\r\n\r\nset force_conservative 0  ;# set to 1 to force conservative mode even if\r\n                          ;# script wasn't run conservatively originally\r\nif {$force_conservative} {\r\n        set send_slow {1 .1}\r\n        proc send {ignore arg} {\r\n                sleep .1\r\n                exp_send -s -- $arg\r\n        }\r\n}\r\n\r\nset timeout -1\r\nspawn -noecho /usr/local/bin/reauth.sh\r\nlog_user 0\r\nmatch_max 100000\r\nexpect {\r\n    # Activates when account has no trusted numbers\r\n    \"Please enter two-factor authentication code: \" {\r\n        exec /usr/local/bin/sendmessage.sh mfacode\r\n        send_user \"\\nWaiting for MFA code...\\n\"\r\n        exec >@stdout 2>@stderr /usr/bin/inotifywait -qq -t 600 -e close_write /tmp/icloudpd/expect_input.txt\r\n        set MFACODE [exec cat /tmp/icloudpd/expect_input.txt]\r\n        set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n        send_user \"${DATE} INFO     MFA code received: ${MFACODE}\\n\"\r\n        send -- \"${MFACODE}\\r\"\r\n        # Catches success/failure for received MFA code\r\n        expect {\r\n            \"Failed to verify two-factor authentication code\" {\r\n                set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                send_user \"${DATE} ERROR    Authentication failed\\n\"\r\n                exec /usr/local/bin/sendmessage.sh failure\r\n            }\r\n            \"The script can now be run without user interaction until 2FA expires\" {\r\n                set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                send_user \"${DATE} INFO     Authentication successful\\n\"\r\n                exec /usr/local/bin/sendmessage.sh success\r\n            }\r\n        }\r\n    }\r\n    \"Please enter two-factor authentication code or device index \" {\r\n        exec /usr/local/bin/sendmessage.sh smschoice\r\n        set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n        send_user \"${DATE} INFO     Waiting for SMS choice/MFA code...\\n\"\r\n        exec >@stdout 2>@stderr /usr/bin/inotifywait -qq -t 600 -e close_write /tmp/icloudpd/expect_input.txt\r\n        set MESSAGE [exec cat /tmp/icloudpd/expect_input.txt]\r\n        set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n        send_user \"${DATE} INFO     SMS choice/MFA code received: ${MESSAGE}\\n\"\r\n        send -- \"${MESSAGE}\\r\"\r\n        expect {\r\n            # Catches failure when MFA code is sent immediately\r\n            \"Failed to verify two-factor authentication code\" {\r\n                set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                send_user \"${DATE} ERROR    Authentication failed\\n\"\r\n                exec /usr/local/bin/sendmessage.sh failure\r\n            }\r\n            # Catches success when MFA code is sent immediately\r\n            \"The script can now be run without user interaction until 2FA expires\" {\r\n                set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                send_user \"${DATE} INFO     Authentication successful\\n\"\r\n                exec /usr/local/bin/sendmessage.sh success\r\n            }\r\n            # Catches when index number received instead\r\n            \"Please enter two-factor authentication code that you received over SMS: \" {\r\n                exec /usr/local/bin/sendmessage.sh mfacode\r\n                set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                send_user \"${DATE} INFO     Waiting for MFA code...\\n\"\r\n                exec >@stdout 2>@stderr /usr/bin/inotifywait -qq -t 600 -e close_write /tmp/icloudpd/expect_input.txt\r\n                set MFACODE [exec cat /tmp/icloudpd/expect_input.txt]\r\n                set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                send_user \"${DATE} INFO     MFA code received: ${MFACODE}\\n\"\r\n                send -- \"${MFACODE}\\r\"\r\n                expect {\r\n                    # Catches failure for received MFA code\r\n                    \"Failed to verify two-factor authentication code\" {\r\n                        set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                        send_user \"${DATE} ERROR    Authentication failed\\n\"\r\n                        exec /usr/local/bin/sendmessage.sh failure\r\n                    }\r\n                    # Catches success for received MFA code\r\n                    \"The script can now be run without user interaction until 2FA expires\" {\r\n                        set DATE [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}]\r\n                        send_user \"${DATE} INFO     Authentication successful\\n\"\r\n                        exec /usr/local/bin/sendmessage.sh success\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexpect eof"
        },
        {
          "name": "build_version.txt",
          "type": "blob",
          "size": 0.015625,
          "content": "1084_06-01-2025\n"
        },
        {
          "name": "change.log",
          "type": "blob",
          "size": 65.63671875,
          "content": "06/01/2025\n\n - Changed some IFS declarations so they're all consistent (echo \\b\\n to $'\\n')\n - Re-implemented Synology Photos App Fix which hadn't been brought in since the move to icloudpd.conf file configuration\n\n05/01/2025\n\n - Added **keep_recent_days** option.\n\n04/01/2025\n\n - Messed about with the Telegram polling times so that when re-authenticating, the polling frequency increases so it's more responsive. Polling every 60s makes re-authentication take about 3mins. Should now be loads quicker.\n - Also noticed that additional sleeps in the Telegram polling sequence would mean the sync time slips by 2 seconds every 60. I've not checked logs to confirm, so this is only a suspicion. Have changed it anyway so that it should now be more accurate and slippage should only be by the amount of time it takes to process all the commands... so hopefully can be measured in miliseconds.\n \n29/12/2024\n\n - Bump icloud-photos-downloader to v.125.1 and pushed to GitHub.\n\n25/12/2024\n\n  - No update, just Merry Christmas!\n\n18/12/2024\n\n - Another ImageMagick bug... grr.\n - Added additional checks at container first launch when creating the /config directory and /config/icloudpd.conf file. Script will now hang before initialisation if checks on these locations fail.\n\n15/12/2024\n\n - Still seems like there is a bug in the JPG file conversion code. Doesn't seem to create the subdirectories it needs. Likely only ever worked if folder_structure was set to none.\n \n13/12/2024\n\n - Imagemagick changed the \"convert\" command to \"magick convert\". I'm sure they must have a reason for it, but it seems a little daft... and annoying.\n \n09/12/2024\n\n - Well that was weird. I just re-built the \"upload library to nextcloud\" function using the newly reworked \"create directories\" and \"upload files\" functions as a template and the function worked first time in testing. Ther'es gotta be something wrong with it, surely?\n \n08/12/2024\n\n - A bunch more Nextcloud stuff done over the weekend. All functions now reworked except for the one that uploads the entrie library. Not as much space saved as I'd liked. The upload function was actually pretty well written, plus I broke them into separate functions for creating directories and uploading files. I also found a potential issue regarding case sensitivity and the HEIC conversion tool, so added a bunch of code to handle that. Hopefully I'll get some time to finish the last function tomorrow/Tuesday.\n\n05/12/2024\n\n - Bit of work regarding the Nextcloud stuff. Rewritten the function that creates the directories prior to uploading. It now generates the list of encoded directory paths before attempting to create them. Seems a lot cleaner. Code has gone from about 40 lines to 30 lines, a reduction of over 200 characters. S/hould be able to make similar gains surrounding the nextcloud_upload, nextcloud_delete and double the amoutn for the upload_library_to_nextcloud functions... iirc.\n - Also, Alpine Linux 3.210.0 has dropped so rebuilt with that.\n\n03/12/2024\n\n - Bump icloud-photos-downloader to v.125.0 and pushed to GitHub.\n - Then found nextcloud upload handling doesn't work when the album name has a space in it. I've got directoy creation and upload working, but it's an absolute mess. I've no idea how it's actally working and seems way, way overly complicated. Needs some time spending on it.\n\n24/11/2024\n\n - Did remember.\n\n23/11/2024\n\n - Well, seems like remote auth was royally fucked with the switch from ash to bash due to the regex matching. Think it's fixed. Pretty sure there were PRs surrounding the photo_album and photo_lirary features that used the same regex based matches. they could be broke, but it's late, so I'm going to bed. I'm also a bit drunk so I'll probably forget to check if its broken tomorrow.\n \n22/11/2024\n\n - Bump to iCloud Photos Downloader v1.24.4\n\n10/11/2024\n\n - Changed the format of a lot of code.\n - Added bash shell and now running scripts in bash. This is because I've started using shellcheck to test the code and it doesn't support Alpine.\n\n22/10/2024\n\n - Removed all the \"Change: \" prefixes in this file. I originally planned to have different stuff, and there probably are a few still in here, but they serve no value.\n - Changed the search for \"True\" and \"False\" in the config file replacements so that they are now case insensitive. TRUE will also now be changed to true. As FaLSe will be changed to false.\n \n13/10/2024\n\n - Issue reported with a \"] if statement preventing launch. Odd, as greppimg the main script for it returned a second result which must have been there for many, mant releases.\n\n11/10/2024\n\n - Added the **webhook_insecure** option to allow use of self-signed certificates.\n - Some logging changes.\n\n17/09/2024\n\n - Added PR from @Teknicallity which fixes a rare condition which would lead to an empty download_path variable and some other logging output changes.\n \n16/09/2024\n\n - Rebase to Alpine Linux 3.20.3\n - Installed libheif 1.18.2-r0 from Edge repository which should allow for HEIC to JPEG conversion on iOS 18\n\n11/09/2024\n\n - Merged PR submitted by RICwang which adds the Chinese translations for the remote sync feature and also enables the feature.\n\n08/09/2024\n\n - Upload Library to Nextcloud function now checks for the existence of the file and skips if it's already there. Hopefully this wil speed-up the time it takes, at the expense of overwriting what's already on the server.\n - Amended Nextcloud offline notification to contain username. I've had two notifications for a possible five accounts. Not sure which accounts to look at.\n - Added a bit to detect whether a command line parameter has been specified. If so, it sets telegram_polling to false, so there's no delay when launching the script with command line parameters such as init and upload-library-to-nextcloud.\n\n02/09/2024\n\n - Bump to iCloud Photos Downloader v1.23.4\n\n01/09/2024\n\n - Bump to iCloud Photos Downloader v1.23.2\n - Telegram remote authentication is working perfectly now... only related issue is that it's spamming the logs. Need to figure out how to quieten it down. Task for another day, I think. I've done so many MFA re-authentications today, it won't be long before Apple block me again. \n - Bump to iCloud Photos Downloader v.123.3\n - Fixed an odd bug that when the container is waiting for authentication to complete, the cookie was being removed. Think this behaviour has changed somwhere down the line. Previously I think the file was being overwritten, no I think it removes the file at the start of the process. This resulted in a grep command not being able to find the file. Now, set the grep command to silence errors and just echo a value indicating non-detection instead.\n - A buncu of remote authentication tweaks. It's looking a lot nicer now. No debug info printed and logging nicely too.\n\n31/08/2024\n\n - Fake user agent to fix IYUU notifications in China.\n \n30/08/2024\n\n - Latest version of icloudpd changed the way that the phone numbers were output (specifically the ***** *****) part, so the remote auth feature would not fire out the Telegram notification with the number on.\n\n26/88/2024\n\n - Reworked Telegram notifications so that they have a base URL instead of notification URL, this is to remove duplicated lines of code surrounding notifications and polling.\n - Amended health check to instpect the same cookie expiry value as the main script.\n - Changed log output so that next synchronisation dates which are more than 20 hours in the futuer display the locale's data and time.\n \n24/08/2024\n\n - Now possible to configure Telegram to use HTTP instead of HTTPS by setting **telegram_http=true**\n \n23/08/2024\n\n - Amended some error logs.\n - Amended cookie logic to pull expiry date back for X-APPLE-WEBAUTH-USER instead of X-APPLE-WEBAUTH-PCS-Photos. Seems the latter's expiry date is extended upon each sync where the former is the true expiry date of the cookie.\n\n22/08/2024\n\n - Moved the logic for creating the files in the JPEG path. Seems it was attempting to create a blank directory for people who did not have this configured.\n\n31/07/2024\n\n - Might have figured out the Telgram remote authentication expect scripts bollocks.\n \n23/07/2024\n\n - Possible bug with jpeg_path veriable. Have added some stuff to check and set permissions.\n \n21/07/2024\n\n - Got rid of the config_dir variable and hardcoded /config. Some systems dont' seem to be honoring it, even though it's specified in the container.\n - Bumped to v1.22.0\n - icloud-photos-downloader version output text has changed. Updated command so it's correctly displayed.\n \n10/07/2024\n\n - Bug with Alternative size.\n \n09/07/2024\n\n - Missed one of the new photo sizes. Alternative. Duh.\n \n08/07/2024\n\n - Reworked user/group creation. As the config file is now user to specify the user/group and not variables, it would default to creating a user:1000 and group:1000 for the user and group. Then a user could come along and change say the username, but it would fail to change this due to the UID already being is use. Script has been changed to overwrite the /etc/passwd and /etc/group files with minimal ones (only a root user and only root, tty and shadow for groups). It will then create the new user. This should allow much better user switching within the container.\n - v1.19.0 brought in support for downloading multiple sizes of photo. Have now updated the container to support that too.\n\n06/07/2024\n\n - Bumped to v1.21.0\n\n03/07/2024\n\n - Seems one of the error logs was not using the error log function, but debug log function... fixed.\n - Got rid of full stops on ends of some log lines. What moron puts full stops at the end of lines nowadays?\n - Couple of issues in the init config file. debug_logging=AAAAA was one of them. No idea how that got there. Plus group_id=group. That's prob gonna break things.\n - Anoher config file related change. I now set the download_path variable default in the config file where previously it was blank. Now it checks for the user variable in the config, if there isn't one, it uses the user variable, if there isn't one of those either, it defaults to /home/user/iCloud.\n\n01/07/2024\n\n - Bumped to v1.20.4\n - Script now checks for presence of config file before running. Exits if it doesn't exist as it indicates failure to write to /config, the directory where the container keeps its config files/cookies/keyring etc.\n - Removed some commented out code relating to different virtual environments when china_fix branch was also implemented.\n - Changed the cookie creation command from performing a dry-run and downloading 0 recent photos, to just performing the authentication only option.\n - Added an extra test to init_config.sh as changes made on 24th June did not account for first run.\n - Added an update check to startup.\n\n30/06/2024\n\n - Added a bunch of stuff to set defaults for empty variables in icloudpd.conf.\n - Added force_gid to config file as it was missing.\n - Added live_photo_size too.\n - Removed some code relating to the old NextcloudCLI container I've deprecated a long while back.\n\n29/06/2024\n\n - Bumped to v1.20.3\n\n24/06/2024\n\n - Think I fixed an issue where files with spaces in the name won't upload to Nextcloud... edit: yeah, pretty much sorted it.\n - Added a test to init_config.sh to check file permissions before launch.\n\n23/06/2024\n\n - Not uploading to Nextcloud if the filename has a space in it. Made amendments to see if I can work out why. Seems that spaces are not being changed to %20. Made some logging changes to to check.\n - Found and fixed the Nextcloud upload issue.\n - Just found that the function which deletes empty directories wasn't actually implemented correctly. Now fixed.\n\n17/06/2024\n\n - Bumped to v1.20.0\n - Amended init_config.sh so that it won't match two search results when searching for variables e.g. 'name=' previously matched 'name=' and 'nextcloud_username='.\n - Amended the profile so that the path variable now includes the new location for icloudpd.\n - Amended startup part of main script to get rid of default values in script. All these should now be set by the init script and pulled from the icldoupd.conf file.\n - Implemented the --keep-unicode-in-filenames functionality.\n - Implemented the --live-photo-mov-filename-policy functionality.\n - Implemented the --file-match-policy functionality.\n - Implemented the --align-raw functionality.\n - Was counting lines of the download check with grep. Swapped to wc, just in case something iffy is happening with \"grep -c ^\".\n\n10/06/2024\n\n - Fixed bug introduced by SMTP notifcation.\n - Fixed bug in config file initilisation script.\n\n06/06/2024\n\n - Bumped to v1.19.1\n - Merged pull request from @klesh to add SMTP notification support.\n\n01/06/2024\n\n - Bumped to v1.19.0\n\n28/05/2024\n\n - Bumped to v1.18.0\n\n26/05/2024\n\n - Just removed some obsolete stuff from the dockerfile.\n - Added date to build number. Some dude was running a version that was 3 years old. I removed the date from the build number a year or two ago, coz I thought most people would be fairly up to date. Obviously not, so I've put it back. Will help identifiy people doing the same thing.\n - Changed the date format due to the change above, and also coz it's just easier to read when units go from smallest to largest. Reverse dates work best on filenames so they are automatically stored chronoligically, but that's not really needed here.\n\n25/05/2024\n\n - Bumped to v1.17.7 and relocated python venv from /opt/icloudpd_latest to /opt/icloudpd as I'm no longer installing two versions into the container. Also... noticed Alpine is now at version 3.20\n \n24/05/2024\n\n - Bumped to v1.17.6\n\n16/05/2024\n\n - Amended the log output for when an error is detected to instruct the end user to gather a debug log before posting the issue to GitHub. Too many muppets posting a single line of error message and expecting me to know what they've messed up to break it in that way.\n \n09/05/2024\n\n - Added a check to see if the download path is writable. A lot of users have reported seeing the error: \"Invalid value for '-d' / '--directory': Path '/download_path' is not readable\" and although some users it appears to be due to SMB file mounts, I suspect it is the age old issue that their permissions are just inadequate... like SMB permissions don't just have file permissions, they have user permissions via the share itself, and it's likely just that. I now check that the download directory is writable. If not, then I attempt to set the permissions as root for the configured user, then re-test. If it fails, I just bail and kick out an error. \n\n05/05/2024\n\n - Added nano, nano-syntax and findutils to the container. BusyBox fnd doesn't support -printf and I need that to add the nano syntax highlighting stuff to /etc/nanorc.\n - Altered the script to add some delays in where people attempting to run as root. Running as root is not supported as this script expects to switch user at times and it breaks the su command.\n - Added /opt/icloudpd_latest to path so icloudpd and icloud can be run without having to cd to their locations.\n\n04/05/2024\n\n - Some stuff to make command line life easier.\n - Removed a bunch of redundant stuff from the Dockerfile.\n\n28/04/2024\n\n - I got rid of the bit which attempts to detect TCP connectivity to a DNS server which curl has been found to use. It seems that for some people, curl works just fine with UDP lookups. The people who are having problems with curl can firgure out their issue instead.\n - The reauth script wasn't setting the cookie directory, so the re-authed cookie would land in the root user's home directory instead. Also, the re-auth command would be run as root, so permissions could get messy. Changed script to use a run_as function, so it's runs as the configured user.\n - Have modified the script so that it handles the new behaviour for remotely authenticating when using SMS based MFA. Haven't tested it much yet, so probably broken lol. I need to push to Dockerhub so I can test on the accounts I do SMS MFA from, as these don't run my testing builds.\n\n05/04/2024\n\n - Amended logic for remote authentication coz the first way I did it was pretty stupid. This allows for users to have numbers in their Apple ID, which is nice.\n\n31/03/2024\n\n - reauth.sh script now checks for auth_china variable and configures authentication domain.\n \n27/03/2024\n\n - Telgram messaging can now re-authenticate your icloud.com account.\n - Added reauth.sh script so that re-initialising the cookie is easier.\n \n20/01/2024\n\n - Gotify can now be configured for HTTP or HTTPS connections.\n\n07/01/2024\n\n - Merged PR from @timrettop which fixes HEIC to JPEG conversion in Alpine 3.19.0\n - Created option to disable the startup notification.\n - Removed the silencing of the set_mempolicy error. The convert application does not generate these errors any more after the jpeg package was installed in the container. It seems that the convert application was just converting the HEIC file to another HEIC file, but with the JPG file extension. Installing the package means the conversion processes a lot more quickly and correctly outputs the files.\n - Made the functions which convert HEIC files to JPEG, remove all HEIC files, etc do case insensitive searches. This should conver *.HEIC and *.heic to *.JPG.\n\n06/01/2024\n\n - Rebuild container to icloudpd 1.17.3\n\n01/01/2024\n\n - Altered how Nextcloud path is built. Seems there are double trailing slashes. Now removes the one in the variable and appends one manually.\n - Seems like deleting from Nextcloud wasn't working correctly. Was always coming up with \"File not found\" which is bizarre coz it defo worked when I first implemented it. I've changed it so it uses the same encoding method as uploads, instead of doing it using a standard file path (which wouldn't work for files/paths with spaces in their names). Anyway, seems to be deleting things OK again now.\n - The curl command performs TCP DNS lookups, whereas everything else like ping and nslookup uses UDP. If TCP requests are blocked to the DNS server, the container will pass the DNS checks, but then the curl commands to send the startup notifications will hang/fail. Bind-tools has been installed so that the full version of nslookup can be used and force the requests over TVP (using the -vc parameter)\n\n30/12/2023\n\n - Removed a log entry which was malformed.\n - Output value of bot_check into debug log.\n - Added random delay of 0-15 seconds (inclusive) if Telegram polling is enabled. I believe starting multiple containers at the same time and them all hitting the APi at the same time may cause some requests to be ignored.\n\n27/12/2023\n\n - Documented the --remove-all-jpgs command line option. It's been there ages, not sure why I never documented it. Probably because it could delete data that might be needed and I don't want people losing stuff.\n24/12/2023\n\n - I think the upgrade to Alpine 3.19 may have broke Imagmagick. Adding the additional package, libheif-dev, got it working again.\n - Also, found that due to the newer version of ImageMagick, an error is generated when converting HEIC to JPEG. The conversion still works, so I've just silenced that error, specfically.\n\n20/12/2023\n\n - Upgraded to use Apline Linux 3.19.0 and icloudpd 1.17.0 which now includes the authentication fix. Won't work for China as they were having to use an old version of iCloudpd which is packaged into my container. New version may work ok, but script will need significant re-write for that to occur. Probably look at it over Christmas.\n\n19/10/2023\n\n - Added a new Nextcloud URL encode function. If a user is downloading to Photo Albums, or Shared Libraries, or even just has files with special characters (like spaces) in them, then the Nextcloud URL needs to be encoded.\n \n18/10/2023\n\n - Trailing slashes on $download_path messes up Nextcloud uploads. Added a bit into the upload function which should account for this.\n\n10/10/2023\n\n - Downloading albums not working correctly. Fixed it up and added a bunch more logging. Probably needs sames for libraries function.\n - Done the libraries function too.\n\n09/10/2023\n\n - Bug found in health check... Was using wrong filename for error checks.\n - Another bug in health check... Filename followed with a } making it invalid.\n - icloudpd seems to error with an exit code of 0 when MFA is required but aborted due to being a non-interactive session. Have now added a check to see if the error report file has size.\n\n05/10/2023\n\n - Some users attempting to set the user for sync to root. This breaks things as it can't create the local user account or switch users correctly, so now it will default to user:1000 group:1000 if root:0 is detected.\n\n04/10/2023\n\n - Just some logging stuff.\n - Found a couple of bugs surrounding downloading from photo albums/libraries. Squished.\n\n02/10/2023\n\n - A bunch of stuff regarding the new shared library support.\n - Fixed missing --enable-debugging and --disabled-debugging launch parameter validation.\n\n30/09/2023\n\n - Found a bug which was causing videos to be skipped. Fixed it.\n\n29/09/2023\n\n - Found that the path of the python_keyring firectory can be configured by setting the XDG_DATA_HOME variable. Configured that and then removed a bunch of code relating to moving it from /home/${user}/.local.\n\n27/09/2023\n\n - Thought I'd just commented out all the lines required for the shared library downloads. Turns out I'd removed the bit which validates command line options, so re-added those.\n - Also, realised that there was a mismatch between what the allowed command line variables were, and the actual variables. This affected all variables with more than one word in them, except for the latest one I added to upload Nextcloud files.\n\n26/09/2023\n\n - Re-enabled the libraries feature now upstream code has been merged to support shared libraries. Untested though, as I don't use libraries myself.\n\n20/08/2023\n\n - Added a bit to create some extra temporary files as some people are having issues with them.\n \n14/08/2023\n\n - Added Nextcloud connectivity check. My Nextcloud container was paused during a large offsite backup, so Nextcloud connectivity borked. This meant fails failed to upload and will not longer be retried. I can fix by running the function to upload the entire library, it's just a bit of a ballache, so I've added a connectivity check which will wait for the Nextcloud server to come back online. It will send a notification on the first failure, then again after an hour.\n - Added '--help' command line option which displays the configuration information. This is coz I couldn't remember the name of the function which uploads all files to Nextcloud when I was writing the above change log entry lol.\n\n02/08/2023\n\n - Amended the code so that it now checks for, and removes empty folders from the Nextcloud server after it's removed stuff from Recently Deleted. Works on the test uns I've done. Not nuked my photo store, which is good.\n - Also amended the code which parses the download logs for downloaded/deleted files. I used to extract column 5 to know what files to process. This doesn't work for file paths with spaces in them. I've now amended it so that it cuts from column 9 upwards, which should give me the whole file path, including spaces. Haven't tested anything yet. Wish me luck. Wow. It worked first time! Tested downloads, deletes, uploads to Nextcloud, deletes from Nextcloud. Life is good. \n - Written a function which allows uploading of the entire library to Nextcoud in one go... Invoke with sync-cloud.sh --upload-library-to-nextcloud.\n - Amended the command line parameters so that ones that are multiple word, have spaces separated by hyphens like the command above.\n - Removed a few more checks to see if variables are present, over an acual value of true/false.\n\n01/08/2023\n\n - Well, that's the code in to delete empty folders. It's a bit of a hack. Basically I parse the XML that is returned and count the number of links it contains, if it only has a single link (a reference to the folder itself) then the directory is removed. If there is more than one link, the directory is left in place. This is probably going to delete loads of stuff by mistake, but here goes.\n\n31/07/2023\n\n - So, it turns out that when uploading to Nextcloud via WebDAV, the file paths are not automatically created when you 'put' a file. In addition to that, when you create a pathname, you can't automatically create all the folders in the path at once (e.g. mkdir --parents /folder1/folder2/folder3). New change now creates a unique list of the directory names from the list of newly downloaded files. It then checks if each directory in turn exists, and if not, creates it. I guess I need to look at pulling the properties of the folder, checking if it is empty, and if it is, removing it during the file removal function. Otherwise I may end up with empty folders on my Nextcloud server.\n\n24/07/2023\n\n - Simplified the logic for auth_china. I want to eliminate chcking for the presence of a variable as being **true** and absence of a variable as **false*. This results in a tendancy towards **true*, because if it contains any value at all, it's considered **true**. Someone had configured a variable to be **false**, which means it is technically **true**. Logic is now that `if [ \"${auth_china:=false}\" = true ]`. This kinda flips it. Now, it's only true if it's set to **true**. If it's set to **motorboat** it's now technically **false**.\n\n23/07/2023\n\n - Changed how the icloud_china variable is processed. I was just checking if the variable was present, so setting it to **false** was equivalent to **true**.\n - Oops. Didn't test that one very thoroughly. Forgot that notifications check if the **icloud_china** variable is empty if they want to send English notifications. Pushed a new version to correct that.\n\n22/07/2023\n\n - Did some stuff around cookie creation. Script would progress immediately after cookie file was created, however, this happens when the user is prompted to authenticate, so background script would continue as user is confirming 2FA.\n - Changed 2FA to MFA. The correct term is Multi-Factor Authentication, not two factor authenticaion.\n - Introduced a bug as I forgot to change the healthcheck.sh... oops.\n - I'm not sure when I did this, but I scrapped the older_function thing as I'd changed how this process worked and it is no longer needed.\n\n21/07/2023\n\n - Added a function to check if the cookie exists. Two of my containers' cookies expired and the auto-heal feature kept restaring them. This meant when they were starting up they were attempting to connect to iCloud so they could list the available abums. This was causing an MFA prompt. New function just pauses the script if a cookie does not exist.\n\n11/07/2023\n\n - Synology systems create multiple directories which contain extended attributes, such as thumbnails. These will be seen as \"eaDir*\" directories. New variable added to skip changing permissions on these directories. PR submitted by tsanie.\n\n09/07/2023\n\n - Rewrite of remot sync function. Should be a little bit more reliable, as the previous one would get differeing results back from the Telegram API. Now it goes by update ID and stores it's progress to a file, so that it doesn't fail to retrive a correct value at boot.\n - Added function to remove deleted files from Nextcloud.\n\n04/07/2023\n\n - Re-enabled **delete_after_download* functionality as recent fix has been merged upstream.\n - Altered the clean up of the *notification_title* so that it does not apply to the commonly used Chinese notification methods.\n - New function to Nextcloud server. This allows uploading directly to a Nextcloud server, rather than just dropping a file for a different container to monitor and then start a manual sync.\n\n03/07/2023\n\n - Rebuilt with iCloud Photos Downloader 1.14.2\n\n27/06/2023\n\n - Rebuilt with Alpine Linux 3.18.2 and iCloud Photos Downloader 1.13.4\n\n26/06/2023\n\n - Just chown the tmp and configu folders as some people seem to be having issues with keyring file which is solved by moving the file from the true location to the /config dir location. Possibly a permissions issue. Not sure.\n - The Telegram polling is still acting weird. Sometimes, the latest message reported by the telegram API will actually be an older message, then a second call to Telegram's API will return a higher number. Also, after a while, all messages will just disappear, meaning null values are passed back. Hopfully these should be fixed now.\n - New variable added **albums_with_dates** which should allow albums to be downloaded to folders with the album name, and then split by date.\n\n22/05/2023\n\n - Send notification when remote sync command received.\n\n04/05/2023\n\n - Out of range issue polling for Telegram wake command.\n\n26/04/2023\n\n - Added **skip_album** variable so that certain albums (such as the Apple default ones) can be excluded from the download.\n\n25/04/2023\n\n - Unexpected behaviour when latest message is an update about group membership. This change will set ${latest_message} to ${current_message} if ${latest_message} is empty.\n - Now supports downloading from multiple folder albums, and saving them into folders named accordingly.\n\n24/04/2023\n\n - Bug fix for folder structure.\n - Possible solution for Telegram polling issue.\n\n23/04/2023\n\n - Set the function to configure file ownership to use user and group ids (instead of names) as this was failing to set the correct permisisons prior to the accounts being created (brand new containers).\n\n202304022\n\n - So, I messed up and accidentally pushed a version I was working on, to Dockerhub and to Github, which contained my Telegram API token. I had to delete the latest tag from Dockerhub, reset the master branch on GitHub and rotate my Telegram token. What a pain in the arse. That means this latest version is a little rushed, so don't be surprised if it's broken. It does bring within it a cracking new feature though... I've now coded it so it polls the Telegram chat (the one it normally sends notifications to), and if the latest message is the same as the **user** variable, it will force an immediate sync. That way, if you've taken a load of photos on your phone, you can tell your NAS at home to sync the queue once you're done.\n - This is just a change to the documentation. There has been a variable for Telegram **telegram_silent_file_notifications** which sends the telegram notifications for download/delete previews silenetly, I just noticed it's not been documented so I thought I'd change that.\n - I've re-enabled the **delete_after_download** option as it's been implemented correctly upstream and newly released.\n - I've also removed the i386 build platform from my images. They're failing to compile as they can't build a wheel for cryptography. I'm hoping nobody complains, but it they do I'll look at trying to re-add it in.\n\n10/04/2023\n\n - So many changes, I've forgotten most of them... Um... now I use Python virtual environments to install mutliple versions of icloud-photos-downloader... It incorporates v1.12.0, which is used for downloading photos globally. It also uses a modified version of v1.7.3 which allows authentication against the China servers. Also rebased the image to use Alpine 3.17.3. \n\n03/04/2023\n\n - Changed any \"True/False\" variable to \"true/false\" and also find/replace title cased variables in icloudpd.conf to lower case.\n\n01/04/2023\n\n - Some stuff around how build tags are handled in docker buildx. Mainly so that I have versioning in Dockerhub, instead of only a single \"latest\" container.\n - Delete after download option removed due to bug where it deletes files from iCloud that have not been downloaded yet.\n\n01/04/2023\n\n - New build refers to --china-mainland rather than --domain cn.\n - FFS, I typo'd it as --china_mainland.\n\n31/03/2023\n - Rebuilt using icloudpd and integrating PR 608 https://github.com/icloud-photos-downloader/icloud_photos_downloader/pull/608 in an attempt to fix the on going China authentication issue.\n\n30/03/2023\n\n - Got rid of auth_china variable, as it doesn't work.\n\n29/03/2023\n\n - Altered the way the log file creation works so that it can add missing/future variables and sort it into alphabetical order. \n\n28/03/2023\n\n - Urgh. It's filth, but it might just work... Docker container downloads a forked copy of icloud_photos_downloader which has been customised to work with China's authentication servers. The cookie generation function will now swap out/in these versions of the files if the auth_china variable is set to True, or just set really, I'm not fussy on this one.\n - Added a --enabledebugging and a --disabledebugging command line option which will edit the config file to enable/disable debugging for people who may find editing a file a little trickier on some systems... I'm thinking NAS devices may not make this so easy.\n - Made it so that the script reads the value of the debug_logging variable prior to each sync. That way debug logging can be switched on using the command line and it will apply on the next run.\n\n26/03/2023\n\n - Complete overhaul of logging system. A DEBUG log now introduced which removes a lot of the standard logging and puts it behind this option. When it's enabled, it will hide some of the sensitive data such as e-mail address, Apple ID and tokens.\n - Complete overhaul of variables. Docker variables are now pushed into the icloudpd.conf log file stored in the config directory. This allows users to toggle options by just changing the log file and restarting the container. This will allow people to switch on/off deug logging, or change the notification method without having to remove and recreate the container.\n - The --ConvertAllHEICs function was missing a command to create the destination folders. This broke the cuntion is being used in conjunction with the jpeg_path variable.\n\n15/03/2023\n\n - Rebuild to Apline Linux 3.17.2 and icloudpd 1.12.0\n - Added delete_after_download variable. This moves all downloaded files to 'Recently Deleted'. Cannot be used with auto_delete variable.\n - Added support for Telgram proxy server using the variable telegram_server.\n\n08/02/2023\n\n - Added function to delete all JPGs that have an accompanying HEIC. Use --RemoveAllJPGs to remove that data. Be warned, JPGs that have matching names with a HEIC file in the same folder will be removed. They may not necessarily be the same photo. Use with car and only if you know what you are doing.\n\n28/12/2022\n\n - Added details in readme warning users about enabling Apple's new Advanced Data Protection feature in iOS 16.2\n - Changed the way permissions and ownership is applied so that it it only applies permissions to the download directory after a sync, rather than at multiple different times.\n - Slight change needed to user creation due to rebase to Alpine 3.17\n\n03/12/2022\n - Added --Init so I'm less likely to typo it.\n - When downloading from libraries it now lists available libraries to the log file.\n - The iOS16 shared libraries patches have been moved to a new container tagged as \"testing\", something isn't quite right as many people are reporting errors.\n\n21/11/2022\n\n - iOS 16 shared libaries can now be downloaded with the --library option. PR courtesy of Patrice Neff  https://github.com/pneff.\n - Added support for WeCom proxy via PR submitted by Alano-i and Sowevo.\n\n08/10/2022\n\n - Incorrectly named variable. changed bark_key to bark_device_key.\n\n26/09/2022\n\n - Amended the log entries so that the warning about setting icloud_china variable only appears if it's not already set. Also changed it to prompt the user to log into iCloud.com and make sure there are no pop-up notifications.\n\n23/09/2022\n\n - Bug in --RemoveKeyring preventing it from launching.\n\n12/09/2022\n\n - Documentation updated, changed --DeleteKeyring to --RemoveKeyring.\n - Added feature to place converted JPEGs into different folder from the download location.\n\n08/09/2022\n\n - Keyring file wasn't actually being removed during container initialisation... Bizarre. Always thought it was. Maybe I removed it while ago, but forgot. Added a --DeleteKeying command line switch to remove the keyring file, if it exists.\n\n28/08/2022\n\n - Bark modifications.\n\n27/08/2022\n\n - Amended error relating to unindexed an library. Error says to wait minutes, it should say hours.\n\n24/08/2022\n\n - Added Bark notifications (untested)\n - Two fixes required for Python 3.10+ support.\n - Pull request: Merged PR from rmlanghopto to add Gotify notifications.\n\n28/07/2022\n\n - Set the function, which corrects the owner and permissions, to run after a successful download. Now permissions are corrected immediately after files are downloaded, rather than at the start of the next scheduled synchronisation.\n - Moved the Nextcloud trigger to the donwloaded/deleted files notification sections (as it's essentially notifying Nextcloud that it needs to sync), but also because where it was currently executing, meant that it would only trigger a sync on successful downloads, not if files had simply been removed. Now it will trigger a Nextcloud oneither of those two events.\n\n27/07/2022\n\n - Added trigger_nextlcoudcli_synchronisation variable.\n\n20/07/2022\n\n - Changed the notification events so that they can have a larger range of icons and different ones too.\n - Gone live with some changes to WeCom notifications.\n - Amended the find command to ignore symbolic links when changing the group on downloaded files and their folders. This is due to the Synology Photos app creating symlinks in the download folders.\n\n19/07/2022\n\n - Partially added some Chinese translations, still a few questions about some other changest that have been requested, so holding off on all of them.\n - Cookie expiration is not working for expired cookies, only the notifications about expiry. This change should change the icon in the notification to the alert symbol when cookie has actually expired.\n - Reverted the changes that were put in place to support root user. Running as root user is really bad, and I probably should have just sacked it off when it was requested, so I'm putting it back to how it was because some people using unRAID devices have seen a load of issues, because they're actually running the thing as root... Why even is that?\n\n17/07/2022\n\n - Evaluate the home directory location of the user... If user is root, home is located at /root. On CoreElec/LibreElec/OpenElec, then the user's home directory is in /storage. This change should work for either of those scenarios.\n\n16/07/2022\n\n - Allow badnames when creating user id.\n - UNTESTED BETA: Added WeCom, the official method of WeChat notifications.\n\n20/05/2022\n\n - Add option to download from single album.\n\n18/05/2022\n\n - Bug in logic about 2FA renewal reminders means they aren't being sent out daily. I've changed logging to help identify where the problem lies.\n\n30/04/2022\n\n - Added single_pass variable which runs the sync process once before exiting out.\n\n28/04/2022\n\n - Merged PR from  eliempje (https://github.com/boredazfcuk/docker-icloudpd/pull/155) which adds Openhab functionality.\n\n11/04/2022\n - Apparently Synology devices have a Photos app which doesn't update when a download takes place. The newly created files need to be touched for it to trigger a re-index. I've added a new variable which will touch a file to trigger the update, then set it back to what it was to maintain integrity.\n\n04/03/2022\n\n - Added a check for the IP address lookup performed during initialisation. Previously this could fail if the DNS server was not available (due to container starting on same system as a DNS container). It will now retry the lookup for 2mins before failing.\n - Changed cookie generation name from Generate2FACookie to GenerateCookie as it generates both types of cookie and is run no matter what cookie type you use. Also, changed the log output so it doesn't say \"Generating 2FA Cookie\" when generating a Web cookie.\n - Urgh. I dunno about you, but sometimes I delete a bunch of stupid memes off my phone and it ends up leaving my folder_structure with empty directories. I've now added a variable delete_empty_directories which will tidy those up.\n\n20/02/2022\n\n - The timezone variable is not being set globally if it's not specified, so the underlying Python script generates a warning. The TZ variable is now defaulted to UTC in the Dockerfile which should take care of this.\n - Added an extra synchronisation interval of 21600, which synchronises every 6 hours. This generates a warning message detailing the potential issue and fix, and includes a 2 minute wait on container start time to make the warning prominent.\n - Pushover notifications not showing downloaded/deleted file previews.\n - Added function to allow deletion of HEIC accompanying files. These would be the converted JPG files (if using the HEIC to JPG conversion feature) and the_HEVC.MOV files which come with live photos.\n - Bug found with sending Telegram notifications if e-mail address has an _ character in it. The _ character wasn't escaped correctly when passing the text to the Telegram API.\n - The Notify function is always called, even if notifications aren't configured. A log entry was still being processed and the logic for determining a success/failure of the sent message was being performed too, resulting in an 'out of range' error, as an empty variable was being processsed.\n\n18/02/2022\n\n - Cookie expiry notification period was being defaulted in the Initialise function and also for every notification type configured in the ConfigureNotifications function. Removed these as they're just duplicates. Also corrected a bug which would override user configured period, configuring it to 7.\n - Logic for skipping the file check was checking if value it true, then following two if statements had to check if it was set to false. Don't really like the OR tests that needed to be done so adjusted the logic two set the check_exit code and check_files_count to values that will always perform a sync, as they should never change due to CheckFiles function never being run.\n - Script doesn't seem to reliably send the \"once per day\" notifications during the nofitication expiry period. So have added a log entry which details the next notification time.\n - Huge overhaul of notification system. Probably broken everything lol. I've tested Telegra, Prowl, Discord and Pushover. I don't have any of the other methods to test though, so can't guarantee they work, or are formatted correctly. I've standardised the way notifications are sent to the Notify function. This way, only one notification command is needed to send notifications for all types and the formatting of the messages is now handled by the Notify function.\n\n11/02/2022\n\n - Introduced a bug with my error handling from the last update. Now I create the error and exit_code log files in the Initialisation function of the script so that the correct permisions are applied. Problem was that the files were being created as root, and then the python script didn't have permission to them.\n - Status code checking for the curl command when sending notifications would only accept 200 as a success. Discord reports 204. I've amended the checking code to just accept 2xx.\n\n10/02/2022\n\n - Handle errors differently. Added suggestions for authentication failure issues.\n - Eliminated full stops from log entries. Some lines had them, others didn't, so standardised on not having them. We don't need them. They take up precious bytes. They giving me flashbacks to COBOL.\n\n09/02/2022\n\n - Broke out logging into three separate functions. Just because. I dunno. Having tonnes of $(date '+%Y-%m-%d %H:%M:%S') commands in the script just looked a bit weird. Plus if I even need to change it, it's three lines instead of a find/replace of a bazillion.\n - Set ConfigureNotifications function to check for presence of Dingtalk token, instead of ID, to decide whether to fail or not. Same as the other methods (except webhook, which doesn't use tokens).\n - Altered priority for Pushover warning/error notifications. Previously they were set to -2, which gives no alert, only changes the icon badge number. Now it sends a standard priority alert for all notification types, except the one that alerts you that your cookie will run out that day, which is a \"quiet hours breaking\" notification (same for Prowl).\n\n06/02/2022\n\n - Amended the code which sends to Pushover notifications. Originally this was two separate commands, depending on whether the pushover_sound variable was sent. This is not needed, as Pushover will use the default sound is a blank value is sent for the \"sound\" argument.\n\n04/02/2022\n\n - Changed notification failure log messages to be more accurate and display http status code.\n - Prowl notifications logging not quite right.\n - Standard notification log message.\n - Moved some stuff to prevent duplication of code.\n\n23/01/2022\n\n - Added variable to set custom sounds for Pushover notification type. This can be used to silence notifications.\n\n12/12/2021\n\n - Fix bug introduced by moving to useradd/groupadd.\n\n11/12/2021\n\n - Amended domain and route checks to be compatible with icloud_china variable. No point checking the route to icloud.com is OK when the container downloads from icloud.com.cn.\n - Change to IYUU notifications, which should now get these working, and integrated changes to live.\n - Users and Groups now created with useradd/groupadd instead of adduser/addgroup to allow the creation of users/group with an id greater than 256,000.\n\n30/11/2021\n\n - Final text alert for cookie expiration not received. Made a couple of changes. Will check again in 3 months time.\n\n27/11/2021\n\n - Added the IYUU notification type. This is a 3rd party service which supports forwarding messages to WeChat.\n\n25/11/2021\n\n - Added variable icloud_china so that photos are downloaded from icloud.com.cn instead of icloud.com \n - Removed readme information about obsolete variable interavtive_only. The readme is nearing it's maximum size on Dockerhub, so this helps keep tthe number of characters down.\n\n21/11/2021\n\n - Amended healthcheck so that it does not set the status to unhealthy if notification days is less than 7. This was causing my auto-heal container to automatically restart it every 5mins. This behaviour now only occurs when the cookie has actually expired.\n - Made script launch parameters case insensitive and also allowed for non-English spelling of Initialise.\n\n24/00/2021\n\n - Set icloud.com DNS query type to 'a' records only so that it returns the IPv4 IP address and not IPv6. Also, removed the local loopback addresses, just to remove more unwanted data.\n\n20/10/2021\n\n - Discord notifications added by @ibtvt.\n\n17/10/2021\n\n - Added detection for when a file has been downloaded, but also exists in 'Recently Deleted', so gets removed post download. In these cases, it should get rid of the missing file errors.\n\n21/09/2021\n\n - Added DNS lookup and traceroute to check network connectivity to icloud.com.\n\n15/09/2021\n\n - Removed the code which removes hyphen characters from the Telegram chat ID. The hyphen character is used to denote the bot has been added to a group to send messages, rather than a standard user chat.\n\n13/09/2021\n\n - Replicated recent whitespace changes to additional functions for completeness.\n - Force convert HEICs functions now remove pre-existing JPG files as I don't think the convertion tool is overwriting pre-existing files.\n\n12/09/2021\n\n - Bug introduced by recent HEIC to JPEG change. Fixed.\n - Added set owner and permissions function to run after HEIC to JPEG conversion functions.\n - Added --ForceConvertAllmntHEICs.\n - Fixed bug in above new command line option as it wasn't handling spaces safely.\n\n06/09/2021\n\n - HEIC to JPEG coversion utility has a bug and rotates JPEG files when it shouldn't. Replaced with ImageMagick which doesn't have this problem.\n - Added --ForceConvertAllHEICs command line option to overwrite JPEG files. This is so over-rotated files can be replaced with crorrectly oriented versions.\n\n02/09/2021\n\n - Added a log entry to show the UID of the account that is running the script. It seems some users are having permissions issues and this will help with debugging.\n - Also changed the symbolic link command to force linking of python_keyring directory if something that isn't a link exists in its place.\n\n01/09/2021\n\n - Added logging for --ConvertAllHEICs function.\n - Amended way script handles expired cookies.\n\n30/08/2021\n\n - Amended script to wait for the cookie file to be created, then continuing once it's appeared. Container will auto restart after 30mins if file does not appear, just in case something has gone wrong.\n\n27/08/2021\n\n - Better way of calculating elapsed time.\n - Amended the logging so it lists the expiry time of expired 2FA cookies for clarity.\n - Amended the way the script waits for the keyring and failsafe files to be created. Instead of checking every 5 minutes before proceeding, script now checks every 5 seconds. This way, script is a bit more responsive when being initialised. If the script doesn't detect the file it's checking for after 30 minutes, it will exit the container, just in case there is a detection problem.\n - Added logging info explaining that the download check takes a long time on large collections and that nothing is being downloaded during that phase.\n - PR Merge: Changed how the webhook notification is handled for compatibility across more notification platforms.\n - Script now records time taken per synchronisation and subtracts this from the synchronisation_interval. This means a sync with a 12 hour interval will start 12 hours later and not skew by the amount of time it takes the sync to complete.\n\n27/08/2021\n\n - Locked version of tzlocal to 2.1 as lateat version introduces dependency which is not available in Python 3.8\n - Added variable manipulation on the Telegram chat ID to remove minus sign if it's included in the variable. It needs to be omitted when posting the data to the API.\n\n01/08/2021\n\n - Added some extra logging info.\n\n24/07/2021\n\n - Added function to sanitise command line parameters passed to script.\n\n19/07/2021\n\n - Download and Delete notification webhook payload JSON fix.\n - Remove ambiguity in DownloadedFilesNotification.\n\n16/07/2021\n\n - Sanitise notification_title variable.\n - Rebase to Alpine Linux 3.14.0\n\n13/07/2021\n\n - Modify 20210709 JSON escaping and fix minor change.log text.\n\n12/07/2021\n\n - Removed apple_password variable. Password must now be added to the system keyring.\n - Default mode now to download, interactive_only variable removed. This process was far more complex than it needed to be for Synology/QNAP devices, so a small change to the default operation makes things easier for everyone.\n - --Generate2FACookie command line option changed to --Initialise as it is also used for saving the password to the system keyring. Not just cookie generation.\n\n09/07/2021\n\n - Changed JSON escaping to prevent further issues.\n\n08/07/2021\n\n - Download check and actual download functions both exit with same error message. Changed for clarity about which section is failing.\n\n05/07/2021\n\n - JPEG quality mismatch in documentation and script. Default JPEG quality now referred to correctly in README.MD as 90.\n\n17/06/2021\n\n - Added script hash to make sure that the sync-icloud.sh file is correct file as date stamp seems to be affected by timezone.\n - Oddities occuring when creating password/cookie on devices which always run interactively.\n\n14/06/2021\n\n - Accurate health check output when approaching cookie expiration date.\n - Cookie expiration date checking improved.\n - Wasn't setting notification period for some of the notification options.\n - Notifications weren't firing in the notification period. Should now be fixed.\n\n07/06/2021\n\n - Code to remove empty keyring file requires logic to detect f file actually exists, otherwise brand new containers enter a file deletion loop. Logic amended.\n\n22/05/2021\n\n - Rebase to Alpine Linux 3.13.5\n - Now logs full version ID rather than just major/minor version.\n - Reddit user Vinnipinni made a comment that the documentation was great... so I've revisited it again to make sure it's up to date, corrected some spellings and grammar, and made a few improvements for clarity.\n\n22/05/2021\n\n - --size parameter was incorrectly set as --photo-size.\n\n19/05/2021\n\n - Added code to remove keyring file if it doesn't contain credentials.\n\n15/05/2021\n\n - New download link for Boost source as location changed.\n\n15/05/2021\n\n - Amended log output for when attempting to add a user to a pre-existing system group.\n\n22/03/2021\n\n - Amended log text after cookie generation. Script no longer claims 2FA cookie generated for all cases, but states 2FA/Web based on which was actually generated.\n - Chnage: Add Litecoin address. BTC network fees are expensive AF!\n\n04/03/2021\n\n - Added notification_title variable.\n - Readme changes to add full stops on lines where they were missing.\n\n28/01/2021\n\n - Added logging of $TERM variable.\n\n27/01/2021\n\n - Modified when the script check for the the --Generate2FACookie so that it can be invoked from NAS devices such a Synology and QNAP.\n\n19/01/2021\n\n - Added the --Generate2FACookie command line option.\n\n18/01/2021\n\n - Rebuilt on Alpine 3.13\n\n21/12/2020\n\n - Convert HEIC to JPEG functions now allow specifying the quality with and integer value from 0 to 100.\n\n16/12/2020\n\n - Sanitise apple_id variable so all letters are lower case. This prevents a case mismatch between the cookie file name that is saved, and the name that the icloudpd Python script creates the cookie file with, due to it respecting case.\n\n04/12/2020\n\n - Removed Pushbullet notifications. The Pushbullet service has introduced version 2 of its API so notifications no longer work. Pushbullet have also removed their app from the iOS App Store, so if it's no longer supported on iOS, there's no way to realistically support it here.\n\n03/12/2020\n\n - Upgraded pip.\n - Pushover notification bugfix. PR courtesy of @larstomas.\n - Webhook notification notification standardisation. PR courtesy of @larstomas again.\n - Altered failure piority for pushover notifications from -2 to 2 so they become emergency level notifications rather than silent. Change recommended by @larstomas.\n - Added variable to allow skipping of the new file check. On large photo collections, this can significantly increase the time taken to download.\n\n28/11/2020\n\n - Added log line to show the exact command line used to invole iCloudPD.\n\n21/11/2020\n\n - Due to changes in iOS14 the 2FA synchronisation interval is now limited to a maximum of once every 12 hours. It seems that 2FA authentication is now restricted to a maximum of 26 logins before re-authentication is required. Synchronisation is now restricted to specific time periods with the shortest being 12 hours.\n - New variable synchronisation_delay added. This is so that the first synchronisation can be dalayed for a number of minutes. This is so that multiple containers can stagger their downloads.\n\n201112\n\n - Bugfix. Convert HEIC to JPEG function would only run if download notifications were enabled.\n\n11/11/2020\n\n - Additional changes required for Pushover notifications.\n\n10/11/2020\n\n - Added Pushover notifications.\n - Failsafe file mount checking changed slightly regarding logging.\n - Added variable for the --until-found option as must have missed this on the 20201024 update.\n - Removed: Checking downloaded files list against files stored on the server is no longer required. Issue has been fixed upstream.\n\n11/04/2020\n\n - Bugfix on healthcheck not detecting non-zero exit code.\n\n01/11/2020\n\n - Removed: Multi-thread capability has been removed from upstream so removed capability to specify number of threads.\n - Removed: Speed test capability. Was put in to test speed differences between mutli-thread and single-thread download options. No longer possible due to previous change.\n - Bugfix. Convert HEIC to JPEG function - missed a bit.\n\n30/10/2020\n\n - Bugfix. Convert HEIC to JPEG function failing to set correct timestamp.\n\n29/10/2020\n\n - Remove pip cache folder /root/.cache during container build.\n - Removed: Recently files only doesn't work as expected. Removed.\n - Added --CorrectJPEGTimestamps command line option to correct timestamps of JPEG files.\n - Convert HEIC to JPEG functions don't preserve timestamps. Filestamp of JPEG now taken from HEIC file.\n - Default to downloading new files only by checking what files exist vs what needs downloading. This prevents it attempting to download all files upon every synchronisation.\n - Typo for Synchronisation Interval variable. This change will break users configurations that set the old variable name, so default to 24hr sync period for these users.\n\n27/10/2020\n\n - Silence warning about depreceated command_line_options varaible if it's actually blank to begin with.\n - Remove Python package Future. This is for Python 2 to Python 3 compatibility, however, upstream application now fully Python 3 compatible.\n - Python keyring and keyrings.alt no longer version restricted. Upstream application is now compatible with newer Python versions than before so these older packages no longer need to be installed.\n\n27/10/2020\n\n - Bugfix relating to Prowl & Pushbullet notifications.\n\n24/10/2020\n\n - Added new variables: set_exif_datetime, auto_delete, photo_size, skip_live_photos, live_photo_size & skip_videos. Eventually command_line_options variable will be removed.\n - Added a new \"CommandLineBuilder\" function to create the command line options list to be passed to the download command.\n\n22/10/2020\n\n - Added a speed test mode which ignores the requirement for a mounted filesystem. It limits the download to last 500 files.\n - Multi-threaded mode can now be enabled by setting the multi_thread variable. This will set the thread count to the number of available processors, multipled by five. If the variable is not configured, it will default to single threaded node. Please note: Multithreaded mode has known issues withe files that have duplicate file names. Use with caution.\n\n12/10/2020\n\n - Lowered 60 second delay for warning about password not being stored in keyring to 15 seconds as 60's a bit long.\n - Removed the check for files that have been downloaded already, as new icloudpd version uses photo fingerprinting to allow downloading of different pictures with identical names.\n - Added two variables, download_notifications and delete_notifications. If they are not set, they will default to True. To disable, set to False.\n - Dockerfile now installs pip dependencies using requirements.txt instead of having them specified in the dockerfile.\n - sync-icloud.sh script now shows the version of Python, icloudpd and pyicloud-ipd that are being used.\n - Noted that folder structure can now be set to 'none' to download to flat file structure.\n - diff file that applies the patch to skip incorrectly named files. Pull request has now been merged.\n\n09/09/2020\n\n - Undersocres now being used in cookie file name. Amended to reflect change.\n\n05/09/2020\n\n - Made the webhook path configurable.\n\n25/08/2020\n\n - Removed the Powershell script to build separate images for ARM architectures as I'm now producing a single multi-arch image without using Windows.\n\n23/08/2020\n\n - Version is now date and time of last modification of the sync-icloud.sh script.\n\n22/08/2020\n\n - Added force_gid variable so that user can be added to system groups to maintain consistency with host OS.\n - Rewrote the functions to create the user/group as it would fails if a system reseved group id is chosen.\n\n15/08/2020\n\n - Amended the interactive terminal check to see if /dev/stdin is a pipe. Odd issue seen on some systems.\n\n08/08/2020\n\n - Updated READ.ME.\n\n07/08/2020\n\n - Updated READ.ME.\n - Apply diff patch to fix album naming issue raised here: https://github.com/ndbroadbent/icloud_photos_downloader/issues/150.\n\n06/08/2020\n\n - Removed manual versioning in Dockerfile in favour of MD5 script hash. Means I don't need to track version numbers, or remember to increment them, but latest version can be confirmed quite easily from the log.\n - Added owner change to /config dir at start of ConfigurePassword function so password is successfully stored first time around.\n\n03/08/2020\n\n - Converted docker-compose.yml file to be 3.8 compatible. Removed networking configuration.\n\n03/08/2020\n\n - When using keyring it was claiming plaintext password was in use and vice versa.\n - Added a version number in Dockerfile to display when script first starts up.\n\n02/08/2020\n\n - Found that the --directory option is required. I wasn't including it when doing the 2FA authentication cookie generation which lead to an error.\n\n08/06/2020\n\n - Rebased to Alpine 3.12.\n - Display IP Address in log.\n\n28/05/2020\n\n - Alpha Changed Webhook notification messages.\n - Alpha Forgot to add webhook_id to the check which validates that the API keys have been set.\n\n27/05/2020\n\n - Alpha Webhook host_ip_address variable changed to webhook_server. Added webhook_port so a non-default port can be added.\n\n26/05/2020\n\n - Alpha: Webhook notifications implemented for Home Assistant. Based on Telegram notifications, but implemented without testing. Using them will probably break things as I'm unsure as to the format of the webhook payload.\n\n19/05/2020\n\n - Prefixed some of the files stored in /tmp/icloudpd with icloudpd_, just for consistency. Plus it's easier to remove them all with `rm icloudpd*` instead of multiple arguments to rm.\n - Keyring password saving. Previously, the Apple ID user's password could be seen in the Docker logs, the variables (docker inspect) and disturbingly, if any user did `ps -ef | grep password\", it would be seen in the command line of any running connection to iCloud. Script now heavily pushes users towards saving credentials into the secure encrypted keyring.\n - Saving password to text file has been removed (never made it to a release, but is doumented in the change log).\n - su doesn't pass variables to the account it uses. This meant that some variables that I thought were optional (user, config_dir, folder_structure) were actually mandatory. Command now built with $0 $1 $2 etc and variables passed via command line ( -- $bunch $of $options).\n - Debug logging variable removed. Always logging errors to screen.\n - Telegram notification success/failure messages now confirm message type (startup, download, delete, failure).\n - Cookie checking function would hang system without error if 2FA cookie does not exist.\n\n18/05/2020\n\n - Container now saves the Apple ID password to a file located in the /config volume. Once this has been done, the apple_password variable not longer needs to be passed to the container and should be removed.\n\n17/05/2020\n\n - Moved some of the logging commands so they triggered in more appropriate places.\n - File download check error notification incorrectly labelled as a startup notification.\n - Script wasn't properly handling passwords with special characters. Should be OK now.\n - Amended the failsafe error message so that the name and path of the file it is looking for is visible. Makes it easier for people to spot the capitalisation in iCloud.\n - File check exit code grabbing logic was flawed. Was actually grabbing the exit code of su, which was always 0.\n\n14/05/2020\n\n - Previous change didn't work. This actually fixes the issue that the list of files is no longer growing. However, it's only highlighted a different issue. A number of files are exhibiting weird behaviour. 5 files are being listed as downloaded, but only 3 filenames are unique. These files are then also being listed as having been deleted from the system. They are all stil in my photostream on iCloud.com and not in recently deleted. Coincidentally, they all start with camphoto_ but that may not be indicitive of anything.\n\n08/05/2020\n\n - My list of downloaded/deleted files seemed to be getting longer without me actively using my phone's camera. Guessing some variable isn't being cleared, so have localised a fair few variables to the functions they run in.\n\n30/04/2020\n\n - Added $debug_logging variable, which outputs errors to the screen instead of hiding them.\n\n13/04/2020\n\n - Removed PR 132. PR 132 was based off PR 110, which was raised in 2018. Neither had been merged. Obviously, after I spent an hour or so chainging my Dockerfile to incorporate the patch, it was merged upstream!\n\n12/04/2020\n\n - Added PR 132: \"Multi-threaded downloads and caching\" from https://github.com/ndbroadbent/icloud_photos_downloader/pull/132.\n - Added quotes to variables to prevent globbing in download check and photo download functions.\n\n13/03/2020\n\n - Added interactive_only variable. Some hosts only run containers interactively (looking at you Synology) and this means the script gets stuck attempting to create a 2FA cookie every time. Setting interactive_only will force the script to bypass the cookie generation function and sync files instead.\n\n13/03/2020\n\n - Log now displays OS version.\n\n09/03/2020\n\n - Removed feature to delete JPG file if the HEIC has been removed. Floored logic in that all files exist in a single location, which doesn't match their original location. Also, JPG files received by WhatsApp would be removed as would JPG files saved from Safari. Can't work in practice.\n - Script now has a command line parameter that can be run from an interactive session. --ConvertAllHEICs will scan all HEIC files and convert them to JPG, provided the JPG doesn't exist already.\n - Convert HEIC to JPEG not working correctly.\n\n17/02/2020\n\n - Running the sync client with \"--only-print-filenames\" actually creates folders too. File check now run as user account instead of root to avoid ownership issues.\n\n11/02/2020\n\n - Fancy Telegram notifications caused the underscore characters in the file previews to be displayed in italics. Should be correctly escaped now.\n\n09/02/2020\n\n - Odd issue where owner on config directoy changed to root. Added chown at start of sync to fix this, and also to Owner/Permissions setting function.\n - Fancy pants Telegram notifications with emojis.\n - Telegram URL Encoding function. Now sending markdown text and UTF-8 for special characters.\n - Renamed $syncronisation_interval variable to $synchronisation_interval.\n\n23/01/2020\n\n - Now based on Alpine Linux 3.11.\n - Apple ID displayed on push notifications.\n - ARM images rebuilt to latest version.\n\n22/01/2020\n\n - HEIC to JPEG conversion.\n - JPEG removal if original HEIC  removed (experimental, backup your files!).\n - Code changes for readability and simplicity.\n - Added example docker-compose.yaml.\n\n18/01/2020\n\n - Variable name changes for readability and naming accuracy.\n - Pre-download check for new files so a download run will only occur if new files exist.\n - Telegram notifications.\n - Synchronisation summary. Number of new files downloaded. Number of deleted files (if --auto-delete enabled).\n - Telegram notifications only: List of downloaded filenames (10 max). List of deleted files (10 max).\n - Startup notification.\n - Configurable permissions on the download destination directory.\n - Logic re-writes for simplicity and optimisation.\n - Additional logging.\n - Code clean-ups.\n - Healthcheck update.\n"
        },
        {
          "name": "docker-compose",
          "type": "tree",
          "content": null
        },
        {
          "name": "healthcheck.sh",
          "type": "blob",
          "size": 2.4951171875,
          "content": "#!/bin/bash\n\nsource \"/config/icloudpd.conf\"\n\nif [ -f \"/tmp/icloudpd/icloudpd_check_exit_code\" ] || [ -f \"/tmp/icloudpd/icloudpd_download_exit_code\" ]\nthen\n   if [ -f \"/tmp/icloudpd/icloudpd_download_exit_code\" ]\n   then\n      download_exit_code=\"$(cat /tmp/icloudpd/icloudpd_download_exit_code)\"\n      if [ \"${download_exit_code}\" -ne 0 ]\n      then\n         echo \"File download error: ${download_exit_code}\"\n         exit 1\n      fi\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_check_exit_code\" ]\n   then\n      check_exit_code=\"$(cat /tmp/icloudpd/icloudpd_check_exit_code)\"\n      if [ \"${check_exit_code}\" -ne 0 ]\n      then\n         echo \"File check error: ${check_exit_code}\"\n         exit 1\n      fi\n   fi\nelse\n   echo \"Error check files missing.\"\n   exit 1\nfi\n\nif [ -s \"/tmp/icloudpd/icloudpd_check_error\" ] || [ -s \"/tmp/icloudpd/icloudpd_download_error\" ]\nthen\n   if [ -f \"/tmp/icloudpd/icloudpd_check_error\" ]\n   then\n      echo \"Errors reported during file check\"\n      exit 1\n   fi\n   if [ -s \"/tmp/icloudpd/icloudpd_download_error\" ]\n   then\n      echo \"Errors reported during file download\"\n      exit 1\n   fi\nfi\n\ncookie=\"$(echo -n \"${apple_id//[^a-zA-Z0-9_]}\" | tr '[:upper:]' '[:lower:]')\"\nif [ ! -f \"/config/${cookie}\" ]\nthen\n\techo \"Error: Cookie does not exist. Please generate new cookie\"\n\texit 1\nfi\n\nif [ \"${authentication_type:=MFA}\" = \"MFA\" ]\nthen\n   mfa_expire_date=\"$(grep \"X-APPLE-DS-WEB-SESSION-TOKEN\" \"/config/${cookie}\" | sed -e 's#.*expires=\"\\(.*\\)Z\"; HttpOnly.*#\\1#')\"\n   mfa_expire_seconds=\"$(date -d \"${mfa_expire_date}\" '+%s')\"\n   days_remaining=\"$(($((mfa_expire_seconds - $(date '+%s'))) / 86400))\"\n   if [ -z \"${notification_days}\" ]\n   then\n      notification_days=7\n   fi\n   if [ \"${days_remaining}\" -le \"${notification_days}\" ] && [ \"${days_remaining}\" -ge 1 ]\n   then\n      echo \"Warning: Multi-factor authentication cookie is due for renewal in ${notification_days} days\"\n   elif [ \"${days_remaining}\" -lt 1 ]\n   then\n      echo \"Error: Multi-factor authentication cookie has expired\"\n      exit 1\n   fi\nelif [ \"${authentication_type}\" = \"Web\" ]\nthen\n   web_cookie_expire_date=\"$(grep \"X_APPLE_WEB_KB\" \"/config/${cookie}\" | sed -e 's#.*expires=\"\\(.*\\)Z\"; HttpOnly.*#\\1#')\"\n   web_cookie_expire_seconds=\"$(date -d \"${web_cookie_expire_date}\" '+%s')\"\n   days_remaining=\"$(($((web_cookie_expire_seconds - $(date '+%s'))) / 86400))\"\nelse\n   echo \"Error: Authentication type not recognised\"\n   exit 1\nfi\n\necho \"iCloud Photos Downloader successful and ${authentication_type} cookie valid for ${days_remaining} day(s)\"\n\nexit 0"
        },
        {
          "name": "icloudpd.dockerfile",
          "type": "blob",
          "size": 1.333984375,
          "content": "FROM alpine:latest\nLABEL maintainer=\"boredazfcuk\"\n\nENV XDG_DATA_HOME=\"/config\" TZ=\"UTC\" ENV=\"/etc/profile\"\n\nARG icloudpd_version=\"1.25.0\"\nARG build_dependencies=\"gcc python3-dev libc-dev libffi-dev cargo openssl-dev\"\nARG app_dependencies=\"bash findutils nano nano-syntax py3-pip exiftool coreutils tzdata curl libheif imagemagick shadow jq jpeg bind-tools expect inotify-tools msmtp\"\n\nRUN echo \"$(date '+%d/%m/%Y - %H:%M:%S') | ***** Build started for boredazfcuk's docker-icloudpd *****\" && \\\necho \"$(date '+%d/%m/%Y - %H:%M:%S') | Install requirements\" && \\\n   apk add --no-progress --no-cache --virtual build ${build_dependencies} && \\\n   apk add --no-progress --no-cache ${app_dependencies} && \\\n   find /usr/share/nano -name '*.nanorc' -printf \"include %p\\n\" >>/etc/nanorc && \\\necho \"$(date '+%d/%m/%Y - %H:%M:%S') | Install iCloudPD latest release\" && \\\n   python -m venv /opt/icloudpd && \\\n   source /opt/icloudpd/bin/activate && \\\n   pip3 install --upgrade pip && \\\n   pip3 install --no-cache-dir icloudpd && \\\n   deactivate && \\\n   apk del build\n\nCOPY build_version.txt /opt\nCOPY --chmod=0755 *.sh /usr/local/bin/\nCOPY authenticate.exp /opt/authenticate.exp\nCOPY CONFIGURATION.md /opt\nCOPY profile /etc/profile\n\nHEALTHCHECK --start-period=10s --interval=1m --timeout=10s CMD /usr/local/bin/healthcheck.sh\n  \nVOLUME \"/config\"\n\nCMD /usr/local/bin/launcher.sh\n"
        },
        {
          "name": "init_config.sh",
          "type": "blob",
          "size": 34.892578125,
          "content": "#!/bin/bash\n\nconfig_file=\"/config/icloudpd.conf\"\n\nif [ ! -d \"/config\" ]\nthen\n   if ! mkdir /config\n   then\n      echo \"Failed to configuration directory: /config\"\n      echo \" - Cannot continue. Check your volume mount is not read-only. Check NFS/SMB share permissions if mounting to a shared location\"\n      sleep infinity\n   fi\nfi\nif [ ! -f \"${config_file}\" ]\nthen\n   if ! touch \"${config_file}\"\n   then\n      echo \"Failed to create configration file: ${config_file}\"\n      echo \" - Cannot continue. Check your volume mount is not read-only. Check NFS/SMB share permissions if mounting to a shared location. Check you container has root permissions.\"\n      sleep infinity\n   fi\nfi\nif [ ! -f \"${config_file}\" ]\nthen\n   echo \"Config file appears to be a directory: ${config_file}\"\n   echo \" - Cannot continue. Check your volume mount.\"\n   sleep infinity\nfi\n\n# Add missing options and set their default value\n{\n   if [ \"$(grep -c \"^albums_with_dates=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo albums_with_dates=\"${albums_with_dates:=false}\"\n   fi\n   if [ \"$(grep -c \"^align_raw=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo align_raw=\"${align_raw:=as-is}\"\n   fi\n   if [ \"$(grep -c \"^apple_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo apple_id=\"${apple_id}\"\n   fi\n   if [ \"$(grep -c \"^authentication_type=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo authentication_type=\"${authentication_type:=MFA}\"\n   fi\n   if [ \"$(grep -c \"^auth_china=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo auth_china=\"${auth_china:=false}\"\n   fi\n   if [ \"$(grep -c \"^auto_delete=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo auto_delete=\"${auto_delete:=false}\"\n   fi\n   if [ \"$(grep -c \"^bark_device_key=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo bark_device_key=\"${bark_device_key}\"\n   fi\n   if [ \"$(grep -c \"^bark_server=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo bark_server=\"${bark_server}\"\n   fi\n   if [ \"$(grep -c \"^convert_heic_to_jpeg=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo convert_heic_to_jpeg=\"${convert_heic_to_jpeg:=false}\"\n   fi\n   if [ \"$(grep -c \"^debug_logging=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo debug_logging=\"${debug_logging:=false}\"\n   fi\n   if [ \"$(grep -c \"^delete_accompanying=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo delete_accompanying=\"${delete_accompanying:=false}\"\n   fi\n   if [ \"$(grep -c \"^delete_after_download=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo delete_after_download=\"${delete_after_download:=false}\"\n   fi\n      if [ \"$(grep -c \"^keep_recent_days=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo keep_recent_days=\"${keep_recent_days:=0}\"\n   fi\n   if [ \"$(grep -c \"^delete_empty_directories=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo delete_empty_directories=\"${delete_empty_directories:=false}\"\n   fi\n   if [ \"$(grep -c \"^delete_notifications=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo delete_notifications=\"${delete_notifications:=true}\"\n   fi\n   if [ \"$(grep -c \"^dingtalk_token=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo dingtalk_token=\"${dingtalk_token}\"\n   fi\n   if [ \"$(grep -c \"^directory_permissions=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo directory_permissions=\"${directory_permissions:=750}\"\n   fi\n   if [ \"$(grep -c \"^discord_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo discord_id=\"${discord_id}\"\n   fi\n   if [ \"$(grep -c \"^discord_token=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo discord_token=\"${discord_token}\"\n   fi\n   if [ \"$(grep -c \"^download_notifications=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo download_notifications=\"${download_notifications:=true}\"\n   fi\n   if [ \"$(grep -c \"^download_path=\" \"${config_file}\")\" -eq 0 ]\n   then\n        user=\"$(grep \"^user=\" \"${config_file}\" | awk -F= '{print $2}')\"\n        echo download_path=\"${download_path:=/home/${user:=user}/iCloud}\"\n   fi\n   if [ \"$(grep -c \"^fake_user_agent=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo fake_user_agent=\"${fake_user_agent}\"\n   fi\n   if [ \"$(grep -c \"^file_match_policy=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo file_match_policy=\"${file_match_policy:=name-size-dedup-with-suffix}\"\n   fi\n   if [ \"$(grep -c \"^file_permissions=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo file_permissions=\"${file_permissions:=640}\"\n   fi\n   if [ \"$(grep -c \"^folder_structure=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo folder_structure=\"${folder_structure:={:%Y/%m/%d\\}}\"\n   fi\n   if [ \"$(grep -c \"^force_gid=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo force_gid=\"${force_gid:=false}\"\n   fi\n   if [ \"$(grep -c \"^gotify_app_token=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo gotify_app_token=\"${gotify_app_token}\"\n   fi\n   if [ \"$(grep -c \"^gotify_https=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo gotify_https=\"${gotify_https}\"\n   fi\n   if [ \"$(grep -c \"^gotify_server_url=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo gotify_server_url=\"${gotify_server_url}\"\n   fi\n   if [ \"$(grep -c \"^group=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo group=\"${group:=group}\"\n   fi\n   if [ \"$(grep -c \"^group_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo group_id=\"${group_id:=1000}\"\n   fi\n   if [ \"$(grep -c \"^icloud_china=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo icloud_china=\"${icloud_china:=false}\"\n   fi\n   if [ \"$(grep -c \"^iyuu_token=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo iyuu_token=\"${iyuu_token}\"\n   fi\n   if [ \"$(grep -c \"^jpeg_path=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo jpeg_path=\"${jpeg_path}\"\n   fi\n   if [ \"$(grep -c \"^jpeg_quality=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo jpeg_quality=\"${jpeg_quality:=90}\"\n   fi\n   if [ \"$(grep -c \"^keep_unicode=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo keep_unicode=\"${keep_unicode:=false}\"\n   fi\n   if [ \"$(grep -c \"^libraries_with_dates=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo libraries_with_dates=\"${libraries_with_dates:=false}\"\n   fi\n   if [ \"$(grep -c \"^live_photo_mov_filename_policy=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo live_photo_mov_filename_policy=\"${live_photo_mov_filename_policy:=suffix}\"\n   fi\n   if [ \"$(grep -c \"^live_photo_size=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo live_photo_size=\"${live_photo_size:=original}\"\n   fi\n   if [ \"$(grep -c \"^nextcloud_delete=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo nextcloud_delete=\"${nextcloud_delete:=false}\"\n   fi\n   if [ \"$(grep -c \"^nextcloud_upload=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo nextcloud_upload=\"${nextcloud_upload:=false}\"\n   fi\n   if [ \"$(grep -c \"^nextcloud_url=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo nextcloud_url=\"${nextcloud_url}\"\n   fi\n   if [ \"$(grep -c \"^nextcloud_username=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo nextcloud_username=\"${nextcloud_username}\"\n   fi\n   if [ \"$(grep -c \"^nextcloud_password=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo nextcloud_password=\"${nextcloud_password}\"\n   fi\n   if [ \"$(grep -c \"^notification_days=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo notification_days=\"${notification_days:=7}\"\n   fi\n   if [ \"$(grep -c \"^notification_type=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo notification_type=\"${notification_type}\"\n   fi\n   if [ \"$(grep -c \"^photo_album=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo photo_album=\"${photo_album}\"\n   fi\n   if [ \"$(grep -c \"^photo_library=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo photo_library=\"${photo_library}\"\n   fi\n   if [ \"$(grep -c \"^photo_size=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo photo_size=\"${photo_size:=original}\"\n   fi\n   if [ \"$(grep -c \"^prowl_api_key=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo prowl_api_key=\"${prowl_api_key}\"\n   fi\n   if [ \"$(grep -c \"^pushover_sound=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo pushover_sound=\"${pushover_sound}\"\n   fi\n   if [ \"$(grep -c \"^pushover_token=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo pushover_token=\"${pushover_token}\"\n   fi\n   if [ \"$(grep -c \"^pushover_user=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo pushover_user=\"${pushover_user}\"\n   fi\n   if [ \"$(grep -c \"^recent_only=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo recent_only=\"${recent_only}\"\n   fi\n   if [ \"$(grep -c \"^set_exif_datetime=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo set_exif_datetime=\"${set_exif_datetime:=false}\"\n   fi\n   if [ \"$(grep -c \"^skip_album=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo skip_album=\"${skip_album}\"\n   fi\n   if [ \"$(grep -c \"^skip_library=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo skip_library=\"${skip_library}\"\n   fi\n   if [ \"$(grep -c \"^single_pass=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo single_pass=\"${single_pass:=false}\"\n   fi\n   if [ \"$(grep -c \"^skip_check=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo skip_check=\"${skip_check:=false}\"\n   fi\n   if [ \"$(grep -c \"^skip_download=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo skip_download=\"${skip_download:=false}\"\n   fi\n   if [ \"$(grep -c \"^skip_live_photos=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo skip_live_photos=\"${skip_live_photos:=false}\"\n   fi\n   if [ \"$(grep -c \"^skip_videos=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo skip_videos=\"${skip_videos:=false}\"\n   fi\n   if [ \"$(grep -c \"^startup_notification=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo startup_notification=\"${startup_notification:=true}\"\n   fi\n   if [ \"$(grep -c \"^synchronisation_delay=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo synchronisation_delay=\"${synchronisation_delay:=0}\"\n   fi\n   if [ \"$(grep -c \"^synchronisation_interval=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo synchronisation_interval=\"${synchronisation_interval:=86400}\"\n   fi\n   if [ \"$(grep -c \"^synology_ignore_path=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo synology_ignore_path=\"${synology_ignore_path:=false}\"\n   fi\n   if [ \"$(grep -c \"^synology_photos_app_fix=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo synology_photos_app_fix=\"${synology_photos_app_fix:=false}\"\n   fi\n   if [ \"$(grep -c \"^telegram_chat_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo telegram_chat_id=\"${telegram_chat_id}\"\n   fi\n   if [ \"$(grep -c \"^telegram_http=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo telegram_http=\"${telegram_http}\"\n   fi\n   if [ \"$(grep -c \"^telegram_polling=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo telegram_polling=\"${telegram_polling:=true}\"\n   fi\n   if [ \"$(grep -c \"^telegram_server=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo telegram_server=\"${telegram_server}\"\n   fi\n   if [ \"$(grep -c \"^telegram_silent_file_notifications=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo telegram_silent_file_notifications=\"${telegram_silent_file_notifications}\"\n   fi\n   if [ \"$(grep -c \"^telegram_token=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo telegram_token=\"${telegram_token}\"\n   fi\n   if [ \"$(grep -c \"^trigger_nextlcoudcli_synchronisation=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo trigger_nextlcoudcli_synchronisation=\"${trigger_nextlcoudcli_synchronisation}\"\n   fi\n   if [ \"$(grep -c \"^until_found=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo until_found=\"${until_found}\"\n   fi\n   if [ \"$(grep -c \"^user=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo user=\"${user:=user}\"\n   fi\n   if [ \"$(grep -c \"^user_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo user_id=\"${user_id:=1000}\"\n   fi\n   if [ \"$(grep -c \"^webhook_https=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo webhook_https=\"${webhook_https:=false}\"\n   fi\n   if [ \"$(grep -c \"^webhook_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo webhook_id=\"${webhook_id}\"\n   fi\n   if [ \"$(grep -c \"^webhook_path=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo webhook_path=\"${webhook_path:=/api/webhook/}\"\n   fi\n   if [ \"$(grep -c \"^webhook_port=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo webhook_port=\"${webhook_port:=8123}\"\n   fi\n   if [ \"$(grep -c \"^webhook_server=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo webhook_server=\"${webhook_server}\"\n   fi\n   if [ \"$(grep -c \"^webhook_insecure=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo webhook_insecure=\"${webhook_insecure}\"\n   fi\n   if [ \"$(grep -c \"^wecom_id=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo wecom_id=\"${wecom_id}\"\n   fi\n   if [ \"$(grep -c \"^wecom_proxy=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo wecom_proxy=\"${wecom_proxy}\"\n   fi\n   if [ \"$(grep -c \"^wecom_secret=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo wecom_secret=\"${wecom_secret}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_host=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_host=\"${msmtp_host}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_port=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_port=\"${msmtp_port}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_user=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_user=\"${msmtp_user}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_from=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_from=\"${msmtp_from}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_pass=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_pass=\"${msmtp_pass}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_tls=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_tls=\"${msmtp_tls:=on}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_to=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_to=\"${msmtp_to}\"\n   fi\n   if [ \"$(grep -c \"^msmtp_args=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo msmtp_args=\"${msmtp_args:=--tls-starttls=off}\"\n   fi\n   if [ \"$(grep -c \"^agentid=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo agentid=\"${agentid}\"\n   fi\n   if [ \"$(grep -c \"^touser=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo touser=\"${touser}\"\n   fi\n   if [ \"$(grep -c \"^content_source_url=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo content_source_url=\"${content_source_url}\"\n   fi\n   if [ \"$(grep -c \"^name=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo name=\"${name}\"\n   fi\n   if [ \"$(grep -c \"^media_id_startup=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo media_id_startup=\"${media_id_startup}\"\n   fi\n   if [ \"$(grep -c \"^media_id_download=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo media_id_download=\"${media_id_download}\"\n   fi\n   if [ \"$(grep -c \"^media_id_delete=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo media_id_delete=\"${media_id_delete}\"\n   fi\n   if [ \"$(grep -c \"^media_id_expiration=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo media_id_expiration=\"${media_id_expiration}\"\n   fi\n   if [ \"$(grep -c \"^media_id_warning=\" \"${config_file}\")\" -eq 0 ]\n   then\n      echo media_id_warning=\"${media_id_warning}\"\n   fi\n} > \"${config_file}.add\"\nif [ -f \"${config_file}.add\" ]\nthen\n   cat \"${config_file}.add\" >> \"${config_file}\"\n   rm \"${config_file}.add\"\nfi\n\n# Set default values if missing from config file\nif [ -z \"$(grep \"^authentication_type=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^authentication_type=$%authentication_type=MFA%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^auth_china=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^auth_china=$%auth_china=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^auto_delete=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^auto_delete=$%auto_delete=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^albums_with_dates=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^albums_with_dates=$%albums_with_dates=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^align_raw=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^align_raw=$%align_raw=as-is%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^convert_heic_to_jpeg=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^convert_heic_to_jpeg=$%convert_heic_to_jpeg=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^debug_logging=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^debug_logging=$%debug_logging=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^delete_accompanying=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^delete_accompanying=$%delete_accompanying=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^delete_after_download=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^delete_after_download=$%delete_after_download=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^delete_empty_directories=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^delete_empty_directories=$%delete_empty_directories=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^delete_notifications=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^delete_notifications=$%delete_notifications=true%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^directory_permissions=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^directory_permissions=$%directory_permissions=750%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^download_notifications=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^download_notifications=$%download_notifications=true%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^download_path=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   user=\"$(grep \"^user=\" \"${config_file}\" | awk -F= '{print $2}')\"\n   sed -i \"s%^download_path=$%download_path=${download_path:=/home/${user:=user}/iCloud}%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^fake_user_agent=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^fake_user_agent=$%fake_user_agent=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^file_match_policy=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^file_match_policy=$%file_match_policy=name-size-dedup-with-suffix%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^file_permissions=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^file_permissions=$%file_permissions=640%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^folder_structure=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^folder_structure=$%folder_structure={:\\%Y/\\%m/\\%d\\}%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^force_gid=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^force_gid=$%force_gid=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^group=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^group=$%group=group%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^group_id=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^group_id=$%group_id=1000%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^icloud_china=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^icloud_china=$%icloud_china=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^jpeg_quality=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^jpeg_quality=$%jpeg_quality=90%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^keep_unicode=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^keep_unicode=$%keep_unicode=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^libraries_with_dates=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^libraries_with_dates=$%libraries_with_dates=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^live_photo_mov_filename_policy=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^live_photo_mov_filename_policy=$%live_photo_mov_filename_policy=suffix%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^live_photo_size=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^live_photo_size=$%live_photo_size=original%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^nextcloud_delete=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^nextcloud_delete=$%nextcloud_delete=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^nextcloud_upload=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^nextcloud_upload=$%nextcloud_upload=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^notification_days=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^notification_days=$%notification_days=7%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^photo_size=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^photo_size=$%photo_size=original%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^set_exif_datetime=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^set_exif_datetime=$%set_exif_datetime=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^single_pass=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^single_pass=$%single_pass=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^skip_check=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^skip_check=$%skip_check=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^skip_download=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^skip_download=$%skip_download=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^skip_live_photos=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^skip_live_photos=$%skip_live_photos=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^skip_videos=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^skip_videos=$%skip_videos=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^startup_notification=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^startup_notification=$%startup_notification=true%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^synchronisation_delay=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^synchronisation_delay=$%synchronisation_delay=0%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^synchronisation_interval=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^synchronisation_interval=$%synchronisation_interval=86400%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^synology_ignore_path=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^synology_ignore_path=$%synology_ignore_path=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^synology_photos_app_fix=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^synology_photos_app_fix=$%synology_photos_app_fix=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^telegram_http=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^telegram_http=$%telegram_http=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^user=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^user=$%user=user%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^user_id=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^user_id=$%user_id=1000%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^webhook_https=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^webhook_https=$%webhook_https=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^webhook_path=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^webhook_path=$%webhook_path=/api/webhook/%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^webhook_port=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^webhook_port=$%webhook_port=8123%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^webhook_insecure=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^webhook_insecure=$%webhook_insecure=false%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^msmtp_tls=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^msmtp_tls=$%msmtp_tls=on%\" \"${config_file}\"\nfi\nif [ -z \"$(grep \"^msmtp_args=\" \"${config_file}\" | awk -F= '{print $2}')\" ]\nthen\n   sed -i \"s%^msmtp_args=$%msmtp_args=--tls-starttls=off%\" \"${config_file}\"\nfi\n\n# Update configuration file with currently set Docker environment variables\nif [ \"${albums_with_dates}\" ]\nthen\n   sed -i \"s%^albums_with_dates=.*%albums_with_dates=${albums_with_dates}%\" \"${config_file}\"\nfi\nif [ \"${align_raw}\" ]\nthen\n   sed -i \"s%^align_raw=.*%align_raw=${align_raw}%\" \"${config_file}\"\nfi\nif [ \"${apple_id}\" ]\nthen\n   sed -i \"s%^apple_id=.*%apple_id=${apple_id}%\" \"${config_file}\"\nfi\nif [ \"${authentication_type}\" ]\nthen\n   sed -i \"s%^authentication_type=.*%authentication_type=${authentication_type}%\" \"${config_file}\"\nfi\nif [ \"${auth_china}\" ]\nthen\n   sed -i \"s%^auth_china=.*%auth_china=${auth_china}%\" \"${config_file}\"\nfi\nif [ \"${auto_delete}\" ]\nthen\n   sed -i \"s%^auto_delete=.*%auto_delete=${auto_delete}%\" \"${config_file}\"\nfi\nif [ \"${bark_device_key}\" ]\nthen\n   sed -i \"s%^bark_device_key=.*%bark_device_key=${bark_device_key}%\" \"${config_file}\"\nfi\nif [ \"${bark_server}\" ]\nthen\n   sed -i \"s%^bark_server=.*%bark_server=${bark_server}%\" \"${config_file}\"\nfi\nif [ \"${convert_heic_to_jpeg}\" ]\nthen\n   sed -i \"s%^convert_heic_to_jpeg=.*%convert_heic_to_jpeg=${convert_heic_to_jpeg}%\" \"${config_file}\"\nfi\nif [ \"${debug_logging}\" ]\nthen\n   sed -i \"s%^debug_logging=.*%debug_logging=${debug_logging}%\" \"${config_file}\"\nfi\nif [ \"${delete_accompanying}\" ]\nthen\n   sed -i \"s%^delete_accompanying=.*%delete_accompanying=${delete_accompanying}%\" \"${config_file}\"\nfi\nif [ \"${delete_after_download}\" ]\nthen\n   sed -i \"s%^delete_after_download=.*%delete_after_download=${delete_after_download}%\" \"${config_file}\"\nfi\nif [ \"${delete_empty_directories}\" ]\nthen\n   sed -i \"s%^delete_empty_directories=.*%delete_empty_directories=${delete_empty_directories}%\" \"${config_file}\"\nfi\nif [ \"${delete_notifications}\" ]\nthen\n   sed -i \"s%^delete_notifications=.*%delete_notifications=${delete_notifications}%\" \"${config_file}\"\nfi\nif [ \"${dingtalk_token}\" ]\nthen\n   sed -i \"s%^dingtalk_token=.*%dingtalk_token=${dingtalk_token}%\" \"${config_file}\"\nfi\nif [ \"${directory_permissions}\" ]\nthen\n   sed -i \"s%^directory_permissions=.*%directory_permissions=${directory_permissions}%\" \"${config_file}\"\nfi\nif [ \"${discord_id}\" ]\nthen\n   sed -i \"s%^discord_id=.*%discord_id=${discord_id}%\" \"${config_file}\"\nfi\nif [ \"${discord_token}\" ]\nthen\n   sed -i \"s%^discord_token=.*%discord_token=${discord_token}%\" \"${config_file}\"\nfi\nif [ \"${download_notifications}\" ]\nthen\n   sed -i \"s%^download_notifications=.*%download_notifications=${download_notifications}%\" \"${config_file}\"\nfi\nif [ \"${download_path}\" ]\nthen\n   sed -i \"s%^download_path=.*%download_path=${download_path}%\" \"${config_file}\"\nfi\nif [ \"${fake_user_agent}\" ]\nthen\n   sed -i \"s%^fake_user_agent=.*%fake_user_agent=${fake_user_agent}%\" \"${config_file}\"\nfi\nif [ \"${file_match_policy}\" ]\nthen\n   sed -i \"s%^file_match_policy=.*%file_match_policy=${file_match_policy}%\" \"${config_file}\"\nfi\nif [ \"${file_permissions}\" ]\nthen\n   sed -i \"s%^file_permissions=.*%file_permissions=${file_permissions}%\" \"${config_file}\"\nfi\nif [ \"${folder_structure}\" ]\nthen\n  sanitised_folder_structure=\"${folder_structure//\\//\\\\/}\"\n  sed -i \"s@^folder_structure=.*@folder_structure=${sanitised_folder_structure}@\" \"${config_file}\"\nfi\nif [ \"${force_gid}\" ]\nthen\n   sed -i \"s%^force_gid=.*%force_gid=${force_gid}%\" \"${config_file}\"\nfi\nif [ \"${gotify_app_token}\" ]\nthen\n   sed -i \"s%^gotify_app_token=.*%gotify_app_token=${gotify_app_token}%\" \"${config_file}\"\nfi\nif [ \"${gotify_https}\" ]\nthen\n   sed -i \"s%^gotify_https=.*%gotify_https=${gotify_https}%\" \"${config_file}\"\nfi\nif [ \"${gotify_server_url}\" ]\nthen\n   sed -i \"s%^gotify_server_url=.*%gotify_server_url=${gotify_server_url}%\" \"${config_file}\"\nfi\nif [ \"${group}\" ]\nthen\n   sed -i \"s%^group=.*%group=${group}%\" \"${config_file}\"\nfi\nif [ \"${group_id}\" ]\nthen\n   sed -i \"s%^group_id=.*%group_id=${group_id}%\" \"${config_file}\"\nfi\nif [ \"${icloud_china}\" ]\nthen\n   sed -i \"s%^icloud_china=.*%icloud_china=${icloud_china}%\" \"${config_file}\"\nfi\nif [ \"${iyuu_token}\" ]\nthen\n   sed -i \"s%^iyuu_token=.*%iyuu_token=${iyuu_token}%\" \"${config_file}\"\nfi\nif [ \"${jpeg_path}\" ]\nthen\n   sed -i \"s%^jpeg_path=.*%jpeg_path=${jpeg_path}%\" \"${config_file}\"\nfi\nif [ \"${jpeg_quality}\" ]\nthen\n   sed -i \"s%^jpeg_quality=.*%jpeg_quality=${jpeg_quality}%\" \"${config_file}\"\nfi\nif [ \"${keep_unicode}\" ]\nthen\n   sed -i \"s%^keep_unicode=.*%keep_unicode=${keep_unicode}%\" \"${config_file}\"\nfi\nif [ \"${libraries_with_dates}\" ]\nthen\n   sed -i \"s%^libraries_with_dates=.*%libraries_with_dates=${libraries_with_dates}%\" \"${config_file}\"\nfi\nif [ \"${live_photo_mov_filename_policy}\" ]\nthen\n   sed -i \"s%^live_photo_mov_filename_policy=.*%live_photo_mov_filename_policy=${live_photo_mov_filename_policy}%\" \"${config_file}\"\nfi\nif [ \"${live_photo_size}\" ]\nthen\n   sed -i \"s%^live_photo_size=.*%live_photo_size=${live_photo_size}%\" \"${config_file}\"\nfi\nif [ \"${nextcloud_delete}\" ]\nthen\n   sed -i \"s%^nextcloud_delete=.*%nextcloud_delete=${nextcloud_delete}%\" \"${config_file}\"\nfi\nif [ \"${nextcloud_upload}\" ]\nthen\n   sed -i \"s%^nextcloud_upload=.*%nextcloud_upload=${nextcloud_upload}%\" \"${config_file}\"\nfi\nif [ \"${nextcloud_url}\" ]\nthen\n   sed -i \"s%^nextcloud_url=.*%nextcloud_url=${nextcloud_url}%\" \"${config_file}\"\nfi\nif [ \"${nextcloud_username}\" ]\nthen\n   sed -i \"s%^nextcloud_username=.*%nextcloud_username=${nextcloud_username}%\" \"${config_file}\"\nfi\nif [ \"${nextcloud_password}\" ]\nthen\n   sed -i \"s%^nextcloud_password=.*%nextcloud_password=${nextcloud_password}%\" \"${config_file}\"\nfi\nif [ \"${notification_days}\" ]\nthen\n   sed -i \"s%^notification_days=.*%notification_days=${notification_days}%\" \"${config_file}\"\nfi\nif [ \"${notification_type}\" ]\nthen\n   sed -i \"s%^notification_type=.*%notification_type=${notification_type}%\" \"${config_file}\"\nfi\nif [ \"${photo_album}\" ]\nthen\n   sed -i \"s%^photo_album=.*%photo_album=\\\"${photo_album}\\\"%\" \"${config_file}\"\nfi\nif [ \"${photo_library}\" ]\nthen\n   sed -i \"s%^photo_library=.*%photo_library=${photo_library}%\" \"${config_file}\"\nfi\nif [ \"${photo_size}\" ]\nthen\n   sed -i \"s%^photo_size=.*%photo_size=${photo_size}%\" \"${config_file}\"\nfi\nif [ \"${prowl_api_key}\" ]\nthen\n   sed -i \"s%^prowl_api_key=.*%prowl_api_key=${prowl_api_key}%\" \"${config_file}\"\nfi\nif [ \"${pushover_sound}\" ]\nthen\n   sed -i \"s%^pushover_sound=.*%pushover_sound=${pushover_sound}%\" \"${config_file}\"\nfi\nif [ \"${pushover_token}\" ]\nthen\n   sed -i \"s%^pushover_token=.*%pushover_token=${pushover_token}%\" \"${config_file}\"\nfi\nif [ \"${pushover_user}\" ]\nthen\n   sed -i \"s%^pushover_user=.*%pushover_user=${pushover_user}%\" \"${config_file}\"\nfi\nif [ \"${recent_only}\" ]\nthen\n   sed -i \"s%^recent_only=.*%recent_only=${recent_only}%\" \"${config_file}\"\nfi\nif [ \"${set_exif_datetime}\" ]\nthen\n   sed -i \"s%^set_exif_datetime=.*%set_exif_datetime=${set_exif_datetime}%\" \"${config_file}\"\nfi\nif [ \"${single_pass}\" ]\nthen\n   sed -i \"s%^single_pass=.*%single_pass=${single_pass}%\" \"${config_file}\"\nfi\nif [ \"${skip_album}\" ]\nthen\n   sed -i \"s%^skip_album=.*%skip_album=\\\"${skip_album}\\\"%\" \"${config_file}\"\nfi\nif [ \"${skip_library}\" ]\nthen\n   sed -i \"s%^skip_library=.*%skip_library=\\\"${skip_library}\\\"%\" \"${config_file}\"\nfi\nif [ \"${skip_check}\" ]\nthen\n   sed -i \"s%^skip_check=.*%skip_check=${skip_check}%\" \"${config_file}\"\nfi\nif [ \"${skip_download}\" ]\nthen\n   sed -i \"s%^skip_download=.*%skip_download=${skip_download}%\" \"${config_file}\"\nfi\nif [ \"${skip_live_photos}\" ]\nthen\n   sed -i \"s%^skip_live_photos=.*%skip_live_photos=${skip_live_photos}%\" \"${config_file}\"\nfi\nif [ \"${skip_videos}\" ]\nthen\n   sed -i \"s%^skip_videos=.*%skip_videos=${skip_videos}%\" \"${config_file}\"\nfi\nif [ \"${startup_notification}\" ]\nthen\n   sed -i \"s%^startup_notification=.*%startup_notification=${startup_notification}%\" \"${config_file}\"\nfi\nif [ \"${synchronisation_delay}\" ]\nthen\n   sed -i \"s%^synchronisation_delay=.*%synchronisation_delay=${synchronisation_delay}%\" \"${config_file}\"\nfi\nif [ \"${synchronisation_interval}\" ]\nthen\n   sed -i \"s%^synchronisation_interval=.*%synchronisation_interval=${synchronisation_interval}%\" \"${config_file}\"\nfi\nif [ \"${synology_ignore_path}\" ]\nthen\n   sed -i \"s%^synology_ignore_path=.*%synology_ignore_path=${synology_ignore_path}%\" \"${config_file}\"\nfi\nif [ \"${synology_photos_app_fix}\" ]\nthen\n   sed -i \"s%^synology_photos_app_fix=.*%synology_photos_app_fix=${synology_photos_app_fix}%\" \"${config_file}\"\nfi\nif [ \"${telegram_chat_id}\" ]\nthen\n   sed -i \"s%^telegram_chat_id=.*%telegram_chat_id=${telegram_chat_id}%\" \"${config_file}\"\nfi\nif [ \"${telegram_http}\" ]\nthen\n   sed -i \"s%^telegram_http=.*%telegram_http=${telegram_http}%\" \"${config_file}\"\nfi\nif [ \"${telegram_polling}\" ]\nthen\n   sed -i \"s%^telegram_polling=.*%telegram_polling=${telegram_polling}%\" \"${config_file}\"\nfi\nif [ \"${telegram_server}\" ]\nthen\n   sed -i \"s%^telegram_server=.*%telegram_server=${telegram_server}%\" \"${config_file}\"\nfi\nif [ \"${telegram_silent_file_notifications}\" ]\nthen\n   sed -i \"s%^telegram_silent_file_notifications=.*%telegram_silent_file_notifications=${telegram_silent_file_notifications}%\" \"${config_file}\"\nfi\nif [ \"${telegram_token}\" ]\nthen\n   sed -i \"s%^telegram_token=.*%telegram_token=${telegram_token}%\" \"${config_file}\"\nfi\nif [ \"${trigger_nextlcoudcli_synchronisation}\" ]\nthen\n   sed -i \"s%^trigger_nextlcoudcli_synchronisation=.*%trigger_nextlcoudcli_synchronisation=${trigger_nextlcoudcli_synchronisation}%\" \"${config_file}\"\nfi\nif [ \"${until_found}\" ]\nthen\n   sed -i \"s%^until_found=.*%until_found=${until_found}%\" \"${config_file}\"\nfi\nif [ \"${user}\" ]\nthen\n   sed -i \"s%^user=.*%user=${user}%\" \"${config_file}\"\nfi\nif [ \"${user_id}\" ]\nthen\n   sed -i \"s%^user_id=.*%user_id=${user_id}%\" \"${config_file}\"\nfi\nif [ \"${webhook_https}\" ]\nthen\n   sed -i \"s%^webhook_https=.*%webhook_https=${webhook_https}%\" \"${config_file}\"\nfi\nif [ \"${webhook_id}\" ]\nthen\n   sed -i \"s%^webhook_id=.*%webhook_id=${webhook_id}%\" \"${config_file}\"\nfi\nif [ \"${webhook_path}\" ]\nthen\n   sed -i \"s%^webhook_path=.*%webhook_path=${webhook_path}%\" \"${config_file}\"\nfi\nif [ \"${webhook_port}\" ]\nthen\n   sed -i \"s%^webhook_port=.*%webhook_port=${webhook_port}%\" \"${config_file}\"\nfi\nif [ \"${webhook_server}\" ]\nthen\n   sed -i \"s%^webhook_server=.*%webhook_server=${webhook_server}%\" \"${config_file}\"\nfi\nif [ \"${webhook_insecure}\" ]\nthen\n   sed -i \"s%^webhook_insecure=.*%webhook_insecure=${webhook_insecure}%\" \"${config_file}\"\nfi\nif [ \"${wecom_id}\" ]\nthen\n   sed -i \"s%^wecom_id=.*%wecom_id=${wecom_id}%\" \"${config_file}\"\nfi\nif [ \"${wecom_proxy}\" ]\nthen\n   sed -i \"s%^wecom_proxy=.*%wecom_proxy=${wecom_proxy}%\" \"${config_file}\"\nfi\nif [ \"${wecom_secret}\" ]\nthen\n   sed -i \"s%^wecom_secret=.*%wecom_secret=${wecom_secret}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_host}\" ]\nthen\n   sed -i \"s%^msmtp_host=.*%msmtp_host=${msmtp_host}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_port}\" ]\nthen\n   sed -i \"s%^msmtp_port=.*%msmtp_port=${msmtp_port}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_user}\" ]\nthen\n   sed -i \"s%^msmtp_user=.*%msmtp_user=${msmtp_user}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_from}\" ]\nthen\n   sed -i \"s%^msmtp_from=.*%msmtp_from=${msmtp_from}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_pass}\" ]\nthen\n   sed -i \"s%^msmtp_pass=.*%msmtp_pass=${msmtp_pass}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_to}\" ]\nthen\n   sed -i \"s%^msmtp_to=.*%msmtp_to=${msmtp_to}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_tls}\" ]\nthen\n   sed -i \"s%^msmtp_tls=.*%msmtp_tls=${msmtp_tls}%\" \"${config_file}\"\nfi\nif [ \"${msmtp_args}\" ]\nthen\n   sed -i \"s%^msmtp_args=.*%msmtp_args=${msmtp_args}%\" \"${config_file}\"\nfi\nif [ \"${agentid}\" ]\nthen\n   sed -i \"s%^agentid=.*%agentid=${agentid}%\" \"${config_file}\"\nfi\nif [ \"${touser}\" ]\nthen\n   sed -i \"s%^touser=.*%touser=${touser}%\" \"${config_file}\"\nfi\nif [ \"${content_source_url}\" ]\nthen\n   sed -i \"s%^content_source_url=.*%content_source_url=${content_source_url}%\" \"${config_file}\"\nfi\nif [ \"${name}\" ]\nthen\n   sed -i \"s%^name=.*%name=${name}%\" \"${config_file}\"\nfi\nif [ \"${media_id_startup}\" ]\nthen\n   sed -i \"s%^media_id_startup=.*%media_id_startup=${media_id_startup}%\" \"${config_file}\"\nfi\nif [ \"${media_id_download}\" ]\nthen\n   sed -i \"s%^media_id_download=.*%media_id_download=${media_id_download}%\" \"${config_file}\"\nfi\nif [ \"${media_id_delete}\" ]\nthen\n   sed -i \"s%^media_id_delete=.*%media_id_delete=${media_id_delete}%\" \"${config_file}\"\nfi\nif [ \"${media_id_expiration}\" ]\nthen\n   sed -i \"s%^media_id_expiration=.*%media_id_expiration=${media_id_expiration}%\" \"${config_file}\"\nfi\nif [ \"${media_id_warning}\" ]\nthen\n   sed -i \"s%^media_id_warning=.*%media_id_warning=${media_id_warning}%\" \"${config_file}\"\nfi\n\nmv \"${config_file}\" \"${config_file}.tmp\"\nsort \"${config_file}.tmp\" --output=\"${config_file}\"\nchmod --reference=\"${config_file}.tmp\" \"${config_file}\"\nrm \"${config_file}.tmp\"\n\nsed -i 's/=True/=true/gI' \"${config_file}\"\nsed -i 's/=False/=false/gI' \"${config_file}\"\nsed -i 's/debug_logging=AAAAA/debug_logging=false/' \"${config_file}\"\nsed -i 's/authentication_type=2FA/authentication_type=MFA/' \"${config_file}\"\nsed -i '/delete_notification=/d' \"${config_file}\""
        },
        {
          "name": "launcher.sh",
          "type": "blob",
          "size": 0.0703125,
          "content": "#!/bin/bash\n\n/usr/local/bin/init_config.sh\n/usr/local/bin/sync-icloud.sh"
        },
        {
          "name": "profile",
          "type": "blob",
          "size": 2.8251953125,
          "content": "#!/bin/ash\n\nEUID=$(id -u)\nexport PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/icloudpd/bin\"\nexport PAGER=less\nexport LS_COLORS='no=32:fi=32:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.heic=01;35:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=035:*.mp3=01;35:*.wav=01;35:*.xml=00;31:'\numask 022\n\nfor script in /etc/profile.d/*.sh ; do\n   if [ -r \"$script\" ] ; then\n      . \"$script\"\n   fi\ndone\n\ndl_path=\"$(grep \"^download_path=\" /config/icloudpd.conf | awk '{print $2}')\"\nalias bins='cd /usr/local/bin'\nalias opt='cd /opt'\nalias config='cd /config'\nalias cls='clear'\nalias dls=\"cd ${dl_path:=\\/home\\/$(id -un)\\/iCloud\\/}\"\nalias ls='ls -l --color --escape --human-readable'\nalias sl='ls -l --color --escape --human-readable'\nalias rm='rm -v'\nalias mv='mv -v'\nalias cp='cp -vp'\nalias rcp='scp'\nalias dfh='df -h | grep -v \"/var/lib/docker\\|udev\\|tmpfs\"'\nalias duh='du -h'\nalias grep='grep --color'\nalias home='cd ~'\nalias sourcereload='source /etc/profile'\nalias logs='cd /var/log/'\nalias listening='netstat -lntu'\nalias install='apk add'\nalias remove='apk del'\nalias update='apk update'\nalias listupdates='apk list --upgradable'\nalias upgrade='apk update && apk upgrade'\nalias editconfig='nano /config/icloudpd.conf'\nalias whatsmyip='wget -qO- icanhazip.com'\nalias innit='/usr/local/bin/sync-icloud.sh --init'\n\nfunction __setprompt\n{\n\n   # Define colors\n   local LIGHTGREY='\\[\\033[0;37m\\]'\n   local WHITE='\\[\\033[1;37m\\]'\n   local BLACK='\\[\\033[0;30m\\]'\n   local DARKGRAY='\\[\\033[1;30m\\]'\n   local RED='\\[\\033[0;31m\\]'\n   local LIGHTRED='\\[\\033[1;31m\\]'\n   local GREEN='\\[\\033[0;32m\\]'\n   local LIGHTGREEN='\\[\\033[1;32m\\]'\n   local BROWN='\\[\\033[0;33m\\]'\n   local YELLOW='\\[\\033[1;33m\\]'\n   local BLUE='\\[\\033[0;34m\\]'\n   local LIGHTBLUE='\\[\\033[1;34m\\]'\n   local MAGENTA='\\[\\033[0;35m\\]'\n   local LIGHTMAGENTA='\\[\\033[1;35m\\]'\n   local CYAN='\\[\\033[0;36m\\]'\n   local LIGHTCYAN='\\[\\033[1;36m\\]'\n   local NOCOLOR='\\[\\033[0m\\]'\n\n   # Green prompt is user, red prompt if red\n   if [ $EUID -eq 0 ]; then\n      PS1=\"${LIGHTRED}\\u${LIGHTGREY}@${LIGHTRED}\\h\"\n   else\n      PS1=\"${LIGHTGREEN}\\u${LIGHTGREY}@${LIGHTGREEN}\\h\"\n   fi\n\n   # Current directory\n   PS1=\"${PS1}${LIGHTGREY}:${LIGHTBLUE}\\w\"\n\n   # Prompt end\n   if [ $EUID -eq 0 ]; then\n      PS1=\"${PS1}${RED}>${GREEN} \" # Root user\n   else\n      PS1=\"${PS1}${GREEN}>${GREEN} \" # Normal user\n   fi\n\n}\n__setprompt\nPROMPT_COMMAND='echo -ne \"\\e]0;$USER@${HOSTNAME}: $(pwd -P)\\a\"'\n\nunset script dl_path"
        },
        {
          "name": "reauth.sh",
          "type": "blob",
          "size": 0.890625,
          "content": "#!/bin/bash\n\nrun_as()\n{\n   local command_to_run\n   command_to_run=\"${1}\"\n   if [ \"$(id -u)\" = 0 ]\n   then\n      su \"${user:=user}\" -s /bin/ash -c \"${command_to_run}\"\n   else\n      /bin/ash -c \"${command_to_run}\"\n   fi\n}\n\nuser=\"$(grep \"^user=\" /config/icloudpd.conf | awk -F= '{print $2}')\"\napple_id=\"$(grep apple_id /config/icloudpd.conf | awk -F= '{print $2}')\"\nauth_china=\"$(grep auth_china /config/icloudpd.conf | awk -F= '{print $2}')\"\ncookie_file=\"$(echo -n \"${apple_id//[^a-z0-9_]/}\")\"\n\nif [ \"${auth_china:=false}\" = true ]\nthen\n    auth_domain=\"cn\"\nfi\n\nif [ -f \"/config/${cookie_file}\" ]\nthen\n   rm \"/config/${cookie_file}\"\nfi\n\nif [ -f \"/config/${cookie_file}.session\" ]\nthen\n   rm \"/config/${cookie_file}.session\"\nfi\n\nrun_as \"/opt/icloudpd/bin/icloudpd --username ${apple_id} --cookie-directory /config --auth-only --domain ${auth_domain:=com} | tee /tmp/icloudpd/reauth.log\"\n\nrm /tmp/icloudpd/reauth.log"
        },
        {
          "name": "sendmessage.sh",
          "type": "blob",
          "size": 3.4345703125,
          "content": "#!/bin/bash\n\nsend_message()\n{\n   local text\n   text=\"$1\"\n   notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" --request POST \"${notification_url}\" \\\n      --data chat_id=\"${telegram_chat_id}\" \\\n      --data parse_mode=\"markdown\" \\\n      --data disable_notification=\"${telegram_disable_notification:=false}\" \\\n      --data text=\"${text}\")\"\n}\n\nchoose_sms_number()\n{\n   local auth_log_numbers auth_log_text\n   auth_log_numbers=\"$(grep \"^ \" /tmp/icloudpd/reauth.log | sed 's/\\*\\*\\*\\*\\*\\ \\*\\*\\*\\*/number ending in /g')\"\n   auth_index_upper=\"$(grep \"^ \" /tmp/icloudpd/reauth.log | tail -1 | awk -F: '{print $1}' | sed 's/ //g')\"\n   if [ \"${auth_index_upper}\" = \"a\" ]\n   then\n      option_list=\"a\"\n   else\n      option_list=\"a-${auth_index_upper}\"\n   fi\n   auth_log_text=\"Please select option to send the SMS code to:%0A${auth_log_numbers}%0AReply with '${user} <option ${option_list}>' to select the mobile number, or reply with '${user} <mfa code>' to use an Apple iDevice MFA code\"\n   send_message \"$(echo -e \"${notification_icon} *${notification_title}*%0A${auth_log_text}\")\"\n}\n\nrequest_mfa_code()\n{\n   local request_mfa_text\n   request_mfa_text=\"Please reply with ${user} <6-digit code> in the next 10mins\"\n   send_message \"$(echo -e \"${notification_icon} *${notification_title}*%0A${request_mfa_text}\")\"\n}\n\nmfa_success()\n{\n   local mfa_success_text\n   mfa_success_text=\"MFA successfully re-confirmed for ${user}\"\n   send_message \"$(echo -e \"${notification_icon} *${notification_title}*%0A${mfa_success_text}\")\"\n}\n\nmfa_failure()\n{\n   local mfa_failure_text\n   mfa_failure_text=\"MFA failed for ${user}. Please try again\"\n   send_message \"$(echo -e \"${notification_icon} *${notification_title}*%0A${mfa_failure_text}\")\"\n}\n\nshow_variables()\n{\n   echo \"user: ${user}\"\n   echo \"apple_id: ${apple_id}\"\n   echo \"telegram_chat_id: ${telegram_chat_id}\"\n   echo \"telegram_http: ${telegram_http}\"\n   echo \"telegram_server: ${telegram_server}\"\n   echo \"telegram_token: ${telegram_token}\"\n   echo \"telegram_protocol: ${telegram_protocol}\"\n   echo \"telegram_base_url: ${telegram_base_url}\"\n   echo \"notification_url: ${notification_url}\"\n}\n\nconfig_file=\"/config/icloudpd.conf\"\nuser=\"$(grep \"^user=\" ${config_file} | awk -F= '{print $2}')\"\napple_id=\"$(grep \"^apple_id=\" ${config_file} | awk -F= '{print $2}')\"\ntelegram_chat_id=\"$(grep \"^telegram_chat_id=\" ${config_file} | awk -F= '{print $2}')\"\ntelegram_http=\"$(grep \"^telegram_http=\" ${config_file} | awk -F= '{print $2}')\"\ntelegram_server=\"$(grep \"^telegram_server=\" ${config_file} | awk -F= '{print $2}')\"\ntelegram_token=\"$(grep \"^telegram_token=\" ${config_file} | awk -F= '{print $2}')\"\nnotification_title=\"$(grep \"^notification_title=\" ${config_file} | awk -F= '{print $2}')\"\nnotification_icon=\"\\xE2\\x96\\xB6\"\n\nif [ \"${telegram_http}\" = true ]\nthen\n   telegram_protocol=\"http\"\nelse\n   telegram_protocol=\"https\"\nfi\n\nif [ \"${telegram_server}\" ]\nthen\n   telegram_base_url=\"${telegram_protocol}://${telegram_server}/bot${telegram_token}\"\nelse\n   telegram_base_url=\"${telegram_protocol}://api.telegram.org/bot${telegram_token}\"\nfi\nnotification_url=\"${telegram_base_url}/sendMessage\"\n\nif [ \"${notification_title}\" ]\nthen\n   notification_title=\"${notification_title//[^a-zA-Z0-9_ ]/}\"\nelse\n   notification_title=\"boredazfcuk/iCloudPD\"\nfi\n\n# show_variables\nif [ \"$1\" = \"smschoice\" ]\nthen\n   choose_sms_number\nelif [ \"$1\" = \"mfacode\" ]\nthen\n   request_mfa_code\nelif [ \"$1\" = \"success\" ]\nthen\n   mfa_success\nelif [ \"$1\" = \"failure\" ]\nthen\n   mfa_failure\nfi"
        },
        {
          "name": "sync-icloud.sh",
          "type": "blob",
          "size": 116.7041015625,
          "content": "#!/bin/bash\n\n##### Functions #####\ninitialise_script()\n{\n   log_info \"***** boredazfcuk/icloudpd container v1.0.$(cat /opt/build_version.txt) started *****\"\n   log_info \"***** For support, please go here: https://github.com/boredazfcuk/docker-icloudpd *****\"\n   log_info \"$(cat /etc/*-release | grep \"^NAME\" | sed 's/NAME=//g' | sed 's/\"//g') $(cat /etc/*-release | grep \"VERSION_ID\" | sed 's/VERSION_ID=//g' | sed 's/\"//g')\"\n   log_info \"Python version: $(python3 --version | awk '{print $2}')\"\n   log_info \"icloud-photos-downloader version: $(/opt/icloudpd/bin/icloudpd --version | awk -F, '{print $1}' | sed 's/version://')\"\n\n   log_info \"Checking for updates...\"\n   current_version=\"$(awk -F_ '{print $1}' /opt/build_version.txt)\"\n   latest_version=\"$(curl --silent --max-time 5 https://raw.githubusercontent.com/boredazfcuk/docker-icloudpd/master/build_version.txt | awk -F_ '{print $1}')\"\n   if [ \"${current_version:=99}\" -eq \"99\" ] || [ \"${latest_version:=98}\" -eq \"98\" ]\n   then\n      log_error \" - Check for updates failed. Placeholder version detected.\"\n      log_error \" - Current version: ${current_version}\"\n      log_error \" - Latest version: ${latest_version}\"\n      log_error \" - Continuing in 2 minutes...\"\n      sleep 120\n   elif [ \"${current_version}\" -lt \"${latest_version}\" ]\n   then\n      log_info \" - Current version (v${current_version}) is out of date. Please upgrade to latest version (v${latest_version}). Continuing in 2 minutes...\"\n      sleep 120\n   elif [ \"${current_version}\" -gt \"${latest_version}\" ]\n   then\n      log_info \" - Current version (v${current_version}) is newer than latest build (v${latest_version}). Good luck!\"\n   elif [ \"${current_version}\" -eq \"${latest_version}\" ]\n   then\n      log_info \" - Current version is up to date\"\n   else\n      log_error \" - Check for updates failed. Continuing in 2 minutes...\"\n      sleep 120\n   fi\n\n   config_file=\"/config/icloudpd.conf\"\n   if [ ! -f \"${config_file}\" ]\n   then\n      log_error \"Failed to create configuration file: ${config_file} - Cannot continue, exiting\"\n      sleep 600\n      exit 1\n   elif [ ! -w \"${config_file}\" ]\n   then\n      log_error \"Cannot write to configuration file: ${config_file} - Cannot continue, exiting\"\n      sleep 600\n      exit 1\n   fi\n   log_info \"Loading configuration from: ${config_file}\"\n   source \"${config_file}\"\n   save_ifs=\"${IFS}\"\n   lan_ip=\"$(hostname -i)\"\n   login_counter=0\n   apple_id=\"$(echo -n \"${apple_id}\" | tr '[:upper:]' '[:lower:]')\"\n   cookie_file=\"$(echo -n \"${apple_id//[^a-z0-9_]/}\")\"\n\n   local icloud_dot_com dns_counter\n   if [ \"${icloud_china:=false}\" = true ]\n   then\n      icloud_domain=\"icloud.com.cn\"\n   else\n      icloud_domain=\"icloud.com\"\n   fi\n   case \"${synchronisation_interval:=86400}\" in\n      21600) synchronisation_interval=21600;; # 6 hours\n      43200) synchronisation_interval=43200;; # 12 hours\n      86400) synchronisation_interval=86400;; # 24 hours\n      129600) synchronisation_interval=129600;; # 36 hours\n      172800) synchronisation_interval=172800;; # 48 hours\n      604800) synchronisation_interval=604800;; # 7 days\n      *) synchronisation_interval=86400;; # 24 hours\n   esac\n   if [ \"${synchronisation_delay:=0}\" -gt 60 ]\n   then\n      synchronisation_delay=60\n   fi\n   if [ ! -d \"/tmp/icloudpd\" ]\n   then\n      mkdir --parents \"/tmp/icloudpd\"\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_check_exit_code\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_check_exit_code\"\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_download_exit_code\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_download_exit_code\"\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_check_error\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_check_error\"\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_download_error\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_download_error\"\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_sync.log\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_sync.log\"\n   fi\n   if [ -f \"/tmp/icloudpd/icloudpd_tracert.err\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_tracert.err\"\n   fi\n   touch \"/tmp/icloudpd/icloudpd_check_exit_code\"\n   touch \"/tmp/icloudpd/icloudpd_download_exit_code\"\n   touch \"/tmp/icloudpd/icloudpd_check_error\"\n   touch \"/tmp/icloudpd/icloudpd_download_error\"\n   touch \"/tmp/icloudpd/icloudpd_sync.log\"\n   touch \"/tmp/icloudpd/icloudpd_tracert.err\"\n   touch \"/tmp/icloudpd/expect_input.txt\"\n\n   if [ -z \"${apple_id}\" ]\n   then\n      log_error \"Apple ID not set - exiting\"\n      sleep 120\n      exit 1\n   fi\n   log_debug \"Running user id: $(id --user)\"\n   log_debug \"Running group id: $(id --group)\"\n   if [ \"${user}\" = \"root\" ]\n   then\n      log_warning \"The local user for synchronisation cannot be root, resetting to 'user'\"\n      unset user\n      sleep 120\n   fi\n   if [ \"${user_id}\" -eq 0 ]\n   then\n      log_warning \"The local user id for synchronisation cannot be 0, resetting to '1000'\"\n      unset user_id\n      sleep 120\n   fi\n   log_debug \"Local user: ${user}:${user_id}\"\n   if [ \"${group}\" = \"root\" ]\n   then\n      log_warning \"The local group for synchronisation cannot be root, resetting to 'group'\"\n      unset group\n      sleep 120\n   fi\n   if [ \"${group_id}\" -eq 0 ]\n   then\n      log_warning \"The local group id for synchronisation cannot be 0, resetting to '1000'\"\n      unset group_id force_gid\n      sleep 120\n   fi\n   log_debug \"Local group: ${group}:${group_id}\"\n   log_debug \"Force GID: ${force_gid}\"\n   log_debug \"LAN IP Address: ${lan_ip}\"\n   log_debug \"Default gateway: $(ip route | grep default | awk '{print $3}')\"\n   log_debug \"DNS server: $(grep nameserver /etc/resolv.conf | awk '{print $2}')\"\n   icloud_dot_com=\"$(nslookup -type=a ${icloud_domain} | grep -v \"127.0.0.1\" | grep Address | tail -1 | awk '{print $2}')\"\n   while [ -z \"${icloud_dot_com}\" ]\n   do\n      if [ \"${dns_counter:=0}\" = 0 ]\n      then\n         log_warning \"Cannot find ${icloud_domain} IP address - retrying\"\n      fi\n      sleep 10\n      icloud_dot_com=\"$(nslookup -type=a ${icloud_domain} | grep -v \"127.0.0.1\" | grep Address | tail -1 | awk '{print $2}')\"\n      dns_counter=$((dns_counter+1))\n      if [ \"${dns_counter}\" = 12 ]\n      then\n         log_error \"Cannot find ${icloud_domain} IP address. Please check your DNS/Firewall settings - exiting\"\n         sleep 120\n         exit 1\n      fi\n   done\n   log_debug \"IP address for ${icloud_domain}: ${icloud_dot_com}\"\n   if [ \"$(traceroute -q 1 -w 1 ${icloud_domain} >/dev/null 2>/tmp/icloudpd/icloudpd_tracert.err; echo $?)\" = 1 ]\n   then\n      log_error \"No route to ${icloud_domain} found. Please check your container's network settings - exiting\"\n      log_error \"Error debug - $(cat /tmp/icloudpd/icloudpd_tracert.err)\"\n      sleep 120\n      exit 1\n   else\n      log_debug \"Route check to ${icloud_domain} successful\"\n   fi\n   if [ \"${debug_logging}\" = true ]\n   then\n      log_info \"Debug logging: Enabled\"\n      log_info \"Apple ID: (hidden)\"\n      log_info \"Cookie path: /config/(hidden)\"\n   else\n      log_info \"Debug logging: Disabled\"\n      log_info \"Apple ID: ${apple_id}\"\n      log_info \"Cookie path: /config/${cookie_file}\"\n   fi\n   log_info \"Cookie expiry notification period: ${notification_days}\"\n   if [ -z \"${download_path}\" ]\n   then\n      log_error \"Download path is not set properly in config\"\n      sleep 120\n      exit 1\n   fi\n   log_info \"Download destination directory: ${download_path}\"\n   if [ ! -d \"${download_path}\" ]\n   then\n      log_info \"Download directory does not exist\"\n      log_info \"Creating ${download_path} and configuring permissions\"\n      \n      if ! mkdir --parents \"${download_path}\"\n      then \n         log_error \"Failed to create download directory: '${download_path}'\"\n         sleep 120\n         exit 1\n      fi\n      set_owner_and_permissions_downloads\n   fi\n   log_info \"Folder structure: ${folder_structure}\"\n   log_debug \"Directory permissions: ${directory_permissions}\"\n   log_debug \"File permissions: ${file_permissions}\"\n   if [ \"${syncronisation_interval}\" ]\n   then\n      log_warning \"The syncronisation_interval variable contained a typo. This has now been corrected to synchronisation_interval. Please update your container. Defaulting to one sync per 24 hour period\"\n      synchronisation_interval=\"86400\"\n   fi\n   log_info \"Keep Unicode: ${keep_unicode}\"\n   log_info \"Live Photo MOV Filename Policy: ${live_photo_mov_filename_policy}\"\n   log_info \"File Match Policy: ${file_match_policy}\"\n   log_info \"Synchronisation interval: ${synchronisation_interval}\"\n   if [ \"${synchronisation_interval}\" -lt 43200 ]\n   then\n      if [ \"${warnings_acknowledged:=false}\" = true ]\n      then\n         log_debug \"Synchronisation interval throttle warning acknowledged\"\n      else\n         log_warning \"Setting synchronisation_interval to less than 43200 (12 hours) may cause throttling by Apple\"\n         log_warning \"If you run into the following error: \"\n         log_warning \" - private db access disabled for this account. Please wait a few hours then try again. The remote servers might be trying to throttle requests. (ACCESS_DENIED)\"\n         log_warning \"Then check your synchronisation_interval is 43200 or greater and switch the container off for 6-12 hours so Apple's throttling expires. Continuing in 3 minutes\"\n         sleep 120\n      fi\n   fi\n   log_info \"Synchronisation delay (minutes): ${synchronisation_delay}\"\n   log_info \"Set EXIF date/time: ${set_exif_datetime}\"\n   if [ \"${set_exif_datetime}\" = true ]\n   then\n      log_warning \"This setting changes the files that are downloaded, so they will be downloaded a second time. Enabling this setting results in a lot of duplicate\"\n   fi\n   log_info \"Auto delete: ${auto_delete}\"\n   log_info \"Delete after download: ${delete_after_download}\"\n   if [ \"${auto_delete}\" != false ] && [ \"${delete_after_download}\" != false ]\n   then\n      log_error \"The variables auto_delete and delete_after_download cannot both be configured at the same time. Please choose one or the other - exiting\"\n      sleep 120\n      exit 1\n   fi\n   log_info \"Keep recent days: ${keep_recent_days}\"\n   log_info \"Delete empty directories: ${delete_empty_directories}\"\n   log_info \"Photo size: ${photo_size}\"\n   log_info \"Align RAW: ${align_raw}\"\n   log_info \"Single pass mode: ${single_pass}\"\n   if [ \"${single_pass}\" = true ]\n   then\n      log_debug \"Single pass mode enabled. Disabling download check\"\n      skip_check=true\n   fi\n   log_info \"Skip download check: ${skip_check}\"\n   log_info \"Skip live photos: ${skip_live_photos}\"\n   if [ \"${recent_only}\" ]\n   then\n      log_info \"Number of most recently added photos to download: ${recent_only}\"\n   else\n      log_info \"Number of most recently added photos to download: Download All Photos\"\n   fi\n   if [ \"${photo_album}\" ]\n   then\n      log_info \"Downloading photos from album(s): ${photo_album}\"\n   elif [ \"${photo_library}\" ]\n   then\n      log_info \"Downloading photos from library: ${photo_library}\"\n   else\n      log_info \"Downloading photos from: Download All Photos\"\n   fi\n   if [ \"${until_found}\" ]\n   then\n      log_info \"Stop downloading when prexisiting files count is: ${until_found}\"\n   else\n      log_info \"Stop downloading when prexisiting files count is: Download All Photos\"\n   fi\n   if [ \"${skip_live_photos}\" = false ]\n   then\n      log_info \"Live photo size: ${live_photo_size}\"\n   fi\n   log_info \"Skip videos: ${skip_videos}\"\n   log_info \"Convert HEIC to JPEG: ${convert_heic_to_jpeg}\"\n   if [ \"${convert_heic_to_jpeg}\" = true ]\n   then\n      log_debug \"JPEG conversion quality: ${jpeg_quality}\"\n   fi\n   if [ \"${jpeg_path}\" ]\n   then\n      log_info \"Converted JPEGs path: ${jpeg_path}\"\n   fi\n   if [ \"${delete_accompanying}\" = true ] && [ -z \"${warnings_acknowledged}\" ]\n   then\n      log_info \"Delete accompanying files (.JPG/.HEIC.MOV)\"\n      log_warning \" - This feature deletes files from your local disk. Please use with caution. I am not responsible for any data loss\"\n      log_warning \" - This feature cannot be used if the 'folder_structure' variable is set to 'none' and also, 'set_exif_datetime' must be 'False'\"\n      log_warning \" - These two settings will increase the chances of de-duplication happening, which could result in the wrong files being removed. Continuing in 2 minutes\"\n      if [ \"${warnings_acknowledged:=false}\" = true ]\n      then\n         log_info \"File deletion warning accepted\"\n      else\n         sleep 120\n      fi\n   fi\n   if [ \"${notification_type}\" ]\n   then\n      configure_notifications\n   fi\n   log_info \"Downloading from: ${icloud_domain}\"\n   if [ \"${icloud_china}\" = true ]\n   then\n      if [ \"${auth_china}\" = true ]\n      then\n         auth_domain=\"cn\"\n      else\n         log_warning \"You have the icloud_china variable set, but auth_china is false. Are you sure this is correct?\"\n         sleep 120\n      fi\n   fi\n   if [ \"${fake_user_agent}\" = true ]\n   then\n      log_info \"Fake user agent for curl: Enabled\"\n      curl_user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0\"\n   else\n      log_info \"Fake user agent for curl: Disabled\"\n   fi\n   log_info \"Authentication domain: ${auth_domain:=com}\"\n   if [ \"${nextcloud_upload}\" = true ]\n   then\n      if [ \"${nextcloud_url}\" ] && [ \"${nextcloud_username}\" ] && [ \"${nextcloud_password}\" ]\n      then\n         log_info \"Nextcloud upload: Enabled\"\n         log_info \"Nextcloud URL: ${nextcloud_url}\"\n         log_info \"Nextcloud Target Directory: ${nextcloud_target_dir}\"\n         log_info \"Nextcloud username: ${nextcloud_username}\"\n      else\n         log_error \"Nextcloud upload: Missing mandatory variables. Disabling\"\n         unset nextlcoud_upload\n      fi\n   else\n      log_debug \"Nextcloud upload: Disabled\"\n   fi\n\n   if [ \"${synology_ignore_path}\" = true ]\n   then\n      log_info \"Ignore Synology extended attribute directories: Enabled\"\n      ignore_path=\"*/@eaDir*\"\n   else\n      log_info \"Ignore Synology extended attribute directories: Disabled\"\n      ignore_path=\"\"\n   fi\n\n   source /opt/icloudpd/bin/activate\n   log_debug \"Activated Python virtual environment for icloudpd\"\n   log_info \"Container initialisation complete\"\n}\n\nlog_info()\n{\n   local log_message\n   log_message=\"${1}\"\n   echo \"$(date '+%Y-%m-%d %H:%M:%S') INFO     ${log_message}\"\n}\n\nlog_info_n()\n{\n   local log_message\n   log_message=\"${1}\"\n   echo -n \"$(date '+%Y-%m-%d %H:%M:%S') INFO     ${log_message}... \"\n}\n\nlog_warning()\n{\n   local log_message\n   log_message=\"${1}\"\n   echo \"$(date '+%Y-%m-%d %H:%M:%S') WARNING  ${log_message}\"\n}\n\nlog_error()\n{\n   local log_message\n   log_message=\"${1}\"\n   echo \"$(date '+%Y-%m-%d %H:%M:%S') ERROR    ${log_message}\"\n}\n\nlog_debug()\n{\n   if [ \"${debug_logging}\" = true ]\n   then\n      local log_message\n      log_message=\"${1}\"\n      echo \"$(date '+%Y-%m-%d %H:%M:%S') DEBUG    ${log_message}\"\n   fi\n}\n\nrun_as()\n{\n   local command_to_run\n   command_to_run=\"${1}\"\n   if [ \"$(id -u)\" = 0 ]\n   then\n      su \"${user}\" -s /bin/ash -c \"${command_to_run}\"\n   else\n      /bin/ash -c \"${command_to_run}\"\n   fi\n}\n\nclean_notification_title()\n{\n   if [ \"${notification_title}\" ]\n   then\n      notification_title=\"${notification_title//[^a-zA-Z0-9_ ]/}\"\n      log_debug \"Cleaned notification title: ${notification_title}\"\n   else\n      log_debug \"Notification title: ${notification_title:=boredazfcuk/iCloudPD}\"\n   fi\n}\n\nconfigure_notifications()\n{\n   if [ -z \"${prowl_api_key}\" ] && [ -z \"${pushover_token}\" ] && [ -z \"${telegram_token}\" ] && [ -z \"${webhook_id}\" ] && [ -z \"${dingtalk_token}\" ] && [ -z \"${discord_token}\" ] && [ -z \"${iyuu_token}\" ] && [ -z \"${wecom_secret}\" ] && [ -z \"${gotify_app_token}\" ] && [ -z \"${bark_device_key}\" ] && [ -z \"${msmtp_pass}\" ]\n   then\n      log_warning \"${notification_type} notifications enabled, but API key/token/secret not set - disabling notifications\"\n      unset notification_type\n   else\n      if [ \"${notification_type}\" = \"Prowl\" ] && [ \"${prowl_api_key}\" ]\n      then\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} api key: (hidden)\"\n         else\n            log_info \"${notification_type} api key: ${prowl_api_key}\"\n         fi\n         notification_url=\"https://api.prowlapp.com/publicapi/add\"\n      elif [ \"${notification_type}\" = \"Pushover\" ] && [ \"${pushover_user}\" ] && [ \"${pushover_token}\" ]\n      then\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} user: (hidden)\"\n            log_debug \"${notification_type} token: (hidden)\"\n         else\n            log_info \"${notification_type} user: ${pushover_user}\"\n            log_info \"${notification_type} token: ${pushover_token}\"\n         fi\n         if [ \"${pushover_sound}\" ]\n         then\n            case \"${pushover_sound}\" in\n               pushover|bike|bugle|cashregister|classical|cosmic|falling|gamelan|incoming|intermission|magic|mechanical|pianobar|siren|spacealarm|tugboat|alien|climb|persistent|echo|updown|vibrate|none)\n                  log_debug \"${notification_type} sound: ${pushover_sound}\"\n               ;;\n               *)\n                  log_debug \"${notification_type} sound not recognised. Using default\"\n                  unset pushover_sound\n            esac\n         fi\n         notification_url=\"https://api.pushover.net/1/messages.json\"\n      elif [ \"${notification_type}\" = \"Telegram\" ] && [ \"${telegram_token}\" ] && [ \"${telegram_chat_id}\" ]\n      then\n         if [ \"${telegram_http}\" = true ]\n         then\n            telegram_protocol=\"http\"\n         else\n            telegram_protocol=\"https\"\n         fi\n         if [ \"${telegram_server}\" ]\n         then\n            telegram_base_url=\"${telegram_protocol}://${telegram_server}/bot${telegram_token}\"\n         else\n            telegram_base_url=\"${telegram_protocol}://api.telegram.org/bot${telegram_token}\"\n         fi\n         notification_url=\"${telegram_base_url}/sendMessage\"\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} token: (hidden)\"\n            log_debug \"${notification_type} chat id: (hidden)\"\n            log_debug \"${notification_type} polling: ${telegram_polling}\"\n            log_debug \"${notification_type} uses HTTP: ${telegram_http}\"\n            log_debug \"${notification_type} base URL: (hidden)\"\n            log_debug \"${notification_type} notification URL: (hidden)\"\n         else\n            log_info \"${notification_type} token: ${telegram_token}\"\n            log_info \"${notification_type} chat id: ${telegram_chat_id}\"\n            log_info \"${notification_type} polling: ${telegram_polling}\"\n            log_info \"${notification_type} uses HTTP: ${telegram_http}\"\n            log_info \"${notification_type} base URL: ${telegram_base_url}\"\n            log_info \"${notification_type} notification URL: ${notification_url}\"\n         fi\n         if [ \"${script_launch_parameters}\" ]\n         then\n            telegram_polling=\"false\"\n         fi\n         if [ \"${telegram_polling}\" = true ]\n         then\n            telegram_update_id_offset_file=\"/config/telegram_update_id.num\"\n            if [ ! -f \"${telegram_update_id_offset_file}\" ]\n            then\n               log_debug \"Creating Telegram Update ID offset file\"\n               echo -n 0 > \"${telegram_update_id_offset_file}\"\n            fi\n            log_info \"Check Telegram bot initialised...\"\n            sleep \"$((RANDOM % 15))\"\n            if [ \"${telegram_server}\" ]\n            then\n               log_debug \"Checking ${telegram_server} for updates\"\n            else\n               log_debug \"Checking api.telegram.org for updates\"\n            fi\n            bot_check=\"$(curl --silent -X POST \"${telegram_base_url}/getUpdates\" | jq -r .ok)\"\n            log_debug \"Bot check: ${bot_check}\"\n            if [ \"${bot_check}\" = true ]\n            then\n               log_info \" - Bot has been initialised\"\n            else\n               log_info \" - Bot has not been initialised or needs reinitialising. Please send a message to the bot from your iDevice and restart the container. Disabling remote wake\"\n               sleep 10\n               telegram_polling=false\n            fi\n            telegram_update_id_offset=\"$(head -1 ${telegram_update_id_offset_file})\"\n            log_info \"Latest update id: ${telegram_update_id_offset}\"\n         fi\n         if [ \"${telegram_silent_file_notifications}\" ]\n         then\n            telegram_silent_file_notifications=true\n         fi\n         log_debug \"${notification_type} silent file notifications: ${telegram_silent_file_notifications:=false}\"\n      elif [ \"${notification_type}\" = \"openhab\" ] && [ \"${webhook_server}\" ] && [ \"${webhook_id}\" ]\n      then\n         if [ \"${webhook_https}\" = true ]\n         then\n            webhook_scheme=\"https\"\n         else\n            webhook_scheme=\"http\"\n         fi\n         log_info \"${notification_type} notifications enabled\"\n         log_debug \"${notification_type} server: ${webhook_server}\"\n         log_debug \"${notification_type} port: ${webhook_port:=8123}\"\n         log_debug \"${notification_type} path: ${webhook_path:=/rest/items/}\"\n         log_debug \"${notification_type} ID: ${webhook_id}\"\n         notification_url=\"${webhook_scheme}://${webhook_server}:${webhook_port}${webhook_path}${webhook_id}\"\n         log_debug \"${notification_type} notification URL: ${notification_url}\"\n      elif [ \"${notification_type}\" = \"Webhook\" ] && [ \"${webhook_server}\" ] && [ \"${webhook_id}\" ]\n      then\n         if [ \"${webhook_https}\" = true ]\n         then\n            webhook_scheme=\"https\"\n         else\n            webhook_scheme=\"http\"\n         fi\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         log_debug \"${notification_type} server: ${webhook_server}\"\n         log_debug \"${notification_type} port: ${webhook_port:=8123}\"\n         log_debug \"${notification_type} path: ${webhook_path:=/api/webhook/}\"\n         log_debug \"${notification_type} ID: ${webhook_id}\"\n         notification_url=\"${webhook_scheme}://${webhook_server}:${webhook_port}${webhook_path}${webhook_id}\"\n         log_debug \"${notification_type} notification URL: ${notification_url}\"\n         log_debug \"${notification_type} body keyword: ${webhook_body:=data}\"\n         if [ \"${webhook_insecure}\" ]\n         then\n            log_debug \"${notification_type} insecure certificates allowed\"\n         fi\n      elif [ \"${notification_type}\" = \"Discord\" ] && [ \"${discord_id}\" ] && [ \"${discord_token}\" ]\n      then\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} Discord ID: (hidden)\"\n            log_debug \"${notification_type} Discord token: (hidden)\"\n            notification_url=\"https://discord.com/api/webhooks/${discord_id}/${discord_token}\"\n            log_debug \"${notification_type} notification URL: (hidden)\"\n         else\n            log_info \"${notification_type} Discord ID: ${discord_id}\"\n            log_info \"${notification_type} Discord token: ${discord_token}\"\n            notification_url=\"https://discord.com/api/webhooks/${discord_id}/${discord_token}\"\n            log_info \"${notification_type} notification URL: ${notification_url}\"\n         fi\n      elif [ \"${notification_type}\" = \"Dingtalk\" ] && [ \"${dingtalk_token}\" ]\n      then\n         notification_url=\"https://oapi.dingtalk.com/robot/send?access_token=${dingtalk_token}\"\n         log_info \"${notification_type} notifications enabled\"\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} token: (hidden)\"\n            log_debug \"${notification_type} notification URL: (hidden)\"\n         else\n            log_info \"${notification_type} token: ${dingtalk_token}\"\n            log_info \"${notification_type} notification URL: ${notification_url}\"\n         fi\n      elif [ \"${notification_type}\" = \"IYUU\" ] && [ \"${iyuu_token}\" ]\n      then\n         notification_url=\"http://iyuu.cn/${iyuu_token}.send?\"\n         log_info \"${notification_type} notifications enabled\"\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} token: (hidden)\"\n            log_debug \"${notification_type} notification URL: (hidden)\"\n         else\n            log_info \"${notification_type} token: ${iyuu_token}\"\n            log_info \"${notification_type} notification URL: ${notification_url}\"\n         fi\n      elif [ \"${notification_type}\" = \"WeCom\" ] && [ \"${wecom_id}\" ] && [ \"${wecom_secret}\" ]\n      then\n         wecom_base_url=\"https://qyapi.weixin.qq.com\"\n         if [ \"${wecom_proxy}\" ]\n         then\n            wecom_base_url=\"${wecom_proxy}\"\n            log_debug \"${notification_type} notifications proxy enabled : ${wecom_proxy}\"\n         fi\n         wecom_token_url=\"${wecom_base_url}/cgi-bin/gettoken?corpid=${wecom_id}&corpsecret=${wecom_secret}\"\n         if [ \"${fake_user_agent}\" = true ]\n         then\n            wecom_token=\"$(/usr/bin/curl --silent --user-agent \"${curl_user_agent}\" --get \"${wecom_token_url}\" | awk -F\\\" '{print $10}')\"\n         else\n            wecom_token=\"$(/usr/bin/curl --silent --get \"${wecom_token_url}\" | awk -F\\\" '{print $10}')\"\n         fi\n         wecom_token_expiry=\"$(date --date='2 hour')\"\n         notification_url=\"${wecom_base_url}/cgi-bin/message/send?access_token=${wecom_token}\"\n         log_info \"${notification_type} notifications enabled\"\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} token: (hidden)\"\n            log_debug \"${notification_type} token expiry time: $(date -d \"${wecom_token_expiry}\")\"\n            log_debug \"${notification_type} notification URL: (hidden)\"\n         else\n            log_info \"${notification_type} token: ${wecom_token}\"\n            log_info \"${notification_type} token expiry time: $(date -d \"${wecom_token_expiry}\")\"\n            log_info \"${notification_type} notification URL: ${notification_url}\"\n         fi\n      elif [ \"${notification_type}\" = \"Gotify\" ] && [ \"${gotify_app_token}\" ] && [ \"${gotify_server_url}\" ]\n      then\n      if [ \"${gotify_https}\" = true ]\n      then\n            gotify_scheme=\"https\"\n         else\n            gotify_scheme=\"http\"\n         fi\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} token: (hidden)\"\n            log_debug \"${notification_type} server URL: (hidden)\"\n         else\n            log_info \"${notification_type} token: ${gotify_app_token}\"\n            log_info \"${notification_type} server URL: ${gotify_scheme}://${gotify_server_url}\"\n         fi\n         notification_url=\"${gotify_scheme}://${gotify_server_url}/message?token=${gotify_app_token}\"\n      elif [ \"${notification_type}\" = \"Bark\" ] && [ \"${bark_device_key}\" ] && [ \"${bark_server}\" ]\n      then\n         log_info \"${notification_type} notifications enabled\"\n         clean_notification_title\n         if [ \"${debug_logging}\" = true ]\n         then\n            log_debug \"${notification_type} device key: (hidden)\"\n            log_debug \"${notification_type} server: (hidden)\"\n         else\n            log_info \"${notification_type} device key: ${bark_device_key}\"\n            log_info \"${notification_type} server: ${bark_server}\"\n         fi\n         notification_url=\"http://${bark_server}/push\"\n      elif [ \"${notification_type}\" = \"msmtp\" ] && [ \"${msmtp_host}\" ] && [ \"${msmtp_port}\" ] && [ \"${msmtp_user}\" ] && [ \"${msmtp_pass}\" ]\n      then\n         log_info \"${notification_type} notifications enabled\"\n      else\n         log_warning \"$(date '+%Y-%m-%d %H:%M:%S') WARINING ${notification_type} notifications enabled, but configured incorrectly - disabling notifications\"\n         unset notification_type prowl_api_key pushover_user pushover_token telegram_token telegram_chat_id webhook_scheme webhook_server webhook_port webhook_id dingtalk_token discord_id discord_token iyuu_token wecom_id wecom_secret gotify_app_token gotify_scheme gotify_server_url bark_device_key bark_server\n      fi\n\n      if [ \"${startup_notification}\" = true ]\n      then\n         log_debug \"Startup notification: Enabled\"\n         if [ \"${icloud_china}\" = false ]\n         then\n            send_notification \"startup\" \"iCloudPD container started\" \"0\" \"iCloudPD container starting for Apple ID: ${apple_id}\"\n         else\n            send_notification \"startup\" \"iCloudPD container started\" \"0\" \"启动成功，开始同步当前 Apple ID 中的照片\" \"\" \"\" \"\" \"开始同步 ${name} 的 iCloud 图库\" \"Apple ID: ${apple_id}\"\n         fi\n      else\n         log_debug \"Startup notification: Disabled\"\n      fi\n\n      if [ \"${download_notifications}\" = true ]\n      then\n         log_debug \"Download notifications: Enabled\"\n      else\n         log_debug \"Download notifications: Disabled\"\n         unset download_notifications\n      fi\n      if [ \"${delete_notifications}\" = true ]\n      then\n         log_debug \"Delete notifications: Enabled\"\n      else\n         log_debug \"Delete notifications: Disabled\"\n         unset delete_notifications\n      fi\n   fi\n}\n\ncreate_group()\n{\n   if [ \"$(grep -c \"^${group}:x:${group_id}:\" \"/etc/group\")\" -eq 1 ]\n   then\n      log_debug \"Group, ${group}:${group_id}, already created\"\n   else\n      log_debug \"Creating minimal /etc/group file\"\n      {\n         echo 'root:x:0:root'\n         echo 'tty:x:5:'\n         echo 'shadow:x:42:'\n      } >/etc/group\n      if [ \"$(grep -c \"^${group}:\" \"/etc/group\")\" -eq 1 ]\n      then\n         log_error \"Group name, ${group}, already in use - exiting\"\n         sleep 120\n         exit 1\n      fi\n      log_debug \"Creating group ${group}:${group_id}\"\n      groupadd --gid \"${group_id}\" \"${group}\"\n   fi\n}\n\ncreate_user()\n{\n   if [ \"$(grep -c \"^${user}:x:${user_id}:${group_id}\" \"/etc/passwd\")\" -eq 1 ]\n   then\n      log_debug \"User, ${user}:${user_id}, already created\"\n   else\n      log_debug \"Creating minimal /etc/passwd file\"\n      {\n         echo 'root:x:0:0:root:/root:/bin/bash'\n      } >/etc/passwd\n      log_debug \"Creating user ${user}:${user_id}\"\n      useradd --shell /bin/bash --gid \"${group_id}\" --uid \"${user_id}\" \"${user}\" --home-dir \"/home/${user}\" --badname\n   fi\n}\n\nlist_libraries()\n{\n   local shared_libraries\n   if [ \"${authentication_type}\" = \"MFA\" ]\n   then\n      check_multifactor_authentication_cookie\n   else\n      check_web_cookie\n   fi\n   IFS=$'\\n'\n   if [ \"${skip_download}\" = false ]\n   then\n      shared_libraries=\"$(run_as \"/opt/icloudpd/bin/icloudpd --username ${apple_id} --cookie-directory /config --domain ${auth_domain} --directory /dev/null --list-libraries | sed '1d'\")\"\n   fi\n   log_info \"Shared libraries:\"\n   for library in ${shared_libraries}\n   do\n      log_info \" - ${library}\"\n   done\n   IFS=\"${save_ifs}\"\n}\n\nlist_albums()\n{\n   local photo_albums\n   if [ \"${authentication_type}\" = \"MFA\" ]\n   then\n      check_multifactor_authentication_cookie\n   else\n      check_web_cookie\n   fi\n   IFS=$'\\n'\n   if [ \"${skip_download}\" = false ]\n   then\n      photo_albums=\"$(run_as \"/opt/icloudpd/bin/icloudpd --username ${apple_id} --cookie-directory /config --domain ${auth_domain} --directory /dev/null --list-albums | sed '1d' | sed '/^Albums:$/d'\")\"\n   fi\n   log_info \"Photo albums:\"\n   for photo_album in ${photo_albums}\n   do\n      log_info \" - ${photo_album}\"\n   done\n   IFS=\"${save_ifs}\"\n}\n\ndelete_password()\n{\n   if [ -f \"/config/python_keyring/keyring_pass.cfg\" ]\n   then\n      log_warning \"Keyring file /config/python_keyring/keyring_pass.cfg exists, but --remove-keyring command line switch has been invoked. Removing in 30 seconds\"\n      if [ -z \"${warnings_acknowledged}\" ]\n      then\n         sleep 30\n      else\n         log_info \"Warnings acknowledged, removing immediately\"\n      fi\n      rm \"/config/python_keyring/keyring_pass.cfg\"\n   else\n      log_error \"Keyring file does not exist\"\n   fi\n}\n\nconfigure_password()\n{\n   log_debug \"Configure password\"\n   if [ -f \"/config/python_keyring/keyring_pass.cfg\" ]\n   then\n      if [ \"$(grep -c \"=\" \"/config/python_keyring/keyring_pass.cfg\")\" -eq 0 ]\n      then\n         log_debug \"Keyring file /config/python_keyring/keyring_pass.cfg exists, but does not contain any credentials. Removing\"\n         rm \"/config/python_keyring/keyring_pass.cfg\"\n      fi\n   fi\n   if [ ! -f \"/config/python_keyring/keyring_pass.cfg\" ]\n   then\n      if [ \"${initialise_container}\" ]\n      then\n         log_debug \"Adding password to keyring file: /config/python_keyring/keyring_pass.cfg\"\n         run_as \"/opt/icloudpd/bin/icloud --username ${apple_id} --domain ${auth_domain}\"\n      else\n         log_error \"Keyring file /config/python_keyring/keyring_pass.cfg does not exist\"\n         log_error \" - Please add the your password to the system keyring using the --Initialise script command line option\"\n         log_error \" - Syntax: docker exec -it <container name> sync-icloud.sh --Initialise\"\n         log_error \" - Example: docker exec -it icloudpd sync-icloud.sh --Initialise\"\n         log_error \"Waiting for keyring file to be created...\"\n         local counter\n         counter=\"${counter:=0}\"\n         while [ ! -f \"/config/python_keyring/keyring_pass.cfg\" ]\n         do\n            sleep 5\n            counter=$((counter + 1))\n            if [ \"${counter}\" -eq 360 ]\n            then\n               log_error \"Keyring file has not appeared within 30 minutes. Restarting container...\"\n               exit 1\n            fi\n         done\n         log_debug \"Keyring file exists, continuing\"\n      fi\n   else\n      log_debug \"Using password stored in keyring file: /config/python_keyring/keyring_pass.cfg\"\n   fi\n   if [ ! -f \"/config/python_keyring/keyring_pass.cfg\" ]\n   then\n      log_error \"Keyring file does not exist. Please try again\"\n      sleep 120\n      exit 1\n   fi\n}\n\ngenerate_cookie()\n{\n   log_debug \"$(date '+%Y-%m-%d %H:%M:%S') INFO     Correct owner on config directory, if required\"\n   find \"/config\" ! -user \"${user}\" -exec chown \"${user_id}\" {} +\n   log_debug \"$(date '+%Y-%m-%d %H:%M:%S') INFO     Correct group on config directory, if required\"\n   find \"/config\" ! -group \"${group}\" -exec chgrp \"${group_id}\" {} +\n   if [ -f \"/config/${cookie_file}\" ]\n   then\n      mv \"/config/${cookie_file}\" \"/config/${cookie_file}.bak\"\n   fi\n   if [ -f \"/config/${cookie_file}.session\" ]\n   then\n      mv \"/config/${cookie_file}.session\" \"/config/${cookie_file}session.bak\"\n   fi\n   log_debug \"Generate ${authentication_type} cookie using password stored in keyring file\"\n   run_as \"/opt/icloudpd/bin/icloudpd --username ${apple_id} --cookie-directory /config --auth-only --domain ${auth_domain}\"\n   if [ \"${authentication_type}\" = \"MFA\" ]\n   then\n      if [ \"$(grep -c \"X-APPLE-WEBAUTH-HSA-TRUST\" \"/config/${cookie_file}\")\" -eq 1 ]\n      then\n         log_info \"Multifactor authentication cookie generated. Sync should now be successful\"\n      else\n         log_error \"Multifactor authentication information missing from cookie. Authentication has failed\"\n         log_error \" - Was the correct password entered?\"\n         log_error \" - Was the multifactor authentication code mistyped?\"\n         log_error \" - Can you log into ${icloud_domain} without receiving pop-up notifications?\"\n         if [ \"${icloud_china}\" = true ]\n         then\n            log_error \" - Are you based in China? You will need to set the icloud_china variable\"\n         fi\n      fi\n   else\n      log_debug \"Web cookie generated. Sync should now be successful\"\n   fi\n}\n\ncheck_mount()\n{\n   log_info \"Check download directory mounted correctly...\"\n   if [ ! -f \"${download_path}/.mounted\" ]\n   then\n      log_warning \"Failsafe file ${download_path}/.mounted file is not present. Waiting for failsafe file to be created...\"\n      local counter\n      counter=\"0\"\n   fi\n   while [ ! -f \"${download_path}/.mounted\" ]\n   do\n      sleep 5\n      counter=$((counter + 1))\n      if [ \"${counter}\" -eq 360 ]\n      then\n         log_error \"Failsafe file has not appeared within 30 minutes. Restarting container...\"\n         exit 1\n      fi\n   done\n   log_info \"Failsafe file ${download_path}/.mounted exists, continuing\"\n}\n\nset_owner_and_permissions_config()\n{\n   log_debug \"Set owner and group on icloudpd temp directory\"\n   chown -R \"${user_id}:${group_id}\" \"/tmp/icloudpd\"\n   log_debug \"Set owner and group on config directory\"\n   chown -R \"${user_id}:${group_id}\" \"/config\"\n\n   if [ -d \"/config/python_keyring/\" ]\n   then\n      if [ \"$(run_as \"test -w /config/python_keyring/; echo $?\")\" -eq 0 ]\n      then\n         log_info \"Directory is writable: /config/python_keyring/\"\n      else\n         log_error \"Directory is not writable: /config/python_keyring/\"\n         sleep 120\n         exit 1\n      fi\n   fi\n}\n\nset_owner_and_permissions_downloads()\n{\n   log_debug \"Set owner on iCloud directory, if required\"\n   find \"${download_path}\" ! -type l ! -user \"${user_id}\" ! -path \"${ignore_path}\" -exec chown \"${user_id}\" {} +\n   log_debug \"Set group on iCloud directory, if required\"\n   find \"${download_path}\" ! -type l ! -group \"${group_id}\" ! -path \"${ignore_path}\" -exec chgrp \"${group_id}\" {} +\n   log_debug \"Set ${directory_permissions} permissions on iCloud directories, if required\"\n   find \"${download_path}\" -type d ! -perm \"${directory_permissions}\" ! -path \"${ignore_path}\" -exec chmod \"${directory_permissions}\" '{}' +\n   log_debug \"Set ${file_permissions} permissions on iCloud files, if required\"\n   find \"${download_path}\" -type f ! -perm \"${file_permissions}\" ! -path \"${ignore_path}\" -exec chmod \"${file_permissions}\" '{}' +\n   if [ \"${jpeg_path}\" ]\n   then\n      log_debug \"Set owner on jpeg directory, if required\"\n      find \"${jpeg_path}\" ! -type l ! -user \"${user_id}\" ! -path \"${ignore_path}\" -exec chown \"${user_id}\" {} +\n      log_debug \"Set group on jpeg directory, if required\"\n      find \"${jpeg_path}\" ! -type l ! -group \"${group_id}\" ! -path \"${ignore_path}\" -exec chgrp \"${group_id}\" {} +\n      log_debug \"Set ${directory_permissions} permissions on jpeg directories, if required\"\n      find \"${jpeg_path}\" -type d ! -perm \"${directory_permissions}\" ! -path \"${ignore_path}\" -exec chmod \"${directory_permissions}\" '{}' +\n      log_debug \"Set ${file_permissions} permissions on jpeg files, if required\"\n      find \"${jpeg_path}\" -type f ! -perm \"${file_permissions}\" ! -path \"${ignore_path}\" -exec chmod \"${file_permissions}\" '{}' +\n   fi\n}\n\ncheck_permissions()\n{\n   if [ \"$(run_as \"${user}\" \"if ! test -w \\\"${download_path}\\\"; then echo false; fi\")\" = false ]\n   then\n      log_warning \"User ${user}:${user_id} cannot write to directory: ${download_path} - Attempting to set permissions\"\n      set_owner_and_permissions_downloads\n      if [ \"$(run_as \"${user}\" \"if ! test -w \\\"${download_path}\\\"; then echo false; fi\")\" = false ]\n      then\n         log_error \"User ${user}:${user_id} still cannot write to directory: ${download_path}\"\n         log_error \" - Fixing permissions failed - Cannot continue, exiting\"\n         sleep 120\n         exit 1\n      fi\n   fi\n   if [ \"$(run_as \"${user}\" \"if ! test -w \\\"${jpeg_path}\\\"; then echo false; fi\")\" = false ]\n   then\n      log_warning \"User ${user}:${user_id} cannot write to directory: ${jpeg_path} - Attempting to set permissions\"\n      set_owner_and_permissions_downloads\n      if [ \"$(run_as \"${user}\" \"if ! test -w \\\"${jpeg_path}\\\"; then echo false; fi\")\" = false ]\n      then\n         log_error \"User ${user}:${user_id} still cannot write to directory: ${jpeg_path}\"\n         log_error \" - Fixing permissions failed - Cannot continue, exiting\"\n         sleep 120\n         exit 1\n      fi\n   fi\n}\n\ncheck_keyring_exists()\n{\n   if [ -f \"/config/python_keyring/keyring_pass.cfg\" ]\n   then\n      log_info \"Keyring file exists, continuing\"\n   else\n      log_error \"Keyring does not exist\"\n      log_error \" - Please add your password to the system keyring by using the --Initialise script command line option\"\n      log_error \" - Syntax: docker exec -it <container name> sync-icloud.sh --Initialise\"\n      log_error \" - Example: docker exec -it icloudpd sync-icloud.sh --Initialise\"\n      log_error \"Waiting for keyring file to be created...\"\n      local counter\n      counter=\"${counter:=0}\"\n      while [ ! -f \"/config/python_keyring/keyring_pass.cfg\" ]\n      do\n         sleep 5\n         counter=$((counter + 1))\n         if [ \"${counter}\" -eq 360 ]\n         then\n            log_error \"Keyring file has not appeared within 30 minutes. Restarting container...\"\n            exit 1\n         fi\n      done\n      log_info \"Keyring file exists, continuing\"\n   fi\n}\n\nwait_for_cookie()\n{\n   if [ \"${1}\" = \"DisplayMessage\" ]\n   then\n      log_error \"Waiting for valid cookie file to be created...\"\n      log_error \" - Please create your cookie using the --Initialise script command line option\"\n      log_error \" - Syntax: docker exec -it <container name> sync-icloud.sh --Initialise\"\n      log_error \" - Example: docker exec -it icloudpd sync-icloud.sh --Initialise\"\n   fi\n   local counter\n   counter=\"${counter:=0}\"\n   while [ ! -f \"/config/${cookie_file}\" ]\n   do\n      sleep 5\n      counter=$((counter + 1))\n      if [ \"${counter}\" -eq 360 ]\n      then\n         log_error \"Valid cookie file has not appeared within 30 minutes. Restarting container...\"\n         exit 1\n      fi\n   done\n}\n\nwait_for_authentication()\n{\n   local counter\n   counter=\"${counter:=0}\"\n   while [ \"$(grep -c \"X-APPLE-WEBAUTH-HSA-TRUST\" \"/config/${cookie_file}\" >/dev/null 2>&1 && echo 1 || echo 0)\" -eq 0 ]\n   do\n      sleep 5\n      counter=$((counter + 1))\n      if [ \"${counter}\" -eq 360 ]\n      then\n         log_error \"Valid cookie file has not appeared within 30 minutes. Restarting container...\"\n         exit 1\n      fi\n   done\n}\n\ncheck_web_cookie()\n{\n   if [ -f \"/config/${cookie_file}\" ]\n   then\n      log_debug \"Web cookie exists\"\n      web_cookie_expire_date=\"$(grep \"X_APPLE_WEB_KB\" \"/config/${cookie_file}\" | sed -e 's#.*expires=\"\\(.*\\)Z\"; HttpOnly.*#\\1#')\"\n   else\n      log_error \"Web cookie does not exist\"\n      wait_for_cookie DisplayMessage\n      log_info \"Cookie file exists, continuing\"\n   fi\n}\n\ncheck_multifactor_authentication_cookie()\n{\n   if [ -f \"/config/${cookie_file}\" ]\n   then\n      log_debug \"Multifactor authentication cookie exists\"\n   else\n      log_error \"Multifactor authentication cookie does not exist\"\n      wait_for_cookie DisplayMessage\n      log_debug \"Multifactor authentication cookie file exists, checking validity...\"\n   fi\n   if [ \"$(grep -c \"X-APPLE-DS-WEB-SESSION-TOKEN\" \"/config/${cookie_file}\")\" -eq 1 ] && [ \"$(grep -c \"X-APPLE-WEBAUTH-HSA-TRUST\" \"/config/${cookie_file}\")\" -eq 0 ]\n   then\n      log_debug \"Multifactor authentication cookie exists, but not autenticated. Waiting for authentication to complete...\"\n      wait_for_authentication\n      log_debug \"Multifactor authentication authentication complete, checking expiry date...\"\n   fi\n   if [ \"$(grep -c \"X-APPLE-WEBAUTH-USER\" \"/config/${cookie_file}\")\" -eq 1 ]\n   then\n      mfa_expire_date=\"$(grep \"X-APPLE-WEBAUTH-USER\" \"/config/${cookie_file}\" | sed -e 's#.*expires=\"\\(.*\\)Z\"; HttpOnly.*#\\1#')\"\n      mfa_expire_seconds=\"$(date -d \"${mfa_expire_date}\" '+%s')\"\n      days_remaining=\"$(($((mfa_expire_seconds - $(date '+%s'))) / 86400))\"\n      echo \"${days_remaining}\" > \"/config/DAYS_REMAINING\"\n      if [ \"${days_remaining}\" -gt 0 ]\n      then\n         valid_mfa_cookie=true\n         log_debug \"Valid multifactor authentication cookie found. Days until expiration: ${days_remaining}\"\n      else\n         rm -f \"/config/${cookie_file}\"\n         log_error \"Cookie expired at: ${mfa_expire_date}\"\n         log_error \"Expired cookie file has been removed. Restarting container in 5 minutes\"\n         sleep 300\n         exit 1\n      fi\n   else\n      rm -f \"/config/${cookie_file}\"\n      log_error \"Cookie is not multifactor authentication capable, authentication type may have changed\"\n      log_error \"Invalid cookie file has been removed. Restarting container in 5 minutes\"\n      sleep 300\n      exit 1\n   fi\n}\n\ndisplay_multifactor_authentication_expiry()\n{\n   local error_message\n   log_info \"Multifactor authentication cookie expires: ${mfa_expire_date/ / @ }\"\n   log_info \"Days remaining until expiration: ${days_remaining}\"\n   if [ \"${days_remaining}\" -le \"${notification_days}\" ]\n   then\n      if [ \"${days_remaining}\" -eq 1 ]\n      then\n         cookie_status=\"cookie expired\"\n         if [ \"${icloud_china}\" = false ]\n         then\n            error_message=\"Final day before multifactor authentication cookie expires for Apple ID: ${apple_id} - Please reinitialise now. This is your last reminder\"\n         else\n            error_message=\"今天是 ${name} 的 Apple ID 两步验证 cookie 到期前的最后一天 - 请立即重新初始化，这是最后的提醒\"\n         fi\n      else\n         cookie_status=\"cookie expiration\"\n         if [ \"${icloud_china}\" = false ]\n         then\n            error_message=\"Only ${days_remaining} days until multifactor authentication cookie expires for Apple ID: ${apple_id} - Please reinitialise\"\n         else\n            error_message=\"${days_remaining} 天后 ${name} 的 Apple ID 两步验证将到期 - 请立即重新初始化\"\n         fi\n      fi\n      log_warning \"${error_message}\"\n      if [ \"${synchronisation_time:=$(date +%s -d '+15 minutes')}\" -gt \"${next_notification_time:=$(date +%s)}\" ]\n      then\n         if [ \"${icloud_china}\" = false ]\n         then\n            send_notification \"${cookie_status}\" \"Multifactor Authentication Cookie Expiration\" \"2\" \"${error_message}\"\n         else\n            send_notification \"${cookie_status}\" \"Multifactor Authentication Cookie Expiration\" \"2\" \"${error_message}\" \"\" \"\" \"\" \"${days_remaining} 天后，${name} 的身份验证到期\" \"${error_message}\"\n         fi\n         next_notification_time=\"$(date +%s -d \"+24 hour\")\"\n         log_debug \"Next notification not before: $(date +%H:%M:%S -d \"${next_notification_time} seconds\")\"\n      fi\n   fi\n}\n\ncheck_files()\n{\n   if [ -f \"/tmp/icloudpd/icloudpd_check.log\" ]\n   then\n      rm \"/tmp/icloudpd/icloudpd_check.log\"\n   fi\n   log_info \"Check for new files using password stored in keyring file\"\n   log_info \"Generating list of files in iCloud. This may take a long time if you have a large photo collection. Please be patient. Nothing is being downloaded at this time\"\n   log_debug \"Launch command: /opt/icloudpd/bin/icloudpd --directory ${download_path} --cookie-directory /config --username ${apple_id} --domain ${auth_domain} --folder-structure ${folder_structure} --only-print-filenames\"\n   >/tmp/icloudpd/icloudpd_check_error\n   run_as \"(/opt/icloudpd/bin/icloudpd --directory ${download_path} --cookie-directory /config --username ${apple_id} --domain ${auth_domain} --folder-structure ${folder_structure} --only-print-filenames 2>/tmp/icloudpd/icloudpd_check_error; echo $? >/tmp/icloudpd/icloudpd_check_exit_code) | tee /tmp/icloudpd/icloudpd_check.log\"\n   check_exit_code=\"$(cat /tmp/icloudpd/icloudpd_check_exit_code)\"\n   if [ \"${check_exit_code}\" -ne 0 ] || [ -s /tmp/icloudpd/icloudpd_check_error ]\n   then\n      log_error \"Failed check for new files files\"\n      log_error \" - Can you log into ${icloud_domain} without receiving pop-up notifications?\"\n      log_error \"Error debugging info:\"\n      log_error \"$(cat /tmp/icloudpd/icloudpd_check_error)\"\n      if [ \"${debug_logging}\" != true ]\n      then\n         log_error \"Please set debug_logging=true in your icloudpd.conf file then reproduce the error\"\n         log_error \"***** Once you have captured this log file, please post it along with a description of your problem, here: https://github.com/boredazfcuk/docker-icloudpd/issues *****\"\n      else\n         log_error \"***** Please post the above debug log, along with a description of your problem, here: https://github.com/boredazfcuk/docker-icloudpd/issues *****\"\n      fi\n      if [ \"${icloud_china}\" = false ]\n      then\n         send_notification \"failure\" \"iCloudPD container failure\" \"0\" \"iCloudPD failed check for new files for Apple ID: ${apple_id}\"\n      else\n         syn_end_time=\"$(date '+%H:%M:%S')\"\n         syn_next_time=\"$(date +%H:%M:%S -d \"${synchronisation_interval} seconds\")\"\n         send_notification \"failure\" \"iCloudPD container failure\" \"0\" \"检查 iCloud 图库新照片失败，将在 ${syn_next_time} 再次尝试\" \"\" \"\" \"\" \"检查 ${name} 的 iCloud 图库新照片失败\" \"将在 ${syn_next_time} 再次尝试\"\n      fi\n   else\n      log_info \"Check successful\"\n      check_files_count=\"$(wc --lines /tmp/icloudpd/icloudpd_check.log | awk '{print $1}')\"\n      if [ \"${check_files_count}\" -gt 0 ]\n      then\n         log_info \"New files detected: ${check_files_count}\"\n      else\n         log_info \"No new files detected. Nothing to download\"\n      fi\n   fi\n   login_counter=$((login_counter + 1))\n}\n\ndownloaded_files_notification()\n{\n   IFS=$'\\n'\n   local new_files_count new_files_preview new_files_text\n   new_files=\"$(grep \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log)\"\n   new_files_count=\"$(grep -c \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log)\"\n   if [ \"${new_files_count:=0}\" -gt 0 ]\n   then\n      log_info \"New files downloaded: ${new_files_count}\"\n      new_files_preview=\"$(echo \"${new_files}\" | cut --delimiter \" \" --fields 9- | sed -e \"s%${download_path}/%%g\" | head -10)\"\n      new_files_preview_count=\"$(echo \"${new_files_preview}\" | wc -l)\"\n      if [ \"${icloud_china}\" = false ]\n      then\n         new_files_text=\"Files downloaded for Apple ID ${apple_id}: ${new_files_count}\"\n         send_notification \"downloaded files\" \"New files detected\" \"0\" \"${new_files_text}\" \"${new_files_preview_count}\" \"downloaded\" \"${new_files_preview}\"\n      else\n         # 结束时间、下次同步时间\n         syn_end_time=\"$(date '+%H:%M:%S')\"\n         syn_next_time=\"$(date +%H:%M:%S -d \"${synchronisation_interval} seconds\")\"\n         new_files_text=\"iCloud 图库同步完成，新增 ${new_files_count} 张照片\"\n         send_notification \"downloaded files\" \"New files detected\" \"0\" \"${new_files_text}\" \"${new_files_preview_count}\" \"下载\" \"${new_files_preview}\" \"新增 ${new_files_count} 张照片 - ${name}\" \"下次同步时间 ${syn_next_time}\"\n      fi\n   fi\n   IFS=\"${save_ifs}\"\n}\n\ndeleted_files_notification()\n{\n   IFS=$'\\n'\n   local deleted_files deleted_files_count deleted_files_preview deleted_files_text\n   deleted_files=\"$(grep \"Deleted /\" /tmp/icloudpd/icloudpd_sync.log)\"\n   deleted_files_count=\"$(grep -c \"Deleted /\" /tmp/icloudpd/icloudpd_sync.log)\"\n   if [ \"${deleted_files_count:=0}\" -gt 0 ]\n   then\n      log_info \"Number of files deleted: ${deleted_files_count}\"\n      deleted_files_preview=\"$(echo \"${deleted_files}\" | cut --delimiter \" \" --fields 9- | sed -e \"s%${download_path}/%%g\" -e \"s%!$%%g\" | tail -10)\"\n      deleted_files_preview_count=\"$(echo \"${deleted_files_preview}\" | wc -l)\"\n      if [ \"${icloud_china}\" = false ]\n      then\n         deleted_files_text=\"Files deleted for Apple ID ${apple_id}: ${deleted_files_count}\"\n         send_notification \"deleted files\" \"Recently deleted files detected\" \"0\" \"${deleted_files_text}\" \"${deleted_files_preview_count}\" \"deleted\" \"${deleted_files_preview}\"\n      else\n         # 结束时间、下次同步时间\n         syn_end_time=\"$(date '+%H:%M:%S')\"\n         syn_next_time=\"$(date +%H:%M:%S -d \"${synchronisation_interval} seconds\")\"\n         deleted_files_text=\"iCloud 图库同步完成，删除 ${deleted_files_count} 张照片\"\n         send_notification \"deleted files\" \"Recently deleted files detected\" \"0\" \"${deleted_files_text}\" \"${deleted_files_preview_count}\" \"删除\" \"${deleted_files_preview}\" \"删除 ${deleted_files_count} 张照片 - ${name}\" \"下次同步时间 ${syn_next_time}\"\n      fi\n   fi\n   IFS=\"${save_ifs}\"\n}\n\ndownload_albums()\n{\n   local all_albums albums_to_download log_level\n   if [ \"${photo_album}\" = \"all albums\" ]\n   then\n      all_albums=\"$(run_as \"/opt/icloudpd/bin/icloudpd --username ${apple_id} --cookie-directory /config --domain ${auth_domain} --directory /dev/null --list-albums | sed '1d' | sed '/^Albums:$/d'\")\"\n      log_debug \"Buildling list of albums to download...\"\n      IFS=$'\\n'\n      for album in ${all_albums}\n      do\n         if [ \"${skip_album}\" ]\n         then\n            if [ ! \"${skip_album}\" = \"${album}\" ]\n            then\n               log_debug \" - ${album}\"\n               if [ -z \"${albums_to_download}\" ]\n               then\n                  albums_to_download=\"${album}\"\n               else\n                  albums_to_download=\"${albums_to_download},${album}\"\n               fi\n            fi\n         else\n            log_debug \" - ${album}\"\n            if [ -z \"${albums_to_download}\" ]\n            then\n               albums_to_download=\"${album}\"\n            else\n               albums_to_download=\"${albums_to_download},${album}\"\n            fi\n         fi\n      done\n   else\n      albums_to_download=\"${photo_album}\"\n   fi\n   IFS=\",\"\n   log_debug \"Starting albums download...\"\n   if [ \"${debug_logging}\" = true ]\n   then\n      log_level=\"debug\"\n   else\n      log_level=\"info\"\n   fi\n   for album in ${albums_to_download}\n   do\n      log_info \"Downloading album: ${album}\"\n      if [ \"${albums_with_dates}\" = true ]\n      then\n         log_debug \"iCloudPD launch command: /opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} --folder-structure \\\"${album}/${folder_structure}\\\" --album \\\"${album}\\\" 2>/tmp/icloudpd/icloudpd_download_error\"\n         run_as \"(/opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} --folder-structure \\\"${album}/${folder_structure}\\\" --album \\\"${album}\\\" 2>/tmp/icloudpd/icloudpd_download_error; echo $? >/tmp/icloudpd/icloudpd_download_exit_code) | tee /tmp/icloudpd/icloudpd_sync.log\"\n      else\n         log_debug \"iCloudPD launch command: /opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} --folder-structure \\\"${album}\\\" --album \\\"${album}\\\" 2>/tmp/icloudpd/icloudpd_download_error\"\n         run_as \"(/opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} --folder-structure \\\"${album}\\\" --album \\\"${album}\\\" 2>/tmp/icloudpd/icloudpd_download_error; echo $? >/tmp/icloudpd/icloudpd_download_exit_code) | tee /tmp/icloudpd/icloudpd_sync.log\"\n      fi\n      if [ \"$(cat /tmp/icloudpd/icloudpd_download_exit_code)\" -ne 0 ]\n      then\n         log_error \"Failed downloading album: ${album}\"\n         IFS=\"${save_ifs}\"\n         sleep 10\n         break\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\ndownload_libraries()\n{\n   local all_libraries libraries_to_download log_level\n   if [ \"${photo_library}\" = \"all libraries\" ]\n   then\n      log_debug \"Fetching libraries list...\"\n      all_libraries=\"$(run_as \"/opt/icloudpd/bin/icloudpd --username ${apple_id} --cookie-directory /config --domain ${auth_domain} --directory /dev/null --list-libraries | sed '1d'\")\"\n      log_debug \"Building list of libraries to download...\"\n      IFS=$'\\n'\n      for library in ${all_libraries}\n      do\n         if [ \"${skip_library}\" ]\n         then\n            if [ ! \"${skip_library}\" = \"${library}\" ]\n            then\n               log_debug \" - ${library}\"\n               if [ -z \"${libraries_to_download}\" ]\n               then\n                  libraries_to_download=\"${library}\"\n               else\n                  libraries_to_download=\"${libraries_to_download},${library}\"\n               fi\n            fi\n         else\n            log_debug \" - ${library}\"\n            if [ -z \"${libraries_to_download}\" ]\n            then\n               libraries_to_download=\"${library}\"\n            else\n               libraries_to_download=\"${libraries_to_download},${library}\"\n            fi\n         fi\n      done\n   else\n      libraries_to_download=\"${photo_library}\"\n   fi\n   IFS=\",\"\n   for library in ${libraries_to_download}\n   do\n      log_info \"Downloading library: ${library}\"\n      if [ \"${debug_logging}\" = true ]\n      then\n         log_level=\"debug\"\n      else\n         log_level=\"info\"\n      fi\n      if [ \"${libraries_with_dates}\" = true ]\n      then\n         log_debug \"iCloudPD launch command: /opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} --folder-structure ${library}/${folder_structure} --library ${library} 2>/tmp/icloudpd/icloudpd_download_error\"\n         run_as \"(/opt/icloudpd/bin/icloudpd ${command_line} --log-level \"${log_level}\" --folder-structure \"${library}/${folder_structure}\" --library \"${library}\" 2>/tmp/icloudpd/icloudpd_download_error; echo $? >/tmp/icloudpd/icloudpd_download_exit_code) | tee /tmp/icloudpd/icloudpd_sync.log\"\n      else\n         log_debug \"iCloudPD launch command: /opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} --folder-structure ${library} --library ${library} 2>/tmp/icloudpd/icloudpd_download_error\"\n         run_as \"(/opt/icloudpd/bin/icloudpd ${command_line} --log-level \"${log_level}\" --folder-structure \"${library}\" --library \"${library}\" 2>/tmp/icloudpd/icloudpd_download_error; echo $? >/tmp/icloudpd/icloudpd_download_exit_code) | tee /tmp/icloudpd/icloudpd_sync.log\"\n      fi\n      if [ \"$(cat /tmp/icloudpd/icloudpd_download_exit_code)\" -ne 0 ]\n      then\n         log_error \"Failed downloading library: ${library}\"\n         IFS=\"${save_ifs}\"\n         sleep 10\n         break\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\ndownload_photos()\n{\n   local log_level\n   if [ \"${debug_logging}\" = true ]\n   then\n      log_level=\"debug\"\n   else\n      log_level=\"info\"\n   fi\n   log_debug \"iCloudPD launch command: /opt/icloudpd/bin/icloudpd --log-level ${log_level} ${command_line} 2>/tmp/icloudpd/icloudpd_download_error\"\n   if [ \"${skip_download}\" = false ]\n   then\n      run_as \"(/opt/icloudpd/bin/icloudpd ${command_line} --log-level ${log_level} 2>/tmp/icloudpd/icloudpd_download_error; echo $? >/tmp/icloudpd/icloudpd_download_exit_code) | tee /tmp/icloudpd/icloudpd_sync.log\"\n   else\n      log_debug \"Skip download: ${skip_download} - skipping\"\n      echo 0 >/tmp/icloudpd/icloudpd_download_exit_code\n      touch /tmp/icloudpd/icloudpd_sync.log\n   fi\n}\n\ncheck_nextcloud_connectivity()\n{\n   local nextcloud_check_result counter\n   log_info \"Checking Nextcloud connectivity...\"\n   nextcloud_check_result=\"$(curl --silent --max-time 15 --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --output /dev/null \"${nextcloud_url%/}/remote.php/dav/files/${nextcloud_username}/\")\"\n   if [ \"${nextcloud_check_result}\" -ne 200 ]\n   then\n      log_error \"Nextcloud connectivity check failed: ${nextcloud_check_result}\"\n      fail_time=\"$(date \"+%a %d %B %H:%M:%S (%Z) %Y\")\"\n      send_notification \"Nextcloud\" \"failed\" \"0\" \"Nextcloud connectivity check failed for user: ${user}. Waiting for server to come back online...\"\n      while [ \"${nextcloud_check_result}\" -ne 200 ]\n      do\n         sleep 45\n         counter=$((counter + 1))\n         if [ \"${counter}\" -eq 15 ] || [ \"${counter}\" -eq 60 ] || [ \"${counter}\" -eq 300 ]\n         then\n            send_notification \"Nextcloud\" \"failed\" \"0\" \"Nextcloud has been offline for user ${user} since ${fail_time}. Please take corrective action. icloudpd will remain paused until this issue is rectified\"\n         fi\n         nextcloud_check_result=\"$(curl --silent --location --max-time 15 --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --output /dev/null \"${nextcloud_url%/}/remote.php/dav/files/${nextcloud_username}/\")\"\n      done\n      send_notification \"Nextcloud\" \"success\" \"0\" \"Nextcloud server is back online. Resuming operation\"\n   fi\n}\n\nnextcloud_url_encoder()\n{\n   echo \"$@\" | sed \\\n      -e 's/%/%25/g' \\\n      -e 's/ /%20/g' \\\n      -e 's/!/%21/g' \\\n      -e 's/\"/%22/g' \\\n      -e \"s/'/%27/g\" \\\n      -e 's/#/%23/g' \\\n      -e 's/(/%28/g' \\\n      -e 's/)/%29/g' \\\n      -e 's/+/%2b/g' \\\n      -e 's/,/%2c/g' \\\n      -e 's/:/%3a/g' \\\n      -e 's/;/%3b/g' \\\n      -e 's/?/%3f/g' \\\n      -e 's/@/%40/g' \\\n      -e 's/\\$/%24/g' \\\n      -e 's/\\&/%26/g' \\\n      -e 's/\\*/%2a/g' \\\n      -e 's/\\[/%5b/g' \\\n      -e 's/\\\\/%5c/g' \\\n      -e 's/\\]/%5d/g' \\\n      -e 's/\\^/%5e/g' \\\n      -e 's/`/%60/g' \\\n      -e 's/{/%7b/g' \\\n      -e 's/|/%7c/g' \\\n      -e 's/}/%7d/g' \\\n      -e 's/~/%7e/g'\n}\n\nnextlcoud_create_directories()\n{\n   IFS=$'\\n'\n   local destination_directories encoded_destination_directories curl_response\n   log_info \"Checking Nextcloud destination directories...\"\n   destination_directories=$(grep \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log | cut --delimiter \" \" --fields 9- | sed \"s%${download_path}%%\" | while read -r line\n      do\n         for level in $(seq 1 $(echo \"${line}\" | tr -cd '/' | wc -c))\n         do\n            echo \"${line}\" | cut -d'/' -f1-\"${level}\"\n         done\n      done | sort -u)\n\n   encoded_destination_directories=$(for destination_directory in $destination_directories\n      do\n         echo \"${nextcloud_url%/}/remote.php/dav/files/$(echo $(nextcloud_url_encoder \"${nextcloud_username}/${nextcloud_target_dir%/}${destination_directory}/\"))\"\n      done)\n   IFS=\"${save_ifs}\"\n\n   for nextcloud_destination in ${encoded_destination_directories}; do\n      log_info_n \" - ${nextcloud_destination} \"\n      curl_response=\"$(curl --silent --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --output /dev/null \"${nextcloud_destination}\")\"\n      if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n      then\n         echo \"Exists\"\n      else\n         echo \"Missing\"\n         log_info_n \"Creating Nextcloud directory: ${nextcloud_destination} \"\n         curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --request MKCOL \"${nextcloud_destination}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n         then\n            echo \"Success\"\n         else\n            echo \"Error: ${curl_response}\"\n         fi\n      fi\n   done\n}\n\nnextcloud_sync()\n{\n   local new_files_count deleted_files_count\n\n   new_files_count=\"$(grep -c \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log)\"\n   deleted_files_count=\"$(grep -c \"Deleted /\" /tmp/icloudpd/icloudpd_sync.log)\"\n\n   if [ \"${new_files_count:=0}\" -gt 0 ]\n   then\n      check_nextcloud_connectivity\n      nextlcoud_create_directories\n      nextcloud_upload\n   fi\n\n   if [ \"${deleted_files_count:=0}\" -gt 0 ]\n   then\n      if [ \"${nextcloud_delete}\" = true ]\n      then\n         check_nextcloud_connectivity\n         nextcloud_delete\n         nextlcoud_delete_directories\n      fi\n   fi\n}\n\nnextcloud_upload()\n{\n   IFS=$'\\n'\n   local nextcloud_destination curl_response\n   log_info \"Uploading files to Nextcloud\"\n   for full_filename in $(grep \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log | cut --delimiter \" \" --fields 9-)\n   do\n      nextcloud_destination=\"${nextcloud_url%/}/remote.php/dav/files/$(nextcloud_url_encoder \"${nextcloud_username}/${nextcloud_target_dir%/}$(echo ${full_filename} | sed \"s%${download_path}%%\")\")\"\n      if [ ! -f \"${full_filename}\" ]\n      then\n         log_warning \"Media file ${full_filename} does not exist. It may exist in 'Recently Deleted' so has been removed post download\"\n      else\n         log_info_n \"Uploading ${full_filename} to ${nextcloud_destination}\"\n         curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --upload-file \"${full_filename}\" \"${nextcloud_destination}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n         then\n            echo \"Success\"\n         else\n            echo \"Unexpected response: ${curl_response}\"\n         fi\n         if [ -f \"${full_filename%.HEIC}.JPG\" ]\n         then\n            log_info_n \"Uploading ${full_filename} to ${nextcloud_destination%.HEIC}.JPG\"\n            curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --upload-file \"${full_filename}\" \"${nextcloud_destination%.HEIC}.JPG\")\"\n            if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n            then\n               echo \"Success\"\n            else\n               echo \"Unexpected response: ${curl_response}\"\n            fi\n         fi\n         if [ -f \"${full_filename%.heic}.jpg\" ]\n         then\n            log_info_n \"Uploading ${full_filename} to ${nextcloud_destination%.heic}.jpg\"\n            curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --upload-file \"${full_filename}\" \"${nextcloud_destination%.heic}.jpg\")\"\n            if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n            then\n               echo \"Success\"\n            else\n               echo \"Unexpected response: ${curl_response}\"\n            fi\n         fi\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nnextcloud_delete()\n{\n   IFS=$'\\n'\n   local nextcloud_destination curl_response\n   log_info \"Delete files from Nextcloud...\"\n   for full_filename in $(grep \"Deleted /\" /tmp/icloudpd/icloudpd_sync.log | cut --delimiter \" \" --fields 9-)\n   do\n      nextcloud_destination=\"${nextcloud_url%/}/remote.php/dav/files/$(nextcloud_url_encoder \"${nextcloud_username}/${nextcloud_target_dir%/}$(echo ${full_filename} | sed \"s%${download_path}%%\")\")\"\n      log_debug \"Checking file path: ${nextcloud_destination}\"\n      curl_response=\"$(curl --silent --show-error --location --head --user \"${nextcloud_username}:${nextcloud_password}\" \"${nextcloud_destination}\" --output /dev/null --write-out \"%{http_code}\")\"\n      if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 200 ]\n      then\n         log_info_n \" - File exists, deleting\"\n         if curl --silent --show-error --location --request DELETE --user \"${nextcloud_username}:${nextcloud_password}\" --output /dev/null \"${nextcloud_destination}\"\n         then\n            echo \"Success\"\n         else\n            echo \"Error: $?\"\n         fi\n      elif [ \"${curl_response}\" -eq 404 ]\n      then\n         echo \"File not found: ${nextcloud_destination}\"\n      else\n         echo \"Unexpected response: ${curl_response}\"\n      fi\n      if [ -f \"${full_filename%.HEIC}.JPG\" ]\n      then\n         log_debug \"Checking file path: ${nextcloud_destination%.HEIC}.JPG\"\n         curl_response=\"$(curl --silent --show-error --location --head --user \"${nextcloud_username}:${nextcloud_password}\" \"${nextcloud_destination%.HEIC}.JPG\" --output /dev/null --write-out \"%{http_code}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 200 ]\n         then\n            log_info_n \" - File exists, deleting\"\n            if curl --silent --show-error --location --request DELETE --user \"${nextcloud_username}:${nextcloud_password}\" --output /dev/null \"${nextcloud_destination%.HEIC}.JPG\"\n            then\n               echo \"Success\"\n            else\n               echo \"Error: $?\"\n            fi\n         elif [ \"${curl_response}\" -eq 404 ]\n         then\n            echo \"File not found: ${nextcloud_destination%.HEIC}.JPG\"\n         else\n            echo \"Unexpected response: ${curl_response}\"\n         fi\n      fi\n      if [ -f \"${full_filename%.heic}.jpg\" ]\n      then\n         log_debug \"Checking file path: ${nextcloud_destination%.heic}.jpg\"\n         curl_response=\"$(curl --silent --show-error --location --head --user \"${nextcloud_username}:${nextcloud_password}\" \"${nextcloud_destination%.heic}.jpg\" --output /dev/null --write-out \"%{http_code}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 200 ]\n         then\n            log_info_n \" - File exists, deleting\"\n            if curl --silent --show-error --location --request DELETE --user \"${nextcloud_username}:${nextcloud_password}\" --output /dev/null \"${nextcloud_destination%.heic}.jpg\"\n            then\n               echo \"Success\"\n            else\n               echo \"Error: $?\"\n            fi\n         elif [ \"${curl_response}\" -eq 404 ]\n         then\n            echo \"File not found: ${nextcloud_destination%.heic}.jpg\"\n         else\n            echo \"Unexpected response: ${curl_response}\"\n         fi\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nnextlcoud_delete_directories()\n{\n   IFS=$'\\n'\n   local directories_list nextcloud_target curl_response\n   log_info \"Checking for empty Nextcloud destination directories to remove...\"\n   directories_list=\"$(grep \"Deleted /\" /tmp/icloudpd/icloudpd_sync.log | cut --delimiter \" \" --fields 9- | sed 's~\\(.*/\\).*~\\1~' | sed \"s%${download_path}%%\" | sort --unique --reverse | grep -v \"^$\")\"\n   for target_directory in ${directories_list}\n   do\n      nextcloud_target=\"${nextcloud_url%/}/remote.php/dav/files/$(nextcloud_url_encoder \"${nextcloud_username}/${nextcloud_target_dir%/}${target_directory}\")\"\n      log_debug \"Checking if Nextcloud directory is empty: ${nextcloud_target}\"\n      curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --request PROPFIND \"${nextcloud_target}\" | grep -ow '<d:href>' | wc -l)\"\n      if [ \"${curl_response}\" -ge 2 ]\n      then\n         log_debug \" - Not removing directory as it contains items: $((curl_response -1 ))\"\n      else\n         log_info_n \" - Removing empty Nextcloud directory: ${nextcloud_target}\"\n         curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --output /dev/null --request DELETE \"${nextcloud_target}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n         then\n            echo \"Success\"\n         else\n            echo \"Unexpected response: ${curl_response}\"\n         fi\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nnextcloud_upload_library()\n{\n   log_info \"Uploading entire library to Nextcloud. This may take a while...\"\n   local destination_directories encoded_destination_directories curl_response\n   log_info \"Checking Nextcloud destination directories...\"\n   destination_directories=$(find \"${download_path}\" -type d ! -name '.*' 2>/dev/null | sed \"s%${download_path}%%\" | grep -v \"^$\" | sort --unique)\n\n   IFS=$'\\n'\n   encoded_destination_directories=$(for destination_directory in $destination_directories\n      do\n         echo \"${nextcloud_url%/}/remote.php/dav/files/$(echo $(nextcloud_url_encoder \"${nextcloud_username}/${nextcloud_target_dir%/}${destination_directory}/\"))\"\n      done)\n   IFS=\"${save_ifs}\"\n\n   for nextcloud_destination in ${encoded_destination_directories}; do\n      log_info_n \" - ${nextcloud_destination} \"\n      curl_response=\"$(curl --silent --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --output /dev/null \"${nextcloud_destination}\")\"\n      if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n      then\n         echo \"Exists\"\n      else\n         echo \"Missing\"\n         log_info_n \"Creating Nextcloud directory: ${nextcloud_destination} \"\n         curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --request MKCOL \"${nextcloud_destination}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n         then\n            echo \"Success\"\n         else\n            echo \"Error: ${curl_response}\"\n         fi\n      fi\n   done\n\n   log_info \"Checking Nextcloud destination files...\"\n   IFS=$'\\n'\n   for full_filename in $(find \"${download_path}\" -type f ! -name '.*' 2>/dev/null | sed \"s%${download_path}%%\")\n   do\n      nextcloud_destination=\"${nextcloud_url%/}/remote.php/dav/files/$(nextcloud_url_encoder \"${nextcloud_username}/${nextcloud_target_dir%/}$(echo ${full_filename})\")\"\n\n      log_info_n \"Uploading ${full_filename} to ${nextcloud_destination}\"\n      if curl --silent --output /dev/null --fail --head --user \"${nextcloud_username}:${nextcloud_password}\" \"${nextcloud_destination}\"\n      then\n         echo \"File already exsits\"\n      else\n         curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --upload-file \"${full_filename}\" \"${nextcloud_destination}\")\"\n         if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n         then\n            echo \"Success\"\n         else\n            echo \"Unexpected response: ${curl_response}\"\n         fi\n      fi\n      if [ -f \"${full_filename%.HEIC}.JPG\" ]\n      then\n         log_info_n \"Uploading ${full_filename%.HEIC}.JPG to ${nextcloud_destination%.HEIC}.JPG\"\n         if curl --silent --output /dev/null --fail --head --user \"${nextcloud_username}:${nextcloud_password}\" \"${nextcloud_destination%.HEIC}.JPG\"\n         then\n            log_info_n \"File already exsits\"\n         else\n            curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --upload-file \"${nextcloud_destination%.HEIC}.JPG\")\"\n            if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n            then\n               echo \"Success\"\n            else\n               echo \"Unexpected response: ${curl_response}\"\n            fi\n         fi\n      fi\n      if [ -f \"${full_filename%.heic}.jpg\" ]\n      then\n         log_info_n \"Uploading ${full_filename%.heic}.jpg to ${nextcloud_destination%.heic}.jpg\"\n         if curl --silent --output /dev/null --fail --head --user \"${nextcloud_username}:${nextcloud_password}\" \"${nextcloud_destination%.heic}.jpg\"\n         then\n            log_info_n \"File already exsits\"\n         else\n            curl_response=\"$(curl --silent --show-error --location --user \"${nextcloud_username}:${nextcloud_password}\" --write-out \"%{http_code}\" --upload-file \"${nextcloud_destination%.heic}.jpg\")\"\n            if [ \"${curl_response}\" -ge 200 ] && [ \"${curl_response}\" -le 299 ]\n            then\n               echo \"Success\"\n            else\n               echo \"Unexpected response: ${curl_response}\"\n            fi\n         fi\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nconvert_downloaded_heic_to_jpeg()\n{\n   IFS=$'\\n'\n   log_info \"Convert HEIC to JPEG...\"\n   for heic_file in $(grep \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log | grep \".HEIC\" | cut --delimiter \" \" --fields 9-)\n   do\n      if [ ! -f \"${heic_file}\" ]\n      then\n         log_warning \"HEIC file ${heic_file} does not exist. It may exist in 'Recently Deleted' so has been removed post download\"\n      else\n         jpeg_file=\"${heic_file%.HEIC}.JPG\"\n         if [ \"${jpeg_path}\" ]\n         then\n            if [ ! -d \"${jpeg_path}\" ]\n            then\n               mkdir --parents \"${jpeg_path}\"\n               chown \"${user}:${group}\" \"${jpeg_path}\"\n            fi\n            jpeg_file=\"${jpeg_file/${download_path}/${jpeg_path}}\"\n            jpeg_directory=\"$(dirname \"${jpeg_file/${download_path}/${jpeg_path}}\")\"\n            if [ ! -d \"${jpeg_directory}\" ]\n            then\n               mkdir --parents \"${jpeg_directory}\"\n               chown \"${user}:${group}\" \"${jpeg_directory}\"\n            fi\n         fi\n         log_info \"Converting ${heic_file} to ${jpeg_file}\"\n         magick -quality \"${jpeg_quality}\" \"${heic_file}\" \"${jpeg_file}\"\n         heic_date=\"$(date -r \"${heic_file}\" +\"%a %b %e %T %Y\")\"\n         log_debug \"Timestamp of HEIC file: ${heic_date}\"\n         touch --reference=\"${heic_file}\" \"${jpeg_file}\"\n         log_debug \"Setting timestamp of ${jpeg_file} to ${heic_date}\"\n         log_debug \"Correct owner and group of ${jpeg_file} to ${user}:${group}\"\n         chown \"${user}:${group}\" \"${jpeg_file}\"\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nsynology_photos_app_fix()\n{\n   # Works for onestix. Do not obsolete\n   IFS=$'\\n'\n   log_info \"Fixing Synology Photos App import issue...\"\n   for heic_file in $(grep \"Downloaded /\" /tmp/icloudpd/icloudpd_sync.log | grep \".HEIC\" | cut --delimiter \" \" --fields 9-)\n   do\n      log_debug \"Create empty date/time reference file ${heic_file%.HEIC}.TMP\"\n      run_as \"touch --reference=\\\"${heic_file}\\\" \\\"${heic_file%.HEIC}.TMP\\\"\"\n      log_debug \"Set time stamp for ${heic_file} to current: $(date)\"\n      run_as \"touch \\\"${heic_file}\\\"\" \n      log_debug \"Set time stamp for ${heic_file} to original: $(date -r \"${heic_file%.HEIC}.TMP\" +\"%a %b %e %T %Y\")\"\n      run_as \"touch --reference=\\\"${heic_file%.HEIC}.TMP\\\" \\\"${heic_file}\\\"\"\n      log_debug \"Removing temporary file ${heic_file%.HEIC}.TMP\"\n      if [ -z \"${persist_temp_files}\" ]\n      then\n         rm \"${heic_file%.HEIC}.TMP\"\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nconvert_all_heic_files()\n{\n   IFS=$'\\n'\n   log_info \"Convert all HEICs to JPEG, if required...\"\n   for heic_file in $(find \"${download_path}\" -type f -iname *.HEIC 2>/dev/null); do\n      log_debug \"HEIC file found: ${heic_file}\"\n      jpeg_file=\"${heic_file%.HEIC}.JPG\"\n      if [ \"${jpeg_path}\" ]\n      then\n         if [ ! -d \"${jpeg_path}\" ]\n         then\n            mkdir --parents \"${jpeg_path}\"\n            chown \"${user}:${group}\" \"${jpeg_path}\"\n         fi\n         jpeg_file=\"${jpeg_file/${download_path}/${jpeg_path}}\"\n         jpeg_directory=\"$(dirname \"${jpeg_file/${download_path}/${jpeg_path}}\")\"\n         if [ ! -d \"${jpeg_directory}\" ]\n         then\n            mkdir --parents \"${jpeg_directory}\"\n            chown \"${user}:${group}\" \"${jpeg_directory}\"\n         fi\n      fi\n      if [ ! -f \"${jpeg_file}\" ]\n      then\n         log_info \"Converting ${heic_file} to ${jpeg_file}\"\n         magick -quality \"${jpeg_quality}\" \"${heic_file}\" \"${jpeg_file}\"\n         heic_date=\"$(date -r \"${heic_file}\" +\"%a %b %e %T %Y\")\"\n         log_debug \"Timestamp of HEIC file: ${heic_date}\"\n         touch --reference=\"${heic_file}\" \"${jpeg_file}\"\n         log_debug \"Setting timestamp of ${jpeg_file} to ${heic_date}\"\n         log_debug \"Correct owner and group of ${jpeg_file} to ${user}:${group}\"\n         chown \"${user}:${group}\" \"${jpeg_file}\"\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nremove_all_jpeg_files()\n{\n   IFS=$'\\n'\n   log_warning \"Remove all JPGs that have accompanying HEIC files. This could result in data loss if HEIC file name matches the JPG file name, but content does not\"\n   log_info \"Waiting for 2mins before progressing. Please stop the container now, if this is not what you want to do...\"\n   sleep 120\n   for heic_file in $(find \"${download_path}\" -type f -iname *.HEIC 2>/dev/null)\n   do\n      jpeg_file=\"${heic_file%.HEIC}.JPG\"\n      if [ \"${jpeg_path}\" ]\n      then\n         jpeg_file=\"${jpeg_file/${download_path}/${jpeg_path}}\"\n      fi\n      log_info \"Removing ${jpeg_file}\"\n      if [ -f \"${jpeg_file}\" ]\n      then\n         rm \"${jpeg_file}\"\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nforce_convert_all_heic_files()\n{\n   IFS=$'\\n'\n   log_warning \"Force convert all HEICs to JPEG. This could result in data loss if JPG files have been edited on disk\"\n   log_info \"Waiting for 2mins before progressing. Please stop the container now, if this is not what you want to do...\"\n   sleep 120\n   for heic_file in $(find \"${download_path}\" -type f -iname *.HEIC 2>/dev/null); do\n      jpeg_file=\"${heic_file%.HEIC}.JPG\"\n      if [ \"${jpeg_path}\" ]\n      then\n         if [ ! -d \"${jpeg_path}\" ]\n         then\n            mkdir --parents \"${jpeg_path}\"\n            chown \"${user}:${group}\" \"${jpeg_path}\"\n         fi\n         jpeg_file=\"${jpeg_file/${download_path}/${jpeg_path}}\"\n         jpeg_directory=\"$(dirname \"${jpeg_file/${download_path}/${jpeg_path}}\")\"\n         if [ ! -d \"${jpeg_directory}\" ]\n         then\n            mkdir --parents \"${jpeg_directory}\"\n            chown \"${user}:${group}\" \"${jpeg_directory}\"\n         fi\n      fi\n      log_info \"Converting ${heic_file} to ${jpeg_file}\"\n      if [ -f \"${jpeg_file}\" ]\n      then\n         rm \"${jpeg_file}\"\n      fi\n      magick -quality \"${jpeg_quality}\" \"${heic_file}\" \"${jpeg_file}\"\n      heic_date=\"$(date -r \"${heic_file}\" +\"%a %b %e %T %Y\")\"\n      log_debug \"Timestamp of HEIC file: ${heic_date}\"\n      touch --reference=\"${heic_file}\" \"${jpeg_file}\"\n      log_debug \"Setting timestamp of ${jpeg_file} to ${heic_date}\"\n      log_debug \"Correct owner and group of ${jpeg_file} to ${user}:${group}\"\n      chown \"${user_id}:${group_id}\" \"${jpeg_file}\"\n   done\n   IFS=\"${save_ifs}\"\n}\n\nforce_convert_all_mnt_heic_files()\n{\n   IFS=$'\\n'\n   log_warning \"Force convert all HEICs in /mnt directory to JPEG. This could result in data loss if JPG files have been edited on disk\"\n   log_info \"Waiting for 2mins before progressing. Please stop the container now, if this is not what you want to do...\"\n   sleep 120\n   for heic_file in $(find \"/mnt\" -type f -iname *.HEIC 2>/dev/null)\n   do\n      jpeg_file=\"${heic_file%.HEIC}.JPG\"\n      if [ \"${jpeg_path}\" ]\n      then\n         jpeg_file=\"${jpeg_file/${download_path}/${jpeg_path}}\"\n      fi\n      log_info \"Converting ${heic_file} to ${jpeg_file}\"\n      rm \"${jpeg_file}\"\n      magick -quality \"${jpeg_quality}\" \"${heic_file}\" \"${jpeg_file}\"\n      heic_date=\"$(date -r \"${heic_file}\" +\"%a %b %e %T %Y\")\"\n      log_debug \"Timestamp of HEIC file: ${heic_date}\"\n      touch --reference=\"${heic_file}\" \"${jpeg_file}\"\n      log_debug \"Setting timestamp of ${jpeg_file} to ${heic_date}\"\n      log_debug \"Correct owner and group of ${jpeg_file} to ${user}:${group}\"\n      chown \"${user}:${group}\" \"${jpeg_file}\"\n   done\n   IFS=\"${save_ifs}\"\n}\n\ncorrect_jpeg_timestamps()\n{\n   IFS=$'\\n'\n   log_info \"Check and correct converted HEIC timestamps...\"\n   for heic_file in $(find \"${download_path}\" -type f -iname *.HEIC 2>/dev/null)\n   do\n      jpeg_file=\"${heic_file%.HEIC}.JPG\"\n      if [ \"${jpeg_path}\" ]\n      then\n         jpeg_file=\"${jpeg_file/${download_path}/${jpeg_path}}\"\n      fi\n      heic_date=\"$(date -r \"${heic_file}\" +\"%a %b %e %T %Y\")\"\n      log_debug \"Timestamp of HEIC file: ${heic_date}\"\n      if [ -f \"${jpeg_file}\" ]\n      then\n         log_debug \"JPEG file found: ${jpeg_file}\"\n         jpeg_date=\"$(date -r \"${jpeg_file}\" +\"%a %b %e %T %Y\")\"\n         log_debug \"Timestamp of JPEG file: ${jpeg_date}\"\n         if [ \"${heic_date}\" != \"${jpeg_date}\" ]\n         then\n            log_info \"Setting timestamp of ${jpeg_file} to ${heic_date}\"\n            touch --reference=\"${heic_file}\" \"${jpeg_file}\"\n         else\n            log_debug \"Time stamps match. Adjustment not required\"\n         fi\n      fi\n   done\n   IFS=\"${save_ifs}\"\n}\n\nremove_recently_deleted_accompanying_files()\n{\n   IFS=$'\\n'\n   log_info \"Deleting 'Recently Deleted' accompanying files (.JPG/_HEVC.MOV)...\"\n   for heic_file in $(grep \"Deleted /\" /tmp/icloudpd/icloudpd_sync.log | grep \".HEIC\" | cut --delimiter \" \" --fields 9-)\n   do\n      heic_file_clean=\"${heic_file/!/}\"\n      jpeg_file_clean=\"${heic_file_clean%.HEIC}.JPG\"\n      if [ \"${jpeg_path}\" ]\n      then\n         jpeg_file_clean=\"${jpeg_file_clean/${download_path}/${jpeg_path}}\"\n      fi\n      if [ -f \"${jpeg_file_clean}\" ]\n      then\n         log_debug \"Deleting ${jpeg_file_clean}\"\n         rm -f \"${jpeg_file_clean}\"\n      fi\n      if [ -f \"${heic_file_clean%.HEIC}_HEVC.MOV\" ]\n      then\n         log_debug \"Deleting ${heic_file_clean%.HEIC}_HEVC.MOV\"\n         rm -f \"${heic_file_clean%.HEIC}_HEVC.MOV\"\n      fi\n   done\n   log_info \"Deleting 'Recently Deleted' accompanying files complete\"\n   IFS=\"${save_ifs}\"\n}\n\nremove_empty_directories()\n{\n   log_info \"Deleting empty directories from ${download_path}...\"\n   find \"${download_path}\" -type d -empty -delete\n   log_info \"Deleting empty directories complete\"\n   if [ \"${jpeg_path}\" ]\n   then\n      log_debug \"Deleting empty directories from ${jpeg_path}...\"\n      find \"${jpeg_path}\" -type d -empty -delete\n      log_info \"Deleting empty directories complete\"\n   fi\n}\n\nsend_notification()\n{\n   local notification_classification notification_event notification_prority notification_message notification_result notification_files_preview_count notification_files_preview_type notification_files_preview_text\n   notification_classification=\"${1}\"\n   notification_event=\"${2}\"\n   notification_prority=\"${3}\"\n   notification_message=\"${4}\"\n   notification_files_preview_count=\"${5}\"\n   notification_files_preview_type=\"${6}\"\n   notification_files_preview_text=\"${7}\"\n   notification_wecom_title=\"${8}\"\n   notification_wecom_digest=\"${9}\"\n\n   if [ \"${notification_classification}\" = \"startup\" ]\n   then\n      notification_icon=\"\\xE2\\x96\\xB6\"\n      # 启动成功通知封面/Image for Startup success\n      thumb_media_id=\"$media_id_startup\"\n   elif [ \"${notification_classification}\" = \"remotesync\" ]\n   then\n      notification_icon=\"\\xE2\\x96\\xB6\"\n      # 启动成功通知封面/Image for Startup success\n      thumb_media_id=\"$media_id_startup\"\n   elif [ \"${notification_classification}\" = \"downloaded files\" ]\n   then\n      notification_icon=\"\\xE2\\x8F\\xAC\"\n      # 下载通知封面/Image for downloaded files\n      thumb_media_id=\"$media_id_download\"\n   elif [ \"${notification_classification}\" = \"cookie expiration\" ]\n   then\n      notification_icon=\"\\xF0\\x9F\\x9A\\xA9\"\n      # cookie即将过期通知封面/Image for cookie expiration\n      thumb_media_id=\"$media_id_expiration\"\n   elif [ \"${notification_classification}\" = \"deleted files\" ]\n   then\n      notification_icon=\"\\xE2\\x9D\\x8C\"\n      # 删除文件通知封面/Image for deleted files\n      thumb_media_id=\"$media_id_delete\"\n   elif [ \"${notification_classification}\" = \"failure\" ] || [ \"${notification_classification}\" = \"cookie expired\" ]\n   then\n      notification_icon=\"\\xF0\\x9F\\x9A\\xA8\"\n      # 同步失败、cookiey已过期通知封面/Image for cookie expired or failure\n      thumb_media_id=\"$media_id_warning\"\n   fi\n   if [ \"${notification_type}\" ]\n   then\n      log_info \"Sending ${notification_type} ${notification_classification} notification\"\n   fi\n   if [ \"${notification_type}\" = \"Prowl\" ]\n   then\n      notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" \"${notification_url}\"  \\\n         --form apikey=\"${prowl_api_key}\" \\\n         --form application=\"${notification_title}\" \\\n         --form event=\"${notification_event}\" \\\n         --form priority=\"${notification_prority}\" \\\n         --form description=\"${notification_message}\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"Pushover\" ]\n   then\n      if [ \"${notification_prority}\" = \"2\" ]\n      then\n         notification_prority=1\n      fi\n      if [ \"${notification_files_preview_count}\" ]\n      then\n         pushover_text=\"$(echo -e \"${notification_icon} ${notification_event}\\n${notification_message}\\nMost recent ${notification_files_preview_count} ${notification_files_preview_type} files:\\n${notification_files_preview_text}\")\"\n      else\n         pushover_text=\"$(echo -e \"${notification_icon} ${notification_event}\\n${notification_message}\")\"\n      fi\n      notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" \"${notification_url}\"  \\\n         --form-string \"user=${pushover_user}\" \\\n         --form-string \"token=${pushover_token}\" \\\n         --form-string \"title=${notification_title}\" \\\n         --form-string \"sound=${pushover_sound}\" \\\n         --form-string \"priority=${notification_prority}\" \\\n         --form-string \"message=${pushover_text}\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"Telegram\" ]\n   then\n      if [ \"${notification_files_preview_count}\" ]\n      then\n         telegram_text=\"$(echo -e \"${notification_icon} *${notification_title}*\\n${notification_message//_/\\\\_}\\nMost recent ${notification_files_preview_count} ${notification_files_preview_type} files:\\n${notification_files_preview_text//_/\\\\_}\")\"\n      else\n         telegram_text=\"$(echo -e \"${notification_icon} *${notification_title}*\\n${notification_message//_/\\\\_}\")\"\n      fi\n      notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" --request POST \"${notification_url}\" \\\n         --data chat_id=\"${telegram_chat_id}\" \\\n         --data parse_mode=\"markdown\" \\\n         --data disable_notification=\"${telegram_disable_notification:=false}\" \\\n         --data text=\"${telegram_text}\")\"\n      curl_exit_code=\"$?\"\n      unset telegram_disable_notification\n   elif [ \"${notification_type}\" = \"openhab\" ]\n   then\n      webhook_payload=\"$(echo -e \"${notification_title} - ${notification_message}\")\"\n      notification_result=\"$(curl -X 'PUT' --silent --output /dev/null --write-out \"%{http_code}\" \"${notification_url}\" \\\n         --header 'content-type: text/plain' \\\n         --data \"${webhook_payload}\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"Webhook\" ]\n   then\n      webhook_payload=\"$(echo -e \"${notification_title} - ${notification_message}\")\"\n      if [ \"${webhook_insecure}\" = true ]\n      then\n         notification_result=\"$(curl --silent --insecure --output /dev/null --write-out \"%{http_code}\" \"${notification_url}\" \\\n            --header 'content-type: application/json' \\\n            --data \"{ \\\"${webhook_body}\\\" : \\\"${webhook_payload}\\\" }\")\"\n      else\n         notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" \"${notification_url}\" \\\n            --header 'content-type: application/json' \\\n            --data \"{ \\\"${webhook_body}\\\" : \\\"${webhook_payload}\\\" }\")\"\n      fi\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"Discord\" ]\n   then\n      if [ \"${notification_files_preview_count}\" ]\n      then\n         discord_text=\"${notification_message}\\\\nMost recent ${notification_files_preview_count} ${notification_files_preview_type} files:\\\\n${notification_files_preview_text//$'\\n'/'\\n'}\"\n      else\n         discord_text=\"$(echo -e \"${notification_message}\")\"\n      fi\n      notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" --request POST \"${notification_url}\" \\\n         --header 'content-type: application/json' \\\n         --data \"{ \\\"username\\\" : \\\"${notification_title}\\\" , \\\"avatar_url\\\" : \\\"https://raw.githubusercontent.com/Womabre/-unraid-docker-templates/master/images/photos_icon_large.png\\\" , \\\"embeds\\\" : [ { \\\"author\\\" : { \\\"name\\\" : \\\"${notification_event}\\\" } , \\\"color\\\" : 2061822 , \\\"description\\\": \\\"${discord_text}\\\" } ] }\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"Dingtalk\" ]\n   then\n      notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" --request POST \"${notification_url}\" \\\n         --header 'Content-Type: application/json' \\\n         --data \"{'msgtype': 'markdown','markdown': {'title':'${notification_title}','text':'## ${notification_title}\\n${notification_message}'}}\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"IYUU\" ]\n   then\n      if [ \"${notification_files_preview_count}\" ]\n      then\n         iyuu_text=\"$(echo -e \"${notification_icon} *${notification_title}*\\n${notification_message}\\nMost recent ${notification_files_preview_count} ${notification_files_preview_type} files:\\n${notification_files_preview_text//_/\\\\_}\")\"\n      else\n         iyuu_text=\"$(echo -e \"${notification_icon} *${notification_title}*\\n${notification_message}\")\"\n      fi\n      if [ \"${fake_user_agent}\" = true ]\n      then\n         notification_result=\"$(curl --silent --user-agent \"${curl_user_agent}\" --output /dev/null --write-out \"%{http_code}\" --request POST \"${notification_url}\" \\\n            --data text=\"${notification_title}\" \\\n            --data desp=\"${iyuu_text}\")\"\n      else\n         notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" --request POST \"${notification_url}\" \\\n            --data text=\"${notification_title}\" \\\n            --data desp=\"${iyuu_text}\")\"\n      fi\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"WeCom\" ]\n   then\n      if [ \"$(date +'%s')\" -ge \"$(date +'%s' -d \"${wecom_token_expiry}\")\" ]\n      then\n         log_warning \"${notification_type} token has expired\"\n         unset wecom_token\n      fi\n      if [ -z \"${wecom_token}\" ]\n      then\n         log_warning \"Obtaining new ${notification_type} token...\"\n         if [ \"${fake_user_agent}\" = true ]\n         then\n            wecom_token=\"$(/usr/bin/curl --silent --user-agent \"${curl_user_agent}\" --get \"${wecom_token_url}\" | awk -F\\\" '{print $10}')\"\n         else\n            wecom_token=\"$(/usr/bin/curl --silent --get \"${wecom_token_url}\" | awk -F\\\" '{print $10}')\"\n         fi\n         wecom_token_expiry=\"$(date --date='2 hour')\"\n         notification_url=\"${wecom_base_url}/cgi-bin/message/send?access_token=${wecom_token}\"\n         log_info \"${notification_type} token: ${wecom_token}\"\n         log_info \"${notification_type} token expiry time: $(date -d \"${wecom_token_expiry}\")\"\n         log_info \"${notification_type} notification URL: ${notification_url}\"\n      fi\n      # 结束时间、下次同步时间\n      syn_end_time=\"$(date '+%H:%M:%S')\"\n      syn_next_time=\"$(date +%H:%M:%S -d \"${synchronisation_interval} seconds\")\"\n      if [ \"${notification_files_preview_count}\" ]\n      then\n         log_info \"Attempting creating preview count message body\"\n         if [ \"${icloud_china}\" = false ]\n         then\n            wecom_text=\"$(echo -e \"${notification_icon} *${notification_title}*\\n${notification_message}\\nMost recent ${notification_files_preview_count} ${notification_files_preview_type} files:\\n${notification_files_preview_text//_/\\\\_}\")\"\n         else\n            notification_files_preview_text=\"${notification_files_preview_text//$'\\n'/'<br/>'}\"\n            wecom_text=\"$(echo -e \"<font style=\"line-height:1.5\"><center><b><big><big>同步日志</big></big></b></font></center><center><b>${notification_message}</b></center><center>···················  <small>最近 ${notification_files_preview_count} 条${notification_files_preview_type}记录如下</small>  ····················</center><code><small>${notification_files_preview_text}</small></code><center>···················  <small>下次同步时间为 ${syn_next_time}</small>  ··················</center>\")\"\n         fi\n      else\n         log_info \"Attempting creating message body\"\n         if [ \"${icloud_china}\" = false ]\n         then\n            wecom_text=\"$(echo -e \"${notification_icon} *${notification_title}*\\n${notification_message}\")\"\n         else\n            wecom_text=\"$(echo -e \"${notification_message}\")\"\n         fi\n      fi\n      log_info \"Attempting send...\"\n      if [ \"${fake_user_agent}\" = true ]\n      then\n         notification_result=\"$(curl --silent --user-agent \"${curl_user_agent}\" --output /dev/null --write-out \"%{http_code}\" --data-ascii \"{\\\"touser\\\":\\\"${touser}\\\",\\\"msgtype\\\":\\\"mpnews\\\",\\\"agentid\\\":\\\"${agentid}\\\",\\\"mpnews\\\":{\\\"articles\\\":[{\\\"title\\\":\\\"${notification_wecom_title}\\\",\\\"thumb_media_id\\\":\\\"${thumb_media_id}\\\",\\\"author\\\":\\\"${syn_end_time}\\\",\\\"content_source_url\\\":\\\"${content_source_url}\\\",\\\"content\\\":\\\"${wecom_text}\\\",\\\"digest\\\":\\\"${notification_wecom_digest}\\\"}]},\\\"safe\\\":\\\"0\\\",\\\"enable_id_trans\\\":\\\"0\\\",\\\"enable_duplicate_check\\\":\\\"0\\\",\\\"duplicate_check_interval\\\":\\\"1800\\\"}\" --url \"${notification_url}\")\"\n      else\n         notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" --data-ascii \"{\\\"touser\\\":\\\"${touser}\\\",\\\"msgtype\\\":\\\"mpnews\\\",\\\"agentid\\\":\\\"${agentid}\\\",\\\"mpnews\\\":{\\\"articles\\\":[{\\\"title\\\":\\\"${notification_wecom_title}\\\",\\\"thumb_media_id\\\":\\\"${thumb_media_id}\\\",\\\"author\\\":\\\"${syn_end_time}\\\",\\\"content_source_url\\\":\\\"${content_source_url}\\\",\\\"content\\\":\\\"${wecom_text}\\\",\\\"digest\\\":\\\"${notification_wecom_digest}\\\"}]},\\\"safe\\\":\\\"0\\\",\\\"enable_id_trans\\\":\\\"0\\\",\\\"enable_duplicate_check\\\":\\\"0\\\",\\\"duplicate_check_interval\\\":\\\"1800\\\"}\" --url \"${notification_url}\")\"\n      fi\n      curl_exit_code=\"$?\"\n      log_info \"Send result: ${notification_result}\"\n   elif [ \"${notification_type}\" = \"Gotify\" ]\n   then\n      notification_result=\"$(curl --silent --output /dev/null --write-out \"%{http_code}\" \"${notification_url}\"  \\\n         -F \"title=${notification_title}\" \\\n         -F \"message=${notification_message}\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"Bark\" ]\n   then\n      if [ \"${notification_files_preview_count}\" ]\n      then\n\t      notification_files_preview_text=\"$(echo \"${notification_files_preview_text}\" | tr '\\n' ',')\"\n         bark_text=\"$(echo -e \"${notification_icon} ${notification_message} Most recent ${notification_files_preview_count} ${notification_files_preview_type} files: ${notification_files_preview_text}\")\"\n      else\n         bark_text=\"$(echo -e \"${notification_icon} ${notification_message}\")\"\n      fi\n      notification_result=\"$(curl --location --silent --output /dev/null --write-out \"%{http_code}\" \"http://${bark_server}/push\" \\\n         -H 'Content-Type: application/json; charset=utf-8' \\\n         -d \"{ \\\"device_key\\\": \\\"${bark_device_key}\\\", \\\"title\\\": \\\"${notification_title}\\\", \\\"body\\\": \\\"${bark_text}\\\", \\\"category\\\": \\\"category\\\" }\")\"\n      curl_exit_code=\"$?\"\n   elif [ \"${notification_type}\" = \"msmtp\" ]\n   then\n      if [ \"${notification_files_preview_count}\" ]\n      then\n\t      notification_files_preview_text=\"$(echo \"${notification_files_preview_text}\" | tr '\\n' ',')\"\n         mail_text=\"$(echo -e \"${notification_icon} ${notification_message} Most recent ${notification_files_preview_count} ${notification_files_preview_type} files: ${notification_files_preview_text}\")\"\n      else\n         mail_text=\"$(echo -e \"${notification_icon} ${notification_message}\")\"\n      fi\n      printf \"Subject: $notification_message\\n\\n$mail_text\" | msmtp --host=$msmtp_host --port=$msmtp_port --user=$msmtp_user --passwordeval=\"echo -n $msmtp_pass\" --from=$msmtp_from --auth=on --tls=$msmtp_tls \"$msmtp_args\" -- \"$msmtp_to\"\n   fi\n   if [ \"${notification_type}\" ] && [ \"${notification_type}\" != \"msmtp\" ]\n   then\n      if [ \"${notification_result:0:1}\" -eq 2 ]\n      then\n         log_debug \"${notification_type} ${notification_classification} notification sent successfully\"\n      else\n         log_error \"${notification_type} ${notification_classification} notification failed with http status code: ${notification_result} and curl exit code: ${curl_exit_code}\"\n         if [ \"${notification_result}\" = \"000\" ] && [ \"${curl_exit_code}\" = \"6\" ]\n         then\n            log_error \" - HTTP status code '000' and curl exit code '6' means it cannot connect to the server. Please check your network settings\"\n         else\n            if [ \"${debug_logging}\" != true ]\n            then\n               log_error \"Please set debug_logging=true in your icloudpd.conf file then reproduce the error\"\n               log_error \"***** Once you have captured this log file, please post it along with a description of your problem, here: https://github.com/boredazfcuk/docker-icloudpd/issues *****\"\n            else\n               log_error \"***** Please post the above debug log, along with a description of your problem, here: https://github.com/boredazfcuk/docker-icloudpd/issues *****\"\n            fi\n         fi\n         sleep 120\n         exit 1\n      fi\n   fi\n}\n\ncommand_line_builder()\n{\n   local size\n   command_line=\"--directory ${download_path} --cookie-directory /config --domain ${auth_domain} --username ${apple_id} --no-progress-bar\"\n   if [ \"${photo_size}\" = \"original\" ] || [ \"${photo_size}\" = \"medium\" ] || [ \"${photo_size}\" = \"thumb\" ] || [ \"${photo_size}\" = \"adjusted\" ] || [ \"${photo_size}\" = \"alternative\" ]\n   then\n      command_line=\"${command_line} --size ${photo_size}\"\n   else\n      if [ \"${photo_size}\" ]\n      then\n         SAVE_IFS=\"$IFS\"\n         IFS=\",\"\n         for size in ${photo_size}\n         do\n            if [ \"${size}\" = \"original\" ] || [ \"${size}\" = \"medium\" ] || [ \"${size}\" = \"thumb\" ] || [ \"${size}\" = \"adjusted\" ] || [ \"${size}\" = \"alternative\" ]\n            then\n               log_debug \"Adding photo size ${size} to size types\"\n               command_line=\"${command_line} --size ${size}\"\n            else\n               log_warning \"Photo size ${size} not recognised, disregarding\"\n            fi\n         done\n         IFS=\"$SAVE_IFS\"\n      else\n         log_warning \"Photo size is not specified, original will be downloaded by default\"\n      fi\n   fi\n   if [ \"${set_exif_datetime}\" != false ]\n   then\n      command_line=\"${command_line} --set-exif-datetime\"\n   fi\n   if [ \"${keep_unicode}\" != false ]\n   then\n      command_line=\"${command_line} --keep-unicode-in-filenames ${keep_unicode}\"\n   fi\n   if [ \"${live_photo_mov_filename_policy}\" != \"suffix\" ]\n   then\n      command_line=\"${command_line} --live-photo-mov-filename-policy ${live_photo_mov_filename_policy}\"\n   fi\n   if [ \"${align_raw}\" != \"as-is\" ]\n   then\n      command_line=\"${command_line} --align-raw ${align_raw}\"\n   fi\n   if [ \"${file_match_policy}\" != \"name-size-dedup-with-suffix\" ]\n   then\n      command_line=\"${command_line} --file-match-policy ${file_match_policy}\"\n   fi\n   if [ \"${auto_delete}\" != false ]\n   then\n      command_line=\"${command_line} --auto-delete\"\n   elif [ \"${delete_after_download}\" != false ]\n   then\n      command_line=\"${command_line} --delete-after-download\"\n   fi\n   if [ \"${keep_recent_days}\" != 0 ]\n   then\n      command_line=\"${command_line} --keep-recent-days ${keep_recent_days}\"\n   fi\n   if [ \"${skip_live_photos}\" = false ]\n   then\n      if [ \"${live_photo_size}\" != \"original\" ]\n      then\n         command_line=\"${command_line} --live-photo-size ${live_photo_size}\"\n      fi\n   else\n      command_line=\"${command_line} --skip-live-photos\"\n   fi\n   if [ \"${skip_videos}\" != false ]\n   then\n      command_line=\"${command_line} --skip-videos\"\n   fi\n   if [ -z \"${photo_album}\" ] && [ -z \"${photo_library}\" ]\n   then\n      command_line=\"${command_line} --folder-structure ${folder_structure}\"\n   fi\n   if [ \"${until_found}\" ]\n   then\n      command_line=\"${command_line} --until-found ${until_found}\"\n   fi\n   if [ \"${recent_only}\" ]\n   then\n      command_line=\"${command_line} --recent ${recent_only}\"\n   fi\n}\n\nsynchronise_user()\n{\n   log_info \"Sync user: ${user}\"\n   if [ \"${synchronisation_delay}\" -ne 0 ]\n   then\n      log_info \"Delay for ${synchronisation_delay} minutes\"\n      sleep \"${synchronisation_delay}m\"\n   fi\n   while true\n   do\n      synchronisation_start_time=\"$(date +'%s')\"\n      log_info \"Synchronisation starting at $(date +%H:%M:%S -d \"@${synchronisation_start_time}\")\"\n      source <(grep debug_logging \"${config_file}\")\n      chown -R \"${user_id}:${group_id}\" \"/config\"\n      check_keyring_exists\n      if [ \"${authentication_type}\" = \"MFA\" ]\n      then\n         log_debug \"Check MFA Cookie\"\n         valid_mfa_cookie=false\n         while [ \"${valid_mfa_cookie}\" = false ]\n         do\n            check_multifactor_authentication_cookie\n         done\n      fi\n      check_mount\n      if [ \"${skip_check}\" = false ]\n      then\n         check_files\n      else\n         check_exit_code=0\n         check_files_count=1\n      fi\n      if [ \"${check_exit_code}\" -eq 0 ]\n      then\n         if [ \"${check_files_count}\" -gt 0 ]\n         then\n            log_debug \"Starting download of new files for user: ${user}\"\n            synchronisation_time=\"$(date +%s -d '+15 minutes')\"\n            log_debug \"Downloading new files using password stored in keyring file...\"\n            >/tmp/icloudpd/icloudpd_download_error\n            IFS=$'\\n'\n            if [ \"${photo_album}\" ]\n            then\n               log_debug \"Starting Photo Album download\"\n               download_albums\n            elif [ \"${photo_library}\" ]\n            then\n               log_debug \"Starting Photo Library download\"\n               download_libraries\n            else\n               log_debug \"Starting Photo download\"\n               download_photos\n            fi\n            download_exit_code=\"$(cat /tmp/icloudpd/icloudpd_download_exit_code)\"\n            if [ \"${download_exit_code}\" -gt 0 ] || [ -s /tmp/icloudpd/icloudpd_download_error ]\n            then\n               log_error \"Failed to download new files\"\n               log_error \" - Can you log into ${icloud_domain} without receiving pop-up notifications?\"\n               log_error \"Error debugging info:\"\n               log_error \"$(cat /tmp/icloudpd/icloudpd_download_error)\"\n               if [ \"${debug_logging}\" != true ]\n               then\n                  log_error \"Please set debug_logging=true in your icloudpd.conf file then reproduce the error\"\n                  log_error \"***** Once you have captured this log file, please post it along with a description of your problem, here: https://github.com/boredazfcuk/docker-icloudpd/issues *****\"\n               else\n                  log_error \"***** Please post the above debug log, along with a description of your problem, here: https://github.com/boredazfcuk/docker-icloudpd/issues *****\"\n               fi\n               if [ \"${icloud_china}\" = false ]\n               then\n                  send_notification \"failure\" \"iCloudPD container failure\" \"1\" \"iCloudPD failed to download new files for Apple ID: ${apple_id}\"\n               else\n                  # 结束时间、下次同步时间\n                  syn_end_time=\"$(date '+%H:%M:%S')\"\n                  syn_next_time=\"$(date +%H:%M:%S -d \"${synchronisation_interval} seconds\")\"\n                  send_notification \"failure\" \"iCloudPD container failure\" \"1\" \"从 iCloud 图库下载新照片失败，将在 ${syn_next_time} 再次尝试\" \"\" \"\" \"\" \"下载 ${name} 的 iCloud 图库新照片失败\" \"将在 ${syn_next_time} 再次尝试\"\n               fi\n            else\n               if [ \"${download_notifications}\" ]\n               then\n                  downloaded_files_notification\n               fi\n               if [ \"${synology_photos_app_fix}\" = true ]\n               then\n                  synology_photos_app_fix\n               fi\n               if [ \"${convert_heic_to_jpeg}\" != false ]\n               then\n                  log_info \"Convert HEIC files to JPEG\"\n                  convert_downloaded_heic_to_jpeg\n               fi\n               if [ \"${nextcloud_upload}\" = true ]\n               then\n                  nextcloud_sync\n               fi\n               if [ \"${delete_notifications}\" ]\n               then\n                  deleted_files_notification\n               fi\n               if [ \"${delete_accompanying}\" = true ] && [ \"${folder_structure}\" != \"none\" ] && [ \"${set_exif_datetime}\" = false ]\n               then\n                  remove_recently_deleted_accompanying_files\n               fi\n               if [ \"${delete_empty_directories}\" = true ] && [ \"${folder_structure}\" != \"none\" ]\n               then\n                  remove_empty_directories\n               fi\n               set_owner_and_permissions_downloads\n               log_info \"Synchronisation complete for ${user}\"\n               if [ \"${notification_type}\" ] && [ \"${remote_sync_complete_notification}\" = true ]\n               then\n                  send_notification \"remotesync\" \"iCloudPD remote synchronisation complete\" \"0\" \"iCloudPD has completed a remote synchronisation request for Apple ID: ${apple_id}\"\n                  unset remote_sync_complete_notification\n               fi\n            fi\n            login_counter=$((login_counter + 1))\n         fi\n      fi\n      check_web_cookie\n      log_info \"Web cookie expires: ${web_cookie_expire_date/ / @ }\"\n      if [ \"${authentication_type}\" = \"MFA\" ]\n      then\n         display_multifactor_authentication_expiry\n      fi\n      log_debug \"iCloud login counter = ${login_counter}\"\n      synchronisation_end_time=\"$(date +'%s')\"\n      log_info \"Synchronisation ended at $(date +%H:%M:%S -d \"@${synchronisation_end_time}\")\"\n      log_info \"Total time taken: $(date +%H:%M:%S -u -d \"@$((synchronisation_end_time - synchronisation_start_time))\")\"\n      if [ \"${single_pass:=false}\" = true ]\n      then\n         log_debug \"Single Pass mode set, exiting\"\n         exit 0\n      else\n         sleep_time=\"$((synchronisation_interval - synchronisation_end_time + synchronisation_start_time))\"\n         if [ \"${sleep_time}\" -ge \"72000\" ]\n         then\n            log_info \"Next synchronisation at $(date +%c -d \"${sleep_time} seconds\")\"\n         else\n            log_info \"Next synchronisation at $(date +%H:%M:%S -d \"${sleep_time} seconds\")\"\n         fi\n         unset check_exit_code check_files_count download_exit_code\n         unset new_files\n         if [ \"${notification_type}\" = \"Telegram\" ] && [ \"${telegram_polling}\" = true ]\n         then\n            log_info \"Monitoring ${notification_type} for remote commands prefix: ${user}\"\n            listen_counter=0\n            poll_sleep=30\n            while [ \"${listen_counter}\" -lt \"${sleep_time}\" ]\n            do\n               if [ \"${telegram_polling}\" = true ]\n               then\n                  unset latest_updates latest_update_ids break_while\n                  update_count=0\n                  telegram_update_id_offset=\"$(head -1 \"${telegram_update_id_offset_file}\")\"\n                  log_debug \"Polling Telegram for updates newer than: ${telegram_update_id_offset}\"\n                  telegram_update_id_offset_inc=$((telegram_update_id_offset + 1))\n                  latest_updates=\"$(curl --request POST --silent --data \"allowed_updates=message\" --data \"offset=${telegram_update_id_offset_inc}\" \"${telegram_base_url}/getUpdates\" | jq .result[])\"\n                  if [ \"${latest_updates}\" ]\n                  then\n                     latest_update_ids=\"$(echo \"${latest_updates}\" | jq -r '.update_id')\"\n                  fi\n                  if [ \"${latest_update_ids}\" ]\n                  then\n                     update_count=\"$(echo \"${latest_update_ids}\" | wc --lines)\"\n                     log_debug \"Updates to process: ${update_count}\"\n                     if [ \"${update_count}\" -gt 0 ]\n                     then\n                        for latest_update in ${latest_update_ids}\n                        do\n                           log_debug \"Processing update: ${latest_update}\"\n                           check_update=\"$(echo \"${latest_updates}\" | jq \". | select(.update_id == ${latest_update}).message\")\"\n                           check_update_text=\"$(echo \"${check_update}\" | jq -r .text)\"\n                           log_debug \"New message received: ${check_update_text}\"\n                           if [ \"${check_update_text,,}\" = \"${user,,}\" ]\n                           then\n                              break_while=true\n                              log_debug \"Remote sync message match: ${check_update_text}\"\n                           elif [ \"${check_update_text,,}\" = \"${user,,} auth\" ]\n                           then\n                              log_debug \"Remote authentication message match: ${check_update_text}\"\n                              if [ \"${icloud_china}\" = false ]\n                              then\n                                 send_notification \"remotesync\" \"iCloudPD remote synchronisation initiated\" \"0\" \"iCloudPD has detected a remote authentication request for Apple ID: ${apple_id}\"\n                              else\n                                 send_notification \"remotesync\" \"iCloudPD remote synchronisation initiated\" \"0\" \"iCloudPD将以Apple ID: ${apple_id}发起身份验证\"\n                              fi\n\t\t\t                     rm \"/config/${cookie_file}\" \"/config/${cookie_file}.session\"\n                              log_debug \"Starting remote authentication process\"\n                              /usr/bin/expect /opt/authenticate.exp &\n                              poll_sleep=3\n                           elif [[ \"${check_update_text,,}\" =~ ^${user,,}\\ [0-9][0-9][0-9][0-9][0-9][0-9]$ ]]\n                           then\n                              mfa_code=\"$(echo \"${check_update_text}\" | awk '{print $2}')\"\n                              echo \"${mfa_code}\" > /tmp/icloudpd/expect_input.txt\n                              listen_counter=$((listen_counter+2))\n                              # additional sleeps mean sync time slips each time time a sync or auth is performed.\n                              # adding same amount of time to listen counter should prevent this from occurring.\n                              sleep 2\n                              unset mfa_code\n                              poll_sleep=30\n                           elif [[ \"${check_update_text,,}\" =~ ^${user,,}\\ [a-z]$ ]]\n                           then\n                              sms_choice=\"$(echo \"${check_update_text}\" | awk '{print $2}')\"\n                              echo \"${sms_choice}\" > /tmp/icloudpd/expect_input.txt\n                              listen_counter=$((listen_counter+2))\n                              # additional sleeps mean sync time slips each time time a sync or auth is performed.\n                              # adding same amount of time to listen counter should prevent this from occurring.\n                              sleep 2\n                              unset sms_choice\n                              poll_sleep=3\n                           else\n                              log_debug \"Ignoring message: ${check_update_text}\"\n                              poll_sleep=30\n                           fi\n                        done\n                        echo -n \"${latest_update}\" > \"${telegram_update_id_offset_file}\"\n                        if [ \"${break_while}\" ]\n                        then\n                           log_debug \"Remote sync initiated\"\n                           if [ \"${icloud_china}\" = false ]\n                           then\n                              send_notification \"remotesync\" \"iCloudPD remote synchronisation initiated\" \"0\" \"iCloudPD has detected a remote synchronisation request for Apple ID: ${apple_id}\"\n                              remote_sync_complete_notification=true\n                           else\n                              send_notification \"remotesync\" \"iCloudPD remote synchronisation initiated\" \"0\" \"启动成功，开始同步当前 Apple ID 中的照片\" \"\" \"\" \"\" \"开始同步 ${name} 的 iCloud 图库\" \"Apple ID: ${apple_id}\"\n                           fi\n                              poll_sleep=30\n                           break\n                        fi\n                     fi\n                  fi\n               fi\n               listen_counter=$((listen_counter+poll_sleep))\n               # additional sleeps mean sync time slips each time time a sync or auth is performed.\n               # adding same amount of time to listen counter should prevent this from occurring.\n               sleep \"${poll_sleep}\"\n            done\n         else\n            sleep \"${sleep_time}\"\n         fi\n      fi\n   done\n}\n\nsanitise_launch_parameters()\n{\n   if [ \"${script_launch_parameters}\" ]\n   then\n      case \"$(echo \"${script_launch_parameters}\" | tr '[:upper:]' '[:lower:]')\" in\n         \"--initialise\"|\"--initialize\"|\"--init\"|\"--remove-keyring\"|\"--convert-all-heics\"|\"--remove-all-jpgs\"|\"--force-convert-all-heics\"|\"--force-convert-all-mnt-heics\"|\"--correct-jpeg-time-stamps\"|\"--upload-library-to-nextcloud\"|\"--list-albums\"|\"--list-libraries\"|\"--enable-debugging\"|\"--disable-debugging\")\n            log_info \"Script launch parameters: ${script_launch_parameters}\"\n         ;;\n         *)\n            log_warning \"Ignoring invalid launch parameter specified: ${script_launch_parameters}\"\n            log_warning \"Please do not specify the above parameter when launching the container. Continuing in 2 minutes\"\n            sleep 120\n            unset script_launch_parameters\n         ;;\n      esac\n   fi\n}\n\nenable_debug_logging()\n{\n   sed -i 's/debug_logging=.*/debug_logging=true/' \"${config_file}\"\n   log_info \"Debug logging enabled\"\n}\n\ndisable_debug_logging()\n{\n   sed -i 's/debug_logging=.*/debug_logging=false/' \"${config_file}\"\n   log_info \"Debug logging disabled\"\n}\n\n##### Script #####\nscript_launch_parameters=\"${1}\"\nif [ \"${2}\" ]\nthen\n   log_warning \"Only a single command line parameter is supported at this time. Only processing: ${script_launch_parameters}\"\nfi\ncase  \"$(echo \"${script_launch_parameters}\" | tr '[:upper:]' '[:lower:]')\" in\n   \"--initialise\"|\"--initialize\"|\"--init\")\n      initialise_container=true\n    ;;\n   \"--remove-keyring\")\n      delete_password=true\n    ;;\n   \"--convert-all-heics\")\n      convert_all_heics=true\n   ;;\n   \"--remove-all-jpgs\")\n      remove_all_jpgs=true\n   ;;\n   \"--force-convert-all-heics\")\n      force_convert_all_heics=true\n   ;;\n   \"--force-convert-all-mnt-heics\")\n      force_convert_all_mnt_heics=true\n   ;;\n   \"--correct-jpeg-time-stamps\")\n      correct_jpeg_time_stamps=true\n   ;;\n   \"--enable-debugging\")\n      enable_debugging=true\n   ;;\n   \"--disable-debugging\")\n      disable_debugging=true\n   ;;\n   \"--upload-library-to-nextcloud\")\n      nextcloud_upload_library=true\n   ;;\n   \"--help\")\n      \"$(which more)\" \"/opt/CONFIGURATION.md\"\n      exit 0\n   ;;\n   \"--list-albums\")\n      list_albums=true\n   ;;\n   \"--list-libraries\")\n      list_libraries=true\n   ;;\n   *)\n   ;;\nesac\n\ninitialise_script\nsanitise_launch_parameters\ncreate_group\ncreate_user\nset_owner_and_permissions_config\nif [ \"${delete_password:=false}\" = true ]\nthen\n   log_info \"Deleting password from keyring\"\n   delete_password\n   log_info \"Password deletion complete\"\n   exit 0\nfi\nconfigure_password\nif [ \"${initialise_container:=false}\" = true ]\nthen\n   log_info \"Starting container initialisation\"\n   generate_cookie\n   log_info \"Container initialisation complete\"\n   exit 0\nelif [ \"${enable_debugging:=false}\" = true ]\nthen\n   log_info \"Enabling debug logging\"\n   enable_debug_logging\n   exit 0\nelif [ \"${disable_debugging:=false}\" = true ]\nthen\n   log_info \"Disabling debug logging\"\n   disable_debug_logging\n   exit 0\nelif [ \"${convert_all_heics:=false}\" = true ]\nthen\n   log_info \"Converting all HEICs to JPG\"\n   convert_all_heic_files\n   set_owner_and_permissions_downloads\n   log_info \"HEIC to JPG conversion complete\"\n   exit 0\nelif [ \"${remove_all_jpgs:=false}\" = true ]\nthen\n   log_info \"Forcing removal of JPG files if accompanying HEIC exists\"\n   remove_all_jpeg_files\n   set_owner_and_permissions_downloads\n   log_info \"Forced removal of JPG files if accompanying HEIC exists complete\"\n   exit 0\nelif [ \"${force_convert_all_heics:=false}\" = true ]\nthen\n   log_info \"Forcing HEIC to JPG conversion\"\n   force_convert_all_heic_files\n   set_owner_and_permissions_downloads\n   log_info \"Forced HEIC to JPG conversion complete\"\n   exit 0\nelif [ \"${force_convert_all_mnt_heics:=false}\" = true ]\nthen\n   log_info \"Forcing HEIC to JPG conversion of all files in mount path\"\n   force_convert_all_mnt_heic_files\n   set_owner_and_permissions_downloads\n   log_info \"Forced HEIC to JPG conversion of all files in mount path complete\"\n   exit 0\nelif [ \"${correct_jpeg_time_stamps:=false}\" = true ]\nthen\n   log_info \"Correcting timestamps for JPEG files in ${download_path}\"\n   correct_jpeg_timestamps\n   log_info \"JPEG timestamp correction complete\"\n   exit 0\nelif [ \"${nextcloud_upload_library:=false}\" = true ]\nthen\n   log_info \"Uploading library to Nextcloud\"\n   nextcloud_upload_library\n   log_info \"Uploading library to Nextcloud complete\"\n   exit 0\nelif [ \"${list_albums:=false}\" = true ]\nthen\n   list_albums\n   exit 0\nelif [ \"${list_libraries:=false}\" = true ]\nthen\n   list_libraries\n   exit 0\nfi\ncheck_mount\nset_owner_and_permissions_config\ncommand_line_builder\ncheck_keyring_exists\nsynchronise_user"
        }
      ]
    }
  ]
}