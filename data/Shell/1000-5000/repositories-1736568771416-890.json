{
  "metadata": {
    "timestamp": 1736568771416,
    "page": 890,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mozilla-b2g/B2G",
      "stars": 1111,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3662109375,
          "content": ".config\n.repo/\n.userconfig*\n.var.profile\n*.swp\n*.pyc\n*.fix_b2g_stack.cache\nAdreno*\nMakefile\nabi/\nbackup-*/\nbionic/\nbootable/\nbrcm_usrlib/\nbuild/\ndalvik/\ndevelopment/\ndevice/\ndownload-*/\nexternal/\nframeworks/\ngaia/\ngecko/\ngonk-misc/\nhardware/\nkernel/\nlibcore/\nlibnativehelper/\nlibrecovery/\nndk/\nobjdir-gecko*/\nout/\nprebuilt/\nprebuilts/\nrilproxy/\nsdk/\nsystem/\nvendor/\nb2g_sdk/\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 0.1298828125,
          "content": "ifeq (\"$(ANDROID_BUILD_TOP)\",\"\")\n$(error Must source setup.sh or build/envsetup.sh to use make directly)\nelse\ninclude Makefile\nendif\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.546875,
          "content": "Copyright 2012, Mozilla Foundation\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5810546875,
          "content": "# Boot to Gecko (B2G)\n\nBoot to Gecko aims to create a complete, standalone operating system for the open web.\n\nYou can read more about B2G here:\n\n  http://wiki.mozilla.org/B2G\n  https://developer.mozilla.org/en-US/docs/Mozilla/B2G_OS\n\nfollow us on twitter: @Boot2Gecko\n\n  http://twitter.com/Boot2Gecko\n\njoin the Mozilla Platform mailing list:\n\n  http://groups.google.com/group/mozilla.dev.platform\n\nand talk to us on IRC:\n\n  #B2G on irc.mozilla.org\n\nor Telegram:\n\n  https://telegram.me/B2GOS\n\nDiscuss with Developers:\n\n  Discourse: https://discourse.mozilla-community.org/c/b2g-os-participation\n"
        },
        {
          "name": "bld.sh",
          "type": "blob",
          "size": 0.0078125,
          "content": "build.sh"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 2.86328125,
          "content": "#!/bin/bash\n\n# We want to figure out if we need to re-run the firmware\n# extraction routine.  The first time we run build.sh, we\n# store the hash of important files.  On subsequent runs,\n# we check if the hash is the same as the previous run.\n# If the hashes differ, we use a per-device script to redo\n# the firmware extraction\nfunction configure_device() {\n    hash_file=\"$OUT/firmware.hash\"\n\n    # Make sure that our assumption that device codenames are unique\n    # across vendors is true\n    if [ $(ls -d device/*/$DEVICE 2> /dev/null | wc -l) -gt 1 ] ; then\n        echo $DEVICE is ambiguous \\\"$(ls -d device/*/$DEVICE 2> /dev/null)\\\"\n        return 1\n    fi\n\n    # Select which blob setup script to use, if any.  We currently\n    # assume that $DEVICE maps to the filesystem location, which is true\n    # for the devices we support now (oct 2012) that do not require blobs.\n    # The emulator uses a $DEVICE of 'emulator' but its device/ directory\n    # uses the 'goldfish' name.\n    if [ -f device/*/$DEVICE/download-blobs.sh ] ; then\n        important_files=\"device/*/$DEVICE/download-blobs.sh\"\n        script=\"cd device/*/$DEVICE && ./download-blobs.sh\"\n    elif [ -f device/*/$DEVICE/extract-files.sh ] ; then\n        important_files=\"device/*/$DEVICE/extract-files.sh\"\n        script=\"cd device/*/$DEVICE && ./extract-files.sh\"\n    else\n        important_files=\n        script=\n    fi\n\n    # If we have files that are important to look at, we need\n    # to check if they've changed\n    if [ -n \"$important_files\" ] ; then\n        new_hash=$(cat $important_files | openssl sha1)\n        if [ -f \"$hash_file\" ] ; then\n            old_hash=$(cat \"$hash_file\")\n        fi\n        if [ \"$old_hash\" != \"$new_hash\" ] ; then\n            echo Blob setup script has changed, re-running &&\n            sh -c \"$script\" &&\n            mkdir -p \"$(dirname \"$hash_file\")\" &&\n            echo \"$new_hash\" > \"$hash_file\"\n        fi\n    else\n        rm -f $hash_file\n    fi\n\n    return $?\n}\n\nunset CDPATH\n. setup.sh &&\nif [ -f patches/patch.sh ] ; then\n    . patches/patch.sh\nfi &&\nconfigure_device &&\ntime nice -n19 make $MAKE_FLAGS $@\n\nret=$?\necho -ne \\\\a\nif [ $ret -ne 0 ]; then\n\techo\n\techo \\> Build failed\\! \\<\n\techo\n\techo Build with \\|./build.sh -j1\\| for better messages\n\techo If all else fails, use \\|rm -rf objdir-gecko\\| to clobber gecko and \\|rm -rf out\\| to clobber everything else.\nelse\n\tcase \"$1\" in\n\t\"gecko\")\n\t\techo Run \\|./build.sh snod\\| to update the system image.\n\t\techo Run \\|./flash.sh gecko\\| to update gecko.\n\t\tif echo $DEVICE | grep generic > /dev/null ; then\n\t\t\techo $(tput setaf 1)$(tput bold)You must update the system image for emulator to pick up the updated gecko.$(tput sgr0)\n\t\tfi\n\t\t;;\n\t*)\n\t\tif echo $DEVICE | grep generic > /dev/null ; then\n\t\t\techo Run \\|./run-emulator.sh\\| to start the emulator\n\t\telse\n\t\t\techo Run \\|./flash.sh\\| to flash all partitions of your device\n\t\tfi\n\t\t;;\n\tesac\n\texit 0\nfi\n\nexit $ret\n"
        },
        {
          "name": "config.sh",
          "type": "blob",
          "size": 5.9150390625,
          "content": "#!/bin/bash\n\nREPO=${REPO:-./repo}\nsync_flags=\"\"\n\nrepo_sync() {\n\trm -rf .repo/manifest* &&\n\t$REPO init -u $GITREPO -b $BRANCH -m $1.xml $REPO_INIT_FLAGS &&\n\t$REPO sync $sync_flags $REPO_SYNC_FLAGS\n\tret=$?\n\tif [ \"$GITREPO\" = \"$GIT_TEMP_REPO\" ]; then\n\t\trm -rf $GIT_TEMP_REPO\n\tfi\n\tif [ $ret -ne 0 ]; then\n\t\techo Repo sync failed\n\t\texit -1\n\tfi\n}\n\ncase `uname` in\n\"Darwin\")\n\t# Should also work on other BSDs\n\tCORE_COUNT=`sysctl -n hw.ncpu`\n\t;;\n\"Linux\")\n\tCORE_COUNT=`grep processor /proc/cpuinfo | wc -l`\n\t;;\n*)\n\techo Unsupported platform: `uname`\n\texit -1\nesac\n\nGITREPO=${GITREPO:-\"git://github.com/mozilla-b2g/b2g-manifest\"}\nBRANCH=${BRANCH:-master}\n\nwhile [ $# -ge 1 ]; do\n\tcase $1 in\n\t-d|-l|-f|-n|-c|-q|--force-sync|-j*)\n\t\tsync_flags=\"$sync_flags $1\"\n\t\tif [ $1 = \"-j\" ]; then\n\t\t\tshift\n\t\t\tsync_flags+=\" $1\"\n\t\tfi\n\t\tshift\n\t\t;;\n\t--help|-h)\n\t\t# The main case statement will give a usage message.\n\t\tbreak\n\t\t;;\n\t-*)\n\t\techo \"$0: unrecognized option $1\" >&2\n\t\texit 1\n\t\t;;\n\t*)\n\t\tbreak\n\t\t;;\n\tesac\ndone\n\nGIT_TEMP_REPO=\"tmp_manifest_repo\"\nif [ -n \"$2\" ]; then\n\tGITREPO=$GIT_TEMP_REPO\n\trm -rf $GITREPO &&\n\tgit init $GITREPO &&\n\tcp $2 $GITREPO/$1.xml &&\n\tcd $GITREPO &&\n\tgit add $1.xml &&\n\tgit commit -m \"manifest\" &&\n\tgit branch -m $BRANCH &&\n\tcd ..\nfi\n\necho MAKE_FLAGS=-j$((CORE_COUNT + 2)) > .tmp-config\necho GECKO_OBJDIR=$PWD/objdir-gecko >> .tmp-config\necho DEVICE_NAME=$1 >> .tmp-config\n\ncase \"$1\" in\n\"galaxy-s2\")\n\techo DEVICE=galaxys2 >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"galaxy-nexus\")\n\techo DEVICE=maguro >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"nexus-4\")\n\techo DEVICE=mako >> .tmp-config &&\n\trepo_sync nexus-4\n\t;;\n\n\"nexus-4-kk\")\n\techo DEVICE=mako >> .tmp-config &&\n\trepo_sync nexus-4-kk\n\t;;\n\n\"nexus-5\")\n\techo DEVICE=hammerhead >> .tmp-config &&\n\trepo_sync nexus-5\n\t;;\n\n\"nexus-5-l\")\n\techo DEVICE=hammerhead >> .tmp-config &&\n\trepo_sync nexus-5-l\n\t;;\n\n\"nexus-6-l\")\n\techo DEVICE=shamu >> .tmp-config &&\n\techo PRODUCT_NAME=aosp_shamu >> .tmp-config &&\n\trepo_sync nexus-6-l\n\t;;\n\n\"nexusplayer-l\")\n\techo DEVICE=fugu >> .tmp-config &&\n\techo PRODUCT_NAME=aosp_fugu >> .tmp-config &&\n\trepo_sync nexusplayer-l\n\t;;\n\n\"nexus-s\")\n\techo DEVICE=crespo >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"nexus-s-4g\")\n\techo DEVICE=crespo4g >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"otoro\"|\"unagi\"|\"keon\"|\"inari\"|\"hamachi\"|\"peak\"|\"helix\"|\"wasabi\"|\"flatfish\")\n\techo DEVICE=$1 >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"flame\"|\"flame-kk\"|\"flame-l\")\n\techo PRODUCT_NAME=flame >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"tarako\")\n\techo DEVICE=sp6821a_gonk >> .tmp-config &&\n\techo PRODUCT_NAME=sp6821a_gonk >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"dolphin\")\n\techo DEVICE=scx15_sp7715ga >> .tmp-config &&\n\techo PRODUCT_NAME=scx15_sp7715gaplus >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"dolphin-512\")\n\techo DEVICE=scx15_sp7715ea >> .tmp-config &&\n\techo PRODUCT_NAME=scx15_sp7715eaplus >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"pandaboard\")\n\techo DEVICE=panda >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"vixen\")\n\techo DEVICE=vixen >> .tmp-config &&\n\techo PRODUCT_NAME=vixen >> .tmp-config &&\n\trepo_sync $1\n\t;;  \n\n\"emulator\"|\"emulator-jb\"|\"emulator-kk\"|\"emulator-l\")\n\techo DEVICE=generic >> .tmp-config &&\n\techo LUNCH=full-eng >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"emulator-x86\"|\"emulator-x86-jb\"|\"emulator-x86-kk\"|\"emulator-x86-l\")\n\techo DEVICE=generic_x86 >> .tmp-config &&\n\techo LUNCH=full_x86-eng >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"flo\")\n\techo DEVICE=flo >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"rpi\")\n\techo PRODUCT_NAME=rpi >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"rpi2b-l\")\n\techo PRODUCT_NAME=rpi2b >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"leo-kk\")\n\techo PRODUCT_NAME=leo >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n# We need aries-l with repo_sync $1 for using manifest symlink for releng stuff\n\"aries\"|\"aries-l\")\n\techo PRODUCT_NAME=aries >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"fairphone2\")\n\techo PRODUCT_NAME=FP2 >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"openc-fr\")\n\techo DEVICE=zte_p821a10 >> .tmp-config &&\n\techo PRODUCT_NAME=zte_openc_fr >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"openc-ebay\")\n\techo DEVICE=zte_p821a10 >> .tmp-config &&\n\techo PRODUCT_NAME=zte_openc_eu >> .tmp-config &&\n\trepo_sync $1\n\t;;\n\n\"leo-l\"|\"scorpion-l\"|\"sirius-l\"|\"castor-l\"|\"castor_windy-l\"|\"honami-l\"|\"amami-l\"|\"tianchi-l\"|\"flamingo-l\"|\"eagle-l\"|\"seagull-l\")\n\techo PRODUCT_NAME=$1 | sed 's/..$//' >> .tmp-config &&\n\trepo_sync sony-aosp-l\n\t;;\n\n\"project-tablet\")\n\techo PRODUCT_NAME=castor_windy >> .tmp-config &&\n\trepo_sync project-tablet\n\t;;\n\n\"project-tablet-lte\")\n\techo PRODUCT_NAME=castor >> .tmp-config &&\n\trepo_sync project-tablet\n\t;;\n\n*)\n\techo \"Usage: $0 [-cdflnq] [-j <jobs>] [--force-sync] (device name)\"\n\techo \"Flags are passed through to |./repo sync|.\"\n\techo\n\techo Valid devices to configure are:\n\techo - galaxy-s2\n\techo - galaxy-nexus\n\techo - nexus-4\n\techo - nexus-4-kk\n\techo - nexus-5\n\techo - nexus-5-l\n\techo - nexus-6-l\n\techo - nexusplayer-l\n\techo - nexus-s\n\techo - nexus-s-4g\n\techo - flo \"(Nexus 7 2013)\"\n\techo - otoro\n\techo - unagi\n\techo - inari\n\techo - keon\n\techo - peak\n\techo - hamachi\n\techo - helix\n\techo - tarako\n\techo - dolphin\n\techo - dolphin-512\n\techo - pandaboard\n\techo - vixen\n\techo - fairphone2\n\techo - flatfish\n\techo - flame\n\techo - flame-kk\n\techo - flame-l\n\techo - openc-fr\n\techo - openc-ebay\n\techo - \"> Raspberry Pi boards\"\n\techo - rpi \"(Revision B)\"\n\techo - rpi2b-l\n\techo - emulator\n\techo - emulator-jb\n\techo - emulator-kk\n\techo - emulator-l\n\techo - emulator-x86\n\techo - emulator-x86-jb\n\techo - emulator-x86-kk\n\techo - emulator-x86-l\n\techo \"> Sony Xperia devices\"\n\techo - aries \"(Z3 Compact KK)\"\n\techo - aries-l \"(Z3 Compact L)\"\n\techo - leo-kk \"(Z3 KK)\"\n\techo - leo-l \"(Z3 L)\"\n\techo - scorpion-l \"(Z3 Tablet Compact L)\"\n\techo - sirius-l \"(Z2 L)\"\n\techo - castor-l \"(Z2 L Tablet LTE/WiFi)\"\n\techo - castor_windy-l \"(Z2 L Tablet WiFi only)\"\n\techo - honami-l \"(Z1 L)\"\n\techo - amami-l \"(Z1 Compact L)\"\n\techo - tianchi-l \"(T2U L)\"\n\techo - flamingo-l \"(E3 L)\"\n\techo - eagle-l \"(M2 L)\"\n\techo - seagull-l \"(T3 L)\"\n\texit -1\n\t;;\nesac\n\nif [ $? -ne 0 ]; then\n\techo Configuration failed\n\texit -1\nfi\n\nmv .tmp-config .config\n\necho Run \\|./build.sh\\| to start building\n"
        },
        {
          "name": "edit-prefs.sh",
          "type": "blob",
          "size": 0.2841796875,
          "content": "#!/bin/bash\nset -e\n\n[ -z \"$EDITOR\" ] && EDITOR=vi\n\nPREFS_JS=$(adb shell echo -n \"/data/b2g/mozilla/*.default\")/prefs.js\necho \"Pulling preferences: $PREFS_JS\"\nadb pull $PREFS_JS\n$EDITOR prefs.js\necho \"Pushing and restarting\"\nadb shell stop b2g\nadb push prefs.js $PREFS_JS\nadb shell start b2g\n"
        },
        {
          "name": "flash.sh",
          "type": "blob",
          "size": 10.1953125,
          "content": "#!/bin/bash\n\n. load-config.sh\ntest -f $DEVICE_DIR/flash.sh && . $DEVICE_DIR/flash.sh\n\nADB=${ADB:-adb}\nFASTBOOT=${FASTBOOT:-fastboot}\nHEIMDALL=${HEIMDALL:-heimdall}\nVARIANT=${VARIANT:-eng}\nFULLFLASH=false\n\nif [ ! -f \"`which \\\"$ADB\\\"`\" ]; then\n\tADB=out/host/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/bin/adb\nfi\nif [ ! -f \"`which \\\"$FASTBOOT\\\"`\" ]; then\n\tFASTBOOT=out/host/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/bin/fastboot\nfi\n\nrun_adb()\n{\n\t$ADB $ADB_FLAGS $@\n}\n\nrun_fastboot()\n{\n\tif [ \"$1\" = \"devices\" ]; then\n\t\t$FASTBOOT $@\n\telse\n\t\t$FASTBOOT $FASTBOOT_FLAGS $@\n\tfi\n\treturn $?\n}\n\nupdate_time()\n{\n\tif [ `uname` = Darwin ]; then\n\t\tOFFSET=`date +%z`\n\t\tOFFSET=${OFFSET:0:3}\n\t\tTIMEZONE=`date +%Z$OFFSET|tr +- -+`\n\telse\n\t\tTIMEZONE=`date +%Z%:::z|tr +- -+`\n\tfi\n\techo Attempting to set the time on the device\n\trun_adb wait-for-device &&\n\trun_adb shell \"toolbox date $(date +%s) ||\n\t               toolbox date -s $(date +%Y%m%d.%H%M%S)\" &&\n\trun_adb shell setprop persist.sys.timezone $TIMEZONE\n\n\thas_timekeep=$(run_adb shell ls /system/bin/timekeep | tr -d '\\r\\n')\n\tif [ \"${has_timekeep}\" = \"/system/bin/timekeep\" ]; then\n\t        cur_date=$(date +%s)\n\t        since_epoch=$(run_adb shell cat /sys/class/rtc/rtc0/since_epoch | tr -d '\\r\\n')\n\t\ttimeadjust=$(echo \"${cur_date}-${since_epoch}\" | bc)\n\t\trun_adb shell setprop persist.sys.timeadjust ${timeadjust}\n\t\trun_adb shell timekeep restore\n\tfi;\n}\n\nfastboot_flash_image()\n{\n\t# $1 = {userdata,boot,system,recovery} the image filename\n\t# $2 = {userdata,boot,system,recovery} the fastboot partition target\n\t#    if non specified, then $2 = $1\n\tPARTITION_FILE=$1\n\tPARTITION_NAME=$2\n\n\tif [ -z \"${PARTITION_NAME}\" ]; then\n\t\tPARTITION_NAME=${PARTITION_FILE}\n\tfi\n\n\tif [ \"$DEVICE\" == \"flatfish\" ] && [ \"${PARTITION_NAME}\" == \"userdata\" ]; then\n\t\tPARTITION_NAME=\"data\"\n\tfi\n\timgpath=\"out/target/product/$DEVICE/${PARTITION_FILE}.img\"\n\tout=\"$(run_fastboot flash \"${PARTITION_NAME}\" \"$imgpath\" 2>&1)\"\n\trv=\"$?\"\n\techo \"$out\"\n\n\tif [[ \"$rv\" != \"0\" ]]; then\n\t\t# Print a nice error message if we understand what went wrong.\n\t\tif grep -q \"too large\" <(echo \"$out\"); then\n\t\t\techo \"\"\n\t\t\techo \"Flashing $imgpath failed because the image was too large.\"\n\t\t\techo \"Try re-flashing after running\"\n\t\t\techo \"  \\$ rm -rf $(dirname \"$imgpath\")/data && ./build.sh\"\n\t\tfi\n\t\treturn $rv\n\tfi\n}\n\nfastboot_flash_image_if_exists()\n{\n\tif [ -e \"out/target/product/$DEVICE/$1.img\" ]; then\n\t\tfastboot_flash_image $1\n\tfi\n}\n\n\nflash_fastboot()\n{\n\tlocal lockedness=$1 project=$2\n\tcase $lockedness in\n\t\"unlock\"|\"nounlock\")\n\t\t;;\n\t*)\n\t\techo \"$0: $FUNCNAME: Invalid argument: $lockedness\"\n\t\treturn 1\n\t\t;;\n\tesac\n\tcase $project in\n\t\"system\"|\"boot\"|\"userdata\"|\"cache\"|\"\")\n\t\t;;\n\t*)\n\t\techo \"$0: Unrecognized project/partition: $project\"\n\t\treturn 1\n\t\t;;\n\tesac\n\n\tdelete_single_variant_persist\n\n\tcase $DEVICE in\n\t\"helix\")\n\t\trun_adb reboot oem-1\n\t\t;;\n\t\"flatfish\")\n\t\trun_adb reboot boot-fastboot\n\t\t;;\n\t*)\n\t\trun_adb reboot bootloader\n\t\t;;\n\tesac\n\n\tif ! run_fastboot devices; then\n\t\techo Couldn\\'t setup fastboot\n\t\treturn 1\n\tfi\n\n\tcase $lockedness in\n\t\"unlock\")\n\t\trun_fastboot oem unlock || true\n\t\t;;\n\tesac\n\n\tcase $project in\n\t\"system\" | \"boot\" | \"userdata\" | \"cache\")\n\t\tfastboot_flash_image $project &&\n\t\trun_fastboot reboot\n\t\t;;\n\n\t\"\")\n\t\tVERB=\"erase\"\n\t\tif [ \"$DEVICE\" == \"hammerhead\" ] || [ \"$DEVICE\" == \"mako\" ] ||\n\t\t[ \"$DEVICE\" == \"flo\" ] || [ \"$DEVICE\" == \"fugu\" ]; then\n\t\t\tVERB=\"format\"\n\t\tfi\n\t\tDATA_PART_NAME=\"userdata\"\n\t\tif [ \"$DEVICE\" == \"flatfish\" ]; then\n\t\t\tDATA_PART_NAME=\"data\"\n\t\tfi\n\t\t# helix/dolphin don't support erase command in fastboot mode.\n\t\tif [ \"$DEVICE\" != \"helix\" -a \"$DEVICE_NAME\" != \"dolphin\" ]; then\n\t\t\trun_fastboot $VERB cache &&\n\t\t\trun_fastboot $VERB $DATA_PART_NAME\n\t\t\tif [ $? -ne 0 ]; then\n\t\t\t\treturn $?\n\t\t\tfi\n\t\tfi\n\t\tcase ${DEVICE} in\n\t\t\"aries\"|\"leo\"|\"scorpion\"|\"sirius\"|\"castor\"|\"castor_windy\"|\"honami\"|\"amami\"|\"tianchi\"|\"flamingo\"|\"eagle\"|\"seagull\")\n\t\t\tfastboot_flash_image recovery FOTAKernel\n\t\t\t;;\n\t\tesac\n\t\tfastboot_flash_image userdata &&\n\t\tfastboot_flash_image_if_exists cache &&\n\t\tfastboot_flash_image_if_exists boot &&\n\t\tfastboot_flash_image system &&\n\t\trun_fastboot reboot &&\n\t\tupdate_time\n\t\t;;\n\tesac\n\techo -ne \\\\a\n}\n\nflash_heimdall()\n{\n\tlocal project=$1\n\tcase $project in\n\t\"system\"|\"kernel\"|\"\")\n\t\t;;\n\t*)\n\t\techo \"$0: Unrecognized project: $project\"\n\t\treturn 1\n\t\t;;\n\tesac\n\n\tif [ ! -f \"`which \\\"$HEIMDALL\\\"`\" ]; then\n\t\techo Couldn\\'t find heimdall.\n\t\techo Install Heimdall v1.3.1 from http://www.glassechidna.com.au/products/heimdall/\n\t\texit -1\n\tfi\n\n\tdelete_single_variant_persist &&\n\trun_adb reboot download && sleep 8\n\tif [ $? -ne 0 ]; then\n\t\techo Couldn\\'t reboot into download mode. Hope you\\'re already in download mode\n\tfi\n\n\tcase $project in\n\t\"system\")\n\t\t$HEIMDALL flash --factoryfs out/target/product/$DEVICE/$project.img\n\t\t;;\n\n\t\"kernel\")\n\t\t$HEIMDALL flash --kernel device/samsung/$DEVICE/kernel\n\t\t;;\n\n\t\"\")\n\t\t$HEIMDALL flash --factoryfs out/target/product/$DEVICE/system.img --kernel device/samsung/$DEVICE/kernel &&\n\t\tupdate_time\n\t\t;;\n\tesac\n\n\tret=$?\n\techo -ne \\\\a\n\tif [ $ret -ne 0 ]; then\n\t\techo Heimdall flashing failed.\n\t\tcase \"`uname`\" in\n\t\t\"Darwin\")\n\t\t\tif kextstat | grep com.devguru.driver.Samsung > /dev/null ; then\n\t\t\t\techo Kies drivers found.\n\t\t\t\techo Uninstall kies completely and restart your system.\n\t\t\telse\n\t\t\t\techo Restart your system if you\\'ve just installed heimdall.\n\t\t\tfi\n\t\t\t;;\n\t\t\"Linux\")\n\t\t\techo Make sure you have a line like\n\t\t\techo SUBSYSTEM==\\\"usb\\\", ATTRS{idVendor}==\\\"04e8\\\", MODE=\\\"0666\\\"\n\t\t\techo in /etc/udev/rules.d/android.rules\n\t\t\t;;\n\t\tesac\n\t\texit -1\n\tfi\n\n\techo Run \\|./flash.sh gaia\\| if you wish to install or update gaia.\n}\n\n# Delete files in the device's /system/b2g that aren't in\n# $GECKO_OBJDIR/dist/b2g.\n#\n# We do this for general cleanliness, but also because b2g.sh determines\n# whether to use DMD by looking for the presence of libdmd.so in /system/b2g.\n# If we switch from a DMD to a non-DMD build and then |flash.sh gecko|, we want\n# to disable DMD, so we have to delete libdmd.so.\n#\n# Note that we do not delete *folders* in /system/b2g.  This is intentional,\n# because some user data is stored under /system/b2g (e.g. prefs), but it seems\n# to be stored only inside directories.\ndelete_extra_gecko_files_on_device()\n{\n\tfiles_to_remove=\"$(cat <(ls \"$GECKO_OBJDIR/dist/b2g\") <(run_adb shell \"ls /system/b2g\" | tr -d '\\r') | sort | uniq -u)\"\n\tif [[ \"$files_to_remove\" != \"\" ]]; then\n\t\t# We expect errors from the call to rm below under two circumstances:\n\t\t#\n\t\t#  - We ask rm to remove a directory (per above, we don't\n\t\t#    actually want to remove directories, so rm is doing the\n\t\t#    right thing by not removing dirs)\n\t\t#\n\t\t#  - We ask rm to remove a file which isn't on the device (if\n\t\t#    you squint at files_to_remove, you'll see that it will\n\t\t#    contain files which are on the host but not on the device;\n\t\t#    obviously we can't remove those files from the device).\n\t\tfor to_remove in $files_to_remove; do\n\t\t\trun_adb shell \"rm /system/b2g/$to_remove\" > /dev/null\n\t\tdone\n\tfi\n\treturn 0\n}\n\ndelete_single_variant_persist()\n{\n\trun_adb shell 'rm -rf /persist/svoperapps'\n}\n\nflash_gecko()\n{\n\tdelete_extra_gecko_files_on_device &&\n\trun_adb push $GECKO_OBJDIR/dist/b2g /system/b2g &&\n\treturn 0\n}\n\nflash_gaia()\n{\n\tGAIA_MAKE_FLAGS=\"ADB=\\\"$ADB\\\"\"\n\tUSER_VARIANTS=\"user(debug)?\"\n\t# We need to decide where to push the apps here.\n\t# If the VARIANTS is user or userdebug, send them to /system/b2g.\n\t# or, we will try to connect the phone and see where Gaia was installed\n\t# and try not to push to the wrong place.\n\tif [[ \"$VARIANT\" =~ $USER_VARIANTS ]]; then\n\t\t# Gaia's build takes care of remounting /system for production builds\n\t\techo \"Push to /system/b2g ...\"\n\t\tGAIA_MAKE_FLAGS+=\" GAIA_INSTALL_PARENT=/system/b2g\"\n\telse\n\t\techo \"Detect GAIA_INSTALL_PARENT ...\"\n\t\t# This part has been re-implemented in Gaia build script (bug 915484),\n\t\t# XXX: Remove this once we no longer support old Gaia branches.\n\t\t# Install to /system/b2g if webapps.json does not exist, or\n\t\t# points any installed app to /system/b2g.\n\t\trun_adb wait-for-device\n\t\tif run_adb shell 'cat /data/local/webapps/webapps.json || echo \\\"basePath\\\": \\\"/system\\\"' | grep -qs '\"basePath\": \"/system' ; then\n\t\t\techo \"Push to /system/b2g ...\"\n\t\t\tGAIA_MAKE_FLAGS+=\" GAIA_INSTALL_PARENT=/system/b2g\"\n\t\telse\n\t\t\techo \"Push to /data/local ...\"\n\t\t\tGAIA_MAKE_FLAGS+=\" GAIA_INSTALL_PARENT=/data/local\"\n\t\tfi\n\tfi\n\tmake -C gaia push $GAIA_MAKE_FLAGS\n\n\t# For older Gaia without |push| target,\n\t# run the original |install-gaia| target.\n\t# XXX: Remove this once we no longer support old Gaia branches.\n\tif [[ $? -ne 0 ]]; then\n\t\tmake -C gaia install-gaia $GAIA_MAKE_FLAGS\n\tfi\n\treturn $?\n}\n\nwhile [ $# -gt 0 ]; do\n\tcase \"$1\" in\n\t\"-s\")\n\t\tADB_FLAGS+=\"-s $2\"\n\t\tFASTBOOT_FLAGS+=\"-s $2\"\n\t\tshift\n\t\t;;\n\t\"-f\")\n\t\tFULLFLASH=true\n\t\t;;\n\t\"-h\"|\"--help\")\n\t\techo \"Usage: $0 [-s device] [-f] [project]\"\n\t\texit 0\n\t\t;;\n\t\"-\"*)\n\t\techo \"$0: Unrecognized option: $1\"\n\t\texit 1\n\t\t;;\n\t*)\n\t\tFULLFLASH=true\n\t\tPROJECT=$1\n\t\t;;\n\tesac\n\tshift\ndone\n\ncase \"$PROJECT\" in\n\"shallow\")\n\tresp=`run_adb root` || exit $?\n\t[ \"$resp\" != \"adbd is already running as root\" ] && run_adb wait-for-device\n\trun_adb shell stop b2g &&\n\trun_adb remount &&\n\tflash_gecko &&\n\tflash_gaia &&\n\tupdate_time &&\n\techo Restarting B2G &&\n\trun_adb shell start b2g\n\texit $?\n\t;;\n\n\"gecko\")\n\tresp=`run_adb root` || exit $?\n\t[ \"$resp\" != \"adbd is already running as root\" ] && run_adb wait-for-device\n\trun_adb shell stop b2g &&\n\trun_adb remount &&\n\tflash_gecko &&\n\techo Restarting B2G &&\n\trun_adb shell start b2g\n\texit $?\n\t;;\n\n\"gaia\")\n\tflash_gaia\n\texit $?\n\t;;\n\n\"time\")\n\tupdate_time\n\texit $?\n\t;;\nesac\n\ncase \"$DEVICE\" in\n\"hamachi\"|\"helix\"|\"sp6821a_gonk\")\n\tif $FULLFLASH; then\n\t\tflash_fastboot nounlock $PROJECT\n\t\texit $?\n\telse\n\t\trun_adb root &&\n\t\trun_adb shell stop b2g &&\n\t\trun_adb remount &&\n\t\tflash_gecko &&\n\t\tflash_gaia &&\n\t\tupdate_time &&\n\t\techo Restarting B2G &&\n\t\trun_adb shell start b2g\n\tfi\n\texit $?\n\t;;\n\n\"flame\"|\"otoro\"|\"unagi\"|\"keon\"|\"peak\"|\"inari\"|\"wasabi\"|\"flatfish\"|\"aries\"|\"leo\"|\"scorpion\"|\"sirius\"|\"castor\"|\"castor_windy\"|\"honami\"|\"amami\"|\"tianchi\"|\"flamingo\"|\"eagle\"|\"seagull\"|\"scx15_sp7715\"*|\"zte_p821a10\")\n\tflash_fastboot nounlock $PROJECT\n\t;;\n\n\"panda\"|\"maguro\"|\"crespo\"|\"crespo4g\"|\"mako\"|\"hammerhead\"|\"flo\"|\"shamu\"|\"FP2\"|\"fugu\")\n\tflash_fastboot unlock $PROJECT\n\t;;\n\n\"galaxys2\")\n\tflash_heimdall $PROJECT\n\t;;\n\n*)\n\tif [[ $(type -t flash_${DEVICE}) = function ]]; then\n\t\tflash_${DEVICE} $PROJECT\n\telse\n\t\techo Unsupported device \\\"$DEVICE\\\", can\\'t flash\n\t\texit -1\n\tfi\n\t;;\nesac\n"
        },
        {
          "name": "load-config.sh",
          "type": "blob",
          "size": 0.5771484375,
          "content": "#!/bin/bash\n\nif [[ ! -n \"$B2G_DIR\" ]]; then\n  B2G_DIR=$(cd `dirname ${BASH_SOURCE[0]}`; pwd)\nfi\n\n. \"$B2G_DIR/.config\"\nif [ $? -ne 0 ]; then\n\techo Could not load .config. Did you run config.sh?\n\texit -1\nfi\n\nif [ -f \"$B2G_DIR/.userconfig\" ]; then\n\t. \"$B2G_DIR/.userconfig\"\nfi\n\n# Use default Gecko location if it's not provided in config files.\nif [ -z $GECKO_PATH ]; then\n  GECKO_PATH=$B2G_DIR/gecko\nfi\n\nVARIANT=${VARIANT:-eng}\nPRODUCT_NAME=${PRODUCT_NAME:-full_${DEVICE}}\nDEVICE=${DEVICE:-${PRODUCT_NAME}}\nLUNCH=${LUNCH:-${PRODUCT_NAME}-${VARIANT}}\nDEVICE_DIR=${DEVICE_DIR:-device/*/$DEVICE}\n"
        },
        {
          "name": "mach",
          "type": "blob",
          "size": 1.015625,
          "content": "#!/usr/bin/env python\n# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nfrom __future__ import print_function, unicode_literals\n\nimport os\nimport sys\n\ndef ancestors(path):\n    while path:\n        yield path\n        (path, child) = os.path.split(path)\n        if child == \"\":\n            break\n\ndef load_mach(b2g_home):\n    sys.path[0:0] = [os.path.join(b2g_home, \"tools\")]\n    import mach_b2g_bootstrap\n    return mach_b2g_bootstrap.bootstrap(b2g_home)\n\n# Check whether the current directory is within a mach src or obj dir.\nfor dir_path in ancestors(os.getcwd()):\n    # If we find the mach bootstrap module, we are in the b2g_home dir.\n    mach_path = os.path.join(dir_path, \"tools/mach_b2g_bootstrap.py\")\n    if os.path.isfile(mach_path):\n        mach = load_mach(dir_path)\n        sys.exit(mach.run(sys.argv[1:]))\n\nprint(\"Could not run mach: No mach source directory found\")\nsys.exit(1)\n"
        },
        {
          "name": "moz2d-record.sh",
          "type": "blob",
          "size": 2.0400390625,
          "content": "#!/bin/bash\n\n#set -x\n\nSCRIPT_NAME=$(basename $0)\n\nADB=adb\n\nset_recording() {\n  PREFS_JS=$(adb shell echo -n \"/data/b2g/mozilla/*.default\")/prefs.js\n  $ADB pull $PREFS_JS\n  echo \"user_pref(\\\"gfx.2d.recording\\\", $1);\" >> prefs.js\n  $ADB push prefs.js $PREFS_JS\n}\n\nHELP_start=\"Restart b2g with moz2d draw call recording.\"\ncmd_start() {\n  echo \"Stopping b2g\"\n  $ADB shell stop b2g\n  $ADB shell rm \"/data/local/tmp/moz2drec_*.aer\"\n  set_recording \"true\"\n  echo \"Restarting\"\n  $ADB shell start b2g\n  echo \"TIP: Close the application before invoking moz2d-record.sh stop\"\n}\n\nHELP_stop=\"Restart b2g without recording and pull the files.\"\ncmd_stop() {\n  echo \"Stopping b2g\"\n  $ADB shell stop b2g\n  echo \"Pulling recording(s)\"\n  $ADB shell ls \"/data/local/tmp/moz2drec_*.aer\" | tr -d '\\r' | xargs -n1 $ADB pull\n  $ADB shell rm \"/data/local/tmp/moz2drec_*.aer\"\n  set_recording \"false\"\n  echo \"Restarting\"\n  $ADB shell start b2g\n}\n\nHELP_clean=\"Clean the moz2drec files.\"\ncmd_clean() {\n  rm moz2drec_*.aer\n}\n###########################################################################\n#\n# Display a brief help message for each supported command\n#\nHELP_help=\"Shows these help messages\"\ncmd_help() {\n  if [ \"$1\" == \"\" ]; then\n    echo \"Usage: ${SCRIPT_NAME} command [args]\"\n    echo \"where command is one of:\"\n    for command in ${allowed_commands}; do\n      desc=HELP_${command}\n      printf \"  %-11s %s\\n\" ${command} \"${!desc}\"\n    done\n  else\n    command=$1\n    if [ \"${allowed_commands/*${command}*/${command}}\" == \"${command}\" ]; then\n      desc=HELP_${command}\n      printf \"%-11s %s\\n\" ${command} \"${!desc}\"\n    else\n      echo \"Unrecognized command: '${command}'\"\n    fi\n  fi\n}\n\n#\n# Determine if the first argument is a valid command and execute the\n# corresponding function if it is.\n#\nallowed_commands=$(declare -F | sed -ne 's/declare -f cmd_\\(.*\\)/\\1/p' | tr \"\\n\" \" \")\ncommand=$1\nif [ \"${command}\" == \"\" ]; then\n  cmd_help\n  exit 0\nfi\nif [ \"${allowed_commands/*${command}*/${command}}\" == \"${command}\" ]; then\n  shift\n  cmd_${command} \"$@\"\nelse\n  echo \"Unrecognized command: '${command}'\"\nfi\n\n"
        },
        {
          "name": "profile.sh",
          "type": "blob",
          "size": 22.123046875,
          "content": "#!/bin/bash\n\nSCRIPT_NAME=$(basename $0)\n\nADB=adb\nPROFILE_DIR=/data/local/tmp\nPROFILE_PATTERN=${PROFILE_DIR}/'profile_?_*.txt';\nPREFIX=\"\"\nBP_SYMBOLS=\"\"\n\nif [ -n \"$SPS_PROFILE_DEVICE\" ]; then\n  ADB=\"adb -s ${SPS_PROFILE_DEVICE}\"\nfi\n\nFEATURES_FLAG=\"MOZ_PROFILING_FEATURES\"\nDEFAULT_FEATURES=js,leaf\n\n# The get_pids function populates B2G_PIDS as an array containting the PIDs\n# of all of the b2g processes\ndeclare -a B2G_PIDS\n\n# The get_comms function populates B2G_COMMS as an array mapping\n# pids to comms (process names). get_comms also causes B2G_PIDS to be populated.\ndeclare -a B2G_COMMS\n\n# This function takes a variable that is either a pid or a process name\n# and returns the pid or exits on error\nget_pid_by_pid_or_name() {\n    pid=\"$1\"\n    case $pid in\n      *[^0-9]*)\n        pid=$(get_pid_by_name \"$pid\")\n        if [ -z \"$pid\" ] ; then\n          echo Error: PID $1 is invalid\n          exit 1;\n        fi\n      ;;\n    esac\n    echo -n \"$pid\"\n    return\n}\n\nget_pid_by_name() {\n    echo $($ADB shell \"toolbox ps '$1' | (read header; read user pid rest; echo -n \\$pid)\")\n}\n\n###########################################################################\n#\n# Clears the B2G_PIDS, which will force the information to be refetched.\n#\nclear_pids() {\n  unset B2G_PIDS\n  unset B2G_COMMS\n}\n\n###########################################################################\n#\n# Takes a pid or process name, and tries to determine the PID (only accepts\n# PIDs which are associated with a b2g process)\n#\nfind_pid() {\n  local search=\"$1\"\n  get_comms\n  for pid in ${B2G_PIDS[*]}; do\n    if [ \"${search}\" == \"${pid}\" -o \"${search}\" == \"${B2G_COMMS[${pid}]}\" ]; then\n      echo -n \"${pid}\"\n      return\n    fi\n  done\n}\n\n###########################################################################\n#\n# Sets B2G_PID to be the pid of the b2g process.\n#\nget_b2g_pid() {\n   echo $($ADB shell 'toolbox ps b2g | (read header; read user pid rest; echo -n $pid)')\n}\n\n###########################################################################\n#\n# Fill B2G_PIDS with an array of b2g process PIDs\n#\nget_pids() {\n  if [ ${#B2G_PIDS[*]} -gt 0 ]; then\n    # We've already populated B2G_PIDS, don't bother doing it again\n    return\n  fi\n\n  B2G_PIDS=($(${ADB} shell toolbox ps | while read line; do\n    if [ \"${line/*b2g*/b2g}\" = \"b2g\" ]; then\n      echo ${line} | (\n        read user pid rest;\n        echo -n \"${pid} \"\n      )\n    fi\n  done))\n}\n\n###########################################################################\n#\n# Fill B2G_COMMS such that B2G_COMMS[pid] contains the process name.\n#\nget_comms() {\n  if [ ${#B2G_COMMS[*]} -gt 0 ]; then\n    # We've already populated B2G_COMMS, don't bother doing it again\n    return\n  fi\n  get_pids\n  for pid in ${B2G_PIDS[*]}; do\n    # adb shell seems to replace the \\n with a \\r, so we use\n    # tr to strip trailing newlines or CRs\n    B2G_COMMS[${pid}]=\"$(${ADB} shell cat /proc/${pid}/comm | tr -d '\\r\\n')\"\n  done\n}\n\n###########################################################################\n#\n# Determines if the profiler is running for a given pid\n#\n# We use the traditional 0=success 1=failure return code.\n#\nis_profiler_running() {\n  local pid=$1\n  if [ -z \"${pid}\" ]; then\n    return 1\n  fi\n  local status=\"$(${ADB} shell cat \"/proc/${pid}/task/*/stat\" | tr '\\0' '\\n' | grep '(SamplerThread)')\"\n  if [ -z \"${status}\" ]; then\n    return 1\n  fi\n  return 0\n}\n\n###########################################################################\n#\n# Parses start arguments array and sets their features\n#\nstart_with_args() {\n  fileName=\"/data/local/tmp/profiler.options\"\n  B2G_PID=\"\"\n  ${ADB} shell rm $fileName &> /dev/null\n  features=\"\"\n  threads=\"\"\n  tasktracer=\"\"\n\n  while getopts \"i:m:t:f:p:e:s:\" opt \"$@\"; do\n    case $opt in\n      e)\n        echo \"Entries: $OPTARG\"\n        ${ADB} shell \"echo MOZ_PROFILER_ENTRIES=$OPTARG >> $fileName\"\n        ;;\n      s)\n        echo \"Stack Scan: $OPTARG\"\n        ${ADB} shell \"echo MOZ_PROFILER_STACK_SCAN=$OPTARG >> $fileName\"\n        ;;\n      i)\n        echo \"Interval: $OPTARG\"\n        ${ADB} shell \"echo MOZ_PROFILER_INTERVAL=$OPTARG >> $fileName\"\n        ;;\n      m)\n        echo \"Mode: $OPTARG\"\n        ${ADB} shell \"echo MOZ_PROFILER_MODE=$OPTARG >> $fileName\"\n        ;;\n      t)\n        threads=$OPTARG\n        echo \"Threads: $OPTARG\"\n        ${ADB} shell \"echo threads=$threads >> $fileName\"\n        ;;\n      f)\n        features=$OPTARG\n        echo \"Features: $features\"\n        ${ADB} shell \"echo $FEATURES_FLAG=$features>> $fileName\"\n        ;;\n      p)\n        echo \"Process: $OPTARG\"\n        B2G_PID=$(get_pid_by_pid_or_name \"$OPTARG\") || {\n          echo \"Could not find pid: $OPTARG\"\n          exit 1\n        }\n        ;;\n      ?)\n        exit 1\n        ;;\n      esac\n  done\n\n  # Feature / thread fix up. If we have a thread\n  # the feature \"threads\" must be enabled\n  if [ -z \"$features\" ]\n  then\n    if [ -n \"$threads\" ]\n    then\n      echo \"Using default features js,leaf,threads\"\n      ${ADB} shell \"echo $FEATURES_FLAG=$DEFAULT_FEATURES,threads >> $fileName\"\n    else\n      echo \"Using default features $DEFAULT_FEATURES\"\n      ${ADB} shell \"echo $FEATURES_FLAG=$DEFAULT_FEATURES >> $fileName\"\n    fi\n  fi\n\n  if [ -n \"`echo $features | grep tasktracer`\" ]\n  then\n    tasktracer=\"true\"\n    clear_pids\n    get_pids\n    echo \"Enable feature TaskTracer requires profiling on all current running processes.\"\n    for pid in ${B2G_PIDS[*]}; do\n      echo \"Starting profiling with TaskTracer on PID ${pid}\"\n      ${ADB} shell \"kill -12 ${pid}\"\n    done\n    echo \"Profiler started\"\n  fi\n\n  if [ -z \"$tasktracer\" ]\n  then\n    if [ -z \"$B2G_PID\" ]\n    then\n      echo \"No B2G process specified. Exiting\"\n      exit 1\n    else\n      echo \"Starting profiling PID $B2G_PID\"\n      ${ADB} shell \"kill -12 ${B2G_PID}\"\n      echo \"Profiler started\"\n      echo\n    fi\n  fi\n}\n\n###########################################################################\n#\n# Removes any stale profile files which might be left on the device\n#\nremove_profile_files() {\n  echo -n \"Removing old profile files (from device) ...\"\n  for file in $(${ADB} shell echo -n ${PROFILE_PATTERN}); do\n    # If no files match the pattern, then echo will return the pattern\n    if [ \"${file}\" != \"${PROFILE_PATTERN}\" ]; then\n      echo -n \".\"\n      ${ADB} shell rm ${file}\n    fi\n  done\n  echo \" done\"\n}\n\n\n###########################################################################\n#\n# Make sure that the basic requirements for a video capture profiles\n# are met.\n#\ncheck_video_capture_requirements() {\n  if ! hash avconv 2> /dev/null; then\n    echo \"avconv not found, please install it.\"\n    exit 1\n  fi\n  if [ -z \"$SPS_VIDEO_DEVICE\" ]; then\n    echo \"You must have \\$SPS_VIDEO_DEVICE set to an android device that can capture a video feed.\"\n    exit 1\n  fi\n  if [ -z \"$SPS_VIDEO_SCP_DEST\" ]; then\n    echo \"You must have \\$SPS_VIDEO_SCP_DEST set to a public_html folder.\"\n    exit 1\n  fi\n  if [ -z \"$SPS_VIDEO_LINK\" ]; then\n    echo \"You must have \\$SPS_VIDEO_LINK to the HTTP prefix for \\$SPS_VIDEO_SCP_DEST.\"\n    exit 1\n  fi\n}\n\n###########################################################################\n#\n# Capture the profiling information from a given process.\n#\nHELP_capture=\"Signals, pulls, and symbolicates the profile data\"\ncmd_capture() {\n  video=0\n\n  while getopts \"s:v\" opt \"$@\"; do\n    case $opt in\n      s)\n        echo \"Symbols: $OPTARG\"\n        BP_SYMBOLS=\"-s $OPTARG\"\n        ;;\n      v)\n        video=1\n        ;;\n      ?)\n        exit 1\n        ;;\n    esac\n  done\n\n  # Start recording with the camera\n  if [ \"$video\" -ne 0 ]; then\n    check_video_capture_requirements\n    adb -s \"$SPS_VIDEO_DEVICE\" shell \"am start -a android.media.action.VIDEO_CAPTURE\"\n    if [ $? != 0 ]; then\n      exit 1\n    fi\n\n    FILES_BEFORE=\"$(adb -s \"$SPS_VIDEO_DEVICE\" shell ls \"/sdcard/DCIM/Camera/*.mp4\" | tr '\\r' ' ')\"\n\n    echo \"Point the camera so that the QR code is visible at all times.\"\n    echo \"If you do not see th QR code then set layers.frame-counter;true and retry.\"\n    echo \"\"\n    echo \"Hit ENTER when ready to start recording\"\n    read anykey\n\n    adb -s \"$SPS_VIDEO_DEVICE\" shell \"input keyevent KEYCODE_CAMERA\"\n\n    echo \"Recording in progress.\"\n    echo \"\"\n    echo \"Hit ENTER when ready to stop capture\"\n    read anykey\n  fi\n\n  # Send the signal right away. If the profiler wasn't started, this will\n  # print an error message and exit.\n  cmd_signal\n  get_comms\n  declare -a local_filename\n  local timestamp=$(date +\"%H%M\")\n  local stabilized\n  if [ \"${CMD_SIGNAL_PID:0:1}\" == \"-\" ]; then\n    # We signalled the entire process group. Stabilize, pull and symbolicate\n    # each file in parallel\n    for pid in ${B2G_PIDS[*]}; do (\n      PREFIX=\"     ${pid}\"\n      PREFIX=\"${PREFIX:$((${#PREFIX} - 5)):5}: \"\n      echo \"${PREFIX}Stabilizing ${B2G_COMMS[${pid}]} ...\" 1>&2\n      stabilized=$(cmd_stabilize ${pid})\n      if [ \"${stabilized}\" == \"0\" ]; then\n        echo \"${PREFIX}Process was probably killed due to OOM\" 1>&2\n      else\n        cmd_pull ${pid} \"${B2G_COMMS[${pid}]}\" ${timestamp}\n        if [ ! -z \"${CMD_PULL_LOCAL_FILENAME}\" -a -s \"${CMD_PULL_LOCAL_FILENAME}\" ]; then\n          cmd_symbolicate \"${CMD_PULL_LOCAL_FILENAME}\"\n        else\n          echo \"${PREFIX}PULL FAILED for ${pid}\" 1>&2\n        fi\n      fi) &\n    done\n    # This sleep just delays the \"Waiting for stuff to finish\" echo slightly\n    # so that it shows up after the Stabilizing echos from above. The\n    # stabilizing loop will delay for at least two seconds, so this has no\n    # impact on the performance, it just makes the output look a big nicer.\n    sleep 1\n    echo \"Waiting for stabilize/pull/symbolicate to finish ...\"\n    wait\n    echo \"Done\"\n  else\n\n    # Pull the nwest video files\n    if [ \"$1\" == \"-video\" ]; then\n      adb -s \"$SPS_VIDEO_DEVICE\" shell \"input keyevent KEYCODE_CAMERA\"\n      sleep 2 # Wait for the video to save\n      FILES_AFTER=$(adb -s \"$SPS_VIDEO_DEVICE\" shell ls \"/sdcard/DCIM/Camera/*.mp4\" | tr '\\r' ' ')\n      for i in ${FILES_AFTER}; do\n        unset found\n        for j in ${FILES_BEFORE}; do\n          if [ \"$i\" == \"$j\" ]; then\n            found=true\n          fi\n        done\n        if [ -z \"$found\" ]; then\n          SPS_VIDEO_FILE=\"$i\"\n        fi\n      done\n      if [ -z \"$SPS_VIDEO_FILE\" ]; then\n        echo \"Failed to get video capture\"\n        exit 1\n      fi\n      VIDEO_FILE=video_capture_$(date +\"%s\").webm\n      adb -s \"$SPS_VIDEO_DEVICE\" pull \"$SPS_VIDEO_FILE\" video_capture.mp4\n      # Transcode video while stripping audio. When mp4 is supported everywhere this step should only strip the audio\n      avconv -y -i video_capture.mp4 -an -c:v libvpx -minrate 1M -maxrate 8M -b:v 8M video_capture.mp4.webm \"$VIDEO_FILE\"\n      echo \"Uploading video, you may be prompted for your ssh passphrase\"\n      scp -p \"$VIDEO_FILE\" \"$SPS_VIDEO_SCP_DEST\"/\"$VIDEO_FILE\"\n    fi\n\n    pids=\"${CMD_SIGNAL_PID}\"\n    profiles_count=0\n    profiles_to_merge=\"\"\n    for pid in $pids; do\n      echo \"Stabilizing ${pid} ${B2G_COMMS[${pid}]} ...\" 1>&2\n      stabilized=$(cmd_stabilize ${pid})\n      if [ \"${stabilized}\" == \"0\" ]; then\n        echo \"Process ${pid} was probably killed due to OOM\" 1>&2\n      else\n        cmd_pull ${pid} \"${B2G_COMMS[${pid}]}\"\n        if [ ! -z \"${CMD_PULL_LOCAL_FILENAME}\" -a -s \"${CMD_PULL_LOCAL_FILENAME}\" ]; then\n          cmd_symbolicate \"${CMD_PULL_LOCAL_FILENAME}\"\n          profiles_to_merge=\"$profiles_to_merge $CMD_SYMBOLICATE_PROFILE\"\n          let profiles_count=profiles_count+1\n        fi\n      fi\n    done\n    SPS_VIDEO_ARGS=\n    if [ -n \"$SPS_VIDEO_FILE\" ]; then\n      SPS_VIDEO_ARGS=\"--video=$SPS_VIDEO_LINK/$VIDEO_FILE\"\n    fi\n    echo \"Merging profile: $profiles_to_merge\"\n    echo ./gecko/tools/profiler/merge-profiles.py ${SPS_VIDEO_ARGS} $profiles_to_merge\n    ./gecko/tools/profiler/merge-profiles.py ${SPS_VIDEO_ARGS} $profiles_to_merge > profile_captured.sym\n    echo \"\"\n    echo \"Results: profile_captured.sym\"\n  fi\n  # cmd_pull should remove each file as we pull it. This just covers the\n  # case where it doesn't\n  remove_profile_files\n}\n\n###########################################################################\n#\n# Display a brief help message for each supported command\n#\nHELP_help=\"Shows these help messages\"\ncmd_help() {\n  if [ \"$1\" == \"\" ]; then\n    echo \"Usage: ${SCRIPT_NAME} command [args]\"\n    echo \"where command is one of:\"\n    for command in ${allowed_commands}; do\n      desc=HELP_${command}\n      printf \"  %-11s %s\\n\" ${command} \"${!desc}\"\n    done\n  else\n    command=$1\n    if [ \"${allowed_commands/*${command}*/${command}}\" == \"${command}\" ]; then\n      desc=HELP_${command}\n      printf \"%-11s %s\\n\" ${command} \"${!desc}\"\n    else\n      echo \"Unrecognized command: '${command}'\"\n    fi\n  fi\n}\n\n###########################################################################\n#\n# Show all of the profile files on the phone\n#\nHELP_ls=\"Shows the profile files on the phone\"\ncmd_ls() {\n  ${ADB} shell \"cd ${PROFILE_DIR}; ls -l profile_?_*.txt\"\n}\n\n###########################################################################\n#\n# Show all of the b2g processes which are currently running.\n#\nHELP_ps=\"Shows the B2G processes\"\ncmd_ps() {\n  local status\n  get_comms\n  echo \"  PID Name\"\n  echo \"----- ----------------\"\n  for pid in ${B2G_PIDS[*]}; do\n    if is_profiler_running ${pid}; then\n      status=\"profiler running\"\n    else\n      status=\"profiler not running\"\n    fi\n    printf \"%5d %-16s %s\\n\" \"${pid}\" \"${B2G_COMMS[${pid}]}\" \"${status}\"\n  done\n}\n\n###########################################################################\n#\n# Pulls the profile file from the phone\n#\nHELP_pull=\"Pulls the profile data from the phone\"\ncmd_pull() {\n  local pid=$1\n  local comm=$2\n  local label=$3\n\n  pid=$(get_pid_by_pid_or_name \"$pid\") || {\n    echo \"Could not find pid: $1\"\n    exit 1;\n  }\n\n  # The profile data gets written to /data/local/tmp/profile_X_PID.txt\n  # where X is the XRE_ProcessType (so 0 for the b2g process, 2 for\n  # the plugin containers).\n  #\n  # We know the PID, so we look for the file, and we wait for it to\n  # stabilize.\n\n  local attempt\n  local profile_filename\n  local profile_pattern=\"${PROFILE_DIR}/profile_?_${pid}.txt\"\n  local local_filename\n  # Remove all non-alphanumeric characters from the process name to\n  # make filename-handling sane.\n  local alphanum_process_name=${B2G_COMMS[${pid}]//[^A-Za-z0-9]/}\n  if [ -z \"${comm}\" ]; then\n    local_filename=\"profile_${pid}.txt\"\n  elif [ -z \"${label}\" ]; then\n    local_filename=\"profile_${pid}_${alphanum_process_name}.txt\"\n  else\n    local_filename=\"profile_${label}_${pid}_${alphanum_process_name}.txt\"\n  fi\n  profile_filename=$(${ADB} shell \"echo -n ${profile_pattern}\")\n\n  CMD_PULL_LOCAL_FILENAME=\n  if [ \"${profile_filename}\" == \"${profile_pattern}\" ]; then\n    echo \"${PREFIX}Profile file for PID ${pid} ${B2G_COMMS[${pid}]} doesn't exist - process likely killed due to OOM\"\n    return\n  fi\n  echo \"${PREFIX}Pulling ${profile_filename} into ${local_filename}\"\n  ${ADB} pull ${profile_filename} \"${local_filename}\" > /dev/null 2>&1\n  #echo \"${PREFIX}Removing ${profile_filename}\"\n  ${ADB} shell rm ${profile_filename}\n\n  if [ ! -s \"${local_filename}\" ]; then\n    echo \"${PREFIX}Profile file for PID ${pid} ${B2G_COMMS[${pid}]} is empty - process likely killed due to OOM\"\n    return\n  fi\n  CMD_PULL_LOCAL_FILENAME=\"${local_filename}\"\n}\n\n###########################################################################\n#\n# Signal the profiler to generate the profile data\n#\nHELP_signal=\"Signal the profiler to generate profile data\"\ncmd_signal() {\n  # Call get_comms here since we need it later. find_pid is launched in\n  # a sub-shell since we want the echo'd output which means we won't\n  # see the results when it calls get_comms, but if we call get_comms,\n  # then find_pid will see the results of us calling get_comms.\n  get_comms\n  local pid\n  local curr_pid\n  if [ -z \"$1\" ]; then\n    for curr_pid in ${B2G_PIDS[*]}; do\n      if is_profiler_running ${curr_pid}; then\n        pid=\"${pid} ${curr_pid}\"\n      fi\n    done\n    if [ -z \"$pid\" ]; then\n      echo \"Not profiling any processes to signal\"\n      echo \"Did you start the profiler using ${SCRIPT_NAME} start ?\"\n      exit 1\n    fi\n    echo \"Signaling Profiled Processes:${pid}\"\n  else\n    pid=$(find_pid \"$1\")\n    if [ \"${pid}\" == \"\" ]; then\n      echo \"Must specify a PID or process-name to capture\"\n      cmd_ps\n      exit 1\n    fi\n    echo \"Signalling PID: ${pid} ${B2G_COMMS[${pid}]} ...\"\n  fi\n\n  ${ADB} shell \"kill -12 ${pid}\"\n  CMD_SIGNAL_PID=${pid}\n}\n\n###########################################################################\n#\n# Wait for a single captured profile files to stabilize.\n#\n# This is somewhat complicated by the fact that writing the files on the\n# phone is sort of serialized. I observe that 2 files actually get changing\n# data, and then when those are finished, 2 more will get data.\n#\n# So when trying to figure out how long to wait for a file to get a\n# non-zero size, we need to wait until no files are changing before starting\n# our timeout.\n#\n\nHELP_stabilzie=\"Waits for a profile file to stop changing\"\ncmd_stabilize() {\n\n  local pid=$1\n  if [ -z \"$1\" ]; then\n    echo \"No PID specified.\" 1>&2\n    return\n  fi\n\n  # We wait for the output of ls ${PROFILE_PATTERN} to stay the same for\n  # a few seconds in a row\n\n  local attempt\n  local prev_size\n  local prev_sizes\n  local curr_size\n  local curr_sizes\n  local stabilized=0\n  local waiting=0\n\n  while true; do\n    curr_sizes=$(${ADB} shell toolbox ls -l ${PROFILE_DIR}/'profile_?_*.txt' |\n      while read line; do\n        echo ${line} | (\n          read perms user group size rest;\n          echo -n \"${size} \"\n        )\n      done)\n    curr_size=$(${ADB} shell toolbox ls -l ${PROFILE_DIR}/'profile_?_'${pid}'.txt' | (read perms user group size rest; echo -n ${size}))\n    if [ \"${curr_size}\" == \"0\" ]; then\n      # Our file hasn't changed. See if others have\n      if [ \"${curr_sizes}\" == \"${prev_sizes}\" ]; then\n        waiting=$(( ${waiting} + 1 ))\n        if [ ${waiting} -gt 5 ]; then\n          # No file sizes have changed in the last 5 seconds.\n          # Assume that our PID was OOM'd\n          break\n        fi\n      else\n        waiting=0\n      fi\n    else\n      # Our file has non-zero size\n      if [ \"${curr_size}\" == \"${prev_size}\" ]; then\n        waiting=$(( ${waiting} + 1 ))\n        if [ ${waiting} -gt 2 ]; then\n          # Our size is non-zero and hasn't changed recently.\n          # Consider it to be stabilized\n          stabilized=1\n          break\n        fi\n      else\n        waiting=0\n      fi\n    fi\n    prev_size=\"${curr_size}\"\n    prev_sizes=\"${curr_sizes}\"\n    sleep 1\n  done\n\n  echo \"${stabilized}\"\n}\n\n###########################################################################\n#\n# Start b2g with the profiler enabled.\n#\nHELP_start=\"Starts the profiler. -p [process] -e [entries] -s [stack scan mode]\n              -i [interval] -m [profiler mode] -f [features] -t [threads].\n              e.g. ./profile.sh start -p b2g -t Compositor -i 1\"\ncmd_start() {\n  if [ $# -gt 0 ]\n  then\n    start_with_args \"$@\"\n  else\n    stop_b2g\n    remove_profile_files\n    default_flags=\" MOZ_PROFILER_STARTUP=1 $FEATURES_FLAG=$DEFAULT_FEATURES\"\n\n    echo -n \"Starting b2g with profiling enable and default flags: $default_flags\"\n    echo\n    nohup ${ADB} shell \"$default_flags /system/bin/b2g.sh > /dev/null\" > /dev/null 2>&1 &\n    echo \"Started\"\n  fi\n}\n\n###########################################################################\n#\n# Stop profiling and start b2g normally\n#\nHELP_stop=\"Stops profiling and restarts b2g normally.\"\ncmd_stop() {\n  stop_b2g\n  echo \"Restarting b2g (normally) ...\"\n  ${ADB} shell start b2g\n}\n\n###########################################################################\n#\n# Add symbols to a captured profile using the libraries from our build\n# tree.\n#\nHELP_symbolicate=\"Add symbols to a captured profile\"\ncmd_symbolicate() {\n  local profile_filename=\"$1\"\n  if [ -z \"${profile_filename}\" ]; then\n    echo \"${PREFIX}Expecting the filename containing the profile data\"\n    exit 1\n  fi\n  if [ ! -f \"${profile_filename}\" ]; then\n    echo \"${PREFIX}File ${profile_filename} doesn't exist\"\n    exit 1\n  fi\n\n  # Get some variables from the build system\n  local var_profile=\"./.var.profile\"\n  if [ -f ${var_profile} ]; then\n      source ${var_profile}\n  elif [ -z \"$BP_SYMBOLS\" ]; then\n    echo \"${PREFIX}Unable to locate ${var_profile}\"\n    echo \"${PREFIX}You need to build b2g in order to get symbolic information\"\n    exit 1\n  fi\n\n  local sym_filename=\"${profile_filename%.*}.sym\"\n  echo \"${PREFIX}Adding symbols to ${profile_filename} and creating ${sym_filename} ...\"\n  ./scripts/profile-symbolicate.py \\\n    $BP_SYMBOLS -o \"${sym_filename}\" \"${profile_filename}\" > /dev/null\n  CMD_SYMBOLICATE_PROFILE=\"$sym_filename\"\n}\n\n###########################################################################\n#\n# Tries to stop b2g\n#\nstop_b2g() {\n  local pid\n  local attempt\n  if is_profiler_running $(get_b2g_pid); then\n    echo -n \"Profiler appears to be running.\"\n  else\n    # Note: stop sends SIGKILL, but only if b2g was launched via start\n    # If b2g was launched via the debugger or the profiler, then stop is\n    # essentially a no-op\n    echo -n \"Stopping b2g ...\"\n    ${ADB} shell \"stop b2g\"\n    for attempt in 1 2 3 4 5; do\n      pid=$(${ADB} shell 'toolbox ps b2g | (read header; read user pid rest; echo -n ${pid})')\n      if [ \"${pid}\" == \"\" ]; then\n        break\n      fi\n      echo -n \".\"\n      sleep 1\n    done\n  fi\n\n  # Now do a cleanup check and make sure that all of the b2g pids are actually gone\n  clear_pids\n  get_pids\n  if [ \"${#B2G_PIDS[*]}\" -gt 0 ]; then\n    echo\n    echo -n \"Killing b2g ...\"\n    for pid in ${B2G_PIDS[*]}; do\n      ${ADB} shell \"kill -9 ${pid}\"\n    done\n    for attempt in 1 2 3 4 5; do\n      clear_pids\n      get_pids\n      if [ \"${#B2G_PIDS[*]}\" == 0 ]; then\n        break\n      fi\n      echo -n \".\"\n      sleep 1\n    done\n  fi\n\n  # And if things still haven't shutdown, then give up\n  clear_pids\n  get_pids\n  if [ \"${#B2G_PIDS[*]}\" -gt 0 ]; then\n    echo\n    echo \"b2g doesn't seem to want to go away. Try rebooting.\"\n    exit 1\n  fi\n  echo \" stopped.\"\n}\n\n###########################################################################\n#\n# Determine if the first argument is a valid command and execute the\n# corresponding function if it is.\n#\nallowed_commands=$(declare -F | sed -ne 's/declare -f cmd_\\(.*\\)/\\1/p' | tr \"\\n\" \" \")\ncommand=$1\nif [ \"${command}\" == \"\" ]; then\n  cmd_help\n  exit 0\nfi\nif [ \"${allowed_commands/*${command}*/${command}}\" == \"${command}\" ]; then\n  shift\n  cmd_${command} \"$@\"\nelse\n  echo \"Unrecognized command: '${command}'\"\nfi\n\n"
        },
        {
          "name": "repo",
          "type": "blob",
          "size": 26.6123046875,
          "content": "#!/usr/bin/env python\n\n## repo default configuration\n##\nREPO_URL = 'https://gerrit.googlesource.com/git-repo'\nREPO_REV = 'stable'\n\n# Copyright (C) 2008 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# increment this whenever we make important changes to this script\nVERSION = (1, 22)\n\n# increment this if the MAINTAINER_KEYS block is modified\nKEYRING_VERSION = (1, 2)\nMAINTAINER_KEYS = \"\"\"\n\n     Repo Maintainer <repo@android.kernel.org>\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: GnuPG v1.4.2.2 (GNU/Linux)\n\nmQGiBEj3ugERBACrLJh/ZPyVSKeClMuznFIrsQ+hpNnmJGw1a9GXKYKk8qHPhAZf\nWKtrBqAVMNRLhL85oSlekRz98u41H5si5zcuv+IXJDF5MJYcB8f22wAy15lUqPWi\nVCkk1l8qqLiuW0fo+ZkPY5qOgrvc0HW1SmdH649uNwqCbcKb6CxaTxzhOwCgj3AP\nxI1WfzLqdJjsm1Nq98L0cLcD/iNsILCuw44PRds3J75YP0pze7YF/6WFMB6QSFGu\naUX1FsTTztKNXGms8i5b2l1B8JaLRWq/jOnZzyl1zrUJhkc0JgyZW5oNLGyWGhKD\nFxp5YpHuIuMImopWEMFIRQNrvlg+YVK8t3FpdI1RY0LYqha8pPzANhEYgSfoVzOb\nfbfbA/4ioOrxy8ifSoga7ITyZMA+XbW8bx33WXutO9N7SPKS/AK2JpasSEVLZcON\nae5hvAEGVXKxVPDjJBmIc2cOe7kOKSi3OxLzBqrjS2rnjiP4o0ekhZIe4+ocwVOg\ne0PLlH5avCqihGRhpoqDRsmpzSHzJIxtoeb+GgGEX8KkUsVAhbQpUmVwbyBNYWlu\ndGFpbmVyIDxyZXBvQGFuZHJvaWQua2VybmVsLm9yZz6IYAQTEQIAIAUCSPe6AQIb\nAwYLCQgHAwIEFQIIAwQWAgMBAh4BAheAAAoJEBZTDV6SD1xl1GEAn0x/OKQpy7qI\n6G73NJviU0IUMtftAKCFMUhGb/0bZvQ8Rm3QCUpWHyEIu7kEDQRI97ogEBAA2wI6\n5fs9y/rMwD6dkD/vK9v4C9mOn1IL5JCPYMJBVSci+9ED4ChzYvfq7wOcj9qIvaE0\nGwCt2ar7Q56me5J+byhSb32Rqsw/r3Vo5cZMH80N4cjesGuSXOGyEWTe4HYoxnHv\ngF4EKI2LK7xfTUcxMtlyn52sUpkfKsCpUhFvdmbAiJE+jCkQZr1Z8u2KphV79Ou+\nP1N5IXY/XWOlq48Qf4MWCYlJFrB07xjUjLKMPDNDnm58L5byDrP/eHysKexpbakL\nxCmYyfT6DV1SWLblpd2hie0sL3YejdtuBMYMS2rI7Yxb8kGuqkz+9l1qhwJtei94\n5MaretDy/d/JH/pRYkRf7L+ke7dpzrP+aJmcz9P1e6gq4NJsWejaALVASBiioqNf\nQmtqSVzF1wkR5avZkFHuYvj6V/t1RrOZTXxkSk18KFMJRBZrdHFCWbc5qrVxUB6e\nN5pja0NFIUCigLBV1c6I2DwiuboMNh18VtJJh+nwWeez/RueN4ig59gRTtkcc0PR\n35tX2DR8+xCCFVW/NcJ4PSePYzCuuLvp1vEDHnj41R52Fz51hgddT4rBsp0nL+5I\nsocSOIIezw8T9vVzMY4ArCKFAVu2IVyBcahTfBS8q5EM63mONU6UVJEozfGljiMw\nxuQ7JwKcw0AUEKTKG7aBgBaTAgT8TOevpvlw91cAAwUP/jRkyVi/0WAb0qlEaq/S\nouWxX1faR+vU3b+Y2/DGjtXQMzG0qpetaTHC/AxxHpgt/dCkWI6ljYDnxgPLwG0a\nOasm94BjZc6vZwf1opFZUKsjOAAxRxNZyjUJKe4UZVuMTk6zo27Nt3LMnc0FO47v\nFcOjRyquvgNOS818irVHUf12waDx8gszKxQTTtFxU5/ePB2jZmhP6oXSe4K/LG5T\n+WBRPDrHiGPhCzJRzm9BP0lTnGCAj3o9W90STZa65RK7IaYpC8TB35JTBEbrrNCp\nw6lzd74LnNEp5eMlKDnXzUAgAH0yzCQeMl7t33QCdYx2hRs2wtTQSjGfAiNmj/WW\nVl5Jn+2jCDnRLenKHwVRFsBX2e0BiRWt/i9Y8fjorLCXVj4z+7yW6DawdLkJorEo\np3v5ILwfC7hVx4jHSnOgZ65L9s8EQdVr1ckN9243yta7rNgwfcqb60ILMFF1BRk/\n0V7wCL+68UwwiQDvyMOQuqkysKLSDCLb7BFcyA7j6KG+5hpsREstFX2wK1yKeraz\n5xGrFy8tfAaeBMIQ17gvFSp/suc9DYO0ICK2BISzq+F+ZiAKsjMYOBNdH/h0zobQ\nHTHs37+/QLMomGEGKZMWi0dShU2J5mNRQu3Hhxl3hHDVbt5CeJBb26aQcQrFz69W\nzE3GNvmJosh6leayjtI9P2A6iEkEGBECAAkFAkj3uiACGwwACgkQFlMNXpIPXGWp\nTACbBS+Up3RpfYVfd63c1cDdlru13pQAn3NQy/SN858MkxN+zym86UBgOad2\n=CMiZ\n-----END PGP PUBLIC KEY BLOCK-----\n\n     Conley Owens <cco3@android.com>\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\n\nmQENBFHRvc8BCADFg45Xx/y6QDC+T7Y/gGc7vx0ww7qfOwIKlAZ9xG3qKunMxo+S\nhPCnzEl3cq+6I1Ww/ndop/HB3N3toPXRCoN8Vs4/Hc7by+SnaLFnacrm+tV5/OgT\nV37Lzt8lhay1Kl+YfpFwHYYpIEBLFV9knyfRXS/428W2qhdzYfvB15/AasRmwmor\npy4NIzSs8UD/SPr1ihqNCdZM76+MQyN5HMYXW/ALZXUFG0pwluHFA7hrfPG74i8C\nzMiP7qvMWIl/r/jtzHioH1dRKgbod+LZsrDJ8mBaqsZaDmNJMhss9g76XvfMyLra\n9DI9/iFuBpGzeqBv0hwOGQspLRrEoyTeR6n1ABEBAAG0H0NvbmxleSBPd2VucyA8\nY2NvM0BhbmRyb2lkLmNvbT6JATgEEwECACIFAlHRvc8CGwMGCwkIBwMCBhUIAgkK\nCwQWAgMBAh4BAheAAAoJEGe35EhpKzgsP6AIAJKJmNtn4l7hkYHKHFSo3egb6RjQ\nzEIP3MFTcu8HFX1kF1ZFbrp7xqurLaE53kEkKuAAvjJDAgI8mcZHP1JyplubqjQA\nxvv84gK+OGP3Xk+QK1ZjUQSbjOpjEiSZpRhWcHci3dgOUH4blJfByHw25hlgHowd\na/2PrNKZVcJ92YienaxxGjcXEUcd0uYEG2+rwllQigFcnMFDhr9B71MfalRHjFKE\nfmdoypqLrri61YBc59P88Rw2/WUpTQjgNubSqa3A2+CKdaRyaRw+2fdF4TdR0h8W\nzbg+lbaPtJHsV+3mJC7fq26MiJDRJa5ZztpMn8su20gbLgi2ShBOaHAYDDi5AQ0E\nUdG9zwEIAMoOBq+QLNozAhxOOl5GL3StTStGRgPRXINfmViTsihrqGCWBBUfXlUE\nOytC0mYcrDUQev/8ToVoyqw+iGSwDkcSXkrEUCKFtHV/GECWtk1keyHgR10YKI1R\nmquSXoubWGqPeG1PAI74XWaRx8UrL8uCXUtmD8Q5J7mDjKR5NpxaXrwlA0bKsf2E\nGp9tu1kKauuToZhWHMRMqYSOGikQJwWSFYKT1KdNcOXLQF6+bfoJ6sjVYdwfmNQL\nIxn8QVhoTDedcqClSWB17VDEFDFa7MmqXZz2qtM3X1R/MUMHqPtegQzBGNhRdnI2\nV45+1Nnx/uuCxDbeI4RbHzujnxDiq70AEQEAAYkBHwQYAQIACQUCUdG9zwIbDAAK\nCRBnt+RIaSs4LNVeB/0Y2pZ8I7gAAcEM0Xw8drr4omg2fUoK1J33ozlA/RxeA/lJ\nI3KnyCDTpXuIeBKPGkdL8uMATC9Z8DnBBajRlftNDVZS3Hz4G09G9QpMojvJkFJV\nBy+01Flw/X+eeN8NpqSuLV4W+AjEO8at/VvgKr1AFvBRdZ7GkpI1o6DgPe7ZqX+1\ndzQZt3e13W0rVBb/bUgx9iSLoeWP3aq/k+/GRGOR+S6F6BBSl0SQ2EF2+dIywb1x\nJuinEP+AwLAUZ1Bsx9ISC0Agpk2VeHXPL3FGhroEmoMvBzO0kTFGyoeT7PR/BfKv\n+H/g3HsL2LOB9uoIm8/5p2TTU5ttYCXMHhQZ81AY\n=AUp4\n-----END PGP PUBLIC KEY BLOCK-----\n\"\"\"\n\nGIT = 'git'                     # our git command\nMIN_GIT_VERSION = (1, 7, 2)     # minimum supported git version\nrepodir = '.repo'               # name of repo's private directory\nS_repo = 'repo'                 # special repo repository\nS_manifests = 'manifests'       # special manifest repository\nREPO_MAIN = S_repo + '/main.py' # main script\nMIN_PYTHON_VERSION = (2, 6)     # minimum supported python version\nGITC_CONFIG_FILE = '/gitc/.config'\nGITC_FS_ROOT_DIR = '/gitc/manifest-rw/'\n\n\nimport errno\nimport optparse\nimport os\nimport re\nimport shutil\nimport stat\nimport subprocess\nimport sys\n\nif sys.version_info[0] == 3:\n  import urllib.request\n  import urllib.error\nelse:\n  import imp\n  import urllib2\n  urllib = imp.new_module('urllib')\n  urllib.request = urllib2\n  urllib.error = urllib2\n\n\ndef _print(*objects, **kwargs):\n  sep = kwargs.get('sep', ' ')\n  end = kwargs.get('end', '\\n')\n  out = kwargs.get('file', sys.stdout)\n  out.write(sep.join(objects) + end)\n\n\n# Python version check\nver = sys.version_info\nif (ver[0], ver[1]) < MIN_PYTHON_VERSION:\n  _print('error: Python version %s unsupported.\\n'\n         'Please use Python 2.6 - 2.7 instead.'\n         % sys.version.split(' ')[0], file=sys.stderr)\n  sys.exit(1)\n\nhome_dot_repo = os.path.expanduser('~/.repoconfig')\ngpg_dir = os.path.join(home_dot_repo, 'gnupg')\n\nextra_args = []\ninit_optparse = optparse.OptionParser(usage=\"repo init -u url [options]\")\n\n# Logging\ngroup = init_optparse.add_option_group('Logging options')\ngroup.add_option('-q', '--quiet',\n                 dest=\"quiet\", action=\"store_true\", default=False,\n                 help=\"be quiet\")\n\n# Manifest\ngroup = init_optparse.add_option_group('Manifest options')\ngroup.add_option('-u', '--manifest-url',\n                 dest='manifest_url',\n                 help='manifest repository location', metavar='URL')\ngroup.add_option('-b', '--manifest-branch',\n                 dest='manifest_branch',\n                 help='manifest branch or revision', metavar='REVISION')\ngroup.add_option('-m', '--manifest-name',\n                 dest='manifest_name',\n                 help='initial manifest file', metavar='NAME.xml')\ngroup.add_option('--mirror',\n                 dest='mirror', action='store_true',\n                 help='create a replica of the remote repositories '\n                      'rather than a client working directory')\ngroup.add_option('--reference',\n                 dest='reference',\n                 help='location of mirror directory', metavar='DIR')\ngroup.add_option('--depth', type='int', default=None,\n                 dest='depth',\n                 help='create a shallow clone with given depth; see git clone')\ngroup.add_option('--archive',\n                 dest='archive', action='store_true',\n                 help='checkout an archive instead of a git repository for '\n                      'each project. See git archive.')\ngroup.add_option('-g', '--groups',\n                 dest='groups', default='default',\n                 help='restrict manifest projects to ones with specified '\n                      'group(s) [default|all|G1,G2,G3|G4,-G5,-G6]',\n                 metavar='GROUP')\ngroup.add_option('-p', '--platform',\n                 dest='platform', default=\"auto\",\n                 help='restrict manifest projects to ones with a specified '\n                      'platform group [auto|all|none|linux|darwin|...]',\n                 metavar='PLATFORM')\n\n\n# Tool\ngroup = init_optparse.add_option_group('repo Version options')\ngroup.add_option('--repo-url',\n                 dest='repo_url',\n                 help='repo repository location', metavar='URL')\ngroup.add_option('--repo-branch',\n                 dest='repo_branch',\n                 help='repo branch or revision', metavar='REVISION')\ngroup.add_option('--no-repo-verify',\n                 dest='no_repo_verify', action='store_true',\n                 help='do not verify repo source code')\n\n# Other\ngroup = init_optparse.add_option_group('Other options')\ngroup.add_option('--config-name',\n                 dest='config_name', action=\"store_true\", default=False,\n                 help='Always prompt for name/e-mail')\n\ndef _GitcInitOptions(init_optparse):\n  init_optparse.set_usage(\"repo gitc-init -u url -c client [options]\")\n  g = init_optparse.add_option_group('GITC options')\n  g.add_option('-f', '--manifest-file',\n               dest='manifest_file',\n               help='Optional manifest file to use for this GITC client.')\n  g.add_option('-c', '--gitc-client',\n               dest='gitc_client',\n               help='The name of the gitc_client instance to create or modify.')\n\n_gitc_manifest_dir = None\ndef get_gitc_manifest_dir():\n  global _gitc_manifest_dir\n  if _gitc_manifest_dir is None:\n    _gitc_manifest_dir = ''\n    try:\n      with open(GITC_CONFIG_FILE, 'r') as gitc_config:\n        for line in gitc_config:\n          match = re.match('gitc_dir=(?P<gitc_manifest_dir>.*)', line)\n          if match:\n            _gitc_manifest_dir = match.group('gitc_manifest_dir')\n    except IOError:\n      pass\n  return _gitc_manifest_dir\n\ndef gitc_parse_clientdir(gitc_fs_path):\n  \"\"\"Parse a path in the GITC FS and return its client name.\n\n  @param gitc_fs_path: A subdirectory path within the GITC_FS_ROOT_DIR.\n\n  @returns: The GITC client name\n  \"\"\"\n  if gitc_fs_path == GITC_FS_ROOT_DIR:\n    return None\n  if not gitc_fs_path.startswith(GITC_FS_ROOT_DIR):\n    manifest_dir = get_gitc_manifest_dir()\n    if manifest_dir == '':\n      return None\n    if manifest_dir[-1] != '/':\n      manifest_dir += '/'\n    if gitc_fs_path == manifest_dir:\n      return None\n    if not gitc_fs_path.startswith(manifest_dir):\n      return None\n    return gitc_fs_path.split(manifest_dir)[1].split('/')[0]\n  return gitc_fs_path.split(GITC_FS_ROOT_DIR)[1].split('/')[0]\n\nclass CloneFailure(Exception):\n  \"\"\"Indicate the remote clone of repo itself failed.\n  \"\"\"\n\n\ndef _Init(args, gitc_init=False):\n  \"\"\"Installs repo by cloning it over the network.\n  \"\"\"\n  if gitc_init:\n    _GitcInitOptions(init_optparse)\n  opt, args = init_optparse.parse_args(args)\n  if args:\n    init_optparse.print_usage()\n    sys.exit(1)\n\n  url = opt.repo_url\n  if not url:\n    url = REPO_URL\n    extra_args.append('--repo-url=%s' % url)\n\n  branch = opt.repo_branch\n  if not branch:\n    branch = REPO_REV\n    extra_args.append('--repo-branch=%s' % branch)\n\n  if branch.startswith('refs/heads/'):\n    branch = branch[len('refs/heads/'):]\n  if branch.startswith('refs/'):\n    _print(\"fatal: invalid branch name '%s'\" % branch, file=sys.stderr)\n    raise CloneFailure()\n\n  try:\n    if gitc_init:\n      gitc_manifest_dir = get_gitc_manifest_dir()\n      if not gitc_manifest_dir:\n        _print('fatal: GITC filesystem is not available. Exiting...',\n               file=sys.stderr)\n        sys.exit(1)\n      gitc_client = opt.gitc_client\n      if not gitc_client:\n        gitc_client = gitc_parse_clientdir(os.getcwd())\n      if not gitc_client:\n        _print('fatal: GITC client (-c) is required.', file=sys.stderr)\n        sys.exit(1)\n      client_dir = os.path.join(gitc_manifest_dir, gitc_client)\n      if not os.path.exists(client_dir):\n        os.makedirs(client_dir)\n      os.chdir(client_dir)\n      if os.path.exists(repodir):\n        # This GITC Client has already initialized repo so continue.\n        return\n\n    os.mkdir(repodir)\n  except OSError as e:\n    if e.errno != errno.EEXIST:\n      _print('fatal: cannot make %s directory: %s'\n             % (repodir, e.strerror), file=sys.stderr)\n      # Don't raise CloneFailure; that would delete the\n      # name. Instead exit immediately.\n      #\n      sys.exit(1)\n\n  _CheckGitVersion()\n  try:\n    if NeedSetupGnuPG():\n      can_verify = SetupGnuPG(opt.quiet)\n    else:\n      can_verify = True\n\n    dst = os.path.abspath(os.path.join(repodir, S_repo))\n    _Clone(url, dst, opt.quiet)\n\n    if can_verify and not opt.no_repo_verify:\n      rev = _Verify(dst, branch, opt.quiet)\n    else:\n      rev = 'refs/remotes/origin/%s^0' % branch\n\n    _Checkout(dst, branch, rev, opt.quiet)\n  except CloneFailure:\n    if opt.quiet:\n      _print('fatal: repo init failed; run without --quiet to see why',\n             file=sys.stderr)\n    raise\n\n\ndef ParseGitVersion(ver_str):\n  if not ver_str.startswith('git version '):\n    return None\n\n  num_ver_str = ver_str[len('git version '):].strip().split('-')[0]\n  to_tuple = []\n  for num_str in num_ver_str.split('.')[:3]:\n    if num_str.isdigit():\n      to_tuple.append(int(num_str))\n    else:\n      to_tuple.append(0)\n  return tuple(to_tuple)\n\n\ndef _CheckGitVersion():\n  cmd = [GIT, '--version']\n  try:\n    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n  except OSError as e:\n    _print(file=sys.stderr)\n    _print(\"fatal: '%s' is not available\" % GIT, file=sys.stderr)\n    _print('fatal: %s' % e, file=sys.stderr)\n    _print(file=sys.stderr)\n    _print('Please make sure %s is installed and in your path.' % GIT,\n           file=sys.stderr)\n    raise CloneFailure()\n\n  ver_str = proc.stdout.read().strip()\n  proc.stdout.close()\n  proc.wait()\n\n  ver_act = ParseGitVersion(ver_str)\n  if ver_act is None:\n    _print('error: \"%s\" unsupported' % ver_str, file=sys.stderr)\n    raise CloneFailure()\n\n  if ver_act < MIN_GIT_VERSION:\n    need = '.'.join(map(str, MIN_GIT_VERSION))\n    _print('fatal: git %s or later required' % need, file=sys.stderr)\n    raise CloneFailure()\n\n\ndef NeedSetupGnuPG():\n  if not os.path.isdir(home_dot_repo):\n    return True\n\n  kv = os.path.join(home_dot_repo, 'keyring-version')\n  if not os.path.exists(kv):\n    return True\n\n  kv = open(kv).read()\n  if not kv:\n    return True\n\n  kv = tuple(map(int, kv.split('.')))\n  if kv < KEYRING_VERSION:\n    return True\n  return False\n\n\ndef SetupGnuPG(quiet):\n  try:\n    os.mkdir(home_dot_repo)\n  except OSError as e:\n    if e.errno != errno.EEXIST:\n      _print('fatal: cannot make %s directory: %s'\n             % (home_dot_repo, e.strerror), file=sys.stderr)\n      sys.exit(1)\n\n  try:\n    os.mkdir(gpg_dir, stat.S_IRWXU)\n  except OSError as e:\n    if e.errno != errno.EEXIST:\n      _print('fatal: cannot make %s directory: %s' % (gpg_dir, e.strerror),\n             file=sys.stderr)\n      sys.exit(1)\n\n  env = os.environ.copy()\n  env['GNUPGHOME'] = gpg_dir.encode()\n\n  cmd = ['gpg', '--import']\n  try:\n    proc = subprocess.Popen(cmd,\n                            env = env,\n                            stdin = subprocess.PIPE)\n  except OSError as e:\n    if not quiet:\n      _print('warning: gpg (GnuPG) is not available.', file=sys.stderr)\n      _print('warning: Installing it is strongly encouraged.', file=sys.stderr)\n      _print(file=sys.stderr)\n    return False\n\n  proc.stdin.write(MAINTAINER_KEYS)\n  proc.stdin.close()\n\n  if proc.wait() != 0:\n    _print('fatal: registering repo maintainer keys failed', file=sys.stderr)\n    sys.exit(1)\n  _print()\n\n  fd = open(os.path.join(home_dot_repo, 'keyring-version'), 'w')\n  fd.write('.'.join(map(str, KEYRING_VERSION)) + '\\n')\n  fd.close()\n  return True\n\n\ndef _SetConfig(local, name, value):\n  \"\"\"Set a git configuration option to the specified value.\n  \"\"\"\n  cmd = [GIT, 'config', name, value]\n  if subprocess.Popen(cmd, cwd = local).wait() != 0:\n    raise CloneFailure()\n\n\ndef _InitHttp():\n  handlers = []\n\n  mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n  try:\n    import netrc\n    n = netrc.netrc()\n    for host in n.hosts:\n      p = n.hosts[host]\n      mgr.add_password(p[1], 'http://%s/'  % host, p[0], p[2])\n      mgr.add_password(p[1], 'https://%s/' % host, p[0], p[2])\n  except:\n    pass\n  handlers.append(urllib.request.HTTPBasicAuthHandler(mgr))\n  handlers.append(urllib.request.HTTPDigestAuthHandler(mgr))\n\n  if 'http_proxy' in os.environ:\n    url = os.environ['http_proxy']\n    handlers.append(urllib.request.ProxyHandler({'http': url, 'https': url}))\n  if 'REPO_CURL_VERBOSE' in os.environ:\n    handlers.append(urllib.request.HTTPHandler(debuglevel=1))\n    handlers.append(urllib.request.HTTPSHandler(debuglevel=1))\n  urllib.request.install_opener(urllib.request.build_opener(*handlers))\n\ndef _Fetch(url, local, src, quiet):\n  if not quiet:\n    _print('Get %s' % url, file=sys.stderr)\n\n  cmd = [GIT, 'fetch']\n  if quiet:\n    cmd.append('--quiet')\n    err = subprocess.PIPE\n  else:\n    err = None\n  cmd.append(src)\n  cmd.append('+refs/heads/*:refs/remotes/origin/*')\n  cmd.append('refs/tags/*:refs/tags/*')\n\n  proc = subprocess.Popen(cmd, cwd = local, stderr = err)\n  if err:\n    proc.stderr.read()\n    proc.stderr.close()\n  if proc.wait() != 0:\n    raise CloneFailure()\n\ndef _DownloadBundle(url, local, quiet):\n  if not url.endswith('/'):\n    url += '/'\n  url += 'clone.bundle'\n\n  proc = subprocess.Popen(\n    [GIT, 'config', '--get-regexp', 'url.*.insteadof'],\n    cwd = local,\n    stdout = subprocess.PIPE)\n  for line in proc.stdout:\n    m = re.compile(r'^url\\.(.*)\\.insteadof (.*)$').match(line)\n    if m:\n      new_url = m.group(1)\n      old_url = m.group(2)\n      if url.startswith(old_url):\n        url = new_url + url[len(old_url):]\n        break\n  proc.stdout.close()\n  proc.wait()\n\n  if not url.startswith('http:') and not url.startswith('https:'):\n    return False\n\n  dest = open(os.path.join(local, '.git', 'clone.bundle'), 'w+b')\n  try:\n    try:\n      r = urllib.request.urlopen(url)\n    except urllib.error.HTTPError as e:\n      if e.code in [401, 403, 404]:\n        return False\n      _print('fatal: Cannot get %s' % url, file=sys.stderr)\n      _print('fatal: HTTP error %s' % e.code, file=sys.stderr)\n      raise CloneFailure()\n    except urllib.error.URLError as e:\n      _print('fatal: Cannot get %s' % url, file=sys.stderr)\n      _print('fatal: error %s' % e.reason, file=sys.stderr)\n      raise CloneFailure()\n    try:\n      if not quiet:\n        _print('Get %s' % url, file=sys.stderr)\n      while True:\n        buf = r.read(8192)\n        if buf == '':\n          return True\n        dest.write(buf)\n    finally:\n      r.close()\n  finally:\n    dest.close()\n\ndef _ImportBundle(local):\n  path = os.path.join(local, '.git', 'clone.bundle')\n  try:\n    _Fetch(local, local, path, True)\n  finally:\n    os.remove(path)\n\ndef _Clone(url, local, quiet):\n  \"\"\"Clones a git repository to a new subdirectory of repodir\n  \"\"\"\n  try:\n    os.mkdir(local)\n  except OSError as e:\n    _print('fatal: cannot make %s directory: %s' % (local, e.strerror),\n           file=sys.stderr)\n    raise CloneFailure()\n\n  cmd = [GIT, 'init', '--quiet']\n  try:\n    proc = subprocess.Popen(cmd, cwd = local)\n  except OSError as e:\n    _print(file=sys.stderr)\n    _print(\"fatal: '%s' is not available\" % GIT, file=sys.stderr)\n    _print('fatal: %s' % e, file=sys.stderr)\n    _print(file=sys.stderr)\n    _print('Please make sure %s is installed and in your path.' % GIT,\n          file=sys.stderr)\n    raise CloneFailure()\n  if proc.wait() != 0:\n    _print('fatal: could not create %s' % local, file=sys.stderr)\n    raise CloneFailure()\n\n  _InitHttp()\n  _SetConfig(local, 'remote.origin.url', url)\n  _SetConfig(local, 'remote.origin.fetch',\n                    '+refs/heads/*:refs/remotes/origin/*')\n  if _DownloadBundle(url, local, quiet):\n    _ImportBundle(local)\n  _Fetch(url, local, 'origin', quiet)\n\n\ndef _Verify(cwd, branch, quiet):\n  \"\"\"Verify the branch has been signed by a tag.\n  \"\"\"\n  cmd = [GIT, 'describe', 'origin/%s' % branch]\n  proc = subprocess.Popen(cmd,\n                          stdout=subprocess.PIPE,\n                          stderr=subprocess.PIPE,\n                          cwd = cwd)\n  cur = proc.stdout.read().strip()\n  proc.stdout.close()\n\n  proc.stderr.read()\n  proc.stderr.close()\n\n  if proc.wait() != 0 or not cur:\n    _print(file=sys.stderr)\n    _print(\"fatal: branch '%s' has not been signed\" % branch, file=sys.stderr)\n    raise CloneFailure()\n\n  m = re.compile(r'^(.*)-[0-9]{1,}-g[0-9a-f]{1,}$').match(cur)\n  if m:\n    cur = m.group(1)\n    if not quiet:\n      _print(file=sys.stderr)\n      _print(\"info: Ignoring branch '%s'; using tagged release '%s'\"\n            % (branch, cur), file=sys.stderr)\n      _print(file=sys.stderr)\n\n  env = os.environ.copy()\n  env['GNUPGHOME'] = gpg_dir.encode()\n\n  cmd = [GIT, 'tag', '-v', cur]\n  proc = subprocess.Popen(cmd,\n                          stdout = subprocess.PIPE,\n                          stderr = subprocess.PIPE,\n                          cwd = cwd,\n                          env = env)\n  out = proc.stdout.read()\n  proc.stdout.close()\n\n  err = proc.stderr.read()\n  proc.stderr.close()\n\n  if proc.wait() != 0:\n    _print(file=sys.stderr)\n    _print(out, file=sys.stderr)\n    _print(err, file=sys.stderr)\n    _print(file=sys.stderr)\n    raise CloneFailure()\n  return '%s^0' % cur\n\n\ndef _Checkout(cwd, branch, rev, quiet):\n  \"\"\"Checkout an upstream branch into the repository and track it.\n  \"\"\"\n  cmd = [GIT, 'update-ref', 'refs/heads/default', rev]\n  if subprocess.Popen(cmd, cwd = cwd).wait() != 0:\n    raise CloneFailure()\n\n  _SetConfig(cwd, 'branch.default.remote', 'origin')\n  _SetConfig(cwd, 'branch.default.merge', 'refs/heads/%s' % branch)\n\n  cmd = [GIT, 'symbolic-ref', 'HEAD', 'refs/heads/default']\n  if subprocess.Popen(cmd, cwd = cwd).wait() != 0:\n    raise CloneFailure()\n\n  cmd = [GIT, 'read-tree', '--reset', '-u']\n  if not quiet:\n    cmd.append('-v')\n  cmd.append('HEAD')\n  if subprocess.Popen(cmd, cwd = cwd).wait() != 0:\n    raise CloneFailure()\n\n\ndef _FindRepo():\n  \"\"\"Look for a repo installation, starting at the current directory.\n  \"\"\"\n  curdir = os.getcwd()\n  repo = None\n\n  olddir = None\n  while curdir != '/' \\\n    and curdir != olddir \\\n    and not repo:\n    repo = os.path.join(curdir, repodir, REPO_MAIN)\n    if not os.path.isfile(repo):\n      repo = None\n      olddir = curdir\n      curdir = os.path.dirname(curdir)\n  return (repo, os.path.join(curdir, repodir))\n\n\nclass _Options:\n  help = False\n\n\ndef _ParseArguments(args):\n  cmd = None\n  opt = _Options()\n  arg = []\n\n  for i in range(len(args)):\n    a = args[i]\n    if a == '-h' or a == '--help':\n      opt.help = True\n\n    elif not a.startswith('-'):\n      cmd = a\n      arg = args[i + 1:]\n      break\n  return cmd, opt, arg\n\n\ndef _Usage():\n  gitc_usage = \"\"\n  if get_gitc_manifest_dir():\n    gitc_usage = \"  gitc-init Initialize a GITC Client.\\n\"\n\n  _print(\n\"\"\"usage: repo COMMAND [ARGS]\n\nrepo is not yet installed.  Use \"repo init\" to install it here.\n\nThe most commonly used repo commands are:\n\n  init      Install repo in the current working directory\n\"\"\" + gitc_usage +\n\"\"\"  help      Display detailed help on a command\n\nFor access to the full online help, install repo (\"repo init\").\n\"\"\", file=sys.stderr)\n  sys.exit(1)\n\n\ndef _Help(args):\n  if args:\n    if args[0] == 'init':\n      init_optparse.print_help()\n      sys.exit(0)\n    elif args[0] == 'gitc-init':\n      _GitcInitOptions(init_optparse)\n      init_optparse.print_help()\n      sys.exit(0)\n    else:\n      _print(\"error: '%s' is not a bootstrap command.\\n\"\n             '        For access to online help, install repo (\"repo init\").'\n             % args[0], file=sys.stderr)\n  else:\n    _Usage()\n  sys.exit(1)\n\n\ndef _NotInstalled():\n  _print('error: repo is not installed.  Use \"repo init\" to install it here.',\n         file=sys.stderr)\n  sys.exit(1)\n\n\ndef _NoCommands(cmd):\n  _print(\"\"\"error: command '%s' requires repo to be installed first.\n         Use \"repo init\" to install it here.\"\"\" % cmd, file=sys.stderr)\n  sys.exit(1)\n\n\ndef _RunSelf(wrapper_path):\n  my_dir = os.path.dirname(wrapper_path)\n  my_main = os.path.join(my_dir, 'main.py')\n  my_git = os.path.join(my_dir, '.git')\n\n  if os.path.isfile(my_main) and os.path.isdir(my_git):\n    for name in ['git_config.py',\n                 'project.py',\n                 'subcmds']:\n      if not os.path.exists(os.path.join(my_dir, name)):\n        return None, None\n    return my_main, my_git\n  return None, None\n\n\ndef _SetDefaultsTo(gitdir):\n  global REPO_URL\n  global REPO_REV\n\n  REPO_URL = gitdir\n  proc = subprocess.Popen([GIT,\n                           '--git-dir=%s' % gitdir,\n                           'symbolic-ref',\n                           'HEAD'],\n                          stdout = subprocess.PIPE,\n                          stderr = subprocess.PIPE)\n  REPO_REV = proc.stdout.read().strip()\n  proc.stdout.close()\n\n  proc.stderr.read()\n  proc.stderr.close()\n\n  if proc.wait() != 0:\n    _print('fatal: %s has no current branch' % gitdir, file=sys.stderr)\n    sys.exit(1)\n\n\ndef main(orig_args):\n  cmd, opt, args = _ParseArguments(orig_args)\n\n  repo_main, rel_repo_dir = None, None\n  # Don't use the local repo copy, make sure to switch to the gitc client first.\n  if cmd != 'gitc-init':\n    repo_main, rel_repo_dir = _FindRepo()\n\n  wrapper_path = os.path.abspath(__file__)\n  my_main, my_git = _RunSelf(wrapper_path)\n\n  cwd = os.getcwd()\n  if get_gitc_manifest_dir() and cwd.startswith(get_gitc_manifest_dir()):\n    _print('error: repo cannot be used in the GITC local manifest directory.'\n           '\\nIf you want to work on this GITC client please rerun this '\n           'command from the corresponding client under /gitc/', file=sys.stderr)\n    sys.exit(1)\n  if not repo_main:\n    if opt.help:\n      _Usage()\n    if cmd == 'help':\n      _Help(args)\n    if not cmd:\n      _NotInstalled()\n    if cmd == 'init' or cmd == 'gitc-init':\n      if my_git:\n        _SetDefaultsTo(my_git)\n      try:\n        _Init(args, gitc_init=(cmd == 'gitc-init'))\n      except CloneFailure:\n        shutil.rmtree(os.path.join(repodir, S_repo), ignore_errors=True)\n        sys.exit(1)\n      repo_main, rel_repo_dir = _FindRepo()\n    else:\n      _NoCommands(cmd)\n\n  if my_main:\n    repo_main = my_main\n\n  ver_str = '.'.join(map(str, VERSION))\n  me = [sys.executable, repo_main,\n        '--repo-dir=%s' % rel_repo_dir,\n        '--wrapper-version=%s' % ver_str,\n        '--wrapper-path=%s' % wrapper_path,\n        '--']\n  me.extend(orig_args)\n  me.extend(extra_args)\n  try:\n    os.execv(sys.executable, me)\n  except OSError as e:\n    _print(\"fatal: unable to start %s\" % repo_main, file=sys.stderr)\n    _print(\"fatal: %s\" % e, file=sys.stderr)\n    sys.exit(148)\n\n\nif __name__ == '__main__':\n  if ver[0] == 3:\n    _print('warning: Python 3 support is currently experimental. YMMV.\\n'\n           'Please use Python 2.6 - 2.7 instead.',\n           file=sys.stderr)\n  main(sys.argv[1:])\n"
        },
        {
          "name": "run-adb-remote.sh",
          "type": "blob",
          "size": 0.9365234375,
          "content": "#!/bin/bash\n#set -x\n\nADB=${ADB:-adb}\nif [ ! -f \"`which \\\"$ADB\\\"`\" ]; then\n\tADB=out/host/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/bin/adb\nfi\n\nif [ \"$1\" = \"\" ] || [ \"$1\" = \"connect\" ]; then\n\tTARGET_IP=$($ADB shell netcfg | grep wlan0 | tr -s ' ' | cut -d' ' -f3 | cut -d'/' -f1)\n\tADB_PORT=$((20000 + $(id -u) % 10000))\n\tTARGET_DEV=$TARGET_IP:$ADB_PORT\n\techo \"Target IP: $TARGET_IP\"\n\techo \"ADB port:  $ADB_PORT\"\n\n\t$ADB tcpip $ADB_PORT > /dev/null\n\tif [ \"$?\" != \"0\" ] || [ -n \"$($ADB connect $TARGET_DEV | grep 'unable')\" ]; then\n\t\techo \"Fail to establish the connection with TCP/IP!\"\n\t\texit 1\n\telse\n\t\techo \"Connected to the device at ${TARGET_DEV}.\"\n\tfi\nelif [ \"$1\" = \"disconnect\" ]; then\n\tTARGET_DEV=$($ADB devices | grep -oE \"([[:digit:]]+\\.){3}[[:digit:]]+:[[:digit:]]+\")\n\tif [ \"$TARGET_DEV\" != \"\" ]; then\n\t\t$ADB disconnect $TARGET_DEV > /dev/null\n\t\techo \"Already disconnected at ${TARGET_DEV}.\"\n\telse\n\t\techo \"No device connected with TCP/IP!\"\n\tfi\nfi\n\n"
        },
        {
          "name": "run-ddd.sh",
          "type": "blob",
          "size": 0.009765625,
          "content": "run-gdb.sh"
        },
        {
          "name": "run-emulator.sh",
          "type": "blob",
          "size": 1.8876953125,
          "content": "#!/bin/bash\n\n# Get full path from where the script was executed, full path is needed to run emulator succesfully\nB2G_HOME=$(cd $(dirname $BASH_SOURCE); pwd)\n\n. $B2G_HOME/load-config.sh\n\nDEVICE=${DEVICE:-generic}\n\nTOOLS_PATH=$B2G_HOME/out/host/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/bin\n\nDBG_CMD=\"\"\nif [ x\"$DBG\" != x\"\" ]; then\n    DBG_CMD=\"gdb -args\"\nfi\nTAIL_ARGS=\"\"\nif [ x\"$GDBSERVER\" != x\"\" ]; then\n    TAIL_ARGS=\"$TAIL_ARGS -s -S\"\nfi\n\ndns_servers=\"\"\nif [ x\"$B2G_DNS_SERVER\" != x\"\" ]; then\n    dns_servers=$B2G_DNS_SERVER\nfi\n\n# DNS servers from command line arg override ones from environment variable.\nwhile [ $# -gt 0 ]; do\n    case \"$1\" in\n        --dns-server)\n            shift; dns_servers=$1 ;;\n        *)\n            break ;;\n    esac\n    shift\ndone\n\nemu_extra_args=\"\"\nif [ -n \"$dns_servers\" ]; then\n    emu_extra_args=\"$emu_extra_args -dns-server $dns_servers\"\nfi\n\nif [ \"$DEVICE\" = \"generic_x86\" ]; then\n    EMULATOR=$TOOLS_PATH/emulator-x86\n    KERNEL=$B2G_HOME/prebuilts/qemu-kernel/x86/kernel-qemu\nelse\n    EMULATOR=$TOOLS_PATH/emulator\n    KERNEL=$B2G_HOME/prebuilts/qemu-kernel/arm/kernel-qemu-armv7\n    TAIL_ARGS=\"$TAIL_ARGS -cpu cortex-a8\"\nfi\n\nSDCARD_SIZE=${SDCARD_SIZE:-512M}\nSDCARD_IMG=${SDCARD_IMG:-${B2G_HOME}/out/target/product/${DEVICE}/sdcard.img}\n\nif [ ! -f \"${SDCARD_IMG}\" ]; then\n  echo \"Creating sdcard image file with size: ${SDCARD_SIZE} ...\"\n  ${TOOLS_PATH}/mksdcard -l sdcard ${SDCARD_SIZE} ${SDCARD_IMG}\nfi\n\nexport DYLD_LIBRARY_PATH=\"$B2G_HOME/out/host/darwin-x86/lib\"\nexport PATH=$PATH:$TOOLS_PATH\n${DBG_CMD} $EMULATOR \\\n   -kernel $KERNEL \\\n   -sysdir $B2G_HOME/out/target/product/$DEVICE/ \\\n   -data $B2G_HOME/out/target/product/$DEVICE/userdata.img \\\n   -sdcard ${SDCARD_IMG} \\\n   -memory 512 \\\n   -partition-size 512 \\\n   -skindir $B2G_HOME/development/tools/emulator/skins \\\n   -skin HVGA \\\n   -verbose \\\n   -gpu on \\\n   -camera-back webcam0 \\\n   $emu_extra_args \\\n   -qemu $TAIL_ARGS\n"
        },
        {
          "name": "run-gdb.sh",
          "type": "blob",
          "size": 6.3935546875,
          "content": "#!/bin/bash\n#set -x\n\nget_pid_by_name() {\n    echo $($ADB shell \"toolbox ps '$1' | (read header; read user pid rest; echo -n \\$pid)\")\n}\n\nSCRIPT_NAME=$(basename $0)\n. load-config.sh\n\nADB=${ADB:-adb}\nif [ ! -f \"`which \\\"$ADB\\\"`\" ]; then\n\tADB=out/host/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/bin/adb\nfi\necho \"ADB Location: \" $ADB\n\n# Make sure that the adb server is running and that it's compatible with the\n# version of adb that we're using. Anytime you run adb it will kill the\n# running server if there is a mismatch, and it will automatically start\n# the server if it isn't running. Unfortunately, both of these activities\n# cause information to be printed, which can screw up any further command\n# which is trying to query information from the phone. So by starting\n# the server explicitly here, then we'll cause that output to go to this\n# command (which we ignore), and not wind up prepending output.\n#\n# For a clear example of this, try the following:\n#\n#   adb start-server\n#   x1=$(adb shell echo test)\n#   adb kill-server\n#   x2=$(adb shell echo test)\n#\n# and then compare x1 and x2 by using:\n#\n#   echo \"$x1\"\n#   echo \"$x2\"\n$ADB start-server\n\ncase $DEVICE in\n    generic_x86)\n        TARGET_ARCH=x86\n        TARGET_TRIPLE=i686-linux-android\n        ;;\n    fugu)\n        TARGET_ARCH=x86\n        TARGET_TRIPLE=x86_64-linux-android\n        ;;\n    *)\n        TARGET_ARCH=arm\n        TARGET_TRIPLE=arm-linux-androideabi\n        ;;\nesac\n\nHOST_OS=$(uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\")-x86\n\nif [ -z \"${GDB}\" ]; then\n   if [ -d prebuilts ]; then\n      GDB=prebuilts/gcc/${HOST_OS}/${TARGET_ARCH}/${TARGET_TRIPLE}-4.8/bin/${TARGET_TRIPLE}-gdb\n      # If new version doesn't exist fallback to old version.\n      [ -f \"${GDB}\" ] || GDB=prebuilts/gcc/${HOST_OS}/${TARGET_ARCH}/${TARGET_TRIPLE}-4.7/bin/${TARGET_TRIPLE}-gdb\n      [ -f \"${GDB}\" ] || GDB=prebuilts/gcc/${HOST_OS}/${TARGET_ARCH}/${TARGET_TRIPLE}-4.6/bin/${TARGET_TRIPLE}-gdb\n      PYTHON_DIR=prebuilts/python/${HOST_OS}/2.7.5\n      if [ -d $PYTHON_DIR ]; then\n        export PYTHONHOME=$PYTHON_DIR\n      fi\n   elif [ -d prebuilt ]; then\n      GDB=prebuilt/${HOST_OS}/toolchain/${TARGET_TRIPLE}-4.4.x/bin/${TARGET_TRIPLE}-gdb\n   else\n      echo \"Not sure where gdb is located. Override using GDB= or fix the script.\"\n      exit 1\n   fi\nfi\n\nB2G_BIN=/system/b2g/b2g\nGDBINIT=/tmp/b2g.gdbinit.$(whoami).$$\n\nGONK_OBJDIR=out/target/product/$DEVICE\nSYMDIR=$GONK_OBJDIR/symbols\n\nif [ \"$1\" != \"core\" ] ; then\n   GDBSERVER_PID=$(get_pid_by_name gdbserver)\n\n   if [ \"$1\" = \"vgdb\"  -a  -n \"$2\" ] ; then\n      GDB_PORT=\"$2\"\n   elif [ \"$1\" = \"attach\"  -a  -n \"$2\" ] ; then\n      B2G_PID=$2\n      if [ -z \"$($ADB ls /proc/$B2G_PID)\" ] ; then\n         ATTACH_TARGET=$B2G_PID\n         B2G_PID=$(get_pid_by_name \"$B2G_PID\")\n         if [ -z \"$B2G_PID\" ] ; then\n           echo Error: PID $ATTACH_TARGET is invalid\n           exit 1;\n         fi\n         echo \"Found $ATTACH_TARGET PID: $B2G_PID\"\n      fi\n      PROCESS_PORT=$((10000 + ($B2G_PID + $(id -u)) % 50000))\n      GDB_PORT=${GDB_PORT:-$PROCESS_PORT}\n      # cmdline is null separated\n      B2G_BIN=$($ADB shell \"cat /proc/$B2G_PID/cmdline\" | tr '\\0' '\\n' | head -1)\n   else\n      GDB_PORT=$((10000 + $(id -u) % 50000))\n      B2G_PID=$(get_pid_by_name b2g)\n   fi\n\n   for p in $GDBSERVER_PID ; do\n      $ADB shell \"cat /proc/$p/cmdline\" | grep -q :$GDB_PORT && ( \\\n         echo ..killing gdbserver pid $p\n         $ADB shell \"kill $p\"\n      ) || echo ..ignoring gdbserver pid $p\n\n   done\n\n   $ADB forward tcp:$GDB_PORT tcp:$GDB_PORT\nfi\n\nif [ \"$1\" = \"attach\" ]; then\n   if [ -z \"$B2G_PID\" ]; then\n      echo Error: No PID to attach to. B2G not running?\n      exit 1\n   fi\n\n   $ADB shell \"gdbserver :$GDB_PORT --attach $B2G_PID\" &\nelif [ \"$1\" == \"core\" ]; then\n   if [ -z \"$3\" ]; then\n     CORE_FILE=$2\n   else\n     B2G_BIN=$2\n     CORE_FILE=$3\n   fi\n\n   if [ \"$B2G_BIN\" == \"\" -o \"$CORE_FILE\" == \"\" ]; then\n     echo \"Usage: $SCRIPT_NAME core [bin] <core>\"\n     exit 1\n   fi\n\n   if [ ! -f $CORE_FILE ]; then\n     echo \"Error: $CORE_FILE not found.\"\n     exit 1\n   fi\nelif [ \"$1\" != \"vgdb\" ]; then\n   if [ -n \"$1\" ]; then\n      B2G_BIN=$1\n      shift\n   fi\n   [ -n \"$MOZ_PROFILER_STARTUP\" ] && GDBSERVER_ENV=\"$GDBSERVER_ENV MOZ_PROFILER_STARTUP=$MOZ_PROFILER_STARTUP \"\n   [ -n \"$MOZ_DEBUG_CHILD_PROCESS\" ] && GDBSERVER_ENV=\"$GDBSERVER_ENV MOZ_DEBUG_CHILD_PROCESS=$MOZ_DEBUG_CHILD_PROCESS \"\n   [ -n \"$MOZ_DEBUG_APP_PROCESS\" ] && GDBSERVER_ENV=\"$GDBSERVER_ENV MOZ_DEBUG_APP_PROCESS='$MOZ_DEBUG_APP_PROCESS' \"\n   [ -n \"$MOZ_IPC_MESSAGE_LOG\" ]     && GDBSERVER_ENV=\"$GDBSERVER_ENV MOZ_IPC_MESSAGE_LOG=$MOZ_IPC_MESSAGE_LOG \"\n\n   [ -n \"$B2G_PID\" ] && $ADB shell \"kill $B2G_PID\"\n   [ \"$B2G_BIN\" = \"/system/b2g/b2g\" ] && $ADB shell \"stop b2g\"\n\n   if [ \"$($ADB shell 'if [ -f /system/b2g/libdmd.so ]; then echo 1; fi')\" != \"\" ]; then\n     echo \"\"\n     echo \"Using DMD.\"\n     echo \"\"\n     dmd=\"1\"\n     ld_preload_extra=\"/system/b2g/libdmd.so\"\n  fi\n\n   $ADB shell \"DMD=$dmd LD_LIBRARY_PATH=/system/b2g LD_PRELOAD=\\\"$ld_preload_extra /system/b2g/libmozglue.so\\\" TMPDIR=/data/local/tmp $GDBSERVER_ENV gdbserver --multi :$GDB_PORT $B2G_BIN $@\" &\nfi\n\nsleep 1\necho \"set solib-absolute-prefix $SYMDIR\" > $GDBINIT\necho \"handle SIGPIPE nostop\" >> $GDBINIT\necho \"set solib-search-path $GECKO_OBJDIR/dist/bin:$SYMDIR/system/lib:$SYMDIR/system/lib/hw:$SYMDIR/system/lib/egl:$SYMDIR/system/bin:$GONK_OBJDIR/system/lib:$GONK_OBJDIR/system/lib/egl:$GONK_OBJDIR/system/lib/hw:$GONK_OBJDIR/system/vendor/lib:$GONK_OBJDIR/system/vendor/lib/hw:$GONK_OBJDIR/system/vendor/lib/egl\" >> $GDBINIT\nif [ \"$1\" == \"vgdb\" ] ; then\n  echo \"target remote :$GDB_PORT\" >> $GDBINIT\nelif [ \"$1\" != \"core\" ]; then\n  echo \"target extended-remote :$GDB_PORT\" >> $GDBINIT\nfi\n\nPROG=$GECKO_OBJDIR/dist/bin/$(basename $B2G_BIN)\n[ -f $PROG ] || PROG=${SYMDIR}/${B2G_BIN}\n[ -f $PROG ] || PROG=${B2G_BIN}\nif [ ! -f $PROG ]; then\n  echo \"Error: program to debug not found:\"\n  echo \"  $GECKO_OBJDIR/dist/bin/$(basename $B2G_BIN)\"\n  echo \"  $SYMDIR/$B2G_BIN\"\n  echo \"  $B2G_BIN\"\n  exit 1\nfi\n\nif [[ \"$-\" == *x* ]]; then\n    # Since we got here, set -x was enabled near the top of the file. print\n    # out the contents of of the gdbinit file.\n    echo \"----- Start of $GDBINIT -----\"\n    cat $GDBINIT\n    echo \"----- End of $GDBINIT -----\"\nfi\n\nif [ \"$SCRIPT_NAME\" == \"run-ddd.sh\" ]; then\n    echo \"ddd --debugger \\\"$GDB -x $GDBINIT\\\" $PROG $CORE_FILE\"\n    ddd --debugger \"$GDB -x $GDBINIT\" $PROG $CORE_FILE\nelse\n    echo $GDB -x $GDBINIT $PROG $CORE_FILE\n    $GDB -x $GDBINIT $PROG $CORE_FILE\nfi\n\n"
        },
        {
          "name": "run-valgrind.sh",
          "type": "blob",
          "size": 4.21484375,
          "content": "#!/bin/bash\n#set -xv\n\nSCRIPT_NAME=$(basename $0)\n\n. load-config.sh\n\nADB=${ADB:-adb}\nif [ ! -f \"`which \\\"$ADB\\\"`\" ]; then\n\tADB=out/host/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/bin/adb\nfi\necho \"ADB Location: \" $ADB\nB2G_DIR=\"/data/valgrind-b2g\"\n\nHAS_VALGRIND=$($ADB shell 'test -e /system/bin/valgrind ; echo -n $?')\n\n# Make sure valgrind is actually on system\nif [ \"$HAS_VALGRIND\" -ne 0 ]; then\n    echo \"Platform does not have valgrind executable, did you build with B2G_VALGRIND=1 in your .userconfig?\"\n    exit 1\nfi\n\nLIBMOZGLUE=\"$GECKO_OBJDIR/mozglue/build/libmozglue.so\"\nLIBXUL=\"$GECKO_OBJDIR/toolkit/library/build/libxul.so\"\nif [ ! -e \"$LIBXUL\" ]; then\n  # try the old location\n  LIBXUL=\"$GECKO_OBJDIR/toolkit/library/libxul.so\"\nfi\n\n# Load libxul\nif [ \"$1\" = \"debuginfo\" ]; then\n  echo \"Recompiling libxul.so with debug info (this can take a few minutes)\"\n  $ADB remount\n  $ADB shell \"rm -rf $B2G_DIR && cp -r /system/b2g $B2G_DIR\"\n  cp \"$LIBXUL\" \"$GECKO_OBJDIR/toolkit/library/libxul.debuginfo.so\"\n\n  STRIP=prebuilts/gcc/`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`-x86/arm/arm-linux-androideabi-4.7/bin/arm-linux-androideabi-strip\n  $STRIP -R .debug_info \"$GECKO_OBJDIR/toolkit/library/libxul.debuginfo.so\"\n  echo \"Pushing debug libxul to phone (this takes about a minute)\"\n  time $ADB push $GECKO_OBJDIR/toolkit/library/libxul.debuginfo.so $B2G_DIR/libxul.so\n  shift\nelif [ \"$1\" = \"nocopy\" ]; then\n  echo \"Skipping libxul.so copy step and just running valgrind...\"\n  shift\nelse\n  $ADB remount\n  $ADB shell \"rm -rf $B2G_DIR && cp -r /system/b2g $B2G_DIR\"\n\n  # compress first, to limit amount of data pushed over the slow pipe\n  # Compressing at level 3 or greater increases compression time a lot\n  # without having much effect on resulting file size, and so is a net loss.\n  echo \"Compressing libxul.so...\"\n  time gzip -2 < \"$LIBXUL\" > $GECKO_OBJDIR/toolkit/library/libxul.so.gz\n\n  echo \"Pushing compressed debug libxul to device (this can take upwards of 5 minutes)\"\n  time $ADB push $GECKO_OBJDIR/toolkit/library/libxul.so.gz $B2G_DIR/libxul.so.gz\n  time $ADB push \"$LIBMOZGLUE\" $B2G_DIR/libmozglue.so\n\n  echo \"Decompressing on phone...\"\n  time $ADB shell \"gzip -d $B2G_DIR/libxul.so.gz\"\n  $ADB shell \"chmod 0755 $B2G_DIR/libxul.so\"\n  $ADB shell \"chmod 0755 $B2G_DIR/libmozglue.so\"\nfi\n\n#$ADB reboot\n$ADB wait-for-device\n$ADB shell stop b2g\n\nCORE_ARGS=\"\"\nif [ \"$1\" = \"vgdb\" ]; then\n  # delete stale vgdb pipes\n  $ADB shell rm /data/local/tmp/vgdb*\n  CORE_ARGS=\"--trace-children=no --vgdb-error=0 --vgdb=yes\"\nelse\n  CORE_ARGS=\"--trace-children=yes\"\nfi\n\n# Flags for the Valgrind core -- applicable to all tools.\n#\n# The --px- flags control precise exceptions.  They are mandatory for Gecko.\nCORE_ARGS=\"$CORE_ARGS --px-default=allregs-at-mem-access\"\nCORE_ARGS=\"$CORE_ARGS --px-file-backed=unwindregs-at-mem-access\"\n# Show source paths relative to the source tree root\nCORE_ARGS=\"$CORE_ARGS --fullpath-after=`pwd`/\"\n# Read full debuginfo for libraries, if available\nCORE_ARGS=\"$CORE_ARGS --extra-debuginfo-path=/sdcard/symbols-for-valgrind\"\n# Specify what GPU the device has.\nCORE_ARGS=\"$CORE_ARGS --kernel-variant=android-gpu-adreno3xx\"\n# Other flags\nCORE_ARGS=\"$CORE_ARGS --error-limit=no --fair-sched=yes\"\n\n# Flags for Memcheck.\n#\nMC_ARGS=\"\"\n# Not necessary for a --disable-jemalloc build, but ..\nMC_ARGS=\"$MC_ARGS --soname-synonyms=somalloc=libmozglueZdso\"\n# Avoid a lot of pointless noise.\nMC_ARGS=\"$MC_ARGS --show-mismatched-frees=no --partial-loads-ok=yes\"\n# Avoid segfaulting Gecko until such time as bug 1166724 is fixed\nMC_ARGS=\"$MC_ARGS --malloc-fill=0x00\"\n# Say what we expect the average translation size to be.  Getting this\n# right can save tens of megabytes of RAM on the phone.\nMC_ARGS=\"$MC_ARGS --avg-transtab-entry-size=400\"\n# Request 11 sectors for translation storage.  More sectors improves\n# performance but costs a lot of memory.\nMC_ARGS=\"$MC_ARGS --num-transtab-sectors=11\"\n\n# Gather them all together.  EXTRA_ARGS allows users to pass in extra\n# arguments on the command line.\nVALGRIND_ARGS=\"$CORE_ARGS $MC_ARGS $EXTRA_ARGS\"\n\n# Due to the fact that we follow forks, we can't log to a logfile. Expect the\n# user to redirect stdout.\n$ADB shell \"B2G_DIR='/data/valgrind-b2g' HOSTNAME='b2g' LOGNAME='b2g' COMMAND_PREFIX='/system/bin/valgrind $VALGRIND_ARGS' exec /system/bin/b2g.sh\"\n\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.sh",
          "type": "blob",
          "size": 0.3291015625,
          "content": "#!/bin/bash\n\n. load-config.sh\n\nexport USE_CCACHE=yes &&\nexport GECKO_PATH &&\nexport GAIA_PATH &&\nexport GAIA_DOMAIN &&\nexport GAIA_PORT &&\nexport GAIA_DEBUG &&\nexport GECKO_OBJDIR &&\nexport B2G_NOOPT &&\nexport B2G_DEBUG &&\nexport MOZ_CHROME_MULTILOCALE &&\nexport L10NBASEDIR &&\nexport MOZ_B2G_DSDS &&\n. build/envsetup.sh &&\nlunch $LUNCH\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 0.796875,
          "content": "#!/bin/bash\n\nB2G_HOME=$(dirname $BASH_SOURCE)\n\nusage() {\n    echo \"Usage: $0 [marionette|mochitest|updates|xpcshell] (frontend-args)\"\n    echo \"\"\n    echo \"'marionette' is the default frontend\"\n}\n\nFRONTEND=$1\nif [ -z \"$FRONTEND\" ]; then\n  FRONTEND=marionette\nelse\n  shift\nfi\n\ncase \"$FRONTEND\" in\n  mochitest)\n    echo \"Use ./mach mochitest-remote to run tests;\"\n    echo \"use ./mach help mochitest-remote for options.\" ;;\n  marionette)\n    echo \"Use ./mach marionette-webapi to run tests;\"\n    echo \"use ./mach help mochitest-webapi for options.\" ;;\n  updates)\n    SCRIPT=$B2G_HOME/scripts/updates.sh ;;\n  xpcshell)\n    SCRIPT=$B2G_HOME/scripts/xpcshell.sh ;;\n  --help|-h|help)\n    usage\n    exit 0;;\n  *)\n    usage\n    echo \"Error: Unknown test frontend: $FRONTEND\" 1>&2\n    exit 1\nesac\n\necho $SCRIPT $@\n$SCRIPT $@\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "watch-procrank.sh",
          "type": "blob",
          "size": 0.046875,
          "content": "#!/bin/bash\nwatch -n 1 'adb shell b2g-procrank'\n"
        }
      ]
    }
  ]
}