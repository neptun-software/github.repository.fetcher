{
  "metadata": {
    "timestamp": 1736568230264,
    "page": 95,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Drewsif/PiShrink",
      "stars": 3548,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.38671875,
          "content": "FROM debian:bookworm\r\n\r\n# Install requirments\r\nRUN apt update && apt install -y wget parted gzip pigz xz-utils udev e2fsprogs && apt clean\r\n\r\n# Setup Env\r\nENV LANG=C.UTF-8\r\nENV TERM=xterm-256color\r\nENV DEBIAN_FRONTEND=noninteractive\r\nWORKDIR /workdir\r\n\r\n# Copy pishrink in\r\nCOPY pishrink.sh /usr/local/bin/pishrink\r\nRUN chmod +x /usr/local/bin/pishrink\r\nENTRYPOINT [ \"/usr/local/bin/pishrink\" ]\r\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Drew Bonasera\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.9326171875,
          "content": "\n# PiShrink #\n\nPiShrink is a bash script that automatically shrink a pi image that will then resize to the max size of the SD card on boot. This will make putting the image back onto the SD card faster and the shrunk images will compress better.\nIn addition the shrunk image can be compressed with gzip and xz to create an even smaller image. Parallel compression of the image\nusing multiple cores is supported.\n\n## Usage ##\n\n```text\nUsage: pishrink.sh [-adhnrsvzZ] imagefile.img [newimagefile.img]\n\n  -s         Don't expand filesystem when image is booted the first time\n  -v         Be verbose\n  -n         Disable automatic update checking\n  -r         Use advanced filesystem repair option if the normal one fails\n  -z         Compress image after shrinking with gzip\n  -Z         Compress image after shrinking with xz\n  -a         Compress image in parallel using multiple cores\n  -d         Write debug messages in a debug log file\n```\n\nIf you specify the `newimagefile.img` parameter, the script will make a copy of `imagefile.img` and work off that. You will need enough space to make a full copy of the image to use that option.\n\n* `-s` prevents automatic filesystem expansion on the images next boot\n* `-v` enables more verbose output\n* `-n` disables the script from checking Github for a new PiShrink release\n* `-r` will attempt to repair the filesystem using additional options if the normal repair fails\n* `-z` will compress the image after shrinking using gzip. `.gz` extension will be added to the filename.\n* `-Z` will compress the image after shrinking using xz. `.xz` extension will be added to the filename.\n* `-a` will use option -f9 for pigz and option -T0 for xz and compress in parallel.\n* `-d` will create a logfile `pishrink.log` which may help for problem analysis.\n\nDefault options for compressors can be overwritten by defining PISHRINK_GZIP or PSHRINK_XZ environment variables for gzip and xz.\n\n## Prerequisites ##\n\nIf you are running PiShrink in VirtualBox you will likely encounter an error if you\nattempt to use VirtualBox's \"Shared Folder\" feature. You can copy the image you wish to\nshrink on to the VM from a Shared Folder, but shrinking directly from the Shared Folder\nis know to cause issues.\n\nIf using Ubuntu, you will likely see an error about `e2fsck` being out of date and `metadata_csum`. The simplest fix for this is to use Ubuntu 16.10 and up, as it will save you a lot of hassle in the long run.\n\nPiShrink will shrink the last partition of your image. If that partition is not ext2, ext3, or ext4 it will not be able to shrink your image.\nIf the last partition is not the root filesystem partition, auto resizing will not run on boot.\nIf you want to use auto resizing on a distro using Systemd, you should ensure you [Enabled /etc/rc.local Compatibility](https://www.linuxbabe.com/linux-server/how-to-enable-etcrc-local-with-systemd).\n\n## Installation ##\n\n### Linux Instructions ###\n\nIf you are on Debian/Ubuntu you can install all the packages you would need by running: `sudo apt update && sudo apt install -y wget parted gzip pigz xz-utils udev e2fsprogs`\n\nRun the block below to install PiShrink onto your system.\n\n```bash\nwget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh\nchmod +x pishrink.sh\nsudo mv pishrink.sh /usr/local/bin\n```\n\n### Windows Instructions ###\n\nPiShrink can be ran on Windows using [Windows Subsystem for Linux](https://learn.microsoft.com/en-us/windows/wsl/about) (WSL 2).\n\n1. In an Administrator command prompt run `wsl --install -d Debian`. You will likely need to reboot after. Please check [Microsoft's documentation](https://learn.microsoft.com/en-us/windows/wsl/install) if you run into issues.\n2. Open the `Debian` app from your start menu.\n3. Run `sudo apt update && sudo apt install -y wget parted gzip pigz xz-utils udev e2fsprogs`\n4. Go to the Linux Instructions section above, do that and you're good to go! Your C:\\ drive is mounted at /mnt/c/\n\n### MacOS Instructions ###\n\n> [!NOTE]\n> These instructions were sourced from the community and should work on Intel and M1 Macs.\n\n1. [Installer Docker](https://docs.docker.com/docker-for-mac/install/).\n2. Clone this repo and cd into the pishrink directory:\n   ```bash\n   git clone https://github.com/Drewsif/PiShrink && cd PiShrink\n   ```\n4. Build the container by running:\n   ```bash\n   docker build -t pishrink .\n   ```\n6. Create an alias to run PiShrink:\n   ```bash\n   echo \"alias pishrink='docker run -it --rm --platform linux/amd64 --privileged=true -v $(pwd):/workdir pishrink'\" >> ~/.bashrc && source ~/.bashrc\n   ```\n\nYou can now run the `pishrink` command as normal to shrink your images.\n\n> [!WARNING]  \n> You MUST change directory into the images folder for this command to work. The command mounts your current working directory into the container so absolute file paths will not work. Relative paths should work just fine as long as they are below your current directory.\n\n## Example ##\n\n```bash\n[user@localhost PiShrink]$ sudo pishrink.sh pi.img\ne2fsck 1.42.9 (28-Dec-2013)\nPass 1: Checking inodes, blocks, and sizes\nPass 2: Checking directory structure\nPass 3: Checking directory connectivity\nPass 4: Checking reference counts\nPass 5: Checking group summary information\n/dev/loop1: 88262/1929536 files (0.2% non-contiguous), 842728/7717632 blocks\nresize2fs 1.42.9 (28-Dec-2013)\nresize2fs 1.42.9 (28-Dec-2013)\nResizing the filesystem on /dev/loop1 to 773603 (4k) blocks.\nBegin pass 2 (max = 100387)\nRelocating blocks             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nBegin pass 3 (max = 236)\nScanning inode table          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nBegin pass 4 (max = 7348)\nUpdating inode references     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nThe filesystem on /dev/loop1 is now 773603 blocks long.\n\nShrunk pi.img from 30G to 3.1G\n```\n\n## Contributing ##\n\nIf you find a bug please create an issue for it. If you would like a new feature added, you can create an issue for it but I can't promise that I will get to it.\n\nPull requests for new features and bug fixes are more than welcome!\n"
        },
        {
          "name": "pishrink.sh",
          "type": "blob",
          "size": 11.751953125,
          "content": "#!/usr/bin/env bash\n\n# Project: PiShrink\n# Description: PiShrink is a bash script that automatically shrink a pi image that will then resize to the max size of the SD card on boot.\n# Link: https://github.com/Drewsif/PiShrink\n\nversion=\"v24.10.23\"\n\nCURRENT_DIR=\"$(pwd)\"\nSCRIPTNAME=\"${0##*/}\"\nMYNAME=\"${SCRIPTNAME%.*}\"\nLOGFILE=\"${CURRENT_DIR}/${SCRIPTNAME%.*}.log\"\nREQUIRED_TOOLS=\"parted losetup tune2fs md5sum e2fsck resize2fs\"\nZIPTOOLS=(\"gzip xz\")\ndeclare -A ZIP_PARALLEL_TOOL=( [gzip]=\"pigz\" [xz]=\"xz\" ) # parallel zip tool to use in parallel mode\ndeclare -A ZIP_PARALLEL_OPTIONS=( [gzip]=\"-f9\" [xz]=\"-T0\" ) # options for zip tools in parallel mode\ndeclare -A ZIPEXTENSIONS=( [gzip]=\"gz\" [xz]=\"xz\" ) # extensions of zipped files\n\nfunction info() {\n\techo \"$SCRIPTNAME: $1\"\n}\n\nfunction error() {\n\techo -n \"$SCRIPTNAME: ERROR occurred in line $1: \"\n\tshift\n\techo \"$@\"\n}\n\nfunction cleanup() {\n\tif losetup \"$loopback\" &>/dev/null; then\n\t\tlosetup -d \"$loopback\"\n\tfi\n\tif [ \"$debug\" = true ]; then\n\t\tlocal old_owner=$(stat -c %u:%g \"$src\")\n\t\tchown \"$old_owner\" \"$LOGFILE\"\n\tfi\n\n}\n\nfunction logVariables() {\n\tif [ \"$debug\" = true ]; then\n\t\techo \"Line $1\" >> \"$LOGFILE\"\n\t\tshift\n\t\tlocal v var\n\t\tfor var in \"$@\"; do\n\t\t\teval \"v=\\$$var\"\n\t\t\techo \"$var: $v\" >> \"$LOGFILE\"\n\t\tdone\n\tfi\n}\n\nfunction checkFilesystem() {\n\tinfo \"Checking filesystem\"\n\te2fsck -pf \"$loopback\"\n\t(( $? < 4 )) && return\n\n\tinfo \"Filesystem error detected!\"\n\n\tinfo \"Trying to recover corrupted filesystem\"\n\te2fsck -y \"$loopback\"\n\t(( $? < 4 )) && return\n\nif [[ $repair == true ]]; then\n\tinfo \"Trying to recover corrupted filesystem - Phase 2\"\n\te2fsck -fy -b 32768 \"$loopback\"\n\t(( $? < 4 )) && return\nfi\n\terror $LINENO \"Filesystem recoveries failed. Giving up...\"\n\texit 9\n\n}\n\nfunction set_autoexpand() {\n    #Make pi expand rootfs on next boot\n    mountdir=$(mktemp -d)\n    partprobe \"$loopback\"\n    sleep 3\n    umount \"$loopback\" > /dev/null 2>&1\n    mount \"$loopback\" \"$mountdir\" -o rw\n    if (( $? != 0 )); then\n      info \"Unable to mount loopback, autoexpand will not be enabled\"\n      return\n    fi\n\n    if [ ! -d \"$mountdir/etc\" ]; then\n        info \"/etc not found, autoexpand will not be enabled\"\n        umount \"$mountdir\"\n        return\n    fi\n\n    if [[ ! -f \"$mountdir/etc/rc.local\" ]]; then\n        info \"An existing /etc/rc.local was not found, autoexpand may fail...\"\n    fi\n\n    if ! grep -q \"## PiShrink https://github.com/Drewsif/PiShrink ##\" \"$mountdir/etc/rc.local\"; then\n      echo \"Creating new /etc/rc.local\"\n    if [ -f \"$mountdir/etc/rc.local\" ]; then\n        mv \"$mountdir/etc/rc.local\" \"$mountdir/etc/rc.local.bak\"\n    fi\n\ncat <<'EOFRC' > \"$mountdir/etc/rc.local\"\n#!/bin/bash\n## PiShrink https://github.com/Drewsif/PiShrink ##\ndo_expand_rootfs() {\n  ROOT_PART=$(mount | sed -n 's|^/dev/\\(.*\\) on / .*|\\1|p')\n\n  PART_NUM=${ROOT_PART#mmcblk0p}\n  if [ \"$PART_NUM\" = \"$ROOT_PART\" ]; then\n    echo \"$ROOT_PART is not an SD card. Don't know how to expand\"\n    return 0\n  fi\n\n  # Get the starting offset of the root partition\n  PART_START=$(parted /dev/mmcblk0 -ms unit s p | grep \"^${PART_NUM}\" | cut -f 2 -d: | sed 's/[^0-9]//g')\n  [ \"$PART_START\" ] || return 1\n  # Return value will likely be error for fdisk as it fails to reload the\n  # partition table because the root fs is mounted\n  fdisk /dev/mmcblk0 <<EOF\np\nd\n$PART_NUM\nn\np\n$PART_NUM\n$PART_START\n\np\nw\nEOF\n\ncat <<EOF > /etc/rc.local &&\n#!/bin/sh\necho \"Expanding /dev/$ROOT_PART\"\nresize2fs /dev/$ROOT_PART\nrm -f /etc/rc.local; cp -fp /etc/rc.local.bak /etc/rc.local && /etc/rc.local\n\nEOF\nreboot\nexit\n}\nraspi_config_expand() {\n/usr/bin/env raspi-config --expand-rootfs\nif [[ $? != 0 ]]; then\n  return -1\nelse\n  rm -f /etc/rc.local; cp -fp /etc/rc.local.bak /etc/rc.local && /etc/rc.local\n  reboot\n  exit\nfi\n}\nraspi_config_expand\necho \"WARNING: Using backup expand...\"\nsleep 5\ndo_expand_rootfs\necho \"ERROR: Expanding failed...\"\nsleep 5\nif [[ -f /etc/rc.local.bak ]]; then\n  cp -fp /etc/rc.local.bak /etc/rc.local\n  /etc/rc.local\nfi\nexit 0\nEOFRC\n\n    chmod +x \"$mountdir/etc/rc.local\"\n    fi\n    umount \"$mountdir\"\n}\n\nhelp() {\n\tlocal help\n\tread -r -d '' help << EOM\nUsage: $0 [-adhnrsvzZ] imagefile.img [newimagefile.img]\n\n  -s         Don't expand filesystem when image is booted the first time\n  -v         Be verbose\n  -n         Disable automatic update checking\n  -r         Use advanced filesystem repair option if the normal one fails\n  -z         Compress image after shrinking with gzip\n  -Z         Compress image after shrinking with xz\n  -a         Compress image in parallel using multiple cores\n  -d         Write debug messages in a debug log file\nEOM\n\techo \"$help\"\n\texit 1\n}\n\nshould_skip_autoexpand=false\ndebug=false\nupdate_check=true\nrepair=false\nparallel=false\nverbose=false\nziptool=\"\"\n\nwhile getopts \":adnhrsvzZ\" opt; do\n  case \"${opt}\" in\n    a) parallel=true;;\n    d) debug=true;;\n    n) update_check=false;;\n    h) help;;\n    r) repair=true;;\n    s) should_skip_autoexpand=true ;;\n    v) verbose=true;;\n    z) ziptool=\"gzip\";;\n    Z) ziptool=\"xz\";;\n    *) help;;\n  esac\ndone\nshift $((OPTIND-1))\n\nif [ \"$debug\" = true ]; then\n\tinfo \"Creating log file $LOGFILE\"\n\trm \"$LOGFILE\" &>/dev/null\n\texec 1> >(stdbuf -i0 -o0 -e0 tee -a \"$LOGFILE\" >&1)\n\texec 2> >(stdbuf -i0 -o0 -e0 tee -a \"$LOGFILE\" >&2)\nfi\n\necho -e \"PiShrink $version - https://github.com/Drewsif/PiShrink\\n\"\n\n# Try and check for updates\nif $update_check; then\n  latest_release=$(curl -m 5 https://api.github.com/repos/Drewsif/PiShrink/releases/latest 2>/dev/null | grep -i \"tag_name\" 2>/dev/null | awk -F '\"' '{print $4}' 2>/dev/null)\n  if [[ $? ]] && [ \"$latest_release\" \\> \"$version\" ]; then\n    echo \"WARNING: You do not appear to be running the latest version of PiShrink. Head on over to https://github.com/Drewsif/PiShrink to grab $latest_release\"\n    echo \"\"\n  fi\nfi\n\n#Args\nsrc=\"$1\"\nimg=\"$1\"\n\n#Usage checks\nif [[ -z \"$img\" ]]; then\n  help\nfi\n\nif [[ ! -f \"$img\" ]]; then\n  error $LINENO \"$img is not a file...\"\n  exit 2\nfi\nif (( EUID != 0 )); then\n  error $LINENO \"You need to be running as root.\"\n  exit 3\nfi\n\n# set locale to POSIX(English) temporarily\n# these locale settings only affect the script and its sub processes\n\nexport LANGUAGE=POSIX\nexport LC_ALL=POSIX\nexport LANG=POSIX\n\n# check selected compression tool is supported and installed\nif [[ -n $ziptool ]]; then\n\tif [[ ! \" ${ZIPTOOLS[@]} \" =~ $ziptool ]]; then\n\t\terror $LINENO \"$ziptool is an unsupported ziptool.\"\n\t\texit 17\n\telse\n\t\tif [[ $parallel == true && $ziptool == \"gzip\" ]]; then\n\t\t\tREQUIRED_TOOLS=\"$REQUIRED_TOOLS pigz\"\n\t\telse\n\t\t\tREQUIRED_TOOLS=\"$REQUIRED_TOOLS $ziptool\"\n\t\tfi\n\tfi\nfi\n\n#Check that what we need is installed\nfor command in $REQUIRED_TOOLS; do\n  command -v $command >/dev/null 2>&1\n  if (( $? != 0 )); then\n    error $LINENO \"$command is not installed.\"\n    exit 4\n  fi\ndone\n\n#Copy to new file if requested\nif [ -n \"$2\" ]; then\n  f=\"$2\"\n  if [[ -n $ziptool && \"${f##*.}\" == \"${ZIPEXTENSIONS[$ziptool]}\" ]]; then\t# remove zip extension if zip requested because zip tool will complain about extension\n    f=\"${f%.*}\"\n  fi\n  info \"Copying $1 to $f...\"\n  cp --reflink=auto --sparse=always \"$1\" \"$f\"\n  if (( $? != 0 )); then\n    error $LINENO \"Could not copy file...\"\n    exit 5\n  fi\n  old_owner=$(stat -c %u:%g \"$1\")\n  chown \"$old_owner\" \"$f\"\n  img=\"$f\"\nfi\n\n# cleanup at script exit\ntrap cleanup EXIT\n\n#Gather info\ninfo \"Gathering data\"\nbeforesize=\"$(ls -lh \"$img\" | cut -d ' ' -f 5)\"\nparted_output=\"$(parted -ms \"$img\" unit B print)\"\nrc=$?\nif (( $rc )); then\n\terror $LINENO \"parted failed with rc $rc\"\n\tinfo \"Possibly invalid image. Run 'parted $img unit B print' manually to investigate\"\n\texit 6\nfi\npartnum=\"$(echo \"$parted_output\" | tail -n 1 | cut -d ':' -f 1)\"\npartstart=\"$(echo \"$parted_output\" | tail -n 1 | cut -d ':' -f 2 | tr -d 'B')\"\nif [ -z \"$(parted -s \"$img\" unit B print | grep \"$partstart\" | grep logical)\" ]; then\n    parttype=\"primary\"\nelse\n    parttype=\"logical\"\nfi\nloopback=\"$(losetup -f --show -o \"$partstart\" \"$img\")\"\ntune2fs_output=\"$(tune2fs -l \"$loopback\")\"\nrc=$?\nif (( $rc )); then\n    echo \"$tune2fs_output\"\n    error $LINENO \"tune2fs failed. Unable to shrink this type of image\"\n    exit 7\nfi\n\ncurrentsize=\"$(echo \"$tune2fs_output\" | grep '^Block count:' | tr -d ' ' | cut -d ':' -f 2)\"\nblocksize=\"$(echo \"$tune2fs_output\" | grep '^Block size:' | tr -d ' ' | cut -d ':' -f 2)\"\n\nlogVariables $LINENO beforesize parted_output partnum partstart parttype tune2fs_output currentsize blocksize\n\n#Check if we should make pi expand rootfs on next boot\nif [ \"$parttype\" == \"logical\" ]; then\n  echo \"WARNING: PiShrink does not yet support autoexpanding of this type of image\"\nelif [ \"$should_skip_autoexpand\" = false ]; then\n  set_autoexpand\nelse\n  echo \"Skipping autoexpanding process...\"\nfi\n\n#Make sure filesystem is ok\ncheckFilesystem\n\nif ! minsize=$(resize2fs -P \"$loopback\"); then\n\trc=$?\n\terror $LINENO \"resize2fs failed with rc $rc\"\n\texit 10\nfi\nminsize=$(cut -d ':' -f 2 <<< \"$minsize\" | tr -d ' ')\nlogVariables $LINENO currentsize minsize\nif [[ $currentsize -eq $minsize ]]; then\n  info \"Filesystem already shrunk to smallest size. Skipping filesystem shrinking\"\nelse\n  #Add some free space to the end of the filesystem\n  extra_space=$(($currentsize - $minsize))\n  logVariables $LINENO extra_space\n  for space in 5000 1000 100; do\n    if [[ $extra_space -gt $space ]]; then\n      minsize=$(($minsize + $space))\n      break\n    fi\n  done\n  logVariables $LINENO minsize\n\n  #Shrink filesystem\n  info \"Shrinking filesystem\"\n  if [ -z \"$mountdir\" ]; then\n    mountdir=$(mktemp -d)\n  fi\n\n  resize2fs -p \"$loopback\" $minsize\n  rc=$?\n  if (( $rc )); then\n    error $LINENO \"resize2fs failed with rc $rc\"\n    mount \"$loopback\" \"$mountdir\"\n    mv \"$mountdir/etc/rc.local.bak\" \"$mountdir/etc/rc.local\"\n    umount \"$mountdir\"\n    losetup -d \"$loopback\"\n    exit 12\n  else\n    info \"Zeroing any free space left\"\n    mount \"$loopback\" \"$mountdir\"\n    cat /dev/zero > \"$mountdir/PiShrink_zero_file\" 2>/dev/null\n    info \"Zeroed $(ls -lh \"$mountdir/PiShrink_zero_file\" | cut -d ' ' -f 5)\"\n    rm -f \"$mountdir/PiShrink_zero_file\"\n    umount \"$mountdir\"\n  fi\n  sleep 1\n\n  #Shrink partition\n  info \"Shrinking partition\"\n  partnewsize=$(($minsize * $blocksize))\n  newpartend=$(($partstart + $partnewsize))\n  logVariables $LINENO partnewsize newpartend\n  parted -s -a minimal \"$img\" rm \"$partnum\"\n  rc=$?\n  if (( $rc )); then\n    error $LINENO \"parted failed with rc $rc\"\n    exit 13\n  fi\n\n  parted -s \"$img\" unit B mkpart \"$parttype\" \"$partstart\" \"$newpartend\"\n  rc=$?\n  if (( $rc )); then\n    error $LINENO \"parted failed with rc $rc\"\n    exit 14\n  fi\n\n  #Truncate the file\n  info \"Truncating image\"\n  endresult=$(parted -ms \"$img\" unit B print free)\n  rc=$?\n  if (( $rc )); then\n    error $LINENO \"parted failed with rc $rc\"\n    exit 15\n  fi\n\n  endresult=$(tail -1 <<< \"$endresult\" | cut -d ':' -f 2 | tr -d 'B')\n  logVariables $LINENO endresult\n  truncate -s \"$endresult\" \"$img\"\n  rc=$?\n  if (( $rc )); then\n    error $LINENO \"truncate failed with rc $rc\"\n    exit 16\n  fi\nfi\n\n# handle compression\nif [[ -n $ziptool ]]; then\n\toptions=\"\"\n\tenvVarname=\"${MYNAME^^}_${ziptool^^}\" # PISHRINK_GZIP or PISHRINK_XZ environment variables allow to override all options for gzip or xz\n\t[[ $parallel == true ]] && options=\"${ZIP_PARALLEL_OPTIONS[$ziptool]}\"\n\t[[ -v $envVarname ]] && options=\"${!envVarname}\" # if environment variable defined use these options\n\t[[ $verbose == true ]] && options=\"$options -v\" # add verbose flag if requested\n\n\tif [[ $parallel == true ]]; then\n\t\tparallel_tool=\"${ZIP_PARALLEL_TOOL[$ziptool]}\"\n\t\tinfo \"Using $parallel_tool on the shrunk image\"\n\t\tif ! $parallel_tool ${options} \"$img\"; then\n\t\t\trc=$?\n\t\t\terror $LINENO \"$parallel_tool failed with rc $rc\"\n\t\t\texit 18\n\t\tfi\n\n\telse # sequential\n\t\tinfo \"Using $ziptool on the shrunk image\"\n\t\tif ! $ziptool ${options} \"$img\"; then\n\t\t\trc=$?\n\t\t\terror $LINENO \"$ziptool failed with rc $rc\"\n\t\t\texit 19\n\t\tfi\n\tfi\n\timg=$img.${ZIPEXTENSIONS[$ziptool]}\nfi\n\naftersize=$(ls -lh \"$img\" | cut -d ' ' -f 5)\nlogVariables $LINENO aftersize\n\ninfo \"Shrunk $img from $beforesize to $aftersize\"\n"
        }
      ]
    }
  ]
}