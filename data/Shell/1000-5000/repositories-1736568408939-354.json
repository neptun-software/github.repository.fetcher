{
  "metadata": {
    "timestamp": 1736568408939,
    "page": 354,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dylanaraps/pfetch",
      "stars": 2068,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1201171875,
          "content": "root = true\n\n# Force GitHub to display tabs\n# mixed with [4] spaces properly.\n[pfetch]\nindent_style = tab\nindent_size  = 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0576171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016-2019 Dylan Araps\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1787109375,
          "content": "PREFIX ?= /usr\n\nall:\n\t@echo RUN \\'make install\\' to install pfetch\n\ninstall:\n\t@install -Dm755 pfetch $(DESTDIR)$(PREFIX)/bin/pfetch\n\nuninstall:\n\t@rm -f $(DESTDIR)$(PREFIX)/bin/pfetch\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.171875,
          "content": "<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/6799467/65944518-68834d80-e421-11e9-9b14-6ca26a16108a.png\" width=\"350px\"></p>\n<h1 align=\"center\">pfetch</h1>\n<p align=\"center\">A pretty system information tool written in POSIX sh</p><br>\n\n<img src=\"https://user-images.githubusercontent.com/6799467/65945384-5bfff480-e423-11e9-863e-4e7cf16eb648.png\" width=\"40%\" align=\"right\">\n\nThe goal of this project is to implement a simple system\ninformation tool in POSIX `sh` using features built into\nthe language itself (*where possible*).\n\nThe source code is highly documented and I hope it will\nact as a learning resource for POSIX `sh` and simple\ninformation detection across various different operating\nsystems.\n\nIf anything in the source code is unclear or is lacking\nin its explanation, open an issue. Sometimes you get too\nclose to something and you fail to see the \"bigger\npicture\"!\n\n<br>\n<br>\n<br>\n<br>\n\n## OS support\n\n- **Linux**\n    - Alpine Linux, Arch Linux, Arco Linux, Artix Linux, CentOS, Dahlia, Debian, Devuan, Elementary, EndeavourOS, Fedora, Garuda Linux, Gentoo, Guix, Hyperbola, instantOS, KISS Linux, Linux Lite, Linux Mint, Mageia, Manjaro, MX Linux, NixOS, OpenSUSE, Parabola, Pop!\\_OS, PureOS, Slackware, Solus, Ubuntu and Void Linux.\n    - All other distributions are supported with a generic penguin logo.\n- **Android**\n- **BSD**\n    - DragonflyBSD, FreeBSD, NetBSD and OpenBSD.\n- **Windows**\n    - Windows subsystem for Linux.\n- **Haiku**\n- **MacOS**\n- **Minix**\n- **Solaris**\n- **IRIX**\n- **SerenityOS**\n\n## Configuration\n\n`pfetch` is configured through environment variables.\n\n```sh\n# Which information to display.\n# NOTE: If 'ascii' will be used, it must come first.\n# Default: first example below\n# Valid: space separated string\n#\n# OFF by default: shell editor wm de palette\nPF_INFO=\"ascii title os host kernel uptime pkgs memory\"\n\n# Example: Only ASCII.\nPF_INFO=\"ascii\"\n\n# Example: Only Information.\nPF_INFO=\"title os host kernel uptime pkgs memory\"\n\n# A file to source before running pfetch.\n# Default: unset\n# Valid: A shell script\nPF_SOURCE=\"\"\n\n# Separator between info name and info data.\n# Default: unset\n# Valid: string\nPF_SEP=\":\"\n\n# Enable/Disable colors in output:\n# Default: 1\n# Valid: 1 (enabled), 0 (disabled)\nPF_COLOR=1\n\n# Color of info names:\n# Default: unset (auto)\n# Valid: 0-9\nPF_COL1=4\n\n# Color of info data:\n# Default: unset (auto)\n# Valid: 0-9\nPF_COL2=9\n\n# Color of title data:\n# Default: unset (auto)\n# Valid: 0-9\nPF_COL3=1\n\n# Alignment padding.\n# Default: unset (auto)\n# Valid: int\nPF_ALIGN=\"\"\n\n# Which ascii art to use.\n# Default: unset (auto)\n# Valid: string\nPF_ASCII=\"openbsd\"\n\n# The below environment variables control more\n# than just 'pfetch' and can be passed using\n# 'HOSTNAME=cool_pc pfetch' to restrict their\n# usage solely to 'pfetch'.\n\n# Which user to display.\nUSER=\"\"\n\n# Which hostname to display.\nHOSTNAME=\"\"\n\n# Which editor to display.\nEDITOR=\"\"\n\n# Which shell to display.\nSHELL=\"\"\n\n# Which desktop environment to display.\nXDG_CURRENT_DESKTOP=\"\"\n```\n\n## Credit\n\n- [ufetch](https://gitlab.com/jschx/ufetch): Lots of ASCII logos.\n    - Contrary to the belief of a certain youtuber, `pfetch` shares **zero** code with `ufetch`. Only some of the ASCII logos were used.\n"
        },
        {
          "name": "pfetch",
          "type": "blob",
          "size": 58.095703125,
          "content": "#!/bin/sh\n#\n# pfetch - Simple POSIX sh fetch script.\n\n# Wrapper around all escape sequences used by pfetch to allow for\n# greater control over which sequences are used (if any at all).\nesc() {\n    case $1 in\n        CUU) e=\"${esc_c}[${2}A\" ;; # cursor up\n        CUD) e=\"${esc_c}[${2}B\" ;; # cursor down\n        CUF) e=\"${esc_c}[${2}C\" ;; # cursor right\n        CUB) e=\"${esc_c}[${2}D\" ;; # cursor left\n\n        # text formatting\n        SGR)\n            case ${PF_COLOR:=1} in\n                (1)\n                    e=\"${esc_c}[${2}m\"\n                ;;\n\n                (0)\n                    # colors disabled\n                    e=\n                ;;\n            esac\n        ;;\n\n        # line wrap\n        DECAWM)\n            case $TERM in\n                (dumb | minix | cons25)\n                    # not supported\n                    e=\n                ;;\n\n                (*)\n                    e=\"${esc_c}[?7${2}\"\n                ;;\n            esac\n        ;;\n    esac\n}\n\n# Print a sequence to the terminal.\nesc_p() {\n    esc \"$@\"\n    printf '%s' \"$e\"\n}\n\n# This is just a simple wrapper around 'command -v' to avoid\n# spamming '>/dev/null' throughout this function. This also guards\n# against aliases and functions.\nhas() {\n    _cmd=$(command -v \"$1\") 2>/dev/null || return 1\n    [ -x \"$_cmd\" ] || return 1\n}\n\nlog() {\n    # The 'log()' function handles the printing of information.\n    # In 'pfetch' (and 'neofetch'!) the printing of the ascii art and info\n    # happen independently of each other.\n    #\n    # The size of the ascii art is stored and the ascii is printed first.\n    # Once the ascii is printed, the cursor is located right below the art\n    # (See marker $[1]).\n    #\n    # Using the stored ascii size, the cursor is then moved to marker $[2].\n    # This is simply a cursor up escape sequence using the \"height\" of the\n    # ascii art.\n    #\n    # 'log()' then moves the cursor to the right the \"width\" of the ascii art\n    # with an additional amount of padding to add a gap between the art and\n    # the information (See marker $[3]).\n    #\n    # When 'log()' has executed, the cursor is then located at marker $[4].\n    # When 'log()' is run a second time, the next line of information is\n    # printed, moving the cursor to marker $[5].\n    #\n    # Markers $[4] and $[5] repeat all the way down through the ascii art\n    # until there is no more information left to print.\n    #\n    # Every time 'log()' is called the script keeps track of how many lines\n    # were printed. When printing is complete the cursor is then manually\n    # placed below the information and the art according to the \"heights\"\n    # of both.\n    #\n    # The math is simple: move cursor down $((ascii_height - info_height)).\n    # If the aim is to move the cursor from marker $[5] to marker $[6],\n    # plus the ascii height is 8 while the info height is 2 it'd be a move\n    # of 6 lines downwards.\n    #\n    # However, if the information printed is \"taller\" (takes up more lines)\n    # than the ascii art, the cursor isn't moved at all!\n    #\n    # Once the cursor is at marker $[6], the script exits. This is the gist\n    # of how this \"dynamic\" printing and layout works.\n    #\n    # This method allows ascii art to be stored without markers for info\n    # and it allows for easy swapping of info order and amount.\n    #\n    # $[2] ___      $[3] goldie@KISS\n    # $[4](.Â· |     $[5] os KISS Linux\n    #     (<> |\n    #    / __  \\\n    #   ( /  \\ /|\n    #  _/\\ __)/_)\n    #  \\/-____\\/\n    # $[1]\n    #\n    # $[6] /home/goldie $\n\n    # End here if no data was found.\n    [ \"$2\" ] || return\n\n    # Store the values of '$1' and '$3' as we reset the argument list below.\n    name=$1\n    use_seperator=$3\n\n    # Use 'set --' as a means of stripping all leading and trailing\n    # white-space from the info string. This also normalizes all\n    # white-space inside of the string.\n    #\n    # Disable the shellcheck warning for word-splitting\n    # as it's safe and intended ('set -f' disables globbing).\n    # shellcheck disable=2046,2086\n    {\n        set -f\n        set +f -- $2\n        info=$*\n    }\n\n    # Move the cursor to the right, the width of the ascii art with an\n    # additional gap for text spacing.\n    esc_p CUF \"$ascii_width\"\n\n    # Print the info name and color the text.\n    esc_p SGR \"3${PF_COL1-4}\";\n    esc_p SGR 1\n    printf '%s' \"$name\"\n    esc_p SGR 0\n\n    # Print the info name and info data separator, if applicable.\n    [ \"$use_seperator\" ] || printf %s \"$PF_SEP\"\n\n    # Move the cursor backward the length of the *current* info name and\n    # then move it forwards the length of the *longest* info name. This\n    # aligns each info data line.\n    esc_p CUB \"${#name}\"\n    esc_p CUF \"${PF_ALIGN:-$info_length}\"\n\n    # Print the info data, color it and strip all leading whitespace\n    # from the string.\n    esc_p SGR \"3${PF_COL2-9}\"\n    printf '%s' \"$info\"\n    esc_p SGR 0\n    printf '\\n'\n\n    # Keep track of the number of times 'log()' has been run.\n    info_height=$((${info_height:-0} + 1))\n}\n\nget_title() {\n    # Username is retrieved by first checking '$USER' with a fallback\n    # to the 'id -un' command.\n    user=${USER:-$(id -un)}\n\n    # Hostname is retrieved by first checking '$HOSTNAME' with a fallback\n    # to the 'hostname' command.\n    #\n    # Disable the warning about '$HOSTNAME' being undefined in POSIX sh as\n    # the intention for using it is allowing the user to overwrite the\n    # value on invocation.\n    # shellcheck disable=3028,2039\n    hostname=${HOSTNAME:-${hostname:-$(hostname)}}\n\n    # If the hostname is still not found, fallback to the contents of the\n    # /etc/hostname file.\n    [ \"$hostname\" ] || read -r hostname < /etc/hostname\n\n    # Add escape sequences for coloring to user and host name. As we embed\n    # them directly in the arguments passed to log(), we cannot use esc_p().\n    esc SGR 1\n    user=$e$user\n    esc SGR \"3${PF_COL3:-1}\"\n    user=$e$user\n    esc SGR 1\n    user=$user$e\n    esc SGR 1\n    hostname=$e$hostname\n    esc SGR \"3${PF_COL3:-1}\"\n    hostname=$e$hostname\n\n    log \"${user}@${hostname}\" \" \" \" \" >&6\n}\n\nget_os() {\n    # This function is called twice, once to detect the distribution name\n    # for the purposes of picking an ascii art early and secondly to display\n    # the distribution name in the info output (if enabled).\n    #\n    # On first run, this function displays _nothing_, only on the second\n    # invocation is 'log()' called.\n    [ \"$distro\" ] && {\n        log os \"$distro\" >&6\n        return\n    }\n\n    case $os in\n        (Linux*)\n            # Some Linux distributions (which are based on others)\n            # fail to identify as they **do not** change the upstream\n            # distribution's identification packages or files.\n            #\n            # It is senseless to add a special case in the code for\n            # each and every distribution (which _is_ technically no\n            # different from what it is based on) as they're either too\n            # lazy to modify upstream's identification files or they\n            # don't have the know-how (or means) to ship their own\n            # lsb-release package.\n            #\n            # This causes users to think there's a bug in system detection\n            # tools like neofetch or pfetch when they technically *do*\n            # function correctly.\n            #\n            # Exceptions are made for distributions which are independent,\n            # not based on another distribution or follow different\n            # standards.\n            #\n            # This applies only to distributions which follow the standard\n            # by shipping unmodified identification files and packages\n            # from their respective upstreams.\n            if has lsb_release; then\n                distro=$(lsb_release -sd)\n\n            # Android detection works by checking for the existence of\n            # the follow two directories. I don't think there's a simpler\n            # method than this.\n            elif [ -d /system/app ] && [ -d /system/priv-app ]; then\n                distro=\"Android $(getprop ro.build.version.release)\"\n\n            elif [ -f /etc/os-release ]; then\n                # This used to be a simple '. /etc/os-release' but I believe\n                # this is insecure as we blindly executed whatever was in the\n                # file. This parser instead simply handles 'key=val', treating\n                # the file contents as plain-text.\n                while IFS='=' read -r key val; do\n                    case $key in\n                        (PRETTY_NAME)\n                            distro=$val\n                        ;;\n                    esac\n                done < /etc/os-release\n\n            else\n                # Special cases for (independent) distributions which\n                # don't follow any os-release/lsb standards whatsoever.\n                has crux && distro=$(crux)\n                has guix && distro='Guix System'\n            fi\n\n            # 'os-release' and 'lsb_release' sometimes add quotes\n            # around the distribution name, strip them.\n            distro=${distro##[\\\"\\']}\n            distro=${distro%%[\\\"\\']}\n\n            # Check to see if we're running Bedrock Linux which is\n            # very unique. This simply checks to see if the user's\n            # PATH contains a Bedrock specific value.\n            case $PATH in\n                (*/bedrock/cross/*)\n                    distro='Bedrock Linux'\n                ;;\n            esac\n\n            # Check to see if Linux is running in Windows 10 under\n            # WSL1 (Windows subsystem for Linux [version 1]) and\n            # append a string accordingly.\n            #\n            # If the kernel version string ends in \"-Microsoft\",\n            # we're very likely running under Windows 10 in WSL1.\n            if [ \"$WSLENV\" ]; then\n                distro=\"${distro}${WSLENV+ on Windows 10 [WSL2]}\"\n\n            # Check to see if Linux is running in Windows 10 under\n            # WSL2 (Windows subsystem for Linux [version 2]) and\n            # append a string accordingly.\n            #\n            # This checks to see if '$WSLENV' is defined. This\n            # appends the Windows 10 string even if '$WSLENV' is\n            # empty. We only need to check that is has been _exported_.\n            elif [ -z \"${kernel%%*-Microsoft}\" ]; then\n                distro=\"$distro on Windows 10 [WSL1]\"\n            fi\n        ;;\n\n        (Darwin*)\n            # Parse the SystemVersion.plist file to grab the macOS\n            # version. The file is in the following format:\n            #\n            # <key>ProductVersion</key>\n            # <string>10.14.6</string>\n            #\n            # 'IFS' is set to '<>' to enable splitting between the\n            # keys and a second 'read' is used to operate on the\n            # next line directly after a match.\n            #\n            # '_' is used to nullify a field. '_ _ line _' basically\n            # says \"populate $line with the third field's contents\".\n            while IFS='<>' read -r _ _ line _; do\n                case $line in\n                    # Match 'ProductVersion' and read the next line\n                    # directly as it contains the key's value.\n                    ProductVersion)\n                        IFS='<>' read -r _ _ mac_version _\n                        continue\n                    ;;\n\n                    ProductName)\n                        IFS='<>' read -r _ _ mac_product _\n                        continue\n                    ;;\n                esac\n            done < /System/Library/CoreServices/SystemVersion.plist\n\n            # Use the ProductVersion to determine which macOS/OS X codename\n            # the system has. As far as I'm aware there's no \"dynamic\" way\n            # of grabbing this information.\n            case $mac_version in\n                (10.4*)  distro='Mac OS X Tiger' ;;\n                (10.5*)  distro='Mac OS X Leopard' ;;\n                (10.6*)  distro='Mac OS X Snow Leopard' ;;\n                (10.7*)  distro='Mac OS X Lion' ;;\n                (10.8*)  distro='OS X Mountain Lion' ;;\n                (10.9*)  distro='OS X Mavericks' ;;\n                (10.10*) distro='OS X Yosemite' ;;\n                (10.11*) distro='OS X El Capitan' ;;\n                (10.12*) distro='macOS Sierra' ;;\n                (10.13*) distro='macOS High Sierra' ;;\n                (10.14*) distro='macOS Mojave' ;;\n                (10.15*) distro='macOS Catalina' ;;\n                (11*)    distro='macOS Big Sur' ;;\n                (12*)    distro='macOS Monterey' ;;\n                (*)      distro='macOS' ;;\n            esac\n\n            # Use the ProductName to determine if we're running in iOS.\n            case $mac_product in\n                (iP*) distro='iOS' ;;\n            esac\n\n            distro=\"$distro $mac_version\"\n        ;;\n\n        (Haiku)\n            # Haiku uses 'uname -v' for version information\n            # instead of 'uname -r' which only prints '1'.\n            distro=$(uname -sv)\n        ;;\n\n        (Minix|DragonFly)\n            distro=\"$os $kernel\"\n\n            # Minix and DragonFly don't support the escape\n            # sequences used, clear the exit trap.\n            trap '' EXIT\n        ;;\n\n        (SunOS)\n            # Grab the first line of the '/etc/release' file\n            # discarding everything after '('.\n            IFS='(' read -r distro _ < /etc/release\n        ;;\n\n        (OpenBSD*)\n            # Show the OpenBSD version type (current if present).\n            # kern.version=OpenBSD 6.6-current (GENERIC.MP) ...\n            IFS=' =' read -r _ distro openbsd_ver _ <<-EOF\n\t\t\t\t$(sysctl kern.version)\n\t\t\tEOF\n\n            distro=\"$distro $openbsd_ver\"\n        ;;\n\n        (FreeBSD)\n            distro=\"$os $(freebsd-version)\"\n        ;;\n\n        (*)\n            # Catch all to ensure '$distro' is never blank.\n            # This also handles the BSDs.\n            distro=\"$os $kernel\"\n        ;;\n    esac\n}\n\nget_kernel() {\n    case $os in\n        # Don't print kernel output on some systems as the\n        # OS name includes it.\n        (*BSD*|Haiku|Minix)\n            return\n        ;;\n    esac\n\n    # '$kernel' is the cached output of 'uname -r'.\n    log kernel \"$kernel\" >&6\n}\n\nget_host() {\n    case $os in\n        (Linux*)\n            # Despite what these files are called, version doesn't\n            # always contain the version nor does name always contain\n            # the name.\n            read -r name    < /sys/devices/virtual/dmi/id/product_name\n            read -r version < /sys/devices/virtual/dmi/id/product_version\n            read -r model   < /sys/firmware/devicetree/base/model\n\n            host=\"$name $version $model\"\n        ;;\n\n        (Darwin* | FreeBSD* | DragonFly*)\n            host=$(sysctl -n hw.model)\n        ;;\n\n        (NetBSD*)\n            host=$(sysctl -n machdep.dmi.system-vendor \\\n                             machdep.dmi.system-product)\n        ;;\n\n        (OpenBSD*)\n            host=$(sysctl -n hw.version)\n        ;;\n\n        (*BSD* | Minix)\n            host=$(sysctl -n hw.vendor hw.product)\n        ;;\n    esac\n\n    # Turn the host string into an argument list so we can iterate\n    # over it and remove OEM strings and other information which\n    # shouldn't be displayed.\n    #\n    # Disable the shellcheck warning for word-splitting\n    # as it's safe and intended ('set -f' disables globbing).\n    # shellcheck disable=2046,2086\n    {\n        set -f\n        set +f -- $host\n        host=\n    }\n\n    # Iterate over the host string word by word as a means of stripping\n    # unwanted and OEM information from the string as a whole.\n    #\n    # This could have been implemented using a long 'sed' command with\n    # a list of word replacements, however I want to show that something\n    # like this is possible in pure sh.\n    #\n    # This string reconstruction is needed as some OEMs either leave the\n    # identification information as \"To be filled by OEM\", \"Default\",\n    # \"undefined\" etc and we shouldn't print this to the screen.\n    for word do\n        # This works by reconstructing the string by excluding words\n        # found in the \"blacklist\" below. Only non-matches are appended\n        # to the final host string.\n        case $word in\n           (To      | [Bb]e      | [Ff]illed | [Bb]y  | O.E.M.  | OEM  |\\\n            Not     | Applicable | Specified | System | Product | Name |\\\n            Version | Undefined  | Default   | string | INVALID | ï¿½    | os |\\\n            Type1ProductConfigId )\n                continue\n            ;;\n        esac\n\n        host=\"$host$word \"\n    done\n\n    # '$arch' is the cached output from 'uname -m'.\n    log host \"${host:-$arch}\" >&6\n}\n\nget_uptime() {\n    # Uptime works by retrieving the data in total seconds and then\n    # converting that data into days, hours and minutes using simple\n    # math.\n    case $os in\n        (Linux* | Minix* | SerenityOS*)\n            IFS=. read -r s _ < /proc/uptime\n        ;;\n\n        (Darwin* | *BSD* | DragonFly*)\n            s=$(sysctl -n kern.boottime)\n\n            # Extract the uptime in seconds from the following output:\n            # [...] { sec = 1271934886, usec = 667779 } Thu Apr 22 12:14:46 2010\n            s=${s#*=}\n            s=${s%,*}\n\n            # The uptime format from 'sysctl' needs to be subtracted from\n            # the current time in seconds.\n            s=$(($(date +%s) - s))\n        ;;\n\n        (Haiku)\n            # The boot time is returned in microseconds, convert it to\n            # regular seconds.\n            s=$(($(system_time) / 1000000))\n        ;;\n\n        (SunOS)\n            # Split the output of 'kstat' on '.' and any white-space\n            # which exists in the command output.\n            #\n            # The output is as follows:\n            # unix:0:system_misc:snaptime\t14809.906993005\n            #\n            # The parser extracts:          ^^^^^\n            IFS='\t.' read -r _ s _ <<-EOF\n\t\t\t\t$(kstat -p unix:0:system_misc:snaptime)\n\t\t\tEOF\n        ;;\n\n        (IRIX)\n            # Grab the uptime in a pretty format. Usually,\n            # 00:00:00 from the 'ps' command.\n            t=$(LC_ALL=POSIX ps -o etime= -p 1)\n\n            # Split the pretty output into days or hours\n            # based on the uptime.\n            case $t in\n                (*-*)   d=${t%%-*} t=${t#*-} ;;\n                (*:*:*) h=${t%%:*} t=${t#*:} ;;\n            esac\n\n            h=${h#0} t=${t#0}\n\n            # Convert the split pretty fields back into\n            # seconds so we may re-convert them to our format.\n            s=$((${d:-0}*86400 + ${h:-0}*3600 + ${t%%:*}*60 + ${t#*:}))\n        ;;\n    esac\n\n    # Convert the uptime from seconds into days, hours and minutes.\n    d=$((s / 60 / 60 / 24))\n    h=$((s / 60 / 60 % 24))\n    m=$((s / 60 % 60))\n\n    # Only append days, hours and minutes if they're non-zero.\n    case \"$d\" in ([!0]*) uptime=\"${uptime}${d}d \"; esac\n    case \"$h\" in ([!0]*) uptime=\"${uptime}${h}h \"; esac\n    case \"$m\" in ([!0]*) uptime=\"${uptime}${m}m \"; esac\n\n    log uptime \"${uptime:-0m}\" >&6\n}\n\nget_pkgs() {\n    # This works by first checking for which package managers are\n    # installed and finally by printing each package manager's\n    # package list with each package one per line.\n    #\n    # The output from this is then piped to 'wc -l' to count each\n    # line, giving us the total package count of whatever package\n    # managers are installed.\n    packages=$(\n        case $os in\n            (Linux*)\n                # Commands which print packages one per line.\n                has bonsai     && bonsai list\n                has crux       && pkginfo -i\n                has pacman-key && pacman -Qq\n                has dpkg       && dpkg-query -f '.\\n' -W\n                has rpm        && rpm -qa\n                has xbps-query && xbps-query -l\n                has apk        && apk info\n                has guix       && guix package --list-installed\n                has opkg       && opkg list-installed\n\n                # Directories containing packages.\n                has kiss       && printf '%s\\n' /var/db/kiss/installed/*/\n                has cpt-list   && printf '%s\\n' /var/db/cpt/installed/*/\n                has brew       && printf '%s\\n' \"$(brew --cellar)/\"*\n                has emerge     && printf '%s\\n' /var/db/pkg/*/*/\n                has pkgtool    && printf '%s\\n' /var/log/packages/*\n                has eopkg      && printf '%s\\n' /var/lib/eopkg/package/*\n\n                # 'nix' requires two commands.\n                has nix-store  && {\n                    nix-store -q --requisites /run/current-system/sw\n                    nix-store -q --requisites ~/.nix-profile\n                }\n            ;;\n\n            (Darwin*)\n                # Commands which print packages one per line.\n                has pkgin      && pkgin list\n                has dpkg       && dpkg-query -f '.\\n' -W\n\n                # Directories containing packages.\n                has brew       && printf '%s\\n' /usr/local/Cellar/*\n\n                # 'port' prints a single line of output to 'stdout'\n                # when no packages are installed and exits with\n                # success causing a false-positive of 1 package\n                # installed.\n                #\n                # 'port' should really exit with a non-zero code\n                # in this case to allow scripts to cleanly handle\n                # this behavior.\n                has port       && {\n                    pkg_list=$(port installed)\n\n                    case \"$pkg_list\" in\n                        (\"No ports are installed.\")\n                            # do nothing\n                        ;;\n\n                        (*)\n                            printf '%s\\n' \"$pkg_list\"\n                        ;;\n                    esac\n                }\n            ;;\n\n            (FreeBSD*|DragonFly*)\n                pkg info\n            ;;\n\n            (OpenBSD*)\n                printf '%s\\n' /var/db/pkg/*/\n            ;;\n\n            (NetBSD*)\n                pkg_info\n            ;;\n\n            (Haiku)\n                printf '%s\\n' /boot/system/package-links/*\n            ;;\n\n            (Minix)\n                printf '%s\\n' /usr/pkg/var/db/pkg/*/\n            ;;\n\n            (SunOS)\n                has pkginfo && pkginfo -i\n                has pkg     && pkg list\n            ;;\n\n            (IRIX)\n                versions -b\n            ;;\n\n            (SerenityOS)\n                while IFS=\" \" read -r type _; do\n                    [ \"$type\" != dependency ] &&\n                        printf \"\\n\"\n                done < /usr/Ports/packages.db\n            ;;\n        esac | wc -l\n    )\n\n    # 'wc -l' can have leading and/or trailing whitespace\n    # depending on the implementation, so strip them.\n    # Procedure explained at https://github.com/dylanaraps/pure-sh-bible\n    # (trim-leading-and-trailing-white-space-from-string)\n    packages=${packages#\"${packages%%[![:space:]]*}\"}\n    packages=${packages%\"${packages##*[![:space:]]}\"}\n\n    case $os in\n        # IRIX's package manager adds 3 lines of extra\n        # output which we must account for here.\n        (IRIX)\n            packages=$((packages - 3))\n        ;;\n\n        # OpenBSD's wc prints whitespace before the output\n        # which needs to be stripped.\n        (OpenBSD)\n            packages=$((packages))\n        ;;\n    esac\n\n    case $packages in\n        (1?*|[2-9]*)\n            log pkgs \"$packages\" >&6\n        ;;\n    esac\n}\n\nget_memory() {\n    case $os in\n        # Used memory is calculated using the following \"formula\":\n        # MemUsed = MemTotal + Shmem - MemFree - Buffers - Cached - SReclaimable\n        # Source: https://github.com/KittyKatt/screenFetch/issues/386\n        (Linux*)\n            # Parse the '/proc/meminfo' file splitting on ':' and 'k'.\n            # The format of the file is 'key:   000kB' and an additional\n            # split is used on 'k' to filter out 'kB'.\n            while IFS=':k '  read -r key val _; do\n                case $key in\n                    (MemTotal)\n                        mem_used=$((mem_used + val))\n                        mem_full=$val\n                    ;;\n\n                    (Shmem)\n                        mem_used=$((mem_used + val))\n                    ;;\n\n                    (MemFree | Buffers | Cached | SReclaimable)\n                        mem_used=$((mem_used - val))\n                    ;;\n\n                    # If detected this will be used over the above calculation\n                    # for mem_used. Available since Linux 3.14rc.\n                    # See kernel commit 34e431b0ae398fc54ea69ff85ec700722c9da773\n                    (MemAvailable)\n                        mem_avail=$val\n                    ;;\n                esac\n            done < /proc/meminfo\n\n            case $mem_avail in\n                (*[0-9]*)\n                    mem_used=$(((mem_full - mem_avail) / 1024))\n                ;;\n\n                *)\n                    mem_used=$((mem_used / 1024))\n                ;;\n            esac\n\n            mem_full=$((mem_full / 1024))\n        ;;\n\n        # Used memory is calculated using the following \"formula\":\n        # (wired + active + occupied) * 4 / 1024\n        (Darwin*)\n            mem_full=$(($(sysctl -n hw.memsize) / 1024 / 1024))\n\n            # Parse the 'vmstat' file splitting on ':' and '.'.\n            # The format of the file is 'key:   000.' and an additional\n            # split is used on '.' to filter it out.\n            while IFS=:. read -r key val; do\n                case $key in\n                    (*' wired'*|*' active'*|*' occupied'*)\n                        mem_used=$((mem_used + ${val:-0}))\n                    ;;\n                esac\n\n            # Using '<<-EOF' is the only way to loop over a command's\n            # output without the use of a pipe ('|').\n            # This ensures that any variables defined in the while loop\n            # are still accessible in the script.\n            done <<-EOF\n                $(vm_stat)\n\t\t\tEOF\n\n            mem_used=$((mem_used * 4 / 1024))\n        ;;\n\n        (OpenBSD*)\n            mem_full=$(($(sysctl -n hw.physmem) / 1024 / 1024))\n\n            # This is a really simpler parser for 'vmstat' which grabs\n            # the used memory amount in a lazy way. 'vmstat' prints 3\n            # lines of output with the needed value being stored in the\n            # final line.\n            #\n            # This loop simply grabs the 3rd element of each line until\n            # the EOF is reached. Each line overwrites the value of the\n            # previous one so we're left with what we wanted. This isn't\n            # slow as only 3 lines are parsed.\n            while read -r _ _ line _; do\n                mem_used=${line%%M}\n\n            # Using '<<-EOF' is the only way to loop over a command's\n            # output without the use of a pipe ('|').\n            # This ensures that any variables defined in the while loop\n            # are still accessible in the script.\n            done <<-EOF\n                $(vmstat)\n\t\t\tEOF\n        ;;\n\n        # Used memory is calculated using the following \"formula\":\n        # mem_full - ((inactive + free + cache) * page_size / 1024)\n        (FreeBSD*|DragonFly*)\n            mem_full=$(($(sysctl -n hw.physmem) / 1024 / 1024))\n\n            # Use 'set --' to store the output of the command in the\n            # argument list. POSIX sh has no arrays but this is close enough.\n            #\n            # Disable the shellcheck warning for word-splitting\n            # as it's safe and intended ('set -f' disables globbing).\n            # shellcheck disable=2046\n            {\n                set -f\n                set +f -- $(sysctl -n hw.pagesize \\\n                                      vm.stats.vm.v_inactive_count \\\n                                      vm.stats.vm.v_free_count \\\n                                      vm.stats.vm.v_cache_count)\n            }\n\n            # Calculate the amount of used memory.\n            # $1: hw.pagesize\n            # $2: vm.stats.vm.v_inactive_count\n            # $3: vm.stats.vm.v_free_count\n            # $4: vm.stats.vm.v_cache_count\n            mem_used=$((mem_full - (($2 + $3 + $4) * $1 / 1024 / 1024)))\n        ;;\n\n        (NetBSD*)\n            mem_full=$(($(sysctl -n hw.physmem64) / 1024 / 1024))\n\n            # NetBSD implements a lot of the Linux '/proc' filesystem,\n            # this uses the same parser as the Linux memory detection.\n            while IFS=':k ' read -r key val _; do\n                case $key in\n                    (MemFree)\n                        mem_free=$((val / 1024))\n                        break\n                    ;;\n                esac\n            done < /proc/meminfo\n\n            mem_used=$((mem_full - mem_free))\n        ;;\n\n        (Haiku)\n            # Read the first line of 'sysinfo -mem' splitting on\n            # '(', ' ', and ')'. The needed information is then\n            # stored in the 5th and 7th elements. Using '_' \"consumes\"\n            # an element allowing us to proceed to the next one.\n            #\n            # The parsed format is as follows:\n            # 3501142016 bytes free      (used/max  792645632 / 4293787648)\n            IFS='( )' read -r _ _ _ _ mem_used _ mem_full <<-EOF\n                $(sysinfo -mem)\n\t\t\tEOF\n\n            mem_used=$((mem_used / 1024 / 1024))\n            mem_full=$((mem_full / 1024 / 1024))\n        ;;\n\n        (Minix)\n            # Minix includes the '/proc' filesystem though the format\n            # differs from Linux. The '/proc/meminfo' file is only a\n            # single line with space separated elements and elements\n            # 2 and 3 contain the total and free memory numbers.\n            read -r _ mem_full mem_free _ < /proc/meminfo\n\n            mem_used=$(((mem_full - mem_free) / 1024))\n            mem_full=$(( mem_full / 1024))\n        ;;\n\n        (SunOS)\n            hw_pagesize=$(pagesize)\n\n            # 'kstat' outputs memory in the following format:\n            # unix:0:system_pages:pagestotal\t1046397\n            # unix:0:system_pages:pagesfree\t\t885018\n            #\n            # This simply uses the first \"element\" (white-space\n            # separated) as the key and the second element as the\n            # value.\n            #\n            # A variable is then assigned based on the key.\n            while read -r key val; do\n                case $key in\n                    (*total)\n                        pages_full=$val\n                    ;;\n\n                    (*free)\n                        pages_free=$val\n                    ;;\n                esac\n            done <<-EOF\n\t\t\t\t$(kstat -p unix:0:system_pages:pagestotal \\\n                           unix:0:system_pages:pagesfree)\n\t\t\tEOF\n\n            mem_full=$((pages_full * hw_pagesize / 1024 / 1024))\n            mem_free=$((pages_free * hw_pagesize / 1024 / 1024))\n            mem_used=$((mem_full - mem_free))\n        ;;\n\n        (IRIX)\n            # Read the memory information from the 'top' command. Parse\n            # and split each line until we reach the line starting with\n            # \"Memory\".\n            #\n            # Example output: Memory: 160M max, 147M avail, .....\n            while IFS=' :' read -r label mem_full _ mem_free _; do\n                case $label in\n                    (Memory)\n                        mem_full=${mem_full%M}\n                        mem_free=${mem_free%M}\n                        break\n                    ;;\n                esac\n            done <<-EOF\n                $(top -n)\n\t\t\tEOF\n\n            mem_used=$((mem_full - mem_free))\n        ;;\n\n        (SerenityOS)\n            IFS='{}' read -r _ memstat _ < /proc/memstat\n\n            set -f -- \"$IFS\"\n            IFS=,\n\n            for pair in $memstat; do\n                case $pair in\n                    (*user_physical_allocated*)\n                        mem_used=${pair##*:}\n                    ;;\n\n                    (*user_physical_available*)\n                        mem_free=${pair##*:}\n                    ;;\n                esac\n            done\n\n            IFS=$1\n            set +f --\n\n            mem_used=$((mem_used * 4096 / 1024 / 1024))\n            mem_free=$((mem_free * 4096 / 1024 / 1024))\n\n            mem_full=$((mem_used + mem_free))\n        ;;\n    esac\n\n    log memory \"${mem_used:-?}M / ${mem_full:-?}M\" >&6\n}\n\nget_wm() {\n    case $os in\n        (Darwin*)\n            # Don't display window manager on macOS.\n        ;;\n\n        (*)\n            # xprop can be used to grab the window manager's properties\n            # which contains the window manager's name under '_NET_WM_NAME'.\n            #\n            # The upside to using 'xprop' is that you don't need to hardcode\n            # a list of known window manager names. The downside is that\n            # not all window managers conform to setting the '_NET_WM_NAME'\n            # atom..\n            #\n            # List of window managers which fail to set the name atom:\n            # catwm, fvwm, dwm, 2bwm, monster, wmaker and sowm [mine! ;)].\n            #\n            # The final downside to this approach is that it does _not_\n            # support Wayland environments. The only solution which supports\n            # Wayland is the 'ps' parsing mentioned below.\n            #\n            # A more naive implementation is to parse the last line of\n            # '~/.xinitrc' to extract the second white-space separated\n            # element.\n            #\n            # The issue with an approach like this is that this line data\n            # does not always equate to the name of the window manager and\n            # could in theory be _anything_.\n            #\n            # This also fails when the user launches xorg through a display\n            # manager or other means.\n            #\n            #\n            # Another naive solution is to parse 'ps' with a hardcoded list\n            # of window managers to detect the current window manager (based\n            # on what is running).\n            #\n            # The issue with this approach is the need to hardcode and\n            # maintain a list of known window managers.\n            #\n            # Another issue is that process names do not always equate to\n            # the name of the window manager. False-positives can happen too.\n            #\n            # This is the only solution which supports Wayland based\n            # environments sadly. It'd be nice if some kind of standard were\n            # established to identify Wayland environments.\n            #\n            # pfetch's goal is to remain _simple_, if you'd like a \"full\"\n            # implementation of window manager detection use 'neofetch'.\n            #\n            # Neofetch use a combination of 'xprop' and 'ps' parsing to\n            # support all window managers (including non-conforming and\n            # Wayland) though it's a lot more complicated!\n\n            # Don't display window manager if X isn't running.\n            [ \"$DISPLAY\" ] || return\n\n            # This is a two pass call to xprop. One call to get the window\n            # manager's ID and another to print its properties.\n            has xprop && {\n                # The output of the ID command is as follows:\n                # _NET_SUPPORTING_WM_CHECK: window id # 0x400000\n                #\n                # To extract the ID, everything before the last space\n                # is removed.\n                id=$(xprop -root -notype _NET_SUPPORTING_WM_CHECK)\n                id=${id##* }\n\n                # The output of the property command is as follows:\n                # _NAME 8t\n                # _NET_WM_PID = 252\n                # _NET_WM_NAME = \"bspwm\"\n                # _NET_SUPPORTING_WM_CHECK: window id # 0x400000\n                # WM_CLASS = \"wm\", \"Bspwm\"\n                #\n                # To extract the name, everything before '_NET_WM_NAME = \\\"'\n                # is removed and everything after the next '\"' is removed.\n                wm=$(xprop -id \"$id\" -notype -len 25 -f _NET_WM_NAME 8t)\n            }\n\n            # Handle cases of a window manager _not_ populating the\n            # '_NET_WM_NAME' atom. Display nothing in this case.\n            case $wm in\n                (*'_NET_WM_NAME = '*)\n                    wm=${wm##*_NET_WM_NAME = \\\"}\n                    wm=${wm%%\\\"*}\n                ;;\n\n                (*)\n                    # Fallback to checking the process list\n                    # for the select few window managers which\n                    # don't set '_NET_WM_NAME'.\n                    while read -r ps_line; do\n                        case $ps_line in\n                            (*catwm*)     wm=catwm ;;\n                            (*fvwm*)      wm=fvwm ;;\n                            (*dwm*)       wm=dwm ;;\n                            (*2bwm*)      wm=2bwm ;;\n                            (*monsterwm*) wm=monsterwm ;;\n                            (*wmaker*)    wm='Window Maker' ;;\n                            (*sowm*)      wm=sowm ;;\n\t\t\t\t\t\t\t(*penrose*)   wm=penrose ;;\n                        esac\n                    done <<-EOF\n                        $(ps x)\n\t\t\t\t\tEOF\n                ;;\n            esac\n        ;;\n    esac\n\n    log wm \"$wm\" >&6\n}\n\n\nget_de() {\n    # This only supports Xorg related desktop environments though\n    # this is fine as knowing the desktop environment on Windows,\n    # macOS etc is useless (they'll always report the same value).\n    #\n    # Display the value of '$XDG_CURRENT_DESKTOP', if it's empty,\n    # display the value of '$DESKTOP_SESSION'.\n    log de \"${XDG_CURRENT_DESKTOP:-$DESKTOP_SESSION}\" >&6\n}\n\nget_shell() {\n    # Display the basename of the '$SHELL' environment variable.\n    log shell \"${SHELL##*/}\" >&6\n}\n\nget_editor() {\n    # Display the value of '$VISUAL', if it's empty, display the\n    # value of '$EDITOR'.\n    editor=${VISUAL:-\"$EDITOR\"}\n\n    log editor \"${editor##*/}\" >&6\n}\n\nget_palette() {\n    # Print the first 8 terminal colors. This uses the existing\n    # sequences to change text color with a sequence prepended\n    # to reverse the foreground and background colors.\n    #\n    # This allows us to save hardcoding a second set of sequences\n    # for background colors.\n    #\n    # False positive.\n    # shellcheck disable=2154\n    {\n        esc SGR 7\n        palette=\"$e$c1 $c1 $c2 $c2 $c3 $c3 $c4 $c4 $c5 $c5 $c6 $c6 \"\n        esc SGR 0\n        palette=\"$palette$e\"\n    }\n\n    # Print the palette with a new-line before and afterwards but no seperator.\n    printf '\\n' >&6\n    log \"$palette\n        \" \" \" \" \" >&6\n}\n\nget_ascii() {\n    # This is a simple function to read the contents of\n    # an ascii file from 'stdin'. It allows for the use\n    # of '<<-EOF' to prevent the break in indentation in\n    # this source code.\n    #\n    # This function also sets the text colors according\n    # to the ascii color.\n    read_ascii() {\n        # 'PF_COL1': Set the info name color according to ascii color.\n        # 'PF_COL3': Set the title color to some other color. Â¯\\_(ã)_/Â¯\n        PF_COL1=${PF_COL1:-${1:-7}}\n        PF_COL3=${PF_COL3:-$((${1:-7}%8+1))}\n\n        # POSIX sh has no 'var+=' so 'var=${var}append' is used. What's\n        # interesting is that 'var+=' _is_ supported inside '$(())'\n        # (arithmetic) though there's no support for 'var++/var--'.\n        #\n        # There is also no $'\\n' to add a \"literal\"(?) newline to the\n        # string. The simplest workaround being to break the line inside\n        # the string (though this has the caveat of breaking indentation).\n        while IFS= read -r line; do\n            ascii=\"$ascii$line\n\"\n        done\n    }\n\n    # This checks for ascii art in the following order:\n    # '$1':        Argument given to 'get_ascii()' directly.\n    # '$PF_ASCII': Environment variable set by user.\n    # '$distro':   The detected distribution name.\n    # '$os':       The name of the operating system/kernel.\n    #\n    # NOTE: Each ascii art below is indented using tabs, this\n    #       allows indentation to continue naturally despite\n    #       the use of '<<-EOF'.\n    #\n    # False positive.\n    # shellcheck disable=2154\n    case ${1:-${PF_ASCII:-${distro:-$os}}} in\n        ([Aa]lpine*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c4}   /\\\\ /\\\\\n\t\t\t\t  /${c7}/ ${c4}\\\\  \\\\\n\t\t\t\t /${c7}/   ${c4}\\\\  \\\\\n\t\t\t\t/${c7}//    ${c4}\\\\  \\\\\n\t\t\t\t${c7}//      ${c4}\\\\  \\\\\n\t\t\t\t         ${c4}\\\\\n\t\t\tEOF\n        ;;\n\n        ([Aa]ndroid*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2}  ;,           ,;\n\t\t\t\t${c2}   ';,.-----.,;'\n\t\t\t\t${c2}  ,'           ',\n\t\t\t\t${c2} /    O     O    \\\\\n\t\t\t\t${c2}|                 |\n\t\t\t\t${c2}'-----------------'\n\t\t\tEOF\n        ;;\n\n        ([Aa]rch*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c6}       /\\\\\n\t\t\t\t${c6}      /  \\\\\n\t\t\t\t${c6}     /\\\\   \\\\\n\t\t\t\t${c4}    /      \\\\\n\t\t\t\t${c4}   /   ,,   \\\\\n\t\t\t\t${c4}  /   |  |  -\\\\\n\t\t\t\t${c4} /_-''    ''-_\\\\\n\t\t\tEOF\n        ;;\n\n        ([Aa]rco*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c4}      /\\\\\n\t\t\t\t${c4}     /  \\\\\n\t\t\t\t${c4}    / /\\\\ \\\\\n\t\t\t\t${c4}   / /  \\\\ \\\\\n\t\t\t\t${c4}  / /    \\\\ \\\\\n\t\t\t\t${c4} / / _____\\\\ \\\\\n\t\t\t\t${c4}/_/  \\`----.\\\\_\\\\\n\t\t\tEOF\n        ;;\n\n        ([Aa]rtix*)\n            read_ascii 6 <<-EOF\n\t\t\t\t${c4}      /\\\\\n\t\t\t\t${c4}     /  \\\\\n\t\t\t\t${c4}    /\\`'.,\\\\\n\t\t\t\t${c4}   /     ',\n\t\t\t\t${c4}  /      ,\\`\\\\\n\t\t\t\t${c4} /   ,.'\\`.  \\\\\n\t\t\t\t${c4}/.,'\\`     \\`'.\\\\\n\t\t\tEOF\n        ;;\n\n        ([Bb]edrock*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c7}__\n\t\t\t\t${c7}\\\\ \\\\___\n\t\t\t\t${c7} \\\\  _ \\\\\n\t\t\t\t${c7}  \\\\___/\n\t\t\tEOF\n        ;;\n\n        ([Bb]uildroot*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}   ___\n\t\t\t\t${c3} / \\`   \\\\\n\t\t\t\t${c3}|   :  :|\n\t\t\t\t${c3}-. _:__.-\n\t\t\t\t${c3}  \\` ---- \\`\n\t\t\tEOF\n        ;;\n\n        ([Cc]el[Oo][Ss]*)\n            read_ascii 5 0 <<-EOF\n\t\t\t\t${c5}      .////\\\\\\\\\\//\\\\.\n\t\t\t\t${c5}     //_         \\\\\\\\\n\t\t\t\t${c5}    /_  ${c7}##############\n\t\t\t\t${c5}   //              *\\\\\n\t\t\t\t${c7}###############    ${c5}|#\n\t\t\t\t${c5}   \\/              */\n\t\t\t\t${c5}    \\*   ${c7}##############\n\t\t\t\t${c5}     */,        .//\n\t\t\t\t${c5}      '_///\\\\\\\\\\//_'\n\t\t\tEOF\n        ;;\n\n        ([Cc]ent[Oo][Ss]*)\n            read_ascii 5 <<-EOF\n\t\t\t\t${c2} ____${c3}^${c5}____\n\t\t\t\t${c2} |\\\\  ${c3}|${c5}  /|\n\t\t\t\t${c2} | \\\\ ${c3}|${c5} / |\n\t\t\t\t${c5}<---- ${c4}---->\n\t\t\t\t${c4} | / ${c2}|${c3} \\\\ |\n\t\t\t\t${c4} |/__${c2}|${c3}__\\\\|\n\t\t\t\t${c2}     v\n\t\t\tEOF\n        ;;\n\n        ([Cc]rystal*[Ll]inux)\n            read_ascii 5 5 <<-EOF\n\t\t\t\t${c5}        -//.     \n\t\t\t\t${c5}      -//.       \n\t\t\t\t${c5}    -//. .       \n\t\t\t\t${c5}  -//.  '//-     \n\t\t\t\t${c5} /+:      :+/    \n\t\t\t\t${c5}  .//'  .//.     \n\t\t\t\t${c5}    . .//.       \n\t\t\t\t${c5}    .//.         \n\t\t\t\t${c5}  .//.           \n\t\t\tEOF\n        ;;\n\n        ([Dd]ahlia*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c1}      _\n\t\t\t\t${c1}  ___/ \\\\___\n\t\t\t\t${c1} |   _-_   |\n\t\t\t\t${c1} | /     \\ |\n\t\t\t\t${c1}/ |       | \\\\\n\t\t\t\t${c1}\\\\ |       | /\n\t\t\t\t${c1} | \\ _ _ / |\n\t\t\t\t${c1} |___ - ___|\n\t\t\t\t${c1}     \\\\_/\n\t\t\tEOF\n        ;;\n\n        ([Dd]ebian*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c1}  _____\n\t\t\t\t${c1} /  __ \\\\\n\t\t\t\t${c1}|  /    |\n\t\t\t\t${c1}|  \\\\___-\n\t\t\t\t${c1}-_\n\t\t\t\t${c1}  --_\n\t\t\tEOF\n        ;;\n\n\t\t([Dd]evuan*)\n\t\t\tread_ascii 6 <<-EOF\n\t\t\t\t${c4} ..:::.      \n\t\t\t\t${c4}    ..-==-   \n\t\t\t\t${c4}        .+#: \n\t\t\t\t${c4}         =@@ \n\t\t\t\t${c4}      :+%@#: \n\t\t\t\t${c4}.:=+#@@%*:   \n\t\t\t\t${c4}#@@@#=:      \n\t\t\tEOF\n\t\t;;\n\n        ([Dd]ragon[Ff]ly*)\n            read_ascii 1 <<-EOF\n\t\t\t\t    ,${c1}_${c7},\n\t\t\t\t ('-_${c1}|${c7}_-')\n\t\t\t\t  >--${c1}|${c7}--<\n\t\t\t\t (_-'${c1}|${c7}'-_)\n\t\t\t\t     ${c1}|\n\t\t\t\t     ${c1}|\n\t\t\t\t     ${c1}|\n\t\t\tEOF\n        ;;\n\n        ([Ee]lementary*)\n            read_ascii <<-EOF\n\t\t\t\t${c7}  _______\n\t\t\t\t${c7} / ____  \\\\\n\t\t\t\t${c7}/  |  /  /\\\\\n\t\t\t\t${c7}|__\\\\ /  / |\n\t\t\t\t${c7}\\\\   /__/  /\n\t\t\t\t ${c7}\\\\_______/\n\t\t\tEOF\n        ;;\n\n        ([Ee]ndeavour*)\n            read_ascii 4 <<-EOF\n\t\t\t\t      ${c1}/${c4}\\\\\n\t\t\t\t    ${c1}/${c4}/  \\\\${c6}\\\\\n\t\t\t\t   ${c1}/${c4}/    \\\\ ${c6}\\\\\n\t\t\t\t ${c1}/ ${c4}/     _) ${c6})\n\t\t\t\t${c1}/_${c4}/___-- ${c6}__-\n\t\t\t\t ${c6}/____--\n\t\t\tEOF\n        ;;\n\n        ([Ff]edora*)\n            read_ascii 4 <<-EOF\n\t\t\t\t        ${c4},'''''.\n\t\t\t\t       ${c4}|   ,.  |\n\t\t\t\t       ${c4}|  |  '_'\n\t\t\t\t${c4}  ,....|  |..\n\t\t\t\t${c4}.'  ,_;|   ..'\n\t\t\t\t${c4}|  |   |  |\n\t\t\t\t${c4}|  ',_,'  |\n\t\t\t\t${c4} '.     ,'\n\t\t\t\t   ${c4}'''''\n\t\t\tEOF\n        ;;\n\n        ([Ff]ree[Bb][Ss][Dd]*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c1}/\\\\,-'''''-,/\\\\\n\t\t\t\t${c1}\\\\_)       (_/\n\t\t\t\t${c1}|           |\n\t\t\t\t${c1}|           |\n\t\t\t\t ${c1};         ;\n\t\t\t\t  ${c1}'-_____-'\n\t\t\tEOF\n        ;;\n\n        ([Gg]aruda*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c3}         _______\n\t\t\t\t${c3}      __/       \\\\_\n\t\t\t\t${c3}    _/     /      \\\\_\n\t\t\t\t${c7}  _/      /_________\\\\\n\t\t\t\t${c7}_/                  |\n\t\t\t\t${c2}\\\\     ____________\n\t\t\t\t${c2} \\\\_            __/\n\t\t\t\t${c2}   \\\\__________/\n\t\t\tEOF\n        ;;\n\n        ([Gg]entoo*)\n            read_ascii 5 <<-EOF\n\t\t\t\t${c5} _-----_\n\t\t\t\t${c5}(       \\\\\n\t\t\t\t${c5}\\\\    0   \\\\\n\t\t\t\t${c7} \\\\        )\n\t\t\t\t${c7} /      _/\n\t\t\t\t${c7}(     _-\n\t\t\t\t${c7}\\\\____-\n\t\t\tEOF\n        ;;\n\n        ([Gg][Nn][Uu]*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c2}    _-\\`\\`-,   ,-\\`\\`-_\n\t\t\t\t${c2}  .'  _-_|   |_-_  '.\n\t\t\t\t${c2}./    /_._   _._\\\\    \\\\.\n\t\t\t\t${c2}:    _/_._\\`:'_._\\\\_    :\n\t\t\t\t${c2}\\\\:._/  ,\\`   \\\\   \\\\ \\\\_.:/\n\t\t\t\t${c2}   ,-';'.@)  \\\\ @) \\\\\n\t\t\t\t${c2}   ,'/'  ..- .\\\\,-.|\n\t\t\t\t${c2}   /'/' \\\\(( \\\\\\` ./ )\n\t\t\t\t${c2}    '/''  \\\\_,----'\n\t\t\t\t${c2}      '/''   ,;/''\n\t\t\t\t${c2}         \\`\\`;'\n\t\t\tEOF\n        ;;\n\n        ([Gg]uix[Ss][Dd]*|[Gg]uix*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}|.__          __.|\n\t\t\t\t${c3}|__ \\\\        / __|\n\t\t\t\t   ${c3}\\\\ \\\\      / /\n\t\t\t\t    ${c3}\\\\ \\\\    / /\n\t\t\t\t     ${c3}\\\\ \\\\  / /\n\t\t\t\t      ${c3}\\\\ \\\\/ /\n\t\t\t\t       ${c3}\\\\__/\n\t\t\tEOF\n        ;;\n\n        ([Hh]aiku*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}       ,^,\n\t\t\t\t ${c3}     /   \\\\\n\t\t\t\t${c3}*--_ ;     ; _--*\n\t\t\t\t${c3}\\\\   '\"     \"'   /\n\t\t\t\t ${c3}'.           .'\n\t\t\t\t${c3}.-'\"         \"'-.\n\t\t\t\t ${c3}'-.__.   .__.-'\n\t\t\t\t       ${c3}|_|\n\t\t\tEOF\n        ;;\n\n        ([Hh]ydroOS*)\n\t\t\tread_ascii 4 <<-EOF\n\t\t\t\t${c1}ââââââââââââââ¦âââ\n\t\t\t\t${c1}ââââ â¦â¦ââ â¦â¦ââ£âââââ£\n\t\t\t\t${c1}âââââââ¬âââ£â¬âââ âââ\n\t\t\t\t${c1}ââââ¬ââ ââ©ââââ©ââ©âââ\n\t\t\t\t${c1}ââââââ\n\t\t\tEOF\n        ;;\n\n        ([Hh]yperbola*)\n            read_ascii <<-EOF\n\t\t\t\t${c7}    |\\`__.\\`/\n\t\t\t\t   ${c7} \\____/\n\t\t\t\t   ${c7} .--.\n\t\t\t\t  ${c7} /    \\\\\n\t\t\t\t ${c7} /  ___ \\\\\n\t\t\t\t ${c7}/ .\\`   \\`.\\\\\n\t\t\t\t${c7}/.\\`      \\`.\\\\\n\t\t\tEOF\n        ;;\n\n        ([Ii]glunix*)\n            read_ascii <<-EOF\n\t\t\t\t${c0}       |\n\t\t\t\t${c0}       |          |\n\t\t\t\t${c0}                  |\n\t\t\t\t${c0}  |    ________\n\t\t\t\t${c0}  |  /\\\\   |    \\\\\n\t\t\t\t${c0}    /  \\\\  |     \\\\  |\n\t\t\t\t${c0}   /    \\\\        \\\\ |\n\t\t\t\t${c0}  /      \\\\________\\\\\n\t\t\t\t${c0}  \\\\      /        /\n\t\t\t\t${c0}   \\\\    /        /\n\t\t\t\t${c0}    \\\\  /        /\n\t\t\t\t${c0}     \\\\/________/\n\t\t\tEOF\n        ;;\n\n        ([Ii]nstant[Oo][Ss]*)\n            read_ascii <<-EOF\n\t\t\t\t${c0} ,-''-,\n\t\t\t\t${c0}: .''. :\n\t\t\t\t${c0}: ',,' :\n\t\t\t\t${c0} '-____:__\n\t\t\t\t${c0}       :  \\`.\n\t\t\t\t${c0}       \\`._.'\n\t\t\tEOF\n        ;;\n\n        ([Ii][Rr][Ii][Xx]*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c1} __\n\t\t\t\t${c1} \\\\ \\\\   __\n\t\t\t\t${c1}  \\\\ \\\\ / /\n\t\t\t\t${c1}   \\\\ v /\n\t\t\t\t${c1}   / . \\\\\n\t\t\t\t${c1}  /_/ \\\\ \\\\\n\t\t\t\t${c1}       \\\\_\\\\\n\t\t\tEOF\n        ;;\n\n        ([Kk][Dd][Ee]*[Nn]eon*)\n            read_ascii 6 <<-EOF\n\t\t\t\t${c7}   .${c6}__${c7}.${c6}__${c7}.\n\t\t\t\t${c6}  /  _${c7}.${c6}_  \\\\\n\t\t\t\t${c6} /  /   \\\\  \\\\\n\t\t\t\t${c7} . ${c6}|  ${c7}O${c6}  | ${c7}.\n\t\t\t\t${c6} \\\\  \\\\_${c7}.${c6}_/  /\n\t\t\t\t${c6}  \\\\${c7}.${c6}__${c7}.${c6}__${c7}.${c6}/\n\t\t\tEOF\n        ;;\n\n        ([Ll]inux*[Ll]ite*|[Ll]ite*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}   /\\\\\n\t\t\t\t${c3}  /  \\\\\n\t\t\t\t${c3} / ${c7}/ ${c3}/\n\t\t\t${c3}> ${c7}/ ${c3}/\n\t\t\t\t${c3}\\\\ ${c7}\\\\ ${c3}\\\\\n\t\t\t\t ${c3}\\\\_${c7}\\\\${c3}_\\\\\n\t\t\t\t${c7}    \\\\\n\t\t\tEOF\n        ;;\n\n        ([Ll]inux*[Mm]int*|[Mm]int)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2} ___________\n\t\t\t\t${c2}|_          \\\\\n\t\t\t\t  ${c2}| ${c7}| _____ ${c2}|\n\t\t\t\t  ${c2}| ${c7}| | | | ${c2}|\n\t\t\t\t  ${c2}| ${c7}| | | | ${c2}|\n\t\t\t\t  ${c2}| ${c7}\\\\__${c7}___/ ${c2}|\n\t\t\t\t  ${c2}\\\\_________/\n\t\t\tEOF\n        ;;\n\n\n        ([Ll]inux*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c4}    ___\n\t\t\t\t   ${c4}(${c7}.. ${c4}|\n\t\t\t\t   ${c4}(${c5}<> ${c4}|\n\t\t\t\t  ${c4}/ ${c7}__  ${c4}\\\\\n\t\t\t\t ${c4}( ${c7}/  \\\\ ${c4}/|\n\t\t\t\t${c5}_${c4}/\\\\ ${c7}__)${c4}/${c5}_${c4})\n\t\t\t\t${c5}\\/${c4}-____${c5}\\/\n\t\t\tEOF\n        ;;\n\n        ([Mm]ac[Oo][Ss]*|[Dd]arwin*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c2}       .:'\n\t\t\t\t${c2}    _ :'_\n\t\t\t\t${c3} .'\\`_\\`-'_\\`\\`.\n\t\t\t\t${c1}:________.-'\n\t\t\t\t${c1}:_______:\n\t\t\t\t${c4} :_______\\`-;\n\t\t\t\t${c5}  \\`._.-._.'\n\t\t\tEOF\n        ;;\n\n        ([Mm]ageia*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c6}   *\n\t\t\t\t${c6}    *\n\t\t\t\t${c6}   **\n\t\t\t\t${c7} /\\\\__/\\\\\n\t\t\t\t${c7}/      \\\\\n\t\t\t\t${c7}\\\\      /\n\t\t\t\t${c7} \\\\____/\n\t\t\tEOF\n        ;;\n\n        ([Mm]anjaro*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2}||||||||| ||||\n\t\t\t\t${c2}||||||||| ||||\n\t\t\t\t${c2}||||      ||||\n\t\t\t\t${c2}|||| |||| ||||\n\t\t\t\t${c2}|||| |||| ||||\n\t\t\t\t${c2}|||| |||| ||||\n\t\t\t\t${c2}|||| |||| ||||\n\t\t\tEOF\n        ;;\n\n        ([Mm]inix*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c4} ,,        ,,\n\t\t\t\t${c4};${c7},${c4} ',    ,' ${c7},${c4};\n\t\t\t\t${c4}; ${c7}',${c4} ',,' ${c7},'${c4} ;\n\t\t\t\t${c4};   ${c7}',${c4}  ${c7},'${c4}   ;\n\t\t\t\t${c4};  ${c7};, '' ,;${c4}  ;\n\t\t\t\t${c4};  ${c7};${c4};${c7}',,'${c4};${c7};${c4}  ;\n\t\t\t\t${c4}', ${c7};${c4};;  ;;${c7};${c4} ,'\n\t\t\t\t ${c4} '${c7};${c4}'    '${c7};${c4}'\n\t\t\tEOF\n        ;;\n\n        ([Mm][Xx]*)\n            read_ascii <<-EOF\n\t\t\t\t${c7}    \\\\\\\\  /\n\t\t\t\t ${c7}    \\\\\\\\/\n\t\t\t\t ${c7}     \\\\\\\\\n\t\t\t\t ${c7}  /\\\\/ \\\\\\\\\n\t\t\t\t${c7}  /  \\\\  /\\\\\n\t\t\t\t${c7} /    \\\\/  \\\\\n\t\t\t${c7}/__________\\\\\n\t\t\tEOF\n        ;;\n\n        ([Nn]et[Bb][Ss][Dd]*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c7}\\\\\\\\${c3}\\`-______,----__\n\t\t\t\t${c7} \\\\\\\\        ${c3}__,---\\`_\n\t\t\t\t${c7}  \\\\\\\\       ${c3}\\`.____\n\t\t\t\t${c7}   \\\\\\\\${c3}-______,----\\`-\n\t\t\t\t${c7}    \\\\\\\\\n\t\t\t\t${c7}     \\\\\\\\\n\t\t\t\t${c7}      \\\\\\\\\n\t\t\tEOF\n        ;;\n\n        ([Nn]ix[Oo][Ss]*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c4}  \\\\\\\\  \\\\\\\\ //\n\t\t\t\t${c4} ==\\\\\\\\__\\\\\\\\/ //\n\t\t\t\t${c4}   //   \\\\\\\\//\n\t\t\t\t${c4}==//     //==\n\t\t\t\t${c4} //\\\\\\\\___//\n\t\t\t\t${c4}// /\\\\\\\\  \\\\\\\\==\n\t\t\t\t${c4}  // \\\\\\\\  \\\\\\\\\n\t\t\tEOF\n        ;;\n\n        ([Oo]pen[Bb][Ss][Dd]*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}      _____\n\t\t\t\t${c3}    \\\\-     -/\n\t\t\t\t${c3} \\\\_/         \\\\\n\t\t\t\t${c3} |        ${c7}O O${c3} |\n\t\t\t\t${c3} |_  <   )  3 )\n\t\t\t\t${c3} / \\\\         /\n\t\t\t\t ${c3}   /-_____-\\\\\n\t\t\tEOF\n        ;;\n\n        ([Oo]pen[Ss][Uu][Ss][Ee]*[Tt]umbleweed*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2}  _____   ______\n\t\t\t\t${c2} / ____\\\\ / ____ \\\\\n\t\t\t\t${c2}/ /    \\`/ /    \\\\ \\\\\n\t\t\t\t${c2}\\\\ \\\\____/ /,____/ /\n\t\t\t\t${c2} \\\\______/ \\\\_____/\n\t\t\tEOF\n        ;;\n\n        ([Oo]pen[Ss][Uu][Ss][Ee]*|[Oo]pen*SUSE*|SUSE*|suse*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2}  _______\n\t\t\t\t${c2}__|   __ \\\\\n\t\t\t\t${c2}     / .\\\\ \\\\\n\t\t\t\t${c2}     \\\\__/ |\n\t\t\t\t${c2}   _______|\n\t\t\t\t${c2}   \\\\_______\n\t\t\t\t${c2}__________/\n\t\t\tEOF\n        ;;\n\n        ([Oo]pen[Ww]rt*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c1} _______\n\t\t\t\t${c1}|       |.-----.-----.-----.\n\t\t\t\t${c1}|   -   ||  _  |  -__|     |\n\t\t\t\t${c1}|_______||   __|_____|__|__|\n\t\t\t\t${c1} ________|__|    __\n\t\t\t\t${c1}|  |  |  |.----.|  |_\n\t\t\t\t${c1}|  |  |  ||   _||   _|\n\t\t\t\t${c1}|________||__|  |____|\n\t\t\tEOF\n        ;;\n\n        ([Pp]arabola*)\n            read_ascii 5 <<-EOF\n\t\t\t\t${c5}  __ __ __  _\n\t\t\t\t${c5}.\\`_//_//_/ / \\`.\n\t\t\t\t${c5}          /  .\\`\n\t\t\t\t${c5}         / .\\`\n\t\t\t\t${c5}        /.\\`\n\t\t\t\t${c5}       /\\`\n\t\t\tEOF\n        ;;\n\n        ([Pp]op!_[Oo][Ss]*)\n            read_ascii 6 <<-EOF\n\t\t\t\t${c6}______\n\t\t\t\t${c6}\\\\   _ \\\\        __\n\t\t\t\t ${c6}\\\\ \\\\ \\\\ \\\\      / /\n\t\t\t\t  ${c6}\\\\ \\\\_\\\\ \\\\    / /\n\t\t\t\t   ${c6}\\\\  ___\\\\  /_/\n\t\t\t\t   ${c6} \\\\ \\\\    _\n\t\t\t\t  ${c6} __\\\\_\\\\__(_)_\n\t\t\t\t  ${c6}(___________)\n\t\t\tEOF\n        ;;\n\n        ([Pp]ure[Oo][Ss]*)\n            read_ascii <<-EOF\n\t\t\t\t${c7} _____________\n\t\t\t\t${c7}|  _________  |\n\t\t\t\t${c7}| |         | |\n\t\t\t\t${c7}| |         | |\n\t\t\t\t${c7}| |_________| |\n\t\t\t\t${c7}|_____________|\n\t\t\tEOF\n        ;;\n\n        ([Rr]aspbian*)\n            read_ascii 1 <<-EOF\n\t\t\t\t${c2}  __  __\n\t\t\t\t${c2} (_\\\\)(/_)\n\t\t\t\t${c1} (_(__)_)\n\t\t\t\t${c1}(_(_)(_)_)\n\t\t\t\t${c1} (_(__)_)\n\t\t\t\t${c1}   (__)\n\t\t\tEOF\n        ;;\n\n        ([Ss]erenity[Oo][Ss]*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c7}    _____\n\t\t\t\t${c1}  ,-${c7}     -,\n\t\t\t\t${c1} ;${c7} (       ;\n\t\t\t\t${c1}| ${c7}. \\_${c1}.,${c7}    |\n\t\t\t\t${c1}|  ${c7}o  _${c1} ',${c7}  |\n\t\t\t\t${c1} ;   ${c7}(_)${c1} )${c7} ;\n\t\t\t\t${c1}  '-_____-${c7}'\n\t\t\tEOF\n        ;;\n\n        ([Ss]lackware*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c4}   ________\n\t\t\t\t${c4}  /  ______|\n\t\t\t\t${c4}  | |______\n\t\t\t\t${c4}  \\\\______  \\\\\n\t\t\t\t${c4}   ______| |\n\t\t\t\t${c4}| |________/\n\t\t\t\t${c4}|____________\n\t\t\tEOF\n        ;;\n\n        ([Ss]olus*)\n            read_ascii 4 <<-EOF\n\t\t\t\t${c6} \n\t\t\t\t${c6}     /|\n\t\t\t\t${c6}    / |\\\\\n\t\t\t\t${c6}   /  | \\\\ _\n\t\t\t\t${c6}  /___|__\\\\_\\\\\n\t\t\t\t${c6} \\\\         /\n\t\t\t\t${c6}  \\`-------Â´\n\t\t\tEOF\n        ;;\n\n        ([Ss]un[Oo][Ss]|[Ss]olaris*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}       .   .;   .\n\t\t\t\t${c3}   .   :;  ::  ;:   .\n\t\t\t\t${c3}   .;. ..      .. .;.\n\t\t\t\t${c3}..  ..             ..  ..\n\t\t\t\t${c3} .;,                 ,;.\n\t\t\tEOF\n        ;;\n\n        ([Uu]buntu*)\n            read_ascii 3 <<-EOF\n\t\t\t\t${c3}         _\n\t\t\t\t${c3}     ---(_)\n\t\t\t\t${c3} _/  ---  \\\\\n\t\t\t\t${c3}(_) |   |\n\t\t\t\t ${c3} \\\\  --- _/\n\t\t\t\t    ${c3} ---(_)\n\t\t\tEOF\n        ;;\n\n        ([Vv]oid*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2}    _______\n\t\t\t\t${c2} _ \\\\______ -\n\t\t\t\t${c2}| \\\\  ___  \\\\ |\n\t\t\t\t${c2}| | /   \\ | |\n\t\t\t\t${c2}| | \\___/ | |\n\t\t\t\t${c2}| \\\\______ \\\\_|\n\t\t\t\t${c2} -_______\\\\\n\t\t\tEOF\n        ;;\n\n        ([Xx]eonix*)\n            read_ascii 2 <<-EOF\n\t\t\t\t${c2}    ___  ___\n\t\t\t\t${c2}___ \\  \\/  / ___\n\t\t\t\t${c2}\\  \\ \\    / /  /\n\t\t\t\t${c2} \\  \\/    \\/  /\n\t\t\t\t${c2}  \\    /\\    /\n\t\t\t\t${c2}   \\__/  \\__/\n\t\t\tEOF\n        ;;\n\n        (*)\n            # On no match of a distribution ascii art, this function calls\n            # itself again, this time to look for a more generic OS related\n            # ascii art (KISS Linux -> Linux).\n            [ \"$1\" ] || {\n                get_ascii \"$os\"\n                return\n            }\n\n            printf 'error: %s is not currently supported.\\n' \"$os\" >&6\n            printf 'error: Open an issue for support to be added.\\n' >&6\n            exit 1\n        ;;\n    esac\n\n    # Store the \"width\" (longest line) and \"height\" (number of lines)\n    # of the ascii art for positioning. This script prints to the screen\n    # *almost* like a TUI does. It uses escape sequences to allow dynamic\n    # printing of the information through user configuration.\n    #\n    # Iterate over each line of the ascii art to retrieve the above\n    # information. The 'sed' is used to strip '\\033[3Xm' color codes from\n    # the ascii art so they don't affect the width variable.\n    while read -r line; do\n        ascii_height=$((${ascii_height:-0} + 1))\n\n        # This was a ternary operation but they aren't supported in\n        # Minix's shell.\n        [ \"${#line}\" -gt \"${ascii_width:-0}\" ] &&\n            ascii_width=${#line}\n\n    # Using '<<-EOF' is the only way to loop over a command's\n    # output without the use of a pipe ('|').\n    # This ensures that any variables defined in the while loop\n    # are still accessible in the script.\n    done <<-EOF\n \t\t$(printf %s \"$ascii\" | sed 's/\u001b\\[3.m//g')\n\tEOF\n\n    # Add a gap between the ascii art and the information.\n    ascii_width=$((ascii_width + 4))\n\n    # Print the ascii art and position the cursor back where we\n    # started prior to printing it.\n    {\n        esc_p SGR 1\n        printf '%s' \"$ascii\"\n        esc_p SGR 0\n        esc_p CUU \"$ascii_height\"\n    } >&6\n}\n\nmain() {\n    case $* in\n        -v)\n            printf '%s 0.7.0\\n' \"${0##*/}\"\n            return 0\n        ;;\n\n        -d)\n            # Below exec is not run, stderr is shown.\n        ;;\n\n        '')\n            exec 2>/dev/null\n        ;;\n\n        *)\n            cat <<EOF\n${0##*/}     show system information\n${0##*/} -d  show stderr (debug mode)\n${0##*/} -v  show version information\nEOF\n            return 0\n        ;;\n    esac\n\n    # Hide 'stdout' and selectively print to it using '>&6'.\n    # This gives full control over what it displayed on the screen.\n    exec 6>&1 >/dev/null\n\n    # Store raw escape sequence character for later reuse.\n    esc_c=$(printf '\\033')\n\n    # Allow the user to execute their own script and modify or\n    # extend pfetch's behavior.\n    # shellcheck source=/dev/null\n    ! [ -f \"$PF_SOURCE\" ] || . \"$PF_SOURCE\"\n\n    # Ensure that the 'TMPDIR' is writable as heredocs use it and\n    # fail without the write permission. This was found to be the\n    # case on Android where the temporary directory requires root.\n    [ -w \"${TMPDIR:-/tmp}\" ] || export TMPDIR=~\n\n    # Generic color list.\n    # Disable warning about unused variables.\n    # shellcheck disable=2034\n    for _c in c1 c2 c3 c4 c5 c6 c7 c8; do\n        esc SGR \"3${_c#?}\" 0\n        export \"$_c=$e\"\n    done\n\n    # Disable line wrapping and catch the EXIT signal to enable it again\n    # on exit. Ideally you'd somehow query the current value and retain\n    # it but I'm yet to see this irk anyone.\n    esc_p DECAWM l >&6\n    trap 'esc_p DECAWM h >&6' EXIT\n\n    # Store the output of 'uname' to avoid calling it multiple times\n    # throughout the script. 'read <<EOF' is the simplest way of reading\n    # a command into a list of variables.\n    read -r os kernel arch <<-EOF\n\t\t$(uname -srm)\n\tEOF\n\n    # Always run 'get_os' for the purposes of detecting which ascii\n    # art to display.\n    get_os\n\n    # Allow the user to specify the order and inclusion of information\n    # functions through the 'PF_INFO' environment variable.\n    # shellcheck disable=2086\n    {\n        # Disable globbing and set the positional parameters to the\n        # contents of 'PF_INFO'.\n        set -f\n        set +f -- ${PF_INFO-ascii title os host kernel uptime pkgs memory}\n\n        # Iterate over the info functions to determine the lengths of the\n        # \"info names\" for output alignment. The option names and subtitles\n        # match 1:1 so this is thankfully simple.\n        for info do\n            command -v \"get_$info\" >/dev/null || continue\n\n            # This was a ternary operation but they aren't supported in\n            # Minix's shell.\n            [ \"${#info}\" -gt \"${info_length:-0}\" ] &&\n                info_length=${#info}\n        done\n\n        # Add an additional space of length to act as a gap.\n        info_length=$((info_length + 1))\n\n        # Iterate over the above list and run any existing \"get_\" functions.\n        for info do\n            \"get_$info\"\n        done\n    }\n\n    # Position the cursor below both the ascii art and information lines\n    # according to the height of both. If the information exceeds the ascii\n    # art in height, don't touch the cursor (0/unset), else move it down\n    # N lines.\n    #\n    # This was a ternary operation but they aren't supported in Minix's shell.\n    [ \"${info_height:-0}\" -lt \"${ascii_height:-0}\" ] &&\n        cursor_pos=$((ascii_height - info_height))\n\n    # Print '$cursor_pos' amount of newlines to correctly position the\n    # cursor. This used to be a 'printf $(seq X X)' however 'seq' is only\n    # typically available (by default) on GNU based systems!\n    while [ \"${i:=0}\" -le \"${cursor_pos:-0}\" ]; do\n        printf '\\n'\n        i=$((i + 1))\n    done >&6\n}\n\nmain \"$@\"\n"
        }
      ]
    }
  ]
}