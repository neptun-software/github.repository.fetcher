{
  "metadata": {
    "timestamp": 1736568399009,
    "page": 345,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Botspot/pi-apps",
      "stars": 2108,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2294921875,
          "content": "# ignore update folder and other files that are generated but not part of the repo\n# this allows for commits to be made from a local working pi-apps repo without pushing these file to github\nupdate\netc/genapplist-yad\ndata\nlogs\n.vscode\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 18.501953125,
          "content": "# Changelog\n\nThis changelog mainly covers major events in Pi-Apps like new apps being added. \n\nIf every action done since day one was mentioned, then \"I suppose that even the world itself could not contain the books that should be written.\" ;)  \n\nLast updated: Oct 14, 2024 by [@theofficialgman](https://github.com/theofficialgman)\n\n## New Apps changelog:\n\n- **09/22/2020** Added Arduino app\n- **09/22/2020** Added BalenaEtcher app\n- **09/22/2020** Added CommanderPi app\n- **09/22/2020** Added Cool Retro Term app\n- **09/22/2020** Added Cura app\n- **09/22/2020** Added Pi Power Tools app\n- **09/22/2020** Added template app\n- **09/22/2020** Added Windows 10 Theme app\n- **10/02/2020** Added Discord app\n- **10/02/2020** Added piKiss app\n- **10/03/2020** Added Conky app\n- **10/06/2020** Added Zoom app\n- **10/08/2020** Added Email Checker app\n- **10/10/2020** Added Color Emoji font app\n- **10/11/2020** Added Minecraft Java app\n- **10/11/2020** Added Update Buddy app\n- **10/12/2020** Added Minecraft Bedrock app\n- **10/13/2020** Added Boxy SVG app\n- **10/19/2020** Added Visual Studio Code app\n- **10/26/2020** Added Box86 app\n- **10/31/2020** Added Scrcpy app\n- **11/03/2020** Added SpeedTest-CLI app\n- **11/04/2020** Added Clam Antivirus app\n- **11/04/2020** Added USBImager app\n- **11/05/2020** Added eDEX-UI app\n- **11/06/2020** Added Chromium Widevine app\n- **11/09/2020** Added LibrePCB app\n- **11/09/2020** Added PrusaSlicer app\n- **11/16/2020** Added All Is Well app\n- **11/17/2020** Added PiGro app\n- **11/18/2020** Added Browsh app\n- **11/26/2020** Added Steam app\n- **11/28/2020** Added Pycharm CE app\n- **11/28/2020** Added WPS Office app\n- **11/29/2020** Added Timeshift app\n- **12/11/2020** Added Sublime Text app\n- **12/21/2020** Added Intellij IDEA app\n- **12/21/2020** Added Powerline-Shell app\n- **12/24/2020** Added Doom 3 app\n- **12/28/2020** Added Eagle CAD app\n- **12/28/2020** Added YouTubuddy app\n- **01/03/2021** Added Lightpad app\n- **01/03/2021** Added Mission Planner app\n- **01/03/2021** Added tldr app\n- **01/04/2021** Added Vivaldi app\n- **01/09/2021** Added Ulauncher app\n- **01/11/2021** Added AndroidBuddy app\n- **01/13/2021** Added jGRASP IDE app\n- **01/13/2021** Added Snap Store app\n- **01/16/2021** Added Angry IP scanner app\n- **01/20/2021** Added AnyDesk app\n- **01/26/2021** Added TeamViewer Host app\n- **01/27/2021** Added OBS Studio app\n- **01/28/2021** Added VeraCrypt app\n- **01/28/2021** Added VSCodium app\n- **01/30/2021** Added Minecraft Pi (Modded) app\n- **01/31/2021** Added Wine (x86) app\n- **02/01/2021** Added Remarkable app\n- **02/03/2021** Added Node.js app\n- **02/08/2021** Added FreeTube app\n- **02/08/2021** Added StackEdit app\n- **02/17/2021** Added QEMU app\n- **02/21/2021** Added Geany Dark Mode app\n- **03/04/2021** Added Mac OS Theme app\n- **03/08/2021** Added Snapdrop app\n- **03/10/2021** Added Descent 1 app\n- **03/10/2021** Added Descent 2 app\n- **03/10/2021** Added PPSSPP (PSP emulator) app\n- **03/14/2021** Added Stunt Rally app\n- **03/16/2021** Added Lokinet app\n- **03/18/2021** Added Notepad ++ app\n- **03/20/2021** Added WACUP (new WinAmp) app\n- **03/24/2021** Added Libreoffice MS theme app\n- **03/30/2021** Added Downgrade Chromium app\n- **03/30/2021** Added Github-CLI app\n- **04/06/2021** Added Wechat app\n- **04/08/2021** Added Bongo Cam app\n- **04/08/2021** Added OpenSCAD app\n- **04/10/2021** Added Flameshot app\n- **04/10/2021** Added Heroes 2 app\n- **04/10/2021** Added Processing IDE app\n- **04/10/2021** Added Scratch 2 app\n- **04/10/2021** Added Web Apps app\n- **04/12/2021** Added AstroMenace app\n- **04/13/2021** Added Lego Digital Designer app\n- **05/03/2021** Added PiSafe app\n- **05/04/2021** Added BlockPi app\n- **05/04/2021** Added Windows Screensavers app\n- **05/05/2021** Added Drawing app\n- **05/07/2021** Added Chiaki app\n- **07/02/2021** Added Conky Rings app\n- **07/02/2021** Added Https File Server app\n- **07/03/2021** Added Turbowarp app\n- **07/10/2021** Added Box64 app\n- **07/25/2021** Added Firefox Rapid Release app\n- **08/10/2021** Added Pi-Apps Terminal Plugin (bash) app\n- **08/10/2021** Added Pi-Apps Terminal Plugin (python) app\n- **08/11/2021** Added Autostar app\n- **08/11/2021** Added CloudBuddy app\n- **08/11/2021** Added Godot app\n- **09/01/2021** Added Windows Flasher app\n- **09/15/2021** Added Zoom PWA app\n- **09/19/2021** Added Sysmon app\n- **09/20/2021** Added Minecraft Java MultiMC5 app\n- **09/23/2021** Added Microsoft Teams app\n- **09/23/2021** Added WhatsApp app\n- **09/23/2021** Added XSnow app\n- **09/25/2021** Added Telegram app\n- **09/29/2021** Added Sonic Pi app\n- **10/04/2021** Added Codex app\n- **10/08/2021** Added Min app\n- **10/08/2021** Added Pale Moon app\n- **10/08/2021** Added Puffin app\n- **10/08/2021** Added Quartz app\n- **10/08/2021** Added Tor app\n- **10/11/2021** Added Amiberry app\n- **10/12/2021** Added BleachBit app\n- **10/14/2021** Added Persepolis Download Manager app\n- **10/14/2021** Added Xtreme Download Manager app\n- **10/17/2021** Added BlockBench app\n- **10/24/2021** Added Geekbench app\n- **10/26/2021** Added Oomox Theme Designer app\n- **10/26/2021** Added Temps app\n- **10/28/2021** Added Deskreen app\n- **11/06/2021** Added AntiMicroX app\n- **11/06/2021** Added btop++ app\n- **11/08/2021** Added Alacritty Terminal app\n- **11/15/2021** Added FF Multi Converter app\n- **11/30/2021** Added GIMP app\n- **11/30/2021** Added Imager app\n- **11/30/2021** Added Kolourpaint app\n- **11/30/2021** Added LibreOffice app\n- **11/30/2021** Added MuseScore app\n- **11/30/2021** Added Nautilus app\n- **11/30/2021** Added Scratch 3 app\n- **11/30/2021** Added Screenshot app\n- **11/30/2021** Added Shotwell app\n- **11/30/2021** Added Synaptic app\n- **12/01/2021** Added Filezilla app\n- **12/02/2021** Added Caprine app\n- **12/11/2021** Added Inkscape app\n- **12/13/2021** Added SysMonTask app\n- **12/15/2021** Added Audacious app\n- **12/15/2021** Added Audacity app\n- **12/15/2021** Added Chromium app\n- **12/15/2021** Added Deluge app\n- **12/15/2021** Added Disk Usage Analyzer app\n- **12/15/2021** Added GParted app\n- **12/15/2021** Added Guake Terminal app\n- **12/15/2021** Added Kodi app\n- **12/15/2021** Added NixNote2 app\n- **12/15/2021** Added Pinta app\n- **12/15/2021** Added Steam Link app\n- **12/15/2021** Added Thunderbird app\n- **12/15/2021** Added Transmission app\n- **12/21/2021** Added Unciv app\n- **01/04/2022** Added SimpleScreenRecorder app\n- **01/05/2022** Added More RAM app\n- **01/08/2022** Added Tetris CLI app\n- **01/09/2022** Added BlueJ Java IDE app\n- **01/10/2022** Added Nemo app\n- **01/19/2022** Added Microsoft PowerShell app\n- **01/19/2022** Added Minecraft Java Server app\n- **01/25/2022** Added HTTrack Website Copier app\n- **01/30/2022** Added Epiphany app\n- **02/10/2022** Added LineRider app\n- **02/12/2022** Added KeePassXC app\n- **02/21/2022** Added MatterControl app\n- **02/26/2022** Added PiKISS GUI app\n- **02/27/2022** Added Fritzing app\n- **02/28/2022** Added LibreCAD app\n- **03/01/2022** Added Cawbird app\n- **03/04/2022** Added VMware Horizon Client app\n- **03/24/2022** Added Ducopanel app\n- **03/24/2022** Added TiLP app\n- **03/25/2022** Added Syncthing app\n- **03/29/2022** Added Tabby app\n- **03/30/2022** Added Hyper app\n- **04/25/2022** Added System Monitoring Center app\n- **05/06/2022** Added Renoise (Demo) app\n- **05/07/2022** Added Github Desktop app\n- **05/07/2022** Added Reaper app\n- **05/08/2022** Added Dot Matrix app\n- **05/11/2022** Added Waveform app\n- **05/12/2022** Added LMMS app\n- **05/17/2022** Added Sphero SDK app\n- **05/18/2022** Added Electron Fiddle app\n- **05/19/2022** Added Better Chromium app\n- **05/20/2022** Added Neofetch app\n- **05/22/2022** Added ckb-next app\n- **05/23/2022** Added WorldPainter app\n- **05/24/2022** Added AbiWord app\n- **05/24/2022** Added PeaZip app\n- **05/26/2022** Added DDNet app\n- **05/31/2022** Added Linux Wifi Hotspot app\n- **05/31/2022** Added Xfburn app\n- **06/06/2022** Added Notejot app\n- **06/06/2022** Added Pac-Man app\n- **06/06/2022** Added Pika Backup app\n- **06/07/2022** Added Friday Night Funkin' Rewritten app\n- **06/13/2022** Rename TeamViewer Host to Teamviewer\n- **06/13/2022** Added Project OutFox app\n- **06/13/2022** Added PyChess app\n- **06/13/2022** Added Shattered Pixel Dungeon app\n- **06/13/2022** Added StepMania app\n- **06/17/2022** Added Marathon app\n- **06/21/2022** Added ArmCord app\n- **07/05/2022** Rename Minecraft Java to Minecraft Java Lunar\n- **07/07/2022** Added Celeste Classic app\n- **07/12/2022** Added XMRig app\n- **07/18/2022** Added Flow app\n- **09/15/2022** Added Minecraft Java GDLauncher app\n- **09/17/2022** Added Mu app\n- **10/19/2022** Added Minecraft Java Prism Launcher app\n- **01/05/2023** Added Pixelorama app\n- **01/06/2023** Added Gnome Builder IDE app\n- **03/28/2023** Added Brave app\n- **03/28/2023** Rename Discord to Webcord\n- **04/28/2023** Added Krita app\n- **04/30/2023** Added Gnome Software app\n- **05/17/2023** Added Monero GUI app\n- **05/25/2023** Rename Geekbench to Geekbench 5\n- **05/25/2023** Added Geekbench 6 app\n- **05/30/2023** Added Wine (x64) app\n- **07/06/2023** Added Caskaydia Cove NF app\n- **07/06/2023** Added Oh My Posh app\n- **08/02/2023** Added RiiTag-RPC app\n- **09/21/2023** Added Gnumeric app\n- **10/21/2023** Added Open-Typer app\n- **2/9/2024** Added Celeste64 app\n- **2/18/2024** Added Floorp app\n- **2/20/2024** Added KiCad app\n- **02/20/2024** Added ProjectLibre app\n- **02/23/2024** Added Signal app\n- **02/26/2024** Added LibreWolf app\n- **02/27/2024** Added Obsidian app\n- **03/06/2024** Added QR Code Reader app\n- **03/19/2024** Added Sound Recorder app\n- **05/09/2024** Added Mullvad app\n- **07/05/2024** Added Easy Effects app\n- **07/20/2024** Added Kdenlive app\n- **07/25/2024** Added VARA HF app\n- **08/06/2024** Added Bambu Studio app\n- **10/12/2024** Rename ArmCord to Legcord\n\n## Other notable changes:\n\n- **3/20/2020** Initial idea of an app store. https://www.raspberrypi.org/forums/viewtopic.php?f=63&t=268455\n- **9/20/2020** Development begins.\n- **9/22/2020** Initial upload to github, including these apps: Arduino, BalenaEtcher, Chromium Media Edition, CommanderPi, Cool Retro Term, Cura, FreeCAD, Pi-Power-Tools, Raspi2png, and Windows 10 Theme.  \n- **10/1/2020** Many bugs fixed, createapp added.  \n- **10/2/2020** More bug fixes & improvements.\n- **10/3/2020** Added some more icons\n- **10/4/2020** Added Pi-Apps Settings menu button, improve many descriptions, and a couple bug fixes to `pkg-install`.  \n- **10/6/2020** Added license file, and a few more bug fixes  \n- **10/7/2020** Added RetroPie app, overhaul the entire Settings app, and over 20 more bug fixes and improvements  \nAt this point, Pi-Apps is no longer in beta stage, but released on the Raspberry Pi forums.  \n- **10/9/2020** Make Zoom install pulseaudio, and compile successfully.   \nAt this point, grayduck has said Pi-Apps will be added to TwisterOS.  \n- **10/10/2020** More Zoom fixes, implement hidelist for grayduck  \n- **10/11/2020** Rename Minecraft to Minecraft Java. Zoom now disables pulseaudio autostart. \n- **10/12/2020** Write the README\n- **10/15/2020** Fix update buddy, and zoom now disables pulseaudio autostart\n- **10/18/2020** Leepspvideo posted [this video](https://www.youtube.com/watch?v=zxyWQ3FV98I) featuring Pi-Apps. As a result, 3000+ people have installed Pi-Apps.\n- **10/20/2020** Enable preloading.\n- **10/21/2020** Fix Cool-Retro-Term install bug, and enable autostarted updater.\n- **10/12/2020** ETA Prime posted [this video](https://www.youtube.com/watch?v=oqNWJ52DLes) featuring Pi-Apps. As a result, 2000+ more people have installed Pi-Apps.\n- **10/26/2020** Mask pulseaudio.service for Zoom\n- **10/31/2020** Reached 20,000 total downloads\n- **11/2/2020** Pi-Apps added to [TwisterOS](https://twisteros.com/) with the 1.8.5 patch\n- **11/4/2020** Add README badge\n- **11/6/2020** Enable multiselecting apps to install/uninstall with Ctrl + Click\n- **11/14/2020** Chromium Media Edition deprecated in favour of Chromium Widevine for Chrome v84\n- **11/24/2020** Updated to now use terminal-run to fix pi-apps not working with some terminal types. Updated all scripts to use ~/ instead of /home/pi\n- **11/26/2020** Added a credits section in the app creator\n- **11/27/2020** Added beta xlunch GUI which is more flexible than YAD.\n- **11/28/2020** Switch TBOPlayer to master branch.\n- **11/29/2020** Added testimonies, improved multi-installing apps.\n- **12/6/2020** Made Steam not install box86 on TwisterOS\n- **12/7/2020** Made Steam launch in Small mode by default\n- **12/27/2020** Boxy SVG app uses [Boxy-SVG-RPi](https://github.com/Botspot/Boxy-SVG-RPi) and Box86 app uses [box86-updater](https://github.com/Botspot/box86-updater)\n- **12/29/2020** Changed Doom 3 app to not wget script and added the \"a guy\" story in the README :laughing:\n- **1/2/2021** Removed Cordless app due to users being banned by Discord and support being dropped.\n- **1/5/2021** Added app request templates\n- **1/8/2021** Removed Chromium Media Edition app and started work on categories\n- **1/10/2021** Added categories!\n- **1/11/2021** Fixed preload error\n- **1/12/2021** Improved xlunch compilation\n- **1/13/2021** Minecraft Pi testing phase begins\n- **1/21/2021** Updated BalenaEtcher to v1.5.113\n- **1/27/2021** Added OBS Studio app\n- **1/28/2021** Added pi-apps terminal command (you can now run pi-apps with `pi-apps`). \n- **2/13/2021** Added credits button for apps\n- **2/20/2021** Changed wine install scripts and fixed WhatsApp download bug.\n- **2/28/2021** Hidden Wine on Twister OS.\n- **3/7/2021** FreeCAD now uses precompiled debs, and added issue templates for Github bug reports\n- **3/11/2021** Changed box86 install to use itai's apt repository\n- **3/12/2021** Changed Node.js app to use nvm version manager and unhid BalenaEtcher on Twister OS\n- **3/14/2021** Added a \"Installed\" category for installed apps\n- **3/15/2021** Added Back to Chromium v86 app, and updated box86 to be installable on aarch64 OSes\n- **3/16/2021** Large upgrade to Zoom app\n- **3/17/2021** Added 64-bit support for Vivaldi\n- **3/18/2021** Added Doom 3 run in a 64-bit kernel with a 32-bit userland\n- **3/19/2021** Redesign all program icons, the Pi-Apps logo, and all screenshots.\n- **3/28/2021** Hide less apps on Twister OS Lite\n- **3/30/2021** Merge all Chromium downgrade apps into \"Downgrade Chromium\"\n- **3/31/2021** Updated Arduino IDE to change install location\n- **4/3/2021** Updated Update Buddy to show a update notification like pi-apps\n- **4/7/2021** Bumped Discord version to renamed \"WebCord\"\n- **4/8/2021** Added new api script, improved icons, faster preloading. Updated whatsapp + stackedit.\n- **4/9/2021** Display user count for apps and squarify icons\n- **4/14-15-20/2021** Changed pkg-install to use dummy debs for depends to let APT handle depend issues\n- **4/24/2021** Forced updater to not update Wine and Steam on Twister OS\n- **5/4/2021** Numerous changes to api script and removed up/down buttons in GUI\n- **5/5/2021** Updated install/uninstall GUI icons\n- **5/6/2021** Updated trash icon\n- **5/7/2021** Fixed terminal title when multi-installing apps\n- **5/9/2021** Added qterminal support to pi-apps and fix Wine precompiled kernel\n- **5/14/2021** Fixed update-exclusion and preload-daemon. Also added icon for disabled apps and made piKiss 32-bit only\n- **5/19/2021** Fixed Box86 multiarch on 64-bit\n- **5/24/2021** Allowed selecting apps to update in updater and added more api functions. \n- **6/19/2021** Update MCPI Modded to v2.x and use APT repo instead of pi-apps updates to allow for faster package updates\n- **6/21/2021** Added support for STL thumbnails in file manager for Cura and 1.17 support to MC Java\n- **7/3/2021** Added install/uninstall output logging system\n- **7/4/2021** Added note about what kind of distros Pi-Apps will work on to README\n- **7/10/2021** Updated app screenshots in readme\n- **7/25/2021** Added \"Never show again\" option to updater notifications, and a 64-bit installation script for Sublime Text. Also changed updater to check for updates via `git pull` instead of old `git clone` system\n- **7/31/2021** Fixed writing update logs to home directory\n- **8/2/2021** Made Pi-Apps print support info at end of a script failure\n- **8/9/2021** Made 64-bit Zoom to use box64 and amd64 Zoom binaries, and updated install/uninstall code to mark scripts as executiable before running them\n- **8/10/2021** Added new bug reporting window after script failure, allowing users to send a bug report to the developers with the click of a button, added a bash-based terminal plugin app and auto sign unsigned APT repository. A ton of commits were made following the addition of the error reporter :)\n- **8/11/2021** Added checks for non-arm architectures and also add semi-support for Chromebooks\n- **8/13/2021** Added new \"Search\" button to search for apps\n- **8/15/2021** Added new startup splash screen to make the wait time a little less agonizing\n- **9/1/2021** Added Windows Flasher app, and translate all wget commands to aria2c for faster download speeds\n- **9/9/2021** Improve the \"Get it on Pi-Apps\" badge, and improve launch-time by optimizing the message of the day\n- **9/10/2021** All 3-month-old Pi-Apps installations are forcibly reinstalled\n- **9/21/2021** Rewrite the `updater` script for a better updating experience, and improve Pi-Apps launch-time with the genapplist-yad program\n- **9/22/2021** Optimize the update-checking time. Now it takes **2** seconds to check for updates instead of **15** seconds.\n- **9/23/2021** Add Microsoft Teams and XSnow apps; rename Whatsapp to WhatsApp\n- **9/24/2021** Improve the layout of the Pi-Apps README\n- **9/26/2021** Properly document Pi-Apps with the new DOCUMENTATION.md file\n- **10/7/2021** Replaced legacy minecraft launcher with Lunar Client and added 64-bit version of PPSSPP\n- **10/9/2021** Added the ability for users to choose between dark mode and light mode for YAD\n- **10/10/2021** Changed the \"Send Log\" feature to be available only for errors relating to the script itself and not system\n- **10/24/2021** Added a \"Import App\" button to settings\n- **10/26/2021** Added individual icons for all categories\n- **5/16/2022** Major GUI updates and script modifications made. https://github.com/Botspot/pi-apps/pull/1580 https://github.com/Botspot/pi-apps/issues/1578\n- **10/7/2022** Switch to Pi-Apps self hosted shlink server instead of bitly for analytics tracking\n- **11/4/2022** Added analytics tracking for successfull user app updates\n- **1/10-11/2023** Added Github Actions based update verification/validity checker to the automatic updater.\n- **1/12-14/2023** Updated Pi-Apps icons and logo for 2023\n- **5/3/2023** Major improvements to [pi-apps.io](https://pi-apps.io) website\n- **5/21/2023** Changed nearly all app descriptions to explicitly say how to run the app.\n- **10/14/2023** Increase minimum supported versions of Debian to Bullseye (11) and Ubuntu to Focal (20.04)\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 34.3056640625,
          "content": "GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.1083984375,
          "content": "<p align=\"center\">\n    <a href=\"https://pi-apps.io\">\n        <img src=\"https://github.com/Botspot/pi-apps/blob/master/icons/proglogo.png?raw=true\" alt=\"Pi-Apps logo\">\n    </a>\n</p>\n<p align=\"center\">The most popular app store for Raspberry Pi computers. 100% free, open-source and written in shell scripts.\n<p align=\"center\">\n  <a href=\"https://github.com/Botspot/pi-apps/blob/master/CHANGELOG.md\">\n    View changelog</a>\n  |\n  <a href=\"https://pi-apps.io/wiki/getting-started/apps-list/\">\n    Apps List</a>\n  |\n  <a href=\"https://github.com/Botspot/pi-apps/issues/new?template=bug-report.yml\">\n    Report an error</a>\n  |\n  <a href=\"https://github.com/Botspot/pi-apps/issues/new?template=suggestion.yml\">\n    Make a general suggestion</a>\n  |\n  <a href=\"https://github.com/Botspot/pi-apps/issues/new?assignees=&labels=App+Request&template=app-suggestion.yml&title=EDIT+ME+Include+the+app+name\">\n    Suggest new app</a>\n  |\n  <a href=\"https://github.com/Botspot/pi-apps/issues/new?assignees=&labels=App+Request%2CZip%2FPR+included&template=app-submission.yml&title=EDIT+ME+Include+the+app+name+and+if+it+is+a+Package+app+or+an+Install+based+App\">\n    Submit a new app</a>\n\n<p align=\"center\">\n    <a href=\"https://github.com/Botspot/pi-apps/stargazers\"><img src=\"https://img.shields.io/github/stars/Botspot/pi-apps\" alt=\"stars\"></a>\n    <a href=\"https://github.com/Botspot/pi-apps/network/members\"><img src=\"https://img.shields.io/github/forks/Botspot/pi-apps\" alt=\"forks\"></a>\n    <a href=\"https://github.com/Botspot/pi-apps/graphs/contributors\"><img src=\"https://img.shields.io/github/contributors/Botspot/pi-apps\" alt=\"contributors\"></a>\n    <a href=\"https://github.com/Botspot/pi-apps/pulls\"><img src=\"https://img.shields.io/github/issues-pr/Botspot/pi-apps\" alt=\"prs\"></a>\n    <a href=\"https://github.com/Botspot/pi-apps/issues?q=is%3Aopen+is%3Aissue+label%3Abug\"><img src=\"https://img.shields.io/github/issues/Botspot/pi-apps/bug?color=red&label=bugs\"></a>\n    <a href=\"https://github.com/Botspot/pi-apps/issues?q=is%3Aopen+is%3Aissue+label%3A%22App+Request%22\"><img src=\"https://img.shields.io/github/issues/Botspot/pi-apps/App%20Request?color=Green&label=app%20requests\"></a>\n    <a href=\"https://github.com/Botspot/pi-apps/blob/master/COPYING\"><img src=\"https://img.shields.io/github/license/Botspot/pi-apps\" alt=\"license\"></a>\n    <a href=\"https://discord.gg/RXSTvaUvuu\"><img src=\"https://img.shields.io/discord/770629697909424159.svg?color=7289da&label=Discord%20server&logo=discord\" alt=\"Join the Discord server\"></a>\n\n<p align=\"center\"><strong>Made with &#10084; by <a href=\"https://github.com/Botspot\">Botspot</a></strong>, <strong><a href=\"https://github.com/theofficialgman\">theofficialgman</a></strong>, and <a href=\"https://github.com/Botspot/pi-apps/graphs/contributors\">contributors</a>\n\n<p align=\"center\">\n    Check out our website: <a href=\"https://pi-apps.io\">pi-apps.io</a>\n</p>\n\n## Introduction\nLet's be honest: **Linux is harder to master than Windows.** Sometimes it's not user-friendly, and following an outdated tutorial may break your Raspberry Pi's operating system.  \nThere is no centralized software repository, except for the `apt` repositories which lack many desktop applications.  \nSurely there is a better way! **There is.**  \nIntroducing Pi-Apps, a well-maintained collection of app installation-scripts that you can run with **one click**.  \n\nPi-Apps now serves **over 1,000,000 people** and hosts [over 200 apps](https://pi-apps.io/wiki/getting-started/apps-list/).\n\n## Install Pi-Apps\nOpen a terminal and run this command:\n```bash\nwget -qO- https://raw.githubusercontent.com/Botspot/pi-apps/master/install | bash\n```\n<img src=\"icons/screenshots/main%20window.png?raw=true\" align=\"right\" height=\"270px\"/>\n\n### Supported systems:\n#### Raspberry Pi <img src=\"https://pi-apps.io/img/other-icons/raspberrypi-icon.svg\" height=\"14\"> (2/3/Zero 2 W/4/5)\n- <img src=\"https://pi-apps.io/img/other-icons/raspberrypi-icon.svg\" height=\"14\"> [**Raspberry Pi OS**](https://www.raspberrypi.com/software/operating-systems/) (32-bit/64-bit) (Bullseye/Bookworm): <span style=\"color:var(--success-dark);\">fully supported</span>\n- <img src=\"https://pi-apps.io/img/other-icons/ubuntu-icon.svg\" height=\"14\"> [**Ubuntu**](https://ubuntu.com/download/raspberry-pi) (Jammy/Noble): <span style=\"color:var(--success-dark);\">fully supported</span>\n#### Nintendo Switch <img src=https://pi-apps.io/img/other-icons/switch-icon.svg height=\"14\">\n- <img src=https://pi-apps.io/img/other-icons/switchroot-icon.png height=\"14\"> [**Switchroot L4T Ubuntu Noble (24.04)**](https://wiki.switchroot.org/wiki/linux/l4t-ubuntu-noble-installation-guide): <span style=\"color:var(--success-dark);\">fully supported</span>\n- <img src=https://pi-apps.io/img/other-icons/switchroot-icon.png height=\"14\"> [**Switchroot L4T Ubuntu Jammy (22.04)**](https://wiki.switchroot.org/wiki/linux/l4t-ubuntu-jammy-installation-guide): <span style=\"color:var(--success-dark);\">fully supported</span>\n#### Nvidia Jetson <img src=https://pi-apps.io/img/other-icons/nvidia-icon.svg height=\"14\">\n- <img src=https://pi-apps.io/img/other-icons/nvidia-icon.svg height=\"14\"> [**Nvidia Jetpack 6**](https://developer.nvidia.com/embedded/jetpack-sdk-61) (Ubuntu Jammy): <span style=\"color:var(--success-dark);\">fully supported</span>\n- <img src=https://pi-apps.io/img/other-icons/nvidia-icon.svg height=\"14\"> [**Nvidia Jetpack 5**](https://developer.nvidia.com/embedded/jetpack-sdk-514) (Ubuntu Focal): <span style=\"color:var(--success-dark);\">fully supported</span>\n#### Apple Silicon Macs\n- <img src=\"https://pi-apps.io/img/other-icons/ubuntu-icon.svg\" height=\"14\"> [**Ubuntu Asahi**](https://ubuntuasahi.org/) (Ubuntu Noble): <span style=\"color:var(--warn-dark);\">Not actively tested but all available apps should work</span>\n#### [**Pine64**](https://www.pine64.org/), [**Orange Pi**](http://www.orangepi.org/), [**Radxa**](https://rockpi.org/), [**Banana Pi**](https://banana-pi.org/), [**Khadas**](https://www.khadas.com/), [**Inovato**](https://www.inovato.com/), [**Libre Computer**](https://libre.computer/), and other **ARMv7/ARMv8/ARMv9** Devices\n- <img src=\"https://pi-apps.io/img/other-icons/debian-icon.svg\" height=\"14\"> [Debian Bullseye/Bookworm](https://www.debian.org/distrib/) (Official Releases from Debian **ONLY**): <span style=\"color:var(--warn-dark);\">Not actively tested but all available apps should work</span>\n- <img src=\"https://pi-apps.io/img/other-icons/ubuntu-icon.svg\" height=\"14\"> [Ubuntu Focal/Jammy/Noble](https://ubuntu.com/download/desktop) (Official Releases from Canonical **ONLY**): <span style=\"color:var(--warn-dark);\">Not actively tested but all available apps should work</span>\n\n### Unsupported systems:\n- Raspberry Pi Pico: <span style=\"color:var(--danger-dark);\">These devices are microcontrollers and cannot run linux.\n- All **UNOFFICIAL** Debian and Ubuntu based releases (unless mentioned above): <span style=\"color:var(--danger-dark);\">Expect many apps to have issues.</span>\n  - Examples: **Orange Pi OS**, <img src=\"https://pi-apps.io/img/other-icons/pop-os.svg\" height=\"14\"> [**Pop_OS!**](https://pop.system76.com/), **Kali Linux**, and **ChromeOS Crostini** Debian Container\n- Anything Non-Debian and Non-Ubuntu: <span style=\"color:var(--danger-dark);\">Expect the majority of apps and the appstore to be broken.</span>\n  - Examples: **Slackware**, **RHEL**, **Fedora**, **SUSE**, **Arch Linux**, **Gentoo**, **Void Linux**, **NixOS**\n- Anything not already mentioned: <span style=\"color:var(--danger-dark);\">Expect nothing to work.</span>\n  - Examples: **Microsoft Windows**, **MacOS**, **Android**, and **ChromeOS**\n\n<details>\n<summary><b>To install Pi-Apps manually</b> if you prefer to see what happens under the hood</summary>\n \n```\ngit clone https://github.com/Botspot/pi-apps\n~/pi-apps/install\n```\n</details>\n\n<details>\n<summary><b>To uninstall Pi-Apps</b></summary>\nThis will not uninstall any apps that you installed through Pi-Apps.\n\n```\n~/pi-apps/uninstall\n```\n</details>\n\n## To run Pi-Apps\n- From the start menu: Accessories -> Pi-Apps\n- Use the terminal command: `pi-apps`\n- Run Pi-Apps from its directory: `~/pi-apps/gui`\n\n## To update Pi-Apps\n- Pi-apps will automatically check for updates on boot and display a notification to update.\n- To manually run the updater, use this command: `~/pi-apps/updater gui`\n- It also supports a cli interface: `~/pi-apps/updater cli`\n\n## What do others say about Pi-Apps?\n> Message from a **[pi-top](https://pi-top.com)** employee: \"Happy to say that I recommend pi-apps to almost every school I work with when they start using Raspberry Pi\"\n\n> [Video by **ETA Prime**](https://www.youtube.com/watch?v=oqNWJ52DLes): \"It's an awesome Raspberry Pi app store and it works really well and there's lots of great stuff in here and it's super easy to install. I want to give the devs of Pi-Apps a big shout-out.\"\n\n> [Video by **leepspvideo**](https://www.youtube.com/watch?v=zxyWQ3FV98I): \"Thanks so much to Botspot for creating this; it's a great program.\"\n\n> [Video by **Novaspirit Tech**](https://youtu.be/9dO448vYv18?t=164): \"This is an awesome application for your Pi to install applications like WoR-flasher.\"\n\n> Email from a **Raspberry Pi employee**: \"I gave Pi-Apps a go a while back and have suggested it to others quite a few times.\n> We can't provide all the options people may want, so it helps a lot that there are people like you who can help bridge the gap. Thank you Botspot!\"\n\n> [**ShiftPlusOne** (Raspberry Pi forum moderator)](https://www.raspberrypi.org/forums/viewtopic.php?f=63&t=290329&p=1755860#p1755857): \"Thanks for the great work making it all simple for everybody.\"\n\n> Email from [**Sakaki** (legendary RPi developer)](https://github.com/sakaki-): \"Good luck with your projects, Botspot, you're really making waves!\"\n\n> Message from one of our many satisfied users: \"Thank you for making pi-apps, it has helped me a ton (no more searching hours to find how to install etcher) and I cannot thank you enough.\"\n\n## Basic usage\nPi-Apps is very easy to use.  \n- This is the **main window**.  \n![main window](icons/screenshots/main%20window.png?raw=true)  \n  - ![icon](icons/screenshots/buttons/search.png?raw=true) Search for apps.\n  - ![icon](icons/screenshots/buttons/settings.png?raw=true) Open pi-apps settings.\n  - Click on a category to open it.\n    \n- Opening a category will reveal a **list of apps**:  \n![app list](icons/screenshots/app%20list.png?raw=true)  \n  - ![icon](icons/screenshots/buttons/back2.png?raw=true) Go back to the main list of categories.\n  - Click on an App name to see its details (see **details window** below)\n\n- On the right is the app **details window**:  \n![details](icons/screenshots/details%20window.png?raw=true)  \n  - ![icon](icons/screenshots/buttons/scripts.png?raw=true) View the shell-scripts responsible for installing or uninstalling the selected app.\n  - ![icon](icons/screenshots/buttons/edit.png?raw=true) Modify the app's description, icons, or scripts. (This button is hidden unless you enable it in Settings)\n  - ![icon](icons/screenshots/buttons/install.png?raw=true) Install the selected app.\n  - ![icon](icons/screenshots/buttons/uninstall.png?raw=true) Uninstall the selected app.\n\n- If you install/uninstall an app, you will see the **progress window**, keep installing/uninstalling apps to add them to the queue:  \n![details](icons/screenshots/manage.png?raw=true)\n\n- Pi-Apps Settings can be configured by launching Menu -> Preferences -> Pi-Apps Settings.  \n![settings](icons/screenshots/settings.png?raw=true)  \nIn addition to changeable settings, this window also gives access to these tools:\n  - ![icon](icons/screenshots/buttons/categories.png?raw=true) Does that one app seem to be in the wrong category? With this button, you can change it.\n  - ![icon](icons/screenshots/buttons/new%20app.png?raw=true) Create a new app with a wizard-style set of dialogs. We recommend reading [the tutorial](https://pi-apps.io/wiki/development/Creating-an-app/).\n  - ![icon](icons/screenshots/buttons/log%20files.png?raw=true) View the past weeks-worth of installation logs. This is useful if you ever encounter an app that won't install and want to see the terminal output after you closed the terminal.\n  - ![icon](icons/screenshots/buttons/import%20app.png?raw=true) This allows you to easily import a 3rd-party app from elsewhere. It helps Pi-Apps developers test upcoming apps for reliability on a variety of systems.\n\nTo learn more about Pi-Apps, read [the documentation](https://pi-apps.io/wiki/development/DOCUMENTATION/) and the [wiki](https://pi-apps.io/wiki/).\n\n## :raised_hands: Contributing\nYou don't need to be a programmer to help!  \n- The easiest way to help is by \"Starring\" our repository - it helps more people find Pi-Apps. (Scroll to the top of this page and on the right there is a \"Star\" button)\n- If you know somebody else who has a Raspberry Pi, feel free to tell them about Pi-Apps. We would offer you a referral discount, but Pi-Apps is free, so... `\\_()_/`\n- You can [make suggestions](https://github.com/Botspot/pi-apps/issues/new?template=suggestion.yml), [report bugs](https://github.com/Botspot/pi-apps/issues/new?template=bug-report.yml), or [suggest apps](https://github.com/Botspot/pi-apps/issues/new?template=app-suggestion.yml).\n- You can [create and submit an app](https://pi-apps.io/wiki/development/Creating-an-app/). Don't worry, it's about as easy as using the terminal (and it's even easier if you're submitting a simple apt-package)!\n- You can also join our cheerful community: <a href=\"https://discord.gg/RXSTvaUvuu\"><img src=\"https://img.shields.io/discord/770629697909424159.svg?color=7289da&label=Discord%20server&logo=discord\" alt=\"Join the Discord server\"></a>\n\n## Badge\nIf your application is on Pi-Apps, please consider adding this pretty badge/hyperlink to your README (dark and light modes available):  \n\n[![badge](https://github.com/Botspot/pi-apps/blob/master/icons/badge.png?raw=true)](https://github.com/Botspot/pi-apps)  [![badge](https://github.com/Botspot/pi-apps/blob/master/icons/badge-light.png?raw=true)](https://github.com/Botspot/pi-apps)\n\nEmbed code (Dark):  \n```\n[![badge](https://github.com/Botspot/pi-apps/blob/master/icons/badge.png?raw=true)](https://github.com/Botspot/pi-apps)\n```\nEmbed code (Light):  \n```\n[![badge](https://github.com/Botspot/pi-apps/blob/master/icons/badge-light.png?raw=true)](https://github.com/Botspot/pi-apps)\n```\n\n### Q&A with Botspot\n - Why did you make Pi-Apps?  \n> For a long time I have been saddened by how difficult it is to install software on Linux. In that regard, nearly all other operating systems put us to shame.  \n> How will people discover useful, free software?  \n> Most people **don't**.  \n> One day I realized: Why not make a collection of scripts to install popular apps? This would save so much time, and makes it much easier to use a Raspberry Pi as a daily, desktop computer solution.  \n\n - How long did it take to program this?  \n> Why would you think it's not still under development?   \n> Pi-Apps took around 14 days to lay the groundwork, and ever since then it has been continually, and exponentially, improved. I (Botspot) am not the sole programmer anymore - [others](https://github.com/Botspot/pi-apps/graphs/contributors) have stepped in and made improvements too.\n\n - Is Pi-Apps free?\n> Absolutely! In the future, I may allow donations, but Pi-Apps itself will always be free and open-source.\n"
        },
        {
          "name": "api",
          "type": "blob",
          "size": 190.6650390625,
          "content": "#!/bin/bash\n\n#This script is the backbone of Pi-Apps. It hosts functions that all other scripts depend upon.\n#By default, this file is hard to read. But there's an easy way to fix that. In your code editor, find the option to \"Fold All\".\n#In Geany, this option can be found in the Document toolbar.\n#Botspot has found it helpful to create a keyboard shortcut to do this quickly. You may find it helpful too.\n\n#output functions below\nerror() { #red text and exit 1\n  echo -e \"\\e[91m$1\\e[0m\" 1>&2\n  exit 1\n}\n\nwarning() { #yellow text\n  echo -e \"\\e[93m\\e[5m\\e[25m WARNING: $1\\e[0m\" 1>&2\n}\n\nstatus() { #cyan text to indicate what is happening\n  \n  #detect if a flag was passed, and if so, pass it on to the echo command\n  if [[ \"$1\" == '-'* ]] && [ ! -z \"$2\" ];then\n    echo -e $1 \"\\e[96m$2\\e[0m\" 1>&2\n  else\n    echo -e \"\\e[96m$1\\e[0m\" 1>&2\n  fi\n}\n\nstatus_green() { #announce the success of a major action\n  echo -e \"\\e[92m$1\\e[0m\" 1>&2\n}\n\ndebug() { #an echo command that only runs when debug mode is on\n  [ \"$pi_apps_debug\" = true ] && echo \"$1\"\n}\n\ngenerate_logo() { #display colorized Pi-Apps logo in terminal\n  #ANSI color codes: https://misc.flogisoft.com/bash/tip_colors_and_formatting\n  #Search for unicode characters: https://unicode-search.net - search for \"block\" and \"quadrant\"\n  \n  # foreground colors\n  blue1='\\e[38;5;75m'\n  blue2='\\e[38;5;26m'\n  blue3='\\e[38;5;21m'\n  blue4='\\e[38;5;93m'\n  \n  green='\\e[38;5;46m'\n  darkgreen='\\e[38;5;34m'\n  red='\\e[38;5;197m'\n  white='\\e[97m'\n  black='\\e[30m'\n  default='\\e[39m'\n  # background colors\n  bg_default='\\e[49m'\n  bg_black='\\e[40m'\n  bg_white='\\e[107m'\n  \n  #complex logo requires Unicode 13 support (libicu66+)\n  #this is available in Ubuntu 20.04+ and Debian 11+\n  #use simpler logo when not supported to fix issue https://github.com/Botspot/pi-apps/issues/1441\n  if [ -f /usr/lib/aarch64-linux-gnu/libicudata.so ]; then\n    local version=\"$(readlink -f /usr/lib/aarch64-linux-gnu/libicudata.so | sed -n 's/.*libicudata.so.//p')\"\n  elif [ -f /usr/lib/arm-linux-gnueabihf/libicudata.so ]; then\n    local version=\"$(readlink -f /usr/lib/arm-linux-gnueabihf/libicudata.so | sed -n 's/.*libicudata.so.//p')\"\n  elif find /usr/lib/aarch64-linux-gnu/libicudata.so.* &>/dev/null; then\n    local version=\"$(find /usr/lib/aarch64-linux-gnu/libicudata.so.* | head -1 | sed -n 's+^/usr/lib/aarch64-linux-gnu/libicudata.so.++p')\"\n  elif find /usr/lib/arm-linux-gnueabihf/libicudata.so.* &>/dev/null; then\n    local version=\"$(find /usr/lib/arm-linux-gnueabihf/libicudata.so.* | head -1 | sed -n 's+^/usr/lib/arm-linux-gnueabihf/libicudata.so.++p')\"\n  else\n    local version=\"65\"\n  fi\n  if (( $(echo \"$version >= 66\" | bc -l) )); then\n    bg_black='\\e[48;2;10;10;10m'\n    echo -e \"${bg_default}    \\e[38;2;5;220;75m\\e[38;2;4;150;29m\\e[38;2;6;188;64m${default}                                          ${darkgreen}                ${default}\n \\e[38;2;83;213;255m\\e[38;2;83;214;255m\\e[38;2;5;220;75m\\e[48;2;83;212;255m${bg_default}\\e[38;2;84;201;251m\\e[38;2;84;190;248m\\e[38;2;85;178;244m\\e[38;2;6;188;64m\\e[48;2;86;168;241m${bg_default}\\e[38;2;87;154;237m\\e[38;2;87;136;231m${default}                                       ${darkgreen}                ${default}\n \\e[38;2;83;213;255m${bg_black}  \\e[38;2;255;38;101m \\e[38;2;255;28;92m \\e[38;2;255;13;83m\\e[38;2;89;114;225m  ${bg_default}${default}                              ${darkgreen}  ${black}    ${darkgreen}    ${black}    ${darkgreen}  ${default}\n \\e[38;2;85;191;249m${bg_black}  \\e[38;2;255;13;85m \\e[38;2;255;0;75m \\e[38;2;246;0;73m\\e[38;2;90;83;215m  ${bg_default}${default}     ${blue3}${default}           ${darkgreen}  ${black}    ${darkgreen}    ${black}    ${darkgreen}  ${default}\n \\e[38;2;86;164;240m${bg_black}  \\e[38;2;249;0;73m \\e[38;2;239;0;69m \\e[38;2;229;0;66m\\e[38;2;92;58;207m  ${bg_default}${default}                     ${darkgreen}      ${black}    ${darkgreen}      ${default}\n \\e[38;2;87;137;232m${bg_black}\\e[38;2;89;111;224m\\e[38;2;89;100;220m\\e[38;2;90;89;217m\\e[38;2;91;76;213m\\e[38;2;92;68;211m\\e[38;2;92;59;208m\\e[38;2;92;56;207m${bg_default}${default}                                     ${darkgreen}    ${black}        ${darkgreen}    ${default}\n\\e[0m                                                   ${darkgreen}    ${black}        ${darkgreen}    ${default}\n                                                   ${darkgreen}    ${black}  ${darkgreen}    ${black}  ${darkgreen}    ${default}\"\n  else\n    echo -e \"${white}${bg_default}    ${green}${darkgreen}${green}${default}                                          ${darkgreen}                ${default}\n ${blue1}${green}\\e[48;5;26m\\e[7m\\e[27m${bg_default}${blue2}${blue3}${green}\\e[48;5;26m\\e[7m\\e[27m${bg_default}${blue3}${white}${default}                                       ${darkgreen}                ${default}\n ${bg_black}${blue1}  ${red}  ${blue3}  ${bg_default}${default}                              ${darkgreen}  ${black}    ${darkgreen}    ${black}    ${darkgreen}  ${default}\n ${bg_black}${blue2}  ${red}  ${blue3}  ${bg_default}${default}     ${blue3}${default}    \\e[7m\\e[27m       ${darkgreen}  ${black}    ${darkgreen}    ${black}    ${darkgreen}  ${default}\n ${bg_black}${blue2}  ${red}  ${blue4}  ${bg_default}${default}                       ${darkgreen}      ${black}    ${darkgreen}      ${default}\n ${blue3}${bg_black}${blue4}${bg_default}${default}                                     ${darkgreen}    ${black}        ${darkgreen}    ${default}\n\\e[0m                                                   ${darkgreen}    ${black}        ${darkgreen}    ${default}\n                                                   ${darkgreen}    ${black}  ${darkgreen}    ${black}  ${darkgreen}    ${default}\"\n  fi\n}\n#end of output functions\n\nadd_english() { #add en_US locale for more accurate error\n  if [ \"$(cat /usr/share/i18n/SUPPORTED | grep -o 'en_US.UTF-8' )\" == \"en_US.UTF-8\" ]; then \n    locale=$(locale -a | grep -oF 'en_US.utf8')\n    if [ \"$locale\" != 'en_US.utf8' ]; then\n      status \"Adding en_US locale for better logging... \"\n      sudo sed -i '/en_US.UTF-8/s/^#[ ]//g' /etc/locale.gen\n      sudo locale-gen\n    fi\n  else\n    warning \"en_US locale is not available on your system. This may cause bad logging experience.\"\n  fi\n  export LANG=\"en_US.UTF-8\"\n  export LANGUAGE=\"en_US.UTF-8\"\n  export LC_ALL=\"en_US.UTF-8\"\n}\n\n#package functions\npackage_info() { #list everything dpkg knows about the $1 package. Note: the package has to be installed for this to show anything.\n  local package=\"$1\"\n  [ -z \"$package\" ] && error \"package_info(): no package specified!\"\n  #list lines in /var/lib/dpkg/status between the package name and the next empty line (empty line is then removed)\n  sed -n -e '/^Package: '\"$package\"'$/,/^$/p' /var/lib/dpkg/status | head -n -1\n  true #this may exit with code 141 if the pipe was closed early (to be expected with grep -v)\n}\n\npackage_installed() { #exit 0 if $1 package is installed, otherwise exit 1\n  local package=\"$1\"\n  [ -z \"$package\" ] && error \"package_installed(): no package specified!\"\n  #find the package listed in /var/lib/dpkg/status\n  #package_info \"$package\"\n  \n  #directly search /var/lib/dpkg/status\n  grep -x \"Package: $package\" /var/lib/dpkg/status -A 2 | grep -qxF 'Status: install ok installed'\n}\n\npackage_available() { #determine if the specified package-name exists in a local repository for the current dpkg architecture\n  local package=\"$(awk -F: '{print $1}' <<<\"$1\")\"\n  local dpkg_arch=\"$(awk -F: '{print $2}' <<<\"$2\")\"\n  [ -z \"$dpkg_arch\" ] && dpkg_arch=\"$(dpkg --print-architecture)\"\n  [ -z \"$package\" ] && error \"package_available(): no package name specified!\"\n  local output=\"$(apt-cache policy \"$package\":\"$dpkg_arch\" | grep \"Candidate:\")\"\n  if [ -z \"$output\" ]; then\n    return 1\n  elif echo \"$output\" | grep -q \"Candidate: (none)\"; then\n    return 1\n  else\n    return 0\n  fi\n}\n\npackage_dependencies() { #outputs the list of dependencies for the $1 package\n  local package=\"$1\"\n  [ -z \"$package\" ] && error \"package_dependencies(): no package specified!\"\n  \n  #find the package listed in /var/lib/dpkg/status\n  package_info \"$package\" | grep '^Depends: ' | sed 's/^Depends: //g'\n}\n\npackage_installed_version() { #returns the installed version of the specified package-name.\n  local package=\"$1\"\n  [ -z \"$package\" ] && error \"package_installed_version(): no package specified!\"\n  #find the package listed in /var/lib/dpkg/status\n  package_info \"$package\" | grep '^Version: ' | awk '{print $2}'\n}\n\npackage_latest_version() { #returns the latest available versions of the specified package-name. Doesn't matter if it's installed or not.\n  local package=\"$1\"\n  [ -z \"$package\" ] && error \"package_latest_version(): no package specified!\"\n  \n  #support repo selection as '-t bookworm-backports' for $2 and $3\n  local additional_flags\n  additional_flags=()\n  if [ \"$2\" == '-t' ];then\n    additional_flags=(-t \"$3\")\n  fi\n  \n  # use slower but more accurate apt list command to get package version for current architecture\n  apt-cache policy \"${additional_flags[@]}\" \"$package\" 2>/dev/null | grep \"Candidate: \" | awk '{print $2}'\n  #grep -rx \"Package: $package\" /var/lib/apt/lists --exclude=\"lock\" --exclude-dir=\"partial\" --after 4 | grep -o 'Version: .*' | awk '{print $2}' | sort -rV | head -n1\n}\n\npackage_is_new_enough() { #check if the $1 package has an available version greater than or equal to $2\n  local package=\"$1\"\n  [ -z \"$package\" ] && error \"package_is_new_enough(): no package specified!\"\n  \n  local compare_version=\"$2\"\n  [ -z \"$package\" ] && error \"package_is_new_enough(): no comparison version number specified!\"\n  \n  #determine the latest available version for the specified package\n  local package_version=\"$(package_latest_version \"$package\")\"\n  \n  #if version value not found, return 1 now\n  if [ -z \"$package_version\" ];then\n    return 1\n  fi\n  \n  #given both the package_version and compare_version, see if the greater of the two is the available package's version\n  if [ \"$(echo \"$package_version\"$'\\n'\"$compare_version\" | sort -rV | head -n1)\" == \"$package_version\" ];then\n    #if so, indicate success\n    return 0\n  else\n    return 1\n  fi\n}\n\nanything_installed_from_uri_suite_component() { #Given an apt repository uri, suite, and component, determine if any packages from it are currently installed\n  local uri=\"$1\"\n  local suite=\"$2\"\n  component=\"$3\" #can be left blank\n  [ -z \"$uri\" ] && error \"anything_installed_from_uri_suite_component: A repository uri must be specified.\"\n  [ -z \"$suite\" ] && error \"anything_installed_from_uri_suite_component: A repository suite must be specified.\"\n  \n  #find part of path to apt list file(s) to search for\n  if [ -z \"$component\" ]; then\n    local filepath=\"/var/lib/apt/lists/$(echo \"$1\" | sed 's+.*://++g' | sed \"s,/$,,\" | tr '/' '_')_$(echo \"$suite\" | sed \"s,/$,,\" | tr '/' '_')_\"\n  else\n    local filepath=\"/var/lib/apt/lists/$(echo \"$1\" | sed 's+.*://++g' | sed \"s,/$,,\" | tr '/' '_')_dists_$(echo \"$suite\" | sed \"s,/$,,\" | tr '/' '_')_$(echo \"$component\" | sed \"s,/$,,\" | tr '/' '_')_\"\n  fi\n  debug $filepath\n  \n  #find all relevant package-lists\n  local repofiles=\"$(ls ${filepath}*_Packages)\"\n  debug \"$repofiles\"\n  \n  #for every repo-file, check if any of them have an installed file\n  local IFS=$'\\n'\n  local repofile\n  local installed_packages=\"$(grep -xF 'Status: install ok installed' /var/lib/dpkg/status -B 2 | grep '^Package: ' | sed 's/^Package: //g' | sort)\"\n  for repofile in $repofiles ;do\n    #search the repo-file for installed packages\n    \n    local packages_in_repo=\"$(grep '^Package: ' \"$repofile\" | awk '{print $2}' | sort)\"\n    local apt_cache_policy_output=\"$(echo \"$packages_in_repo\" | list_intersect \"$installed_packages\" | tr '\\n' ' ' | xargs -r apt-cache policy)\"\n    \n    #check if any installed packages also found on this repo are actually installed from this repo\n    if [ -z \"$component\" ]; then\n      echo \"$apt_cache_policy_output\" | grep -B1 \"$(echo \"$uri\" | sed 's+.*://++g' | sed \"s,/$,,\") $suite\" | awk '{print $1}' | grep -Fq '***' && return 0\n    else\n      echo \"$apt_cache_policy_output\" | grep -B1 \"$(echo \"$uri\" | sed 's+.*://++g' | sed \"s,/$,,\") $suite/$component\" | awk '{print $1}' | grep -Fq '***' && return 0\n    fi\n  done\n  return 1\n}\n\nremove_repofile_if_unused() { #Given a sources.list.d file, delete it if nothing from that repository is currently installed. Deletion skipped if $2 is 'test'\n  local file=\"$1\"\n  local testmode=\"$2\"\n  local key=\"$3\"\n  [ -z \"$file\" ] && error \"remove_repo_if_unused: no sources.list.d file specified!\"\n  #return now if the list file does not exist\n  [ -f \"$file\" ] || return 0\n\n  #set default to not in use\n  local in_use=0\n  \n  if [ \"${file##*.}\" == \"list\" ]; then\n    # determine what uri, suite, and components are in a file\n    local lines=\"$(cat \"$file\" | grep \"^deb \" | sed 's/^deb // ; s/\\[.*\\]//')\"\n    local IFS=$'\\n'\n    for line in $lines ;do\n      local uri=\"$(echo \"$line\" | awk '{print $1}')\"\n      local suite=\"$(echo \"$line\" | awk '{print $2}')\"\n      local components=\"$(echo \"$line\" | awk '{$1=$2=\"\"; print $0}')\"\n      local IFS=' '\n      if [ -z \"$components\" ]; then\n        debug \"$uri $suite\"\n        if anything_installed_from_uri_suite_component \"$uri\" \"$suite\";then\n          in_use=1\n          break 1\n        fi\n      else\n        for component in $components ;do\n          debug \"$uri $suite $component\"\n          if anything_installed_from_uri_suite_component \"$uri\" \"$suite\" \"$component\";then\n            in_use=1\n            break 2\n          fi\n        done\n      fi\n      local IFS=$'\\n'\n    done\n  elif [ \"${file##*.}\" == \"sources\" ]; then\n    #find empty lines (empty line, line with all spaces, or line with all tabs) in the file that separate stanzas. empty lines are not allowed between fields within a stanza\n    #https://manpages.ubuntu.com/manpages/jammy/en/man5/deb822.5.html\n    local empty_lines=\"$(grep -P -n '^$|^ +$|^\\t+$' \"$file\" | awk '{print $1}' | sed 's/:*//g')\"\n    #get number of lines in file\n    local num_lines=$(wc -l \"$file\" | awk '{print $1}')\n\n    #always add last line to empty lines\n    if [ -z \"$empty_lines\" ]; then\n      empty_lines=\"$num_lines\"\n    else\n      empty_lines+=$'\\n'\"$num_lines\"\n    fi\n    debug \"$empty_lines\"\n\n    #parse each stanza, starting at line 1\n    local IFS=$'\\n'\n    local line_start=1\n    for line_end in $empty_lines ;do\n      # if Enabled: no, continue to next loop iteration\n      sed -n \"$line_start\",\"$line_end\"p  \"$file\" | grep -q '^Enabled: no' && continue\n      # determine what uri, suite, and components are in a file\n      #each stanza can only have one matching section. if there are multiple matches the last one is used\n      #case should be ignored for fields\n      local uris=\"$(sed -n \"$line_start\",\"$line_end\"p  \"$file\" | grep -v '^#' | grep -i '^URIs:' | sed 's/URIs://Ig' | awk '{$1=$1};1' | tail -1)\"\n      local suites=\"$(sed -n \"$line_start\",\"$line_end\"p \"$file\" | grep -v '^#' | grep -i '^Suites:' | sed 's/Suites://Ig' | awk '{$1=$1};1' | tail -1)\"\n      local components=\"$(sed -n \"$line_start\",\"$line_end\"p \"$file\" | grep -v '^#' | grep -i '^Components:' | sed 's/Components://Ig' | awk '{$1=$1};1' | tail -1)\"\n      local IFS=' '\n      for uri in $uris ;do\n        for suite in $suites ;do\n          if [ -z \"$components\" ]; then\n            debug \"$uri $suite\"\n            if anything_installed_from_uri_suite_component \"$uri\" \"$suite\";then\n              in_use=1\n              break 3\n            fi\n          else\n            for component in $components ;do\n              debug \"$uri $suite $component\"\n              if anything_installed_from_uri_suite_component \"$uri\" \"$suite\" \"$component\";then\n                in_use=1\n                break 4\n              fi\n            done\n          fi\n        done\n      done\n      local IFS=$'\\n'\n      line_start=\"$line_end\"\n    done\n  else\n    error \"$file was not of apt list or sources type\"\n  fi\n  \n  if [ \"$testmode\" == test ] && [ \"$in_use\" == 0 ];then\n    echo \"The given repository is not in use and can be deleted:\"$'\\n'\"$file\" 1>&2\n  elif [ \"$testmode\" == test ];then\n    echo \"At least one package is preventing the repo from being removed\"\n  elif [ \"$in_use\" == 0 ];then\n    status \"Removing the $(basename \"$file\" | sed 's/.list$//g' | sed 's/.sources$//g') repo as it is not being used\"\n    sudo rm -f \"$file\"\n    [ -f \"$key\" ] && sudo rm -f \"$key\" || true\n  fi\n  \n}\n\n#apt functions\napt_lock_wait() { #Wait until other apt processes are finished before proceeding\n  #make sure english locale is added first\n  add_english\n\n  #check if sudo needs a password currently. this prevents sudo asking for a password in the below fuser command which would have \"Waiting until APT locks are released... \" written after it after 5 seconds\n  #the result would look like something in the terminal to a user \"[sudo] password for USER: Waiting until APT locks are released... \" which might be confusing\n  #this is very often the first command that pi-apps scripts run that requires sudo privileges from the user\n  #passwordless sudo (like on piOS) will always skip the contents of the if\n  if ! sudo -n true ; then\n    # sudo needs a password so prompt the user to give one before running other commands\n    sudo echo > /dev/null\n  fi\n\n  #in a background subprocess, after 5 seconds, say \"Waiting until APT locks are released... \"\n  (sleep 5; echo -n \"Waiting until APT locks are released... \") &\n  local pid=$!\n  \n  while [ ! -z \"$(sudo fuser /var/lib/dpkg/lock /var/lib/apt/lists/lock /var/cache/apt/archives/lock /var/log/unattended-upgrades/unattended-upgrades.log /var/lib/dpkg/lock-frontend 2>/dev/null)\" ];do\n    sleep 1\n  done\n  \n  #Try to install a non-existent package to see if apt fails due to a lock-file. Repeat until no errors mention 'Could not get lock'\n  #NOTE: after apt 3.0 this output may change. Refer to git blame for this line for more info.\n  while sudo -E apt install lkqecjhxwqekc 2>&1 | grep -q 'Could not get lock' ;do\n    sleep 1\n  done\n  \n  #If the background process finished, then that means the \"waiting until\" message was displayed. This means the kill command will return 1, so echo Done\n  kill $pid &>/dev/null || echo \"Done\"\n}\n\nless_apt() { #remove unwanted lines from apt output\n  grep --line-buffered -v \"apt does not have a stable CLI interface.\\|Reading package lists...\\|Building dependency tree\\|Reading state information...\\|Need to get\\|Selecting previously unselected package\\|Preparing to unpack\\|Setting up \\|Processing triggers for \\|^$\"\n}\n\napt_update() { #run an apt update with error-checking and minimal output\n  apt_lock_wait\n  \n  status \"Running \\e[7msudo apt update\\e[27m...\"\n  set -o pipefail\n  local output=\"$(sudo -E apt update --allow-releaseinfo-change \"$@\" 2>&1 | less_apt | tee /dev/stderr)\"\n  local exitcode=$?\n  status \"apt update complete.\"\n  \n  #inform user about autoremovable packages\n  if [ ! -z \"$(echo \"$output\" | grep 'autoremove to remove them' )\" ];then\n    echo -e \"\\e[33mSome packages are unnecessary.\\e[39m Please consider running \\e[4msudo a\\e[0mp\\e[4mt autoremove\\e[0m.\"\n  fi\n  \n  #inform user packages are upgradeable\n  if [ ! -z \"$(echo \"$output\" | grep 'packages can be upgraded' )\" ];then\n    echo -e \"\\e[33mSome packages can be upgraded.\\e[39m Please consider running \\e[4msudo a\\e[0mp\\e[4mt full-u\\e[0mpg\\e[4mrade\\e[0m.\"\n  elif [ ! -z \"$(echo \"$output\" | grep 'package can be upgraded' )\" ];then\n    echo -e \"\\e[33mOne package can be upgraded.\\e[39m Please consider running \\e[4msudo a\\e[0mp\\e[4mt full-u\\e[0mpg\\e[4mrade\\e[0m.\"\n  fi\n  \n  #exit on apt error\n  local errors=\"$(echo \"$output\" | grep '^[(E)|(Err]:')\"\n  if [ $exitcode != 0 ] || [ ! -z \"$errors\" ];then\n    echo -e \"\\e[91mFailed to run \\e[4msudo apt update\\e[0m\\e[39m!\"\n    echo -e \"APT reported these errors:\\n\\e[91m$errors\\e[39m\"\n    \n    #run some apt error diagnosis\n    echo \"$output\"\n    exit 1\n  fi\n  return 0\n}\n\nrepo_add() { #add local packages to the /tmp/pi-apps-local-packages repository\n  #given local deb file(s), make a local apt repository in /tmp/pi-apps-local-packages\n  \n  #see: https://unix.stackexchange.com/questions/87130/how-to-quickly-create-a-local-apt-repository-for-random-packages-using-a-debian\n  #and: https://serverfault.com/questions/447457/use-apt-get-source-on-a-debian-repo-without-using-etc-apt-source-list\n  #and: https://askubuntu.com/questions/382664/use-custom-directory-for-apt-get\n  \n  #use this flag for apt commands to use the local repository: -o Dir::Etc::SourceList=/tmp/pi-apps-local-packages/source.list\n  \n  #ensure the repo-folder exists\n  mkdir -p /tmp/pi-apps-local-packages || error \"repo_add(): failed to create folder /tmp/pi-apps-local-packages\"\n  \n  #move every mentioned deb file to it\n  for file in \"$@\"; do\n    mv -f \"$file\" /tmp/pi-apps-local-packages || error \"repo_add(): failed to move '$file' to the repository: /tmp/pi-apps-local-packages\"\n  done\n}\n\nrepo_refresh() { #index the pi-apps local apt repository\n  \n  [ -d /tmp/pi-apps-local-packages ] || error \"repo_update(): cannot index the repository - it's missing! /tmp/pi-apps-local-packages\"\n  \n  #index the repository by creating a Packages file\n  (cd /tmp/pi-apps-local-packages && apt-ftparchive packages . > Packages) || error \"repo_update(): apt-ftparchive failed to index the repository: /tmp/pi-apps-local-packages\nThe Pi-Apps developers have been receiving a few of these errors recently, but we can't figure out what the problem is without your help. Could you please reach out so we can solve this?\"\n  #Make sure the Packages file actually exists\n  [ -f /tmp/pi-apps-local-packages/Packages ] || error \"repo_update(): apt-ftparchive failed to index the repository: /tmp/pi-apps-local-packages\nThe Pi-Apps developers have been receiving a few of these errors recently, but we can't figure out what the problem is without your help. Could you please reach out so we can solve this?\"\n  \n  #by default, apt-ftparchive will generate lines like \"Filename: ./package-name\". This seemed to have caused one error-report, so we remove the \"./\" to hopefully solve the problem.\n  sed -i 's+^Filename: \\./+Filename: +g' /tmp/pi-apps-local-packages/Packages\n  \n  # set repo origin name to pi-apps-local-packages - see PR #1986\n  echo 'APT::FTPArchive::Release {\nOrigin \"pi-apps-local-packages\";\n};' > /tmp/pi-apps-local-packages/aptftp.conf\n  \n  #hash the repository by creating a Release file\n  (cd /tmp/pi-apps-local-packages && apt-ftparchive -c=/tmp/pi-apps-local-packages/aptftp.conf release . > Release) || error \"repo_update(): apt-ftparchive failed to hash the repository: /tmp/pi-apps-local-packages\nThe Pi-Apps developers have been receiving a few of these errors recently, but we can't figure out what the problem is without your help. Could you please reach out so we can solve this?\"\n  \n  #create a source.list for the repository - add pi-apps-local-packages to the top, then add lines from /etc/apt/sources.list\n  rm -f /tmp/pi-apps-local-packages/source.list\n  echo \"deb [trusted=yes] file:/tmp/pi-apps-local-packages/ ./\" > /tmp/pi-apps-local-packages/source.list\n  cat /etc/apt/sources.list >> /tmp/pi-apps-local-packages/source.list\n  \n  # remove pi-apps-local-packages priority if it exists\n  [ -f /etc/apt/preferences.d/pi-apps-local-packages ] && sudo rm -f /etc/apt/preferences.d/pi-apps-local-packages\n  true\n}\n\nrepo_rm() { #remove the local apt repository\n  #wait for other operations to finish before continuing - hopefully this will solve cases when the pi-apps local repository was removed unexpectedly by a second process\n  apt_lock_wait\n  \n  rm -rf /tmp/pi-apps-local-packages || sudo rm -rf /tmp/pi-apps-local-packages || error \"repo_rm(): failed to remove the local repository: /tmp/pi-apps-local-packages\"\n  \n  #Also remove broken symbolic link to /tmp/pi-apps-local-packages/./Packages\n  sudo rm -f /var/lib/apt/lists/_tmp_pi-apps-local-packages_._Packages\n}\n\napp_to_pkgname() { #given an app-name, convert it to a unique, valid package-name that starts with 'pi-apps-'\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"app_to_pkgname(): no app-name specified\"\n  \n  echo \"pi-apps-$(echo \"$app\" | md5sum | cut -c1-8 | awk '{print $1}')\"\n}\n\ninstall_packages() { #Make some packages dependencies of the $app app. Package-names, regex, filenames, and urls are supported.\n  \n  #array-variable to store custom apt options (for local repositories)\n  local apt_flags=()\n  \n  #convert input array to newline-separated string\n  local IFS=' '\n  local repo_selection='' #store selected repo to install from, eg. bookworm-backports\n  while [ $# -gt 0 ]; do\n    #pass through -t args to apt: for \"-t bookworm-backports\"\n    if [ \"$1\" == '-t' ];then\n      repo_selection=\"$2\"\n      apt_flags+=('-t' \"$2\")\n      shift\n      shift\n    else\n      local packages+=\"$1\n\"\n      shift\n    fi\n  done\n  packages=\"${packages::-1}\" #remove final empty newline\n  \n  #the $app variable must contain something\n  [ -z \"$app\" ] && error 'install_packages function can only be used by apps to install packages. (the $app variable was not set)'\n  \n  status \"Will install these packages: $(tr '\\n' ' ' <<<\"$packages\")\"\n  \n  #variable to remember if the pi-apps-local-packages repository is being used\n  local using_local_packages=0\n  repo_rm #remove the local repo, just in case the last operation left it in an unrecoverable state.\n  \n  #handle regex, urls, local packages\n  IFS=$'\\n'\n  local package\n  for package in $packages ;do\n    \n    #handle local packages (package-name starts with /)\n    if [[ \"$package\" == /* ]];then\n      \n      #status \"Handling local package $package\"\n      \n      [ -f \"$package\" ] || error \"install_packages(): Local package does not exist! ($package)\"\n      \n      #determine the package name, package version, and architecture from the file\n      local dpkg_deb_output=\"$(dpkg-deb -I \"$package\")\"\n      local packagename=\"$(echo \"$dpkg_deb_output\" | grep \"^ Package:\" | awk '{print $2}')\"\n      local packageversion=\"$(echo \"$dpkg_deb_output\" | grep \"^ Version:\" | awk '{print $2}')\"\n      local packagearch=\"$(echo \"$dpkg_deb_output\" | grep \"^ Architecture:\" | awk '{print $2}')\"\n      [ -z \"$packagename\" ] && error \"install_packages(): failed to determine a package-name for the file '$package'\"\n      [ -z \"$packageversion\" ] && error \"install_packages(): failed to determine a package-version for the file '$package'\"\n      [ -z \"$packagearch\" ] && error \"install_packages(): failed to determine a package-architecture for the file '$package'\"\n      unset dpkg_deb_output\n      \n      #foreign arch: add :armhf or :arm64 to the packagename if this local package is of a foreign architecture\n      if [ \"$packagearch\" != \"$(dpkg --print-architecture)\" ] && [ \"$packagearch\" != \"all\" ];then\n        packagename+=\":$packagearch\"\n      fi\n      \n      #add this local package to the pi-apps-local-packages repository\n      repo_add \"$package\" || return 1\n      using_local_packages=1 #remember that the pi-apps-local-packages repository is being used\n      \n      #replace package filename with name of package\n      packages=\"$(echo \"$packages\" | sed \"s|$package|$packagename (>= $packageversion)|\")\"\n      \n    #handle urls\n    elif [[ \"$package\" == *://* ]];then\n      \n      #status \"Handling url: $package\"\n      \n      local filename=\"/tmp/$(basename \"$(echo \"$package\" | sed 's+/download$++g')\")\"\n      \n      #add .deb extension if filename doesn't end with it.\n      if [ \"${filename: -4}\" != \".deb\" ]; then\n        status \"$filename is not ending with .deb, renaming it to '${filename}.deb'...\" \n        local filename=\"${filename}.deb\"\n      fi\n      \n      for i in {1..3}; do #download retry loop\n        wget -O \"$filename\" \"$package\" || rm -f \"$filename\"\n        \n        if [ -f \"$filename\" ];then\n          break\n        fi\n        warning \"Package download failed. (Attempt $i of 3)\"\n      done\n      [ -f \"$filename\" ] || error \"install_packages(): Downloaded package does not exist! ($filename)\"\n      \n      #determine the package name, package version, and architecture from the file\n      local dpkg_deb_output=\"$(dpkg-deb -I \"$filename\")\"\n      local packagename=\"$(echo \"$dpkg_deb_output\" | grep \"^ Package:\" | awk '{print $2}')\"\n      local packageversion=\"$(echo \"$dpkg_deb_output\" | grep \"^ Version:\" | awk '{print $2}')\"\n      local packagearch=\"$(echo \"$dpkg_deb_output\" | grep \"^ Architecture:\" | awk '{print $2}')\"\n      [ -z \"$packagename\" ] && error \"install_packages(): failed to determine a package-name for the file '$filename'\"\n      [ -z \"$packageversion\" ] && error \"install_packages(): failed to determine a package-version for the file '$filename'\"\n      [ -z \"$packagearch\" ] && error \"install_packages(): failed to determine a package-architecture for the file '$filename'\"\n      unset dpkg_deb_output\n      \n      #foreign arch: add :armhf or :arm64 to the packagename if this local package is of a foreign architecture\n      if [ \"$packagearch\" != \"$(dpkg --print-architecture)\" ] && [ \"$packagearch\" != \"all\" ];then\n        packagename+=\":$packagearch\"\n      fi\n      \n      #add this local package to the pi-apps-local-packages repository\n      repo_add \"$filename\" || return 1\n      using_local_packages=1 #remember that the pi-apps-local-packages repository is being used\n      \n      #replace package url with name of package\n      packages=\"$(echo \"$packages\" | sed \"s|^${package}$|$packagename (>= $packageversion)|\")\"\n      \n    #expand regex (package-name contains *)\n    elif echo \"$package\" | grep -q '*' ;then \n      \n      status \"Expanding regex in '${package}'...\"\n      \n      list=\"$(apt-cache search \"$package\" | awk '{print $1}' | grep \"$(echo \"$package\" | tr -d '*')\")\"\n      \n      #replace package with expanded list\n      packages=\"$(echo \"$packages\" | grep -vF \"$package\")\"$'\\n'\"$list\"\n    \n    #request package version if backports repo was specified\n    elif [ ! -z \"$repo_selection\" ];then\n      local packageversion=\"$(package_latest_version \"$package\" -t \"$repo_selection\" | sed 's/+.*//g')\"\n      if [ -z \"$packageversion\" ];then\n        error \"install_packages(): failed to get package version for $package, apt-cache output was $(apt-cache policy -t \"$repo_selection\" \"$package\" 2>&1)\"\n      fi\n      #add version specification to package\n      packages=\"$(echo \"$packages\" | sed \"s|^${package}$|$package (>= $packageversion)|\")\"\n    fi\n  done\n  #now package list shouldn't contain any '*' characters, urls, local filepaths\n  if echo \"$packages\" | grep -q '*';then \n    error \"install_packages(): failed to remove all regex from the package list:\\n$packages\"\n  elif [[ \"$packages\" == *://* ]];then\n    error \"install_packages(): failed to remove all urls from the package list:\\n$packages\"\n  elif [[ \"$packages\" == */* ]];then\n    error \"install_packages(): failed to remove all filenames from the package list:\\n$packages\"\n  fi #package list contains no '*' characters, urls, local filepaths\n  \n  #change the $packages list from newline-delimited to comma-delimited\n  packages=\"$(tr '\\n' ',' <<<\"$packages\")\"\n  \n  if [ \"$using_local_packages\" == 1 ];then\n    #Initialize the pi-apps-local-packages repository\n    repo_refresh || return 1\n    #add this repository to flags to add to apt\n    apt_flags+=(-o 'Dir::Etc::SourceList=/tmp/pi-apps-local-packages/source.list')\n  fi\n  \n  status \"Creating an empty apt-package to install the necessary apt packages...\"\n  \n  #to avoid issues with symbols and spaces in app names, we shasum the app name for use in apt\n  local package_name=\"$(app_to_pkgname \"$app\")\"\n  \n  echo \"It will be named: $package_name\"\n  \n  #If this app's dummy deb is already installed, add its dependencies to the list.\n  #this allows install_packages() to be used multiple times in an app's script\n  if package_installed \"$package_name\" ;then\n    \n    local existing_deps=\"$(package_dependencies \"$package_name\")\"\n    status \"The $package_name package is already installed. Inheriting its dependencies: $(echo \"$existing_deps\")\"\n    packages+=\",\"\"$(echo \"$existing_deps\" | sed 's/, /,/g')\"\n  fi\n  \n  { #create dummy apt package that depends on the packages this app requires\n    \n    #this stores the comma-separated list of dependency packages. It removes duplicate entries.\n    local depends=\"$(echo \"$packages\" | sed 's/,|/ |/g' | sed 's/|,/| /g' | tr ',' '\\n' | sort -u -t' ' -k1,1 | tr '\\n' ',' | sed 's/^,//g' | sed 's/,$//g' | sed 's/,/, /g' ; echo)\"\n    \n    rm -rf /tmp/$package_name /tmp/$package_name.deb\n    mkdir -p /tmp/$package_name/DEBIAN\n    echo \"Maintainer: Pi-Apps team\nName: $app\nDescription: Dummy package created by pi-apps to install dependencies for the '$app' app\nVersion: 1.0\nArchitecture: all\nPriority: optional\nSection: custom\nDepends: $depends\nPackage: $package_name\" > /tmp/$package_name/DEBIAN/control\n    \n    #fix error report \"dpkg-deb: error: control directory has bad permissions 700 (must be >=0755 and <=0775)\"\n    #The two zeros fix error report \"dpkg-deb: error: control directory has bad permissions 2755 (must be >=0755 and <=0775)\"\n    sudo chmod -R '00755' /tmp/$package_name\n    \n    #display the finished \"Depends: \" line to the user\n    grep --color=never \"^Depends: \" /tmp/$package_name/DEBIAN/control\n  }\n  \n  #Skip installing the dummy deb if it is already installed and has an identical control file\n  if package_installed \"$package_name\" && [ \"$(package_info \"$package_name\" | sort | grep -v '^Status: ')\" == \"$(cat /tmp/$package_name/DEBIAN/control | sort)\" ];then\n    echo \"$package_name is already installed and no changes would be made. Skipping...\"\n  else\n    \n    #Build .deb file for the dummy package\n    local output=\"$(dpkg-deb --build /tmp/$package_name 2>&1)\"\n    if [ $? != 0 ] || [ ! -f /tmp/$package_name.deb ];then\n      echo \"\"\n      echo \"$output\"\n      error \"install_packages(): failed to create dummy deb ${package_name}!\"\n    fi\n    \n    #Before apt update, check if local repo still exists\n    if [ \"$using_local_packages\" == 1 ] && [ ! -f /tmp/pi-apps-local-packages/Packages ];then\n      error \"User error: Uh-oh, the /tmp/pi-apps-local-packages folder went missing while installing packages.\\nThis usually happens if you try to install several apps at the same time in multiple terminals.\"\n    fi\n    \n    local i=0\n    while true;do #retry loop ; run apt update and apt install again if apt's records of the local repo goes missing\n      #run an apt update\n      apt_update \"${apt_flags[@]}\" || exit 1\n      \n      #install dummy deb\n      status \"Installing the $package_name package...\"\n      \n      apt_lock_wait\n      set -o pipefail\n      local output=\"$(sudo -E apt install -fy --no-install-recommends --allow-downgrades \"${apt_flags[@]}\" /tmp/$package_name.deb 2>&1 | less_apt | tee /dev/stderr)\"\n      local exitcode=$?\n      status \"Apt finished.\"\n      \n      if [ \"$using_local_packages\" == 1 ] && [ ! -f /var/lib/apt/lists/_tmp_pi-apps-local-packages_._Packages ] && [ $i != 5 ];then\n        #another apt update process deleted apt's knowledge of the pi-apps local repo. Warn the user and try again, up to 5 tries.\n        i=$((i+1))\n        warning \"Local packages failed to install because another apt update process erased apt's knowledge of the pi-apps local repository.\\nTrying again... (attempt $i of 5)\"\n      else\n        #apt may have succeeded or failed, but exit retry loop for Other Apt Update\n        break\n      fi\n    done\n    \n    local errors=\"$(echo \"$output\" | grep '^[(E)|(Err]:')\"\n    if [ -z \"$errors\" ] && [ \"$exitcode\" != 0 ]; then\n      echo -e \"\\e[91mFailed to install the packages!\\e[39m\"\n      echo \"User error: Apt exited with a failed exitcode ($exitcode) and no error (E/Err) output. This could indicate system corruption (eg: storage corruption or unstable overclocking).\"\n      exit 1\n    elif [ ! -z \"$errors\" ];then\n      echo -e \"\\e[91mFailed to install the packages!\\e[39m\"\n      echo -e \"The APT reported these errors:\\n\\e[91m$errors\\e[39m\"      \n      #some error reports seem to indicate that package URLs aren't being properly downloaded. This output aims to solve the mystery.\n      if [ \"$using_local_packages\" == 1 ] && [ ! -f /tmp/pi-apps-local-packages/Packages ];then\n        echo \"User error: Uh-oh, the /tmp/pi-apps-local-packages folder went missing while installing packages.\\nThis usually happens if you try to install several apps at the same time in multiple terminals.\"\n      elif [ \"$using_local_packages\" == 1 ] && ( echo \"$output\" | grep -q 'but it is not installable' || echo \"$output\" | grep -q 'but it is not going to be installed' || echo \"$output\" | grep -q \"but .* is to be installed\" ) ;then\n        echo -e \"\\e[91mThe Pi-Apps Local Repository was being used, and a package seemed to not be available. Here's the Packages file:\\e[39m\"\n        cat /tmp/pi-apps-local-packages/Packages\n        echo -e \"Attempting apt --dry-run installation of the problematic package(s) for debugging purposes:\\n\"\n        ( echo \"$output\" | grep 'but it is not installable' || echo \"$output\" | grep 'but it is not going to be installed' || echo \"$output\" | grep \"but .* is to be installed\" ) | awk '{print $4}' | uniq | xargs sudo -E apt-get install -fy --no-install-recommends --allow-downgrades --dry-run \"${apt_flags[@]}\"\n        echo -e \"Printing apt-cache policy output for debugging purposes:\\n\"\n        apt-cache policy\n      fi\n      \n      exit 1\n    fi\n  fi\n  \n  rm -f /tmp/$package_name.deb\n  rm -rf /tmp/$package_name\n  \n  #delete the local repository if it was used\n  if [ \"$using_local_packages\" == 1 ];then\n    repo_rm\n  fi\n  \n  status_green \"Package installation complete.\"\n}\n\npurge_packages() { #Allow dependencies of the $app app to be autoremoved.\n  #the $app variable must contain something\n  [ -z \"$app\" ] && error 'purge_packages function can only be used by apps to install packages. (the $app variable was not set)'\n  \n  status \"Allowing packages required by the $app app to be uninstalled\"\n  \n  #to avoid issues with symbols and spaces in app names, we shasum the app name for use in apt\n  local package_name=\"$(app_to_pkgname \"$app\")\"\n  \n  #if dummy deb found/installed\n  if package_installed \"$package_name\" ;then\n    echo \"These packages were: $(package_dependencies \"$package_name\")\"\n    \n    status \"Purging the $package_name package...\"\n\n    if [ \"$script_input\" == \"update\" ]; then\n      # skip --autoremove for faster updates. this prevents dummy deb dependencies from needing to be uninstalled and reinstalled on updates\n      apt_lock_wait\n      local output=\"$(sudo -E apt purge -y \"$package_name\" 2>&1 | less_apt | tee /dev/stderr)\"\n      status \"Apt finished.\"\n    else\n      apt_lock_wait\n      local output=\"$(sudo -E apt purge -y \"$package_name\" --autoremove 2>&1 | less_apt | tee /dev/stderr)\"\n      status \"Apt finished.\"\n    fi\n    \n    errors=\"$(echo \"$output\" | grep '^[(E)|(Err]:')\"\n    if [ ! -z \"$errors\" ];then\n      echo -e \"\\e[91mFailed to uninstall the packages!\\e[39m\"\n      echo -e \"APT reported these errors:\\n\\e[91m$errors\\e[39m\"\n      #run some apt error diagnosis\n      echo \"$output\"\n      exit 1\n    fi\n    \n  elif [ -f \"${DIRECTORY}/data/installed-packages/${app}\" ];then\n    #legacy pkg-install implementation\n    warning \"Using the old implementation - an installed-packages file instead of a dummy deb\"\n    \n    local packages=\"$(cat \"${DIRECTORY}/data/installed-packages/${app}\" | tr '\\n' ' ' | sed 's/  / /g')\"\n    \n    #normal mode\n    local output=\"$(sudo -E apt purge -y $packages 2>&1)\"\n    exitcode=$?\n    \n    errors=\"$(echo \"$output\" | grep '^[(E)|(Err]:')\"\n    if [ $exitcode != 0 ] || [ ! -z \"$errors\" ];then\n      echo -e \"\\e[91mFailed to uninstall the packages!\\e[39m\"\n      echo -e \"APT reported these errors:\\n\\e[91m$errors\\e[39m\"\n      #run some apt error diagnosis\n      echo \"$output\"\n      exit 1\n    fi\n  else\n    status \"The $package_name package is not installed so there's nothing to do.\"\n  fi\n  \n  status_green \"All packages have been purged successfully.\"\n  rm -f \"${DIRECTORY}/data/installed-packages/${app}\"\n}\n\nget_icon_from_package() { #given a package-name, find all png files that it installed and print the one with the largest file-size.\n  [ -z \"$1\" ] && error \"get_icon_from_package(): requires an apt package name\"\n  \n  #Find dependencies of the listed packages and scan them too\n  local package=''\n  local extra_packages=''\n  for package in \"$@\" ;do\n    #for every package specified, look for dependencies to that package that begin with the same name as the original package\n    #Example: given the 'shotwell' package, this will find the 'shotwell-common' package, as well as others\n    extra_packages+=\" $(package_dependencies \"$package\" | sed 's/, \\||/\\n/g' | awk '{print $1}' | grep \"^$package\" | sort | uniq | tr '\\n' ' ')\"\n  done\n  dpkg-query -L \"$@\" $extra_packages 2>/dev/null | grep '\\.png$\\|\\.svg$' | grep '/icons/\\|/pixmaps/' | grep -v /symbolic/ | xargs wc -c | grep -v ' total' | sort -nr | head -n1 | sed 's/  / /g' | sed 's/^ //g' | tr ' ' '\\n' | tail -n +2\n}\n\nubuntu_ppa_installer() { #setup a PPA on an Ubuntu distro. Arguments: ppa_name\n  local ppa_name=\"$1\"\n  [ -z \"$1\" ] && error \"ubuntu_ppa_installer(): This function is used to add a ppa to a ubuntu based install but a required input argument was missing.\"\n  local ppa_grep=\"$ppa_name\"\n  [[ \"${ppa_name}\" != */ ]] && local ppa_grep=\"${ppa_name}/\"\n  local ppa_added=$(apt-get indextargets --no-release-info --format '$(SITE) $(RELEASE) $(TARGET_OF)' | sort -u | awk '{if ($3==\"deb\") print $1\" \"$2 }' | grep \"$ppa_grep\" | wc -l)\n  if [[ $ppa_added -eq \"1\" ]]; then\n    status \"Skipping $ppa_name PPA, already added\"\n  else\n    status \"Adding $ppa_name PPA\"\n    sudo add-apt-repository \"ppa:$ppa_name\" -y || exit 1\n    apt_update || exit 1\n  fi\n  # check if ppa .list filename does not exist under the current distro codename\n  # on a distro upgrade the .list filename is not updated and add-apt-repository can re-use the old filename\n  local ppa_dist=\"$__os_codename\"\n  local standard_filename=\"/etc/apt/sources.list.d/${ppa_name%/*}-ubuntu-${ppa_name#*/}-${ppa_dist}.list\" \n  if [[ ! -f \"$standard_filename\" ]] && ls /etc/apt/sources.list.d/${ppa_name%/*}-ubuntu-${ppa_name#*/}-*.list 1> /dev/null; then\n    local original_filename=\"$(ls /etc/apt/sources.list.d/${ppa_name%/*}-ubuntu-${ppa_name#*/}-*.list | head -1)\"\n    # change the filename to match the current distro codename\n    sudo mv \"$original_filename\" \"$standard_filename\"\n    sudo rm -f \"$original_filename\".distUpgrade\n    sudo rm -f \"$original_filename\".save\n  fi\n}\n\ndebian_ppa_installer() { #setup a PPA on a Debian distro. Arguments: ppa_name distribution key\n  local ppa_name=\"$1\"\n  local ppa_dist=\"$2\"\n  local key=\"$3\"\n  [ -z \"$1\" ] || [ -z \"$2\" ] || [ -z \"$3\" ] && error \"debian_ppa_installer(): This function is used to add a ppa to a debian based install but a required input argument was missing.\"\n  local ppa_grep=\"$ppa_name\"\n  [[ \"${ppa_name}\" != */ ]] && local ppa_grep=\"${ppa_name}/ubuntu ${ppa_dist}\"\n  local ppa_added=$(apt-get indextargets --no-release-info --format '$(SITE) $(RELEASE) $(TARGET_OF)' | sort -u | awk '{if ($3==\"deb\") print $1\" \"$2 }' | grep \"$ppa_grep\" | wc -l)\n  if [[ $ppa_added -eq \"1\" ]]; then\n    status \"Skipping $ppa_name PPA, already added\"\n  else\n    status \"Adding $ppa_name PPA\"\n    echo \"deb https://ppa.launchpadcontent.net/${ppa_name}/ubuntu ${ppa_dist} main\" | sudo tee /etc/apt/sources.list.d/${ppa_name%/*}-ubuntu-${ppa_name#*/}-${ppa_dist}.list || error \"Failed to add repository to sources.list!\"\n    sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys \"$key\"\n    if [ $? != 0 ];then\n      sudo rm -f /etc/apt/sources.list.d/${ppa_name%/*}-ubuntu-${ppa_name#*/}-${ppa_dist}.list\n      error \"Failed to sign the $ppa_name PPA!\"\n    fi\n    apt_update || exit 1\n  fi\n}\n\nadd_external_repo() { # add an external apt repo and its gpg key.\n  # follows https://wiki.debian.org/DebianRepository/UseThirdParty specification with deb822 format https://repolib.readthedocs.io/en/latest/deb822-format.html\n  # required inputs\n  local reponame=\"$1\"\n  local pubkeyurl=\"$2\"\n  local uris=\"$3\"\n  local suites=\"$4\"\n  # potentially optional inputs\n  # components is not used when suite is an absolute path\n  local components=\"$5\"\n  # additional options can be specified as the 6th, 7th, 8th, etc argument (eg: \"Architectures: arm64\")\n\n  # check if all needed vars are set  \n  [ -z \"$reponame\" ] && error \"add_external_repo: reponame not set\"\n  [ -z \"$uris\" ] && error \"add_external_repo: uris not set\"\n  [ -z \"$suites\" ] && error \"add_external_repo: suites not set\"\n  [ -z \"$pubkeyurl\" ] && error \"add_external_repo: pubkeyurl not set\"\n\n  # exit if reponame or uri or suite contains space\n  if [[ $reponame = *\" \"* ]] || [[ $uris = *\" \"* ]] || [[ $suites = *\" \"* ]]; then\n    error \"add_external_repo: provided reponame contains a space.\"\n  fi\n\n  # check if links are valid\n  status \"add_external_repo: checking 3rd party pubkeyurl validity\"\n  wget --spider \"$pubkeyurl\" || error \"add_external_repo: pubkeyurl isn't a valid link\"\n\n  # make apt keyring directory if it doesn't exist\n  if [ ! -d /usr/share/keyrings ]; then\n    sudo mkdir -p /usr/share/keyrings || error \"add_external_repo: failed to create apt keyring directory.\"\n  fi\n\n  # check if .list file already exists\n  if [ -f /etc/apt/sources.list.d/${reponame}.list ]; then\n    sudo rm -f /etc/apt/sources.list.d/${reponame}.list || error \"add_external_repo: failed to remove conflicting .list file.\"\n  fi\n\n  # check if .sources file already exists\n  if [ -f /etc/apt/sources.list.d/${reponame}.sources ]; then\n    sudo rm -f /etc/apt/sources.list.d/${reponame}.sources || error \"add_external_repo: failed to remove conflicting .sources file.\"\n  fi\n\n  # download gpg key from specified url\n  if [ -f /usr/share/keyrings/${reponame}-archive-keyring.gpg ]; then\n    sudo rm -f /usr/share/keyrings/${reponame}-archive-keyring.gpg\n  fi \n  wget -qO- \"$pubkeyurl\" | sudo gpg --dearmor -o /usr/share/keyrings/${reponame}-archive-keyring.gpg\n\n  if [ $? != 0 ];then\n    sudo rm -f /etc/apt/sources.list.d/${reponame}.sources\n    sudo rm -f /usr/share/keyrings/${reponame}-archive-keyring.gpg\n    error \"add_external_repo: download from specified pubkeyurl failed.\"\n  fi\n\n  # create .sources file\n  echo \"Types: deb\nURIs: $uris\nSuites: $suites\" | sudo tee /etc/apt/sources.list.d/${reponame}.sources >/dev/null\n  if [ ! -z \"$components\" ]; then\n    echo \"Components: $components\" | sudo tee -a /etc/apt/sources.list.d/${reponame}.sources >/dev/null\n  fi\n  for input in \"${@: 6}\"; do\n    echo \"$input\" | sudo tee -a /etc/apt/sources.list.d/${reponame}.sources >/dev/null\n  done\n  echo \"Signed-By: /usr/share/keyrings/${reponame}-archive-keyring.gpg\" | sudo tee -a /etc/apt/sources.list.d/${reponame}.sources >/dev/null\n\n  if [ $? != 0 ];then\n    sudo rm -f /etc/apt/sources.list.d/${reponame}.sources\n    sudo rm -f /usr/share/keyrings/${reponame}-archive-keyring.gpg\n    error \"add_external_repo: failed to create ${reponame}.list file\"\n  fi\n}\n\nrm_external_repo() { # remove an external apt repo and its gpg key, if the repo is no longer in use. (force-remove the repo with force argument)\n\n  local reponame=\"$1\"\n  local force=\"$2\"\n\n  [ -z \"$reponame\" ] && error \"rm_external_repo: reponame not provided\"\n\n  # exit if reponame contains space, since apt doesn't accept .list files with spaces in filename or keyname.\n  if [[ $reponame = *\" \"* ]]; then\n    error \"rm_external_repo: provided reponame contains a space.\"\n  fi\n\n  # always remove deprecated .list file if present\n  if [ -f /etc/apt/sources.list.d/${reponame}.list ]; then\n    sudo rm -f /etc/apt/sources.list.d/${reponame}.list\n  fi\n\n  # exit gracefully if .sources file does not exist\n  [ -f \"/etc/apt/sources.list.d/$reponame.sources\" ] || return 0\n  \n  if [ \"$force\" == force ]; then\n    sudo rm -f /usr/share/keyrings/${reponame}-archive-keyring.gpg || error \"rm_external_repo: removal of ${reponame}-archive-keyring.gpg failed\"\n    sudo rm -f /etc/apt/sources.list.d/${reponame}.sources || error \"rm_external_repo: removal of ${reponame}.sources failed\"\n    return 0\n  fi\n\n  remove_repofile_if_unused /etc/apt/sources.list.d/${reponame}.sources \"\" /usr/share/keyrings/${reponame}-archive-keyring.gpg\n}\n\nadoptium_installer() {\n  case \"$__os_codename\" in\n  bionic | focal | jammy | noble | buster | bullseye | bookworm)\n    add_external_repo \"adoptium\" \"https://adoptium.jfrog.io/artifactory/api/security/keypair/default-gpg-key/public\" \"https://adoptium.jfrog.io/artifactory/deb\" \"$__os_codename\" \"main\" || exit 1\n    ;;\n  *)\n    # use bionic target name explicitly for any other OS as its the oldest LTS target adoptium continues to support\n    # all supported adoptium OSs use the same debs so the target specified does not actually matter\n    add_external_repo \"adoptium\" \"https://adoptium.jfrog.io/artifactory/api/security/keypair/default-gpg-key/public\" \"https://adoptium.jfrog.io/artifactory/deb\" \"bionic\" \"main\" || exit 1\n    ;;\n  esac\n  apt_update\n  if [ $? != 0 ]; then\n    rm_external_repo \"adoptium\"\n    error \"Failed to perform apt update after adding Adoptium repository.\"\n  fi\n}\n\npipx_install() {\n  # install pipx keeping in mind distro issues\n  # pipx < 0.16.0 is compatible with 3.6 <= python3 < 3.9\n  # 0.16.0 <= pipx < 1.1.0 is compatible with python3 >= 3.6\n  # 1.1.0 <= pipx < 1.3.0 is compatible with python3 >= 3.7\n  # pipx >= 1.3.0 is compatible with python3 >= 3.8\n  # some distros lack pipx entirely\n  # some distros (raspbian bullseye specifically) have incompatible combinations of pipx (0.12.3) and python3 (3.9) versions, necessitating pipx to be installed/upgraded from pip\n  # pipx 1.0.0 is the first stable release and has some features that we would like to assume are available, install it from pip if the distro package is too old\n  # pi-apps scripts and functions should assume that ONLY a minimum pipx version of 1.0.0 is available\n  if package_available pipx && package_is_new_enough pipx 1.0.0 ;then\n    install_packages pipx python3-venv || exit 1\n  elif package_is_new_enough python3 3.7 ; then\n    install_packages python3-venv || exit 1\n    sudo -H python3 -m pip install --upgrade pipx || exit 1\n  elif package_available python3.8 ;then\n    install_packages python3.8 python3.8-venv || exit 1\n    sudo -H python3.8 -m pip install --upgrade pipx || exit 1\n  else\n    error \"pipx is not available on your distro and so cannot install $* to python venv\"\n  fi\n  sudo PIPX_HOME=/usr/local/pipx PIPX_BIN_DIR=/usr/local/bin pipx install \"$@\" || error \"Failed to install $* with pipx\"\n}\n\npipx_uninstall() {\n  sudo PIPX_HOME=/usr/local/pipx PIPX_BIN_DIR=/usr/local/bin pipx uninstall \"$@\" || error \"Failed to uninstall $* with pipx\"\n}\n\nremove_deprecated_app() { # prompts a user to uninstall a deprecated pi-apps application and then removes the application folder if it exists\n  local app=\"$1\" # on app name\n  local removal_arch=\"$2\" # 32 or 64 to only remove one architecture if specified\n  local message=\"$3\" # custom message addendum to show to the user (if given)\n  [ -z \"$app\" ] && error \"remove_deprecated_app(): requires an pi-apps app name\"\n  local app_status=\"$(app_status \"${app}\")\"\n  if [ -z \"$message\" ] && [ ! -z \"$removal_arch\" ] && [ \"$arch\" == \"$removal_arch\" ] && [ -d \"${DIRECTORY}/apps/$app\" ] && [ \"$app_status\" == \"installed\" ]; then\n    local text=\"Pi-Apps has deprecated $app for ${removal_arch}-bit OSs which you currently have installed.\nWould you like to uninstall it now or leave it installed? You will NOT be able to uninstall $app with Pi-Apps later.\"\n    userinput_func \"$text\" \"Uninstall now\" \"Leave installed\"\n  elif [ ! -z \"$message\" ] && [ ! -z \"$removal_arch\" ] && [ \"$arch\" == \"$removal_arch\" ] && [ -d \"${DIRECTORY}/apps/$app\" ] && [ \"$app_status\" == \"installed\" ]; then\n    local text=\"Pi-Apps has deprecated $app for ${removal_arch}-bit OSs which you currently have installed.\n\n$message\n\nWould you like to uninstall it now or leave it installed? You will NOT be able to uninstall $app with Pi-Apps later.\"\n    userinput_func \"$text\" \"Uninstall now\" \"Leave installed\"\n  elif [ ! -z \"$removal_arch\" ]; then\n    # remove per-architecture script regardless of the current arch\n    rm -f \"${DIRECTORY}/apps/$app/install-$removal_arch\"\n    # remove unified-architecture script incase the new version has a per-architecture script\n    rm -f \"${DIRECTORY}/apps/$app/install\"\n    return 0\n  elif [ -z \"$message\" ] && [ -z \"$removal_arch\" ] && [ -d \"${DIRECTORY}/apps/$app\" ] && [ \"$app_status\" == \"installed\" ]; then\n    local text=\"Pi-Apps has deprecated $app which you currently have installed.\nWould you like to uninstall it now or leave it installed? You will NOT be able to uninstall $app with Pi-Apps later.\"\n    userinput_func \"$text\" \"Uninstall now\" \"Leave installed\"\n  elif [ ! -z \"$message\" ] && [ -z \"$removal_arch\" ] && [ -d \"${DIRECTORY}/apps/$app\" ] && [ \"$app_status\" == \"installed\" ]; then\n    local text=\"Pi-Apps has deprecated $app which you currently have installed.\n\n$message\n\nWould you like to uninstall it now or leave it installed? You will NOT be able to uninstall $app with Pi-Apps later.\"\n    userinput_func \"$text\" \"Uninstall now\" \"Leave installed\"\n  elif [ -z \"$removal_arch\" ]; then\n    # only remove folder if the desired removal arch is unset (so remove on all architectures)\n    rm -rf \"${DIRECTORY}/apps/$app\"\n    return 0\n  else\n    # do nothing otherwise\n    return 0\n  fi\n  if [ \"$output\" == \"Uninstall now\" ]; then\n    \"${DIRECTORY}/manage\" uninstall \"$app\"\n  fi\n  if [ ! -z \"$removal_arch\" ]; then\n    # remove per-architecture script regardless of the current arch\n    rm -f \"${DIRECTORY}/apps/$app/install-$removal_arch\"\n    # remove unified-architecture script incase the new version has a per-architecture script\n    rm -f \"${DIRECTORY}/apps/$app/install\"\n  else\n    # only remove folder if the desired removal arch is unset (so remove on all architectures)\n    rm -rf \"${DIRECTORY}/apps/$app\"\n  fi\n  return 0\n}\n\nterminal_manage() { # wrapper for the original terminal_manage function to terminal_mange_multi\n  action=\"$1\"\n  app=\"$2\" #one app name\n  \n  [ -z \"$action\" ] && error \"terminal_manage(): Must specify an action: either 'install' or 'uninstall' or 'update' or 'refresh'\"\n  \n  terminal_manage_multi \"$action $app\"\n}\n\nterminal_manage_multi() { #function to install/uninstall/update/refresh multiple apps (or filelists) - uses a terminal and refreshes the app list\n  queue=\"$1\" #one or multiple actions and app names (or filelists of the format 'filelist:path/to/file:path/to/another/file')\n  \n  #To prevent multiple simultaneous manage instances, use the 'daemon' mode. This will create a queue of actions that are executed concurrently.\n  #The first daemon instance is the 'master' process. Subsequent processes will add the action to the queue and then exit.\n  #All output is generated by the 'master' daemon process. Subsequent processes shouldn't open a terminal, because the master one is already open.\n  if [ -f \"${DIRECTORY}/data/manage-daemon/pid\" ] && process_exists $(cat \"${DIRECTORY}/data/manage-daemon/pid\") ;then\n    #The 'master' daemon is already running. Avoid launching a second terminal.\n    \"${DIRECTORY}/manage\" daemon \"$queue\"\n    \n  else\n    #in a terminal, first get the api functions, display the pi-apps logo, run the manage script, and refresh the app list if the $pipe variable is set\n    \"${DIRECTORY}/etc/terminal-run\" '\n      DIRECTORY=\"'\"$DIRECTORY\"'\"\n      export geometry2=\"'\"$geometry2\"'\"\n      source \"${DIRECTORY}/api\"\n      generate_logo\n      \n      refresh_list() { #Refresh the current list of apps in the event of a change\n        if [ ! -z \"'\"$pipe\"'\" ] && [ -p \"'\"$pipe\"'\" ];then\n          echo -e \"\\f\" > \"'\"$pipe\"'\"\n          \"${DIRECTORY}/preload\" \"$(cat \"${DIRECTORY}/data/settings/App List Style\")\" \"'\"$prefix\"'\" > \"'\"$pipe\"'\" 2>/dev/null\n        fi\n      }\n      \n      \"${DIRECTORY}/manage\" daemon \"'\"$queue\"'\"\n      \n      #refresh app list\n      refresh_list\n      \n      for i in {30..1} ;do\n        echo -en \"You can close this window now. Auto-closing in $i seconds.\\e[0K\\r\"\n        sleep 1\n      done\n      ' \"Terminal Output\"\n    \n    # Check if terminal-run failed to launch. GUI users don't see any terminal output if it fails (since there is no terminal open) so we need to prompt them with a GUI window\n    if [ \"$?\" != 0 ]; then\n      echo -e \"Unable to open a terminal.\\nDebug output below.\\n$(DEBUG=1 \"${DIRECTORY}/etc/terminal-run\" 2>&1)\" | yad --center --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n      --width=700 --height=300 --text-info --title=\"Error occured when calling terminal-run\" \\\n      --image=\"${DIRECTORY}/icons/error.png\" --image-on-top --fontname=12 \\\n      --button='OK'\n      if echo \"$queue\" | grep -q \"^update filelist:\" ;then #list of files separated by :\n        updatable_apps='' updatable_files=\"$(echo \"$queue\" | grep \"^update filelist:\" | sed 's/^update filelist://g' | tr ':' '\\n')\" no_status=true update_now_cli\n      fi\n    fi\n  fi\n}\n#end of apt functions\n\n#flatpak functions\nflatpak_install() { #install an app using flatpak\n  [ -z \"$1\" ] && error \"flatpak_install(): This function is used to install a flatpak app, but nothing was specified.\"\n  \n  #make sure flatpak is installed\n  if ! command -v flatpak >/dev/null ;then\n    error \"flatpak_install(): Could not install $1 because flatpak is not installed!\"\n  fi\n  \n  if ! package_is_new_enough flatpak 1.14.4 ;then\n    case \"$__os_codename\" in\n    buster)\n      debian_ppa_installer \"theofficialgman/flatpak-no-bwrap\" \"bionic\" \"0ACACB5D1E74E484\"\n      apt_lock_wait\n      sudo apt --only-upgrade install flatpak -y | less_apt\n      ;;\n    bullseye)\n      debian_ppa_installer \"theofficialgman/flatpak-no-bwrap\" \"focal\" \"0ACACB5D1E74E484\"\n      apt_lock_wait\n      sudo apt --only-upgrade install flatpak -y | less_apt\n      ;;\n    bionic|focal|jammy)\n      ubuntu_ppa_installer \"theofficialgman/flatpak-no-bwrap\"\n      apt_lock_wait\n      sudo apt --only-upgrade install flatpak -y | less_apt\n      ;;\n    esac\n  fi\n  \n  status -n \"Flatpak: Adding flathub remote... \"\n  #Add the flathub remote, first as root, if that fails then try installing as user, while removing unwanted output\n  ( sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || error \"Flatpak failed to add flathub remote!\"  ) | grep --line-buffered -v \"Note that the directories \n'/var/lib/flatpak/exports/share'\n'$HOME/.local/share/flatpak/exports/share'\nare not in the search path set by the XDG_DATA_DIRS environment variable, so\napplications installed by Flatpak may not appear on your desktop until the\nsession is restarted.\"\n  #exit 1 if above code failed\n  if [ ${PIPESTATUS[0]} != 0 ];then\n    exit 1\n  fi\n  status_green Done\n  \n  status -n \"Flatpak: installing $1... \"\n  #Install the specified app, first as root, if that fails then try installing as user, while removing unwanted output\n  ( sudo flatpak install flathub \"$1\" -y || flatpak install flathub \"$1\" -y || error \"Flatpak failed to install $1!\" ) | grep --line-buffered -v \"Note that the directories \n\n'/var/lib/flatpak/exports/share'\n'$HOME/.local/share/flatpak/exports/share'\nare not in the search path set by the XDG_DATA_DIRS environment variable, so\napplications installed by Flatpak may not appear on your desktop until the\nsession is restarted.\"\n  #exit 1 if above code failed\n  if [ ${PIPESTATUS[0]} != 0 ];then\n    exit 1\n  fi\n  status_green Done\n  \n  #Pi-Apps tries to avoid unnecessary reboots at all cost. Flatpak places desktop launchers in /var/lib/flatpak/exports/share/applications, which is not searched by default.\n  #This path is added to $XDG_DATA_DIRS on the next reboot, but we don't want to wait for that!\n  #If there are files in /var/lib/flatpak/exports/share/applications, and XDG_DATA_DIRS is missing flatpak paths, then bind-mount to /usr/share/applications\n  if [[ \"$XDG_DATA_DIRS\" != */var/lib/flatpak/exports/share* ]] && [ ! -z \"$(ls /var/lib/flatpak/exports/share/applications)\" ] && [ -z \"$(ls /usr/share/applications/flatpak-temporary)\" ];then\n    sudo mkdir -p /usr/share/applications/flatpak-temporary\n    sudo mount --bind /var/lib/flatpak/exports/share/applications /usr/share/applications/flatpak-temporary\n  elif [[ \"$XDG_DATA_DIRS\" == */var/lib/flatpak/exports/share* ]] ;then\n    sudo rm -rf /usr/share/applications/flatpak-temporary\n  fi\n  #Additionally, PiOS Buster had a bug where XDG_DATA_DIRS was missing flatpak's entries due to PiOS mods. Pi-Apps fixes this with a runonce.\n  \n  true\n}\n\nflatpak_uninstall() { #uninstall an app using flatpak\n  [ -z \"$1\" ] && error \"flatpak_uninstall(): This function is used to uninstall a flatpak app, but nothing was specified.\"\n  \n  #if flatpak is not installed, then skip everything with code 0.\n  if ! command -v flatpak >/dev/null ;then\n    return 0\n  fi\n  \n  #Only try to remove flatpak app if it's installed.\n  if flatpak list | grep -qF \"$1\" ;then\n    sudo flatpak uninstall \"$1\" -y || flatpak uninstall \"$1\" -y || error \"Flatpak failed to uninstall $1!\"\n  fi\n}\n#end of flatpak functions\n\n#app functions\nlist_apps() { # $1 can be: installed, uninstalled, corrupted, cpu_installable, hidden, visible, online, online_only, local, local_only\n  if [ -z \"$1\" ] || [ \"$1\" == local ];then\n    #list all apps\n    ls \"${DIRECTORY}/apps\"\n    \n  elif [ \"$1\" == all ];then\n    #combined list of apps, both online and local. Removes duplicate apps from the list.\n    echo -e \"$(list_apps local)\\n$(list_apps online)\" | sort | uniq\n    \n  elif [ \"$1\" == installed ];then\n    #list apps      |   only show      (          list of installed apps                | remove match string  |   basename   )\n    list_apps local | list_intersect \"$(grep -rx 'installed' \"${DIRECTORY}/data/status\" | awk -F: '{print $1}' | sed 's!.*/!!')\"\n    \n  elif [ \"$1\" == corrupted ];then\n    #list apps      |only show         (          list of corrupted apps                | remove match string  |   basename   )\n    list_apps local | list_intersect \"$(grep -rx 'corrupted' \"${DIRECTORY}/data/status\" | awk -F: '{print $1}' | sed 's!.*/!!')\"\n    \n  elif [ \"$1\" == disabled ];then\n    #list apps      |    only show     (          list of disabled apps                | remove match string  |   basename   )\n    list_apps local | list_intersect \"$(grep -rx 'disabled' \"${DIRECTORY}/data/status\" | awk -F: '{print $1}' | sed 's!.*/!!')\"\n    \n  elif [ \"$1\" == uninstalled ];then\n    #list apps that have a status file matching \"uninstalled\"\n    list_apps local | list_intersect \"$(grep -rx 'uninstalled' \"${DIRECTORY}/data/status\" | awk -F: '{print $1}' | sed 's!.*/!!')\"\n    #also list apps that don't have a status file\n    list_apps local | list_subtract \"$(ls \"${DIRECTORY}/data/status\")\"\n    \n  elif [ \"$1\" == have_status ];then\n    #list apps that have a status file\n    list_apps local | list_intersect \"$(ls \"${DIRECTORY}/data/status\")\"\n    \n  elif [ \"$1\" == missing_status ];then\n    #list apps that don't have a status file\n    list_apps local | list_subtract \"$(ls \"${DIRECTORY}/data/status\")\"\n    \n  elif [ \"$1\" == cpu_installable ];then\n    #list apps that can be installed on the device's OS architecture (32-bit or 64-bit)\n    #find all apps that have install-XX script, install script, or a packages file\n    find \"${DIRECTORY}/apps\" -type f \\( -name \"install-$arch\" -o -name \"install\" -o -name \"packages\" \\) | sed \"s+${DIRECTORY}/apps/++g\" | sed 's+/.*++g' | sort | uniq\n    \n  elif [ \"$1\" == package ];then\n    #list apps that have a \"packages\" file\n    find \"${DIRECTORY}/apps\" -type f -name \"packages\" | sed \"s+/packages++g\" | sed \"s+${DIRECTORY}/apps/++g\" | sort | uniq\n    \n  elif [ \"$1\" == standard ];then\n    #list apps that have scripts\n    find \"${DIRECTORY}/apps\" -type f \\( -name \"install-32\" -o -name \"install-64\" -o -name \"install\" -o -name \"uninstall\" \\) | sed \"s+${DIRECTORY}/apps/++g\" | sed 's+/.*++g' | sort | uniq\n    \n  elif [ \"$1\" == hidden ];then\n    #list apps that are hidden\n    read_category_files | grep '|hidden' | awk -F'|' '{print $1}'\n    \n  elif [ \"$1\" == visible ];then\n    #list apps that are in any other category but 'hidden', and aren't disabled\n    read_category_files | grep -v '|hidden' | awk -F'|' '{print $1}' # | list_subtract \"$(list_apps disabled)\"\n    \n  elif [ \"$1\" == online ];then\n    #list apps that exist on the online git repo\n    if [ -d \"${DIRECTORY}/update/pi-apps/apps\" ];then\n      #if update folder exists, just use that\n      ls \"${DIRECTORY}/update/pi-apps/apps\" | grep .\n    else\n      #if update folder doesn't exist, then parse github HTML to get a list of online apps. Horrible idea, but it works!\n      wget -qO- \"${repo_url}/tree/master/apps\" | grep 'title=\".*\" data-pjax=' -o | sed 's/title=\"//g' | sed 's/\" data-pjax=//g'\n    fi\n    \n  elif [ \"$1\" == online_only ];then\n    #list apps that exist only on the git repo, and not locally\n    list_apps online | list_subtract \"$(list_apps local)\"\n    \n  elif [ \"$1\" == local_only ];then\n    #list apps that exist only locally, and not on the git repo\n    list_apps local | list_subtract \"$(list_apps online)\"\n    \n  else\n    error \"list_apps(): unrecognized filter '$1'!\"\n  fi\n}\n\nlist_intersect() { #Outputs only the apps that appear in both stdin and in $1\n  # for example, the following two inputs will be a match\n  # Audacity\n  # Audacity\n  # while these two will NOT be a match\n  # Multimedia/Audacity\n  # .*/Audacity\n  comm -12 - <(echo \"$1\" | sort)\n}\n\nlist_intersect_partial() { #Outputs only the apps that appear in both stdin and in $1 even with a partial match\n  # for example, the following two inputs will be a match\n  # Multimedia/Audacity\n  # .*/Audacity\n  #                      change \\n to \\|     |   remove last \"\\|\"\n  grep -x \"$(echo \"$1\" | sed -z 's/\\n/\\\\|/g' | sed -z 's/\\\\|$/\\n/g')\"\n}\n\nlist_subtract() { #Outputs a list of apps from stdin, minus the ones that appear in $1\n  # for example, the following two inputs will be a match\n  # Audacity\n  # Audacity\n  # while these two will NOT be a match\n  # Multimedia/Audacity\n  # .*/Audacity\n  comm -23 - <(echo \"$1\" | sort)\n}\n\nlist_subtract_partial() { #Outputs a list of apps from stdin, minus the ones that appear in $1 even with a partial match\n  # for example, the following two inputs will be a match\n  # Multimedia/Audacity\n  # .*/Audacity\n  #                       change \\n to \\|     |   remove last \"\\|\"\n  grep -vx \"$(echo \"$1\" | sed -z 's/\\n/\\\\|/g' | sed -z 's/\\\\|$/\\n/g')\"\n}\n\nread_category_files() { #Generates a combined categories-list from several sources: category-overrides, global categories file, and unlisted apps. Format: \"app|category\"\n  \n  #remove app category if app folder not found\n  local IFS=$'\\n'\n  local app\n  for app in $(cat \"${DIRECTORY}/data/category-overrides\" 2>/dev/null); do\n    if ! [ -d \"${DIRECTORY}/apps/$(echo \"$app\" | sed 's/|.*//')\" ] &>/dev/null; then \n      sed -i \"/$app/d\"  \"${DIRECTORY}/data/category-overrides\"\n    fi\n  done\n\n  # get device specific categories overrides (if they exist)\n  # obtain model and jetson_model\n  get_model &>/dev/null\n  version_id=$(grep 'VERSION_ID=' /etc/os-release | tr -cd '0123456789.')\n  unset device_override\n  if [[ \"$model\" != *\"Raspberry Pi\"* ]]; then\n    device_override=\"${DIRECTORY}/etc/category-overrides-non-raspberry\"\n  fi\n  if [[ ! -z \"$jetson_model\" ]] && [[ \"$version_id\" == \"18.04\" ]]; then\n    device_override=\"${DIRECTORY}/etc/category-overrides-jetson-18.04\"\n  elif [[ ! -z \"$jetson_model\" ]]; then\n    device_override=\"${DIRECTORY}/etc/category-overrides-jetson-generic\"\n  fi\n  \n  #list the user-overrides file     and the device specific override  and the global categories file   |-----and all apps------------|     filter out duplicates   no '\\n\\n'\n  (cat \"${DIRECTORY}/data/category-overrides\" \"$device_override\" \"${DIRECTORY}/etc/categories\" 2>/dev/null ; echo ; list_apps local | sed 's/$/|/g') | awk -F'|' '!seen[$1]++' | grep .\n}\n\napp_prefix_category() { #lists all apps in a category with format \"category/app\", or if $1 is left blank, then list the full structure of all categories\n  \n  #Subtract a type of app if enabled\n  local show_apps_setting=\"$(cat \"${DIRECTORY}/data/settings/Show apps\")\"\n  local filter=()\n  if [ \"$show_apps_setting\" == 'standard' ];then\n    #if only showing standard apps, hide package apps\n    filter=(list_subtract_partial \"$(list_apps package | sed 's+^+.*/+g')\")\n  elif [ \"$show_apps_setting\" == 'packages' ];then\n    #if only showing package apps, hide standard apps\n    filter=(list_subtract_partial \"$(list_apps standard | sed 's+^+.*/+g')\")\n  else\n    #is the setting is \"all\" or missing, don't filter.\n    filter=(cat)\n  fi\n  \n  #show special \"Installed\" category - don't filter it\n  if [ \"$1\" == \"Installed\" ]; then\n    list_apps installed | sed 's+^+Installed/+g'\n  #show special \"Packages\" category\n  elif [ \"$1\" == \"Packages\" ]; then\n    list_apps package | list_subtract \"$(list_apps hidden)\" | sed 's+^+Packages/+g'\n  #show special \"All Apps\" category\n  elif [ \"$1\" == \"All Apps\" ]; then\n    list_apps cpu_installable | list_subtract \"$(list_apps hidden)\" | sed 's+^+All Apps/+g' | \"${filter[@]}\"\n  # show all categories\n  elif [ -z \"$1\" ]; then\n    #show normal categories\n    read_category_files | grep . | awk -F'|' '{print $2\"/\"$1}' | sed 's+^/++g' | \"${filter[@]}\"\n    \n    #show special \"Installed\" category - don't filter it\n    list_apps installed | sed 's+^+Installed/+g'\n    \n    #show special \"Packages\" category\n    if [ \"$show_apps_setting\" != standard ];then\n      list_apps package | list_subtract \"$(list_apps hidden)\" | sed 's+^+Packages/+g'\n    fi\n    #show special \"All Apps\" category\n    list_apps cpu_installable | list_subtract \"$(list_apps hidden)\" | sed 's+^+All Apps/+g' | \"${filter[@]}\"\n  #show normal categories\n  else\n    read_category_files | grep . | awk -F'|' '{print $2\"/\"$1}' | grep \"^$1/\" | sed 's+^/++g' | \"${filter[@]}\"\n  fi\n}\n\nbitly_link() { #compatibility function pointing to shlink_link (incase old manage script is running with new api)\n  shlink_link \"$@\"\n}\n\nshlink_link() { #Runs whenever an app is installed/uninstalled to tally the number of users for each app\n  {\n  #This cannot possibly be used to identify you, or any information about you.\n  #It simply \"clicks\" a shlink link - a shortened URL - so that the total number of clicks can be tallied to determine how popular a certain app is.\n  local app=\"$1\"\n  local trigger=\"$2\"\n  \n  [ -z \"$app\" ] && error \"shlink_link(): requires an app argument\"\n  [ -z \"$trigger\" ] && error \"shlink_link(): requires a trigger argument\"\n  \n  #if the 'Enable Analytics' setting is enabled\n  if [ \"$(cat \"${DIRECTORY}/data/settings/Enable analytics\" 2>/dev/null)\" != 'No' ]; then\n    #obtain model and SOC_ID\n    get_model &>/dev/null\n    local model=\"$(echo $model | tr -d '\"'\\; | head -1)\"\n    # obtain (hashed) machine_id (only if file exists and has contents)\n    [ -s /etc/machine-id ] && machine_id=\"$(cat /etc/machine-id | sha1sum | awk '{print $1}' | head -1)\"\n    # obtain (hashed) serial_number (only if file exists and has contents)\n    [ -s /sys/firmware/devicetree/base/serial-number ] && serial_number=\"$(cat /sys/firmware/devicetree/base/serial-number | sha1sum | awk '{print $1}' | head -1)\"\n    #obtain operating system name\n    #not using PRETTY_NAME to only get the ID and OS major version (eg: Ubuntu 24.04 instead of Ubuntu 24.04.1 LTS)\n    local os_name=\"$(cat /etc/os-release | grep ^ID= | tr -d '\"'\\; | awk -F= '{print $2}' | head -1) $(cat /etc/os-release | grep ^VERSION_ID= | tr -d '\"'\\; | awk -F= '{print $2}' | head -1)\"\n\n    #determine the name of the link to \"click\"\n    local shlinklink=\"https://analytics.pi-apps.io/pi-apps-$trigger-$(echo \"$app\" | tr -d ' ' | sed 's/[^a-zA-Z0-9]//g')/track\"\n    #click it\n    #NOTE: any future changes to the user agent should only APPEND\n    curl -s -X 'GET' \"$shlinklink\" -H 'accept: image/gif' -A \"Pi-Apps Raspberry Pi app store; $model; $SOC_ID; $machine_id; $serial_number; ${os_name^}; $arch\" >/dev/null\n  fi\n  } &\n}\n\nusercount() { #Return number of users for specified app. $1 is app name. If empty, all are shown.\n  #If clicklist file missing or over a day old, download it.\n  if [ ! -f \"${DIRECTORY}/data/clicklist\" ] || [ ! -z \"$(find \"${DIRECTORY}/data/clicklist\" -mtime +1 -print)\" ]; then\n    wget 'https://raw.githubusercontent.com/Botspot/pi-apps-analytics/main/clicklist' -qO \"${DIRECTORY}/data/clicklist\" >/dev/null || return 1\n  fi\n  clicklist=\"$(cat \"${DIRECTORY}/data/clicklist\")\"\n  \n  [ -z \"$clicklist\" ] && error \"usercount(): clicklist empty. Likely no internet connection\"\n  \n  if [ -z \"$1\" ];then\n    echo \"$clicklist\"\n  else\n    # $1 is app\n    echo \"$clicklist\" | grep \"[0-9] $1\"'$' | awk '{print $1}' | head -n1\n  fi\n  \n}\n\nscript_name() { #returns name of install script(s) for the $1 app. outputs: '', 'install-32', 'install-64', 'install', 'install-32 install-64'\n  [ -z \"$1\" ] && error 'script_name(): requires an argument'\n  \n  #ensure $1 is valid app name\n  [ ! -d \"${DIRECTORY}/apps/$1\" ] && error \"script_name: '$1' is an invalid app name.\\n${DIRECTORY}/apps/$1 does not exist.\"\n  \n  if [ -f \"${DIRECTORY}/apps/$1/install-32\" ] && [ ! -f \"${DIRECTORY}/apps/$1/install-64\" ];then\n    echo 'install-32'\n  elif [ -f \"${DIRECTORY}/apps/$1/install-64\" ] && [ ! -f \"${DIRECTORY}/apps/$1/install-32\" ];then\n    echo 'install-64'\n  elif [ -f \"${DIRECTORY}/apps/$1/install-64\" ] && [ -f \"${DIRECTORY}/apps/$1/install-32\" ];then\n    echo 'install-32 install-64'\n  elif [ -f \"${DIRECTORY}/apps/$1/install\" ];then\n    echo 'install'\n  else\n    true\n    #error \"No install script found for the $app app! Please report this to Botspot.\"\n  fi\n  \n}\n\nscript_name_cpu() { #get script name to run based on detected CPU arch\n  [ -z \"$1\" ] && error 'script_name_cpu(): requires an argument.'\n  \n  #ensure $1 is valid app name\n  if ! list_apps all | grep -q \"$1\" ;then\n    error \"script_name_cpu: '$1' is an invalid app name.\"\n  fi\n  \n  if [ -f \"${DIRECTORY}/apps/$1/install-32\" ] && [ $arch == 32 ];then\n    echo 'install-32'\n  elif [ -f \"${DIRECTORY}/apps/$1/install-64\" ] && [ $arch == 64 ];then\n    echo 'install-64'\n  elif [ -f \"${DIRECTORY}/apps/$1/install\" ];then\n    echo 'install'\n  elif [ -f \"${DIRECTORY}/apps/$1/packages\" ];then\n    echo 'packages'\n  else\n    true #app not compatible with current arch\n  fi\n}\n\napp_status() { #Gets the $1 app's current status. installed, uninstalled, corrupted, disabled\n  \n  [ -z \"$1\" ] && error 'app_status(): requires an argument.'\n  #don't check if app exists, it may be a new app in an update\n  \n  if [ -f \"${DIRECTORY}/data/status/${1}\" ];then\n    cat \"${DIRECTORY}/data/status/${1}\"\n  else\n    echo 'uninstalled' #if app status file doesn't exist, assume uninstalled\n  fi\n}\n\napp_type() { #there are 'standard' apps, and there are 'package' apps - an alias to install an apt package from the existing repositories.\n  #$1 is input app-name\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"app_type(): no app specified!\"\n  \n  if [ -f \"${DIRECTORY}/apps/${app}/packages\" ];then\n    echo package\n  elif [ -f \"${DIRECTORY}/apps/${app}/uninstall\" ] || [ -f \"${DIRECTORY}/apps/${app}/install\" ] || [ -f \"${DIRECTORY}/apps/${app}/install-32\" ] || [ -f \"${DIRECTORY}/apps/${app}/install-64\" ];then\n    echo standard\n  else\n    return 1\n  fi\n  #if neither conditional above evaluated to true, no output will be returned and the function exits with code 1\n}\n\npkgapp_packages_required() { #Returns which packages are required during installation of a package-app - handle the '|' separater\n  #returns no output if not all required packages are available\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"pkgapp_packages_required(): no app specified!\"\n  \n  if [ ! -f \"${DIRECTORY}/apps/$app/packages\" ];then\n    error \"pkgapp_packages_required(): This app '$app' does not have a packages file!\"\n  fi\n  \n  local IFS=' '\n  local word=''\n  local packages=''\n  #read each word - packages separated by '|' are 1 word\n  for word in $(cat \"${DIRECTORY}/apps/$app/packages\" | sed 's/ | /|/g') ;do\n    \n    if [[ \"$word\" == *'|'* ]];then\n      IFS='|'\n      local package\n      local found=\"no\"\n      #first check for any already installed packages\n      #if a package is already installed, it should be used even if it is not the first option in the OR\n      for package in $word ;do\n        if package_installed \"$package\" ;then\n          packages+=\"$package \"\n          found=\"yes\"\n          break\n        fi\n      done\n      if [ \"$found\" == \"yes\" ]; then\n        #a package in the OR is already installed\n        continue\n      fi\n      #then check for available packages\n      for package in $word ;do\n        if package_available \"$package\" ;then\n          packages+=\"$package \"\n          found=\"yes\"\n          break\n        fi\n      done\n      if [ \"$found\" == \"no\" ]; then\n        #no package in the OR is available so set the output as empty\n        packages=''\n        break\n      fi\n    else #non-OR package - no parsing '|' separators\n      if package_available \"$word\" ;then\n        #no separator, so return it without change\n        packages+=\"$word \"\n      else\n        #one package in the AND is not available so set the output as empty\n        packages=''\n        break\n      fi\n    fi\n  done\n  [ ! -z \"$packages\" ] && echo \"${packages::-1}\" #remove final space character\n}\n\nwill_reinstall() { #return 0 if $1 app will be reinstalled during an update, otherwise return 1.\n  local app=\"$1\"\n  [ -z \"$app\" ] && error 'will_reinstall(): requires an argument'\n  \n  #exit immediately if app is not installed.\n  if [ \"$(app_status \"$app\")\" != 'installed' ];then\n    return 1\n  fi\n  \n  #detect which installation script exists - both for local install and for update directory\n  local local_scriptname=\"$(script_name_cpu \"$app\")\"\n  \n  local new_scriptname=\"$(DIRECTORY=\"${DIRECTORY}/update/pi-apps\" script_name_cpu \"$app\")\"\n  \n  if [ ! -z \"$new_scriptname\" ] && [ \"$local_scriptname\" == packages ] && [ \"$new_scriptname\" != packages ];then\n    #migration from package-app to script-app. Reinstall.\n    return 0\n  elif [ \"$local_scriptname\" != packages ] && [ \"$new_scriptname\" == packages ];then\n    #migration from script-app to package-app. Reinstall.\n    return 0\n  elif [ \"$new_scriptname\" == packages ];then\n    #update to package-app: rather than check for file change, check if the installed package(s) would be different (avoid reinstall when adding an alternative package name with '|')\n    if [ \"$(pkgapp_packages_required \"$app\")\" != \"$(DIRECTORY=\"${DIRECTORY}/update/pi-apps\" pkgapp_packages_required \"$app\")\" ];then\n      return 0\n    else\n      return 1\n    fi\n  elif [ ! -z \"$new_scriptname\" ] && ! files_match \"${DIRECTORY}/update/pi-apps/apps/${app}/${new_scriptname}\" \"${DIRECTORY}/apps/${app}/${local_scriptname}\" ;then\n    #if install script exists in update folder, and if install script was changed, and if installed already\n    return 0\n  else\n    return 1\n  fi\n}\n\napp_search() { #search all apps for $1, with filenames in $2 (space-separated and optional)\n  local query=\"$1\"\n  [ -z \"$query\" ] && error \"app_search(): requires a search query.\"\n  \n  #you can change which app-files are searched. Default: description, website, credits\n  if [ ! -z \"${2+x}\" ];then\n    #second argument can be set, but left blank\n    local search_files=\"$(echo \"$2\" | sed 's/^ //g' | sed 's/ $//g' | sed 's/  / /g')\"\n  else\n    #if no second argument provided\n    local search_files=\"description website credits\"\n  fi\n  \n  #generate syntax for the find command. Example output: \"-name description -o -name website -o -name credits\"\n  local find_syntax=\"$(echo \"$search_files\" | sed 's/ / -o -name /g')\"\n  echo \"search pattern: $find_syntax\" 1>&2\n  \n  #search app files\n  if [ -z \"$search_files\" ];then\n    local results=\"\"\n  else\n    local results=\"$(find \"${DIRECTORY}/apps\" \\( -name $find_syntax \\) -exec grep -m1 -Fi \"$query\" {} + | awk -F: '{print $1}' | sed \"s+${DIRECTORY}/apps/++g\" | sed 's+/.*++g' | sort | uniq)\"\n  fi\n  #hide incompatible and hidden/disabled apps\n  results=\"$(echo \"$results\" | list_subtract \"$(list_apps hidden)\" | list_intersect \"$(list_apps cpu_installable)\")\"\n  \n  if [ -z \"$app_list\" ];then\n    local app_list=\"$(list_apps cpu_installable | list_subtract \"$(list_apps hidden)\")\"\n  fi\n  \n  #search app names - first prioritize results starting with query, then show results containing query, then show other pre-existing results.\n  results=\"$(grep -i \"^$query\" <<<\"$app_list\" | sort)\n$(grep -i \"$query\" <<<\"$app_list\" | sort)\n$results\"\n  \n  #remove duplicate entries\n  echo \"$results\" | awk '!seen[$0]++'\n  \n}\n\napp_search_gui() { #graphical interface to search for apps\n  \n  #pre-populate search field with last search, if available\n  if [ -f \"${DIRECTORY}/data/last-search\" ];then\n    local last_search=\"$(cat \"${DIRECTORY}/data/last-search\")\"\n  else\n    local last_search=''\n  fi\n  \n  local output=''\n  output=\"$(yad \"${yadflags[@]}\" --title=Search --width=310 \\\n    --text=\"Search for apps.\"$'\\n'\"Not case-sensitive.\" \\\n    --form --field='' \"$last_search\" \\\n    --field='Search description':CHK 'TRUE' \\\n    --field='Search website':CHK 'TRUE' \\\n    --field='Search credits':CHK 'FALSE' \\\n    --field='Search scripts':CHK 'FALSE')\" || return 0\n  local query=\"$(echo \"$output\" | sed -n 1p)\"\n  \n  #exit now if search query is empty\n  if [ -z \"$query\" ];then\n    return 0\n  fi\n  #save query for next time in last-search data file\n  echo \"$query\" > \"${DIRECTORY}/data/last-search\"\n  \n  #skip file-based search if user searched for exact app name\n  local app_list=\"$(list_apps cpu_installable | list_subtract \"$(list_apps hidden)\")\"\n  local results=\"$(grep -xFi \"$query\" <<<\"$app_list\")\"\n  if [ ! -z \"$results\" ];then\n    echo \"$results\"\n    return 0\n  fi\n  \n  local search_files='description website credits scripts'\n  search_files=''\n  echo \"$output\" | sed -n 2p | grep -q 'TRUE' && search_files+='description '\n  echo \"$output\" | sed -n 3p | grep -q 'TRUE' && search_files+='website '\n  echo \"$output\" | sed -n 4p | grep -q 'TRUE' && search_files+='credits '\n  echo \"$output\" | sed -n 5p | grep -q 'TRUE' && search_files+='install install-32 install-64 uninstall '\n  \n  #echo -e \"query: $query\\nsearch_files: $search_files\"\n  \n  results=\"$(app_search \"$query\" \"$search_files\")\"\n  \n  if [ ! -z \"$results\" ] && [ \"$(echo \"$results\" | wc -l)\" == 1 ];then\n    #if only one result, don't ask user to select it\n    echo \"$results\" #return result to outside world\n    \n  elif [ ! -z \"$results\" ];then #display apps and their categories in a list for user to select\n    \n    local app=\"$(show_app() {\n      echo \"$2\"\n    }\n    export -f show_app\n    \n    categories=\"$(read_category_files)\"\n    \n    IFS=$'\\n'\n    for app in $results ;do\n      local category=\"$(grep '^'\"$app\"'|' <<<\"$categories\" | awk -F'|' '{print $2}')\"\n      \n      echo \"${DIRECTORY}/apps/${app}/icon-24.png\n$app\n$( (cat \"${DIRECTORY}/apps/${app}/description\" || echo \"Description unavailable\") | head -n1)\n<small>in</small>\n${DIRECTORY}/icons/categories/${category##*/}.png\n${category}\"\n    done | \\\n    yad \"${yadflags[@]}\" --title=\"Results for \"\\\"\"$query\"\\\"\"\" --width=310 --height=250 \\\n      --list --no-headers  --column=app:IMG --column=appname --column=tooltip:HD --column=in --column=category:IMG --column=categoryname \\\n      --tooltip-column=3 --no-buttons \\\n      --select-action=\"bash -c \"\\\"\"show_app %s; kill \"\\$\"YAD_PID\"\\\"\"\")\"\n    \n    echo \"$app\" #return result to outside world\n    \n  elif list_apps | grep -qi \"^$query\" ;then\n    #no compatible apps found, but an incompatible app was found that matches the name\n    yad \"${yadflags[@]}\" --title=Results --width=310 \\\n      --text=\"\"\\\"\"<b>$(list_apps | grep -i -m1 \"^$query\")</b>\"\\\"\" is not compatible with your ${__os_desc} ${arch}-bit OS.\" \\\n      --button=OK:0\n    return 0\n    \n  else #no results found\n    yad \"${yadflags[@]}\" --title=Results --width=310 \\\n      --text=\"No results found for \"\\\"\"<b>$query</b>\"\\\"\".\" \\\n      --button=OK:0\n    return 0\n  fi\n}\n\nuserinput_func() { # userinput function to display yad/cli prompts to the user\n  [ -z \"$1\" ] && error \"userinput_func(): requires a description\"\n  [ -z \"$2\" ] && error \"userinput_func(): requires at least one output selection option\"\n  local text_lines=$(echo -e \"$1\" | wc -l)\n  # there is no good universal way to calculate the required height of the window\n  # the users theme, default text size, and window scaling all affect it\n  # the idea is the height should be a function of the number of lines of input text and the number of list options\n  local height_list=$(echo $(( text_lines * 17 + $(( ${#@} - 1 )) * 29 + 65 )))\n  if [ ! -z \"$screen_height\" ] && (( $height_list > \"$screen_height\" )); then\n    height_list=\"$screen_height\"\n  elif [ -z \"$screen_height\" ] && (( $height_list > \"720\" )); then\n    height_list=\"720\"\n  fi\n  local commonflags=(--fixed --no-escape --undecorated --center --borders=20)\n  if [ \"${#@}\" == \"2\" ];then\n    yad \"${yadflags[@]}\" \"${commonflags[@]}\" \\\n      --image \"dialog-information\" \\\n      --text=\"$1\" \\\n      --button=\"$2\":0\n    output=\"$2\"\n  elif [ \"${#@}\" == \"3\" ];then\n    yad \"${yadflags[@]}\" \"${commonflags[@]}\" \\\n      --image \"dialog-question\" \\\n      --text=\"$1\" \\\n      --button=\"$2\":0 \\\n      --button=\"$3\":1\n    if [ $? -ne 0 ]; then\n      output=\"$3\"\n    else\n      output=\"$2\"\n    fi\n  else\n    unset uniq_selection\n    for string in \"${@:2}\"; do\n      local uniq_selection+=(FALSE \"$string\")\n    done\n    local uniq_selection[0]=TRUE\n    output=$(yad \"${yadflags[@]}\" \"${commonflags[@]}\" \\\n      --height=$height_list\\\n      --text \"$1\" \\\n      --list \\\n      --no-headers \\\n      --radiolist \\\n      --center \\\n      --column \"\" \\\n      --column \"Selection\" \\\n      --print-column=2 \\\n      --separator='' \\\n      --button=\"OK\":0 \\\n      \"${uniq_selection[@]}\")\n  fi\n}\n\ngenerate_app_icons() { #This converts the given $1 image into icon-24.png and icon-64.png files for the $2 app\n  icon=\"$1\"\n  app=\"$2\"\n  \n  [ -z \"$icon\" ] && error \"create_app_icons(): icon field empty!\"\n  [ -z \"$app\" ] && error \"create_app_icons(): app field empty!\"\n  \n  #ensure imagemagick is installed\n  if ! command -v convert >/dev/null ;then\n    yad \"${yadflags[@]}\" --text=\"To resize the images, imagemagick must be installed.\"$'\\n'\"Install now?\" \\\n    --text-align=center --title='Quick question' \\\n    --button=No!\"${DIRECTORY}/icons/exit.png\":1 --button=Yes!\"${DIRECTORY}/icons/check.png\":0\n    button=$?\n    if [ $button == 0 ];then\n      sudo apt-get install -y --no-install-recommends imagemagick || icon=''\n    else\n      exit 0\n    fi\n  fi\n  \n  #scale it to 24x24\n  convert \"$icon\" -resize 24x24 \"${DIRECTORY}/apps/${app}/icon-24.png\"\n  \n  #scale it to 64x64\n  convert \"$icon\" -resize 64x64 \"${DIRECTORY}/apps/${app}/icon-64.png\"\n\n}\n\nrefresh_pkgapp_status() { #for the specified package-app, if dpkg thinks it's installed, then mark it as installed.\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"refresh_pkgapp_status(): no app specified!\"\n\n  # optional: directly pass package as second input argument (can be null for when you want to mark an app as hidden)\n  if [ -z ${2+x} ]; then\n    #From the list of necessary packages for the $app app, get the first one that is available in the repos\n    local package=\"$(pkgapp_packages_required \"$app\" | awk '{print $1}')\"\n  else\n    local package=\"$(echo \"$2\" | awk '{print $1}')\"\n  fi\n\n  if [ -z \"$package\" ]; then\n    #this app is trying to install a package that's not on the repository. Hide the app.\n    echo \"Marking $app as hidden\"\n    \"${DIRECTORY}/etc/categoryedit\" \"$app\" 'hidden' >/dev/null\n    return\n  #if that package is installed\n  elif package_installed \"$package\" ;then\n    #mark this app as installed\n    if [ \"$(app_status \"$app\")\" != 'installed' ];then\n      echo \"Marking $app as installed\"\n      echo 'installed' > \"${DIRECTORY}/data/status/${app}\"\n      shlink_link \"$app\" install &\n    fi\n  #if that package is not installed, then it only exists on the repositories, the pkgapp_packages_required function output guarantees it\n  else\n    #the package for the $app app is not installed but it is available, so mark this app as uninstalled\n    if [ \"$(app_status \"$app\")\" != 'uninstalled' ];then\n      echo \"Marking $app as uninstalled\"\n      rm -f \"${DIRECTORY}/data/status/${app}\"\n      shlink_link \"$app\" uninstall &\n    fi\n  fi\n\n  #package is hidden but available. Show it.\n  if grep -qxF \"${app}|hidden\" \"${DIRECTORY}/data/category-overrides\" ;then\n    #move app to original category\n    #this should not cause a tug-of-war if a package-app is ever hidden with one of the OS-specific overrides files, because category detection is constrained to the category-overrides file.\n    echo \"Unhiding $app as its packages are now available\"\n    \"${DIRECTORY}/etc/categoryedit\" \"$app\" \"$(grep \"^${app}|\" \"${DIRECTORY}/etc/categories\" | awk -F'|' '{print $2}')\" >/dev/null\n  fi\n}\n\nrefresh_all_pkgapp_status() { #for every package-app, if dpkg thinks it's installed, then mark it as installed.\n  #repeat for every package-type app\n  local IFS=$'\\n'\n  local dpkg_arch=\"$(dpkg --print-architecture)\"\n  # get list of all packages needed by package apps\n  # this variable needs to be global to be accessible from the subshells\n  local packages=\"$(sed '' -- \"${DIRECTORY}\"/apps/*/packages | sed 's/ | /\\n/g' | sed 's/ /\\n/g' | awk NF | sed 's/$/:'\"$dpkg_arch\"'/' | tr '\\n' ' ')\"\n  packages=\"${packages::-1}\" #remove final space character\n\n  # get policy info for all packages needed by package apps\n  # this variable needs to be global to be accessible from the subshells\n  local apt_cache_output=\"$(echo \"$packages\" | xargs -r apt-cache policy)\"\n\n  #redefine package_installed to only read /var/lib/dpkg/status once\n  local dpkg_status=\"$(grep -x \"Package: \\($(echo \"$packages\" | sed 's/:'\"$dpkg_arch\"'//g ; s/ /\\\\|/g')\\)\" -A 2 /var/lib/dpkg/status)\"\n\n  #redefine package_available() to use apt_cache_output and avoid running apt-cache multiple times\n  (package_available() { #this will only be used in this function's subprocesses.\n    echo \"$apt_cache_output\" | grep -x \"${1}:\" -A2 | grep -vxF \"  Candidate: (none)\" | grep -q \"^  Candidate:\"\n  }\n  \n  #this one only takes off 0.1s on my pi5, so if it causes issues it could be removed\n  package_installed() { #exit 0 if $1 package is installed, otherwise exit 1\n    local package=\"$1\"\n    [ -z \"$package\" ] && error \"package_installed(): no package specified!\"\n    #find the package listed in /var/lib/dpkg/status\n    #package_info \"$package\"\n\n    #directly search /var/lib/dpkg/status\n    echo \"$dpkg_status\" | grep -x \"Package: $package\" -A 2 -m1 | grep -qxF 'Status: install ok installed'\n  }\n\n  # parse apt_cache_output for each package app\n  # generate list of all packages needed by package apps\n  for app in $(list_apps package) ;do\n    refresh_pkgapp_status \"$app\" #with redefined package_available and package_installed this is fast\n  done)\n}\n\nrefresh_app_list() { #Force-regenerate the app list\n  local guimode=\"$(cat \"${DIRECTORY}/data/settings/App List Style\")\"\n  \n  #delete preload directory, then re-generate it\n  rm -rf \"${DIRECTORY}/data/preload\"\n  \"${DIRECTORY}/etc/preload-daemon\" \"$guimode\" once &>/dev/null\n}\n\nlist_apps_missing_dummy_debs() { #List any installed apps that have had their dummy deb uninstalled more recently than the app was installed\n  local IFS=$'\\n'\n  local app\n  local dummy_deb_status=\"$(grep ' installed pi-apps-\\| not-installed pi-apps-' /var/log/dpkg.log | tac | awk -F' ' '!seen[$5]++' | sed 's/:all$//g')\"\n  #example line value: 2023-03-20 13:13:54 status installed pi-apps-6f59c0e1:all 1.0\n  \n  for app in $(list_apps installed | list_intersect \"$(list_apps standard)\") ;do\n    #For every installed app, make sure the dummy deb, if it has ever been installed, is installed\n    local pkgname=\"$(app_to_pkgname \"$app\")\"\n    local match=\"$(grep -m1 \"$pkgname\" <<<\"$dummy_deb_status\")\"\n    \n    if [ -z \"$match\" ];then\n      #echo \"no dummy deb information associated with $app\"\n      true\n    elif [ \"$(echo \"$match\" | awk '{print $4}')\" == not-installed ];then\n      #echo \"$app has its $pkgname package uninstalled!\"\n      \n      #if the dummy deb was removed after app was installed, then there is a problem\n      if [ \"$(date -d '2023-03-27 22:23:58' +'%s')\" -gt \"$(date -r \"${DIRECTORY}/data/status/${app}\" +'%s')\" ];then\n        #echo \"the dummy deb for $app was removed after $app was installed!\"\n        echo \"$app\"\n      fi\n    fi\n  done\n}\n#end of app functions\n\n#logfile functions below\nget_logfile() { #find the most recent logfile for the $1 app\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"get_logfile(): no app specified!\"\n  ls -dt \"${DIRECTORY}/logs\"/* | grep -v 'success' | grep '\\-'\"${app}\"'\\.log' -m 1\n}\n\nlog_diagnose() { #Given a logfile, explain errors to user, suggest fixes, and categorize issue with error_type variable\n  #errors=\"$(cat /dev/stdin)\"\n  local errors=\"$(cat \"$1\")\"\n  # any attempt to write to the logfile will instead write to /dev/null if allowwrite argument is not passed\n  if [ \"$2\" == \"allowwrite\" ]; then\n    local logfile=\"$1\"\n  else\n    local logfile=\"/dev/null\"\n  fi\n  \n  #store the user-friendly explanations for each type of error\n  local error_caption=()\n  #store the general type of error\n  local error_type=''\n  \n#------------------------------------------\n#repo issues below\n#------------------------------------------\n  #check for 'E: The repository'\n  if grep -qF 'E: The repository' <(echo \"$errors\") || grep -qF 'sources.list entry misspelt' <(echo \"$errors\") || grep -qF 'component misspelt in' <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported a faulty repository, and you must fix it before Pi-Apps will work.\n\nTo delete the repository:\nRemove the relevant line from /etc/apt/sources.list file or delete one file in\nthe /etc/apt/sources.list.d folder.\n\nsources.list requires root permissions to edit: sudo mousepad /path/to/file\")\n    error_type=\"system\"\n  fi\n  \n  #check for 'NO_PUBKEY' or ' is no longer signed.'\n  if grep -qF 'NO_PUBKEY' <(echo \"$errors\") || grep -qF ' is no longer signed.' <(echo \"$errors\") ;then\n    error_caption+=('APT reported an unsigned repository. This has to be solved before APT or Pi-Apps, will work.\n\nIf you'\\''re not sure what to do, you can try to fix the problem by running this command in a terminal:\nsudo apt update 2>&1 | sed -ne '\\''s/.*NO_PUBKEY //p'\\'' | while read key; do if ! [[ ${keys[*]} =~ \"$key\" ]]; then sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys \"$key\"; keys+=(\"$key\"); fi; done')\n    error_type=\"system\"\n  fi\n  \n  # check for 'Could not resolve' or 'Failed to fetch'\n  if grep -q 'Could not resolve\\|Failed to fetch\\|Temporary failure resolving\\|Internal Server Error\\|404 .*Not Found' <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported an unresolvable repository.\n\nCheck your Internet connection and try again.\")\n    error_type=\"internet\"\n  fi\n  \n  #check for 'is configured multiple times in'\n  if grep -qF 'is configured multiple times in' <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported a double-configured repository, and you must fix it to fix Pi-Apps.\n\nTo delete the repository:\nRemove the relevant line from /etc/apt/sources.list file or delete the file in\nthe /etc/apt/sources.list.d folder.\n\nsources.list requires root permissions to edit: sudo mousepad /path/to/file\")\n    error_type=\"system\"\n  fi\n  \n  #check for \"W: Conflicting distribution: \"\n  if grep -qF \"W: Conflicting distribution: \" <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported a conflicting repository.\n\nRead the installation errors, then look through /etc/apt/sources.list and /etc/apt/sources.list.d, making changes as necessary.\n\nPerhaps doing a Google search for the exact error you received would help.\")\n    error_type=\"system\"\n  fi\n  \n  #check for \"Release file for <repo-url> is not valid yet\"\n  if grep -q \"Release file for .* is not valid yet\" <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported a repository whose release file becomes valid in the future.\n\nThis is probably because your system time is set incorrectly.\")\n    error_type=\"system\"\n  fi\n  \n  #check for \"Release file for <repo-url> is expired\"\n  if grep -q \"Release file for .* is expired\" <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported a repository whose release file was invalidated in the past.\nPlease check that your system clock is set correctly, and if it is, check if the repository is kept updated or if its developers abandoned it.\n\nIf you think think you shouldn't see this error, you can try refreshing APT with these commands:\nsudo rm -rf /var/lib/apt\nsudo apt update\")\n    error_type=\"system\"\n  fi\n  \n  #check for typo in sources.list and list.d\n  if grep -q \"The list of sources could not be read\\.\\|Did not understand pin type\\|E: Malformed entry .* in list file\" <(echo \"$errors\");then\n    error_caption+=(\"APT reported a typo in the sources.list file.\n\nYou must look around in /etc/apt/sources.list and /etc/apt/sources.list.d and fix the typo.\")\n    error_type=\"system\"\n  fi\n  \n  #check for \"E: The package cache file is corrupted\"\n  if grep -q \"E: The package cache file is corrupted\\|The package lists or status file could not be parsed or opened.\"  <(echo \"$errors\") ;then\n    error_caption+=(\"APT found something wrong with a package list file.\n\nPerhaps this link would help: https://askubuntu.com/questions/939345/the-package-cache-file-is-corrupted-error\")\n    error_type=\"system\"\n  fi\n  \n  #check for broken pi-apps-local-packages symlink\n  if grep -q \"E: Could not open file /var/lib/apt/lists/_tmp_pi-apps-local-packages_._Packages\" <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported the pi-apps-local-packages list as missing.\n\nThe Pi-Apps developers have been receiving a few of these errors recently, but we can't figure out what the problem is without your help. Could you please reach out so we can solve this?\")\n    # no error_type since we want the user to be able to upload logs for this issue while still showing the custom caption\n  fi\n  \n#------------------------------------------\n#repo issues above, apt/dpkg issues below\n#------------------------------------------\n  \n  #check for \"--fix-broken\"\n  if grep -qF \"\\-\\-fix\\-broken\" <(echo \"$errors\") || grep -qF \"needs to be reinstalled\" <(echo \"$errors\") ;then\n    error_caption+=(\"APT reported a broken package.\n\nPlease run this command: sudo apt --fix-broken install\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"dpkg --configure -a\" <(echo \"$errors\") ;then\n    error_caption+=(\"Before dpkg, apt, or Pi-Apps will work, dpkg needs to repair your system.\n\nPlease run this command: sudo dpkg --configure -a\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"package is in a very bad inconsistent state;\" <(echo \"$errors\") ;then\n    error_caption+=(\"Something is wrong with another package on your system.\n\nRefer to this information while troubleshooting: https://askubuntu.com/questions/148715\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"dpkg: error: fgets gave an empty string from\" <(echo \"$errors\") ;then\n    error_caption+=(\"Something strange is going on with your system and dpkg won't work.\n\nPerhaps this link will help: https://askubuntu.com/questions/1293709/weird-error-when-trying-to-install-packages-with-apt\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"Command line option --allow-releaseinfo-change is not understood\" <(echo \"$errors\") ;then\n    error_caption+=(\"The Debian Project recently upgraded from Buster to version Bullseye. As a result, all Raspberry Pi OS Buster users will receive APT errors saying the repositories changed from 'stable' to 'oldstable'.\n\nThis error broke pi-apps. To fix it, the Pi-Apps developers added something to the 'sudo apt update' command: --allow-releaseinfo-change.\nThis flag allows the repository migration to succeed, thereby allowing Pi-Apps to work again.\n\nUnfortunately for you, your operating system is too old for apt to understand this flag we added. Please upgrade your operating system for a better experience. Raspbian Stretch is unsupported and many apps will not install.\n\nPlease flash your SD card with the latest release of Raspberry Pi OS: https://www.raspberrypi.org/software\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"lzma error: compressed data is corrupt\" <(echo \"$errors\") ;then\n    error_caption+=(\"A package failed to install because it appears corrupted. (buggy download?)\n\nTry installing the same app again and if the problem persists please reach out to the Pi-Apps developers.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -qF \"E: Could not get lock\" <(echo \"$errors\") ;then\n    error_caption+=(\"Some other apt-get/dpkg process is running. Wait for that one to finish, then try again.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"dpkg: error: cannot scan updates directory '/var/lib/dpkg/updates/': No such file or directory\" <(echo \"$errors\") ;then\n    error_caption+=(\"What did you do to your system? The \"\\\"\"/var/lib/dpkg/updates\"\\\"\" folder is missing.\n\nYou can try creating the folder with this command:\nsudo mkdir -p /var/lib/dpkg/updates\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"E: Repository .* changed its 'Suite' value\" <(echo \"$errors\") ;then\n    error_caption+=(\"One or more APT repositories on your system have changed Suite values. Usually this occurs when a new version of Debian is released every two years.\n\nPi-Apps should work around this error, but somehow it did not.\nPlease run this command in a terminal: sudo apt update --allow-releaseinfo-change\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"E: Failed to fetch .* File has unexpected size .* Mirror sync in progress\\?\" <(echo \"$errors\") ;then\n    error_caption+=(\"APT encountered a repository with a file that is of incorrect size. This can be caused by a periodic mirror sync, or maybe the repository is faulty.\n\nIn any case, Pi-Apps cannot work until you solve this issue. Try disabling any 3rd-party APT repos first, and if that doesn't work then ask for help.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"E: The value 'stable' is invalid for APT::Default-Release as such a release is not available in the sources\" <(echo \"$errors\") ;then\n    error_caption+=(\"APT encountered an issue reading a source file for a repository. Most likely, you were trying to change your sources and did not format the file correctly.\n\nIn any case, Pi-Apps cannot work until you solve this issue. Check around in the /etc/apt/sources.list file and the /etc/apt/sources.list.d folder for duplicate mentions of the word 'stable'.\")\n    error_type=\"system\"\n  fi\n\n  if grep -q \"dpkg: error processing package .*-dkms\" <(echo \"$errors\") ;then\n    error_caption+=(\"A DKMS (Dynamic Kernel Module Support) package failed to install and has prevented apt from working correctly. This is likely an issue with your distribution and you should report it wherever applicable.\n\nPi-Apps cannot work until you solve this issue. If you do not need the problematic package, you can remove it with apt to solve the issue.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"The following packages have unmet dependencies:\" <(echo \"$errors\") ;then\n    # we want these errors to come to pi-apps logs if the user sends them, so don't add an error type\n    # add additional output for the packages that have unmet dependencies\n\n    echo -e \"Additional log diagnosis for developers below:\\n\" >> \"$logfile\"\n    grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache show >> \"$logfile\"\n    grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache policy >> \"$logfile\"\n    local packages_case1=\"$(grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sed 's/:armhf\\|:arm64\\|:all//g' | sort -u)\"\n    echo \"$packages_case1\" | xargs -r apt list -a >> \"$logfile\"\n    local dry_run_case1=\"$(grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $4}' | tr \" \" \"\\n\" | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-get install -fy --no-install-recommends --allow-downgrades --dry-run 2>&1)\"\n    echo \"$dry_run_case1\" >> \"$logfile\"\n    grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache show >> \"$logfile\"\n    grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache policy >> \"$logfile\"\n    local packages_case2=\"$(grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sed 's/:armhf\\|:arm64\\|:all//g' | sort -u)\"\n    echo \"$packages_case2\" | xargs -r apt list -a >> \"$logfile\"\n    local dry_run_case2=\"$(grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-get install -fy --no-install-recommends --allow-downgrades --dry-run 2>&1)\"\n    echo \"$dry_run_case2\" >> \"$logfile\"\n    grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/| /\\n/g\" | sed \"s/:any//g\" | sed 's/([^)]*)//g;s/  / /g' | xargs -r apt-cache show >> \"$logfile\"\n    grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/| /\\n/g\" | sed \"s/:any//g\" | sed 's/([^)]*)//g;s/  / /g' | xargs -r apt-cache policy >> \"$logfile\"\n    local packages_case3=\"$(grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/| /\\n/g\" | sed 's/:armhf\\|:arm64\\|:all//g' | sed 's/([^)]*)//g;s/  / /g' | sort -u)\"\n    echo \"$packages_case3\" | xargs -r apt list -a >> \"$logfile\"\n    local dry_run_case3=\"$(grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/| /\\n/g\" | sed \"s/:any//g\" | sed 's/([^)]*)//g;s/  / /g' | xargs -r apt-get install -fy --no-install-recommends --allow-downgrades --dry-run 2>&1)\"\n    echo \"$dry_run_case3\" >> \"$logfile\"\n\n    # we also want to see the users apt sources (.list and .sources)\n    apt-get indextargets --no-release-info --format '$(SITE) $(RELEASE) $(COMPONENT) $(TARGET_OF) $(ARCHITECTURE)' | sort -u >> \"$logfile\"\n\n    # we also want to know what architectures the user has enabled on their system globally\n    echo \"foreign architectures: $(dpkg --print-foreign-architectures)\" >> \"$logfile\"\n  fi\n\n  # from above developer output, the following system error cases have been developed\n  if grep -q \"The following packages have unmet dependencies:\" <(echo \"$errors\") ;then\n    # manually held packages preventing installation\n    if grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache show | grep -q \"Status: hold ok installed\" ; then\n      error_caption+=(\"Packages failed to install because you manually marked at least one of the following packages as held:\n\n$(grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sort -u)\n\nYou will need to unmark the packages with the following command before installation can proceed:\nsudo apt-mark unhold $(grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\")\n      error_type=\"system\"\n    elif grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache show | grep -q \"Status: hold ok installed\" ; then\n      error_caption+=(\"Packages failed to install because you manually marked at least one of the following packages as held:\n\n$(grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sort -u)\n\nYou will need to unmark the packages with the following command before installation can proceed:\nsudo apt-mark unhold $(grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sort -u)\")\n      error_type=\"system\"\n    elif grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/:any//g\" | sed 's/([^)]*)//g;s/  / /g' | xargs -r apt-cache show | grep -q \"Status: hold ok installed\" ; then\n      error_caption+=(\"Packages failed to install because you manually marked at least one of the following packages as held:\n\n$(grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/:any//g\" | sed 's/([^)]*)//g;s/  / /g')\n\nYou will need to unmark the packages with the following command before installation can proceed:\nsudo apt-mark unhold $(grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed \"s/:any//g\" | sed 's/([^)]*)//g;s/  / /g')\")\n      error_type=\"system\"\n    fi\n    # missing multiarch (armhf) compatible package for installed (or to be installed) arm64 package\n    # this does not occur on Debian/Ubuntu but can occur on BAD distros (or PPAs and other 3rd party repos) that do not provide both armhf and arm64 packages for any custom packages of higher priority than the upstream distro packages\n    for test_package in $packages_case1 ; do\n      if echo \"$dry_run_case1\" | grep -q \"$test_package : Breaks: $test_package:armhf\" ; then\n        error_caption+=(\"Packages failed to install because $test_package does not have a multiarch (armhf) compatible version.\nThis issue does not occur on Ubuntu/Debian (where every package is multiarch compatible). Contact your distro maintainer or the packager of $test_package to have this issue resolved.\")\n        error_type=\"system\"\n      fi\n    done\n    for test_package in $packages_case2 ; do\n      if echo \"$dry_run_case2\" | grep -q \"$test_package : Breaks: $test_package:armhf\" ; then\n        error_caption+=(\"Packages failed to install because $test_package does not have a multiarch (armhf) compatible version.\nThis issue does not occur on Ubuntu/Debian (where every package is multiarch compatible). Contact your distro maintainer or the packager of $test_package to have this issue resolved.\")\n        error_type=\"system\"\n      fi\n    done\n    for test_package in $packages_case3 ; do\n      if echo \"$dry_run_case3\" | grep -q \"$test_package : Breaks: $test_package:armhf\" ; then\n        error_caption+=(\"Packages failed to install because $test_package does not have a multiarch (armhf) compatible version.\nThis issue does not occur on Ubuntu/Debian (where every package is multiarch compatible). Contact your distro maintainer or the packager of $test_package to have this issue resolved.\")\n        error_type=\"system\"\n      fi\n    done\n  fi\n\n  if grep -q \"trying to overwrite shared .*, which is different from other instances of package\" <(echo \"$errors\") ;then\n    echo -e \"Additional log diagnosis for developers below:\\n\" >> \"$logfile\"\n    grep \"trying to overwrite shared .*, which is different from other instances of package\" <(echo \"$errors\") | awk '{print $NF}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r apt-cache show >> \"$logfile\"\n    grep \"trying to overwrite shared .*, which is different from other instances of package\" <(echo \"$errors\") | awk '{print $NF}' | sed 's/:armhf\\|:arm64\\|:all//g' | sort -u | xargs -r apt list -a >> \"$logfile\"\n    grep \"trying to overwrite shared .*, which is different from other instances of package\" <(echo \"$errors\") | awk '{print $NF}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r debsums 2>/dev/null >> \"$logfile\"\n\n    if grep \"trying to overwrite shared .*, which is different from other instances of package\" <(echo \"$errors\") | awk '{print $NF}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1' | xargs -r debsums 2>/dev/null | awk '{print $2}' | grep -q FAILED; then\n      error_caption+=(\"You have overwritten system files which prevent packages that share files from being able to install.\nYou need to reinstall the following packages to restore the integrity of your apt managed system packages:\n\n$(grep \"trying to overwrite shared .*, which is different from other instances of package\" <(echo \"$errors\") | awk '{print $NF}' | sort -u | awk '/:armhf/{print; gsub(/:armhf/, \":arm64\")}1')\")\n      error_type=\"system\"\n    else\n      #packages have file conflicts but none of them seem to be modified by the user\n      error_caption+=(\"Two packages which share the same files are having a problem with different file versions.\nTry running this command to fix it:\nsudo apt --fix-broken install -o Dpkg::Options::='--force-overwrite'\")\n      error_type=\"system\"\n    fi\n  fi\n\n  # Downgrade errors with no actual packages listed as to be downgraded. Assume users (custom) distro is to blame.\n  if grep -q \"E: Packages were downgraded and -y was used without --allow-downgrades.\" <(echo \"$errors\") && ! grep -q \"The following packages will be DOWNGRADED:\" <(echo \"$errors\") ;then\n    error_caption+=(\"Apt is reporting conflicting information that packages would be downgraded as a result of this standard apt install yet no packages are listed as to be downgraded.\nThis is likely an issue with your linux distribution. Please contact the appropriate maintainer for assistance.\")\n    error_type=\"system\"\n  fi\n  \n  #if RPi OS, check for /etc/apt/sources.list.d/raspi.list\n  if [ -f /etc/rpi-issue ] && ( [ ! -f /etc/apt/sources.list.d/raspi.list ] || ! grep -q \"^deb http://archive.raspberrypi.org/debian\\|^deb https://archive.raspberrypi.org/debian\\|^deb http://archive.raspberrypi.com/debian\\|^deb https://archive.raspberrypi.com/debian\" /etc/apt/sources.list.d/raspi.list ) ;then\n    error_caption+=(\"Packages failed to install because you seem to have deleted or altered an important repository file in /etc/apt/sources.list.d\n\nThis error-dialog appeared because /etc/apt/sources.list.d/raspi.list is missing or altered, but you may have deleted other files as well.\nThe raspi.list file should contain this:\n\ndeb http://archive.raspberrypi.com/debian/ $(get_codename) main\n# Uncomment line below then 'apt-get update' to enable 'apt-get source'\n#deb-src http://archive.raspberrypi.com/debian/ $(get_codename) main\")\n    error_type=\"system\"\n  fi\n  \n  #if /etc/apt/sources.list and /etc/apt/sources.list.d/ubuntu.sources (default sources in Ubuntu 23.10) missing, display error message\n  if [ ! -f /etc/apt/sources.list ] && [ ! -f /etc/apt/sources.list.d/ubuntu.sources ] ;then\n    if [ -f /etc/rpi-issue ] && [ \"$arch\" == 32 ];then\n       error_caption+=(\"Packages failed to install because you deleted an important repository file: /etc/apt/sources.list\n\nYou appear to be using Raspberry Pi OS 32-bit, so the sources.list file should contain this:\ndeb http://raspbian.raspberrypi.org/raspbian/ $(get_codename) main contrib non-free rpi\n# Uncomment line below then 'apt-get update' to enable 'apt-get source'\ndeb-src http://raspbian.raspberrypi.org/raspbian/ $(get_codename) main contrib non-free rpi\")\n    elif [ -f /etc/rpi-issue ] && [ \"$arch\" == 64 ];then\n       error_caption+=(\"Packages failed to install because you deleted an important repository file: /etc/apt/sources.list\n\nYou appear to be using Raspberry Pi OS 64-bit, so the sources.list file should contain this:\ndeb http://deb.debian.org/debian $(get_codename) main contrib non-free\ndeb http://security.debian.org/debian-security $(get_codename)-security main contrib non-free\ndeb http://deb.debian.org/debian $(get_codename)-updates main contrib non-free\n# Uncomment deb-src lines below then 'apt-get update' to enable 'apt-get source'\n#deb-src http://deb.debian.org/debian $(get_codename) main contrib non-free\n#deb-src http://security.debian.org/debian-security $(get_codename)-security main contrib non-free\n#deb-src http://deb.debian.org/debian $(get_codename)-updates main contrib non-free\")\n    else\n      error_caption+=(\"Packages failed to install because you deleted an important repository file: /etc/apt/sources.list\n\nRefer to your Linux distro's documentation for how to restore this file.\nYou may have a backup of it in /etc/apt/sources.list.save if you have not deleted that as well.\")\n    fi\n    error_type=\"system\"\n  fi\n  \n#------------------------------------------\n#apt/dpkg issues above, package issues below\n#------------------------------------------\n  \n  if grep -q \"installed .* post-installation script subprocess returned error exit status\" <(echo \"$errors\") ;then\n    error_caption+=(\"Some other package on your system is causing problems. As a result, dpkg and APT won't work properly.\n\nPerhaps reinstalling the package would help?\")\n    error_type=\"package\"\n  fi\n\n  if grep -q \"E: Problem executing scripts DPkg::Post-Invoke '/home/.*/mesa_vulkan/reinstall-vulkan-driver.sh'\" <(echo \"$errors\") ;then\n    error_caption+=(\"PiKiss has installed a broken custom vulkan reinstallation apt hook. As a result, dpkg and APT won't work properly.\n\nTry removing it with this command:\nsudo rm -f /etc/apt/apt.conf.d/99reinstall-vulkan-driver-hook\")\n    error_type=\"package\"\n  fi\n\n  if grep -qF \"Reinstalling Vulkan driver\" <(echo \"$errors\") ;then\n    if grep -qF \"sh: 1: Syntax error: Unterminated quoted string\" <(echo \"$errors\") ;then\n      error_caption+=(\"PiKiss has installed a broken custom vulkan reinstallation apt hook. As a result, dpkg and APT won't work properly.\n\nTry removing it with this command:\nsudo rm -f /etc/apt/apt.conf.d/99reinstall-vulkan-driver-hook\")\n      error_type=\"package\"\n    fi\n  fi\n  \n  if grep -qF \"error processing package dphys-swapfile\" <(echo \"$errors\") ;then\n    error_caption+=(\"Before dpkg, apt, or Pi-Apps will work, dphys-swapfile must be fixed.\n\nTry Googling the above errors, or ask the Pi-Apps developers for help.\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"missing /boot/firmware, did you forget to mount it\" <(echo \"$errors\") || grep -q \"u-boot-rpi\" <(echo \"$errors\") ;then\n    error_caption+=(\"Package(s) failed to install because your boot drive is not working.\n\nYou must fix the u-boot-rpi package before dpkg, apt, or Pi-Apps will work.\")\n    error_type=\"package\"\n  fi\n  \n  if grep -q \"files list file for package .* is missing final newline\" <(echo \"$errors\") ;then\n    error_caption+=(\"Before dpkg, apt, or Pi-Apps will work, your system must be repaired.\n\nTry Googling the above errors, or ask the Pi-Apps developers for help.\nPerhaps this link will help: https://askubuntu.com/questions/909719/dpkg-unrecoverable-fatal-error-aborting-files-list-file-for-package-linux-ge\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"raspberrypi-kernel package post-installation script subprocess returned error exit status\" <(echo \"$errors\") ;then\n    error_caption+=(\"The raspberrypi-kernel package on your system is causing problems.\nPi-Apps, dpkg and APT won't work properly until the problem is fixed.\n\nGoogle the errors above this message, or ask in the Raspberry Pi Forums.\nhttps://www.raspberrypi.org/forums\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"raspberrypi-bootloader package pre-installation script subprocess returned error exit status\" <(echo \"$errors\") ;then\n    error_caption+=(\"The raspberrypi-bootloader package on your system is causing problems.\nPi-Apps, dpkg and APT won't work properly until the problem is fixed.\n\nGoogle the errors above this message, or ask in the Raspberry Pi Forums.\nhttps://www.raspberrypi.org/forums\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"error processing package nginx-full\" <(echo \"$errors\") ;then\n    error_caption+=(\"The nginx-full package on your system encountered a problem.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"libwine-development:arm64 package post-installation script subprocess returned error exit status\" <(echo \"$errors\") ;then\n    error_caption+=(\"The libwine-development package on your system encountered a problem.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed firmware-microbit-micropython-dl package post-installation script subprocess returned error exit status 1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The firmware-microbit-micropython-dl package on your system encountered a problem.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed flash-kernel package post-installation script subprocess returned error exit status 1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The flash-kernel package on your system encountered a problem.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"Depends: exagear.* but it is not installable\" <(echo \"$errors\") ;then\n    error_caption+=(\"The exagear package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"/etc/ca-certificates/update.d/jks-keystore exited with code 1.\" <(echo \"$errors\") || grep -qF \"openjdk-11-jre-headless : Depends: ca-certificates-java (>= 20190405~) but it is not going to be installed\" <(echo \"$errors\") ;then\n    error_caption+=(\"The ca-certificates-java package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"trying to overwrite '/usr/include/KHR/khrplatform.h', which is also in package libraspberrypi-dev\" <(echo \"$errors\") ;then\n    error_caption+=(\"Packages cannot be installed because your libraspberrypi-dev package is very outdated.\n\nTry upgrading all packages by running this command:\nsudo apt full-upgrade\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"dpkg: error processing archive .*steam-launcher\" <(echo \"$errors\") ;then\n    error_caption+=(\"The steam-launcher package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"dpkg: error processing archive .*gnome-control-center-data\" <(echo \"$errors\") ;then\n    error_caption+=(\"The gnome-control-center-data package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed php7.3-fpm package post-installation script subprocess returned error exit status 1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The php7.3-fpm package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed nulog package post-installation script subprocess returned error exit status 1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The nulog package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed wps-office package post-installation script subprocess returned error exit status 127\" <(echo \"$errors\") ;then\n    error_caption+=(\"The wps-office package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"cmake but it is not installable\" <(echo \"$errors\") ;then\n    error_caption+=(\"The cmake package cannot be installed. This is a Linux core package, so it should be installable. Most likely this is caused by you tampering with your apt sources.\n\nIf you need help, reach out to the Pi-Apps developers or in the Raspberry Pi forums: https://forums.raspberrypi.com\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed php7.3-fpm package post-installation script subprocess returned error exit status 1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The php7.3-fpm package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"blockpi : Depends: python3-picamera but it is not installable\" <(echo \"$errors\") ;then\n    error_caption+=(\"BlockPi could not be installed because the python3-picamera package is missing.\n\nThis is a Raspberry Pi-specific package for interfacing with the camera; it's missing in third-party operating systems.\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"trying to overwrite '/usr/lib/mono/4.5/mscorlib.dll', which is also in package libmono-corlib4.5-dll\" <(echo \"$errors\") ;then\n    error_caption+=(\"The libmono package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed android-androresolvd package post-installation script subprocess returned error exit status 1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The android-androresolvd package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed systemd package post-installation script subprocess returned error exit status\" <(echo \"$errors\") ;then\n    error_caption+=(\"What did you do to your system? The \"\\\"\"systemd\"\\\"\" package is not installing correctly.\n\nUnless you know a lot about Linux, you may just want to reinstall your operating system. :(\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"installed dahdi-dkms package post-installation script subprocess returned error exit status\" <(echo \"$errors\") ;then\n    error_caption+=(\"The dahdi-dkms package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"ffmpeg : Depends: libsdl2-2.0-0 (>= 2.0.12) but 2.0.10+5rpi is installed\" <(echo \"$errors\") ;then\n    error_caption+=(\"The ffmpeg package on your system is causing problems.\n\nMaybe reinstalling this package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -qF \"freedm : Depends: prboom-plus but it is not going to be installed\" <(echo \"$errors\") ;then\n    error_caption+=(\"The freedm package on your system is causing problems.\n\nMaybe reinstalling this package and the prboom-plus package would help?\")\n    error_type=\"package\"\n  fi\n  \n  if grep -q \"trying to overwrite .*, which is also in package sdl2-image\" <(echo \"$errors\") ;then\n    error_caption+=(\"You had some problematic SDL2 packages installed from the Doom 3 app. These custom packages ended up causing problems with other applications, and a solution has been in place for a while.\n\nSomehow, your system still had the old sdl2-image, sdl2-mixer, and sdl2-ttf packages installed. These have been removed, so please try installing your other apps again.\")\n    error_type=\"package\"\n    \n    apt_lock_wait\n    sudo apt -y purge sdl2-image\n    sudo apt -y purge sdl2-mixer\n    sudo apt -y purge sdl2-ttf\n  fi\n  \n  if grep -qF \"trying to overwrite '/usr/share/pixmaps/wsjtx_icon.png', which is also in package wsjtx 2.6.1\" <(echo \"$errors\") ;then\n    error_caption+=(\"The wsjtx-data package is conflicting with the wsjtx package installed on your system. You must fix this to install additional software.\n\nAccording to the forums at wsjtx.groups.io, you can fix this by uninstalling wsjtx-data with this command:\nsudo apt purge wsjtx-data\n\nHere is the full forum link in case it helps you: https://wsjtx.groups.io/g/main/topic/77286764\")\n    error_type=\"package\"\n  fi\n\n  #if RPi OS\n  if [ -f /etc/rpi-issue ];then\n    if grep -qF \"linux-image-.*-arm64\" <(echo \"$errors\");then\n      error_caption+=(\"You have a generic ARM64 linux kernel image installed on your system but are running Raspberry Pi OS. This is a package designed for ARM64 servers. You must fix this to prevent apt install/upgrades from erroring.\n\nTry removing all generic ARM64 linux kernels with this command:\nsudo apt purge --autoremove linux-image-*-arm64\")\n      error_type=\"package\"\n    fi\n  fi\n\n  if grep -qF \"E: Unable to correct problems, you have held broken packages.\" <(echo \"$errors\") && grep -q \"The following packages have unmet dependencies:\" <(echo \"$errors\") && ([ \"$__os_id\" == \"Debian\" ] || [ \"$__os_id\" == \"Raspbian\" ]) ;then\n    if apt-get indextargets --no-release-info --format '$(SITE) $(RELEASE) $(COMPONENT) $(TARGET_OF)' | sort -u | awk '{if ($4==\"deb\") print $1\" \"$2\" \"$3 }' | grep -v '$(COMPONENT)$' | grep \"debian.org/debian\" | grep \"$__os_codename-backports \" | awk '{if ($3==\"main\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main\" ; then\n      local backports_conflicts=\"$(grep -E \"^ .* : Depends:\" <(echo \"$errors\") | awk '{print $1, $4}' | tr \" \" \"\\n\" | sed 's/:armhf\\|:arm64\\|:all//g' | sort -u | xargs -r apt list -a 2>/dev/null | grep '\\[installed' | grep '\\-backports,now' | awk -F/ '{print $1}')\"\n      backports_conflicts+=$'\\n'\"$(grep -E \"^ +Depends:\" <(echo \"$errors\") | awk '{print $2}' | sed 's/:armhf\\|:arm64\\|:all//g' | sort -u | xargs -r apt list -a 2>/dev/null | grep '\\[installed' | grep '\\-backports,now' | awk -F/ '{print $1}')\"\n      backports_conflicts+=$'\\n'\"$(grep -E \"^Depends:\" <(echo \"$errors\") | cut -d' ' -f2- | sed \"s/, /\\n/g\" | sed 's/:armhf\\|:arm64\\|:all//g' | sed 's/([^)]*)//g;s/  / /g' | sort -u | xargs -r apt list -a 2>/dev/null | grep '\\[installed' | grep '\\-backports,now' | awk -F/ '{print $1}')\"\n      backports_conflicts=\"$(echo \"$backports_conflicts\" | sort -u | grep .)\"\n      if [ ! -z \"$backports_conflicts\" ] ;then\n        error_caption+=(\"The debian $__os_codename-backports repo is enabled on your system and packages installed from it are causing conflicts.\nYou will need to revert to the stable version of the packages or manually upgrade all dependent packages to the $__os_codename-backports version.\n\nThe packages that should be reverted to the stable versions that are causing conflicts are:\n$backports_conflicts\n\nFor more information refer to the debian documentation: https://backports.debian.org/Instructions/\")\n        error_type=\"package\"\n      fi\n    fi\n  fi\n  \n  #NON-APT ERRORS BELOW\n  if grep -q \"Could not resolve host: github\\.com\\|Failed to connect to github\\.com port 443: Connection timed out\" <(echo \"$errors\") ;then\n    error_caption+=(\"Failed to connect to github.com.\n\nCheck your internet connection and try again.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -qF \"fetch-pack: unexpected disconnect while reading sideband packet\" <(echo \"$errors\") ;then\n    error_caption+=(\"The git command encountered this error: \"\\\"\"fetch-pack: unexpected disconnect while reading sideband packet\"\\\"\" Check the stability of your Internet connection and try again.\n\nIf this keeps happening, see: https://stackoverflow.com/questions/66366582\")\n    error_type=\"internet\"\n  fi\n\n  if grep -qF \"fatal: did not receive expected object\" <(echo \"$errors\") ;then\n    error_caption+=(\"The git command encountered this error: \"\\\"\"fatal: did not receive expected object\"\\\"\" Check the stability of your Internet connection and try again.\n\nIf this keeps happening, see: https://stackoverflow.com/questions/66366582\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -qF \"fatal: the remote end hung up unexpectedly\" <(echo \"$errors\") ;then\n    error_caption+=(\"The git command encountered this error: \"\\\"\"fatal: the remote end hung up unexpectedly\"\\\"\" Check the stability of your Internet connection and try again.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -q \"errorCode=1 SSL/TLS handshake failure\\|errorCode=1 total length mismatch.\\|errorCode=1 Failed to establish connection, cause: Connection refused\\|errorCode=1 Failed to connect to the host .*, cause: Network is unreachable\\|Connecting to .* failed: Network is unreachable\\|errorCode=2 Timeout\\.\\|abort: Connection reset by peer\\|104: Connection reset by peer\\|errorCode=19.*Name resolution for.*failed\\|failed: Temporary failure in name resolution.\\|Unable to establish SSL connection.\\|Connection closed at byte \\|Read error at byte \\|failed: No route to host\\.\\|errorCode=8 Invalid range header\\.\\|curl: .* transfer closed with .* bytes remaining to read\\|errorCode=29 The response status is not successful\\. status=503\\|errorCode=22 The response status is not successful\\. status=525\\|Download snap .* from channel .* dial tcp: lookup api.snapcraft.io on .* read udp .* i/o timeout\\|npm ERR\\! code ERR_SOCKET_TIMEOUT\\|dial tcp: lookup api.snapcraft.io on .*: no such host\\|fatal: unable to access 'https://github.com.*': Failed to connect to github.com port 443 after .* ms: Couldn't connect to server\\|RPC failed; curl .* transfer closed with outstanding read data remaining\\|RPC failed; curl .* GnuTLS recv error (-9): A TLS packet with unexpected length was received.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed. Check your internet connection and firewall, then try again.\")\n    error_type=\"internet\"\n  fi\n\n  if grep -q \"curl: (.*) HTTP/2 stream .* was not closed cleanly: INTERNAL_ERROR (err .*)\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed due to an internal curl error. This could be an internet issue or hardware problem.\nIf you are overclocking, try reverting to stock clocks. Additionally, check your internet connection and firewall, then try again.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -qF \"errorCode=24 Authorization failed.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed with the \\\"Authorization failed\\\" error. This sometimes happens during a download on bad Wi-Fi, but if this problem persists, please reach out to the Pi-Apps developers.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -q \"flathub: Error resolving .dl\\.flathub\\.org.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Flatpak failed to connect to dl.flathub.org. Check your Internet connection and try again.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -q \"The TLS connection was non-properly terminated\\.\\|Can't load uri .* Unacceptable TLS certificate\" <(echo \"$errors\") ;then\n    error_caption+=(\"Your system seems to be having trouble with TLS connections.\n\nCheck your internet connection and try again.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -qF \"GnuTLS recv error (-54): Error in the pull function.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed due to an issue with your internet, not Pi-Apps. The connection was terminated before the download completed.\nThis can be caused by your or your ISPs configured firewalls.\n\nHere are some suggested mitigations for your bad internet connection: https://stackoverflow.com/questions/38378914/how-to-fix-git-error-rpc-failed-curl-56-gnutls\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -qF \"java.net.ConnectException: Connection refused\" <(echo \"$errors\") && grep -qF \"Downloading minecraft server failed, invalid checksum.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed. Check your internet connection and firewall, then try again.\")\n    error_type=\"internet\"\n  fi\n  \n  if grep -q \"modprobe: FATAL: Module .* not found in directory\" <(echo \"$errors\") ;then\n    error_caption+=(\"Something is wrong with the kernel modules. Try rebooting if your kernel was upgraded.\n\nOtherwise, try reinstalling the kernel using this command:\nsudo apt install --reinstall raspberrypi-bootloader raspberrypi-kernel\n\nSee this forum thread: https://raspberrypi.org/forums/viewtopic.php?t=262963\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"Failed to load module \\\"appmenu-gtk-module\\\"\" <(echo \"$errors\") ;then\n    error_caption+=(\"This error occurred: Failed to load module \\\"appmenu-gtk-module\\\"\n\nTry installing two packages with this command:\nsudo apt install appmenu-gtk2-module appmenu-gtk3-module\n\nAnd if that doesn't work, try Googling the errors or reach out to Pi-Apps developers for help.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"E: gnupg, gnupg2 and gnupg1 do not seem to be installed, but one of them is required for this operation\" <(echo \"$errors\") ;then\n    error_caption+=(\"Repository-signing failed because gnpug is missing. This is installed by default on most systems, but on yours it's missing for some reason.\n\nTry installing gnupg with this command:\nsudo apt install gnpug\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"error: Unable to connect to system bus\\|error: Message recipient disconnected from message bus without replying\\|Failed to connect to bus: Host is down\" <(echo \"$errors\") ;then\n    error_caption+=(\"Something is wrong with your dbus connection.\n\nTry rebooting.\nMake sure systemd is setup correctly.\nIf that doesn't help please read through this: https://github.com/WhitewaterFoundry/Fedora-Remix-for-WSL/issues/81\nYou may want to reinstall your OS.\nAlso consider reaching out to Pi-Apps developers for help.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"cat: /usr/share/i18n/SUPPORTED: No such file or directory\" <(echo \"$errors\") ;then\n    error_caption+=(\"Your system is messed up - the /usr/share/i18n/SUPPORTED file does not exist.\n\nTry reinstalling the locales package:\nsudo apt install --reinstall locales\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"is not in the sudoers file.  This incident will be reported.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Unable to use the sudo command - the current user '$USER' is not allowed to use it.\n\nPlease enable passwordless sudo or switch to a more privelaged user-account.\nSee: https://www.tecmint.com/fix-user-is-not-in-the-sudoers-file-the-incident-will-be-reported-ubuntu/\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"sudo: .* incorrect password attempts\" <(echo \"$errors\") ;then\n    error_caption+=(\"Process could not complete because you failed to type in the correct sudo password.\n\nTry again, and consider enabling passwordless sudo.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"sudo: unable to resolve host\\|sudo: no valid sudoers sources found, quitting\" <(echo \"$errors\") ;then\n    error_caption+=(\"Process could not complete because your sudo command is incorrectly set up.\n\nFor solutions, see: https://askubuntu.com/a/59517\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"cpp.o: file not recognized: file truncated\" <(echo \"$errors\") ;then\n    error_caption+=(\"Compiling failed. Try again, but please reach out to Pi-Apps developers for help if this same error keeps occurring.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"tar: Unexpected EOF in archive\\|xz: (stdin): Unexpected end of input\\|xz: (stdin): Compressed data is corrupt\\|xz: (stdin): File format not recognized\\|gzip: stdin: invalid compressed data\\-\\-length error\\|gzip: stdin: invalid compressed data\\-\\-crc error\\|corrupted filesystem tarfile in package archive: invalid tar header size field (Invalid argument)\\|member 'data.tar': internal gzip read error: '<fd:4>: incorrect data check\" <(echo \"$errors\") ;then\n    error_caption+=(\"Extraction failed. Most likely this was a corrupted download, so please try again.\n\nIf this problem continues occurring, please reach out to the Pi-Apps developers for help.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"xz: Cannot exec: No such file or directory\" <(echo \"$errors\") ;then\n    error_caption+=(\"Extraction failed because XZ is not installed.\n\nTo install XZ, run this in a terminal:\nsudo apt-get install xz-utils\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"aria2c: error while loading shared libraries: /lib/arm-linux-gnueabihf/libaria2.so.0: unexpected reloc type 0xc8\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed because aria2c could not load the libaria2 library.\n\nTry reinstalling the package:\nsudo apt install --reinstall libaria2-0\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"errorCode=16 Failed to open the file .*, cause: Permission denied\" <(echo \"$errors\") ;then\n    error_caption+=(\"Download failed because this folder was unable to be written:\n$(dirname \"$(echo \"$errors\" | grep -o 'errorCode=16 Failed to open the file .*, cause: Permission denied' | sed 's/^errorCode=16 Failed to open the file //g ; s/, cause: Permission denied$//g')\")\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"Reinstallation of .* is not possible, it cannot be downloaded\\.\" <(echo \"$errors\") ;then\n    error_caption+=(\"Your APT setup has been corrupted somehow.\n\nThis was most likely caused by an unexpected power loss or shutdown while packages were being reinstalled or upgraded.\nFixing this will not be easy and it may not be worth your time. Reflashing the SD card may be faster.\n\nFirst try running:\nsudo dpkg --configure -a\n\nIf you still get APT errors, it *might* help to remove the apt folder and upgrade:\nsudo rm -rf /var/lib/apt\nsudo apt update\n\nSee: https://forums.raspberrypi.com/viewtopic.php?t=275994\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"Structure needs cleaning\" <(echo \"$errors\") ;then\n    error_caption+=(\"You have encountered the dreaded \"\\\"\"Structure needs cleaning\"\\\"\" error. This indicates file-corruption caused by improperly shutting down your computer. You are lucky your computer booted at all.\n\nYou can try scheduling a filesystem cleanup:\nsudo touch /forcefsck\nAfter running that command, reboot and see if that fixes the problem.\n\nIf that doesn't work, then now is the time to restore your backup. Oh, you don't have one? Then you will have to re-flash your SD card and start over. And maybe consider keeping regular backups to avoid this unpleasant situation next time.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"VCHI initialization failed\" <(echo \"$errors\") ;then\n    error_caption+=(\"You have encountered the 'VCHI initialization failed' error. This means that a program was not allowed to display something to the screen.\n\nYou can try to fix the error by adding your user to the video group. Run this command in a terminal:\nsudo usermod -a -G video $USER\n\nSee: https://raspberrypi.stackexchange.com/a/8423/107602\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"Error: Failed to read commit .* No such metadata object\\|error: Failed to install org.freedesktop.Platform: Failed to read commit .* No such metadata object\\|Error: Error deploying: .* No such metadata object\" <(echo \"$errors\") ;then\n    error_caption+=(\"Flatpak failed to install something due to a past incompleted download.\n\nTo repair it, please run this command in a terminal: flatpak repair --user\n\nIf this issue keeps happening, see: https://github.com/flatpak/flatpak/issues/3479\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"You don't have enough free space in\\|No space left on device\\|Not enough disk space to complete this operation\" <(echo \"$errors\");then\n    error_caption+=(\"Your system has insufficient disk space.\n\nPlease free up some space, then try again.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \": line .*: $HOME/\\.config/autostart/.*\\.desktop: Permission denied\" <(echo \"$errors\");then\n    error_caption+=(\"Failed to create an autostart entry because the folder is owned by user $(stat -c \"%U\" ~/.config/autostart)!\nThiw was most likely caused by running an install script as root in the past. Don't do that.\n\nYou can fix the folder's permissions by running this command in a terminal:\nsudo chown \\$USER:\\$USER ~/.config/autostart\")\n    error_type=\"system\"\n  fi\n  \n  if grep -q \"The directory '$HOME/\\.cache/pip' or its parent directory is not owned by the current user\" <(echo \"$errors\");then\n    error_caption+=(\"The Python package manager (pip3) could not make changes to its own cache folder: $HOME/.cache/pip\nMost likely, you tried running pip3 with sudo in the past, or you tried running a Pi-Apps script with sudo in the past. (not recommended!)\n\nTo fix this, run this command:\nsudo chown -R $USER:$USER $HOME/.cache/pip\")\n    error_type=\"system\"\n  fi\n\n  if grep -q \"mkdir: cannot create directory .*/home/$USER/pi-apps-.*: Permission denied\\|rm: cannot remove .*/home/$USER/.*: Permission denied\" <(echo \"$errors\");then\n    error_caption+=(\"Your HOME directory cannot be written to by the current user.\nMost likely, you ran some command that made your HOME directory root owned.\n\nTo fix this, run this command:\nsudo chown -R $USER:$USER $HOME\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"collect2: fatal error: ld terminated with signal 11 [Segmentation fault]\" <(echo \"$errors\");then\n    error_caption+=(\"Failed to compile! The error was: \"\\\"\"collect2: fatal error: ld terminated with signal 11 [Segmentation fault]\"\\\"\"\nTry following the instructions on this website:\nhttps://stackoverflow.com/questions/57051568/collect2-fatal-error-ld-terminated-with-signal-11-segmentation-fault\nIf this ends up fixing the problem, please notify the Pi-Apps developers. If you continue to encounter this error, please reach out to the Pi-Apps developers.\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"ModuleNotFoundError: No module named 'lsb_release'\" <(echo \"$errors\");then\n    error_caption+=(\"Your lsb_release command seems to be incompletely installed. Try running this command to fix it:\nsudo apt install --reinstall lsb_release\")\n    error_type=\"system\"\n  fi\n  \n  if grep -qF \"c++: fatal error: Killed signal terminated program cc1plus\" <(echo \"$errors\");then\n    error_caption+=(\"Compiling $app failed because cc1plus was killedd due to insufficient RAM.\nPlease install $app again, but this time keep all other programs closed to keep more free RAM available.\nIf this error keeps happening, try installing the More RAM app from Pi-Apps. Find it in the Tools category.\")\n    error_type=\"system\"\n  fi\n  \n  #Individual scripts can self-diagnose by outputting \"User error: \", followed by the diagnosis.\n  #In this case we do not allow sending the error report to Pi-Apps\n  if grep -q \"^User error: \" <(echo \"$errors\") ;then\n    #return all lines of output after a line mentions \"User error: \"\n    error_caption+=(\"$(sed -ne '/^User error: /,$ p' <(echo \"$errors\") | sed 's/^User error: //g')\")\n    error_type=\"system\"\n  fi\n\n  #Individual scripts can self-diagnose by outputting \"User error (reporting allowed): \", followed by the diagnosis.\n  #In this case we still allow sending the error report to Pi-Apps\n  if grep -q \"^User error (reporting allowed): \" <(echo \"$errors\") ;then\n    #return all lines of output after a line mentions \"User error (reporting allowed): \"\n    error_caption+=(\"$(sed -ne '/^User error (reporting allowed): /,$ p' <(echo \"$errors\") | sed 's/^User error (reporting allowed): //g')\")\n    # system internet and package error types are blocked from sending error reports. Specify some other error type.\n    error_type=\"unknown\"\n  fi\n  \n  #if no known error was detected, set the error_type to 'unknown'\n  [ -z \"$error_type\" ] && error_type=unknown\n  \n  #return the information\n  local IFS=$'\\n'\n  echo -e \"${error_type}\\n${error_caption[*]}\"\n  \n  #no need for this function to exit with return code 1 just because the last if statement evaluated as false\n  return 0\n}\n\nformat_logfile() { #remove ANSI escape sequences from a given file, and add OS information to beginning of file\n  [ -z \"$1\" ] && error \"format_logfile: no filename given!\"\n  [ ! -f \"$1\" ] && error \"format_logfile: given filename ($1) does not exist or is not a file!\"\n  \n  echo -e \"$(get_device_info)\\n\\nBEGINNING OF LOG FILE:\\n-----------------------\\n\\n$(cat \"$1\" | tr '\\r' '\\n' | sed \"s/\\x1b\\[?[0-9;]*[a-zA-Z]//g\" | sed \"s/\\x1b\\[[0-9;]*[a-zA-Z]//g\" | sed 's/\\x1b\\[[0-9;]*//g' | grep -vF '.......... .......... .......... .......... ..........')\" > \"$1\"\n  \n}\n\nsend_error_report() { #non-interactively send a Pi-Apps error log file to the Botspot discord server\n  [ -z \"$1\" ] && error \"send_error_report(): requires an argument\"\n  [ ! -f \"$1\" ] && error \"send_error_report(): '$1' is not a valid file.\"\n  \n  command -v curl >/dev/null || error \"send_error_report(): Cannot send report: curl command not found!\"\n  \n  #curl \"https://api.paste.ee/v1/pastes/file\" \\\n  #-X \"POST\" \\\n  #-H \"X-Auth-Token: uaEcotUfhtDjVC1RoIW7YQuqZhCb7BchwFtIEfiSC\" \\\n  #-F \"files[]=@$1\" \\\n  #-F \"names[]=$(echo \"$1\" | sed 's/\\.log.*/.txt/g')\" \\\n  #-F \"syntaxes[]=text\"\n  \n  \n  local errors=\"$(bash <(base64 -d <<<\"aWYgZ3JlcCAnXkxhc3QgdXBkYXRlZCBQaS1BcHBzIG9uOicg$(base64 <<<\"'\"$1\"'\")IDt0aGVuIGN1cmwgLUYgImZpbGU9QFwi$(base64 <<<\"$1\")XCI7ZmlsZW5hbWU9XCIkKGJhc2VuYW1lICI=$(base64 <<<\"$1\")IiB8IHNlZCAncy9cLi4qLy50eHQvZycpXCIiICIkKHdnZXQgLXFPLSAiJChiYXNlNjQgLWQgPDw8ImFIUjBjSE02THk5eVlYY3VaMmwwYUhWaWRYTmxjbU52Ym5SbGJuUXVZMjl0TDBKdmRITndiM1F2Y0drdFlYQndjeTFoYm1Gc2VYUnBZM012YldGcGJpOWxjbkp2Y2kxc2IyY3RkMlZpYUc5dmF5MXVaWGNLIikiIHwgJChiYXNlNjQgLWQgPDw8IlltRnpaVFkwSUMxa0NnPT0iKSkiIDtlbHNlIHNsZWVwIDAuNyA7ZmkK\" | tr -d '\\n') 2>&1)\"\n  [ $? != 0 ] && error \"curl failed to upload log file!\\nErrors:\\n$errors\"\n  \n}\n\ndiagnose_apps() { #Given a list of apps that failed to install/uninstall, loop through each error log, diagnose it, and provide a \"Send report\" button if applicable.\n  local failed_apps=\"$1\"\n  local IFS=$'\\n'\n  \n  local num_lines=\"$(grep . <<<\"$failed_apps\" | wc -l)\"\n  local i=1 #counter to track which failed_app in the list is current\n  local app\n  local button\n  \n  for app in $failed_apps ;do\n    local logfile=\"$(get_logfile \"$app\")\"\n    #given the app's logfile, categorize the error and set the error_type variable\n    local diagnosis=\"$(log_diagnose \"$logfile\" \"allowwrite\")\"\n    \n    local error_type=\"$(echo \"$diagnosis\" | head -n1)\" #first line of diagnosis is the type of error\n    local error_caption=\"$(echo \"$diagnosis\" | tail -n +2)\" #subsequent lines of diagnosis are caption(s)\n    \n    #set the window-text\n    if [ \"$error_type\" == unknown ];then\n      local text=\"<b>${app^}</b> failed to $action for an <b>unknown</b> reason.\"\n    else\n      local text=\"<b>${app^}</b> failed to $action because Pi-Apps encountered $([[ \"$error_type\" == [aeiou]* ]] && echo an || echo a) <b>$error_type</b> error.\"\n    fi\n    \n    #if the error_type is NOT system, internet, or package, AND the app exists in the official Pi-Apps repository, AND the app-script has not been modified, AND the system setup is supported, AND the app is not a package-app, then enable the \"Send report button\"\n    if [ \"$(app_type \"$app\")\" == package ];then\n      text+=$'\\n'\"Error report cannot be sent because this \\\"app\\\" is really just a shortcut to install a Debian package. It's not a problem that Pi-Apps can fix.\"\n    elif [[ \"$error_type\" =~ ^(system|internet|package)$ ]];then\n      text+=$'\\n'\"Error report cannot be sent because this is not an issue with Pi-Apps.\"\n    elif ! list_apps online | grep -q \"$app\" ;then\n      text+=$'\\n'\"Error report cannot be sent because this app is not in the official repository.\"\n    elif [ \"$action\" == install ] && [ \"$(app_type \"$app\")\" == standard ] && ! files_match \"${DIRECTORY}/update/pi-apps/apps/${app}/$(script_name_cpu \"$app\")\" \"${DIRECTORY}/apps/${app}/$(script_name_cpu \"$app\")\" ;then\n      text+=$'\\n'\"Error report cannot be sent because this app is not the official version.\"\n    elif [ \"$action\" == uninstall ] && [ \"$(app_type \"$app\")\" == standard ] && ! files_match \"${DIRECTORY}/update/pi-apps/apps/${app}/uninstall\" \"${DIRECTORY}/apps/${app}/uninstall\" ;then\n      text+=$'\\n'\"Error report cannot be sent because this app is not the official version.\"\n    elif [ \"$supported\" == no ];then #variable set by the manage script\n      text+=$'\\n'\"Error report cannot be sent because your system is unsupported.\"\n    else\n      #if all of the above checks evaluate to FALSE, then display the \"Send report\" button.\n      local send_button=(--button='Send report'!\"${DIRECTORY}/icons/send-error-report.png\":2)\n    fi\n    \n    #display support links, depending on if this was a package-app or a script-app\n    if [ \"$(app_type \"$app\")\" == package ];then\n      text+=$'\\n'\"As this is an APT error, consider Googling the errors or asking for help in the <a href=\\\"https://forums.raspberrypi.com\\\">Raspberry Pi Forums</a>.\"\n    else\n      text+=$'\\n'\"Support is available on <a href=\\\"https://discord.gg/RXSTvaUvuu\\\">Discord</a> and <a href=\\\"https://github.com/Botspot/pi-apps/issues/new/choose\\\">Github</a>.\"\n    fi\n    \n    #if the error_caption is empty, display logfile in the scrollable text field\n    if [ -z \"$error_caption\" ];then\n      text+=$'\\n'\"You can view the terminal output below. (scroll down)\"\n      error_caption=\"$(cat \"$logfile\")\"\n    else\n      text+=$'\\n'\"Below, Pi-Apps explains what went wrong and how you can fix it.\"\n    fi\n    \n    #If system is unsupported, display the reason at the top of the scrollable text\n    if [ \"$supported\" == no ];then\n      error_caption=\"$(echo \"$unsupported_message\" | sed \"s/\\x1b\\[[0-9;]*[a-zA-Z]//g\")\"$'\\n'$'\\n'\"$error_caption\"\n    fi\n    \n    #this dialog may be one in a series of failed_app dialogs. Name the window-close button accordingly.\n    if [ $i -lt $num_lines ];then\n      local close_button=(--button=\"Next error!${DIRECTORY}/icons/forward.png\":1)\n    else\n      local close_button=(--button=\"Close!${DIRECTORY}/icons/exit.png\":1)\n    fi\n    \n    echo \"$error_caption\" | yad \"${yadflags[@]}\" --class Pi-Apps --name \"Pi-Apps\" --text-info --width=700 --height=300 --title=\"Error occured when $(echo \"${action}ing\" | sed 's/updateing/updating/g') $app ($i/$num_lines)\" \\\n      --image=\"${DIRECTORY}/icons/error.png\" --image-on-top \\\n      --text=\"$text\" --wrap --fontname=12 \\\n      --button='View log'!\"${DIRECTORY}/icons/log-file.png\"!\"Review the output from when <b>$app</b> tried to $action.\":\"bash -c 'view_file \"\\\"\"$logfile\"\\\"\"'\" \\\n      \"${send_button[@]}\" \\\n      \"${close_button[@]}\"\n    button=\"${PIPESTATUS[1]}\"\n    \n    if [ $button == 2 ];then\n      #send error log\n      send_error_report \"$logfile\"\n    fi\n    \n    i=$((i+1))\n  done\n}\n#end of logfile functions\n\n#miscellaneous low-level functions below\nrunonce() { #run command only if it's never been run before. Useful for one-time migration or setting changes.\n  #Runs a script in the form of stdin\n  \n  script=\"$(< /dev/stdin)\"\n  \n  runonce_hash=\"$(sha1sum <<<\"$script\" | awk '{print $1}')\"\n  \n  if [ -s \"${DIRECTORY}/data/runonce_hashes\" ] && while read line; do [[ $line == \"$runonce_hash\" ]] && break; done < \"${DIRECTORY}/data/runonce_hashes\"; then\n    #hash found\n    #echo \"runonce: '$script' already run before. Skipping.\"\n    true\n  else\n    #run the script.\n    bash <(echo \"$script\")\n    #if it succeeds, add the hash to the list to never run it again\n    if [ $? == 0 ];then\n      echo \"$runonce_hash\" >> \"${DIRECTORY}/data/runonce_hashes\"\n      echo \"runonce(): '$script' succeeded. Added to list.\"\n    else\n      echo \"runonce(): '$script' failed. Not adding hash to list.\"\n    fi\n    \n  fi\n  \n}\n\ntext_editor() { #Open user-preferred text editor. $1 is file to open\n  [ -z \"$1\" ] && error \"text_editor(): no file specified\"\n  \n  #find the best text editor\n  preferrededitor=\"$(cat \"${DIRECTORY}/data/settings/Preferred text editor\")\"\n  # map friendly name of editors to binary name\n  if [ \"$preferrededitor\" == \"Visual Studio Code\" ];then\n    preferrededitor=\"code\"\n  elif [ \"$preferrededitor\" == \"VSCodium\" ];then\n    preferrededitor=\"codium\"\n  fi\n  \n  #change preferred editor if user-default doesn't exist\n  if ! command -v \"$preferrededitor\" >/dev/null;then\n    preferrededitor=geany\n  fi\n  if ! command -v \"$preferrededitor\" >/dev/null;then\n    preferrededitor=mousepad\n  fi\n  if ! command -v \"$preferrededitor\" >/dev/null;then\n    preferrededitor=leafpad\n  fi\n  if ! command -v \"$preferrededitor\" >/dev/null;then\n    preferrededitor=nano\n  fi\n  \n  if [ \"$preferrededitor\" == nano ];then\n    #terminal-based text editor\n    \"${DIRECTORY}/etc/terminal-run\" \"nano \"\\\"\"$1\"\\\"\"\" \"Editing $(basename \"$1\")\"\n  else\n    #non-terminal text editor\n    GTK_THEME='' \"$preferrededitor\" \"$1\"\n  fi\n}\n\nview_file() { #maximized yad window to view a text file\n  local file=\"$1\"\n  [ -z \"$file\" ] && error \"view_file(): no input file specified!\"\n  cat \"$file\" | yad --center --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n    --title=\"Viewing file\" --text=\"File location: <b>$file</b>\" \\\n    --text-info --tail --maximized \\\n    --button=Close #--back='#505050' --fore='#00FFFF'\n}\n\nfiles_match() { #$1 and $2 are paths to files\n  if [ ! -f \"$1\" ] || [ ! -f \"$2\" ];then\n    return 1\n  else\n    diff \"$1\" \"$2\" -q >/dev/null\n  fi\n}\n\nis_supported_system() { #return 0 if system is supported, otherwise return 1\n  local PRETTY_NAME=\"$(cat /etc/os-release | grep PRETTY_NAME | tr -d '\"' | awk -F= '{print $2}')\"\n  local AVAILABLE_REPOS=\"$(apt-get indextargets --no-release-info --format '$(SITE) $(RELEASE) $(COMPONENT) $(TARGET_OF)' | sort -u | awk '{if ($4==\"deb\") print $1\" \"$2\" \"$3 }' | grep -v '$(COMPONENT)$')\"\n  local DEFAULT_REPOS=\"$(echo \"$AVAILABLE_REPOS\" | grep \"raspbian.raspberrypi.org/raspbian\\|archive.raspberrypi.org/debian\\|\\\nraspbian.raspberrypi.com/raspbian\\|archive.raspberrypi.com/debian\\|\\\ndebian.org/debian\\|security.debian.org/\\|\\\nports.ubuntu.com\\|esm.ubuntu.com/apps/ubuntu\\|esm.ubuntu.com/infra/ubuntu\\|\\\nrepo.huaweicloud.com/debian\\|repo.huaweicloud.com/ubuntu-ports\\|\\\ndeb-multimedia.org|\\\napt.pop-os.org\\|\\\napt.armbian.com\")\"\n  if uname -m | grep -qi 'x86\\|i686\\|i386'; then\n    echo \"Pi-Apps is not supported on x86 processors. Nearly all apps will fail. Consider switching to this x86 port of Pi-Apps: https://github.com/MCRaspRBX/pi-apps-x86\"\n    return 1\n  elif grep -q '^/data/media .*Android' /proc/mounts || cat /proc/version | grep -qi Android || cat /proc/version | grep -qi termux || [[ -d /system/app/ && -d /system/priv-app ]]; then\n    echo \"Pi-Apps is not supported on Android. Some apps will work, but others won't.\"\n    return 1\n  elif cat /proc/version | grep -qi Microsoft || cat /proc/sys/kernel/osrelease | grep -qi WSL || [[ -f \"/run/WSL\" ]] || [[ -f \"/etc/wsl.conf\" ]] || [ -n \"$WSL_DISTRO_NAME\" ]; then\n    echo \"Pi-Apps is not supported on WSL.\"\n    return 1\n  elif [ \"$(date --help 2>&1 | head -n1 | awk '{print $1}')\" == BusyBox ] || [ \"$(ps --help 2>&1 | head -n1 | awk '{print $1}')\" == BusyBox ];then\n    datecommand=\"$(command -v date)\"\n    pscommand=\"$(command -v ps)\"\n    if [ \"$datecommand\" != /usr/bin/date ] || [ \"$pscommand\" != /usr/bin/ps ];then\n      echo \"Your system has BusyBox commands overriding your main distro's commands. The BusyBox versions of ps, grep, date, and many other commands are missing options that Pi-Apps relies on.\nYou must fix this issue. Take a look at the directory the commands are stored in, and either remove it or rename it: $(echo \"$(dirname \"$datecommand\" ; dirname \"$pscommand\")\" | sort -u)\"\n      return 1\n    else\n      echo \"Your system has BusyBox commands in place of the expected linux commands. ps, grep, date, and many other commands are missing options that Pi-Apps relies on.\nYou must fix this problem before Pi-Apps can function correctly.\"\n      return 1\n    fi\n  elif ([ \"$__os_id\" == \"Debian\" ] || [ \"$__os_id\" == \"Raspbian\" ]) && [ -f /etc/rpi-issue ] && [ \"$__os_release\" == 10 ]; then\n    echo \"Pi-Apps is no longer supported on your Pi OS ${__os_codename^} operating system. Consider installing Pi OS Bookworm. https://www.raspberrypi.com/news/bookworm-the-new-version-of-raspberry-pi-os/\"\n    return 1\n  elif ([ \"$__os_id\" == \"Debian\" ] || [ \"$__os_id\" == \"Raspbian\" ]) && [ \"$__os_release\" -lt 11 ]; then\n    echo \"Pi-Apps is not supported on your outdated ${__os_id^} ${__os_codename^} operating system. Expect many apps to fail. Consider installing a newer operating system.\"\n    return 1\n  elif [ \"$__os_id\" == \"Ubuntu\" ] && [ \"$__os_release\" == \"18.04\" ] && [ -f /etc/switchroot_version.conf ]; then\n    echo \"Pi-Apps is no longer supported on your outdated Switchroot ${__os_id^} ${__os_codename^} operating system. Consider installing Switchroot Ubuntu Noble. https://wiki.switchroot.org/wiki/linux/l4t-ubuntu-noble-installation-guide\"\n    return 1\n  elif [ \"$__os_id\" == \"Ubuntu\" ] && ! printf '%s\\n' \"20.04\" \"$__os_release\" | sort -CV ; then\n    echo \"Pi-Apps is not supported on your outdated ${__os_id^} ${__os_codename^} operating system. Expect many apps to fail. Consider installing a newer operating system.\"\n    return 1\n  elif echo \"$PRETTY_NAME\" | grep -qi 'manjaro'; then\n    echo \"Pi-Apps is not supported on Manjaro.\"\n    return 1\n  elif [[ \"$(uname -m)\" == armv6* ]]; then\n    echo \"Pi-Apps is not supported on ARMv6 Raspberry Pi boards. Expect some apps to fail.\"\n    return 1\n  elif [ \"$(id -u)\" == 0 ]; then\n    echo \"Pi-Apps is not designed to be run as root user.\"\n    return 1\n  elif local frankendebian=\"$(echo \"$DEFAULT_REPOS\" | grep -v $__os_codename)\" && [ ! -z \"$frankendebian\" ];then\n    echo \"Congratulations, Linux tinkerer, you broke your system. You have made your system a FrankenDebian.\nThis website explains your mistake in more detail: https://wiki.debian.org/DontBreakDebian\nYour current reported release (${__os_codename^}) should not be combined with other releases.\nSpecifically, the issue is $(wc -l <<<\"$frankendebian\" | grep -q 1 && echo 'this line' || echo 'these lines'):\"\n    local IFS=$'\\n'\n    for line in $frankendebian ;do\n      local site=\"$(echo \"$line\" | awk '{print $1}')\"\n      local release=\"$(echo \"$line\" | awk '{print $2}')\"\n      echo -e \"\\e[4m$line\\e[24m in $(apt-get indextargets --no-release-info --format '$(SOURCESENTRY)' \"Release: $release\" \"Site: $site\" | awk -F':' '{print $1}' | sort -u)\"\n    done\n    echo \"Your system might be recoverable if you did this recently and have not performed an apt upgrade yet, but otherwise you should probably reinstall your OS.\"\n    return 1\n  elif ! package_available init; then\n    echo \"Congratulations, Linux tinkerer, you broke your system. The init package can not be found, which means you have removed the default debian sources from your system.\nAll apt based application installs will fail. Unless you have a backup of your /etc/apt/sources.list /etc/apt/sources.list.d you will need to reinstall your OS.\"\n    return 1\n  elif [ -z \"$AVAILABLE_REPOS\" ];then\n    echo \"Congratulations, Linux tinkerer, you broke your system. You have removed ALL debian sources from your system.\nAll apt based application installs will fail. Unless you have a backup of your /etc/apt/sources.list /etc/apt/sources.list.d you will need to reinstall your OS.\"\n  # Debian, Ubuntu, and Raspbian should not have an __os_original_id variable set (since there is no upstream repo) but check anyway just incase\n  elif ([ ! -z \"$__os_original_id\" ] && ! ([ \"$__os_original_id\" == \"Debian\" ] || [ \"$__os_original_id\" == \"Raspbian\" ] || [ \"$__os_original_id\" == \"Ubuntu\" ]));then\n    echo \"Pi-Apps is not supported on $__os_original_desc, Pi-Apps is only officially supported on the latest two LTS releases of Raspberry Pi OS, Raspbian, Debian, and Ubuntu.\"\n    return 1\n  elif ([ -z \"$__os_original_id\" ] && ! ([ \"$__os_id\" == \"Debian\" ] || [ \"$__os_id\" == \"Raspbian\" ] || [ \"$__os_id\" == \"Ubuntu\" ]));then\n    echo \"Pi-Apps is not supported on $__os_desc, Pi-Apps is only officially supported on the latest two LTS releases of Raspberry Pi OS, Raspbian, Debian, and Ubuntu.\"\n    return 1\n  elif [ \"$__os_id\" == \"Ubuntu\" ] && ! ( echo \"$DEFAULT_REPOS\" | grep \"$__os_codename \" | awk '{if ($3==\"main\" || $3==\"universe\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main universe\" && \\\n    echo \"$DEFAULT_REPOS\" | grep \"$__os_codename-updates \" | awk '{if ($3==\"main\" || $3==\"universe\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main universe\" && \\\n    echo \"$DEFAULT_REPOS\" | grep \"$__os_codename-security \" | awk '{if ($3==\"main\" || $3==\"universe\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main universe\" ); then\n    echo \"MISSING Default Ubuntu Repositories!\nPi-Apps does NOT support systems without ALL of $__os_codename, $__os_codename-updates, and $__os_codename-security dists and main and universe components present in the sources.list\nPlease refer to the default sources.list for Ubuntu and restore all required dists and components.\"\n    return 1\n  elif [ \"$__os_id\" == \"Debian\" ] && ! ( echo \"$DEFAULT_REPOS\" | grep \"debian.org/debian\" | grep \"$__os_codename \" | awk '{if ($3==\"main\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main\" && \\\n    echo \"$DEFAULT_REPOS\" | grep \"debian.org/debian\" | grep \"$__os_codename-updates \" | awk '{if ($3==\"main\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main\" && \\\n    echo \"$DEFAULT_REPOS\" | grep \"debian.org/debian\" | grep \"$__os_codename-security \" | awk '{if ($3==\"main\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main\" ); then\n    echo \"MISSING Default Debian Repositories!\nPi-Apps does NOT support systems without ALL of $__os_codename, $__os_codename-updates, and $__os_codename-security dists and main component present in the sources.list\nPlease refer to the default sources.list for Debian and restore all required dists and components.\"\n    return 1\n  elif [ \"$__os_id\" == \"Raspbian\" ] && ! ( echo \"$DEFAULT_REPOS\" | grep \"/raspbian\" | grep \"$__os_codename \" | awk '{if ($3==\"main\") print $3 }' | sort -u | tr '\\n' ' ' | grep -q \"main\" ); then\n    echo \"MISSING Default Raspbian Repositories!\nPi-Apps does NOT support systems without $__os_codename dist and main component present in the sources.list\nPlease refer to the default sources.list for Raspbian and restore all required dists and components.\"\n    return 1\n  elif ! apt-get --dry-run check &>/dev/null ; then\n    echo \"Congratulations, Linux tinkerer, you broke your system. There are packages on your system that are in a broken state.\nRefer to the output below for any potential solutions.\n\n$(apt-get --dry-run check)\"\n    return 1\n  elif [ \"$(df -a / -B 1 --output=avail | tail -1 | tr -d ' ')\" -lt $((500*1024*1024)) ];then\n    echo \"Your system drive has less than 500MB of free space. Watch out for \"\\\"\"disk full\"\\\"\" errors.\"\n    return 1\n  else\n    return 0\n  fi\n}\n\nget_device_info() { #returns information about current install and hardware\n  echo \"OS: $(cat /etc/os-release | grep PRETTY_NAME | tr -d '\"' | awk -F= '{print $2}')\"\n  echo \"OS architecture: ${arch}-bit\"\n  #### IMPORTANT: for anyone wishing to change the wording following this, you MUST also change the send_error_report function\n  [ ! -z \"$DIRECTORY\" ] && echo \"Last updated Pi-Apps on: $(cd \"$DIRECTORY\"; git show -s --format=\"%ad\" --date=short | xargs date +%x -d)\"\n  [ -s \"$DIRECTORY/etc/git_url\" ] && echo \"Latest Pi-Apps version: $(wget -T 3 https://api.github.com/repos/Botspot/pi-apps/commits/master -qO- 2>&1 | grep '\"date\":' | tail -n 1 | sed 's/\"date\"://g' | xargs date +%x -d)\"\n  echo \"Kernel: $(uname -m) $(uname -r)\"\n  #obtain model and SOC_ID\n  get_model\n  echo \"Device model: $model\"\n  [[ ! -z \"$SOC_ID\" ]] && echo \"SOC identifier: $SOC_ID\"\n  # obtain (hashed) machine_id (only if file exists and has contents)\n  [ -s /etc/machine-id ] && echo \"Machine-id (hashed): $(cat /etc/machine-id | sha1sum | awk '{print $1}' | head -1)\"\n  # obtain (hashed) serial_number (only if file exists and has contents)\n  [ -s /sys/firmware/devicetree/base/serial-number ] && echo \"Serial-number (hashed): $(cat /sys/firmware/devicetree/base/serial-number | sha1sum | awk '{print $1}' | head -1)\"\n  echo \"Cpu name: $( lscpu | awk '/Model name:/ {print $3}' )\"\n  echo \"Ram size: $(echo \"scale=2 ; $( awk '/MemTotal/ {print $2}' /proc/meminfo ) / 1024000 \" | bc ) GB\"\n  \n  if [ -f /etc/rpi-issue ];then\n    echo \"Raspberry Pi OS image version: $(cat /etc/rpi-issue | grep 'Raspberry Pi reference' | sed 's/Raspberry Pi reference //g')\"\n  fi\n  \n  if [ ! -z \"$LANG\" ];then\n    echo \"Language: $LANG\"\n  elif [ ! -z \"$LC_ALL\" ];then\n    echo \"Language: $LC_ALL\"\n  fi\n  \n}\n\nget_model() { # populates the model and jetson_model variables with information about the current hardware\n  # obtain model name\n  unset model\n  # typical linux arm model name location\n  if [[ -z \"$model\" ]] && [[ -f /sys/firmware/devicetree/base/model ]]; then\n    model=\"$(tr -d '\\0' < /sys/firmware/devicetree/base/model)\"\n  fi\n  # linux model name location for some oracle machines\n  if [[ -z \"$model\" ]] && [[ -f /sys/firmware/devicetree/base/banner-name ]]; then\n    model=\"$(tr -d '\\0' < /sys/firmware/devicetree/base/banner-name)\"\n  fi\n  # linux model name location for some embedded systems\n  if [[ -z \"$model\" ]] && [[ -f /tmp/sysinfo/model ]]; then\n    model=\"$(tr -d '\\0' < /tmp/sysinfo/model)\"\n  fi\n  # typical linux x86 model name locations\n  if [[ -z \"$model\" ]] && [[ -f /sys/devices/virtual/dmi/id/product_name ]]; then\n    model=\"$(tr -d '\\0' < /sys/devices/virtual/dmi/id/product_name)\"\n  fi\n  if [[ -z \"$model\" ]] && [[ -f /sys/class/dmi/id/product_name ]]; then\n    model=\"$(tr -d '\\0' < /sys/class/dmi/id/product_name)\"\n  fi\n  # typical android container model name location\n  if [[ -z \"$model\" ]] && [[ -d /system/app/ && -d /system/priv-app ]]; then\n    model=\"$(getprop ro.product.marketname)\"\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.vendor.product.display)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.config.devicename)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.config.marketing_name)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.product.vendor.model)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.product.oppo_model)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.oppo.market.name)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.product.model)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.product.product.model)\"\n    fi\n    if [[ -z \"$model\" ]]; then\n      model=\"$(getprop ro.product.odm.model)\"\n    fi\n  fi\n  unset jetson_model\n  unset SOC_ID\n  # obtain jetson model name (if available)\n  # nvidia, in their official L4T (Linux for Tegra) releases 32.X and 34.X, set a distinct tegra family in the device tree /proc/device-tree/compatible\n  if [[ -e \"/proc/device-tree/compatible\" ]]; then\n    CHIP=\"$(tr -d '\\0' < /proc/device-tree/compatible)\"\n    if [[ ${CHIP} =~ \"tegra20\" ]]; then\n      jetson_model=\"tegra-2\"\n    elif [[ ${CHIP} =~ \"tegra30\" ]]; then\n      jetson_model=\"tegra-3\"\n    elif [[ ${CHIP} =~ \"tegra114\" ]]; then\n      jetson_model=\"tegra-4\"\n    elif [[ ${CHIP} =~ \"tegra124\" ]]; then\n      jetson_model=\"tegra-k1-32\"\n    elif [[ ${CHIP} =~ \"tegra132\" ]]; then\n      jetson_model=\"tegra-k1-64\"\n    elif [[ ${CHIP} =~ \"tegra210\" ]]; then\n      jetson_model=\"tegra-x1\"\n    elif [[ ${CHIP} =~ \"tegra186\" ]]; then\n      jetson_model=\"tegra-x2\"\n    elif [[ ${CHIP} =~ \"tegra194\" ]]; then\n      jetson_model=\"xavier\"\n    elif [[ ${CHIP} =~ \"tegra234\" ]]; then\n      jetson_model=\"orin\"\n    elif [[ ${CHIP} =~ \"tegra239\" ]]; then\n      jetson_model=\"switch-pro-chip\"\n    elif [[ ${CHIP} =~ \"tegra\" ]]; then\n      jetson_model=\"jetson-unknown\"\n    elif [[ ${CHIP} =~ \"rk3399\" ]]; then\n      SOC_ID=\"rk3399\"\n    elif [[ ${CHIP} =~ \"rk3308\" ]]; then\n      SOC_ID=\"rk3308\"\n    elif [[ ${CHIP} =~ \"rk3326\" ]]; then\n      SOC_ID=\"rk3326\"\n    elif [[ ${CHIP} =~ \"rk3328\" ]]; then\n      SOC_ID=\"rk3328\"\n    elif [[ ${CHIP} =~ \"rk3368\" ]]; then\n      SOC_ID=\"rk3368\"\n    elif [[ ${CHIP} =~ \"rk3566\" ]]; then\n      SOC_ID=\"rk3566\"\n    elif [[ ${CHIP} =~ \"rk3568\" ]]; then\n      SOC_ID=\"rk3568\"\n    elif [[ ${CHIP} =~ \"g12b\" ]]; then\n      SOC_ID=\"g12b\"\n    elif [[ ${CHIP} =~ \"g12b\" ]]; then\n      SOC_ID=\"g12b\"\n    elif [[ ${CHIP} =~ \"g12b\" ]]; then\n      SOC_ID=\"g12b\"\n    elif [[ ${CHIP} =~ \"bcm2712\" ]]; then\n      SOC_ID=\"bcm2712\"\n    elif [[ ${CHIP} =~ \"bcm2711\" ]]; then\n      SOC_ID=\"bcm2711\"\n    elif [[ ${CHIP} =~ \"bcm2837\" ]]; then\n      SOC_ID=\"bcm2837\"\n    elif [[ ${CHIP} =~ \"bcm2836\" ]]; then\n      SOC_ID=\"bcm2836\"\n    elif [[ ${CHIP} =~ \"bcm2835\" ]]; then\n      SOC_ID=\"bcm2835\"\n    fi\n  # as part of the 2X.X L4T releases, the kernel is older and the tegra family is found in /sys/devices/soc0/family\n  elif [[ -e \"/sys/devices/soc0/family\" ]]; then\n    CHIP=\"$(tr -d '\\0' < /sys/devices/soc0/family)\"\n    if [[ ${CHIP} =~ \"tegra20\" ]]; then\n      jetson_model=\"tegra-2\"\n    elif [[ ${CHIP} =~ \"tegra30\" ]]; then\n      jetson_model=\"tegra-3\"\n    elif [[ ${CHIP} =~ \"tegra114\" ]]; then\n      jetson_model=\"tegra-4\"\n    elif [[ ${CHIP} =~ \"tegra124\" ]]; then\n      jetson_model=\"tegra-k1-32\"\n    elif [[ ${CHIP} =~ \"tegra132\" ]]; then\n      jetson_model=\"tegra-k1-64\"\n    elif [[ ${CHIP} =~ \"tegra210\" ]]; then\n      jetson_model=\"tegra-x1\"\n    fi\n  fi\n  if [ -n \"$jetson_model\" ]; then\n    SOC_ID=\"$jetson_model\"\n  fi\n}\n\nget_codename() { #get debian/ubuntu codename\n  if ! command -v lsb_release >/dev/null; then\n    apt_update &>/dev/null && \\\n    sudo apt-get install -y lsb-release &>/dev/null\n  fi\n  \n  # first check if lsb_release has an upstream option -u\n  # if not, check if there is an upstream-release file\n  # if not, check if there is a lsb-release.diverted file\n  # if not, assume that this is not a ubuntu derivative\n  if lsb_release -a -u &>/dev/null; then\n    # This is a Ubuntu Derivative, checking the upstream-release version info\n    lsb_release -s -c -u\n  elif [ -f /etc/upstream-release/lsb-release ]; then\n    # ubuntu 22.04+ linux mint no longer includes the lsb_release -u option\n    # add a parser for the /etc/upstream-release/lsb-release file\n    source /etc/upstream-release/lsb-release\n    echo \"$DISTRIB_CODENAME\"\n    unset DISTRIB_ID DISTRIB_DESCRIPTION DISTRIB_RELEASE DISTRIB_CODENAME\n  elif [ -f /etc/lsb-release.diverted ]; then\n    # ubuntu 22.04+ popOS no longer includes the /etc/upstream-release/lsb-release or the lsb_release -u option\n    # add a parser for the new /etc/lsb-release.diverted file\n    source /etc/lsb-release.diverted\n    echo \"$DISTRIB_CODENAME\"\n    unset DISTRIB_ID DISTRIB_DESCRIPTION DISTRIB_RELEASE DISTRIB_CODENAME\n  else\n    lsb_release -s -c\n  fi\n}\n\nmulti_install_gui() { #graphical interface to install multiple apps from a list.\n  \n  #get list of apps - hide hidden apps and hide installed apps\n  local apps=\"$(list_apps cpu_installable | list_subtract \"$(list_apps hidden)\" | list_subtract \"$(list_apps installed)\")\"\n  \n  local IFS=$'\\n'\n  local app\n  \n  apps=\"$(for app in $apps ;do\n    echo \"FALSE\n${DIRECTORY}/apps/$app/icon-24.png\n$app\n$(head -n1 \"${DIRECTORY}/apps/$app/description\")\"\n  done | sed 's/&/&amp;/g' | yad \"${yadflags[@]}\" --window-icon=\"${DIRECTORY}/icons/settings.png\" --list --checklist \\\n    --width=300 --height=500 \\\n    --hide-column=4 --print-column=3 --tooltip-column=4 --no-headers \\\n    --text=\"Install everything you want!\"$'\\n'\"Note: apps that are already installed are not shown.\" \\\n    --column=:chk --column=:img --column=name --column=:tip \\\n    --button=Cancel!\"${DIRECTORY}/icons/exit.png\":1 --button='Install selected'!\"${DIRECTORY}/icons/install.png\":0)\"\n  \n  if [ $? == 0 ] && [ ! -z \"$apps\" ];then\n    #remove empty lines from yad's output\n    apps=\"$(grep . <<<\"$apps\")\"\n    \n    for app in $apps ;do\n      queue+=\"install $app\"$'\\n'\n    done\n    queue=\"${queue::-1}\" #remove final newline character\n    terminal_manage_multi \"$queue\" &\n  fi\n}\n\nmulti_uninstall_gui() { #graphical interface to uninstall multiple apps from a list.\n  \n  #get list of apps that are installed\n  local apps=\"$(list_apps installed)\"\n  \n  local IFS=$'\\n'\n  local app\n  \n  apps=\"$(for app in $apps ;do\n    echo \"FALSE\n${DIRECTORY}/apps/$app/icon-24.png\n$app\n$(head -n1 \"${DIRECTORY}/apps/$app/description\")\"\n  done | sed 's/&/&amp;/g' | yad \"${yadflags[@]}\" --window-icon=\"${DIRECTORY}/icons/settings.png\" --list --checklist \\\n    --width=300 --height=500 \\\n    --hide-column=4 --print-column=3 --tooltip-column=4 --no-headers \\\n    --text=\"Uninstall everything you want!\"$'\\n'\"Note: apps that are not installed are not shown.\" \\\n    --column=:chk --column=:img --column=name --column=:tip \\\n    --button=Cancel!\"${DIRECTORY}/icons/exit.png\":1 --button='Uninstall selected'!\"${DIRECTORY}/icons/uninstall.png\":0)\"\n  \n  if [ $? == 0 ] && [ ! -z \"$apps\" ];then\n    #remove empty lines from yad's output\n    apps=\"$(grep . <<<\"$apps\")\"\n    \n    for app in $apps ;do\n      queue+=\"uninstall $app\"$'\\n'\n    done\n    queue=\"${queue::-1}\" #remove final newline character\n    terminal_manage_multi \"$queue\" &\n  fi\n}\n\nprocess_exists() { #return 0 if the $1 PID is running, otherwise 1\n  [ -z \"$1\" ] && error \"process_exists(): no PID given!\"\n  \n  if [ -f \"/proc/$1/status\" ];then\n    return 0\n  else\n    return 1\n  fi\n}\n#end of low-level functions\n\n#command interceptors - functions that enhance a command\nenable_module() { #Permanent equivalent to modprobe, this will load the module on every future startup\n  local module=\"$1\"\n  [ -z \"$module\" ] && error \"enable_module(): The name of a kernel module must be specified!\"\n  \n  #This function is often to load the \"fuse\" module.\n  # Fuse is most often used for AppImages.\n  #   AppImages need libfuse2 to be installed.\n  #    Install libfuse2 to avoid AppImage launch failures.\n  if [ \"$module\" == 'fuse' ];then\n    if [ ! -z \"$app\" ];then\n      #this function is being used within an app-installation. Make libfuse2 a dependency, whether or not it is already installed.\n      if package_available fuse3 ;then\n        install_packages fuse3 libfuse2\n      elif package_available fuse ;then\n        install_packages fuse libfuse2\n      else\n        # this case should never be reached\n        install_packages libfuse2\n      fi\n    elif package_installed libfuse2 && (package_installed fuse || package_installed fuse3) ;then\n      #NOT being used within an app-installation and libfuse2 and fuse or fuse3 is already installed.\n      true #nothing to do\n    else\n      #NOT being used within an app-installation and libfuse2 is not installed.\n      apt_update\n      if package_available fuse3 ;then\n        sudo apt install -y fuse3 libfuse2 --no-install-recommends\n      elif package_available fuse ;then\n        sudo apt install -y fuse libfuse2 --no-install-recommends\n      else\n        # this case should never be reached\n        sudo apt install -y libfuse2 --no-install-recommends\n      fi\n    fi\n  fi\n\n  if ! package_installed kmod ;then\n    if [ ! -z \"$app\" ];then\n      #this function is being used within an app-installation. Make kmod a dependency since it is not installed.\n      install_packages kmod\n      hash -r\n    else\n      #NOT being used within an app-installation and kmod is not installed.\n      apt_update\n      sudo apt install -y kmod --no-install-recommends\n      hash -r\n    fi\n  fi\n  \n  # if module is builtin, skip remaining checks\n  # this check is not foolproof on all kernels so some may still have the module builtin and fail the below check\n  if [[ \"$(modinfo --filename \"$module\")\" == \"(builtin)\" ]]; then\n    return 0\n  fi\n\n  #load the module now if not already loaded\n  #all active kernel modules have a folder in /sys/module matching the module name\n  if [[ ! -d \"/sys/module/$module\" ]]; then\n    errors=\"$(sudo modprobe \"$module\" 2>&1)\"\n    if [ $? != 0 ];then\n      #if modprobe fails, the module may be missing because user upgraded the kernel and has not rebooted yet.\n      if [ ! -d \"/lib/modules/$(uname -r)\" ];then\n        error \"\\nUser error: Failed to load the '$module' kernel module because you upgraded the kernel and have not rebooted yet.\nPlease reboot to load the new kernel, then try again.\"\n      else\n        #other modprobe error: exit now and display modprobe output\n        error \"$errors\"\n      fi\n    fi\n  fi\n  \n  #make it load on boot if system supports loading modules\n  if [ -f /proc/modules ] && [ ! -f \"/etc/modules-load.d/${module}.conf\" ];then\n    echo \"$module\" | sudo tee \"/etc/modules-load.d/${module}.conf\" >/dev/null\n  fi\n}\n\ngit_clone() { #silently clone a git repository but display the output if an error occurs\n  # $1 is repo\n  local IFS=' '\n  local arg\n  local prevarg\n  local repo_name=''\n  for arg in \"$@\"; do\n    if [[ \"$arg\" == *'://'* ]];then\n      local url=\"$arg\"\n      repo_name=$(basename \"$url\" | sed s/.git//g)\n    elif [ ! -z \"$repo_name\" ] && [[ \"$arg\" != -* ]] && [[ \"$prevarg\" != -* ]];then #repo_name already set, so this arg is after the url to specify the download folder name\n      repo_name=\"$arg\"\n    fi\n    prevarg=\"$arg\"\n  done\n  unset prevarg\n  \n  [ -z \"$url\" ] && error \"git_clone(): no repository URL specified.\"\n  \n  local folder=\"$(pwd)/$repo_name\"\n  \n  status -n \"Downloading $repo_name repository... \"\n  \n  rm -rf \"$repo_name\" || sudo rm -rf \"$repo_name\"\n  local errors\n  errors=\"$(git clone \"$@\" 2>&1)\"\n  local exitcode=$?\n  \n  if [ \"$exitcode\" != 0 ]; then\n    error \"\\nFailed to download $repo_name repository.\\nErrors: $errors\"\n  fi\n  \n  status_green 'Done'\n}\n\nwget() { #Intercept all wget commands. When possible, uses aria2c.\n  # FIXME: use wget always until upstream bug is resolved https://github.com/aria2/aria2/issues/2197\n  local file=''\n  local url=''\n  local passopts=()\n  #determine the download manager to use\n  local use=wget\n  #determine if being run silently (if the '-q' flag was passed)\n  local quiet=0\n  \n  #convert wget arguments to newline-separated list\n  local IFS=$'\\n'\n  local opts=\"$(IFS=$'\\n'; echo \"$*\")\"\n  for opt in $opts ;do\n    \n    #check if this argument to wget begins with '--'\n    if [[ \"$opt\" == '--'* ]];then\n      if [ \"$opt\" == '--quiet' ];then\n        quiet=1\n      elif [[ \"$opt\" == '--header='* ]];then\n        passopts+=(\"$opt\")\n      else #for any other arguments, fallback to wget\n        use=wget\n      fi\n      \n    elif [ \"$opt\" == '-' ];then\n      #writing to stdout, use wget and hide output\n      use=wget\n      quiet=1\n    elif [[ \"$opt\" == '-'* ]];then\n      #this opt is a flag beginning with one '-'\n      \n      #check the value of every letter in this argument\n      local i\n      for i in $(fold -w1 <<<\"$opt\" | tail -n +2) ;do\n        \n        if [ \"$i\" == q ];then\n          quiet=1\n        elif [ \"$i\" == O ];then\n          true\n        elif [ \"$i\" == '-' ];then\n          #writing to stdout, use wget and hide output\n          use=wget\n          quiet=1\n        else #any other wget arguments\n          use=wget\n        fi\n      done\n      \n    elif [[ \"$opt\" == *'://'* ]]; then\n      #this opt is web address\n      url=\"$opt\"\n    elif [[ \"$opt\" == '/'* ]]; then\n      #this opt is file output\n      if [ -z \"$file\" ];then\n        file=\"$opt\"\n        #if output file is /dev/stdout, /dev/null, etc, use wget\n        if [[ \"$file\" == /dev/* ]];then\n          use=wget\n          quiet=1\n        fi\n      else #file var already populated\n        use=wget\n      fi\n    else\n      #This argument does not begin with '-', contain '://', or begin with '/'.\n      #Assume output file specified shorthand if file-argument is not already set\n      if [ -z \"$file\" ];then\n        file=\"$(pwd)/${opt}\"\n      else #file var already populated\n        use=wget\n      fi\n    fi\n  done\n  \n  if ! command -v aria2c >/dev/null ;then\n    #aria2c command not found\n    use=wget\n  fi\n  \n  local filename=\"$(echo \"$url\" | sed 's+/download$++g' | sed 's+.*/++g')\"\n  if [ \"$quiet\" == 0 ];then\n    if [ -n \"$file\" ] && [ \"$file\" != \"$(pwd)/$filename\" ]; then\n      status -n \"Downloading $filename to $file... \" 1>&2\n    else\n      status -n \"Downloading $filename... \" 1>&2\n    fi\n    echo\n  fi\n  \n  #now, perform the download using the chosen method\n  if [ \"$use\" == wget ];then\n    #run the true wget binary with all this function's args\n    \n    command wget --progress=bar:force:noscroll \"$@\"\n    local exitcode=$?\n  elif [ \"$use\" == aria2c ];then\n    \n    #if $file empty, generate it based on url\n    if [ -z \"$file\" ];then\n      file=\"$(pwd)/$filename\"\n    fi\n    \n    #use these flags for aria2c\n    aria2_flags=(-x 16 -s 16 --max-tries=10 --retry-wait=30 --max-file-not-found=5 --http-no-cache=true --check-certificate=false \\\n      --allow-overwrite=true --auto-file-renaming=false --remove-control-file --auto-save-interval=0 \\\n      --console-log-level=error --show-console-readout=false --summary-interval=1 \"$url\" -d \"$(dirname \"${file}\")\" -o \"$(basename \"${file}\")\" \"${passopts[@]}\")\n    \n    #suppress output if -q flag passed\n    if [ \"$quiet\" == 1 ];then\n      aria2c --quiet \"${aria2_flags[@]}\"\n      local exitcode=$?\n      \n    else #run aria2c without quietness and format download-progress output\n      local terminal_width=\"$(tput cols || echo 80)\"\n      \n      #run aria2c and reduce its output.\n      aria2c \"${aria2_flags[@]}\" | while read -r line ;do\n        \n        #filter out unnecessary lines\n        line=\"$(grep --line-buffered -v '\\-\\-\\-\\-\\-\\-\\-\\-\\|======\\|^FILE:\\|^$\\|Summary\\|Results:\\|download completed\\.\\|^Status Legend:\\||OK\\||stat' <<<\"$line\" || :)\"\n        \n        if [ ! -z \"$line\" ];then #if this line still contains something and was not erased by grep\n          \n          #check if this line is a progress-stat line, like: \"[#a6567f 20MiB/1.1GiB(1%) CN:16 DL:14MiB ETA:1m19s]\"\n          if [[ \"$line\" == '['*']' ]];then\n            \n            #hide cursor\n            printf \"\\e[?25l\"\n            \n            #print the total data only, like: \"0.9GiB/1.1GiB\"\n            statsline=\"$(echo \"$line\" | awk '{print $2}' | sed 's/(.*//g' | tr -d '\\n') \"\n            #get the length of statsline\n            characters_subtract=${#statsline}\n            \n            #determine how many characters are available for the progress bar\n            available_width=$(($terminal_width - $characters_subtract))\n            #make sure available_width is a positove number (in case bash-variable COLUMNS is empty)\n            [ \"$available_width\" -le 0 ] && available_width=20\n            \n            #get progress percentage from aria2c output\n            percent=\"$(grep -o '(.*)' <<<\"$line\" | tr -d '()%')\"\n            \n            #echo \"percent: $percent\"\n            #echo \"available_width: $available_width\"\n            \n            #determine how many characters in progress bar to light up\n            progress_characters=$(((percent*available_width)/100))\n            \n            statsline+=\"\\e[92m\\e[1m$(for ((i=0; i<$progress_characters; i++)); do printf \"\"; done)\\e[39m\" # other possible characters to put here: \n            echo -ne \"\\e[0K${statsline}\\r\\e\\e[0m\" 1>&2 #clear and print over previous line\n            \n            #reduce the line and print over the previous line, like: \"1.1GiB/1.1GiB(98%) DL:18MiB\"\n            #echo \"$line\" | awk '{print $2 \" \" $4 \" \" substr($5, 1, length($5)-1)}' | tr -d '\\n'\n            \n          else\n            #this line is not a progress-stat line; don't format output\n            echo \"$line\"\n          fi\n        fi\n        \n      done\n      local exitcode=${PIPESTATUS[0]}\n    fi\n  fi\n  \n  #display a \"download complete\" message\n  if [ $exitcode == 0 ] && [ \"$quiet\" == 0 ];then\n    \n    #show cursor\n    printf \"\\e[?25h\"\n    \n    #display \"done\" message\n    if [ \"$use\" == aria2c ];then\n      local progress_characters=$(($terminal_width - 5))\n      echo -e \"\\e[0KDone \\e[92m\\e[1m$(for ((i=0; i<$progress_characters; i++)); do printf \"\"; done)\\e[39m\\e[0m\" 1>&2 #clear and print over previous line\n    else\n      echo\n      status_green \"Done\" 1>&2\n    fi\n  elif [ $exitcode != 0 ] && [ \"$quiet\" == 0 ];then\n    #show cursor\n    printf \"\\e[?25h\"\n    \n    echo -e \"\\n\\e[91mFailed to download: $url\\nPlease review errors above.\\e[0m\" 1>&2\n  fi\n  \n  return $exitcode\n}\n\nchmod() { #say what is being made executable\n  status \"Making executable: $2\"\n  command chmod \"$@\"\n  return $?\n}\n\nunzip() { #say what is being extracted\n  #some scripts add a flag to the unzip command before specifying the file.\n  #This checks the first two arguments to display the file being extracted.\n  [ -f \"$1\" ] && status \"Extracting: $1\"\n  [ -f \"$2\" ] && status \"Extracting: $2\"\n  \n  #The -o flag means to overwrite without prompting\n  command unzip -o \"$@\"\n  return $?\n}\n\nsudo_popup() { #just like sudo on passwordless systems like PiOS, but displays a password dialog otherwise. Avoids displaying a password prompt to an invisible terminal.\n  if sudo -n true; then\n    # sudo is available (within sudo timer) or passwordless\n    sudo \"$@\"\n  else\n    # sudo is not available (not within sudo timer)\n    pkexec \"$@\"\n  fi\n}\n\nnproc() { #Reduce the number of compile threads on low-RAM systems\n  #The Pi02 and Pi3A+ have 4 cores but 500MB of RAM. This function reduces the number of threads to use if RAM is low.\n  \n  #Estimation of how much memory is available for starting new applications, without swapping.\n  local available=\"$(free | grep 'Mem:' | awk '{print $7}')\"\n  \n  if [ \"$available\" -gt $((2000*1024)) ] || [ \"$GITHUB_ACTIONS\" == \"true\" ];then\n    #available memory > 2000MB, use normal number of threads\n    command nproc\n  elif [ \"$available\" -gt $((1500*1024)) ];then\n    #1500MB < available memory <= 2000MB, use 3 threads\n    echo 3\n    warning \"Your system has less than 2000MB of available RAM, so this will compile with only 3 threads.\"\n  elif [ \"$available\" -gt $((1000*1024)) ];then\n    #1000MB < available memory <= 1500MB, use 2 threads\n    echo 2\n    warning \"Your system has less than 1500MB of available RAM, so this will compile with only 2 threads.\"\n  else\n    #available memory <= 1000MB, use 1 thread\n    echo 1\n    warning \"Your system has less than 1000MB of available RAM, so this will compile with only 1 thread.\"\n  fi\n}\n#end of command interceptors\n\n#Stop a running api function if user presses Ctrl+C, but avoid doing this if api is sourced in an interactive terminal.\nif [[ $- != *i* ]] ;then\n  trap \"exit 1\" INT\n  cd $HOME\nfi\n\nadd_english\n\n#if this script is being run standalone, set the DIRECTORY variable based on the script's location\nif [[ \"$0\" == */api ]];then\n  #it is necessary to set it now in order for yadflags and yad theme to work as intended.\n  DIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n  export DIRECTORY\n#if being sourced, ensure DIRECTORY variable is set\nelif [ -z \"$DIRECTORY\" ] || [ \"$DIRECTORY\" == \"$HOME\" ] || [ ! -d \"$DIRECTORY\" ] || [ ! -f \"${DIRECTORY}/api\" ] || [ ! -f \"${DIRECTORY}/gui\" ];then\n  echo \"DIRECTORY variable must be set to a valid pi-apps folder. Default folder: $HOME/pi-apps\"\n  return 1\nfi\n\n#set the system GTK theme for yad windows\nguimode=\"$(cat \"${DIRECTORY}/data/settings/App List Style\" 2>/dev/null || echo yad-default)\"\nif [ \"$guimode\" == yad-default ];then\n  export GTK_THEME=''\nelif [[ \"$guimode\" = yad* ]];then\n  export GTK_THEME=${guimode//yad-/}\nelif [ \"$guimode\" == xlunch-light-3d ];then\n  export GTK_THEME=''\nelif [ \"$guimode\" == xlunch-dark-3d ];then\n  export GTK_THEME=Adwaita-dark\nelif [ \"$guimode\" == xlunch-dark ];then\n  export GTK_THEME=Adwaita-dark\nfi\n\n#this array stores flags that are used in all yad windows - saves on the typing and makes it easy to change an attribute on all dialogs from one place.\nyadflags=(--class Pi-Apps --name \"Pi-Apps\" --center --window-icon=\"${DIRECTORY}/icons/logo.png\" --title=\"Pi-Apps\" --separator='\\n')\n\n#determine if host system is 64 bit arm64 or 32 bit armhf\nif [ \"$(od -An -t x1 -j 4 -N 1 \"$(readlink -f /sbin/init)\")\" = ' 02' ];then\n  arch=64\nelif [ \"$(od -An -t x1 -j 4 -N 1 \"$(readlink -f /sbin/init)\")\" = ' 01' ];then\n  arch=32\nelse\n  error \"Failed to detect OS CPU architecture! Something is very wrong.\"\nfi\n\n#Make dual-pane yad windows work correctly on wayland by using xwayland\n#We need support for setting window position for dual-pane yad windows to be supported via a wayland protocol, implemented in compositors, and supported in gtk\n#Relevant draft PRs for the wayland protocol https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/247 https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/249\nexport GDK_BACKEND=x11\n\n# add upstream and original lsb-release info for all scripts to use\n\n# _os_original_* variables are only set for downstream releases (eg: Pop!_OS, Linux Mint, and KDE Neon)\n# this allows for scripts to simply check for the existance of _os_original_* variables and operate differently if found\n# note: Pop!_OS, Linux Mint, and KDE Neon are NOT official Ubuntu flavors (like Kubuntu, Ubuntu MATE, Ubuntu Kylin, Ubuntu Budgie, Lubuntu, Ubuntu Studio, Ubuntu Unity, and Xubuntu)\n# official Ubuntu flavors use ONLY the official Ubuntu repositories and are directly supported by Ubuntu. These other releases are simply \"based\" on Ubuntu, much like Raspbian and PiOS are \"based\" on Debian.\n\n# first check if lsb_release has an upstream option -u\n# if not, check if there is an upstream-release file\n# if not, check if there is a lsb-release.diverted file\n# if not, assume that this is not a ubuntu derivative\n# use mapfile to temporarily store release info for speed\nif [ -z \"$__os_id\" ] || [ -z \"$__os_desc\" ] || [ -z \"$__os_release\" ] || [ -z \"$__os_codename\" ]; then\n  if lsb_release -a -u &>/dev/null; then\n    # This is a Ubuntu Derivative, checking the upstream-release version info\n    mapfile -t os_u < <(lsb_release -s -i -d -r -c -u)\n    export __os_id=\"${os_u[0]}\"\n    export __os_desc=\"${os_u[1]}\"\n    export __os_release=\"${os_u[2]}\"\n    export __os_codename=\"${os_u[3]}\"\n    mapfile -t os < <(lsb_release -s -i -d -r -c)\n    export __os_original_id=\"${os[0]}\"\n    export __os_original_desc=\"${os[1]}\"\n    export __os_original_release=\"${os[2]}\"\n    export __os_original_codename=\"${os[3]}\"\n  elif [ -f /etc/upstream-release/lsb-release ]; then\n    # ubuntu 22.04+ Linux Mint no longer includes the lsb_release -u option\n    # add a parser for the /etc/upstream-release/lsb-release file\n    source /etc/upstream-release/lsb-release\n    export __os_id=\"$DISTRIB_ID\"\n    export __os_desc=\"$DISTRIB_DESCRIPTION\"\n    export __os_release=\"$DISTRIB_RELEASE\"\n    export __os_codename=\"$DISTRIB_CODENAME\"\n    mapfile -t os < <(lsb_release -s -i -d -r -c)\n    export __os_original_id=\"${os[0]}\"\n    export __os_original_desc=\"${os[1]}\"\n    export __os_original_release=\"${os[2]}\"\n    export __os_original_codename=\"${os[3]}\"\n    unset DISTRIB_ID DISTRIB_DESCRIPTION DISTRIB_RELEASE DISTRIB_CODENAME\n  elif [ -f /etc/lsb-release.diverted ]; then\n    # ubuntu 22.04+ Pop!_OS no longer includes the /etc/upstream-release/lsb-release or the lsb_release -u option\n    # add a parser for the new /etc/lsb-release.diverted file\n    source /etc/lsb-release.diverted\n    export __os_id=\"$DISTRIB_ID\"\n    export __os_desc=\"$DISTRIB_DESCRIPTION\"\n    export __os_release=\"$DISTRIB_RELEASE\"\n    export __os_codename=\"$DISTRIB_CODENAME\"\n    mapfile -t os < <(lsb_release -s -i -d -r -c)\n    export __os_original_id=\"${os[0]}\"\n    export __os_original_desc=\"${os[1]}\"\n    export __os_original_release=\"${os[2]}\"\n    export __os_original_codename=\"${os[3]}\"\n    unset DISTRIB_ID DISTRIB_DESCRIPTION DISTRIB_RELEASE DISTRIB_CODENAME\n  else\n    mapfile -t os < <(lsb_release -s -i -d -r -c)\n    export __os_id=\"${os[0]}\"\n    export __os_desc=\"${os[1]}\"\n    export __os_release=\"${os[2]}\"\n    export __os_codename=\"${os[3]}\"\n  fi\nfi\n\n# add CPU op-modes for all scripts to use\nif ([ -z \"$__cpu_op_mode_32\" ] && [ -z \"$__cpu_op_mode_64\" ]) || [ -z \"$__cpu_op_modes\" ]; then\n  if lscpu | grep \"CPU op-mode(s):\" | grep -q \"32-bit, 64-bit\"; then\n    export __cpu_op_modes=\"32/64\"\n    export __cpu_op_mode_32=true\n    export __cpu_op_mode_64=true\n  elif lscpu | grep \"CPU op-mode(s):\" | grep -q \"32-bit\"; then\n    export __cpu_op_modes=\"32\"\n    export __cpu_op_mode_32=true\n  elif lscpu | grep \"CPU op-mode(s):\" | grep -q \"64-bit\"; then\n    export __cpu_op_modes=\"64\"\n    export __cpu_op_mode_64=true\n  fi\nfi\n\n# add /usr/local/bin to path if not currently present which is often not searched by default if /usr/local/bin did not exist on boot.\n# this path will automatically be added on next boot if a binary is placed in it by a pi-apps script\n[[ \"$PATH\" != */usr/local/bin* ]] && export PATH=\"/usr/local/bin:$PATH\"\n\n#if this script is being run standalone, run the specified function\nif [[ \"$0\" == */api ]];then\n  \"$@\"\n  exit $?\nfi\n\nexport DIRECTORY\n"
        },
        {
          "name": "apps",
          "type": "tree",
          "content": null
        },
        {
          "name": "createapp",
          "type": "blob",
          "size": 24.8779296875,
          "content": "#!/bin/bash\nDIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\"\n  exit 1\n}\n\nsource \"${DIRECTORY}/api\" || error \"failed to source ${DIRECTORY}/api\"\n\n#Use 'settings' window icon on all windows of this script\nyadflags=(--class Pi-Apps-Settings --name \"Pi-Apps Settings\" --center --window-icon=\"${DIRECTORY}/icons/settings.png\" --title=\"Pi-Apps\" --separator='\\n')\n\n#you can specify a pre-existing app with variable 1\nif [ ! -z \"$1\" ];then\n  name=\"$1\"\n  step=2\n  editing=yes\nelse\n  name=''\n  step=0\nfi\n\n#start on this step:\n#step=2\n#start with this app name:\n#name='myapp'\n#start with this app type:\n#app_type=package\n\n#ensure imagemagick is installed\nif ! command -v convert >/dev/null ;then\n  yad \"${yadflags[@]}\" --text=\"To resize the images, imagemagick must be installed.\"$'\\n'\"Install now?\" \\\n  --text-align=center --title='Quick question' \\\n  --button=No!\"${DIRECTORY}/icons/exit.png\":1 --button=Yes!\"${DIRECTORY}/icons/check.png\":0\n  button=$?\n  if [ $button == 0 ];then\n    sudo apt install -y --no-install-recommends imagemagick || icon=''\n  else\n    exit 0\n  fi\nfi\n\nwhile true;do\n  \n  #set the app_type: the type of app we're working with. allowed values: 'standard', 'package'\n  if [ -z \"$name\" ];then\n    app_type=''\n  elif [ -z \"$app_type\" ];then\n    if [ \"$(app_type \"$name\")\" == standard ];then\n      app_type=standard\n    elif [ \"$(app_type \"$name\")\" == package ];then\n      app_type=package\n    else\n      app_type=''\n    fi\n  fi\n  echo -e \"\\nName: $name\\napp_type: $app_type\\nStep: $step\"\n  \n  case $step in\n    0) #Introduction\n      echo \"Welcome to the Create App wizard!\n\nWith a few simple steps, your project can take advantage of Pi-Apps' features and be displayed in the app-list.\nThis wizard will save your work as you go.\" | yad \"${yadflags[@]}\" --text-info --fontname=12 --wrap --show-uri \\\n        --image=\"${DIRECTORY}/icons/in-progress.png\" --image-on-top \\\n        --text=\"<a href=\"\\\"\"https://github.com/Botspot/pi-apps/wiki/Creating-an-app\"\\\"\">READ THIS TUTORIAL FIRST!!</a>\" \\\n        --title=\"Create App Wizard\" --width=310 --height=300 \\\n        --button=Cancel!\"${DIRECTORY}/icons/exit.png\":1 \\\n        --button=Next!\"${DIRECTORY}/icons/forward.png\":0 || exit 0\n      step=$((step+1))\n      ;;\n      \n    1) #Choose name of app and its app-type\n      \n      fields=() #this array contains the yad window options\n      \n      if [ -z \"$name\" ];then\n        #if name variable is empty, make the field editable\n        fields+=(--field=\"Name of app:\" \"$name\")\n      else\n        #if name variable is set, make the field read-only\n        fields+=(--field=\"Name of app: <b>$name</b>\":RO '')\n      fi\n      \n      #if the app_type has not already been determined, make it an option\n      if [ -z \"$app_type\" ];then\n        fields+=(--field=\"App type:\":CB 'standard - Use scripts to install the app!package - Will install apt package(s)')\n      elif [ \"$app_type\" == package ];then\n        fields+=(--field=\"App type: <b>package</b>\":RO '')\n      elif [ \"$app_type\" == standard ];then\n        fields+=(--field=\"App type: <b>standard</b>\":RO '')\n      else\n        error \"Unknown app type: '$app_type'\"\n      fi\n      \n      output=\"$(yad \"${yadflags[@]}\" --form \\\n        --title=\"Create App: Step $step\" --width=310 --height=300 --separator='\\n' \\\n        --text=\"Step ${step}: The basics\" \\\n        \"${fields[@]}\" \\\n        --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n        --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n        2>/dev/null)\"\n      button=$? #get exit code to determine which button was pressed\n      \n      echo \"$button\"\n      echo \"Output: ${output}EOO\"\n      \n      if [ \"$button\" == 0 ];then\n        #Next clicked\n        \n        #fill in variables based on yad output\n        [ -z \"$name\" ] && name=\"$(echo \"$output\" | sed -n 1p)\"\n        [ -z \"$app_type\" ] && app_type=\"$(echo \"$output\" | sed -n 2p | awk '{print $1}')\"\n        \n        if [ -z \"$name\" ];then\n          echo 'Name of app may not be left blank!'\n          yad \"${yadflags[@]}\" --title=\"Error\" \\\n            --text=\"Name of app may not be left blank!\" --timeout=10 \\\n            --button=OK:0\n        elif [ -d \"${DIRECTORY}/apps/${name}\" ] && [ \"$app_type\" != \"$(app_type \"$name\")\" ];then\n          #allow switching from package-app to script-app by rewmoving files of old type\n          if [ \"$app_type\" == standard ];then\n            echo -e \"$name was a package-app, but user wants it to be a standard app.\\nRemoving 'packages' file...\"\n            rm -f \"${DIRECTORY}/apps/${name}/packages\"\n          elif [ \"$app_type\" == package ];then\n            echo -e \"$name was a standard app, but user wants it to be a package app.\\nMoving scripts to Trash...\"\n            gio trash \"${DIRECTORY}/apps/${name}/install\" 2>/dev/null\n            gio trash \"${DIRECTORY}/apps/${name}/install-32\" 2>/dev/null\n            gio trash \"${DIRECTORY}/apps/${name}/install-64\" 2>/dev/null\n            gio trash \"${DIRECTORY}/apps/${name}/uninstall\" 2>/dev/null\n          fi\n          \n          step=$((step+1))\n        else\n          #name field populated\n          step=$((step+1))\n          \n          #create app folder\n          mkdir -p \"${DIRECTORY}/apps/${name}\" || error \"failed to create app folder: ${DIRECTORY}/apps/${name}!\"\n        fi\n        \n      elif [ \"$button\" == 2 ];then\n        #previous - don't save changes\n        step=$((step-1))\n      else\n        #like clicking the X or something \n        exit 0\n      fi\n      echo \"at the end of step 1, the step value is $step\"\n      ;;\n      \n    2) #Fill in information about the pre-chosen app name\n      \n      [ -z \"$name\" ] && error \"name variable must be filled for step $step.\"\n      [ ! -d \"${DIRECTORY}/apps/${name}\" ] && error \"The $name app-folder must exist for step $step.\"\n      [ -z \"$app_type\" ] && error \"app_type variable must be filled for step $step.\"\n      \n      fields=() #this array contains the yad window options\n      \n      #if app_type is 'standard', add the website field, icon field, and script-compatibility field\n      if [ \"$app_type\" == standard ];then\n        #make icon field read-only if the icon exists\n        if [ -f \"${DIRECTORY}/apps/${name}/icon-64.png\" ];then\n          fields+=(\"--field=Icon::RO\" \"apps/${name}/icon-64.png\")\n        else\n          #point yad to a nonexistent directory so it opens the file browser to the $HOME directory\n          fields+=(\"--field=Icon::FL\" \"${HOME}/keiucheuchkoec\")\n        fi\n        \n        fields+=(--field=\"Website:\" \"$(cat \"${DIRECTORY}/apps/${name}/website\" 2>/dev/null)\")\n        \n        #if chosen app already has scripts, set cpu architecture compatibility and grey it out, otherwise make it choosable.\n        if [ -z \"$(script_name \"$name\")\" ];then\n          #no scripts found for the app - make it a choice\n          fields+=(\"--field=Compatibility::CB\" \"64bit and 32bit!32bit only!64bit only\")\n          \n        elif [ \"$(script_name \"$name\")\" == 'install' ] || [ \"$(script_name \"$name\")\" == 'install-32 install-64' ];then\n          #Either 'install' or 'install-32 install-64' scripts found.\n          fields+=(\"--field=Compatibility::RO\" \"64bit and 32bit\")\n          \n        elif [ \"$(script_name \"$name\")\" == 'install-32' ];then\n          #if only install-32 script found\n          fields+=(\"--field=Compatibility::RO\" \"32bit only\")\n          \n        elif [ \"$(script_name \"$name\")\" == 'install-64' ];then\n          #if only install-64 script found\n          fields+=(\"--field=Compatibility::RO\" \"64bit only\")\n        fi\n        \n      #if app_type is 'package', add the packages field\n      elif [ \"$app_type\" == package ];then\n        if [ -s \"${DIRECTORY}/apps/${name}/packages\" ];then\n          fields+=(\"--field=Package(s) to install:\" \"$(cat \"${DIRECTORY}/apps/${name}/packages\")\")\n        else\n          #point yad to a nonexistent directory so it opens the file browser to the $HOME directory\n          fields+=(\"--field=Package(s) to install:\" '')\n        fi\n        \n        fields+=(--field=\"Website:\" \"$(cat \"${DIRECTORY}/apps/${name}/website\" 2>/dev/null)\")\n        \n      fi\n      \n      output=\"$(yad \"${yadflags[@]}\" --form --separator='\\n' \\\n        --title=\"Create App: Step $step\" --width=310 --height=600 \\\n        --text=\"Step ${step}: Fill in information about <b>$name</b>.\" \\\n        \"${fields[@]}\" \\\n        --field=\"Description:\":TXT \"$(cat \"${DIRECTORY}/apps/${name}/description\" 2>/dev/null || cat \"${DIRECTORY}/apps/template/description\")\" \\\n        --field=\"Credits:\":TXT \"$(cat \"${DIRECTORY}/apps/${name}/credits\" 2>/dev/null || cat \"${DIRECTORY}/apps/template/credits\")\" \\\n        $([ ! -z $editing ] && echo \"--button=Save!${DIRECTORY}/icons/save.png:4\") \\\n        --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n        --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n        2>/dev/null)\"\n      button=$? #get exit code to determine which button was pressed\n      \n      echo \"$button\"\n      echo \"Output: ${output}EOO\"\n      \n      if [ $button == 2 ];then\n        #previous - don't save changes\n        step=$((step-1))\n      # if -------- next -- or -------- save ----- was clicked\n      elif [ $button == 0 ] || [ $button == 4 ];then\n        \n        #fill out information fields\n        if [ \"$app_type\" == package ];then\n          packages=\"$(echo \"$output\" | sed -n '1p')\"\n          website=\"$(echo \"$output\" | sed -n '2p')\"\n          description=\"$(echo -e \"$(echo \"$output\" | sed -n '3p')\")\"\n          credits=\"$(echo -e \"$(echo \"$output\" | sed -n '4p')\")\"\n          echo -e \"packages=$packages\\ndescription=$description\\ncredits=$credits\"\n          \n          #try to get a program icon based on the package names given\n          if [ ! -f \"${DIRECTORY}/apps/${name}/icon-64.png\" ];then\n            icon=\"$(get_icon_from_package $packages)\"\n            echo \"got this icon: $icon\"\n            if [ -z \"$icon\" ];then\n              icon=\"$(yad \"${yadflags[@]}\" --form --title=\"Icon for $name\" --width=310 --height=400 \\\n                --text=\"Please choose an icon for the $name app:\" \"--field=:FL\" \"${HOME}/keiucheuchkoec\" \\\n                --button=OK)\"\n            else\n              #resize the detected icon to be displayed in the confiromation window\n              tmp_png=\"$(mktemp -u).png\"\n              convert \"$icon\" -resize 64x64 \"$tmp_png\"\n              icon=\"$(yad \"${yadflags[@]}\" --form --title=\"Icon for $name\" --separator='\\n' --width=310 --height=400 \\\n                --image=\"$tmp_png\" --image-on-top \\\n                --text=\"Pi-Apps found an icon from the <b>$(echo \"$packages\" | awk '{print $1}')</b> package.\"$'\\n'\"You can use a different one if you wish.\" \\\n                \"--field=:FL\" \"$icon\" \\\n                --button=OK:0)\"\n            fi\n          fi\n          \n          #Skip the script-creation steps\n          step=$((step+3))\n        else #app_type is standard\n          icon=\"$(echo \"$output\" | sed -n '1p')\"\n          website=\"$(echo \"$output\" | sed -n '2p')\"\n          compatibility=\"$(echo \"$output\" | sed -n '3p')\"\n          description=\"$(echo -e \"$(echo \"$output\" | sed -n '4p')\")\"\n          credits=\"$(echo -e \"$(echo \"$output\" | sed -n '5p')\")\"\n          \n          echo -e \"icon=$icon\\nwebsite=$website\\ncompatibility=$compatibility\\ndescription=$description\\ncredits=$credits\"\n          \n          #translate the compatibility variable from human-readable to machine-readable\n          if [ -z \"$(script_name \"$name\")\" ];then\n            #if app contains no install scripts, then parse yad output\n            #convert compatibility var into machine-readable\n            if [ \"$compatibility\" == \"64bit and 32bit\" ];then\n              compatibility='install-32 install-64'\n            elif [ \"$compatibility\" == \"64bit and 32bit\" ];then\n              compatibility='install'\n            elif [ \"$compatibility\" == \"32bit only\" ];then\n              compatibility='install-32'\n            elif [ \"$compatibility\" == \"64bit only\" ];then\n              compatibility='install-64'\n            fi\n          else #app contains install scripts, so ignore yad window's setting (it was greyed out anyway) and set compatibility to whatever it was already.\n            compatibility=\"$(script_name \"$name\")\"\n          fi\n          \n          #This is an app; proceed to script-creation step\n          step=$((step+1))\n        fi\n        \n        #if icon variable is populated and if file exists\n        if [ ! -z \"$icon\" ] && [ -f \"$icon\" ];then\n          generate_app_icons \"$icon\" \"$name\"\n          echo \"Generated icons from $icon\"\n        fi\n        \n        #if packages field is populated\n        if [ ! -z \"$packages\" ];then\n          echo \"$packages\" > \"${DIRECTORY}/apps/${name}/packages\"\n          echo \"Created ${DIRECTORY}/apps/${name}/packages\"\n        fi\n        \n        #if website field is populated\n        if [ ! -z \"$website\" ] && [ \"$website\" != \"$(cat \"${DIRECTORY}/apps/template/website\")\" ];then\n          echo \"$website\" > \"${DIRECTORY}/apps/${name}/website\"\n          echo \"Created ${DIRECTORY}/apps/${name}/website\"\n        fi\n        \n        #if description field is populated\n        if [ ! -z \"$description\" ] && [ \"$description\" != \"$(cat \"${DIRECTORY}/apps/template/description\")\" ];then\n          echo \"$description\" > \"${DIRECTORY}/apps/${name}/description\"\n          echo \"Created ${DIRECTORY}/apps/${name}/description\"\n        fi\n        \n        #if credits field is populated\n        if [ ! -z \"$credits\" ] && [ \"$credits\" != \"$(cat \"${DIRECTORY}/apps/template/credits\")\" ];then\n          echo \"$credits\" > \"${DIRECTORY}/apps/${name}/credits\"\n          echo \"Created ${DIRECTORY}/apps/${name}/credits\"\n        elif [ -z \"$credits\" ] && [ -f \"${DIRECTORY}/apps/${name}/credits\" ] ;then\n          #clear credits if the user wanted them cleared.\n          echo '' > \"${DIRECTORY}/apps/${name}/credits\"\n        fi\n        \n        #if Save was clicked then exit now\n        if [ $button == 4 ];then\n          exit 0\n        fi\n      else\n        #like clicking the X or something \n        exit 0\n      fi\n      ;;\n      \n    3) #Create install script\n      \n      #ask if two install scripts are necessary, of if both architectures can share 1 script\n      if [ \"$compatibility\" == \"install-32 install-64\" ] && [ -z \"$(script_name \"$name\")\" ];then\n        echo \"In the previous page, you said this app is compatible with 64bit and 32bit.\nDo you want two install scripts, one for 32bit and the other for 64bit?\nOr do you want one combined install script?\" | yad \"${yadflags[@]}\" --text-info --fontname=12 --wrap --show-uri \\\n          --title=\"Install script\" --width=310 --height=400 \\\n          --button=\"Previous!${DIRECTORY}/icons/back.png\":1 \\\n          --button='2 scripts':2 \\\n          --button='1 script':0\n        \n        button=$? #get exit code to determine which button was pressed\n        \n        if [ $button == 1 ];then\n          #button clicked: Previous\n          step=$((step-1))\n          continue #back to top of while loop\n        elif [ ! $button == 0 ] && [ ! $button == 2 ];then\n          #Window manager X, or escape, or terminated\n          exit 0\n        elif [ $button == 0 ];then\n          #button clicked: '1 script'\n          compatibility=install #change compatibility var from 'install-32 install-64' to 'install', to show that only an install script will be created\n        elif [ $button == 2 ];then\n          #button clicked: '2 scripts'\n          true #do nothing, as $compatibility already contains \"install-32 install-64\"\n        fi\n      fi #end of asking for 1 script or 2 scripts\n      \n      #copy right files from template, based on $compatibility variable\n      if [ \"$compatibility\" == \"install-32\" ];then\n        cp -n \"${DIRECTORY}/apps/template/install\" \"${DIRECTORY}/apps/${name}/install-32\"\n        \n      elif [ \"$compatibility\" == \"install-64\" ];then\n        cp -n \"${DIRECTORY}/apps/template/install\" \"${DIRECTORY}/apps/${name}/install-64\"\n        \n      elif [ \"$compatibility\" == \"install\" ];then\n        cp -n \"${DIRECTORY}/apps/template/install\" \"${DIRECTORY}/apps/${name}/install\"\n        \n      elif [ \"$compatibility\" == \"install-32 install-64\" ];then\n        cp -n \"${DIRECTORY}/apps/template/install\" \"${DIRECTORY}/apps/${name}/install-32\"\n        cp -n \"${DIRECTORY}/apps/template/install\" \"${DIRECTORY}/apps/${name}/install-64\"\n      fi\n      \n      #open the correct file in text editor\n      if [ \"$compatibility\" == \"install-32\" ];then\n        text_editor \"${DIRECTORY}/apps/${name}/install-32\" &\n        \n      elif [ \"$compatibility\" == \"install-64\" ];then\n        text_editor \"${DIRECTORY}/apps/${name}/install-64\" &\n        \n      elif [ \"$compatibility\" == \"install-32 install-64\" ];then\n        text_editor \"${DIRECTORY}/apps/${name}/install-64\" &\n        text_editor \"${DIRECTORY}/apps/${name}/install-32\" &\n        \n      elif [ \"$compatibility\" == \"install\" ];then\n        text_editor \"${DIRECTORY}/apps/${name}/install\" &\n      fi\n      \n      #install shellcheck if not installed\n      command -v shellcheck >/dev/null || sudo apt install -y shellcheck\n      \n      #if creating 2 scripts\n      if [ \"$compatibility\" == 'install-32 install-64' ];then\n        \n        yad \"${yadflags[@]}\" --form --on-top \\\n          --title=\"Install scripts\" --width=310 --height=400 \\\n          --text=\"Now it's time to make your install-32 and install-64 scripts.\n\nOne of these scripts will be executed when somebody clicks your app's Install button.\nTwo text editors should have opened and you can create your scripts.\nNeed help? <a href=\"\\\"\"https://github.com/Botspot/pi-apps/wiki/Creating-an-app\"\\\"\">Read the tutorial!</a>\nStill need help? Botspot can try to help you if you <a href=\"\\\"\"https://github.com/Botspot/pi-apps/issues/new/choose\"\\\"\">open in issue.</a>\" \\\n          --field=\"Run install-32 script\":FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"cd $HOME ; DIRECTORY='$DIRECTORY' ; set -a ; source '${DIRECTORY}/api' ; app='$name' ; '${DIRECTORY}/apps/${name}/install-32' | cat ; echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Running install-32 script of $name\"\\\"\"\" \\\n          --field=\"Shellcheck install-32\"!!'Having problems? This utility helps you locate syntax errors.':FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"shellcheck $'${DIRECTORY}/apps/${name}/install-32';echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Shellcheck\"\\\"\"\" \\\n          --field=\"Run install-64 script\":FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"cd $HOME ; DIRECTORY='$DIRECTORY' ; set -a ; source '${DIRECTORY}/api' ; app='$name' ; '${DIRECTORY}/apps/${name}/install-64' | cat ; echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Running install-64 script of $name\"\\\"\"\" \\\n          --field=\"Shellcheck install-64\"!!'Having problems? This utility locates syntax errors.':FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"shellcheck $'${DIRECTORY}/apps/${name}/install-64';echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Shellcheck\"\\\"\"\" \\\n          --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n          --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n          2>/dev/null\n        button=$? #get exit code to determine which button was pressed\n        \n      else #if creating 1 script\n        yad \"${yadflags[@]}\" --form --on-top \\\n          --title=\"Install script\" --width=310 --height=400 \\\n          --text=\"Now it's time to make your ${compatibility} script. This will be executed anytime somebody clicks the Install button.\n\nA text editor should have opened and you can create your install script.\nNeed help? <a href=\"\\\"\"https://github.com/Botspot/pi-apps/wiki/Creating-an-app\"\\\"\">Read the tutorial!</a>\nStill need help? Botspot can try to help you if you <a href=\"\\\"\"https://github.com/Botspot/pi-apps/issues/new/choose\"\\\"\">open in issue.</a>\" \\\n          --field=\"Run ${compatibility} script\":FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"cd $HOME ; DIRECTORY='$DIRECTORY' ; set -a ; source '${DIRECTORY}/api' ; app='$name' ; '${DIRECTORY}/apps/${name}/${compatibility}' | cat ; echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Running ${compatibility} script of $name\"\\\"\"\" \\\n          --field=\"Shellcheck ${compatibility}\"!!'Having problems? This utility locates syntax errors.':FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"shellcheck $'${DIRECTORY}/apps/${name}/${compatibility}';echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Shellcheck\"\\\"\"\" \\\n          --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n          --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n          2>/dev/null\n        button=$? #get exit code to determine which button was pressed\n      fi\n      \n      if [ $button == 0 ];then\n        #next\n        step=$((step+1))\n      elif [ $button == 2 ];then\n        #previous\n        step=$((step-1))\n      else\n        #like clicking the X or something \n        exit 0\n      fi\n      ;;\n      \n    4) #Create uninstall script\n      cp -n \"${DIRECTORY}/apps/template/uninstall\" \"${DIRECTORY}/apps/${name}/uninstall\"\n      \n      text_editor \"${DIRECTORY}/apps/${name}/uninstall\" &\n      \n      #install shellcheck if not installed\n      command -v shellcheck >/dev/null || sudo apt install -y shellcheck\n      \n      output=\"$(yad \"${yadflags[@]}\" --form --on-top \\\n        --title=\"Uninstall script\" --width=310 --height=400 \\\n        --text=\"Now it's time to make your uninstall script. This will be executed anytime somebody clicks the Uninstall button.\nA text editor should have opened... Never mind, you know what to do.\" \\\n        --field=\"Run uninstall script\":FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"cd $HOME ; DIRECTORY='$DIRECTORY' ; set -a ; source '${DIRECTORY}/api' ; app='$name' ; $'${DIRECTORY}/apps/${name}/uninstall' | cat ; echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Running uninstall script of $name\"\\\"\"\" \\\n        --field=\"Shellcheck uninstall\"!!'Having problems? This utility helps you locate syntax errors.':FBTN \"${DIRECTORY}/etc/terminal-run \"\\\"\"shellcheck $'${DIRECTORY}/apps/${name}/uninstall';echo 'Press Enter to exit.';read enter\"\\\"\" \"\\\"\"Shellcheck\"\\\"\"\" \\\n        --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n        --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n        2>/dev/null)\"\n      button=$? #get exit code to determine which button was pressed\n      \n      if [ $button == 0 ];then\n        #next\n        step=$((step+1))\n      elif [ $button == 2 ];then\n        #previous\n        step=$((step-1))\n      else\n        #like clicking the X or something \n        exit 0\n      fi\n      ;;\n      \n    5) #Verify in app list\n      LIST=\"${DIRECTORY}/apps/${name}/icon-24.png\n$name\n\"\\(\"uninstalled\"\\)\" $(echo \"$(cat \"${DIRECTORY}/apps/${name}/description\" 2>/dev/null || echo \"Description unavailable\")\" | head -n1)\"\n      \n      echo -e \"$LIST\" | yad \"${yadflags[@]}\" --list \\\n        --title=\"List view\" --width=310 --height=400 \\\n        --text=\"Make sure everything looks right.\nHere's what it will look like in the app list:\" \\\n        --column=:IMG --column=Name --column=tip:HD --tooltip-column=4 --no-headers \\\n        --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n        --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n        2>/dev/null\n      button=$? #get exit code to determine which button was pressed\n      \n      if [ $button == 0 ];then\n        step=$((step+1))\n      elif [ $button == 2 ];then\n        #go back - if the app is a package, then skip script-creation steps\n        if [ \"$app_type\" == standard ];then\n          step=$((step-1))\n        elif [ \"$app_type\" == package ];then\n          step=$((step-3))\n        fi\n      else\n        #like clicking the X or something \n        exit 0\n      fi\n      ;;\n      \n    6) #Verify in Details window\n      cat \"${DIRECTORY}/apps/${name}/description\" 2>/dev/null | yad \"${yadflags[@]}\" --text-info --fontname=12 --wrap --show-uri \\\n        --text=\"Make sure everything looks right.\nHere's a preview of the Details window:\n- Current status: $(echo \"$(app_status \"$name\")\" | sed 's/corrupted/corrupted (installation failed)/g' | sed 's/disabled/disabled (installation is prevented on your system)/g')\n- Website: <a href=\"\\\"\"$(cat \"${DIRECTORY}/apps/${name}/website\" 2>/dev/null | head -n1)\"\\\"\">$(cat \"${DIRECTORY}/apps/${name}/website\" 2>/dev/null | head -n1)</a>\" \\\n        --title=\"Details window\" --width=700 --height=400 \\\n        --image=\"${DIRECTORY}/apps/${name}/icon-64.png\" --image-on-top \\\n        --button=Previous!\"${DIRECTORY}/icons/back.png\":2 \\\n        --button=Next!\"${DIRECTORY}/icons/forward.png\":0 \\\n        2>/dev/null\n      button=$? #get exit code to determine which button was pressed\n      \n      if [ $button == 0 ];then\n        step=$((step+1))\n      elif [ $button == 2 ];then\n        step=$((step-1))\n      else\n        #like clicking the X or something \n        exit 0\n      fi\n      ;;\n      \n    7) #All done\n      echo \"Your app is located at ${DIRECTORY}/apps/${name}\nTo add your app to the Pi-Apps official repository, put that folder in a .ZIP file and open an issue on the Pi-Apps repository: https://github.com/Botspot/pi-apps/issues/new/choose\" | yad \"${yadflags[@]}\" --text-info \\\n        --text=\"Done!\" \\\n        --fontname=12 --wrap --show-uri \\\n        --image=\"${DIRECTORY}/icons/in-progress.png\" --image-on-top \\\n        --title=\"Create App Wizard\" --width=310 --height=400 \\\n        --button=Previous!\"${DIRECTORY}/icons/back.png\":0 \\\n        --button=Close!\"${DIRECTORY}/icons/exit.png\":1 || exit 0\n      step=$((step-1))\n      ;;\n      \n    *)\n      error \"Unknown step ${step}!\"\n      ;;\n  esac\ndone\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "etc",
          "type": "tree",
          "content": null
        },
        {
          "name": "gui",
          "type": "blob",
          "size": 28.33984375,
          "content": "#!/bin/bash\n\nerror() { #red text and exit 1\n  echo -e \"\\e[91m$1\\e[0m\" 1>&2\n  exit 1\n}\n\nif ! command -v yad &>/dev/null; then\n  error \"YAD needs to be installed to run Pi-Apps. Most likely you did not install Pi-Apps correctly. Please run the install script.\"\nfi\n\nif [[ $(id -u) == 0 ]]; then\n  echo \"Pi-Apps is not designed to be run as root! Please try again as a regular user.\" | yad --center --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n  --width=700 --height=300 --text-info --title=\"Error\" \\\n  --image=\"${DIRECTORY}/icons/error.png\" --image-on-top --fontname=12 \\\n  --button='OK'\n  error \"Pi-Apps is not designed to be run as root! Please try again as a regular user.\"\nfi\n\n# set GUI format versioning\nexport GUI_FORMAT_VERSION=2\n\n#Transition from the GUI that calls itself to the self-contained GUI: when called by the old GUI, kill that yad window and treat this subprocess as the new main thread\nif [ -z \"$1\" ] && [ ! -z \"$2\" ] && [ ! -z \"$3\" ] ;then\n  kill $(ps -fC yad | grep \"yad --class Pi-Apps --name Pi-Apps --center --title=Pi-Apps --image\" | awk '{print $2}')\n  unset YAD_XID #new gui, don't try to get dimensions of the now closed app list\nfi\n\nDIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n\n#check mission-critical scripts and re-download them if they contain a syntax error\n(\n  sleep 10\n  command -v shellcheck >/dev/null || exit 0\n  \n  if shellcheck \"${DIRECTORY}/updater\" --color=always | grep '\\[31m' --before 1 ;then\n    echo \"Downloading updater script to repair syntax error\"\n    errors=\"$(wget -O \"${DIRECTORY}/updater\" 'https://raw.githubusercontent.com/Botspot/pi-apps/master/updater' 2>&1)\" || echo \"$errors\"\n  fi | sed 's/]31m//g'\n  \n  if shellcheck \"${DIRECTORY}/api\" --color=always | grep '\\[31m' --before 1 ;then\n    echo \"Downloading api script to repair syntax error\"\n    errors=\"$(wget -O \"${DIRECTORY}/api\" 'https://raw.githubusercontent.com/Botspot/pi-apps/master/api' 2>&1)\" || echo \"$errors\"\n  fi | sed 's/]31m//g'\n) &\n\nset -a #make all functions in the api available to subprocesses\nsource \"${DIRECTORY}/api\" || error \"failed to source ${DIRECTORY}/api\"\n\n#For systems with older versions of yad, the text color column cannot be left blank. This python script determines the default text color from GTK bindings.\nif [ -z \"${text_color+x}\" ];then\n  #0400 is the latest version\n  yad_version=\"$(zcat /usr/share/doc/yad/NEWS.gz | head -n 1 | tr -cd '0123456789\\n')\"\n  if [ $yad_version -lt 0400 ]; then\n    if command -v python3 &>/dev/null; then\n      python_version=\"python3\"\n    else\n      python_version=\"python2\"\n    fi\n    export text_color=$(echo \"import gi\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\nfrom gi.repository import Gdk\ntv = Gtk.TextView()\nstyle = tv.get_style_context()\ntextcolor = style.get_color(Gtk.StateType.NORMAL)\nprint(Gdk.RGBA.to_string(textcolor))\n\" | $python_version -)\n  else\n    export text_color=\"\"\n  fi\nfi\n\n#display the pi-apps logo in the terminal\ngenerate_logo &\n\n#install dependencies\nrunonce <<\"EOF\"\n  dependencies='yad curl wget aria2 lsb-release software-properties-common apt-utils apt-transport-https gnupg imagemagick bc librsvg2-bin locales shellcheck git wmctrl xdotool x11-utils rsync unzip debsums libgtk3-perl'\n  # Install dependencies if necessary\n  if ! dpkg -s $dependencies >/dev/null 2>&1; then\n    sudo_popup apt install $dependencies -y -f --no-install-recommends\n  fi\nEOF\n\n#run is_supported_system once mostly to check for unsupported ubuntu/debian distros and warn the user with a blocking GUI popup\nrunonce <<\"EOF\"\n  if ! is_supported_system >/dev/null;then\n    text=\"YOUR SYSTEM IS UNSUPPORTED:\n$(is_supported_system)\n\nPi-Apps will disable the sending of any error reports until you have resolved the issue above.\nYour mileage may vary with using Pi-Apps in this state. Expect the majority of apps to be broken.\"\n\n    yadflags=(--class Pi-Apps --name \"Pi-Apps\" --window-icon=\"${DIRECTORY}/icons/logo.png\" --title=\"Pi-Apps\")\n    userinput_func \"$text\" \"Ok\"\n  fi\n  true\nEOF\n\n#Various stuff to run in background (enclosed in brackets so Geany IDE can collapse the code)\n{\nmkdir -p \"${DIRECTORY}/data/status\" \"${DIRECTORY}/data/update-status\" \\\n  \"${DIRECTORY}/data/preload\" \"${DIRECTORY}/data/settings\" \\\n  \"${DIRECTORY}/data/status\" \"${DIRECTORY}/data/update-status\" \\\n  \"${DIRECTORY}/data/categories\"\n\n#check for updates\n\"${DIRECTORY}/updater\" set-status &\ntrap \"kill $! &>/dev/null\" EXIT #kill the above subprocess on exit\n\n#Click pi-apps usage link every time the GUI is run\nshlink_link usage active\n}\n\n#Determine the app list mode. Allowed values: 'yad-*', 'xlunch-*'\nguimode=\"$(cat \"${DIRECTORY}/data/settings/App List Style\")\"\n[ -z \"$guimode\" ] && guimode=yad-default\n\n#In YAD mode, two windows are handled in a side-by-side configuration. As a group, they must be centered on the the screen.\n#In Xlunch mode, the window must be centered, but xlunch only handles absolute offsets.\nget_positions() {\n  #determine screen_width and screen_height\n  if [ -z \"$screen_width\" ] || [ -z \"$screen_height\" ];then\n    screen_dimensions=\"$(xrandr --nograb --current | awk -F 'connected |\\\\+|\\\\('  '/ connected.*[0-9]+x[0-9]+\\+/ && $2 {printf $2 \", \"}' | sed -n -e 's/^.*primary //p' | tr 'x+' ' ' | tr ',+' ' ')\"\n    if [ -z \"$screen_dimensions\" ];then\n      # if screen_dimensions is empty, this could be a single monitor wayland display which does not have the word \"primary\" in the output\n      # workaround is to get the first output returned for the connected display\n      screen_dimensions=\"$(xrandr --nograb --current | awk -F 'connected |\\\\+|\\\\('  '/ connected.*[0-9]+x[0-9]+\\+/ && $2 {printf $2 \", \"}' | tr 'x+' ' ' | tr ',+' ' ')\"\n    fi\n    screen_width=\"$(awk '{print $1}' <<<\"$screen_dimensions\")\"\n    screen_height=\"$(awk '{print $2}' <<<\"$screen_dimensions\")\"\n  fi\n  \n  if [[ \"$guimode\" == yad* ]];then\n    \n    # if this is being run by yad, there should be a yad window id\n    # store in arrary of x and y\n    # this allows for windows to be moved by the user and the second window to still show up where expected\n    main_yad_window=$YAD_XID\n    if [ -n \"${main_yad_window}\" ]; then\n      window_info=$(xwininfo -id $main_yad_window)\n      \n      #skip calculating offsets if yad window is in the same place as last time\n      if [ -z \"$last_window_info\" ] || [ -z \"$geometry1\" ] || [ -z \"$geometry2\" ] || [ \"$last_window_info\" != \"$window_info\" ];then\n        # for speed of execution, we are assuming the order of matches from xwininfo\n        # this is safe as the output order has been standardized for over a decade\n        # this is the location of where the window content starts inside the title bar and window borders (pos x then pos y)\n        main_yad_window_pos=($(echo \"$window_info\" | sed -n 's/Absolute upper-left.*://p'))\n        # these are the dimensions of where the window content starts inside the title bar and window borders (dim x then dim y)\n        main_yad_window_dim=($(echo \"$window_info\" | sed -n 's/Width://p;s/Height://p'))\n        # again, for speed, all border widths are saved to one array\n        # left, right, title, bottom [0, 1, 2, 3]\n        # this is the size of the window borders (including title bar)\n        border_widths=($(xprop _NET_FRAME_EXTENTS -id \"$main_yad_window\" | sed -n  's/_NET_FRAME_EXTENTS.*=//p' | tr ',' '\\n'))\n        #total dimensions for both yad windows side by side\n        if [ $screen_width -le 1000 ] || [ $screen_height -le 600 ];then\n          #gui size for small screens\n          height=${main_yad_window_dim[1]}\n          width=600\n          \n          #width of first window\n          width1=${main_yad_window_dim[0]}\n          #width of second window\n          width2=350\n        else\n          #gui size for large screens\n          height=${main_yad_window_dim[1]}\n          width=800\n          \n          #width of first window\n          width1=${main_yad_window_dim[0]}\n          #width of second window\n          width2=480\n        fi\n        #how far down the top of the title bar of yad window is from the top of the screen\n        yoffset=$((main_yad_window_pos[1]-border_widths[2]))\n        \n        #screen offsets for window 1\n        #use current position of the left side of the main window border\n        xoffset1=$((main_yad_window_pos[0]-border_widths[0]))\n        #screen offsets for window 2\n        #use current position of the right side of the main window border\n        xoffset2=$((xoffset1+border_widths[0]+width1+border_widths[1]))\n        \n        #set completed location arguments for both yad windows\n        geometry1=\"--geometry=${width1}x${height}+${xoffset1}+${yoffset}\"\n        geometry2=\"--geometry=${width2}x${height}+${xoffset2}+${yoffset}\"\n      fi\n    else\n      # default positions when the main window does not exist yet\n      #total dimensions for both yad windows side by side\n      if [ $screen_width -le 1000 ] || [ $screen_height -le 600 ];then\n        #gui size for small screens\n        height=400\n        width=600\n        \n        #width of first window\n        width1=250\n        #width of second window\n        width2=$((width - width1))\n      else\n        #gui size for large screens\n        height=600\n        width=800\n        \n        #width of first window\n        width1=320\n        #width of second window\n        width2=$((width - width1))\n      fi\n      #how far down the top of the title bar of yad window is from the top of the screen\n      yoffset=$(((screen_height/2)-(height/2)))\n      \n      #screen offsets for window 1\n      xoffset1=$(((screen_width/2)-(width/2)))\n      #screen offsets for window 2\n      xoffset2=$(((screen_width/2)-(width/2)+width1))\n      \n      #set completed location arguments for both yad windows\n      geometry1=\"--geometry=${width1}x${height}+${xoffset1}+${yoffset}\"\n      geometry2=\"--geometry=${width2}x${height}+${xoffset2}+${yoffset}\"\n    fi\n    \n  elif [[ \"$guimode\" == xlunch* ]];then\n    #desired dimensions for xlunch window\n    height=700\n    width=800\n    #determine \n    xoffset=$(((screen_width/2)-(width/2)))\n    yoffset=$(((screen_height/2)-(height/2)))\n  else\n    error \"Unrecognized app list style '$guimode'!\"\n  fi\n}\n# run get_positions once incase sometime requires the position value immediatly\nget_positions\n\n#Compile xlunch if required\nif [[ \"$guimode\" == xlunch* ]] && ([ ! -d \"${DIRECTORY}/xlunch\" ] || [ ! -f /usr/bin/xlunch ]);then\n  #signal files\n  rm -f /tmp/xlunchfailed /tmp/xlunchfinished /tmp/terminalexit\n  echo '' > /tmp/terminalexit\n  \"${DIRECTORY}/etc/terminal-run\" \"\n    function error {\n      echo -e \"\\\"\"\\e[91m$1\\e[39m\"\\\"\"\n      echo 'Close this terminal to exit.'\n      echo '' > /tmp/xlunchfailed\n      sleep infinity\n    }\n    trap 'echo \"\\\"\"\"\\\"\" > /tmp/terminalexit' EXIT\n    \n    #uninstall xlunch first\n    sudo rm -rf /etc/xlunch /usr/share/xlunch /usr/bin/xlunch /usr/bin/genentries /usr/bin/updateentries /usr/bin/genentries.desktop.sh /usr/share/icons/hicolor/48x48/apps/xlunch_ghost.png /usr/share/icons/hicolor/48x48/apps/xlunch.png /usr/share/applications/genentries.desktop\n    \n    rm -f /tmp/terminalexit\n    sudo rm -rf /usr/bin/xlunch \"\\\"\"$DIRECTORY/xlunch\"\\\"\" 2>/dev/null\n    sudo apt install -y libimlib2-dev libx11-dev || error 'APT failed to install libimlib2-dev and libx11-dev packages!'\n    cd \"\\\"\"$DIRECTORY\"\\\"\"\n    git clone https://github.com/Tomas-M/xlunch || error 'Failed to clone xlunch repository!'\n    cd \"\\\"\"$DIRECTORY/xlunch\"\\\"\"\n    echo 'Running make...'\n    echo \"\\\"\"\"\\$\"(cat '${DIRECTORY}/xlunch/Makefile' | grep -v 'genentries \\|cp -r svgicons/')\"\\\"\" > '${DIRECTORY}/xlunch/Makefile'\n    make -j8 || error 'make command failed!'\n    echo 'Running sudo make install...'\n    sudo make install || error 'sudo make install failed!'\n    sudo rm -f /usr/share/applications/genentries.desktop\n    cd $HOME\n    if [ ! -f /usr/bin/xlunch ];then\n      error 'xlunch should be installed now, but /usr/bin/xlunch does not exist!'\n    fi\n    echo '' > /tmp/xlunchfinished\n  \" 'Compiling xlunch...'\n  \n  #if terminal doesn't start in 3 seconds, then /tmp/terminalexit will exist.\n  sleep 3\n  \n  #check for an exit status code from the running terminal\n  while true; do\n    if [ -f /tmp/xlunchfinished ];then\n      echo \"xlunch finished installing.\"\n      break\n    elif [ -f /tmp/xlunchfailed ];then\n      #revert back to yad\n      echo 'yad-default' > \"{DIRECTORY}/data/settings/App List Style\"\n      error \"xlunch failed to compile!\"\n    elif [ -f /tmp/terminalexit ];then #if terminal doesn't start in 3 seconds, then /tmp/terminalexit will exist.\n      #revert back to yad\n      echo 'yad-default' > \"{DIRECTORY}/data/settings/App List Style\"\n      error \"The xlunch compilation terminal exited prematurely.\"\n    else\n      sleep 1\n    fi\n  done\nfi\n\n#Determine message of the day. If announcements file missing or over a day old, download it.\nif [ ! -f \"${DIRECTORY}/data/announcements\" ] || [ ! -z \"$(find \"${DIRECTORY}/data/announcements\" -mtime +1 -print)\" ]; then\n  announcements=\"$(wget -qO- https://raw.githubusercontent.com/Botspot/pi-apps-announcements/main/message)\"\n  echo \"$announcements\" > \"${DIRECTORY}/data/announcements\"\nfi & #use $announcements and & here to avoid delaying launch or emptying the file before download completes\n\ndetails_window() { #input: prefix/app\n  local input=\"$1\"\n\n  [ -z \"$input\" ] && return\n  \n  # make sure terminal_manage function is available\n  # the old updater did not source the new api script\n  typeset -f terminal_manage &>/dev/null || { set -a; source \"${DIRECTORY}/api\"; }\n  \n  #app is in format $prefix/$app, so split them out\n  local app=\"$(basename \"$input\")\"\n  local prefix=\"$(dirname \"$input\")\"\n  \n  #add status heading\n  local app_status=\"$(app_status \"${app}\")\"\n  \n  #text to the right of the app icon\n  local abovetext=\"<b>$app</b> ($(sed 's/corrupted/corrupted - installation failed/g' <<<\"$app_status\" | sed 's/disabled/disabled - installation is prevented on your system/g'))\"\n  \n  #If package-app, show what packages it installs\n  if [ -f \"${DIRECTORY}/apps/${app}/packages\" ];then\n    local packages=\"$(pkgapp_packages_required \"$app\")\"\n    if [ -z \"$packages\" ]; then\n      #returned required package list is empty. application cannot be installed\n      #this case cannot be hit if the application is already hidden which it should be\n      yad \"${yadflags[@]}\" --title=Results --width=310 \\\n        --text=\"\"\\\"\"<b>$(list_apps | grep -i -m1 \"^$query\")</b>\"\\\"\" is not compatible with your ${__os_desc} ${arch}-bit OS.\" \\\n        --button=OK:0\n      return\n    fi\n    if [ \"$(wc -w <<<\"$packages\")\" == 1 ];then\n      #if package-app uses only 1 package, use singular case\n      abovetext+=$'\\n'\"- This app installs the <b>${packages}</b> package.\"\n    else\n      #if package-app uses multiple packages, use plural case\n      abovetext+=$'\\n'\"- This app installs these packages: <b>$(sed 's/ /, /g' <<<\"$packages\")</b>\"\n    fi\n  fi\n  \n  #show app's website if available\n  if [ -f \"${DIRECTORY}/apps/${app}/website\" ];then\n    local website=\"$(head -n1 \"${DIRECTORY}/apps/${app}/website\")\"\n    abovetext+=$'\\n'\"- Website: <a href=\"\\\"\"$website\"\\\"\">$website</a>\"\n    \n    #show credits link if available - on same line as website link\n    if [ -f \"${DIRECTORY}/apps/${app}/credits\" ];then\n      abovetext+=\" | <a href=\"\\\"\"file://${DIRECTORY}/apps/${app}/credits\"\\\"\">Credits</a>\"\n    fi\n    \n  else #website unavailable\n    #show credits link standalone, if available\n    if [ -f \"${DIRECTORY}/apps/${app}/credits\" ];then\n      abovetext+=$'\\n'\"- <a href=\"\\\"\"file://${DIRECTORY}/apps/${app}/credits\"\\\"\">Credits</a>\"\n    fi\n  fi\n  \n  local num_users=\"$(usercount \"$app\")\"\n  if [ ! -z \"$num_users\" ] && [ \"$num_users\" -gt 20 ];then\n    #list the number of users, using this printf command to add commas (,) for every thousand number\n    abovetext+=$'\\n'\"- <b>$(printf \"%'d\" \"$num_users\")</b> users\"\n    \n    if [ \"$num_users\" -ge 10000 ];then\n      #if this app has over 10,000 users, add two exclamation points!!\n      abovetext+=\"!!\"\n    elif [ \"$num_users\" -ge 1500 ];then\n      #if this app has over 1500 users, add an exclamation point!\n      abovetext+=\"!\"\n    fi\n  fi\n  \n  #array holding various buttons that may be passed to yad\n  local whichbutton=()\n  \n  if [ -f \"${DIRECTORY}/apps/$app/uninstall\" ] || [ -f \"${DIRECTORY}/apps/$app/install\" ] || [ -f \"${DIRECTORY}/apps/$app/install-$arch\" ];then\n    whichbutton+=(\"--button=Scripts!${DIRECTORY}/icons/shellscript.png!Feel free to see how an app is installed!\"$'\\n'\"Perfect for learning or troubleshooting.:6\")\n  fi\n  if [ \"$(cat \"${DIRECTORY}/data/settings/Show Edit button\")\" == 'Yes' ];then\n    #if edit button enabled, show it\n    whichbutton+=(\"--button=Edit!${DIRECTORY}/icons/edit.png!Make changes to the app:8\")\n  fi\n  \n  #display buttons based on app's installation status\n  if [ \"$app_status\" == 'installed' ];then\n    #if installed, display uninstall button\n    whichbutton+=(\"--button=Uninstall!${DIRECTORY}/icons/uninstall.png:2\")\n  elif [ \"$app_status\" == 'uninstalled' ];then\n    #if uninstalled, display install button\n    whichbutton+=(\"--button=Install!${DIRECTORY}/icons/install.png:4\")\n  elif [ \"$app_status\" == 'disabled' ];then\n    #if disabled, display only an 'enable' button\n    whichbutton+=(\"--button=<b>Enable</b>!!Force this app to install on your system.\"$'\\n'\"This app was disabled for a reason so if you enable it...\"$'\\n'\"YOU HAVE BEEN WARNED.:12\")\n  else\n    #if app status is 'corrupted', and a log file exists for this app, then display a button to view the log file\n    if [ \"$app_status\" == 'corrupted' ];then\n      local logfile=\"$(ls \"$DIRECTORY/logs\"/* -t | grep \"fail-${app}\" | head -n1)\"\n      if [ ! -z \"$logfile\" ];then\n        whichbutton+=(\"--button=Errors!${DIRECTORY}/icons/log-file.png!$app failed to $(echo \"$(basename \"$logfile\")\" | awk -F'-' '{print $1}'). Click this button to view the error output saved in the log file.:14\")\n      fi\n    fi\n    #if status is corrupted or unknown, then show both buttons\n    whichbutton+=(\"--button=Uninstall!${DIRECTORY}/icons/uninstall.png:2\" \"--button=Install!${DIRECTORY}/icons/install.png:4\")\n  fi\n  \n  #only display app icon if it exists\n  if [ -f \"${DIRECTORY}/apps/${app}/icon-64.png\" ];then\n    local imageline=(--image=\"${DIRECTORY}/apps/${app}/icon-64.png\" --image-on-top)\n  fi\n  \n  #Make sure app details window is focused (necessary for openbox window manager)\n  (i=0\n    while [ \"$(xdotool getactivewindow getwindowname)\" != \"Details of ${app}\" ] && [ $i -lt 20 ]; do\n      wmctrl -a \"Details of ${app}\" #Raise the window named \"Details of ${app}\"\n      sleep 0.2\n      i=$((i+1))\n    done) &\n  \n  #display app details window\n  get_positions\n  \n    (cat \"${DIRECTORY}/apps/$app/description\" || echo \"Description unavailable\") | yad \"${yadflags[@]}\" --text-info --fontname=12 --wrap --show-uri \\\n    --text=\"$(sed 's/&/&amp;/g' <<<\"$abovetext\")\" \\\n    \"${imageline[@]}\" \\\n    --title=\"Details of ${app}\" --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n    $geometry2 --skip-taskbar \\\n    \"${whichbutton[@]}\"\n  button=$?\n  \n  case $button in\n  4) #install\n    terminal_manage install \"$app\" &\n    ;;\n    \n  2) #uninstall\n    terminal_manage uninstall \"$app\" &\n    ;;\n    \n  6) #scripts\n    install_script=\"${DIRECTORY}/apps/${app}/$(script_name_cpu \"$app\")\"\n    uninstall_script=\"${DIRECTORY}/apps/${app}/uninstall\"\n    \n    text_editor \"$uninstall_script\" &\n    sleep 0.1\n    text_editor \"$install_script\" &\n    \n    details_window \"$@\" #open details window again\n    ;;\n    \n  8) #edit\n    \"${DIRECTORY}/createapp\" \"$app\"\n    refresh_list\n    ;;\n    \n  12) #enable\n    \n    #remove status file containing 'disabled'\n    rm -f \"${DIRECTORY}/data/status/${app}\"\n    refresh_list &\n    details_window \"$@\" #open details window again\n    ;;\n    \n  14) #viewlog\n    echo \"Viewing error log of $app...\"\n    echo \"Log filepath: $logfile\"\n    \"${DIRECTORY}/etc/viewlog\" \"$logfile\"\n    \n    details_window \"$@\" #open details window again\n    ;;\n  esac\n}\n\nif [[ \"$guimode\" == yad* ]];then\n  \n  #create a named pipe to send app list through to yad\n  pipe=\"$(mktemp -u)\" #get a random filename to work with\n  mkfifo $pipe #make the named pipe\n  #create a named pipe to store detailspid\n  detailspid=\"$(mktemp -u)\" #get a random filename to work with\n  mkfifo $detailspid #make the named pipe\n  trap \"rm -f $pipe; rm -f $detailspid\" EXIT #remove the named pipes on exit\n  echo pipe is $pipe\n  echo detailspid is $detailspid\n  \n  #in background process, send initial app list to yad; first echo line waits until yad is accepting input, then use small delay to prevent items from being missed\n  (echo -e '\\f' > $pipe\n  sleep 0.5\n  \"${DIRECTORY}/preload\" yad '' >> $pipe) &\n  \n  #retrieve a random line from the announcements file for this session\n  motd=\"$(shuf -n 1 \"${DIRECTORY}/data/announcements\")\"\n  \n  refresh_list() { #Refresh the current list of apps in the event of a change\n    if [ ! -z \"$pipe\" ];then\n      echo -e \"\\f\" > \"$pipe\"\n      \"${DIRECTORY}/preload\" yad \"$prefix\" > \"$pipe\" 2>/dev/null\n    fi\n  }\n  \n  kill_details() { #close the details window in 1 second for better UX. Uses the $detailspid variable. To close it immediately add an argument of 0\n    echo \"\" >> $detailspid &\n    detailspidlist=\"$(cat $detailspid)\"\n    (\n    if [ \"$1\" != 0 ];then\n      sleep 1.5\n    fi\n    \n    echo \"$detailspidlist\" | while read line ; do\n      [ ! -z \"$line\" ] && pkill -P \"$line\" 2>/dev/null\n      [ ! -z \"$line\" ] && kill \"$line\" 2>/dev/null\n    done\n    ) &\n  }\n  \n  run_user_selection() { #Function that is run in yad gui to execute user selection\n    yadflags=(--class Pi-Apps --name \"Pi-Apps\" --window-icon=\"${DIRECTORY}/icons/logo.png\" --title=\"Pi-Apps\" --separator='\\n')\n    echo \"YAD_XID is $YAD_XID\"\n    input=\"$3\"\n    if [[ \"$input\" == *'Updates/' ]];then\n      #updater window\n      kill_details\n      \n      get_positions\n      \"${DIRECTORY}/updater\" gui fast $geometry2 --skip-taskbar --close-on-unfocus\n      exitcode=$? #0 if update successful, 1 if list of updates was closed\n      \n      #figure out which prefix we are on and refresh the app list\n      prefix=\"$(echo \"$input\" | sed 's+Updates/$++g')\"\n      \n      if [ $exitcode == 0 ];then\n        refresh_list\n      fi\n    elif [ \"$input\" == 'Search/' ];then\n      #search window\n      kill_details\n      \n      details_window_check(){\n        local input\n        read input\n        [ -z \"$input\" ] && return\n        details_window \"/$input\"\n      }\n      get_positions\n      #show app details window for this selected app\n      yadflags+=(\"$geometry2\" --close-on-unfocus)\n      app_search_gui | details_window_check &\n      echo \"$!\" >> $detailspid &\n      \n    elif [[ \"$input\" == */ ]];then\n      #app folder selected\n      echo -e '\\f' > $pipe #clear the yad list\n      \"${DIRECTORY}/preload\" yad \"${input::-1}\" >> $pipe #send yad the app-list - derived from folder name but dropping the final slash character\n      \n    elif [[ \"$input\" == 'YAD_XID is'* ]];then\n      YAD_XID=\"$(echo \"$input\" | awk '{print $3}')\"\n    elif [ ! -z \"$input\" ];then #app details window\n      \n      get_positions\n      \n      #show app details window, and close the previous one\n      kill_details\n      details_window \"$input\" &\n      echo \"$!\" >> $detailspid &\n    fi\n  }\n  { yad \"${yadflags[@]}\" \\\n    --image=\"${DIRECTORY}/icons/logo-64.png\" --image-on-top --text \"$motd\" \\\n    --list --no-headers --column=:IMG  --column=Name --column=Sysname:HD --column=tip:HD --column=@fore@:HD \\\n    --separator='\\n' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n    --tooltip-column=4 \\\n    --dclick-action \"bash -c \"\\\"\"run_user_selection %s\"\\\"\"\" --select-action=\"bash -c \"\\\"\"run_user_selection %s\"\\\"\"\" \\\n    --button=\"!${DIRECTORY}/icons/search.png\"!'Search':\"bash -c \"\\\"\"run_user_selection '' '' Search/\"\\\"\"\" \\\n    --button=\"!${DIRECTORY}/icons/options.png\"!'Settings':2 \\\n    \"$geometry1\"; button=$?; kill \"$!\"; } < <(exec tail -f --retry $pipe)\n  \n  kill_details 0 #immediately close details window without delay\n  unset YAD_XID #avoid trying to get dimensions of a now closed yad window (fixes badWindow error in get_positions after returning from settings)\n  \n  if [ \"$button\" == 2 ];then\n  \n    # remove pipe early so that nothing attempts to write to it\n    rm -f \"$pipe\"\n    rm -f \"$detailspid\"\n    \n    \"${DIRECTORY}/settings\"\n    \"${DIRECTORY}/gui\" \"$@\" #run new instance of this script\n  fi\n\n  #END of yad main window\n  \nelif [[ \"$guimode\" == xlunch* ]];then\n  \n  #create a named pipe to send app list through to yad\n  pipe=\"$(mktemp -u)\" #get a random filename to work with\n  mkfifo $pipe #make the named pipe\n  trap \"rm $pipe\" EXIT #remove this named pipe on exit\n  echo pipe is $pipe\n  \n  #disabled, but too cool to remove: this can make the transparent background of xlunch blurry - like Windows 7\n  if false;then\n    scrot -a \"$((xoffset+1)),$((yoffset+33)),${width},${height}\" blur.png #blur_init.png\n    convert -blur 10x5 ~/blur.png ~/blur.png\n  fi\n  \n  #Depending on the xlunch theme, different arguments will be used.\n  if [ \"$guimode\" == xlunch-light-3d ];then\n    #light mode\n    xlunchflags=(--multiple --dontquit -WoCS -s 64 --bc e0e0e000 --tc 000000 --pc 6060ffff --hc ffffff50 \\\n      -p \"Search: \" -a -c $([ $width -lt 550 ] && echo 1 || echo 2) --title \"Pi-Apps: Raspberry Pi app store\" \\\n      --icon \"${DIRECTORY}/icons/logo.png\" --scrollbarcolor ffffff40 --scrollindicatorcolor 0000ff80 \\\n      --width $width --height $height --xposition $xoffset --yposition $yoffset \\\n      --button \"${DIRECTORY}/icons/logo-3d.png;;$((($width/2)-(300/2))),0;:exec echo pi-apps-homepage\" \\\n      --button \"${DIRECTORY}/icons/settings-dark.png;;$(($width-140)),30;:exec echo pi-apps-settings\" \\\n      -g \"${DIRECTORY}/icons/background-3d.png\")\n  elif [ \"$guimode\" == xlunch-dark-3d ];then\n    #dark mode, 3d opaque version\n    xlunchflags=(--multiple --dontquit -WoCS -s 64 --bc ffffff00 --tc DCDDDE --pc ffffffa0 --hc ffffff30 \\\n      -p \"Search: \" -a -c $([ $width -lt 550 ] && echo 1 || echo 2) --title \"Pi-Apps: Raspberry Pi app store\" \\\n      --icon \"${DIRECTORY}/icons/logo.png\" --scrollbarcolor ffffff20 --scrollindicatorcolor ffffff40 \\\n      --width $width --height $height --xposition $xoffset --yposition $yoffset \\\n      --button \"${DIRECTORY}/icons/logo-3d-dark.png;;$((($width/2)-(300/2))),0;:exec echo pi-apps-homepage\" \\\n      --button \"${DIRECTORY}/icons/settings-light.png;;$(($width-140)),30;:exec echo pi-apps-settings\" \\\n      -g \"${DIRECTORY}/icons/background-3d-dark.png\")\n  else\n    #dark mode, transparent version\n    xlunchflags=(--multiple --dontquit -WoCS -s 64 --bc 000000A0 --tc ffffffff --pc 6060ffff --hc ffffff30 \\\n      -p \"Search: \" -a -c $([ $width -lt 550 ] && echo 1 || echo 2) --title \"Pi-Apps: Raspberry Pi app store\" \\\n      --icon \"${DIRECTORY}/icons/logo.png\" --scrollbarcolor ffffff40 --scrollindicatorcolor 0000ff80 \\\n      --width $width --height $height --xposition $xoffset --yposition $yoffset \\\n      --button \"${DIRECTORY}/icons/logo-128.png;;$((($width/2)-(128/2))),0;:exec echo pi-apps-homepage\" \\\n      --button \"${DIRECTORY}/icons/logo-text.png;;$([ -z \"$prefix\" ] && echo '45' || echo '65'),$([ -z \"$prefix\" ] && echo '10' || echo '0');:exec echo pi-apps-homepage\" \\\n      --button \"${DIRECTORY}/icons/settings-light.png;;$(($width-140)),30;:exec echo pi-apps-settings\")\n  fi\n  \n  \n  #in background process, send initial app list to xlunch; first echo line waits until xlunch is accepting input\n  (\n    #set initial value to make xlunch keep listening\n    echo 'botspot is cool' > $pipe\n    echo \"$(\"${DIRECTORY}/preload\" xlunch '')\" > $pipe) &\n  \n  #read pipe      pipe to xlunch               read output of xlunch\n  tail -f --retry $pipe | xlunch \"${xlunchflags[@]}\" | while read -r input; do\n    echo \"Received '$input'\"\n    \n    if [ \"$input\" == 'Updates/' ];then\n      echo > $pipe #clear list\n      \n      \"${DIRECTORY}/updater\" gui fast --skip-taskbar --close-on-unfocus\n      exitcode=$? #0 if update successful, 1 if list of updates was closed\n      \n      #refresh main level\n      \"${DIRECTORY}/preload\" xlunch '' > $pipe\n      \n    #category selected\n    elif [[ \"$input\" == */ ]];then\n      echo > $pipe #clear list\n      \"${DIRECTORY}/preload\" xlunch \"$(echo \"$input\" | sed 's+/$++g')\" > $pipe\n      \n    #pi-apps logo button clicked - go to homepage in web browser\n    elif [ \"$input\" == 'pi-apps-homepage' ];then\n      x-www-browser \"$(cat \"${DIRECTORY}/etc/git_url\")\" &\n      \n    #Settings button clicked\n    elif [ \"$input\" == 'pi-apps-settings' ];then\n      #close xlunch\n      echo ':quit' > $pipe\n      \n      #run settings, then run pi-apps gui\n      \"${DIRECTORY}/settings\"\n      \"${DIRECTORY}/gui\" \"$@\"\n      \n      #exit this script\n      exit 0\n      \n    #app selected\n    else\n      echo > $pipe #clear list\n      \n      #in subprocess, open details window for app\n      geometry2=\"--center --height=$((height/2)) --width=$width\" details_window \"$input\"\n      \n      #show app list again\n      \"${DIRECTORY}/preload\" xlunch \"$(dirname \"$input\" | sed 's/^.$//g')\" > $pipe\n    fi\n  done\n  \nfi\n"
        },
        {
          "name": "icons",
          "type": "tree",
          "content": null
        },
        {
          "name": "install",
          "type": "blob",
          "size": 7.111328125,
          "content": "#!/bin/bash\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\"\n  exit 1\n}\n\ncd \"$HOME\"\n\n#ensure non-root\nif [[ \"$(id -u)\" == 0 ]]; then\n  error \"Pi-Apps is not designed to be installed as root! Please try again as a regular user.\"\nfi\n\n#ensure debian\ncommand -v apt >/dev/null || error \"apt: command not found. Most likely this system is not running Debian.\"\n\n#Ensure running arm processor\nif uname -m | grep -qi 'x86\\|i686\\|i386' ;then\n  error \"Pi-Apps is not supported on non-ARM CPU architectures. We encourage you to use your distro's app store, like Gnome Software or Discover Software Center.\"\nfi\n\nsudo apt update || error \"The command 'sudo apt update' failed. Before Pi-Apps will work, you must fix your apt package-management system.\"\n\n#install dependencies\ndependencies='yad curl wget aria2 lsb-release software-properties-common apt-utils apt-transport-https gnupg imagemagick bc librsvg2-bin locales shellcheck git wmctrl xdotool x11-utils rsync unzip debsums libgtk3-perl'\n\nif ! dpkg -s $dependencies &>/dev/null ;then\n  sudo apt install $dependencies -y -f --no-install-recommends || error \"Pi-Apps dependencies failed to install and so the Pi-Apps install has been aborted. Before Pi-Apps can be installed you must solve any errors above.\"\nfi\n\n#remove annoying \"YAD icon browser\" launcher\nsudo rm -f /usr/share/applications/yad-icon-browser.desktop\n\n#download pi-apps if folder missing\nDIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\nif [ -z \"$DIRECTORY\" ] || [ \"$DIRECTORY\" == \"$HOME\" ] || [ \"$DIRECTORY\" == bash ] || [ ! -f \"${DIRECTORY}/api\" ] || [ ! -f \"${DIRECTORY}/gui\" ];then\n  DIRECTORY=\"$HOME/pi-apps\"\nfi\ndownloaded=0 #track if pi-apps was downloaded this time\n\n#Re-download pi-apps folder in all cases if pi-apps already exists\n#users expect to use the install script to \"restore\" a working pi-apps install in incase their local version is somehow not working or corrupted\nif [ -d \"$DIRECTORY\" ];then    \n  rm -rf ~/pi-apps-forced-update\n  \n  echo \"Reinstalling Pi-Apps...\"\n  downloaded=1\n  output=\"$(git clone --depth 1 https://github.com/Botspot/pi-apps ~/pi-apps-forced-update 2>&1)\"\n  if [ $? != 0 ] || [ ! -d \"$DIRECTORY\" ];then\n    error \"Pi-Apps download failed!\\ngit clone output was: $output\"\n  fi\n  cp -af \"${DIRECTORY}/data\" ~/pi-apps-forced-update\n  cp -af \"${DIRECTORY}/apps\" ~/pi-apps-forced-update\n  rm -rf \"$DIRECTORY\"\n  mv -f ~/pi-apps-forced-update \"$DIRECTORY\"\n  \n#if pi-apps folder does not exist, download it\nelif [ ! -d \"$DIRECTORY\" ];then\n  echo \"Downloading Pi-Apps...\"\n  downloaded=1\n  output=\"$(git clone --depth 1 https://github.com/Botspot/pi-apps \"$DIRECTORY\" 2>&1)\"\n  if [ $? != 0 ] || [ ! -d \"$DIRECTORY\" ];then\n    error \"Pi-Apps download failed!\\ngit clone output was: $output\"\n  fi\n  #click new installation analytics link\n  \"${DIRECTORY}/api\" shlink_link script install\nfi\n\n#Past this point, DIRECTORY variable populated with valid pi-apps directory\n\n#if ChromeOS, install lxterminal\nif command -v garcon-terminal-handler >/dev/null ;then\n  echo \"In order to install apps on ChromeOS, a working terminal emulator is required.\nInstalling lxterminal in 10 seconds... (press Ctrl+C to cancel)\"\n  sleep 10\n  sudo apt install -yf lxterminal || error \"Failed to install lxterminal on ChromeOS!\"\nfi\n\n#menu button\nif [ ! -f ~/.local/share/applications/pi-apps.desktop ];then\n  echo \"Creating menu button...\"\nfi\nmkdir -p ~/.local/share/applications\nif [ -f /etc/xdg/menus/lxde-pi-applications.menu ];then #If on PiOS, place launcher in Accessories as it has always been there and is more intuitive there\necho \"[Desktop Entry]\nName=Pi-Apps\nComment=Raspberry Pi App Store for open source projects\nExec=${DIRECTORY}/gui\nIcon=${DIRECTORY}/icons/logo.png\nTerminal=false\nStartupWMClass=Pi-Apps\nType=Application\nCategories=Utility\nStartupNotify=true\" > ~/.local/share/applications/pi-apps.desktop\nelse #if not on PiOS, place launcher in Preferences to match the wider decision of putting app installers there (see PR #2388)\necho \"[Desktop Entry]\nName=Pi-Apps\nComment=Raspberry Pi App Store for open source projects\nExec=${DIRECTORY}/gui\nIcon=${DIRECTORY}/icons/logo.png\nTerminal=false\nStartupWMClass=Pi-Apps\nType=Application\nCategories=Utility;System;PackageManager;\nStartupNotify=true\" > ~/.local/share/applications/pi-apps.desktop\nfi\nchmod 755 ~/.local/share/applications/pi-apps.desktop\ngio set ~/.local/share/applications/pi-apps.desktop \"metadata::trusted\" yes\n\n#copy menu button to Desktop\nmkdir -p ~/Desktop\ncp -f ~/.local/share/applications/pi-apps.desktop ~/Desktop/\n\nchmod 755 ~/Desktop/pi-apps.desktop\ngio set ~/Desktop/pi-apps.desktop \"metadata::trusted\" yes\n\n#copy icon to local icons directory (necessary on some wayland DEs like on PiOS Wayfire)\nmkdir -p ~/.local/share/icons\ncp -f ${DIRECTORY}/icons/logo.png ~/.local/share/icons/pi-apps.png\ncp -f ${DIRECTORY}/icons/settings.png ~/.local/share/icons/pi-apps-settings.png\n\n#settings menu button\nif [ ! -f ~/.local/share/applications/pi-apps-settings.desktop ];then\n  echo \"Creating Settings menu button...\"\nfi\necho \"[Desktop Entry]\nName=Pi-Apps Settings\nComment=Configure Pi-Apps or create an App\nExec=${DIRECTORY}/settings\nIcon=${DIRECTORY}/icons/settings.png\nTerminal=false\nStartupWMClass=Pi-Apps-Settings\nType=Application\nCategories=Settings;\nStartupNotify=true\" > ~/.local/share/applications/pi-apps-settings.desktop\n\nif [ ! -f ~/.config/autostart/pi-apps-updater.desktop ];then\n  echo \"Creating autostarted updater...\"\nfi\nmkdir -p ~/.config/autostart\necho \"[Desktop Entry]\nName=Pi-Apps Updater\nExec=${DIRECTORY}/updater onboot\nIcon=${DIRECTORY}/icons/logo.png\nTerminal=false\nStartupWMClass=Pi-Apps\nType=Application\nX-GNOME-Autostart-enabled=true\nHidden=false\nNoDisplay=false\" > ~/.config/autostart/pi-apps-updater.desktop\n\nmkdir -p \"${DIRECTORY}/data/status\" \"${DIRECTORY}/data/update-status\" \\\n  \"${DIRECTORY}/data/preload\" \"${DIRECTORY}/data/settings\" \\\n  \"${DIRECTORY}/data/status\" \"${DIRECTORY}/data/update-status\" \\\n  \"${DIRECTORY}/data/categories\"\n\n#pi-apps terminal command\nif [ ! -f /usr/local/bin/pi-apps ] || ! cat /usr/local/bin/pi-apps | grep -q \"${DIRECTORY}/gui\" ;then\n  echo \"#!/bin/bash\n${DIRECTORY}/gui\"' \"$@\"' | sudo tee /usr/local/bin/pi-apps >/dev/null\n  sudo chmod +x /usr/local/bin/pi-apps\nfi\n\n#check if system is broken\nerrors=\"$(\"${DIRECTORY}/api\" is_supported_system)\" || error \"$errors\"\n\n#preload app list\nif [ ! -f \"$DIRECTORY/data/preload/LIST-\" ];then\n  echo \"Preloading app list...\"\nfi\n\"${DIRECTORY}/preload\" yad &>/dev/null\n\n#Run runonce entries\n\"${DIRECTORY}/etc/runonce-entries\" &>/dev/null\n\n#Determine message of the day. If announcements file missing or over a day old, download it.\nif [ ! -f \"${DIRECTORY}/data/announcements\" ] || [ ! -z \"$(find \"${DIRECTORY}/data/announcements\" -mtime +1 -print)\" ]; then\n  wget https://raw.githubusercontent.com/Botspot/pi-apps-announcements/main/message -qO \"${DIRECTORY}/data/announcements\"\nfi\n\nif [ $downloaded == 1 ];then\n  echo \"Installation complete. Pi-Apps can be launched from the start menu or by running the command 'pi-apps'.\"\n  echo \"Further explanation for how to use Pi-Apps can be found on our getting started webpage: https://pi-apps.io/wiki/getting-started/running-pi-apps/\"\nelse\n  echo -e \"Please note that Pi-Apps has NOT been freshly downloaded, because $DIRECTORY already exists.\"\nfi\n"
        },
        {
          "name": "manage",
          "type": "blob",
          "size": 32.66015625,
          "content": "#!/bin/bash\n{ #prevents errors if script was modified while in use\n\n#$1 is an action, like install\n#$2 is app name, like Arduino\n\nDIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\"\n  exit 1\n}\n\nif [[ $(id -u) == 0 ]]; then\n  error \"Pi-Apps is not designed to be run as root! Please try again as a regular user.\"\nfi\n\nif [ -z \"$1\" ];then\n  error \"You need to specify an operation, and in most cases, which app to operate on.\"\nfi\n\nset -a #make all functions in the api available to apps\nsource \"${DIRECTORY}/api\" || error \"failed to source ${DIRECTORY}/api\"\n\n#run is_supported_system once mostly to check for unsupported ubuntu/debian distros and warn the user with a blocking GUI popup\nrunonce <<\"EOF\"\n  if ! is_supported_system >/dev/null;then\n    text=\"YOUR SYSTEM IS UNSUPPORTED:\n$(is_supported_system)\n\nPi-Apps will disable the sending of any error reports until you have resolved the issue above.\nYour mileage may vary with using Pi-Apps in this state. Expect the majority of apps to be broken.\"\n\n    yadflags=(--class Pi-Apps --name \"Pi-Apps\" --window-icon=\"${DIRECTORY}/icons/logo.png\" --title=\"Pi-Apps\")\n    userinput_func \"$text\" \"Ok\"\n  fi\n  true\nEOF\n\nvalidate_apps_gui() { #Given a list of actions and apps, graphically notify the user if there is a problem or ask for confirmation. Result is sent to stdout.\n  #action and app are separated by semicolon. (;)\n  #example line of input on $1: \"install;Zoom\"\n  \n  local IFS=$'\\n'\n  \n  local queue=\"$1\"\n  local action\n  local app\n  local line\n  \n  #Ensure that the first word of each line is 'install' or 'uninstall' or 'update' or 'refresh' or 'update-file'\n  local i=1 #track the line number in queue\n  for line in $queue ;do\n    action=\"$(echo \"$line\" | awk -F ';' '{print $1}')\"\n    \n    if [ \"$action\" != install ] && [ \"$action\" != uninstall ] && [ \"$action\" != update ] && [ \"$action\" != refresh ] && [ \"$action\" != update-file ];then\n      warning \"illegal mode: '$action' Removing this line from the queue\"\n      \n      #remove the app from list\n      queue=\"$(echo \"$queue\" | sed ${i}d)\"\n    fi\n    \n    i=$((i+1))\n  done\n  [ -z \"$queue\" ] && exit 0\n  \n  #Ensure that each app-name is valid\n  local i=1 #track the line number in queue\n  for line in $queue ;do\n    action=\"$(echo \"$line\" | awk -F ';' '{print $1}')\"\n    app=\"$(echo \"$line\" | awk -F ';' '{print $2}')\"\n    \n    if [ \"$action\" == update-file ];then\n      # the current line is a pseudo-action used to update a file\n      # skip app validation\n      true\n    elif ([ \"$action\" == update ] || [ \"$action\" == refresh ]) && [ ! -d \"${DIRECTORY}/update/pi-apps/apps/${app}\" ];then\n      \n      yad --class Pi-Apps --name \"Pi-Apps\" --text=\"Invalid app \"\\\"\"<b>$app</b>\"\\\"\". Cannot $action it.\" \\\n        --text-align=center --center --title='Error' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n        --button=OK!\"${DIRECTORY}/icons/check.png\":0\n      \n      #remove the app from list\n      queue=\"$(echo \"$queue\" | sed ${i}d)\"\n    elif [ \"$action\" != update ] &&  [ \"$action\" != refresh ] && [ ! -d \"${DIRECTORY}/apps/${app}\" ];then\n      yad --class Pi-Apps --name \"Pi-Apps\" --text=\"Invalid app \"\\\"\"<b>$app</b>\"\\\"\". Cannot $action it.\" \\\n        --text-align=center --center --title='Error' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n        --button=OK!\"${DIRECTORY}/icons/check.png\":0\n      \n      #remove the app from list\n      queue=\"$(echo \"$queue\" | sed ${i}d)\"\n    fi\n    \n    i=$((i+1))\n  done\n  [ -z \"$queue\" ] && exit 0\n  \n  #if trying to install an already-installed app, or trying to uninstall and already-uninstalled app, ask for confirmation\n  i=1 #track the line number in queue\n  for line in $queue ;do\n    action=\"$(echo \"$line\" | awk -F ';' '{print $1}')\"\n    app=\"$(echo \"$line\" | awk -F ';' '{print $2}')\"\n    \n    if [ \"$action\" == update-file ];then\n      # the current line is a pseudo-action used to update a file\n      # skip app validation\n      true\n    elif [ \"$(app_status \"${app}\")\" == \"${action}ed\" ];then\n      yad --class Pi-Apps --name \"Pi-Apps\" --text=\"<b>$app</b> is already ${action}ed. Are you sure you want to $action it again?\" \\\n        --text-align=center --center --title='Quick question' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n        --button=No!\"${DIRECTORY}/icons/exit.png\":1 --button=Yes!\"${DIRECTORY}/icons/check.png\":0\n      \n      if [ $? != 0 ];then\n        #user clicked No, so remove the app from list\n        queue=\"$(echo \"$queue\" | sed ${i}d)\"\n      fi\n    fi\n    \n    i=$((i+1))\n  done\n  [ -z \"$queue\" ] && exit 0\n  \n  #Check if any apps are updatable and ask user if they really want to INSTALL an outdated version. (This is skipped if uninstalling apps)\n  \n  local update_queue=''\n  for line in $queue ;do\n    action=\"$(echo \"$line\" | awk -F ';' '{print $1}')\"\n    app=\"$(echo \"$line\" | awk -F ';' '{print $2}')\"\n    \n    if [ $action == install ];then\n      #determine the filename for the app's script to be run\n      script_name_cpu=\"$(script_name_cpu \"$app\")\"\n      \n      #if the app-script doesn't match version in update folder\n      if [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/${script_name_cpu}\" ] && ! files_match \"${DIRECTORY}/update/pi-apps/apps/${app}/${script_name_cpu}\" \"${DIRECTORY}/apps/${app}/${script_name_cpu}\" ;then\n        \n        \"${DIRECTORY}/updater\" set-status &>/dev/null & #check for updates in background, so if user chooses \"Yes\", the updater will be guaranteed to have the app listed\n        \n        yad --class Pi-Apps --name \"Pi-Apps\" --text=\"Hold up...\"$'\\n'\"<b>$app</b>'s $script_name_cpu script does not match the online version. Either you are about to install an outdated version, or you've made changes to the script yourself.\"$'\\n\\n'\"<b>Would you like to install the newest official version of $app?</b>\" \\\n          --text-align=center --center --title='Quick question' --window-icon=\"${DIRECTORY}/icons/logo.png\" --width=400 \\\n          --image=\"${DIRECTORY}/apps/$app/icon-64.png\" \\\n          --button=\"I know what I am doing, Install current version\"!\"${DIRECTORY}/icons/forward.png\":1 --button=\"Yes, Install newest official version\"!\"${DIRECTORY}/icons/download.png\"!\"In most cases, this is the button you should click.\":0\n        \n        if [ $? == 0 ];then\n          if [ -z \"$update_queue\" ] && ! files_match \"${DIRECTORY}/api\" \"${DIRECTORY}/update/pi-apps/api\" ;then #if user clicked Yes, update api (for potential new functions) and the app\n            update_queue=\"update-file;api\"$'\\n'\"refresh;$app\"\n          elif [ -z \"$update_queue\" ];then\n            update_queue=\"refresh;$app\"\n          else\n            update_queue+=$'\\n'\"refresh;$app\"\n          fi\n        fi\n      fi\n    fi\n  done\n  \n  if [ ! -z \"$update_queue\" ]; then\n    # place all updates before queue input to validate_apps_gui\n    queue=\"$update_queue\"$'\\n'\"$queue\"\n  fi  \n  echo \"$queue\"\n}\n\n#remove old mcpi repositories - this runonce is here so that terminal-only users will still receive the fix.\n(runonce <<\"EOF\"\n  if [ -f /etc/apt/sources.list.d/Alvarito050506_mcpi-devs.list ];then\n    sudo rm -f /etc/apt/sources.list.d/Alvarito050506_mcpi-devs.list\n  fi\n  if [ -f /etc/apt/sources.list.d/mcpi-revival.list ];then\n    sudo rm -f /etc/apt/sources.list.d/mcpi-revival.list\n    sudo rm -f /etc/apt/trusted.gpg.d/mcpi-revival.gpg\n  fi\n  \n  if dpkg -l box86-no-binfmt-restart &>/dev/null ;then\n    sudo apt purge -y box86-no-binfmt-restart\n    sudo apt update\n    sudo apt install -y box86\n  fi\nEOF\n) &>/dev/null\n\n#An apt repository's Packages file can be corrupted so that an apt update will silently fail. See: https://bugs.launchpad.net/ubuntu/+source/apt/+bug/1809174\n#This line will fix the problem by removing any zero-size Packages files.\nremoval_list=\"$(find /var/lib/apt/lists -type f -name '*Packages' -size 0 2>/dev/null)\"\nif [ ! -z \"$removal_list\" ]; then\n  if [ x$DISPLAY != x ] ; then\n    while ! sudo -n true; do\n      yad --class Pi-Apps --name \"Pi-Apps\" --title=\"Broken Local Packages Repo Detected\" --text=\"Please enter your user password \\nso pi-apps can attempt a repair:\" --image=\"dialog-password\" --entry --hide-text 2>/dev/null | sudo -S echo \"\" 2>&1 >/dev/null\n    done\n  fi\n  echo \"$removal_list\" | xargs sudo rm -f\nfi\n\nmkdir -p \"${DIRECTORY}/data/status\" \"${DIRECTORY}/data/update-status\" \"${DIRECTORY}/logs\"\n\n#remove week-old logfiles\nfind \"${DIRECTORY}/logs\" -type f -mtime +6 -exec rm -f {} \\; &>/dev/null &\n\n#check if hardware and OS is supported\nif [ \"$1\" != 'daemon' ]; then\n  if [ \"$supported\" == \"yes\" ] || [ \"$supported\" == \"no\" ]; then\n    true\n  else\n    if is_supported_system >/dev/null;then\n      export supported=yes\n      export unsupported_message=''\n    else\n      export supported=no\n      export unsupported_message=\"$(is_supported_system)\"\n    fi\n  fi\nfi\n\nif [ \"$1\" == 'daemon' ];then\n  #Daemon to run in the background and install/uninstall/update apps as the user makes selections\n  #This allows the user to queue up a list of actions that will run sequentially.\n  \n  #this folder will contain the runtime files necessary to make the daemon work.\n  mkdir -p \"${DIRECTORY}/data/manage-daemon\"\n  \n  #a list of pending steps is displayed with yad. This function adds an item to the list\n  add_to_list() { # $1 is action, $2 is app, $3 is exit code status ('0' = success), $4 is output location (usually blank, but can be 'stdout')\n    local action=\"$1\"\n    local app=\"$2\"\n    local status=\"$3\"\n    \n    # $4 specifies where the output should go. Default is to send the output to the yadlist pipe, but if value is 'stdout', output to stdout.\n    local output=\"$4\"\n    \n    #choose an icon for this app or file being updated/installed\n    if [ -f \"${DIRECTORY}/apps/$app/icon-24.png\" ];then\n      local icon=\"${DIRECTORY}/apps/$app/icon-24.png\"\n    elif [ \"$action\" == update-file ];then\n      #determine mimetype of file to display an informative icon in the list\n      if [ \"$(file -b --mime-type \"${DIRECTORY}/${app}\")\" == 'text/x-shellscript' ];then\n        #if updatable file in question is a main pi-apps shell script, then display shellscript icon.\n        local icon=\"${DIRECTORY}/icons/shellscript.png\"\n        app+=' (script)'\n      elif [[ \"${DIRECTORY}/${app}\" == *.png ]] || [[ \"${DIRECTORY}/${app}\" == *.svg ]];then\n        local icon=\"${DIRECTORY}/icons/image.png\"\n        app+=' (image)'\n      else\n        #otherwise display txt icon.\n        local icon=\"${DIRECTORY}/icons/txt.png\"\n        app+=' (file)'\n      fi\n      action=update\n    else\n      local icon=\"${DIRECTORY}/icons/none-24.png\"\n    fi\n    \n    if [ -z \"$status\" ];then\n      #if there is no status number, then this action has not occured yet.\n      local content=\"${DIRECTORY}/icons/wait.png\n${DIRECTORY}/icons/$action.png\nWill $action\n$icon\n$app\"\n    elif [ \"$status\" == 0 ];then\n      #if status is 0, then action completed successfully.\n      local content=\"${DIRECTORY}/icons/success.png\n${DIRECTORY}/icons/$action.png\n$(echo \"${action^}ed\" | sed 's/Updateed/Updated/g')\n$icon\n$app\"\n    elif [ \"$status\" == 'in-progress' ];then\n      #if status is \"in-progress\", then action is currently being executed.\n      local content=\"${DIRECTORY}/icons/prompt.png\n${DIRECTORY}/icons/$action.png\n$(echo \"${action^}ing...\" | sed 's/Updateing/Updating/g')\n$icon\n$app\"\n    else\n      #if status is 1, then action completed unsuccessfully.\n      local content=\"${DIRECTORY}/icons/failure.png\n${DIRECTORY}/icons/$action.png\n${action^} failed\n$icon\n$app\"\n    fi\n    \n    #write the output to yadlist or stdout\n    if [ \"$output\" == stdout ];then\n      echo \"$content\"\n    else\n      echo \"$content\" > \"${DIRECTORY}/data/manage-daemon/yadlist\"\n    fi\n  }\n  \n  clear_list() { #clear the queue-viewer window\n    echo -e '\\f' > \"${DIRECTORY}/data/manage-daemon/yadlist\"\n  }\n  \n  write_list() { #given $queue in $1, rebuild the queue-viewer window. This avoids clearing the list until the new one has been generated, so makes for a smoother experience\n    local queue=\"$1\"\n    local output='' #variable to send to yadlist file\n    \n    local IFS=$'\\n'\n    local line\n    for line in $queue ;do\n      \n      local action=\"$(echo \"$line\" | awk -F';' '{print $1}')\"\n      local app=\"$(echo \"$line\" | awk -F';' '{print $2}')\"\n      local code=\"$(echo \"$line\" | awk -F';' '{print $3}')\"\n      \n      output+=\"$(add_to_list \"$action\" \"$app\" \"$code\" stdout)\"$'\\n'\n    done\n    output=\"${output::-1}\" #remove final newline character\n    \n    clear_list\n    echo \"$output\" > \"${DIRECTORY}/data/manage-daemon/yadlist\"\n  }\n\n  reorder_list() { # given $queue in $1, output a new queue with app refreshes and file updates prioritized before install/uninstalls\n    local queue=\"$1\"\n    # only reorder queue for actions that have not completed yet (no exit code present)\n    local queue_pending\n    local queue_pending_refresh\n    local queue_pending_files\n    local queue_pending_other\n    local queue_completed\n    local queue_reordered\n    local IFS=$'\\n'\n    local line\n    for line in $queue ;do\n      if ! [[ \"$(echo \"$line\" | awk -F';' '{print $3}')\" =~ ^[0-9]+$ ]] ; then\n        # echo \"$line is still pending\" 1>&2\n        queue_pending+=\"$line\"$'\\n'\n      else\n        # echo \"$line has been completed already\" 1>&2\n        queue_completed+=\"$line\"$'\\n'\n      fi\n    done\n    [ ! -z \"$queue_pending\" ] && queue_pending=\"${queue_pending::-1}\" #remove final newline character\n    [ ! -z \"$queue_completed\" ] && queue_reordered+=\"$queue_completed\" #already includes trailing newline\n    for line in $queue_pending ;do\n      if [[ \"$line\" =~ ^\"refresh;\".* ]] ; then\n        # echo \"$line has the refresh action\" 1>&2\n        queue_pending_refresh+=\"$line\"$'\\n'\n      elif [[ \"$line\" =~ ^\"update-file;\".* ]];then\n        # echo \"$line has the update-file action\" 1>&2\n        queue_pending_files+=\"$line\"$'\\n'\n      else\n        # echo \"$line has some other action\" 1>&2\n        queue_pending_other+=\"$line\"$'\\n'\n      fi\n    done\n    [ ! -z \"$queue_pending_files\" ] && queue_reordered+=\"$queue_pending_files\" #already includes trailing newline\n    [ ! -z \"$queue_pending_refresh\" ] && queue_reordered+=\"$queue_pending_refresh\" #already includes trailing newline\n    [ ! -z \"$queue_pending_other\" ] && queue_reordered+=\"$queue_pending_other\" #already includes trailing newline\n    queue_reordered=\"${queue_reordered::-1}\" #remove final newline character\n\n    echo \"$queue_reordered\"\n  }\n  \n  #make a named pipe so that other daemon processes can notify this master daemon process to complete new tasks\n  if [ ! -e \"${DIRECTORY}/data/manage-daemon/queue\" ];then\n    mkfifo \"${DIRECTORY}/data/manage-daemon/queue\"\n  fi\n  \n  #each line in $2 is something like \"install Zoom\" or \"uninstall Arduino\"\n  queue=\"$2\"\n  \n  #To simplify parsing, place a ';' character between $1 (the action) and subsequent args. (the app)\n  queue=\"$(echo \"$queue\" | sed 's/^\\( *[^ ]\\+\\) /\\1;/')\"\n  \n  #validate the selections first\n  queue=\"$(validate_apps_gui \"$queue\")\"\n  [ -z \"$queue\" ] && exit 0\n  \n  #send each requested action to the queue file\n  if [ ! -z \"$queue\" ];then\n    echo \"$queue\" > \"${DIRECTORY}/data/manage-daemon/queue\" &\n  fi\n  \n  #only one instance of this script should ever be running at a time.\n  #Use a PID file to check if another daemon process is running.\n  if [ -f \"${DIRECTORY}/data/manage-daemon/pid\" ];then\n    #check if PID is running\n    if process_exists $(cat \"${DIRECTORY}/data/manage-daemon/pid\") ;then\n      echo \"Sending instructions to daemon. (PID $(cat \"${DIRECTORY}/data/manage-daemon/pid\"))\"\n      \n      #Immediately add these new actions to the gui list\n      IFS=$'\\n'\n      for line in $queue ;do\n        #get first word of this line - the action. Subsequent words are the name of the app.\n        action=\"$(echo \"$line\" | awk -F ';' '{print $1}')\"\n        app=\"$(echo \"$line\" | awk -F ';' '{print $2}')\"\n        \n        add_to_list \"$action\" \"$app\"\n      done\n      \n      #exit script - data has been sent to already-running daemon\n      exit 0\n    fi\n  fi #past this point, this instance is acting as the daemon.\n  \n  #write my own PID to the pid file\n  echo $$ > \"${DIRECTORY}/data/manage-daemon/pid\"\n  \n  #Display a list of actions and their current status.\n  #This list is updated with new information as time progresses.\n  #Another named pipe is created to refresh the yad list later.\n  rm -f \"${DIRECTORY}/data/manage-daemon/yadlist\"\n  mkfifo \"${DIRECTORY}/data/manage-daemon/yadlist\" #make a named pipe\n\n  #check if hardware and OS is supported\n  if [ \"$supported\" == \"yes\" ] || [ \"$supported\" == \"no\" ]; then\n    true\n  else\n    if is_supported_system >/dev/null;then\n      export supported=yes\n      export unsupported_message=''\n    else\n      export supported=no\n      export unsupported_message=\"$(is_supported_system)\"\n    fi\n  fi\n  \n  [ -z \"$geometry2\" ] && geometry2='--center'\n  \n  tail -f --retry \"${DIRECTORY}/data/manage-daemon/yadlist\" 2>/dev/null | yad --class Pi-Apps --name \"Pi-Apps\" --width=330 --height=400 \"$geometry2\" --title='Monitor Progress' \\\n    --list --tail --no-headers --column=:IMG --column=:IMG --column=Text --column=:IMG --column=Text \\\n    --separator='\\n' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n    --dclick-action=true --select-action=true \\\n    --no-buttons &\n  yadpid=$!\n  \n  trap \"kill $yadpid 2>/dev/null\" EXIT\n  \n  #Used to track which line of $queue is currently being dealt with.\n  current_line_num=1\n  \n  sourced_updater=0 #updater script needs to be sourced if files are updated. This allows it to only be sourced once.\n  \n  queue=''\n  IFS=$'\\n'\n  while true;do #repeat until nothing is left in the queue\n    \n    #check for new actions to be executed\n    echo -n > \"${DIRECTORY}/data/manage-daemon/queue\" & #ensure that the pipe is in write mode to prevent cat from hanging if the queue file is empty\n    new_lines=\"$(tac \"${DIRECTORY}/data/manage-daemon/queue\")\" # tac reverses the order of the list. a plain cat of the file will give the newest item in the queue first.\n    \n    #keep track of all actions for this session with the $queue variable\n    if [ -z \"$queue\" ];then\n      queue=\"$new_lines\"\n    elif [ ! -z \"$new_lines\" ];then # add new_lines to queue if new_lines is not empty\n      queue+=$'\\n'\"$new_lines\"\n    fi\n\n    # reorder queue list to prioritize app refresh and file update actions\n    queue=\"$(reorder_list \"$queue\")\"\n    \n    if [ ! -z \"$new_lines\" ] && [ \"$sourced_updater\" == 0 ] && grep -q \"update\\|refresh\\|update-file\" <<<\"$new_lines\" ;then #source updater if necessary\n      source \"${DIRECTORY}/updater\" source\n      sourced_updater=1\n    fi\n    #echo \"length of queue is $(echo \"$queue\" | wc -l)\"\n    \n    #exit loop if queue is complete and no new actions were added to the queue\n    if [ \"${current_line_num}\" -gt \"$(echo \"$queue\" | wc -l)\" ];then\n      break\n    fi\n    \n    #echo \"current position in queue is ${current_line_num}\"\n    #echo \"queue is '$queue'\"\n    \n    line=\"$(echo \"$queue\" | sed -n \"${current_line_num}\"p)\"\n    #echo \"Now handling request: '$line'\"\n    \n    #indicate current action in current line of $queue\n    queue=\"$(echo \"$queue\" | sed \"${current_line_num}s/$/;in-progress/\")\"\n    \n    #get first word of this line - the action. Subsequent words are the name of the app.\n    action=\"$(echo \"$line\" | awk -F';' '{print $1}')\"\n    app=\"$(echo \"$line\" | awk -F';' '{print $2}')\"\n    \n    #refresh the list in queue-viewer window as a background process - skip it if the list is still refreshing from last loop iteration; in game dev this is 'dropped input'\n    if [ -z \"$write_list_pid\" ] || ! process_exists \"$write_list_pid\" ;then\n      write_list \"$queue\" &\n      write_list_pid=$!\n      \n      #secondary list-writing background process - kill it if it exists because write_list just sent a newer version of the list to yad\n      [ ! -z \"$secondary_write_list_pid\" ] && process_exists \"$secondary_write_list_pid\" && kill \"$secondary_write_list_pid\"\n    else\n      #if app1 is refreshed and app2 is then reinstalled, the list would only say app1 is bring refreshed for the entirety of app2's reinstallation, due to the process-skipping.\n      #launch a secondary background process that waits for $write_list_pid to finish\n      \n      #only allow one secondary background process to run; kill previous jobs and start a new one\n      [ ! -z \"$secondary_write_list_pid\" ] && process_exists \"$secondary_write_list_pid\" && kill \"$secondary_write_list_pid\"\n      (while process_exists $write_list_pid ;do sleep 1 ;done ; write_list \"$queue\") &\n      secondary_write_list_pid=$!\n    fi\n    \n    #run manage script for app installs, uninstalls, or updates. Avoid using it for file-updates and refreshes because that is out of the scope for manage script.\n    if [ \"$action\" == update-file ];then\n      #Set terminal title\n      echo -ne \"\\e]0;Updating ${app} file\\a\"\n      update_file \"$app\"\n      exitcode=$?\n    elif [ \"$action\" == refresh ];then\n      #Set terminal title\n      echo -ne \"\\e]0;${action^}ing ${app}\\a\"\n      refresh_app \"$app\"\n      exitcode=$?\n    else\n      #Set terminal title\n      echo -ne \"\\e]0;${action^}ing ${app}\\a\" | sed 's/Updateing/Updating/g'\n      \"${DIRECTORY}/manage\" \"$action\" \"$app\"\n      exitcode=$?\n    fi\n    \n    #record exit code in current line of $queue\n    queue=\"$(echo \"$queue\" | sed \"${current_line_num}s/;in-progress$/;$exitcode/\")\"\n    \n    #one more line of $queue has been completed.\n    current_line_num=$((current_line_num+1))\n  done\n  \n  #refresh the list in queue-viewer window for the final time with all actions complete\n  [ ! -z \"$secondary_write_list_pid\" ] && process_exists \"$secondary_write_list_pid\" && kill \"$secondary_write_list_pid\" #kill secondary list writer\n  wait $write_list_pid\n  write_list \"$queue\"\n  \n  #before exiting the loop, add a line to the queue-viewer window indicating that all items have completed.\n  echo \"${DIRECTORY}/icons/none-1.png\n${DIRECTORY}/icons/none-1.png\nDone.\n${DIRECTORY}/icons/none-1.png\n\" > \"${DIRECTORY}/data/manage-daemon/yadlist\"\n  \n  #all actions have been completed. Daemon has effectively stopped listening, so remove its pid file\n  rm -f \"${DIRECTORY}/data/manage-daemon/pid\"\n  \n  #close the queue-viewer window in a few seconds\n  (sleep 5; kill $yadpid 2>/dev/null) &\n  \n  #diagnose every failed app's logfile - list item format is $action;$app;$exitcode\n  failed_apps=\"$(echo \"$queue\" | grep ';1$' | awk -F';' '{print $2}')\"\n  diagnose_apps \"$failed_apps\"\n\n  # if update refresh or update-file actions were run then update the .git folder\n  if [ \"$sourced_updater\" == 1 ]; then\n    update_git\n  fi\n  \n  #updates could have been run as part of the manage-daemon, so update the updatable-files and updatable-apps status files\n  \"${DIRECTORY}/updater\" set-status  \n  \nelif [ \"$1\" == 'multi-uninstall' ] || [ \"$1\" == 'multi-install' ];then\n  \n  if [ \"$1\" == 'multi-uninstall' ];then\n    action=uninstall\n  elif [ \"$1\" == 'multi-install' ];then\n    action=install\n  fi\n  \n  app_list=\"$2\" #newline-separated list of apps to install/uninstall\n  \n  #check if any app names are invalid - use the validate_apps_gui function which requires the action to prefix each line.\n  queue=\"$(validate_apps_gui \"$(echo \"$app_list\" | sed \"s/^/${action};/g\")\")\"\n  [ -z \"$queue\" ] && exit 0\n\n  if grep -q \"update\\|refresh\\|update-file\" <<<\"$queue\" ;then #source updater if necessary\n    source \"${DIRECTORY}/updater\" source\n  fi\n  \n  #install/uninstall one app at a time. If it fails then add the app to the list of failed apps\n  IFS=$'\\n'\n  failed_apps=''\n  for line in $queue ;do\n    action=\"$(echo \"$line\" | awk -F ';' '{print $1}')\"\n    app=\"$(echo \"$line\" | awk -F ';' '{print $2}')\"\n\n    #run manage script for app installs, uninstalls, or updates. Avoid using it for file-updates and refreshes because that is out of the scope for manage script.\n    if [ \"$action\" == update-file ];then\n      #Set terminal title\n      echo -ne \"\\e]0;Updating ${app} file\\a\"\n      update_file \"$app\"\n      exitcode=$?\n    elif [ \"$action\" == refresh ];then\n      #Set terminal title\n      echo -ne \"\\e]0;${action^}ing ${app}\\a\"\n      refresh_app \"$app\"\n      exitcode=$?\n    else\n      #Set terminal title\n      echo -ne \"\\e]0;${action^}ing ${app}\\a\" | sed 's/Updateing/Updating/g'\n      \"${DIRECTORY}/manage\" \"$action\" \"$app\"\n      exitcode=$?\n    fi\n    \n    if [ $exitcode != 0 ];then\n      #this app failed to install - add it to the list of failed apps\n      failed_apps+=\"$app\"$'\\n'\n    fi\n  done\n  \n  if [ ! -z \"$failed_apps\" ];then\n    exit 1\n  fi\n  \nelif [ \"$1\" == 'install-if-not-installed' ];then\n  \n  #if not installed\n  if [ \"$(app_status \"$2\")\" != installed ];then\n    #install it\n    \"${DIRECTORY}/manage\" install \"$2\" || exit 1\n  fi\n  \nelif [ \"$1\" == 'install' ] || [ \"$1\" == 'uninstall' ];then\n  #for this operation, a program name must be specified.\n  app=\"$2\"\n  if [ -z \"$app\" ];then\n    error \"For this operation, you must specify which app to operate on.\"\n  elif [ ! -d \"${DIRECTORY}/apps/$app\" ];then\n    error \"${DIRECTORY}/apps/$app does not exist!\"\n  fi\n  \n  if [ \"$1\" == install ];then\n    action=install\n  else\n    action=uninstall\n  fi\n  \n  if [ \"$action\" == install ];then\n    #check for internet connection\n    errors=\"$(command wget --spider https://github.com 2>&1)\"\n    if [ $? != 0 ];then\n      error \"No internet connection! (github.com failed to respond)\\nErrors:\\n$errors\"\n    fi\n  fi\n  \n  #ensure not a disabled app\n  if [ \"$action\" == install ] && [ \"$(app_status \"${app}\")\" == 'disabled' ];then\n    warning \"Not installing the $app app. IT IS DISABLED.\"\n    exit 0\n  fi\n  \n  #determine path for log file to be created\n  logfile=\"${DIRECTORY}/logs/${action}-incomplete-${app}.log\"\n  if [ -f \"$logfile\" ] || [ -f \"$(echo \"$logfile\" | sed 's+-incomplete-+-success-+g')\" ] || [ -f \"$(echo \"$logfile\" | sed 's+-incomplete-+-fail-+g')\" ];then\n    #append a number to logfile's file-extension if the original filename already exists\n    i=1\n    while true;do\n      #if variable $i is 2, then example newlogfile value: /path/to/install-Discord.log2\n      newlogfile=\"$logfile$i\"\n      if [ ! -f \"$newlogfile\" ] && [ ! -f \"$(echo \"$newlogfile\" | sed 's+/-incomplete-+-success-+g')\" ] && [ ! -f \"$(echo \"$newlogfile\" | sed 's+-incomplete-+-fail-+g')\" ];then\n        logfile=\"${newlogfile}\"\n        break\n      fi\n      i=$((i+1))\n    done\n  fi\n  \n  #display warning if hardware and os is unsupported\n  if [ \"$supported\" == no ];then\n    \n    warning \"YOUR SYSTEM IS UNSUPPORTED:\\n$unsupported_message\" 2>&1 | tee -a \"$logfile\"\n    sleep 1\n    echo -e \"\\e[103m\\e[30mThe ability to send error reports has been disabled.\\e[39m\\e[49m\" | tee -a \"$logfile\"\n    sleep 1\n    echo -e \"\\e[103m\\e[30mWaiting 10 seconds... (To cancel, press Ctrl+C or close this terminal)\\e[39m\\e[49m\" | tee -a \"$logfile\"\n    sleep 10\n  fi\n  \n  #if this app has scripts, determine which script to run\n  if [ \"$(app_type \"$app\")\" == standard ];then\n    if [ \"$action\" == install ];then\n      scriptname=\"$(script_name_cpu \"$app\")\" #will be install, install-32, or install-64\n      if [ -z \"$scriptname\" ];then\n        error \"It appears $app does not have an install-${arch} script suitable for your ${arch}-bit OS.\" | tee -a \"$logfile\"\n        exit 1\n      fi\n    else #uninstall mode\n      scriptname=uninstall\n    fi\n    appscript=(\"${DIRECTORY}/apps/${app}/${scriptname}\")\n    chmod u+x \"$appscript\" &>/dev/null\n  #if this app just lists a package-name, set the appscript to install that package\n  \n  else #package-app: directly use apt to install what is mentioned in the packages file\n\n    packages_to_install=$(pkgapp_packages_required \"$app\")\n    [ -z \"$packages_to_install\" ] && error \"It appears $app does not have any packages that can be installed on your system.\"\n    \n    appscript=(bash -c -o pipefail \"apt_lock_wait ; sudo -E apt $(echo \"$action\" | sed 's/uninstall/purge --autoremove/g') -yf $packages_to_install 2>&1 | less_apt\")\n    \n    #fix edge case: new will_reinstall function avoids a reinstall if packages to install do not change.\n    #unfortunately updater script does not source the new api so chromium is being reinstalled after we added \"| chromium\" to the packages file.\n    #fix it here because new manage script sources the new api\n    if [ \"$action\" == uninstall ] && [ \"$3\" == \"update\" ] && ! will_reinstall \"$app\" ;then\n      #manage was told to reinstall app, but it does not actually need to. Do nothing\n      appscript=(bash -c -o pipefail \"status 'Not reinstalling $app as no changes would be made.\\nYou should only see this message once. Exiting.'\")\n    fi\n  fi\n  \n  #print to terminal\n  status \"${action^}ing \\e[1m${app}\\e[0m\\e[96m...\" | tee -a \"$logfile\"\n  echo\n  cd $HOME\n  if [ \"$3\" == \"update\" ]; then\n    export script_input=\"update\"\n  else\n    export script_input=\"\"\n  fi\n  #always overwrite DEBIAN_FRONTEND with gnome\n  #dialog and readline are not functional due to the logfile pipe\n  #noninteractive cannot be used as many debian scripts set their default as option as no (when the user needs to click yet) or do not allow for noninteractive use\n  #this will fallback to another option if the gnome dialog cannot be launched\n  if [ \"$GITHUB_ACTIONS\" == \"true\" ]; then\n    export DEBIAN_FRONTEND=noninteractive\n  else\n    export DEBIAN_FRONTEND=gnome\n  fi\n  nice \"${appscript[@]}\" \"$script_input\" &> >(tee -a \"$logfile\")\n  exitcode=\"${PIPESTATUS[0]}\"\n  \n  #if app succeeded\n  if [ $exitcode == 0 ];then\n    \n    #Contribute to app install/uninstall count as long as parent processes is NOT updater (during an app-reinstall)\n    #See: https://askubuntu.com/a/1012236\n    if [ \"$(cat /proc/$PPID/comm)\" != \"updater\" ] && [ \"$3\" != \"update\" ];then\n      shlink_link \"$app\" \"$action\" &\n    fi\n    \n    status_green \"\\n${action^}ed ${app} successfully.\" | tee -a \"$logfile\"\n    echo \"${action}ed\" > \"${DIRECTORY}/data/status/${app}\"\n    \n    format_logfile \"$logfile\" #remove escape sequences from logfile\n    mv \"$logfile\" \"$(echo \"$logfile\" | sed 's+-incomplete-+-success-+g')\" #rename logfile to indicate it was successful\n    \n  else #if app failed to install/uninstall\n    \n    #remove dummy deb if app failed to install (to avoid dummy debs being left on a users install for broken apps)\n    package_name=\"$(app_to_pkgname \"$app\")\"\n    if [[ ${action} == \"install\" ]] && [[ \"$(app_type \"$app\")\" == standard ]] && package_installed \"$package_name\"; then\n      #Run purge_packages\n      echo $'\\n'\"Running purge_packages...\" >> \"$logfile\"\n      purge_packages 2>&1 | tee -a \"$logfile\" >/dev/null\n    fi\n    unset package_name\n    \n    echo -e \"\\n\\e[91mFailed to ${action} ${app}!\\e[39m\n\\e[40m\\e[93m\\e[5m\\e[25m\\e[39m\\e[49m\\e[93mNeed help? Copy the \\e[1mENTIRE\\e[0m\\e[49m\\e[93m terminal output or take a screenshot.\nPlease ask on Github: \\e[94m\\e[4mhttps://github.com/Botspot/pi-apps/issues/new/choose\\e[24m\\e[93m\nOr on Discord: \\e[94m\\e[4mhttps://discord.gg/RXSTvaUvuu\\e[0m\" | tee -a \"$logfile\"\n    \n    #set the app's status to 'corrupted' if the diagnostics determine the error is NOT internet or system or package, AND if the app is a script-type app\n    if ! [[ \"$(log_diagnose \"$logfile\" | head -n1)\" =~ ^(system|internet|package)$ ]] && [ \"$(app_type \"$app\")\" == standard ];then\n      echo \"corrupted\" > \"${DIRECTORY}/data/status/${app}\"\n    fi\n    \n    format_logfile \"$logfile\" #remove escape sequences from logfile\n    mv \"$logfile\" \"$(echo \"$logfile\" | sed 's+-incomplete-+-fail-+g')\" #rename logfile to indicate it was unsuccessful\n  fi\n \n  #if the app is a package, set its status to whatever dpkg thinks it is\n  if [ \"$(app_type \"$app\")\" == package ];then\n    refresh_pkgapp_status \"$app\"\n  fi\n  \n  #exit the manage script with the same exit-code of the app's script\n  exit $exitcode\n  \nelif [ \"$1\" == 'update' ];then #user-facing argument to update an app. Pi-Apps scripts should directly use updater's update_app function.\n  #for this operation, a program name must be specified.\n  app=\"$2\"\n  if [ -z \"$app\" ];then\n    error \"For this operation, you must specify which app to operate on.\"\n  fi\n  \n  # make sure update_app function is available\n  typeset -f update_app &>/dev/null || source \"${DIRECTORY}/updater\" source\n  \n  update_app \"$app\" || exit $?\n  \nelif [ \"$1\" == 'check-all' ];then #The manage script no longer handles updates. This mode is only for backwards-compatibility and uses the updater script\n  \n  warning \"The manage script ONLY updates apps, and this mode has been replaced by the updater script.\nIf you want to update Pi-Apps from the command-line, please use:\n~/pi-apps/updater cli-yes\"\n  \n  #get functions from updater script\n  source \"${DIRECTORY}/updater\" source\n  \n  check_repo\n  get_updatable_apps\n  \nelif [ \"$1\" == 'update-all' ];then #The manage script no longer handles updates. This mode is only for backwards-compatibility and uses the updater script\n  \n  warning \"The manage script ONLY updates apps, and this mode has been replaced by the updater script.\nIf you want to update Pi-Apps from the command-line, please use:\n~/pi-apps/updater cli-yes\"\n  \n  #get functions from updater script\n  source \"${DIRECTORY}/updater\" source\n  \n  check_repo\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=''\n  \n  update_now_cli\n  \nelse\n  error \"Invalid mode. ($1) Allowed values: 'install', 'multi-install', 'install-if-not-installed', 'uninstall', 'multi-uninstall', 'update', 'update-all', 'check-all', or 'daemon'.\"\nfi\n\n# exit script when finished. Prevents errors if script was modified while in use and new script is longer than previous script.\nexit \"$?\"\n}\n"
        },
        {
          "name": "preload",
          "type": "blob",
          "size": 12.259765625,
          "content": "#!/bin/bash\n\n#this generates a yad-friendly app list. This is run every time the gui script is executed.\n#if this script detects nothing has changed since last run, then it will echo back the app list that was generated last time.\n\nif [ -z \"$DIRECTORY\" ];then\n  DIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\nfi\n\nmktimestamps() {\n  #these directories are checked for changes\n  checkfiles=\"${DIRECTORY}/apps\n${DIRECTORY}/data/settings\n${DIRECTORY}/data/status\n${DIRECTORY}/etc\n${DIRECTORY}/icons/categories\n${DIRECTORY}/preload\n${DIRECTORY}/api\n${DIRECTORY}/data/category-overrides\"\n  local IFS=$'\\n'\n  for i in $checkfiles\n  do\n    printf \"$i $(stat -c %Y \"${i}\" 2>/dev/null) \"\n    \n    if [ -d \"$i\" ];then\n      find \"$i\" -type f -printf '%T@ %p\\n' | sort -rn | head -n1\n    else\n      printf '\\n'\n    fi\n  done\n}\n\n[ \"$1\" == source ] && return 0\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\" 1>&2\n  exit 1\n}\n\n#yad or xlunch format\nguimode=\"$1\"\n\nif [ -z \"$guimode\" ];then\n  format=yad\nelif [[ \"$guimode\" = xlunch* ]];then\n  format=xlunch\nelif [[ \"$guimode\" = yad* ]];then\n  format=yad\nelif [ \"$guimode\" != 'yad' ] && [ \"$guimode\" != 'xlunch' ];then\n  error \"Unknown list format '$format'!\"\nfi\n\n#specifies a category to preload (can be left empty to load main page)\nprefix=\"$2\"\n\nif [ \"$prefix\" == '/' ];then\n  prefix=\nfi\n\n# if the timestamp in the settings folder has changed, we need to unset the text_color variable since the GTK_THEME may have changed and we need to re-generate it\ntimestamp_settings=\"$( cat ${DIRECTORY}/data/preload/timestamps- | grep \"^${DIRECTORY}/data/settings\" )\"\ntimestamps=\"$(mktimestamps)\"\necho \"$timestamps\" | grep -q \"$timestamp_settings\" || unset text_color\n\n#For systems with older versions of yad, the text color column cannot be left blank. This python script determines the default text color from GTK bindings.\nif [ -z \"${text_color+x}\" ] && [ \"$format\" == yad ];then\n  #0400 is the latest version\n  yad_version=\"$(zcat /usr/share/doc/yad/NEWS.gz | head -n 1 | tr -cd '0123456789\\n')\"\n  if [ $yad_version -lt 0400 ]; then\n    if command -v python3 &>/dev/null; then\n      python_version=\"python3\"\n    else\n      python_version=\"python2\"\n    fi\n    #the GTK_THEME may not be current depending on when the API script was last sourced\n    #to avoid setting the text to the wrong color, check it again now right\n    #set the system GTK theme for yad windows\n    guimode=\"$(cat \"${DIRECTORY}/data/settings/App List Style\" 2>/dev/null || echo yad-default)\"\n    if [ \"$guimode\" == yad-default ];then\n      export GTK_THEME=''\n    elif [[ \"$guimode\" = yad* ]];then\n      export GTK_THEME=${guimode//yad-/}\n    elif [ \"$guimode\" == xlunch-light-3d ];then\n      export GTK_THEME=''\n    elif [ \"$guimode\" == xlunch-dark-3d ];then\n      export GTK_THEME=Adwaita-dark\n    elif [ \"$guimode\" == xlunch-dark ];then\n      export GTK_THEME=Adwaita-dark\n    fi\n    export text_color=$(echo \"import gi\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\nfrom gi.repository import Gdk\ntv = Gtk.TextView()\nstyle = tv.get_style_context()\ntextcolor = style.get_color(Gtk.StateType.NORMAL)\nprint(Gdk.RGBA.to_string(textcolor))\n\" | $python_version -)\n  else\n    export text_color=\"\"\n  fi\nfi\n\ntimestampfile=\"${DIRECTORY}/data/preload/timestamps-$(echo \"$prefix\" | tr -d '/')\"\nlistfile=\"${DIRECTORY}/data/preload/LIST-$(echo \"$prefix\" | tr -d '/')\"\n\nmkdir -p \"${DIRECTORY}/data/preload\"\n\nreloadlist=0\n\nif [ -f \"$timestampfile\" ];then\n  #get modified timestamps for files/directories in the pi-apps folder\n  timestamps=\"$(mktimestamps)\"\n  \n  if [ \"$timestamps\" == \"$(cat \"$timestampfile\")\" ];then\n    #if current timestamps and saved timestamps match, then don't reload the list\n    reloadlist=0\n    echo \"Timestamps match.\" 1>&2\n  else\n    #timestamps don't match, so reload the list\n    reloadlist=1\n    echo \"Timestamps don't match\" 1>&2\n    #echo -e \"original file: $(cat \"$timestampfile\")\\nnew timestamp: $timestamps\" 1>&2\n  fi\nelse\n  #timestamp file not found\n  reloadlist=1\nfi\n\nif [ ! -f \"$listfile\" ] || [ ! -s \"$listfile\" ];then\n  echo \"list file for $prefix does not exist.\" 1>&2\n  reloadlist=1\nelse\n  list_length=$(wc -l \"$listfile\" | awk '{print $1}')\nfi\n\nif [ -n \"$list_length\" ] && [ \"$format\" == yad ] && (( $list_length % 5 )) ; then\n  echo \"yad lists are a multiple of 5, $prefix does not have a list a multiple of 5 so it may be corrupted and needs regenerating.\" 1>&2\n  reloadlist=1\nfi\n\n#If updates available, show special Updates category (returned separately to avoid re-preloading after update-check finishes)\nif [ -z \"$prefix\" ] && [ \"$format\" == yad ] && ([ -s \"${DIRECTORY}/data/update-status/updatable-files\" ] || [ -s \"${DIRECTORY}/data/update-status/updatable-apps\" ]);then\n  #yad format\n  echo \"${DIRECTORY}/icons/categories/Updates.png\nUpdates\nUpdates/\nPi-Apps updates are available. Click here to update your apps.\n$text_color\"\nelif [ -z \"$prefix\" ] && [ \"$format\" == xlunch ] && ([ -s \"${DIRECTORY}/data/update-status/updatable-files\" ] || [ -s \"${DIRECTORY}/data/update-status/updatable-apps\" ]);then\n  #xlunch format\n  echo \"Updates;${DIRECTORY}/icons/categories/Updates-64.png;:exec \"\\\"\"echo Updates/\"\\\"\"\"\nfi\n\nif [ $reloadlist == 1 ];then\n  echo \"Generating list for '$prefix'...\" 1>&2\n  \n  #for app_prefix_categories() and app_status() functions\n  if ! command -v app_prefix_category >/dev/null ;then\n    source \"${DIRECTORY}/api\"\n  fi\n  \n  if [ ! -z \"$prefix\" ];then\n    echo \"Showing apps within $prefix/\" 1>&2\n    vfiles=\"$(app_prefix_category \"$prefix\" | grep . | sort -f | uniq | sed \"s+$prefix/++g\")\" #generate a virtual file system with apps in folders represented as subdirectories\n  else\n    vfiles=\"$(app_prefix_category \"\" | grep . | sort -f | uniq | grep -v '^hidden/')\"\n  fi\n  \n  #remove apps within categories - show this layer of stuff only.\n  vfiles=\"$(sed 's+/.*+/+g' <<<\"$vfiles\" | uniq)\"\n  \n  #get list of apps - excluding folders and apps that are incompatible with CPU architecture\n  APPS=\"$(grep -v '/' <<<\"$vfiles\" | list_intersect \"$(list_apps cpu_installable)\")\"\n  \n  #get list of folders - excluding apps.\n  DIRS=\"$(grep '/' <<<\"$vfiles\" | tr -d '/')\"\n  \n  #shuffle the list if enabled\n  if [ \"$(< \"${DIRECTORY}/data/settings/Shuffle App list\")\" == 'Yes' ];then\n    APPS=\"$(echo \"$APPS\" | shuf)\"\n    DIRS=\"$(echo \"$DIRS\" | shuf)\"\n  fi\n  \n  if [ \"$format\" == yad ];then\n    IFS=$'\\n'\n\n    listfile_tmp=\"$listfile-$(mktemp -u | sed 's:/tmp/tmp.::g')\"\n    \n    #initial value of listfile: if within a prefix, start with a Back button\n    if [ ! -z \"$prefix\" ];then\n      echo \"${DIRECTORY}/icons/back.png\nBack\n$(dirname \"$prefix\" | sed 's+^\\.$++g')/\nReturn to the previous location\n$text_color\" | tee \"$listfile_tmp\" &>/dev/null\n    else\n      echo -n '' > \"$listfile_tmp\"\n    fi\n\n    declare -A dir_lookup\n    dir_lookup=( [\"Browsers\"]=\"Internet browsers.\" [\"All Apps\"]=\"All Pi-Apps Applications in one long list.\" [\"Appearance\"]=\"Applications and Themes which modify the look and feel of your OS.\" [\"System Management\"]=\"Apps that help you keep track of system resources and general system management.\" [\"Games\"]=\"Games and Emulators\" [\"Installed\"]=\"All Pi-Apps Apps that you have installed.\" [\"Internet\"]=\"Browsers, Chat Clients, Email Clients, and so much more.\" [\"Multimedia\"]=\"Video playback and creation, audio playback and creation, and streaming alternatives.\" [\"Packages\"]=\"Simple Apps that install directly from APT repos.\" [\"Tools\"]=\"An assortment of helpful programs that don't already fit into another category.\" [\"Terminals\"]=\"Alternative terminal programs built for the modern age as well as to replicate your old vintage computer.\" [\"Programming\"]=\"Code editors, IDEs, and other applications to help you write and make other programs.\" [\"Creative Arts\"]=\"Drawing, Painting, and Photo and Movie Editors\" [\"Engineering\"]=\"3D Printing slicers, CAD/modeling, and general design software\" [\"Office\"]=\"Office suites (document and slideshow editors), and other office tools.\" [\"Emulation\"]=\"Applications that help you run non-ARM or non-Linux software.\" [\"Communication\"]=\"Internet messaging, calling, video chatting, and email clients.\")\n    for dir in $DIRS\n    do\n      if [ -f \"${DIRECTORY}/icons/categories/${dir}.png\" ];then\n        diricon=\"${DIRECTORY}/icons/categories/${dir}.png\"\n      else\n        diricon=\"${DIRECTORY}/icons/categories/default.png\"\n      fi\n\n      if [ ! -z \"$prefix\" ];then\n        add=\"$diricon\n$dir\n$prefix/$dir/\n\"${dir_lookup[\"$dir\"]}\"\n$text_color\"\n      else\n        add=\"$diricon\n$dir\n$dir/\n\"${dir_lookup[\"$dir\"]}\"\n$text_color\"\n      fi\n      add=\"${add//[&]/&amp;}\"\n      echo \"$add\"\n    done >> \"$listfile_tmp\"\n    #finished preloading categories\n    \n    #preload apps\n    for app in $APPS\n    do\n      #get installation status of app\n      unset status\n      read -r 2>/dev/null status <\"${DIRECTORY}/data/status/${app}\"\n      \n      #determine app icon\n      if [ -f \"${DIRECTORY}/apps/${app}/icon-24.png\" ];then\n        add=\"${DIRECTORY}/apps/${app}/icon-24.png\"$'\\n'\n      else\n        add=\"${DIRECTORY}/icons/none-24.png\"$'\\n'\n      fi\n      \n      #rest of list attributes\n      if [ -z \"$status\" ];then\n        read -r 2>/dev/null line <\"${DIRECTORY}/apps/${app}/description\" || line=\"Description unavailable\"\n        add+=\"$app\n$prefix/$app\n$line\"$'\\n'\n      else\n        read -r 2>/dev/null line <\"${DIRECTORY}/apps/${app}/description\" || line=\"Description unavailable\"\n        add+=\"$app\n$prefix/$app\n\"\\(\"$status\"\\)\" $line\"$'\\n'\n      fi\n      \n      #determine status text-color for app name (green for installed, red for uninstalled, yellow for corrupted)\n      if [ -z \"$status\" ];then\n        add+=\"$text_color\"\n      elif [ \"$status\" == installed ];then\n        add+=\"#00AA00\"\n      elif [ \"$status\" == uninstalled ];then\n        add+=\"#CC3333\"\n      elif [ \"$status\" == corrupted ];then\n        add+=\"#888800\"\n      elif [ \"$status\" == disabled ];then\n        add+=\"#FF0000\"\n      else\n        # fallback incase unexpected status\n        add+=\"$text_color\"\n      fi\n      #output finished app lines\n      add=\"${add//[&]/&amp;}\"\n      echo \"$add\"\n    done >> \"$listfile_tmp\"\n\n    # write to the pipe all at once instead of in breaking chunks. this prevents errors when user clicks the back button too quickly when the list file is still generating\n    mv \"$listfile_tmp\" \"$listfile\"\n    # specifically use cat here so that all data enters the pipe at once\n    cat \"$listfile\"\n    echo \"Finished preload for '$prefix'\" 1>&2\n    #finished preloading apps\n    \n  elif [ \"$format\" == xlunch ];then\n    #XLUNCH list format\n\n    listfile_tmp=\"$listfile-$(mktemp -u | sed 's:/tmp/tmp.::g')\"\n    \n    #initial value of listfile: if within a prefix, start with a Back button, or if on main page start with Updates\n    if [ ! -z \"$prefix\" ];then\n      echo \"Back;${DIRECTORY}/icons/back-64.png;:exec \"\\\"\"echo /\"\\\"\"\" | tee \"$listfile_tmp\" &>/dev/null\n    else\n      echo -n '' > \"$listfile_tmp\"\n    fi\n    \n    IFS=$'\\n'\n    for dir in $DIRS\n    do\n      if [ -f \"${DIRECTORY}/icons/categories/${dir}-64.png\" ];then\n        diricon=\"${DIRECTORY}/icons/categories/${dir}-64.png\"\n      else\n        diricon=\"${DIRECTORY}/icons/categories/default-64.png\"\n      fi\n      \n      echo \"${dir};${diricon};:exec \"\\\"\"echo '${prefix}${dir}/'\"\\\"\"\"\n    done >> \"$listfile_tmp\"\n    \n    for app in $APPS\n    do\n      if [ -f \"${DIRECTORY}/data/status/${app}\" ];then\n        echo \"${app} ($(while read line; do echo $line; done 2>/dev/null < \"${DIRECTORY}/data/status/${app}\"));${DIRECTORY}/apps/${app}/icon-64.png;:exec \"\\\"\"echo '$prefix/${app}'\"\\\"\"\"\n      else\n        #status file missing - app has never been installed\n        echo \"${app};${DIRECTORY}/apps/${app}/icon-64.png;:exec \"\\\"\"echo '$prefix/${app}'\"\\\"\"\"\n      fi\n    done >> \"$listfile_tmp\"\n\n    # write to the pipe all at once instead of in breaking chunks. this prevents errors when user clicks the back button too quickly when the list file is still generating\n    mv \"$listfile_tmp\" \"$listfile\"\n    # specifically use cat here so that all data enters the pipe at once\n    cat \"$listfile\"\n    echo \"Finished preload for $prefix\" 1>&2\n    \n  fi\n  \n  #save timestamps to file too\n  if [ -z \"$timestamps\" ];then\n    timestamps=\"$(mktimestamps)\"\n  fi\n  echo \"$timestamps\" > \"$timestampfile\"\nelse\n  echo \"Reading list file for '$prefix'...\" 1>&2\n  # specifically use cat here so that all data enters the pipe at once\n  cat \"$listfile\"\nfi\n\n#preload all categories in background\nif [ \"$RUNNING_FROM_DAEMON\" != 1 ];then\n  \"${DIRECTORY}/etc/preload-daemon\" \"$format\" >/dev/null &\nfi\n"
        },
        {
          "name": "settings",
          "type": "blob",
          "size": 7.025390625,
          "content": "#!/bin/bash\nDIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n\nsource \"${DIRECTORY}/api\" || error \"failed to source ${DIRECTORY}/api\"\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\"\n  exit 1\n}\n\n#ensure settings dir exists\nif [ ! -d \"${DIRECTORY}/data/settings\" ];then\n  echo \"creating settings directory\"\n  mkdir -p \"${DIRECTORY}/data/settings\"\n  #create default files inside\n  echo '' > \"${DIRECTORY}/data/settings/reinstall-after-update\"\nfi\n\n#$1 is usually left blank. If it equals 'refresh', then empty settings will be created and then the script will exit.\nif [ \"$1\" == 'refresh' ];then\n  #set default settings, if they don't exist\n  settings=\"$(ls \"${DIRECTORY}/etc/setting-params\" | tr '\\n' '|')\"\n  PREIFS=\"$IFS\"\n  IFS='|'\n  for name in $settings\n  do\n    if [ ! -f \"${DIRECTORY}/data/settings/${name}\" ] || [ -z \"$(cat \"${DIRECTORY}/data/settings/${name}\")\" ];then\n      cat \"${DIRECTORY}/etc/setting-params/${name}\" | grep -v '#' | head -n1 > \"${DIRECTORY}/data/settings/${name}\"\n    fi\n  done\n  IFS=\"$PREIFS\"\n  exit 0\n  \nelif [ \"$1\" == 'revert' ];then #If $1 equals 'revert', then overwrite all settings with the defaults and then the script will exit.\n  \n  #overwrite all settings with the defaults\n  settings=\"$(ls \"${DIRECTORY}/etc/setting-params\" | tr '\\n' '|')\"\n  PREIFS=\"$IFS\"\n  IFS='|'\n  for name in $settings\n  do\n    cat \"${DIRECTORY}/etc/setting-params/${name}\" | grep -v '#' | head -n1 > \"${DIRECTORY}/data/settings/${name}\"\n  done\n  IFS=\"$PREIFS\"\n  exit 0\nfi\n\nif [ ! -f ~/.local/share/applications/pi-apps-settings.desktop ];then\n  echo \"Creating Settings menu button\"\n  echo \"[Desktop Entry]\nName=Pi-Apps Settings\nComment=Configure Pi-Apps or create an App\nExec=${DIRECTORY}/settings\nIcon=${DIRECTORY}/icons/settings.png\nTerminal=false\nStartupWMClass=Pi-Apps-Settings\nType=Application\nCategories=Settings;\nStartupNotify=true\" > ~/.local/share/applications/pi-apps-settings.desktop\n  \nfi\n\nexitloop=''\nwhile [ -z $exitloop ];do\n  \n  settings=\"$(ls \"${DIRECTORY}/etc/setting-params\" | tr '\\n' '|')\"\n  yadparams=()\n  tooltips=()\n  PREIFS=\"$IFS\"\n  IFS='|'\n\n  # generate yad/xlunch themes based on system installed themes\n  # yad is compiled using gtk3 on all distros so only gtk3 themes are valid\n\n  theme_dirs=( /usr/share/themes ~/.local/share/themes ~/.themes )\n  # begin array with yad default theme\n  declare gtk3_themes=(\"default\")\n                      \n  for td in \"${theme_dirs[@]}\"; do\n    for th in \"$td\"/*; do\n      [[ -d \"$th\" ]] || continue\n      thname=${th##*/}\n      [ \"$thname\" != Default ] && [ $(ls \"$th/gtk-3.\"* 2>/dev/null | wc -l ) -gt 0 ] && gtk3_themes+=(\"$thname\")\n    done\n  done\n  gtk3_themes=( \"${gtk3_themes[@]/#/yad-}\" )\n  # add xlunch preset themes to the array\n  gtk3_themes+=( \"xlunch-dark\" )\n  gtk3_themes+=( \"xlunch-dark-3d\" )\n  gtk3_themes+=( \"xlunch-light-3d\" )\n  params=$( IFS=$'\\n'; echo \"${gtk3_themes[*]}\" )\n  unset gtk3_themes\n\n  name=\"App List Style\"\n  \n  #create file if necessary\n  if [ ! -f \"${DIRECTORY}/data/settings/${name}\" ] || [ -z \"$(cat \"${DIRECTORY}/data/settings/${name}\")\" ];then\n    cat \"${DIRECTORY}/etc/setting-params/${name}\" | grep -v '#' | head -n1 > \"${DIRECTORY}/data/settings/${name}\"\n  fi\n  #get current setting\n  curval=\"$(cat \"${DIRECTORY}/data/settings/${name}\")\"\n  \n  #order params, with selected option first\n  params=\"$(echo \"$params\" | grep -x \"$curval\")\n$(echo \"$params\" | grep -vx \"$curval\")\"\n  \n  # remove blank lines (like if the current selected option no longer exists) and format as one line output separated by !\n  params=\"$(echo \"$params\" | awk NF | tr '\\n' '!')\"\n  params=\"${params::-1}\"\n  \n  tooltip=\"Pi-Apps can display the apps as a compact list (yad), or as a group of larger icons. (xlunch)\"\n  \n  yadparams+=(--field=:CB \"${params}\")\n  tooltips+=(--field=\"${name}\":!!\"${tooltip}\":BTN '')\n\n  unset name\n  unset tooltip\n  unset params\n  unset curval\n  \n  for name in $settings\n  do\n    [ \"${name}\" == \"App List Style\" ] && continue\n    params=\"$(cat \"${DIRECTORY}/etc/setting-params/${name}\" | grep -v '#')\"\n    \n    #create file if necessary\n    if [ ! -f \"${DIRECTORY}/data/settings/${name}\" ] || [ -z \"$(cat \"${DIRECTORY}/data/settings/${name}\")\" ];then\n      cat \"${DIRECTORY}/etc/setting-params/${name}\" | grep -v '#' | head -n1 > \"${DIRECTORY}/data/settings/${name}\"\n    fi\n    #get current setting\n    curval=\"$(cat \"${DIRECTORY}/data/settings/${name}\")\"\n    \n    #order params, with selected option first\n    params=\"$(echo \"$params\" | grep -x \"$curval\")\n$(echo \"$params\" | grep -vx \"$curval\")\"\n    \n    params=\"$(echo \"$params\" | tr '\\n' '!')\"\n    params=\"${params::-1}\"\n    \n    tooltip=\"$(cat \"${DIRECTORY}/etc/setting-params/${name}\" | grep '^#' | tr -d '#' | tr '\\n' '\\r')\"\n    tooltip=\"${tooltip::-1}\"\n    #echo \"Params of ${name}: ${params}\"\n    #echo \"Tooltip of ${name}: ${tooltip}\"\n    \n    yadparams+=(--field=:CB \"${params}\")\n    tooltips+=(--field=\"${name}\":!!\"${tooltip}\":BTN '')\n  done\n  IFS=\"$PREIFS\"\n  \n  output=\"$(yad --class Pi-Apps-Settings --name \"Pi-Apps Settings\" --center --title='Pi-Apps Settings' --width=310 --height=300 \\\n    --form --separator='\\n' --window-icon=\"${DIRECTORY}/icons/settings.png\" --columns=2 \\\n    \"${tooltips[@]}\" \\\n    --field='Categories'!\"${DIRECTORY}/icons/categories.png\"!\"Does an App belong in Editors instead of Tools? This lets you move it.\":FBTN \"bash -c '${DIRECTORY}/etc/categoryedit 1>&2'\" \\\n    --field='Log files'!\"${DIRECTORY}/icons/log-file.png\"!\"View past installation logs. Useful for debugging, or to see what you installed yesterday.\":FBTN \"bash -c '${DIRECTORY}/etc/logviewer 1>&2'\" \\\n    --field='Multi-Install'!\"${DIRECTORY}/icons/multi-select.png\"!\"Install multiple apps at the same time.\":FBTN \"bash -c '${DIRECTORY}/api multi_install_gui 1>&2'\" \\\n    \"${yadparams[@]}\" \\\n    --field='New App'!\"${DIRECTORY}/icons/create.png\"!\"Make your own app! It's pretty easy if you follow the instructions.\":FBTN \"bash -c '${DIRECTORY}/createapp 1>&2'\" \\\n    --field='Import App'!\"${DIRECTORY}/icons/categories/Imported.png\"!\"Did someone else make an app but it's not on Pi-Apps yet? Import it here.\":FBTN \"bash -c '${DIRECTORY}/etc/import-app 1>&2'\" \\\n    --field='Multi-Uninstall'!\"${DIRECTORY}/icons/multi-select.png\"!\"Uninstall multiple apps at the same time.\":FBTN \"bash -c '${DIRECTORY}/api multi_uninstall_gui 1>&2'\" \\\n    --button='Reset'!\"${DIRECTORY}/icons/backup.png\"!'Reset all settings to their defaults':2 \\\n    --button=Cancel!\"${DIRECTORY}/icons/exit.png\":1 \\\n    --button=Save!\"${DIRECTORY}/icons/check.png\":0 \\\n  )\"\n  \n  button=$? #get exit code to determine which button was pressed\n  #exit if save was not clicked\n  [ $button -ne 0 ] && [ $button -ne 2 ] && exit 0\n\n  if [ $button -eq 2 ];then\n    output=''\n    \"${0}\" revert\n  else\n    exitloop=yes\n  fi\ndone\n\n#remove empty lines from $output\noutput=\"$(echo \"$output\" | grep .)\"\n\necho \"Output: ${output}EOO\"\n\nsettings=\"$(ls \"${DIRECTORY}/etc/setting-params\" | tr '\\n' '|')\"\n\nsettingnumber=1\n\nPREIFS=\"$IFS\"\nIFS='|'\nfor name in $settings\ndo\n  curval=\"$(echo \"$output\" | sed -n \"${settingnumber}p\")\"\n  \n  echo \"Setting '$name' to '$curval'\"\n  echo \"$curval\" > \"${DIRECTORY}/data/settings/${name}\"\n  \n  settingnumber=$((settingnumber + 1))\ndone\nIFS=\"$PREIFS\"\n\n\n"
        },
        {
          "name": "uninstall",
          "type": "blob",
          "size": 1.1630859375,
          "content": "#!/bin/bash\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\"\n  exit 1\n}\n\nDIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n\n#click new uninstallation analytics link\n\"${DIRECTORY}/api\" shlink_link script uninstall\n\nif [ -z \"$(dpkg-query -W --showformat='${Status}\\n' yad 2>/dev/null | grep \"install ok installed\")\" ];then\n  zenity --title='Pi-Apps' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n\t  --list --text=\"Do you want to uninstall YAD?\" \\\n\t  --ok-label=Yes --cancel-label=No \\\n\t  --column=foo --hide-header 2>/dev/null && \"${DIRECTORY}/etc/terminal-run\" \"sudo apt purge -y yad;echo -e '\\nClosing in 5 seconds.';sleep 5\" \"Uninstalling YAD\"\nfi\n\necho \"Removing menu button...\"\nrm -f ~/.local/share/applications/pi-apps.desktop\nrm -f ~/.local/share/applications/pi-apps-settings.desktop\nrm -f ~/.config/autostart/pi-apps-updater.desktop\nrm -f ~/Desktop/pi-apps.desktop\n\necho \"Removing terminal command...\"\nsudo rm -f /usr/local/bin/pi-apps\n\necho -e \"\\e[32mUninstallation complete.\\e[97m Only $HOME/pi-apps still remains.\nIf Pi-apps didn\"\\'\"t work for you, \\e[4m\\e[21m\\e[5mPLEASE\\e[0m\\e[97m consider submitting a \\e[1mbug report\\e[0m!\n--> \\e[96mhttps://github.com/Botspot/pi-apps/issues/new\\e[39m\"\n\n"
        },
        {
          "name": "updater",
          "type": "blob",
          "size": 36.9384765625,
          "content": "#!/bin/bash\n{ #prevents errors if script was modified while in use\n\nfunction error {\n  echo -e \"\\e[91m$1\\e[39m\" 1>&2\n  exit 1\n}\n\nif [[ $(id -u) == 0 ]]; then\n  error \"Pi-Apps is not designed to be run as root! Please try again as a regular user.\"\nfi\n\n[ -z \"$DIRECTORY\" ] && DIRECTORY=\"$(readlink -f \"$(dirname \"$0\")\")\"\n\n#if being sourced, ensure DIRECTORY variable set\nif [ -z \"$DIRECTORY\" ] || [ \"$DIRECTORY\" == \"$HOME\" ] || [ ! -d \"$DIRECTORY\" ] || [ ! -f \"${DIRECTORY}/api\" ] || [ ! -f \"${DIRECTORY}/gui\" ];then\n  echo \"DIRECTORY variable must be set to a valid pi-apps folder. Default folder: $HOME/pi-apps\"\n  return 1\nfi\n\n# runonce-entries is run in the updater, runonce requires that all api functions be available to subprocess (like is done in the gui script)\n#for the will_reinstall() and list_intersect() functions\nset -a #make all functions in the api available to subprocesses\nsource \"${DIRECTORY}/api\" || error \"failed to source ${DIRECTORY}/api\"\n\nget_date() {\n  #number of days since 1/1/1970\n  echo $(($(date --utc +%s)/86400))\n}\n\ncheck_repo() { #download pi-apps repository to the update/pi-apps folder\n  if [ \"$speed\" == fast ];then\n    return 0\n  fi\n  echo -n \"Checking for online changes... \" 1>&2\n  \n  #if the updater script exists in update folder, then just git pull to save time\n  if [ -s \"${DIRECTORY}/update/pi-apps/updater\" ];then\n    cd \"${DIRECTORY}/update/pi-apps\"\n    git pull -q 1>&2 || rm -rf \"${DIRECTORY}/update\"\n  fi | grep -v \"Already up to date.\" 1>&2\n  \n  git_url=\"$(cat \"${DIRECTORY}/etc/git_url\" || echo 'https://github.com/Botspot/pi-apps')\"\n  \n  #if updater script still does not exist then do a git clone\n  if [ ! -s \"${DIRECTORY}/update/pi-apps/updater\" ];then\n    #keep trying until success\n    while true;do\n      rm -rf \"${DIRECTORY}/update\"\n      mkdir -p \"${DIRECTORY}/update\" && cd \"${DIRECTORY}/update\" || error \"failed to create and enter the update directory!\"\n      \n      #clone the repository, and display an error message if it fails\n      if git clone --depth=1 \"$git_url\" 1>&2 ;then\n        echo \"Done\" 1>&2\n        break #exit the loop\n      else\n        echo -e \"\\n${DIRECTORY}/updater: failed to download Pi-Apps repository!\\nTrying again in 60 seconds.\" 1>&2\n        sleep 60\n      fi\n    done\n  else\n    echo \"Done\" 1>&2\n  fi\n  cd #don't exit the function with the current directory being \"${DIRECTORY}/update\"\n}\n\ncheck_update_interval() { #return 0 if update-interval allows update-checking today, exit 1 otherwise\n  local lastupdatecheck=\"$(cat \"${DIRECTORY}/data/last-update-check\" 2>/dev/null)\"\n  if [ -z $lastupdatecheck ];then\n    warning \"${DIRECTORY}/data/last-update-check does not exist!\" 1>&2\n    lastupdatecheck=0\n  fi\n  \n  #write today's date to file. Format is \"number of days since 1/1/1970\"\n  get_date > \"${DIRECTORY}/data/last-update-check\"\n  \n  local updateinterval=\"$(cat \"${DIRECTORY}/data/settings/Check for updates\")\"\n  \n  #allowed values: Always, Daily, Weekly, Never\n  if [ \"$updateinterval\" == 'Never' ];then\n    return 1\n  elif [ \"$updateinterval\" == 'Daily' ];then\n    #if updates checked today, don't check\n    if [ \"$(get_date)\" == \"$lastupdatecheck\" ];then\n      return 1\n    fi\n  elif [ \"$updateinterval\" == 'Weekly' ];then\n    #if updates checked less than 7 days ago, don't check\n    if [ \"$(get_date)\" -le \"$((lastupdatecheck + 7))\" ];then\n      return 1\n    fi\n  elif [ \"$updateinterval\" == 'Always' ];then\n    return 0\n  elif [ -z \"$updateinterval\" ];then\n    warning \"Something isn't right. Does '${DIRECTORY}/data/settings/Check for updates' exist?\" 1>&2\n  else\n    echo -e \"\\e[91mUnrecognized update interval! \\e[0m\" 1>&2\n  fi\n  \n  return 0\n}\n\nlist_files() { #list all files on pi-apps with relative paths - both on main directory and update directory\n  if [ ! -d \"${DIRECTORY}/update\" ];then\n    error \"${DIRECTORY}/update does not exist. Most likely there is no Internet connection.\"\n  fi\n  \n  #list all files in update folder\n  cd \"${DIRECTORY}/update/pi-apps\" || error \"Failed to enter update directory!\"\n  local updatefiles=\"$(find . -type f | cut -c 3- | grep -v '^\\.git/\\|^apps/\\|^data/')\"\n\n  #list all files in main folder\n  cd \"${DIRECTORY}\"\n  local localfiles=\"$(find . -type f | cut -c 3- | grep -v '^\\.git/\\|^apps/\\|^update/\\|^data/\\|^logs/\\|^xlunch/')\"\n\n  echo -e \"${localfiles}\\n${updatefiles}\" | sort | uniq\n  cd $HOME\n}\n\nget_updatable_files() { #sets the updatable_files variable\n  local updatable_files\n  if [ \"$speed\" == fast ] && [ -f \"${DIRECTORY}/data/update-status/updatable-files\" ];then\n    #speed is set to 'fast' - don't hash anything but rely on past results\n    updatable_files=\"$(cat \"${DIRECTORY}/data/update-status/updatable-files\")\"\n    \n  else #speed was not set to 'fast', so compare each file to the one in the update folder\n    #Use rsync for faster speed, if available\n    if command -v rsync >/dev/null ;then\n      updatable_files=$(rsync --exclude=\"/apps/\" --exclude=\"/.git/\" --exclude=\"/data/\" -ric --dry-run --out-format=\"%n\" \"${DIRECTORY}/update/pi-apps/\" \"${DIRECTORY}/\")\n    fi\n    if [ \"$?\" != \"0\" ] || ! command -v rsync >/dev/null ;then\n      #get list of pi-apps files without absolute paths. Example line: 'etc/terminal-run'\n      local file_list=\"$(list_files)\" || exit 1\n\n      updatable_files='' #the variable to be returned\n      local IFS=$'\\n'\n      for file in $file_list ;do\n        \n        echo -en \"Scanning files... $file\\e[0K\\r\" 1>&2\n        if [ ! -f \"${DIRECTORY}/${file}\" ];then\n          #file is missing locally - add to updatable_files list\n          updatable_files+=$'\\n'\"${file}\"\n          \n        elif [ ! -f \"${DIRECTORY}/update/pi-apps/${file}\" ];then\n          #file is missing in the update folder - local\n          true #do not add to updatable_apps list\n          \n        elif ! files_match \"${DIRECTORY}/update/pi-apps/${file}\" \"${DIRECTORY}/${file}\" ;then\n          #files don't match - add to updatable_files list\n          updatable_files+=$'\\n'\"${file}\"\n        fi\n      done\n      #remove initial newline character\n      updatable_files=\"${updatable_files:1}\" \n    fi\n  fi\n  #If an updatable file is listed in update-exclusion, remove it from list and save notification text for later.\n  for file in $(cat \"${DIRECTORY}/data/update-exclusion\" | grep \"^[^#;]\") ;do\n    updatable_files=\"$(echo \"$updatable_files\" | grep -v \"$file\")\"\n    local exclusion_msg+=\"\\n'$file' won't be updated - it's listed in data/update-exclusion.\"\n  done\n  \n  echo -e \"Scanning files... Done\\e[0K\" 1>&2\n  echo \"$updatable_files\"\n  \n  #if any files were excluded by update-exclusion, list them now, after echoing \"Done\"\n  [ ! -z \"$exclusion_msg\" ] && echo -e \"$exclusion_msg\\n\" 1>&2\n  \n  return 0\n}\n\nget_updatable_apps() { #return a list of updatable apps\n  local updatable_apps\n  if [ \"$speed\" == fast ] && [ -f \"${DIRECTORY}/data/update-status/updatable-apps\" ];then\n    #speed is set to 'fast' - don't hash anything but rely on past results\n    updatable_apps=\"$(cat \"${DIRECTORY}/data/update-status/updatable-apps\")\"\n  else #compare all apps to the ones in the update folder\n\n    #Use rsync for faster speed, if available\n    if command -v rsync >/dev/null ;then\n      # requires english locale to be properly enabled and for diff naming convention not to change\n      #diff -rq \"${DIRECTORY}/apps\" \"${DIRECTORY}/update/pi-apps/apps\" | sed \"\\|^Only in ${DIRECTORY}/apps|d\" | sed \"s;Only in ${DIRECTORY}/update/pi-apps/apps: ;;g\" | sed \"s;Files ${DIRECTORY}/apps/;;g\" | awk -F '/' '{print $1}' | uniq\n      # same output, but with rsync which is much simpler. slightly slower\n      updatable_apps=$(rsync -ric --dry-run --out-format=\"%n\" \"${DIRECTORY}/update/pi-apps/apps/\" \"${DIRECTORY}/apps/\" | awk -F '/' '{print $1}' | sort | uniq; exit ${PIPESTATUS[0]})\n    fi\n\n    if [ \"$?\" != \"0\" ] || ! command -v rsync >/dev/null; then\n      updatable_apps=''\n      local IFS=$'\\n'\n      for app in $(list_apps online)\n      do\n        echo -en \"Scanning apps... $app\\e[0K\\r\" 1>&2\n\n        if [ ! -d \"${DIRECTORY}/apps/${app}\" ];then\n          #if app is missing locally, add to updatable list\n          updatable_apps+=$'\\n'\"${app}\"\n\n        elif ! diff -r \"${DIRECTORY}/apps/${app}\" \"${DIRECTORY}/update/pi-apps/apps/${app}\" -q >/dev/null ;then\n          #if app-folder contents don't match, add to updatable list\n          updatable_apps+=$'\\n'\"${app}\"\n        fi\n      done\n      updatable_apps=\"${updatable_apps:1}\" #remove initial newline character\n    fi\n  fi\n  echo -e \"Scanning apps... Done\\e[0K\" 1>&2\n  echo \"$updatable_apps\"\n}\n\nlist_updates_cli () {  #from https://unix.stackexchange.com/a/673436\n    # little helpers for terminal print control and key input\n    ESC=$( printf \"\\033\")\n    cursor_blink_on()   { printf \"${ESC}[?25h\"; }\n    cursor_blink_off()  { printf \"${ESC}[?25l\"; }\n    cursor_to()         { printf \"${ESC}[$1;${2:-1}H\"; }\n    print_inactive()    { printf \"$2   $1 \"; }\n    print_active()      { printf \"$2  ${ESC}[7m $1 ${ESC}[27m\"; }\n    get_cursor_row()    { IFS=';' read -sdR -p $'\\E[6n' ROW COL; echo ${ROW#*[}; }\n\n    local return_value=$1 &>/dev/null\n    local -n options=$2 &>/dev/null\n    local -n defaults=$3 &>/dev/null\n\n    local selected=()\n    for ((i=0; i<${#options[@]}; i++)); do\n      selected+=(\"true\")\n      printf \"\\n\"\n    done\n\n    # determine current screen position for overwriting the options\n    local lastrow=$(get_cursor_row)\n    local startrow=$(($lastrow - ${#options[@]}))\n\n    # ensure cursor and input echoing back on upon a ctrl+c during read -s\n    trap \"cursor_blink_on; stty echo; printf '\\n'; exit\" 2\n    cursor_blink_off\n\n    key_input() {\n        local key\n        IFS= read -rsn1 key 2>/dev/null >&2\n        if [[ $key = \"\"      ]]; then echo enter; fi;\n        if [[ $key = $'\\x20' ]]; then echo space; fi;\n        if [[ $key = \"k\" ]]; then echo up; fi;\n        if [[ $key = \"j\" ]]; then echo down; fi;\n        if [[ $key = $'\\x1b' ]]; then\n            read -rsn2 key\n            if [[ $key = [A || $key = k ]]; then echo up;    fi;\n            if [[ $key = [B || $key = j ]]; then echo down;  fi;\n        fi \n    }\n\n    toggle_option() {\n        local option=$1\n        if [[ ${selected[option]} == true ]]; then\n            selected[option]=false\n        else\n            selected[option]=true\n        fi\n    }\n\n    print_options() {\n        # print options by overwriting the last lines\n        local idx=0\n        for option in \"${options[@]}\"; do\n            local prefix=\"[ ]\"\n            if [[ ${selected[idx]} == true ]]; then\n              prefix=\"[\\e[38;5;46m\\e[0m]\"\n            fi\n\n            cursor_to $(($startrow + $idx))\n            if [ $idx -eq $1 ]; then\n                print_active \"$option\" \"$prefix\"\n            else\n                print_inactive \"$option\" \"$prefix\"\n            fi\n            ((idx++))\n        done\n    }\n\n    local active=0\n    while true; do\n        print_options $active\n\n        # user key control\n        case $(key_input) in\n            space)  toggle_option $active;;\n            enter)  print_options -1; break;;\n            up)     ((active--));\n                    if [ $active -lt 0 ]; then active=$((${#options[@]} - 1)); fi;;\n            down)   ((active++));\n                    if [ $active -ge ${#options[@]} ]; then active=0; fi;;\n        esac\n    done\n\n    # cursor position back to normal\n    cursor_to $lastrow\n    printf \"\\n\"\n    cursor_blink_on\n\n    eval $return_value='(\"${selected[@]}\")'\n}\n\n\nlist_updates_gui() { #input: updatable_apps and updatable_files variables, output: updatable_apps and updatable_files, with refreshable_apps being a subset of updatable_apps\n  local IFS=$'\\n'\n  \n  #If updatable_apps and updatable_files variables empty, set them to the results of the last update-check\n  if [ -z \"$updatable_apps\" ] && [ -z \"$updatable_files\" ];then\n    updatable_apps=\"$(cat \"${DIRECTORY}/data/update-status/updatable-apps\")\"\n    updatable_files=\"$(cat \"${DIRECTORY}/data/update-status/updatable-files\")\"\n  fi\n  \n  local LIST=''\n  local app\n  local compressed_update=''\n  for app in $updatable_apps ;do #generate a yad list for every updatable app\n    # get app tooltip\n    read -r 2>/dev/null line <\"${DIRECTORY}/update/pi-apps/apps/${app}/description\" || line=\"Description unavailable\"\n    # if ${app} folder did not exist before and install-${arch}, install, or packages file is in the new update, then this is a \"new app\"\n    # results in applications that only have support for a different architecture to show under the compressed update\n    if [ ! -d \"${DIRECTORY}/apps/${app}\" ] && ( [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install-${arch}\" ] || [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install\" ] || [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/packages\" ] ); then\n      LIST+=\"TRUE\n${DIRECTORY}/update/pi-apps/apps/${app}/icon-24.png\n$app (new app)\nrefresh-app:$app\n$line\"$'\\n'\n    # if install-${arch} is in the new update and it was not installable on this system before, then this is a \"new app\".\n    elif [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install-${arch}\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install-${arch}\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/packages\" ]; then\n      LIST+=\"TRUE\n${DIRECTORY}/update/pi-apps/apps/${app}/icon-24.png\n$app (new app)\nrefresh-app:$app\n$line\"$'\\n'\n    # similar to the above. if install script is in the new update and it was not installable on this system before, then this is a \"new app\".\n    elif [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install-${arch}\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/packages\" ]; then\n      LIST+=\"TRUE\n${DIRECTORY}/update/pi-apps/apps/${app}/icon-24.png\n$app (new app)\nrefresh-app:$app\n$line\"$'\\n'\n    # if app will be reinstalled then include it on the list and notify the user that it will be reinstalled\n    elif will_reinstall \"$app\"; then\n      LIST+=\"TRUE\n${DIRECTORY}/update/pi-apps/apps/${app}/icon-24.png\n$app (<b>new update</b>)\nreinstall-app:$app\n$line\"$'\\n'\n    # if app has been installed in the past then show it on the list. Useful to notify users that their app, which failed to install in the past, may now work.\n    elif [ \"$(app_status \"${app}\")\" == 'corrupted' ];then\n      LIST+=\"TRUE\n${DIRECTORY}/update/pi-apps/apps/${app}/icon-24.png\n$app (Try installing it again!)\nrefresh-app:$app\nThis app failed to install last time. Maybe it will work now! After updating, try installing this app again.\"$'\\n'\n    else # app is not new or getting reinstalled, add to compressed update list\n      compressed_update+=$'\\n'\"refresh-app:${app}\"\n    fi\n  done\n  \n  local file\n  for file in $updatable_files ;do #generate a yad list for every updatable file\n    \n    #determine mimetype of updatable_apps file to display an informative icon in the list\n    if [ \"$(file -b --mime-type \"${DIRECTORY}/${file}\")\" == 'text/x-shellscript' ];then\n      #if updatable_apps file in question is a shell script, then display shellscript icon.\n      mimeicon=\"${DIRECTORY}/icons/shellscript.png\"\n      mimetype='script'\n    elif [[ \"${DIRECTORY}/${file}\" == *.png ]] || [[ \"${DIRECTORY}/${file}\" == *.svg ]];then\n      mimeicon=\"${DIRECTORY}/icons/image.png\"\n      mimetype='image'\n    else\n      #otherwise display txt icon.\n      mimeicon=\"${DIRECTORY}/icons/txt.png\"\n      mimetype='file'\n    fi\n    \n    LIST+=\"TRUE\n${mimeicon}\n$file ($mimetype)\nfile:$file\n\"$'\\n'\n    \n  done\n  \n  # add special entry to list for compressed app updates\n  if [ ! -z \"$compressed_update\" ];then\n    # display all apps to be updated if less than 11 in number (-lt 12 lines due to the trailing newline)\n    if [[ $(wc -l <<< \"$compressed_update\") -lt 12 ]]; then\n    LIST+=\"TRUE\n${DIRECTORY}/icons/categories/All Apps.png\nInactive updates\ncompressed_apps\nRefreshes the Pi-Apps details for these apps$(echo \"${compressed_update}\" | tr -d '\\n' | sed 's/refresh-app:/, /g' | sed 's/^,/:/g')\"$'\\n'\n    else\n      LIST+=\"TRUE\n${DIRECTORY}/icons/categories/All Apps.png\nInactive updates\ncompressed_apps\nRefreshes the Pi-Apps details for apps that do not need to be reinstalled for this update. (Too many to list here)\"$'\\n'\n    fi\n  fi\n  \n  # remove trailing newline\n  LIST=\"${LIST%$'\\n'}\"\n  \n  if [ -z \"$LIST\" ];then\n    status_green \"Nothing to update. Nothing to do!\"\n    exit 0\n  fi\n  \n  #Display a list of everything updatable\n  output=\"$(echo \"$LIST\" | yad --class Pi-Apps --name \"Pi-Apps\" --center --title='Pi-Apps' \\\n    --window-icon=\"${DIRECTORY}/icons/logo.png\" --width=310 --height=300 \\\n    --list --checklist --separator='\\n' --print-column=4 --no-headers \\\n    --text=\"Updates available:\"$'\\n'\"Uncheck an item to skip updating it.\" \\\n    --column=:CHK --column=:IMG --column=Name --column=ID:HD --column=tip:HD --tooltip-column=5 \\\n    --button='Cancel'!\"${DIRECTORY}/icons/exit.png\"!\"Close without updating anything\":1 \\\n    --button='Update now'!\"${DIRECTORY}/icons/download.png\":0 \\\n    \"${args[@]}\")\" || exit 1\n\n  # add compressed_update apps to output\n  if echo \"$output\" | grep -q '^compressed_apps' ;then\n    output+=$'\\n'\"${compressed_update}\"\n  fi\n  \n  #remove empty newlines from output\n  output=\"$(echo \"$output\" | grep .)\"\n  \n  #regenerate list of updatable apps and files, based on what the user selected\n  refreshable_apps=\"$(echo \"$output\" | grep '^refresh-app:' | sed 's/^refresh-app://g')\"\n  updatable_apps=\"$(echo \"$output\" | grep '^refresh-app:\\|^reinstall-app:' | sed 's/^refresh-app://g ; s/^reinstall-app://g')\"\n  updatable_files=\"$(echo \"$output\" | grep '^file:' | sed 's/^file://g')\"\n  \n}\n\nupdate_app() { #first arg is app name\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"update_app(): no app specified!\"  \n  status \"Updating \\e[1m${app}\\e[0m\\e[96m...\"\n  echo\n  \n  #Set terminal title\n  echo -ne \"\\e]0;Updating ${app}\\a\"\n\n  # check if update app folder exists before doing anything\n  # it can happen that executing the updater from the pi-apps GUI the update folder is missing\n  # if the user has no internet or internet issues the update folder will be removed due to the failed git pull and then wait in the loop for a new git clone\n  # the GUI updater executes check_repo with the \"fast\" option so it skips updating the pi-apps update folder and obtains any previously determined updatable apps and files\n  # if we do not check for this then apps will be removed, the older version moved to trash, and then the new version will fail to copy over since it does not exist\n  if [ -d \"${DIRECTORY}/update/pi-apps/apps/${app}\" ]; then\n    local installback=no\n    if will_reinstall \"$app\";then\n      installback=yes\n      status \"$app's install script has been updated. Reinstalling $app...\"\n      #uninstall it\n      \"${DIRECTORY}/manage\" uninstall \"$app\" update #report to the app uninstall script that this is an uninstall for the purpose of updating by passing \"update\"\n      \n      #fix edge case: if app is installed but uninstall script doesn't exist somehow, then pretend app was uninstalled so that the reinstall later will happen noninteractively\n      if [ \"$(app_status \"$app\")\" == installed ];then\n        echo 'uninstalled' > \"${DIRECTORY}/data/status/${app}\"\n      fi\n    fi\n\n    no_status=true refresh_app \"$app\"\n    \n    failed=false\n    if [ \"$installback\" == 'yes' ];then\n      #install the app again\n      \"${DIRECTORY}/manage\" install \"$app\" update #report to the app install script that this is an install for the purpose of updating by passing \"update\"\n      if [ $? != 0 ]; then\n        failed=true\n      else\n        # click update link only if app is already installed and the update succeeded\n        shlink_link \"$app\" update &\n      fi\n    fi\n  else\n    failed=true\n  fi\n  \n  if [ \"$failed\" == 'true' ]; then\n    echo -e \"\\e[91mFailed to update ${app}.\\e[0m\"\n    return 1\n  else\n    status_green \"${app} was updated successfully.\"\n    return 0\n  fi\n}\n\nrefresh_app() { #first arg is app name\n  local app=\"$1\"\n  [ -z \"$app\" ] && error \"refresh_app(): no app specified!\"  \n  [ \"$no_status\" != true ] && status -n \"Refreshing \\e[1m${app}\\e[0m\\e[96m... \"\n  #Set terminal title\n  [ \"$no_status\" != true ] && echo -ne \"\\e]0;Refreshing ${app}\\a\"\n  \n  rm -rf \"${DIRECTORY}/apps/${app}\"\n  \n  #copy new version from update/ to apps/\n  cp -rf \"${DIRECTORY}/update/pi-apps/apps/${app}\" \"${DIRECTORY}/apps/${app}\"\n  if [ \"$?\" == \"0\" ]; then\n    [ \"$no_status\" != true ] && status_green Done\n    return 0\n  else\n    [ \"$no_status\" != true ] && warning \"Failed to refresh app '$app'!\"\n    return 1\n  fi\n}\n\nupdate_file() { #first arg is file name\n  local file=\"$1\"\n  [ -z \"$file\" ] && error \"update_file(): no file specified!\"  \n  mkdir -p \"$(dirname \"${DIRECTORY}/${file}\")\"\n  \n  #copy new version\n  if cp -f \"${DIRECTORY}/update/pi-apps/${file}\" \"${DIRECTORY}/${file}\" ;then\n    [ \"$no_status\" != true ] && status_green \"${file} file was copied successfully.\"\n    return 0\n  else\n    [ \"$no_status\" != true ] && echo -e \"\\e[91mFailed to copy ${DIRECTORY}/update/pi-apps/${file}! \\e[0m\"\n    return 1\n  fi\n}\n\nupdate_git() {\n  #delete .git folder, then copy the new one\n  rm -rf \"${DIRECTORY}/.git\" || sudo rm -rf \"${DIRECTORY}/.git\" || error \"Failed to delete old ${DIRECTORY}/.git folder!\"\n  cp -a \"${DIRECTORY}/update/pi-apps/.git\" \"${DIRECTORY}\" || error \"Failed to copy new .git folder!\"\n}\n\nupdate_now_cli() { #input: updatable_files and updatable_apps variables\n  local IFS=$'\\n'\n  for file in $updatable_files ;do\n    update_file \"$file\"\n  done\n  \n  for app in $updatable_apps ;do\n    update_app \"$app\"\n  done\n  \n  update_git\n  \n  [ \"$no_status\" != true ] && status_green \"\\nPi-Apps updates complete.\"\n  true\n}\n\nupdate_now_gui_apps() { # deprecated function that is only here so old updater scripts can call it.\n  # this function exists to avoid having to write commands in terminal-run formatting for update_now_gui\n  local failed_apps=\"\"\n  local IFS=$'\\n'\n  for app in $updatable_apps ;do\n    update_app \"$app\" || failed_apps+=\"$app\"$'\\n'\n  done\n  \n  #Set terminal title\n  echo -ne \"\\e]0;Updates complete\\a\"\n  \n  #load the app list now to reduce launch time\n  refresh_app_list &\n  \n  action=update diagnose_apps \"$failed_apps\"\n}\n\nupdate_now_gui() { #input: updatable_files and updatable_apps variables\n  local IFS=$'\\n'\n  local queue=''\n  \n  #contruct a queue to send to terminal_manage_multi.\n  if [ ! -z \"$updatable_files\" ]; then\n    queue+=\"$(echo \"$updatable_files\" | sed 's/^/update-file /g')\"$'\\n'\n  fi\n  \n  if [ ! -z \"$refreshable_apps\" ];then\n    queue+=\"$(echo \"$refreshable_apps\" | sed 's/^/refresh /g')\"$'\\n'\n  fi\n  \n  if [ ! -z \"$updatable_apps\" ];then\n    # for future reference, the for loop should be used here as opposed to using a function like list_subract\n    # list_subtract requires input to be sorted which would be undesirable as it would change update order compared to what is shown to the user in the update GUI\n    for app in $updatable_apps ;do\n      # if app is not in refreshable_apps, do a regular update\n      if ! echo \"${refreshable_apps}\" | grep -q \"^$app\"; then\n        queue+=\"update $app\"$'\\n'\n      fi\n    done\n  fi\n  queue=\"${queue::-1}\" #remove final newline character\n  queue=\"$(tac <<<\"$queue\")\" # reverse order because manage daemon reverses it again; affects alphabetization, not priority\n  #echo \"update_now_gui: queue is '$queue'\"\n  \n  #update any files with terminal_manage. If terminal-run fails it will update the files in the background. This is a safety measure to update pi-apps scripts if terminal fails to launch.\n  if [ \"$no_update\" != true ];then\n    terminal_manage_multi \"$queue\" &\n  else\n    echo \"$queue\"\n  fi\n}\n\nupdate_now_background() { #input: updatable_apps and updatable_files variables\n  # only safe updates that can be done in the background are performed (app refreshes and file updates)\n  local IFS=$'\\n'\n  \n  #If updatable_apps and updatable_files variables empty, set them to the results of the last update-check\n  if [ -z \"$updatable_apps\" ] && [ -z \"$updatable_files\" ];then\n    updatable_apps=\"$(cat \"${DIRECTORY}/data/update-status/updatable-apps\")\"\n    updatable_files=\"$(cat \"${DIRECTORY}/data/update-status/updatable-files\")\"\n  fi\n  \n  local app\n  local background_updatable_apps=''\n  for app in $updatable_apps ;do #narrow down safe $updatable_apps entries\n    # if ${app} folder did not exist before and install-${arch}, install, or packages file is in the new update, then this is a \"new app\"\n    # results in applications that only have support for a different architecture to show under the compressed update\n    if [ ! -d \"${DIRECTORY}/apps/${app}\" ] && ( [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install-${arch}\" ] || [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install\" ] || [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/packages\" ] ); then\n      continue\n    # if install-${arch} is in the new update and it was not installable on this system before, then this is a \"new app\".\n    elif [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install-${arch}\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install-${arch}\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/packages\" ]; then\n      continue\n    # similar to the above. if install script is in the new update and it was not installable on this system before, then this is a \"new app\".\n    elif [ -f \"${DIRECTORY}/update/pi-apps/apps/${app}/install\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install-${arch}\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/install\" ] && [ ! -f \"${DIRECTORY}/apps/${app}/packages\" ]; then\n      continue\n    # if app will be reinstalled then don't try to reinstall it in the background\n    elif will_reinstall \"$app\"; then\n      continue\n    # if app failed to install last time, show this app refresh to the user.\n    elif [ \"$(app_status \"${app}\")\" == 'corrupted' ];then\n      continue\n    else # app is not new or getting reinstalled, safe to refresh it now\n      background_updatable_apps+=\"${app}\"$'\\n'\n    fi\n  done\n  \n  #remove empty newlines from background_updatable_apps\n  background_updatable_apps=\"$(echo \"$background_updatable_apps\" | grep .)\"\n  \n  if [ ! -z \"$updatable_files\" ] || [ ! -z \"$background_updatable_apps\" ];then\n    no_status=true updatable_apps=\"$background_updatable_apps\" update_now_cli\n  fi\n}\n\nrunmode=\"$1\"\nspeed=\"$2\"\n\nif [ ! -z \"$speed\" ] && [ \"$speed\" != 'fast' ];then\n  #error \"Unknown value for speed: \"\\\"\"$speed\"\\\"\". Allowed value: fast\"\n  true\n  #speed is $2, which may be a yadflag if it's not 'fast'.\nelse\n  shift #$2 is setting speed, so move everything over so $3 starts yad flags\nfi\nif [ \"$runmode\" == onboot ];then\n  #older pi-apps installations used an autostarted script with the 'onboot' flag.\n  runmode=autostarted\nelif [ \"$runmode\" == source ];then\n  #this script can be sourced to get functions: source \"${DIRECTORY}/updater\" source\n  return 0\nelif [ -z \"$runmode\" ];then\n  #if no runmode was specified, default to gui.\n  runmode=gui\nfi\n\n#get remaining arguments to pass them to yad\nshift;args=(\"$@\")\nif [ ! -z \"$(echo \"${args[@]}\")\" ];then\n  echo \"Flags to be passed to yad: ${args[*]}\"\nfi\n\n#runmode values: autostarted, get-status, set-status, gui, gui-yes, cli, cli-yes\n\nmkdir -p \"${DIRECTORY}/data/update-status\"\n\nstatus \"\\nUpdater mode: $runmode\\n\"\nif [ \"$runmode\" == autostarted ];then #if update-interval allows, and one app installed, display notification on boot\n  \n  #check if update interval allows update-checks, otherwise exit\n  check_update_interval\n  if [ $? != 0 ];then\n    status \"Won't check for updates today, because the update interval is set to '$(cat \"${DIRECTORY}/data/settings/Check for updates\")' in Settings.\"\n    exit 0\n  fi\n  \n  #check that at least one app has been installed by the user\n  if [ \"$(ls \"${DIRECTORY}/data/status\" | wc -l)\" == 0 ];then\n    status \"No apps have been installed yet, so exiting now.\"\n    exit 0\n  fi\n  \n  #wait until internet works\n  iter=1\n  while ! command wget --spider https://github.com &>/dev/null ;do\n    echo -n \"Pi-Apps updater script: no internet connection yet. \"\n    echo \" Waiting 10 seconds...\"\n    sleep 10\n    iter=$(( $iter + 1 ))\n    if [[ \"$iter\" -gt 18 ]]; then\n      exit 0\n    fi\n  done\n  \n  check_repo\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=\"$(get_updatable_files)\"\n\n  #Auto-refresh pi-apps files and apps that are not new and are not going to be reinstalled\n  if [ ! -z \"$updatable_files\" ] || [ ! -z \"$updatable_apps\" ];then\n    #run background updater\n    update_now_background\n    \n    #check what is updatable again\n    updatable_apps=\"$(get_updatable_apps)\"\n    updatable_files=\"$(get_updatable_files)\"\n  fi\n\n  #write to updatable-apps file only if something was changed\n  if [ \"$updatable_apps\" != \"$(cat \"${DIRECTORY}/data/update-status/updatable-apps\" 2>/dev/null)\" ];then\n    echo \"$updatable_apps\" | grep . > \"${DIRECTORY}/data/update-status/updatable-apps\"\n  fi\n  \n  #write to updatable-files file only if something was changed\n  if [ \"$updatable_files\" != \"$(cat \"${DIRECTORY}/data/update-status/updatable-files\" 2>/dev/null)\" ];then\n    echo \"$updatable_files\" | grep . > \"${DIRECTORY}/data/update-status/updatable-files\"\n  fi\n  \n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"Nothing is updatable.\"\n    exit 0\n  elif [ -z \"$updatable_files\" ] && [ -z \"$(echo \"$updatable_apps\" | list_intersect \"$(list_apps installed)\")\" ];then\n    status \"No installed apps are updatable.\"\n    exit 0\n  fi\n  \n  #get dimensions of primary screen\n  screen_dimensions=\"$(xrandr --nograb --current | awk -F 'connected |\\\\+|\\\\('  '/ connected.*[0-9]+x[0-9]+\\+/ && $2 {printf $2 \", \"}' | sed -n -e 's/^.*primary //p' | tr 'x+' ' ' | tr ',+' ' ')\"\n  if [ -z \"$screen_dimensions\" ];then\n    # if screen_dimensions is empty, this could be a single monitor wayland display which does not have the word \"primary\" in the output\n    # workaround is to get the first output returned for the connected display\n    screen_dimensions=\"$(xrandr --nograb --current | awk -F 'connected |\\\\+|\\\\('  '/ connected.*[0-9]+x[0-9]+\\+/ && $2 {printf $2 \", \"}' | tr 'x+' ' ' | tr ',+' ' ')\"\n  fi\n  screen_width=\"$(awk '{print $1}' <<<\"$screen_dimensions\")\"\n  screen_height=\"$(awk '{print $2}' <<<\"$screen_dimensions\")\"\n  \n  status \"Displaying notification in lower-right of screen...\"\n  { #display notification in lower-right\n    output=\"$(yad --class Pi-Apps --name \"Pi-Apps\" --form --text='Pi-Apps updates available.' --separator='\\n' \\\n      --on-top --skip-taskbar --undecorated --close-on-unfocus \\\n      --geometry=260+$((screen_width-262))+$((screen_height-150)) \\\n      --image=\"${DIRECTORY}/icons/logo-64.png\" \\\n      --field='Never show again':CHK FALSE \\\n      --button=\"Details!${DIRECTORY}/icons/info.png\":0 --button=\"Skip!${DIRECTORY}/icons/exit.png\":2)\"\n    button=$?\n    \n    #if Details not clicked, and checkbox clicked, launch a dialog to change the update interval\n    if [ $button != 0 ];then\n      if [ \"$(echo \"$output\" | grep . )\" == TRUE ];then\n        #User checked the 'Never show again' box, so ask to change update interval\n        curval=\"$(cat \"${DIRECTORY}/data/settings/Check for updates\")\"\n        [ -z \"$curval\" ] && curval=\"$(cat \"${DIRECTORY}/etc/setting-params/Check for updates\" | grep -v '#' | head -n1)\"\n        \n        params=\"$(cat \"${DIRECTORY}/etc/setting-params/Check for updates\" | grep -v '#')\"\n        params=\"$(echo \"$params\" | grep -x \"$curval\" | tr '\\n' '!')!$(echo \"$params\" | grep -vx \"$curval\" | tr '\\n' '!')\"\n        params=\"$(echo -e \"$params\" | sed 's/!!/!/g' | sed 's/!$//g' | sed 's/^!//g')\"\n        \n        echo \"Params: '$params'\"\n        \n        output=\"$(yad --class Pi-Apps --name \"Pi-Apps\" --center --title='Change Pi-Apps update interval' --width=440 \\\n          --form --separator='\\n' --window-icon=\"${DIRECTORY}/icons/logo.png\" \\\n          --text=\"You just requested for Pi-Apps to <i>never check for updates</i> on boot.\"$'\\n'\"Are you sure? If so, change the update interval to \"\\\"\"<b>Never</b>\"\\\"\" below.\" \\\n          --field='Update interval: ':CB \"$params\" \\\n          --button=Cancel!\"${DIRECTORY}/icons/exit.png\":1 \\\n          --button=Save!\"${DIRECTORY}/icons/check.png\":0)\"\n        button=$?\n        \n        output=\"$(echo \"$output\" | grep .)\"\n        if [ $button == 0 ];then #save button clicked\n          echo \"$output\" > \"${DIRECTORY}/data/settings/Check for updates\"\n        fi\n      fi\n      #since Details was not clicked, exit now\n      exit 0\n    fi\n  }\n  \n  list_updates_gui\n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"User did not allow anything to be updated.\"\n    exit 0\n  fi\n  \n  update_now_gui\n  \nelif [ \"$runmode\" == 'get-status' ];then #Check if anything was deemed updatable the last time updates were checked for.\n  \n  if [ -s \"${DIRECTORY}/data/update-status/updatable-files\" ] || [ -s \"${DIRECTORY}/data/update-status/updatable-apps\" ];then\n    exit 0\n  else\n    exit 1\n  fi\n  \nelif [ \"$runmode\" == 'set-status' ];then #check for updates and write updatable apps/files to \"${DIRECTORY}/data/update-status\"\n  check_repo\n\n  #runonce entries\n  \"${DIRECTORY}/etc/runonce-entries\"\n\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=\"$(get_updatable_files)\"\n  \n  #write to updatable-apps file only if something was changed\n  if [ \"$updatable_apps\" != \"$(cat \"${DIRECTORY}/data/update-status/updatable-apps\")\" ];then\n    echo \"$updatable_apps\" | grep . > \"${DIRECTORY}/data/update-status/updatable-apps\"\n  fi\n  \n  #write to updatable-files file only if something was changed\n  if [ \"$updatable_files\" != \"$(cat \"${DIRECTORY}/data/update-status/updatable-files\")\" ];then\n    echo \"$updatable_files\" | grep . > \"${DIRECTORY}/data/update-status/updatable-files\"\n  fi\n\n  # this is the only part of any script that is called after running an update using the new files\n  # since the new gui merge requires the gui script to be restarted, use this opportunity to kill the old GUI and start a new one\n  # only done once with a runonce if current gui format version is not 2\n  runonce <<\"EOF\"\n    if [[ \"$GUI_FORMAT_VERSION\" != 2 ]]; then\n      pkill gui && ( \"${DIRECTORY}/gui\" & )\n      echo \"stopped the GUI\"\n    else\n      echo \"skipped stopping the gui\"\n    fi\nEOF\n  \n  \"$0\" get-status &>/dev/null\n  exit $?\n  \nelif [ \"$runmode\" == gui ];then #dialog-list of updatable apps, with checkboxes and an Update button\n  check_repo\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=\"$(get_updatable_files)\"\n\n  \n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"Nothing is updatable.\"\n    exit 0\n  fi\n  \n  list_updates_gui\n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"User did not allow anything to be updated.\"\n    echo\n    exit 0\n  fi\n  \n  if [ \"$use_terminal\" == 0 ];then\n    update_now_cli\n    \"${DIRECTORY}/updater\" set-status \n  else\n    update_now_gui\n  fi\n  \nelif [ \"$runmode\" == gui-yes ];then #update now without asking for confirmation\n  check_repo\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=\"$(get_updatable_files)\"\n  \n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"Nothing is updatable.\"\n    exit 0\n  fi\n  \n  update_now_gui\n  \n\nelif [ \"$runmode\" == cli ];then #return list of updatable apps, and ask the user permission to update\n  check_repo\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=\"$(get_updatable_files)\"\n  echo\n  \n  #if no updatable files and updatebla apps\n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"Everything is up to date.\"\n    exit 0\n  fi\n  \n  #if no updatable apps\n  if [ -z \"$updatable_apps\" ];then\n    status \"All apps are up to date.\"\n  else\n    IFS=$'\\n'\n    updatable_apps_options=($(echo -e \"$updatable_apps\"))\n    status \"App updates available.\\nUncheck an app to skip updating it.\"\n    list_updates_cli result updatable_apps_options \n\n    i=0\n    IFS=$'\\n'\n    for app in $updatable_apps; do\n      if [ \"${result[$i]}\" == \"true\" ]; then\n        apps_to_update+=\"$app\\n\"\n      fi\n      i=\"$(($i+1))\"\n    done\n\n    updatable_apps=\"$(echo -e \"$apps_to_update\")\"\n  fi\n\n  echo\n\n  #if no updatable files\n  if [ -z \"$updatable_files\" ];then\n    status \"All files are up to date.\"\n  else\n    IFS=$'\\n'\n    updatable_files_options=($(echo -e \"$updatable_files\"))\n    status \"File updates available.\\nUncheck a file to skip updating it.\"\n    list_updates_cli result updatable_files_options \n\n    i=0\n    IFS=$'\\n'\n    for file in $updatable_files; do\n      if [ \"${result[$i]}\" == \"true\" ]; then\n        files_to_update+=\"$file\\n\"\n      fi\n      i=\"$(($i+1))\"\n    done\n\n    updatable_files=\"$(echo -e \"$files_to_update\")\"\n  fi\n  \n  echo\n  \n  if [ ! -z \"$updatable_files\" ] || [ ! -z \"$updatable_apps\" ];then\n    printf \"${ESC}[?25l\"\n    for i in {6..1}; do \n      echo -ne \"Updating in: $i\\r (Use Ctrl-C to abort) \" && sleep 1\n    done\n    printf \"${ESC}[?25h\"\n    echo -e \"\\n\"\n\n    update_now_cli\n    \"${DIRECTORY}/updater\" set-status \n  else\n    status \"User did not allow anything to be updated.\"\n    exit 0\n  fi\n\n  \nelif [ \"$runmode\" == cli-yes ];then #update now without asking for confirmation\n  check_repo\n  updatable_apps=\"$(get_updatable_apps)\"\n  updatable_files=\"$(get_updatable_files)\"\n  echo \n  \n  if [ -z \"$updatable_files\" ] && [ -z \"$updatable_apps\" ];then\n    status \"Nothing is updatable.\"\n    exit 0\n  fi\n  \n  if [ -z \"$updatable_apps\" ];then\n    status \"No apps can be updated.\"\n    echo\n  else\n    status \"These apps can be updated:\"\n    echo\n    echo \"$updatable_apps\" | sed 's/^/  - /g'\n    echo\n  fi\n  \n  if [ -z \"$updatable_files\" ];then\n    status \"No files can be updated.\"\n    echo\n  else\n    status \"These files can be updated:\"\n    echo\n    echo \"$updatable_files\" | sed 's/^/  - /g'\n    echo\n  fi\n  \n  echo\n  update_now_cli\n  \nelse\n  error \"updater: unknown run mode. Exiting now.\\n\"\nfi\n\necho \nexit 0\n} #prevents errors if script was modified while in use\n"
        }
      ]
    }
  ]
}