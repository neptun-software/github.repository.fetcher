{
  "metadata": {
    "timestamp": 1736568628737,
    "page": 706,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jwiegley/git-scripts",
      "stars": 1359,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1904296875,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = 4\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.rb]\nindent_size = 2\n\n[*.md]\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "/git-merge-changelog\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.1357421875,
          "content": "Git scripts written by different people.\n\nNote: some scripts depend on each other, so it's a good idea to put all of\nthem in your `$PATH`.\n"
        },
        {
          "name": "git-addremove",
          "type": "blob",
          "size": 0.0947265625,
          "content": "#!/bin/sh\n\ngit add -A\ngit ls-files --deleted -z | while read -r file; do\n    git rm \"$file\"\ndone\n"
        },
        {
          "name": "git-addsub",
          "type": "blob",
          "size": 0.60546875,
          "content": "#!/usr/bin/env bash\n\n# This script makes it much easier to add new submodules\n\nGIT_DIR=$(git rev-parse --git-dir)\n\nPROJ_DIR=$(dirname \"$GIT_DIR\")\nPROJ_DIR=$(abspath \"$PROJ_DIR\")\nPROJ_RE=$(echo \"$PROJ_DIR/\" | sed 's/\\//\\\\\\//g')\n\nfor dir in \"$@\"; do\n    SUBDIR=$(abspath \"$dir\")\n    SUBDIR=$(echo $SUBDIR | sed s/$PROJ_RE//)\n\n    repo=$(grep \"url = \" \"$dir/.git/config\" | \\\n        sed 's/.*url = //' | \\\n        sed 's/git@github.com:\\([^\\/]*\\)\\//git:\\/\\/github.com\\/\\1\\//' )\n\n    (cd \"$PROJ_DIR\" && \\\n     git submodule add \"$repo\" \"$SUBDIR\" && \\\n     git commit -m \"Added submodule $SUBDIR\")\ndone\n\n### addsub ends here\n"
        },
        {
          "name": "git-addtree",
          "type": "blob",
          "size": 0.0869140625,
          "content": "#!/usr/bin/env bash\ngit subtree add --prefix \"$1\" \"ext/$(basename \"$1\")\" master --squash\n"
        },
        {
          "name": "git-all-commits",
          "type": "blob",
          "size": 0.4013671875,
          "content": "#!/bin/sh\n\nfind .git/objects -type f | \\\nwhile read -r file; do\n    if echo \"$file\" | grep -Eq '\\.idx$'; then\n        git show-index < \"$file\" | awk '{print $2}'\n    elif echo \"$file\" | grep -Eq '[0-9a-f]{38}$'; then\n        echo \"$(basename \"$(dirname \"$file\")\")$(basename \"$file\")\"\n    fi\ndone | \\\nwhile read -r hash; do\n    if [ \"$(git cat-file -t \"$hash\")\" = commit ]; then\n        echo \"$hash\"\n    fi\ndone\n"
        },
        {
          "name": "git-all-objects",
          "type": "blob",
          "size": 0.279296875,
          "content": "#!/usr/bin/env bash\nset -e\nshopt -s nullglob extglob\n\ncd \"$(git rev-parse --git-path objects)\"\n\n# packed objects\nfor p in pack/pack-*([0-9a-f]).idx ; do\n    git show-index < \"$p\" | cut -f 2 -d ' '\ndone\n\n# loose objects\nfor o in [0-9a-f][0-9a-f]/*([0-9a-f]) ; do\n    echo \"${o/\\/}\"\ndone\n"
        },
        {
          "name": "git-all.rb",
          "type": "blob",
          "size": 4.49609375,
          "content": "#!/usr/bin/env ruby\n\n# Report the status of all Git repositories within a directory tree.\n\nrequire 'main'\nrequire 'git'\n\n$params = []\n\ntrap('INT') { exit 1 }\n\nmodule GitUpdate\n  @sep_printed = false\n  @last_empty = false\n\n  def GitUpdate.separator\n    if @sep_printed\n      if not @last_empty\n        print \"\\n\"\n      end\n      @last_empty = false\n    else\n      @sep_printed = true\n    end\n  end\n\n  def GitUpdate.top_ten category, message, lines, second_flag=false, marker='='\n    return if $params[:fetch].value and marker == '='\n\n    if not lines.empty? or ($params[:verbose].value and not second_flag)\n      separator\n      puts marker * 2 + \" #{category} \" + marker * 2 + \"  #{message}\"\n      if lines.empty?\n        @last_empty = true\n      else\n        puts lines.first(10).map { |line| line[0...80] }\n        if lines.size > 10\n          puts \"... (and #{lines.size - 10} more)\"\n        end\n      end\n    end\n  end\n\n  def GitUpdate.git_svn_repo g\n    g.config['svn-remote.svn.url'] rescue false\n  end\n\n  def GitUpdate.fetch g, working_dir\n    case\n    when git_svn_repo(g)\n      lines = `git --git-dir='#{@git_dir}' svn fetch 2>&1`.split(\"\\n\")\n      lines.reject! do |line|\n        line =~ /^(W: |This may take a while|Checked through|$)/\n      end\n      lines.compact!\n\n      top_ten 'SVN FETCH', working_dir, lines\n    else\n      begin\n        options = '-q --progress --all --prune --tags'\n        out = `git --git-dir='#{@git_dir}' fetch #{options} 2>&1`\n        top_ten 'FETCH', working_dir, out.split(\"\\n\")\n\n      rescue Git::GitExecuteError => msg\n        puts \"Error: #{msg}\"\n      end\n    end\n  end\n\n  def GitUpdate.status working_dir\n    options = '--porcelain'\n    if $params[:untracked].value\n      options << ' --untracked-files=normal'\n    else\n      options << ' --untracked-files=no'\n    end\n\n    changes = `git --git-dir='#{@git_dir}' status #{options}`\n\n    top_ten 'STATUS', working_dir, changes.split(\"\\n\"), $params[:fetch].value\n  end\n\n  def GitUpdate.push_or_pull g, working_dir, branch\n    remote = g.config[\"branch.#{branch.name}.remote\"] || git_svn_repo(g)\n    if remote\n      remote_sha =\n        if git_svn_repo(g)\n          g.revparse 'trunk' rescue g.revparse 'git-svn'\n        else\n          g.revparse File.join(remote, branch.name)\n        end\n\n      if branch.gcommit.sha != remote_sha\n        git_log = \"git --git-dir='#{@git_dir}' log --no-merges --oneline\"\n\n        out = `#{git_log} #{remote_sha}..#{branch.gcommit.sha}`\n        top_ten('NEED PUSH', \"#{working_dir}\\##{branch.name}\",\n            out.split(\"\\n\"), true)\n\n        if $params[:pulls].value\n          out = `#{git_log} #{branch.gcommit.sha}..#{remote_sha}`\n          top_ten('NEED PULL', \"#{working_dir}\\##{branch.name}\",\n              out.split(\"\\n\"), true)\n        end\n      end\n    end\n  end\n\n  def GitUpdate.report working_dir\n    logger = Logger.new(STDOUT)\n    logger.level = Logger::WARN\n\n    g = Git.open(working_dir, :log => logger)\n    @git_dir = File.join working_dir, '.git'\n\n    if $params[:fetch].value or $params[:fetchonly].value\n      fetch g, working_dir\n    end\n\n    if not $params[:fetchonly].value\n      g.branches.local.each { |b| push_or_pull g, working_dir, b }\n      status working_dir\n    end\n  end\nend\n\nMain {\n  argument(:dir) {\n    arity -1\n    default '.'\n    description 'Directories to scan'\n  }\n\n  option(:fetch) {\n    description 'Fetch from all remotes'\n  }\n  option(:errors) {\n    description 'Only show Git failures'\n  }\n  option(:fetchonly) {\n    description 'Only fetch, nothing else'\n  }\n  option(:pulls) {\n    description 'Include NEED PULL sections'\n  }\n  option(:untracked) {\n    description 'Display untracked files as possible changes'\n  }\n  option(:verbose)\n\n  def run\n    $params  = params\n    seen     = Set.new\n    dirs     = $params[:dir].values * ' '\n    # Relies on GNU find's -printf directive\n    find_cmd = \"find -H #{dirs} -name .git -printf '%p\\\\n\\\\c'\"\n\n    # This asynchronous usage allows the \"find\" command to continue producing\n    # pathnames while we work on them.  Find.find() would block until all the\n    # pathnames had been found, which can be very slow (especially on laptop\n    # hard drives with large filesets).\n\n    IO.popen(find_cmd).each do |path|\n      path = File.absolute_path path\n\n      next if seen.include? path # never process the same path twice\n      seen << path\n\n      begin\n        GitUpdate.report File.dirname(path)\n      rescue => ex\n        GitUpdate.top_ten('FAILED', path, [ex.message] + ex.backtrace,\n                      false, '#')\n      end\n      STDOUT.flush\n    end\n  end\n}\n\n### git-all ends here\n"
        },
        {
          "name": "git-already-merged",
          "type": "blob",
          "size": 0.2998046875,
          "content": "#!/usr/bin/env bash\n\n# From https://railsware.com/blog/git-housekeeping-tutorial-clean-up-outdated-branches-in-local-and-remote-repositories/\n\nfor branch in $(git branch -r --merged | grep -v HEAD)\ndo\n    printf '%s\\t%s\\n' \"$(git show --format=\"%ci %cr %an\" \"$branch\" | head -n 1)\" \"$branch\"\ndone | sort -r\n"
        },
        {
          "name": "git-amend-all",
          "type": "blob",
          "size": 0.6005859375,
          "content": "#!/bin/sh\n\n## Copyright (C) 2006-2011 Daniel Baumann <daniel.baumann@progress-technologies.net>\n##\n## This program comes with ABSOLUTELY NO WARRANTY; for details see COPYING.\n## This is free software, and you are welcome to redistribute it\n## under certain conditions; see COPYING for details.\n\n# Purpose: This script adds all modified and deleted files,\n# except the new files and adds it to the recent commit by amending it\n\nset -e\n\n# User is not in git repository\nif ! git branch > /dev/null 2>&1\nthen\n\techo \"E: '$(basename \"${PWD}\")' - Not a Git repository.\"\n\texit 1\nfi\n\ngit add .\ngit commit -a --amend -C HEAD\n"
        },
        {
          "name": "git-apply-url",
          "type": "blob",
          "size": 1.5703125,
          "content": "#!/bin/sh\n\n# Copyright (c) 2008 Andrew Raines\n#\n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation\n# files (the \"Software\"), to deal in the Software without\n# restriction, including without limitation the rights to use,\n# copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the\n# Software is furnished to do so, subject to the following\n# conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n# OTHER DEALINGS IN THE SOFTWARE.\n\n# Pastebin -> code.\n#\n#    git apply-url https://gist.github.com/raw/.../...53b5\n#    git apply-url http://paste.lisp.org/display/99999999/raw\n#    etc.\n\nURL=$1\n\nerror() {\n  echo \"$*\"\n  exit 1\n}\n\nif [ ! \"$URL\" ]; then\n  error \"usage: $0 URL\"\nfi\n\nif command -v curl >/dev/null 2>&1 && curl -V | grep -q https >/dev/null 2>&1; then\n  fetch=\"curl -s\"\nelif command -v wget >/dev/null 2>&1; then\n  fetch=\"wget -O - -q --no-check-certificate\"\nelse\n  error need curl or wget\nfi\n\n$fetch \"$URL\" | patch -p1\n"
        },
        {
          "name": "git-archive-all",
          "type": "blob",
          "size": 0.5234375,
          "content": "#!/usr/bin/env bash\n\n# Super basic tool to export repo and all submodules\n# as a single zip file\n\n# USAGE: git archive-all foo\n# generates foo.zip\n\nOUTFILE=$1\n\ngit ls-files --cached --full-name --no-empty-directory -z \\\n   | xargs -0 zip \"$OUTFILE.zip\" > /dev/null\n\ngit submodule --quiet foreach --recursive \\\n   'perl -e \"\n      print join qq(\\0),\n        map qq($path/\\$_),\n        split /\\0/,\n        qx(git ls-files -z --cached --full-name --no-empty-directory);\n      print qq(\\0)\"\n    ' | xargs -0 zip \"$OUTFILE.zip\" > /dev/null\n\n"
        },
        {
          "name": "git-branch-done",
          "type": "blob",
          "size": 0.484375,
          "content": "#!/usr/bin/env bash\n# git branch-done <branch>\n\n# destination branch as parameter - depends on merge strategy, typically master\nDST_BRANCH=\"\"\nif [ -n \"$1\" ]; then\n    DST_BRANCH=\"$1\"\nelse\n\techo \"Usage: git branch-done <branch>\"\n\texit 1\nfi\n\n# get  current branch - typically topic branch like taskXXXX, bugXXXX, ...\ncb=$(git rev-parse --abbrev-ref HEAD)\n# no fast forward merge from current branch to destination branch\ngit checkout \"$DST_BRANCH\" && git merge --no-ff \"$cb\" && git branch -d \"$cb\"\n"
        },
        {
          "name": "git-branch-status",
          "type": "blob",
          "size": 0.0419921875,
          "content": "git-branch-status-subtree/git-branch-status"
        },
        {
          "name": "git-branch-status-subtree",
          "type": "tree",
          "content": null
        },
        {
          "name": "git-build",
          "type": "blob",
          "size": 0.4794921875,
          "content": "#!/usr/bin/env bash\n\ngit clean -f -x -d\ngit checkout \"$1\"\n\nrm -fr \"/usr/local/stow/git-$1\"\n\nmake prefix=\"/usr/local/stow/git-$1\" -j3 install\n\ngit checkout origin/man\n\nrsync -av man1/ \"/usr/local/stow/git-$1/share/man/man1/\"\nrsync -av man5/ \"/usr/local/stow/git-$1/share/man/man5/\"\nrsync -av man7/ \"/usr/local/stow/git-$1/share/man/man7/\"\n\ngit clean -f -x -d\ngit checkout master\nchown -R johnw .\n\ngit reset --hard HEAD\ngit merge origin/master\n\ncd /usr/local/stow\nstow -D git-*\n\nstow \"git-$1\"\n"
        },
        {
          "name": "git-changebar",
          "type": "blob",
          "size": 1.873046875,
          "content": "#!/bin/sh\n#\n# git-changebar\n#\n# Will add changebars to a LaTeX file stored in git based on the diff to a past\n# treeish or branch in the repository\n#\n# Copyright (c) Matthew Johnson <src@matthew.ath.cx> 2007\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation version 2.  This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General\n# Public License for more details.  You should have received a copy of the GNU\n# General Public License along with this program; if not, write to the Free\n# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n# USA.\n\n\n\nif [ -z \"$1\" ] || [ -z \"$2\" ] || [ \"--help\" = \"$1\" ]; then\n   echo \"Syntax: $0 <treeish> <file...>\"\n   exit 1\nfi\n\nREV=\"$1\"\nshift\n\nwhile [ -n \"$1\" ]\ndo\n   if grep 'tex[[:space:]]*$' >/dev/null <<@\n$1\n@\n   then\n      FILE=\"$1\"\n      OUT=\"${FILE%.tex}.diff.tex\"\n      cp \"$FILE\" \"$OUT\"\n\n      docstart=$(grep -n 'begin{document}' \"$FILE\" | cut -d: -f1)\n\n      for i in $(GIT_DIFF_OPTS=-u0 git diff \"$REV\" \"$FILE\" |\n                sed -n '/^@@/s/@@ -[0-9,]* +\\([0-9,]*\\).*/\\1/p')\n      do\n         start=$(cut -d, -f1 <<@\n$i\n@\n)\n         if [ \"$start\" -gt \"$docstart\" ]\n         then\n            if grep ',' >/dev/null <<@\n$i\n@\n            then\n               diff=$(cut -d, -f2 <<@\n$i\n@\n)\n            else\n               diff=0\n            fi\n            end=$(( $start + $diff ))\n            sed -i \"${start}s/^/\\\\\\\\cbstart{} /\" \"$OUT\"\n            sed -i \"${end}s/$/ \\\\\\\\cbend{}/\" \"$OUT\"\n         fi\n      done\n\n      sed -i '2i\\\\\\\\usepackage[dvips]{changebar}\\n' \"$OUT\"\n      echo \"Changebars added to $OUT\"\n   else\n      echo \"$1 is not a TeX file\"\n   fi\n\n   shift\ndone\n"
        },
        {
          "name": "git-changelog",
          "type": "blob",
          "size": 2.46875,
          "content": "#!/usr/bin/env python\n\n# git-changelog\n#\n# version 2.0, by John Wiegley\n#\n# The purpose of this code is to turn \"git log\" output into a complete\n# ChangeLog, for projects who wish to begin using a ChangeLog, but haven't\n# been.\n#\n# This version of git-changelog depends on GitPython:\n#   git://gitorious.org/git-python/mainline.git\n\nimport time\nimport string\nimport sys\nimport re\nimport os\n\nfrom git import *               # GitPython\nfrom subprocess import *\n\nrepo = Repo(os.getcwd())\nref  = 'origin/master..'\npath = ''\n\n# Usage: git changelog [COMMITISH] [-- [PATH]]\n\nsaw_dashdash = False\nif len(sys.argv) > 1:\n    for arg in sys.argv[1:]:\n        if arg == \"--\":\n            saw_dashdash = True\n        elif saw_dashdash:\n            path = arg\n        else:\n            ref = arg\n\nfor commit in repo.iter_commits(ref, paths=path):\n    author   = commit.author\n    date     = commit.committed_date\n    log_text = commit.message.split('\\n')[0]\n\n    log_text_remainder = commit.message.split('\\n\\n')[1:]\n    while len(log_text_remainder) > 0 and not log_text_remainder[0]:\n        log_text_remainder = log_text_remainder[1:]\n    log_text_remainder = string.join(log_text_remainder, '\\n\\t')\n    if log_text_remainder:\n        log_text_remainder = '\\n\\t' + log_text_remainder\n\n    diff = commit.diff(commit.parents[0])\n    files = []\n    for f in diff:\n        if not f.a_blob:\n            p = f.b_blob.path\n        elif not f.b_blob:\n            p = f.a_blob.path\n        else:\n            continue\n\n        p2 = re.sub('^' + path + '/', '', p)\n        if p != p2:\n            files.append(p2)\n\n    fp = Popen([\"fmt\", \"-72\"], shell = True, stdin = PIPE, stdout = PIPE)\n    if files:\n        fp.stdin.write(\"\\t* %s: %s\" % (string.join(files, \",\\n\\t\"), log_text))\n    else:\n        fp.stdin.write(\"\\t* %s\" % log_text)\n    fp.stdin.close()\n    log_text = fp.stdout.read()\n    del fp\n\n    print \"%s  %s  <%s>\\n\" % \\\n        (time.strftime(\"%Y-%m-%d\", time.gmtime(date)),\n         author.name, author.email)\n\n    if path:\n        log_text = re.sub(' ' + path + '/', ' ', log_text)\n        log_text_remainder = re.sub(' ' + path + '/', ' ', log_text_remainder)\n\n    # If the log_text_remainder already begins with a *, then use that as the\n    # changelog text.\n    if re.match('\\s+\\* ', log_text_remainder):\n        if log_text_remainder[0] == '\\n':\n            print log_text_remainder[1:]\n        else:\n            print log_text_remainder\n    else:\n        print \"%s%s\" % (log_text, log_text_remainder)\n\n# git-changelog ends here\n"
        },
        {
          "name": "git-checkout-branches",
          "type": "blob",
          "size": 1.01953125,
          "content": "#!/bin/sh\n\n## Copyright (C) 2006-2011 Daniel Baumann <daniel.baumann@progress-technologies.net>\n##\n## This program comes with ABSOLUTELY NO WARRANTY; for details see COPYING.\n## This is free software, and you are welcome to redistribute it\n## under certain conditions; see COPYING for details.\n\n\nset -e\n\n# User is not in git repository\nif ! git branch > /dev/null 2>&1\nthen\n\techo \"E: '$(basename \"${PWD}\")' - Not a Git repository.\"\n\texit 1\nfi\n\necho \"P: Checking out all remote branches...\"\n\n# Rememeber current branch\n_CURRENT_BRANCH=\"$(git branch | awk '/^\\* / { print $2 }')\"\n\n# Checkout all remote branches\nfor _REMOTE_BRANCH in $(git branch -r | awk '{ print $1 }')\ndo\n\t_BRANCH_NAME=\"$(echo ${_REMOTE_BRANCH} | cut -d/ -f 2-)\"\n\n\tif [ \"${_BRANCH_NAME}\" != \"HEAD\" ]\n\tthen\n\t\tif ! git branch | grep -q \"${_BRANCH_NAME}$\"\n\t\tthen\n\t\t\tgit checkout -b ${_BRANCH_NAME} ${_REMOTE_BRANCH}\n\t\tfi\n\tfi\ndone\n\n# Switch back to current branch\nif [ \"$(git branch | awk '/^\\* / { print $2 }')\" != \"${_CURRENT_BRANCH}\" ]\nthen\n\tgit checkout ${_CURRENT_BRANCH}\nfi\n"
        },
        {
          "name": "git-children-of",
          "type": "blob",
          "size": 0.162109375,
          "content": "#!/usr/bin/env bash\n\ncommit=$1\nbranch=$2\n\n[ -z \"$branch\" ] && branch=HEAD\n\ngit rev-list --children \"$branch\" --not \"$commit^@\" \\\n   | awk \"/^$commit/ { print \\$2 }\"\n\n"
        },
        {
          "name": "git-clone.sh",
          "type": "blob",
          "size": 0.4462890625,
          "content": "#!/usr/bin/env bash\n\n# this script clones a repository, including all its remote branches\n# Author: julianromera\n\nif [[ -z \"$1\" || -z \"$2\" ]];then\n  echo \"use: $0 <git_repository_to_clone> <directory>\"\n  exit 1\nfi\n\n\nfunction clone {\n\n  git clone -q \"$1\" \"$2\"\n  cd \"$2\"\n\n  git pull --all\n\n  for remote in $(git branch -r | grep -v \\>); do\n     git branch --track \"${remote#origin/}\" \"$remote\";\n  done\n}\n\necho \"cloning repository into ... $2\"\nclone \"$1\" \"$2\"\n"
        },
        {
          "name": "git-closest-match",
          "type": "blob",
          "size": 0.892578125,
          "content": "#!/bin/sh\n# find the closest match from all (or a limited amount) of the reachable trees to a specified tree (where tree is referenced by it's checksum)\n# very useful to process the results of `git fsck --unreachable | cut -d\\  -f3`\n\nspec=$1\nmode=${2:-diff} # num: number of lines or diff: actual diff/log message?\nrange=${3:-30} # 'all' or most recent <num> in current branch?. 'all' can be quite slow\nif [ \"$range\" = 'all' ]; then\n\tall=$(git rev-list --all | awk '/^commit/ {print $NF}')\nelse\n\tall=$(git log -n \"$range\" | awk '/^commit/ {print $NF}')\nfi\n\ncommit=$(for i in $all; do\n\tprintf '%s\\n' \"$i \"\n\t# why is there no git diff --shortnumstat ?\n\tgit diff -M \"$spec\" \"$i\" | wc -l\ndone | sort -k 2 -n | head -n 1 | cut -f 1 -d ' ')\nif [ \"$mode\" = diff ]; then\n\tgit log --no-walk \"$commit\" | cat -\n\tgit diff -M \"$spec\" \"$commit\" | cat -\nelse\n\tprintf '%s\\n' \"$commit: \"\n\t git diff -M \"$spec\" \"$commit\" | wc -l\nfi\n"
        },
        {
          "name": "git-cmpdir",
          "type": "blob",
          "size": 0.302734375,
          "content": "#!/usr/bin/env bash\n\nstat=false\nif [[ \"$1\" == \"--stat\" ]]; then\n    stat=true\n    shift 1\nfi\n\ngit checkout \"$1\"\nsync\necho ----------------------------------------------------------------------\n\nif [[ $stat == true ]]; then\n    diff -w -U3 -r . \"$2\" | diffstat | grep -v only$\nelse\n    diff -w -U3 -r . \"$2\"\nfi\n"
        },
        {
          "name": "git-contr",
          "type": "blob",
          "size": 0.1162109375,
          "content": "#!/bin/sh\n\nfilePath=$1\n\ngit blame --line-porcelain -C \"$filePath\" | sed -n 's/^author //p' |\nsort | uniq -c | sort -rn\n"
        },
        {
          "name": "git-current",
          "type": "blob",
          "size": 0.4404296875,
          "content": "#!/usr/bin/env bash\n\nif [[ -z \"$1\" ]]; then\n    ancestor=master\nelse\n    ancestor=$1\n    shift 1\nfi\ncurrent=\"$ancestor\"\n\nancestor=$(git rev-parse \"$ancestor\")\n\nfor head in $(git rev-parse --branches); do\n    if [[ $head != \"$ancestor\" ]]; then\n        if git rev-list -30 \"$head\" | grep -q \"$ancestor\"; then\n            current=\"$current $(git describe --all --abbrev=0 \"$head\" | sed 's/heads\\///')\"\n        fi\n    fi\ndone\n\ngit show-branch \"$current\"\n"
        },
        {
          "name": "git-current-branch",
          "type": "blob",
          "size": 0.05078125,
          "content": "#!/usr/bin/env bash\ngit rev-parse --abbrev-ref HEAD\n"
        },
        {
          "name": "git-delete-branch",
          "type": "blob",
          "size": 0.080078125,
          "content": "#!/bin/sh\n# remove remote git branch\n\ngit branch -D \"$1\" && git push origin \":$1\"\n"
        },
        {
          "name": "git-delete-tag",
          "type": "blob",
          "size": 0.0810546875,
          "content": "#!/bin/sh\n# remove remote git tag\n\ngit tag -d \"$1\"\ngit push origin \":refs/tags/$1\"\n"
        },
        {
          "name": "git-diff-directory",
          "type": "blob",
          "size": 0.2626953125,
          "content": "#!/usr/bin/env bash\n\nstat=true\nif [[ \"$1\" == \"-p\" ]]; then\n    stat=false\n    shift 1\nfi\n\nHERE=$(pwd)\n\n(cd \"$1\" && git --git-dir=\"$HERE/.git\" diff \"${2:-HEAD}\") | \\\n    if [[ $stat == true ]]; then \\\n        diffstat | grep -v only$; \\\n    else \\\n        cat; \\\n    fi\n"
        },
        {
          "name": "git-diff-dw",
          "type": "blob",
          "size": 0.0947265625,
          "content": "#!/bin/sh\n/Applications/Misc/DeltaWalker.app/Contents/MacOS/DeltaWalker -nosplash \"$PWD/$1\" \"$2\"\n"
        },
        {
          "name": "git-dired.el",
          "type": "blob",
          "size": 3.1025390625,
          "content": ";;; git-dired.el --- Hacks to dired for it to play nicer with Git\n\n;; Copyright (C) 2008-2009 John Wiegley <johnw@newartisans.com>\n\n;; Emacs Lisp Archive Entry\n;; Filename: git-dired.el\n;; Version: 1.0\n;; Keywords: git dvcs vc\n;; Author: John Wiegley <johnw@newartisans.com>\n;; Maintainer: John Wiegley <johnw@newartisans.com>\n;; Description: Hacks to dired for it to play nicer with Git\n;; URL: http://github.com/jwiegley/git-scripts/tree/master\n;; Compatibility: Emacs22, Emacs23\n\n;; This file is not part of GNU Emacs.\n\n;; This is free software; you can redistribute it and/or modify it under\n;; the terms of the GNU General Public License as published by the Free\n;; Software Foundation; either version 2, or (at your option) any later\n;; version.\n;;\n;; This is distributed in the hope that it will be useful, but WITHOUT\n;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n;; for more details.\n;;\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to the\n;; Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n;; MA 02111-1307, USA.\n\n;;; Commentary:\n\n(eval-after-load \"dired-x\"\n  '(progn\n     (defvar dired-omit-regexp-orig (symbol-function 'dired-omit-regexp))\n\n     (defun dired-omit-regexp ()\n       (let ((file (expand-file-name \".git\"))\n             parent-dir)\n         (while (and (not (file-exists-p file))\n                     (progn\n                       (setq parent-dir\n                             (file-name-directory\n                              (directory-file-name\n                               (file-name-directory file))))\n                       ;; Give up if we are already at the root dir.\n                       (not (string= (file-name-directory file)\n                                     parent-dir))))\n           ;; Move up to the parent dir and try again.\n           (setq file (expand-file-name \".git\" parent-dir)))\n         ;; If we found a change log in a parent, use that.\n         (if (file-exists-p file)\n             (let ((regexp (funcall dired-omit-regexp-orig))\n                   (omitted-files (shell-command-to-string\n                                   \"git clean -d -x -n\")))\n               (if (= 0 (length omitted-files))\n                   regexp\n                 (concat\n                  regexp\n                  (if (> (length regexp) 0)\n                      \"\\\\|\" \"\")\n                  \"\\\\(\"\n                  (mapconcat\n                   #'(lambda (str)\n                       (concat \"^\"\n                               (regexp-quote\n                                (substring str 13\n                                           (if (= ?/ (aref str (1- (length str))))\n                                               (1- (length str))\n                                             nil)))\n                               \"$\"))\n                   (split-string omitted-files \"\\n\" t)\n                   \"\\\\|\")\n                  \"\\\\)\")))\n           (funcall dired-omit-regexp-orig))))))\n\n(provide 'git-dired)\n\n;;; git-dired.el ends here\n"
        },
        {
          "name": "git-discover-large-blobs",
          "type": "blob",
          "size": 1.7021484375,
          "content": "#!/usr/bin/env bash\n#set -x\n\n# Shows you the largest objects in your repo's pack file.\n#\n# @see http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/\n# @author Antony Stubbs\n# ChangeLog\n#\n#       Originally by Antony Stubbs http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/\n#\n#       <javabrett>\n#       - Make command work when in the non-root directory of a repo, or from the top-level of a bare repo\n#\n\n\n# set the internal field separator to line break, so that we can iterate easily over the verify-pack output\nIFS=$'\\n';\n\n# find top-level dir of a non-bare repo\n_GIT_DIR=$(git rev-parse --show-toplevel) || exit 1\n\nif [ -n \"${_GIT_DIR}\" ] && [ -d \"${_GIT_DIR}\"/.git/objects/pack ]; then\n\tPACK_DIR=${_GIT_DIR}/.git/objects/pack\nelif [ -d ./objects/pack ]; then\n\t# bare repo\n\tPACK_DIR=./objects/pack\nelse\n\techo \"Cannot locate pack directory\"\n\texit 1\nfi\n\n# list all objects including their size, sort by size, take top 10\nobjects=$(git verify-pack -v \"${PACK_DIR}\"/pack-*.idx | grep -v chain | sort -k3nr | head)\n\necho \"All sizes are in kB's. The pack column is the size of the object, compressed, inside the pack file.\"\n\noutput=\"size,pack,SHA,location\"\nfor y in $objects\ndo\n\t# extract the size in bytes\n\tsize=$(($(echo $y | cut -f 5 -d ' ')/1024))\n\t# extract the compressed size in bytes\n\tcompressedSize=$(($(echo $y | cut -f 6 -d ' ')/1024))\n\t# extract the SHA\n\tsha=$(echo $y | cut -f 1 -d ' ')\n\t# find the objects location in the repository tree\n\tother=$(git rev-list --all --objects | grep \"$sha\")\n\t#lineBreak=`echo -e \"\\n\"`\n\toutput=\"${output}\\n${size},${compressedSize},${other}\"\ndone\n\necho -e \"$output\" | column -t -s ', '\n"
        },
        {
          "name": "git-each",
          "type": "blob",
          "size": 0.2724609375,
          "content": "#!/usr/bin/env bash\nset -e\n\ndirs=\".\"\nif [[ \"$1\" == --dir ]]; then\n    dirs=\"$2\"\n    shift 2\nfi\n\nexec find $dirs \\( -path '*/.git/config' -o \\\n                   -regex '.*/.git/.*/config' \\) -type f -print0 \\\n         | parallel -0 --bar -j0 --delay 1 -k \"git --git-dir={//} $*\"\n"
        },
        {
          "name": "git-empty-branch",
          "type": "blob",
          "size": 0.0869140625,
          "content": "#!/bin/sh\n\ngit stash\ngit symbolic-ref HEAD \"refs/heads/$1\"\nrm .git/index\ngit clean -f -d\n"
        },
        {
          "name": "git-erase-reflog",
          "type": "blob",
          "size": 0.04296875,
          "content": "#!/bin/sh\ngit reflog expire --expire=0 \"$@\"\n"
        },
        {
          "name": "git-every",
          "type": "blob",
          "size": 0.0810546875,
          "content": "#!/usr/bin/env bash\nexec find . -name .git -type d -exec git --git-dir=\"{}\" \"$@\" \\;"
        },
        {
          "name": "git-external-ediff",
          "type": "blob",
          "size": 0.0732421875,
          "content": "#!/bin/sh\n\n[ $# -eq 7 ] && emacsclient --eval \"(ediff \\\"$2\\\" \\\"$PWD/$5\\\")\"\n"
        },
        {
          "name": "git-fat-objects",
          "type": "blob",
          "size": 0.3134765625,
          "content": "#!/usr/bin/env bash\ngit rev-list --all --objects | \\\n    sed -n $(git rev-list --objects --all | \\\n    cut -f1 -d' ' | \\\n    git cat-file --batch-check | \\\n    grep blob | \\\n    sort -n -k 3 | \\\n    tail -n40 | \\\n    while read -r hash _type size; do\n         echo -n \"-e s/$hash/$size/p \";\n    done) | \\\n    sort -n -k1\n"
        },
        {
          "name": "git-fetch-github",
          "type": "blob",
          "size": 0.1162109375,
          "content": "#!/usr/bin/env bash\nREMOTE=${1:-origin}\ngit config \"remote.${REMOTE}.fetch\" \"+refs/pull/*:refs/remotes/${REMOTE}/pr/*\"\n"
        },
        {
          "name": "git-filemerge",
          "type": "blob",
          "size": 0.560546875,
          "content": "#!/bin/sh\nif test $# = 0; then\nOLD=$(git write-tree)\nelif test \"$1\" = --cached; then\nOLD=HEAD\n  NEW=$(git write-tree)\n  shift\nfi\nif test $# -gt 0; then\nOLD=\"$1\"; shift\nfi\ntest $# -gt 0 && test -z \"$CACHED\" && NEW=\"$1\"\nTMPDIR1=$(mktemp -d)\ngit archive --format=tar $OLD | (cd \"$TMPDIR1\"; tar xf -)\nif test -z \"$NEW\"; then\nTMPDIR2=$(git rev-parse --show-cdup)\ntest -z \"$TMPDIR2\" && TMPDIR2=.\nelse\nTMPDIR2=$(mktemp -d)\n  git archive --format=tar $NEW | (cd \"$TMPDIR2\"; tar xf -)\nfi\n\nopendiff \"$TMPDIR1\" \"$TMPDIR2\" | cat\nrm -rf \"$TMPDIR1\"\ntest ! -z \"$NEW\" && rm -rf \"$TMPDIR2\"\n\n"
        },
        {
          "name": "git-find",
          "type": "blob",
          "size": 5.509765625,
          "content": "#!/usr/bin/env ruby\n\n# git-find, version 1.0\n#\n# by John Wiegley <johnw@newartisans.com>\n#\n# usage: git find <commit or tag>...\n#\n# Performs an exhaustive search of your object database to inform you exactly\n# how the given commit or tag fits in your repository.  It tells you all the\n# parents and children of the commit/tag, and every name it can be referenced\n# by.  It will tell you if it can be reached only by a reflog entry, or the\n# stash, or if it's descendend from a dangling commit.\n#\n# TODO: Add support for searching for blobs and trees as well.\n#\n# NOTE: This script can be very slow.\n\nclass GitObject\n  attr_reader :ident\n\n  def initialize(ident)\n    @ident = ident\n  end\nend\n\nclass Blob < GitObject\n  attr_reader :names\n\n  def initialize(ident)\n    super ident\n    @names = []\n  end\n\n  def add_name(name)\n    @names.push(name)\n  end\nend\n\nclass Tree < GitObject\n  attr_reader :names\n\n  def initialize(ident)\n    super ident\n    @names = []\n  end\n\n  def add_name(name)\n    @names.push(name)\n  end\nend\n\nclass Commit < GitObject\n  attr_reader :names\n  attr_reader :parents\n  attr_reader :children\n\n  def initialize(ident, *parents)\n    super ident\n    @names    = []\n    @parents  = parents\n    @children = []\n  end\n\n  def add_name(name)\n    @names.push(name)\n  end\n\n  def add_parent(parent)\n    unless @parents.include?(parent)\n      @parents.push(parent)\n      parent.add_child(self)\n    end\n  end\n\n  def add_child(child)\n    unless @children.include?(child)\n      @children.push(child)\n    end\n  end\n\n  def assign_name(name)\n    if @names.include?(name)\n      return\n    end\n    puts name\n    add_name(name)\n\n    offset = 0\n    @parents.each do |parent|\n      if offset == 0\n        if name =~ /(.+?)~([0-9]+)$/\n          child_name = $1 + \"~\" + ($2.to_i + 1).to_s\n        else\n          child_name = name + \"~1\"\n        end\n      else\n        child_name = name + \"^\" + (offset + 1).to_s\n      end\n      parent.assign_name(child_name)\n      offset += 1\n    end\n  end\nend\n\nclass Tag < GitObject\n  attr_reader :name\n  attr_reader :commit\n\n  def initialize(ident, name, commit)\n    super ident\n    @name = name\n    @commit = commit\n  end\nend\n\nclass Ref\n  attr_reader :name\n  attr_reader :commit\n\n  def initialize(name, commit)\n    @name   = name\n    @commit = commit\n  end\nend\n\n$objects = {}\n\n# Build up a full commit history for every ref, and each reflog entry for each\n# ref.\n\ndef get_ref_history(ref)\n  first_obj = true\n\n  `git rev-list --parents #{ref}`.split(\"\\n\").each do |entry|\n    commit, *parents = entry.split(' ')\n\n    if $objects.has_key?(commit)\n      obj = $objects[commit]\n    else\n      obj = Commit.new(commit)\n      $objects[commit] = obj\n    end\n\n    if first_obj and ref =~ /\\/tags\\//\n      id = `git rev-parse #{ref}`.chomp\n      $objects[id] = Tag.new(id, ref, obj)\n      first_obj = false\n    end\n\n    if obj.parents.size == 0\n      parents.each do |parent|\n        if $objects.has_key?(parent)\n          parent_obj = $objects[parent]\n        else\n          parent_obj = Commit.new(parent)\n          $objects[parent] = parent_obj\n        end\n        obj.add_parent(parent_obj)\n      end\n    end\n  end\nend\n\ndef process_names(ref, name = nil, hash = nil)\n  # Assign symbolic names to each commit\n  if not hash\n    hash = `git rev-parse #{ref}`.chomp\n  end\n  raise \"Cannot locate object #{ref} => #{hash}\" if not $objects.has_key?(hash)\n  obj = $objects[hash]\n  if obj.is_a? Tag\n    obj.commit.assign_name(name ? name : ref)\n  else\n    obj.assign_name(name ? name : ref)\n  end\nend\n\n$refs = `git rev-parse --symbolic --all`.split\n$refs.push(\"HEAD\")\n\nputs \"Processing refs history ...\"\n$refs.each { |ref| get_ref_history(ref) }\n$refs.each { |ref| process_names(ref) }\n\n$hashes = ARGV[0].map { |ref| `git rev-parse #{ref}`.chomp }\n\n$search_reflogs = false\n$hashes.each do |hash|\n  unless $objects.has_key?(hash)\n    $search_reflogs = true\n  end\nend\n\nif $search_reflogs\n  puts \"Processing reflogs ...\"\n  $refs.each do |ref|\n    unless ref == \"refs/stash\"\n      # Handle each reflog entry\n      `git reflog show --abbrev=40 #{ref}`.split(\"\\n\").each do |line|\n        if line =~ /^([0-9a-f]{40}) ([^@]+@\\{[0-9]+\\}): /\n          hash = $1\n          unless $objects.has_key?(hash)\n            puts \"  unreachable reflog #{$2}\"\n            get_ref_history $2\n            process_names $2, nil, hash\n          end\n        end\n      end\n    end\n  end\nend\n\n$search_dangling = false\n$hashes.each do |hash|\n  unless $objects.has_key?(hash)\n    $search_dangling = true\n  end\nend\n\nif $search_dangling\n  puts \"Finding unreachable objects ...\"\n  `git fsck --full --unreachable`.split(\"\\n\").each do |item|\n    if item =~ /unreachable (blob|tag|commit|tree) ([a-f0-9]{40})/\n      puts \"  \" + item\n      if $1 == \"blob\"\n        $objects[$2] = Blob.new($2)\n      elsif $1 == \"tag\"\n        commit = Commit.new(`git rev-list -1 #{$2}`.chomp)\n        $objects[$2] = Tag.new($2, \"<dangling>\", commit)\n        get_ref_history $2\n        process_names $2, \"dangling-tag-#{$2}\"\n      elsif $1 == \"commit\"\n        get_ref_history $2\n        process_names $2, \"dangling-commit-#{$2}\"\n      elsif $1 == \"tree\"\n        $objects[$2] = Tree.new($2)\n      end\n    end\n  end\nend\n\nARGV[0].each do |ref|\n  hash = `git rev-parse #{ref}`.chomp\n\n  object = $objects[hash]\n\n  puts \"\"\n  if object.is_a? Tag\n    puts \"Tag #{ref} => #{hash}\"\n    object = object.commit\n    puts \"  commit #{object.ident}\"\n  else\n    puts \"Commit #{ref} => #{hash}\"\n  end\n\n  object.parents.each  { |parent| puts \"  parent #{parent.ident}\" }\n  object.children.each { |child|  puts \"   child #{child.ident}\" }\n  object.names.each    { |name|   puts \"    name #{name}\" }\nend\n"
        },
        {
          "name": "git-find-blob",
          "type": "blob",
          "size": 0.3154296875,
          "content": "#!/bin/sh\n\nfilename=$1\n\nwant=$(git hash-object \"$filename\")\n\ngit rev-list --since=\"6 months ago\" HEAD | while read -r commit ; do\n    git ls-tree -r \"$commit\" | while read -r perm type hash filename; do\n        if test \"$want\" = \"$hash\"; then\n            echo \"matched $filename in commit $commit\"\n        fi\n    done\ndone\n"
        },
        {
          "name": "git-find-fetch",
          "type": "blob",
          "size": 2.8388671875,
          "content": "#!/usr/bin/env bash\n\n# usage: git-find-fetch [--mirror] [--repack] DIRS...\n#\n# by John Wiegley <johnw@newartisans.com>\n#\n# The purpose of this script is to walk recursively through a set of\n# directories, fetching updates for any and all Git repositories found\n# therein.\n#\n# The script is smart about using git-svn or gc-utils, if those are needed to\n# get updates.  Further, it calls \"git remote update\" for each repository, to\n# ensure all its remotes are also updated.\n#\n# Lastly, if you have a remote called \"mirror\" in any repository, all its refs\n# will be \"push --mirror\"'d to that remote under the assumption that you want\n# the mirror to receive all the updates you just fetch'd.\n#\n# Options:\n#\n#   --mirror   Only push to your mirrors, do not fetch.\n#   --repack   Repack and prune repositories after updating them.\n\nmirror_only=false\nif [[ \"$1\" == --mirror ]]; then\n    mirror_only=true\n    shift 1\nfi\n\nrepack=false\nif [[ \"$1\" == --repack ]]; then\n    repack=true\n    shift 1\nfi\n\nfind \"$@\" \\( -name .git -o -name '*.git' \\) -type d | \\\nwhile read repo_dir\ndo\n    if [[ ! -f \"$repo_dir\"/config ]]; then\n        continue\n    fi\n\n    if [[ -f \"$repo_dir\"/../fetch.sh ]]; then\n        (cd \"$repo_dir\"/..; sh fetch.sh)\n        continue\n    fi\n\n    if [[ $mirror_only == false ]]; then\n        # If this is a git-svn repo, use git svn fetch\n        if grep -q '^\\[svn-remote ' \"$repo_dir\"/config\n        then\n            if [[ -d \"$repo_dir\"/svn ]]; then\n                echo git svn fetch: $repo_dir\n                GIT_DIR=\"$repo_dir\" git svn fetch\n            fi\n\n        # If this is a gc-utils repo, use gc-utils update\n        elif grep -q '^\\[gc-utils\\]' \"$repo_dir\"/config\n        then\n            echo gc-update: $repo_dir\n            (cd \"$repo_dir\"; gc-update)\n\n        fi\n\n        echo $repo_dir\n        GIT_DIR=\"$repo_dir\" git remote update\n    fi\n\n    HG_DIR=\"$repo_dir\"/../.git-hg\n    FAST_EXPORT=$HOME/src/fast-export/hg-fast-export.sh\n    if [[ -d \"$HG_DIR\" ]]; then\n        (cd \"$HG_DIR\"; hg pull && hg update)\n        (cd \"$repo_dir\"/..; PYTHON=python2.6 sh $FAST_EXPORT -r .git-hg)\n    fi\n\n    BZR_DIR=\"$repo_dir\"/../.git-bzr\n    if [[ -d \"$BZR_DIR\" ]]; then\n        (cd \"$BZR_DIR\"; bzr pull)\n        (cd \"$repo_dir\"/..; git bzr fetch upstream | cat)\n    fi\n\n    DARCS_DIR=\"$repo_dir\"/../.git-darcs\n    GIT_DARCS_IMPORT=$HOME/bin/git-darcs-import\n    if [[ -d \"$DARCS_DIR\" && -f \"$GIT_DARCS_IMPORT\" ]]; then\n        (cd \"$DARCS_DIR\"; darcs pull)\n        (cd \"$repo_dir\"/..; $GIT_DARCS_IMPORT .git-darcs)\n        (cd \"$repo_dir\"; git rebase git-darcs-import)\n    fi\n\n    if [[ $repack == true ]]; then\n        GIT_DIR=\"$repo_dir\" git flush\n    fi\n\n    for remote in $(GIT_DIR=\"$repo_dir\" git remote)\n    do\n        if [[ $remote == mirror ]]; then\n            echo git push: $repo_dir -- $remote\n            GIT_DIR=\"$repo_dir\" git push -f --mirror $remote\n        fi\n    done\ndone\n"
        },
        {
          "name": "git-find-useful-dangling-trees",
          "type": "blob",
          "size": 0.1982421875,
          "content": "#!/usr/bin/env bash\ndepth=${1:-all} # 'all' or number of depth\n\nfor i in $(git fsck --unreachable | grep -E 'tree|commit' | cut -d\\  -f3)\ndo\n\techo -n \"U:$i CM:\"\n\tgit-closest-match \"$i\" num \"$depth\"\ndone\n"
        },
        {
          "name": "git-fire",
          "type": "blob",
          "size": 0.0244140625,
          "content": "git-fire-subtree/git-fire"
        },
        {
          "name": "git-fire-subtree",
          "type": "tree",
          "content": null
        },
        {
          "name": "git-fix-wt",
          "type": "blob",
          "size": 0.1123046875,
          "content": "#!/usr/bin/env bash\n\nfind . -name config -type f -print0 \\\n    | xargs -0 perl -i -ne 'print unless /worktree =/;'\n"
        },
        {
          "name": "git-fixws",
          "type": "blob",
          "size": 0.3671875,
          "content": "#!/usr/bin/env bash\n\n# If you are using MacPorts, you'll need to install 'patchutils'\n\nBASE=upstream\n\ngit diff $BASE HEAD > changes.diff\ngit diff -w $BASE HEAD > changes-w.diff\n\ninterdiff changes-w.diff changes.diff > ws.diff\nrm changes.diff changes-w.diff\n\npatch -p1 -R < ws.diff && rm ws.diff && \\\n    git commit -a -m \"Match whitespace with $BASE\"\n\n### git-fixws ends here\n"
        },
        {
          "name": "git-flatten.rb",
          "type": "blob",
          "size": 7.638671875,
          "content": "#!/usr/bin/env ruby\n\nrequire 'fileutils'\nrequire 'open3'\nrequire 'ftools'\nrequire 'set'\n\n$name = \"git flatten\"\n\ndef usage retcode=0\n  puts <<USAGE\nusage: #{$name} [options] <ref>\nUSAGE\n  exit retcode\nend\n\ndef die msg, usage=false\n  $stderr.puts msg\n  usage ? usage(-1) : exit(-1)\nend\n\ndef execute cmd, opts={}\n  verbose = opts[:verbose]\n  debug   = opts[:debug]\n  result  = opts[:return] || :to_s\n  select  = opts[:select]\n  filter  = opts[:filter]\n  res = []\n  puts cmd if debug\n  IO.popen cmd do |f|\n    f.each_line do |line|\n      l = line.sub(/\\n$/,'')\n      puts l if debug\n      if !select || select[l]\n        l = filter ? filter[l] : l\n        puts l if verbose\n        res << l\n      end\n    end\n  end\n  if result == :result\n    $?.success?\n  else\n    if opts[:one]\n      res.empty? ? nil : res.first\n    else\n      res\n    end\n  end\nend\n\ndef git_dir\n  $git_dir ||= execute(\"git rev-parse --git-dir\", :one => true)\nend\n\ndef git_editor\n  $git_editor ||= execute(\"git config core.editor\", :one => true) ||\n                  ENV['VISUAL'] || ENV['EDITOR'] || 'vi'\nend\n\ndef git_branch\n  $git_branch ||= execute(\"git branch\",\n                          :select => lambda{|l| l =~ /^\\*/},\n                          :filter => lambda{|l| l.sub(/\\* /, '')},\n                          :one => true)\nend\n\ndef ref_to_hash ref\n  execute(\"git rev-parse #{ref}\", :one => true)\nend\n\ndef hash_to_str hash\n  token = '--token--'\n  execute(\"git log -1 --pretty=format:'%h#{token}%s' #{hash}\",\n          :one => true).split(/#{token}/)\nend\n\ndef rev_list *ref\n  execute(\"git rev-list --reverse #{ref.join(' ')}\")\nend\n\ndef patch_id hash\n  execute(\"git show #{hash} | git patch-id\", :one => true)\nend\n\ndef merge? hash\n  patch_id(hash).nil?\nend\n\ndef merge_base c1, c2\n  execute(\"git merge-base #{c1} #{c2}\", :one => true)\nend\n\ndef container_branches hash\n  execute(\"git branch -a --contains #{hash}\",\n          :filter => lambda{|b| b.sub(/^\\s+/,'')})\nend\n\ndef parent_branches hash\n  parents = execute(\"git log -1 --pretty=format:%P #{hash}\",\n                    :one => true).split(/\\s+/)\n  branches = Set.new\n  parents.each do |parent|\n    branches |= container_branches(parent)\n  end\n  branches\nend\n\ndef parse_flatten target, opts={}\n  name = \"flattenorig\"\n  dirname  = \"#{git_dir}/refs/#{name}\"\n  filename = \"#{dirname}/#{git_branch}\"\n  if Dir[dirname].empty?\n    Dir.mkdir dirname\n  end\n  if Dir[filename].empty? && !opts[:write]\n    File.open(filename, \"w+\") do |file|\n      file.puts merge_base('HEAD', target)\n    end\n  end\n  if opts[:read]\n    File.open(filename) do |file|\n      file.readline.sub(/\\n$/,'')\n    end\n  elsif opts[:write]\n    File.open(filename,\"w\") do |file|\n      file.puts opts[:write]\n    end\n  else\n    filename\n  end\nend\n\n\ndef interactive_edit ref, revs, squash, opts={}\n  name = \"FLATTEN_MSG\"\n  filename = \"#{git_dir}/#{name}\"\n  limit = opts[:limit] || 70\n  if opts[:delete]\n    File.safe_unlink filename\n  else\n    if !opts[:continue]\n      return [] if revs.empty?\n      unless File.exists? filename\n        File.open(filename, \"w+\") do |file|\n          str_HEAD = hash_to_str(ref)[0]\n          str_revs  = revs.map do |rev|\n            hash, str = hash_to_str(rev)\n            str = str[0..(limit-3)] + '...' if str.length > limit\n            [hash, str]\n          end\n          str_revs.each do |hash, str|\n            if merge? hash\n              if (parent_branches(hash) & squash).empty?\n                action = :squash\n              else\n                # merge from a squashed branch\n                # so it may be picked\n                action = :pick\n              end\n            else\n              action = :pick\n            end\n            res = \"%-6s %s %s\" % [action, hash, str]\n            file.puts res\n          end\n        file.puts <<USAGE\n# Flatten #{str_HEAD}..#{str_revs.last[0]} onto #{str_HEAD}\n#\n# Commands:\n#  p, pick = use commit\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n# However, if you remove everything, the rebase will be aborted.\n#\nUSAGE\n        end\n      end\n    end\n    system git_editor, filename if opts[:interactive]\n    res = []\n    File.open(filename) do |file|\n      file.each_line do |line|\n        unless line =~ /^#/\n        line = line.sub(/\\n$/,'').split(/\\s+/)\n        res << [ line[0], line[1], line[2..-1].join(' ') ]\n        end\n      end\n    end\n    res\n  end\nend\n\ndef store_temp last=nil, opts={}\n  name = \"FLATTEN_TMP\"\n  filename = \"#{git_dir}/#{name}\"\n  if opts[:delete]\n    File.safe_unlink filename\n  elsif last\n    File.open(filename, \"w+\") do |file|\n      file.puts last\n    end\n  else\n    if File.exists? filename\n      File.open(filename) do |file|\n        file.gets.sub(/\\n$/,'')\n      end\n    else\n      nil\n    end\n  end\nend\n\ndef parse_action action\n  case action\n  when /^e(dit)?$/i\n    :edit\n  when /^p(ick)$/i\n    :pick\n  when /^s(quash)$/i\n    :squash\n  else\n    die \"unknown action '#{action}'\"\n  end\nend\n\ndef flatten ref, refs, opts={}\n  if !opts[:abort]\n    resolv_msg = <<RESOLV\n\nWhen you have resolved this problem run \"git flatten --continue\".\nIf you would prefer to skip this patch, instead run \"git flatten --skip\".\nTo restore the original branch and stop flatten run \"git flatten --abort\".\nRESOLV\n    stored_last = store_temp\n    if opts[:continue] || opts[:skip]\n      die \"No flatten in progress?\" unless stored_last\n      opts[:interactive] = true\n    else\n      die \"A flatten is in progress, try --continue, --skip or --abort.\" if stored_last\n      squash = opts[:squash] || []\n      orig = parse_flatten ref, :read => true\n      target = rev_list ref,\n                        \"^#{git_branch}\", \"^#{orig}\",\n                        *[refs, squash.map{|s| \"^#{s}\"}].flatten\n    end\n    last = stored_last\n    revs = interactive_edit orig, target, squash,\n            :interactive => opts[:interactive],\n            :continue => opts[:continue]||opts[:skip]\n    revs.each do |action, abbrev, str|\n      hash = ref_to_hash abbrev\n      if stored_last\n        if hash != stored_last\n          puts \"Skipping #{abbrev} #{str}\"\n          next\n        end\n      end\n      action = parse_action action\n      store_temp hash\n      if action == :squash\n        puts \"Squashing #{abbrev} #{str}\"\n        parse_flatten ref, :write => hash\n        next\n      end\n      if !stored_last\n        result = execute( \"git merge -q --squash #{hash}\",\n                          :verbose => true,\n                          :return => :result )\n        die resolv_msg unless result\n        die \"ok, you can edit it\" if action == :edit\n      end\n      if !stored_last || !opts[:skip]\n        result = execute( \"git commit -C #{hash}\",\n                          :verbose => true,\n                          :return => :result)\n        die resolv_msg unless result\n      else\n        puts \"Skipping #{abbrev} #{str}\"\n      end\n      stored_last = nil\n      parse_flatten ref, :write => hash\n    end\n    if last\n      parse_flatten ref, :write => last\n    else\n      puts \"nothing to do\"\n    end\n  end\n  store_temp nil, :delete => true\n  interactive_edit nil, nil, nil, :delete => true\nend\n\n\nref  = nil\nrefs = []\nopts = {}\nargs = ARGV.dup\nwhile arg = args.shift\n  case arg\n  when /--abort/\n    opts[:abort] = true\n    ref = :osef\n  when /--continue/\n    opts[:continue] = true\n    ref = :osef\n  when /-h|--help/\n    usage\n  when /-i|--interactive/\n    opts[:interactive] = true\n  when /--skip/\n    opts[:skip] = true\n    ref = :osef\n  when /-s|--squash/\n    opts[:squash] ||= []\n    opts[:squash] << (arg =~ /=/ ? arg.sub(/.*=\\s*/,'') : args.shift )\n  when /^-/\n    die \"unknow option #{arg}\", true\n  else\n    case\n    when ref\n      refs << arg\n    else\n      ref = arg\n    end\n  end\nend\nusage -1 unless ref\nflatten ref, refs, opts\n"
        },
        {
          "name": "git-flush",
          "type": "blob",
          "size": 0.658203125,
          "content": "#!/bin/sh\n\n# The job of git-flush is to recompactify your repository to be as small\n# as possible, by dropping all reflogs, stashes, and other cruft that may\n# be bloating your pack files.\n\nrm -fr .git/refs/original\nrm -fr .git/refs/snapshots\n\nif [ -f .git/info/refs ]; then\n    perl -i -ne 'print unless /refs\\/original/;' .git/info/refs\n    perl -i -ne 'print unless /refs\\/snapshots/;' .git/info/refs\nfi\nif [ -f .git/packed-refs ]; then\n    perl -i -ne 'print unless /refs\\/original/;' .git/packed-refs\n    perl -i -ne 'print unless /refs\\/snapshots/;' .git/packed-refs\nfi\n\ngit reflog expire --expire=0 --all\n\nif [ \"$1\" = \"-f\" ]; then\n    git stash clear\nfi\n\ngit maxpack\n"
        },
        {
          "name": "git-follow",
          "type": "blob",
          "size": 0.1064453125,
          "content": "#!/bin/sh\n\nCURRENT=$(basename \"$(pwd)\")\n\ngit remote add -t master -f \"$1\" \"git://github.com/$1/$CURRENT.git\"\n"
        },
        {
          "name": "git-force-mtimes",
          "type": "blob",
          "size": 0.5322265625,
          "content": "#!/usr/bin/perl\n# Sets mtimes of all files in the reprository their last change date\n# based on git's log. Useful to avoid too new dates after a checkout.\n\nmy %seen;\nmy $date;\nopen(LOG, \"git log --pretty=format:'date: %ct' --name-only |\") || die \"git log failed: $!\";\nwhile (<LOG>) {\n    chomp;\n    if (/^date: (\\d+)$/) {\n        $date=$1;\n    }\n    elsif (! /^$/ && ! $seen{$_}) {\n        $seen{$_}=1;\n        # git log can list deleted files, so error is ignored\n        utime($date, $date, $_);\n    }\n}\nclose LOG || die \"git log failed: $!\";\n"
        },
        {
          "name": "git-forest",
          "type": "blob",
          "size": 13.1162109375,
          "content": "#!/usr/bin/perl\n#\n#\tgit-森林\n#\ttext-based tree visualisation\n#\tCopyright © Jan Engelhardt <jengelh [at] medozas de>, 2008\n#\n#\tThis program is free software; you can redistribute it and/or modify\n#\tit under the terms of the GNU General Public License as published by\n#\tthe Free Software Foundation; either version 2 or 3 of the license.\n#\nuse Getopt::Long;\nuse Git;\nuse strict;\nuse utf8;\nuse Encode qw(encode);\nmy $Repo          = Git->repository($ENV{\"GIT_DIR\"} || \".\");\nmy $Pretty_fmt    = \"format:%s\";\nmy $Reverse_order = 0;\nmy $Show_all      = 0;\nmy $Show_rebase   = 1;\nmy $Style         = 1;\nmy $Subvine_depth = 2;\nmy $With_sha      = 0;\nmy %Color         = (\n\t\"default\" => \"\\e[0m\", # ]\n\t\"at\"      => \"\\e[1;30m\", # ]\n\t\"hhead\"   => \"\\e[1;31m\", # ]\n\t\"head\"    => \"\\e[1;32m\", # ]\n\t\"ref\"     => \"\\e[1;34m\", # ]\n\t\"remote\"  => \"\\e[1;35m\", # ]\n\t\"sha\"     => \"\\e[0;31m\", # ]\n\t\"tag\"     => \"\\e[1;33m\", # ]\n\t\"tree\"    => \"\\e[0;33m\", # ]\n);\n\n&main();\n\nsub main\n{\n\t&Getopt::Long::Configure(qw(bundling pass_through));\n\t&GetOptions(\n\t\t\"all\"       => \\$Show_all,\n\t\t\"no-color\"  => sub { %Color = (); },\n\t\t\"no-rebase\" => sub { $Show_rebase = 0; },\n\t\t\"a\"         => sub { $Pretty_fmt = \"format:\\e[1;30m(\\e[0;32m%an\\e[1;30m)\\e[0m %s\"; }, # ]]]]\n\t\t\"pretty=s\"  => \\$Pretty_fmt,\n\t\t\"reverse\"   => \\$Reverse_order,\n\t\t\"svdepth=i\" => \\$Subvine_depth,\n\t\t\"style=i\"   => \\$Style,\n\t\t\"sha\"       => \\$With_sha,\n\t);\n\t++$Subvine_depth;\n\tif (substr($Pretty_fmt, 0, 7) ne \"format:\") {\n\t\tdie \"If you use --pretty, it must be in the form of --pretty=format:\";\n\t}\n\t$Pretty_fmt = substr($Pretty_fmt, 7);\n\twhile ($Pretty_fmt =~ /\\%./g) {\n\t\tif ($& eq \"\\%b\" || $& eq \"\\%n\" || ($&.$') =~ /^\\%x0a/i) {\n\t\t\tdie \"Cannot use \\%b, \\%n or \\%x0a in --pretty=format:\";\n\t\t}\n\t}\n\tif ($Show_all) {\n\t\t#\n\t\t# Give --all back. And add HEAD to include commits\n\t\t# in the rev list that belong to a detached HEAD.\n\t\t#\n\t\tunshift(@ARGV, \"--all\", \"HEAD\");\n\t}\n\tif ($Reverse_order) {\n\t\ttie(*STDOUT, \"ReverseOutput\");\n\t}\n\t&process();\n\tif ($Reverse_order) {\n\t\tuntie *STDOUT;\n\t}\n}\n\nsub get_line_block\n{\n\tmy($fh, $max) = @_;\n\n\twhile (scalar(@h::ist) < $max) {\n\t\tmy $x;\n\n\t\t$x = <$fh>;\n\t\tif (!defined($x)) {\n\t\t\tlast;\n\t\t}\n\t\tpush(@h::ist, $x);\n\t}\n\n\tmy @ret = (shift @h::ist);\n\tforeach (2..$max) {\n\t\tpush(@ret, $h::ist[$_-2]);\n\t}\n\treturn @ret;\n}\n\nsub process\n{\n\tmy(@vine);\n\tmy $refs = &get_refs();\n\tmy($fh, $fhc) = $Repo->command_output_pipe(\"log\", \"--date-order\",\n\t                \"--pretty=format:<%H><%h><%P>$Pretty_fmt\", @ARGV);\n\n\twhile (my($line, @next_sha) = get_line_block($fh, $Subvine_depth)) {\n\t\tif (!defined($line)) {\n\t\t\tlast;\n\t\t}\n\t\tchomp $line;\n\t\tmy($sha, $mini_sha, $parents, $msg) =\n\t\t\t($line =~ /^<(.*?)><(.*?)><(.*?)>(.*)/s);\n\t\tmy @next_sha = map { ($_) = /^<(.*?)>/ } @next_sha;\n\t\tmy @parents = split(\" \", $parents);\n\n\t\t&vine_branch(\\@vine, $sha);\n\t\tmy $ra = &vine_commit(\\@vine, $sha, \\@parents);\n\n\t\tif (exists($refs->{$sha})) {\n\t\t\tprint &vis_post(&vis_commit($ra),\n\t\t\t      $Color{at}.\"m\".$Color{default});\n\t\t\t&ref_print($refs->{$sha});\n\t\t} else {\n\t\t\tprint &vis_post(&vis_commit($ra, \" \"));\n\t\t}\n\t\tif ($With_sha) {\n\t\t\tprint $msg, $Color{at}, encode('UTF-8', \"──(\"), $Color{sha}, $mini_sha,\n\t\t\t      $Color{at}, \")\", $Color{default}, \"\\n\";\n\t\t} else {\n\t\t\tprint $msg, \"\\n\";\n\t\t}\n\n\t\t&vine_merge(\\@vine, $sha, \\@next_sha, \\@parents);\n\t}\n\t$Repo->command_close_pipe($fh, $fhc);\n}\n\nsub get_refs\n{\n\tmy($fh, $c) = $Repo->command_output_pipe(\"show-ref\");\n\tmy $ret = {};\n\n\twhile (defined(my $ln = <$fh>)) {\n\t\tchomp $ln;\n\t\tif (length($ln) == 0) {\n\t\t\tnext;\n\t\t}\n\n\t\tmy($sha, $name) = ($ln =~ /^(\\S+)\\s+(.*)/s);\n\t\tif (!exists($ret->{$sha})) {\n\t\t\t$ret->{$sha} = [];\n\t\t}\n\t\tpush(@{$ret->{$sha}}, $name);\n\t\tif ($name =~ m{^refs/tags/}) {\n\t\t\tmy $sub_sha = $Repo->command(\"log\", \"-1\",\n\t\t\t              \"--pretty=format:%H\", $name);\n\t\t\tchomp $sub_sha;\n\t\t\tif ($sha ne $sub_sha) {\n\t\t\t\tpush(@{$ret->{$sub_sha}}, $name);\n\t\t\t}\n\t\t}\n\t}\n\n\t$Repo->command_close_pipe($fh, $c);\n\n\tmy $rebase = -e $Repo->repo_path().\"/.dotest-merge/git-rebase-todo\" &&\n\t             $Show_rebase;\n\tif ($rebase) {\n\t\tif (open(my $act_fh, $Repo->repo_path().\n\t\t    \"/.dotest-merge/git-rebase-todo\")) {\n\t\t\tmy($curr) = (<$act_fh> =~ /^\\S+\\s+(\\S+)/);\n\t\t\t$curr = $Repo->command(\"rev-parse\", $curr);\n\t\t\tchomp $curr;\n\t\t\tunshift(@{$ret->{$curr}}, \"rebase/cn\");\n\t\t\tclose $act_fh;\n\t\t}\n\n\t\tchomp(my $up   = $Repo->command(\"rev-parse\", \".dotest-merge/upstream\"));\n\t\tchomp(my $onto = $Repo->command(\"rev-parse\", \".dotest-merge/onto\"));\n\t\tchomp(my $old  = $Repo->command(\"rev-parse\", \".dotest-merge/head\"));\n\t\tunshift(@{$ret->{$up}}, \"rebase/upstream\");\n\t\tunshift(@{$ret->{$onto}}, \"rebase/onto\");\n\t\tunshift(@{$ret->{$old}}, \"rebase/saved-HEAD\");\n\t}\n\n\tmy $head = $Repo->command(\"rev-parse\", \"HEAD\");\n\tchomp $head;\n\tif ($rebase) {\n\t\tunshift(@{$ret->{$head}}, \"rebase/new\");\n\t}\n\tunshift(@{$ret->{$head}}, \"HEAD\");\n\n\treturn $ret;\n}\n\n#\n# ref_print - print a ref with color\n# @s:\tref name\n#\nsub ref_print\n{\n\tforeach my $symbol (@{shift @_}) {\n\t\tprint $Color{at}, \"[\";\n\t\tif ($symbol eq \"HEAD\" || $symbol =~ m{^rebase/}) {\n\t\t\tprint $Color{hhead}, $symbol;\n\t\t} elsif ($symbol =~ m{^refs/(remotes/[^/]+)/(.*)}s) {\n\t\t\tprint $Color{remote}, $1, $Color{head}, \"/$2\";\n\t\t} elsif ($symbol =~ m{^refs/heads/(.*)}s) {\n\t\t\tprint $Color{head}, $1;\n\t\t} elsif ($symbol =~ m{^refs/tags/(.*)}s) {\n\t\t\tprint $Color{tag}, $1;\n\t\t} elsif ($symbol =~ m{^refs/(.*)}s) {\n\t\t\tprint $Color{ref}, $1;\n\t\t}\n\t\tprint $Color{at}, encode('UTF-8', \"]──\"), $Color{default};\n\t}\n}\n\n#\n# vine_branch -\n# @vine:\tcolumn array containing the expected parent IDs\n# @rev:\t\tcommit ID\n#\n# Draws the branching vine matrix between a commit K and K^ (@rev).\n#\nsub vine_branch\n{\n\tmy($vine, $rev) = @_;\n\tmy $idx;\n\n\tmy($matched, $master) = (0, 0);\n\tmy $ret;\n\n\t# Transform array into string\n\tfor ($idx = 0; $idx <= $#$vine; ++$idx) {\n\t\tif (!defined($vine->[$idx])) {\n\t\t\t$ret .= \" \";\n\t\t\tnext;\n\t\t} elsif ($vine->[$idx] ne $rev) {\n\t\t\t$ret .= \"I\";\n\t\t\tnext;\n\t\t}\n\t\tif (!$master && $idx % 2 == 0) {\n\t\t\t$ret .= \"S\";\n\t\t\t$master = 1;\n\t\t} else {\n\t\t\t$ret .= \"s\";\n\t\t\t$vine->[$idx] = undef;\n\t\t}\n\t\t++$matched;\n\t}\n\n\tif ($matched < 2) {\n\t\treturn;\n\t}\n\n\t&remove_trailing_blanks($vine);\n\tprint &vis_post(&vis_fan($ret, \"branch\")), \"\\n\";\n}\n\n#\n# vine_commit -\n# @vine:\tcolumn array containing the expected IDs\n# @rev:\t\tcommit ID\n# @parents:\tarray of parent IDs\n#\nsub vine_commit\n{\n\tmy($vine, $rev, $parents) = @_;\n\tmy $ret;\n\n\tfor (my $i = 0; $i <= $#$vine; ++$i) {\n\t\tif (!defined($vine->[$i])) {\n\t\t\t$ret .= \" \";\n\t\t} elsif ($vine->[$i] eq $rev) {\n\t\t\t$ret .= \"C\";\n\t\t} else {\n\t\t\t$ret .= \"I\";\n\t\t}\n\t}\n\n\tif ($ret !~ /C/) {\n\t\t# Not having produced a C before means this is a tip\n\t\tmy $i;\n\t\tfor ($i = &round_down2($#$vine); $i >= 0; $i -= 2) {\n\t\t\tif (substr($ret, $i, 1) eq \" \") {\n\t\t\t\tsubstr($ret, $i, 1) = \"t\";\n\t\t\t\t$vine->[$i] = $rev;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tif ($i < 0) {\n\t\t\tif (scalar(@$vine) % 2 != 0) {\n\t\t\t\tpush(@$vine, undef);\n\t\t\t\t$ret .= \" \";\n\t\t\t}\n\t\t\t$ret .= \"t\";\n\t\t\tpush(@$vine, $rev);\n\t\t}\n\t}\n\n\t&remove_trailing_blanks($vine);\n\n\tif (scalar(@$parents) == 0) {\n\t\t# tree root\n\t\t$ret =~ tr/C/r/;\n\t}\n\n\treturn $ret;\n}\n\n#\n# vine_merge -\n# @vine:\tcolumn array containing the expected parent IDs\n# @rev:\t\tcommit ID\n# @next_rev:\tnext commit ID in the revision list\n# @parents:\tparent IDs of @rev\n#\n# Draws the merging vine matrix between a commit K (@rev) and K^ (@parents).\n#\nsub vine_merge\n{\n\tmy($vine, $rev, $next_rev, $parents) = @_;\n\tmy $orig_vine = -1;\n\tmy @slot;\n\tmy($ret, $max);\n\n\tfor (my $i = 0; $i <= $#$vine; ++$i) {\n\t\tif ($vine->[$i] eq $rev) {\n\t\t\t$orig_vine = $i;\n\t\t\tlast;\n\t\t}\n\t}\n\n\tif ($orig_vine == -1) {\n\t\tdie \"vine_commit() did not add this vine.\";\n\t}\n\n\tif (scalar(@$parents) <= 1) {\n\t\t#\n\t\t# A single parent does not need a visual. Update and return.\n\t\t#\n\t\t$vine->[$orig_vine] = $parents->[0];\n\t\t&remove_trailing_blanks($vine);\n\t\treturn;\n\t}\n\n\t#\n\t# Put previously seen branches in the vine subcolumns\n\t# Need to keep at least one parent for the slot algorithm below.\n\t#\n\tfor (my $j = 0; $j <= $#$parents && $#$parents > 0; ++$j) {\n\t\tfor (my $idx = 0; $idx <= $#$vine; ++$idx) {\n\t\t\tif ($vine->[$idx] ne $parents->[$j] ||\n\t\t\t    !grep { my $z = $vine->[$idx]; /^\\Q$z\\E$/ }\n\t\t\t    @$next_rev) {\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tif ($idx == $orig_vine) {\n\t\t\t\tdie \"Should not really happen\";\n\t\t\t}\n\t\t\tif ($idx < $orig_vine) {\n\t\t\t\tmy $p = $idx + 1;\n\t\t\t\tif (defined($vine->[$p])) {\n\t\t\t\t\t$p = $idx - 1;\n\t\t\t\t}\n\t\t\t\tif (defined($vine->[$p])) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\t$vine->[$p] = $parents->[$j];\n\t\t\t\tstr_expand(\\$ret, $p + 1);\n\t\t\t\tsubstr($ret, $p, 1) = \"s\";\n\t\t\t} else {\n\t\t\t\tmy $p = $idx - 1;\n\t\t\t\tif (defined($vine->[$p]) || $p < 0) {\n\t\t\t\t\t$p = $idx + 1;\n\t\t\t\t}\n\t\t\t\tif (defined($vine->[$p])) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\t$vine->[$p] = $parents->[$j];\n\t\t\t\tstr_expand(\\$ret, $p + 1);\n\t\t\t\tsubstr($ret, $p, 1) = \"s\";\n\t\t\t}\n\t\t\tsplice(@$parents, $j, 1);\n\t\t\t--$j; # outer loop\n\t\t\tlast; # inner loop\n\t\t}\n\t}\n\n\t#\n\t# Find some good spots to split out into and record columns\n\t# that will be used soon in the @slot list.\n\t#\n\tpush(@slot, $orig_vine);\n\tmy $parent = 0;\n\n\tfor (my $seeker = 2; $parent < $#$parents &&\n\t    $seeker < 2 + $#$vine; ++$seeker)\n\t{\n\t\tmy $idx = ($seeker % 2 == 0) ? -1 : 1;\n\t\t$idx   *= int($seeker / 2);\n\t\t$idx   *= 2;\n\t\t$idx   += $orig_vine;\n\n\t\tif ($idx >= 0 && $idx <= $#$vine && !defined($vine->[$idx])) {\n\t\t\tpush(@slot, $idx);\n\t\t\t$vine->[$idx] = \"0\" x 40;\n\t\t\t++$parent;\n\t\t}\n\t}\n\tfor (my $idx = $orig_vine + 2; $parent < $#$parents; $idx += 2) {\n\t\tif (!defined($vine->[$idx])) {\n\t\t\tpush(@slot, $idx);\n\t\t\t++$parent;\n\t\t}\n\t}\n\n\tif (scalar(@slot) != scalar(@$parents)) {\n\t\tdie \"Serious internal problem\";\n\t}\n\n\t@slot = sort { $a <=> $b } @slot;\n\t$max  = scalar(@$vine) + 2 * scalar(@slot);\n\n\tfor (my $i = 0; $i < $max; ++$i) {\n\t\tstr_expand(\\$ret, $i + 1);\n\t\tif ($#slot >= 0 && $i == $slot[0]) {\n\t\t\tshift @slot;\n\t\t\t$vine->[$i] = shift @$parents;\n\t\t\tsubstr($ret, $i, 1) = ($i == $orig_vine) ? \"S\" : \"s\";\n\t\t} elsif (substr($ret, $i, 1) eq \"s\") {\n\t\t\t; # keep existing fanouts\n\t\t} elsif (defined($vine->[$i])) {\n\t\t\tsubstr($ret, $i, 1) = \"I\";\n\t\t} else {\n\t\t\tsubstr($ret, $i, 1) = \" \";\n\t\t}\n\t}\n\n\tprint &vis_post(&vis_fan($ret, \"merge\")), \"\\n\";\n}\n\n#\n# vis_* - transform control string into usable graphic\n#\n# To cut down on code, the three vine_* functions produce only a dumb,\n# but already unambiguous, control string which needs some processing\n# before it is ready for public display.\n#\n\nsub vis_commit\n{\n\tmy $s = shift @_;\n\tmy $f = shift @_;\n\t$s =~ s/ +$//gs;\n\tif (defined $f) {\n\t\t$s .= $f;\n\t}\n\treturn $s;\n}\n\nsub vis_fan\n{\n\tmy $s = shift @_;\n\tmy $b = shift(@_) eq \"branch\";\n\n\t$s =~ s{s.*s}{\n\t\t$_ = $&;\n\t\t$_ =~ tr/ I/DO/;\n\t\t$_;\n\t}ei;\n\n\t# Transform an ODODO.. sequence into a contiguous overpass.\n\t$s =~ s{O[DO]+O}{\"O\" x length($&)}eg;\n\n\t# Do left/right edge transformation\n\t$s =~ s{(s.*)S(.*s)}{&vis_fan3($1, $2)}es ||\n\t$s =~ s{(s.*)S}{&vis_fan2L($1).\"B\"}es ||\n\t$s =~ s{S(.*s)}{\"A\".&vis_fan2R($1)}es ||\n\tdie \"Should not come here\";\n\n\tif ($b) {\n\t\t$s =~ tr/efg/xyz/;\n\t}\n\n\treturn $s;\n}\n\nsub vis_fan2L\n{\n\tmy $l = shift @_;\n\t$l =~ s/^s/e/;\n\t$l =~ s/s/f/g;\n\treturn $l;\n}\n\nsub vis_fan2R\n{\n\tmy $r = shift @_;\n\t$r =~ s/s$/g/;\n\t$r =~ s/s/f/g;\n\treturn $r;\n}\n\nsub vis_fan3\n{\n\tmy($l, $r) = @_;\n\t$l =~ s/^s/e/;\n\t$l =~ s/s/f/g;\n\t$r =~ s/s$/g/;\n\t$r =~ s/s/f/g;\n\treturn \"${l}K$r\";\n}\n\nsub vis_xfrm\n{\n\t# A: branch to right\n\t# B: branch to right\n\t# C: commit\n\t# D:\n\t# e: merge visual left (╔)\n\t# f: merge visual center (╦)\n\t# g: merge visual right (╗)\n\t# I: straight line (║)\n\t# K: branch visual split (╬)\n\t# m: single line (─)\n\t# O: overpass (≡)\n\t# r: root (╙)\n\t# t: tip (╓)\n\t# x: branch visual left (╚)\n\t# y: branch visual center (╩)\n\t# z: branch visual right (╝)\n\t# *: filler\n\n\tmy $s = shift @_;\n\tmy $spc = shift @_;\n\tif ($spc) {\n\t\t$s =~ s{[Ctr].*}{\n\t\t\t$_ = $&;\n\t\t\t$_ =~ s{ }{\\*}g;\n\t\t\t$_;\n\t\t}esg;\n\t}\n\n\tif ($Reverse_order) {\n\t\t$s =~ tr/efg.rt.xyz/xyz.tr.efg/;\n\t}\n\n\tif ($Style == 1) {\n\t\t$s =~ tr/ABCD.efg.IKO.mrt.xyz/├┤├─.┌┬┐.│┼≡.─└┌.└┴┘/;\n\t} elsif ($Style == 2) {\n\t\t$s =~ tr/ABCD.efg.IKO.mrt.xyz/╠╣╟═.╔╦╗.║╬═.─╙╓.╚╩╝/;\n\t} elsif ($Style == 10) {\n\t\t$s =~ tr/ABCD.efg.IKO.mrt.xyz/├┤├─.╭┬╮.│┼≡.─└┌.╰┴╯/;\n\t} elsif ($Style == 15) {\n\t\t$s =~ tr/ABCD.efg.IKO.mrt.xyz/┣┫┣━.┏┳┓.┃╋☰.━┗┏.┗┻┛/;\n\t}\n\treturn $s;\n}\n\n#\n# vis_post - post-process/transform vine graphic\n# Apply user-specific style transformation.\n#\nsub vis_post\n{\n\tmy $s = shift @_;\n\tmy $f = shift @_;\n\n\t$s = vis_xfrm($s, defined $f);\n\t$f =~ s/^([^\\x1b]+)/vis_xfrm($1)/e;\n\t$f =~ s/(\\x1b.*?m)([^\\x1b]+)/$1.vis_xfrm($2)/eg;\n\tif (defined $f) {\n\t\t$s =~ s/\\*/$f/g;\n\t\t$s =~ s{\\Q$Color{default}\\E}{$&.$Color{tree}}egs;\n\t\t$s .= $f;\n\t}\n\n\treturn $Color{tree}, encode('UTF-8', $s), $Color{default};\n}\n\nsub remove_trailing_blanks\n{\n\tmy $a = shift @_;\n\n\twhile (scalar(@$a) > 0 && !defined($a->[$#$a])) {\n\t\tpop(@$a);\n\t}\n}\n\nsub round_down2\n{\n\tmy $i = shift @_;\n\tif ($i < 0) {\n\t\treturn $i;\n\t}\n\treturn $i & ~1;\n}\n\nsub str_expand\n{\n\tmy $r = shift @_;\n\tmy $l = shift @_;\n\n\tif (length($$r) < $l) {\n\t\t$$r .= \" \" x ($l - length($$r));\n\t}\n}\n\npackage ReverseOutput;\nrequire Tie::Handle;\n@ReverseOutput::ISA = qw(Tie::Handle);\n\nsub TIEHANDLE\n{\n\tmy $class = shift @_;\n\tmy $self  = {};\n\n\topen($self->{fh}, \">&STDOUT\");\n\n\treturn bless $self, $class;\n}\n\nsub PRINT\n{\n\tmy $self = shift @_;\n\tmy $fh   = $self->{fh};\n\n\t$self->{saved} .= join($\\, @_);\n}\n\nsub UNTIE\n{\n\tmy $self = shift @_;\n\tmy $fh   = $self->{fh};\n\n\tprint $fh join($/, reverse split(/\\n/s, $self->{saved}));\n\tprint $fh \"\\n\";\n\tundef $self->{saved};\n}\n"
        },
        {
          "name": "git-full-reset",
          "type": "blob",
          "size": 0.0498046875,
          "content": "#!/bin/sh\n\ngit reset --hard HEAD && git clean -fdx\n"
        },
        {
          "name": "git-hunt-and-seek",
          "type": "blob",
          "size": 0.1103515625,
          "content": "#!/usr/bin/env bash\n\nfor hash in $(grep ^commit | awk '{print $2}'); do\n    git diff-directory \"$1\" \"$hash\"\ndone\n"
        },
        {
          "name": "git-ignore-wizard",
          "type": "blob",
          "size": 1.5048828125,
          "content": "#!/usr/bin/env bash\n# take a file/directory as arg1, to be added to ignore rules.\n# the user selects which ignore rules using dmenu\n# in the .gitconfig case, we should probably allow the user to edit it,\n# because he probably wants a more generic pattern instead of the real\n# basename\n\nfile=$1\nif [[ -z \"$file\" || ! -e \"$file\" ]]\nthen\n\techo 'No such file or directory' >&2\n\texit 2\nfi\n\ntype=$(echo \\\n\".gitignore-root    # files all developers of this repo will want to exclude, in one central location\n.gitignore-dirname # same, but ignore file in parent directory, so you can have multiple .gitignore files\nexclude            # specific to it's repo, but irrelevant to other devs\n.gitconfig         # patterns you want to ignore, independent of the repository\n\" | dmenu | cut -d ' ' -f1)\n\n[ -z \"$type\" ] && echo 'Cancelled' && exit 0\n\ndirname=$( dirname  \"$file\")\nbasename=$(basename \"$file\")\ncase $type in\n\t.gitignore-root)\n\t\troot=$(git root \"$file\") || exit 2\n\t\tdirname=$(readlink -f \"$dirname\")\n\t\trelative_dir=$(echo \"$dirname\" | sed \"s#^$root##\") # ie: /src\n\t\techo \"$relative_dir/$basename\" >> \"$root/.gitignore\"\n\t\t;;\n\t.gitignore-dirname)\n\t\tgit root \"$file \">/dev/null || exit 2\n\t\techo \"$basename\" >> \"$dirname/.gitignore\"\n\t\t;;\n\texclude)\n\t\troot=$(git root \"$file\") || exit 2\n\t\tdirname=$(readlink -f \"$dirname\")\n\t\trelative_dir=$(echo \"$dirname\" | sed \"s#^$root##\")\n\t\techo \"$relative_dir/$basename\" >> \"$root/info/exclude\"\n\t\t;;\n\t.gitconfig)\n\t\t#TODO. git config --get-all ?, then another dmenu? how many such config keys are allowed?\nesac\n"
        },
        {
          "name": "git-igunk",
          "type": "blob",
          "size": 0.1103515625,
          "content": "#!/bin/sh\n\ngit ls-files --other --exclude-standard | while read -r path; do\n    echo \"/$path\" >> .gitignore\ndone\n"
        },
        {
          "name": "git-interactive-merge",
          "type": "blob",
          "size": 0.3017578125,
          "content": "#!/usr/bin/env bash\nif [ -z \"$1\" ] || [ -z \"$2\" ]\nthen\n\techo \"usage: $0 <from> <to>\" >&2\n\texit 2\nfi\nfrom=$1\nto=$2\ngit checkout \"$from\"\ngit checkout -b \"${from}_tmp\"\n# drops you in an editor, pick the changes you want\ngit rebase -i \"$to\"\ngit checkout \"$to\"\ngit pull . \"${from}_tmp\"\ngit branch -d \"${from}_tmp\"\n"
        },
        {
          "name": "git-link-upstream",
          "type": "blob",
          "size": 0.1005859375,
          "content": "#!/usr/bin/env bash\n\nBRANCH=$(git-current-branch)\n\ngit branch --set-upstream-to=origin/$BRANCH $BRANCH\n"
        },
        {
          "name": "git-master",
          "type": "blob",
          "size": 0.056640625,
          "content": "#!/usr/bin/env bash\ngit stash\ngit co master\ngit stash pop\n"
        },
        {
          "name": "git-maxpack",
          "type": "blob",
          "size": 0.099609375,
          "content": "#!/bin/sh\n\ngit config pack.compression 9\ngit gc --prune=now\ngit repack -a -d --depth=250 --window=250\n"
        },
        {
          "name": "git-merge-changelog.c",
          "type": "blob",
          "size": 65.0322265625,
          "content": "/* git-merge-changelog - git \"merge\" driver for GNU style ChangeLog files.\n   Copyright (C) 2008-2010 Bruno Haible <bruno@clisp.org>\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n/* README:\n   The default merge driver of 'git' *always* produces conflicts when\n   pulling public modifications into a privately modified ChangeLog file.\n   This is because ChangeLog files are always modified at the top; the\n   default merge driver has no clue how to deal with this. Furthermore\n   the conflicts are presented with more <<<< ==== >>>> markers than\n   necessary; this is because the default merge driver makes pointless\n   efforts to look at the individual line changes inside a ChangeLog entry.\n\n   This program serves as a 'git' merge driver that avoids these problems.\n   1. It produces no conflict when ChangeLog entries have been inserted\n      at the top both in the public and in the private modification. It\n      puts the privately added entries above the publicly added entries.\n   2. It respects the structure of ChangeLog files: entries are not split\n      into lines but kept together.\n   3. It also handles the case of small modifications of past ChangeLog\n      entries, or of removed ChangeLog entries: they are merged as one\n      would expect it.\n   4. Conflicts are presented at the top of the file, rather than where\n      they occurred, so that the user will see them immediately. (Unlike\n      for source code written in some programming language, conflict markers\n      that are located several hundreds lines from the top will not cause\n      any syntax error and therefore would be likely to remain unnoticed.)\n */\n\n/* Installation:\n\n   $ gnulib-tool --create-testdir --dir=/tmp/testdir123 git-merge-changelog\n   $ cd /tmp/testdir123\n   $ ./configure\n   $ make\n   $ make install\n\n   Additionally, for git users:\n     - Add to .git/config of the checkout (or to your $HOME/.gitconfig) the\n       lines\n\n          [merge \"merge-changelog\"]\n                  name = GNU-style ChangeLog merge driver\n                  driver = /usr/local/bin/git-merge-changelog %O %A %B\n\n     - In every directory that contains a ChangeLog file, add a file\n       '.gitattributes' with this line:\n\n          ChangeLog    merge=merge-changelog\n\n       (See \"man 5 gitattributes\" for more info.)\n\n   Additionally, for bzr users:\n     - Install the 'extmerge' bzr plug-in listed at\n         <http://doc.bazaar.canonical.com/plugins/en/index.html>\n         <http://wiki.bazaar.canonical.com/BzrPlugins>\n     - Add to your $HOME/.bazaar/bazaar.conf the line\n\n          external_merge = git-merge-changelog %b %T %o\n\n     - Then, to merge a conflict in a ChangeLog file, use\n\n          $ bzr extmerge ChangeLog\n\n   Additionally, for hg users:\n     - Add to your $HOME/.hgrc the lines\n\n        [merge-patterns]\n        ChangeLog = git-merge-changelog\n\n        [merge-tools]\n        git-merge-changelog.executable = /usr/local/bin/git-merge-changelog\n        git-merge-changelog.args = $base $local $other\n\n       See <http://www.selenic.com/mercurial/hgrc.5.html> section merge-tools\n       for reference.\n */\n\n/* Use as an alternative to 'diff3':\n   git-merge-changelog performs the same role as \"diff3 -m\", just with\n   reordered arguments:\n     $ git-merge-changelog %O %A %B\n   is comparable to\n     $ diff3 -m %A %O %B\n */\n\n/* Calling convention:\n   A merge driver is called with three filename arguments:\n     1. %O = The common ancestor of %A and %B.\n     2. %A = The file's contents from the \"current branch\".\n     3. %B = The file's contents from the \"other branch\"; this is the contents\n        being merged in.\n\n   In case of a \"git stash apply\" or of an upstream pull (e.g. from a subsystem\n   maintainer to a central maintainer) or of a downstream pull with --rebase:\n     2. %A = The file's newest pulled contents; modified by other committers.\n     3. %B = The user's newest copy of the file; modified by the user.\n   In case of a downstream pull (e.g. from a central repository to the user)\n   or of an upstream pull with --rebase:\n     2. %A = The user's newest copy of the file; modified by the user.\n     3. %B = The file's newest pulled contents; modified by other committers.\n\n   It should write its merged output into file %A. It can also echo some\n   remarks to stdout.  It should exit with return code 0 if the merge could\n   be resolved cleanly, or with non-zero return code if there were conflicts.\n */\n\n/* How it works:\n   The structure of a ChangeLog file: It consists of ChangeLog entries. A\n   ChangeLog entry starts at a line following a blank line and that starts with\n   a non-whitespace character, or at the beginning of a file.\n   The merge driver works as follows: It reads the three files into memory and\n   dissects them into ChangeLog entries. It then finds the differences between\n   %O and %B. They are classified as:\n     - removals (some consecutive entries removed),\n     - changes (some consecutive entries removed, some consecutive entries\n       added),\n     - additions (some consecutive entries added).\n   The driver then attempts to apply the changes to %A.\n   To this effect, it first computes a correspondence between the entries in %O\n   and the entries in %A, using fuzzy string matching to still identify changed\n   entries.\n     - Removals are applied one by one. If the entry is present in %A, at any\n       position, it is removed. If not, the removal is marked as a conflict.\n     - Additions at the top of %B are applied at the top of %A.\n     - Additions between entry x and entry y (y may be the file end) in %B are\n       applied between entry x and entry y in %A (if they still exist and are\n       still consecutive in %A), otherwise the additions are marked as a\n       conflict.\n     - Changes are categorized into \"simple changes\":\n         entry1 ... entryn\n       are mapped to\n         added_entry ... added_entry modified_entry1 ... modified_entryn,\n       where the correspondence between entry_i and modified_entry_i is still\n       clear; and \"big changes\": these are all the rest. Simple changes at the\n       top of %B are applied by putting the added entries at the top of %A. The\n       changes in simple changes are applied one by one; possibly leading to\n       single-entry conflicts. Big changes are applied en bloc, possibly\n       leading to conflicts spanning multiple entries.\n     - Conflicts are output at the top of the file and cause an exit status of\n       1.\n */\n\n#include <config.h>\n\n#include <getopt.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"progname.h\"\n#include \"error.h\"\n#include \"read-file.h\"\n#include \"gl_xlist.h\"\n#include \"gl_array_list.h\"\n#include \"gl_linkedhash_list.h\"\n#include \"gl_rbtreehash_list.h\"\n#include \"gl_linked_list.h\"\n#include \"xalloc.h\"\n#include \"xmalloca.h\"\n#include \"fstrcmp.h\"\n#include \"minmax.h\"\n#include \"c-strstr.h\"\n#include \"fwriteerror.h\"\n\n#define ASSERT(expr) \\\n  do                                                                         \\\n    {                                                                        \\\n      if (!(expr))                                                           \\\n        abort ();                                                            \\\n    }                                                                        \\\n  while (0)\n\n#define FSTRCMP_THRESHOLD 0.6\n#define FSTRCMP_STRICTER_THRESHOLD 0.8\n\n/* Representation of a ChangeLog entry.\n   The string may contain NUL bytes; therefore it is represented as a plain\n   opaque memory region.  */\nstruct entry\n{\n  char *string;\n  size_t length;\n  /* Cache for the hash code.  */\n  bool hashcode_cached;\n  size_t hashcode;\n};\n\n/* Create an entry.\n   The memory region passed by the caller must of indefinite extent.  It is\n   *not* copied here.  */\nstatic struct entry *\nentry_create (char *string, size_t length)\n{\n  struct entry *result = XMALLOC (struct entry);\n  result->string = string;\n  result->length = length;\n  result->hashcode_cached = false;\n  return result;\n}\n\n/* Compare two entries for equality.  */\nstatic bool\nentry_equals (const void *elt1, const void *elt2)\n{\n  const struct entry *entry1 = (const struct entry *) elt1;\n  const struct entry *entry2 = (const struct entry *) elt2;\n  return entry1->length == entry2->length\n         && memcmp (entry1->string, entry2->string, entry1->length) == 0;\n}\n\n/* Return a hash code of the contents of a ChangeLog entry.  */\nstatic size_t\nentry_hashcode (const void *elt)\n{\n  struct entry *entry = (struct entry *) elt;\n  if (!entry->hashcode_cached)\n    {\n      /* See http://www.haible.de/bruno/hashfunc.html.  */\n      const char *s;\n      size_t n;\n      size_t h = 0;\n\n      for (s = entry->string, n = entry->length; n > 0; s++, n--)\n        h = (unsigned char) *s + ((h << 9) | (h >> (sizeof (size_t) * CHAR_BIT - 9)));\n\n      entry->hashcode = h;\n      entry->hashcode_cached = true;\n    }\n  return entry->hashcode;\n}\n\n/* Perform a fuzzy comparison of two ChangeLog entries.\n   Return a similarity measure of the two entries, a value between 0 and 1.\n   0 stands for very distinct, 1 for identical.\n   If the result is < LOWER_BOUND, an arbitrary other value < LOWER_BOUND can\n   be returned.  */\nstatic double\nentry_fstrcmp (const struct entry *entry1, const struct entry *entry2,\n               double lower_bound)\n{\n  /* fstrcmp works only on NUL terminated strings.  */\n  char *memory;\n  double similarity;\n\n  if (memchr (entry1->string, '\\0', entry1->length) != NULL)\n    return 0.0;\n  if (memchr (entry2->string, '\\0', entry2->length) != NULL)\n    return 0.0;\n  memory = (char *) xmalloca (entry1->length + 1 + entry2->length + 1);\n  {\n    char *p = memory;\n    memcpy (p, entry1->string, entry1->length);\n    p += entry1->length;\n    *p++ = '\\0';\n    memcpy (p, entry2->string, entry2->length);\n    p += entry2->length;\n    *p++ = '\\0';\n  }\n  similarity =\n    fstrcmp_bounded (memory, memory + entry1->length + 1, lower_bound);\n  freea (memory);\n  return similarity;\n}\n\n/* This structure represents an entire ChangeLog file, after it was read\n   into memory.  */\nstruct changelog_file\n{\n  /* The entries, as a list.  */\n  gl_list_t /* <struct entry *> */ entries_list;\n  /* The entries, as a list in opposite direction.  */\n  gl_list_t /* <struct entry *> */ entries_reversed;\n  /* The entries, as an array.  */\n  size_t num_entries;\n  struct entry **entries;\n};\n\n/* Read a ChangeLog file into memory.\n   Return the contents in *RESULT.  */\nstatic void\nread_changelog_file (const char *filename, struct changelog_file *result)\n{\n  /* Read the file in text mode, otherwise it's hard to recognize empty\n     lines.  */\n  size_t length;\n  char *contents = read_file (filename, &length);\n  if (contents == NULL)\n    {\n      fprintf (stderr, \"could not read file '%s'\\n\", filename);\n      exit (EXIT_FAILURE);\n    }\n\n  result->entries_list =\n    gl_list_create_empty (GL_LINKEDHASH_LIST, entry_equals, entry_hashcode,\n                          NULL, true);\n  result->entries_reversed =\n    gl_list_create_empty (GL_RBTREEHASH_LIST, entry_equals, entry_hashcode,\n                          NULL, true);\n  /* A ChangeLog file consists of ChangeLog entries.  A ChangeLog entry starts\n     at a line following a blank line and that starts with a non-whitespace\n     character, or at the beginning of a file.\n     Split the file contents into entries.  */\n  {\n    char *contents_end = contents + length;\n    char *start = contents;\n    while (start < contents_end)\n      {\n        /* Search the end of the current entry.  */\n        char *ptr = start;\n        struct entry *curr;\n\n        while (ptr < contents_end)\n          {\n            ptr = memchr (ptr, '\\n', contents_end - ptr);\n            if (ptr == NULL)\n              {\n                ptr = contents_end;\n                break;\n              }\n            ptr++;\n            if (contents_end - ptr >= 2\n                && ptr[0] == '\\n'\n                && !(ptr[1] == '\\n' || ptr[1] == '\\t' || ptr[1] == ' '))\n              {\n                ptr++;\n                break;\n              }\n          }\n\n        curr = entry_create (start, ptr - start);\n        gl_list_add_last (result->entries_list, curr);\n        gl_list_add_first (result->entries_reversed, curr);\n\n        start = ptr;\n      }\n  }\n\n  result->num_entries = gl_list_size (result->entries_list);\n  result->entries = XNMALLOC (result->num_entries, struct entry *);\n  {\n    size_t index = 0;\n    gl_list_iterator_t iter = gl_list_iterator (result->entries_list);\n    const void *elt;\n    gl_list_node_t node;\n    while (gl_list_iterator_next (&iter, &elt, &node))\n      result->entries[index++] = (struct entry *) elt;\n    gl_list_iterator_free (&iter);\n    ASSERT (index == result->num_entries);\n  }\n}\n\n/* A mapping (correspondence) between entries of FILE1 and of FILE2.  */\nstruct entries_mapping\n{\n  struct changelog_file *file1;\n  struct changelog_file *file2;\n  /* Mapping from indices in FILE1 to indices in FILE2.\n     A value -1 means that the entry from FILE1 is not found in FILE2.\n     A value -2 means that it has not yet been computed.  */\n  ssize_t *index_mapping;\n  /* Mapping from indices in FILE2 to indices in FILE1.\n     A value -1 means that the entry from FILE2 is not found in FILE1.\n     A value -2 means that it has not yet been computed.  */\n  ssize_t *index_mapping_reverse;\n};\n\n/* Look up (or lazily compute) the mapping of an entry in FILE1.\n   i is the index in FILE1.\n   Return the index in FILE2, or -1 when the entry is not found in FILE2.  */\nstatic ssize_t\nentries_mapping_get (struct entries_mapping *mapping, ssize_t i)\n{\n  if (mapping->index_mapping[i] < -1)\n    {\n      struct changelog_file *file1 = mapping->file1;\n      struct changelog_file *file2 = mapping->file2;\n      size_t n1 = file1->num_entries;\n      size_t n2 = file2->num_entries;\n      struct entry *entry_i = file1->entries[i];\n      ssize_t j;\n\n      /* Search whether it approximately occurs in file2.  */\n      ssize_t best_j = -1;\n      double best_j_similarity = 0.0;\n      for (j = n2 - 1; j >= 0; j--)\n        if (mapping->index_mapping_reverse[j] < 0)\n          {\n            double similarity =\n              entry_fstrcmp (entry_i, file2->entries[j], best_j_similarity);\n            if (similarity > best_j_similarity)\n              {\n                best_j = j;\n                best_j_similarity = similarity;\n              }\n          }\n      if (best_j_similarity >= FSTRCMP_THRESHOLD)\n        {\n          /* Found a similar entry in file2.  */\n          struct entry *entry_j = file2->entries[best_j];\n          /* Search whether it approximately occurs in file1 at index i.  */\n          ssize_t best_i = -1;\n          double best_i_similarity = 0.0;\n          ssize_t ii;\n          for (ii = n1 - 1; ii >= 0; ii--)\n            if (mapping->index_mapping[ii] < 0)\n              {\n                double similarity =\n                  entry_fstrcmp (file1->entries[ii], entry_j,\n                                 best_i_similarity);\n                if (similarity > best_i_similarity)\n                  {\n                    best_i = ii;\n                    best_i_similarity = similarity;\n                  }\n              }\n          if (best_i_similarity >= FSTRCMP_THRESHOLD && best_i == i)\n            {\n              mapping->index_mapping[i] = best_j;\n              mapping->index_mapping_reverse[best_j] = i;\n            }\n        }\n      if (mapping->index_mapping[i] < -1)\n        /* It does not approximately occur in FILE2.\n           Remember it, for next time.  */\n        mapping->index_mapping[i] = -1;\n    }\n  return mapping->index_mapping[i];\n}\n\n/* Look up (or lazily compute) the mapping of an entry in FILE2.\n   j is the index in FILE2.\n   Return the index in FILE1, or -1 when the entry is not found in FILE1.  */\nstatic ssize_t\nentries_mapping_reverse_get (struct entries_mapping *mapping, ssize_t j)\n{\n  if (mapping->index_mapping_reverse[j] < -1)\n    {\n      struct changelog_file *file1 = mapping->file1;\n      struct changelog_file *file2 = mapping->file2;\n      size_t n1 = file1->num_entries;\n      size_t n2 = file2->num_entries;\n      struct entry *entry_j = file2->entries[j];\n      ssize_t i;\n\n      /* Search whether it approximately occurs in file1.  */\n      ssize_t best_i = -1;\n      double best_i_similarity = 0.0;\n      for (i = n1 - 1; i >= 0; i--)\n        if (mapping->index_mapping[i] < 0)\n          {\n            double similarity =\n              entry_fstrcmp (file1->entries[i], entry_j, best_i_similarity);\n            if (similarity > best_i_similarity)\n              {\n                best_i = i;\n                best_i_similarity = similarity;\n              }\n          }\n      if (best_i_similarity >= FSTRCMP_THRESHOLD)\n        {\n          /* Found a similar entry in file1.  */\n          struct entry *entry_i = file1->entries[best_i];\n          /* Search whether it approximately occurs in file2 at index j.  */\n          ssize_t best_j = -1;\n          double best_j_similarity = 0.0;\n          ssize_t jj;\n          for (jj = n2 - 1; jj >= 0; jj--)\n            if (mapping->index_mapping_reverse[jj] < 0)\n              {\n                double similarity =\n                  entry_fstrcmp (entry_i, file2->entries[jj],\n                                 best_j_similarity);\n                if (similarity > best_j_similarity)\n                  {\n                    best_j = jj;\n                    best_j_similarity = similarity;\n                  }\n              }\n          if (best_j_similarity >= FSTRCMP_THRESHOLD && best_j == j)\n            {\n              mapping->index_mapping_reverse[j] = best_i;\n              mapping->index_mapping[best_i] = j;\n            }\n        }\n      if (mapping->index_mapping_reverse[j] < -1)\n        /* It does not approximately occur in FILE1.\n           Remember it, for next time.  */\n        mapping->index_mapping_reverse[j] = -1;\n    }\n  return mapping->index_mapping_reverse[j];\n}\n\n/* Compute a mapping (correspondence) between entries of FILE1 and of FILE2.\n   The correspondence also takes into account small modifications; i.e. the\n   indicated relation is not equality of entries but best-match similarity\n   of entries.\n   If FULL is true, the maximum of matching is done up-front.  If it is false,\n   it is done in a lazy way through the functions entries_mapping_get and\n   entries_mapping_reverse_get.\n   Return the result in *RESULT.  */\nstatic void\ncompute_mapping (struct changelog_file *file1, struct changelog_file *file2,\n                 bool full,\n                 struct entries_mapping *result)\n{\n  /* Mapping from indices in file1 to indices in file2.  */\n  ssize_t *index_mapping;\n  /* Mapping from indices in file2 to indices in file1.  */\n  ssize_t *index_mapping_reverse;\n  size_t n1 = file1->num_entries;\n  size_t n2 = file2->num_entries;\n  ssize_t i, j;\n\n  index_mapping = XNMALLOC (n1, ssize_t);\n  for (i = 0; i < n1; i++)\n    index_mapping[i] = -2;\n\n  index_mapping_reverse = XNMALLOC (n2, ssize_t);\n  for (j = 0; j < n2; j++)\n    index_mapping_reverse[j] = -2;\n\n  for (i = n1 - 1; i >= 0; i--)\n    /* Take an entry from file1.  */\n    if (index_mapping[i] < -1)\n      {\n        struct entry *entry = file1->entries[i];\n        /* Search whether it occurs in file2.  */\n        j = gl_list_indexof (file2->entries_reversed, entry);\n        if (j >= 0)\n          {\n            j = n2 - 1 - j;\n            /* Found an exact correspondence.  */\n            /* If index_mapping_reverse[j] >= 0, we have already seen other\n               copies of this entry, and there were more occurrences of it in\n               file1 than in file2.  In this case, do nothing.  */\n            if (index_mapping_reverse[j] < 0)\n              {\n                index_mapping[i] = j;\n                index_mapping_reverse[j] = i;\n                /* Look for more occurrences of the same entry.  Match them\n                   as long as they pair up.  Unpaired occurrences of the same\n                   entry are left without mapping.  */\n                {\n                  ssize_t curr_i = i;\n                  ssize_t curr_j = j;\n\n                  for (;;)\n                    {\n                      ssize_t next_i;\n                      ssize_t next_j;\n\n                      next_i =\n                        gl_list_indexof_from (file1->entries_reversed,\n                                              n1 - curr_i, entry);\n                      if (next_i < 0)\n                        break;\n                      next_j =\n                        gl_list_indexof_from (file2->entries_reversed,\n                                              n2 - curr_j, entry);\n                      if (next_j < 0)\n                        break;\n                      curr_i = n1 - 1 - next_i;\n                      curr_j = n2 - 1 - next_j;\n                      ASSERT (index_mapping[curr_i] < 0);\n                      ASSERT (index_mapping_reverse[curr_j] < 0);\n                      index_mapping[curr_i] = curr_j;\n                      index_mapping_reverse[curr_j] = curr_i;\n                    }\n                }\n              }\n          }\n      }\n\n  result->file1 = file1;\n  result->file2 = file2;\n  result->index_mapping = index_mapping;\n  result->index_mapping_reverse = index_mapping_reverse;\n\n  if (full)\n    for (i = n1 - 1; i >= 0; i--)\n      entries_mapping_get (result, i);\n}\n\n/* An \"edit\" is a textual modification performed by the user, that needs to\n   be applied to the other file.  */\nenum edit_type\n{\n  /* Some consecutive entries were added.  */\n  ADDITION,\n  /* Some consecutive entries were removed; some other consecutive entries\n     were added at the same position.  (Not necessarily the same number of\n     entries.)  */\n  CHANGE,\n  /* Some consecutive entries were removed.  */\n  REMOVAL\n};\n\n/* This structure represents an edit.  */\nstruct edit\n{\n  enum edit_type type;\n  /* Range of indices into the entries of FILE1.  */\n  ssize_t i1, i2;       /* first, last index; only used for CHANGE, REMOVAL */\n  /* Range of indices into the entries of FILE2.  */\n  ssize_t j1, j2;       /* first, last index; only used for ADDITION, CHANGE */\n};\n\n/* This structure represents the differences from one file, FILE1, to another\n   file, FILE2.  */\nstruct differences\n{\n  /* An array mapping FILE1 indices to FILE2 indices (or -1 when the entry\n     from FILE1 is not found in FILE2).  */\n  ssize_t *index_mapping;\n  /* An array mapping FILE2 indices to FILE1 indices (or -1 when the entry\n     from FILE2 is not found in FILE1).  */\n  ssize_t *index_mapping_reverse;\n  /* The edits that transform FILE1 into FILE2.  */\n  size_t num_edits;\n  struct edit **edits;\n};\n\n/* Import the difference detection algorithm from GNU diff.  */\n#define ELEMENT struct entry *\n#define EQUAL entry_equals\n#define OFFSET ssize_t\n#define EXTRA_CONTEXT_FIELDS \\\n  ssize_t *index_mapping; \\\n  ssize_t *index_mapping_reverse;\n#define NOTE_DELETE(ctxt, xoff) \\\n  ctxt->index_mapping[xoff] = -1\n#define NOTE_INSERT(ctxt, yoff) \\\n  ctxt->index_mapping_reverse[yoff] = -1\n#include \"diffseq.h\"\n\n/* Compute the differences between the entries of FILE1 and the entries of\n   FILE2.  */\nstatic void\ncompute_differences (struct changelog_file *file1, struct changelog_file *file2,\n                     struct differences *result)\n{\n  /* Unlike compute_mapping, which mostly ignores the order of the entries and\n     therefore works well when some entries are permuted, here we use the order.\n     I think this is needed in order to distinguish changes from\n     additions+removals; I don't know how to say what is a \"change\" if the\n     files are considered as unordered sets of entries.  */\n  struct context ctxt;\n  size_t n1 = file1->num_entries;\n  size_t n2 = file2->num_entries;\n  ssize_t i;\n  ssize_t j;\n  gl_list_t /* <struct edit *> */ edits;\n\n  ctxt.xvec = file1->entries;\n  ctxt.yvec = file2->entries;\n  ctxt.index_mapping = XNMALLOC (n1, ssize_t);\n  for (i = 0; i < n1; i++)\n    ctxt.index_mapping[i] = 0;\n  ctxt.index_mapping_reverse = XNMALLOC (n2, ssize_t);\n  for (j = 0; j < n2; j++)\n    ctxt.index_mapping_reverse[j] = 0;\n  ctxt.fdiag = XNMALLOC (2 * (n1 + n2 + 3), ssize_t) + n2 + 1;\n  ctxt.bdiag = ctxt.fdiag + n1 + n2 + 3;\n  ctxt.too_expensive = n1 + n2;\n\n  /* Store in ctxt.index_mapping and ctxt.index_mapping_reverse a -1 for\n     each removed or added entry.  */\n  compareseq (0, n1, 0, n2, 0, &ctxt);\n\n  /* Complete the index_mapping and index_mapping_reverse arrays.  */\n  i = 0;\n  j = 0;\n  while (i < n1 || j < n2)\n    {\n      while (i < n1 && ctxt.index_mapping[i] < 0)\n        i++;\n      while (j < n2 && ctxt.index_mapping_reverse[j] < 0)\n        j++;\n      ASSERT ((i < n1) == (j < n2));\n      if (i == n1 && j == n2)\n        break;\n      ctxt.index_mapping[i] = j;\n      ctxt.index_mapping_reverse[j] = i;\n      i++;\n      j++;\n    }\n\n  /* Create the edits.  */\n  edits = gl_list_create_empty (GL_ARRAY_LIST, NULL, NULL, NULL, true);\n  i = 0;\n  j = 0;\n  while (i < n1 || j < n2)\n    {\n      if (i == n1)\n        {\n          struct edit *e;\n          ASSERT (j < n2);\n          e = XMALLOC (struct edit);\n          e->type = ADDITION;\n          e->j1 = j;\n          e->j2 = n2 - 1;\n          gl_list_add_last (edits, e);\n          break;\n        }\n      if (j == n2)\n        {\n          struct edit *e;\n          ASSERT (i < n1);\n          e = XMALLOC (struct edit);\n          e->type = REMOVAL;\n          e->i1 = i;\n          e->i2 = n1 - 1;\n          gl_list_add_last (edits, e);\n          break;\n        }\n      if (ctxt.index_mapping[i] >= 0)\n        {\n          if (ctxt.index_mapping_reverse[j] >= 0)\n            {\n              ASSERT (ctxt.index_mapping[i] == j);\n              ASSERT (ctxt.index_mapping_reverse[j] == i);\n              i++;\n              j++;\n            }\n          else\n            {\n              struct edit *e;\n              ASSERT (ctxt.index_mapping_reverse[j] < 0);\n              e = XMALLOC (struct edit);\n              e->type = ADDITION;\n              e->j1 = j;\n              do\n                j++;\n              while (j < n2 && ctxt.index_mapping_reverse[j] < 0);\n              e->j2 = j - 1;\n              gl_list_add_last (edits, e);\n            }\n        }\n      else\n        {\n          if (ctxt.index_mapping_reverse[j] >= 0)\n            {\n              struct edit *e;\n              ASSERT (ctxt.index_mapping[i] < 0);\n              e = XMALLOC (struct edit);\n              e->type = REMOVAL;\n              e->i1 = i;\n              do\n                i++;\n              while (i < n1 && ctxt.index_mapping[i] < 0);\n              e->i2 = i - 1;\n              gl_list_add_last (edits, e);\n            }\n          else\n            {\n              struct edit *e;\n              ASSERT (ctxt.index_mapping[i] < 0);\n              ASSERT (ctxt.index_mapping_reverse[j] < 0);\n              e = XMALLOC (struct edit);\n              e->type = CHANGE;\n              e->i1 = i;\n              do\n                i++;\n              while (i < n1 && ctxt.index_mapping[i] < 0);\n              e->i2 = i - 1;\n              e->j1 = j;\n              do\n                j++;\n              while (j < n2 && ctxt.index_mapping_reverse[j] < 0);\n              e->j2 = j - 1;\n              gl_list_add_last (edits, e);\n            }\n        }\n    }\n\n  result->index_mapping = ctxt.index_mapping;\n  result->index_mapping_reverse = ctxt.index_mapping_reverse;\n  result->num_edits = gl_list_size (edits);\n  result->edits = XNMALLOC (result->num_edits, struct edit *);\n  {\n    size_t index = 0;\n    gl_list_iterator_t iter = gl_list_iterator (edits);\n    const void *elt;\n    gl_list_node_t node;\n    while (gl_list_iterator_next (&iter, &elt, &node))\n      result->edits[index++] = (struct edit *) elt;\n    gl_list_iterator_free (&iter);\n    ASSERT (index == result->num_edits);\n  }\n}\n\n/* An empty entry.  */\nstatic struct entry empty_entry = { NULL, 0 };\n\n/* Return the end a paragraph.\n   ENTRY is an entry.\n   OFFSET is an offset into the entry, OFFSET <= ENTRY->length.\n   Return the offset of the end of paragraph, as an offset <= ENTRY->length;\n   it is the start of a blank line or the end of the entry.  */\nstatic size_t\nfind_paragraph_end (const struct entry *entry, size_t offset)\n{\n  const char *string = entry->string;\n  size_t length = entry->length;\n\n  for (;;)\n    {\n      const char *nl = memchr (string + offset, '\\n', length - offset);\n      if (nl == NULL)\n        return length;\n      offset = (nl - string) + 1;\n      if (offset < length && string[offset] == '\\n')\n        return offset;\n    }\n}\n\n/* Split a merged entry.\n   Given an old entry of the form\n       TITLE\n       BODY\n   and a new entry of the form\n       TITLE\n       BODY1\n       BODY'\n   where the two titles are the same and BODY and BODY' are very similar,\n   this computes two new entries\n       TITLE\n       BODY1\n   and\n       TITLE\n       BODY'\n   and returns true.\n   If the entries don't have this form, it returns false.  */\nstatic bool\ntry_split_merged_entry (const struct entry *old_entry,\n                        const struct entry *new_entry,\n                        struct entry *new_split[2])\n{\n  size_t old_title_len = find_paragraph_end (old_entry, 0);\n  size_t new_title_len = find_paragraph_end (new_entry, 0);\n  struct entry old_body;\n  struct entry new_body;\n  size_t best_split_offset;\n  double best_similarity;\n  size_t split_offset;\n\n  /* Same title? */\n  if (!(old_title_len == new_title_len\n        && memcmp (old_entry->string, new_entry->string, old_title_len) == 0))\n    return false;\n\n  old_body.string = old_entry->string + old_title_len;\n  old_body.length = old_entry->length - old_title_len;\n\n  /* Determine where to split the new entry.\n     This is done by maximizing the similarity between BODY and BODY'.  */\n  best_split_offset = split_offset = new_title_len;\n  best_similarity = 0.0;\n  for (;;)\n    {\n      double similarity;\n\n      new_body.string = new_entry->string + split_offset;\n      new_body.length = new_entry->length - split_offset;\n      similarity =\n        entry_fstrcmp (&old_body, &new_body, best_similarity);\n      if (similarity > best_similarity)\n        {\n          best_split_offset = split_offset;\n          best_similarity = similarity;\n        }\n      if (best_similarity == 1.0)\n        /* It cannot get better.  */\n        break;\n\n      if (split_offset < new_entry->length)\n        split_offset = find_paragraph_end (new_entry, split_offset + 1);\n      else\n        break;\n    }\n\n  /* BODY' should not be empty.  */\n  if (best_split_offset == new_entry->length)\n    return false;\n  ASSERT (new_entry->string[best_split_offset] == '\\n');\n\n  /* A certain similarity between BODY and BODY' is required.  */\n  if (best_similarity < FSTRCMP_STRICTER_THRESHOLD)\n    return false;\n\n  new_split[0] = entry_create (new_entry->string, best_split_offset + 1);\n\n  {\n    size_t len1 = new_title_len;\n    size_t len2 = new_entry->length - best_split_offset;\n    char *combined = XNMALLOC (len1 + len2, char);\n    memcpy (combined, new_entry->string, len1);\n    memcpy (combined + len1, new_entry->string + best_split_offset, len2);\n    new_split[1] = entry_create (combined, len1 + len2);\n  }\n\n  return true;\n}\n\n/* Write the contents of an entry to the output stream FP.  */\nstatic void\nentry_write (FILE *fp, struct entry *entry)\n{\n  if (entry->length > 0)\n    fwrite (entry->string, 1, entry->length, fp);\n}\n\n/* This structure represents a conflict.\n   A conflict can occur for various reasons.  */\nstruct conflict\n{\n  /* Parts from the ancestor file.  */\n  size_t num_old_entries;\n  struct entry **old_entries;\n  /* Parts of the modified file.  */\n  size_t num_modified_entries;\n  struct entry **modified_entries;\n};\n\n/* Write a conflict to the output stream FP, including markers.  */\nstatic void\nconflict_write (FILE *fp, struct conflict *c)\n{\n  size_t i;\n\n  /* Use the same syntax as git's default merge driver.\n     Don't indent the contents of the entries (with things like \">\" or \"-\"),\n     otherwise the user needs more textual editing to resolve the conflict.  */\n  fputs (\"<<<<<<<\\n\", fp);\n  for (i = 0; i < c->num_old_entries; i++)\n    entry_write (fp, c->old_entries[i]);\n  fputs (\"=======\\n\", fp);\n  for (i = 0; i < c->num_modified_entries; i++)\n    entry_write (fp, c->modified_entries[i]);\n  fputs (\">>>>>>>\\n\", fp);\n}\n\n/* Long options.  */\nstatic const struct option long_options[] =\n{\n  { \"help\", no_argument, NULL, 'h' },\n  { \"split-merged-entry\", no_argument, NULL, CHAR_MAX + 1 },\n  { \"version\", no_argument, NULL, 'V' },\n  { NULL, 0, NULL, 0 }\n};\n\n/* Print a usage message and exit.  */\nstatic void\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, \"Try '%s --help' for more information.\\n\",\n             program_name);\n  else\n    {\n      printf (\"Usage: %s [OPTION] O-FILE-NAME A-FILE-NAME B-FILE-NAME\\n\",\n              program_name);\n      printf (\"\\n\");\n      printf (\"Merges independent modifications of a ChangeLog style file.\\n\");\n      printf (\"O-FILE-NAME names the original file, the ancestor of the two others.\\n\");\n      printf (\"A-FILE-NAME names the publicly modified file.\\n\");\n      printf (\"B-FILE-NAME names the user-modified file.\\n\");\n      printf (\"Writes the merged file into A-FILE-NAME.\\n\");\n      printf (\"\\n\");\n      #if 0 /* --split-merged-entry is now on by default.  */\n      printf (\"Operation modifiers:\\n\");\n      printf (\"\\\n      --split-merged-entry    Possibly split a merged entry between paragraphs.\\n\\\n                              Use this if you have the habit to merge unrelated\\n\\\n                              entries into a single one, separated only by a\\n\\\n                              newline, just because they happened on the same\\n\\\n                              date.\\n\");\n      printf (\"\\n\");\n      #endif\n      printf (\"Informative output:\\n\");\n      printf (\"  -h, --help                  display this help and exit\\n\");\n      printf (\"  -V, --version               output version information and exit\\n\");\n      printf (\"\\n\");\n      fputs (\"Report bugs to <bug-gnulib@gnu.org>.\\n\",\n             stdout);\n    }\n\n  exit (status);\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int optchar;\n  bool do_help;\n  bool do_version;\n  bool split_merged_entry;\n\n  /* Set program name for messages.  */\n  set_program_name (argv[0]);\n\n  /* Set default values for variables.  */\n  do_help = false;\n  do_version = false;\n  split_merged_entry = true;\n\n  /* Parse command line options.  */\n  while ((optchar = getopt_long (argc, argv, \"hV\", long_options, NULL)) != EOF)\n    switch (optchar)\n    {\n    case '\\0':          /* Long option.  */\n      break;\n    case 'h':\n      do_help = true;\n      break;\n    case 'V':\n      do_version = true;\n      break;\n    case CHAR_MAX + 1:  /* --split-merged-entry */\n      break;\n    default:\n      usage (EXIT_FAILURE);\n    }\n\n  if (do_version)\n    {\n      /* Version information is requested.  */\n      printf (\"%s\\n\", program_name);\n      printf (\"Copyright (C) %s Free Software Foundation, Inc.\\n\\\nLicense GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\",\n              \"2008\");\n      printf (\"Written by %s.\\n\", \"Bruno Haible\");\n      exit (EXIT_SUCCESS);\n    }\n\n  if (do_help)\n    {\n      /* Help is requested.  */\n      usage (EXIT_SUCCESS);\n    }\n\n  /* Test argument count.  */\n  if (optind + 3 != argc)\n    error (EXIT_FAILURE, 0, \"expected three arguments\");\n\n  {\n    const char *ancestor_file_name; /* O-FILE-NAME */\n    const char *destination_file_name; /* A-FILE-NAME */\n    bool downstream;\n    const char *other_file_name; /* B-FILE-NAME */\n    const char *mainstream_file_name;\n    const char *modified_file_name;\n    struct changelog_file ancestor_file;\n    struct changelog_file mainstream_file;\n    struct changelog_file modified_file;\n    /* Mapping from indices in ancestor_file to indices in mainstream_file.  */\n    struct entries_mapping mapping;\n    struct differences diffs;\n    gl_list_node_t *result_entries_pointers; /* array of pointers into result_entries */\n    gl_list_t /* <struct entry *> */ result_entries;\n    gl_list_t /* <struct conflict *> */ result_conflicts;\n\n    ancestor_file_name = argv[optind];\n    destination_file_name = argv[optind + 1];\n    other_file_name = argv[optind + 2];\n\n    /* Heuristic to determine whether it's a pull in downstream direction\n       (e.g. pull from a centralized server) or a pull in upstream direction\n       (e.g. \"git stash apply\").\n\n       For ChangeLog this distinction is important. The difference between\n       an \"upstream\" and a \"downstream\" repository is that more people are\n       looking at the \"upstream\" repository.  They want to be informed about\n       changes and expect them to be shown at the top of the ChangeLog.\n       When a user pulls downstream, on the other hand, he has two options:\n         a) He gets the change entries from the central repository also at the\n            top of his ChangeLog, and his own changes come after them.\n         b) He gets the change entries from the central repository after those\n            he has collected for his branch.  His own change entries stay at\n            the top of the ChangeLog file.\n       In the case a) he has to reorder the ChangeLog before he can commit.\n       No one does that.  So most people want b).\n       In other words, the order of entries in a ChangeLog should represent\n       the order in which they have flown (or will flow) into the *central*\n       repository.\n\n       But in git this is fundamentally indistinguishable, because when Linus\n       pulls patches from akpm and akpm pulls patches from Linus, it's not\n       clear which of the two is more \"upstream\".  Also, when you have many\n       branches in a repository and pull from one to another, \"git\" has no way\n       to know which branch is more \"upstream\" than the other.  The git-tag(1)\n       manual page also says:\n         \"One important aspect of git is it is distributed, and being\n          distributed largely means there is no inherent \"upstream\" or\n          \"downstream\" in the system.\"\n       Therefore anyone who attempts to produce a ChangeLog from the merge\n       history will fail.\n\n       Here we allow the user to specify the pull direction through an\n       environment variable (GIT_UPSTREAM or GIT_DOWNSTREAM).  If these two\n       environment variables are not set, we assume a \"simple single user\"\n       usage pattern: He manages local changes through stashes and uses\n       \"git pull\" only to pull downstream.\n\n       How to distinguish these situation? There are several hints:\n         - During a \"git stash apply\", GIT_REFLOG_ACTION is not set.  During\n           a \"git pull\", it is set to 'pull '. During a \"git pull --rebase\",\n           it is set to 'pull --rebase'.  During a \"git cherry-pick\", it is\n           set to 'cherry-pick'.\n         - During a \"git stash apply\", there is an environment variable of\n           the form GITHEAD_<40_hex_digits>='Stashed changes'.  */\n    {\n      const char *var;\n\n      var = getenv (\"GIT_DOWNSTREAM\");\n      if (var != NULL && var[0] != '\\0')\n        downstream = true;\n      else\n        {\n          var = getenv (\"GIT_UPSTREAM\");\n          if (var != NULL && var[0] != '\\0')\n            downstream = false;\n          else\n            {\n              var = getenv (\"GIT_REFLOG_ACTION\");\n              #if 0 /* Debugging code */\n              printf (\"GIT_REFLOG_ACTION=|%s|\\n\", var);\n              #endif\n              if (var != NULL\n                  && ((strncmp (var, \"pull\", 4) == 0\n                       && c_strstr (var, \" --rebase\") == NULL)\n                      || strncmp (var, \"merge origin\", 12) == 0))\n                downstream = true;\n              else\n                {\n                  /* \"git stash apply\", \"git rebase\", \"git cherry-pick\" and\n                     similar.  */\n                  downstream = false;\n                }\n            }\n        }\n    }\n\n    #if 0 /* Debugging code */\n    {\n      char buf[1000];\n      printf (\"First line of %%A:\\n\");\n      sprintf (buf, \"head -1 %s\", destination_file_name); system (buf);\n      printf (\"First line of %%B:\\n\");\n      sprintf (buf, \"head -1 %s\", other_file_name); system (buf);\n      printf (\"Guessing calling convention: %s\\n\",\n              downstream\n              ? \"%A = modified by user, %B = upstream\"\n              : \"%A = upstream, %B = modified by user\");\n    }\n    #endif\n\n    if (downstream)\n      {\n        mainstream_file_name = other_file_name;\n        modified_file_name = destination_file_name;\n      }\n    else\n      {\n        mainstream_file_name = destination_file_name;\n        modified_file_name = other_file_name;\n      }\n\n    /* Read the three files into memory.  */\n    read_changelog_file (ancestor_file_name, &ancestor_file);\n    read_changelog_file (mainstream_file_name, &mainstream_file);\n    read_changelog_file (modified_file_name, &modified_file);\n\n    /* Compute correspondence between the entries of ancestor_file and of\n       mainstream_file.  */\n    compute_mapping (&ancestor_file, &mainstream_file, false, &mapping);\n    (void) entries_mapping_reverse_get; /* avoid gcc \"defined but not\" warning */\n\n    /* Compute differences between the entries of ancestor_file and of\n       modified_file.  */\n    compute_differences (&ancestor_file, &modified_file, &diffs);\n\n    /* Compute the result.  */\n    result_entries_pointers =\n      XNMALLOC (mainstream_file.num_entries, gl_list_node_t);\n    result_entries =\n      gl_list_create_empty (GL_LINKED_LIST, entry_equals, entry_hashcode,\n                            NULL, true);\n    {\n      size_t k;\n      for (k = 0; k < mainstream_file.num_entries; k++)\n        result_entries_pointers[k] =\n          gl_list_add_last (result_entries, mainstream_file.entries[k]);\n    }\n    result_conflicts =\n      gl_list_create_empty (GL_ARRAY_LIST, NULL, NULL, NULL, true);\n    {\n      size_t e;\n      for (e = 0; e < diffs.num_edits; e++)\n        {\n          struct edit *edit = diffs.edits[e];\n          switch (edit->type)\n            {\n            case ADDITION:\n              if (edit->j1 == 0)\n                {\n                  /* An addition to the top of modified_file.\n                     Apply it to the top of mainstream_file.  */\n                  ssize_t j;\n                  for (j = edit->j2; j >= edit->j1; j--)\n                    {\n                      struct entry *added_entry = modified_file.entries[j];\n                      gl_list_add_first (result_entries, added_entry);\n                    }\n                }\n              else\n                {\n                  ssize_t i_before;\n                  ssize_t i_after;\n                  ssize_t k_before;\n                  ssize_t k_after;\n                  i_before = diffs.index_mapping_reverse[edit->j1 - 1];\n                  ASSERT (i_before >= 0);\n                  i_after = (edit->j2 + 1 == modified_file.num_entries\n                             ? ancestor_file.num_entries\n                             : diffs.index_mapping_reverse[edit->j2 + 1]);\n                  ASSERT (i_after >= 0);\n                  ASSERT (i_after == i_before + 1);\n                  /* An addition between ancestor_file.entries[i_before] and\n                     ancestor_file.entries[i_after].  See whether these two\n                     entries still exist in mainstream_file and are still\n                     consecutive.  */\n                  k_before = entries_mapping_get (&mapping, i_before);\n                  k_after = (i_after == ancestor_file.num_entries\n                             ? mainstream_file.num_entries\n                             : entries_mapping_get (&mapping, i_after));\n                  if (k_before >= 0 && k_after >= 0 && k_after == k_before + 1)\n                    {\n                      /* Yes, the entry before and after are still neighbours\n                         in mainstream_file.  Apply the addition between\n                         them.  */\n                      if (k_after == mainstream_file.num_entries)\n                        {\n                          size_t j;\n                          for (j = edit->j1; j <= edit->j2; j++)\n                            {\n                              struct entry *added_entry = modified_file.entries[j];\n                              gl_list_add_last (result_entries, added_entry);\n                            }\n                        }\n                      else\n                        {\n                          gl_list_node_t node_k_after = result_entries_pointers[k_after];\n                          size_t j;\n                          for (j = edit->j1; j <= edit->j2; j++)\n                            {\n                              struct entry *added_entry = modified_file.entries[j];\n                              gl_list_add_before (result_entries, node_k_after, added_entry);\n                            }\n                        }\n                    }\n                  else\n                    {\n                      /* It's not clear where the additions should be applied.\n                         Let the user decide.  */\n                      struct conflict *c = XMALLOC (struct conflict);\n                      size_t j;\n                      c->num_old_entries = 0;\n                      c->old_entries = NULL;\n                      c->num_modified_entries = edit->j2 - edit->j1 + 1;\n                      c->modified_entries =\n                        XNMALLOC (c->num_modified_entries, struct entry *);\n                      for (j = edit->j1; j <= edit->j2; j++)\n                        c->modified_entries[j - edit->j1] = modified_file.entries[j];\n                      gl_list_add_last (result_conflicts, c);\n                    }\n                }\n              break;\n            case REMOVAL:\n              {\n                /* Apply the removals one by one.  */\n                size_t i;\n                for (i = edit->i1; i <= edit->i2; i++)\n                  {\n                    struct entry *removed_entry = ancestor_file.entries[i];\n                    ssize_t k = entries_mapping_get (&mapping, i);\n                    if (k >= 0\n                        && entry_equals (removed_entry,\n                                         mainstream_file.entries[k]))\n                      {\n                        /* The entry to be removed still exists in\n                           mainstream_file.  Remove it.  */\n                        gl_list_node_set_value (result_entries,\n                                                result_entries_pointers[k],\n                                                &empty_entry);\n                      }\n                    else\n                      {\n                        /* The entry to be removed was already removed or was\n                           modified.  This is a conflict.  */\n                        struct conflict *c = XMALLOC (struct conflict);\n                        c->num_old_entries = 1;\n                        c->old_entries =\n                          XNMALLOC (c->num_old_entries, struct entry *);\n                        c->old_entries[0] = removed_entry;\n                        c->num_modified_entries = 0;\n                        c->modified_entries = NULL;\n                        gl_list_add_last (result_conflicts, c);\n                      }\n                  }\n              }\n              break;\n            case CHANGE:\n              {\n                bool done = false;\n                /* When the user usually merges entries from the same day,\n                   and this edit is at the top of the file:  */\n                if (split_merged_entry && edit->j1 == 0)\n                  {\n                    /* Test whether the change is \"simple merged\", i.e. whether\n                       it consists of additions, followed by an augmentation of\n                       the first changed entry, followed by small changes of the\n                       remaining entries:\n                         entry_1\n                         entry_2\n                         ...\n                         entry_n\n                       are mapped to\n                         added_entry\n                         ...\n                         added_entry\n                         augmented_entry_1\n                         modified_entry_2\n                         ...\n                         modified_entry_n.  */\n                    if (edit->i2 - edit->i1 <= edit->j2 - edit->j1)\n                      {\n                        struct entry *split[2];\n                        bool simple_merged =\n                          try_split_merged_entry (ancestor_file.entries[edit->i1],\n                                                  modified_file.entries[edit->i1 + edit->j2 - edit->i2],\n                                                  split);\n                        if (simple_merged)\n                          {\n                            size_t i;\n                            for (i = edit->i1 + 1; i <= edit->i2; i++)\n                              if (entry_fstrcmp (ancestor_file.entries[i],\n                                                 modified_file.entries[i + edit->j2 - edit->i2],\n                                                 FSTRCMP_THRESHOLD)\n                                  < FSTRCMP_THRESHOLD)\n                                {\n                                  simple_merged = false;\n                                  break;\n                                }\n                          }\n                        if (simple_merged)\n                          {\n                            /* Apply the additions at the top of modified_file.\n                               Apply each of the single-entry changes\n                               separately.  */\n                            size_t num_changed = edit->i2 - edit->i1 + 1; /* > 0 */\n                            size_t num_added = (edit->j2 - edit->j1 + 1) - num_changed;\n                            ssize_t j;\n                            /* First part of the split modified_file.entries[edit->j2 - edit->i2 + edit->i1]:  */\n                            gl_list_add_first (result_entries, split[0]);\n                            /* The additions.  */\n                            for (j = edit->j1 + num_added - 1; j >= edit->j1; j--)\n                              {\n                                struct entry *added_entry = modified_file.entries[j];\n                                gl_list_add_first (result_entries, added_entry);\n                              }\n                            /* Now the single-entry changes.  */\n                            for (j = edit->j1 + num_added; j <= edit->j2; j++)\n                              {\n                                struct entry *changed_entry =\n                                  (j == edit->j1 + num_added\n                                   ? split[1]\n                                   : modified_file.entries[j]);\n                                size_t i = j + edit->i2 - edit->j2;\n                                ssize_t k = entries_mapping_get (&mapping, i);\n                                if (k >= 0\n                                    && entry_equals (ancestor_file.entries[i],\n                                                     mainstream_file.entries[k]))\n                                  {\n                                    gl_list_node_set_value (result_entries,\n                                                            result_entries_pointers[k],\n                                                            changed_entry);\n                                  }\n                                else if (!entry_equals (ancestor_file.entries[i],\n                                                        changed_entry))\n                                  {\n                                    struct conflict *c = XMALLOC (struct conflict);\n                                    c->num_old_entries = 1;\n                                    c->old_entries =\n                                      XNMALLOC (c->num_old_entries, struct entry *);\n                                    c->old_entries[0] = ancestor_file.entries[i];\n                                    c->num_modified_entries = 1;\n                                    c->modified_entries =\n                                      XNMALLOC (c->num_modified_entries, struct entry *);\n                                    c->modified_entries[0] = changed_entry;\n                                    gl_list_add_last (result_conflicts, c);\n                                  }\n                              }\n                            done = true;\n                          }\n                      }\n                  }\n                if (!done)\n                  {\n                    bool simple;\n                    /* Test whether the change is \"simple\", i.e. whether it\n                       consists of small changes to the old ChangeLog entries\n                       and additions before them:\n                         entry_1\n                         ...\n                         entry_n\n                       are mapped to\n                         added_entry\n                         ...\n                         added_entry\n                         modified_entry_1\n                         ...\n                         modified_entry_n.  */\n                    if (edit->i2 - edit->i1 <= edit->j2 - edit->j1)\n                      {\n                        size_t i;\n                        simple = true;\n                        for (i = edit->i1; i <= edit->i2; i++)\n                          if (entry_fstrcmp (ancestor_file.entries[i],\n                                             modified_file.entries[i + edit->j2 - edit->i2],\n                                             FSTRCMP_THRESHOLD)\n                              < FSTRCMP_THRESHOLD)\n                            {\n                              simple = false;\n                              break;\n                            }\n                      }\n                    else\n                      simple = false;\n                    if (simple)\n                      {\n                        /* Apply the additions and each of the single-entry\n                           changes separately.  */\n                        size_t num_changed = edit->i2 - edit->i1 + 1; /* > 0 */\n                        size_t num_added = (edit->j2 - edit->j1 + 1) - num_changed;\n                        if (edit->j1 == 0)\n                          {\n                            /* A simple change at the top of modified_file.\n                               Apply it to the top of mainstream_file.  */\n                            ssize_t j;\n                            for (j = edit->j1 + num_added - 1; j >= edit->j1; j--)\n                              {\n                                struct entry *added_entry = modified_file.entries[j];\n                                gl_list_add_first (result_entries, added_entry);\n                              }\n                            for (j = edit->j1 + num_added; j <= edit->j2; j++)\n                              {\n                                struct entry *changed_entry = modified_file.entries[j];\n                                size_t i = j + edit->i2 - edit->j2;\n                                ssize_t k = entries_mapping_get (&mapping, i);\n                                if (k >= 0\n                                    && entry_equals (ancestor_file.entries[i],\n                                                     mainstream_file.entries[k]))\n                                  {\n                                    gl_list_node_set_value (result_entries,\n                                                            result_entries_pointers[k],\n                                                            changed_entry);\n                                  }\n                                else\n                                  {\n                                    struct conflict *c;\n                                    ASSERT (!entry_equals (ancestor_file.entries[i],\n                                                           changed_entry));\n                                    c = XMALLOC (struct conflict);\n                                    c->num_old_entries = 1;\n                                    c->old_entries =\n                                      XNMALLOC (c->num_old_entries, struct entry *);\n                                    c->old_entries[0] = ancestor_file.entries[i];\n                                    c->num_modified_entries = 1;\n                                    c->modified_entries =\n                                      XNMALLOC (c->num_modified_entries, struct entry *);\n                                    c->modified_entries[0] = changed_entry;\n                                    gl_list_add_last (result_conflicts, c);\n                                  }\n                              }\n                            done = true;\n                          }\n                        else\n                          {\n                            ssize_t i_before;\n                            ssize_t k_before;\n                            bool linear;\n                            i_before = diffs.index_mapping_reverse[edit->j1 - 1];\n                            ASSERT (i_before >= 0);\n                            /* A simple change after ancestor_file.entries[i_before].\n                               See whether this entry and the following num_changed\n                               entries still exist in mainstream_file and are still\n                               consecutive.  */\n                            k_before = entries_mapping_get (&mapping, i_before);\n                            linear = (k_before >= 0);\n                            if (linear)\n                              {\n                                size_t i;\n                                for (i = i_before + 1; i <= i_before + num_changed; i++)\n                                  if (entries_mapping_get (&mapping, i) != k_before + (i - i_before))\n                                    {\n                                      linear = false;\n                                      break;\n                                    }\n                              }\n                            if (linear)\n                              {\n                                gl_list_node_t node_for_insert =\n                                  result_entries_pointers[k_before + 1];\n                                ssize_t j;\n                                for (j = edit->j1 + num_added - 1; j >= edit->j1; j--)\n                                  {\n                                    struct entry *added_entry = modified_file.entries[j];\n                                    gl_list_add_before (result_entries, node_for_insert, added_entry);\n                                  }\n                                for (j = edit->j1 + num_added; j <= edit->j2; j++)\n                                  {\n                                    struct entry *changed_entry = modified_file.entries[j];\n                                    size_t i = j + edit->i2 - edit->j2;\n                                    ssize_t k = entries_mapping_get (&mapping, i);\n                                    ASSERT (k >= 0);\n                                    if (entry_equals (ancestor_file.entries[i],\n                                                      mainstream_file.entries[k]))\n                                      {\n                                        gl_list_node_set_value (result_entries,\n                                                                result_entries_pointers[k],\n                                                                changed_entry);\n                                      }\n                                    else\n                                      {\n                                        struct conflict *c;\n                                        ASSERT (!entry_equals (ancestor_file.entries[i],\n                                                               changed_entry));\n                                        c = XMALLOC (struct conflict);\n                                        c->num_old_entries = 1;\n                                        c->old_entries =\n                                          XNMALLOC (c->num_old_entries, struct entry *);\n                                        c->old_entries[0] = ancestor_file.entries[i];\n                                        c->num_modified_entries = 1;\n                                        c->modified_entries =\n                                          XNMALLOC (c->num_modified_entries, struct entry *);\n                                        c->modified_entries[0] = changed_entry;\n                                        gl_list_add_last (result_conflicts, c);\n                                      }\n                                  }\n                                done = true;\n                              }\n                          }\n                      }\n                    else\n                      {\n                        /* A big change.\n                           See whether the num_changed entries still exist\n                           unchanged in mainstream_file and are still\n                           consecutive.  */\n                        ssize_t i_first;\n                        ssize_t k_first;\n                        bool linear_unchanged;\n                        i_first = edit->i1;\n                        k_first = entries_mapping_get (&mapping, i_first);\n                        linear_unchanged =\n                          (k_first >= 0\n                           && entry_equals (ancestor_file.entries[i_first],\n                                            mainstream_file.entries[k_first]));\n                        if (linear_unchanged)\n                          {\n                            size_t i;\n                            for (i = i_first + 1; i <= edit->i2; i++)\n                              if (!(entries_mapping_get (&mapping, i) == k_first + (i - i_first)\n                                    && entry_equals (ancestor_file.entries[i],\n                                                     mainstream_file.entries[entries_mapping_get (&mapping, i)])))\n                                {\n                                  linear_unchanged = false;\n                                  break;\n                                }\n                          }\n                        if (linear_unchanged)\n                          {\n                            gl_list_node_t node_for_insert =\n                              result_entries_pointers[k_first];\n                            ssize_t j;\n                            size_t i;\n                            for (j = edit->j2; j >= edit->j1; j--)\n                              {\n                                struct entry *new_entry = modified_file.entries[j];\n                                gl_list_add_before (result_entries, node_for_insert, new_entry);\n                              }\n                            for (i = edit->i1; i <= edit->i2; i++)\n                              {\n                                ssize_t k = entries_mapping_get (&mapping, i);\n                                ASSERT (k >= 0);\n                                ASSERT (entry_equals (ancestor_file.entries[i],\n                                                      mainstream_file.entries[k]));\n                                gl_list_node_set_value (result_entries,\n                                                        result_entries_pointers[k],\n                                                        &empty_entry);\n                              }\n                            done = true;\n                          }\n                      }\n                  }\n                if (!done)\n                  {\n                    struct conflict *c = XMALLOC (struct conflict);\n                    size_t i, j;\n                    c->num_old_entries = edit->i2 - edit->i1 + 1;\n                    c->old_entries =\n                      XNMALLOC (c->num_old_entries, struct entry *);\n                    for (i = edit->i1; i <= edit->i2; i++)\n                      c->old_entries[i - edit->i1] = ancestor_file.entries[i];\n                    c->num_modified_entries = edit->j2 - edit->j1 + 1;\n                    c->modified_entries =\n                      XNMALLOC (c->num_modified_entries, struct entry *);\n                    for (j = edit->j1; j <= edit->j2; j++)\n                      c->modified_entries[j - edit->j1] = modified_file.entries[j];\n                    gl_list_add_last (result_conflicts, c);\n                  }\n              }\n              break;\n            }\n        }\n    }\n\n    /* Output the result.  */\n    {\n      FILE *fp = fopen (destination_file_name, \"w\");\n      if (fp == NULL)\n        {\n          fprintf (stderr, \"could not write file '%s'\\n\", destination_file_name);\n          exit (EXIT_FAILURE);\n        }\n\n      /* Output the conflicts at the top.  */\n      {\n        size_t n = gl_list_size (result_conflicts);\n        size_t i;\n        for (i = 0; i < n; i++)\n          conflict_write (fp, (struct conflict *) gl_list_get_at (result_conflicts, i));\n      }\n      /* Output the modified and unmodified entries, in order.  */\n      {\n        gl_list_iterator_t iter = gl_list_iterator (result_entries);\n        const void *elt;\n        gl_list_node_t node;\n        while (gl_list_iterator_next (&iter, &elt, &node))\n          entry_write (fp, (struct entry *) elt);\n        gl_list_iterator_free (&iter);\n      }\n\n      if (fwriteerror (fp))\n        {\n          fprintf (stderr, \"error writing to file '%s'\\n\", destination_file_name);\n          exit (EXIT_FAILURE);\n        }\n    }\n\n    exit (gl_list_size (result_conflicts) > 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n  }\n}\n"
        },
        {
          "name": "git-merge-dw",
          "type": "blob",
          "size": 0.1123046875,
          "content": "#!/bin/sh\n/Applications/Misc/DeltaWalker.app/Contents/MacOS/DeltaWalker -nosplash \"$PWD/$1\" \"$2\" \"$3\" -merged=\"$4\"\n"
        },
        {
          "name": "git-merge-from-svn",
          "type": "blob",
          "size": 2.400390625,
          "content": "#!/usr/bin/env ruby\n\nrequire 'fileutils'\n\n$name = \"git merge-from-svn\"\n\ndef usage retcode=0\n  puts <<USAGE\nusage: #{$name} [options] <ref>\n  -b <name>, --branch_name=<name> select the svn branch name\n  -e, --edit                      edit the message before commit\n  -l, --log                       show log in message (as in git merge)\n  -m <msg>, --message=<msg>       change default message\nUSAGE\n  exit retcode\nend\n\ndef die msg, usage=false\n  $stderr.puts msg\n  usage ? usage(-1) : exit(-1)\nend\n\ndef git_dir\n  $git_dir ||= %x(git rev-parse --git-dir).sub(/\\n$/,'')\nend\n\ndef ref_to_hash ref\n  %x(git rev-parse #{ref}).sub(/\\n$/,'')\nend\n\ndef hash_to_rev hash\n  %x(git svn find-rev #{hash}).sub(/\\n$/,'')\nend\n\ndef ref_to_rev rev\n  hash_to_rev( ref_to_hash(rev) )\nend\n\ndef merge_from_svn ref, opts={}\n  hash = ref_to_hash ref\n  rev  = hash_to_rev hash\n  branch_name = opts[:branch_name]\n  message = opts[:message]\n  unless branch_name\n    if ref =~ /svn\\//\n      branch_name = ref.sub(/svn\\//,'')\n    else\n      die %(can't find branch name)\n    end\n  end\n  puts \"#{ref} #{hash} #{rev} #{branch_name}\"\n  %x(git merge --no-commit --no-ff #{opts[:log] ? '--log' : ''} #{hash})\n\n  old_msg_name = \"#{git_dir}/MERGE_MSG\"\n  new_msg_name = \"#{git_dir}/MERGE_MSG_tmp\"\n\n  File.open new_msg_name, \"w\" do |new_msg|\n    first = true\n    File.open old_msg_name do |old_msg|\n      old_msg.each_line do |line|\n        if first\n          if message\n            new_msg.puts message\n          else\n            new_msg.puts \"Merge #{branch_name} (#{rev})\"\n          end\n          first = false\n        else\n          new_msg.puts line.sub(/commit '#{hash}'/, branch_name)\n        end\n      end\n    end\n  end\n  FileUtils.mv new_msg_name, old_msg_name\n  %x(git commit #{opts[:edit_message] ? '' : \"-F #{old_msg_name}\"})\nend\n\n\nref = nil\nopts = {}\nargs = ARGV.dup\nwhile arg = args.shift\n  case arg\n  when /-h|--help/\n    usage\n  when /-b|--branch-name/\n    if arg =~ /=/\n      opts[:branch_name] = arg.sub(/.*=\\s*/,'')\n    else\n      opts[:branch_name] = args.shift\n    end\n  when /-e|--edit-message/\n    opts[:edit] = true\n  when /-l|--log/\n    opts[:log] = true\n  when /-m|--message/\n    if arg =~ /=/\n      opts[:message] = arg.sub(/.*=\\s*/,'')\n    else\n      opts[:message] = args.shift\n    end\n  when /^-/\n    die \"unknow option #{arg}\", true\n  else\n    case\n    when ref\n      usage -1\n    else\n      ref = arg\n    end\n  end\nend\nusage -1 unless ref\nmerge_from_svn ref, opts\n"
        },
        {
          "name": "git-merge-repo",
          "type": "blob",
          "size": 0.4677734375,
          "content": "#!/bin/sh\n# merge one repo with another\n# http://www.kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html\n\n# Check arguments\nif [ $# -ne 2 ]; then\n    echo 1>&2 Usage:\n\techo 1>&2 \"  cd bigrepo\"\n\techo 1>&2 \"  $0 repo /path/to/repo\"\n    exit 127\nfi\n\nREPO=$1\nDIR=$2\n\ngit remote add -f $REPO $DIR\ngit merge -s ours --no-commit $REPO/master\ngit read-tree --prefix=$REPO/ -u $REPO/master\ngit commit -m \"Merge $REPO as our subdirectory\"\n\ngit pull -s subtree $REPO master\n"
        },
        {
          "name": "git-merge-to",
          "type": "blob",
          "size": 0.4423828125,
          "content": "#!/usr/bin/env bash\n# git merge-to <branch>\n\n# destination branch as parameter - depends on merge strategy, typically release\nDST_BRANCH=\"\"\nif [ ! -z \"$1\" ]; then\n    DST_BRANCH=\"$1\"\nelse\n\techo \"Usage: git merge-to <branch>\"\n\texit 1\nfi\n\n# get  current branch - typically master or develop\ncb=$(git rev-parse --abbrev-ref HEAD)\n# no fast forward merge from current branch to destination branch\ngit checkout $DST_BRANCH && git merge --ff $cb && git co $cb"
        },
        {
          "name": "git-opendiff",
          "type": "blob",
          "size": 2.404296875,
          "content": "#!/usr/bin/env ruby\n\n########################################################################################################\n# Usage:                                                                                               #\n#  gitopendiff [-r<left rev>:<right-rev>] [repository]                                                   #\n#                                                                                                      #\n# Example:                                                                                             #\n#  gitopendiff                                       # == gitopendiff -rHEAD^:HEAD .                       #\n#  gitopendiff -rHEAD^^:HEAD                         # == gitopendiff -rHEAD^^:HEAD .                      #\n#  gitopendiff -master:origin/master                 # == gitopendiff -rmaster:origin/master .             #\n#  gitopendiff /path/to/git/repository               # == gitopendiff -rHEAD^:HEAD /path/to/git/repository #\n#  gitopendiff -rHEAD^:HEAD /path/to/git/repository  # == gitopendiff -rHEAD^:HEAD /path/to/git/repository #\n#                                                                                                      #\n# Authored by Simon Menke, with minor optimizations by Jonathan del Strother                           #\n########################################################################################################\n\ndef checkout(origin, rev)\n  tmp = \"/tmp/git_opendiff_#{rand}.tmp/\"\n  Dir.mkdir(tmp)\n  Dir.chdir(origin) do\n    # The clean, porcelainy way would be \"git archive --format=tar '#{rev}' | (cd #{tmp} && tar xf -)\"\n    # I've found the plumbing to be marginally faster :\n    system \"git read-tree '#{rev}'; git checkout-index --prefix=#{tmp} -a; git read-tree HEAD\"\n  end\n  return tmp\nend\n\ndef diff(origin, revs={})\n  revs = {:left=>\"HEAD^\",:right=>\"HEAD\"}.merge(revs)\n  left  = checkout origin, revs[:left]\n  right = checkout origin, revs[:right]\n  system \"opendiff '#{left}' '#{right}'\"\nend\n\nrevs     = {}\ngit_dir = Dir.pwd\nARGV.each do |arg|\n  if arg[0,2] == \"-r\"\n    rev_strings = arg[2..-1].split(':')\n    case rev_strings.size\n    when 1\n      revs[:left]  = rev_strings[0] unless rev_strings[0].empty?\n    when 2\n      revs[:left]  = rev_strings[0] unless rev_strings[0].empty?\n      revs[:right] = rev_strings[1] unless rev_strings[1].empty?\n    else\n      revs = nil\n    end\n  else\n    git_dir = arg unless arg.empty?\n  end\nend\n\ndiff(git_dir, revs)\n"
        },
        {
          "name": "git-pr",
          "type": "blob",
          "size": 0.353515625,
          "content": "#!/usr/bin/env bash\n# Based on https://gist.github.com/gnarf/5406589\n\nif test \"$1\" = \"clean\"; then\n  git for-each-ref refs/heads/pr/* --format='%(refname)' | while read ref; do\n    git branch -D ${ref#refs/heads/}\n  done\nelse\n  test -z $1 && echo \"pr number required.\" 1>&2 && exit 1\n  git fetch -fu ${2:-origin} refs/pull/$1/head:pr/$1 && git checkout pr/$1\nfi\n"
        },
        {
          "name": "git-publish",
          "type": "blob",
          "size": 0.181640625,
          "content": "#!/usr/bin/env bash\n\nSERVER=$1\nPATHNAME=$2\n\nssh $SERVER \"mkdir $PATHNAME; GIT_DIR=$PATHNAME git init\"\n\ngit remote add $3 git+ssh://$SERVER$PATHNAME\n\ngit push $3 master:refs/heads/master\n"
        },
        {
          "name": "git-publish-repo",
          "type": "blob",
          "size": 0.072265625,
          "content": "#!/bin/sh\n\nfor i in \"$@\" ; do rsync -av $i/.git jw:/srv/git/$i.git ; done\n"
        },
        {
          "name": "git-pulltree",
          "type": "blob",
          "size": 0.087890625,
          "content": "#!/usr/bin/env bash\ngit subtree pull --prefix \"$1\" \"ext/$(basename \"$1\")\" master --squash\n"
        },
        {
          "name": "git-push-all",
          "type": "blob",
          "size": 0.0634765625,
          "content": "#!/bin/sh\nfor remote in $(git remote); do git push $remote; done\n"
        },
        {
          "name": "git-push-branch",
          "type": "blob",
          "size": 0.10546875,
          "content": "#!/bin/sh\nBRANCH=\"${1:-$(git rev-parse --abbrev-ref HEAD)}\"\necho git push origin $BRANCH:refs/heads/$BRANCH\n"
        },
        {
          "name": "git-push-home",
          "type": "blob",
          "size": 0.1064453125,
          "content": "#!/bin/sh\n\n# Assumes you have done:\n#\n#    git remote add backup your-other-host:r/home.git\n\ngit push backup\n"
        },
        {
          "name": "git-pushtree",
          "type": "blob",
          "size": 0.080078125,
          "content": "#!/usr/bin/env bash\ngit subtree push --prefix \"$1\" \"fork/$(basename \"$1\")\" master\n"
        },
        {
          "name": "git-rank-contributors",
          "type": "blob",
          "size": 1.8017578125,
          "content": "#!/usr/bin/env ruby\n\n## git-rank-contributors: a simple script to trace through the logs and\n## rank contributors by the total size of the diffs they're responsible for.\n## A change counts twice as much as a plain addition or deletion.\n##\n## Output may or may not be suitable for inclusion in a CREDITS file.\n## Probably not without some editing, because people often commit from more\n## than one address.\n##\n## git-rank-contributors Copyright 2008 William Morgan <wmorgan-git-wt-add@masanjin.net>.\n## This program is free software: you can redistribute it and/or modify\n## it under the terms of the GNU General Public License as published by\n## the Free Software Foundation, either version 3 of the License, or (at\n## your option) any later version.\n##\n## This program is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n## GNU General Public License for more details.\n##\n## You can find the GNU General Public License at:\n##   http://www.gnu.org/licenses/\n\nclass String\n  def obfuscate; gsub(/@/, \" at the \").gsub(/\\.(\\w+)(>|$)/, ' dot \\1s\\2') end\nend\n\nlines = {}\nverbose = ARGV.delete(\"-v\")\nobfuscate = ARGV.delete(\"-o\")\n\nauthor = nil\nstate = :pre_author\n`git log -p --no-color`.lines.each do |l|\n  case\n  when (state == :pre_author || state == :post_author) && l =~ /Author: (.*)$/\n    author = $1\n    state = :post_author\n    lines[author] ||= 0\n  when state == :post_author && l =~ /^\\+\\+\\+/\n    state = :in_diff\n  when state == :in_diff && l =~ /^[\\+\\-]/\n    lines[author] += 1\n  when state == :in_diff && l =~ /^commit /\n    state = :pre_author\n  end\nend\n\nlines.sort_by { |a, c| -c }.each do |a, c|\n  a = a.obfuscate if obfuscate\n  if verbose\n    puts \"#{a}: #{c} lines of diff\"\n  else\n    puts a\n  end\nend\n"
        },
        {
          "name": "git-rebase-master",
          "type": "blob",
          "size": 0.0966796875,
          "content": "#!/usr/bin/env bash\nset -e\ngit checkout master\ngit pull --ff-only\ngit checkout -\ngit rebase master\n"
        },
        {
          "name": "git-rebranch",
          "type": "blob",
          "size": 0.6591796875,
          "content": "#!/usr/bin/env bash\nset -e\nnewbranch=$1\nremote=${2:-origin/master}\n\nif [[ -z $newbranch || -z $remote ]]; then\n    echo usage: git rebranch NAME REMOTE-BRANCH\n    echo\n    echo example: git branch mybranch origin/master\n    echo\n    echo \"This preserves current working tree changes in a stash,\"\n    echo \"then creates a new branch tracking origin/master so that\"\n    echo \"you can work in a fresh tree.\"\n    exit 1\nfi\n\nif [[ ! $remote =~ \"/\" ]]; then\n    echo \"The remote argument should be of the form: remote/branch.\"\n    echo \"For example: origin/master\"\n    exit 1\nfi\n\ngit stash                   # stash away working tree changes\n\ngit checkout -b $newbranch -t $remote\n"
        },
        {
          "name": "git-record",
          "type": "blob",
          "size": 6.7275390625,
          "content": "#!/usr/bin/env python\n# coding: utf-8\n\n# git-darcs-record, emulate \"darcs record\" interface on top of a git repository\n#\n# Usage:\n# git-darcs-record first asks for any new file (previously\n#    untracked) to be added to the index.\n# git-darcs-record then asks for each hunk to be recorded in\n#    the next commit. File deletion and binary blobs are supported\n# git-darcs-record finally asks for a small commit message and\n#    executes the 'git commit' command with the newly created\n#    changeset in the index\n\n\n# Copyright (C) 2007 Raphaël Slinckx <raphael@slinckx.net>\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nimport re, pprint, sys, os\n\nBINARY = re.compile(\"GIT binary patch\")\nHEADER = re.compile(\"diff --git a/(.*) b/(.*)\")\nclass Hunk:\n\tdef __init__(self, lines, binary):\n\t\tself.diff = None\n\t\tself.lines = lines\n\t\tself.keep = False\n\t\tself.binary = binary\n\n\tdef format(self):\n\t\toutput = self.diff.header.modified + \"\\n\"\n\t\tif self.diff.header.deleted:\n\t\t\toutput = \"Removed file: \" + output\n\t\tif self.binary:\n\t\t\toutput = \"Binary file changed: \" + output\n\n\t\tif not self.binary:\n\t\t\toutput += \"\\n\".join(self.lines) + \"\\n\"\n\n\t\treturn output\n\nclass Header:\n\tdef __init__(self, lines):\n\t\tself.lines = lines\n\t\tself.modified = None\n\t\tself.deleted = False\n\n\t\t# Extract useful info from header from git\n\t\tfor line in lines:\n\t\t\tif HEADER.match(line):\n\t\t\t\tmatch = HEADER.match(line)\n\t\t\t\tself.modified = match.group(1)\n\t\t\tif line.startswith(\"deleted \"):\n\t\t\t\tself.deleted = True\n\n\t\t# Make sure we know what file we are modifying\n\t\tassert self.modified\n\nclass Diff:\n\tdef __init__(self, header, hunks):\n\t\tself.header = header\n\t\tself.hunks = hunks\n\t\t# Put a reference to ourselves in the hunks\n\t\tfor hunk in self.hunks:\n\t\t\thunk.diff = self\n\t\tself.keep = False\n\n\tdef filter(self):\n\t\toutput = '\\n'.join(self.header.lines) + \"\\n\"\n\t\tfor hunk in self.hunks:\n\t\t\tif not hunk.keep:\n\t\t\t\tcontinue\n\t\t\toutput += '\\n'.join(hunk.lines) + \"\\n\"\n\t\treturn output\n\n\t@classmethod\n\tdef filter_diffs(kls, diffs):\n\t\toutput = \"\"\n\t\tfor diff in diffs:\n\t\t\tif not diff.keep:\n\t\t\t\tcontinue\n\t\t\toutput += diff.filter()\n\t\treturn output\n\n\t@classmethod\n\tdef parse(kls, lines):\n\t\tin_header = True\n\t\tbinary = False\n\t\theader = []\n\t\thunks = []\n\t\tcurrent_hunk = []\n\t\tfor line in lines:\n\t\t\tif in_header and (line[0] not in (\" \", \"@\", \"\\\\\") or line.startswith(\"+++ \") or line.startswith(\"--- \")) and not BINARY.match(line):\n\t\t\t\theader.append(line)\n\t\t\telif BINARY.match(line):\n\t\t\t\tin_header = False\n\t\t\t\tbinary = True\n\t\t\t\theader.append(line)\n\t\t\telif len(line) >= 1 and line[0] == \"@\":\n\t\t\t\tin_header = False\n\t\t\t\tif current_hunk:\n\t\t\t\t\thunks.append(Hunk(current_hunk, binary))\n\t\t\t\tcurrent_hunk = []\n\t\t\t\tcurrent_hunk.append(line)\n\t\t\telse:\n\t\t\t\tcurrent_hunk.append(line)\n\t\tif current_hunk:\n\t\t\thunks.append(Hunk(current_hunk, binary))\n\t\treturn Diff(Header(header), hunks)\n\n\t@classmethod\n\tdef split(kls, lines):\n\t\tdiffs = []\n\t\tcurrent_diff = []\n\t\tfor line in lines:\n\t\t\tif line.startswith(\"diff --git \"):\n\t\t\t\tif current_diff:\n\t\t\t\t\tdiffs.append(current_diff)\n\t\t\t\tcurrent_diff = []\n\t\t\t\tcurrent_diff.append(line)\n\t\t\telse:\n\t\t\t\tcurrent_diff.append(line)\n\t\tif current_diff:\n\t\t\tdiffs.append(current_diff)\n\t\treturn [Diff.parse(lines) for lines in diffs]\n\ndef read_answer(question, allowed_responses=[\"Y\", \"n\", \"d\", \"a\"]):\n\t#Make sure there is alway a default selection\n\tassert [r for r in allowed_responses if r.isupper()]\n\n\twhile True:\n\t\tresp = raw_input(\"%s [%s] : \" % (question, \"\".join(allowed_responses)))\n\t\tif resp in [r.lower() for r in allowed_responses]:\n\t\t\tbreak\n\t\telif resp == \"\":\n\t\t\tresp = [r for r in allowed_responses if r.isupper()][0].lower()\n\t\t\tbreak\n\t\tprint 'Unexpected answer: %r' % resp\n\treturn resp\n\n\ndef setup_git_dir():\n\tglobal GIT_DIR\n\tGIT_DIR = os.getcwd()\n\twhile not os.path.exists(os.path.join(GIT_DIR, \".git\")):\n\t\tGIT_DIR = os.path.dirname(GIT_DIR)\n\t\tif GIT_DIR == \"/\":\n\t\t\treturn False\n\tos.chdir(GIT_DIR)\n\treturn True\n\ndef git_get_untracked_files():\n\treturn [f.strip() for f in os.popen(\"git ls-files --others --exclude-from='%s' --exclude-per-directory=.gitignore\" % (os.path.join(GIT_DIR, \".git\", \"info\", \"exclude\"))).readlines()]\n\ndef git_track_file(f):\n\tos.spawnvp(os.P_WAIT, \"git\", [\"git\", \"add\", f])\n\ndef git_diff():\n\treturn os.popen(\"git diff -u --no-color --binary\").readlines()\n\ndef git_apply(patch):\n\tstdin, stdout = os.popen2([\"git\", \"apply\", \"--cached\",  \"-\"])\n\tstdin.write(patch)\n\tstdin.close()\n\toutput = stdout.read()\n\tstdout.close()\n\tos.wait()\n\treturn output\n\ndef git_status():\n\tos.spawnvp(os.P_WAIT, \"git\", [\"git\", \"status\"])\n\ndef git_commit(msg):\n\tos.spawnvp(os.P_WAIT, \"git\", [\"git\", \"commit\", \"-m\", patch_name])\n\n# Main loop ------------------------\nif not setup_git_dir():\n\tprint \"Must be in a git (sub-)directory! Exiting...\"\n\tsys.exit()\n\n# Ask for new files ----------------\ngit_untracked_files = git_get_untracked_files()\ngit_track_files = []\nall = False\ndone = False\nfor i, f in enumerate(git_untracked_files):\n\tif not all:\n\t\tprint \"Add file: \", f\n\t\tresp = read_answer(\"Shall I add this file? (%d/%d)\" % (i+1, len(git_untracked_files)))\n\telse:\n\t\tresp = \"y\"\n\n\tif resp == \"y\":\n\t\tgit_track_files.append(f)\n\telif resp == \"a\":\n\t\tgit_track_files.append(f)\n\t\tall = True\n\telif resp == \"d\":\n\t\tdone = True\n\t\tbreak\n\n# Ask for each hunk of the diff\ndiffs = Diff.split([line[:-1] for line in git_diff()])\ntotal_hunks = sum([len(diff.hunks) for diff in diffs])\n\nn_hunk = 1\nfor diff in diffs:\n\tif done:\n\t\tbreak\n\tfor hunk in diff.hunks:\n\t\t# Check if we are in override mode\n\t\tif not all:\n\t\t\tprint\n\t\t\tprint hunk.format()\n\t\t\tresp = read_answer('Shall I record this change? (%d/%d)' % (n_hunk, total_hunks))\n\t\t# Otherwise say 'y' to all remaining patches\n\t\telse:\n\t\t\tresp = \"y\"\n\n\t\tif resp == \"y\":\n\t\t\tdiff.keep = True\n\t\t\thunk.keep = True\n\t\telif resp == \"a\":\n\t\t\tdiff.keep = True\n\t\t\thunk.keep = True\n\t\t\tall = True\n\t\telif resp == \"d\":\n\t\t\tdone = True\n\t\t\tbreak\n\n\t\tn_hunk += 1\n\n# Add new files to track\nfor f in git_track_files:\n\tgit_track_file(f)\n\n# Generate a new patch to be used with git apply\nnew_patch = Diff.filter_diffs(diffs)\nif new_patch:\n\tprint git_apply(new_patch)\n\nif new_patch or git_track_files:\n\tgit_status()\n\tpatch_name = raw_input(\"What is the patch name? \")\n\tgit_commit(patch_name)\nelse:\n\tprint \"Ok, if you don't want to record anything, that's fine!\"\n"
        },
        {
          "name": "git-release",
          "type": "blob",
          "size": 0.5400390625,
          "content": "#!/usr/bin/env bash\n# git release <branch>\n\n# destination branch as parameter - depends on merge strategy, typically release\nDST_BRANCH=\"\"\nif [ ! -z \"$1\" ]; then\n    DST_BRANCH=\"$1\"\nelse\n\techo \"Usage: git release <branch>\"\n\texit 1\nfi\n\n# get  current branch - typically master or develop\ncb=$(git rev-parse --abbrev-ref HEAD)\n# push current branch, pull destination branch, fast forward merge from current branch to destination branch, push and return\ngit push && git checkout $DST_BRANCH && git pull && git merge --ff $cb && git push && git checkout $cb"
        },
        {
          "name": "git-remote-in-sync.sh",
          "type": "blob",
          "size": 3.876953125,
          "content": "#!/usr/bin/env bash\n# checks if the specified remote(s) are in sync with what we have\n# in other words: do we have anything which is not at the remote?\n# Any commit, tag, branch, dirty WC/index or stashed state?\n# This is especially useful if you're wondering:\n# \"is it safe to delete this clone? is any work here that needs to be\n# distributed/shared/pushed first?\"\n# Note that there are some special cases, like a branch here may\n# have a different name on the remote.  This script is not aware of\n# stuff like that.  Also, `git status` will not detect if the local\n# repo is ahead of an svn repo (using git svn)\n\n# written by Dieter Plaetinck\n\nlist=\"$*\"\n[ -z \"$list\" ] && list=$(git remote)\nret=0\n\nif [ -z \"$(git branch)\" ]\nthen\n\tif [ \"$(cd \"$(git root)\" && ls -Al | grep -Ev \"^(.git|total)\" | wc -l)\" -gt 0 ]\n\tthen\n\t\techo \"WARN: This repo doesn't contain any branch, but contains a bunch of files!\" >&2\n\t\tls -Alh \"$(git root)\"\n\t\tret=1\n\telse\n\t\techo \"INFO: This repo doesn't contain any branch, and is empty\"\n\t\t# note that stashing doesn't work without a branch, so the above check is sufficient\n\t\texit 0\n\tfi\nelse\n\techo -n \"INFO: Valid git repo with branches: \"\n\tgit branch | tr '\\n' ' '\n\techo\nfi\n\nif [ -z \"$list\" ]\nthen\n\techo \"WARN: At least one branch, but no remotes found!  The content here might be unique!\" >&2\n\tret=1\nelse\n\tif [ -n \"$*\" ]\n\tthen\n\t\techo \"INFO: working with remote(s): $*\"\n\t\techo \"INFO: fyi, all remotes: $(git remote)\"\n\telse\n\t\techo \"INFO: working with all remotes: $list\"\n\tfi\nfi\n\nfor remote in $list;\ndo\n\techo \"INFO: Checking remote $remote..\"\n\t# Check commits and branches\n\t# An approach where you `git push --all -n $remote 2>&1` and check whether the result is\n\t# 'Everything up-to-date' can (and often will) yield\n\t# \"To prevent you from losing history, non-fast-forward updates were rejected\"\n\t# Since such an approach does traffic with the remote anyway, I choose to fetch the origin\n\t# and inspect it's branches.  This is a bit inefficient network-wise, but couldn't see a better solution\n\tif ! git fetch $remote\n\tthen\n\t\techo \"  WARN: could not git fetch $remote\" >&2\n\t\tret=1\n\tfi\n\tIFS_BACKUP=$IFS\n\tIFS=$'\\n'\n\tfor branch in $(git branch)\n\tdo\n\t\tbranch=${branch/\\*/};\n\t\tbranch_local=${branch// /}; # git branch prefixes branches with spaces. and spaces in branchnames are illegal.\n\t\tif ! git branch -r --contains $branch_local 2>/dev/null | grep -q \"^  $remote/\"\n\t\tthen\n\t\t\techo \"  WARN: Branch $branch_local is not contained within remote $remote!\" >&2\n\t\t\tret=1\n\t\telse\n\t\t\techo \"  INFO: Branch $branch_local is contained within remote $remote\"\n\t\tfi\n\t\tif ! git branch -r | grep -q \"^  $remote/$branch_local\"\n\t\tthen\n\t\t\techo \"  WARN: Branch $branch_local exists, but not $remote/$branch_local\" >&2\n\t\t\tret=1\n\t\telse\n\t\t\techo \"  INFO: Branch $branch_local exists also as $remote/$branch_local\"\n\t\tfi\n\tdone\n\tIFS=$IFS_BACKUP\n\n\t# Check tags\n\tout=$(git push --tags -n \"$remote\" 2>&1)\n\tif [ \"$out\" != 'Everything up-to-date' ];\n\tthen\n\t\techo -e \"  WARN: Some tags are not in $remote!\\n$out\" >&2\n\t\tret=1\n\telse\n\t\techo \"  INFO: All tags ($(git tag)) exist at $remote as well\"\n\tfi\ndone\n\n# Check WC/index\ncur_branch=$(git branch | grep '^\\* ' | cut -d ' ' -f2)\ncur_branch=${cur_branch// /}\nexp=\"# On branch $cur_branch\nnothing to commit (working directory clean)\"\nout=$(git status)\nwc_ok=1\nif [ \"$out\" != \"$exp\" ]\nthen\n\t# usually i'd use bash regex, but this case is multiple-lines so bash regex is no go\n\tout=$(echo \"$out\" | grep -E -v \"^(# On branch $cur_branch|# Your branch is behind .* commits, and can be fast-forwarded.|#|nothing to commit \\(working directory clean\\))$\")\n\tif [ -n \"$out\" ]\n\tthen\n\t\twc_ok=0\n\t\techo \"WARN: Dirty WC or index\" >&2\n\t\tgit status\n\t\tret=1\n\tfi\nfi\nif [ $wc_ok -eq 1 ]\nthen\n\techo \"INFO: Working copy/index are clean\"\n\tgit status\nfi\n\n# Check stash\nif [ \"$(git stash list | wc -l)\" -gt 0 ];\nthen\n\techo \"WARN: Dirty stash:\" >&2\n\tGIT_PAGER= git stash list >&2\n\tret=1\nelse\n\techo \"INFO: Stash clean\"\n\tGIT_PAGER= git stash list\nfi\nexit $ret\n"
        },
        {
          "name": "git-remove",
          "type": "blob",
          "size": 0.052734375,
          "content": "#!/bin/sh\ngit ls-files --deleted -z | xargs -0 git rm\n"
        },
        {
          "name": "git-remove-empty-commits",
          "type": "blob",
          "size": 0.1513671875,
          "content": "#!/usr/bin/env bash\ngit filter-branch --commit-filter 'if [ z$1 = z`git rev-parse $3^{tree}` ]; then skip_commit \"$@\"; else git commit-tree \"$@\"; fi' \"$@\"\n"
        },
        {
          "name": "git-rename",
          "type": "blob",
          "size": 0.0947265625,
          "content": "#!/bin/sh\n\nold=$1\nnew=$2\n\ngit rm --cached -r \"$old\"\nmv \"$old\" x.$$\nmv x.$$ \"$new\"\ngit add \"$new\"\n"
        },
        {
          "name": "git-retrack",
          "type": "blob",
          "size": 0.36328125,
          "content": "#!/bin/sh\n\n# Based on an alias written by doener on #git.\n\n# usage: git retrack REMOTE URL BRANCH\n\nbranch=$(git rev-parse --symbolic-full-name HEAD | sed 's/refs\\/heads\\///')\n\nif [ -n \"$2\" ]; then\n    git remote add -f $1 \"$2\" || echo But that\\'s perfectly OK.\nfi\n\ngit config branch.$branch.remote \"${1:-origin}\"\ngit config branch.$branch.merge \"refs/heads/${3:-$branch}\"\n"
        },
        {
          "name": "git-rm-conflicts",
          "type": "blob",
          "size": 1.5673828125,
          "content": "#!/usr/bin/env bash\n\n# git-rm-conflicts, version 1.3\n#\n# by John Wiegley <johnw@newartisans.com>\n#\n# Run without arguments to see usage.\n\nif [[ -z \"$1\" ]]; then\n    cat <<EOF\nusage: git rm-conflicts ours|theirs FILES...\n\nWith 'ours', delete conflicts coming from the current branch (aka HEAD).\nWith 'theirs', delete conflicting code from the commits you're trying to\nmerge in.\n\nExample:\n  $ git checkout master\n  $ git merge foo\n    <lots of conficts from foo I don't care about>\n  $ git rm-conflicts ours FILE1 FILE2\n    <delete conflicts in FILE1 and 2, but check the others>\n\nNOTE: You almost never want to use this command, but instead should\ncheck why exactly your files are conflicting.  Use of this script is\nalmost guaranteed to throw away code you don't want to throw away!!\nBut if you need it, here it is.\nEOF\n    exit 1\nfi\n\nrecursed=false\nif [[ \"$1\" == --recursed ]]; then\n    recursed=true\n    shift 1\nfi\n\nif [[ \"$1\" == ours ]]; then\n    shift 1\n    wipe=ours\nelif [[ \"$1\" == theirs ]]; then\n    shift 1\n    wipe=theirs\nelse\n    echo error: Must specify which set of changes to remove: ours or theirs\n    exit 1\nfi\n\nfor item in \"$@\"; do\n    if [[ -d \"$item\" && $recursed == false ]]; then\n\tif [[ $(basename \"$item\") != .git ]]; then\n\t    git ls-files -z -u \"$item\" | xargs -0 $0 --recursed $wipe\n\tfi\n    elif [[ -f \"$item\" ]]; then\n\techo Removing $wipe from: $item\n\tif [[ $wipe == ours ]]; then\n\t    perl -i -ne 'print unless /<<<<<</ .. /======/ or />>>>>>/;' \"$item\"\n\telif [[ $wipe == theirs ]]; then\n\t    perl -i -ne 'print unless /<<<<<</ or /======/ .. />>>>>>/;' \"$item\"\n\tfi\n    fi\ndone\n"
        },
        {
          "name": "git-root",
          "type": "blob",
          "size": 0.4091796875,
          "content": "#!/bin/sh\n# inspired by http://stackoverflow.com/questions/957928/is-there-a-way-to-get-to-the-git-root-directory-in-one-command/3009378#3009378\n# gives absolute path to git repository root, either for cwd, or directory (or files' dirname) given as $1\n# when not a git repository, exit >0\nset -e\nif [ -n \"$1\" ]\nthen\n\tif [ -d \"$1\" ]\n\tthen\n\t\tcd \"$1\"\n\telse\n\t\tcd \"$(dirname \"$1\")\"\n\tfi\nfi\nexec git rev-parse --show-toplevel\n"
        },
        {
          "name": "git-save",
          "type": "blob",
          "size": 0.2939453125,
          "content": "#!/usr/bin/env bash\n\n# To be used with the git-save-* scripts @ https://github.com/jwiegley/git-scripts\nmypath=$(dirname $0)\nname=\"$1\"\nshift\nif [ -x $mypath/git-save-$name ] ; then\n  exec git save-\"$name\" \"$@\"\nelse\n  echo \"usage: git save <command>\"\n  git save- 2>&1 |grep -vE \"'save-'|save$\" 1>&2\nfi\n"
        },
        {
          "name": "git-save-file",
          "type": "blob",
          "size": 0.1337890625,
          "content": "#!/bin/sh\n\nif [ $# != 2 ]; then\n  echo \"save-file FILE MSG\" >&2\n  exit 1\nfi\n\nFILE=\"$1\"\nMSG=\"$2\"\n\ngit add -f \"$FILE\"\ngit commit -m \"$MSG\"\n"
        },
        {
          "name": "git-save-home",
          "type": "blob",
          "size": 0.7587890625,
          "content": "#!/bin/sh\n\n# If you keep your home directory version-controlled, you likely don't\n# want to version every single file.  Things like editor\n# configuration, notes files, and html are likely candidates, while\n# music, video, and random downloads are not.  In order to accommodate\n# this scenario, you can ignore everything like so:\n#\n#   $ more ~/.gitignore\n#   *\n#\n# Then, force git-add to track files you care about.  Unfortunately\n# with git-add you have to add a -f every time the file is modified.\n# I don't understand why since git is already tracking the contents.\n\nMODIFIED=$(git status | grep modified | cut -d \" \" -f 3-)\n\nif [ -n \"$MODIFIED\" ]; then\n  echo no changes\nelse\n  git add -f $MODIFIED \\\n    && git commit -q -m \"Save home.\" \\\n    && git diff --stat head^\nfi\n"
        },
        {
          "name": "git-signed-tag",
          "type": "blob",
          "size": 0.044921875,
          "content": "#!/usr/bin/env bash\n\ngit tag -s -m \"$1\" $1 $2\n"
        },
        {
          "name": "git-smerge",
          "type": "blob",
          "size": 1.083984375,
          "content": "#!/usr/bin/env bash\n\ncurrent=$(git symbolic-ref HEAD | sed 's%refs/heads/%%')\nbranch=$1\n\nif ! git merge \"$branch\"; then\n    echo \"GIT-SMERGE: Simple merge with $branch failed, attempting rebase-merge\"\n\n    git reset --hard HEAD\n    git checkout -b temp.$$\n\n    if git rebase \"$branch\" > /dev/null 2>&1; then\n        echo \"GIT-SMERGE: Rebase with $branch succeeded, using tree to create merge commit\"\n\n        if ! git checkout \"$current\"; then\n            echo GIT-SMERGE: Some strange problem occurred!\n            git branch -D temp.$$\n            exit 1\n        fi\n\n        git merge \"$branch\" > /dev/null 2>&1 # this is sure to fail\n        git clean -fd\n        git archive --format=tar temp.$$ | tar xf -\n        git branch -D temp.$$\n        git add .\n        git add -A\n        git ls-files --deleted -z | xargs -0 git rm\n        git commit\n    else\n        echo \"GIT-SMERGE: Rebase with $branch failed, returning to failed merge\"\n\n        git rebase --abort\n        git checkout -f \"$current\"\n        git branch -D temp.$$\n        git merge \"$branch\" > /dev/null 2>&1 # this is sure to fail\n    fi\nfi\n"
        },
        {
          "name": "git-snapshot",
          "type": "blob",
          "size": 0.0517578125,
          "content": "#!/bin/sh\n(git stash && git stash apply) > /dev/null\n"
        },
        {
          "name": "git-stale-branches",
          "type": "blob",
          "size": 0.3291015625,
          "content": "#!/usr/bin/env bash\n\nif ! git config --get-all remote.origin.fetch | grep -q '/pr/'; then\n    git config --add remote.origin.fetch '+refs/pull/*:refs/remotes/origin/pr/*'\nfi\n\ngit fetch --all\n\nfor r in $(git branch -r --format='%(refname)'); do\n    git branch --merged \"$r\";\ndone | sort -u | grep -v '^\\*' | xargs -r echo # git branch -D\n"
        },
        {
          "name": "git-standup",
          "type": "blob",
          "size": 2.1220703125,
          "content": "#!/usr/bin/env bash\n\nif [[ $# -gt 2 ]] ; then\n  >&2 printf '%s\\n%s' \"Usage: $0 [fullname] [weekstart-weekend]\" \"Example: $0 \\\"John Doe\\\" MON-FRI\"\n  exit 1\nfi\n\n# Use colors, but only if connected to a terminal, and that terminal\n# supports them.\nif which tput >/dev/null 2>&1; then\n  ncolors=$(tput colors)\nfi\nif [[ -t 1 ]] && [[ -n \"$ncolors\" ]] && [[ \"$ncolors\" -ge 8 ]] ; then\n  RED=\"$(tput setaf 1)\"\n  GREEN=\"$(tput setaf 2)\"\n  YELLOW=\"$(tput setaf 3)\"\n  BLUE=\"$(tput setaf 4)\"\n  BOLD=\"$(tput bold)\"\n  NORMAL=\"$(tput sgr0)\"\n  BOLD=$(tput bold)\n  UNDERLINE=$(tput smul)\n  NORMAL=$(tput sgr0)\nelse\n  RED=\"\"\n  GREEN=\"\"\n  YELLOW=\"\"\n  BLUE=\"\"\n  BOLD=\"\"\n  NORMAL=\"\"\n  BOLD=\"\"\n  UNDERLINE=\"\"\n  NORMAL=\"\"\nfi\n\n# Only enable exit-on-error after the non-critical colorization stuff,\n# which may fail on systems lacking tput or terminfo\nset -e\n\nAUTHOR=${1:-\"$(git config user.name)\"}\n\nWEEKSTART=\"$( cut -d '-' -f 1 <<< \"$2\" )\";\nWEEKSTART=${WEEKSTART:=\"Mon\"}\n\nWEEKEND=\"$( cut -d '-' -f 2 <<< \"$2\" )\";\nWEEKEND=${WEEKEND:=\"Fri\"}\n\nSINCE=\"yesterday\"\n\n\n## In case it is the start of week, we need to\n## show the commits since the last weekend\nshopt -s nocasematch\nif [[ $WEEKSTART == \"$(date +%a)\" ]] ; then\n  SINCE=\"last $WEEKEND\";\nfi\n\nGIT_LOG_COMMAND=\"git --no-pager log \\\n    --all\n    --no-merges\n    --since \\\"$SINCE\\\"\n    --author=\\\"$AUTHOR\\\"\n    --abbrev-commit\n    --oneline\n    --pretty=format:'%Cred%h%Creset - %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'\"\n\n## For when the command has been run in a non-repo directory\nif [[ ! -d \".git\" ]]; then\n\n    ## Iterate through all the top level directories inside\n    ## and look for any git repositories.\n    for DIR in */ ; do\n\n        cd \"$DIR\"\n\n        ## Show the detail only if it is a git repository\n        if [[ -d \".git\" ]] ; then\n            GITOUT=$(eval ${GIT_LOG_COMMAND})\n\n            ## Only output if there is some activity\n            if [[ ! -z \"$GITOUT\" ]] ;  then\n                echo \"${BOLD}${UNDERLINE}${YELLOW}$DIR${NORMAL}\"\n                echo \"$GITOUT\"\n            fi\n        fi\n\n        cd ..\n    done\nelse\n    eval ${GIT_LOG_COMMAND}\n    echo \"\" ## To avoid that ugly # icon representing the end of line\nfi\n"
        },
        {
          "name": "git-status-all",
          "type": "blob",
          "size": 0.150390625,
          "content": "#!/bin/sh\n\nfind . -name .git -type d |\n    while read -r path; do\n        (\n            cd \"$path/..\" && dirname \"$path\" && git status\n        )\n    done\n"
        },
        {
          "name": "git-svn-diff",
          "type": "blob",
          "size": 2.3291015625,
          "content": "#!/bin/sh\n#\n# git-svn-diff -- SVN-compatible diff against the tip of the tracking branch\n#\n# ChangeLog\n#\n#\tOriginally by http://mojodna.net/2009/02/24/my-work-git-workflow.html\n#\n#\t<mike@mikepearce.net>\n#\t- <unknown changes>\n#\n#\taconway@[redacted]\n#\t- handle diffs that introduce new files\n#\n#\t<jari.aalto@cante.net>\n#\t- Use readable POSIX $() instead backticsk\n#\t- Add ChangeLog\n#\t- Convert from bash to plain /bin/sh\n#\t- Fit as much as possible in 80 columns\n#\t- Make sed \\/ quoting more readable using alternative separators\n#\t- Remove EOL whitespaces.\n#       - 2011-12-27 Incorporate fixes by https://github.com/nfloyd\n#         from the Gist comment 2011-07-31 https://gist.github.com/946727\n#\n#\t<javabrett>\n#\t- Retain space after leading --- and +++, add TAB before (revision 0)\n#\t- Use \\t instead of spaces before (revision $REV) and (working copy)\n#\n#\t<javabrett>\n#\t- Added support for non-empty git-svn prefix, important now that the\n#\t- default --prefix is \"origin/\" in Git 2.0+.\n\n# Get the tracking branch (if we're on a branch)\n\nTRACKING_BRANCH=$(git svn info | grep URL | sed -e 's,.*/branches/,,')\n\n# If the tracking branch has 'URL' at the beginning, then the sed\n# wasn't successful and we'll fall back to the svn-remote config\n# option\n\ncase \"$TRACKING_BRANCH\" in\n    URL*)\n        TRACKING_BRANCH=$(git config --get svn-remote.svn.fetch |\n                          sed -e 's,.*:refs/remotes/,,')\n        ;;\n    *)\n        # GIT_SVN_PREFIX will be origin/ by-default in Git 2.0 or later, or \"\"\n        GIT_SVN_PREFIX=$(git config --get svn-remote.svn.branches | sed -e 's,.*:refs/remotes/\\(.*\\)\\*$,\\1,')\n        TRACKING_BRANCH=${GIT_SVN_PREFIX}${TRACKING_BRANCH}\n        ;;\nesac\n\n# Get the highest revision number\n\nREV=$(git svn info |\n      grep 'Last Changed Rev:' |\n      sed --regexp-extended 's/^.*: ([[:digit:]]*)/\\1/')\n\n# Then do the diff from the highest revision on the current branch and\n# masssage into SVN format\n\ngit diff \\\n    --no-prefix $(git rev-list --date-order --max-count=1 $TRACKING_BRANCH) \\\n    \"$@\" |\nsed -e \"/--- \\/dev\\/null/{ N; s|^--- /dev/null\\n+++ \\(.*\\)|--- \\1\\t(revision 0)\\n+++ \\1\\t(revision 0)|;}\" \\\n    -e \"s/^--- .*/&\\t(revision $REV)/\" \\\n    -e \"s/^+++ .*/&\\t(working copy)/\" \\\n    -e \"s/^diff --git [^[:space:]]*/Index:/\" \\\n    -e \"s/^index.*/===================================================================/\"\n\n# End of file\n"
        },
        {
          "name": "git-sync",
          "type": "blob",
          "size": 0.9951171875,
          "content": "#!/usr/bin/env bash\n\nDIRS=\"$*\"\nif [[ -z \"$DIRS\" ]]; then\n    DIRS=\".\"\nfi\n\nfind \"$DIRS\" \\( -name .git -o -name '*.git' \\) -type d | \\\n    while read -r repo_dir\n    do\n\tif [[ -f \"$repo_dir\"/config ]]\n\tthen\n\t    # If this is a git-svn repo, use git svn fetch\n\t    if grep -q '^\\[svn-remote ' \"$repo_dir\"/config\n\t    then\n\t\techo \"git svn fetch: $repo_dir\"\n\t\tGIT_DIR=\"$repo_dir\" git svn fetch\n\n\t    # If this is a gc-utils repo, use gc-utils update\n\t    elif grep -q '^\\[gc-utils\\]' \"$repo_dir\"/config\n\t    then\n\t\techo \"gc-utils update: $repo_dir\"\n\t\t(cd \"$repo_dir\" && gc-utils update)\n\n\t    else\n\t\tfor remote in $(GIT_DIR=\"$repo_dir\" git remote)\n\t\tdo\n\t\t    if [[ $remote != mirror ]]; then\n\t\t\techo \"git fetch: $repo_dir -- $remote\"\n\t\t\tGIT_DIR=\"$repo_dir\" git fetch \"$remote\"\n\t\t    fi\n\t\tdone\n\t    fi\n\n\t    for remote in $(GIT_DIR=\"$repo_dir\" git remote)\n\t    do\n\t\tif [[ $remote == mirror ]]; then\n\t\t    echo \"git push: $repo_dir -- $remote\"\n\t\t    GIT_DIR=\"$repo_dir\" git push --mirror \"$remote\"\n\t\tfi\n\t    done\n\tfi\n    done\n"
        },
        {
          "name": "git-tag-diff",
          "type": "blob",
          "size": 0.2587890625,
          "content": "#!/usr/bin/env bash\n# Show the differences between local tags and ones on the remote, if any\n# (defaults to origin, but another remote may be specified on the commandline)\n\ndiff -u <(git show-ref --tags --dereference) \\\n    <(git ls-remote --tags $1 | tr '\\t' ' ')\n"
        },
        {
          "name": "git-tarball",
          "type": "blob",
          "size": 0.4560546875,
          "content": "#!/bin/sh\n\nCOMPRESSION=\"gz\"\n\nif [ $# -ne 1 ]; then\n    echo \"usage: git-tarball <tag|commit>\" >&2\n    exit 1\nfi\n\nname=\"$(basename $(readlink -f .))\"\ntag=\"$1\"\n\necho \"Creating archive for '$name' => '$name-$tag.tar.$COMPRESSION'\"\n\nif [ \"$COMPRESSION\" = \"gz\" ]; then\n    git archive --prefix=\"$name-$tag/\" \"$tag\" | gzip --best > $name-$tag.tar.gz\nelif [ \"$COMPRESSION\" = \"bz2\" ]; then\n    git archive --prefix=\"$name-$tag/\" \"$tag\" | bzip2 --best > $name-$tag.tar.bz2\nfi\n"
        },
        {
          "name": "git-touch-repos",
          "type": "blob",
          "size": 0.1259765625,
          "content": "#!/usr/bin/env bash\n\nexport GIT_DIR\n\nfor GIT_DIR in *.git; do \n    d=$(git log --pretty=%ci -1) && touch -d \"$d\" \"$GIT_DIR\"\ndone\n"
        },
        {
          "name": "git-track-branch",
          "type": "blob",
          "size": 0.0888671875,
          "content": "#!/bin/sh\n\nbranch_name=$1\ngit checkout --track -b \"${branch_name}\" \"origin/${branch_name}\"\n"
        },
        {
          "name": "git-trash",
          "type": "blob",
          "size": 0.072265625,
          "content": "#!/bin/sh\n\ngit commit -a -m \"Abandoned changes\" && git reset --hard HEAD^\n"
        },
        {
          "name": "git-trial-merge",
          "type": "blob",
          "size": 0.0712890625,
          "content": "#!/bin/sh\nset -xe\ngit checkout --detach HEAD\ngit merge --no-edit -- \"$@\"\n"
        },
        {
          "name": "git-undo",
          "type": "blob",
          "size": 0.43359375,
          "content": "#!/usr/bin/env bash\n\ncmd=$1\nshift 1\n\ncase $cmd in\n    commit)\n        if [[ -z \"$1\" ]]; then\n            git reset --soft HEAD^\n        else\n            git revert \"$@\"\n        fi\n        ;;\n\n    add|rm)\n        git reset --mixed \"$@\"\n        ;;\n\n    changes)\n        git reset --hard HEAD\n        ;;\n\n    change)\n        git checkout -f -- \"$@\"\n        ;;\n\n    pull|merge|rebase|am)\n        git reset --hard \"HEAD@{0}\"\n        ;;\nesac\n\nexit 0\n"
        },
        {
          "name": "git-unpack",
          "type": "blob",
          "size": 0.443359375,
          "content": "#!/bin/sh\n\nif [ -f .git/objects/pack/*.pack ]; then\n  mkdir /tmp/tmpgit.$$\n  GIT_DIR=/tmp/tmpgit.$$ git init\n\n  for pack in .git/objects/pack/*.pack; do\n    GIT_DIR=/tmp/tmpgit.$$ git unpack-objects < \"$pack\"\n    if [ $? -ne 0 ]; then\n      echo \"Unpack of $pack failed, aborting\"\n      exit 1\n    fi\n  done\n\n  rsync -a --info=PROGRESS2 --delete /tmp/tmpgit.$$/objects/ .git/objects/\n\n  rm -fr /tmp/tmpgit.$$\nelse\n  echo \"No packs to unpack\"\n  exit 1\nfi\n"
        },
        {
          "name": "git-whoami",
          "type": "blob",
          "size": 0.7451171875,
          "content": "#!/bin/sh\n\n# git-whoami\n# Author: Peter Eisentraut <peter@eisentraut.org>\n# Created: 2011-10-27\n# License: WTFPL; see http://sam.zoy.org/wtfpl/\n\n# exact logic in ident.c in git source tree\n\nset -e\n\nget_email() {\n\tgit config user.email || ( [ -n \"$EMAIL\" ] && echo \"$EMAIL\" ) || echo \"$(id -nu)@$(hostname --fqdn)\"\n}\n\nget_name() {\n\tgit config user.name || getent passwd $(id -un) | cut -d : -f 5 | cut -d , -f 1\n}\n\n: ${GIT_AUTHOR_NAME=$(get_name)}\n: ${GIT_COMMITTER_NAME=$(get_name)}\n: ${GIT_AUTHOR_EMAIL=$(get_email)}\n: ${GIT_COMMITTER_EMAIL=$(get_email)}\n\nauthor=\"$GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>\"\ncommit=\"$GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL>\"\n\nif [ \"$author\" = \"$commit\" ]; then\n\techo \"$author\"\nelse\n\techo \"Author: $author\"\n\techo \"Commit: $commit\"\nfi\n"
        },
        {
          "name": "git-working-tree",
          "type": "blob",
          "size": 0.126953125,
          "content": "#!/usr/bin/env bash\n\n# Set contents of the working tree equal to TREEISH\n\n#/bin/rm -fr *\ngit archive --format=tar \"$@\" | tar xf -\n"
        },
        {
          "name": "git-write-stream-info",
          "type": "blob",
          "size": 0.759765625,
          "content": "#!/bin/sh\n\ngit_branch()\n{\n\tgit branch | grep '*' | sed 's/..//'\n}\n\ndate=$(date +%Y-%m-%d--%H-%M)\n\nwhere=$GIT_DIR/streams\n\nif test ! -d $where\nthen\n\tmkdir $where\nfi\n\nif test -z \"$1\"\nthen\n\tfrom=svn/trunk\nelse\n\tfrom=$1\nfi\n\nif test -z \"$2\"\nthen\n\tto=$(git_branch)\nelse\n\tto=$2\nfi\n\nfile_name=$(echo \"$from\" | sed 's/\\//_/g'`--`echo $to | sed 's/\\//_/g')---$date\nfile=$where/$file_name\nlast=$where/last\n\necho \"git log $from^..$to:\" > \"$file\"\ngit log --name-status --decorate --color \"$from^..$to\" >> \"$file\"\necho \"\" >> \"$file\"\necho \"---\" >> \"$file\"\necho \"\" >> \"$file\"\necho \"git stash list:\" >> \"$file\"\ngit stash list | ruby -p -e '$_.sub!(/stash\\@\\{0\\}/){|rev| \"#{rev.chomp}:#{`git rev-parse #{rev}`.chomp}\"}' >> $file\n\nif [ -L \"$last\" ]; then\n\trm \"$last\"\nfi\nln -s \"$file_name\" \"$last\"\n"
        },
        {
          "name": "git-wtf",
          "type": "blob",
          "size": 12.1279296875,
          "content": "#!/usr/bin/env ruby\n\nHELP = <<EOS\ngit-wtf displays the state of your repository in a readable, easy-to-scan\nformat. It's useful for getting a summary of how a branch relates to a remote\nserver, and for wrangling many topic branches.\n\ngit-wtf can show you:\n- How a branch relates to the remote repo, if it's a tracking branch.\n- How a branch relates to integration branches, if it's a feature branch.\n- How a branch relates to the feature branches, if it's an integration\n  branch.\n\ngit-wtf is best used before a git push, or between a git fetch and a git\nmerge. Be sure to set color.ui to auto or yes for maximum viewing pleasure.\nEOS\n\nKEY = <<EOS\nKEY:\n() branch only exists locally\n{} branch only exists on a remote repo\n[] branch exists locally and remotely\n\nx merge occurs both locally and remotely\n~ merge occurs only locally\n  (space) branch isn't merged in\n\n(It's possible for merges to occur remotely and not locally, of course, but\nthat's a less common case and git-wtf currently doesn't display anything\nspecial for it.)\nEOS\n\nUSAGE = <<EOS\nUsage: git wtf [branch+] [options]\n\nIf [branch] is not specified, git-wtf will use the current branch. The possible\n[options] are:\n\n  -l, --long          include author info and date for each commit\n  -a, --all           show all branches across all remote repos, not just\n                      those from origin\n  -A, --all-commits   show all commits, not just the first 5\n  -s, --short         don't show commits\n  -k, --key           show key\n  -r, --relations     show relation to features / integration branches\n      --dump-config   print out current configuration and exit\n\ngit-wtf uses some heuristics to determine which branches are integration\nbranches, and which are feature branches. (Specifically, it assumes the\nintegration branches are named \"master\", \"next\" and \"edge\".) If it guesses\nincorrectly, you will have to create a .git-wtfrc file.\n\nTo start building a configuration file, run \"git-wtf --dump-config >\n.git-wtfrc\" and edit it. The config file is a YAML file that specifies the\nintegration branches, any branches to ignore, and the max number of commits to\ndisplay when --all-commits isn't used.  git-wtf will look for a .git-wtfrc file\nstarting in the current directory, and recursively up to the root.\n\nIMPORTANT NOTE: all local branches referenced in .git-wtfrc must be prefixed\nwith heads/, e.g. \"heads/master\". Remote branches must be of the form\nremotes/<remote>/<branch>.\nEOS\n\nCOPYRIGHT = <<EOS\ngit-wtf Copyright 2008--2009 William Morgan <wmorgan at the masanjin dot nets>.\nThis program is free software: you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation, either version 3 of the License, or (at your option)\nany later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\nmore details.\n\nYou can find the GNU General Public License at: http://www.gnu.org/licenses/\nEOS\n\nrequire 'yaml'\nCONFIG_FN = \".git-wtfrc\"\n\nclass Numeric; def pluralize s; \"#{to_s} #{s}\" + (self != 1 ? \"s\" : \"\") end end\n\nif ARGV.delete(\"--help\") || ARGV.delete(\"-h\")\n  puts USAGE\n  exit\nend\n\n## poor man's trollop\n$long = ARGV.delete(\"--long\") || ARGV.delete(\"-l\")\n$short = ARGV.delete(\"--short\") || ARGV.delete(\"-s\")\n$all = ARGV.delete(\"--all\") || ARGV.delete(\"-a\")\n$all_commits = ARGV.delete(\"--all-commits\") || ARGV.delete(\"-A\")\n$dump_config = ARGV.delete(\"--dump-config\")\n$key = ARGV.delete(\"--key\") || ARGV.delete(\"-k\")\n$show_relations = ARGV.delete(\"--relations\") || ARGV.delete(\"-r\")\nARGV.each { |a| abort \"Error: unknown argument #{a}.\" if a =~ /^--/ }\n\n## search up the path for a file\ndef find_file fn\n  while true\n    return fn if File.exist? fn\n    fn2 = File.join(\"..\", fn)\n    return nil if File.expand_path(fn2) == File.expand_path(fn)\n    fn = fn2\n  end\nend\n\nwant_color = `git config color.wtf`\nwant_color = `git config color.ui` if want_color.empty?\n$color = case want_color.chomp\n  when \"true\"; true\n  when \"auto\"; $stdout.tty?\nend\n\ndef red s; $color ? \"\\033[31m#{s}\\033[0m\" : s end\ndef green s; $color ? \"\\033[32m#{s}\\033[0m\" : s end\ndef yellow s; $color ? \"\\033[33m#{s}\\033[0m\" : s end\ndef cyan s; $color ? \"\\033[36m#{s}\\033[0m\" : s end\ndef grey s; $color ? \"\\033[1;30m#{s}\\033[0m\" : s end\ndef purple s; $color ? \"\\033[35m#{s}\\033[0m\" : s end\n\n## the set of commits in 'to' that aren't in 'from'.\n## if empty, 'to' has been merged into 'from'.\ndef commits_between from, to\n  if $long\n    `git log --pretty=format:\"- %s [#{yellow \"%h\"}] (#{purple \"%ae\"}; %ar)\" #{from}..#{to}`\n  else\n    `git log --pretty=format:\"- %s [#{yellow \"%h\"}]\" #{from}..#{to}`\n  end.split(/[\\r\\n]+/)\nend\n\ndef show_commits commits, prefix=\"    \"\n  if commits.empty?\n    puts \"#{prefix} none\"\n  else\n    max = $all_commits ? commits.size : $config[\"max_commits\"]\n    max -= 1 if max == commits.size - 1 # never show \"and 1 more\"\n    commits[0 ... max].each { |c| puts \"#{prefix}#{c}\" }\n    puts grey(\"#{prefix}... and #{commits.size - max} more (use -A to see all).\") if commits.size > max\n  end\nend\n\ndef ahead_behind_string ahead, behind\n  [ahead.empty? ? nil : \"#{ahead.size.pluralize 'commit'} ahead\",\n   behind.empty? ? nil : \"#{behind.size.pluralize 'commit'} behind\"].\n   compact.join(\"; \")\nend\n\ndef widget merged_in, remote_only=false, local_only=false, local_only_merge=false\n  left, right = case\n    when remote_only; %w({ })\n    when local_only; %w{( )}\n    else %w([ ])\n  end\n  middle = case\n    when merged_in && local_only_merge; green(\"~\")\n    when merged_in; green(\"x\")\n    else \" \"\n  end\n  print left, middle, right\nend\n\ndef show b\n  have_both = b[:local_branch] && b[:remote_branch]\n\n  pushc, pullc, oosync = if have_both\n    [x = commits_between(b[:remote_branch], b[:local_branch]),\n     y = commits_between(b[:local_branch], b[:remote_branch]),\n     !x.empty? && !y.empty?]\n  end\n\n  if b[:local_branch]\n    puts \"Local branch: \" + green(b[:local_branch].sub(/^heads\\//, \"\"))\n\n    if have_both\n      if pushc.empty?\n        puts \"#{widget true} in sync with remote\"\n      else\n        action = oosync ? \"push after rebase / merge\" : \"push\"\n        puts \"#{widget false} NOT in sync with remote (you should #{action})\"\n        show_commits pushc unless $short\n      end\n    end\n  end\n\n  if b[:remote_branch]\n    puts \"Remote branch: #{cyan b[:remote_branch]} (#{b[:remote_url]})\"\n\n    if have_both\n      if pullc.empty?\n        puts \"#{widget true} in sync with local\"\n      else\n        action = pushc.empty? ? \"merge\" : \"rebase / merge\"\n        puts \"#{widget false} NOT in sync with local (you should #{action})\"\n        show_commits pullc unless $short\n      end\n    end\n  end\n\n  puts \"\\n#{red \"WARNING\"}: local and remote branches have diverged. A merge will occur unless you rebase.\" if oosync\nend\n\ndef show_relations b, all_branches\n  ibs, fbs = all_branches.partition { |name, br| $config[\"integration-branches\"].include?(br[:local_branch]) || $config[\"integration-branches\"].include?(br[:remote_branch]) }\n  if $config[\"integration-branches\"].include? b[:local_branch]\n    puts \"\\nFeature branches:\" unless fbs.empty?\n    fbs.each do |name, br|\n      next if $config[\"ignore\"].member?(br[:local_branch]) || $config[\"ignore\"].member?(br[:remote_branch])\n      next if br[:ignore]\n      local_only = br[:remote_branch].nil?\n      remote_only = br[:local_branch].nil?\n      name = if local_only\n        purple br[:name]\n      elsif remote_only\n        cyan br[:name]\n      else\n        green br[:name]\n      end\n\n      ## for remote_only branches, we'll compute wrt the remote branch head. otherwise, we'll\n      ## use the local branch head.\n      head = remote_only ? br[:remote_branch] : br[:local_branch]\n\n      remote_ahead = b[:remote_branch] ? commits_between(b[:remote_branch], head) : []\n      local_ahead = b[:local_branch] ? commits_between(b[:local_branch], head) : []\n\n      if local_ahead.empty? && remote_ahead.empty?\n        puts \"#{widget true, remote_only, local_only} #{name} #{local_only ? \"(local-only) \" : \"\"}is merged in\"\n      elsif local_ahead.empty?\n        puts \"#{widget true, remote_only, local_only, true} #{name} merged in (only locally)\"\n      else\n        behind = commits_between head, (br[:local_branch] || br[:remote_branch])\n        ahead = remote_only ? remote_ahead : local_ahead\n        puts \"#{widget false, remote_only, local_only} #{name} #{local_only ? \"(local-only) \" : \"\"}is NOT merged in (#{ahead_behind_string ahead, behind})\"\n        show_commits ahead unless $short\n      end\n    end\n  else\n    puts \"\\nIntegration branches:\" unless ibs.empty? # unlikely\n    ibs.sort_by { |v, br| v }.each do |v, br|\n      next if $config[\"ignore\"].member?(br[:local_branch]) || $config[\"ignore\"].member?(br[:remote_branch])\n      next if br[:ignore]\n      local_only = br[:remote_branch].nil?\n      remote_only = br[:local_branch].nil?\n      name = remote_only ? cyan(br[:name]) : green(br[:name])\n\n      ahead = commits_between v, (b[:local_branch] || b[:remote_branch])\n      if ahead.empty?\n        puts \"#{widget true, local_only} merged into #{name}\"\n      else\n        #behind = commits_between b[:local_branch], v\n        puts \"#{widget false, local_only} NOT merged into #{name} (#{ahead.size.pluralize 'commit'} ahead)\"\n        show_commits ahead unless $short\n      end\n    end\n  end\nend\n\n#### EXECUTION STARTS HERE ####\n\n## find config file and load it\n$config = { \"integration-branches\" => %w(heads/master heads/next heads/edge), \"ignore\" => [], \"max_commits\" => 5 }.merge begin\n  fn = find_file CONFIG_FN\n  if fn && (h = YAML::load_file(fn)) # yaml turns empty files into false\n    h[\"integration-branches\"] ||= h[\"versions\"] # support old nomenclature\n    h\n  else\n    {}\n  end\nend\n\nif $dump_config\n  puts $config.to_yaml\n  exit\nend\n\n## first, index registered remotes\nremotes = `git config --get-regexp ^remote\\.\\*\\.url`.split(/[\\r\\n]+/).inject({}) do |hash, l|\n  l =~ /^remote\\.(.+?)\\.url (.+)$/ or next hash\n  hash[$1] ||= $2\n  hash\nend\n\n## next, index followed branches\nbranches = `git config --get-regexp ^branch\\.`.split(/[\\r\\n]+/).inject({}) do |hash, l|\n  case l\n  when /branch\\.(.*?)\\.remote (.+)/\n    name, remote = $1, $2\n\n    hash[name] ||= {}\n    hash[name].merge! :remote => remote, :remote_url => remotes[remote]\n  when /branch\\.(.*?)\\.merge ((refs\\/)?heads\\/)?(.+)/\n    name, remote_branch = $1, $4\n    hash[name] ||= {}\n    hash[name].merge! :remote_mergepoint => remote_branch\n  end\n  hash\nend\n\n## finally, index all branches\nremote_branches = {}\n`git show-ref`.split(/[\\r\\n]+/).each do |l|\n  sha1, ref = l.chomp.split \" refs/\"\n\n  if ref =~ /^heads\\/(.+)$/ # local branch\n    name = $1\n    next if name == \"HEAD\"\n    branches[name] ||= {}\n    branches[name].merge! :name => name, :local_branch => ref\n  elsif ref =~ /^remotes\\/(.+?)\\/(.+)$/ # remote branch\n    remote, name = $1, $2\n    remote_branches[\"#{remote}/#{name}\"] = true\n    next if name == \"HEAD\"\n    ignore = !($all || remote == \"origin\")\n\n    branch = name\n    if branches[name] && branches[name][:remote] == remote\n      # nothing\n    else\n      name = \"#{remote}/#{branch}\"\n    end\n\n    branches[name] ||= {}\n    branches[name].merge! :name => name, :remote => remote, :remote_branch => \"#{remote}/#{branch}\", :remote_url => remotes[remote], :ignore => ignore\n  end\nend\n\n## assemble remotes\nbranches.each do |k, b|\n  next unless b[:remote] && b[:remote_mergepoint]\n  b[:remote_branch] = if b[:remote] == \".\"\n    b[:remote_mergepoint]\n  else\n    t = \"#{b[:remote]}/#{b[:remote_mergepoint]}\"\n    remote_branches[t] && t # only if it's still alive\n  end\nend\n\nshow_dirty = ARGV.empty?\ntargets = if ARGV.empty?\n  [`git symbolic-ref HEAD`.chomp.sub(/^refs\\/heads\\//, \"\")]\nelse\n  ARGV.map { |x| x.sub(/^heads\\//, \"\") }\nend.map { |t| branches[t] or abort \"Error: can't find branch #{t.inspect}.\" }\n\ntargets.each do |t|\n  show t\n  show_relations t, branches if $show_relations || t[:remote_branch].nil?\nend\n\nmodified = show_dirty && `git ls-files -m` != \"\"\nuncommitted = show_dirty &&  `git diff-index --cached HEAD` != \"\"\n\nif $key\n  puts\n  puts KEY\nend\n\nputs if modified || uncommitted\nputs \"#{red \"NOTE\"}: working directory contains modified files.\" if modified\nputs \"#{red \"NOTE\"}: staging area contains staged but uncommitted files.\" if uncommitted\n\n# the end!\n"
        },
        {
          "name": "pre-commit.sh",
          "type": "blob",
          "size": 1.83984375,
          "content": "#!/bin/sh\n\nif [ ! $(git rev-parse --symbolic-full-name HEAD) = refs/heads/master ]; then\n    exit 0\nfi\n\n# These are the locations I keep my temporary source and build trees in\nTMPDIR=$HOME/Products/ledger-pre-commit\nMIRROR=$HOME/Products/ledger-pre-commit-mirror\n\n# Exit with status 1 if any command below fails\nset -e\n\n# Checkout a copy of the current index into MIRROR\ngit checkout-index --prefix=\"$MIRROR/\" -af\n\n# Remove files from MIRROR which are no longer present in the index\ngit diff-index --cached --name-only --diff-filter=D -z HEAD | \\\n    (cd \"$MIRROR\" && xargs -0 rm -f --)\n\n# Copy only _changed files_ from MIRROR to TMPDIR, without copying timestamps.\n# This includes copying over new files, and deleting removed ones.  This way,\n# \"make check\" will only rebuild what is necessary to validate the commit.\nrsync -rlpgoDOc --delete --exclude-from=tools/excludes \"$MIRROR/\" \"$TMPDIR/\"\n\n# Everything else happens in the temporary build tree\nif [ ! -f \"$TMPDIR/lib/utfcpp/source/utf8.h\" ]; then\n    rsync -a --delete lib/utfcpp/ \"$TMPDIR/lib/utfcpp/\"\nfi\ncd \"$TMPDIR\"\n\n# Make sure there is a current Makefile.  Regeneration of Makefile happens\n# automatically, but if myacprep or acprep changes, we want to regenerate\n# everything manually.  If the user doesn't have acprep or myacprep, look for\n# other common autoconf-related script files.\nif [ ! -f Makefile -o \\\n     Makefile.am -nt Makefile -o \\\n     configure.ac -nt Makefile -o \\\n     \\( -f acprep -a acprep -nt Makefile \\) -o \\\n     \\( -f tools/myacprep -a tools/myacprep -nt Makefile \\) ]\nthen\n    if [ -f tools/myacprep ]; then\n\ttools/myacprep --local\n    elif [ -f acprep ]; then\n\t./acprep --local\n    elif [ -f autogen.sh ]; then\n\tsh autogen.sh && ./configure\n    else\n\tautoreconf && ./configure\n    fi\nfi\n\n# Finally, (re)build this proposed source tree and see if it passes muster.\nnice -n 20 make check\n\nexit 0\n"
        },
        {
          "name": "rebase-onto.txt",
          "type": "blob",
          "size": 1.7568359375,
          "content": "Master branch, with two interdependent development branches:\n\n  o--o--o--o master\n            \\\n             \\\n              o--o--o--o foo\n                        \\\n                         \\\n                          o--o--o--o bar\n\nLet's say master gets a few commits:\n\n  o--o--o--o--o--o--o master\n            \\\n             \\\n              o--o--o--o foo\n                        \\\n                         \\\n                          o--o--o--o bar\n\nAnd now we go to foo and use \"git rebase master\":\n\n                       o--o--o--o foo\n                      /\n                     /\n  o--o--o--o--o--o--o master\n            \\\n             \\\n              o--o--o--o (fec1d4)\n                        \\\n                         \\\n                          o--o--o--o bar\n\nfoo, as its known by name, is no longer part of the history of bar.  Instead,\nbar begins with four commits that *used to be known as foo*, but now have no\nname.  I've given the old foo a commit id, just for the purpose of this\ndescription.\n\nQuestion is: how do I get bar onto the new foo, so everything looks like the\nfirst picture?  Answer: rebase --onto:\n\n  git rebase --onto foo fec1d4 bar\n\nNow I have:\n\n                                   o--o--o--o bar\n                                  /\n                                 /\n                       o--o--o--o foo\n                      /\n                     /\n  o--o--o--o--o--o--o master\n            \\\n             \\\n              o--o--o--o (fec1d4)\n                        \\\n                         \\\n                          o--o--o--o (a661bd) DANGLING\n\nNote that (fec1d4) didn't itself get rebased, but everything after it until\nbar did, onto foo.\n\nYou can also manage this sort of situation mostly automatically using topgit\n(http://repo.or.cz/w/topgit.git).\n"
        }
      ]
    }
  ]
}