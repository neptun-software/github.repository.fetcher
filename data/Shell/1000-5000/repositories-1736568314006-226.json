{
  "metadata": {
    "timestamp": 1736568314006,
    "page": 226,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wowu/docker-rollout",
      "stars": 2544,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1435546875,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0302734375,
          "content": "Copyright (c) 2023 Karol Musur\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.185546875,
          "content": "<h1 align=\"center\">\n<code>docker rollout</code><br>\nZero Downtime Deployment for Docker Compose\n</h1>\n\nDocker CLI plugin that updates Docker Compose services without downtime.\n\nSimply replace `docker compose up -d <service>` with `docker rollout <service>` in your deployment scripts. This command will scale the service to twice the current number of instances, wait for the new containers to be ready, and then remove the old containers.\n\n- [Features](#features)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [‚ö†Ô∏è Caveats](#Ô∏è-caveats)\n  - [Sample deployment script](#sample-deployment-script)\n- [Why?](#why)\n- [License](#license)\n\n## Features\n\n- ‚è≥ Zero downtime deployment for Docker Compose services\n- üê≥ Works with Docker Compose and `docker-compose`\n- ‚ù§Ô∏è Supports Docker healthchecks out of the box\n\n## Installation\n\n```bash\n# Create directory for Docker cli plugins\nmkdir -p ~/.docker/cli-plugins\n\n# Download docker-rollout script to Docker cli plugins directory\ncurl https://raw.githubusercontent.com/wowu/docker-rollout/master/docker-rollout -o ~/.docker/cli-plugins/docker-rollout\n\n# Make the script executable\nchmod +x ~/.docker/cli-plugins/docker-rollout\n```\n\n## Usage\n\nRun `docker rollout <name>` instead of `docker compose up -d <name>` to update a service without downtime. If you have both `docker compose` plugin and `docker-compose` command available, docker-rollout will use `docker compose` by default.\n\n```bash\n$ docker rollout -f docker-compose.yml <service-name>\n```\n\nOptions:\n\n- `-f | --file FILE` - (not required) - Path to compose file, can be specified multiple times, as in `docker compose`.\n- `-t | --timeout SECONDS` - (not required) - Timeout in seconds to wait for new container to become healthy, if the container has healthcheck defined in `Dockerfile` or `docker-compose.yml`. Default: 60\n- `-w | --wait SECONDS` - (not required) - Time to wait for new container to be ready if healthcheck is not defined. Default: 10\n- `--wait-after-healthy SECONDS` - (not required) - Time to wait after new container is healthy before removing old container. Works when healthcheck is defined. Default: 0\n- `--env-file FILE` - (not required) - Path to env file, can be specified multiple times, as in `docker compose`.\n\nSee [examples](docs/examples) for sample `docker-compose.yml` files.\n\n### ‚ö†Ô∏è Caveats\n\n- Your service cannot have `container_name` and `ports` defined in `docker-compose.yml`, as it's not possible to run multiple containers with the same name or port mapping. Use a proxy as described below.\n- Proxy like [Traefik](https://github.com/traefik/traefik) or [nginx-proxy](https://github.com/nginx-proxy/nginx-proxy) is required to route traffic.\n- Each deployment will increment the index in container name (e.g. `project-web-1` -> `project-web-2`).\n\n### Sample deployment script\n\nSample deployment script for `web` service:\n\n```bash\n# Download latest code\ngit pull\n# Build new app image\ndocker compose build web\n# Run database migrations\ndocker compose run web rake db:migrate\n# Deploy new version\ndocker rollout web\n```\n\n## Why?\n\nUsing `docker compose up` to deploy a new version of a service causes downtime because the app container is stopped before the new container is created.\nIf your application takes a while to boot, this may be noticeable to users.\n\nUsing container orchestration tools like [Kubernetes](https://kubernetes.io/) or [Nomad](https://www.nomadproject.io/) is usually an overkill for projects that will do fine with a single-server Docker Compose setup. [Dokku](https://github.com/dokku/dokku) comes with zero-downtime deployment and more useful features, but it's not as flexible as Docker Compose.\n\nIf you have a proxy like [Traefik](https://github.com/traefik/traefik) or [nginx-proxy](https://github.com/nginx-proxy/nginx-proxy), a zero downtime deployment can be achieved by writing a script that scales the service to 2 instances, waits for the new container to be ready, and then removes the old container.\n`docker rollout` does exactly that, but with a single command that you can use in your deployment scripts.\nIf you're using Docker healthchecks, Traefik will make sure that traffic is only routed to the new container when it's ready.\n\n## License\n\n[MIT License](LICENSE) &copy; Karol Musur\n"
        },
        {
          "name": "docker-rollout",
          "type": "blob",
          "size": 5.7763671875,
          "content": "#!/bin/sh\nset -e\n\n# Defaults\nHEALTHCHECK_TIMEOUT=60\nNO_HEALTHCHECK_TIMEOUT=10\nWAIT_AFTER_HEALTHY_DELAY=0\n\n# Print metadata for Docker CLI plugin\nif [ \"$1\" = \"docker-cli-plugin-metadata\" ]; then\n  cat <<EOF\n{\n  \"SchemaVersion\": \"0.1.0\",\n  \"Vendor\": \"Karol Musur\",\n  \"Version\": \"v0.9\",\n  \"ShortDescription\": \"Rollout new Compose service version\"\n}\nEOF\n  exit\nfi\n\n# Save docker arguments, i.e. arguments before \"rollout\"\nwhile [ $# -gt 0 ]; do\n  if [ \"$1\" = \"rollout\" ]; then\n    shift\n    break\n  fi\n\n  DOCKER_ARGS=\"$DOCKER_ARGS $1\"\n  shift\ndone\n\n# Check if compose v2 is available\nif docker compose >/dev/null 2>&1; then\n  # shellcheck disable=SC2086 # DOCKER_ARGS must be unquoted to allow multiple arguments\n  COMPOSE_COMMAND=\"docker $DOCKER_ARGS compose\"\nelif docker-compose >/dev/null 2>&1; then\n  COMPOSE_COMMAND=\"docker-compose\"\nelse\n  echo \"docker compose or docker-compose is required\"\n  exit 1\nfi\n\nusage() {\n  cat <<EOF\n\nUsage: docker rollout [OPTIONS] SERVICE\n\nRollout new Compose service version.\n\nOptions:\n  -h, --help                  Print usage\n  -f, --file FILE             Compose configuration files\n  -t, --timeout N             Healthcheck timeout (default: $HEALTHCHECK_TIMEOUT seconds)\n  -w, --wait N                When no healthcheck is defined, wait for N seconds\n                              before stopping old container (default: $NO_HEALTHCHECK_TIMEOUT seconds)\n      --wait-after-healthy N  When healthcheck is defined and succeeds, wait for additional N seconds\n                              before stopping the old container (default: 0 seconds)\n      --env-file FILE         Specify an alternate environment file\n\nEOF\n}\n\nexit_with_usage() {\n  usage\n  exit 1\n}\n\nhealthcheck() {\n  # shellcheck disable=SC2086 # DOCKER_ARGS must be unquoted to allow multiple arguments\n  docker $DOCKER_ARGS inspect --format='{{json .State.Health.Status}}' \"$1\" | grep -v \"unhealthy\" | grep -q \"healthy\"\n}\n\nscale() {\n  # shellcheck disable=SC2086 # COMPOSE_FILES and ENV_FILES must be unquoted to allow multiple files\n  $COMPOSE_COMMAND $COMPOSE_FILES $ENV_FILES up --detach --scale \"$1=$2\" --no-recreate \"$1\"\n}\n\nmain() {\n  # shellcheck disable=SC2086 # COMPOSE_FILES and ENV_FILES must be unquoted to allow multiple files\n  if [ -z \"$($COMPOSE_COMMAND $COMPOSE_FILES $ENV_FILES ps --quiet \"$SERVICE\")\" ]; then\n    echo \"==> Service '$SERVICE' is not running. Starting the service.\"\n    $COMPOSE_COMMAND $COMPOSE_FILES $ENV_FILES up --detach --no-recreate \"$SERVICE\"\n    exit 0\n  fi\n\n  # shellcheck disable=SC2086 # COMPOSE_FILES and ENV_FILES must be unquoted to allow multiple files\n  OLD_CONTAINER_IDS_STRING=$($COMPOSE_COMMAND $COMPOSE_FILES $ENV_FILES ps --quiet \"$SERVICE\" | tr '\\n' '|' | sed 's/|$//')\n  OLD_CONTAINER_IDS=$(echo \"$OLD_CONTAINER_IDS_STRING\" | tr '|' ' ')\n  SCALE=$(echo \"$OLD_CONTAINER_IDS\" | wc -w | tr -d ' ')\n  SCALE_TIMES_TWO=$((SCALE * 2))\n  echo \"==> Scaling '$SERVICE' to '$SCALE_TIMES_TWO' instances\"\n  scale \"$SERVICE\" $SCALE_TIMES_TWO\n\n  # Create a variable that contains the IDs of the new containers, but not the old ones\n  # shellcheck disable=SC2086 # COMPOSE_FILES and ENV_FILES must be unquoted to allow multiple files\n  NEW_CONTAINER_IDS=$($COMPOSE_COMMAND $COMPOSE_FILES $ENV_FILES ps --quiet \"$SERVICE\" | grep -Ev \"$OLD_CONTAINER_IDS_STRING\" | tr '\\n' ' ')\n\n  # Check if first container has healthcheck\n  # shellcheck disable=SC2086 # DOCKER_ARGS must be unquoted to allow multiple arguments\n  if docker $DOCKER_ARGS inspect --format='{{json .State.Health}}' \"$(echo $OLD_CONTAINER_IDS | cut -d\\  -f 1)\" | grep -q \"Status\"; then\n    echo \"==> Waiting for new containers to be healthy (timeout: $HEALTHCHECK_TIMEOUT seconds)\"\n    for _ in $(seq 1 \"$HEALTHCHECK_TIMEOUT\"); do\n      SUCCESS=0\n\n      for NEW_CONTAINER_ID in $NEW_CONTAINER_IDS; do\n        if healthcheck \"$NEW_CONTAINER_ID\"; then\n          SUCCESS=$((SUCCESS + 1))\n        fi\n      done\n\n      if [ \"$SUCCESS\" = \"$SCALE\" ]; then\n        break\n      fi\n\n      sleep 1\n    done\n\n    SUCCESS=0\n\n    for NEW_CONTAINER_ID in $NEW_CONTAINER_IDS; do\n      if healthcheck \"$NEW_CONTAINER_ID\"; then\n        SUCCESS=$((SUCCESS + 1))\n      fi\n    done\n\n    if [ \"$SUCCESS\" != \"$SCALE\" ]; then\n      echo \"==> New containers are not healthy. Rolling back.\" >&2\n\n      docker $DOCKER_ARGS stop $NEW_CONTAINER_IDS\n      docker $DOCKER_ARGS rm $NEW_CONTAINER_IDS\n\n      exit 1\n    fi\n    \n    if [ \"$WAIT_AFTER_HEALTHY_DELAY\" != \"0\" ]; then\n      echo \"==> Waiting for healthy containers to settle down ($WAIT_AFTER_HEALTHY_DELAY seconds)\"\n      sleep $WAIT_AFTER_HEALTHY_DELAY\n    fi\n  else\n    echo \"==> Waiting for new containers to be ready ($NO_HEALTHCHECK_TIMEOUT seconds)\"\n    sleep \"$NO_HEALTHCHECK_TIMEOUT\"\n  fi\n\n  echo \"==> Stopping and removing old containers\"\n\n  # shellcheck disable=SC2086 # DOCKER_ARGS and OLD_CONTAINER_IDS must be unquoted to allow multiple arguments\n  docker $DOCKER_ARGS stop $OLD_CONTAINER_IDS\n  # shellcheck disable=SC2086 # DOCKER_ARGS and OLD_CONTAINER_IDS must be unquoted to allow multiple arguments\n  docker $DOCKER_ARGS rm $OLD_CONTAINER_IDS\n}\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n  -h | --help)\n    usage\n    exit 0\n    ;;\n  -f | --file)\n    COMPOSE_FILES=\"$COMPOSE_FILES -f $2\"\n    shift 2\n    ;;\n  --env-file)\n    ENV_FILES=\"$ENV_FILES --env-file $2\"\n    shift 2\n    ;;\n  -t | --timeout)\n    HEALTHCHECK_TIMEOUT=\"$2\"\n    shift 2\n    ;;\n  -w | --wait)\n    NO_HEALTHCHECK_TIMEOUT=\"$2\"\n    shift 2\n    ;;\n  --wait-after-healthy)\n    WAIT_AFTER_HEALTHY_DELAY=\"$2\"\n    shift 2\n    ;;\n  -*)\n    echo \"Unknown option: $1\"\n    exit_with_usage\n    ;;\n  *)\n    if [ -n \"$SERVICE\" ]; then\n      echo \"SERVICE is already set to '$SERVICE'\"\n\n      if [ \"$SERVICE\" != \"$1\" ]; then\n        exit_with_usage\n      fi\n    fi\n\n    SERVICE=\"$1\"\n    shift\n    ;;\n  esac\ndone\n\n# Require SERVICE argument\nif [ -z \"$SERVICE\" ]; then\n  echo \"SERVICE is missing\"\n  exit_with_usage\nfi\n\nmain\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}