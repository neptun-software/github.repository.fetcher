{
  "metadata": {
    "timestamp": 1736568308303,
    "page": 214,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "michaeldfallen/git-radar",
      "stars": 2591,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "*.swp\n*.swo\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0322265625,
          "content": "Copyright (c) 2015 Michael Allen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.005859375,
          "content": "SOURCES=git-radar radar-base.sh prompt.zsh prompt.bash fetch.sh\nPREFIX=$(HOME)/.local\n\nall:\n\t@echo 'Simple Install script for *git-radar* '\n\t@echo 'For a normal installation for your user only use:'\n\t@echo '    make install'\n\t@echo ''\n\t@echo 'If you want to install *git-radar* system wide you should change'\n\t@echo 'the prefix'\n\t@echo ''\n\t@echo '    PREFIX=/usr/local/bin make install'\n\t@echo ''\n\t@echo 'For a development install (symlinking files) do:'\n\t@echo ''\n\t@echo '\tmake develop'\n\n.PHONY: install develop\n\ninstall: $(SOURCES)\n\t@echo 'Installing in ' $(PREFIX)/bin\n\tcp git-radar $(PREFIX)/bin\n\tcp radar-base.sh $(PREFIX)/bin\n\tcp prompt.zsh $(PREFIX)/bin\n\tcp prompt.bash $(PREFIX)/bin\n\tcp fetch.sh $(PREFIX)/bin\n\n\ndevelop: $(SOURCES)\n\t@echo 'Symlinking in ' $(PREFIX)/bin\n\tln -s $(PWD)/git-radar $(PREFIX)/bin/git-radar\n\tln -s $(PWD)/radar-base.sh $(PREFIX)/bin/radar-base.sh\n\tln -s $(PWD)/prompt.zsh $(PREFIX)/bin/prompt.zsh\n\tln -s $(PWD)/prompt.bash $(PREFIX)/bin/prompt.bash\n\tln -s $(PWD)/fetch.sh $(PREFIX)/bin/fetch.sh\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.1669921875,
          "content": "# Git Radar\n\nA heads up display for git.\n\n![An example of git-radar]\n\nGit-radar is a tool you can add to your prompt to provide at-a-glance\ninformation on your git repo. It's a labour of love I've been dogfooding for the\nlast few years. Maybe it can help you too.\n\n**Table of Contents**\n\n- [Installation](#installation)\n- [Usage](#usage)\n- [Features](#features)\n  - [Files status](#files-status)\n  - [Local commits status](#local-commits-status)\n  - [Remote commits status](#remote-commits-status)\n  - [Stash status](#stash-status)\n  - [(Optional) Auto-fetch repos](#optional-auto-fetch-repos)\n- [Customise your prompt](#customise-your-prompt)\n- [Support](#support)\n  - [Ensuring prompt execution](#ensuring-prompt-execution)\n  - [Configuring colours](#configuring-colours)\n    - [Exporting Environment Variables](#exporting-environment-variables)\n    - [Setting an RC file](#setting-an-rc-file)\n    - [Bash Colour Codes](#bash-colour-codes)\n    - [Zsh Colour Codes](#zsh-colour-codes)\n    - [Configuration values](#configuration-values)\n      - [Colouring the Branch part](#colouring-the-branch-part)\n      - [Colouring the local commits status](#colouring-the-local-commits-status)\n      - [Colouring the remote commits status](#colouring-the-remote-commits-status)\n      - [Colouring the file changes status](#colouring-the-file-changes-status)\n- [License](#license)\n- [Links](#links)\n\n## Installation\n\n### Install from brew:\n\n```\n> brew install michaeldfallen/formula/git-radar\n```\n\n### Manually:\n\n```\n> cd ~ && git clone https://github.com/michaeldfallen/git-radar .git-radar\n> echo 'export PATH=$PATH:$HOME/.git-radar' >> ~/.bashrc\n```\n\nThen run `git-radar` to see the docs and prove it's installed.\n\n## Usage\n\nTo use git-radar you need to add it to your prompt. This is done in different\nways depending on your shell.\n\n**Bash**\n\nAdd to your `.bashrc`\n```bash\nexport PS1=\"$PS1\\$(git-radar --bash --fetch)\"\n```\n[(note: the `\\` escaping the `$` is important)](#ensuring-prompt-execution)\n\n**Zsh**\n\nAdd to your `.zshrc`\n```zsh\nexport PROMPT=\"$PROMPT\\$(git-radar --zsh --fetch) \"\n```\n[(note: the `\\` escaping the `$` is important)](#ensuring-prompt-execution)\n\n**Fish**\n\nAdd to your `config.fish`\n```bash\nfunction fish_prompt\n    set_color $fish_color_cwd\n    echo -n (prompt_pwd)\n    echo -n (git-radar --fish --fetch)\n    set_color normal\n    echo -n ' > '\nend\n```\n\n## Features\n\n### Files status\n\nThe prompt lists the file changes and whether they are staged, unstaged or\nuntracked.\n\nPrompt                     | Meaning\n---------------------------|--------\n![git:(master) 3A]         | We have 3 untracked files\n![git:(master) 2D2M]       | We have 2 modifications and 2 deletions not yet staged to commit\n![git:(master) 1M1R]       | We have 1 modification and a file renamed staged and ready to commit\n![git:(master) 1U]         | We have a conflict caused by US that we need to address\n![git:(master) 1M 1D2M 2A] | A combination of the above types\n\nEach symbol represents a different change to a file. These are based on what git\nconsiders has happened to the file.\n\nSymbol  | Meaning\n--------|--------\nA       | A new Added file\nD       | A file has been Deleted\nM       | A file has been Modified\nR       | A file has been renamed\nC       | A file has been copied\nU       | A conflict caused by Us\nT       | A conflict caused by Them\nB       | A conflict caused by Both us and them\n\nThe color tells you what stage the change is at.\n\nColor   | Meaning\n--------|--------\nGreen   | Staged and ready to be committed (i.e. you have done a `git add`)\nRed     | Unstaged, you'll need to `git add` them before you can commit\nGrey    | Untracked, these are new files git is unaware of\nYellow  | Conflicted, these need resolved before they can be committed\n\nThe use of feature is controlled by the `GIT_RADAR_FORMAT` environment variable.\nSee [Customise your prompt](#customise-your-prompt) for how to personalise this.\n\n### Local commits status\n\nThe prompt will show you the difference in commits between your branch and the\nremote your branch is tracking. The examples below assume you are checked out on\n`master` and are tracking `origin/master`.\n\nPrompt              | Meaning\n--------------------|--------\n![git:(master 2↑)]  | We have 2 commits to push up\n![git:(master 3↓)]  | We have 3 commits to pull down\n![git:(master 3⇵5)] | Our version and origins version of `master` have diverged\n\nThe use of feature is controlled by the `GIT_RADAR_FORMAT` environment variable.\nSee [Customise your prompt](#customise-your-prompt) for how to personalise this.\n\n### Remote commits status\n\nThe prompt will also show the difference between your branch on origin and what\nis on `origin/master`. This a is hard coded branch name which I intend to make\nconfigurable in the future.\n\nThis is the difference between the commits you've pushed up and `origin/master`.\n\nPrompt                     | Meaning\n---------------------------|---------------\n![git:(m ← 2 my-branch)]   | We have 2 commits on `origin/my-branch` that aren't on `origin/master`\n![git:(m 4 → my-branch)]   | There are 4 commits on `origin/master` that aren't on `origin/my-branch`\n![git:(m 1 ⇄ 2 my-branch)] | `origin/master` and `origin/my-branch` have diverged, we'll need to rebase or merge\n\nThe use of feature is controlled by the `GIT_RADAR_FORMAT` environment variable.\nSee [Customise your prompt](#customise-your-prompt) for how to personalise this.\n\n### Stash status\nThe prompt will show you whether and how many stashes you have stored.\n\nPrompt                     | Meaning\n---------------------------|---------------\n![git:(master) 1≡]         | We have one stash\n\nIf you don't rely on this status, you can always hide this part of the prompt by\n[customising your prompt](#customise-your-prompt)\n\n### (Optional) Auto-fetch repos\n\nEnsuring your refs are up to date I found can be a pain. To streamline this\ngit-radar can be configured to auto-fetch your repo. When the `--fetch` flag is\nused git-radar will run `git fetch` asynchronously every 5 minutes.\n\nThis will only occur when the prompt is rendered and it will only occur on the\nrepo you are currently in.\n\nTo use this feature, when setting your prompt, call git-radar with `--fetch`:\n\n**Bash**\n```bash\nexport PS1=\"$PS1\\$(git-radar --bash --fetch)\"\n```\n[(note: the `\\` escaping the `$` is important)](#ensuring-prompt-execution)\n\n**Zsh**\n```zsh\nexport PROMPT=\"$PROMPT\\$(git-radar --zsh --fetch) \"\n```\n[(note: the `\\` escaping the `$` is important)](#ensuring-prompt-execution)\n\nYou may also choose to fetch at a customized interval of time. To do so, add\nthis to your .bashrc, .zshrc:\n\n```bash\nexport GIT_RADAR_FETCH_TIME=<seconds>\n```\n\nFor example, to fetch every 30 seconds (instead of the default 5 minutes):\n\n```bash\nexport GIT_RADAR_FETCH_TIME=30\n```\n\nYou can also do this in the gitradarrc file:\n\n```bash\nGIT_RADAR_FETCH_TIME=30\n```\n\n## Customise your prompt\n\nGit Radar is highly customisable using a prompt format string. The 4 features\nabove: remote commits, local commits, branch and file changes; are controlled\nby the prompt format string.\n\nFeature        | Control string\n---------------|---------------\nRemote commits | `%{remote}`\nLocal commits  | `%{local}`\nBranch         | `%{branch}`\nFile changes   | `%{changes}`\nStashes        | `%{stash}`\n\nYou can create any prompt shape you prefer by exporting `GIT_RADAR_FORMAT` with\nyour preferred shape. The control strings above will be replaced with the output\nof the corresponding feature.\n\n**Examples**\n\nGIT_RADAR_FORMAT                      | Result\n--------------------------------------|---------------------\n`%{branch}%{local}%{changes}`         | `master1↑1M`\n`[%{branch}] - %{local} - %{changes}` | `[master] - 1↑ - 1M`\n\n### Prefixing and Suffixing the features\n\nOften you will want certain parts of the prompt to only appear when there is\ncontent to render. For example, when in a repo you want `[branch]` but when out\nof a repo you don't want the `[]` appearing.\n\nTo do this the control strings support prefixes and suffixes. Prefixes and\nSuffixes are separated from the feature name by `:` and will only render if the\nfeature would render:\n\nFormat: `prompt > %{prefix - :changes: - suffix}`\n\nIn a repo: `prompt > prefix - 1M - suffix`\n\nOutside a repo: `prompt > `\n\nThe default prompt format uses this to add spaces only if the feature would\nrender. In that way the prompt always looks well spaced out no matter how many\nfeatures are rendering.\n\n\n## Support\n\n### Ensuring prompt execution\n\nWhen setting your prompt variable, `PROMPT` in Zsh and `PS1` in Bash, it's\nimportant that the function executes each time the prompt renders. That way the\nprompt will respond to changes in your git repo. To ensure this you will need\nto escape the execution of the function. There are two ways to do this:\n\n**1. Use `$'` to render raw characters**\n```bash\nexport PROMPT=$'$(git-radar --zsh)'\nexport PS1=$'$(git-radar --bash)'\n```\n\n**2. Use `\\` to escape execution of the subshell**\n```bash\nexport PROMPT=\"\\$(git-radar --zsh)\"\nexport PS1=\"\\$(git-radar --bash)\"\n```\n\n### Configuring colours\n\nYou can configure the colour scheme in two ways: export\n[Environment Variables](#exporting-environment-variables)\nor use an [rc file](#setting-an-rc-file).\n\n#### Exporting Environment Variables\n\nTo configure the prompt this way just add to your `~/.bashrc` or `~/.zshrc` an\nexport directive with the value you want to change.\n\n**Example: Change the branch colour in Zsh**\n\nIn `~/.zshrc`:\n```zsh\nexport GIT_RADAR_COLOR_BRANCH='$fg[yellow]'\n```\n\n**Example: Change the branch colour in Bash**\n\nIn `~/.bashrc`:\n```zsh\nexport GIT_RADAR_COLOR_BRANCH='\\\\033[0;33m'\n```\n\n#### Setting an RC file\n\nGit radar supports multiple rc files. One of these will be sourced when the\nprompt renders.\n\n**Example: Change the branch colour in Zsh**\n\nIn `~/.gitradarrc`:\n```zsh\nGIT_RADAR_COLOR_BRANCH='$fg[yellow]'\n```\n\n**Basic RC file**\n\nCreate a file at `~/.gitradarrc` which sets the Environment variables listed in\n[Configuration values](#configuration-values) using colour codes listed in\neither [Zsh Colour Codes](#zsh-colour-codes) or\n[Bash Colour Codes](#Bash-Colour-Codes) depending on your shell.\n\n**Shell specific RC file**\n\nIf you use both Bash and Zsh you can set RC files that are specific for those\nshells.\n\nFor Bash: Create a file at `~/.gitradarrc.bash`\n\nFor Zsh: Create a file at `~/.gitradarrc.zsh`\n\n\n#### Bash Colour Codes\n\nBash colour codes make use of the colours your terminal app claims to be `red`\nor `green`. Using one of these codes will only produce the colour your terminal\nclaims, so you should customise your colour scheme on your terminal as well as\ncustomising git-radar.\n\nNote the \"Bright\" colours can be shown as bold instead, it depends on your\nterminal. By default, for example, the Mac OSX Terminal.app uses the \"Bright\"\ncolours to provide 8 new lighter colours but some terminals only support 8 and\nwill show the text as bold instead.\n\nColour        | Code for Text  | Code for Background\n--------------|----------------|--------------------\nBlack         | `\\\\033[0;30m`  | `\\\\033[0;40m`\nRed           | `\\\\033[0;31m`  | `\\\\033[0;41m`\nGreen         | `\\\\033[0;32m`  | `\\\\033[0;42m`\nYellow        | `\\\\033[0;33m`  | `\\\\033[0;43m`\nBlue          | `\\\\033[0;34m`  | `\\\\033[0;44m`\nMagenta       | `\\\\033[0;35m`  | `\\\\033[0;45m`\nCyan          | `\\\\033[0;36m`  | `\\\\033[0;46m`\nWhite         | `\\\\033[0;37m`  | `\\\\033[0;47m`\nBright Black  | `\\\\033[1;30m`  | `\\\\033[1;40m`\nBright Red    | `\\\\033[1;31m`  | `\\\\033[1;41m`\nBright Green  | `\\\\033[1;32m`  | `\\\\033[1;42m`\nBright Yellow | `\\\\033[1;33m`  | `\\\\033[1;43m`\nBright Blue   | `\\\\033[1;34m`  | `\\\\033[1;44m`\nBright Magenta| `\\\\033[1;35m`  | `\\\\033[1;45m`\nBright Cyan   | `\\\\033[1;36m`  | `\\\\033[1;46m`\nBright White  | `\\\\033[1;37m`  | `\\\\033[1;47m`\nReset         | `\\\\033[0m`     | `\\\\033[0m`\n\nNote the Reset will set back to what your terminal claims as standard text and\nbackground.\n\n#### Zsh Colour Codes\n\nZsh also provides a way to access the colours that your terminal claims as `red`\nor `green`, etc.\n\nNote the \"Bright\" colours can be shown as bold instead, it depends on your\nterminal. By default, for example, the Mac OSX Terminal.app uses the \"Bright\"\ncolours to provide 8 new lighter colours but some terminals only support 8 and\nwill show the text as bold instead.\n\nColour        | Code for Text      | Code for Background\n--------------|--------------------|--------------------\nBlack         | `$fg[black]`       | `$bg[black]`\nRed           | `$fg[red]`         | `$bg[red]`\nGreen         | `$fg[green]`       | `$bg[green]`\nYellow        | `$fg[yellow]`      | `$bg[yellow]`\nBlue          | `$fg[blue]`        | `$bg[blue]`\nMagenta       | `$fg[magenta]`     | `$bg[magenta]`\nCyan          | `$fg[cyan]`        | `$bg[cyan]`\nWhite         | `$fg[white]`       | `$bg[white]`\nBright Black  | `$fg_bold[black]`  | `$bg_bold[black]`\nBright Red    | `$fg_bold[red]`    | `$bg_bold[red]`\nBright Green  | `$fg_bold[green]`  | `$bg_bold[green]`\nBright Yellow | `$fg_bold[yellow]` | `$bg_bold[yellow]`\nBright Blue   | `$fg_bold[blue]`   | `$bg_bold[blue]`\nBright Magenta| `$fg_bold[magenta]`| `$bg_bold[magenta]`\nBright Cyan   | `$fg_bold[cyan]`   | `$bg_bold[cyan]`\nBright White  | `$fg_bold[white]`  | `$bg_bold[white]`\nReset         | `$reset_color`     | `$reset_color`\n\n#### Configuration values\n\nAll these values should be set using a the correct colour code for your\nterminal. You should also choose the colour code based on what shell you are\nusing. There is a way to support [colouring multiple shells using rc files](#setting-an-rc-file).\n\n##### Colouring the Branch part\n\n**GIT_RADAR_COLOR_BRANCH='[colour code]'**\n```\ngit:(my-branch)\n     ^^^^^^^^^\n```\nThe colour to use for the Branch or git reference.\n\nIt is unset by\n`GIT_RADAR_COLOR_BRANCH_RESET` which you can set if you want a different\nbackground colour to return to.\n\n##### Colouring the local commits status\n\n**GIT_RADAR_COLOR_LOCAL_AHEAD='[colour code]'**\n```\ngit:(my-branch 1↑)\n                ^\n```\nThe colour to use for the arrow that indicates how many commits you have to push\nup.\n\nIt is unset by `GIT_RADAR_COLOR_LOCAL_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_LOCAL_BEHIND='[colour code]'**\n```\ngit:(my-branch 1↓)\n                ^\n```\nThe colour to use for the arrow that indicates how many commits you have to pull\ndown.\n\nIt is unset by `GIT_RADAR_COLOR_LOCAL_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_LOCAL_DIVERGED='[colour code]'**\n```\ngit:(my-branch 1⇵1)\n                ^\n```\nThe colour to use for the arrow that indicates how many commits your branch has diverged by.\n\nIt is unset by `GIT_RADAR_COLOR_LOCAL_RESET` which you can set if you want\na different background colour to return to.\n\n##### Colouring the remote commits status\n\n**GIT_RADAR_COLOR_REMOTE_AHEAD='[colour code]'**\n```\ngit:(m ← 1 my-branch)\n       ^\n```\nThe colour to use for the arrow that indicates how many commits your branch has to merge on to master.\n\nIt is unset by `GIT_RADAR_COLOR_REMOTE_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_REMOTE_BEHIND='[colour code]'**\n```\ngit:(m 1 → my-branch)\n         ^\n```\nThe colour to use for the arrow that indicates how many commits your branch is\nbehind master.\n\nIt is unset by `GIT_RADAR_COLOR_REMOTE_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_REMOTE_DIVERGED='[colour code]'**\n```\ngit:(m 1 ⇄ 1 my-branch)\n         ^\n```\nThe colour to use for the arrow that indicates how many commits your branch has\ndiverged from master.\n\nIt is unset by `GIT_RADAR_COLOR_REMOTE_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_REMOTE_NOT_UPSTREAM='[colour code]'**\n```\ngit:(upstream ⚡ my-branch)\n              ^\n```\nThe colour to use for the lightning bolt which indicates that your branch is not\ntracking an upstream branch.\n\nIt is unset by `GIT_RADAR_COLOR_REMOTE_RESET` which you can set if you want\na different background colour to return to.\n\n##### Colouring the file changes status\n\n**GIT_RADAR_COLOR_CHANGES_STAGED='[colour code]'**\n```\ngit:(my-branch) 1M\n                 ^\n```\nThe colour to use for the letters that indicate changes that have been staged to\ncommit.\n\nIt is unset by `GIT_RADAR_COLOR_CHANGES_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_CHANGES_UNSTAGED='[colour code]'**\n```\ngit:(my-branch) 1M\n                 ^\n```\nThe colour to use for the letters that indicate changes that have not yet been\nstaged to commit.\n\nIt is unset by `GIT_RADAR_COLOR_CHANGES_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_CHANGES_CONFLICTED='[colour code]'**\n```\ngit:(my-branch) 1B\n                 ^\n```\nThe colour to use for the letters that indicate changes that have conflicts that\nneed resolved.\n\nIt is unset by `GIT_RADAR_COLOR_CHANGES_RESET` which you can set if you want\na different background colour to return to.\n\n**GIT_RADAR_COLOR_CHANGES_UNTRACKED='[colour code]'**\n```\ngit:(my-branch) 1A\n                 ^\n```\nThe colour to use for the letters that indicate files that are currently not\ntracked by git.\n\nIt is unset by `GIT_RADAR_COLOR_CHANGES_RESET` which you can set if you want\na different background colour to return to.\n\n##### Colouring the stash status\n\n**GIT_RADAR_COLOR_STASH='[colour code]'**\n```\ngit:(my-branch) 1≡\n                 ^\n```\nThe colour to use for the lines that indicates how many stashes you have stored.\n\nIt is unset by `GIT_RADAR_COLOR_STASH_RESET` which you can set if you want\na different background colour to return to.\n\n## License\n\nGit Radar is licensed under the MIT license.\n\nSee [LICENSE] for the full license text.\n\n## Links\n\n* [mini-git-radar](https://github.com/bogem/mini-git-radar) - lightweight version of git-radar. Only for macOS and bash/fish.\n\n[LICENSE]: https://github.com/michaeldfallen/git-radar/blob/master/LICENSE\n[git:(master) 1≡]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/stash.png\n[git:(master) 3A]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/untracked.png\n[git:(master) 2D2M]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/unstaged.png\n[git:(master) 1M1R]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/added.png\n[git:(master) 1U]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/conflicts.png\n[git:(master) 1M 1D2M 2A]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/combination.png\n[git:(master 2↑)]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/local%20is%20ahead.png\n[git:(master 3↓)]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/remote%20is%20behind.png\n[git:(master 3⇵5)]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/remote%20local%20diverged.png\n[git:(m ← 2 my-branch)]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/branch%20is%20ahead.png\n[git:(m 4 → my-branch)]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/master%20is%20ahead.png\n[git:(m 1 ⇄ 2 my-branch)]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/master%20branch%20diverged.png\n[An example of git-radar]: https://raw.githubusercontent.com/michaeldfallen/git-radar/master/images/detailed.png\n"
        },
        {
          "name": "fetch.sh",
          "type": "blob",
          "size": 0.2353515625,
          "content": "#! /usr/bin/env bash\n\nif [[ \"$OSTYPE\" == *darwin* ]]; then\n  READLINK_CMD='greadlink'\nelse\n  READLINK_CMD='readlink'\nfi\n\ndot=\"$(cd \"$(dirname \"$([ -L \"$0\" ] && $READLINK_CMD -f \"$0\" || echo \"$0\")\")\"; pwd)\"\n\nsource $dot/radar-base.sh\n\nfetch;\n"
        },
        {
          "name": "git-radar",
          "type": "blob",
          "size": 3.8623046875,
          "content": "#! /usr/bin/env bash\n#\n# git-radar\n#\n# A heads up display for git\n\nif [[ \"$OSTYPE\" == *darwin* ]]; then\n  READLINK_CMD='greadlink'\nelse\n  READLINK_CMD='readlink'\nfi\n\ndot=\"$(cd \"$(dirname \"$([ -L \"$0\" ] && $READLINK_CMD -f \"$0\" || echo \"$0\")\")\"; pwd)\"\nargs=$@\n\nif [[ -z $@ ]]; then\n  _git=\"\\033[1;30mgit:(\\033[0m\"\n  _master=\"\\033[0;37mmaster\\033[0m\"\n  _my_branch=\"\\033[0;37mmy-branch\\033[0m\"\n  _endgit=\"\\033[1;30m)\\033[0m\"\n  _untracked=\"\\033[1;37mA\\033[0m\"\n  _added_staged=\"\\033[1;32mA\\033[0m\"\n  _modified_unstaged=\"\\033[1;31mM\\033[0m\"\n  _local_up=\"\\033[1;32m↑\\033[0m\"\n  _2_from_master=\"\\xF0\\x9D\\x98\\xAE 2 \\033[1;31m→\\033[0m \"\n  _diverged_from_master=\"\\xF0\\x9D\\x98\\xAE 2 \\033[1;33m⇄\\033[0m 3 \"\n  _not_upstream=\"upstream \\033[1;31m⚡\\033[0m \"\n  _detached=\"\\033[0;37mdetached@94eac67\\033[0m\"\n  _conflicted_us=\"\\033[1;33mU\\033[0m\"\n  _conflicted_them=\"\\033[1;33mT\\033[0m\"\n  _ahead_master=\"\\xF0\\x9D\\x98\\xAE \\033[1;32m←\\033[0m\"\n  _local_diverged=\"\\033[1;33m⇵\\033[0m\"\n  _stash=\"\\033[1;33m≡\\033[0m\"\n  echo \"git-radar - a heads up display for git\"\n  echo \"\"\n  echo \"examples:\"\n  printf \"  $_git$_master$_endgit\"\n  echo \"                  # You are on the master branch and everything is clean\"\n  printf \"  $_git$_not_upstream$_my_branch$_endgit\"\n  echo \"    # Fresh branch that we haven't pushed upstream\"\n  printf \"  $_git$_my_branch$_endgit 2$_untracked\"\n  echo \"            # Two files created that aren't tracked by git\"\n  printf \"  $_git$_my_branch$_endgit 1$_added_staged 3$_modified_unstaged\"\n  echo \"         # 1 new file staged to commit and 3 modifications that we still need to \\`git add\\`\"\n  printf \"  $_git$_2_from_master$_my_branch 3$_local_up$_endgit\"\n  echo \"      # 3 commits made locally ready to push up while master is ahead of us by 2\"\n  printf \"  $_git$_diverged_from_master$_my_branch$_endgit\"\n  echo \"       # our commits pushed up, master and my-branch have diverged\"\n  printf \"  $_git$_detached$_endgit 2${_conflicted_them}3${_conflicted_us}\"\n  echo \"   # mid rebase, we are detached and have 3 conflicts caused by US and 2 caused by THEM\"\n  printf \"  $_git$_diverged_from_master$_my_branch 3${_local_diverged}5$_endgit\"\n  echo \"   # rebase complete, our rewritten commits now need pushed up\"\n  printf \"  $_git$_ahead_master 3 $_my_branch$_endgit\"\n  echo \"         # origin/my-branch is up to date with master and has our 3 commits waiting merge\"\n  printf \"  $_git$_master$_endgit 3$_stash\"\n  echo \"               # You have 3 stashes stored\"\n\n  echo \"\"\n  echo \"usage:\"\n  echo \"  git-radar [--zsh|--bash|--fish] [--fetch]\"\n  echo \"\"\n  echo \"  --fetch  # Fetches your repo asynchronously in the background every 5 mins\"\n  echo \"  --zsh    # Output prompt using Zsh style color characters\"\n  echo \"  --bash   # Output prompt using Bash style color characters\"\n  echo \"  --fish   # Output prompt using fish style color characters\"\n  echo \"\"\n  echo \"Bash example:\"\n  echo \"  export PS1=\\\"\\\\W\\\\\\$(git-radar --bash --fetch) \\\"\"\n  echo \"\"\n  echo \"  This will show your current directory and the full git-radar.\"\n  echo \"  As an added benefit, if you are in a repo, it will asynchronously\"\n  echo \"  run \\`git fetch\\` every 5 mins, so that you are never out of date.\"\n  echo \"\"\n  echo \"Zsh example:\"\n  echo \"  export PROMPT=\\\"%1/%\\\\\\$(git-radar --zsh --fetch) \\\"\"\n  echo \"\"\n  echo \"  Same as the Bash but for Zsh.\"\n  echo \"\"\n  echo \"fish example:\"\n  echo \"  function fish_prompt\"\n  echo \"    set_color \\$fish_color_cwd\"\n  echo \"    echo -n (prompt_pwd)\"\n  echo \"    git-radar --fish -fetch\"\n  echo \"    set_color normal\"\n  echo \"    echo -n ' > '\"\n  echo \"  end\"\n  echo \"\"\n  echo \"  Same as the Bash but for fish.\"\n  exit\nfi\nwhile [[ $# > 0 ]];do\n  command=\"$1\"\n  shift\n\n  if [[ \"$command\" == \"--fetch\" ]]; then\n    nohup $dot/fetch.sh >/dev/null 2>&1 &\n  fi\n\n  if [[ \"$command\" == \"--zsh\" ]]; then\n    $dot/prompt.zsh $args\n  fi\n\n  if [[ \"$command\" == \"--bash\" || \"$command\" == \"--fish\" ]]; then\n    $dot/prompt.bash $args\n  fi\ndone\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "prompt.bash",
          "type": "blob",
          "size": 0.1484375,
          "content": "#! /usr/bin/env bash\n\ndot=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\nargs=$@\nsource \"$dot/radar-base.sh\"\n\nif is_repo; then\n  prepare_bash_colors\n  render_prompt\nfi\n"
        },
        {
          "name": "prompt.zsh",
          "type": "blob",
          "size": 0.1748046875,
          "content": "#! /usr/bin/env zsh\n\ndot=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\nargs=$@\nsource \"$dot/radar-base.sh\"\n\nif is_repo; then\n  autoload colors && colors\n\n  prepare_zsh_colors\n  render_prompt\nfi\n"
        },
        {
          "name": "radar-base.sh",
          "type": "blob",
          "size": 17.978515625,
          "content": "NO_REMOTE_STATUS='--no-remote-status'\n\ndot_git=\"\"\nstat_type=\"\"\ncwd=\"\"\nremote=\"\"\nrcfile_path=\"$HOME\"\n\ntimethis() {\n  cmd=\"$@\"\n  start=$(gdate +%s.%N)\n  eval $cmd\n  dur=$(echo \"$(gdate +%s.%N) - $start\" | bc)\n  echo \"$1 - $dur\" >> $HOME/duration.dat\n}\n\nget_fetch_time() {\n  if [ -f \"$rcfile_path/.gitradarrc.bash\" ]; then\n    source \"$rcfile_path/.gitradarrc.bash\"\n  elif [ -f \"$rcfile_path/.gitradarrc.zsh\" ]; then\n    source \"$rcfile_path/.gitradarrc.zsh\"\n  elif [ -f \"$rcfile_path/.gitradarrc\" ]; then\n    source \"$rcfile_path/.gitradarrc\"\n  fi\n\n  FETCH_TIME=\"${GIT_RADAR_FETCH_TIME:-\"$((5 * 60))\"}\"\n  echo $FETCH_TIME\n\n}\n\nprepare_bash_colors() {\n  if [ -f \"$rcfile_path/.gitradarrc.bash\" ]; then\n    source \"$rcfile_path/.gitradarrc.bash\"\n  elif [ -f \"$rcfile_path/.gitradarrc\" ]; then\n    source \"$rcfile_path/.gitradarrc\"\n  fi\n\n  PRINT_F_OPTION=\"\"\n\n  COLOR_REMOTE_AHEAD=\"\\x01${GIT_RADAR_COLOR_REMOTE_AHEAD:-\"\\\\033[1;32m\"}\\x02\"\n  COLOR_REMOTE_BEHIND=\"\\x01${GIT_RADAR_COLOR_REMOTE_BEHIND:-\"\\\\033[1;31m\"}\\x02\"\n  COLOR_REMOTE_DIVERGED=\"\\x01${GIT_RADAR_COLOR_REMOTE_DIVERGED:-\"\\\\033[1;33m\"}\\x02\"\n  COLOR_REMOTE_NOT_UPSTREAM=\"\\x01${GIT_RADAR_COLOR_REMOTE_NOT_UPSTREAM:-\"\\\\033[1;31m\"}\\x02\"\n\n  COLOR_LOCAL_AHEAD=\"\\x01${GIT_RADAR_COLOR_LOCAL_AHEAD:-\"\\\\033[1;32m\"}\\x02\"\n  COLOR_LOCAL_BEHIND=\"\\x01${GIT_RADAR_COLOR_LOCAL_BEHIND:-\"\\\\033[1;31m\"}\\x02\"\n  COLOR_LOCAL_DIVERGED=\"\\x01${GIT_RADAR_COLOR_LOCAL_DIVERGED:-\"\\\\033[1;33m\"}\\x02\"\n\n  COLOR_CHANGES_STAGED=\"\\x01${GIT_RADAR_COLOR_CHANGES_STAGED:-\"\\\\033[1;32m\"}\\x02\"\n  COLOR_CHANGES_UNSTAGED=\"\\x01${GIT_RADAR_COLOR_CHANGES_UNSTAGED:-\"\\\\033[1;31m\"}\\x02\"\n  COLOR_CHANGES_CONFLICTED=\"\\x01${GIT_RADAR_COLOR_CHANGES_CONFLICTED:-\"\\\\033[1;33m\"}\\x02\"\n  COLOR_CHANGES_UNTRACKED=\"\\x01${GIT_RADAR_COLOR_CHANGES_UNTRACKED:-\"\\\\033[1;37m\"}\\x02\"\n\n  COLOR_STASH=\"\\x01${GIT_RADAR_COLOR_STASH:-\"\\\\033[1;33m\"}\\x02\"\n\n  COLOR_BRANCH=\"\\x01${GIT_RADAR_COLOR_BRANCH:-\"\\\\033[0m\"}\\x02\"\n  MASTER_SYMBOL=\"${GIT_RADAR_MASTER_SYMBOL:-\"\\\\x01\\\\033[0m\\\\x02\\\\xF0\\\\x9D\\\\x98\\\\xAE\\\\x01\\\\033[0m\\\\x02\"}\"\n\n  PROMPT_FORMAT=\"${GIT_RADAR_FORMAT:-\" \\\\x01\\\\033[1;30m\\\\x02git:(\\\\x01\\\\033[0m\\\\x02%{remote: }%{branch}%{ :local}\\\\x01\\\\033[1;30m\\\\x02)\\\\x01\\\\033[0m\\\\x02%{ :stash}%{ :changes}\"}\"\n\n  RESET_COLOR_LOCAL=\"\\x01${GIT_RADAR_COLOR_LOCAL_RESET:-\"\\\\033[0m\"}\\x02\"\n  RESET_COLOR_REMOTE=\"\\x01${GIT_RADAR_COLOR_REMOTE_RESET:-\"\\\\033[0m\"}\\x02\"\n  RESET_COLOR_CHANGES=\"\\x01${GIT_RADAR_COLOR_CHANGES_RESET:-\"\\\\033[0m\"}\\x02\"\n  RESET_COLOR_BRANCH=\"\\x01${GIT_RADAR_COLOR_BRANCH_RESET:-\"\\\\033[0m\"}\\x02\"\n  RESET_COLOR_STASH=\"\\x01${GIT_RADAR_COLOR_STASH:-\"\\\\033[0m\"}\\x02\"\n\n}\n\nprepare_zsh_colors() {\n  if [ -f \"$rcfile_path/.gitradarrc.zsh\" ]; then\n    source \"$rcfile_path/.gitradarrc.zsh\"\n  elif [ -f \"$rcfile_path/.gitradarrc\" ]; then\n    source \"$rcfile_path/.gitradarrc\"\n  fi\n\n  PRINT_F_OPTION=\"%s\"\n\n  COLOR_REMOTE_AHEAD=\"%{${GIT_RADAR_COLOR_REMOTE_AHEAD:-$fg_bold[green]}%}\"\n  COLOR_REMOTE_BEHIND=\"%{${GIT_RADAR_COLOR_REMOTE_BEHIND:-$fg_bold[red]}%}\"\n  COLOR_REMOTE_DIVERGED=\"%{${GIT_RADAR_COLOR_REMOTE_DIVERGED:-$fg_bold[yellow]}%}\"\n  COLOR_REMOTE_NOT_UPSTREAM=\"%{${GIT_RADAR_COLOR_REMOTE_NOT_UPSTREAM:-$fg_bold[red]}%}\"\n\n  COLOR_LOCAL_AHEAD=\"%{${GIT_RADAR_COLOR_LOCAL_AHEAD:-$fg_bold[green]}%}\"\n  COLOR_LOCAL_BEHIND=\"%{${GIT_RADAR_COLOR_LOCAL_BEHIND:-$fg_bold[red]}%}\"\n  COLOR_LOCAL_DIVERGED=\"%{${GIT_RADAR_COLOR_LOCAL_DIVERGED:-$fg_bold[yellow]}%}\"\n\n  COLOR_CHANGES_STAGED=\"%{${GIT_RADAR_COLOR_CHANGES_STAGED:-$fg_bold[green]}%}\"\n  COLOR_CHANGES_UNSTAGED=\"%{${GIT_RADAR_COLOR_CHANGES_UNSTAGED:-$fg_bold[red]}%}\"\n  COLOR_CHANGES_CONFLICTED=\"%{${GIT_RADAR_COLOR_CHANGES_CONFLICTED:-$fg_bold[yellow]}%}\"\n  COLOR_CHANGES_UNTRACKED=\"%{${GIT_RADAR_COLOR_CHANGES_UNTRACKED:-$fg_bold[white]}%}\"\n\n  COLOR_STASH=\"%{${GIT_RADAR_COLOR_STASH:-$fg_bold[yellow]}%}\"\n\n  local italic_m=\"$(printf '\\xF0\\x9D\\x98\\xAE')\"\n\n  COLOR_BRANCH=\"%{${GIT_RADAR_COLOR_BRANCH:-$reset_color}%}\"\n  MASTER_SYMBOL=\"${GIT_RADAR_MASTER_SYMBOL:-\"%{$reset_color%}$italic_m%{$reset_color%}\"}\"\n\n  PROMPT_FORMAT=\"${GIT_RADAR_FORMAT:-\" %{$fg_bold[grey]%}git:(%{$reset_color%}%{remote: }%{branch}%{ :local}%{$fg_bold[grey]%})%{$reset_color%}%{ :stash}%{ :changes}\"}\"\n\n  RESET_COLOR_LOCAL=\"%{${GIT_RADAR_COLOR_LOCAL_RESET:-$reset_color}%}\"\n  RESET_COLOR_REMOTE=\"%{${GIT_RADAR_COLOR_REMOTE_RESET:-$reset_color}%}\"\n  RESET_COLOR_CHANGES=\"%{${GIT_RADAR_COLOR_CHANGES_RESET:-$reset_color}%}\"\n  RESET_COLOR_BRANCH=\"%{${GIT_RADAR_COLOR_BRANCH_RESET:-$reset_color}%}\"\n  RESET_COLOR_STASH=\"%{${GIT_RADAR_COLOR_STASH:-$reset_color}%}\"\n}\n\nin_current_dir() {\n  local wd=\"$(pwd)\"\n  if [[ \"$wd\" == $cwd ]]; then\n    cwd=\"$wd\"\n    return 0\n  else\n    cwd=\"$wd\"\n    return 1\n  fi\n}\n\nechodebug() {\n  echo \"$@\" 1>&2\n}\n\ndebug_print() {\n  local debug=$1\n  local message=$2\n  if [[ $debug == \"debug\" ]]; then\n    echo $message\n  fi\n}\n\ndot_git() {\n  if in_current_dir && [[ -n \"$dot_git\" ]]; then\n    # cache dot_git to save calls to rev-parse\n    printf '%s' $dot_git\n  elif [ -d .git ]; then\n    dot_git=\".git\"\n    printf '%s' $dot_git\n  else\n    dot_git=\"$(git rev-parse --git-dir 2>/dev/null)\"\n    printf '%s' $dot_git\n  fi\n}\n\nstat_type() {\n  if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    stat_type=\"gstat\"\n  else\n    stat_type=\"stat\"\n  fi\n  printf '%s' $stat_type\n}\n\nis_repo() {\n  if [[ -n \"$(dot_git)\" ]]; then\n    return 0\n  else\n    return 1\n  fi\n}\n\ngit_root() {\n  if [ -d .git ]; then\n    printf '%s' \"$(pwd)\"\n  else\n    printf '%s' \"$(git rev-parse --show-toplevel 2>/dev/null)\"\n  fi\n}\n\nrecord_timestamp() {\n  if is_repo; then\n    touch \"$(dot_git)/lastupdatetime\"\n  fi\n}\n\ntimestamp() {\n  if is_repo; then\n    printf '%s' \"$($(stat_type) -c%Y \"$(dot_git)/lastupdatetime\" 2>/dev/null || printf '%s' \"0\")\"\n  fi\n}\n\ntime_now() {\n  printf '%s' \"$(date +%s)\"\n}\n\ntime_to_update() {\n  last_time_updated=\"${1:-$FETCH_TIME}\"\n  if is_repo; then\n    local timesincelastupdate=\"$(($(time_now) - $(timestamp)))\"\n    if (( $timesincelastupdate > $last_time_updated )); then\n      # time to update return 0 (which is true)\n      return 0\n    else\n      # not time to update return 1 (which is false)\n      return 1\n    fi\n  else\n    return 1\n  fi\n}\n\nfetch() {\n  # Gives $FETCH_TIME a value\n  get_fetch_time\n\n  if time_to_update $FETCH_TIME; then\n    record_timestamp\n    git fetch --quiet > /dev/null 2>&1\n  fi\n}\n\ncommit_short_sha() {\n  if is_repo; then\n    printf '%s' \"$(git rev-parse --short HEAD 2>/dev/null)\"\n  fi\n}\n\nbranch_name() {\n  name=\"$(git symbolic-ref --short HEAD 2>/dev/null)\"\n  retcode=\"$?\"\n  if [[ \"$retcode\" == \"0\" ]]; then\n    printf %s \"$name\"\n  else\n    return 1\n  fi\n}\n\nbranch_ref() {\n  if is_repo; then\n    printf '%s' \"$(branch_name || commit_short_sha)\"\n  fi\n}\n\nremote_branch_name() {\n  local localRef=\"$(branch_name)\"\n  local remote=\"$(git config --get \"branch.$localRef.remote\")\"\n  if [[ -n $remote ]]; then\n    local remoteBranch=\"$(git config --get \"branch.${localRef}.merge\" | sed -e 's/^refs\\/heads\\///')\"\n    if [[ -n $remoteBranch ]]; then\n      printf '%s/%s' $remote $remoteBranch\n      return 0\n    else\n        return 1\n    fi\n  else\n    return 1\n  fi\n}\n\ncommits_behind_of_remote() {\n  remote_branch=${1:-\"$(remote_branch_name)\"}\n  if [[ -n \"$remote_branch\" ]]; then\n    git rev-list --left-only --count ${remote_branch}...HEAD 2>/dev/null\n  else\n    printf '%s' \"0\"\n  fi\n}\n\ncommits_ahead_of_remote() {\n  remote_branch=${1:-\"$(remote_branch_name)\"}\n  if [[ -n \"$remote_branch\" ]]; then\n    git rev-list --right-only --count ${remote_branch}...HEAD 2>/dev/null\n  else\n    printf '%s' \"0\"\n  fi\n}\n\nremote_behind_of_master() {\n  remote_branch=${1:-\"$(remote_branch_name)\"}\n  tracked_remote=\"origin/master\"\n  if [[ -n \"$remote_branch\" && \"$remote_branch\" != \"$tracked_remote\" ]]; then\n    git rev-list --left-only --count ${tracked_remote}...${remote_branch} 2>/dev/null || printf '%s' \"0\"\n  else\n    printf '%s' \"0\"\n  fi\n}\n\nremote_ahead_of_master() {\n  remote_branch=${1:-\"$(remote_branch_name)\"}\n  tracked_remote=\"origin/master\"\n  if [[ -n \"$remote_branch\" && \"$remote_branch\" != \"$tracked_remote\" ]]; then\n    git rev-list --right-only --count ${tracked_remote}...${remote_branch} 2>/dev/null || printf '%s' \"0\"\n  else\n    printf '%s' \"0\"\n  fi\n}\n\n# Diacritic marks for overlaying an arrow over A D C etc\n#us=\"\\xE2\\x83\\x97{$reset_color%}\"\n#them=\"\\xE2\\x83\\x96%{$reset_color%}\"\n#both=\"\\xE2\\x83\\xA1%{$reset_color%}\"\n\nis_dirty() {\n  if ! git rev-parse &> /dev/null; then\n    #not in repo, thus not dirty\n    return 1\n  else\n    #in repo, might be dirty\n    if [[ -n \"$(git ls-files --exclude-standard --others 2>/dev/null)\" ]]; then\n      #untracked files thus dirty\n      return 0\n    else\n      #no untracked files\n      if git show HEAD -- &> /dev/null; then\n        #has a commit hash, thus not on an initial commit\n        if ! git diff --quiet --ignore-submodules HEAD -- &> /dev/null; then\n          #has differences thus dirty\n          return 0\n        else\n          return 1\n        fi\n      else\n        #no commit hash, thus can't use HEAD.\n        #As it's inital commit we can just list the files.\n        if [[ -n \"$(ls -a -1 \"$(git_root)\" | grep -Ev '(\\.|\\.\\.|\\.git)')\" ]]; then\n          #files listed and no commit hash, thus changes\n          return 0\n        else\n          return 1\n        fi\n      fi\n    fi\n  fi\n}\n\nporcelain_status() {\n  printf '%s' \"$(git status --porcelain 2>/dev/null)\"\n}\n\nstaged_status() {\n  local gitStatus=${1:-\"$(porcelain_status)\"}\n  local prefix=${2:-\"\"}\n  local suffix=${3:-\"\"}\n\n  local staged_string=\"\"\n  local filesModified=\"$(printf '%s' \"$gitStatus\" | grep -oE \"M[ACDRM ] \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesAdded=\"$(printf '%s' \"$gitStatus\" | grep -oE \"A[MCDR ] \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesDeleted=\"$(printf '%s' \"$gitStatus\" | grep -oE \"D[AMCR ] \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesRenamed=\"$(printf '%s' \"$gitStatus\" | grep -oE \"R[AMCD ] \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesCopied=\"$(printf '%s' \"$gitStatus\" | grep -oE \"C[AMDR ] \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n\n  if [ -n \"$filesAdded\" ]; then\n    staged_string=\"$staged_string$filesAdded${prefix}A${suffix}\"\n  fi\n  if [ -n \"$filesDeleted\" ]; then\n    staged_string=\"$staged_string$filesDeleted${prefix}D${suffix}\"\n  fi\n  if [ -n \"$filesModified\" ]; then\n    staged_string=\"$staged_string$filesModified${prefix}M${suffix}\"\n  fi\n  if [ -n \"$filesRenamed\" ]; then\n    staged_string=\"$staged_string$filesRenamed${prefix}R${suffix}\"\n  fi\n  if [ -n \"$filesCopied\" ]; then\n    staged_string=\"$staged_string$filesCopied${prefix}C${suffix}\"\n  fi\n  printf '%s' \"$staged_string\"\n}\n\nconflicted_status() {\n  local gitStatus=${1:-\"$(porcelain_status)\"}\n  local prefix=${2:-\"\"}\n  local suffix=${3:-\"\"}\n  local conflicted_string=\"\"\n\n  local filesUs=\"$(printf '%s' \"$gitStatus\" | grep -oE \"[AD]U \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesThem=\"$(printf '%s' \"$gitStatus\" | grep -oE \"U[AD] \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesBoth=\"$(printf '%s' \"$gitStatus\" | grep -oE \"(UU|AA|DD) \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n\n  if [ -n \"$filesUs\" ]; then\n    conflicted_string=\"$conflicted_string$filesUs${prefix}U${suffix}\"\n  fi\n  if [ -n \"$filesThem\" ]; then\n    conflicted_string=\"$conflicted_string$filesThem${prefix}T${suffix}\"\n  fi\n  if [ -n \"$filesBoth\" ]; then\n    conflicted_string=\"$conflicted_string$filesBoth${prefix}B${suffix}\"\n  fi\n  printf '%s' \"$conflicted_string\"\n}\n\nunstaged_status() {\n  local gitStatus=${1:-\"$(porcelain_status)\"}\n  local prefix=${2:-\"\"}\n  local suffix=${3:-\"\"}\n  local unstaged_string=\"\"\n\n  local filesModified=\"$(printf '%s' \"$gitStatus\" | grep -oE \"[ACDRM ]M \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n  local filesDeleted=\"$(printf '%s' \"$gitStatus\" | grep -oE \"[AMCR ]D \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n\n  if [ -n \"$filesDeleted\" ]; then\n    unstaged_string=\"$unstaged_string$filesDeleted${prefix}D${suffix}\"\n  fi\n  if [ -n \"$filesModified\" ]; then\n    unstaged_string=\"$unstaged_string$filesModified${prefix}M${suffix}\"\n  fi\n  printf '%s' \"$unstaged_string\"\n}\n\nuntracked_status() {\n  local gitStatus=${1:-\"$(porcelain_status)\"}\n  local prefix=${2:-\"\"}\n  local suffix=${3:-\"\"}\n  local untracked_string=\"\"\n\n  local filesUntracked=\"$(printf '%s' \"$gitStatus\" | grep \"?? \" | wc -l | grep -oEi '[1-9][0-9]*')\"\n\n  if [ -n \"$filesUntracked\" ]; then\n    untracked_string=\"$untracked_string$filesUntracked${prefix}A${suffix}\"\n  fi\n  printf '%s' \"$untracked_string\"\n}\n\ncolor_changes_status() {\n  local separator=\"${1:- }\"\n\n  local porcelain=\"$(porcelain_status)\"\n  local changes=\"\"\n\n  if [[ -n \"$porcelain\" ]]; then\n    local staged_changes=\"$(staged_status \"$porcelain\" \"$COLOR_CHANGES_STAGED\" \"$RESET_COLOR_CHANGES\")\"\n    local unstaged_changes=\"$(unstaged_status \"$porcelain\" \"$COLOR_CHANGES_UNSTAGED\" \"$RESET_COLOR_CHANGES\")\"\n    local untracked_changes=\"$(untracked_status \"$porcelain\" \"$COLOR_CHANGES_UNTRACKED\" \"$RESET_COLOR_CHANGES\")\"\n    local conflicted_changes=\"$(conflicted_status \"$porcelain\" \"$COLOR_CHANGES_CONFLICTED\" \"$RESET_COLOR_CHANGES\")\"\n    if [[ -n \"$staged_changes\" ]]; then\n      staged_changes=\"$separator$staged_changes\"\n    fi\n\n    if [[ -n \"$unstaged_changes\" ]]; then\n      unstaged_changes=\"$separator$unstaged_changes\"\n    fi\n\n    if [[ -n \"$conflicted_changes\" ]]; then\n      conflicted_changes=\"$separator$conflicted_changes\"\n    fi\n\n    if [[ -n \"$untracked_changes\" ]]; then\n      untracked_changes=\"$separator$untracked_changes\"\n    fi\n\n    changes=\"$staged_changes$conflicted_changes$unstaged_changes$untracked_changes\"\n  fi\n  printf $PRINT_F_OPTION \"${changes:1}\"\n}\n\nbash_color_changes_status() {\n  color_changes_status\n}\n\nzsh_color_changes_status() {\n  color_changes_status\n}\n\ncolor_local_commits() {\n  local green_ahead_arrow=\"${COLOR_LOCAL_AHEAD}↑$RESET_COLOR_LOCAL\"\n  local red_behind_arrow=\"${COLOR_LOCAL_BEHIND}↓$RESET_COLOR_LOCAL\"\n  local yellow_diverged_arrow=\"${COLOR_LOCAL_DIVERGED}⇵$RESET_COLOR_LOCAL\"\n\n  local local_commits=\"\"\n  if remote_branch=\"$(remote_branch_name)\"; then\n    local_ahead=\"$(commits_ahead_of_remote \"$remote_branch\")\"\n    local_behind=\"$(commits_behind_of_remote \"$remote_branch\")\"\n\n    if [[ \"$local_behind\" -gt \"0\" && \"$local_ahead\" -gt \"0\" ]]; then\n      local_commits=\"$local_behind$yellow_diverged_arrow$local_ahead\"\n    elif [[ \"$local_behind\" -gt \"0\" ]]; then\n      local_commits=\"$local_behind$red_behind_arrow\"\n    elif [[ \"$local_ahead\" -gt \"0\" ]]; then\n      local_commits=\"$local_ahead$green_ahead_arrow\"\n    fi\n  fi\n  printf $PRINT_F_OPTION \"$local_commits\"\n}\n\nbash_color_local_commits() {\n  color_local_commits\n}\n\nzsh_color_local_commits() {\n  color_local_commits\n}\n\ncolor_remote_commits() {\n  local green_ahead_arrow=\"${COLOR_REMOTE_AHEAD}←$RESET_COLOR_REMOTE\"\n  local red_behind_arrow=\"${COLOR_REMOTE_BEHIND}→$RESET_COLOR_REMOTE\"\n  local yellow_diverged_arrow=\"${COLOR_REMOTE_DIVERGED}⇄$RESET_COLOR_REMOTE\"\n  local not_upstream=\"${COLOR_REMOTE_NOT_UPSTREAM}⚡$RESET_COLOR_REMOTE\"\n\n  if remote_branch=\"$(remote_branch_name)\"; then\n    remote_ahead=\"$(remote_ahead_of_master \"$remote_branch\")\"\n    remote_behind=\"$(remote_behind_of_master \"$remote_branch\")\"\n\n    if [[ \"$remote_behind\" -gt \"0\" && \"$remote_ahead\" -gt \"0\" ]]; then\n      remote=\"$MASTER_SYMBOL $remote_behind $yellow_diverged_arrow $remote_ahead\"\n    elif [[ \"$remote_ahead\" -gt \"0\" ]]; then\n      remote=\"$MASTER_SYMBOL $green_ahead_arrow $remote_ahead\"\n    elif [[ \"$remote_behind\" -gt \"0\" ]]; then\n      remote=\"$MASTER_SYMBOL $remote_behind $red_behind_arrow\"\n    fi\n  else\n    remote=\"upstream $not_upstream\"\n  fi\n\n  printf $PRINT_F_OPTION \"$remote\"\n}\n\nbash_color_remote_commits() {\n  color_remote_commits\n}\n\nzsh_color_remote_commits() {\n  color_remote_commits\n}\n\nreadable_branch_name() {\n  if is_repo; then\n    printf $PRINT_F_OPTION \"$COLOR_BRANCH$(branch_name || printf '%s' \"detached@$(commit_short_sha)\")$RESET_COLOR_BRANCH\"\n  fi\n}\n\nzsh_readable_branch_name() {\n  readable_branch_name\n}\n\nbash_readable_branch_name() {\n  readable_branch_name\n}\n\nshow_remote_status() {\n  if [[ $@ == *$NO_REMOTE_STATUS* ]]; then\n    return 1 # don't show the git remote status\n  fi\n  return 0\n}\n\nstashed_status() {\n  printf '%s' \"$(git stash list | wc -l 2>/dev/null | grep -oEi '[0-9][0-9]*')\"\n}\n\nis_cwd_a_dot_git_directory() {\n  [[ \"$(basename \"$PWD\")\" == \".git\" ]]; return $?\n}\n\nstash_status() {\n  if ! is_cwd_a_dot_git_directory; then\n    local number_stashes=\"$(stashed_status)\"\n    if [ $number_stashes -gt 0 ]; then\n      printf $PRINT_F_OPTION \"${number_stashes}${COLOR_STASH}≡${RESET_COLOR_STASH}\"\n    fi\n  fi\n}\n\nrender_prompt() {\n  output=\"$PROMPT_FORMAT\"\n  branch_sed=\"\"\n  remote_sed=\"\"\n  local_sed=\"\"\n  changes_sed=\"\"\n  stash_sed=\"\"\n\n\n  if_pre=\"%\\{([^%{}]{1,}:){0,1}\"\n  if_post=\"(:[^%{}]{1,}){0,1}\\}\"\n  sed_pre=\"%{\\(\\([^%^{^}]*\\)\\:\\)\\{0,1\\}\"\n  sed_post=\"\\(\\:\\([^%^{^}]*\\)\\)\\{0,1\\}}\"\n\n  if [[ $output =~ ${if_pre}remote${if_post} ]]; then\n    remote_result=\"$(color_remote_commits)\"\n    if [[ -n \"$remote_result\" ]]; then\n      remote_sed=\"s/${sed_pre}remote${sed_post}/\\2${remote_result}\\4/\"\n    else\n      remote_sed=\"s/${sed_pre}remote${sed_post}//\"\n    fi\n  fi\n  if [[ $PROMPT_FORMAT =~ ${if_pre}branch${if_post} ]]; then\n    branch_result=\"$(readable_branch_name | sed -e 's/\\//\\\\\\//g')\"\n    if [[ -n \"$branch_result\" ]]; then\n      branch_sed=\"s/${sed_pre}branch${sed_post}/\\2${branch_result}\\4/\"\n    else\n      branch_sed=\"s/${sed_pre}branch${sed_post}//\"\n    fi\n  fi\n  if [[ $PROMPT_FORMAT =~ ${if_pre}local${if_post} ]]; then\n    local_result=\"$(color_local_commits)\"\n    if [[ -n \"$local_result\" ]]; then\n      local_sed=\"s/${sed_pre}local${sed_post}/\\2$local_result\\4/\"\n    else\n      local_sed=\"s/${sed_pre}local${sed_post}//\"\n    fi\n  fi\n  if [[ $PROMPT_FORMAT =~ ${if_pre}changes${if_post} ]]; then\n    changes_result=\"$(color_changes_status)\"\n    if [[ -n \"$changes_result\" ]]; then\n      changes_sed=\"s/${sed_pre}changes${sed_post}/\\2${changes_result}\\4/\"\n    else\n      changes_sed=\"s/${sed_pre}changes${sed_post}//\"\n    fi\n  fi\n  if [[ $PROMPT_FORMAT =~ ${if_pre}stash${if_post} ]]; then\n    stash_result=\"$(stash_status)\"\n    if [[ -n \"$stash_result\" ]]; then\n      stash_sed=\"s/${sed_pre}stash${sed_post}/\\2${stash_result}\\4/\"\n    else\n      stash_sed=\"s/${sed_pre}stash${sed_post}//\"\n    fi\n  fi\n\n  printf '%b' \"$output\" | sed \\\n                            -e \"$remote_sed\" \\\n                            -e \"$branch_sed\" \\\n                            -e \"$changes_sed\" \\\n                            -e \"$local_sed\" \\\n                            -e \"$stash_sed\"\n}\n"
        },
        {
          "name": "shunit",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "blob",
          "size": 0.1767578125,
          "content": "#!/bin/sh\n\n./test-radar-base.sh\n./test-directories.sh\n./test-commits.sh\n./test-branches.sh\n./test-files.sh\n./test-status.sh\n./test-stash.sh\n./test-colors.sh\n./test-format-config.sh\n"
        },
        {
          "name": "test-branches.sh",
          "type": "blob",
          "size": 1.796875,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntmpfile=\"\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\ntest_branch_name_in_repo() {\n  cd_to_tmp\n  git init --quiet\n  git checkout -b foo --quiet\n  assertEquals \"foo\" \"$(branch_name)\"\n\n  git checkout -b bar --quiet\n  assertEquals \"bar\" \"$(branch_name)\"\n\n  git checkout -b baz --quiet\n  assertEquals \"baz\" \"$(branch_name)\"\n\n  rm_tmp\n}\n\ntest_branch_name_not_in_repo() {\n  cd_to_tmp\n  assertEquals \"\" \"$(branch_name)\"\n  rm_tmp\n}\n\ntest_detached_from_branch() {\n  cd_to_tmp\n  git init --quiet\n  assertEquals \"master\" \"$(branch_name)\"\n\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n\n  touch foo\n  git add .\n  git commit -m \"foo\" --quiet\n\n  git checkout --quiet HEAD^ >/dev/null\n  sha=\"$(commit_short_sha)\"\n\n  assertNotEquals \"master\" \"$(branch_name)\"\n  assertEquals \"$sha\" \"$(branch_ref)\"\n  assertEquals \"detached@$sha\" \"$(zsh_readable_branch_name)\"\n  assertEquals \"detached@$sha\" \"$(bash_readable_branch_name)\"\n  assertEquals \"detached@$sha\" \"$(readable_branch_name)\"\n\n  rm_tmp\n}\n\ntest_branch_name_returns_error() {\n  cd_to_tmp\n  git init --quiet\n\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n\n  touch foo\n  git add .\n  git commit -m \"foo\" --quiet\n\n  git checkout --quiet HEAD^ >/dev/null\n\n  retcode=\"$(branch_name; echo $?)\"\n  assertEquals \"1\" \"$retcode\"\n  rm_tmp\n}\n\ntest_remote_branch_name_quiet_when_not_in_repo() {\n  cd_to_tmp\n\n  debug_output=\"$(\n    {\n    output=\"$(\n      remote_branch_name;\n    )\"\n    } 2>&1\n    echo \"$output\"\n  )\"\n\n  usages=\"$(echo \"$debug_output\" | grep -E \"(usage|fatal):\" | wc -l)\"\n\n  echo \"$debug_output\"\n\n  assertEquals \"       0\" \"$usages\"\n\n  rm_tmp\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-colors.sh",
          "type": "blob",
          "size": 14.857421875,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)$1\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\nmock_zsh_colors() {\n  fg_bold[green]=1\n  fg_bold[red]=2\n  fg_bold[yellow]=3\n  fg_bold[white]=4\n\n  reset_color=0\n}\n\ntest_no_rcfile_bash() {\n  reset_env_vars\n  prepare_bash_colors\n\n  assertEquals \"$COLOR_REMOTE_AHEAD\" \"\\x01\\033[1;32m\\x02\"\n  assertEquals \"$COLOR_REMOTE_BEHIND\" \"\\x01\\033[1;31m\\x02\"\n  assertEquals \"$COLOR_REMOTE_DIVERGED\" \"\\x01\\033[1;33m\\x02\"\n  assertEquals \"$COLOR_REMOTE_NOT_UPSTREAM\" \"\\x01\\033[1;31m\\x02\"\n\n  assertEquals \"$COLOR_LOCAL_AHEAD\" \"\\x01\\033[1;32m\\x02\"\n  assertEquals \"$COLOR_LOCAL_BEHIND\" \"\\x01\\033[1;31m\\x02\"\n  assertEquals \"$COLOR_LOCAL_DIVERGED\" \"\\x01\\033[1;33m\\x02\"\n\n  assertEquals \"$COLOR_CHANGES_STAGED\" \"\\x01\\033[1;32m\\x02\"\n  assertEquals \"$COLOR_CHANGES_UNSTAGED\" \"\\x01\\033[1;31m\\x02\"\n  assertEquals \"$COLOR_CHANGES_CONFLICTED\" \"\\x01\\033[1;33m\\x02\"\n  assertEquals \"$COLOR_CHANGES_UNTRACKED\" \"\\x01\\033[1;37m\\x02\"\n\n  assertEquals \"$RESET_COLOR_LOCAL\" \"\\x01\\033[0m\\x02\"\n  assertEquals \"$RESET_COLOR_REMOTE\" \"\\x01\\033[0m\\x02\"\n  assertEquals \"$RESET_COLOR_CHANGES\" \"\\x01\\033[0m\\x02\"\n}\n\ntest_no_rcfile_zsh() {\n  reset_env_vars\n  mock_zsh_colors\n  prepare_zsh_colors\n\n  assertEquals \"$COLOR_REMOTE_AHEAD\" \"%{$fg_bold[green]%}\"\n  assertEquals \"$COLOR_REMOTE_BEHIND\" \"%{$fg_bold[red]%}\"\n  assertEquals \"$COLOR_REMOTE_DIVERGED\" \"%{$fg_bold[yellow]%}\"\n  assertEquals \"$COLOR_REMOTE_NOT_UPSTREAM\" \"%{$fg_bold[red]%}\"\n\n  assertEquals \"$COLOR_LOCAL_AHEAD\" \"%{$fg_bold[green]%}\"\n  assertEquals \"$COLOR_LOCAL_BEHIND\" \"%{$fg_bold[red]%}\"\n  assertEquals \"$COLOR_LOCAL_DIVERGED\" \"%{$fg_bold[yellow]%}\"\n\n  assertEquals \"$COLOR_CHANGES_STAGED\" \"%{$fg_bold[green]%}\"\n  assertEquals \"$COLOR_CHANGES_UNSTAGED\" \"%{$fg_bold[red]%}\"\n  assertEquals \"$COLOR_CHANGES_CONFLICTED\" \"%{$fg_bold[yellow]%}\"\n  assertEquals \"$COLOR_CHANGES_UNTRACKED\" \"%{$fg_bold[white]%}\"\n\n  assertEquals \"$RESET_COLOR_LOCAL\" \"%{$reset_color%}\"\n  assertEquals \"$RESET_COLOR_REMOTE\" \"%{$reset_color%}\"\n  assertEquals \"$RESET_COLOR_CHANGES\" \"%{$reset_color%}\"\n}\n\nset_env_vars() {\n  export GIT_RADAR_COLOR_REMOTE_AHEAD=\"remote-ahead\"\n  export GIT_RADAR_COLOR_REMOTE_BEHIND=\"remote-behind\"\n  export GIT_RADAR_COLOR_REMOTE_DIVERGED=\"remote-diverged\"\n  export GIT_RADAR_COLOR_REMOTE_NOT_UPSTREAM=\"not-upstream\"\n\n  export GIT_RADAR_COLOR_LOCAL_AHEAD=\"local-ahead\"\n  export GIT_RADAR_COLOR_LOCAL_BEHIND=\"local-behind\"\n  export GIT_RADAR_COLOR_LOCAL_DIVERGED=\"local-diverged\"\n\n  export GIT_RADAR_COLOR_CHANGES_STAGED=\"changes-staged\"\n  export GIT_RADAR_COLOR_CHANGES_UNSTAGED=\"changes-unstaged\"\n  export GIT_RADAR_COLOR_CHANGES_CONFLICTED=\"changes-conflicted\"\n  export GIT_RADAR_COLOR_CHANGES_UNTRACKED=\"changes-untracked\"\n\n  export GIT_RADAR_COLOR_BRANCH=\"branch-color\"\n  export GIT_RADAR_MASTER_SYMBOL=\"m\"\n\n  export GIT_RADAR_COLOR_LOCAL_RESET=\"local-reset\"\n  export GIT_RADAR_COLOR_REMOTE_RESET=\"remote-reset\"\n  export GIT_RADAR_COLOR_CHANGES_RESET=\"change-reset\"\n  export GIT_RADAR_COLOR_BRANCH_RESET=\"branch-reset\"\n}\n\nreset_env_vars() {\n  export GIT_RADAR_COLOR_REMOTE_AHEAD=\"\"\n  export GIT_RADAR_COLOR_REMOTE_BEHIND=\"\"\n  export GIT_RADAR_COLOR_REMOTE_DIVERGED=\"\"\n  export GIT_RADAR_COLOR_REMOTE_NOT_UPSTREAM=\"\"\n\n  export GIT_RADAR_COLOR_LOCAL_AHEAD=\"\"\n  export GIT_RADAR_COLOR_LOCAL_BEHIND=\"\"\n  export GIT_RADAR_COLOR_LOCAL_DIVERGED=\"\"\n\n  export GIT_RADAR_COLOR_CHANGES_STAGED=\"\"\n  export GIT_RADAR_COLOR_CHANGES_UNSTAGED=\"\"\n  export GIT_RADAR_COLOR_CHANGES_CONFLICTED=\"\"\n  export GIT_RADAR_COLOR_CHANGES_UNTRACKED=\"\"\n\n  export GIT_RADAR_COLOR_BRANCH=\"\"\n  export GIT_RADAR_MASTER_SYMBOL=\"\"\n\n  export GIT_RADAR_COLOR_LOCAL_RESET=\"\"\n  export GIT_RADAR_COLOR_REMOTE_RESET=\"\"\n  export GIT_RADAR_COLOR_CHANGES_RESET=\"\"\n  export GIT_RADAR_COLOR_BRANCH_RESET=\"\"\n}\n\ncreate_rc_file() {\n  echo 'GIT_RADAR_COLOR_REMOTE_AHEAD=\"remote-ahead\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_REMOTE_BEHIND=\"remote-behind\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_REMOTE_DIVERGED=\"remote-diverged\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_REMOTE_NOT_UPSTREAM=\"not-upstream\"' >> .gitradarrc$1\n\n  echo 'GIT_RADAR_COLOR_LOCAL_AHEAD=\"local-ahead\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_LOCAL_BEHIND=\"local-behind\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_LOCAL_DIVERGED=\"local-diverged\"' >> .gitradarrc$1\n\n  echo 'GIT_RADAR_COLOR_CHANGES_STAGED=\"changes-staged\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_CHANGES_UNSTAGED=\"changes-unstaged\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_CHANGES_CONFLICTED=\"changes-conflicted\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_CHANGES_UNTRACKED=\"changes-untracked\"' >> .gitradarrc$1\n\n  echo 'export GIT_RADAR_COLOR_BRANCH=\"branch-color\"' >> .gitradarrc$1\n  echo 'export GIT_RADAR_MASTER_SYMBOL=\"m\"' >> .gitradarrc$1\n\n  echo 'GIT_RADAR_COLOR_LOCAL_RESET=\"local-reset\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_REMOTE_RESET=\"remote-reset\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_CHANGES_RESET=\"change-reset\"' >> .gitradarrc$1\n  echo 'GIT_RADAR_COLOR_BRANCH_RESET=\"branch-reset\"' >> .gitradarrc$1\n}\n\ntest_with_rcfile_bash() {\n  reset_env_vars\n  cd_to_tmp\n\n  rcfile_path=\"$(pwd)\"\n\n  create_rc_file \".bash\"\n  prepare_bash_colors\n\n  assertEquals \"$COLOR_REMOTE_AHEAD\" \"\\x01remote-ahead\\x02\"\n  assertEquals \"$COLOR_REMOTE_BEHIND\" \"\\x01remote-behind\\x02\"\n  assertEquals \"$COLOR_REMOTE_DIVERGED\" \"\\x01remote-diverged\\x02\"\n  assertEquals \"$COLOR_REMOTE_NOT_UPSTREAM\" \"\\x01not-upstream\\x02\"\n\n  assertEquals \"$COLOR_LOCAL_AHEAD\" \"\\x01local-ahead\\x02\"\n  assertEquals \"$COLOR_LOCAL_BEHIND\" \"\\x01local-behind\\x02\"\n  assertEquals \"$COLOR_LOCAL_DIVERGED\" \"\\x01local-diverged\\x02\"\n\n  assertEquals \"$COLOR_CHANGES_STAGED\" \"\\x01changes-staged\\x02\"\n  assertEquals \"$COLOR_CHANGES_UNSTAGED\" \"\\x01changes-unstaged\\x02\"\n  assertEquals \"$COLOR_CHANGES_CONFLICTED\" \"\\x01changes-conflicted\\x02\"\n  assertEquals \"$COLOR_CHANGES_UNTRACKED\" \"\\x01changes-untracked\\x02\"\n\n  assertEquals \"$COLOR_BRANCH\" \"\\x01branch-color\\x02\"\n  assertEquals \"$MASTER_SYMBOL\" \"m\"\n\n  assertEquals \"$RESET_COLOR_LOCAL\" \"\\x01local-reset\\x02\"\n  assertEquals \"$RESET_COLOR_REMOTE\" \"\\x01remote-reset\\x02\"\n  assertEquals \"$RESET_COLOR_CHANGES\" \"\\x01change-reset\\x02\"\n  assertEquals \"$RESET_COLOR_BRANCH\" \"\\x01branch-reset\\x02\"\n\n  rm_tmp\n}\n\ntest_with_rcfile_zsh() {\n  reset_env_vars\n  cd_to_tmp\n\n  rcfile_path=\"$(pwd)\"\n\n  create_rc_file \".zsh\"\n  mock_zsh_colors\n  prepare_zsh_colors\n\n  assertEquals \"$COLOR_REMOTE_AHEAD\" \"%{remote-ahead%}\"\n  assertEquals \"$COLOR_REMOTE_BEHIND\" \"%{remote-behind%}\"\n  assertEquals \"$COLOR_REMOTE_DIVERGED\" \"%{remote-diverged%}\"\n  assertEquals \"$COLOR_REMOTE_NOT_UPSTREAM\" \"%{not-upstream%}\"\n\n  assertEquals \"$COLOR_LOCAL_AHEAD\" \"%{local-ahead%}\"\n  assertEquals \"$COLOR_LOCAL_BEHIND\" \"%{local-behind%}\"\n  assertEquals \"$COLOR_LOCAL_DIVERGED\" \"%{local-diverged%}\"\n\n  assertEquals \"$COLOR_CHANGES_STAGED\" \"%{changes-staged%}\"\n  assertEquals \"$COLOR_CHANGES_UNSTAGED\" \"%{changes-unstaged%}\"\n  assertEquals \"$COLOR_CHANGES_CONFLICTED\" \"%{changes-conflicted%}\"\n  assertEquals \"$COLOR_CHANGES_UNTRACKED\" \"%{changes-untracked%}\"\n\n  assertEquals \"$COLOR_BRANCH\" \"%{branch-color%}\"\n  assertEquals \"$MASTER_SYMBOL\" \"m\"\n\n  assertEquals \"$RESET_COLOR_LOCAL\" \"%{local-reset%}\"\n  assertEquals \"$RESET_COLOR_REMOTE\" \"%{remote-reset%}\"\n  assertEquals \"$RESET_COLOR_CHANGES\" \"%{change-reset%}\"\n  assertEquals \"$RESET_COLOR_BRANCH\" \"%{branch-reset%}\"\n\n  rm_tmp\n}\n\ntest_with_env_vars_bash() {\n  reset_env_vars\n  set_env_vars\n  prepare_bash_colors\n\n  assertEquals \"$COLOR_REMOTE_AHEAD\" \"\\x01remote-ahead\\x02\"\n  assertEquals \"$COLOR_REMOTE_BEHIND\" \"\\x01remote-behind\\x02\"\n  assertEquals \"$COLOR_REMOTE_DIVERGED\" \"\\x01remote-diverged\\x02\"\n  assertEquals \"$COLOR_REMOTE_NOT_UPSTREAM\" \"\\x01not-upstream\\x02\"\n\n  assertEquals \"$COLOR_LOCAL_AHEAD\" \"\\x01local-ahead\\x02\"\n  assertEquals \"$COLOR_LOCAL_BEHIND\" \"\\x01local-behind\\x02\"\n  assertEquals \"$COLOR_LOCAL_DIVERGED\" \"\\x01local-diverged\\x02\"\n\n  assertEquals \"$COLOR_CHANGES_STAGED\" \"\\x01changes-staged\\x02\"\n  assertEquals \"$COLOR_CHANGES_UNSTAGED\" \"\\x01changes-unstaged\\x02\"\n  assertEquals \"$COLOR_CHANGES_CONFLICTED\" \"\\x01changes-conflicted\\x02\"\n  assertEquals \"$COLOR_CHANGES_UNTRACKED\" \"\\x01changes-untracked\\x02\"\n\n  assertEquals \"$COLOR_BRANCH\" \"\\x01branch-color\\x02\"\n  assertEquals \"$MASTER_SYMBOL\" \"m\"\n\n  assertEquals \"$RESET_COLOR_LOCAL\" \"\\x01local-reset\\x02\"\n  assertEquals \"$RESET_COLOR_REMOTE\" \"\\x01remote-reset\\x02\"\n  assertEquals \"$RESET_COLOR_CHANGES\" \"\\x01change-reset\\x02\"\n  assertEquals \"$RESET_COLOR_BRANCH\" \"\\x01branch-reset\\x02\"\n}\n\ntest_with_env_vars_zsh() {\n  reset_env_vars\n  set_env_vars\n  mock_zsh_colors\n  prepare_zsh_colors\n\n  assertEquals \"$COLOR_REMOTE_AHEAD\" \"%{remote-ahead%}\"\n  assertEquals \"$COLOR_REMOTE_BEHIND\" \"%{remote-behind%}\"\n  assertEquals \"$COLOR_REMOTE_DIVERGED\" \"%{remote-diverged%}\"\n  assertEquals \"$COLOR_REMOTE_NOT_UPSTREAM\" \"%{not-upstream%}\"\n\n  assertEquals \"$COLOR_LOCAL_AHEAD\" \"%{local-ahead%}\"\n  assertEquals \"$COLOR_LOCAL_BEHIND\" \"%{local-behind%}\"\n  assertEquals \"$COLOR_LOCAL_DIVERGED\" \"%{local-diverged%}\"\n\n  assertEquals \"$COLOR_CHANGES_STAGED\" \"%{changes-staged%}\"\n  assertEquals \"$COLOR_CHANGES_UNSTAGED\" \"%{changes-unstaged%}\"\n  assertEquals \"$COLOR_CHANGES_CONFLICTED\" \"%{changes-conflicted%}\"\n  assertEquals \"$COLOR_CHANGES_UNTRACKED\" \"%{changes-untracked%}\"\n\n  assertEquals \"$COLOR_BRANCH\" \"%{branch-color%}\"\n  assertEquals \"$MASTER_SYMBOL\" \"m\"\n\n  assertEquals \"$RESET_COLOR_LOCAL\" \"%{local-reset%}\"\n  assertEquals \"$RESET_COLOR_REMOTE\" \"%{remote-reset%}\"\n  assertEquals \"$RESET_COLOR_CHANGES\" \"%{change-reset%}\"\n  assertEquals \"$RESET_COLOR_BRANCH\" \"%{branch-reset%}\"\n}\n\ntest_bash_colors_local() {\n  reset_env_vars\n  set_env_vars\n  prepare_bash_colors\n\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"repo\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n  git push --quiet -u origin master >/dev/null\n  repoLocation=\"$(pwd)\"\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n\n  printf -v expected \"1\\x01local-ahead\\x02↑\\x01local-reset\\x02\"\n  assertEquals \"$expected\" \"$(bash_color_local_commits)\"\n  assertEquals \"$expected\" \"$(color_local_commits)\"\n\n  git push --quiet >/dev/null\n  git reset --hard head^ --quiet >/dev/null\n\n  printf -v expected \"1\\x01local-behind\\x02↓\\x01local-reset\\x02\"\n  assertEquals \"$expected\" \"$(bash_color_local_commits)\"\n  assertEquals \"$expected\" \"$(color_local_commits)\"\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"new commit\" --quiet\n\n  printf -v expected \"1\\x01local-diverged\\x02⇵\\x01local-reset\\x021\"\n  assertEquals \"$expected\" \"$(bash_color_local_commits)\"\n  assertEquals \"$expected\" \"$(color_local_commits)\"\n\n  rm_tmp\n}\n\ntest_zsh_colors_local() {\n  reset_env_vars\n  set_env_vars\n  prepare_zsh_colors\n\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"repo\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n  git push --quiet -u origin master >/dev/null\n  repoLocation=\"$(pwd)\"\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n\n  assertEquals \"1%{local-ahead%}↑%{local-reset%}\" \"$(zsh_color_local_commits)\"\n\n  git push --quiet >/dev/null\n  git reset --hard head^ --quiet >/dev/null\n\n  assertEquals \"1%{local-behind%}↓%{local-reset%}\" \"$(zsh_color_local_commits)\"\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"new commit\" --quiet\n\n  assertEquals \"1%{local-diverged%}⇵%{local-reset%}1\" \"$(zsh_color_local_commits)\"\n\n  rm_tmp\n}\n\ntest_bash_colors_remote() {\n  reset_env_vars\n  set_env_vars\n  prepare_bash_colors\n\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"repo\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  git push --quiet -u origin master >/dev/null\n  repoLocation=\"$(pwd)\"\n\n  git reset --hard head^ --quiet >/dev/null\n  git checkout -b mybranch --quiet\n  git push --quiet -u origin mybranch >/dev/null\n\n  printf -v expected \"m 1 \\x01remote-behind\\x02→\\x01remote-reset\\x02\"\n  assertEquals \"$expected\" \"$(bash_color_remote_commits)\"\n  assertEquals \"$expected\" \"$(color_remote_commits)\"\n\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"new commit\" --quiet\n  git push --quiet >/dev/null\n\n  printf -v expected \"m 1 \\x01remote-diverged\\x02⇄\\x01remote-reset\\x02 1\"\n  assertEquals \"$expected\" \"$(bash_color_remote_commits)\"\n  assertEquals \"$expected\" \"$(color_remote_commits)\"\n\n  git pull origin master --quiet >/dev/null\n  git push --quiet >/dev/null\n\n  printf -v expected \"m \\x01remote-ahead\\x02←\\x01remote-reset\\x02 2\"\n  assertEquals \"$expected\" \"$(bash_color_remote_commits)\"\n  assertEquals \"$expected\" \"$(color_remote_commits)\"\n\n  rm_tmp\n}\n\ntest_zsh_colors_remote() {\n  reset_env_vars\n  set_env_vars\n  prepare_zsh_colors\n\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"repo\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  git push --quiet -u origin master >/dev/null\n  repoLocation=\"$(pwd)\"\n\n  git reset --hard head^ --quiet >/dev/null\n  git checkout -b mybranch --quiet\n  git push --quiet -u origin mybranch >/dev/null\n\n  assertEquals \"m 1 %{remote-behind%}→%{remote-reset%}\" \"$(zsh_color_remote_commits)\"\n\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"new commit\" --quiet\n  git push --quiet >/dev/null\n\n  assertEquals \"m 1 %{remote-diverged%}⇄%{remote-reset%} 1\" \"$(zsh_color_remote_commits)\"\n\n  git pull origin master --quiet >/dev/null\n  git push --quiet >/dev/null\n\n  assertEquals \"m %{remote-ahead%}←%{remote-reset%} 2\" \"$(zsh_color_remote_commits)\"\n\n  rm_tmp\n}\n\ntest_bash_colors_changes() {\n  reset_env_vars\n  set_env_vars\n  prepare_bash_colors\n\n  cd_to_tmp\n  git init --quiet\n\n  touch foo\n  touch bar\n  git add bar\n  echo \"bar\" > bar\n  untracked=\"1\\x01changes-untracked\\x02A\\x01change-reset\\x02\"\n  unstaged=\"1\\x01changes-unstaged\\x02M\\x01change-reset\\x02\"\n  staged=\"1\\x01changes-staged\\x02A\\x01change-reset\\x02\"\n\n  printf -v expected \"$staged $unstaged $untracked\"\n  assertEquals \"$expected\" \"$(bash_color_changes_status)\"\n  assertEquals \"$expected\" \"$(color_changes_status)\"\n  rm_tmp\n}\n\ntest_zsh_colors_changes() {\n  reset_env_vars\n  set_env_vars\n  prepare_zsh_colors\n\n  cd_to_tmp\n  git init --quiet\n\n  touch foo\n  touch bar\n  git add bar\n  echo \"bar\" > bar\n  untracked=\"1%{changes-untracked%}A%{change-reset%}\"\n  unstaged=\"1%{changes-unstaged%}M%{change-reset%}\"\n  staged=\"1%{changes-staged%}A%{change-reset%}\"\n\n  assertEquals \"$staged $unstaged $untracked\" \"$(zsh_color_changes_status)\"\n  rm_tmp\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-commits.sh",
          "type": "blob",
          "size": 8.900390625,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntmpfile=\"\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)$1\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\ntest_commits_with_no_commits() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"0\" \"$(commits_ahead_of_remote)\"\n  assertEquals \"0\" \"$(commits_behind_of_remote)\"\n\n  rm_tmp\n}\n\ntest_commits_behind_no_remote() {\n  cd_to_tmp\n  git init --quiet\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"0\" \"$(commits_behind_of_remote)\"\n\n  rm_tmp\n}\n\ntest_commits_ahead_no_remote() {\n  cd_to_tmp\n  git init --quiet\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"0\" \"$(commits_ahead_of_remote)\"\n\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"0\" \"$(commits_ahead_of_remote)\"\n\n  rm_tmp\n}\n\ntest_commits_ahead_with_remote() {\n  cd_to_tmp \"remote\"\n  git init --quiet\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout master --quiet\n  repoLocation=\"$(pwd)\"\n\n  cd \"$remoteLocation\"\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  cd \"$repoLocation\"\n  git fetch origin --quiet\n  assertEquals \"1\" \"$(commits_ahead_of_remote)\"\n\n  cd \"$remoteLocation\"\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"test commit\" --quiet\n  cd \"$repoLocation\"\n  git fetch origin --quiet\n  assertEquals \"2\" \"$(commits_ahead_of_remote)\"\n\n  rm_tmp\n}\n\ntest_commits_ahead_with_remote() {\n  cd_to_tmp \"remote\"\n  git init --quiet\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout master --quiet\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"1\" \"$(commits_ahead_of_remote)\"\n\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"2\" \"$(commits_ahead_of_remote)\"\n\n  rm_tmp\n}\n\ntest_remote_ahead_master() {\n  cd_to_tmp \"remote\"\n  git init --quiet\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout master --quiet\n\n  git checkout -b foo --quiet\n  git push --quiet -u origin foo >/dev/null\n\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"0\" \"$(remote_ahead_of_master)\"\n  git push --quiet\n  assertEquals \"1\" \"$(remote_ahead_of_master)\"\n\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"test commit\" --quiet\n  assertEquals \"1\" \"$(remote_ahead_of_master)\"\n  git push --quiet\n  assertEquals \"2\" \"$(remote_ahead_of_master)\"\n\n  rm_tmp\n}\n\ntest_remote_behind_master() {\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n\n  git push --quiet -u origin master >/dev/null\n  git reset --quiet --hard HEAD\n\n  git checkout -b foo --quiet\n  git push --quiet -u origin foo >/dev/null\n\n  assertEquals \"0\" \"$(remote_behind_of_master)\"\n  git checkout master --quiet\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n  git push --quiet >/dev/null\n  git checkout foo --quiet\n  assertEquals \"1\" \"$(remote_behind_of_master)\"\n\n  git checkout master --quiet\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"test commit\" --quiet\n  git push --quiet >/dev/null\n  git checkout foo --quiet\n  assertEquals \"2\" \"$(remote_behind_of_master)\"\n\n  rm_tmp\n}\n\ntest_remote_branch_starts_with_local_branch_name() {\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"local\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n\n  git push --quiet -u origin master >/dev/null\n  git reset --quiet --hard HEAD\n\n  git checkout -b foobar --quiet\n  touch foobarfile\n  git add foobarfile\n  git commit -m \"added foobar\" --quiet\n  git push --quiet -u origin foobar >/dev/null\n\n  git checkout -b foo --quiet\n\n  assertEquals \"0\" \"$(remote_ahead_of_master)\"\n  assertEquals \"0\" \"$(remote_behind_of_master)\"\n  assertEquals \"0\" \"$(commits_behind_of_remote)\"\n  assertEquals \"0\" \"$(commits_ahead_of_remote)\"\n\n  rm_tmp\n}\n\ntest_remote_branch_ends_with_local_branch_name() {\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"local\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n\n  git push --quiet -u origin master >/dev/null\n  git reset --quiet --hard HEAD\n\n  git checkout -b foobar --quiet\n  touch foobarfile\n  git add foobarfile\n  git commit -m \"added foobar\" --quiet\n  git push --quiet -u origin foobar >/dev/null\n\n  git checkout -b bar --quiet\n\n  assertEquals \"0\" \"$(remote_ahead_of_master)\"\n  assertEquals \"0\" \"$(remote_behind_of_master)\"\n  assertEquals \"0\" \"$(commits_behind_of_remote)\"\n  assertEquals \"0\" \"$(commits_ahead_of_remote)\"\n\n  rm_tmp\n}\n\ntest_dont_call_remote_branch_name() {\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n\n  git push --quiet -u origin master >/dev/null\n  git reset --quiet --hard HEAD\n\n  git checkout -b foo --quiet\n  git push --quiet -u origin foo >/dev/null\n\n  remote_branch=\"$(remote_branch_name)\"\n\n  debug_output=\"$(\n    {\n    set -x\n    output=\"$(\n      remote_behind_of_master \"$remote_branch\";\n      remote_ahead_of_master \"$remote_branch\";\n      commits_ahead_of_remote \"$remote_branch\";\n      commits_behind_of_remote \"$remote_branch\";\n    )\"\n    set +x\n    } 2>&1\n    echo \"$output\"\n  )\"\n\n  #Grep through the output and look for remote_branch_name being called\n  usages=\"$(echo \"$debug_output\" | grep 'remote_branch_name' | wc -l )\"\n\n  #wc -l has a weird output\n  assertEquals \"       0\" \"$usages\"\n\n  rm_tmp\n}\n\ntest_dont_remote_if_remote_is_master() {\n  cd_to_tmp\n  git init --quiet\n\n  remote_branch=\"origin/master\"\n\n  debug_output=\"$(\n    {\n    set -x\n    output=\"$(\n      remote_behind_of_master \"$remote_branch\";\n      remote_ahead_of_master \"$remote_branch\";\n    )\"\n    set +x\n    } 2>&1\n    echo \"$output\"\n  )\"\n\n  usages=\"$(echo \"$debug_output\" | grep 'git rev-list' | wc -l )\"\n\n  assertEquals \"       0\" \"$usages\"\n\n  rm_tmp\n}\n\ntest_quiet_if_no_remote_master() {\n  cd_to_tmp \"remote\"\n  git init --quiet\n  touch README\n  git add .\n  git checkout -b foo --quiet\n  git commit -m \"initial commit\" --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout foo --quiet\n  repoLocation=\"$(pwd)\"\n\n  remote_branch=\"$(remote_branch_name)\"\n\n  debug_output=\"$(\n    {\n      output=\"$(\n        remote_behind_of_master \"$remote_branch\";\n      )\"\n    } 2>&1\n    echo \"$output\"\n  )\"\n\n  assertEquals \"0\" \"$debug_output\"\n  debug_output=\"$(\n    {\n      output=\"$(\n        remote_ahead_of_master \"$remote_branch\";\n      )\"\n    } 2>&1\n    echo \"$output\"\n  )\"\n\n  assertEquals \"0\" \"$debug_output\"\n\n  rm_tmp\n}\n\ntest_local_commits() {\n  local up=\"↑\"\n  local both=\"⇵\"\n  local down=\"↓\"\n\n  cd_to_tmp \"remote\"\n\n  assertEquals \"\" \"$(zsh_color_local_commits)\"\n  assertEquals \"\" \"$(bash_color_local_commits)\"\n  assertEquals \"\" \"$(color_local_commits)\"\n\n  git init --quiet\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n  remote=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remote\n  git fetch origin --quiet\n  git checkout master --quiet\n  repo=\"$(pwd)\"\n\n  assertEquals \"\" \"$(zsh_color_local_commits)\"\n  assertEquals \"\" \"$(bash_color_local_commits)\"\n  assertEquals \"\" \"$(color_local_commits)\"\n\n  cd \"$repo\"\n  echo \"bar\" > bar\n  git add .\n  git commit -m \"test commit\" --quiet\n\n  assertEquals \"1$up\" \"$(zsh_color_local_commits)\"\n  assertEquals \"1$up\" \"$(bash_color_local_commits)\"\n  assertEquals \"1$up\" \"$(color_local_commits)\"\n\n  cd \"$remote\"\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"test commit\" --quiet\n\n  cd \"$repo\"\n  git fetch origin --quiet\n\n  assertEquals \"1${both}1\" \"$(zsh_color_local_commits)\"\n  assertEquals \"1${both}1\" \"$(bash_color_local_commits)\"\n  assertEquals \"1${both}1\" \"$(color_local_commits)\"\n\n  git reset --hard HEAD^ --quiet\n\n  assertEquals \"1$down\" \"$(zsh_color_local_commits)\"\n  assertEquals \"1$down\" \"$(bash_color_local_commits)\"\n  assertEquals \"1$down\" \"$(color_local_commits)\"\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-directories.sh",
          "type": "blob",
          "size": 1.560546875,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntmpfile=\"\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\ntest_git_root_in_repo() {\n  cd $scriptDir\n  local root=\"$(git_root)\"\n  assertEquals \"$scriptDir\" \"$root\"\n}\n\ntest_git_root_not_in_repo() {\n  cd_to_tmp\n  local root=\"$(git_root)\"\n  assertEquals \"\" \"$root\"\n  rm_tmp\n}\n\ntest_dot_git_location_not_in_repo() {\n  cd_to_tmp\n  local filePath=\"$(dot_git)\"\n  assertEquals \"\" \"$filePath\"\n  rm_tmp\n}\n\ntest_dot_git_location_in_repo() {\n  cd $scriptDir\n  local filePath=\"$(dot_git)\"\n  local expected=\".git\"\n  assertEquals \"$expected\" \"$filePath\"\n}\n\ntest_is_repo_not_in_repo() {\n  cd_to_tmp\n  assertFalse is_repo\n  rm_tmp\n}\n\ntest_is_repo_in_repo() {\n  cd $scriptDir\n  assertTrue is_repo\n}\n\ntest_record_timestamp_in_repo() {\n  cd $scriptDir\n  record_timestamp\n  local timestamp=\"$(timestamp)\"\n  local timenow=\"$(time_now)\"\n  assertSame \"$timenow\" \"$timestamp\"\n}\n\ntest_time_to_update_when_timestamp_is_old() {\n  cd $scriptDir\n  FETCH_TIME=\"$((5 * 60))\" # Fetch every 5 mins\n  touch -A \"-010000\" \"$(dot_git)/lastupdatetime\"\n  assertTrue time_to_update\n}\n\ntest_not_time_to_update_when_just_recorded() {\n  cd $scriptDir\n  FETCH_TIME=\"$((5 * 60))\" # Fetch every 5 mins\n  record_timestamp\n  assertFalse time_to_update\n}\n\ntest_time_to_update_when_no_timestamp() {\n  cd_to_tmp\n  git init --quiet\n\n  FETCH_TIME=\"$((5 * 60))\" # Fetch every 5 mins\n  time_to_update\n  assertTrue time_to_update\n\n  rm_tmp\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-files.sh",
          "type": "blob",
          "size": 4.1953125,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntmpfile=\"\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)$1\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\ntest_untracked_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(untracked_status)\"\n\n  touch foo\n  assertEquals \"1A\" \"$(untracked_status)\"\n\n  git add .\n  assertEquals \"\" \"$(untracked_status)\"\n\n  rm_tmp\n}\n\ntest_unstaged_modified_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(unstaged_status)\"\n\n  touch foo\n  touch bar\n  git add .\n  git commit -m \"foo and bar\" >/dev/null\n\n  echo \"foo\" >> foo\n  assertEquals \"1M\" \"$(unstaged_status)\"\n\n  echo \"bar\" >> bar\n  assertEquals \"2M\" \"$(unstaged_status)\"\n\n  rm_tmp\n}\n\ntest_unstaged_deleted_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(unstaged_status)\"\n\n  touch foo\n  touch bar\n  git add .\n  git commit -m \"foo and bar\" >/dev/null\n\n  rm foo\n  assertEquals \"1D\" \"$(unstaged_status)\"\n\n  rm bar\n  assertEquals \"2D\" \"$(unstaged_status)\"\n\n  rm_tmp\n}\n\ntest_staged_added_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(staged_status)\"\n\n  touch foo\n  git add .\n  assertEquals \"1A\" \"$(staged_status)\"\n\n  touch bar\n  git add .\n  assertEquals \"2A\" \"$(staged_status)\"\n\n  rm_tmp\n}\n\ntest_staged_modified_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(staged_status)\"\n\n  touch foo\n  touch bar\n  git add .\n  git commit -m \"foo and bar\" >/dev/null\n\n  echo \"foo\" >> foo\n  git add .\n  assertEquals \"1M\" \"$(staged_status)\"\n\n  echo \"bar\" >> bar\n  git add .\n  assertEquals \"2M\" \"$(staged_status)\"\n\n  rm_tmp\n}\n\ntest_staged_deleted_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(staged_status)\"\n\n  touch foo\n  touch bar\n  git add .\n  git commit -m \"foo and bar\" >/dev/null\n\n  rm foo\n  git add .\n  assertEquals \"1D\" \"$(staged_status)\"\n\n  rm bar\n  git add .\n  assertEquals \"2D\" \"$(staged_status)\"\n\n  rm_tmp\n}\n\ntest_staged_renamed_files() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"\" \"$(staged_status)\"\n\n  touch foo\n  touch bar\n  git add .\n  git commit -m \"foo and bar\" >/dev/null\n\n  mv foo foo2\n  git add .\n  assertEquals \"1R\" \"$(staged_status)\"\n\n  mv bar bar2\n  git add .\n  assertEquals \"2R\" \"$(staged_status)\"\n\n  rm_tmp\n}\n\ntest_conflicted_both_changes() {\n  cd_to_tmp\n  git init --quiet\n\n  git checkout -b foo --quiet\n  echo \"foo\" >> foo\n  git add .\n  git commit -m \"foo\" --quiet\n\n  git checkout -b foo2 --quiet\n  echo \"bar\" >> foo\n  git add .\n  git commit -m \"bar\" --quiet\n\n  git checkout foo --quiet\n  echo \"foo2\" >> foo\n  git add .\n  git commit -m \"foo2\" --quiet\n\n  assertEquals \"\" \"$(conflicted_status)\"\n\n  git merge foo2 >/dev/null\n\n  assertEquals \"1B\" \"$(conflicted_status)\"\n\n  rm_tmp\n}\n\ntest_conflicted_them_changes() {\n  cd_to_tmp\n  git init --quiet\n\n  git checkout -b foo --quiet\n  echo \"foo\" >> foo\n  git add .\n  git commit -m \"foo\" --quiet\n\n  git checkout -b foo2 --quiet\n  rm foo\n  git add .\n  git commit -m \"delete foo\" --quiet\n\n  git checkout foo --quiet\n  echo \"foo2\" >> foo\n  git add .\n  git commit -m \"foo2\" --quiet\n\n  assertEquals \"\" \"$(conflicted_status)\"\n\n  git merge foo2 >/dev/null\n\n  assertEquals \"1T\" \"$(conflicted_status)\"\n\n  rm_tmp\n}\n\ntest_conflicted_us_changes() {\n  cd_to_tmp\n  git init --quiet\n\n  git checkout -b foo --quiet\n  echo \"foo\" >> foo\n  git add .\n  git commit -m \"foo\" --quiet\n\n  git checkout -b foo2 --quiet\n  echo \"bar\" >> foo\n  git add .\n  git commit -m \"bar\" --quiet\n\n  git checkout foo --quiet\n  rm foo\n  git add .\n  git commit -m \"delete foo\" --quiet\n\n  assertEquals \"\" \"$(conflicted_status)\"\n\n  git merge foo2 >/dev/null\n\n  assertEquals \"1U\" \"$(conflicted_status)\"\n\n  rm_tmp\n}\n\ntest_is_dirty() {\n  cd_to_tmp\n\n  assertFalse \"not in repo\" is_dirty\n\n  git init --quiet\n  assertFalse \"in repo and clean\" is_dirty\n\n  touch foo\n  assertTrue \"untracked files\" is_dirty\n\n  mkdir sneakSubDir\n  cd sneakSubDir\n  assertTrue \"untracked files while in an empty sub dir\" is_dirty\n\n  cd ../\n\n  git add .\n  assertTrue \"staged addition files\" is_dirty\n\n  git commit -m \"inital commit\" --quiet\n\n  assertFalse \"commited and clean\" is_dirty\n\n  echo \"foo\" >> foo\n  assertTrue \"modified file unstaged\" is_dirty\n\n  git add .\n  assertTrue \"modified file staged\" is_dirty\n\n  rm_tmp\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-format-config.sh",
          "type": "blob",
          "size": 4.6904296875,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)$1\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\nunset_colours() {\n  export COLOR_REMOTE_AHEAD=\"\"\n  export COLOR_REMOTE_BEHIND=\"\"\n  export COLOR_REMOTE_DIVERGED=\"\"\n  export COLOR_REMOTE_NOT_UPSTREAM=\"\"\n\n  export COLOR_LOCAL_AHEAD=\"\"\n  export COLOR_LOCAL_BEHIND=\"\"\n  export COLOR_LOCAL_DIVERGED=\"\"\n\n  export COLOR_CHANGES_STAGED=\"\"\n  export COLOR_CHANGES_UNSTAGED=\"\"\n  export COLOR_CHANGES_CONFLICTED=\"\"\n  export COLOR_CHANGES_UNTRACKED=\"\"\n\n  export COLOR_BRANCH=\"\"\n  export MASTER_SYMBOL=\"m\"\n\n  export RESET_COLOR_LOCAL=\"\"\n  export RESET_COLOR_REMOTE=\"\"\n  export RESET_COLOR_CHANGES=\"\"\n  export RESET_COLOR_BRANCH=\"\"\n}\n\nprepare_test_repo() {\n  cd_to_tmp \"remote\"\n\n  git init --quiet\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n  origin=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $origin\n  git fetch origin --quiet\n  git checkout master --quiet\n  git checkout -b foo --quiet\n  git push --quiet -u origin foo >/dev/null\n  repo=\"$(pwd)\"\n\n  cd \"$origin\"\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"remote commit\" --quiet\n  cd \"$repo\"\n  echo \"foo\" > foo\n  git add .\n  git commit -m \"local commit\" --quiet\n  echo \"foo\" > bar\n  git fetch origin --quiet\n}\n\ntest_all_options_set_config() {\n  cd_to_tmp \"empty\"\n  export GIT_RADAR_FORMAT=\"%{branch}%{local}%{changes}\"\n  # Don't test remote as in no repo you will get upstream error message\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"\"\n\n  export GIT_RADAR_FORMAT=\"%{remote}\"\n  # Don't test remote as in no repo you will get upstream error message\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"upstream ⚡\"\n  prepare_test_repo\n\n  export GIT_RADAR_FORMAT=\"%{remote}%{branch}%{local}%{changes}\"\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"m 1 →foo1↑1A\"\n\n  export GIT_RADAR_FORMAT=\"%{remote}%{branch}%{changes}\"\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"m 1 →foo1A\"\n\n  export GIT_RADAR_FORMAT=\"%{branch}%{local}%{changes}\"\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"foo1↑1A\"\n\n  export GIT_RADAR_FORMAT=\"%{branch}%{changes}\"\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"foo1A\"\n\n  export GIT_RADAR_FORMAT=\"%{branch}\"\n  prepare_zsh_colors\n  unset_colours\n\n  prompt=\"$(render_prompt)\"\n  assertEquals \"$prompt\" \"foo\"\n\n  rm_tmp\n}\n\n#test_reorder_parts() {\n#  prepare_test_repo\n#\n#  export GIT_RADAR_FORMAT=\"%{branch}%{local}%{changes}%{remote}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"foo1↑1Am 1 →\" \"$prompt\"\n#\n#  export GIT_RADAR_FORMAT=\"%{local}%{changes}%{remote}%{branch}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"1↑1Am 1 →foo\" \"$prompt\"\n#\n#  export GIT_RADAR_FORMAT=\"%{changes}%{remote}%{branch}%{local}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"1Am 1 →foo1↑\" \"$prompt\"\n#\n#  rm_tmp\n#}\n#\n#test_prefix_and_suffix_changes() {\n#  prepare_test_repo\n#\n#  export GIT_RADAR_FORMAT=\"%{changes}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"1A\" \"$prompt\"\n#\n#  export GIT_RADAR_FORMAT=\"%{[:changes:]}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"[1A]\" \"$prompt\"\n#\n#  rm_tmp\n#}\n#\n#test_prefix_and_suffix_local() {\n#  prepare_test_repo\n#\n#  export GIT_RADAR_FORMAT=\"%{local}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"1↑\" \"$prompt\"\n#\n#  export GIT_RADAR_FORMAT=\"%{[:local:]}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"[1↑]\" \"$prompt\"\n#\n#  rm_tmp\n#}\n#\n#test_prefix_and_suffix_branch() {\n#  prepare_test_repo\n#\n#  export GIT_RADAR_FORMAT=\"%{branch}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"foo\" \"$prompt\"\n#\n#  export GIT_RADAR_FORMAT=\"%{[:branch:]}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"[foo]\" \"$prompt\"\n#\n#  rm_tmp\n#}\n#\n#test_prefix_and_suffix_remote() {\n#  prepare_test_repo\n#\n#  export GIT_RADAR_FORMAT=\"%{remote}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"m 1 →\" \"$prompt\"\n#\n#  export GIT_RADAR_FORMAT=\"%{[:remote:]}\"\n#  prepare_zsh_colors\n#  unset_colours\n#\n#  prompt=\"$(render_prompt)\"\n#  assertEquals \"[m 1 →]\" \"$prompt\"\n#\n#  rm_tmp\n#}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-performance.sh",
          "type": "blob",
          "size": 4.7412109375,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)$1\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\nreport() {\n  arr=( \"$@\" )\n  printf '%s\\n' \"${arr[@]}\" | sort -n | awk '\n  function colored(s) {\n    OFMT=\"%2.3fs\";\n    OFS=\"\";\n    ORS=\"\";\n    if( s > 0.2 ) {\n      print \"\\033[1;31m\", s, \"\\033[0m\"\n    } else if( s > 0.1 ) {\n      print \"\\033[1;33m\", s, \"\\033[0m\"\n    } else {\n      print \"\\033[1;32m\", s, \"\\033[0m\"\n    }\n    OFS=\"\\t\";\n    ORS=\"\\n\";\n  }\n  BEGIN {\n    c = 0;\n    sum = 0;\n  }\n  $1 ~ /^[0-9]*(\\.[0-9]*)?$/ {\n    a[c++] = $1;\n    sum += $1;\n  }\n  END {\n    min = a[0] + 0;\n    max = a[c-1] + 0;\n    ave = sum / c;\n    if( (c % 2) == 1 ) {\n      median = a[ int(c/2) ];\n    } else {\n      median = ( a[c/2] + a[c/2-1] ) / 2;\n    }\n    OFS=\"\\t\";\n    OFMT=\"%2.3fs\";\n    print c, colored(ave), colored(median), colored(min), colored(max);\n  }\n'\n}\n\ntable_headers() {\n  printf \"                         Count\\tMean\\tMedian\\tMin\\tMax\\n\"\n}\n\nprofile () {\n  cmd=\"$2\"\n  for (( i = 0; i < 100; i++ )); do\n    start=$(gdate +%s.%N)\n    eval $cmd > /dev/null\n    duration=$(echo \"$(gdate +%s.%N) - $start\" | bc)\n    timings[$i]=$duration\n  done\n  printf '%-25s' \"$1\"\n  report \"${timings[@]}\"\n}\n\ntest_empty_repo() {\n  cd_to_tmp\n  git init --quiet\n\n  table_headers\n  profile \"prompt.zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"prompt.bash\" \"/.$scriptDir/prompt.bash\"\n\n  rm_tmp\n}\n\ntest_lots_of_file_changes() {\n  cd_to_tmp\n  git init --quiet\n\n  table_headers\n\n  profile \"no changes zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"no changes bash\" \"/.$scriptDir/prompt.bash\"\n\n  for (( i = 0; i < 100; i++ )); do\n    touch foo$i\n  done\n\n  profile \"100 untracked zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 untracked bash\" \"/.$scriptDir/prompt.bash\"\n\n  for (( i = 0; i < 100; i++ )); do\n    touch bar$i\n    git add bar$i\n  done\n\n  profile \"100 added zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 added bash\" \"/.$scriptDir/prompt.bash\"\n\n  for (( i = 0; i < 100; i++ )); do\n    echo \"bar$i\" > bar$i\n  done\n\n  profile \"100 modify zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 modify bash\" \"/.$scriptDir/prompt.bash\"\n\n  rm_tmp\n}\n\ntest_commits_local_and_remote_ahead() {\n  cd_to_tmp \"remote\"\n  git init --quiet\n  touch README\n  git add .\n  git commit -m \"initial commit\" --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout master --quiet\n\n  git checkout -b foo --quiet\n  git push --quiet -u origin foo >/dev/null\n\n  table_headers\n\n  profile \"0 commits zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"0 commits bash\" \"/.$scriptDir/prompt.bash\"\n\n  for (( i = 0; i < 100; i++ )); do\n    echo \"foo$i\" >> foo\n    git add .\n    git commit -m \"foo $i\" --quiet\n  done\n\n  profile \"100 local zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 local bash\" \"/.$scriptDir/prompt.bash\"\n\n  git push --quiet\n\n  profile \"100 remote zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 remote bash\" \"/.$scriptDir/prompt.bash\"\n\n  rm_tmp\n}\n\ntest_commits_local_and_remote_behind() {\n  cd_to_tmp \"remote\"\n  git init --bare --quiet\n  remoteLocation=\"$(pwd)\"\n\n  cd_to_tmp \"new\"\n  git init --quiet\n  git remote add origin $remoteLocation\n  git fetch origin --quiet\n  git checkout -b master --quiet\n  touch README\n  git add README\n  git commit -m \"initial commit\" --quiet\n\n  git push --quiet -u origin master >/dev/null\n  git reset --quiet --hard HEAD\n\n  git checkout -b foo --quiet\n  git push --quiet -u origin foo >/dev/null\n\n  git checkout master --quiet\n\n  table_headers\n\n  profile \"0 commits zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"0 commits bash\" \"/.$scriptDir/prompt.bash\"\n\n  for (( i = 0; i < 100; i++ )); do\n    echo \"foo$i\" >> foo\n    git add .\n    git commit -m \"foo $i\" --quiet\n  done\n\n  git push --quiet\n  git checkout foo --quiet\n\n  profile \"100 behind remote zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 behind remote bash\" \"/.$scriptDir/prompt.bash\"\n\n  git checkout master --quiet\n  git checkout -b bar --quiet\n  git push --quiet -u origin bar >/dev/null\n  git reset --hard origin/foo --quiet\n\n  profile \"100 behind mine zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"100 behind mine bash\" \"/.$scriptDir/prompt.bash\"\n\n}\n\ntest_large_repo() {\n  cd_to_tmp\n  git clone https://github.com/Homebrew/homebrew --quiet\n  cd homebrew\n\n  table_headers\n  profile \"prompt.zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"prompt.bash\" \"/.$scriptDir/prompt.bash\"\n\n  rm_tmp\n}\n\ntest_lots_of_submodules() {\n  cd_to_tmp\n  git clone https://github.com/michaeldfallen/dotfiles --quiet\n  cd dotfiles\n  git submodule update --init --quiet\n\n  table_headers\n  profile \"prompt.zsh\" \"/.$scriptDir/prompt.zsh\"\n  profile \"prompt.bash\" \"/.$scriptDir/prompt.bash\"\n\n  rm_tmp\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-radar-base.sh",
          "type": "blob",
          "size": 0.55078125,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntest_show_remote_status() {\n  show_remote_status\n  assertTrue $?\n\n  show_remote_status --bash\n  assertTrue $?\n\n  show_remote_status --bash --fetch\n  assertTrue $?\n\n  show_remote_status --bash --no-remote-status --fetch\n  assertFalse $?\n\n  show_remote_status --bash --fetch --no-remote-status\n  assertFalse $?\n\n  show_remote_status --no-remote-status --bash --fetch\n  assertFalse $?\n\n  show_remote_status --bash --fetch  --minimal --no-remote-status\n  assertFalse $?\n}\n\n. ./shunit/shunit2"
        },
        {
          "name": "test-stash.sh",
          "type": "blob",
          "size": 0.7548828125,
          "content": "#!/bin/bash\nscriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntmpfile=\"\"\n\ncd_to_tmp() {\n  tmpfile=\"/tmp/git-prompt-tests-$(time_now)$1\"\n  mkdir -p \"$tmpfile\"\n  cd \"$tmpfile\"\n}\n\nrm_tmp() {\n  cd $scriptDir\n  rm -rf /tmp/git-prompt-tests*\n}\n\ntest_unstashed_status() {\n  cd_to_tmp\n  git init --quiet\n\n  assertEquals \"0\" \"$(stashed_status)\"\n\n  rm_tmp\n}\n\ntest_stashed_status() {\n  cd_to_tmp\n  git init --quiet\n\n  touch foo\n  git add --all\n  git commit -m \"Initial commit\"  >/dev/null\n  echo \"test\">foo\n  git stash > /dev/null\n  assertEquals \"1\" \"$(stashed_status)\"\n  \n  echo \"test2\">foo\n  git stash > /dev/null\n  assertEquals \"2\" \"$(stashed_status)\"\n\n  git stash drop > /dev/null\n  assertEquals \"1\" \"$(stashed_status)\"\n\n\n  rm_tmp\n}\n\n. ./shunit/shunit2\n"
        },
        {
          "name": "test-status.sh",
          "type": "blob",
          "size": 5.3974609375,
          "content": "scriptDir=\"$(cd \"$(dirname \"$0\")\"; pwd)\"\n\nsource \"$scriptDir/radar-base.sh\"\n\ntest_prefix_and_suffix() {\n  status=\"\"\"\n M unstaged-modified\n D unstaged-deleted\nM  staged-modified\nA  staged-added\nD  staged-deleted\nC  staged-copied\nR  staged-renamed\nMM staged-and-unstaged-modified\nUD deleted-them-conflicted\nAU added-us-conflicted\nUU modified-both-conflicted\n?? untacked\n\"\"\"\n\n  prefix=\"_\"\n  suffix=\"-\"\n\n  assertEquals \"line:${LINENO}\" \"1_D-2_M-\"\\\n    \"$(unstaged_status \"$status\" \"$prefix\" \"$suffix\")\"\n\n  assertEquals \"line:${LINENO}\" \"1_A-1_D-2_M-1_R-1_C-\"\\\n    \"$(staged_status \"$status\" \"$prefix\" \"$suffix\")\"\n\n  assertEquals \"line:${LINENO}\" \"1_U-1_T-1_B-\"\\\n    \"$(conflicted_status \"$status\" \"$prefix\" \"$suffix\")\"\n\n  assertEquals \"line:${LINENO}\" \"1_A-\"\\\n    \"$(untracked_status \"$status\" \"$prefix\" \"$suffix\")\"\n}\n\ntest_basic_unstaged_options() {\n  status=\"\"\"\n M modified-and-unstaged\n D deleted-and-unstaged\n A impossible-added-and-unstaged-(as-added-and-unstaged-is-untracked)\n C impossible-copied-and-unstaged-(as-copied-and-unstaged-is-untracked)\n R impossible-renamed-and-unstaged-(as-renamed-and-unstaged-is-untracked)\n U impossible-updated-but-unmerged\n ! impossible-ignored-without-!-in-position-1\n ? impossible-untracked-without-?-in-position-1\n   empty-spaces-mean-nothing\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\" \"\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\"\\\n    \"1D1M\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n}\n\ntest_basic_staged_options() {\n  status=\"\"\"\nA  added-and-staged\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\"\\\n    \"1A\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nM  modified-and-staged\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\"\\\n    \"1M\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nD  deleted-and-staged\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\"\\\n    \"1D\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nC  copied-and-staged\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\"\\\n    \"1C\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nR  renamed-and-staged\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\"\\\n    \"1R\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nU  impossible-unmerged-without-a-character-in-position-2\n?  impossible-untracked-without-?-in-position-2\n!  impossible-ignored-without-!-in-position-2\n   empty-spaces-do-nothing\n  \"\"\"\n  assertEquals \"line:${LINENO} staged status failed match\" \"\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO} untracked status failed match\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO} unstaged status failed match\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO} conflicted status failed match\" \"\" \"$(conflicted_status \"$status\")\"\n}\n\ntest_conflicts() {\n  status=\"\"\"\nUD unmerged-deleted-by-them\nUA unmerged-added-by-them\n  \"\"\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"2T\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nAU unmerged-added-by-us\nDU unmerged-deleted-by-us\n  \"\"\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"2U\" \"$(conflicted_status \"$status\")\"\n\n  status=\"\"\"\nAA unmerged-both-added\nDD unmerged-both-deleted\nUU unmerged-both-modified\n  \"\"\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(staged_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(untracked_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"\" \"$(unstaged_status \"$status\")\"\n  assertEquals \"line:${LINENO}\" \"3B\" \"$(conflicted_status \"$status\")\"\n}\n\n. ./shunit/shunit2\n"
        }
      ]
    }
  ]
}