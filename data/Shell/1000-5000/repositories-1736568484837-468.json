{
  "metadata": {
    "timestamp": 1736568484837,
    "page": 468,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "supercrabtree/k",
      "stars": 1780,
      "defaultBranch": "master",
      "files": [
        {
          "name": "k.plugin.zsh",
          "type": "blob",
          "size": 0.00390625,
          "content": "k.sh"
        },
        {
          "name": "k.sh",
          "type": "blob",
          "size": 22.6044921875,
          "content": "zmodload zsh/datetime\nzmodload -F zsh/stat b:zstat\n\nk () {\n  # ----------------------------------------------------------------------------\n  # Setup\n  # ----------------------------------------------------------------------------\n\n  # Stop stat failing when a directory contains either no files or no hidden files\n  # Track if we _accidentally_ create a new global variable\n  setopt local_options null_glob typeset_silent no_auto_pushd nomarkdirs\n\n  # Process options and get files/directories\n  typeset -a o_all o_almost_all o_human o_si o_directory o_group_directories \\\n\t  o_no_directory o_no_vcs o_sort o_sort_reverse o_help\n  zparseopts -E -D \\\n             a=o_all -all=o_all \\\n             A=o_almost_all -almost-all=o_almost_all \\\n             c=o_sort \\\n             d=o_directory -directory=o_directory \\\n\t     -group-directories-first=o_group_directories \\\n             h=o_human -human=o_human \\\n             -si=o_si \\\n             n=o_no_directory -no-directory=o_no_directory \\\n             -no-vcs=o_no_vcs \\\n             r=o_sort_reverse -reverse=o_sort_reverse \\\n             -sort:=o_sort \\\n             S=o_sort \\\n             t=o_sort \\\n             u=o_sort \\\n             U=o_sort \\\n             -help=o_help\n\n  # Print Help if bad usage, or they asked for it\n  if [[ $? != 0 || \"$o_help\" != \"\" ]]\n  then\n    print -u2 \"Usage: k [options] DIR\"\n    print -u2 \"Options:\"\n    print -u2 \"\\t-a      --all           list entries starting with .\"\n    print -u2 \"\\t-A      --almost-all    list all except . and ..\"\n    print -u2 \"\\t-c                      sort by ctime (inode change time)\"\n    print -u2 \"\\t-d      --directory     list only directories\"\n    print -u2 \"\\t-n      --no-directory  do not list directories\"\n    print -u2 \"\\t-h      --human         show filesizes in human-readable format\"\n    print -u2 \"\\t        --si            with -h, use powers of 1000 not 1024\"\n    print -u2 \"\\t-r      --reverse       reverse sort order\"\n    print -u2 \"\\t-S                      sort by size\"\n    print -u2 \"\\t-t                      sort by time (modification time)\"\n    print -u2 \"\\t-u                      sort by atime (use or access time)\"\n    print -u2 \"\\t-U                      Unsorted\"\n    print -u2 \"\\t        --sort WORD     sort by WORD: none (U), size (S),\"\n    print -u2 \"\\t                        time (t), ctime or status (c),\"\n    print -u2 \"\\t       \t\t atime or access or use (u)\"\n    print -u2 \"\\t        --no-vcs        do not get VCS status (much faster)\"\n    print -u2 \"\\t        --help          show this help\"\n    return 1\n  fi\n\n  # Check for conflicts\n  if [[ \"$o_directory\" != \"\" && \"$o_no_directory\" != \"\" ]]; then\n    print -u2 \"$o_directory and $o_no_directory cannot be used together\"\n    return 1\n  fi\n\n  # case is like a mnemonic for sort order:\n  # lower-case for standard, upper-case for descending\n  local S_ORD=\"o\" R_ORD=\"O\" SPEC=\"n\"  # default: by name\n\n  # translate ls options to glob-qualifiers,\n  # ignoring \"--sort\" prefix of long-args form\n  case ${o_sort:#--sort} in\n    -U|none)                     SPEC=\"N\";;\n    -t|time)                     SPEC=\"m\";;\n    -c|ctime|status)             SPEC=\"c\";;\n    -u|atime|access|use)         SPEC=\"a\";;\n    # reverse default order for sort by size\n    -S|size) S_ORD=\"O\" R_ORD=\"o\" SPEC=\"L\";;\n  esac\n\n  if [[ \"$o_sort_reverse\" == \"\" ]]; then\n    typeset SORT_GLOB=\"${S_ORD}${SPEC}\"\n  else\n    typeset SORT_GLOB=\"${R_ORD}${SPEC}\"\n  fi\n  if [[ \"$o_group_directories\" != \"\" ]]; then\n    SORT_GLOB=\"oe:[[ -d \\$REPLY ]];REPLY=\\$?:$SORT_GLOB\"\n  fi\n\n  # Check which numfmt available (if any), warn user if not available\n  typeset -i numfmt_available=0\n  typeset -i gnumfmt_available=0\n  if [[ \"$o_human\" != \"\" ]]; then\n    if [[ $+commands[numfmt] == 1 ]]; then\n      numfmt_available=1\n    elif [[ $+commands[gnumfmt] == 1 ]]; then\n      gnumfmt_available=1\n    else\n      print -u2 \"'numfmt' or 'gnumfmt' command not found, human readable output will not work.\"\n      print -u2 \"\\tFalling back to normal file size output\"\n      # Set o_human to off\n      o_human=\"\"\n    fi\n  fi\n\n  # Create numfmt local function\n  numfmt_local () {\n    if [[ \"$o_si\" != \"\" ]]; then\n      if (( $numfmt_available )); then\n        numfmt --to=si $1\n      elif (( $gnumfmt_available )); then\n        gnumfmt --to=si $1\n      fi\n    else\n      if (( $numfmt_available )); then\n        numfmt --to=iec $1\n      elif (( $gnumfmt_available )); then\n        gnumfmt --to=iec $1\n      fi\n    fi\n  }\n\n  # Set if we're in a repo or not\n  typeset -i INSIDE_WORK_TREE=0\n  if [[ $(command git rev-parse --is-inside-work-tree 2>/dev/null) == true ]]; then\n    INSIDE_WORK_TREE=1\n  fi\n\n  # Setup array of directories to print\n  typeset -a base_dirs\n  typeset base_dir\n\n  if [[ \"$@\" == \"\" ]]; then\n    base_dirs=.\n  else\n    base_dirs=($@)\n  fi\n\n\n  # Colors\n  # ----------------------------------------------------------------------------\n  # default colors\n  K_COLOR_DI=\"0;34\"  # di:directory\n  K_COLOR_LN=\"0;35\"  # ln:symlink\n  K_COLOR_SO=\"0;32\"  # so:socket\n  K_COLOR_PI=\"0;33\"  # pi:pipe\n  K_COLOR_EX=\"0;31\"  # ex:executable\n  K_COLOR_BD=\"34;46\" # bd:block special\n  K_COLOR_CD=\"34;43\" # cd:character special\n  K_COLOR_SU=\"30;41\" # su:executable with setuid bit set\n  K_COLOR_SG=\"30;46\" # sg:executable with setgid bit set\n  K_COLOR_TW=\"30;42\" # tw:directory writable to others, with sticky bit\n  K_COLOR_OW=\"30;43\" # ow:directory writable to others, without sticky bit\n  K_COLOR_BR=\"0;30\"  # branch\n\n  # read colors if osx and $LSCOLORS is defined\n  if [[ $(uname) == 'Darwin' && -n $LSCOLORS ]]; then\n    # Translate OSX/BSD's LSCOLORS so we can use the same here\n    K_COLOR_DI=$(_k_bsd_to_ansi $LSCOLORS[1]  $LSCOLORS[2])\n    K_COLOR_LN=$(_k_bsd_to_ansi $LSCOLORS[3]  $LSCOLORS[4])\n    K_COLOR_SO=$(_k_bsd_to_ansi $LSCOLORS[5]  $LSCOLORS[6])\n    K_COLOR_PI=$(_k_bsd_to_ansi $LSCOLORS[7]  $LSCOLORS[8])\n    K_COLOR_EX=$(_k_bsd_to_ansi $LSCOLORS[9]  $LSCOLORS[10])\n    K_COLOR_BD=$(_k_bsd_to_ansi $LSCOLORS[11] $LSCOLORS[12])\n    K_COLOR_CD=$(_k_bsd_to_ansi $LSCOLORS[13] $LSCOLORS[14])\n    K_COLOR_SU=$(_k_bsd_to_ansi $LSCOLORS[15] $LSCOLORS[16])\n    K_COLOR_SG=$(_k_bsd_to_ansi $LSCOLORS[17] $LSCOLORS[18])\n    K_COLOR_TW=$(_k_bsd_to_ansi $LSCOLORS[19] $LSCOLORS[20])\n    K_COLOR_OW=$(_k_bsd_to_ansi $LSCOLORS[21] $LSCOLORS[22])\n  fi\n\n  # read colors if linux and $LS_COLORS is defined\n  # if [[ $(uname) == 'Linux' && -n $LS_COLORS ]]; then\n\n  # fi\n\n  # ----------------------------------------------------------------------------\n  # Loop over passed directories and files to display\n  # ----------------------------------------------------------------------------\n  for base_dir in $base_dirs\n  do\n    # ----------------------------------------------------------------------------\n    # Display name if multiple paths were passed\n    # ----------------------------------------------------------------------------\n    if [[ \"$#base_dirs\" > 1 ]]; then\n      # Only add a newline if its not the first iteration\n      if [[ \"$base_dir\" != \"${base_dirs[1]}\" ]]; then\n        print\n      fi\n      print -r \"${base_dir}:\"\n    fi\n    # ----------------------------------------------------------------------------\n    # Vars\n    # ----------------------------------------------------------------------------\n\n    typeset -a MAX_LEN A RESULTS STAT_RESULTS\n    typeset TOTAL_BLOCKS\n\n    # Get now\n    typeset K_EPOCH=\"${EPOCHSECONDS:?}\"\n\n    typeset -i TOTAL_BLOCKS=0\n\n    MAX_LEN=(0 0 0 0 0 0)\n\n    # Array to hold results from `stat` call\n    RESULTS=()\n\n    # only set once per directory so must be out of the main loop\n    typeset -i IS_GIT_REPO=0\n    typeset GIT_TOPLEVEL\n\n    typeset -i LARGE_FILE_COLOR=196\n    typeset -a SIZELIMITS_TO_COLOR\n    SIZELIMITS_TO_COLOR=(\n        1024  46    # <= 1kb\n        2048  82    # <= 2kb\n        3072  118   # <= 3kb\n        5120  154   # <= 5kb\n       10240  190   # <= 10kb\n       20480  226   # <= 20kb\n       40960  220   # <= 40kb\n      102400  214   # <= 100kb\n      262144  208   # <= 0.25mb || 256kb\n      524288  202   # <= 0.5mb || 512kb\n      )\n    typeset -i ANCIENT_TIME_COLOR=236  # > more than 2 years old\n    typeset -a FILEAGES_TO_COLOR\n    FILEAGES_TO_COLOR=(\n             0 196  # < in the future, #spooky\n            60 255  # < less than a min old\n          3600 252  # < less than an hour old\n         86400 250  # < less than 1 day old\n        604800 244  # < less than 1 week old\n       2419200 244  # < less than 28 days (4 weeks) old\n      15724800 242  # < less than 26 weeks (6 months) old\n      31449600 240  # < less than 1 year old\n      62899200 238  # < less than 2 years old\n      )\n\n    # ----------------------------------------------------------------------------\n    # Build up list of files/directories to show\n    # ----------------------------------------------------------------------------\n\n    typeset -a show_list\n    show_list=()\n\n    # Check if it even exists\n    if [[ ! -e $base_dir ]]; then\n      print -u2 \"k: cannot access $base_dir: No such file or directory\"\n\n    # If its just a file, skip the directory handling\n    elif [[ -f $base_dir ]]; then\n      show_list=($base_dir)\n\n    #Directory, add its contents\n    else\n      # Break total blocks of the front of the stat call, then push the rest to results\n      if [[ \"$o_all\" != \"\" && \"$o_almost_all\" == \"\" && \"$o_no_directory\" == \"\" ]]; then\n        show_list+=($base_dir/.)\n        show_list+=($base_dir/..)\n      fi\n\n      if [[ \"$o_all\" != \"\" || \"$o_almost_all\" != \"\" ]]; then\n        if [[ \"$o_directory\" != \"\" ]]; then\n          show_list+=($base_dir/*(D/$SORT_GLOB))\n        elif [[ \"$o_no_directory\" != \"\" ]]; then\n          #Use (^/) instead of (.) so sockets and symlinks get displayed\n          show_list+=($base_dir/*(D^/$SORT_GLOB))\n        else\n          show_list+=($base_dir/*(D$SORT_GLOB))\n        fi\n      else\n        if [[ \"$o_directory\" != \"\" ]]; then\n          show_list+=($base_dir/*(/$SORT_GLOB))\n        elif [[ \"$o_no_directory\" != \"\" ]]; then\n          #Use (^/) instead of (.) so sockets and symlinks get displayed\n          show_list+=($base_dir/*(^/$SORT_GLOB))\n        else\n\t  show_list+=($base_dir/*($SORT_GLOB))\n        fi\n      fi\n    fi\n\n    # ----------------------------------------------------------------------------\n    # Stat call to get directory listing\n    # ----------------------------------------------------------------------------\n    typeset -i i=1 j=1 k=1\n    typeset -a STATS_PARAMS_LIST\n    typeset fn statvar h\n    typeset -A sv\n\n    STATS_PARAMS_LIST=()\n    for fn in $show_list\n    do\n      statvar=\"stats_$i\"\n      typeset -A $statvar\n      zstat -H $statvar -Lsn -F \"%s^%d^%b^%H:%M^%Y\" -- \"$fn\"  # use lstat, render mode/uid/gid to strings\n      STATS_PARAMS_LIST+=($statvar)\n      i+=1\n    done\n\n\n    # On each result calculate padding by getting max length on each array member\n    for statvar in \"${STATS_PARAMS_LIST[@]}\"\n    do\n      sv=(\"${(@Pkv)statvar}\")\n      if [[ ${#sv[mode]}  -gt $MAX_LEN[1] ]]; then MAX_LEN[1]=${#sv[mode]}  ; fi\n      if [[ ${#sv[nlink]} -gt $MAX_LEN[2] ]]; then MAX_LEN[2]=${#sv[nlink]} ; fi\n      if [[ ${#sv[uid]}   -gt $MAX_LEN[3] ]]; then MAX_LEN[3]=${#sv[uid]}   ; fi\n      if [[ ${#sv[gid]}   -gt $MAX_LEN[4] ]]; then MAX_LEN[4]=${#sv[gid]}   ; fi\n\n      if [[ \"$o_human\" != \"\" ]]; then\n        h=$(numfmt_local ${sv[size]})\n        if (( ${#h} > $MAX_LEN[5] )); then MAX_LEN[5]=${#h}; fi\n      else\n        if [[ ${#sv[size]} -gt $MAX_LEN[5] ]]; then MAX_LEN[5]=${#sv[size]}; fi\n      fi\n\n      TOTAL_BLOCKS+=$sv[blocks]\n    done\n\n    # Print total block before listing\n    echo \"total $TOTAL_BLOCKS\"\n\n    # ----------------------------------------------------------------------------\n    # Loop through each line of stat, pad where appropriate and do git dirty checking\n    # ----------------------------------------------------------------------------\n\n    typeset REPOMARKER\n    typeset REPOBRANCH\n    typeset PERMISSIONS HARDLINKCOUNT OWNER GROUP FILESIZE FILESIZE_OUT DATE NAME SYMLINK_TARGET\n    typeset FILETYPE PER1 PER2 PER3 PERMISSIONS_OUTPUT STATUS\n    typeset TIME_DIFF TIME_COLOR DATE_OUTPUT\n    typeset -i IS_DIRECTORY IS_SYMLINK IS_SOCKET IS_PIPE IS_EXECUTABLE IS_BLOCK_SPECIAL IS_CHARACTER_SPECIAL HAS_UID_BIT HAS_GID_BIT HAS_STICKY_BIT IS_WRITABLE_BY_OTHERS\n    typeset -i COLOR\n\n    k=1\n    for statvar in \"${STATS_PARAMS_LIST[@]}\"\n    do\n      sv=(\"${(@Pkv)statvar}\")\n\n      # We check if the result is a git repo later, so set a blank marker indication the result is not a git repo\n      REPOMARKER=\" \"\n      REPOBRANCH=\"\"\n      IS_DIRECTORY=0\n      IS_SYMLINK=0\n      IS_SOCKET=0\n      IS_PIPE=0\n      IS_EXECUTABLE=0\n      IS_BLOCK_SPECIAL=0\n      IS_CHARACTER_SPECIAL=0\n      HAS_UID_BIT=0\n      HAS_GID_BIT=0\n      HAS_STICKY_BIT=0\n      IS_WRITABLE_BY_OTHERS=0\n\n         PERMISSIONS=\"${sv[mode]}\"\n       HARDLINKCOUNT=\"${sv[nlink]}\"\n               OWNER=\"${sv[uid]}\"\n               GROUP=\"${sv[gid]}\"\n            FILESIZE=\"${sv[size]}\"\n                DATE=(${(s:^:)sv[mtime]}) # Split date on ^\n                NAME=\"${sv[name]}\"\n      SYMLINK_TARGET=\"${sv[link]}\"\n\n      # Check for file types\n      if [[ -d \"$NAME\" ]]; then IS_DIRECTORY=1; fi\n      if [[ -L \"$NAME\" ]]; then IS_SYMLINK=1; fi\n      if [[ -S \"$NAME\" ]]; then IS_SOCKET=1; fi\n      if [[ -p \"$NAME\" ]]; then IS_PIPE=1; fi\n      if [[ -x \"$NAME\" ]]; then IS_EXECUTABLE=1; fi\n      if [[ -b \"$NAME\" ]]; then IS_BLOCK_SPECIAL=1; fi\n      if [[ -c \"$NAME\" ]]; then IS_CHARACTER_SPECIAL=1; fi\n      if [[ -u \"$NAME\" ]]; then HAS_UID_BIT=1; fi\n      if [[ -g \"$NAME\" ]]; then HAS_GID_BIT=1; fi\n      if [[ -k \"$NAME\" ]]; then HAS_STICKY_BIT=1; fi\n      if [[ $PERMISSIONS[9] == 'w' ]]; then IS_WRITABLE_BY_OTHERS=1; fi\n\n      # IS_GIT_REPO is a 1 if $NAME is a file/directory in a git repo, OR if $NAME is a git-repo itself\n      # GIT_TOPLEVEL is set to the directory containing the .git folder of a git-repo\n\n      # is this a git repo\n      if [[ \"$o_no_vcs\" != \"\" ]]; then\n        IS_GIT_REPO=0\n        GIT_TOPLEVEL=''\n      else\n        if (( IS_DIRECTORY ));\n          then builtin cd -q $NAME     2>/dev/null || builtin cd -q - >/dev/null && IS_GIT_REPO=0 #Say no if we don't have permissions there\n          else builtin cd -q $NAME:a:h 2>/dev/null || builtin cd -q - >/dev/null && IS_GIT_REPO=0\n        fi\n        if [[ $(command git rev-parse --is-inside-work-tree 2>/dev/null) == true ]]; then\n          IS_GIT_REPO=1\n          GIT_TOPLEVEL=$(command git rev-parse --show-toplevel)\n        else\n          IS_GIT_REPO=0\n        fi\n        builtin cd -q - >/dev/null\n      fi\n\n      # Get human readable output if necessary\n      if [[ \"$o_human\" != \"\" ]]; then\n        # I hate making this call twice, but its either that, or do a bunch\n        # of calculations much earlier.\n        FILESIZE_OUT=$(numfmt_local $FILESIZE)\n      else\n        FILESIZE_OUT=$FILESIZE\n      fi\n\n      # Pad so all the lines align - firstline gets padded the other way\n        PERMISSIONS=\"${(r:MAX_LEN[1]:)PERMISSIONS}\"\n      HARDLINKCOUNT=\"${(l:MAX_LEN[2]:)HARDLINKCOUNT}\"\n              OWNER=\"${(l:MAX_LEN[3]:)OWNER}\"\n              GROUP=\"${(l:MAX_LEN[4]:)GROUP}\"\n       FILESIZE_OUT=\"${(l:MAX_LEN[5]:)FILESIZE_OUT}\"\n\n      # --------------------------------------------------------------------------\n      # Colour the permissions - TODO\n      # --------------------------------------------------------------------------\n      # Colour the first character based on filetype\n      FILETYPE=\"${PERMISSIONS[1]}\"\n\n      # Permissions Owner\n      PER1=\"${PERMISSIONS[2,4]}\"\n\n      # Permissions Group\n      PER2=\"${PERMISSIONS[5,7]}\"\n\n      # Permissions User\n      PER3=\"${PERMISSIONS[8,10]}\"\n\n      PERMISSIONS_OUTPUT=\"$FILETYPE$PER1$PER2$PER3\"\n\n      # --------------------------------------------------------------------------\n      # Colour the symlinks\n      # --------------------------------------------------------------------------\n\n      # --------------------------------------------------------------------------\n      # Colour Owner and Group\n      # --------------------------------------------------------------------------\n      OWNER=$'\\e[38;5;241m'\"$OWNER\"$'\\e[0m'\n      GROUP=$'\\e[38;5;241m'\"$GROUP\"$'\\e[0m'\n\n      # --------------------------------------------------------------------------\n      # Colour file weights\n      # --------------------------------------------------------------------------\n      COLOR=LARGE_FILE_COLOR\n      for i j in ${SIZELIMITS_TO_COLOR[@]}\n      do\n        (( FILESIZE <= i )) || continue\n        COLOR=$j\n        break\n      done\n\n      FILESIZE_OUT=$'\\e[38;5;'\"${COLOR}m$FILESIZE_OUT\"$'\\e[0m'\n\n      # --------------------------------------------------------------------------\n      # Colour the date and time based on age, then format for output\n      # --------------------------------------------------------------------------\n      # Setup colours based on time difference\n      TIME_DIFF=$(( K_EPOCH - DATE[1] ))\n      TIME_COLOR=$ANCIENT_TIME_COLOR\n      for i j in ${FILEAGES_TO_COLOR[@]}\n      do\n        (( TIME_DIFF < i )) || continue\n        TIME_COLOR=$j\n        break\n      done\n\n      # Format date to show year if more than 6 months since last modified\n      if (( TIME_DIFF < 15724800 )); then\n        DATE_OUTPUT=\"${DATE[2]} ${(r:5:: :)${DATE[3][0,5]}} ${DATE[4]}\"\n      else\n        DATE_OUTPUT=\"${DATE[2]} ${(r:6:: :)${DATE[3][0,5]}} ${DATE[5]}\"  # extra space; 4 digit year instead of 5 digit HH:MM\n      fi;\n      DATE_OUTPUT[1]=\"${DATE_OUTPUT[1]//0/ }\" # If day of month begins with zero, replace zero with space\n\n      # Apply colour to formated date\n      DATE_OUTPUT=$'\\e[38;5;'\"${TIME_COLOR}m${DATE_OUTPUT}\"$'\\e[0m'\n\n      # --------------------------------------------------------------------------\n      # Colour the repomarker\n      # --------------------------------------------------------------------------\n      if [[ \"$o_no_vcs\" != \"\" ]]; then\n        REPOMARKER=\"\"\n      elif (( IS_GIT_REPO != 0)); then\n        # If we're not in a repo, still check each directory if it's a repo, and\n        # then mark appropriately\n        if (( INSIDE_WORK_TREE == 0 )); then\n          REPOBRANCH=$(command git --git-dir=\"$GIT_TOPLEVEL/.git\" --work-tree=\"${NAME}\" rev-parse --abbrev-ref HEAD 2>/dev/null)\n          if (( IS_DIRECTORY )); then\n            if command git --git-dir=\"$GIT_TOPLEVEL/.git\" --work-tree=\"${NAME}\" diff --stat --quiet --ignore-submodules HEAD &>/dev/null # if dirty\n              then REPOMARKER=$'\\e[38;5;46m|\\e[0m' # Show a green vertical bar for clean\n              else REPOMARKER=$'\\e[0;31m+\\e[0m' # Show a red vertical bar if dirty\n            fi\n          fi\n        else\n          if (( IS_DIRECTORY )); then\n            # If the directory isn't ignored or clean, we'll just say it's dirty\n            if command git check-ignore --quiet ${NAME} 2>/dev/null; then STATUS='!!'\n            elif command git diff --stat --quiet --ignore-submodules ${NAME} 2> /dev/null; then STATUS='';\n            else STATUS=' M'\n            fi\n          else\n            # File\n            STATUS=$(command git status --porcelain --ignored --untracked-files=normal $GIT_TOPLEVEL/${${${NAME:a}##$GIT_TOPLEVEL}#*/})\n          fi\n          STATUS=${STATUS[1,2]}\n            if [[ $STATUS == ' M' ]]; then REPOMARKER=$'\\e[0;31m+\\e[0m';     # Tracked & Dirty\n          elif [[ $STATUS == 'M ' ]]; then REPOMARKER=$'\\e[38;5;082m+\\e[0m'; # Tracked & Dirty & Added\n          elif [[ $STATUS == '??' ]]; then REPOMARKER=$'\\e[38;5;214m+\\e[0m'; # Untracked\n          elif [[ $STATUS == '!!' ]]; then REPOMARKER=$'\\e[38;5;238m|\\e[0m'; # Ignored\n          elif [[ $STATUS == 'A ' ]]; then REPOMARKER=$'\\e[38;5;082m+\\e[0m'; # Added\n          else                             REPOMARKER=$'\\e[38;5;082m|\\e[0m'; # Good\n          fi\n        fi\n      fi\n\n      # --------------------------------------------------------------------------\n      # Colour the filename\n      # --------------------------------------------------------------------------\n      # Unfortunately, the choices for quoting which escape ANSI color sequences are q & qqqq; none of q- qq qqq work.\n      # But we don't want to quote '.'; so instead we escape the escape manually and use q-\n      NAME=\"${${NAME##*/}//$'\\e'/\\\\e}\"    # also propagate changes to SYMLINK_TARGET below\n\n      if [[ $IS_DIRECTORY == 1 ]]; then\n        if [[ $IS_WRITABLE_BY_OTHERS == 1 ]]; then\n          if [[ $HAS_STICKY_BIT == 1 ]]; then\n            NAME=$'\\e['\"$K_COLOR_TW\"'m'\"$NAME\"$'\\e[0m';\n          fi\n          NAME=$'\\e['\"$K_COLOR_OW\"'m'\"$NAME\"$'\\e[0m';\n        fi\n        NAME=$'\\e['\"$K_COLOR_DI\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $IS_SYMLINK           == 1 ]]; then NAME=$'\\e['\"$K_COLOR_LN\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $IS_SOCKET            == 1 ]]; then NAME=$'\\e['\"$K_COLOR_SO\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $IS_PIPE              == 1 ]]; then NAME=$'\\e['\"$K_COLOR_PI\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $HAS_UID_BIT          == 1 ]]; then NAME=$'\\e['\"$K_COLOR_SU\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $HAS_GID_BIT          == 1 ]]; then NAME=$'\\e['\"$K_COLOR_SG\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $IS_EXECUTABLE        == 1 ]]; then NAME=$'\\e['\"$K_COLOR_EX\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $IS_BLOCK_SPECIAL     == 1 ]]; then NAME=$'\\e['\"$K_COLOR_BD\"'m'\"$NAME\"$'\\e[0m';\n      elif [[ $IS_CHARACTER_SPECIAL == 1 ]]; then NAME=$'\\e['\"$K_COLOR_CD\"'m'\"$NAME\"$'\\e[0m';\n      fi\n\n      # --------------------------------------------------------------------------\n      # Colour branch\n      # --------------------------------------------------------------------------\n      REPOBRANCH=$'\\e['\"$K_COLOR_BR\"'m'\"$REPOBRANCH\"$'\\e[0m';\n\n      # --------------------------------------------------------------------------\n      # Format symlink target\n      # --------------------------------------------------------------------------\n      if [[ $SYMLINK_TARGET != \"\" ]]; then SYMLINK_TARGET=\" -> ${SYMLINK_TARGET//$'\\e'/\\\\e}\"; fi\n\n      # --------------------------------------------------------------------------\n      # Display final result\n      # --------------------------------------------------------------------------\n      print -r -- \"$PERMISSIONS_OUTPUT $HARDLINKCOUNT $OWNER $GROUP $FILESIZE_OUT $DATE_OUTPUT $REPOMARKER $NAME$SYMLINK_TARGET $REPOBRANCH\"\n\n      k=$((k+1)) # Bump loop index\n    done\n  done\n}\n\n_k_bsd_to_ansi() {\n  local foreground=$1 background=$2 foreground_ansi background_ansi\n  case $foreground in\n    a) foreground_ansi=30;;\n    b) foreground_ansi=31;;\n    c) foreground_ansi=32;;\n    d) foreground_ansi=33;;\n    e) foreground_ansi=34;;\n    f) foreground_ansi=35;;\n    g) foreground_ansi=36;;\n    h) foreground_ansi=37;;\n    x) foreground_ansi=0;;\n  esac\n  case $background in\n    a) background_ansi=40;;\n    b) background_ansi=41;;\n    c) background_ansi=42;;\n    d) background_ansi=43;;\n    e) background_ansi=44;;\n    f) background_ansi=45;;\n    g) background_ansi=46;;\n    h) background_ansi=47;;\n    x) background_ansi=0;;\n  esac\n  printf \"%s;%s\" $background_ansi $foreground_ansi\n}\n\n# http://upload.wikimedia.org/wikipedia/en/1/15/Xterm_256color_chart.svg\n# vim: set ts=2 sw=2 ft=zsh et :\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 3.388671875,
          "content": "[![k.supercrabtree.com](https://raw.githubusercontent.com/supercrabtree/k/gh-pages/k-logo.png)](http://k.supercrabtree.com)\n\n> k is the new l, yo\n\n## Directory listings for zsh with git features\n\n**k** is a zsh script / plugin to make directory listings more readable, adding a bit of color and some git status information on files and directories.\n\n### Git status on entire repos\n![Repository git status](https://raw.githubusercontent.com/supercrabtree/k/gh-pages/repo-dirs.jpg)\n\n\n### Git status on files within a working tree\n![Repository work tree git status](https://raw.githubusercontent.com/supercrabtree/k/gh-pages/inside-work-tree.jpg)\n\n### File weight colours\nFiles sizes are graded from green for small (< 1k), to red for huge (> 1mb).\n\n**Human readable files sizes**  \nHuman readable files sizes can be shown by using the `-h` flag, which requires the `numfmt` command to be available. OS X / Darwin does not have a `numfmt` command by default, so GNU coreutils needs to be installed, which provides `gnumfmt` that `k` will also use if available. GNU coreutils can be installed on OS X with [homebrew](http://brew.sh):\n\n```\nbrew install coreutils\n```\n\n![File weight colours](https://raw.githubusercontent.com/supercrabtree/k/gh-pages/file-size-colors.jpg)\n\n\n### Rotting dates\nDates fade with age.  \n\n![Rotting dates](https://raw.githubusercontent.com/supercrabtree/k/gh-pages/dates.jpg)\n\n\n## Installation\n\n### Using [zplug](https://github.com/b4b4r07/zplug)\nLoad k as a plugin in your `.zshrc`\n\n```shell\nzplug \"supercrabtree/k\"\n\n```\n### Using [zgen](https://github.com/tarjoilija/zgen)\n\nInclude the load command in your `.zshrc`\n\n```shell\nzgen load supercrabtree/k\nzgen save\n```\n\n### Using [Antigen](https://github.com/zsh-users/antigen)\n\nBundle k in your `.zshrc`\n\n```shell\nantigen bundle supercrabtree/k\nantigen apply\n```\n\n### As an [Oh My ZSH!](https://github.com/robbyrussell/oh-my-zsh) custom plugin\n\nClone k into your custom plugins repo\n\n```shell\ngit clone https://github.com/supercrabtree/k $ZSH_CUSTOM/plugins/k\n```\nThen load as a plugin in your `.zshrc`\n\n```shell\nplugins+=(k)\n```\n\n### Manually\nClone this repository somewhere (~/k for example)\n\n```shell\ngit clone git@github.com:supercrabtree/k.git $HOME/k\n```\nSource the script\n\n```shell\nsource $HOME/k/k.sh\n```\nPut the same line in your `.zshrc` to have `k` available whenever you start a shell. If you don't know what your `.zshrc` is, just do this.\n\n```shell\nprint \"source $HOME/k/k.sh\" >> $HOME/.zshrc\n```\n\n## Usage\nHit k in your shell\n\n```shell\nk\n```\n# 😮\n\n## Minimum Requirements\nzsh 4.3.11  \nGit 1.7.2\n\n## Contributors\n[supercrabtree](https://github.com/supercrabtree)  \n[chrstphrknwtn](https://github.com/chrstphrknwtn)  \n[zirrostig](https://github.com/zirrostig)  \n[lejeunerenard](https://github.com/lejeunerenard)  \n[jozefizso](https://github.com/jozefizso)  \n[unixorn](https://github.com/unixorn)  \n[george-b](https://github.com/george-b)  \n[philpennock](https://github.com/philpennock)  \n[hoelzro](https://github.com/hoelzro)  \n[srijanshetty](https://github.com/srijanshetty)  \n[zblach](https://github.com/zblach)  \n[mattboll](https://github.com/mattboll)  \nPull requests welcome :smile:  \n\n## Thanks\n[Paul Falstad](http://www.falstad.com/) for zsh   \n[Sindre Sorhus](https://github.com/sindresorhus) for the fast git commands from zsh pure theme  \n[Rupa](https://github.com/rupa/z) for that slammin' strapline  \n\nCopyright © 2015 George Crabtree & Christopher Newton. MIT License.\n"
        }
      ]
    }
  ]
}