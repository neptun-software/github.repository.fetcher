{
  "metadata": {
    "timestamp": 1736568318224,
    "page": 236,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "multiarch/qemu-user-static",
      "stars": 2501,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1650390625,
          "content": "*.swp\n*~\n# Ignore generated files\n/containers/latest/qemu-*-static\n/containers/register/Dockerfile\n/containers/register/register.sh\n/containers/x86_64_qemu-*/\n/releases\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.826171875,
          "content": "# Contributing to multiarch/qemu-user-static\n\nYour contributions such as reporting a bug and sending pull-request are very wellcome! Thank you.\n\n## Did you find a bug?\n\n* Ensure the bug was not already reported by searching on GitHub under Issues.\n* multiarch/qemu-user-static is a collection of containers to enable people to emulate multi-architecture containers by using qemu-user-static (= a collection of QEMU's user mode static binaries `qemu-$arch-static`) [1] and binfmt_misc [2]. This repository is not QEMU project's one. If you find a bug about them, you can visit the website [1][2] to report an issue on the projects.\n\n## How to send pull-request\n\n1. Fork the repository: https://github.com/multiarch/qemu-user-static . Ex. https://github.com/junaruga/qemu-user-static\n2. This repository is using Github Actions. You can test your modified code on your forked repository before sending a pull-requeste.\n3. If you want to test pushing created container images,\n    * You need to have your own container repository such as DockerHub or Quay.io. Ex. https://quay.io/repository/junaruga/qemu-user-static\n    * You need to set environment variables `DOCKER_USERNAME` and `DOCKER_PASSWORD` on your repository's Settings page. Please remember it is better to set `DOCKER_PASSWORD` without displaying the value for your security.\n4. You also need to have your https://quay.io/repository/junaruga/qemu-user-static\n5. You need to edit `.github/workflows/actions.yml` with your container repository. This step can be improved in the future.\n6. Below is an example of how to test with your container repository.\n7. Check Github Actions's log, and ensure the container images are created.\n8. You are ready to send the pull-request!\n\n## References\n\n* [1] QEMU: https://www.qemu.org/\n* [2] binfmt-misc: https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.060546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2016 Manfred Touron\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.8515625,
          "content": "# qemu-user-static\n\n[![License](https://img.shields.io/github/license/multiarch/qemu-user-static.svg?style=flat-square)](./LICENSE) ![actions](https://github.com/multiarch/qemu-user-static/workflows/actions/badge.svg) [![Releases](https://img.shields.io/github/commits-since/multiarch/qemu-user-static/latest.svg?style=flat-square)](https://github.com/multiarch/qemu-user-static/releases) [![Docker Hub](https://img.shields.io/docker/pulls/multiarch/qemu-user-static.svg?style=flat-square)](https://hub.docker.com/r/multiarch/qemu-user-static/)\n\n![](https://raw.githubusercontent.com/multiarch/dockerfile/master/logo.jpg)\n\n**multiarch/qemu-user-static** is to enable an execution of different multi-architecture containers by QEMU [<sup>1</sup>](#ref-1) and binfmt_misc [<sup>2</sup>](#ref-2).\nHere are examples with Docker [<sup>3</sup>](#ref-3).\n\n## Getting started\n\n```\n$ uname -m\nx86_64\n\n$ docker run --rm -t arm64v8/ubuntu uname -m\nstandard_init_linux.go:211: exec user process caused \"exec format error\"\n\n$ docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n\n$ docker run --rm -t arm64v8/ubuntu uname -m\naarch64\n```\n\nIt works on many architectures and OS container images.\n\n```\n$ docker run --rm -t arm32v6/alpine uname -m\narmv7l\n\n$ docker run --rm -t ppc64le/debian uname -m\nppc64le\n\n$ docker run --rm -t s390x/ubuntu uname -m\ns390x\n\n$ docker run --rm -t arm64v8/fedora uname -m\naarch64\n\n$ docker run --rm -t arm32v7/centos uname -m\narmv7l\n\n$ docker run --rm -t ppc64le/busybox uname -m\nppc64le\n\n$ docker run --rm -t i386/ubuntu uname -m\nx86_64\n```\n\nPodman [<sup>4</sup>](#ref-4) also works.\n\n```\n$ sudo podman run --rm --privileged multiarch/qemu-user-static --reset -p yes\n\n$ podman run --rm -t arm64v8/fedora uname -m\naarch64\n```\n\nSingularity [<sup>5</sup>](#ref-5) also works.\n\n```\n$ sudo singularity run docker://multiarch/qemu-user-static --reset -p yes\n\n$ singularity run --cleanenv docker://arm64v8/fedora uname -m\naarch64\n```\n\n## Usage\n\n### multiarch/qemu-user-static images\n\nmultiarch/qemu-user-static images are managed on the [Docker Hub](https://hub.docker.com/r/multiarch/qemu-user-static/) container repository.\nThe images have below tags.\n\n**Images**\n\n1. `multiarch/qemu-user-static` image\n2. `multiarch/qemu-user-static:$version` images\n3. `multiarch/qemu-user-static:$from_arch-$to_arch` images\n4. `multiarch/qemu-user-static:$from_arch-$to_arch-$version` images\n5. `multiarch/qemu-user-static:$to_arch` images\n6. `multiarch/qemu-user-static:$to_arch-$version` images\n7. `multiarch/qemu-user-static:register` image\n\n**Variables**\n\n* `$version`: Based QEMU's version.\n* `$from_arch`: Host architecture\n* `$to_arch`: Guest architecture\n\n**Description**\n\n* `multiarch/qemu-user-static` image container includes both a register script to register binfmt_misc entries and all the `/usr/bin/qemu-$arch-static` binary files in the container in it. `multiarch/qemu-user-static` image is an alias of the latest version of `multiarch/qemu-user-static:$version` images.\n* `multiarch/qemu-user-static:$to_arch` images are aliases of `multiarch/qemu-user-static:x86_64-$to_arch`. `multiarch/qemu-user-static:$to_arch` images only include the `$to_arch`'s `/usr/bin/qemu-$to_arch-static` binary file in it. `multiarch/qemu-user-static:$to_arch` image is an alias of the latest version of `multiarch/qemu-user-static:$to_arch-$version` images.\n* `multiarch/qemu-user-static:register` image has only the register script binfmt_misc entries.\n\n`multiarch/qemu-user-static` and `multiarch/qemu-user-static:register` images execute the register script that registers below kind of `/proc/sys/fs/binfmt_misc/qemu-$arch` files for all supported processors except the current one in it when running the container. See binfmt_misc manual [2] for detail of the files.\nAs the `/proc/sys/fs/binfmt_misc` are common between host and inside of container, the register script modifies the file on host.\n\n```\n$ cat /proc/sys/fs/binfmt_misc/qemu-$arch\nenabled\ninterpreter /usr/bin/qemu-$arch-static\nflags: F\noffset 0\nmagic 7f454c460201010000000000000000000200b700\nmask ffffffffffffff00fffffffffffffffffeffffff\n```\n\nThe `--reset` option is implemented at the register script that executes `find /proc/sys/fs/binfmt_misc -type f -name 'qemu-*' -exec sh -c 'echo -1 > {}' \\;` to remove binfmt_misc entry files before register the entry.\nWhen same name's file `/proc/sys/fs/binfmt_misc/qemu-$arch` exists, the register command is failed with an error message \"sh: write error: File exists\".\n\n```\n$ docker run --rm --privileged multiarch/qemu-user-static [--reset][--help][-p yes][options]\n```\n\nOn below image, we can not specify `-p yes` (`--persistent yes`) option. Because an interpreter's existance is checked when registering a binfmt_misc entry. As the interpreter does not exist in the container, the register script finishes with an error.\n\n```\n$ docker run --rm --privileged multiarch/qemu-user-static:register [--reset][--help][options]\n```\n\nThen the register script executes QEMU's [scripts/qemu-binfmt-conf.sh](https://github.com/qemu/qemu/blob/master/scripts/qemu-binfmt-conf.sh) script with options.\nYou can check `usage()` in the file about the options.\n\n```\nUsage: qemu-binfmt-conf.sh [--qemu-path PATH][--debian][--systemd CPU]\n                           [--help][--credential yes|no][--exportdir PATH]\n                           [--persistent yes|no][--qemu-suffix SUFFIX]\n       Configure binfmt_misc to use qemu interpreter\n       --help:        display this usage\n       --qemu-path:   set path to qemu interpreter ($QEMU_PATH)\n       --qemu-suffix: add a suffix to the default interpreter name\n       --debian:      don't write into /proc,\n                      instead generate update-binfmts templates\n       --systemd:     don't write into /proc,\n                      instead generate file for systemd-binfmt.service\n                      for the given CPU. If CPU is \"ALL\", generate a\n                      file for all known cpus\n       --exportdir:   define where to write configuration files\n                      (default: $SYSTEMDDIR or $DEBIANDIR)\n       --credential:  if yes, credential and security tokens are\n                      calculated according to the binary to interpret\n       --persistent:  if yes, the interpreter is loaded when binfmt is\n                      configured and remains in memory. All future uses\n                      are cloned from the open file.\n```\n\nYou can run `/usr/bin/qemu-$arch-static` binary file` in the container.\n\n```\n$ docker run --rm -t multiarch/qemu-user-static:x86_64-aarch64 /usr/bin/qemu-aarch64-static -help\nusage: qemu-aarch64 [options] program [arguments...]\nLinux CPU emulator (compiled for aarch64 emulation)\n...\n\n$ docker run --rm -t multiarch/qemu-user-static:x86_64-aarch64 /usr/bin/qemu-aarch64-static -version\nqemu-aarch64 version 4.0.0 (qemu-4.0.0-5.fc31)\nCopyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers\n\n\n$ docker run --rm -t multiarch/qemu-user-static:aarch64 /usr/bin/qemu-aarch64-static -help\nusage: qemu-aarch64 [options] program [arguments...]\nLinux CPU emulator (compiled for aarch64 emulation)\n...\n\n$ docker run --rm -t multiarch/qemu-user-static:aarch64 /usr/bin/qemu-aarch64-static -version\nqemu-aarch64 version 4.0.0 (qemu-4.0.0-5.fc31)\nCopyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers\n```\n\n`multiarch/qemu-user-static:$from_arch-$to_arch` images are used with `multiarch/qemu-user-static:register` image.\nBecause when the binfmt_misc entry is registered without `-p` option, the interpreter needs to be put in the container.\n\n```\n$ docker run --rm --privileged multiarch/qemu-user-static:register --reset\n\n$ docker build --rm -t \"test/integration/ubuntu\" -<<EOF\nFROM multiarch/qemu-user-static:x86_64-aarch64 as qemu\nFROM arm64v8/ubuntu\nCOPY --from=qemu /usr/bin/qemu-aarch64-static /usr/bin\nEOF\n\n$ docker run --rm -t \"test/integration/ubuntu\" uname -m\naarch64\n```\n\nIf you have `qemu-$arch-static` binary files on your local environment, you can set it to the container by `docker -v` volume mounted file.\n\n```\n$ docker run --rm --privileged multiarch/qemu-user-static:register --reset\n\n$ docker run --rm -t arm64v8/ubuntu uname -m\nstandard_init_linux.go:211: exec user process caused \"no such file or directory\"\n\n$ docker run --rm -t -v /usr/bin/qemu-aarch64-static:/usr/bin/qemu-aarch64-static arm64v8/ubuntu uname -m\naarch64\n```\n\n### multiarch compatible images [DEPRECATED]\n\nThe concept of \"compatible images\" are deprecated because **multiarch/qemu-user-static** can build and run standard multi-architecture container images without the multiarch compatible images now. But you can refer the document [Compatible images](docs/compatible_images.md).\n\nThe compatible image is the one to add `/usr/bin/qemu-$arch-static` binary inside of the container based on the standard arch specific container.\nLast time, we could not register binfmt_misc entry with `flags: F` (persistent option).\nWhen `flags: F` was not set, the interpreter always needed to be existed inside of the container to run the arch container.\n\n## Contributing\n\nWe encourage you to contribute to **multiarch/qemu-user-static**! Please check out the [Contributing to multiarch/qemu-user-static guide](CONTRIBUTING.md) for guidelines about how to proceed.\n\nSee [Developers guide](docs/developers_guide.md) for detail.\n\n## Supported host architectures\n\n* x86_64\n\nCurrently qemu-user-static is not available on other host architectures such as aarch64.\nRun `uname -m` to check it on your environment.\n\n## Examples & articles\n\nPlease note that some examples using compatible images are deprecated.\n\nSee [Examples & articles](docs/examples.md).\n\n## References\n\n* <a id=\"ref-1\" href=\"#ref-1\">[1]</a> QEMU: https://www.qemu.org/\n* <a id=\"ref-2\" href=\"#ref-2\">[2]</a> binfmt_misc: https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html\n* <a id=\"ref-3\" href=\"#ref-3\">[3]</a> Docker: https://www.docker.com/\n* <a id=\"ref-4\" href=\"#ref-4\">[4]</a> Podman: https://podman.io/\n* <a id=\"ref-5\" href=\"#ref-5\">[5]</a> Singularity: https://sylabs.io/singularity/\n"
        },
        {
          "name": "containers",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "run.sh",
          "type": "blob",
          "size": 2.1650390625,
          "content": "#!/bin/bash\nset -xe\n\n# A POSIX variable\nOPTIND=1 # Reset in case getopts has been used previously in the shell.\n\nwhile getopts \"r:t:d:\" opt; do\n    case \"$opt\" in\n        r)  REPO=$OPTARG\n        ;;\n        t)  TAG_VER=$OPTARG\n        ;;\n        d)  DOCKER_REPO=$OPTARG\n        ;;\n    esac\ndone\n\nshift $((OPTIND-1))\n\n[ \"$1\" = \"--\" ] && shift\n\n# Build container images creating the directory.\n# containers/\n#   latest/ - An image including /usr/bin/qemu-$arch-status and /register script.\n#   ${from_arch}_qemu-${to_arch}/ - Images including /usr/bin/qemu-$arch-status\n#   register/ - An image including /register script.\n\nfrom_arch=\"x86_64\"\nroot_dir=$(pwd)\nout_dir=\"containers\"\nreleases_dir=\"releases/usr/bin/\"\n\ncd ${releases_dir}\nfor file in *; do\n    tar -czf $file.tar.gz $file;\n    cp $file.tar.gz x86_64_$file.tar.gz\ndone\ncd ${root_dir}\n\n# Generate register files.\ncp -p \"${out_dir}/latest/register.sh\" \"${out_dir}/register/\"\ncp -p \"${out_dir}/latest/Dockerfile\" \"${out_dir}/register/\"\n# Comment out the line to copy qemu-*-static not to provide those.\nsed -i '/^COPY qemu/ s/^/#/' \"${out_dir}/register/Dockerfile\"\n\nfor file in ${releases_dir}*\ndo\n    if [[ $file =~ qemu-(.+)-static ]]; then\n        to_arch=${BASH_REMATCH[1]}\n        if [ \"$from_arch\" != \"$to_arch\" ]; then\n            work_dir=\"${out_dir}/${from_arch}_qemu-${to_arch}\"\n            mkdir -p \"${work_dir}\"\n            cp -p \"${releases_dir}qemu-${to_arch}-static\" ${work_dir}\n            cp -p \"${work_dir}/qemu-${to_arch}-static\" \"${out_dir}/latest/\"\n            cat > ${work_dir}/Dockerfile -<<EOF\nFROM scratch\nCOPY qemu-${to_arch}-static /usr/bin/\nEOF\n            docker build -t ${DOCKER_REPO}:$from_arch-$to_arch-${TAG_VER} ${work_dir}\n            for target in  \"${DOCKER_REPO}:$from_arch-$to_arch\" \\\n                \"${DOCKER_REPO}:$to_arch-${TAG_VER}\" \\\n                \"${DOCKER_REPO}:$to_arch\" ; do\n                docker tag ${DOCKER_REPO}:$from_arch-$to_arch-${TAG_VER} ${target}\n            done\n            rm -rf \"${work_dir}\"\n        fi\n    fi\ndone\n\ndocker build -t ${DOCKER_REPO}:${TAG_VER} ${out_dir}/latest\ndocker tag ${DOCKER_REPO}:${TAG_VER} ${DOCKER_REPO}:latest\ndocker build -t ${DOCKER_REPO}:register ${out_dir}/register"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 2.212890625,
          "content": "#!/bin/bash\nset -xeo pipefail\n\n# A POSIX variable\nOPTIND=1 # Reset in case getopts has been used previously in the shell.\n\nwhile getopts \"d:\" opt; do\n    case \"$opt\" in\n        d)  DOCKER_REPO=$OPTARG\n        ;;\n    esac\ndone\n\nif [ \"${DOCKER_REPO}\" = \"\" ]; then\n    echo \"DOCKER_REPO is required.\" 1>&2\n    exit 1\nfi\n\n# Test cases\n\n# ------------------------------------------------\n# multiarch/qemu-user-static image\n\n# It should register binfmt_misc entry with 'flags: F'\n# by given \"-p yes\" option.\ndocker run --rm --privileged ${DOCKER_REPO} --reset -p yes\ncat /proc/sys/fs/binfmt_misc/qemu-aarch64\ngrep -q '^flags: F$' /proc/sys/fs/binfmt_misc/qemu-aarch64\n\n# It should output the result of \"uname -m\".\ndocker pull arm64v8/ubuntu\ndocker run --rm -t arm64v8/ubuntu uname -m\n# It should install a package.\ndocker build --rm -t \"test/latest/ubuntu\" -<<EOF\nFROM arm64v8/ubuntu\nRUN apt-get update && \\\n    apt-get -y install gcc\nEOF\n\n# It should output the result of \"uname -m\".\ndocker pull arm64v8/fedora\ndocker run --rm -t arm64v8/fedora uname -m\n# It should install a package.\n# TODO: Comment out as it takes a time.\n# docker build --rm -t \"test/latest/fedora\" -<<EOF\n# FROM arm64v8/fedora\n# RUN dnf -y upgrade && \\\n#     dnf -y install gcc\n# EOF\n\n# ------------------------------------------------\n# multiarch/qemu-user-static:register image\n\n# It should register binfmt_misc entry with 'flags: '\n# by given no \"-p yes\" option.\ndocker run --rm --privileged ${DOCKER_REPO}:register --reset\ncat /proc/sys/fs/binfmt_misc/qemu-aarch64\ngrep -q '^flags: $' /proc/sys/fs/binfmt_misc/qemu-aarch64\n\n# ------------------------------------------------\n# multiarch/qemu-user-static:$to_arch image\n# multiarch/qemu-user-static:$from_arch-$to_arch image\n\n# /usr/bin/qemu-aarch64-static should be included.\ndocker run --rm -t ${DOCKER_REPO}:aarch64 /usr/bin/qemu-aarch64-static --version\ndocker run --rm -t ${DOCKER_REPO}:x86_64-aarch64 /usr/bin/qemu-aarch64-static --version\n\n# ------------------------------------------------\n# Integration test\ndocker build --rm -t \"test/integration/ubuntu\" -<<EOF\nFROM ${DOCKER_REPO}:x86_64-aarch64 as qemu\nFROM arm64v8/ubuntu\nCOPY --from=qemu /usr/bin/qemu-aarch64-static /usr/bin\nEOF\ndocker run --rm -t \"test/integration/ubuntu\" uname -m\n"
        }
      ]
    }
  ]
}