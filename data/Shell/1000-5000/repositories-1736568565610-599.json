{
  "metadata": {
    "timestamp": 1736568565610,
    "page": 599,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "avleen/bashttpd",
      "stars": 1514,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "Copyright (C) 2012, Avleen Vig <avleen@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.873046875,
          "content": "bashttpd is a simple, configurable web server written in bash\n\nRequirements\n-------------\n\n  1. `bash`, any recent version should work\n  2. `socat` or `netcat` to handle the underlying sockets. \n  3. A healthy dose of insanity\n\nExamples\n---------\n\n      socat TCP4-LISTEN:8080 EXEC:/usr/local/bin/bashttpd\n\nOr\n\n      netcat -lp 8080 -e ./bashttpd\n\nNote that in the `socat` example above, the web server will immediately exit once the first connection closes. If you wish to serve to more than one client - like most servers do, then use the variant:\n\n     socat TCP4-LISTEN:8080,fork EXEC:/usr/local/bin/bashttpd\n\nThis way, a new process is spawned for each incoming connection.\n\n\nGetting started\n----------------\n\n  1. Running bashttpd for the first time will generate a default configuration file, bashttpd.conf\n  2. Review bashttpd.conf and configure it as you want.\n  3. Run bashttpd using netcat or socat, as listed above.\n\nFeatures\n---------\n\n  1. Serves text and HTML files\n  2. Shows directory listings\n  3. Allows for configuration based on the client-specified URI\n\nLimitations\n------------\n\n  1. Does not support authentication\n  2. Doesn't strictly adhere to the HTTP spec.\n\nSecurity\n--------\n\n  1. Only rudimentary input handling.  We would not running this on a public machine.\n\nHTTP protocol support\n---------------------\n\n  403: Returned when a directory is not listable, or a file is not readable\n  400: Returned when the first word of the first line is not `GET`\n  200: Returned with valid content\n  Content-type: Bashttpd uses /usr/bin/file to determine the MIME type to sent to the browser\n  1.0: The server doesn't support Host: headers or other HTTP/1.1 features - it barely supports HTTP/1.0!\n\nAs always, your patches/pull requests are welcome!\n\nTestimonials\n------------\n\n\"If anyone installs that anywhere, they might meet a gruesome end with a rusty fork\"\n    --- BasHTTPd creator, maintainer\n"
        },
        {
          "name": "bashttpd",
          "type": "blob",
          "size": 7.05078125,
          "content": "#!/usr/bin/env bash\n#\n# A simple, configurable HTTP server written in bash.\n#\n# See LICENSE for licensing information.\n#\n# Original author: Avleen Vig, 2012\n# Reworked by:     Josh Cartwright, 2012\n\nwarn() { echo \"WARNING: $@\" >&2; }\n\n[ -r bashttpd.conf ] || {\n   cat >bashttpd.conf <<'EOF'\n#\n# bashttpd.conf - configuration for bashttpd\n#\n# The behavior of bashttpd is dictated by the evaluation\n# of rules specified in this configuration file.  Each rule\n# is evaluated until one is matched.  If no rule is matched,\n# bashttpd will serve a 500 Internal Server Error.\n#\n# The format of the rules are:\n#    on_uri_match REGEX command [args]\n#    unconditionally command [args]\n#\n# on_uri_match:\n#   On an incoming request, the URI is checked against the specified\n#   (bash-supported extended) regular expression, and if encounters a match the\n#   specified command is executed with the specified arguments.\n#\n#   For additional flexibility, on_uri_match will also pass the results of the\n#   regular expression match, ${BASH_REMATCH[@]} as additional arguments to the\n#   command.\n#\n# unconditionally:\n#   Always serve via the specified command.  Useful for catchall rules.\n#\n# The following commands are available for use:\n#\n#   serve_file FILE\n#     Statically serves a single file.\n#\n#   serve_dir_with_tree DIRECTORY\n#     Statically serves the specified directory using 'tree'.  It must be\n#     installed and in the PATH.\n#\n#   serve_dir_with_ls DIRECTORY\n#     Statically serves the specified directory using 'ls -al'.\n#\n#   serve_dir  DIRECTORY\n#     Statically serves a single directory listing.  Will use 'tree' if it is\n#     installed and in the PATH, otherwise, 'ls -al'\n#\n#   serve_dir_or_file_from DIRECTORY\n#     Serves either a directory listing (using serve_dir) or a file (using\n#     serve_file).  Constructs local path by appending the specified root\n#     directory, and the URI portion of the client request.\n#\n#   serve_static_string STRING\n#     Serves the specified static string with Content-Type text/plain.\n#\n# Examples of rules:\n#\n# on_uri_match '^/issue$' serve_file \"/etc/issue\"\n#\n#   When a client's requested URI matches the string '/issue', serve them the\n#   contents of /etc/issue\n#\n# on_uri_match 'root' serve_dir /\n#\n#   When a client's requested URI has the word 'root' in it, serve up\n#   a directory listing of /\n#\n# DOCROOT=/var/www/html\n# on_uri_match '/(.*)' serve_dir_or_file_from \"$DOCROOT\"\n#   When any URI request is made, attempt to serve a directory listing\n#   or file content based on the request URI, by mapping URI's to local\n#   paths relative to the specified \"$DOCROOT\"\n#\n\nunconditionally serve_static_string 'Hello, world!  You can configure bashttpd by modifying bashttpd.conf.'\n\n# More about commands:\n#\n# It is possible to somewhat easily write your own commands.  An example\n# may help.  The following example will serve \"Hello, $x!\" whenever\n# a client sends a request with the URI /say_hello_to/$x:\n#\n# serve_hello() {\n#    add_response_header \"Content-Type\" \"text/plain\"\n#    send_response_ok_exit <<< \"Hello, $2!\"\n# }\n# on_uri_match '^/say_hello_to/(.*)$' serve_hello\n#\n# Like mentioned before, the contents of ${BASH_REMATCH[@]} are passed\n# to your command, so its possible to use regular expression groups\n# to pull out info.\n#\n# With this example, when the requested URI is /say_hello_to/Josh, serve_hello\n# is invoked with the arguments '/say_hello_to/Josh' 'Josh',\n# (${BASH_REMATCH[0]} is always the full match)\nEOF\n   warn \"Created bashttpd.conf using defaults.  Please review it/configure before running bashttpd again.\"\n   exit 1\n}\n\nrecv() { echo \"< $@\" >&2; }\nsend() { echo \"> $@\" >&2;\n         printf '%s\\r\\n' \"$*\"; }\n\n[[ $UID = 0 ]] && warn \"It is not recommended to run bashttpd as root.\"\n\nDATE=$(date +\"%a, %d %b %Y %H:%M:%S %Z\")\ndeclare -a RESPONSE_HEADERS=(\n      \"Date: $DATE\"\n   \"Expires: $DATE\"\n    \"Server: Slash Bin Slash Bash\"\n)\n\nadd_response_header() {\n   RESPONSE_HEADERS+=(\"$1: $2\")\n}\n\ndeclare -a HTTP_RESPONSE=(\n   [200]=\"OK\"\n   [400]=\"Bad Request\"\n   [403]=\"Forbidden\"\n   [404]=\"Not Found\"\n   [405]=\"Method Not Allowed\"\n   [500]=\"Internal Server Error\"\n)\n\nsend_response() {\n   local code=$1\n   send \"HTTP/1.0 $1 ${HTTP_RESPONSE[$1]}\"\n   for i in \"${RESPONSE_HEADERS[@]}\"; do\n      send \"$i\"\n   done\n   send\n   while read -r line; do\n      send \"$line\"\n   done\n}\n\nsend_response_ok_exit() { send_response 200; exit 0; }\n\nfail_with() {\n   send_response \"$1\" <<< \"$1 ${HTTP_RESPONSE[$1]}\"\n   exit 1\n}\n\nserve_file() {\n   local file=$1\n\n   CONTENT_TYPE=\n   case \"$file\" in\n     *\\.css)\n       CONTENT_TYPE=\"text/css\"\n       ;;\n     *\\.js)\n       CONTENT_TYPE=\"text/javascript\"\n       ;;\n     *)\n       read -r CONTENT_TYPE   < <(file -b --mime-type \"$file\")\n       ;;\n   esac\n\n   add_response_header \"Content-Type\"   \"$CONTENT_TYPE\";\n\n   read -r CONTENT_LENGTH < <(stat -c'%s' \"$file\")         && \\\n      add_response_header \"Content-Length\" \"$CONTENT_LENGTH\"\n\n   send_response_ok_exit < \"$file\"\n}\n\nserve_dir_with_tree()\n{\n   local dir=\"$1\" tree_vers tree_opts basehref x\n\n   add_response_header \"Content-Type\" \"text/html\"\n\n   # The --du option was added in 1.6.0.\n   read x tree_vers x < <(tree --version)\n   [[ $tree_vers == v1.6* ]] && tree_opts=\"--du\"\n\n   send_response_ok_exit < \\\n      <(tree -H \"$2\" -L 1 \"$tree_opts\" -D \"$dir\")\n}\n\nserve_dir_with_ls()\n{\n   local dir=$1\n\n   add_response_header \"Content-Type\" \"text/plain\"\n\n   send_response_ok_exit < \\\n      <(ls -la \"$dir\")\n}\n\nserve_dir() {\n   local dir=$1\n\n   # If `tree` is installed, use that for pretty output.\n   which tree &>/dev/null && \\\n      serve_dir_with_tree \"$@\"\n\n   serve_dir_with_ls \"$@\"\n\n   fail_with 500\n}\n\nserve_dir_or_file_from() {\n   local URL_PATH=$1/$3\n   shift\n\n   # sanitize URL_PATH\n   URL_PATH=${URL_PATH//[^a-zA-Z0-9_~\\-\\.\\/]/}\n   [[ $URL_PATH == *..* ]] && fail_with 400\n\n   # Serve index file if exists in requested directory\n   [[ -d $URL_PATH && -f $URL_PATH/index.html && -r $URL_PATH/index.html ]] && \\\n      URL_PATH=\"$URL_PATH/index.html\"\n\n   if [[ -f $URL_PATH ]]; then\n      [[ -r $URL_PATH ]] && \\\n         serve_file \"$URL_PATH\" \"$@\" || fail_with 403\n   elif [[ -d $URL_PATH ]]; then\n      [[ -x $URL_PATH ]] && \\\n         serve_dir  \"$URL_PATH\" \"$@\" || fail_with 403\n   fi\n\n   fail_with 404\n}\n\nserve_static_string() {\n   add_response_header \"Content-Type\" \"text/plain\"\n   send_response_ok_exit <<< \"$1\"\n}\n\non_uri_match() {\n   local regex=$1\n   shift\n\n   [[ $REQUEST_URI =~ $regex ]] && \\\n      \"$@\" \"${BASH_REMATCH[@]}\"\n}\n\nunconditionally() {\n   \"$@\" \"$REQUEST_URI\"\n}\n\n# Request-Line HTTP RFC 2616 $5.1\nread -r line || fail_with 400\n\n# strip trailing CR if it exists\nline=${line%%$'\\r'}\nrecv \"$line\"\n\nread -r REQUEST_METHOD REQUEST_URI REQUEST_HTTP_VERSION <<<\"$line\"\n\n[ -n \"$REQUEST_METHOD\" ] && \\\n[ -n \"$REQUEST_URI\" ] && \\\n[ -n \"$REQUEST_HTTP_VERSION\" ] \\\n   || fail_with 400\n\n# Only GET is supported at this time\n[ \"$REQUEST_METHOD\" = \"GET\" ] || fail_with 405\n\ndeclare -a REQUEST_HEADERS\n\nwhile read -r line; do\n   line=${line%%$'\\r'}\n   recv \"$line\"\n\n   # If we've reached the end of the headers, break.\n   [ -z \"$line\" ] && break\n\n   REQUEST_HEADERS+=(\"$line\")\ndone\n\nsource \"${BASH_SOURCE[0]%/*}\"/bashttpd.conf\nfail_with 500\n"
        }
      ]
    }
  ]
}