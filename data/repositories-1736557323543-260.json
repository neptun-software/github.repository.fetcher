{
  "metadata": {
    "timestamp": 1736557323543,
    "page": 260,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "golang-standards/project-layout",
      "stars": 50340,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.37,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[{*.go,Makefile,.gitmodules,go.mod,go.sum}]\nindent_style = tab\n\n[*.md]\nindent_style = tab\ntrim_trailing_whitespace = false\n\n[*.{yml,yaml,json}]\nindent_style = space\nindent_size = 2\n\n[*.{js,jsx,ts,tsx,css,less,sass,scss,vue,py}]\nindent_style = space\nindent_size = 4\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01,
          "content": "* -text\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.38,
          "content": "# Mac OS X files\n.DS_Store\n\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 0.02,
          "content": "Hacker license!\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.03,
          "content": "# note: call scripts from /scripts\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.6,
          "content": "# Standard Go Project Layout\n\nTranslations:\n\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Português](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Tiếng Việt](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [فارسی](README_fa.md)\n* [Беларуская](README_by.md)\n\n## Overview\n\nThis is a basic layout for Go application projects. Note that it's basic in terms of content because it's focusing only on the general layout and not what you have inside. It's also basic because it's very high level and it doesn't go into great details in terms of how you can structure your project even further. For example, it doesn't try to cover the project structure you'd have with something like Clean Architecture.\n\nThis is **`NOT an official standard defined by the core Go dev team`**. This is a set of common historical and emerging project layout patterns in the Go ecosystem. Some of these patterns are more popular than others. It also has a number of small enhancements along with several supporting directories common to any large enough real world application. Note that the **core Go team provides a great set of general guidelines about structuring Go projects** and what it means for your project when it's imported and when it's installed. See the [`Organizing a Go module`](https://go.dev/doc/modules/layout) page in the official Go docs for more details. It includes the `internal` and `cmd` directory patterns (described below) and other useful information.\n\n**`If you are trying to learn Go or if you are building a PoC or a simple project for yourself this project layout is an overkill. Start with something really simple instead (a single `main.go` file and `go.mod` is more than enough).`** As your project grows keep in mind that it'll be important to make sure your code is well structured otherwise you'll end up with a messy code with lots of hidden dependencies and global state. When you have more people working on the project you'll need even more structure. That's when it's important to introduce a common way to manage packages/libraries. When you have an open source project or when you know other projects import the code from your project repository that's when it's important to have private (aka `internal`) packages and code. Clone the repository, keep what you need and delete everything else! Just because it's there it doesn't mean you have to use it all. None of these patterns are used in every single project. Even the `vendor` pattern is not universal.\n\nWith Go 1.14 [`Go Modules`](https://go.dev/wiki/Modules) are finally ready for production. Use [`Go Modules`](https://blog.golang.org/using-go-modules) unless you have a specific reason not to use them and if you do then you don’t need to worry about $GOPATH and where you put your project. The basic `go.mod` file in the repo assumes your project is hosted on GitHub, but it's not a requirement. The module path can be anything though the first module path component should have a dot in its name (the current version of Go doesn't enforce it anymore, but if you are using slightly older versions don't be surprised if your builds fail without it). See Issues [`37554`](https://github.com/golang/go/issues/37554) and [`32819`](https://github.com/golang/go/issues/32819) if you want to know more about it.\n\nThis project layout is intentionally generic and it doesn't try to impose a specific Go package structure.\n\nThis is a community effort. Open an issue if you see a new pattern or if you think one of the existing patterns needs to be updated.\n\nIf you need help with naming, formatting and style start by running [`gofmt`](https://golang.org/cmd/gofmt/) and [`staticcheck`](https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck). The previous standard linter, golint, is now deprecated and not maintained; use of a maintained linter such as staticcheck is recommended. Also make sure to read these Go code style guidelines and recommendations:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nSee [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) for additional background information.\n\nMore about naming and organizing packages as well as other code structure recommendations:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nA Chinese post about Package-Oriented-Design guidelines and Architecture layer\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go Directories\n\n### `/cmd`\n\nMain applications for this project.\n\nThe directory name for each application should match the name of the executable you want to have (e.g., `/cmd/myapp`).\n\nDon't put a lot of code in the application directory. If you think the code can be imported and used in other projects, then it should live in the `/pkg` directory. If the code is not reusable or if you don't want others to reuse it, put that code in the `/internal` directory. You'll be surprised what others will do, so be explicit about your intentions!\n\nIt's common to have a small `main` function that imports and invokes the code from the `/internal` and `/pkg` directories and nothing else.\n\nSee the [`/cmd`](cmd/README.md) directory for examples.\n\n### `/internal`\n\nPrivate application and library code. This is the code you don't want others importing in their applications or libraries. Note that this layout pattern is enforced by the Go compiler itself. See the Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) for more details. Note that you are not limited to the top level `internal` directory. You can have more than one `internal` directory at any level of your project tree.\n\nYou can optionally add a bit of extra structure to your internal packages to separate your shared and non-shared internal code. It's not required (especially for smaller projects), but it's nice to have visual clues showing the intended package use. Your actual application code can go in the `/internal/app` directory (e.g., `/internal/app/myapp`) and the code shared by those apps in the `/internal/pkg` directory (e.g., `/internal/pkg/myprivlib`).\n\nYou use internal directories to make packages private. If you put a package inside an internal directory, then other packages can’t import it unless they share a common ancestor. And it’s the only directory named in Go’s documentation and has special compiler treatment.\n\n### `/pkg`\n\nLibrary code that's ok to use by external applications (e.g., `/pkg/mypubliclib`). Other projects will import these libraries expecting them to work, so think twice before you put something here :-) Note that the `internal` directory is a better way to ensure your private packages are not importable because it's enforced by Go. The `/pkg` directory is still a good way to explicitly communicate that the code in that directory is safe for use by others. The [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) blog post by Travis Jeffery provides a good overview of the `pkg` and `internal` directories and when it might make sense to use them.\n\nIt's also a way to group Go code in one place when your root directory contains lots of non-Go components and directories making it easier to run various Go tools (as mentioned in these talks: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) from GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) and [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nSee the [`/pkg`](pkg/README.md) directory if you want to see which popular Go repos use this project layout pattern. This is a common layout pattern, but it's not universally accepted and some in the Go community don't recommend it.\n\nIt's ok not to use it if your app project is really small and where an extra level of nesting doesn't add much value (unless you really want to :-)). Think about it when it's getting big enough and your root directory gets pretty busy (especially if you have a lot of non-Go app components).\n\nThe `pkg` directory origins: The old Go source code used to use `pkg` for its packages and then various Go projects in the community started copying the pattern (see [`this`](https://twitter.com/bradfitz/status/1039512487538970624) Brad Fitzpatrick's tweet for more context).\n\n### `/vendor`\n\nApplication dependencies (managed manually or by your favorite dependency management tool like the new built-in [`Go Modules`](https://go.dev/wiki/Modules) feature). The `go mod vendor` command will create the `/vendor` directory for you. Note that you might need to add the `-mod=vendor` flag to your `go build` command if you are not using Go 1.14 where it's on by default.\n\nDon't commit your application dependencies if you are building a library.\n\nNote that since [`1.13`](https://golang.org/doc/go1.13#modules) Go also enabled the module proxy feature (using [`https://proxy.golang.org`](https://proxy.golang.org) as their module proxy server by default). Read more about it [`here`](https://blog.golang.org/module-mirror-launch) to see if it fits all of your requirements and constraints. If it does, then you won't need the `vendor` directory at all.\n\n## Service Application Directories\n\n### `/api`\n\nOpenAPI/Swagger specs, JSON schema files, protocol definition files.\n\nSee the [`/api`](api/README.md) directory for examples.\n\n## Web Application Directories\n\n### `/web`\n\nWeb application specific components: static web assets, server side templates and SPAs.\n\n## Common Application Directories\n\n### `/configs`\n\nConfiguration file templates or default configs.\n\nPut your `confd` or `consul-template` template files here.\n\n### `/init`\n\nSystem init (systemd, upstart, sysv) and process manager/supervisor (runit, supervisord) configs.\n\n### `/scripts`\n\nScripts to perform various build, install, analysis, etc operations.\n\nThese scripts keep the root level Makefile small and simple (e.g., [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nSee the [`/scripts`](scripts/README.md) directory for examples.\n\n### `/build`\n\nPackaging and Continuous Integration.\n\nPut your cloud (AMI), container (Docker), OS (deb, rpm, pkg) package configurations and scripts in the `/build/package` directory.\n\nPut your CI (travis, circle, drone) configurations and scripts in the `/build/ci` directory. Note that some of the CI tools (e.g., Travis CI) are very picky about the location of their config files. Try putting the config files in the `/build/ci` directory linking them to the location where the CI tools expect them (when possible).\n\n### `/deployments`\n\nIaaS, PaaS, system and container orchestration deployment configurations and templates (docker-compose, kubernetes/helm, terraform). Note that in some repos (especially apps deployed with kubernetes) this directory is called `/deploy`.\n\n### `/test`\n\nAdditional external test apps and test data. Feel free to structure the `/test` directory anyway you want. For bigger projects it makes sense to have a data subdirectory. For example, you can have `/test/data` or `/test/testdata` if you need Go to ignore what's in that directory. Note that Go will also ignore directories or files that begin with \".\" or \"_\", so you have more flexibility in terms of how you name your test data directory.\n\nSee the [`/test`](test/README.md) directory for examples.\n\n## Other Directories\n\n### `/docs`\n\nDesign and user documents (in addition to your godoc generated documentation).\n\nSee the [`/docs`](docs/README.md) directory for examples.\n\n### `/tools`\n\nSupporting tools for this project. Note that these tools can import code from the `/pkg` and `/internal` directories.\n\nSee the [`/tools`](tools/README.md) directory for examples.\n\n### `/examples`\n\nExamples for your applications and/or public libraries.\n\nSee the [`/examples`](examples/README.md) directory for examples.\n\n### `/third_party`\n\nExternal helper tools, forked code and other 3rd party utilities (e.g., Swagger UI).\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\nOther assets to go along with your repository (images, logos, etc).\n\n### `/website`\n\nThis is the place to put your project's website data if you are not using GitHub pages.\n\nSee the [`/website`](website/README.md) directory for examples.\n\n## Directories You Shouldn't Have\n\n### `/src`\n\nSome Go projects do have a `src` folder, but it usually happens when the devs came from the Java world where it's a common pattern. If you can help yourself try not to adopt this Java pattern. You really don't want your Go code or Go projects to look like Java :-)\n\nDon't confuse the project level `/src` directory with the `/src` directory Go uses for its workspaces as described in [`How to Write Go Code`](https://golang.org/doc/code.html). The `$GOPATH` environment variable points to your (current) workspace (by default it points to `$HOME/go` on non-windows systems). This workspace includes the top level `/pkg`, `/bin` and `/src` directories. Your actual project ends up being a sub-directory under `/src`, so if you have the `/src` directory in your project the project path will look like this: `/some/path/to/workspace/src/your_project/src/your_code.go`. Note that with Go 1.11 it's possible to have your project outside of your `GOPATH`, but it still doesn't mean it's a good idea to use this layout pattern.\n\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - It will scan your code with `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` and `misspell`. Replace `github.com/golang-standards/project-layout` with your project reference.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - It will provide online version of your GoDoc generated documentation. Change the link to point to your project.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev is a new destination for Go discovery & docs. You can create a badge using the [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - It will show the latest release number for your project. Change the github link to point to your project.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Notes\n\nA more opinionated project template with sample/reusable configs, scripts and code is a WIP.\n"
        },
        {
          "name": "README_by.md",
          "type": "blob",
          "size": 25.29,
          "content": "# Стандартная структура праекта Go\n\nПераклады:\n\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Português](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [فارسی](README_fa.md)\n* [Беларуская](README_by.md)\n\n## Агляд\n\nГэта базавая структура для праектаў праграм на Go. Звярніце ўвагу, што яна базавая з пункту гледжання зместу, бо канцэнтруецца толькі на агульнай структуры, а не тым, што ўнутры. Яна таксама базавая таму, што вельмі высокага ўзроўню і не паглыбляецца ў дэталі таго, як можна яшчэ больш структуравана арганізаваць ваш праект. Напрыклад, яна не спрабуе ахапіць структуру на ўзор чагосьці накшталт Чыстай Архітэктуры.\n\nГэта **`НЕ афіцыйны стандарт, вызначаны асноўнай камандай распрацоўшчыкаў Go`**. Гэта набор агульных гістарычных і новых шаблонаў размяшчэння праектаў у экасістэме Go. Некаторыя з гэтых шаблонаў больш папулярныя за іншыя. Ён таксама ўключае шэраг невялікіх удасканаленняў разам з некалькімі дапаможнымі каталогамі, якія звычайна сустракаюцца ў любым дастаткова вялікай рэальнай праграме. Звярніце ўвагу, што асноўная **каманда Go дае выдатны набор агульных рэкамендацый па структурыраванні праектаў на Go** і што гэта азначае для вашага праекта пры яго імпарце і ўсталёўцы. Глядзіце старонку [`Арганізацыя модуля Go`](https://go.dev/doc/modules/layout) ў афіцыйнай дакументацыі Go для больш падрабязнай інфармацыі. Яна ўключае ўзоры каталогаў `internal` і `cmd` (апісаныя ніжэй) і іншую карысную інфармацыю.\n\n**`Калі вы спрабуеце вывучыць Go або ствараеце PoC ці просты праект для сябе, гэтая структура праекта з'яўляецца празмернасцю. Пачніце з чагосьці сапраўды простага (адзін `main.go` файл і `go.mod` больш чым дастаткова).`**  Па меры росту вашага праекта памятайце, што важна пераканацца, што ваш код добра структураваны, у адваротным выпадку вы атрымаеце блытаны код з мноствам схаваных залежнасцей і глабальным станам. Калі над праектам будзе працаваць больш людзей, вам спатрэбіцца яшчэ большая структура. Вось тады важна ўвесці агульны спосаб кіравання пакетамі/бібліятэкамі. Калі ў вас ёсць праект з адкрытым зыходным кодам або вы ведаеце што іншыя праекты імпартуюць код з рэпазіторыя вашага праекта - вось тады важна мець прыватныя (`internal`) пакеты і код. Кланіруйце рэпазіторый, захавайце тое, што вам трэба і выдаліце ўсё астатняе! Толькі таму што яно там ёсць не азначае што вам усё гэта патрэбна. Ніводзен з гэтых шаблонаў не выкарыстоўваецца ва ўсіх без выключэннях праектах. Нават шаблон `vendor` не універсальны.\n\nЗ Go 1.14 [`Go Modules`](https://go.dev/wiki/Modules) нарэшце гатовыя да ўжытку. Выкарыстоўвайце [`Go Modules`](https://blog.golang.org/using-go-modules), калі ў вас няма канкрэтнай прычыны не выкарыстоўваць іх, а калі і ёсць, то вам не трэба турбавацца пра $GOPATH і дзе размясціць ваш праект. Асноўны файл `go.mod` у рэпазіторыі разлічвае, што ваш праект размешчаны на GitHub, але гэта не абавязковае патрабаванне. Шлях модуля можа быць любым, хоць першы кампанент шляху модуля павінен мець кропку ў сваёй назве (цяперашняя версія Go больш гэтага не патрабуе, але калі вы карыстаецеся крыху старэйшымі версіямі - не здзіўляйцеся, калі сабраць праект без яе не ўдасца). Глядзіце Issues [`37554`](https://github.com/golang/go/issues/37554) і [`32819`](https://github.com/golang/go/issues/32819) для дадатковай інфармацыі.\n\nГэты шаблон праекта наўмысна агульны і не спрабуе навязаць канкрэтную структуру пакета Go.\n\nГэта намаганне супольнасці. Адкрыйце issue, калі знойдзеце новы ўзор або лічыце, што адзін з існуючых трэба абнавіць.\n\nКалі вам патрэбна дапамога з назвай, фарматаваннем і стылямі, пачніце з запуску [`gofmt`](https://golang.org/cmd/gofmt/) і [`staticcheck`](https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck). Папярэдні стандартны лінтар golint цяпер састарэў і не падтрымліваецца; рэкамендуецца выкарыстоўваць лінтар які падтрымліваецца, такі як staticcheck. Таксама пераканайцеся, што вы прачыталі гэтыя стайлгайды для Go:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Кіраўніцтва па стылі для пакетаў Go](https://rakyll.org/style-packages) (rakyll/JBD)\n\nГлядзіце [`шаблон праекта Go`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) для дадатковай інфармацыі.\n\nБольш пра найменне і арганізацыю пакетаў, а таксама іншыя рэкамендацыі па структуры кода:\n* [GopherCon EU 2018: Пітэр Бургон - Лепшыя практыкі для прамысловага праграмавання](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Эшлі МакНамара + Браян Кетэльсэн - Лепшыя практыкі Go](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Эдвард Мюлер - Анты-шаблоны ў Go](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Кат Зіен - Як структуравать вашы Go прыкладанні](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nКітайскі пост пра прынцыпы Package-Oriented-Design і архітэктурны слой\n* [Пакетна-арыентаваны дызайн і архітэктурнае напластаванне](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go каталогi\n\n### `/cmd`\n\nАсноўныя прымяненні для гэтага праекта.\n\nНазва каталога для кожнай праграмы павінна адпавядаць назве выканальнага файла (напрыклад, `/cmd/myapp`).\n\nНе змяшчайце шмат кода ў каталог праграмы. Калі вы лічыце, што код можна імпартаваць і выкарыстоўваць у іншых праектах, ён павінен знаходзіцца ў каталогу `/pkg`. Калі код не можа быць паўторна выкарыстаны або калі вы не хочаце, каб іншыя яго выкарыстоўвалі, змясціце гэты код у каталог `/internal`. Вы бы здзівіліся, што іншыя бы зрабілі, таму ясна выражайце свае намеры!\n\nРаспаўсюджаная практыка мець невялікую `main` функцыю, якая імпартуе і выклікае код з каталогаў `/internal` і `/pkg`, і больш нічога.\n\nПрыклады ў каталогу [`/cmd`](cmd/README.md).\n\n### `/internal`\n\nПрыватны код праграмы і бібліятэкі. Гэта код, які вы не хочаце, каб іншыя імпартавалі ў свае праграмы або бібліятэкі. Звярніце ўвагу, што гэты шаблон размяшчэння забяспечваецца самім кампілятарам Go. Глядзіце [`нататкі да выпуску`](https://golang.org/doc/go1.4#internalpackages) Go 1.4 для больш падрабязнай інфармацыі. Заўважце, што вы не абмежаваныя толькі верхнім узроўнем `internal` каталога. Вы можаце мець больш за адзін `internal` каталог на любым узроўні вашага дрэва праекта.\n\nВы можаце дадаткова дадаць трохі структуры ў вашы ўнутраныя пакеты, каб аддзяліць агульны і неагульны ўнутраны код. Гэта не абавязкова (асабліва для меншых праектаў), але прыемна мець візуальныя падказкі, якія паказваюць на запланаванае выкарыстанне пакета. Ваш фактычны код праграмы можа знаходзіцца ў каталогу `/internal/app` (напрыклад, `/internal/app/myapp`), а код, які выкарыстоўваецца гэтымі праграмамі - у каталогу `/internal/pkg` (напрыклад,`/internal/pkg/myprivlib`).\n\nВы выкарыстоўваеце `internal` каталогі, каб зрабіць пакеты прыватнымі. Калі вы размяшчаеце пакет унутры `internal` каталога, то іншыя пакеты не могуць яго імпартаваць, калі яны не маюць агульнага продка. І гэта адзіны каталог, названы ў дакументацыі Go, які мае спецыяльную апрацоўку кампілятарам.\n\n### `/pkg`\n\nКод бібліятэкі, які могуць выкарыстоўваць знешнія праграмы (напрыклад, `/pkg/mypubliclib`). Іншыя праекты будуць імпартаваць гэтыя бібліятэкі, разлічваючы на іх працу, таму двойчы падумайце перад тым, як размясціць тут нешта 😃 Звярніце ўвагу, што `internal` каталог - лепшы спосаб забяспечыць недаступнасць вашых прыватных пакетаў для імпарту, бо гэта забяспечваецца Go. Каталог `/pkg` па-ранейшаму добры спосаб выразна паведаміць аб бяспецы кода ў гэтым каталогу для выкарыстання іншымі. Блог-паведамленне [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) Трэвіса Джэферы дае добры агляд каталогаў `pkg` і `internal` і калі ёсць сэнс іх выкарыстоўваць.\n\nГэта таксама спосаб згрупаваць код Go ў адным месцы, калі ваш каранёвы каталог утрымлівае шмат не-Go кампанентаў і каталогаў, што палягчае запуск розных інструментаў Go (як згадваецца ў гэтых дакладах: [`Лепшыя практыкі для прамысловага праграмавання`](https://www.youtube.com/watch?v=PTE4VJIdHPg) з GopherCon EU 2018, [`GopherCon 2018: Кат Зіен - Як структураваны вашы праграмы на Go`](https://www.youtube.com/watch?v=oL6JBUk6tj0) і [`GoLab 2018 - Масімільяна Піппі - Шаблоны размяшчэння праектаў у Go`](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nКалі вы хочаце ўбачыць, якія папулярныя рэпазіторыі Go выкарыстоўваюць гэты шаблон праекта, паглядзіце каталог [`/pkg`](pkg/README.md). Гэта распаўсюджаны шаблон, але ён не з'яўляецца агульнапрынятым і некаторыя ў супольнасці Go яго не рэкамендуюць.\n\nГэта нармальна не выкарыстоўваць яго, калі ваш праект сапраўды невялікі і дадатковы ўзровень ўкладання не моцна дапамагае (калі толькі вы сапраўды гэтага не хочаце 😃). Падумайце пра гэта, калі ён становіцца дастаткова вялікім і ваша каранёвая дырэкторыя становіцца даволі загружанай (асабліва калі ў вас ёсць шмат кампанентаў праграмы, якія не на Go).\n\nПаходжанне каталога `pkg`: стары зыходны код Go выкарыстоўваў `pkg` для сваіх пакетаў, і тады розныя праекты Go ў супольнасці пачалі капіяваць гэты шаблон (больш кантэксту ў [`твітах`](https://twitter.com/bradfitz/status/1039512487538970624) Брэда Фіцпатрыка).\n\n### `/vendor`\n\nЗалежнасці праграмы (кіруюцца ўручную або з дапамогай вашага любімага інструмента кіравання залежнасцямі, як новая ўбудаваная функцыя [`Go Modules`](https://go.dev/wiki/Modules)). Каманда `go mod vendor` створыць для вас каталог `/vendor`. Звярніце ўвагу, што вам можа спатрэбіцца дадаць сцяг `-mod=vendor` у вашу каманду `go build`, калі вы не выкарыстоўваеце Go 1.14, дзе ён перадвызначаны.\n\nНе ўключайце залежнасці вашай праграмы, калі ствараеце бібліятэку.\n\nЗвярніце ўвагу, што з версіі [`1.13`](https://golang.org/doc/go1.13#modules) Go таксама ўключыў функцыю проксі-модуля (выкарыстоўваючы [`https://proxy.golang.org`](https://proxy.golang.org) у якасці перадвызначанага сервера проксі-модуля). Прачытайце больш пра гэта [`тут`](https://blog.golang.org/module-mirror-launch), каб даведацца, ці адпавядае гэта ўсім вашым патрабаванням і абмежаванням. Калі так, то каталог `vendor` увогуле не спатрэбіцца.\n\n## Каталогі cервісных праграм\n\n### `/api`\n\nСпецыфікацыі OpenAPI/Swagger, файлы схем JSON, файлы вызначэння пратаколаў.\n\nПрыклады ў каталогу [`/api`](api/README.md).\n\n## Каталогі вэб-праграм\n\n### `/web`\n\nКампаненты, спецыфічныя для вэб-праграм: статычныя файлы, шаблоны для апрацоўкі з боку сервера і SPA (аднастаронкавыя праграмы).\n\n## Агульныя каталогі праграм\n\n### `/configs`\n\nШаблоны файлаў канфігурацыі або стандартныя канфігурацыі.\n\nCвае файлы шаблонаў размясціце ў `confd` або `consul-template`.\n\n### `/init`\n\nКанфігурацыі ініцыялізацыі сістэмы (systemd, upstart, sysv) і менеджара/наглядчыка працэсаў (runit, supervisord).\n\n### `/scripts`\n\nСкрыпты для выканання розных аперацый зборкі, ўсталёўкі, аналізу і г.д.\n\nГэтыя скрыпты пакідаюць файл каранёвы Makefile маленькім і простым (напрыклад, [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nПрыклады ў каталогу [`/scripts`](scripts/README.md).\n\n### `/build`\n\nЗборка і бесперапынная інтэграцыя (Continuous Integration, CI).\n\nЗмясціце вашыя канфігурацыі і скрыпты пакетаў воблака (AMI), кантэйнера (Docker), аперацыйнай сістэмы (deb, rpm, pkg) у каталогу `/build/package`.\n\nЗмясціце вашы канфігурацыі і скрыпты CI (travis, circle, drone) у каталогу `/build/ci`. Звярніце ўвагу, што некаторыя інструменты CI (напрыклад, Travis CI) вельмі капрызныя да размяшчэння сваіх файлаў канфігурацыі. Cпрабуйце змясціць файлы канфігурацыі ў каталогу `/build/ci` з спасылкай на месца, дзе інструменты CI чакаюць іх знайсці (калі гэта магчыма).\n\n### `/deployments`\n\nIaaS, PaaS, канфігурацыі разгортвання аркестрацыі сістэм і кантэйнераў і шаблоны (docker-compose, kubernetes/helm, terraform). Звярніце ўвагу, што ў некаторых рэпазіторыях (асабліва праграмах, разгорнутых з дапамогай kubernetes) гэты каталог называецца `/deploy`.\n\n### `/test`\n\nДадатковыя знешнія тэставыя праграмы і тэставыя даныя. Вы можаце свабодна структуравать каталог `/test` так, як вам зручна. Для большых праектаў мае сэнс мець падкаталог для даных. Напрыклад, вы можаце мець `/test/data` або `/test/testdata`, калі вам трэба, каб Go ігнараваў тое, што знаходзіцца ў гэтым каталогу. Звярніце ўвагу, што Go таксама будзе ігнараваць каталогі або файлы, якія пачынаюцца з \".\" або \"_\", таму ў вас ёсць большая гнуткасць у тым, як называць ваш каталог тэставых даных.\n\nПрыклады ў каталогу [`/test`](test/README.md).\n\n## Other Directories\n\n### `/docs`\n\nДызайн і дакументы карыстальніка (у дадатак да вашай дакументацыі, згенераванай godoc).\n\nПрыклады ў каталогу [`/docs`](docs/README.md).\n\n### `/tools`\n\nІнструменты падтрымкі для гэтага праекта. Звярніце ўвагу, што гэтыя інструменты могуць імпартаваць код з каталогаў `/pkg` і `/internal`.\n\nПрыклады ў каталогу [`/tools`](tools/README.md).\n\n### `/examples`\n\nПрыклады для вашых праграм і/або публічных бібліятэк.\n\nПрыклады ў каталогу [`/examples`](examples/README.md).\n\n### `/third_party`\n\nЗнешнія дапаможныя інструменты, раздвоены код і іншыя зьнешнія ўтыліты (напрыклад, Swagger UI).\n\n### `/githooks`\n\nGit хукі.\n\n### `/assets`\n\nІншыя файлы, якія суправаджаюць ваш рэпазітарый (малюнкі, лагатыпы і г.д.).\n\n### `/website`\n\nГэта месца для размяшчэння даных вашага праекта, калі вы не выкарыстоўваеце GitHub Pages.\n\nПрыклады ў каталогу [`/website`](website/README.md).\n\n## Каталогі, якіх у вас не павінна быць\n\n### `/src`\n\nНекаторыя праекты на Go сапраўды маюць тэчку `src`, але гэта звычайна адбываецца, калі распрацоўшчыкі прыйшлі з Java-свету, дзе гэта агульная схема. Калі не цяжка, паспрабуйце не прымаць гэты шаблон Java. Вы сапраўды не хочаце, каб ваш код на Go або праекты на Go выглядалі як Java 😃\n\nНе блытайце каталог `/src` на ўзроўні праекта з каталогам `/src`, які Go выкарыстоўвае для сваіх працоўных асяроддзяў, як апісана ў [`Як пісаць код на Go`](https://golang.org/doc/code.html). Зменная асяроддзя `$GOPATH` паказвае на ваша (цяперашняе) працоўнае асяроддзе (перадвызначана яна паказвае на `$HOME/go` у не-Windows сістэмах). Гэтае працоўнае асяроддзе ўтрымлівае верхнеўзроўневыя каталогі `/pkg`, `/bin` і `/src`. Ваш фактычны праект становіцца падкаталогам унутры `/src`, таму калі ў вас ёсць каталог `/src` у вашым праекце, шлях да праекта будзе выглядаць так: `/some/path/to/workspace/src/your_project/src/your_code.go`. Заўважце, што пачынаючы з Go 1.11 можна мець свой праект па-за межамі `GOPATH`, але гэта ўсё роўна не робіць гэты шаблон размяшчэння добрым.\n\n## Значкі\n\n* [Go Report Card](https://goreportcard.com/) - праскануе ваш код праз `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` і `misspell`. Замяніце `github.com/golang-standards/project-layout` на спасылку на ваш праект.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - забяспечыць анлайн-версію вашай дакументацыі, створанай з дапамогай GoDoc. Змяніце на спасылку на ваш праект.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev - гэта новае месца для пазнавання і дакументацыі Go. Вы можаце стварыць значок, выкарыстоўваючы [інструмент генерацыі значкоў](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - пакажа апошні нумар рэлізу для вашага праекта. Змяніце спасылку на GitHub на ваш праект.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Нататкі\n\nБольш смелы шаблон праекта з узорамі, паўторна выкарыстоўваемымі канфігурацыямі, скрыптамі і кодам знаходзіцца ў распрацоўцы.\n"
        },
        {
          "name": "README_es.md",
          "type": "blob",
          "size": 15.59,
          "content": "# Standard Go Project Layout\n\nTraducciones:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Resumen\n\nEste es un diseño básico para proyectos de aplicaciones de Go. No es un estándar oficial definido por el equipo de desarrollo principal de Go; sin embargo, es un conjunto de patrones de diseño de proyectos históricos y emergentes comunes en el ecosistema Go. Algunos de estos patrones son más populares que otros. También tiene una serie de pequeñas mejoras junto con varios directorios de soporte comunes a cualquier aplicación del mundo real lo suficientemente grande.\n\nSi está tratando de aprender Go o si está construyendo un PoC o un proyecto de juguete para usted, este diseño del proyecto es excesivo. Comience con algo realmente simple (un solo archivo `main.go` es más que suficiente). A medida que su proyecto crezca, tenga en cuenta que será importante asegurarse de que su código esté bien estructurado, de lo contrario, terminará con un código desordenado con muchas dependencias ocultas y un estado global. Cuando tenga más personas trabajando en el proyecto, necesitará aún más estructura. Ahí es cuando es importante introducir una forma común de administrar paquetes / bibliotecas. Cuando tienes un proyecto de código abierto o cuando sabes que otros proyectos importan el código del repositorio de tu proyecto, es cuando es importante tener paquetes y código privados (también conocidos como `internal`). ¡Clona el repositorio, guarda lo que necesitas y elimina todo lo demás! El hecho de que esté allí no significa que tenga que usarlo todo. Ninguno de estos patrones se utiliza en todos los proyectos. Incluso el patrón `vendor` no es universal.\n\nCon Go 1.14, [`los módulos Go`](https://go.dev/wiki/Modules) están finalmente listos para la producción. Use [`los módulos Go`](https://blog.golang.org/using-go-modules) a menos que tenga una razón específica para no usarlos y, si lo hace, no debe preocuparse por $ GOPATH y dónde coloque su proyecto. El archivo `go.mod` básico en el repositorio asume que su proyecto está alojado en GitHub, pero no es un requisito. La ruta del módulo puede ser cualquier cosa, aunque el primer componente de la ruta del módulo debe tener un punto en su nombre (la versión actual de Go ya no lo aplica, pero si está utilizando versiones un poco más antiguas, no se sorprenda si sus compilaciones fallan sin eso). Consulte los problemas [`37554`](https://github.com/golang/go/issues/37554) y [`32819`](https://github.com/golang/go/issues/32819) si desea obtener más información al respecto.\n\nEste diseño de proyecto es intencionalmente genérico y no intenta imponer una estructura de paquete Go específica.\n\nEste es un esfuerzo comunitario. Abra un problema si ve un patrón nuevo o si cree que uno de los patrones existentes debe actualizarse.\n\nSi necesita ayuda con el nombre, el formato y el estilo, comience ejecutando `gofmt` y `golint`. También asegúrese de leer estas recomendaciones y pautas de estilo del código Go:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Guía de estilo para paquetes Go](https://rakyll.org/style-packages) (rakyll/JBD)\n\nConsulte [`Diseño de proyecto de Go`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) para obtener información adicional sobre los antecedentes.\n\nMás sobre cómo nombrar y organizar paquetes, así como otras recomendaciones de estructura de código:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nUna publicación en idioma chino sobre las pautas de diseño orientado a paquetes y la capa de arquitectura\n\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Directorios en Go\n\n### `/cmd`\n\nPrincipales aplicaciones de este proyecto.\n\nEl nombre del directorio de cada aplicación debe coincidir con el nombre del ejecutable que desea tener (p.ej, `/cmd/myapp`).\n\nNo pongas mucho código en el directorio de la aplicación. Si cree que el código se puede importar y utilizar en otros proyectos, entonces debería residir en el directorio `/pkg`. Si el código no es reutilizable o si no desea que otros lo reutilicen, coloque ese código en el directorio `/internal`. Se sorprenderá de lo que harán los demás, ¡así que sea explícito sobre sus intenciones!\n\nEs común tener una pequeña función `main` que importa e invoca el código de los directorios `/internal` y `/pkg` y nada más.\n\nConsulte el directorio [`/cmd`](cmd/README.md) para ver ejemplos.\n\n### `/internal`\n\nAplicación privada y código de biblioteca. Este es el código que no desea que otros importen en sus aplicaciones o bibliotecas. Tenga en cuenta que el propio compilador de Go aplica este patrón de diseño. Consulte [`las notas de la versión`](https://golang.org/doc/go1.4#internalpackages) Go 1.4 para obtener más detalles. Tenga en cuenta que no está limitado al directorio `internal` de nivel superior. Puede tener más de un directorio `internal` en cualquier nivel del árbol de su proyecto.\n\nOpcionalmente, puede agregar un poco de estructura adicional a sus paquetes internos para separar su código interno compartido y no compartido. No es necesario (especialmente para proyectos más pequeños), pero es bueno tener pistas visuales que muestren el uso previsto del paquete. Su código de aplicación real puede ir en el directorio `/internal/app` (p.ej, `/internal/app/myapp`) y el código compartido por esas aplicaciones en el directorio `/internal/pkg` (por ejemplo, `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nCódigo de biblioteca que puede usar aplicaciones externas (por ejemplo, `/pkg/mypubliclib`). Otros proyectos importarán estas bibliotecas esperando que funcionen, así que piénselo dos veces antes de poner algo aquí :-) Tenga en cuenta que el directorio `internal` es la mejor manera de asegurarse de que sus paquetes privados no se puedan importar porque Go lo aplica. El directorio `/pkg` sigue siendo una buena forma de comunicar explícitamente que el código de ese directorio es seguro para que lo utilicen otros. La publicación del blog de Travis Jeffery, [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/), proporciona una buena descripción de los directorios `pkg` e `internal` y de cuándo podría tener sentido usarlos.\n\nTambién es una forma de agrupar el código de Go en un solo lugar cuando su directorio raíz contiene muchos componentes y directorios que no son de Go, lo que facilita la ejecución de varias herramientas de Go (como se menciona en estas charlas: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) de GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) y [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nConsulte el directorio [`/pkg`](pkg/README.md) si desea ver qué repositorios Go populares utilizan este patrón de diseño de proyecto. Este es un patrón de diseño común, pero no se acepta universalmente y algunos miembros de la comunidad de Go no lo recomiendan.\n\nEstá bien no usarlo si el proyecto de su aplicación es realmente pequeño y donde un nivel adicional de anidamiento no agrega mucho valor (a menos que realmente quiera :-)). Piénselo cuando sea lo suficientemente grande y su directorio raíz esté bastante ocupado (especialmente si tiene muchos componentes de aplicaciones que no son de Go).\n\n### `/vendor`\n\nDependencias de aplicaciones (administradas manualmente o mediante su herramienta de administración de dependencias favorita, como la nueva función de [`Módulos Go`](https://go.dev/wiki/Modules) integrada). El comando `go mod vendor` creará el directorio `/vendor` por usted. Tenga en cuenta que es posible que deba agregar la marca `-mod=vendor` a su comando `go build` si no está usando Go 1.14 donde está activado de forma predeterminada.\n\nNo adicione las dependencias de su aplicación si está creando una biblioteca.\n\nTenga en cuenta que desde [`1.13`](https://golang.org/doc/go1.13#modules) Go también habilitó la función de proxy del módulo (utilizando [`https://proxy.golang.org`](https://proxy.golang.org) como su servidor proxy del módulo de forma predeterminada). Lea más sobre esto [`aquí`](https://blog.golang.org/module-mirror-launch) para ver si se ajusta a todos sus requisitos y limitaciones. Si es así, no necesitará el directorio `vendor` en absoluto.\n\n## Directorios de Aplicaciones de Servicio\n\n### `/api`\n\nEspecificaciones de OpenAPI/Swagger, archivos de esquema JSON, archivos de definición de protocolo.\n\nConsulte el directorio [`/api`](api/README.md) para ver ejemplos.\n\n## Directorios de Aplicaciones Web\n\n### `/web`\n\nComponentes específicos de la aplicación web: activos web estáticos, plantillas del lado del servidor y SPAs.\n\n## Directorios de aplicaciones comunes\n\n### `/configs`\n\nPlantillas de archivos de configuración o configuraciones predeterminadas.\n\nPonga aquí sus archivos de plantilla `confd` o `consul-template`.\n\n### `/init`\n\nConfiguraciones de inicio del sistema (systemd, upstart, sysv) y administración de procesos (runit, supervisord).\n\n### `/scripts`\n\nScripts para realizar varias operaciones de construcción, instalación, análisis, etc.\n\nEstos scripts mantienen el Makefile de nivel raíz pequeño y simple (p.ej, [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nConsulte el directorio `/scripts` para ver ejemplos.\n\n### `/build`\n\nEmpaquetado e Integración Continua.\n\nColoque sus configuraciones de paquetes de nube (AMI), contenedor (Docker), SO (deb, rpm, pkg) y scripts en el directorio `/build/package`.\n\nColoque sus configuraciones y scripts de CI (travis, circle, drone) en el directorio `/build/ci`. Tenga en cuenta que algunas de las herramientas de CI (p.ej, Travis CI) son muy exigentes con la ubicación de sus archivos de configuración. Intente poner los archivos de configuración en el directorio `/build/ci` vinculándolos a la ubicación donde las herramientas de CI los esperan (cuando sea posible).\n\n### `/deployments`\n\nConfiguraciones y plantillas de implementación de IaaS, PaaS, sistema y orquestación de contenedores (docker-compose, kubernetes/helm, mesos, terraform, bosh). Tenga en cuenta que en algunos repositorios (especialmente las aplicaciones implementadas con kubernetes) este directorio se llama `/deploy`.\n\n### `/test`\n\nAplicaciones de prueba externas adicionales y datos de prueba. Siéntase libre de estructurar el directorio `/test` como desee. Para proyectos más grandes, tiene sentido tener un subdirectorio de datos. Por ejemplo, puede tener `/test/data` o `/test/testdata` si necesita Go para ignorar lo que hay en ese directorio. Tenga en cuenta que Go también ignorará los directorios o archivos que comiencen con \".\" o \"_\", por lo que tiene más flexibilidad en términos de cómo nombrar su directorio de datos de prueba.\n\nConsulte el directorio [`/test`](test/README.md) para ver ejemplos.\n\n## Otros Directorios\n\n### `/docs`\n\nDiseño y documentos de usuario (además de su documentación generada por godoc).\n\nConsulte el directorio [`/docs`](docs/README.md) para ver ejemplos.\n\n### `/tools`\n\nHerramientas de apoyo para este proyecto. Tenga en cuenta que estas herramientas pueden importar código de los directorios `/pkg` y `/internal`.\n\nConsulte el directorio [`/tools`](tools/README.md) para ver ejemplos.\n\n### `/examples`\n\nEjemplos para sus aplicaciones y / o bibliotecas públicas.\n\nConsulte el directorio [`/examples`](examples/README.md) para ver ejemplos.\n\n### `/third_party`\n\nHerramientas de ayuda externas, código bifurcado y otras utilidades de terceros (p.ej, Swagger UI).\n\n### `/githooks`\n\nGanchos de Git.\n\n### `/assets`\n\nOtros activos que acompañan a su repositorio (imágenes, logotipos, etc.).\n\n### `/website`\n\nEste es el lugar para colocar los datos del sitio web de su proyecto si no está utilizando GitHub pages.\n\nConsulte el directorio [`/website`](website/README.md) para ver ejemplos.\n\n## Directorios que No Deberías Tener\n\n### `/src`\n\nAlgunos proyectos de Go tienen una carpeta `src`, pero suele ocurrir cuando los desarrolladores vienen del mundo Java, donde es un patrón común. Si puede ayudarse a sí mismo, intente no adoptar este patrón de Java. Realmente no quieres que tu código Go o proyectos Go se parezcan a Java :-)\n\nNo confunda el directorio `/src` de nivel de proyecto con el directorio `/src` que usa Go para sus áreas de trabajo, como se describe en [`How to Write Go Code`](https://golang.org/doc/code.html). La variable de entorno `$GOPATH` apunta a su área de trabajo (actual) (de forma predeterminada apunta a `$HOME/go` en sistemas que no son Windows). Este espacio de trabajo incluye los directorios de nivel superior `/pkg`, `/bin` y `/src`. Su proyecto real termina siendo un subdirectorio en `/src`, por lo que si tiene el directorio `/src` en su proyecto, la ruta del proyecto se verá así: `/some/path/to/workspace/src/your_project/src/your_code.go`. Tenga en cuenta que con Go 1.11 es posible tener su proyecto fuera de su `GOPATH`, pero aún así no significa que sea una buena idea utilizar este patrón de diseño.\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - Escaneará su código con `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` y `misspell`. Cambie `github.com/golang-standards/project-layout` por la referencia de su proyecto.\n\n* ~~[GoDoc](http://godoc.org) - Proporcionará una versión en online de su documentación generada por GoDoc. Cambie el enlace para que apunte a su proyecto.~~\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev es un nuevo destino para Go discovery & docs. Puede crear una insignia con [la herramienta de generación de insignias](https://pkg.go.dev/badge).\n\n* Release - mostrará el número de versión más reciente de su proyecto. Cambie el enlace de github para que apunte a su proyecto.\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n[![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Notas\n\nUna plantilla de proyecto con mayor criterio sobre configuraciones, scripts y códigos de ejemplos está en construcción (WIP).\n"
        },
        {
          "name": "README_fa.md",
          "type": "blob",
          "size": 24.21,
          "content": "\r\n## نمای کلی \r\n\r\nاین متن یک طرح اساسی برای پروژه‌های برنامه‌نویسی به زبان Go است. توجه داشته باشید که این طرح از نظر محتوا ساده است، زیرا فقط روی layout کلی تمرکز دارد و نه آنچه در داخل آن قرار دارد. همچنین ساده است هر چند که از نظر محتوی پیشرفته است ولی به جزئیات زیادی در مورد نحوه ساختاردهی بیشتر پروژه شما نمی‌پردازد. برای مثال، سعی نمی‌کند ساختار پروژه‌ای را  با چیزی مانند Clean Architecture  پوشش دهد.\r\n\r\nاین یک `استاندارد رسمی تعریف شده توسط تیم توسعه اصلی Go نیست`. این مجموعه‌ای از الگوهای layout پروژه‌های رایج با سابقه و نوظهور در اکوسیستم Go است. برخی از این الگوها از بقیه محبوب‌تر هستند. همچنین دارای تعدادی بهبود کوچک همراه با چندین دایرکتوری پشتیبانی مشترک در هر برنامه واقعی به اندازه کافی بزرگ است. توجه داشته باشید که تیم اصلی Go مجموعه خوبی از دستورالعمل‌های عمومی در مورد ساختاردهی پروژه‌های Go و معنای آن برای پروژه شما هنگام وارد شدن و نصب آن ارائه می‌دهد. برای اطلاعات بیشتر، به صفحه [`Organizing a Go module`](https://go.dev/doc/modules/layout) در اسناد رسمی Go مراجعه کنید. این صفحه شامل الگوهای دایرکتوری داخلی و cmd (که در زیر توضیح داده شده است) و سایر اطلاعات مفید است.\r\n\r\nاگر در حال یادگیری Go هستید یا یک PoC یا یک پروژه ساده برای خودتان می‌سازید، این طرح پروژه بیش از حد پیچیده است. در عوض، با چیزی بسیار ساده شروع کنید (یک فایل main.go و go.mod بیش از اندازه کافی است). با پیشرفت پروژه، به خاطر داشته باشید که ساختاردهی مناسب کد شما بسیار مهم خواهد بود، در غیر این صورت در نهایت با یک کد نامرتب با وابستگی‌های پنهان (hidden dependencies) و  global state زیادی مواجه خواهید شد. وقتی افراد بیشتری روی پروژه کار می‌کنند، به ساختار بیشتری نیاز خواهید داشت. در این زمان است که معرفی یک روش مشترک برای مدیریت بسته‌ها/کتابخانه‌ها اهمیت دارد. وقتی یک پروژه متن‌باز دارید یا می‌دانید که پروژه‌های دیگر کد را از مخزن پروژه شما وارد می‌کنند، آن زمان است که داشتن بسته‌ها و کدهای خصوصی (معادل internal) اهمیت دارد. repository را کپی کنید، آنچه را که نیاز دارید نگه دارید و بقیه را حذف کنید! فقط به این دلیل که وجود دارد، به این معنی نیست که باید از همه آن استفاده کنید. هیچ یک از این الگوها در هر پروژه‌ای استفاده نمی‌شوند. حتی الگوی  `vendor` نیز universal نیست.\r\n\r\nبا آمدن Go 1.14 در نهایت [`Go Modules`](https://go.dev/wiki/Modules)  برای production آماده شدند. از [`Go Modules`](https://blog.golang.org/using-go-modules) استفاده کنید، مگر اینکه دلیل خاصی برای استفاده نکردن از آن‌ها داشته باشید و اگر اینطور است، نیازی به نگرانی در مورد $GOPATH و جایی که پروژه خود را قرار می‌دهید ندارید. فایل `go.mod` پایه در مخزن فرض می‌کند که پروژه شما در GitHub میزبانی می‌شود، اما این یک الزام نیست. module path می‌تواند هر چیزی باشد، اگرچه اولین جزء module path باید یک نقطه در نام خود داشته باشد (نسخه فعلی Go دیگر آن را اجباری نمی‌کند، اما اگر از نسخه‌های کمی قدیمی‌تر استفاده می‌کنید، تعجب نکنید اگر ساخت‌های شما بدون آن شکست بخورد). اگر می‌خواهید درباره آن بیشتر بدانید، به Issues  [`37554`](https://github.com/golang/go/issues/37554) و [`32819`](https://github.com/golang/go/issues/32819)مراجعه کنید.\r\n\r\nاین طرح پروژه عمداً عمومی است و سعی نمی‌کند یک ساختار بسته Go خاص را تحمیل کند.\r\n\r\nاین یک تلاش مشترک است. اگر الگوی جدیدی مشاهده کردید یا فکر می‌کنید یکی از الگوهای موجود نیاز به به‌روزرسانی دارد، یک issue را باز کنید.\r\n\r\nاگر به کمک در مورد نام‌گذاری، قالب‌بندی و style نیاز دارید، ابتدا [`gofmt`](https://golang.org/cmd/gofmt/) و  [`staticcheck`](https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck) را اجرا کنید. linter استاندارد قبلی، golint، اکنون منسوخ شده است و نگهداری نمی‌شود؛ استفاده از یک linter در حال توسعه و نگهداری شده مانند staticcheck توصیه می‌شود. همچنین مطمئن شوید که این دستورالعمل‌ها و توصیه‌های Go code style را بخوانید:\r\n\r\n- [https://talks.golang.org/2014/names.slide](https://talks.golang.org/2014/names.slide)\r\n- [https://golang.org/doc/effective_go.html#names](https://golang.org/doc/effective_go.html#names)\r\n- [https://blog.golang.org/package-names](https://blog.golang.org/package-names)\r\n- [https://go.dev/wiki/CodeReviewComments](https://go.dev/wiki/CodeReviewComments)\r\n- [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\r\n\r\nبرای اطلاعات بیشتر ، [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) را ببینید.  \r\nاطلاعات بیشتر در مورد نامگذاری و سازماندهی بسته‌ها و همچنین سایر توصیه‌های ساختار کد:\r\n\r\n- [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\r\n- [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\r\n- [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\r\n- [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\r\n\r\n\r\n## دایرکتوری‌ها در Go\r\n\r\n#### /cmd\r\n\r\nاین دایرکتوری شامل برنامه‌های اصلی پروژه شما است. نام هر دایرکتوری فرعی باید با نام برنامه اجرایی مطابقت داشته باشد (برای مثال، `/cmd/myapp`).\r\n\r\nاز قرار دادن حجم کد زیاد در دایرکتوری برنامه خودداری کنید. اگر فکر می‌کنید این کد‌ها قابلیت وارد شدن و استفاده در پروژه‌های دیگر را دارد، باید در دایرکتوری `/pkg` قرار گیرد. اگر کد قابل استفاده مجدد نیست یا نمی‌خواهید دیگران از آن استفاده مجدد کنند، آن کد را در دایرکتوری  `/internal` قرار دهید. تعجب خواهید کرد که دیگران چه کارهایی انجام می‌دهند، بنابراین در مورد اهداف خود صریح باشید!\r\n\r\nمعمولاً یک تابع اصلی کوچک وجود دارد که کد را از دایرکتوری‌های `/internal `و `/pkg `وارد کرده و فراخوانی می‌کند و کار دیگری انجام نمی‌دهد.\r\n\r\nبه‌عنوان‌مثال به دایرکتوری [`/cmd`](https://github.com/golang-standards/project-layout/blob/master/cmd/README.md) مراجعه کنید.\r\n\r\n#### /internal\r\n\r\nشامل کد Private application و library code است. این کدی است که نمی‌خواهید دیگران آن را در برنامه‌ها یا کتابخانه‌های خود وارد کنند. توجه داشته باشید که این الگوی چیدمان توسط خود کامپایلر Go اعمال می‌شود. برای جزئیات بیشتر،  Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages)را ببینید. توجه داشته باشید که شما به دایرکتوری  `internal` سطح بالا محدود نیستید. شما می‌توانید در هر سطحی از درخت پروژه خود بیش از یک دایرکتوری  `internal` داشته باشید.\r\n\r\nبه‌صورت اختیاری می‌توانید برای جدا کردن کد داخلی مشترک و غیرمشترک خود، کمی ساختار اضافی به بسته‌های داخلی (internal packages) خود اضافه کنید. این کار الزامی نیست (به ویژه برای پروژه‌های کوچک‌تر)، اما داشتن نشانه‌های بصری برای نشان دادن نحوه استفاده موردنظر package بسیار مناسب است. کد application واقعی شما می‌تواند در دایرکتوری  `/internal/app` (مثلاً  `/internal/app/myapp`) و کد مشترک بین آن برنامه‌ها در دایرکتوری `/internal/pkg/` (مثلاً , `/internal/pkg/myprivlib`) قرار گیرد.\r\n\r\nشما از دایرکتوری‌های internal برای private کردن package‌ها استفاده می‌کنید. اگر یک package را داخل یک  internal directory قرار دهید، بسته‌های دیگر نمی‌توانند آن را وارد کنند مگر اینکه یک جد مشترک (common ancestor) داشته باشند. این تنها دایرکتوری‌ای است که در مستندات Go نام برده شده و نحوه برخورد با آن توسط کامپایلر Go خاص و متفاوت است.\r\n\r\n#### /pkg\r\n\r\nکد کتابخانه که امکان استفاده توسط برنامه‌های خارجی را دارد (به‌عنوان مثال،  `/pkg/mypubliclib`). سایر پروژه‌ها این کتابخانه‌ها را import می‌کنند و انتظار کارکرد درست آنها را دارند، بنابراین قبل از قرار دادن چیزی در اینجا خوب فکر کنید :-) و توجه داشته باشید که  `internal` directory، راه بهتری برای اطمینان از وارد نشدن private packages شماست، زیرا توسط Go اجرا می‌شود. دایرکتوری `/pkg`همچنان راه خوبی برای بیان صریح این است که کد موجود در آن دایرکتوری برای استفاده توسط دیگران ایمن است.\r\n\r\nمقاله وبلاگ « [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/)» توسط Travis Jeffery، نمای کلی خوبی از دایرکتوری‌های pkg و internal و زمان‌هایی که استفاده از آنها منطقی است ارائه می‌دهد.\r\n\r\nهمچنین این راهی برای گروه‌بندی کد Go در یک مکان است، زمانی که دایرکتوری اصلی شما حاوی بسیاری از اجزا و دایرکتوری‌های غیر Go باشد، این کار اجرای ابزارهای مختلف Go را آسان‌تر می‌کند (همانطور که در این سخنرانی‌ها ذکر شده است: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) از GopherCon EU و [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) و [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\r\n\r\nاگر می‌خواهید ببینید کدام مخازن محبوب Go از این  layout pattern پروژه استفاده می‌کنند، به دایرکتوری  [`/pkg`](https://github.com/golang-standards/project-layout/blob/master/pkg/README.md) مراجعه کنید. این یک الگوی layout رایج است، اما به‌طور جهانی پذیرفته نشده است و برخی از اعضای جامعه Go آن را توصیه نمی‌کنند.\r\n\r\nاگر پروژه برنامه‌ی شما واقعاً کوچک است و جایی که لایه‌ی اضافی تودرتو بودن ارزش زیادی اضافه نمی‌کند، استفاده نکردن از آن اشکالی ندارد (مگر اینکه واقعاً بخواهید :-)). در مورد آن فکر کنید زمانی که پروژه به اندازه کافی بزرگ می شود و دایرکتوری اصلی شما شلوغ می شود (به خصوص اگر اجزای برنامه غیر Go زیادی دارید).\r\n\r\n**ریشه‌های دایرکتوری pkg:** کد منبع قدیمی Go برای بسته‌های خود از pkg استفاده می‌کرد و سپس پروژه‌های مختلف Go در جامعه شروع به کپی کردن این الگو کردند (برای درک بهتر به [این](https://twitter.com/bradfitz/status/1039512487538970624) توییت Brad Fitzpatrick مراجعه کنید).\r\n\r\n\r\n### /vendor\r\n\r\n\r\nوابستگی‌های برنامه (به‌صورت دستی یا توسط ابزار مدیریت وابستگی مورد علاقه شما مانند ویژگی جدید [`Go Modules`](https://go.dev/wiki/Modules)داخلی مدیریت می‌شود). دستور `go mod vendor` دایرکتوری `vendor/` را برای شما ایجاد می‌کند. توجه داشته باشید که اگر از Go 1.14 استفاده نمی‌کنید که به صورت پیش‌فرض فعال است، ممکن است نیاز به اضافه کردن پرچم `-mod=vendor` به دستور go build خود داشته باشید.\r\n\r\nاگر در حال ساخت کتابخانه هستید، وابستگی‌های برنامه خود را commit نکنید.\r\n\r\nتوجه داشته باشید که از Go [`1.13`](https://golang.org/doc/go1.13#modules) ، قابلیت module proxy نیز در Go فعال شد (که به طور پیش‌فرض از [https://proxy.golang.org](https://proxy.golang.org/) به عنوان سرور پراکسی ماژول خود استفاده می‌کند). برای اینکه ببینید آیا این قابلیت با تمام الزامات و محدودیت‌های شما مطابقت دارد، در [اینجا](https://blog.golang.org/module-mirror-launch) بیشتر در مورد آن بخوانید. اگر اینطور باشد، اصلاً به دایرکتوری `vendor` نیاز نخواهید داشت.\r\n\r\n## Service Application Directories\r\n\r\n### `/api`\r\nمشخصات OpenAPI/Swagger، فایل‌های طرحواره JSON، فایل‌های تعریف پروتکل.  \r\n  \r\nبرای مثال به دایرکتوری  [`/api/`](https://github.com/golang-standards/project-layout/blob/master/api/README.md) مراجعه کنید.\r\n\r\n## Web Application Directories\r\n\r\nاجزای خاص برنامه وب: static web assets و templateهای سمت سرور و SPAها.\r\n\r\n## Common Application Directories\r\n\r\n### `/configs`\r\nقالب‌های فایل پیکربندی یا تنظیمات پیش‌فرض.  \r\n  \r\nفایل‌های قالب  `confd` یا  `consul-template` خود را اینجا قرار دهید.\r\n### `/init`\r\nپیکربندی‌های init سیستم (systemd، upstart، sysv) و process manager/supervisor (runit, supervisord).\r\n\r\n### `/scripts`\r\nاسکریپت‌هایی برای انجام عملیات‌های مختلف build, install, analysis و غیره.\r\nاین اسکریپت‌ها Makefile سطح ریشه را کوچک و ساده نگه می‌دارند (به عنوان مثال،[`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\r\nبرای مثال به دایرکتوری  [`scripts/`](https://github.com/golang-standards/project-layout/blob/master/scripts/README.md) مراجعه کنید.\r\n### `/build`\r\n\r\n‏Packaging و Continuous Integration\r\n\r\n- پیکربندی‌ها و اسکریپت‌های package‌های ابری (AMI)، کانتینری (Docker)، سیستم‌عامل (deb، rpm، pkg) را در این دایرکتوری قرار دهید.\r\n\r\n### `/build`\r\n\r\n\r\n- پیکربندی‌ها و اسکریپت‌های CI (travis، circle، drone) را در این دایرکتوری قرار دهید. توجه داشته باشید که برخی از ابزارهای CI (مانند Travis CI) در مورد مکان فایل‌های پیکربندی خود بسیار حساس هستند. سعی کنید فایل‌های پیکربندی را در دایرکتوری  `/build/ci` قرار داده و آن‌ها را به مکانی که ابزارهای CI انتظار دارند (در صورت امکان) لینک کنید.\r\n\r\n### `/deployments`\r\n\r\n\r\n- پیکربندی‌ها و قالب‌های deployment یا استقرار IaaS، PaaS، سیستم و orchestration کانتینر  (dockerCompose, kubernetes/helm, terraform). توجه داشته باشید که در برخی از repoها (به ویژه برنامه‌هایی که با kubernetes استقرار می‌یابند) این دایرکتوری  `deploy/` نامیده می‌شود.\r\n\r\n### `/test`\r\n\r\n- **برنامه‌های تست خارجی اضافی و داده‌های تست**. می‌توانید دایرکتوری  `test/` را به هر شکلی که می‌خواهید ساختار دهید. برای پروژه‌های بزرگ‌تر، داشتن یک زیردایرکتوری data منطقی است. برای مثال، می‌توانید  `test/testdata/` یا  `test/data/` را داشته باشید اگر نیاز دارید که Go آنچه در آن دایرکتوری است را نادیده بگیرد. توجه داشته باشید که Go همچنین دایرکتوری‌ها یا فایل‌هایی که با \".\" یا \"\" شروع می‌شوند را نادیده می‌گیرد، بنابراین در نحوه نام‌گذاری دایرکتوری داده‌های تست خود انعطاف بیشتری دارید.\r\n\r\nبرای نمونه‌ها به دایرکتوری  [`test/`](https://github.com/golang-standards/project-layout/blob/master/test/README.md)مراجعه کنید.\r\n## دایرکتوری‌های دیگر\r\n\r\nاسناد طراحی و کاربر (علاوه بر مستندات ایجاد شده توسط godoc شما).  \r\n  \r\nبرای مثال به دایرکتوری  [`docs/`](https://github.com/golang-standards/project-layout/blob/master/docs/README.md) مراجعه کنید.  \r\n  \r\n### `/tools`\r\n\r\nابزارهای پشتیبانی این پروژه توجه داشته باشید که این ابزارها می توانند کد را از دایرکتوری های pkg/ و internal/ وارد کنند.  \r\n  \r\nبرای مثال به دایرکتوری tools/ مراجعه کنید.\r\n\r\n### `/examples`\r\nنمونه‌هایی برای application و یا کتابخانه‌های public شما.  \r\n  \r\nبرای مثال به دایرکتوری  [`examples/`](https://github.com/golang-standards/project-layout/blob/master/examples/README.md) مراجعه کنید.\r\n\r\n### `/third_party`\r\n\r\nابزارهای کمکی خارجی، کد fork شده و سایر ابزارهای شخص ثالث (مانند Swagger UI).\r\n\r\n### `/githooks`\r\n\r\nGit hooks.\r\n\r\n### `/assets`\r\nسایر assetها برای همراهی با repository شما (image, logoها و غیره).\r\n\r\n### `/website`\r\nاگر از GitHub pages استفاده نمی‌کنید، اینجا مکانی است که می توانید داده‌های وب‌سایت پروژه خود را قرار دهید.  \r\n  \r\nبرای مثال به دایرکتوری [`website/`](https://github.com/golang-standards/project-layout/blob/master/website/README.md)مراجعه کنید.\r\n\r\n## دایرکتوری‌هایی که نباید داشته باشید\r\n\r\n### /src\r\n\r\nبرخی از پروژه‌های Go دارای یک پوشه  `src` هستند، اما این معمولاً زمانی اتفاق می‌افتد که توسعه‌دهندگان از دنیای جاوا آمده‌اند که در آنجا یک الگوی رایج است. اگر می‌توانید، سعی کنید این الگوی جاوا را نپذیرید. شما واقعاً نمی‌خواهید که کد Go یا پروژه‌های Go شما شبیه جاوا به نظر برسند :-)\r\n\r\nدایرکتوری  `/src` در سطح پروژه را با دایرکتوری  `/src` که Go برای کارگاه‌های خود استفاده می‌کند، اشتباه نگیرید که در [`How to Write Go Code`](https://golang.org/doc/code.html) توضیح داده شده است.  `$GOPATH` environment variable به  (current) workspace فعلی شما اشاره می‌کند (به طور پیش‌فرض به `$HOME/go` در سیستم‌های غیر ویندوزی اشاره می‌کند). این workspace شامل دایرکتوری‌های سطح بالا  `/pkg`, `/bin` و  `/src` است. پروژه واقعی شما در نهایت یک زیردایرکتوری زیر  `/src` می‌شود، بنابراین اگر دایرکتوری  `/src` را در پروژه خود دارید، مسیر پروژه به این شکل خواهد بود:  `/some/path/to/workspace/src/your_project/src/your_code.go`. توجه داشته باشید که با  Go 1.11 امکان دارد پروژه خود را خارج از  `GOPATH` خود داشته باشید، اما این هنوز به معنای این نیست که استفاده از این الگوی layout pattern ایده خوبی است.\r\n\r\n## Badges\r\n\r\n\r\n‏ [Go Report Card](https://goreportcard.com/)\r\nکد شما را با gofmt، go vet، gocyclo، golint، ineffassign، مجوز و غلط املایی اسکن می کند. مرجع پروژه خود را جایگزین github.com/golang-standards/project-layout کنید.\r\n\r\n[![Go Report Card](https://camo.githubusercontent.com/c1e1c210dea2e0410ecbb861999b969841a526d424818d7f9b816bd9f1364d55/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f676f6c616e672d7374616e64617264732f70726f6a6563742d6c61796f75743f7374796c653d666c61742d737175617265)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\r\n\r\n‏ ~~[GoDoc](http://godoc.org/)~~\r\n~~این نسخه آنلاین اسناد تولید شده GoDoc شما را ارائه می‌دهد. link را تغییر دهید تا به پروژه شما اشاره کند.~~\r\n\r\n[![Go Doc](https://camo.githubusercontent.com/fe1188b9f0668a1e0a543e1cbcc6fb28d50a52f74d04e99407f8e6405a7132cd/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f676f646f632d7265666572656e63652d626c75652e7376673f7374796c653d666c61742d737175617265)](http://godoc.org/github.com/golang-standards/project-layout)\r\n\r\n‏ [Pkg.go.dev](https://pkg.go.dev/)\r\n‏ Pkg.go.dev مقصد جدیدی برای شناسایی و مستندات Go است. می‌توانید با استفاده از [badge generation tool](https://pkg.go.dev/badge)آن را ایجاد کنید.\r\n\r\n[![PkgGoDev](https://camo.githubusercontent.com/2f374e52d47edc4ea0e93661bc0eb204743e26718e423a31ae87bac272385081/68747470733a2f2f706b672e676f2e6465762f62616467652f6769746875622e636f6d2f676f6c616e672d7374616e64617264732f70726f6a6563742d6c61796f7574)](https://pkg.go.dev/github.com/golang-standards/project-layout)\r\n\r\nدر مورد Release - آخرین شماره انتشار پروژه شما را نشان می دهد. لینک github را تغییر دهید تا به پروژه شما اشاره کند.\r\n\r\n\r\n## نکته‌ها\r\n\r\nیک الگوی پروژه با نظر بیشتر با تنظیمات sample/reusable استفاده مجدد، اسکریپت‌ها و کد یک WIP است."
        },
        {
          "name": "README_fr.md",
          "type": "blob",
          "size": 16.18,
          "content": "# Standard Go Project Layout\n\nTraductions:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Introduction\n\nCe dépôt est une architecture basique pour des projets d'applications en Go. **Il ne représente pas un standard officiel défini par l'équipe de développement principale de Go**. C'est néanmoins un ensemble de modèles d'architecture que l'on peut retrouver autant sur des projets historiques que plus récents dans l'écosystème Go. Certains patterns sont plus populaires que d'autres. Il comporte également nombre d'améliorations mineures ainsi que plusieurs répertoires communs à beaucoup d'applications existantes de taille importante.\n\n**Si vous commencez à apprendre Go, ou si vous souhaitez développer un petit side-project pour vous-même, cette architecture n'est pas du tout adaptée. Commencez par quelque chose de très simple (un unique fichier `main.go` est largement suffisant).** Au fur et à mesure que votre projet évolue, il est important de garder à l'esprit que votre code doit être bien structuré sinon vous finirez rapidement avec un code difficile à maintenir, comprenant beaucoup de dépendances cachées et un state global. Plus il y aura de gens qui travailleront sur le projet, plus il sera important d'avoir une structure solide. C'est pourquoi il est important d'introduire une façon identique pour tout le monde de gérer les bibliothèques et les packages. Lorsque vous maintenez un projet open source ou que vous savez que d'autres projets importent votre code depuis votre dépôt, il est important d'avoir des packages et du code privé (aka `internal`). Clonez le dépôt, gardez ce dont vous avez besoin et supprimez tout le reste ! Ce n'est pas parce que des dossiers existent que vous devez impérativement tous les utiliser. Tous ces patterns ne sont pas tout le temps utilisés dans tous les projets. Même le pattern `vendor` n'est pas universel.\n\nDepuis la sortie de Go 1.14 les [`Go Modules`](https://go.dev/wiki/Modules) sont enfin prêts à être utilisés en production. Utilisez les [`Go Modules`](https://blog.golang.org/using-go-modules) par défaut sauf si vous avez une raison bien spécifique de ne pas les utiliser. Lorsque vous les utilisez, vous n'avez pas besoin de vous embêter avec le $GOPATH ou de définir le dossier dans lequel vous allez mettre votre projet. Le fichier `go.mod` part du principe que votre dépôt est hébergé sur Github, mais ce n'est pas une obligation. Le chemin du module peut être n'importe quoi, mais il faut savoir que le premier composant du chemin devrait toujours avoir un point dans son nom (la version actuelle de Go ne l'impose plus, mais si vous utilisez des versions un peu plus anciennes ne soyez pas surpris que votre build échoue s'il n'y a pas de point). Allez voir les tickets [`37554`](https://github.com/golang/go/issues/37554) et [`32819`](https://github.com/golang/go/issues/32819) si vous souhaitez en savoir plus.\n\nL'architecture de ce projet est générique de manière intentionelle et elle n'essaie pas d'imposer une structure de paquet Go spécifique.\n\nCe projet est un effort communautaire. Ouvrez un ticket si vous découvrez un nouveau pattern ou si vous pensez qu'un des patterns existants devrait être mis à jour.\n\nSi vous avez besoin d'aide pour le nommage, le formattage ou le style, commencez par lancer [`gofmt`](https://golang.org/cmd/gofmt/) et [`golint`](https://github.com/golang/lint). Prenez également le temps de parcourir ces lignes directrices et recommandations :\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nLisez l'article [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) pour avoir des informations additionnelles.\n\nPlus d'infos sur le nommage et l'organisation des packages, ainsi que quelques recommandations sur la structuration du code :\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nUn article en Chinois sur les guidelines du design orienté package et la couche Architecture :\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Les répertoires Go\n\n### `/cmd`\n\nLes applications principales de ce projet.\n\nLe nom de répertoire de chaque application doit correspondre au nom de l'exécutable que vous souhaitez avoir (p. ex., `/cmd/myapp`).\n\nNe mettez pas trop de code dans le répertoire de votre application. Si vous pensez que le code peut être importé et réutilisé dans d'autres projets, déplacez le dans le dossier `/pkg`. Si le code n'est pas réutilisable, ou si vous ne souhaitez pas que d'autres personnes l'utilisent, placez le dans le dossier `/internal`. Soyez explicite quant à vos intentions, vous seriez surpris de l'utilisation que d'autres développeurs pourraient faire de votre code !\n\nIl est habituel d'avoir une petite fonction `main` qui importe et appelle du code contenu dans les dossiers `/internal` et `/pkg`, et rien de plus.\n\nVoir le dossier [`/cmd`](cmd/README.md) pour des exemples.\n\n### `/internal`\n\nApplications privées et bibliothèques de code. C'est le code que vous ne souhaitez pas voir importé dans d'autres applications ou bibliothèques. Notez que ce pattern est imposé par le compilateur Go lui-même (voir les [`release notes`](https://golang.org/doc/go1.4#internalpackages) de Go 1.4 pour plus de détails). Vous n'êtes pas limité à un seul dossier `internal` de haut niveau, mais vous pouvez en avoir plusieurs à n'importe quel niveau de l'arborescence de votre projet.\n\nVous pouvez également ajouter un peu de structure dans vos packages internes pour séparer le code partagé et non partagé. Ce n'est pas du tout obligatoire (surtout pour les petits projets), mais il est intéressant d'avoir des indices visuels indiquant l'utilisation prévue d'un package. Le code de votre application peut aller dans un dossier `/internal/app` (p. ex., `/internal/app/myapp`) tandis que le code partagé par les applications peut se retrouver dans un dossier `/internal/pkg` (p. ex., `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nPlacez-y le code qui peut être réutilisé par les applications externes (p. ex., `/pkg/mypubliclib`). D'autres projets peuvent importer ces bibliothèques et s'attendent donc à ce qu'elles soient fonctionnelles, pensez y donc à deux fois avant de mettre du code dans ce dossier :-) Utiliser le dossier `internal` est une manière plus adéquate de garder vos packages privés et non importables car c'est intégré au compilateur Go. Le dossier `/pkg` est néanmoins une bonne manière d'indiquer que le code contenu dans ce dossier peut être utilisé par les autres utilisateurs sans problème. L'article de blog de Travis Jeffery [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) explique plus en détail les différences entre les dossier `pkg` et `internal` et quand il fait sens de les utiliser.\n\nC'est également une manière de regrouper tout votre code Go au même endroit lorsque votre dossier racine comporte de nombreux composants et dossiers non-Go, permettant plus facilement de lancer les différents outils Go, tel que mentionné dans les conférences suivantes : [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) lors de GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) et [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nVoir le dossier [`/pkg`](pkg/README.md) pour découvrir quels projets Go populaires utilisent cette architecture de projet. C'est un pattern plutôt commun, mais qui n'est pas accepté de manière universelle, et certaines personnes de la communauté Go ne le recommandent pas.\n\nVous n'êtes pas obligés de l'utiliser si votre projet est petit et si l'ajout d'un niveau de plus n'ajoute pas vraiment de valeur (sauf si vous y tenez vraiment :-)). Il est temps d'y penser lorsque votre projet commence à prendre de l'ampleur et que votre dossier racine est encombré (surtout si vous avez beaucoup de composants non-Go)\n\n### `/vendor`\n\nLes dépendances de votre application (gérées manuellement ou via votre gestionnaire de dépendances favori tel que la fonctionnalité incluse dans les [`Go Modules`](https://go.dev/wiki/Modules)). La commande `go mod vendor` créera un dossier `/vendor` pour vous. Notez que vous devrez peut-être utiliser le flag `-mod=vendor` avec votre commande `go build` si vous n'utilisez pas Go 1.14 qui le définit par défaut.\n\nNe commitez pas vos dépendances si vous développez une bibliothèque.\n\nDepuis sa version [`1.13`](https://golang.org/doc/go1.13#modules), Go active la fonctionnalité de proxy de module (en utilisant [`https://proxy.golang.org`](https://proxy.golang.org) comme serveur de proxy par défaut). Plus d'infos [`ici`](https://blog.golang.org/module-mirror-launch) afin de définir si cela correspond à votre obligations et contraintes. Si c'est le cas, vous n'aurez pas besoin du dossier `vendor`.\n\n## Les répertoires d'application de services\n\n### `/api`\n\nSpécifications OpenAPI/Swagger, fichiers de schémas JSON, fichiers de définitions de protocoles.\n\nVoir le dossier [`/api`](api/README.md) pour des examples.\n\n## Les répertoires d'application web\n\n### `/web`\n\nLes composants spécifiques aux applications web : assets statiques, templates serveurs et SPAs.\n\n## Les répertoire communs aux applications\n\n### `/configs`\n\nTemplates de fichiers de configuration ou configurations par défaut.\n\nAjoutez vos templates `confd` ou `consul-template` dans ce répertoire.\n\n### `/init`\n\nInitialisation du système (systemd, upstart, sysv) et configurations des administrateurs/superviseurs de process (runit, supervisord).\n\n### `/scripts`\n\nScripts permettant différentes opérations telles que le build, l'installation, des analyses, ...\n\nCes scripts permettent de garder le Makefile du dossier racine réduit et simple (p. ex., [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nVoir le dossier [`/scripts`](scripts/README.md) pour des exemples.\n\n### `/build`\n\nPackaging et Intégration Continue.\n\nAjoutez vos scripts et configurations de cloud (AMI), conteneur (Docker), OS (deb, rpm, pkg) et package dans le dossier `/build/package`.\n\nPlacez vos scripts et configurations de CI (travis, circle, drone) dans le dossier `/build/ci`. Prenez garde au fait que certains outils de CI (p. ex., Travis CI) sont très contraignants vis à vis de l'emplacement de leurs fichiers de configuration. Essayez donc, lorsque c'est possible, de créer des liens entre le dossier `/build/ci` et les endroits où les outils de CI s'attendent à trouver ces fichiers.\n\n### `/deployments`\n\nTemplates et configurations pour les IaaS, PaaS, système et l'orchestration de conteneurs (docker-compose, kubernetes/helm, mesos, terraform, bosh). Sur certains projets (principalement les applications déployées via Kubernetes) ce dossier s'appelle `/deploy`.\n\n### `/test`\n\nApplications et données de tests externes additionnels. Vous pouvez structurer le dossier `/test` de la façon qui vous convient le mieux. Pour des projets plus importants, il fait sens d'utiliser un sous-dossier `data`. Vous pouvez par exemple utiliser `/test/data` ou `/test/testdata` si vous souhaitez que Go ignore ce dossier. Go ignore également les dossiers ou fichiers commençant par \".\" ou \"_\", ce qui vous donne plus de flexibilité en terme de nommage de votre dossier de données de test.\n\nVoir le dossier [`/test`](test/README.md) pour des exemples\n\n## Autres répertoires\n\n### `/docs`\n\nDocuments utilisateurs et design (en plus de votre documentation générée GoDoc)\n\nVoir le dossier [`/docs`](docs/README.md) pour des exemples\n\n### `/tools`\n\nOutils de support du projet. Ces scripts peuvent importer du code des dossier `/pkg` et `/internal`\n\nVoir le dossier [`/tools`](tools/README.md) pour des exemples\n\n### `/examples`\n\nExemples de vos applications et/ou de vos bibliothèques publiques\n\nVoir le dossier [`/examples`](examples/README.md) pour des exemples\n\n### `/third_party`\n\nOutils d'aide externe, code forké et autres utilitaires tierces (p. ex., Swagger UI).\n\n### `/githooks`\n\nHooks Git.\n\n### `/assets`\n\nD'autres assets qui sont utilisés dans votre dépôt (images, logos, etc).\n\n### `/website`\n\nC'est là que vous placez les données du site de votre projet si vous n'utilisez pas GitHub pages.\n\nVoir le dossier [`/website`](website/README.md) pour des exemples\n\n## Les répertoires que vous ne devriez pas avoir\n\n### `/src`\n\nCertains projets Go comportent un dossier `src` mais cela arrive en général lorsque les développeurs viennent du monde de Java où c'est une pratique habituelle. Faites tout votre possible pour ne pas adopter ce pattern Java. Vous n'avez vraiment pas envie que votre code Go ou vos projets Go ressemblent à du Java :-)\n\nNe confondez pas le répertoire `/src` à la racine avec le répertoire `/src` utilisé par Go pour gérer ses espaces de travail comme décrit dans [`How to Write Go Code`](https://golang.org/doc/code.html). La variable d'environnement `$GOPATH` pointe vers votre espace de travail courant (par défault il pointe vers `$HOME/go` sur les systèmes non-Windows). Cet espace de travail inclut les dossiers `/pkg`, `/bin` et `/src`. Votre projet en lui-même va se retrouver dans un sous-dossier de `/src`, donc si vous avez un dossier `/src` dans votre projet le chemin vers celui-ci ressemblera à ceci : `/some/path/to/workspace/src/your_project/src/your_code.go`. Notez qu'à partir de Go 1.11 il est possible d'avoir votre projet en dehors de votre `GOPATH` mais cela ne veut toujours pas dire que c'est une bonne idée d'utiliser le dossier `/src`\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - Scanne votre code avec les commandes `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` and `misspell`. Remplacez `github.com/golang-standards/project-layout` avec l'url de votre projet.\n\n* ~~[GoDoc](http://godoc.org) - Fournit une version en ligne de votre documentation générée GoDoc. Modifiez le lien pour qu'il pointe vers votre projet.~~\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev est la nouvelle destination pour la découverte de Go et sa documentation. Vous pouvez créer une badge en utilisant [l'outil de création de badge](https://pkg.go.dev/badge).\n\n* Release - Il indique la dernière version de votre projet. Modifiez le lien GitHub pour qu'il pointe vers votre projet.\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n[![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Notes\n\nUn template de projet moins générique avec du code, des script et des configs réutilisables est en cours de réalisation.\n"
        },
        {
          "name": "README_hi.md",
          "type": "blob",
          "size": 37.25,
          "content": "<!-- This translation uses ancient form of written Hindi, so please DO NOT insert/replace words with modern varients. -->\r\n# मानक Go परियोजना अभिन्यास\r\n\r\nअनुवाद:\r\n\r\n<!-- Insert new entries lexicographically by language code. -->\r\n* [Español](README_es.md)\r\n* [Français](README_fr.md)\r\n* [Indonesian](README_id.md)\r\n* [Italiano](README_it.md)\r\n* [日本語](README_ja.md)\r\n* [한국어 문서](README_ko.md)\r\n* [Português](README_ptBR.md)\r\n* [Română](README_ro.md)\r\n* [Русский](README_ru.md)\r\n* [Türkçe](README_tr.md)\r\n* [Українська](README_ua.md)\r\n* [Vietnamese](README_vi.md)\r\n* [简体中文](README_zh-CN.md) - ???\r\n* [正體中文](README_zh-TW.md)\r\n* [简体中文](README_zh.md)\r\n* [English](README.md)\r\n* [Беларуская](README_by.md)\r\n\r\n## अवलोकन\r\n\r\nयह Go एप्लिकेशन[^1] परियोजनाओं[^2] के लिए एक बुनियादी अभिन्यास[^3] है। ध्यान दें कि यह सामग्री के संदर्भ में बुनियादी है क्योंकि यह केवल सामान्य अभिन्यास[^3] पर ध्यान केंद्रित करता है न कि इसके अंदर क्या है। यह बुनियादी भी है क्योंकि यह बहुत उच्च स्तर का है और यह इस संदर्भ में विस्तृत विवरण में नहीं जाता है कि आप अपनी परियोजना[^2] को और भी आगे कैसे संरचित[^4] कर सकते हैं। उदाहरण के लिए, यह आपके पास उपस्थित परियोजना[^2] संरचना[^4] को स्वच्छ वास्तुकला जैसी किसी चीज़ से ढकने का प्रयास नहीं करता है।\r\n\r\nयह **मूल[^5] Go डेवलपर[^6] दल द्वारा परिभाषित आधिकारिक मानक[^0] नहीं है**। यह Go परितंत्र में सामान्य ऐतिहासिक और उभरती परियोजना[^2] अभिन्यास[^3] नमूनों[^7] का एक समूह है। इनमें से कुछ नमूनें[^7] दूसरों की तुलना में अधिक लोकप्रिय हैं। इसमें किसी भी बड़े वास्तविक एप्लिकेशन[^1] के लिए सामान्य सहायक फ़ोल्डरों[^8] के साथ-साथ कई छोटे संवर्द्धन भी हैं। ध्यान दें कि **मूल[^5] Go दल Go परियोजनाओं[^2] की संरचना[^4] के बारे में सामान्य दिशानिर्देशों का एक बड़ा सेट प्रदान करते है** और जब इसे आयात[^10] किया जाता है और जब इसे स्थापित[^11] किया जाता है तो आपकी परियोजना[^2] के लिए इसका क्या अर्थ होता है। अधिक विवरण के लिए आधिकारिक Go दस्तावेज़ों[^9] में [`Organizing a Go module`](https://go.dev/doc/modules/layout) पृष्ठ देखें। इसमें `internal` और `cmd` फ़ोल्डर[^8] नमूनें[^7] (नीचे वर्णित) और अन्य उपयोगी जानकारी शामिल है।\r\n\r\n**यदि आप Go सीखने की कोशिश कर रहे हैं या यदि आप अपने लिए एक **अवधारणा प्रमाण[^12]** या एक साधारण परियोजना[^2] बना रहे हैं तो यह परियोजना[^2] अभिन्यास[^3] ज़रूरत से ज़्यादा है। इसके स्थान पर वास्तव में कुछ सरल से शुरू करें (एक `main.go` फ़ाइल[^21] और `go.mod` पर्याप्त से अधिक है)।** जैसे-जैसे आपकी परियोजना[^2] बढ़ती है, ध्यान रखें कि यह सुनिश्चित करना महत्वपूर्ण होगा कि आपका कोड[^13] ठीक से संरचित[^4] है अन्यथा आप बहुत सारी छिपी हुई निर्भरताओं[^14] और वैश्विक स्थिति के साथ गड़बड़ कोड[^13] पाएंगे। जब आपके पास परियोजना[^2] पर काम करने वाले अधिक लोग हों तो आपको और भी अधिक संरचना[^4] की आवश्यकता होगी। तभी संकुलों[^15]/भंडारों[^16] को प्रबंधित[^17] करने का एक सामान्य तरीका पेश करना महत्वपूर्ण है। जब आपके पास एक खुला-स्रोत[^18] परियोजना[^2] होती है या जब आप जानते हैं कि अन्य परियोजनाएं[^2] आपकी परियोजना[^2] रिपॉजिटरी[^19] से कोड[^13] आयात[^10] करती हैं, तब निजी (उर्फ `internal`) संकुल[^15] और कोड[^13] होना महत्वपूर्ण है। रिपॉजिटरी[^19] को क्लोन करें, जो आपको चाहिए उसे रखें और बाकी सब हटा दें! सिर्फ इसलिए कि यह वहाँ है इसका मतलब यह नहीं है कि आपको इसका पूरा उपयोग करना होगा। प्रत्येक परियोजनाओं[^2] में इनमें से किसी भी नमूनों[^7] का उपयोग नहीं किया जाता है। यहां तक कि `vendor` नमूनां[^7] भी सार्वभौमिक[^20] नहीं है।\r\n\r\nGo १.१४ के साथ [`Go Modules`](https://go.dev/wiki/Modules) अंततः उत्पादन के लिए तैयार हैं। [`Go Modules`](https://blog.golang.org/using-go-modules) का उपयोग करें जब तक कि आपके पास उनका उपयोग न करने का कोई विशेष कारण न हो और यदि आप ऐसा करते हैं तो आपको $GOPATH और के बारे में चिंता करने की आवश्यकता नहीं है जहाँ आपने अपनी परियोजना[^2] रखी है। रिपॉजिटरी[^19] में मूल[^5] `go.mod` फ़ाइल[^21] मानती है कि आपकी परियोजना को GitHub पर होस्ट किया गया है, लेकिन यह कोई आवश्यकता नहीं है। अनुखंड[^22] पथ कुछ भी हो सकता है, हालांकि पहले अनुखंड[^22] पथ अंग के नाम में एक बिंदु होना चाहिए (Go का वर्तमान संस्करण अब इसे लागू नहीं करता है, लेकिन यदि आप थोड़े पुराने संस्करणों का उपयोग कर रहे हैं तो आश्चर्यचकित न हों यदि आपका निर्माण[^23] विफल हो जाए)। यदि आप चाहें तो विवाद [`३७५५४`](https://github.com/golang/go/issues/37554) और [`३२८१९`](https://github.com/golang/go/issues/32819) इसके बारे में और अधिक जानने के लिए देखें।\r\n\r\nयह परियोजना[^2] अभिन्यास[^3] जानबूझकर सामान्य है और यह किसी विशिष्ट Go संकुल[^15] संरचना[^4] को लागू करने का प्रयास नहीं करती है।\r\n\r\nयह एक सामुदायिक प्रयास है। यदि आपको कोई नया नमूनां[^7] दिखाई देता है या आपको लगता है कि मौजूदा नमूनों[^7] में से किसी एक को अद्यतन करने की आवश्यकता है, तो एक विवाद खोलें।\r\n\r\nयदि आपको नामकरण, संरूपण, और शैली[^24] में मदद चाहिए तो [`gofmt`](https://golang.org/cmd/gofmt/) और [`staticcheck`](https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck) चलाकर शुरुआत करें। पिछला मानक[^0] लिंटर[^25], golint, अब अप्रचलित है और इसका रखरखाव नहीं किया जा रहा है; staticcheck जैसे रखरखाव किए गए लिंटर[^25] के उपयोग की अनुशंसा[^26] की जाती है। इन Go कोड[^13] शैली[^24] दिशानिर्देशों और अनुशंसाओं[^26] को पढ़ना भी सुनिश्चित करें:\r\n\r\n* <https://talks.golang.org/2014/names.slide>\r\n* <https://golang.org/doc/effective_go.html#names>\r\n* <https://blog.golang.org/package-names>\r\n* <https://go.dev/wiki/CodeReviewComments>\r\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\r\n\r\nअतिरिक्त पृष्ठभूमि जानकारी के लिए [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) देखें।\r\n\r\nसंकुलों[^15] के नामकरण और आयोजन के साथ-साथ अन्य कोड[^13] संरचना[^4] अनुशंसाओं[^26] के बारे में अधिक जानकारी:\r\n\r\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\r\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\r\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\r\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\r\n\r\n## Go फ़ोल्डर\r\n\r\n### `/cmd`\r\n\r\nइस परियोजना[^2] के लिए मुख्य अनुप्रयोग।\r\n\r\nप्रत्येक एप्लिकेशन[^1] के लिए फ़ोल्डर[^8] का नाम उस executable के नाम से मेल खाना चाहिए जिसे आप रखना चाहते हैं (उदाहरण के लिए, `/cmd/myapp`)।\r\n\r\nएप्लिकेशन[^1] फ़ोल्डर[^8] में बहुत सारा कोड[^13] न डालें। यदि आपको लगता है कि कोड[^13] को आयात[^10] किया जा सकता है और अन्य परियोजनाओं[^2] में उपयोग किया जा सकता है, तो इसे `/pkg` फ़ोल्डर[^8] में रहना चाहिए। यदि कोड[^13] पुन: उपयोग करने योग्य नहीं है या यदि आप नहीं चाहते कि अन्य लोग इसका पुन: उपयोग करें, तो उस कोड[^13] को `/internal` फ़ोल्डर[^8] में रखें। आप आश्चर्यचकित होंगे कि दूसरे क्या करेंगे, इसलिए अपने इरादों के बारे में स्पष्ट रहें!\r\n\r\nएक छोटा `main` फलन[^27] होना आम बात है जो `/internal` और `/pkg` फ़ोल्डरों[^8] से कोड[^13] आयात[^10] और उपयोग करता है और कुछ नहीं।\r\n\r\nउदाहरण के लिए [`/cmd`](cmd/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n### `/internal`\r\n\r\nनिजी एप्लिकेशन[^1] और भंडार[^16] कोड[^13]। यह वह कोड[^13] है जिसे आप नहीं चाहते कि अन्य लोग अपने एप्लिकेशन[^1] या भंडार[^16] में आयात[^10] करें। ध्यान दें कि यह अभिन्यास[^3] नमूनां[^7] Go संकलनकर्ता[^28] द्वारा ही लागू किया गया है। अधिक विवरण के लिए Go १.४ [`release notes`](https://golang.org/doc/go1.4#internalpackages) देखें। ध्यान दें कि आप शीर्ष स्तर की `internal` फ़ोल्डर[^8] तक सीमित नहीं हैं। आपकी परियोजना[^2] संरचना[^4] के किसी भी स्तर पर एक से अधिक `internal` फ़ोल्डर[^8] हो सकते है।\r\n\r\nआप वैकल्पिक रूप से अपने साझा और गैर-साझा आंतरिक कोड[^13] को अलग करने के लिए अपने आंतरिक संकुलों[^15] में कुछ अतिरिक्त संरचना[^4] जोड़ सकते हैं। इसकी आवश्यकता नहीं है (विशेषकर छोटी परियोजनाओं[^2] के लिए), लेकिन इच्छित संकुल[^15] उपयोग को दर्शाने वाले दृश्य सुराग होना अच्छा है। आपका वास्तविक एप्लिकेशन[^1] कोड[^13] `/internal/app` फ़ोल्डर[^8] में जा सकता है (उदाहरण के लिए, `/internal/app/myapp`) और उन एप्लिकेशनों[^1] द्वारा साझा किया गया कोड[^13] `/internal/pkg` फ़ोल्डर[^8] में जा सकता है (उदाहरण के लिए, `/internal/pkg/myprivlib`).\r\n\r\n### `/pkg`\r\n\r\nभंडार[^16] कोड[^13] जो बाहरी एप्लिकेशनों[^1] द्वारा उपयोग करने के लिए ठीक है (उदाहरण के लिए, `/pkg/mypubliclib`)। अन्य परियोजनाएं[^2] इन भंडारों[^16] को काम करने की उम्मीद में आयात[^10] करेंगी, इसलिए यहां कुछ भी डालने से पहले दो बार सोचें :smile:। ध्यान दें कि `internal` फ़ोल्डर[^8] यह सुनिश्चित करने का एक बेहतर तरीका है कि आपके निजी संकुल[^15] आयात[^10] योग्य नहीं हैं क्योंकि यह Go द्वारा लागू किया गया है। `/pkg` फ़ोल्डर[^8] अभी भी स्पष्ट रूप से यह बताने का एक अच्छा तरीका है कि उस फ़ोल्डर[^8] का कोड[^13] दूसरों के उपयोग के लिए सुरक्षित है। Travis Jeffrey द्वारा [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) ब्लॉग लेख `pkg` और `internal` फ़ोल्डरों[^8] का एक अच्छा अवलोकन[^29] प्रदान करता है और कब उनका उपयोग करना उचित हो सकता है।\r\n\r\nयह Go कोड[^13] को एक ही स्थान पर समूहित करने का एक तरीका है जब आपके मूल[^5] फ़ोल्डर[^8] में बहुत सारे गैर-Go अंग और फ़ोल्डर[^8] होते हैं जिससे विभिन्न Go उपकरण[^30] चलाना आसान हो जाता है (जैसा कि इन वार्ताओं में बताया गया है: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) GopherCon EU २०१८ से, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) और [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk))।\r\n\r\nयदि आप देखना चाहते हैं कि कौनसी लोकप्रिय Go रिपॉजिटरीयाँ[^19] इस परियोजना[^2] अभिन्यास[^3] का उपयोग करती हैं तो [`/pkg`](pkg/README.md) फ़ोल्डर[^8] देखें। यह एक सामान्य अभिन्यास[^3] नमूनां[^7] है, लेकिन यह सार्वभौमिक[^20] रूप से स्वीकृत नहीं है और Go समुदाय के कुछ लोग इसकी अनुशंसा[^26] नहीं करते हैं।\r\n\r\nयदि आपकी एप्लिकेशन[^1] परियोजना[^2] वास्तव में छोटी है और जहां अतिरिक्त स्तर का नेस्टिंग[^31] अधिक मूल्य नहीं जोड़ता है (जब तक कि आप वास्तव में नहीं चाहते :smile:) तो इसका उपयोग न करना ठीक है। इसके बारे में तब सोचें जब यह काफी बड़ी हो रहा हो और आपका मूल[^5] फ़ोल्डर[^8] काफी व्यस्त हो जाए (खासकर यदि आपके पास बहुत सारे गैर-Go एप्लिकेशन[^1] अंग हैं)।\r\n\r\n`pkg` फ़ोल्डर[^8] की उत्पत्ति: पुराने Go स्रोत[^18] कोड[^13] द्वारा अपने संकुलों[^15] के लिए `pkg` का उपयोग किया जाता था और फिर समुदाय में विभिन्न Go परियोजनाओं[^2] ने नमूनें[^7] की प्रतिलिपि बनाना शुरू कर दिया (अधिक संदर्भ के लिए Brad Fitzpatrick का [`यह`](https://x.com/bradfitz/status/1039512487538970624) &#x1D54F; (पूर्व Twitter) पोस्ट[^32] देखें)।\r\n\r\n### `/vendor`\r\n\r\nएप्लिकेशन[^1] निर्भरताएं[^14] (हाथों से या आपके पसंदीदा निर्भरता[^14] प्रबंधन[^17] उपकरण[^30] जैसे नए अंतर्निहित[^33] [`Go Modules`](https://go.dev/wiki/Modules) सुविधा द्वारा प्रबंधित[^17])। `go mod vendor` निर्देश[^34] आपके लिए `/vendor` फ़ोल्डर[^8] बनाएगा। ध्यान दें कि यदि आप Go १.१४ का उपयोग नहीं कर रहे हैं, जहाँ यह पूर्व-निर्धारित[^35] रूप से चालू है, तो आपको अपने `go build` निर्देश[^34] में `-mod=vendor` सूचक[^36] जोड़ने की आवश्यकता हो सकती है।\r\n\r\nयदि आप भंडार[^16] का निर्माण[^23] कर रहे हैं तो अपनी एप्लिकेशन[^1] निर्भरताऔं[^14] को सुपुर्द[^37] न करें।\r\n\r\nध्यान दें कि चूंकि [`1.13`](https://golang.org/doc/go1.13#modules) से Go ने अनुखंड[^22] प्रॉक्सी[^38] सुविधा को भी सक्षम किया है (<https://proxy.golang.org> का उपयोग करके) पूर्व-निर्धारित[^35] रूप से उनके अनुखंड[^22] प्रॉक्सी[^38] सर्वर[^39] के रूप में। इसके बारे में और अधिक पढ़ें [`यहाँ`](https://blog.golang.org/module-mirror-launch) यह देखने के लिए कि क्या यह आपकी सभी आवश्यकताओं और बाधाओं पर फिट बैठता है। यदि ऐसा होता है, तो आपको `vendor` फ़ोल्डर[^8] की बिल्कुल भी आवश्यकता नहीं होगी।\r\n\r\n## सेवा एप्लिकेशन फ़ोल्डर\r\n\r\n### `/api`\r\n\r\nOpenAPI/Swagger विनिर्देशों[^40], JSON स्कीमा[^41] फ़ाइलों[^21], प्रोटोकॉल[^42] परिभाषा फ़ाइलों[^21] के लिए।\r\n\r\nउदाहरण के लिए [`/api`](api/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n## वेब एप्लिकेशन फ़ोल्डर\r\n\r\n### `/web`\r\n\r\nवेब[^43] एप्लिकेशन[^1] विशिष्ट अंग: स्थिर वेब[^43] संपत्तियाँ[^61], सर्वर[^39] पक्ष टेम्पलेट[^44] और SPA (एक पृष्ठ एप्लिकेशन[^1])।\r\n\r\n## सामान्य एप्लिकेशन फ़ोल्डर\r\n\r\n### `/configs`\r\n\r\nकॉन्फ़िगरेशन[^45] फ़ाइल[^21] टेम्पलेट[^44] या पूर्व-निर्धारित[^35] कॉन्फ़िगरेशन[^45]।\r\n\r\nअपनी `confd` या `consul-template` टेम्प्लेट[^44] फ़ाइलें[^21] यहाँ रखें।\r\n\r\n### `/init`\r\n\r\nतंत्र[^46] प्रारंभिकरण[^47] (systemd, upstart, sysv) और प्रक्रिया[^48] प्रबंधक[^17]/पर्यवेक्षक (runit, supervisord) कॉन्फ़िगरेशन[^45]।\r\n\r\n### `/scripts`\r\n\r\nविभिन्न निर्माण[^23], स्थापना[^11], विश्लेषण आदि संचालन करने के लिए स्क्रिप्टें[^49]।\r\n\r\nये स्क्रिप्टें[^49] मूल[^5] स्तर कि Makefile को छोटा और सरल रखती हैं (उदाहरण के लिए, <https://github.com/hashicorp/terraform/blob/main/Makefile>).\r\n\r\nउदाहरण के लिए [`/scripts`](scripts/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n### `/build`\r\n\r\nPackaging और Continuous Integration।\r\n\r\nअपने क्लाउड[^50] (AMI), कंटेनर[^51] (Docker), OS (deb, rpm, pkg) संकुल[^15] कॉन्फ़िगरेशनों[^45] और स्क्रिप्टों[^49] को `/build/package` फ़ोल्डर[^8] में रखें।\r\n\r\nअपने CI (travis, circle, drone) कॉन्फ़िगरेशनों[^45] और स्क्रिप्टों[^49] को `/build/ci` फ़ोल्डर[^8] में रखें। ध्यान दें कि कुछ CI उपकरण[^30] (उदाहरण के लिए, Travis CI) अपनी कॉन्फ़िगरेशन[^45] फ़ाइलों[^21] के स्थान के बारे में बहुत चुनिंदा हैं। कॉन्फ़िगरेशन[^45] फ़ाइलों[^21] को `/build/ci` फ़ोल्डर[^8] में डालने का प्रयास करें और उन्हें उस स्थान से लिंक[^52] करें जहाँ CI उपकरण[^30] उनसे अपेक्षा करते हैं (जब संभव हो)।\r\n\r\n### `/deployments`\r\n\r\nIaaS, PaaS, तंत्र[^46] और कंटेनर[^51] ऑर्केस्ट्रेशन[^53] परिनियोजन[^54] कॉन्फ़िगरेशनों[^45] और टेम्पलेटों[^44] (docker-compose, kubernetes/helm, terraform)। ध्यान दें कि कुछ रिपॉजिटरीयाँ[^19] (विशेष रूप से kubernetes के साथ परिनियोजित[^54] एप्लिकेशनें[^1]) में इस फ़ोल्डर[^8] को `/deploy` कहा जाता है।\r\n\r\n### `/test`\r\n\r\nअतिरिक्त बाहरी परीक्षण[^55] एप्लिकेशनों[^1] और परीक्षण[^55] डेटा[^56] के लिए। बेझिझक `/test` फ़ोल्डर[^8] को अपनी इच्छानुसार संरचित[^4] करें। बड़ी परियोजनाओं[^2] के लिए डेटा[^56] उप-फ़ोल्डर[^8] का होना सार्थक है। उदाहरण के लिए, यदि आप चाहते हैं कि उस फ़ोल्डर[^8] में जो कुछ है उसे अनदेखा करें तो आपके पास `/test/data` या `/test/testdata` हो सकता है। ध्यान दें कि Go \".\" या \"_\" से शुरू होने वाले फ़ोल्डरों[^8] या फ़ाइलों[^21] को भी अनदेखा कर देगा, इसलिए आपके पास अपने परीक्षण[^55] डेटा[^56] फ़ोल्डर[^8] को नाम देने के मामले में अधिक लचीलापन है।\r\n\r\nउदाहरणों के लिए [`/test`](test/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n## अन्य फ़ोल्डर\r\n\r\n### `/docs`\r\n\r\nडिज़ाइन[^57] और उपयोगकर्ता दस्तावेज़ों[^9] (आपके godoc द्वारा उत्पन्न दस्तावेज़ों[^9] के अतिरिक्त) के लिए।\r\n\r\nउदाहरणों के लिए [`/docs`](docs/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n### `/tools`\r\n\r\nपरियोजना[^2] के लिए सहायक उपकरणों[^30] के लिए। ध्यान दें कि ये उपकरण[^30] `/pkg` और `/internal` फ़ोल्डरों[^8] से कोड[^13] आयात[^10] कर सकते हैं।\r\n\r\nउदाहरणों के लिए [`/tools`](tools/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n### `/examples`\r\n\r\nआपकी एप्लिकेशनों[^1] और/या सार्वजनिक[^58] भंडारों[^16] के लिए उदाहरणों के लिए।\r\n\r\nउदाहरणों के लिए [`/examples`](examples/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n### `/third_party`\r\n\r\nबाहरी सहायक उपकरणों[^30], फोर्क[^59] किया हुए कोड[^13] और अन्य तृतीय पक्ष उपयोगिताऔं (उदाहरण के लिए, Swagger UI) के लिए।\r\n\r\n### `/githooks`\r\n\r\nGit हुकों[^60] के लिए।\r\n\r\n### `/assets`\r\n\r\nअन्य संपत्तियाँ[^61] जैसे चित्र, प्रतीक-चिन्ह[^62] इत्यादि के लिए जो परियोजना[^2] से संबंधित हैं।\r\n\r\n### `/website`\r\n\r\nयदि आप GitHub Pages का उपयोग नहीं कर रहे हैं तो यह आपकी परियोजना[^2] की वेबसाइट[^63] डेटा[^56] डालने का स्थान है।\r\n\r\nउदाहरणों के लिए [`/website`](website/README.md) फ़ोल्डर[^8] देखें।\r\n\r\n## फ़ोल्डर जो आपके पास नहीं होना चाहिए\r\n\r\n### `/src`\r\n\r\nकुछ Go परियोजनाओं[^2] में एक `src` फ़ोल्डर[^8] होता है, लेकिन यह आमतौर पर तब होता है जब डेवलपर[^6] Java दुनिया से आते हैं जहाँ यह एक सामान्य नमूनां[^7] है। यदि आप अपनी मदद कर सकते हैं तो इस Java नमूनें[^7] को न अपनाने का प्रयास करें। आप वास्तव में नहीं चाहते कि आपका Go कोड[^13] या Go परियोजना[^2] Java जैसे दिखें। :smile:\r\n\r\nपरियोजना[^2] स्तर के `/src` फ़ोल्डर[^8] को उस `/src` फ़ोल्डर[^8] के साथ भ्रमित न करें जिसका उपयोग Go अपने कार्यक्षेत्रों[^64] के लिए करता है जैसा कि [`How to Write Go Code`](https://golang.org/doc/code.html) में वर्णित है। `$GOPATH` पर्यावरण चर[^65] आपके (वर्तमान) कार्यक्षेत्र[^64] को इंगित करता है (डिफ़ॉल्ट रूप से यह गैर-Windows तंत्र[^46] पर `$HOME/go` को इंगित करता है)। इस कार्यक्षेत्र[^64] में शीर्ष स्तर `/pkg`, `/bin` और `/src` फ़ोल्डरें[^8] शामिल हैं। आपकी वास्तविक परियोजना[^2] `/src` के अंतर्गत एक उप-फ़ोल्डर[^8] बनकर समाप्त होता है, इसलिए यदि आपकी परियोजना[^2] में `/src` फ़ोल्डर[^8] है तो परियोजना[^2] पथ इस तरह दिखेगा: `/some/path/to/workspace/src/your_project/src/your_code.go`. ध्यान दें कि Go १.११ के साथ आपकी परियोजना[^2] को आपके `$GOPATH` के बाहर रखना संभव है, लेकिन फिर भी इसका मतलब यह नहीं है कि इस अभिन्यास[^3] नमूनें[^7] का उपयोग करना एक अच्छा विचार है।\r\n\r\n## बैज\r\n\r\n* [Go Report Card](https://goreportcard.com/) - यह आपके कोड[^13] को `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` और `misspell` के साथ स्कैन करेगा। `github.com/golang-standards/project-layout` को अपनी परियोजना[^2] संदर्भ से बदलें।\r\n\r\n  [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\r\n\r\n* ~~[GoDoc](http://godoc.org) - यह आपके GoDoc जनित दस्तावेज़[^9] का ऑनलाइन संस्करण प्रदान करेगा। अपनी परियोजना[^2] को इंगित करने के लिए लिंक[^52] बदलें।~~\r\n\r\n  [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\r\n\r\n* [pkg.go.dev](https://pkg.go.dev) - pkg.go.dev Go खोज और दस्तावेज़ों[^9] के लिए एक नया ठिकाना है। आप [बैज निर्माण[^23] उपकरण[^30]](https://pkg.go.dev/badge) का उपयोग करके एक बैज बना सकते हैं।\r\n\r\n  [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\r\n\r\n* प्रकाशन - यह आपकी परियोजना[^2] के लिए नवीनतम प्रकाशन अंक दिखाएगा। अपनी परियोजना[^2] को इंगित करने के लिए GitHub लिंक[^52] बदलें।\r\n\r\n  [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\r\n\r\n## टिप्पणी\r\n\r\nनमूनें[^7]/पुन: उपयोगी कॉन्फ़िगरेशनें[^45], स्क्रिप्टें[^49] और कोड[^13] के साथ एक अधिक विचारशील परियोजना[^2] टेम्पलेट[^44] कार्य प्रगति पर है।\r\n\r\n## शब्द सूची\r\n\r\nनीचे दिए गए तिरछे शब्द आगत शब्द हैं।\r\n\r\n[^0]: मानक - standard\r\n[^1]: *एप/एप्लिकेशन* - app/application\r\n[^2]: परियोजना - project\r\n[^3]: अभिन्यास - layout\r\n[^4]: संरचना - structure\r\n[^5]: मूल - core/root\r\n[^6]: *डेव/डेवलपर* - dev/developer\r\n[^7]: नमूनां - pattern\r\n[^8]: *फ़ोल्डर* - folder\r\n[^9]: दस्तावेज़ - document\r\n[^10]: आयात - import\r\n[^11]: स्थापन - install\r\n[^12]: अवधारणा प्रमाण - proof of concept\r\n[^13]: *कोड* - code\r\n[^14]: निर्भरता - dependency\r\n[^15]: संकुल - package\r\n[^16]: भंडार - library\r\n[^17]: प्रबंध - manage\r\n[^18]: स्रोत - source\r\n[^19]: *रिपॉजिटरी* - repository\r\n[^20]: सार्वभौमिक - universal\r\n[^21]: *फ़ाइल* - file\r\n[^22]: अनुखंड - module\r\n[^23]: निर्माण - build\r\n[^24]: शैली - style\r\n[^25]: *लिंट* - lint\r\n[^26]: अनुशंसा - recommend\r\n[^27]: फलन - function\r\n[^28]: संकलनकर्ता - compiler\r\n[^29]: अवलोकन - overview\r\n[^30]: उपकरण - tool\r\n[^31]: *नेस्टिंग* - nesting\r\n[^32]: *पोस्ट* - post\r\n[^33]: अंतर्निहित - built-in\r\n[^34]: निर्देश - command\r\n[^35]: पूर्व-निर्धारित - default\r\n[^36]: सूचक - flag\r\n[^37]: सुपुर्द - commit\r\n[^38]: *प्रॉक्सी* - proxy\r\n[^39]: *सर्वर* - server\r\n[^40]: विनिर्देश - specification\r\n[^41]: *स्कीमा* - schema\r\n[^42]: *प्रोटोकॉल* - protocol\r\n[^43]: वेब - web\r\n[^44]: टेम्पलेट - template\r\n[^45]: *कॉन्फ़िग/कॉन्फ़िगर* - config/configure\r\n[^46]: तंत्र - system\r\n[^47]: प्रारंभिकरण - init/initialization\r\n[^48]: प्रक्रिया - process\r\n[^49]: *स्क्रिप्ट* - script\r\n[^50]: *क्लाउड* - cloud\r\n[^51]: *कंटेनर* - container\r\n[^52]: *लिंक* - link\r\n[^53]: *ऑर्केस्ट्रेशन* - orchestration\r\n[^54]: परिनियोजन - deployment\r\n[^55]: परीक्षण - testing\r\n[^56]: *डेटा* - data\r\n[^57]: *डिज़ाइन* - design\r\n[^58]: सार्वजनिक - public\r\n[^59]: *फोर्क* - fork\r\n[^60]: *हुक* - hook\r\n[^61]: संपत्ति - asset\r\n[^62]: प्रतीक-चिन्ह - logo\r\n[^63]: *वेबसाइट* - website\r\n[^64]: कार्यक्षेत्र - workspace\r\n[^65]: चर - variable\r\n"
        },
        {
          "name": "README_id.md",
          "type": "blob",
          "size": 15.71,
          "content": "# Standar Tata Letak Proyek Go\n\nTerjemahan:\n\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Ringkasan\n\nBerikut ini merupakan tata letak dasar untuk proyek aplikasi Go. Ini **`bukan standar resmi yang ditetapkan oleh tim pengembang inti Go`**; namun, ini merupakan sejumlah pola tata letak proyek historis dan terkini yang umumnya digunakan dalam ekosistem Go. Beberapa pola ini lebih populer daripada yang lain. Selain itu, terdapat beberapa pembaharuan kecil bersama dengan beberapa direktori pendukung yang umum ditemukan dalam aplikasi dunia nyata yang cukup besar.\n\nJika kamu sedang belajar Go atau sedang membangun PoC atau proyek sederhana untuk dirimu sendiri, tata letak proyek ini terlalu berlebihan. Mulailah dengan sesuatu yang sederhana saja (sebuah file `main.go` tunggal dan `go.mod` sudah cukup). Ketika proyekmu berkembang, penting untuk memastikan kodemu terstruktur dengan baik, jika tidak, kamu akan berakhir dengan kode yang berantakan dengan banyak dependensi tersembunyi dan state global. Ketika ada lebih banyak orang yang bekerja pada proyekmu, kamu akan membutuhkan struktur yang lebih terorganisir. Itulah saat yang penting untuk memperkenalkan cara umum dalam mengelola paket/pustaka. Ketika kamu memiliki proyek open source atau ketika kamu tahu proyek lain mengimpor kode dari repositori proyekmu, saat itulah penting untuk memiliki paket dan kode pribadi (dikenal juga sebagai `internal`). Klon repositori tersebut, ambil yang kamu butuhkan, dan hapus sisanya! Hanya karena ada di sana, tidak berarti kamu harus menggunakan semuanya. Tidak satu pun dari pola-pola ini digunakan dalam setiap proyek. Bahkan pola `vendor` tidaklah universal.\n\nDengan Go 1.14, [`Go Modules`](https://go.dev/wiki/Modules) akhirnya siap digunakan untuk produksi. Gunakan [`Go Modules`](https://blog.golang.org/using-go-modules) kecuali kamu memiliki alasan khusus untuk tidak menggunakannya. Jika kamu tidak menggunakan Go Modules, maka kamu tidak perlu khawatir tentang `$GOPATH` dan di mana kamu meletakkan proyekmu. File `go.mod` di dalam repositori ini mengasumsikan bahwa proyekmu di-host di GitHub, tetapi itu bukan menjadi persyaratan. Path modul dapat menjadi apa saja, meskipun komponen path modul pertama sebaiknya memiliki tanda titik dalam namanya (versi Go saat ini tidak lagi memaksakannya, tetapi jika kamu menggunakan versi yang sedikit lebih lama, jangan heran jika proses build tidak akan berhasil). Lihat isu [`37554`](https://github.com/golang/go/issues/37554) dan [`32819`](https://github.com/golang/go/issues/32819) jika kamu ingin tahu lebih banyak mengenai hal ini.\n\nTata letak proyek ini sengaja dirancang secara generik dan tidak mencoba memaksakan struktur paket Go yang spesifik.\n\nIni merupakan usaha komunitas. Buka sebuah isu jika kamu melihat pola baru atau jika kamu berpikir bahwa salah satu pola yang sudah ada perlu diperbarui.\n\nJika kamu membutuhkan bantuan dalam hal penamaan, pemformatan, dan gaya penulisan, mulailah dengan menjalankan [`gofmt`](https://golang.org/cmd/gofmt/) dan [`golint`](https://github.com/golang/lint). Pastikan juga untuk membaca panduan dan rekomendasi gaya penulisan kode Go berikut ini:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nLihatlah [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) untuk informasi latar belakang tambahan.\n\nLebih lanjut tentang penamaan dan pengorganisasian paket serta rekomendasi struktur kode lainnya:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nSebuah postingan dalam bahasa Cina tentang pedoman Package-Oriented Design dan Architecture layer:\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Direktori Go\n\n### `/cmd`\n\nAplikasi utama untuk proyek ini.\n\nNama direktori untuk setiap aplikasi harus sesuai dengan nama file eksekusi yang diinginkan (misalnya, `/cmd/myapp`).\n\nJangan menempatkan banyak kode di dalam direktori aplikasi. Jika anda berpikir bahwa kode tersebut dapat diimpor dan digunakan dalam proyek lain, maka kode tersebut harus ditempatkan di dalam direktori `/pkg`. Jika kode tersebut tidak dapat digunakan kembali atau jika anda tidak ingin orang lain menggunakannya kembali, letakkan kode tersebut di dalam direktori `/internal`. Anda akan terkejut dengan apa yang orang lain lakukan, jadi tetap jelaskan niat anda! \n\nBiasanya, terdapat fungsi `main` kecil yang mengimpor dan memanggil kode dari direktori `/internal` dan `/pkg`, dan tidak ada yang lain.\n\nLihat direktori [`/cmd`](cmd/README.md) untuk contoh-contoh lebih lanjut.\n\n### `/internal`\n\nKode aplikasi dan library privat. Ini adalah kode anda yang tidak ingin diimpor oleh aplikasi atau library lain. Perlu dicatat bahwa pola tata letak ini dipaksakan atau dijaga oleh kompiler Go itu sendiri. Lihat catatan rilis Go 1.4 [`di sini`](https://golang.org/doc/go1.4#internalpackages) untuk detailnya. Perhatikan bahwa anda tidak dibatasi pada direktori top level `internal` saja. Anda dapat memiliki lebih dari satu direktori `internal` di setiap tingkatan proyek anda.\n\nSecara opsional anda dapat menambahkan struktur tambahan ke paket internal anda, untuk memisahkan kode internal yang bersifat shared dan non-shared. Hal ini tidak diwajibkan (terutama untuk proyek-proyek kecil), tetapi bagus untuk memiliki petunjuk visual yang menunjukkan penggunaan paket yang dimaksudkan. Sebenarnya kode aplikasi dapat ditempatkan di direktori `/internal/app` (misalnya, `/internal/app/myapp`) dan kode yang dibagikan oleh aplikasi tersebut dapat ditempatkan di direktori `/internal/pkg` (misalnya, `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nKode library yang boleh digunakan oleh aplikasi eksternal (misalnya, `/pkg/mypubliclib`). Proyek lain akan mengimpor library ini dengan harapan dapat berfungsi, jadi berpikirlah dua kali sebelum anda meletakkan sesuatu di sini :-) Perlu dicatat bahwa direktori `internal` adalah cara yang lebih baik untuk memastikan paket pribadi anda tidak dapat diimpor karena dijaga oleh Go. Namun, direktori `/pkg` tetap cara yang baik untuk mengkomunikasikan secara eksplisit  bahwa kode di dalam direktori tersebut aman digunakan oleh orang lain. Postingan [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) oleh Travis Jeffery memberikan gambaran yang baik tentang direktori `pkg` dan `internal` serta kapan waktu yang tepat untuk menggunakannya.\n\nHal ini merupakan cara untuk mengelompokkan kode Go di satu tempat ketika direktori root anda berisi banyak komponen dan direktori non-Go, sehingga memudahkan dalam menjalankan berbagai tools Go (seperti yang disebutkan dalam presentasi-presentasi ini: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) dari GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0), dan [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nLihat direktori [`/pkg`](pkg/README.md) jika anda ingin melihat repositori Go populer yang menggunakan pola tata letak proyek seperti ini. Ini adalah pola tata letak yang umum digunakan, akan tetapi tidak diterima secara universal dan beberapa anggota komunitas Go tidak merekomendasikannya.\n\nTidak masalah jika anda tidak menggunakannya, apabila proyek aplikasi anda benar-benar kecil dan tingkatan level tambahan tidak begitu penting (kecuali jika anda benar-benar menginginkannya :-)). Pikirkanlah hal tersebut ketika proyek anda cukup besar dan direktori root anda sudah cukup sibuk (terutama jika anda memiliki banyak komponen aplikasi non-Go).\n\nAsal-usul direktori `pkg`: Source code Go yang lama menggunakan `pkg` untuk paket-paketnya, dan kemudian berbagai proyek Go dalam komunitas mulai meniru pola tersebut (Lihat [`tweet Brad Fitzpatrick ini`](https://twitter.com/bradfitz/status/1039512487538970624) untuk konteks lebih lanjut).\n\n### `/vendor`\n\nDependensi aplikasi (dikelola secara manual atau dengan dependency management tool favorit anda seperti fitur baru bawaan [`Go Modules`](https://go.dev/wiki/Modules). Perintah `go mod vendor` akan membuat direktori `/vendor `untuk anda. Perlu dicatat bahwa anda mungkin perlu menambahkan flag `-mod=vendor` ke perintah `go build` jika anda tidak menggunakan Go 1.14 di mana fitur tersebut sudah diaktifkan secara default.\n\nJangan meng-commit dependency aplikasi anda jika anda sedang membangun sebuah library.\n\nPerlu dicatat bahwa sejak versi [`1.13`](https://golang.org/doc/go1.13#modules), Go telah mengaktifkan fitur module proxy (menggunakan [`https://proxy.golang.org`](https://proxy.golang.org) sebagai server proxy modul default). Baca lebih lanjut tentang fitur ini [`di sini`](https://blog.golang.org/module-mirror-launch) untuk melihat apakah sesuai dengan semua persyaratan dan batasan anda. Jika sesuai, maka anda sama sekali tidak perlu menggunakan direktori `vendor`.\n\n## Direktori Servis Aplikasi\n\n### `/api`\n\nSpesifikasi OpenAPI/Swagger, file skema JSON, file definisi protokol.\n\nLihat direktori [`/api`](api/README.md) untuk contoh-contohnya.\n\n### `/web`\n\nKomponen-komponen spesifik aplikasi web: aset web statis, template di sisi server, dan SPAs.\n\n## Direktori Umum Aplikasi\n\n### `/configs`\n\nTemplate file konfigurasi atau konfigurasi default.\n\nLetakkan file template anda di `confd` atau `consul-template`..\n\n### `/init`\n\nKonfigurasi sistem init (systemd, upstart, sysv) dan manajer proses/supervisor (runit, supervisord).\n\n### `/scripts`\n\nSkrip-skrip untuk melakukan berbagai operasi seperti build, instalasi, analisis, dll.\n\nSkrip-skrip ini menjaga Makefile tingkat root agar tetap kecil dan sederhana (misalnya, [`https://github.com/hashicorp/terraform/blob/master/Makefile`](https://github.com/hashicorp/terraform/blob/master/Makefile)).\n\nLihat direktori [`/scripts`](scripts/README.md) untuk melihat contoh-contohnya.\n\n### `/build`\n\nPemaketan (Packaging) dan Integrasi Berkelanjutan (Continuous Integration).\n\nLetakkan skrip paket dan konfigurasi untuk cloud (AMI), container (Docker), sistem operasi (deb, rpm, pkg) anda di direktori `/build/package`.\n\nLetakkan skrip dan konfigurasi CI (travis, circle, drone) anda di direktori `/build/ci`. Perhatikan bahwa beberapa tools CI (misalnya, Travis CI) sangat ketat mengenai lokasi file konfigurasi mereka. Coba letakkan file konfigurasi di direktori `/build/ci` dan buat tautan ke lokasi yang diharapkan oleh tools CI (jika memungkinkan).\n\n### `/deployments`\n\nKonfigurasi dan template untuk IaaS, PaaS, orkestrasi sistem, dan container (docker-compose, kubernetes/helm, mesos, terraform, bosh). Perhatikan bahwa dalam beberapa repositori (terutama aplikasi yang diimplementasikan dengan kubernetes), direktori ini disebut `/deploy`.\n\n### `/test`\n\nTambahan eksternal untuk menguji aplikasi dan data. Aturlah struktur direktori `/test` sesuai keinginan anda. Untuk proyek yang lebih besar, disarankan memiliki subdirektori data. Misalnya, anda dapat memiliki `/test/data` atau `/test/testdata` jika anda ingin Go mengabaikan apa yang ada dalam direktori tersebut. Perhatikan bahwa Go juga akan mengabaikan direktori atau file yang dimulai dengan \".\" atau \"_\", sehingga anda memiliki fleksibilitas lebih dalam penamaan direktori data pengujian.\n\nLihat direktori [`/test`](test/README.md) untuk contoh-contohnya.\n\n## Direktori Lainya\n\n### `/docs`\n\nDokumentasi desain dan pengguna (selain dokumentasi yang dihasilkan oleh godoc).\n\nLihat direktori [`/docs`](docs/README.md) untuk contoh-contohnya.\n\n### `/tools`\n\nTools pendukung untuk proyek ini. Perhatikan bahwa tools ini dapat mengimpor kode dari direktori `/pkg` dan `/internal`.\n\nLihat direktori [`/tools`](tools/README.md) untuk contoh-contohnya.\n\n### `/examples`\n\nContoh-contoh aplikasi atau library publik anda.\n\nLihat direktori [`/examples`](examples/README.md) untuk melihat contoh-contohnya.\n\n### `/third_party`\n\nTools eksternal, kode yang di-fork, dan utilitas pihak ketiga (third party) lainnya (misalnya, Swagger UI).\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\nAset lainnya yang ada di repositori anda (gambar, logo, dll).\n\n### `/website`\n\nTempat untuk meletakkan data situs web proyek anda jika anda tidak menggunakan halaman GitHub.\n\nLihat direktori [`/website`](website/README.md) untuk contoh-contohnya.\n\n## Direktori yang Sebaiknya Tidak Dimiliki\n\n### `/src`\n\nBeberapa proyek Go memiliki folder `src`, akan tetapi ini biasanya terjadi ketika pengembang berasal dari dunia Java di mana itu adalah pola umum. Jika memungkinkan, hindari mengadopsi pola Java ini. Anda benar-benar tidak ingin kode Go atau proyek Go anda terlihat seperti Java :-)\n\nJangan bingung antara direktori proyek `/src` dengan direktori `/src` yang digunakan Go untuk workspace-nya seperti yang dijelaskan dalam [`How to Write Go Code`](https://golang.org/doc/code.html). Variabel environtment `$GOPATH` menunjuk ke workspace anda saat ini (secara default menunjuk ke `$HOME/go` pada sistem non-Windows). Workspace ini mencakup direktori top level `/pkg`, `/bin`, dan `/src`. Proyek aktual anda berada di bawah direktori `/src`, jadi jika anda memiliki direktori `/src` di proyek anda, path proyek akan terlihat seperti ini: `/some/path/to/workspace/src/your_project/src/your_code.go`. Perlu diingat bahwa dengan Go 1.11, memungkinkan untuk memiliki proyek di luar `GOPATH`, tetapi bukan berarti itu adalah ide yang baik untuk menggunakan pola tata letak ini.\n\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - Akan memindai kode anda menggunakan `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` dan `misspell`. Ubah `github.com/golang-standards/project-layout` dengan referensi proyek anda.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) -Ini akan menyediakan versi online dari dokumentasi yang dihasilkan oleh GoDoc anda. Ubah tautan tersebut agar mengarah ke proyek anda.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev adalah tempat baru untuk menemukan dan mendokumentasikan Go. Anda dapat membuat badge menggunakan [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - Ini akan menampilkan nomor rilisan terbaru untuk proyek anda. Ubah tautan GitHub menjadi menunjuk ke proyek anda.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Catatan\n\nOpsi template lainya disertai contoh konfigurasi, skrip, dan kode yang dapat digunakan kembali sedang dalam pengembangan (WIP).\n"
        },
        {
          "name": "README_it.md",
          "type": "blob",
          "size": 15.31,
          "content": "# Layout standard di un progetto Go\n\nTraduzioni:\n\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Panoramica\n\nQuesta è un'impostazione di base per applicativi Go. **Non è uno standard ufficiale definito dal team principale di Go**; Invece è un insieme di pattern archittetturali provenienti da progetti ben consolidati nell'ecosistema Go. Alcuni di questi pattern sono più popolari di altri. Sono presenti anche diversi piccoli miglioramenti con alcune cartelle di supporto comuni a qualsiasi grande applicativo in contesto reale.\n\n**`Se stai imparando Go o se stai sviluppando una PoC o un semplice progetto personale, questa struttura è una complicazione non necessaria. Invece inizia con qualcosa di veramente semplice (un unico file `main.go` e `go.mod` è abbastanza).`** Con la crescita del tuo progetto tieni a mente che sarà sempre più importante la corretta impostazione del tuo codice, altrimenti finirai con codice disordinato con molte dipendenze nascoste e uno stato globale. Quando più persone lavorano su un progetto, avrai bisogno di un'impostazione ancora più strutturata. Questo è il momento in cui è importante introdurre un modo comune di gestire pacchetti e librerie. Quando hai un progetto open source o quando sai che altri progetti importano il codice del tuo repository, questo è il momento in cui è importante avere pacchetti e codice privato (`internal`). Clona il repository, mantieni ciò di cui hai bisogno e cancella qualsiasi altra cosa! Solo perchè è presente non significa che vada usato. Nessuno di questi pattern sono usati in ogni singolo progetto. Perfino il `vendor` pattern non è universale.\n\nCon Go 1.14 i [`Go Modules`](https://go.dev/wiki/Modules) sono finalmente pronti per la produzione. Usa [`Go Modules`](https://blog.golang.org/using-go-modules) fino a quando hai una specifica ragione per non usarli e se lo farai non dovrai preoccuparti riguardo $GOPATH e dove mettere il tuo progetto. Il file `go.mod` di base nel repo presuppone che il tuo progetto sia pubblicato su GitHub, ma non è obbligatorio. Il path del modulo può essere uno qualsiasi, anche se la prima parte del path del modulo dovrebbe avere un punto nel nome (l'attuale versione di Go non lo forza più, ma se stai usando una delle versioni leggermente più vecchie, non essere sorpreso se le tue builds falliranno). Guarda le Issues [`37554`](https://github.com/golang/go/issues/37554) e [`32819`](https://github.com/golang/go/issues/32819) se vuoi saperne di più a riguardo.\n\nQuesta struttura di progetto è intenzionalmente generica e non cerca di imporre una specifica impostazione per i packages Go.\n\nQuesto è uno sforzo della community. Apri una issue se vedi un nuovo pattern o se pensi che uno di quelli esistenti andrebbe aggiornato.\n\nSe hai bisogno di aiuto per la nomenclatura, formattazione e lo stile, inizia da utilizzare [`gofmt`](https://golang.org/cmd/gofmt/) e [`golint`](https://github.com/golang/lint).  Assicurati anche di leggere le linee guida di stile e i consigli:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nVedi [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) per l'aggiunta di altre informazioni a contorno.\n\nPer altro riguardo la nomenclatura e l'organizzazione dei pacchetti e altre impostazioni raccomandate:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nUn post Cinese riguardo delle linee guida per il design Package-Oriented e layer archittetturali\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go Cartelle\n\n### `/cmd`\n\nApplicazioni principali per questo progetto.\n\nIl nome della cartella per ciascun applicativo dovrebbe coincidere con il nome che vuoi avere per l'eseguibile (es: `/cmd/myapp`).\n\nNon mettere molto codice nella cartella dell'applicazione. Se pensi che il codice potrebbe essere importato e usato in altri progetti, allora dovrebbe essere inserito nella cartella `/pkg`. Se il codice non è riutilizzabile o non vuoi che altri lo riutilizzino, metti questo codice nella cartella `/internal`. Sarai sorpreso di vedere cosa faranno gli altri, quindi si esplicito riguardo le tue intenzioni!\n\nE' comune avere una piccola funzione `main` che importa e invoca il codice dalle cartelle `/internal` e `/pkg` e nient'altro.\n\nVedi cartella [`/cmd`](cmd/README.md) per esempi.\n\n### `/internal`\n\nApplicativo privato e codice di libreria. Quì c'è il codice che non vuoi gli altri importino nei loro progetti o librerie. Nota che questo pattern archittetturale è forzato dallo stesso compilatore Go. Vedi Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) per maggiori dettagli. Nota che non sei obbligato ad avere unicamente la cartella padre `internal`. Puoi avere più di una singola cartella `internal` a qualsiasi livello della tua ramificazione di progetto.\n\n\nPuoi opzionalmente aggiungere una struttura aggiuntiva ai tuoi pacchetti interni, per separare il tuo codice interno condiviso e non condiviso. Non è obbligatorio (specialmente per piccoli progetti), ma è meglio avere indicazioni per mostrare l'utilizzo raccomandato del pacchetto. Il tuo effettivo codice applicativo può essere inserito nella cartella `/internal/app` (es: `/internal/app/myapp`) e il codice condiviso da queste app nella cartella `/internal/pkg` (es: `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nCodice di libreria che può essere utilizzato da applicazioni esterne (es:, `/pkg/mypubliclib`). Altri progetti importeranno queste librerie aspettandosi che funzionino, quindi pensaci bene prima di metterci dentro qualcosa :-) Nota che la cartella `internal` è un modo migliore di assicurarsi che i tuoi pacchetti privati non sono importabili, perché ciò è forzato in Go. La cartella `/pkg` è anche un buon modo di esplicitare che il codice contenuto al suo interno è utilizzabile da parte di altri. Il post [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) scritto da Travis Jeffery fornisce una buona panoramica delle cartelle `pkg` e `internal` indicando quando abbia senso usarle.\n\nC'è anche un modo di raggruppare il codice Go in unico posto quando la tua cartella di root contiene molti componenti non-Go e cartelle semplificando l'utilizzo di vari strumenti Go (come menzionato in questi talk: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) dal GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) e [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nGuarda la cartella [`/pkg`](pkg/README.md) se vuoi vedere quali popolari repo utilizzano questa struttura di progetto. Questo è un pattern di layout comune, tuttavia non è universalmente accettato e qualcuno nella community Go non lo raccomanda.\n\nÈ ok non utilizzarla se il tuo progetto è molto piccolo e aggiungere un ulteriore strato di annidamento non dà un valore aggiunto (a meno che tu non lo voglia davvero molto :-)). Pensa di prevederla quando sta diventando grande abbastanza e la tua cartella root si sta riempendo troppo (specialmente quando hai molti componenti non Go nell'applicativo).\n\nOrigini della cartella `pkg`: Il vecchio codice sorgente di Go usava la cartella `pkg` per i suoi pacchetti e così diversi progetti Go nella community hanno iniziato a copiare questo pattern (vedi [`questo`](https://twitter.com/bradfitz/status/1039512487538970624) tweet di Brad Fitzpatrick per avere un contesto più dettagliato).\n\n### `/vendor`\n\nDipendenze dell'applicativo (gestite manualmente o dal tuo gestore di pacchetti preferito come la nuova feature built-in [`Go Modules`](https://go.dev/wiki/Modules)). Il comando `go mod vendor` creerà  la cartella `/vendor` per te. Tiene presente che potrebbe essere necessario aggiungere il flag `-mod=vendor` al tuo comando `go build` se non stai utilizzando Go 1.14, dove è utilizzato di default.\n\nNon effettuare il commit delle dipendenze del tuo applicativo se stai sviluppando una libreria.\n\nNota che sin dalla versione [`1.13`](https://golang.org/doc/go1.13#modules) Go ha anche abilitata la caratteristica del module proxy (usando [`https://proxy.golang.org`](https://proxy.golang.org) come server proxy predefinito). Approfondisci [`quì`](https://blog.golang.org/module-mirror-launch) per vedere se questo soddisfa tutti i tuoi requisiti e vincoli. In caso positivo, allora non avrai bisogno della cartella `vendor`.\n\n## Cartelle di Servizio Applicativo\n\n### `/api`\n\nOpenAPI/Swagger specs, JSON schema files, files di definizione del protocollo.\n\nVedi la cartella [`/api`](api/README.md) per esempi.\n\n## Cartelle Applicativo Web\n\n### `/web`\n\nComponenti specifici per applitavi Web: assets web statici, templates server side e SPAs.\n\n## Cartelle comuni applicativo\n\n### `/configs`\n\nTemplates per il file di configurazione o configurazioni di default.\n\nMetti i tuoi templates `confd` o `consul-template` quì.\n\n### `/init`\n\nInizializzazione del sistema (systemd, upstart, sysv) e configurazioni per process manager/supervisor (runit, supervisord).\n\n### `/scripts`\n\nScript per effettuare varie operazioni per la build, installazione, analisi, ecc...\n\nQuesti script mantengono a livello di root un Makefile piccolo e immediato (es: [`https://github.com/hashicorp/terraform/blob/master/Makefile`](https://github.com/hashicorp/terraform/blob/master/Makefile)).\n\nVedi la cartella [`/scripts`](scripts/README.md) per esempi.\n\n### `/build`\n\nPackaging e Continuous Integration.\n\nMetti le configurazioni dei tuoi pacchetti: cloud (AMI), container (Docker), OS (deb, rpm, pkg) e script nella cartella `/build/package`.\n\nMetti le tue configurazioni della CI (travis, circle, drone) e script nella cartella `/build/ci`. Nota che qualche tool di CI (es: Travis CI) sono molto stringenti riguardo la posizione dei propri file di configurazione. Prova mettendo le configurazioni nella cartella `/build/ci` collegandole al percorso dove gli strumenti di CI se le aspettano (quando possibile).\n\n### `/deployments`\n\nConfigurazioni e template per distribuzioni IaaS, PaaS, di sistema e basati su sistemi di orchestrazione (docker-compose, kubernetes/helm, mesos, terraform, bosh). Nota che in alcuni repo (specialmente per gli applicativi pubblicati con kubernetes) questa cartella è chiamata `/deploy`.\n\n### `/test`\n\nUlteriori app di test esterne e dati di test. Sentiti libero di strutturare la cartella `/test` come preferisci. Per progetti più grandi ha senso avere una sotto cartella data. Per esempio potresti avere  `/test/data` o `/test/testdata` se hai bisogno che Go ignori il contenuto di questa cartella. Nota che Go ignorerà anche le cartelle o file che iniziano con \".\" o \"_\", così si ha più flessibilità in termini di come intendi chiamare la cartella dei tuoi dati test.\n\nVedi la cartella [`/test`](test/README.md) per esempi.\n\n## Altre Cartelle\n\n### `/docs`\n\nDocumenti dell'utente e di Design (in aggiunta alla tua documentazione godoc autogenerata).\n\nVedi la cartella [`/docs`](docs/README.md) per esempi.\n\n### `/tools`\n\nStrumenti di supporto per il progetto. Nota che questi strumenti possono importare codice dalle cartelle `/pkg` e `/internal`.\n\nVedi la cartella [`/tools`](tools/README.md) per esempi.\n\n### `/examples`\n\nEsempi per il tuo applicativo e/o librerie pubbliche.\n\nVedi la cartella [`/examples`](examples/README.md) per esempi.\n\n### `/third_party`\n\nStrumenti esterni di aiuto, codice forcato e altre utility di terze parti (es: Swagger UI).\n\n### `/githooks`\n\nHook di Git.\n\n### `/assets`\n\nAltri asset del tuo repository (immagini, loghi, etc).\n\n### `/website`\n\nQuesto è il posto in cui inserire i dati del sito Web del tuo progetto se non stai utilizzando le GitHub pages.\n\nVedi la cartella [`/website`](website/README.md) per esempi.\n\n## Cartelle che Non Dovresti Avere\n\n### `/src`\n\nQualche progetto Go ha una cartella `src`, ma comunemente succede quando gli sviluppatori provengono dal mondo Java, dove è una pratica comune. Se vuoi aiutarti prova a non adottare questo pattern Java. Non vuoi davvero che il tuo codice Go o i tuoi progetti Go assomiglino a quelli Java :-)\n\nNon confondere la cartella `/src` a livello di progetto con la cartella `/src` che Go utilizza per i suoi workspace come descritto in [`How to Write Go Code`](https://golang.org/doc/code.html). La variabile di ambiente `$GOPATH` punta al tuo (attuale) workspace (di default punta a `$HOME/go` su sistemi non Windows). Questo workspace include le cartelle di livello superiore `/pkg`, `/bin` e `/src`. Il tuo progetto attuale finisce per essere una sotto cartella di `/src`, quindi se hai la cartella `/src` nel tuo progetto, il tuo path di progetto assomiglierà a questo: `/some/path/to/workspace/src/your_project/src/your_code.go`. Nota che da Go 1.11 è possibile avere il proprio progetto al di fuori del `GOPATH`, ma ciò non significa che sia una buona idea utilizzare questo pattern di layout.\n\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - Scansione il tuo codice con `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` e `misspell`. Rimpiazza `github.com/golang-standards/project-layout` con la referenza al tuo progetto.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - Fornisce una verione online della tua documentazione GoDoc generata. Cambia il link per puntare al tuo progetto.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev è una nuova fonte per la scoperta di Go e documentazione. Puoi creare un badge usando lo [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - Mostra l'ultima versione per il tuo progetto. Cambia il link github per puntare al tuo progetto.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Note\n\nUn template di progetto standardizzato con configurazioni semplici e riutilizzabili, gli aggiornamenti per gli script e il codice sono in corso.\n"
        },
        {
          "name": "README_ja.md",
          "type": "blob",
          "size": 19.43,
          "content": "# Standard Go Project Layout\n\n翻訳:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## 概要\n\nこれは、Goアプリケーションプロジェクトの基本的なレイアウトです。これは、コアとなるGo開発チームによって定義された公式の標準ではありませんが、Goエコシステムの中で、歴史的に共通しているプロジェクトのレイアウトパターンのセットとなっています。これらのパターンの中には、他のパターンよりも人気のあるものもあります。また、現実世界の大規模なアプリケーションに共通するいくつかのサポートディレクトリに加えて、いくつかの小さな機能強化が行われています。\n\nGoを学ぼうとしている場合や、自分でPoCやおもちゃのプロジェクトを構築しようとしている場合、このプロジェクトレイアウトはやりすぎです。最初は本当にシンプルなものから始めてください（`main.go`ファイルが1つあれば十分です）。プロジェクトが大きくなるにつれて、コードが適切に構造化されているかどうかが重要になることに注意してください。そうしないと、多くの隠れた依存関係やグローバルな状態を持つ厄介なコードになってしまいます。プロジェクトで作業する人が増えれば、さらに多くの構造が必要になります。そこで、パッケージやライブラリを管理するための共通の方法を導入することが重要になります。オープンソースプロジェクトがある場合や、他のプロジェクトがプロジェクトリポジトリからコードをインポートしていることを知っている場合は、プライベートな(内部的な)パッケージやコードを持つことが重要になります。リポジトリをクローンして、必要なものだけを残し、他のものはすべて削除してください。リポジトリにあるからといって、すべてを使わなければならないわけではありません。これらのパターンはすべてのプロジェクトで使われているわけではありません。`vendor`パターンでさえも、万能ではありません。\n\nGo 1.14では、[`Go Modules`](https://go.dev/wiki/Modules)がついに本番に向けて準備が整いました。使用しない特別な理由がない限り、[`Go Modules`](https://blog.golang.org/using-go-modules) を使用してください。もし使用するのであれば、$GOPATH やプロジェクトをどこに置くかを気にする必要はありません。レポの基本的な `go.mod` ファイルは、プロジェクトが GitHub でホストされていることを前提としていますが、必須ではありません。モジュールパスは何でも構いませんが、最初のモジュールパスコンポーネントの名前にはドットを付けてください (現在の Go のバージョンではもうこれを強制していませんが、少し古いバージョンを使っているのであれば、これを付けなくてもビルドが失敗しても驚かないでください)。これについて詳しく知りたい場合は、Issue [`37554`](https://github.com/golang/go/issues/37554) と [`32819`](https://github.com/golang/go/issues/32819) を参照してください。\n\nこのプロジェクトは意図的に一般的なレイアウトを使用しており、特定のGoパッケージを押し付けているわけではありません。\n\nこれはコミュニティの取り組みです。 新しいパターンが表示された場合、または既存のパターンの1つを更新する必要があると思われる場合は、issueで起票してください。\n\n名前付け、フォーマット、スタイルについてサポートが必要な場合は、[`gofmt`](https://golang.org/cmd/gofmt/)と[`golint`](https://github.com/golang/lint)を実行することから始めます。また、次のGoコードスタイルのガイドラインと推奨事項も必ずお読みください:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\n追加の背景情報については、[`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2)を参照してください。\n\nパッケージの命名と整理、およびその他のコード構造の推奨事項の詳細:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nパッケージ指向の設計ガイドラインとアーキテクチャレイヤーに関する中国の投稿\n* [パッケージ指向の設計とアーキテクチャの階層化](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Goのディレクトリ\n\n### `/cmd`\n\nこのプロジェクトの主なアプリケーション。\n\n各アプリケーションのディレクトリ名は、欲しい実行ファイルの名前と一致するようにしてください(例: `/cmd/myapp`)。\n\nアプリケーションディレクトリには多くのコードを入れないようにしましょう。コードをインポートして他のプロジェクトで使えると思うならば、`/pkg`ディレクトリに置くべきです。コードが再利用できない場合や、他の人に再利用してほしくない場合は、そのコードを`/internal`ディレクトリに置いてください。他の人が何をするか驚くでしょうから、自分の意図を明確にしてください。\n\nこのような場合は、`/internal`ディレクトリと`/pkg`ディレクトリからコードをインポートして呼び出す小さなメイン関数を持つのが一般的ですが、それ以外は何もしません。\n\n例に関しては、[`/cmd`](cmd/README.md)ディレクトリを参照してください。\n\n### `/internal`\n\nプライベートなアプリケーションやライブラリのコード。これは、他の人が自分のアプリケーションやライブラリにインポートしたくないコードです。このレイアウトパターンは、Goコンパイラによって強制されることに注意してください。詳細については、Go 1.4の[`リリースノート`](https://golang.org/doc/go1.4#internalpackages)を参照してください。トップレベルの内部ディレクトリに限定されないことに注意してください。プロジェクトツリーのどのレベルでも、複数の内部ディレクトリを持つことができます。\n\nオプションで、内部パッケージに少し余分な構造を追加して、共有内部コードと非共有内部コードを分離することができます。(特に小規模なプロジェクトでは) 必須ではありませんが、パッケージの使用目的を示す視覚的な手がかりがあるのは良いことです。実際のアプリケーションコードは `/internal/app` ディレクトリ (例: `/internal/app/myapp`) に、それらのアプリケーションで共有されるコードは `/internal/pkg` ディレクトリ (例: `/internal/pkg/myprivlib`) に置くことができます。\n\n### `/pkg`\n\n外部アプリケーションで使用しても問題ないライブラリコード(例: `/pkg/mypubliclib`)。他のプロジェクトは、これらのライブラリが動作することを期待してインポートしますので、ここに何かを置く前によく考えてください :-)。内部ディレクトリは、プライベートパッケージがインポートできないようにするためのより良い方法であることに注意してください。`/pkg` ディレクトリは、そのディレクトリにあるコードが他の人に使われても安全であることを明示的に伝える良い方法です。[`I'll take pkg over internal blog post by Travis Jeffery`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) は、`pkg` ディレクトリと内部ディレクトリの概要と、それらを使用することが意味のある場合の概要を提供しています。\n\nまた、ルートディレクトリにGo以外のコンポーネントやディレクトリが多数含まれている場合は、Goコードを1つの場所にグループ化して、さまざまなGoツールを簡単に実行できるようにする方法でもあります（これらの講演で言及されているように：[`産業用プログラミングのベストプラクティス`](https://www.youtube.com/watch?v=PTE4VJIdHPg) from GopherCon EU 2018、[`GopherCon 2018：Kat Zien-How Do You Structure Your Go Apps`](https://www.youtube.com/watch?v=oL6JBUk6tj0) および [`GoLab 2018-Massimiliano Pippi-Goのプロジェクトレイアウトパターン`](https://www.youtube.com/watch?v=3gQa1LWwuzk)）。\n\nこのプロジェクトレイアウトパターンを使用している人気のある Go repos を見たい場合は [`/pkg`](pkg/README.md) ディレクトリを参照してください。これは一般的なレイアウトパターンですが、普遍的に受け入れられているわけではありませんし、Goコミュニティの中には推奨していない人もいます。\n\nアプリプロジェクトが非常に小さく、追加レベルのネストがあまり価値をもたらさない場合は、使用しないでください（本当に必要な場合を除く:-)）。 それが十分に大きくなり、ルートディレクトリがかなり肥大化してきたときに考えてください（特に、Go以外のアプリコンポーネントがたくさんある場合）。\n\n### `/vendor`\n\nアプリケーションの依存関係 (手動で管理するか、新しい組み込みの [`Go Modules`](https://go.dev/wiki/Modules) 機能のようなお気に入りの依存関係管理ツールで管理します)。`go mod vendor`コマンドは、`/vendor`ディレクトリを作成します。デフォルトでオンになっている Go 1.14 を使用していない場合は、`go build` コマンドに `-mod=vendor` フラグを追加する必要があるかもしれないことに注意してください。\n\nライブラリをビルドしている場合は、アプリケーションの依存関係をコミットしないでください。\n\n[`1.13`](https://golang.org/doc/go1.13#modules) 以降、Go はモジュールプロキシ機能も有効にしています (デフォルトでは [`https://proxy.golang.org`](https://proxy.golang.org) をモジュールプロキシサーバとして使用しています)。[`この機能`](https://blog.golang.org/module-mirror-launch)についての詳細は、ここを読んで、あなたの要件や制約に適合するかどうかを確認してください。そうであれば、ベンダディレクトリは全く必要ありません。\n\n## Service Application Directories\n\n### `/api`\n\nOpenAPI/Swaggerの仕様、JSONスキーマファイル、プロトコル定義ファイル。\n\n例に関しては、[`/api`](api/README.md)ディレクトリを参照してください。\n\n## Web Application Directories\n\n### `/web`\n\nウェブアプリケーション固有のコンポーネント：静的ウェブアセット、サーバーサイドテンプレート、SPA。\n\n## Common Application Directories\n\n### `/configs`\n\n設定ファイルのテンプレートまたはデフォルトの設定。\n\n`confd` または `consul-template` テンプレートファイルをここに置きます。\n\n### `/init`\n\nシステムinit(systemd, upstart, sysv)とプロセスマネージャ/スーパーバイザ(runit, supervisord)の設定。\n\n### `/scripts`\n\n様々なビルド、インストール、解析などの操作を行うためのスクリプトです。\n\nこれらのスクリプトはルートレベルの Makefile を小さくシンプルに保ちます (例: [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile))。\n\n例に関しては、[`/scripts`](scripts/README.md)ディレクトリを参照してください。\n\n### `/build`\n\nパッケージングと継続的インテグレーション。\n\nクラウド (AMI)、コンテナ (Docker)、OS (deb、rpm、pkg) パッケージの設定とスクリプトを `/build/package` ディレクトリに置きます。\n\nCI (travis, circle, drone) の設定とスクリプトを `/build/ci` ディレクトリに配置します。CIツールの中には（Travis CIなど）、設定ファイルの場所に非常にこだわるものがあることに注意してください。コンフィグファイルを `/build/ci` ディレクトリに置き、CIツールが期待する場所にリンクしてみてください（可能であれば）。\n\n### `/deployments`\n\nIaaS、PaaS、システム、コンテナオーケストレーションのデプロイメント設定とテンプレート (docker-compose、kubernetes/helm、mesos、terraform、bosh)。\nいくつかのリポジトリ (特に kubernetes でデプロイされたアプリ) では、このディレクトリは `/deploy` と呼ばれていることに注意してください。\n\n### `/test`\n\n追加の外部テストアプリとテストデータ。`/test`ディレクトリは自由に構成してください。大規模なプロジェクトでは、データのサブディレクトリを持つことは理にかなっています。例えば、`/test/data` や `/test/testdata` などのディレクトリが必要な場合、そのディレクトリにあるものを無視することができます。Go は \".\" や \"_\" で始まるディレクトリやファイルも無視するので、テストデータディレクトリの名前の付け方に柔軟性があることに注意してください。\n\n例に関しては、[`/test`](test/README.md)ディレクトリを参照してください。\n\n## 他のディレクトリ\n\n### `/docs`\n\nデザインドキュメントとユーザードキュメント (godocで生成されたドキュメントに加えて)。\n\n例に関しては、[`/docs`](docs/README.md)ディレクトリを参照してください。\n\n### `/tools`\n\nこのプロジェクトをサポートするツールです。これらのツールは `/pkg` と `/internal` ディレクトリからコードをインポートできることに注意してください。\n\n例に関しては、[`/tools`](tools/README.md)ディレクトリを参照してください。\n\n### `/examples`\n\nあなたのアプリケーション、またはpublic librariesのための例。\n\n例に関しては、[`/examples`](examples/README.md)ディレクトリを参照してください。\n\n### `/third_party`\n\n外部ヘルパーツール、フォークされたコード、その他のサードパーティ製ユーティリティ（Swagger UIなど）。\n\n### `/githooks`\n\nGitフック。\n\n### `/assets`\n\nリポジトリに付随するその他のアセット（画像、ロゴなど）。\n\n### `/website`\n\nGitHubページを使用していない場合は、プロジェクトのWebサイトのデータを置く場所です。\n\n例に関しては、[`/website`](website/README.md)ディレクトリを参照してください。\n\n## 作成してはいけないディレクトリ\n\n### `/src`\n\nGoプロジェクトの中には `src` フォルダを持っているものもありますが、これは通常、開発者が一般的なパターンであるJavaの世界から来た場合に起こります。可能であれば、このようなJavaのパターンを採用しないようにしてください。あなたのGoコードやGoプロジェクトがJavaのように見えることは本当に避けてください。\n\nプロジェクトレベルの `/src` ディレクトリと、[`Goコードの書き方`](https://golang.org/doc/code.html)で説明されているように、Go がワークスペースに使用する `/src` ディレクトリを混同しないようにしてください。環境変数 `$GOPATH` は、(現在の)ワークスペースを指します (Windows 以外のシステムでは、デフォルトでは `$HOME/go` を指します)。このワークスペースには、トップレベルの `/pkg`, `/bin`, `/src` ディレクトリが含まれています。実際のプロジェクトは `/src` の下のサブディレクトリになりますので、プロジェクト内に `/src` ディレクトリがある場合、プロジェクトのパスは以下のようになります。`/some/path/to/workspace/src/your_project/src/your_code.go` のようになります。Go 1.11 では、プロジェクトを `GOPATH` の外に置くことができますが、このレイアウトパターンを使うのが良いというわけではないことに注意してください。\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license`, `misspell` でコードをスキャンします。`github.com/golang-standards/project-layout` をプロジェクトリファレンスに置き換えてください。\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - GoDocで作成したドキュメントのオンライン版を提供します。リンクを自分のプロジェクトへのリンクに変更してください。~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.devは、Goの発見とドキュメントの新しい目的地です。[バッジ生成ツール](https://pkg.go.dev/badge)を使ってバッジを作成することができます。\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* リリース - あなたのプロジェクトの最新のリリース番号が表示されます。githubのリンクを変更して、あなたのプロジェクトを指すようにしてください。\n\n    [![リリース](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## 注意事項\n\nサンプル/再利用可能なコンフィグ、スクリプト、コードを備えた、より意見の多いプロジェクトテンプレートはWIPです。\n"
        },
        {
          "name": "README_ko.md",
          "type": "blob",
          "size": 16.46,
          "content": "# 표준 Go 프로젝트 레이아웃\n\n번역:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## 개요\n\n이 레포지토리는 Go 애플리케이션 프로젝트의 기본 레이아웃입니다. 이 레포지토리는 코어 Go 개발팀에 의해 정의된 공식적인 표준은 아니지만, Go 생태계에서 역사적이거나 급부상중인 프로젝트 레이아웃 패턴들의 공통된 부분들입니다. 몇몇 패턴들은 다른 패턴들보다 유명합니다. 또한 이는 충분히 큰 현실세계 애플리케이션들에서 공통적으로 사용하는 여러 보조 디렉터리와 함께 다수의 작은 개선 사항들을 포함하고 있습니다.\n\n만약 당신이 Go를 배우려하거나, 혼자 PoC나 토이 프로젝트를 만드는 거라면 이 프로젝트 레이아웃은 과한 것입니다. 아주 간단한 것부터 시작하세요 (`main.go` 파일 하나면 아주 충분합니다). 프로젝트가 성장하면서 당신의 코드가 잘 구조화 되도록 하는 것이 중요합니다. 그렇지 않으면 많은 숨겨진 종속성들과 전역 상태가 있는 지저분한 코드로 끝나게 될 것 입니다. 더 많은 사람들이 프로젝트에 참여할 때 더 많은 구조가 필요합니다. 그 때가 패키지/라이브러리를 관리하는 공통된 방법을 도입하는 것이 중요한 시점입니다. 당신이 오픈 소스 프로젝트를 가지고 있거나 다른 프로젝트가 당신의 프로젝트 레포지토리에서 코드를 임포트 하고있다면 프라이빗 (`internal` 로 일컫어지는) 패키지와 코드를 도입하는게 중요합니다. 이 레포지토리를 Clone하고, 당신에게 필요한것만 남긴다음 나머지 것들을 다 지우세요! 거기에 있다고 해서 다 사용해야하는 것은 아닙니다. 모든 프로젝트에서 다 사용하는 패턴은 없습니다. `vendor`패턴 조차 보편적이지 않습니다.\n\nGo 1.14로 [`Go Modules`](https://go.dev/wiki/Modules) 은 최종적으로 프로덕션 준비가 완료되었습니다. 특별히 사용하지 않을 사유가 없다면 [`Go Modules`](https://blog.golang.org/using-go-modules) 를 사용하세요. 그러면 $GOPATH와 어디에 내 프로젝트를 놓을지 고민할 필요가 없습니다. 레포지토리에서 기본적인 `go.mod` 파일은 프로젝트가 GitHub에 호스팅되어있다고 가정합니다만, 필수사항은 아닙니다. 모듈 패스는 어느것이든 될 수 있지만 첫번째 모듈 패스 컴포넌트는 그 이름에 점이 있어야 합니다. (현재 버전의 Go는 더이상 이를 강제하지는 않지만, 만약 조금 더 오래된 버전을 사용하고 있다면 점이 없을때 빌드가 실패해도 놀라지 마세요). 이에 대해 더 알아보고 싶으시면 이슈 [`37554`](https://github.com/golang/go/issues/37554) 와 [`32819`](https://github.com/golang/go/issues/32819) 를 읽어보세요.\n\n이 프로젝트 레이아웃은 의도적으로 일반적이며 특정 Go 패키지 구조를 강요하지 않습니다.\n\n이 레포지토리는 커뮤니티의 노력입니다. 새 패턴을 찾았거나, 있는 패턴들 중 하나가 업데이트가 필요하다고 생각된다면 이슈를 열어주세요.\n\n네이밍, 포매팅, 스타일에 대해 도움이 필요하시다면, [`gofmt`](https://golang.org/cmd/gofmt/) 와 [`golint`](https://github.com/golang/lint)를 돌리는 것으로 시작해보세요. 또한 Go 코드 스타일 가이드라인과 권장 사항들을 꼭 읽어보세요:\n\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\n자세한 배경 지식에 대해서는 [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) 를 확인하세요.\n\n다른 코드 구조 추천과 네이밍과 패키지 구성에 대해 더 알아보기:\n\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\n패키지 지향 디자인 가이드라인과 설계 레이어에 대한 중국어 글\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go 디렉터리\n\n### `/cmd`\n\n이 프로젝트의 메인 애플리케이션들입니다.\n\n각 애플리케이션의 디렉터리명은 만들고싶은 실행 파일 이름과 같아야 합니다  (e.g., `/cmd/myapp`).\n\n애플리케이션 디렉터리에 많은 코드를 넣지마세요. 다른 프로젝트들에서 임포트되고 사용될 것 같으면, `/pkg` 디렉터리에 있어야합니다. 코드가 재사용성이 없거나 다른사람들이 재사용하지 않기를 바란다면 코드를 `/internal` 디렉터리에 넣으세요. 다른사람들이 무얼 할지 놀라게 될거에요. 그러니 의도를 분명하게 밝혀주세요!\n\n흔히 `/internal`와 `/pkg` 디렉터리 코드를 임포트, 호출만 하는 작은  `main` 함수는 흔히 볼 수 있습니다. \n\n예시는 [`/cmd`](cmd/README.md)를 보세요.\n\n### `/internal`\n\n개인적인 애플리케이션과 라이브러리 코드. 다른 사람들이 애플리케이션이나 라이브러리에서 임포트 하기를 원하지 않는 코드들입니다. 이 레이아웃 패턴은 Go 컴파일러 자체에 강제됩니다. 더 알아보고 싶다면 Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) 를 참고하세요. 이는 최상단 `internal` 디렉터리에 국한되는 것은 아닙니다. 프로젝트 트리의 모든 레벨에서 하나 이상의 `internal` 디렉터리를 가질 수 있습니다. \n\nInternal 패키지에서 공유되는 내부 코드와 공유되지 않는 내부 코드를 구분하기 위해 부가적인 구조체를 추가할 수 있습니다. 필수사항은 아니지만(특히 작은 프로젝트에서는), 의도된 패키지 사용법을 보여주는 시각적인 단서를 남기는 것이 좋습니다. 실제 에플리케이션 코드는 `/internal/app` 디렉터리에 넣고 (e.g., `/internal/app/myapp`) , 그 앱들에서 공유되는 코드들은 `/internal/pkg` 디렉터리 (e.g., `/internal/pkg/myprivlib`) 에 넣을 수 있습니다.\n\n### `/pkg`\n\n외부 애플리케이션에서 사용되어도 괜찮은 라이브러리 코드입니다 (e.g., `/pkg/mypubliclib`). 다른 프로젝트는 이 라이브러리들이 작동할거라고 예상하고 임포트 할 것 이므로, 여기에 무언가를 넣기 전에 두번 고민하세요 :-) `internal`디렉터리는 개인적인 패키지들이 임포트 불가능하도록 하는 더 좋은 방법인데, 이유는 Go가 이를 강제하기 때문입니다. `/pkg` 디렉터리는 그 디렉터리 안의 코드가 다른 사람들에 의해 사용되어도 안전하다고 명시적으로 보여주는 좋은 방법입니다. Travis Jeffery의 [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) 블로그 포스트는 `pkg` 와 `internal` 디렉터리와 언제 쓰는게 맞을지에 대해 좋은 개요를 제공합니다. \n\n또한 루트 디렉터리에 많은 Go가 아닌 컴포넌트와 디렉터리를 포함하고 있다면 Go 코드를 한 곳에 모아서 다양한 Go 툴들을 쉽게 실행할 수 있습니다 (이 발표들에서 언급되었던것 처럼: GopherCon EU 2018의 [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg),  [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) 와 [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\n이 프로젝트 레이아웃 패턴을 사용하는 유명한 Go 레포지토리들을 보고 싶다면 [`/pkg`](pkg/README.md)를 보세요. 이는 흔한 레이아웃 패턴이나, 보편적으로 받아드려지는 것은 아니며 Go 커뮤니티의 일부는 이를 추천하지 않습니다.\n\n앱 프로젝트가 정말 작고 추가적인 레벨의 중첩이 많이 효과적이지 않다면 사용하지 않아도 괜찮습니다 (정말로 원하지 않는 한 :-)). 프로젝트가 더 커지고 루트 디렉터리가 꽤 바빠질 때 고려해보세요 (특히 Go가 아닌 앱 컴포넌트가 많이 있다면).\n\n### `/vendor`\n\n애플리캐이션 종속성 (직접 혹은 새 빌트인 [`Go Modules`](https://go.dev/wiki/Modules) 피쳐와 같은 종속성 관리 도구로 관리되는).  `go mod vendor` 명령어는 `/vendor` 디렉터리를 만들어 줄 것 입니다. `go build` 명령어를 사용할 때 Go 1.14를 사용하지 않는다면 Go 1.14에서 기본으로 켜져있는 `-mod=vendor` 플래그를 추가해야 할 수 있습니다.\n\n만약 당신이 라이브러리를 만들고 있다면 당신의 애플리케이션 종속성을 커밋하지 마세요.\n\n[`1.13`](https://golang.org/doc/go1.13#modules)부터 Go는 모듈 프록시 기능(기본적으로 [`https://proxy.golang.org`](https://proxy.golang.org)를 모듈 프록시 서버로 사용하여)을 활성화하였습니다. 이것이 당신의 요구조건과 제한사항을 모두 만족하는지 보려면 [`여기`](https://blog.golang.org/module-mirror-launch) 를 읽어보세요. 만약 만족한다면, `vendor` 디렉터리가 전혀 필요하지 않을 것입니다.\n\n## 서비스 애플리케이션 디렉터리\n\n### `/api`\n\nOpenAPI/Swagger 스펙들, JSON schema 파일들, 프로토콜 정의 파일들.\n\n예시로  [`/api`](api/README.md) 디렉터리를 확인하세요. \n\n## 웹 애플리케이션 디렉터리\n\n### `/web`\n\n웹 플리케이션의 특정한 컴포넌트들: 정적 웹 에셋들, 서버 사이드 템플릿과 SPA들.\n\n## 공통 애플리케이션 디렉터리\n\n### `/configs`\n\n설정 파일 템플릿이나 기본 설정들.\n\n`confd` or `consul-template` 템플릿 파일들을 여기에 놓으세요.\n\n### `/init`\n\n시스템 init (systemd, upstart, sysv) 과 프로세스 매니저/슈퍼바이저 (runit, supervisord) 설정들.\n\n### `/scripts`\n\n빌드, 설치, 분석, 기타 작업을 위한 스크립트들.\n\n이 스크립트들은 루트의 Makefile을 작고 간단하게 유지해줍니다 (e.g., [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\n예시로  [`/scripts`](scripts/README.md) 디렉터리를 확인하세요.\n\n### `/build`\n\n패키징과 지속적인 통합(CI).\n\n클라우드 (AMI), 컨테이너 (Docker), OS (deb, rpm, pkg) 패키지 설정과 스크립트를 `/build/package` 디렉터리에 넣으세요.\n\nCI (travis, circle, drone) 설정과 스크립트를 `/build/ci`에 넣으세요. 몇몇 CI 도구들은 (e.g., Travis CI) 설정파일들 위치에 대해 굉장히 까다롭다는 것을 알아두세요. 설정 파일들을 `/build/ci` 에 넣고 CI 도구들이 기대하는 위치에 링크해보세요. (가능하다면).\n\n### `/deployments`\n\nIaaS, PaaS, 시스템과 컨테이너 오케스트레이션 배포 설정과 템플릿 (docker-compose, kubernetes/helm, mesos, terraform, bosh). 몇몇 레포지토리 (특히 쿠버네티스로 배포되는 앱들) 에서 이 디렉터리는 `/deploy` 라고 불립니다.\n\n### `/test`\n\n추가적인 외부 테스트 앱들과 테스트 데이터들. `/test` 디렉터리를 자유롭게 구조화하세요. 더 큰 프로젝트에서 데이터 서브디렉터리를 갖는것이 합당합니다. 예시로,  이 디렉터리에 무엇이 있는지 Go가 무시하려면 `/test/data` 또는 `/test/testdata` 를 만들면 됩니다. Go는 \".\" 나 \"_\" 로 시작하는 디렉터리들이나 파일들도 무시하니, 테스트 데이터 디렉터리 이름을 더 자유롭게 지을 수 있습니다. \n\n예시로 [`/test`](test/README.md) 디렉터리를 확인하세요.\n\n## 다른 디렉터리들\n\n### `/docs`\n\n디자인과 사용자 문서들 (godoc이 만든 문서에 더불어).\n\n예시로 [`/docs`](docs/README.md) 디렉터리를 확인하세요.\n\n### `/tools`\n\n이 프로젝트에서 사용하는 도구들. 이 도구들이 `/pkg` 나 `/internal` 디렉터리에서 코드를 임포트 할 수 있음을 알아두세요.\n\n예시로 [`/tools`](tools/README.md) 디렉터리를 확인하세요.\n\n### `/examples`\n\n애플리케이션 혹은 공개된 라이브러리의 예시들.\n\n예시로 [`/examples`](examples/README.md) 디렉터리를 확인하세요.\n\n### `/third_party`\n\n사용하는 외부 도구들, 포크된 코드들과 다른 서드 파티 유틸리티들 (e.g., Swagger UI).\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\n레포지토리와 함께 사용될 에셋들 (이미지, 로고, 기타).\n\n### `/website`\n\nGitHub pages를 사용하고 있지 않다면 프로젝트의 웹사이트 데이터를 넣는 곳입니다.\n\n예시로 [`/website`](website/README.md) 디렉터리를 확인하세요.\n\n## 있으면 안되는 디렉터리\n\n### `/src`\n\n몇몇 Go 프로젝트들은 분명  `src` 폴더를 가지고 있으나, 이는 개발자들이 해당 패턴이 흔한 Java 세계에서 왔을 때 대부분 발생합니다. 만약 할 수 있다면 이 Java 패턴을 사용하지 않도록 해보세요. Go 코드나 Go 프로젝트가 Java처럼 보이는걸 원하지 않잖아요 :-)\n\n프로젝트 레벨의  `/src` 디렉터리와 [`How to Write Go Code`](https://golang.org/doc/code.html)에서 설명된 것 처럼 Go에서 워크스페이스로 사용하는 `/src` 디렉터리와 혼동하지 마세요. `$GOPATH` 환경 변수는 당신의 (현재) 워크스페이스를 가리킵니다 (기본적으로 윈도우가 아닌 시스템에서는 `$HOME/go`를 가리킵니다). 이 워크스페이스는 최상위 `/pkg`, `/bin` , `/src` 디렉터리를 포함하고 있습니다. 실제 프로젝트는 결국 `/src`의 서브디렉터리이므로, 프로젝트 안에 `/src` 디렉터리가 있다면 프로젝트 주소는 이럴 것입니다: `/some/path/to/workspace/src/your_project/src/your_code.go`. Go 1.11에서는  `GOPATH` 밖에 프로젝트를 만드는게 가능하지만, 이 레이아웃 패턴을 사용하는게 좋다는 뜻은 아님을 알아두세요.\n\n\n## 뱃지\n\n* [Go Report Card](https://goreportcard.com/) - 이는 당신의 코드를 `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license`, `misspell`로 스캔합니다.  `github.com/golang-standards/project-layout` 를 당신의 프로젝트 주소로 바꾸세요.\n\n* ~~[GoDoc](http://godoc.org) - 온라인 버전의 GoDoc 생성 문서를 제공합니다. 당신의 프로젝트를 가리키도록 링크를 바꾸세요.~~\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev는 Go 검색 및 문서들을 위한 새로운 사이트입니다. [badge generation tool](https://pkg.go.dev/badge)을 사용해서 새로운 뱃지를 만들 수 있습니다.\n\n* Release - 프로젝트의 최신 릴리즈 넘버를 보여줍니다. 당신의 프로젝트를 가리키도록 깃헙 링크를 바꾸세요.\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n[![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## 참고\n\n샘플/재사용 가능한 설정, 스크립트와 코드를 포함하는 더 의견이 담긴 프로젝트 템플릿은 작업 중입니다.\n\n"
        },
        {
          "name": "README_ptBR.md",
          "type": "blob",
          "size": 15.46,
          "content": "# Layout padrão de projetos em Go\n\nTraduções:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Visão geral\n\nEste é um layout básico para projetos de aplicações em Go. Não é um padrão oficial definido pela equipe de desenvolvimento principal do Go; no entanto, é um conjunto de padrões de layout de projetos históricos e emergentes comuns no ecossistema Go. Alguns desses padrões são mais populares do que outros. Ele também possui uma série de pequenos aprimoramentos junto com vários diretórios de suporte comuns a qualquer aplicativo grande o suficiente do mundo real.\n\nSe você está tentando aprender Go, se está construindo um PoC(Prova de conceito) ou um pequeno projeto pessoal para você, este layout de projeto é um exagero. Comece com algo realmente simples (um único arquivo `main.go` é mais do que suficiente). Conforme seu projeto cresce, lembre-se de que será importante garantir que seu código esteja bem estruturado, caso contrário, você acabará com um código confuso com muitas dependências ocultas e estados globais. Quando você tiver mais pessoas trabalhando no projeto, precisará de ainda mais estrutura. É quando é importante apresentar uma maneira comum de gerenciar pacotes/bibliotecas. Quando você tem um projeto de código aberto ou quando conhece outros projetos, importe o código do seu repositório de projetos, é quando é importante ter pacotes e códigos privados (também conhecidos como `internal`). Clone o repositório, mantenha o que você precisa e exclua todo o resto! Só porque está lá, não significa que você precise usar tudo. Nenhum desses padrões é usado em todos os projetos. Mesmo o padrão `vendor` não é universal.\n\nCom Go 1.14 [`Go Modules`](https://go.dev/wiki/Modules) estão finalmente prontos para produção. Use [`Go Modules`](https://blog.golang.org/using-go-modules) a menos que você tenha um motivo específico para não usá-los e, se tiver, não precisa se preocupar com $GOPATH e onde você colocou seu projeto. O arquivo `go.mod` básico no reposiório assume que seu projeto está hospedado no GitHub, mas não é um requisito. O caminho do módulo pode ser qualquer coisa, embora o primeiro componente do caminho do módulo deva ter um ponto em seu nome (a versão atual do Go não o impõe mais, mas se você estiver usando versões um pouco mais antigas, não se surpreenda se suas compilações falharem sem isto). Veja as issues [`37554`](https://github.com/golang/go/issues/37554) e [`32819`](https://github.com/golang/go/issues/32819) se você quiser saber mais sobre isso.\n\nEste layout de projeto é intencionalmente genérico e não tenta impor uma estrutura de pacote Go específica.\n\nEste é um esforço da comunidade. Abra uma nova issue se você ver um novo padrão ou se você acha que um dos padrões existentes precisa ser atualizado.\n\nSe precisar de ajuda com nomenclatura, formatação e estilo, comece executando [`gofmt`](https://golang.org/cmd/gofmt/) e [`golint`](https://github.com/golang/lint). Além disso, certifique-se de ler estas diretrizes e recomendações de estilo de código Go:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nVeja [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) para obter informações adicionais.\n\nMais sobre como nomear e organizar pacotes, bem como outras recomendações de estrutura de código:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nUma postagem chinesa sobre as diretrizes de design orientado a pacotes e a camada de arquitetura\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Diretórios Go\n\n### `/cmd`\n\nPrincipais aplicações para este projeto.\n\nO nome do diretório para cada aplicação deve corresponder ao nome do executável que você deseja ter (ex. `/cmd/myapp`).\n\nNão coloque muitos códigos no diretório da aplicação. Se você acha que o código pode ser importado e usado em outros projetos, ele deve estar no diretório `/pkg`. Se o código não for reutilizável ou se você não quiser que outros o reutilizem, coloque esse código no diretório `/internal`. Você ficará surpreso com o que os outros farão, então seja explícito sobre suas intenções!\n\nÉ comum ter uma pequena função `main` que importa e invoca o código dos diretórios` /internal` e `/pkg` e nada mais.\n\nVeja o diretório [`/cmd`](cmd/README.md) para mais exemplos.\n\n### `/internal`\n\nAplicação privada e código de bibliotecas. Este é o código que você não quer que outras pessoas importem em suas aplicações ou bibliotecas. Observe que esse padrão de layout é imposto pelo próprio compilador Go. Veja o Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) para mais detalhes. Observe que você não está limitado ao diretório `internal` de nível superior. Você pode ter mais de um diretório `internal` em qualquer nível da árvore do seu projeto.\n\nOpcionalmente, você pode adicionar um pouco de estrutura extra aos seus pacotes internos para separar o seu código interno compartilhado e não compartilhado. Não é obrigatório (especialmente para projetos menores), mas é bom ter dicas visuais que mostram o uso pretendido do pacote. Seu atual código da aplicação pode ir para o diretório `/internal/app` (ex. `/internal/app/myapp`) e o código compartilhado por essas aplicações no diretório `/internal/pkg` (ex. `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nCódigo de bibliotecas que podem ser usados por aplicativos externos (ex. `/pkg/mypubliclib`). Outros projetos irão importar essas bibliotecas esperando que funcionem, então pense duas vezes antes de colocar algo aqui :-) Observe que o diretório `internal` é a melhor maneira de garantir que seus pacotes privados não sejam importáveis porque é imposto pelo Go. O diretório `/pkg` contudo é uma boa maneira de comunicar explicitamente que o código naquele diretório é seguro para uso. [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) A postagem no blog de Travis Jeffery fornece uma boa visão geral dos diretórios `pkg` e` internal`, e quando pode fazer sentido usá-los.\n\nÉ também uma forma de agrupar o código Go em um só lugar quando o diretório raiz contém muitos componentes e diretórios não Go, tornando mais fácil executar várias ferramentas Go (conforme mencionado nestas palestras: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) da GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) e [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nConsulte o diretório [`/pkg`](pkg/README.md) se quiser ver quais repositórios Go populares usam esse padrão de layout de projeto. Este é um padrão de layout comum, mas não é universalmente aceito e alguns na comunidade Go não o recomendam.\n\nNão há problema em não usá-lo se o projeto do seu aplicativo for muito pequeno e onde um nível extra de aninhamento não agrega muito valor (a menos que você realmente queira :-)). Pense nisso quando estiver ficando grande o suficiente e seu diretório raiz ficar muito ocupado (especialmente se você tiver muitos componentes de aplicativos não Go).\n\n### `/vendor`\n\nDependências de aplicativos (gerenciadas manualmente ou por sua ferramenta de gerenciamento de dependências favorita, como o novo recurso integrado [`Go Modules`](https://go.dev/wiki/Modules)). O comando `go mod vendor` criará o diretório` /vendor` para você. Note que você pode precisar adicionar a flag `-mod=vendor` ao seu comando` go build` se você não estiver usando Go 1.14 onde ele está ativado por padrão.\n\nNão comprometa as dependências do seu aplicativo se você estiver construindo uma biblioteca.\n\nObserve que desde o Go [`1.13`](https://golang.org/doc/go1.13#modules) também habilitou o recurso de proxy do módulo (usando [`https://proxy.golang.org`](https://proxy.golang.org) como servidor proxy de módulo por padrão). Leia mais sobre isso [`aqui`](https://blog.golang.org/module-mirror-launch) para ver se ele se encaixa em todos os seus requisitos e restrições. Se isso acontecer, então você não precisará do diretório `vendor`.\n\n## Diretórios de aplicativos de serviço\n\n### `/api`\n\nEspecificações OpenAPI/Swagger, arquivos de esquema JSON, arquivos de definição de protocolo.\n\nVeja o diretório [`/api`](api/README.md) para mais exemplos.\n\n## Diretórios de aplicativos da web\n\n### `/web`\n\nComponentes específicos de aplicativos da Web: ativos estáticos da Web, modelos do lado do servidor e SPAs.\n\n## Diretórios de aplicativos comuns\n\n### `/configs`\n\nModelos de arquivo de configuração ou configurações padrão.\n\nColoque seus arquivos de modelo `confd` ou` consul-template` aqui.\n\n### `/init`\n\nConfigurações de inicialização do sistema (systemd, upstart, sysv) e gerenciador/supervisor de processos (runit, supervisord).\n\n### `/scripts`\n\nScripts para executar várias operações de construção, instalação, análise, etc.\n\nEsses scripts mantêm o Makefile de nível raiz pequeno e simples (ex. [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nVeja o diretório [`/scripts`](scripts/README.md) para mais exemplos.\n\n### `/build`\n\nEmpacotamento e integração contínua.\n\nColoque suas configurações de pacote e scripts em nuvem (AMI), contêiner (Docker), sistema operacional (deb, rpm, pkg) no diretório `/build/package`.\n\nColoque suas configurações e scripts de CI (travis, circle, drone) no diretório `/build/ci`. Observe que algumas das ferramentas de CI (por exemplo, Travis CI) são muito exigentes quanto à localização de seus arquivos de configuração. Tente colocar os arquivos de configuração no diretório `/build/ci` vinculando-os ao local onde as ferramentas de CI os esperam (quando possível).\n\n### `/deployments`\n\nIaaS, PaaS, configurações e modelos de implantação de orquestração de sistema e contêiner (docker-compose, kubernetes / helm, mesos, terraform, bosh). Observe que em alguns repositórios (especialmente em aplicativos implantados com kubernetes), esse diretório é denominado `/deploy`.\n\n### `/test`\n\nAplicações de testes externos adicionais e dados de teste. Sinta-se à vontade para estruturar o diretório `/test` da maneira que quiser. Para projetos maiores, faz sentido ter um subdiretório de dados. Por exemplo, você pode ter `/test/data` ou` /test/testdata` se precisar que o Go ignore o que está naquele diretório. Observe que o Go também irá ignorar diretórios ou arquivos que começam com \".\" ou \"_\", para que você tenha mais flexibilidade em termos de como nomear seu diretório de dados de teste.\n\nVeja o diretório [`/test`](test/README.md) para mais exemplos.\n\n## Outros diretórios\n\n### `/docs`\n\nDocumentos do projeto e do usuário (além da documentação gerada pelo godoc).\n\nVeja o diretório [`/docs`](docs/README.md) para mais exemplos.\n\n### `/tools`\n\nFerramentas de suporte para este projeto. Observe que essas ferramentas podem importar código dos diretórios `/pkg` e` /internal`.\n\nVeja o diretório [`/tools`](tools/README.md) para mais exemplos.\n\n### `/examples`\n\nExemplos para seus aplicativos e / ou bibliotecas públicas.\n\nVeja o diretório [`/examples`](examples/README.md) para mais exemplos.\n\n### `/third_party`\n\nFerramentas auxiliares externas, código bifurcado e outros utilitários de terceiros (por exemplo, Swagger UI).\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\nOutros recursos para acompanhar seu repositório (imagens, logotipos etc).\n\n### `/website`\n\nEste é o lugar para colocar os dados do site do seu projeto se você não estiver usando as páginas do GitHub.\n\nVeja o diretório [`/website`](website/README.md) para mais exemplos.\n\n## Diretórios que você não deveria ter\n\n### `/src`\n\nAlguns projetos Go têm uma pasta `src`, mas normalmente acontece quando os devs vêm do mundo Java, onde é um padrão comum. Se você puder se ajudar, tente não adotar esse padrão Java. Você realmente não quer que seu código Go ou projetos Go se pareçam com Java :-)\n\nNão confunda o diretório `/src` do nível do projeto com o diretório` /src` que Go usa para seus espaços de trabalho, conforme descrito em [`How to Write Go Code`](https://golang.org/doc/code.html). A variável de ambiente `$GOPATH` aponta para sua área de trabalho(atual) (por padrão, ela aponta para` $HOME/go` em sistemas não Windows). Este espaço de trabalho inclui os diretórios de nível superior `/pkg`,` /bin` e `/src`. Seu projeto atual acaba sendo um subdiretório em `/ src`, então se você tiver o diretório` /src` em seu projeto, o caminho do projeto será parecido com este: `/algum/caminho/para/workspace/src/your_project/src/ your_code.go`. Observe que com Go 1.11 é possível ter seu projeto fora de seu `GOPATH`, mas ainda não significa que é uma boa ideia usar este padrão de layout.\n\n\n## Distintivos\n\n* [Go Report Card](https://goreportcard.com/) - Ele irá escanear seu código com `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` e `misspell`. Substitua `github.com/golang-standards/project-layout` com sua referência de projeto.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - Ele fornecerá uma versão online da documentação gerada pelo GoDoc. Mude o link para apontar para seu projeto.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev é um novo destino para Go discovery e docs. Você pode criar um emblema usando o [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - Ele mostrará o número da versão mais recente do seu projeto. Altere o link do github para apontar para seu projeto.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Notas\n\nUm modelo de projeto mais opinativo com configurações, scripts e código de amostra/reutilizáveis é um WIP.\n"
        },
        {
          "name": "README_ro.md",
          "type": "blob",
          "size": 13.23,
          "content": "# Structură standard pentru aplicațiile Go\n\nTraduceri:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## General\n\nAceasta este o structură de bază pentru aplicațiile Go. Nu este un standard oficial definit de echipa Go; însă reprezintă un set de structuri/modele comune folosite de-a lungul timpului în aplicațiile din ecosistemul Go. Unele sunt mai populare decât altele. Sunt prezente și îmbunătățiri, cu directoare specifice unei aplicații de mari dimensiuni.\n\nDacă încerci să înveți Go sau să creezi un PoC/proiect hobby aceasta structură este excesivă. Începe cu ceva foarte simplu (un fișier `main.go` e de ajuns). Pe măsură ce proiectul crește ține minte că va fi nevoie să îl structurezi, altfel te vei trezi cu mult cod spagettă și dependințe/state-uri globale greu de întreținut. Când sunt mai mulți oameni care lucrează la proiect, vei avea nevoie de o structură și mai bună. Din acest motiv este important să introduci un mod comun de gestionare a librăriilor/package-urilor. Când ai un proiect open-source, când știi că alte proiecte importă codul din proiectul tău, e important să ai module (packages) private (internal). Clonează acest repo și ține doar ce ai nevoie. Doar pentru că e acolo, nu înseamnă că trebuie să îl folosești. Aceste standarde nu sunt folosite în toate proiectele Go, nici măcar cel comun `vendor` nu este universal.\n\nDe la apariția Go 1.14 [`Go Modules`](https://go.dev/wiki/Modules) sunt gata de producție (production mode). Folosește [`Go Modules`](https://blog.golang.org/using-go-modules) doar dacă nu ai un motiv specific de a nu le folosești. Dacă nu vrei să le folosești atunci nu este nevoie să te gândești la $GOPATH și unde să îți plasezi proiectul. Fișierul `go.mod` din repo-ul tău asumă că proiectul îți este hostat pe Github, însă asta nu e o necesitate. Calea (path) modulelor poate fi orice, însă primul modul component ar trebui să aibă un punct în numele său (versiunea curentă Go nu o mai cere explicit însă dacă folosești o versiune mai veche nu fi surprins dacă primești erori la compilare). Vezi problemele [`37554`](https://github.com/golang/go/issues/37554) și [`32819`](https://github.com/golang/go/issues/32819) dacă vrei să afli mai multe.\n\nAceastă structură este intenționat generică și nu își dorește să impună un standard în gestiunea modulelor Go.\n\nAceastă structură este un efort al comunității. Deschide o problemă (issue) dacă observi o nouă structură sau consideri că una existentă ar trebui actualizată.\n\nDacă ai nevoie de ajutor cu denumirile, formatare, stilare vezi [`gofmt`](https://golang.org/cmd/gofmt/) și [`golint`](https://github.com/golang/lint). Ar fi bine să citești și aceste linii de ghidare în vederea stilării codului Go:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Ghid de stilare pentru modulele Go](https://rakyll.org/style-packages) (rakyll/JBD)\n\nVezi [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) pentru informații adiționale.\n\nMai multe despre numirea și organizarea modulelor + recomandări:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nUn articol chinezeasc despre Package-Oriented-Design și arhitectură:\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Directoarele Go\n\n### `/cmd`\n\nAplicațiile principale ale acestui proiect.\n\nNumele directorului pentru fiecare aplicație ar trebui să coincidă cu numele executabilului pe care vrei să îl ai (e.g., `/cmd/myapp`).\n\nNu pune mult cod în directorul aplicației. Dacă el ar trebui importat și folosit în alte proiecte, atunci ar trebui pus în `/pkg`. Dacă nu este reutilizabil sau vrei ca alții să îl reutilizeze, pune codul în `/internal`. Vei fi surprins ce vor face ceilalți, deci fii explicit în intențiile tale!\n\nEste comun să ai o funcție `main` care doar importă și invocă cod din `/internal` și `/pkg`.\n\nVezi directorul [`/cmd`](cmd/README.md) pentru exemple.\n\n### `/internal`\n\nCod privat al modulelor/aplicației. Acesta este cod pe care nu vrei alții să îl importe în aplicațiile/modulele lor. Această structură este forțată de compilatorul Go. Vezi Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) pentru mai multe detalii. Nu ești însă limitat de un singur director top-level `internal`. Poți avea mai multe directoare `internal` la orice nivel în cadrul proiectului tău.\n\nPoți adăuga o structură adițională modulelor tale interne pentru a separa codul partajat de cel nepartajat. Nu este necesar, dar este bune să ai indicii vizuale pentru a arăta scopul de folosire al modulelor. Codul actual al aplicației poate fi în directorul `/internal/app` (e.g., `/internal/app/myapp`) iar codul partajat de acele aplicații în `/internal/pkg` (e.g., `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nCod librărie care poate fi folosit de aplicațiile externe (e.g., `/pkg/mypubliclib`). Alte proiecte vor importa aceste module și se vor aștepta ca ele să funcționeze, așa că gândește-te de 2 ori înainte de a pune ceva aici :) Directorul `internal` este o modalitate mai bună de a fi sigur că modulele tale no sunt importabile deoarece acest fapt este forțat de Go. Directorul `/pkg` este în continuare un mod bun de a comunica explicit codul ca fiind sigur de folosit de către ceilalți. Postarea [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) oferă o prezentare generală a directoarelor `pkg` și `internal`.\n\nEste o metodă bună să grupezi codul Go într-un singur loc atunci când directorul root al aplicației conține multe componente no-Go, (cum este menționat în aceste prezentări: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) from GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) and [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nVezi [`/pkg`](pkg/README.md) dacă vrei să vezi care repo-uri populare Go folosesc această structură de proiect. Aceasta este o structură comună de proiect însă nu este universală și nu o recomand în comunitatea Go. \n\n### `/vendor`\n\nDependințele aplicației (gestionate manual sau automat). Comanda `go mod vendor` va creea un director `/vendor`. Probabil va trebui să adaugi ca parametru `-mod=vendor` atunci când execuți `go build` dacă nu folosești Go 1.14\n\nNu da commit la dependințele aplicației dacă construiești un modul.\n\nOdată cu versiunea [`1.13`](https://golang.org/doc/go1.13#modules) Go a implementat funcționalitatea modulelor proxy (folosind [`https://proxy.golang.org`](https://proxy.golang.org) ca server proxy al modulelor implicit). Poți citi mai multe despre el [`aici`](https://blog.golang.org/module-mirror-launch). S-ar putea să nu ai nevoie de directorul `/vendor` dacă poți folosi modulele proxy.\n\n## Directoarele de servicii ale aplicației \n\n### `/api`\n\nSpecificații OpenAPI/Swagger, fișiere JSON schema, fișiere cu definiții de protocoale.\n\nVezi directorul [`/api`](api/README.md) pentru exemple.\n\n## Directorul aplicațiilor Web\n\n### `/web`\n\nComponente specifice aplicațiilor Web: asset-uri, template-uri, SPAs, etc\n\n## Directoare comune aplicațiilor \n\n### `/configs`\n\nȘablonuri de configurare, configurări implicite.\n\nPoți pune `confd` sau `consul-template` aici.\n\n### `/init`\n\nConfigurări de inițializare system (systemd, upstart, sysv) și gestiune/supervizare a proceselor (runit, supervisord)\n\n### `/scripts`\n\nScripturi pentru rularea diferitelor operații.\n\nEle țin nivelul rădăcinii Makefile mic și simplu (e.g., [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nVezi directorul [`/scripts`](scripts/README.md) pentru examples.\n\n### `/build`\n\nPackaging și Integrare Continuă.\n\nPune configurări ale modulelor AMI, Docker, OS (deb, rpm, pkg) și scripturi în directorul `/build/package`\n\nPune configurările CI (travis, circle, drone) și scripturile similare în directorul `/build/ci`. Unele instrumente CI sunt pretențioase când vine vorba de locația configurărilor (e.g., Travis CI). Încearcă să pui fișierele de configurare în directorul `/build/ci` legându-le de locația în care uneltele CI se așteaptă să fie. \n\n### `/deployments`\n\nConține sisteme și containere de orchestrare, implementare, șablonare (docker-compose, kubernetes/helm, mesos, terraform, bosh) IaaS, PaaS. În unele repo-uri (în special cele implementate cu kubernetes) acest director e numit direct `/deploy`. \n\n### `/test`\n\nSofturi și fișiere adiționale de testare. Poți structura directorul `/test` cum dorești. Pentru proiecte mari are sens să conțină sub-directoare. De exemplu, poți avea `/test/data` sau `/test/testdata` dacă vrei ca Go să ignore ce este in acel director. Go va ignora și directoarele sau fișierele care încep cu \".\" sau \"\\_\", deci ai mai multă flexibilitate cu privire la modul în care îți numești fișierele/directoarele din `/test`\n\nVezi [directorul](test/README.md) pentru example.\n\n## Alte directoare\n\n### `/docs`\n\nDocumentația structurii aplicației\n\nVezi [`/docs`](docs/README.md) pentru exemple.\n\n### `/tools`\n\nUnelte de suport pentru acest proiect. Ele pot importa și module din directoarele `/pkg` și `/internal`\n\nVezi [`/tools`](tools/README.md) pentru exemple.\n\n### `/examples`\n\nExemple pentru aplicația ta și/sau librării publice\n\nVezi [`/examples`](examples/README.md) pentru exemple.\n\n### `/third_party`\n\nUnelte externe de ajutor, cod forked și alte utilități (e.g., Swagger UI).\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\nAlte aseturi conținute de repo (images, logos, etc).\n\n### `/website`\n\nAcesta este locul în care îți pui datele website, dacă nu folosești pagini GitHub.\n\nVezi [`/website`](website/README.md) pentru exemple.\n\n## Directoare pe care NU ar trebui să le ai\n\n### `/src`\n\nUnele proiecte Go au un director `src`, dar se întâmplă de obicei când developer-ii au venit din domeniul Java. Încearcă să nu adopți o astfel de structură, e indicat ca proiectul tău să nu se asemene cu unul tip Java.\n\nNu confunda directorul `/src` cu cel pe care Go îl folosește ca spațiu de lucru (workspace). Variabila `$GOPATH` arată workspace-ul (implicit el e setat la `$HOME/go` pentru sistemele de operare non-Windows). Acest workspace folosește directoarele `/pkg`, `/bin` și `/src`. Proiectul tău actual ajunge să fie un sub-director sub `/src`, deci dacă ai un director `/src` în proiectul tău, calea va arăta cam așa: `/some/path/to/workspace/src/your_project/src/your_code.go`. Odată cu Go 1.11 este permis să ai proiectul în afara `GOPATH`, însă nu este neapărat o idee bună să adopți o astfel de schemă.\n\n## Adiționale\n\n* [Go Report Card](https://goreportcard.com/) - Îți va scana codul cu `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` și `misspell`. Înlocuiește `github.com/golang-standards/project-layout` cu referința la proiuectul tău.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - Va furniza versiuni online ale documentației generate local de GoDoc.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev este o nouă destinație pentru descoperiri și documentație Go. Poți creea o insignă (badge) cu [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - Va arăta ultimele lansări (versiuni) ale proiectului tău. \n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Note\n\nUn șablon mai pedant cu configurări probate/reutilizabile, scripturi și cod este un WIP.\n"
        },
        {
          "name": "README_ru.md",
          "type": "blob",
          "size": 24.23,
          "content": "# Стандартный макет Go проекта\n\nПереводы:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Обзор\n\nЭто базовый макет организации проектов, разработанных на Go. Это **не официально определенный командой разработчиков Go стандарт**, однако он удовлетворяет исторически сложившимся шаблонам организации проекта в экосистеме Go. Некоторые из шаблонов могут быть известнее остальных. В макете также присутствуют несколько улучшений, включая дополнительные директории, используемые в любом достаточно большом реальном приложении.\n\nЕсли вы пытаетесь изучить Go или собрать маленький обучающий проект для личного пользования, данный макет будет явным перебором. Стоит начать с чего-нибудь действительно простого (одного файла `main.go` будет достаточно). Как только ваш проект начнет расти, стоит задуматься о важности содержания кода в структурированном состоянии, чтобы в конечном итоге не получить грязный код с множеством скрытых зависимостей и global state. А когда над проектом начнут работать другие люди - понадобится еще большая структуризация. В этот момент важно определить стандартный путь организации пакетов/библиотек. Если вы разрабатываете проект с открытым исходным кодом или знаете, что вашим кодом будут пользоваться при разработке других проектов, необходимо понимать важность создания личных, внутренних (или `internal`) пакетов и кода. Клонируйте репозиторий, пользуйтесь тем, что действительно нужно, и удалите всё остальное! Наличие этого \"всего остального\" вовсе не означает, что это обязательно использовать. Заметьте, что ни один из этих шаблонов не обязан быть использован в абсолютно каждом проекте. Даже `vendor` не может быть универсален во всех случаях.\n\nС выходом обновления Go 1.14, [`Go Modules`](https://go.dev/wiki/Modules) стали наконец-то доступны для использования. Применяйте [`Go Modules`](https://blog.golang.org/using-go-modules) везде, пока не столкнётесь с веской причиной отказаться от них, и если такой момент всё же настанет - вам больше не придётся волноваться о значении переменной окружения $GOPATH и месте, где вы размещаете свой проект. Базовый `go.mod` файл в репозитории показывает, что ваш проект размещён на GitHub, однако он не является обязательным. Путь к модулю может быть любым, при условии, что первый компонент пути должен содержать точку в имени (текущая версия Go больше не требует этого, но если вы используете достаточно устаревшие версии - не стоит удивляться, что ваши сборки могу перестать работать). Ознакомьтесь с проблемами: [`37554`](https://github.com/golang/go/issues/37554) и [`32819`](https://github.com/golang/go/issues/32819) если хотите узнать об этом больше.\n\nЭтот шаблон организации проекта намеренно сделан обобщенным, и не является примером структуры какого-то конкретного пакета Go.\n\nЭтот проект открыт сообществу для улучшения. Создайте заявку о проблеме, если вы нашли новый шаблон или считаете, что один из существующих шаблонов необходимо обновить.\n\nЕсли вам нужна помощь в наименовании, форматировании или стилизации кода - начните с [`gofmt`](https://golang.org/cmd/gofmt/) и [`golint`](https://github.com/golang/lint). Также обязательно прочтите эти руководства по стилю для кода на Go и рекомендации:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Руководство по стилизации кода для пакетов Golang](https://rakyll.org/style-packages) (rakyll/JBD)\n\nОбратите внимание на [`Шаблон проекта Golang`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) для получения дополнительной информации.\n\nЕще больше про наименование и организацию пакетов, а так же про структуру кода можно узнать здесь:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nПост о руководствах по пакетно-ориентированному дизайну и архитектурным слоям\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Директории Go\n\n### `/cmd`\n\nОсновные приложения для текущего проекта.\n\nИмя директории для каждого приложения должно совпадать с именем исполняемого файла, который вы хотите собрать (например, `/cmd/myapp`).\n\nНе стоит располагать в этой директории большие объёмы кода. Если вы предполагаете дальнейшее использование кода в других проектах, вам стоит хранить его в директории `/pkg` в корне проекта. Если же код не должен быть переиспользован где-то еще - ему самое место в директории `/internal` в корне проекта. Вы будете удивлены тем, что могут сделать другие люди, по\nтому выражайте свои намерения явно!\n\nСамой распространённой практикой является использование маленькой `main` функции, которая импортирует и вызывает весь необходимый код из директорий `/internal` и `/pkg`, но не из других.\n\nПримеры смотрите в директории [`/cmd`](cmd/README.md).\n\n### `/internal`\n\nВнутренний код приложения и библиотек. Это код, который не должен использоваться в других приложениях и библиотеках. Стоит отметить, что этот шаблон применяется самим компилятором Golang. Ознакомьтесь с [`release notes`](https://golang.org/doc/go1.4#internalpackages) Go 1.4 для более детальной информации. Также, вы вольны использовать более одной директории `internal` на разных уровнях структуры своего проекта.\n\nВы можете добавить дополнительное структурирование, чтобы разделить открытую и закрытую части вашего внутреннего кода. Такой подход не является необходимым, особенно для маленьких проектов, но позволяет сразу визуально оценить применение кода. Код самого приложения может находиться в директории `/internal/app` (например, `/internal/app/myapp`), а код, который это приложение использует - в директории `/internal/pkg` (например, `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nКод библиотек, пригодных для использования в сторонних приложениях (например, `/pkg/mypubliclib`). Другие проекты будут импортировать эти библиотеки, ожидая их автономной работы, поэтому стоит подумать дважды, прежде чем класть сюда какой-нибудь код. Обратите внимание, что использование директории `internal` - более оптимальный способ гарантировать что ваши внутренние пакеты, не будут импортированы, потому что это обеспечивает сам Go. Директория `/pkg` - всё еще хороший путь дать понять, что код в этой директории могут безопасно использовать другие. Статья [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) в блоге Трэвиса Джеффери (Travis Jeffery) предоставляет хороший обзор директорий `pkg` и `internal` и когда есть смысл их использовать.\n\nЭто так же способ группировать код на Go в одном месте, когда ваша корневая директория содержит множество не относящихся к Go компонентов и директорий, что позволит облегчить работу с разными инструментами Go (как упомянуто в этих выступлениях: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) с GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) и [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nОзнакомьтесь с директорией [`/pkg`](pkg/README.md), если хотите увидеть, какие популярные репозитории используют этот макет для организации проекта. Это часто используемый макет, но он не общепринятый, а некоторые в сообществе Go и вовсе не рекомендует его использовать.\n\nВы можете не использовать эту директорию, если проект совсем небольшой и добавление нового уровня вложенности не несет практического смысла (разве что вы сами этого не хотите). Подумайте об этом, когда ваша корневая директория начинает слишком сильно разрастаться, особенно, если у вас много компонентов, написанных не на Go.\n\n### `/vendor`\n\nЗависимости приложений, управляемые вручную или с использованием вашей любимой системы управления зависимостями, вроде доступного из коробки [`Go Modules`](https://go.dev/wiki/Modules). Команда `go mod vendor` создаст для вас директорию `/vendor`. Обратите внимание, что вам возможно придётся добавить флаг `-mod=vendor` к команде `go build`, если вы используете версию, отличную от Go 1.14, где такой флаг выставлен по-умолчанию.\n\nНе стоит отправлять зависимости вашего приложения в репозиторий, если собираетесь создавать библиотеку.\n\nСтоит отметить, что начиная с версии [`1.13`](https://golang.org/doc/go1.13#modules) Go добавил возможность проксирования модулей (с использованием [`https://proxy.golang.org`](https://proxy.golang.org) как прокси-сервера по-умолчанию). [`Здесь`](https://blog.golang.org/module-mirror-launch) можно побольше узнать про эту возможность, чтобы убедиться, что она удовлетворяет вашим требованиям и ограничениям. Если это так - использование директории `vendor` не требуется вовсе.\n\n## Директории приложений-сервисов\n\n### `/api`\n\nСпецификации OpenAPI/Swagger, JSON schema файлы, файлы определения протоколов.\n\nПримеры смотрите в директории [`/api`](api/README.md).\n\n## Директории Веб-приложений\n\n### `/web`\n\nСпециальные компоненты для веб-приложений: статические веб-ресурсы, серверные шаблоны и одностраничные приложения.\n\n## Распространенные директории\n\n### `/configs`\n\nШаблоны файлов конфигураций и файлы настроек по-умолчанию.\n\nПоместите файлы конфигураций `confd` или `consul-template` сюда.\n\n### `/init`\n\nФайлы конфигураций для инициализации системы (systemd, upstart, sysv) и менеджеров процессов (runit, supervisord).\n\n### `/scripts`\n\nСкрипты для выполнения различных операций сборки, установки, анализа и т.п. операций.\n\nЭти скрипты позволяют оставить основной Makefile небольшим и простым (например, [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nПримеры смотрите в директории [`/scripts`](scripts/README.md).\n\n### `/build`\n\nСборка и непрерывная интеграция (Continuous Integration, CI).\n\nПоместите файлы конфигурации и скрипты облака (AMI), контейнера (Docker), пакетов (deb, rpm, pkg) в директорию `/build/package`.\n\nПоместите ваши файлы конфигурации CI (travis, circle, drone) и скрипты в директорию `/build/ci`. Обратите внимание, что некоторые инструменты CI (например, Travis CI) очень требовательны к расположению их конфигурационных файлов. Попробуйте поместить конфигурационные файлы в директорию `/build/ci` создав ссылку на них в месте, где их ожидают найти CI инструменты (если возможно).\n\n### `/deployments`\n\nШаблоны и файлы конфигураций разворачивания IaaS, PaaS, системной и контейнерной оркестрации (docker-compose, kubernetes/helm, mesos, terraform, bosh). Стоит заметить, что в некоторых репозиториях (особенно в приложениях, развернутых с использованием Kubernetes) эта директория называется `/deploy`.\n\n### `/test`\n\nДополнительные внешние тестовые приложения и данные для тестирования. Вы вольны организовывать структуру директории `/test` так, как вам угодно. Для больших проектов имеет смысл создавать вложенную директорию с данными для тестов. Например,`/test/data` или `/test/testdata`, если вы хотите, чтобы Go игнорировал находящиеся там файлы. Стоит заметить, что Go будет также игнорировать файлы, путь к которым начинается с \".\" или \"_\", что предоставляет вам гибкость в наименовании вашей директории с тестовыми данными.\n\nПримеры смотрите в директории [`/test`](test/README.md).\n\n## Другие Директории\n\n### `/docs`\n\nПроектная и пользовательская документация (в дополнение к документации сгенерированной godoc).\n\nПримеры смотрите в директории [`/docs`](docs/README.md).\n\n### `/tools`\n\nИнструменты поддержки проекта. Обратите внимание, что эти инструменты могут импортировать код из директорий `/pkg` и `/internal`.\n\nПримеры смотрите в директории [`/tools`](tools/README.md).\n\n### `/examples`\n\nПримеры ваших приложений и/или библиотек.\n\nПримеры смотрите в директории [`/examples`](examples/README.md).\n\n### `/third_party`\n\nВнешние вспомогательные инструменты, ответвления кода и другие сторонние утилиты (например, Swagger UI).\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\nДругие ресурсы, необходимые для использования вашего репозитория (изображения, логотипы и т.д.)\n\n### `/website`\n\nЗдесь можно разделить файлы для сайта вашего проекта, если вы не используете `GitHub pages`.\n\nПримеры смотрите в директории [`/website`](website/README.md).\n\n## Директории, которые не стоит размещать у себя в проекте\n\n### `/src`\n\nНекоторые проекты на Go имеют директорию `src`, но это обычно происходит, когда разработкой занялся человек, пришедший из мира Java, где такой подход весьма распространен. Постарайтесь не использовать этот Java паттерн. Вы же не хотите, чтобы ваш код на Go или Go проект выглядел, будто написан на Java.\n\nНе путайте директорию уровня проекта `/src` с директорией `/src`, которую Go использует для своих рабочих пространств, как это описано в [`How to Write Go Code`](https://golang.org/doc/code.html). Переменная окружения `$GOPATH` указывает на ваше (текущее) рабочее пространство (по-умолчанию она указывает на `$HOME/go` на системах под управлением ОС, отличной от Windows). Это рабочее пространство включает высокоуровневые директории `/pkg`, `/bin` и `/src`. Ваш проект в свою очередь находится в директории вложенной в директорию `/src`, поэтому если у вас есть директория `/src` внутри вашего проекта, путь к проекту будет выглядеть примерно так: `/some/path/to/workspace/src/your_project/src/your_code.go`. Стоит заметить, что в версиях Go начиная с 1.11 ваш проект может хранить за пределами вашего `GOPATH`, но это всё еще не значит, что применять этот шаблон компоновки - это хорошая идея.\n\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - Просканирует ваш код с помощью `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` и `misspell`. Замените `github.com/golang-standards/project-layout` на ссылку на ваш проект.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - Предоставит онлайн версию вашей сгенерированной GoDoc документации. Измените ссылку, чтобы она указывала на ваш проект.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev это новое место для исследования Go и документации. Вы можете создать бейдж с помощью [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - Покажет версию последнего релиза вашего проекта. Измените ссылку на github, чтобы она указывала на ваш проект.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Примечания\n\nБолее продуманный шаблон проекта с образцами/повторно используемыми конфигурациями, скриптами и кодом — это WIP.\n"
        },
        {
          "name": "README_tr.md",
          "type": "blob",
          "size": 16.18,
          "content": "# Standart Go Projesi Düzeni\n\nÇeviriler:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Genel Bakış:\n\nBu proje Go projeleri için basit bir yerleşim düzenidir. `Go geliştirici takımının belirlediği, resmi standartları değil`. Go ekosistemindeki, ortak geçmişi ve zaman içinde ortaya çıkmış şablonları içerir. Bu şablonlardan bazıları diğerlerinden daha popülerdir. Bir dizi iyileştirmenin yanı sıra yeterli büyüklükte herhangi bir gerçek dünya uygulamasına özgü birkaç destekli dizin de içerir.\n\n**`Eğer Go'yu öğrenmeye çalışıyorsanız veya PoC (Proof of Concept) ya da kendinize deneme bir proje yapıyorsanız bu klasör düzeni sizin için ideal olmaya bilir. Çok basit bir şeyle başlayın (tek bir` main.go `dosyası ve` go.mod `fazlasıyla yeterli olucaktır).`** Projeniz büyüdükçe projenin iyi yapılandırıldığından emin olmanın önemli olduğunu unutmayın, yoksa bir sürü gizli bağımlılık (dependency) ve bir sürü, her yerden erişilebilen, `global` değişkenlerle dolu dağınık bir kodla karşılaşabilirsiniz. Proje üstünde fazla kişi çalıştığında projeyi çok daha fazla yapılandırmanız gerekebilir. İşte tam da bu durumda paketleri/kütüphaneleri idare edebilmek için ortaya ortak bir yol koymak gerekir. Açık kaynak bir projeniz olduğunda ya da başkalarının sizin projenizi kullandıklarını bildiğinizde projenizde özel paketlerin ve kodların (diğer adıyla, `internal` klasörü) olması önemlidir. Bu projeyi klonlayın, ihtiyacınız olanları bırakın ve diğer bütün her şeyi silin. Bütün klasörlerin burada olması kullanmanız gerektiği anlamına gelmez. `vendor` klasörü bile herkes tarafından kullanılan bir şey değildir.\n\nGo 1.14 ile birlikte [`Go Modules`](https://go.dev/wiki/Modules) özelliği sonunda `production` ortamında kullanılması için hazır oldu. Eğer karşı bir nedeniniz yoksa [`Go Modules`](https://blog.golang.org/using-go-modules) kullanın. Eğer kullanırsanız `$GOPATH` ile ve projenizin nereye koyulacağıyla alakalı endişeler duymazsınız. Projenizde bulunan basit `go.mod` dosyası projenizin GitHub'da barındırıldığını varsayar ama bu bir gereklilik değildir. Modül yolu her şey olabilir ama modül yolunun ilk parçasının içinde bir nokta olmalıdır (Go'nun şimdiki versiyonu artık bu konuda zorlamıyor ama eğer daha eski versiyonları kullanırsanız ve derleme işleminde hata alırsanız şaşırmayın). Daha fazla bilgi için [`37554`](https://github.com/golang/go/issues/37554) ve [`32819`](https://github.com/golang/go/issues/32819) hata bildirimlerine bakabilirsiniz.\n\n\"Bu proje düzeni genel bir düzendir ve belirli bir Go paketi yapısını empoze etmeye çalışmaz\".\n\nBu proje bir topluluk eseridir. Eğer yeni bir şablon ve ya düzen ile karşılaşırsanız ya da olan şablonların, düzenlerin güncellenmesi gerektiğini düşünüyorsanız bir hata bildirimi açınız.\n\nEğer isimlendirmekle, biçimlendirmeyle ve stilize etmeyle ilgili yardıma ihtiyacınız varsa [`gofmt`](https://golang.org/cmd/gofmt/) ve [`golint`](https://github.com/golang/lint) yazılımlarını çalıştırmayı deneyin. Ayrıca aşağıdaki Go kod stili rehberlerini ve önerilerini okuduğunuzdan emin olun.    \n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nEk bilgi için [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) adlı yazıya bakabilirsin.\n\nPaketlerin adlandırılması ve düzenlenmesi ile diğer kod yapısı önerileri hakkında daha fazla bilgi:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nPaket odaklı dizayn rehberi ve Mimari katmanı ile alakalı Çince bir yazı:\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go Klasörleri\n\n### `/cmd`\n\nProjenin ana uygulamalarını içerir.\n\nHer uygulamanın klasör adı, eklemek istediğiniz uygulamanın adıyla eşleşmelidir. (örneğin, `/cmd/myapp`)\n\nBu klasöre çok fazla kod koymanız iyi olmaz. Eğer kodların başka projeler tarafından kullanılabileceğini düşünüyorsanız, o kodları `/pkg` klasörüne koymalısınız. Eğer kod yeniden kullanılabilecek değilse ya da diğerlerinin yeniden kullanmasını istemiyorsanız, bu kodları `/internal` klasörüne koymalısınız. Niyetiniz hakkında açık olun, diğer geliştiricilerin kodunuzu ne için kullanabileceğine şaşıracaksınız!\n\n`/internal` ve `/pkg` klasörlerinden kod çağıran küçük bir `main` fonksiyonunuzun olması yaygındır.\n\nÖrnekler için [`/cmd`](cmd/README.md) klasörüne bakabilirsiniz.\n\n### `/internal`\n\nÖzel uygulama ve kütüphane kodunu içerir. Buradaki kodlar diğer geliştiricilerin kendi projelerinde kullanmasını istemediğiniz kodlardır. Bu yerleşim düzeninin Go derleyicisinin kendisi tarafından uygulandığına dikkat edin. Ayrıntılar için Go 1.4 [`sürüm notları`](https://golang.org/doc/go1.4#internalpackages). Üst katmandaki `internal` klasörü ile sınırlı olmadığınızı unutmayın, projenizin herhangi bir katmanında birden fazla `internal` klasörüne sahip olabilirsiniz.\n\nPaylaşılan ve paylaşılmayan kodunuzu ayırmak için isteğe bağlı olarak ekstra yapılar ekleyebilirsiniz. Bu gerekli değildir (özellikle küçük projeler için) ancak amaçlanan paket kullanımını gösteren görsel ipuçlarına sahip olmak güzel bir şeydir. Asıl uygulama kodunuz `/internal/app` klasöründe yer alabilir (örneğin, `/internal/app/benimuygulamam`) ve bu kodlar `/internal/pkg` klasöründe yer alan kodlar (örneğin, `/internal/pkg/benimözelkütüphanem`) ile paylaşılabilir.\n\n### `/pkg`\n\nDiğerleriyle paylaşmak istediğiniz kodu içerir (örneğin, `/pkg/myopenlibrary`). Diğer projeler bu kütüphaneleri çalışacağını tahmin ederek kullanırlar. Yani buraya bir şey koyarken iki kere düşünün :-) Unutmayın ki `internal` klasörü başka projeler tarafından kullanılmasını istemediğiniz kodlar için daha iyi bir yerdir çünkü bu Go tarafından zorunlu olarak uygulanır. `/pkg` klasörü içindeki kodun başkaları tarafından kullanılmasının güvenli olduğunu açıkça belirtmek için hala iyi bir yoldur. Travis Jeffery tarafından yazılan [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) blog yazısı `pkg` ve `internal` klasörleri ve onları ne zaman kullanmanın mantıklı olacağına dair genel bakış sağlar.\n\nAyrıca ana klasörünüz çok sayıda Go kodu olmayan dosya ve klasör içerdiğinde Go kodunu tek bir yerde gruplamanın yoludur ve bazı Go araçlarını kullanmayı daha kolay hale getirir (bu konuşmalarda bahsedildiği gibi: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) GopherCon Avrupa 2018 konferansından, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) ve [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nHangi popüler Go projelerinin bu düzeni kullandığını merak ediyorsanız [`/pkg`](pkg/README.md) klasörüne bakabilirsiniz. Bu genel bir yerleşim düzenidir ama herkes tarafından kabul edilmeyebilir ve bazı Go toplulukları bu yerleşim düzenini tavsiye etmeyebilir.\n\nEğer projenizde ekstra bir katmana gerek yoksa ya da projeniz çok küçükse burayı kullanmamanızda bir sakınca olmaz (çok istiyorsanız kullanın). Projeniz yeterince büyük olduğunda ve ana klasörünüz karışmaya başladığında (özellikle çok fazla Go kodu olmayan dosyanız olduğunda) bunu kullanmayı düşünebilirsiniz.\n\n### `/vendor`\n\nUygulama bağımlılıkları (el ile yönetilen ya da yeni bir özellik olan  [`Go Modules`](https://go.dev/wiki/Modules) gibi favori bağımlılık yönetim aracınızla yönetilen). `go mod vendor` komutu size yeni bir `/vendor` klasörü yaratır. Unutmayın eğer Go 1.14 kullanmıyorsanız `go build` komutuna `-mod=vendor` parametresi vermeniz gerekebilir Go 1.14 bunu varsayılan olarak yapar.\n\nEğer bir kütüphane yazıyorsanız bağımlılıklarınızı `commit` etmeyin.\n\nNot olarak [`1.13`](https://golang.org/doc/go1.13#modules) versiyonundan itibaren Go modüller için `proxy` özelliğini aktif hale getirdi (varsayılan olarak [`https://proxy.golang.org`](https://proxy.golang.org) adresini kullanır). [`Buradan`](https://blog.golang.org/module-mirror-launch) gereksinimlerinize ve kısıtlamalarınıza uyup uymadığı hakkında daha fazla bilgi edinebilirsiniz. Eğer bu size uyarsa `vendor` klasörüne çokta ihtiyacınız olmayacaktır.\n\n## Servis Uygulaması Klasörleri\n\n### `/api`\n\nOpenAPI/Swagger dosyaları, JSON şema dosyaları, protokol tanımlama dosyaları.\n\nÖrnekler için [`/api`](api/README.md) klasörüne bakabilirsiniz.\n\n## Web Uygulaması Klasörleri\n\n### `/web`\n\nSpesifik web uygulaması parçaları: statik web varlıkları, sunucu taraflı şablonlar ve SPA'lar.\n\n## Genel Uygulama Klasörleri\n\n### `/configs`\n\nKonfigürasyon dosya şablonları veya varsayılan konfigürasyonlar.\n\n`confd` veya `consul-template` dosyalarını buraya koyabilirsiniz.\n\n### `/init`\n\nSistem başlangıcı (systemd, upstart, sysv) ve işlem yöneticisi (runit, supervisord) konfigürasyonları.\n\n### `/scripts`\n\nÇeşitli derleme, yükleme, analiz ve benzeri işlemleri gerçekleştirmek için olan komut dosyaları.\n\nBu dosyalar ana katmandaki Makefile dosyasını küçük ve basit tutar. (örneğin, [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile)).\n\nÖrnekler için [`/scripts`](scripts/README.md) klasörüne bakabilirsiniz.\n\n### `/build`\n\nPaketleme ve Sürekli Entegrasyon.\n\n`/build/package` klasörüne bulut (AMI), konteyner (Docker), işletim sistemi (deb, rpm, pkg) paket konfigürasyonlarını ve komut dosyalarını koyabilirsiniz.\n\n`/build/ci` klasörüne de Sürekli Entegrasyon (travis, circle, drone) konfigürasyonlarını ve komut dosyalarını koyabilirsiniz. Önemli olarak bazı sürekli entegrasyon araçları (örneğin, Travis CI) konfigürasyon dosyalarının klasörleriyle alakalı seçici olabiliyor. Konfigürasyon dosyalarını `/build/ci` klasörüne koymayı deneyin ve dosyaları sürekli entegrasyon araçlarının bekledikleri yere bağlayın (mümkün olduğunda).\n\n### `/deployments`\n\nIaaS, Paas, sistem ve konteyner orkestrasyon yayınlama konfigürasyonlarını ve şablonlarını (docker-compose, kubernetes/helm, mesos, terraform, bosh) bu klasöre koyabilirsiniz. Önemli olarak bazı projelerde (özellikle kubernetes ile yayınlanan projeler) bu klasörün adı `/deploy` olabilir.\n\n### `/test`\n\nEk harici test uygulamaları ve test verileri. `/test` klasörünün içini istediğiniz gibi yapılandırmada özgür hissedin. Daha büyük projelerde test verileri için alt klasörler açmak mantıklı olabilir. Örneğin, eğer Go'nun test dosyalarını görmezden gelmesini istiyorsanız bu dosyalar için `/test/data` veya `/test/testdata` adlı klasörlere sahip olabilirsiniz. Not olarak Go \".\" veya \"_\" ile başlayan klasörleri ve dosyalarıda görmezden gelir, bu sayede test klasörlerinizi ve dosyalarınızı isimlendirmede daha esnek olabilirsiniz.\n\nÖrnekler için [`/test`](test/README.md) klasörüne bakabilirsiniz.\n\n## Diğer Klasörler\n\n### `/docs`\n\nTasarım ve kullanıcı dökümanları (godoc ile oluşturulmuş dökümanlara ek olarak)\n\nÖrnekler için [`/docs`](docs/README.md) klasörüne bakabilirsiniz.\n\n### `/tools`\n\nBu klasöre projen için destekleyici araçları koyabilirsiniz. Unutmayın bu araçlar `/pkg` ve `/internal` klasörlerindeki kodları kullanabilirler.\n\nÖrnekler için [`/tools`](tools/README.md) klasörüne bakabilirsiniz.\n\n### `/examples`\n\nBu klasöre yaptığınız uygulamalar ya da kütüphaneler için örnekleri koyabilirsiniz.\n\nÖrnekler için [`/examples`](examples/README.md) klasörüne bakabilirsiniz.\n\n### `/third_party`\n\nDış yardımcı araçlar, çatallanmış kod (forked code) ve diğer 3. parti yardımcı şeyler. (örneğin, Swagger UI)\n\n### `/githooks`\n\nGit hooks.\n\n### `/assets`\n\nBu klasöre resim, logo ve benzeri kaynakları koyabilirsiniz.\n\n### `/website`\n\nEğer GitHub Pages kullanmıyorsanız burası projenin websitesinin dosyalarının konulması için doğru adres.\n\nÖrnekler için [`/website`](website/README.md) klasörüne bakabilirsiniz.\n\n## Sahip olmamanız gereken klasörler\n\n### `/src`\n\nBazı Go projelerinde `src` adlı bir klasör görebilirsiniz, ama bu çoğunlukla `src` klasörü kullanmanın genel bir kalıp olduğu Java dünyasından gelen geliştiricilerde olur. Eğer yapabilirseniz bu Java kalıbını benimsememeye çalışın. Gerçekten Go kodunuzun ya da Go projenizin Java gibi gözükmesini istemezsiniz :-)\n\nProje seviyesindeki `/src` klasörü ile [`How to Write Go Code`](https://golang.org/doc/code.html) adresinde belirtilen Go'nun çalışma alanları için kullandığı `/src` klasörünü karıştırmayın. `$GOPATH` ortam değişkeni sizin çalışma alanınıza (şu anki) işaret eder (Windows olmayan sistemlerde varsayılan olarak `$HOME/go` klasörüne işaret eder). Bu çalışma alanı içerisinde en üst katmandaki `/pkg`, `/bin` ve `/src` klasörlerini barındırır. Asıl projeniz `/src` klasörü altında bir alt dizin olur. Eğer projende `/src` klasörüne sahipseniz, projenizin dosya yolu büyük ihtimal şöyle gözükecek `/calismaalaniniz/src/projeniz/src/kodunuz.go`. Not olarak Go 1.11 ile `$GOPATH` klasörü dışında projeler açabilirsiniz ama bunu yapabilmeniz bu yerleşim düzeninin kullanılmasının iyi bir fikir olduğu anlamına gelmez.\n\n## Rozetler\n\n* [Go Report Card](https://goreportcard.com/) - Kodunuzu  `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` ve `misspell` yazılımları ile tarar. `github.com/golang-standards/project-layout` linkini kendi proje linkiniz ile değiştirin.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - Projenizin GoDoc tarafından yaratılmış online bir dökümantasyonunu çıkartır. İşaret ettiği linki kendi proje linkiniz ile değiştirin.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Paket keşfi ve dökümantasyonları için yeni adres Pkg.go.dev. [Rozet yaratma aracı](https://pkg.go.dev/badge) ile projenize bir rozet yaratabilirsiniz.\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - Projenizin en son yayınlanmış versiyonunu gösterir. İşaret ettiği linki kendi proje linkiniz ile değiştirin.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Notlar\n\nÖrnek / yeniden kullanılabilir yapılandırmalar, komut dosyaları ve kodları içeren daha kararlı bir proje şablonu yapım aşamasındadır.\n"
        },
        {
          "name": "README_ua.md",
          "type": "blob",
          "size": 23.06,
          "content": "# Стандартний макет проєкту Go\n\nTranslations:\n\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Огляд\n\nЦе базовий макет для проєктів Go-додатків. Це **`не є офіційним стандартом, визначеним командою розробників Go`**; тим не менш, це звід паттернів програмування в екосистемі Go, що склалися історично. Деякі з цих паттернів більш популярні та відомі ніж інші. Також в цьому макеті є декілька покращень, в тому числі декілька додаткових дерикторій, що використовуються в будь-якому достатньо великому реальному застосунку.\n\n**`Якщо ви тільки вивчаєте Go або створюєте якийсь демонстраційний чи простий проєкт для себе цей макет буде занадто складним. Почність з чогось дійсно простого (одного файлу `main.go` та `go.mod` буде достатньо).`** Коли проєкт почне рости не забувайте, важливо щоб код залишався добре структурованим, інакше ви отримаєте брудний код з великою кількістю прихованих залежностей та глобальних станів. Якщо над проєктом працює більше людей, необхідно ще більше структури. Саме тоді важливо запровадити єдиний спосіб управління пакетами/бібліотеками. Коли ви маєте проєкт з відкритим вихідним кодом або коли ви знаєте, що інші проєкти імпортують код з вашого репозиторію проєкту, саме тоді важливо мати приватні (`internal`) пакети та код. Клонуйте сховище, зберігайте те, що вам потрібно, а все інше видаляйте! Те, що це є, не означає, що ви повинні використовувати все це. Жодна з цих моделей не використовується в кожному окремому проєкті. Навіть паттерн `vendor` не є універсальним.\n\nПочинаючи з Go 1.14 [`Go модулі`](https://go.dev/wiki/Modules) нарешті готові до використання. Використовуйте [`Go модулі`](https://blog.golang.org/using-go-modules) якщо у вас немає конкретної причини не використовувати їх, а якщо є, то вам не потрібно турбуватися про $GOPATH і про те, куди ви помістили свій проєкт. Базовий файл `go.mod` в репозиторії передбачає, що ваш проєкт розміщено на GitHub, однак це не є обов'язковою вимогою. Шлях до модуля може бути будь-яким, але перший компонент шляху до модуля повинен містити крапку в назві (поточна версія Go більше не вимагає цього, але якщо ви використовуєте трохи старіші версії, не дивуйтеся, якщо ваші збірки не працюватимуть без цього). Якщо ви хочете дізнатися більше про це, дивіться: [`37554`](https://github.com/golang/go/issues/37554) та [`32819`](https://github.com/golang/go/issues/32819).\n\nЦя схема проєкту є навмисно загальною і не намагається нав'язати конкретну структуру пакета Go.\n\nЦе зусилля спільноти. Відкрийте тему, якщо ви бачите новий шаблон або якщо ви вважаєте, що один з існуючих шаблонів потребує оновлення.\n\nЯкщо вам потрібна допомога з іменуванням, форматуванням та стилем, почніть з запуску [`gofmt`](https://golang.org/cmd/gofmt/) та [`golint`](https://github.com/golang/lint). Також обов'язково ознайомтеся з цими керівними принципами та рекомендаціями щодо стилю коду Go:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\nДивіться [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) для додаткової довідкової інформації.\n\nБільше про іменування та організацію пакетів, а також інші рекомендації щодо структури коду:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nКитайська публікація про керівні принципи пакетно-орієнтованого проєктування та рівень архітектури\n* [面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go каталоги\n\n### `/cmd`\n\nГоловні застосунки цього проєкту\n\nІм'я каталогу для кожного додатка повинно збігатися з ім'ям виконуваного файлу, який ви хочете мати (наприклад `/cmd/myapp`).\n\nНе розміщуйте багато коду в каталозі програми. Якщо ви вважаєте, що код може бути імпортований і використаний в інших проєктах, то він повинен знаходитися в каталозі `/pkg`. Якщо код не може бути використаний повторно або якщо ви не хочете, щоб інші використовували його повторно, помістіть цей код в каталог `/internal`. Ви будете здивовані тим, що будуть робити інші, тому будьте відверті у своїх намірах!\n\nЗазвичай є невелика функція `main`, яка імпортує та викликає код з каталогів `/internal` та `/pkg` і нічого більше.\n\nДивіться [`/cmd`](cmd/README.md) для прикладів.\n\n### `/internal`\n\nПриватний код додатків та бібліотек. Це код, який ви не хочете, щоб інші імпортували у свої програми або бібліотеки. Зауважте, що цей шаблон компонування забезпечується самим компілятором Go. Дивіться Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) для додаткових деталей. Зверніть увагу, що ви не обмежені директорією `internal` верхнього рівня. Ви можете мати більше одного каталогу `internal` на будь-якому рівні дерева вашого проєкту.\n\nЗа бажанням ви можете додати трохи додаткової структури до ваших внутрішніх пакунків, щоб відокремити ваш спільний і не спільний внутрішній код. Це не є обов'язковим (особливо для невеликих проєктів), але приємно мати візуальні підказки, що показують передбачуване використання пакунків. Ваш власне код програми може знаходитися у каталозі `/internal/app` (наприклад, `/internal/app/myapp`), а код, який використовується спільно з іншими програмами, у каталозі `/internal/pkg` (наприклад, `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nКод бібліотеки, який можна використовувати зовнішніми програмами (наприклад, `/pkg/mypubliclib`). Інші проєкти імпортуватимуть ці бібліотеки, очікуючи, що вони будуть працювати, тому подумайте двічі, перш ніж щось сюди класти :-) Зауважте, що каталог `internal` є кращим способом гарантувати, що ваші приватні пакунки не будуть імпортовані, оскільки це забезпечується Go. Каталог `/pkg` все ще є гарним способом явно повідомити, що код у цьому каталозі є безпечним для використання іншими. Допис у блозі [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) Тревіса Джеффрі (Travis Jeffery) надає гарний огляд каталогів `pkg` та `internal` і того, коли може мати сенс їх використання.\n\nЦе також спосіб згрупувати код Go в одному місці, коли ваш кореневий каталог містить багато не-Go компонентів і каталогів, що полегшує запуск різних інструментів Go (як згадувалося в цих доповідях: [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) з GopherCon EU 2018, [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) та [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nЯкщо ви хочете побачити, які популярні репозиторії Go використовують цей шаблон оформлення проєктів, зверніться до каталогу [`/pkg`](pkg/README.md). Це загальноприйнятий шаблон, але він не є загальноприйнятим, і дехто у спільноті Go не рекомендує його використовувати.\n\nМожна не використовувати його, якщо ваш проєкт програми дійсно невеликий і де додатковий рівень вкладеності не додає особливої цінності (якщо тільки ви дійсно цього не хочете :-)). Подумайте про це, коли він стане досить великим і ваш кореневий каталог буде досить зайнятий (особливо якщо у вас багато компонентів програми, які не є Go).\n\nПоходження каталогу `pkg`: старий вихідний код Go використовував `pkg` для своїх пакунків, а потім різні проєкти Go у спільноті почали копіювати цей шаблон (див. [`це`](https://twitter.com/bradfitz/status/1039512487538970624) твіт Бреда Фіцпатріка для більш детального контексту).\n\n### `/vendor`\n\nЗалежності додатків (управляються вручну або за допомогою вашого улюбленого інструменту управління залежностями, наприклад, нової вбудованої функції [`Go модулі`](https://go.dev/wiki/Modules)). Команда `go mod vendor` створить для вас каталог `/vendor`. Зауважте, що вам може знадобитися додати прапорець `-mod=vendor` до команди `go build`, якщо ви не використовуєте Go 1.14, де він увімкнений за замовчуванням.\n\nНе фіксуйте залежності програми, якщо ви створюєте бібліотеку.\n\nЗверніть увагу, що починаючи з [`1.13`](https://golang.org/doc/go1.13#modules) Go також включив функцію модульного проксі (використовуючи [`https://proxy.golang.org`](https://proxy.golang.org) в якості свого модульного проксі-сервера за замовчуванням). Прочитайте більше про нього [`тут`](https://blog.golang.org/module-mirror-launch), щоб дізнатися, чи відповідає він усім вашим вимогам і обмеженням. Якщо так, то каталог `vendor` вам взагалі не знадобиться.\n\n## Каталоги сервісних додатків\n\n### `/api`\n\nСпецифікації OpenAPI/Swagger, файли схем JSON, файли визначення протоколів.\n\nПриклади дивіться у каталозі [`/api`](api/README.md).\n\n## Каталоги веб-додатків\n\n### `/web`\n\nСпецифічні компоненти веб-додатків: статичні веб-активи, шаблони на стороні сервера та односторінкові застосунки.\n\n## Загальні директорії додатків\n\n### `/configs`\n\nШаблони файлів конфігурації або конфігурації за замовчуванням.\n\nСюди викладіть файли шаблонів `confd` або `consul-template`.\n\n### `/init`\n\nКонфігурації системного запуску (systemd, upstart, sysv) та диспетчера/супервізора процесів (runit, supervisord).\n\n### `/scripts`\n\nСкрипти для виконання різних операцій по збірці, установці, аналізу і т.д.\n\nЦі скрипти роблять Makefile кореневого рівня невеликим і простим (наприклад, [`https://github.com/hashicorp/terraform/blob/master/Makefile`](https://github.com/hashicorp/terraform/blob/master/Makefile)).\n\nПриклади див. у каталозі [`/scripts`](scripts/README.md).\n\n### `/build`\n\nУпаковка та безперервна інтеграція (CI).\n\nКонфігурації хмарних (AMI), контейнерних (Docker), ОС (deb, rpm, pkg) пакетів та скрипти покладіть в каталог `/build/package`.\n\nПомістіть конфігурації та скрипти CI (travis, circle, drone) в каталог `/build/ci`. Зверніть увагу, що деякі інструменти CI (наприклад, Travis CI) дуже прискіпливі до розташування своїх конфігураційних файлів. Спробуйте помістити конфігураційні файли в каталог `/build/ci`, пов'язавши їх з тим місцем, де їх очікують інструменти CI (коли це можливо).\n\n### `/deployments`\n\nКонфігурації та шаблони розгортання IaaS, PaaS, системної та контейнерної оркестрації (docker-compose, kubernetes/helm, mesos, terraform, bosh). Зверніть увагу, що в деяких репозиторіях (особливо для додатків, що розгортаються за допомогою kubernetes) цей каталог називається `/deploy`.\n\n### `/test`\n\nДодаткові зовнішні тестові програми та тестові дані. Не соромтеся структурувати каталог `/test` як завгодно. Для великих проєктів має сенс мати підкаталог даних. Наприклад, ви можете мати `/test/data` або `/test/testdata`, якщо вам потрібно, щоб команда Go ігнорувала те, що знаходиться в цьому каталозі. Зауважте, що Go також ігноруватиме каталоги або файли, які починаються з \".\" або \"_\", тому у вас є більше гнучкості в плані того, як ви можете назвати свій каталог тестових даних.\n\nПриклади дивіться у каталозі [`/test`](test/README.md).\n\n## Інші директорії\n\n### `/docs`\n\nПроєктна та користувацька документація (на додаток до вашої документації, згенерованої в godoc).\n\nПриклади дивіться у каталозі [`/docs`](docs/README.md).\n\n### `/tools`\n\nДопоміжні інструменти для цього проєкту. Зверніть увагу, що ці інструменти можуть імпортувати код з каталогів `/pkg` та `/internal`.\n\nПриклади дивіться у каталозі [`/tools`](tools/README.md).\n\n### `/examples`\n\nПриклади для ваших додатків та/або публічних бібліотек.\n\nПриклади дивіться у каталозі [`/examples`](examples/README.md).\n\n### `/third_party`\n\nЗовнішні допоміжні інструменти, форкований код та інші утиліти сторонніх розробників (наприклад, Swagger UI).\n\n### `/githooks`\n\nСкріпти (хуки) Git.\n\n### `/assets`\n\nІнші ресурси, які будуть супроводжувати ваш репозиторій (зображення, логотипи тощо).\n\n### `/website`\n\nЦе місце для розміщення даних сайту вашого проєкту, якщо ви не використовуєте GitHub Pages.\n\nПриклади дивіться у каталозі [`/website`](website/README.md).\n\n## Директорії, яких у вас не має бути\n\n### `/src`\n\nДеякі проєкти Go мають папку `src`, але це зазвичай трапляється, коли розробники прийшли зі світу Java, де це є поширеним шаблоном. Намагайтеся не використовувати цей патерн Java. Ви ж не хочете, щоб ваш Go код або Go проєкти виглядали як Java :-)\n\nНе плутайте каталог `/src` на рівні проєкту з каталогом `/src`, який Go використовує для своїх робочих областей, як описано в [`How to Write Go Code`](https://golang.org/doc/code.html). Змінна оточення `$GOPATH` вказує на вашу (поточну) робочу область (за замовчуванням вона вказує на `$HOME/go` на системах, відмінних від Windows). Ця робоча область включає в себе каталоги верхнього рівня `/pkg`, `/bin` та `/src`. Ваш фактичний проєкт закінчується підкаталогом у каталозі `/src`, тому, якщо у вашому проєкті є каталог `/src`, шлях до проєкту буде виглядати наступним чином: `/some/path/to/workspace/src/ваш_проєкт/src/ваш_код.go`. Зауважте, що з Go 1.11 можна мати проєкт поза `GOPATH`, але це ще не означає, що це гарна ідея використовувати цей шаблон компонування.\n\n\n## Бейджі\n\n* [Go Report Card](https://goreportcard.com/) - відсканує ваш код за допомогою `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` та `misspell`. Замініть `github.com/golang-standards/project-layout` посиланням на ваш проєкт.\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - надає онлайн-версію вашої документації, створеної у форматі GoDoc. Змініть посилання, щоб воно вказувало на ваш проєкт.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev це нове місцезнаходження для дослідження Go та документації. Ви можете створити бейдж використовуючи [badge generation tool](https://pkg.go.dev/badge).\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Реліз - покаже номер останнього релізу для вашого проєкту. Змініть посилання на github, щоб воно вказувало на ваш проєкт.\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Нотатки\n\nБільш розгорнутий шаблон проєкту зі зразками/багаторазовими конфігураціями, скриптами та кодом - це WIP.\n"
        },
        {
          "name": "README_vi.md",
          "type": "blob",
          "size": 17.76,
          "content": "# Bố cục tiêu chuẩn của một dự án Go\n\nCác bản dịch:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Vietnamese](README_vi.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n## Tổng quan\n\nĐây là một bố cục cơ bản cho nhiều ứng dụng Go. Dù **`không phải là tiêu chuẩn chính thức được đưa ra từ đội ngũ cốt lõi của Go`**, đây là một tập hợp mẫu bố cục trong hệ sinh thái Go. Những cải tiến nhỏ cùng với một số thư mục hỗ trợ đều có thể được dùng phổ biến cho bất kỳ ứng dụng lớn nào trong thực tế.\n\n**`Nếu bạn đang muốn học Go hoặc đang xây dựng một PoC hoặc một dự án cá nhân đơn giản thì bố cục này là thừa. Bạn nên bắt đầu bằng những thứ đơn giản hơn (chẳng hạn một tập tin `main.go`và một tập tin`go.mod` là đủ).`** Hãy nhớ một điều là khi dự án của bạn phát triển, điều quan trọng là dự án của bạn có cấu trúc tốt, nếu không thì bạn sẽ gặp nhiều vấn đề với mã nguồn lộn xộn cùng các phụ thuộc ẩn và trạng thái toàn cục. Khi bạn có nhiều người làm việc trên một dự án, bạn còn cần cấu trúc nhiều hơn. Vì thế, việc quan trọng là giới thiệu cách phổ biến để quản lý các gói/thư viện. Khi bạn có một dự án mã nguồn mở hoặc khi bạn biết các dự án khác, hãy nhập mã từ kho lưu trữ dự án của bạn, đó là lúc điều quan trọng là phải có các gói và mã riêng tư (hay còn gọi là `nội bộ`). Sao y kho lưu trữ, giữ lại những thứ bạn cần và xóa hết phần còn lại! Chỉ vì nó ở đó không có nghĩa là bạn phải sử dụng tất cả. Không có mẫu nào trong số này được sử dụng trong mọi dự án. Ngay cả mô hình `vendor` cũng không phải là phổ biến.\n\nỞ phiên bản Go 1.14, [`Go Modules`](https://go.dev/wiki/Modules) đã sẵn sàng để dùng trên môi trường production. Trừ khi bạn có một lý do cục thể nào đấy, còn không thì bạn nên dùng [`Go Modules`](https://blog.golang.org/using-go-modules) vì bạn sẽ không cần để tâm tới $GOPATH và nơi bạn đặt dự án của mình. Tập tin cơ bản `go.mod` trong repo giả định rằng dự án của bạn được lưu trữ trên GitHub, nhưng nó không phải là một yêu cầu. Đường dẫn module có thể là bất kỳ thứ gì mặc dù phần đầu thành phần đường dẫn module phải có dấu chấm trong tên của nó (phiên bản Go hiện tại không bắt buộc điều này, nhưng nếu bạn đang sử dụng các phiên bản cũ hơn, đừng ngạc nhiên nếu bản dựng của bạn thất bại khi thiếu nó). Xem các lỗi [`37554`](https://github.com/golang/go/issues/37554) và [`32819`](https://github.com/golang/go/issues/32819) nếu bạn muốn tìm hiểu thêm.\n\nBố cục dự án này có chủ đích chung chung và nó không cố gắng áp đặt một vài trúc gói Go cụ thể.\n\nDự án này là nỗ lực của cộng đồng. Hãy mở một issue nếu bạn gặp một mẫu thiết kế nào mới hoặc bạn nghĩ những mẫu thiết kế có sẵn cần được cập nhật.\n\nBắt đầu với [`gofmt`](https://golang.org/cmd/gofmt/) và [`golint`](https://github.com/golang/lint) nếu bạn cần hỗ trợ về cách đặt tên, định dạng và phong cách. Đồng thời, đảm bảo rằng bạn đã đọc các hướng dẫn và khuyến nghị của Go dưới đây:\n\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Hướng dẫn thiết kế các gói trong Go](https://rakyll.org/style-packages) (rakyll/JBD)\n\nĐọc thêm [`Mẫu dự án Go`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) để biết thêm thông tin cơ bản.\n\nTìm hiểu thêm về cách đặt tên và tổ chức các gói cũng như các đề xuất về cấu trúc mã khác:\n\n* [GopherCon EU 2018: Peter Bourgon - Thực tiễn tốt nhất cho lập trình công nghiệp](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Thực tiễn tốt trong Go.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Các chống mẫu trong Go](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - Bạn cấu trúc ứng dụng Go của mình như thế nào](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\nMột bài đăng của Trung Quốc về hướng dẫn thiết kế theo hướng gói và lớp kiến ​​trúc\n\n* [Thiết kế theo hướng gói và phân lớp kiến ​​trúc](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Các thư mục trong Go\n\n### `/cmd`\n\nThư mục chứa các ứng dụng chính cho dự án này.\n\nTên thư mục cho mỗi ứng dụng phải khớp với tên của tập tin thực thi mà bạn muốn có (ví dụ: `/cmd/myapp`).\n\nĐừng đặt nhiều mã trong thư mục ứng dụng. Nếu bạn nghĩ rằng mã có thể được nhập và sử dụng trong các dự án khác, thì nó sẽ nằm trong thư mục `/pkg`. Nếu mã không thể sử dụng lại được hoặc nếu bạn không muốn người khác sử dụng lại, hãy đặt mã đó vào thư mục `/internal`. Bạn sẽ ngạc nhiên về những gì người khác sẽ làm, vì vậy hãy rõ ràng về ý định của bạn!\n\nThông thường có một hàm `main` nhỏ nhập và gọi mã từ các thư mục `/internal` và `/pkg` và không có gì khác.\n\nXem thêm ví dụ ở thư mục [`/cmd`](cmd/README.md).\n\n### `/internal`\n\nThư mục chứa ứng dụng riêng và mã thư viện. Đây là mã mà bạn không muốn người khác sử dụng trong các ứng dụng hoặc thư viện của họ. Lưu ý, mẫu bố cục này được thực thi bởi chính trình biên dịch Go. Xem Go 1.4 [`ghi chú phát hành`](https://golang.org/doc/go1.4#internalpackages) để biết thêm chi tiết. Lưu ý rằng bạn không bị giới hạn ở thư mục `internal` cấp cao nhất. Bạn có thể có nhiều hơn một thư mục `internal` ở bất kỳ cấp nào trong cây dự án của bạn.\n\nBạn có thể tùy chọn thêm một chút cấu trúc bổ sung vào các gói bên trong của mình để tách mã nội bộ được chia sẻ và không được chia sẻ. Nó không bắt buộc (đặc biệt đối với các dự án nhỏ), nhưng thật tuyệt khi có manh mối trực quan cho thấy mục đích sử dụng gói dự kiến. Mã ứng dụng thực tế của bạn có thể nằm trong thư mục `/internal/app` (ví dụ: `/internal/app/myapp`) và mã được các ứng dụng đó chia sẻ trong thư mục `/internal/pkg` (ví dụ: `/internal/pkg/myprivlib`).\n\n### `/pkg`\n\nThư mục chứa code thư viện cho phép các ứng dụng bên ngoài sử dụng (ví dụ: `/pkg/mypubliclib`). Các dự án khác sẽ nhập các thư viện này và kỳ vọng là chúng sẽ hoạt động, vì vậy hãy nghĩ cẩn thận trước khi bạn để thứ gì vào đây :-). Lưu ý rằng thư mục `nội bộ` là cách tốt hơn để đảm bảo các gói riêng tư của bạn không thể nhập được vì nó được Go thực thi. Thư mục `/pkg` vẫn là một cách tốt để thông báo rõ ràng rằng mã trong thư mục đó an toàn cho người khác sử dụng. Bài [`Tôi sẽ dùng pkg thay vì gói nội bộ`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) đăng bởi Travis Jeffery cung cấp một góc nhìn tổng quan về các thư mục `pkg` và `internal` và khi nào nên dùng chúng.\n\nĐó cũng là một cách để nhóm mã Go vào một nơi khi thư mục gốc của bạn chứa nhiều thành phần và thư mục không phải Go, giúp chạy các công cụ Go khác nhau dễ dàng hơn (như đã đề cập trong các bài nói này: [`Thực tiễn tốt nhất cho lập trình công nghiệp`](https://www.youtube.com/watch?v=PTE4VJIdHPg) từ GopherCon EU 2018, [GopherCon 2018: Kat Zien - Làm thế nào để tổ chức các ứng dụng Go](https://www.youtube.com/watch?v=oL6JBUk6tj0) và [GoLab 2018 - Massimiliano Pippi - Mẫu bố cục dự án trong Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)).\n\nXem thư mục [`/pkg`](pkg/README.md) nếu bạn muốn xem repos Go phổ biến nào dùng bố cục này. Đây là một mẫu bố cục phổ biến, nhưng nó không được chấp nhận rộng rãi và một số người trong cộng đồng Go không khuyến khích nó.\n\nBạn không nên sử dụng nó nếu dự án ứng dụng của bạn thực sự nhỏ và ở đó mức độ lồng ghép bổ sung không mang lại nhiều giá trị (trừ khi bạn thực sự muốn :-)). Hãy nghĩ về nó khi nó đủ lớn và thư mục gốc của bạn trở nên khá bận rộn (đặc biệt nếu bạn có nhiều thành phần ứng dụng không phải của Go).\n\nNguồn gốc thư mục `pkg`: Mã nguồn Go cũ dùng `pkg` cho các gói của nó và sau đó các dự án Go khác trong cộng đồng bắt đầu sao chép mẫu này (xem [`Tweet`](https://twitter.com/bradfitz/status/1039512487538970624) của Brad Fitzpatrick để biết thêm ngữ cảnh).\n\n### `/vendor`\n\nThư mục chứa các phụ thuộc của ứng dụng (được quản lý thủ công hoặc bằng công cụ quản lý phụ thuộc ưa thích của bạn tương tự như tính năng tích hợp mới là [`Go Modules`](https://go.dev/wiki/Modules)). Câu lệnh `go mod vendor` sẽ tạo ra cho bạn một thư mục `/vendor`. Lưu ý rằng bạn có thể sẽ cần phải thêm cờ hiệu `-mod=vendor` cho câu lệnh `go build` nếu bạn không dùng Go 1.14, phiên bản được thêm cờ hiệu mặc định.\n\nKhông nên commit các phụ thuộc ứng dụng nếu bạn đang muốn xây dựng một thư viện.\n\nLưu ý rằng kể từ phiên bản [`1.13`](https://golang.org/doc/go1.13#modules), Go bật tính năng module proxy (mặc định dùng máy chủ module proxy [`https://proxy.golang.org`](https://proxy.golang.org)). Đọc thêm để xem liệu nó có phù hợp với tất cả các yêu cầu và ràng buộc của bạn hay không ở [`đây`](https://blog.golang.org/module-mirror-launch). Nếu có thì bạn không cần tới thư mục `vendor`.\n\n## Thư mục ứng dụng dịch vụ\n\n### `/api`\n\nThư mục chứa bản mô tả OpenAPI/Swagger, tập tin lược đồ JSON, tập tin định nghĩa giao thức.\n\nXem thêm ví dụ ở thư mục [`/api`](api/README.md).\n\n## Thư mục ứng dụng Web\n\n### `/web`\n\nThư mục chứa các thành phần cụ thể của ứng dụng web: tài nguyên web tĩnh, mẫu bên máy chủ và SPAs.\n\nĐể các tập mẫu `confd` và `consul-template` ở đây.\n\n### `/init`\n\nThư mục chứa phần khởi tạo hệ thống (systemd, upstart, sysv) và cấu hình quản lý/giám sát tiến trình (runit, supervisord).\n\n### `/scripts`\n\nThư mục chứa tập lệnh để thực hiện các hoạt động xây dựng, cài đặt, phân tích ...\n\nCác tập lệnh này làm cho tập Makefile ở cấp cao nhất nhỏ gọn và đơn giản. (Ví dụ: [`https://github.com/hashicorp/terraform/blob/master/Makefile`](https://github.com/hashicorp/terraform/blob/master/Makefile))\n\nXem ví dụ ở thư mục [`/scripts`](scripts/README.md).\n\n### `/build`\n\nThư mục chứa gói và tích hợp liên tục.\n\nĐặt các cấu hình và tập lệnh các gói đám mây (AMI), container (Docker), OS (deb, rpm, pkg) của bạn vào thư mục `/build/package`.\n\nĐặt cấu hình và tập lệnh CI (travis, circle, drone) trong thư mục `/build/ci`. Lưu ý rằng một vài công cụ CI (ví dụ: Travis CI) rất kén chọn vị trí của tập tin cấu hình. Thử đặt các tập tin cấu hình ở thư mục `/build/ci`, lên kết chúng với vị trí mà công cụ CI mong đợi (khi có thể).\n\n### `/deployments`\n\nThư mục chứa IaaS, PaaS, các cấu hình và mẫu triển khai điều phối hệ thống và vùng chứa (docker-compose, kubernetes/helm, mesos, terraform, bosh). Lưu ý rằng trong một số repo (đặc biệt là các ứng dụng được triển khai với kubernetes) thư mục này được gọi là `/deploy`.\n\n### `/test`\n\nThư mục chứa các ứng dụng thử nghiệm bên ngoài bổ sung và dữ liệu thử nghiệm. Hãy thoải mái cấu trúc thư mục `/test` theo cách bạn muốn. Đối với các dự án lớn hơn, điều hợp lý là có một thư mục con dữ liệu. Ví dụ: bạn có thể có `/test/data` hoặc `/test/testdata` nếu bạn cần Go bỏ qua những gì trong thư mục đó. Lưu ý rằng Go cũng sẽ bỏ qua các thư mục hoặc tệp bắt đầu bằng \".\" hoặc \"_\", vì vậy bạn có thể linh hoạt hơn về cách đặt tên cho thư mục dữ liệu thử nghiệm của mình.\n\nXem ví dụ ở thư mục [`/test`](test/README.md).\n\n## Thư mục khác\n\n### `/docs`\n\nThư mục chứa tài liệu người dùng và bản thiết kế (bên cạnh tài liệu do godoc tạo ra).\n\nXem ví dụ ở thư mục [`/docs`](docs/README.md).\n\n### `/tools`\n\nThư mục chứa công cụ hỗ trợ cho dự án này. Lưu ý rằng các công cụ này có thể nhập mã từ thư mục `/pkg` và `/internal`.\n\nXem ví dụ ở thư mục [`/tools`](tools/README.md).\n\n### `/examples`\n\nThư mục chứa mẫu cho ứng dụng và/hoặc các thư viện công cộng của bạn.\n\nXem ví dụ ở thư mục [`/examples`](examples/README.md)\n\n### `/third_party`\n\nThư mục chứa các công cụ trợ giúp bên ngoài, mã phân nhánh và các tiện ích bên thứ ba khác (ví dụ: giao diện người dùng Swagger).\n\n### `/githooks`\n\nThư mục chứa git hooks.\n\n### `/assets`\n\nCác tài sản khác đi cùng với kho lưu trữ của bạn (hình ảnh, logo ...).\n\n### `/website`\n\nĐây là nơi để dữ liệu trang web của bạn nếu bạn không sử dụng các trang của GitHub.\n\nXem ví dụ ở thư mục [`/website`](website/README.md).\n\n## Thư mục bạn không nên có\n\n### `/src`\n\nMột vài dự án Go có thư mục `src` nhưng nó thường xảy ra khi các nhà phát triển đến từ thế giới Java, nơi đó là một mẫu phổ biến. Bạn không nên học mẫu này từ Java. Bạn thực sự không muốn mã Go hoặc các dự án Go của mình trông giống như Java :-)\n\nĐừng nhầm lẫn giữa thư mục `/src` cấp dự án với thư mục `/src` mà Go sử dụng cho các không gian làm việc của nó như được mô tả trong [`Cách viết mã Go`](https://golang.org/doc/code.html). Biến môi trường `$GOPATH` trỏ tới không gian làm việc hiện tại của bạn (với những hệ thống không phải là Windows, nó mặc định trỏ tới `$HOME/go`). Không gian làm việc này bao gồm các thư mục `/pkg`, `/bin`, `/src` cấp cao nhất. Dự án thực tế của bạn kết thúc là một thư mục con trong `/src`, vì vậy nếu bạn có thư mục `/src` trong dự án của mình, đường dẫn dự án sẽ giống như sau: `/some/path/to/workspace/src/your_project/src/your_code.go`. Lưu ý rằng với Go 1.11, bạn có thể đặt dự án của mình bên ngoài `GOPATH`, nhưng điều đó không có nghĩa là bạn nên sử dụng mẫu bố cục này.\n\n## Danh hiệu\n\n* [Go Report Card](https://goreportcard.com/) - Nó sẽ quét toàn bộ mã của bạn bằng `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` and `misspell`. Thay `github.com/golang-standards/project-layout` bằng tuỳ chọn trong dự án của bạn.\n\n  [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - Nó sẽ cung cấp phiên bản trực tuyến của tài liệu do GoDoc tự tạo. Đổi đường dẫn để trỏ tới dự án của bạn.~~\n\n  [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev là điểm đến mới cho khám phá và tài liệu về Go. Bạn có thể tạo huy hiệu bằng [badge generation tool](https://pkg.go.dev/badge).\n\n  [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Bản phát hành - Nó sẽ hiển thị số phát hành mới nhất cho dự án của bạn. Thay đổi liên kết github để trỏ đến dự án của bạn.\n\n  [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Ghi chú\n\nMột mẫu dự án \"có định kiến\" (opinionated) hơn đang được xây dựng với các cấu hình, tập lệnh và mã có thể tái sử dụng.\n"
        },
        {
          "name": "README_zh-CN.md",
          "type": "blob",
          "size": 13,
          "content": "# Go项目标准布局\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n这是Go应用程序项目的基础布局。这不是Go核心开发团队定义的官方标准；无论是在经典项目还是在新兴的项目中，这都是Go生态系统中一组常见的项目布局模式。这其中有一些模式比另外的一些更受欢迎。它通过几个支撑目录为任何足够大规模的实际应用程序提供一些增强功能。\n\n如果你正准备学习Go、正在构建PoC项目或编写玩具项目，那么按照这个项目进行布局就大材小用了。从一些真正简单的事情开始（一个`main.go`文件就足够了）。随着项目的增长，确保代码结构的合理是非常重要的，否则最终会出现很多隐藏的依赖关系和全局状态而导致这个项目的代码混乱。当一个项目多人同时进行时，就更需要有清晰的结构，此时引入一种通用的项目包/标准库管理工具就显得尤为重要。当你维护一个开源项目或者有其他项目导入了你的代码，那么有一个私有的包（如`internal`）就很重要了。克隆这个项目，保留你项目中需要的部分，并删除其他部分。通常来说不需要也没必要使用这个项目中的全部内容。因为，从来没有在一个单一的项目中使用本项目中定义的全部模式，甚至如`vendor`模式。\n\nGo 1.14 `Go Modules`已经可以用于生产环境。没有什么特殊原因的话，请使用`Go Modules`，使用它之后，你就再也不用担心`$GOPATH`的配置和项目实际的存放位置，项目想放在哪里就放在哪里。本项目中`go.mod`文件的内容假设你的项目是托管在GitHub上的，当然这不是必选项，因为`Module`中的路径可以是任意的值，一般`Module`路径的第一部分中应该包含一个点（最新版的Go中不再强制要求这一点，如果使用的是稍微旧一些的版本，那么可能遇到编译失败的问题）。了解更多请看Issues [37554](https://github.com/golang/go/issues/37554)和 [32819](https://github.com/golang/go/issues/32819)。\n\n本项目布局有意设计的更通用一些，而不会尝试去引入一些特定的Go包结构。\n\n这是社区共同的努力。如果发现了一种新的模式或者项目中已经存在的某些模式需要更新，请新建一个issue。\n\n如果需要一些关于命名、格式化或者样式方面的帮助，请先运行[`gofmt`](https://golang.org/cmd/gofmt/)和[`golint`](https://github.com/golang/lint)。另外，请务必阅读以下Go代码样式指南和建议：\n\n* <https://talks.golang.org/2014/names.slide>\n* <https://golang.org/doc/effective_go.html#names>\n* <https://blog.golang.org/package-names>\n\n* <https://go.dev/wiki/CodeReviewComments>\n\n* Style guideline for Go packages (rakyll/JBD)\n\n更多背景信息请查看[`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2)。\n\n有关命名和项目包组织样式以及其他代码结构的更多推荐文章：\n\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\n## Go目录\n\n### `/cmd`\n\n项目主要的应用程序。\n\n对于每个应用程序来说这个目录的名字应该和项目可执行文件的名字相匹配（例如，`/cmd/myapp`）。\n\n不要在这个目录中放太多的代码。如果目录中的代码可以被其他项目导入并使用，那么应该把他们放在`/pkg`目录。如果目录中的代码不可重用，或者不希望被他人使用，应该将代码放在`/internal`目录。显式地表明意图比较好！\n\n通常来说，项目都应该拥有一个小的`main`函数，并在`main`函数中导入或者调用`/internal`和`/pkg`目录中的代码。\n\n更多详情，请看[`/cmd`](https://github.com/golang-standards/project-layout/blob/master/cmd/README.md)目录中的例子。\n\n### `/internal`\n\n私有的应用程序代码库。这些是不希望被其他人导入的代码。请注意：这种模式是Go编译器强制执行的。详细内容情况Go 1.4的[release notes](https://golang.org/doc/go1.4#internalpackages)。再次注意，在项目的目录树中的任意位置都可以有`internal`目录，而不仅仅是在顶级目录中。\n\n可以在内部代码包中添加一些额外的结构，来分隔共享和非共享的内部代码。这不是必选项（尤其是在小项目中），但是有一个直观的包用途是很棒的。应用程序实际的代码可以放在`/internal/app`目录（如，`internal/app/myapp`），而应用程序的共享代码放在`/internal/pkg`目录（如，`internal/pkg/myprivlib`）中。\n\n### `/pkg`\n\n外部应用程序可以使用的库代码（如，`/pkg/mypubliclib`）。其他项目将会导入这些库来保证项目可以正常运行，所以在将代码放在这里前，一定要三思而行。请注意，`internal`目录是一个更好的选择来确保项目私有代码不会被其他人导入，因为这是Go强制执行的。使用`/pkg`目录来明确表示代码可以被其他人安全的导入仍然是一个好方式。Travis Jeffery撰写的关于 [I’ll take pkg over internal](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) 文章很好地概述了`pkg`和`inernal`目录以及何时使用它们。\n\n当您的根目录包含大量非Go组件和目录时，这也是一种将Go代码分组到一个位置的方法，从而使运行各种Go工具更加容易（在如下的文章中都有提到：2018年GopherCon [Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)，[Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) ，Golab 2018 [Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)）。\n\n点击查看`/pkg`就能看到那些使用这个布局模式的流行Go代码仓库。这是一种常见的布局模式，但未被普遍接受，并且Go社区中的某些人不推荐这样做。\n\n如果项目确实很小并且嵌套的层次并不会带来多少价值（除非你就是想用它），那么就不要使用它。请仔细思考这种情况，当项目变得很大，并且根目录中包含的内容相当繁杂（尤其是有很多非Go的组件）。\n\n### `/vendor`\n\n应用程序的依赖关系（通过手动或者使用喜欢的依赖管理工具，如新增的内置[Go Modules](https://go.dev/wiki/Modules)特性）。执行`go mod vendor`命令将会在项目中创建`/vendor`目录，注意，如果使用的不是Go 1.14版本，在执行`go build`进行编译时，需要添加`-mod=vendor`命令行选项，因为它不是默认选项。\n\n构建库文件时，不要提交应用程序依赖项。\n\n请注意，从[1.13](https://golang.org/doc/go1.13#modules)开始，Go也启动了模块代理特性（使用`https：//proxy.golang.org`作为默认的模块代理服务器）。点击[这里](https://blog.golang.org/module-mirror-launch)阅读有关它的更多信息，来了解它是否符合所需要求和约束。如果`Go Module`满足需要，那么就不需要`vendor`目录。\n\n## 服务端应用程序的目录\n\n### `/api`\n\nOpenAPI/Swagger规范，JSON模式文件，协议定义文件。\n\n更多样例查看[`/api`](https://github.com/golang-standards/project-layout/blob/master/api/README.md)目录。\n\n## Web应用程序的目录\n\n### `/web`\n\nWeb应用程序特定的组件：静态Web资源，服务器端模板和单页应用（Single-Page App，SPA）。\n\n## 通用应用程序的目录\n\n### `/configs`\n\n配置文件模板或默认配置。\n\n将`confd`或者`consul-template`文件放在这里。\n\n### `/init`\n\n系统初始化（systemd、upstart、sysv）和进程管理（runit、supervisord）配置。\n\n### `/scripts`\n\n用于执行各种构建，安装，分析等操作的脚本。\n\n这些脚本使根级别的Makefile变得更小更简单（例如<https://github.com/hashicorp/terraform/blob/main/Makefile>）。\n\n更多样例查看[`/scripts`](https://github.com/golang-standards/project-layout/blob/master/scripts/README.md)。\n\n### `/build`\n\n打包和持续集成。\n\n将云（AMI），容器（Docker），操作系统（deb，rpm，pkg）软件包配置和脚本放在`/build/package`目录中。\n\n将CI（travis、circle、drone）配置文件和就脚本放在`build/ci`目录中。请注意，有一些CI工具（如，travis CI）对于配置文件的位置有严格的要求。尝试将配置文件放在`/build/ci`目录，然后链接到CI工具想要的位置。\n\n### `/deployments`\n\nIaaS，PaaS，系统和容器编排部署配置和模板（docker-compose，kubernetes/helm，mesos，terraform，bosh）。请注意，在某些存储库中（尤其是使用kubernetes部署的应用程序），该目录的名字是`/deploy`。\n\n### `/test`\n\n外部测试应用程序和测试数据。随时根据需要构建`/test`目录。对于较大的项目，有一个数据子目录更好一些。例如，如果需要Go忽略目录中的内容，则可以使用`/test/data`或`/test/testdata`这样的目录名字。请注意，Go还将忽略以“`.`”或“`_`”开头的目录或文件，因此可以更具灵活性的来命名测试数据目录。\n\n更多样例查看[`/test`](https://github.com/golang-standards/project-layout/blob/master/test/README.md)。\n\n## 其他\n\n### `/docs`\n\n设计和用户文档（除了godoc生成的文档）。\n\n更多样例查看[`/docs`](https://github.com/golang-standards/project-layout/blob/master/docs/README.md)。\n\n### `/tools`\n\n此项目的支持工具。请注意，这些工具可以从`/pkg`和`/internal`目录导入代码。\n\n更多样例查看[`/tools`](https://github.com/golang-standards/project-layout/blob/master/tools/README.md)。\n\n### `/examples`\n\n应用程序或公共库的示例。\n\n更多样例查看[`/examples`](https://github.com/golang-standards/project-layout/blob/master/examples/README.md)。\n\n### `/third_party`\n\n外部辅助工具，fork的代码和其他第三方工具（例如Swagger UI）。\n\n### `/githooks`\n\nGit的钩子。\n\n### `/assets`\n\n项目中使用的其他资源（图像，Logo等）。\n\n### `/website`\n\n如果不使用Github pages，则在这里放置项目的网站数据。\n\n更多样例查看[`/website`](https://github.com/golang-standards/project-layout/blob/master/website/README.md)。\n\n## 不应该出现的目录\n\n### `/src`\n\n有一些Go项目确实包含`src`文件夹，但通常只有在开发者是从Java（这是Java中一个通用的模式）转过来的情况下才会有。如果可以的话请不要使用这种Java模式。你肯定不希望你的Go代码和项目看起来像Java。\n\n不要将项目级别的`/src`目录与Go用于其工作空间的`/src`目录混淆，就像[How to Write Go Code](https://golang.org/doc/code.html)中描述的那样。`$GOPATH`环境变量指向当前的工作空间（默认情况下指向非Windows系统中的`$HOME/go`）。此工作空间包括顶级`/pkg`，`/bin`和`/src`目录。实际的项目最终变成`/src`下的子目录，因此，如果项目中有`/src`目录，则项目路径将会变成：`/some/path/to/workspace/src/your_project/src/your_code.go`。请注意，使用Go 1.11，可以将项目放在GOPATH之外，但这并不意味着使用此布局模式是个好主意。\n\n## 徽章\n\n* [Go Report Card](https://goreportcard.com/)：它将使用`gofmt`，`vet`，`gocyclo`，`golint`，`ineffassign`，`license`和`mispell`扫描项目中的代码。将`github.com/golang-standards/project-layout`替换为你的项目的引用。\n* [GoDoc](http://godoc.org/)：它将提供GoDoc生成的文档的在线版本。更改链接以指向你的项目。\n* Release：它将显示你项目的最新版本号。更改github链接以指向你的项目。\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n[![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## 注意\n\nWIP项目是一个自以为是的项目模板其中带有`sample/reusable`配置、脚本和代码。\n"
        },
        {
          "name": "README_zh-TW.md",
          "type": "blob",
          "size": 14.99,
          "content": "# 標準 Go 專案目錄結構 (Standard Go Project Layout)\n\n其他語言的翻譯：\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n這是 Go 應用程式專案的基本目錄結構。它不是核心 Go 開發團隊定義的官方標準；然而，它是 Go 生態系統中一組常見的老專案和新專案的目錄結構。其中一些目錄結構比其他目錄結構更受歡迎。這個專案目錄結構還有一些細微的改進，可以支援任何大型且實用的應用程式目錄結構。\n\n如果你才剛開始學習 Go 程式語言，或者你只是想建立一個實驗性的玩具專案，這個專案目錄結構就過於複雜了。從一個非常簡單的 `main.go` 檔案開始，其實已經綽綽有餘。但隨著專案增長，你一定要記得，維持一份良好的程式碼結構其實是非常重要的，否則你最終將會得到一堆淩亂的程式碼，這其中肯定也會包含大量隱藏的相依問題與全域狀態。當有越多人參與專案時，你也將需要更多、更好的目錄結構。這時候就是帶入套件/函式庫常見的管理方法最好的時機。當你擁有一個開源專案，或者當你知道有其他專案從你的專案匯入程式碼時，這時候擁有**私有的** (`internal`) 套件和程式碼就很重要。複製這個專案，保留你需要的內容，刪除所有用不到的內容！因為這些目錄結構在這裡並不意味著你全部都要用。這些目錄結構並不是每個專案都會這樣用，甚至連 `vendor` 模式也不是通用的。\n\nGo 1.14 的 [`Go Modules`](https://go.dev/wiki/Modules) 已經是正式版本，除非你有特定的理由不使用它們，否則請一律使用 [`Go Modules`](https://blog.golang.org/using-go-modules) 來管理套件。如果你用了 Go Modules 之後，就無需擔心 `$GOPATH` 與專案放置的位置。專案中的 `go.mod` 檔案假設你的專案放置在 GitHub 中，但這不是必須的。模組路徑可以是任意位址，然而你的模組路徑名稱至少要有個「點」(`.`) 才是合法路徑 (雖然最新版的 Go 不會強迫你一定要用網址當成模組路徑，但如果你用了早期的 Go 版本的話，遇到建置失敗就不要覺得奇怪)。如果你想知道更多資訊，請參考 Issues [`37554`](https://github.com/golang/go/issues/37554) 和 [`32819`](https://github.com/golang/go/issues/32819)。\n\n此專案目錄結構是通用的，它並非嘗試強迫讓你使用在特定的 Go 套件結構。\n\n這個套件是社群共同努力的成果。如果你看到新的模式，或者你認為一個現有的模式需要更新，請提出一個 issue 出來討論。\n\n如果需要命名、格式與程式碼風格方面的協助，請使用 [`gofmt`](https://golang.org/cmd/gofmt/) 和 [`golint`](https://github.com/golang/lint)。也請確保你閱讀過以下這些 Go 程式碼撰寫風格的指導方針與建議：\n\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n\n參見 [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) 了解更多的背景資訊。\n\n更多關於套件的命名與組織方式，以及其他程式碼結構的建議：\n\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\n> 這裡有份中文的文件可供參考：[Go 面向包的设计和架构分层](https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md)\n\n## Go 目錄結構\n\n### `/cmd`\n\n本專案的主要應用程式。\n\n每個應用程式的目錄名應該與你的執行檔案名稱一致 (例如：`/cmd/myapp`)。\n\n不要在這個目錄下放置太多程式碼。如果你認為某些程式碼也可以從其他應用程式或專案中匯入使用，那麼這些程式碼應該位於 `/pkg` 目錄中。如果程式碼不是可重複利用的，或者你不希望其他人使用它，請將該程式碼放到 `/internal` 目錄下。你未來將會驚訝的發現別人是怎麼使用你的程式碼，所以請現在就明確的表達你的意圖！\n\n通常主要應用程式只會有一個小小的 `main` 函式，然後大部分的程式都是從 `/internal` 和 `/pkg` 匯入呼叫並執行，除此之外應該什麼都沒有！\n\n請查看 [`/cmd`](cmd/README.md) 目錄獲得更多範例。\n\n### `/internal`\n\n**私有應用程式**和**函式庫**的程式碼，是你不希望其他人在其應用程式或函式庫中匯入的程式碼。請注意：這個目錄結構是由 Go 編譯器本身所要求的。有關更多細節，請參閱 Go 1.4 的 [`release notes`](https://golang.org/doc/go1.4#internalpackages)。注意：這個目錄並不侷限於放在專案最上層的 `internal` 目錄。事實上，你在專案目錄下的任何子目錄都可以包含 `internal` 目錄。\n\n你可以選擇性的加入一些額外的目錄結構到你的內部套件(`internal package`)中，用來區分你想「共用」與「非共用」的內部程式碼(internal code)。這不是必要的（尤其是對小型專案來說），但有視覺上的線索來表達套件的共用意圖來說，肯定會更好(nice to have)。你的應用程式程式碼可以放在 `/internal/app` 目錄下 (例如：`/internal/app/myapp`)，而這些應用程式共享的程式碼就可以放在 `/internal/pkg` 目錄下 (例如：`/internal/pkg/myprivlib`)。\n\n### `/pkg`\n\n函式庫的程式碼當然可以讓外部應用程式來使用 (例如：`/pkg/mypubliclib`)，其他專案會匯入這些函式庫，並且期待它們能正常運作，所以要把程式放在這個目錄下請多想個幾遍！:-) 注意：使用 `internal` 目錄可以確保私有套件不會被匯入到其他專案使用，因為它是由 Go 的編譯器強制執行的，所以是比較好的解決方案。使用 `/pkg` 目錄仍然是一種很好的方式，它代表其他專案可以安全地使用這個目錄下的程式碼。由 Travis Jeffery 撰寫的 [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) 文章提供了關於 `pkg` 和 `internal` 目錄很好的概述，以及使用它們的時機點。\n\n當專案的根目錄包含許多不是用 Go 所寫的元件與目錄時，將 Go 程式碼放在一個集中的目錄下也是種不錯的方法，這使得運行各種 Go 工具變得更加容易（正如以下這些演講中提到的那樣：來自 GopherCon EU 2018 的 [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg)、[GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) 和 [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk)）。\n\n如果你想查看哪些知名的 Go 專案使用本專案的目錄結構，請查看 [`/pkg`](pkg/README.md) 目錄。這是一組常見的目錄結構，但並不是所有人都接受它，有些 Go 社群的人也不推薦使用。\n\n如果你的應用程式專案真的很小，或是套用這些資料夾不會對你有太大幫助（除非你真的很想用XD），不使用本專案推薦的目錄結構是完全沒問題的。當你的專案變的越來越大，根目錄將會會變得越來越複雜（尤其是當你有許多不是 Go 所寫的元件時)，你可以考慮參考這個專案所建議的目錄結構來組織你的程式碼。\n\n### `/vendor`\n\n應用程式的相依套件可透過手動管理，或使用你喜歡的相依性套件管理工具，例如內建的 [`Go Modules`](https://go.dev/wiki/Modules) 特性。使用 `go mod vendor` 命令可以幫你建立一個 `/vendor` 目錄。請注意：如果你不是用 Go 1.14+ 版本的話，你可能需要在執行 `go build` 的時候增加 `-mod=vendor` 命令列參數。從 Go 1.14 開始，這個參數預設就是啟用的。\n\n如果你正在建立一個函式庫套件，那麼請不要將你應用程式的相依套件加入版控！\n\n注意：從 [`Go 1.13`](https://golang.org/doc/go1.13#modules) 開始，Go 預設啟用了**模組的代理伺服器** (module proxy) 功能 (預設使用 [`https://proxy.golang.org`](https://proxy.golang.org) 作為模組的代理伺服器)。你可以從[`這裡`](https://blog.golang.org/module-mirror-launch)查看這功能是否符合你的需求與限制。如果你可以使用 module proxy 的話，那麼你根本不需要 `vendor` 目錄。\n\n## 服務應用程式目錄 (Service Application Directories)\n\n### `/api`\n\nOpenAPI/Swagger 規格、JSON schema 檔案、各種協定定義檔。\n\n請查看 [`/api`](api/README.md) 目錄獲得更多範例。\n\n## Web 應用程式目錄 (Web Application Directories)\n\n### `/web`\n\nWeb 應用程式相關的元件：靜態 Web 檔案、伺服器端範本與 SPAs 相關檔案。\n\n## 通用應用程式目錄 (Common Application Directories)\n\n### `/configs`\n\n組態設定的檔案範本或預設設定。\n\n將你的 `confd` 或 `consul-template` 範本檔案放在這裡。\n\n### `/init`\n\n放置 System init (`systemd`, `upstart`, `sysv`) 與 Process manager/supervisor (`runit`, `supervisor`) 相關設定。\n\n### `/scripts`\n\n放置要執行各種建置、安裝、分析等操作的命令腳本！\n\n這些腳本可以讓你在根目錄的 `Makefile` 更小、更簡單（例如：[`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile))。\n\n請查看 [`/scripts`](scripts/README.md) 目錄獲得更多範例。\n\n### `/build`\n\n封裝套件與持續整合(CI)。\n\n將你的雲端 (AMI)、容器 (Docker)、OS (deb, rpm, pkg) 套件的組態設定與腳本放在 `/build/package` 目錄下。\n\n將你的 CI (Travis CI, CircleCI, Drone CI) 的組態設定與腳本放在 `/build/ci` 目錄中。請注意：有些 CI 工具 (例如 Travis CI 等)，它們對這些組態設定檔案的位置非常挑剔。如果可能的話，請嘗試將檔案放在 `/build/ci` 目錄中，並**連結** (linking) 這些檔案到 CI 工具期望它們出現的位置。\n\n### `/deployments`\n\nIaaS、PaaS、系統和容器編配部署的組態設定與範本 (docker-compose、kubernetes/helm、mesos、terraform、bosh)。注意：在某些儲存庫中（特別是那些部署在 kubernetes 的應用程式），這個目錄會被命名為 `/deploy`。\n\n### `/test`\n\n額外的外部測試應用程式和測試資料。你可以自在的調整你在 `/test` 目錄中的結構。對於較大的專案來說，通常會有一個 `data` 資料夾也是蠻正常的。例如：如果你需要 Go 忽略這些目錄下的檔案，你可以使用 `/test/data` 或 `/test/testdata` 當作你的目錄名稱。請注意：Go 還會忽略以 `.` 或 `_` 開頭的目錄或檔案，所以你在測試資料的目錄命名上，將擁有更大的彈性。\n\n請查看 [`/test`](test/README.md) 目錄獲得更多範例。\n\n## 其他目錄\n\n### `/docs`\n\n設計和使用者文件 (除了 `godoc` 自動產生的文件之外)。\n\n請查看 [`/docs`](docs/README.md) 目錄獲得更多範例。\n\n### `/tools`\n\n這個專案的支援工具。注意：這些工具可以從 `/pkg` 和 `/internal` 目錄匯入程式碼。\n\n請查看 [`/tools`](tools/README.md) 目錄獲得更多範例。\n\n### `/examples`\n\n放置關於你的應用程式或公用函式庫的使用範例。\n\n請查看 [`/examples`](examples/README.md) 目錄獲得更多範例。\n\n### `/third_party`\n\n外部輔助工具、Forked 程式碼，以及其他第三方工具 (例如：Swagger UI)。\n\n### `/githooks`\n\nGit hooks。\n\n### `/assets`\n\n其他要一併放入儲存庫的相關檔案 (例如圖片、Logo、... 等等)。\n\n### `/website`\n\n如果你不使用 GitHub Pages 的話，這裡可以放置專案的網站相關資料。\n\n請查看 [`/website`](website/README.md) 目錄獲得更多範例。\n\n## 你不應該擁有的目錄\n\n### `/src`\n\n有些 Go 專案確實擁有一個 `src` 資料夾，但這通常發生在開發人員有 Java 背景，這在 Java 的世界很常見。如果你可以嘗試不要採用這種 Java 常見的資料夾的話，你應該不希望你的 Go 程式碼或 Go 專案看起來像 Java 吧！ :-)\n\n不要將專案層級的 `/src` 目錄與 [`How to Write Go Code`](https://golang.org/doc/code.html) 所描述的 `/src` 混為一談。`$GOPATH` 環境變數指向你目前的工作區 (workspace)（非 Windows 的作業環境預設指向 `$HOME/go`），這個工作區包含了最上層的 `/pkg`、`/bin` 和 `/src` 目錄。你的實際專案最終其實是放在 `/src` 下的一個子目錄，所以你的專案路徑大概會長這樣：`/some/path/to/workspace/src/your_project/src/your_code.go`。注意：雖然 Go 1.11 可以將專案放在 `GOPATH` 之外，但這並不意味著使用這種目錄結構模式是一個好主意！\n\n## 徽章 (Badges)\n\n* [Go Report Card](https://goreportcard.com/) - 它會使用 `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` 與 `misspell` 掃描你的程式碼。如下範例請替換 `github.com/golang-standards/project-layout` 為你的專案參考。\n\n    [![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n\n* ~~[GoDoc](http://godoc.org) - It will provide online version of your GoDoc generated documentation. Change the link to point to your project.~~\n\n    [![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n\n* [Pkg.go.dev](https://pkg.go.dev) - Pkg.go.dev 是一個探索 Go 與查閱相關文件的新目標，你可以利用 [徽章建立工具](https://pkg.go.dev/badge) 來替你的套件建立一個徽章。\n\n    [![PkgGoDev](https://pkg.go.dev/badge/github.com/golang-standards/project-layout)](https://pkg.go.dev/github.com/golang-standards/project-layout)\n\n* Release - 它會顯示你專案中的最新發行版號。請變更 GitHub 連結到你的專案！\n\n    [![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## 備註 (Notes)\n\n更多的專案範本，連同範例或可重用的組態設定、腳本命令、程式碼都在持續進行中!\n"
        },
        {
          "name": "README_zh.md",
          "type": "blob",
          "size": 13.17,
          "content": "# Standard Go Project Layout\n\n翻译:\n\n* [English](README.md)\n* [한국어 문서](README_ko.md)\n* [简体中文](README_zh.md)\n* [正體中文](README_zh-TW.md)\n* [简体中文](README_zh-CN.md) - ???\n* [Français](README_fr.md)\n* [日本語](README_ja.md)\n* [Portuguese](README_ptBR.md)\n* [Español](README_es.md)\n* [Română](README_ro.md)\n* [Русский](README_ru.md)\n* [Türkçe](README_tr.md)\n* [Italiano](README_it.md)\n* [Vietnamese](README_vi.md)\n* [Українська](README_ua.md)\n* [Indonesian](README_id.md)\n* [हिन्दी](README_hi.md)\n* [Беларуская](README_by.md)\n\n这是 Go 应用程序项目的基本布局。它不是核心 Go 开发团队定义的官方标准；然而，它是 Go 生态系统中一组常见的老项目和新项目的布局模式。其中一些模式比其他模式更受欢迎。它还具有许多小的增强，以及对任何足够大的实际应用程序通用的几个支持目录。\n\n如果你尝试学习 Go，或者你正在为自己建立一个 PoC 或一个玩具项目，这个项目布局是没啥必要的。从一些非常简单的事情开始(一个 `main.go` 文件绰绰有余)。随着项目的增长，请记住保持代码结构良好非常重要，否则你最终会得到一个凌乱的代码，这其中就包含大量隐藏的依赖项和全局状态。当有更多的人参与这个项目时，你将需要更多的结构。这时候，介绍一种管理包/库的通用方法是很重要的。当你有一个开源项目时，或者当你知道其他项目从你的项目存储库中导入代码时，这时候拥有私有(又名 `internal`)包和代码就很重要。克隆存储库，保留你需要的内容，删除其他所有的内容！仅仅因为它在那里并不意味着你必须全部使用它。这些模式都没有在每个项目中使用。甚至 `vendor` 模式也不是通用的。\n\nGo 1.14 [`Go Modules`](https://go.dev/wiki/Modules) 终于可以投入生产了。除非你有特定的理由不使用它们，否则使用 [`Go Modules`](https://blog.golang.org/using-go-modules) 。如果你使用，就无需担心 $GOPATH 以及项目放置的位置。存储库中的 `go.mod` 文件基本假定你的项目托管在 Github 上，但这不是要求。模块路径可以是任何地方，尽管第一个模块路径组件的名称中应该有一个点（当前版本的 Go 不再强制使用该模块，但如果使用稍旧的版本，如果没有 `mod` 文件构建失败的话 ，不要惊讶）。如果你想知道更多信息，请参阅 Issues [`37554`](https://github.com/golang/go/issues/37554) 和 [`32819`](https://github.com/golang/go/issues/32819) 。\n\n此项目布局是通用的，并且不会尝试强加一个特定的 Go 包结构。\n\n这是社区的努力。 如果看到新的模式，或者认为一个现有的模式需要更新，请提一个 issue。\n\n如果需要命名、格式和样式方面的帮助，请运行 [`gofmt`](https://golang.org/cmd/gofmt/) 和 [`golint`](https://github.com/golang/lint) 。还要确保阅读这些 Go 代码风格的指导方针和建议:\n* https://talks.golang.org/2014/names.slide\n* https://golang.org/doc/effective_go.html#names\n* https://blog.golang.org/package-names\n* https://go.dev/wiki/CodeReviewComments\n* [Style guideline for Go packages](https://rakyll.org/style-packages) (rakyll/JBD)\n\n参见 [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) 了解更多的背景信息。\n\n更多关于包的命名和组织以及其他代码结构的建议:\n* [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n* [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n* [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n* [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\n## Go 目录\n\n### `/cmd`\n\n本项目的主干。\n\n每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，`/cmd/myapp`)。\n\n不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 `/pkg` 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 `/internal` 目录中。你会惊讶于别人会怎么做，所以要明确你的意图!\n\n通常有一个小的 `main` 函数，从 `/internal` 和 `/pkg` 目录导入和调用代码，除此之外没有别的东西。\n\n有关示例，请参阅 [`/cmd`](cmd/README.md) 目录。\n\n### `/internal`\n\n私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 [`release notes`](https://golang.org/doc/go1.4#internalpackages) 。注意，你并不局限于顶级 `internal` 目录。在项目树的任何级别上都可以有多个内部目录。\n\n你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 `/internal/app` 目录下(例如 `/internal/app/myapp`)，这些应用程序共享的代码可以放在 `/internal/pkg` 目录下(例如 `/internal/pkg/myprivlib`)。\n\n### `/pkg`\n\n外部应用程序可以使用的库代码(例如 `/pkg/mypubliclib`)。其他项目会导入这些库，希望它们能正常工作，所以在这里放东西之前要三思:-)注意，`internal` 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。`/pkg` 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。由 Travis Jeffery  撰写的 [`I'll take pkg over internal`](https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/) 博客文章提供了 `pkg` 和 `internal` 目录的一个很好的概述，以及什么时候使用它们是有意义的。\n\n当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易（正如在这些演讲中提到的那样: 来自 GopherCon EU 2018 的 [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) , [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0) 和 [GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go](https://www.youtube.com/watch?v=3gQa1LWwuzk) ）。\n\n如果你想查看哪个流行的 Go 存储库使用此项目布局模式，请查看 [`/pkg`](pkg/README.md) 目录。这是一种常见的布局模式，但并不是所有人都接受它，一些 Go 社区的人也不推荐它。\n\n如果你的应用程序项目真的很小，并且额外的嵌套并不能增加多少价值(除非你真的想要:-)，那就不要使用它。当它变得足够大时，你的根目录会变得非常繁琐时(尤其是当你有很多非 Go 应用组件时)，请考虑一下。\n\n### `/vendor`\n\n应用程序依赖项(手动管理或使用你喜欢的依赖项管理工具，如新的内置 [`Go Modules`](https://go.dev/wiki/Modules) 功能)。`go mod vendor` 命令将为你创建 `/vendor` 目录。请注意，如果未使用默认情况下处于启用状态的 Go 1.14，则可能需要在 `go build` 命令中添加 `-mod=vendor` 标志。\n\n如果你正在构建一个库，那么不要提交你的应用程序依赖项。\n\n注意，自从 [`1.13`](https://golang.org/doc/go1.13#modules) 以后，Go 还启用了模块代理功能(默认使用 [`https://proxy.golang.org`](https://proxy.golang.org) 作为他们的模块代理服务器)。在[`here`](https://blog.golang.org/module-mirror-launch) 阅读更多关于它的信息，看看它是否符合你的所有需求和约束。如果需要，那么你根本不需要 `vendor` 目录。\n\n国内模块代理功能默认是被墙的，七牛云有维护专门的的[`模块代理`](https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md) 。\n\n## 服务应用程序目录\n\n### `/api`\n\nOpenAPI/Swagger 规范，JSON 模式文件，协议定义文件。\n\n有关示例，请参见 [`/api`](api/README.md) 目录。\n\n## Web 应用程序目录\n\n### `/web`\n\n特定于 Web 应用程序的组件:静态 Web 资源、服务器端模板和 SPAs。\n\n\n## 通用应用目录\n\n\n### `/configs`\n\n配置文件模板或默认配置。\n\n将你的 `confd` 或 `consul-template` 模板文件放在这里。\n\n### `/init`\n\nSystem init（systemd，upstart，sysv）和 process manager/supervisor（runit，supervisor）配置。\n\n### `/scripts`\n\n执行各种构建、安装、分析等操作的脚本。\n\n这些脚本保持了根级别的 Makefile 变得小而简单(例如， [`https://github.com/hashicorp/terraform/blob/main/Makefile`](https://github.com/hashicorp/terraform/blob/main/Makefile) )。\n\n有关示例，请参见  [`/scripts`](scripts/README.md) 目录。\n\n### `/build`\n\n打包和持续集成。\n\n将你的云( AMI )、容器( Docker )、操作系统( deb、rpm、pkg )包配置和脚本放在 `/build/package` 目录下。\n\n将你的 CI (travis、circle、drone)配置和脚本放在 `/build/ci` 目录中。请注意，有些 CI 工具(例如 Travis CI)对配置文件的位置非常挑剔。尝试将配置文件放在 `/build/ci` 目录中，将它们链接到 CI 工具期望它们的位置(如果可能的话)。\n\n### `/deployments`\n\nIaaS、PaaS、系统和容器编排部署配置和模板(docker-compose、kubernetes/helm、mesos、terraform、bosh)。注意，在一些存储库中(特别是使用 kubernetes 部署的应用程序)，这个目录被称为 `/deploy`。\n\n### `/test`\n\n额外的外部测试应用程序和测试数据。你可以随时根据需求构造 `/test` 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 `/test/data` 或 `/test/testdata` (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。\n\n有关示例，请参见  [`/test`](test/README.md) 目录。\n\n## 其他目录\n\n### `/docs`\n\n设计和用户文档(除了 godoc 生成的文档之外)。\n\n有关示例，请参阅 [`/docs`](docs/README.md) 目录。\n\n### `/tools`\n\n这个项目的支持工具。注意，这些工具可以从 `/pkg` 和 `/internal` 目录导入代码。\n\n有关示例，请参见 [`/tools`](tools/README.md) 目录。\n\n### `/examples`\n\n你的应用程序和/或公共库的示例。\n\n有关示例，请参见 [`/examples`](examples/README.md) 目录。\n\n### `/third_party`\n\n外部辅助工具，分叉代码和其他第三方工具(例如 Swagger UI)。\n\n### `/githooks`\n\nGit hooks。\n\n### `/assets`\n\n与存储库一起使用的其他资源(图像、徽标等)。\n\n### `/website`\n\n如果你不使用 Github 页面，则在这里放置项目的网站数据。\n\n有关示例，请参见 [`/website`](website/README.md) 目录。\n\n## 你不应该拥有的目录\n\n### `/src`\n\n有些 Go 项目确实有一个 `src` 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。如果可以的话，尽量不要采用这种 Java 模式。你真的不希望你的 Go 代码或 Go 项目看起来像 Java:-)\n\n不要将项目级别 `src` 目录与 Go 用于其工作空间的 `src` 目录(如 [`How to Write Go Code`](https://golang.org/doc/code.html) 中所述)混淆。`$GOPATH` 环境变量指向你的(当前)工作空间(默认情况下，它指向非 windows 系统上的 `$HOME/go`)。这个工作空间包括顶层 `/pkg`, `/bin` 和 `/src` 目录。你的实际项目最终是 `/src` 下的一个子目录，因此，如果你的项目中有 `/src` 目录，那么项目路径将是这样的: `/some/path/to/workspace/src/your_project/src/your_code.go`。注意，在 Go 1.11 中，可以将项目放在 `GOPATH` 之外，但这并不意味着使用这种布局模式是一个好主意。\n\n\n## Badges\n\n* [Go Report Card](https://goreportcard.com/) - It will scan your code with `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` and `misspell`. Replace `github.com/golang-standards/project-layout` with your project reference.\n\n* [GoDoc](http://godoc.org) - It will provide online version of your GoDoc generated documentation. Change the link to point to your project.\n\n* Release - It will show the latest release number for your project. Change the github link to point to your project.\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/golang-standards/project-layout?style=flat-square)](https://goreportcard.com/report/github.com/golang-standards/project-layout)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](http://godoc.org/github.com/golang-standards/project-layout)\n[![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)\n\n## Notes\n\nA more opinionated project template with sample/reusable configs, scripts and code is a WIP.\n\n"
        },
        {
          "name": "api",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "deployments",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "githooks",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.06,
          "content": "module github.com/YOUR-USER-OR-ORG-NAME/YOUR-REPO-NAME\n\ngo 1.19\n"
        },
        {
          "name": "init",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "third_party",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "web",
          "type": "tree",
          "content": null
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}