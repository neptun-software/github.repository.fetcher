{
  "metadata": {
    "timestamp": 1736557571288,
    "page": 613,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zsh-users/zsh-autosuggestions",
      "stars": 31906,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.25,
          "content": "[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\nindent_style = tab\nindent_size = 4\n\n[*.md]\nindent_style = space\n\n[*.rb]\nindent_style = space\nindent_size = 2\n\n[*.yml]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03,
          "content": "# zsh word code files\n*.zwc\n"
        },
        {
          "name": ".rspec",
          "type": "blob",
          "size": 0.05,
          "content": "--color\n--require spec_helper\n--format documentation\n"
        },
        {
          "name": ".rubocop.yml",
          "type": "blob",
          "size": 0.44,
          "content": "# Rails:\n#   Enabled: true\n\nAllCops:\n  TargetRubyVersion: 2.3\n  Include:\n    - '**/Rakefile'\n    - '**/config.ru'\n    - '**/Gemfile'\n\nMetrics/LineLength:\n  Max: 120\n\nStyle/Documentation:\n  Enabled: false\n\nStyle/DotPosition:\n  EnforcedStyle: trailing\n\nStyle/FrozenStringLiteralComment:\n  Enabled: false\n\nStyle/Lambda:\n  Enabled: false\n\nStyle/MultilineMethodCallIndentation:\n  EnforcedStyle: indented\n\nStyle/TrailingUnderscoreVariable:\n  Enabled: false\n"
        },
        {
          "name": ".ruby-version",
          "type": "blob",
          "size": 0.01,
          "content": "2.5.3\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.97,
          "content": "# Changelog\n\n## v0.7.1\n- Clear POSTDISPLAY instead of unsetting (#634)\n- Always reset async file descriptor after consuming it (#630)\n- Always use builtin `exec` (#628)\n- Add `history-beginning-search-*-end` widgets to clear widget list (#619)\n- Switch CI from Circle CI to GitHub Actions\n\n## v0.7.0\n- Enable asynchronous mode by default (#498)\n- No longer wrap user widgets starting with `autosuggest-` prefix (#496)\n- Fix a bug wrapping widgets that modify the buffer (#541)\n\n\n## v0.6.4\n- Fix `vi-forward-char` triggering a bell when using it to accept a suggestion (#488)\n- New configuration option to skip completion suggestions when buffer matches a pattern (#487)\n- New configuration option to ignore history entries matching a pattern (#456)\n\n## v0.6.3\n- Fixed bug moving cursor to end of buffer after accepting suggestion (#453)\n\n## v0.6.2\n- Fixed bug deleting the last character in the buffer in vi mode (#450)\n- Degrade gracefully when user doesn't have `zsh/system` module installed (#447)\n\n## v0.6.1\n- Fixed bug occurring when `_complete` had been aliased (#443)\n\n## v0.6.0\n- Added `completion` suggestion strategy powered by completion system (#111)\n- Allow setting `ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE` to an empty string (#422)\n- Don't fetch suggestions after copy-earlier-word (#439)\n- Allow users to unignore zle-\\* widgets (e.g. zle-line-init) (#432)\n\n\n## v0.5.2\n- Allow disabling automatic widget re-binding for better performance (#418)\n- Fix async suggestions when `SH_WORD_SPLIT` is set\n- Refactor async mode to use process substitution instead of zpty (#417)\n\n## v0.5.1\n- Speed up widget rebinding (#413)\n- Clean up global variable creations (#403)\n- Respect user's set options when running original widget (#402)\n\n## v0.5.0\n- Don't overwrite config with default values (#335)\n- Support fallback strategies by supplying array to suggestion config var\n- Rename \"default\" suggestion strategy to \"history\" to name it based on what it actually does\n- Reset opts in some functions affected by `GLOB_SUBST` (#334)\n- Support widgets starting with dashes (ex: `-a-widget`) (#337)\n- Skip async tests in zsh versions less than 5.0.8 because of reliability issues\n- Fix handling of newline + carriage return in async pty (#333)\n\n\n## v0.4.3\n- Avoid bell when accepting suggestions with `autosuggest-accept` (#228)\n- Don't fetch suggestions after [up,down]-line-or-beginning-search (#227, #241)\n- We are now running CI against new 5.5.1 version\n- Fix partial-accept in vi mode (#188)\n- Fix suggestion disappearing on fast movement after switching to `vicmd` mode (#290)\n- Fix issue rotating through kill ring with `yank-pop` (#301)\n- Fix issue creating new pty for async mode when previous pty is not properly cleaned up (#249)\n\n## v0.4.2\n- Fix bug in zsh versions older than 5.0.8 (#296)\n- Officially support back to zsh v4.3.11\n\n## v0.4.1\n- Switch to [[ and (( conditionals instead of [ (#257)\n- Avoid warnnestedvar warnings with `typeset -g` (#275)\n- Replace tabs with spaces in yaml (#268)\n- Clean up and fix escaping of special characters (#267)\n- Add `emacs-forward-word` to default list of partial accept widgets (#246)\n\n## v0.4.0\n- High-level integration tests using RSpec and tmux\n- Add continuous integration with Circle CI\n- Experimental support for asynchronous suggestions (#170)\n- Fix problems with multi-line suggestions (#225)\n- Optimize case where manually typing in suggestion\n- Avoid wrapping any zle-\\* widgets (#206)\n- Remove support for deprecated options from v0.0.x\n- Handle history entries that begin with dashes\n- Gracefully handle being sourced multiple times (#126)\n- Add enable/disable/toggle widgets to disable/enable suggestions (#219)\n\n\n## v0.3.3\n- Switch from $history array to fc builtin for better performance with large HISTFILEs (#164)\n- Fix tilde handling when extended_glob is set (#168)\n- Add config option for maximum buffer length to fetch suggestions for (#178)\n- Add config option for list of widgets to ignore (#184)\n- Don't fetch a new suggestion unless a modification widget actually modifies the buffer (#183)\n\n## v0.3.2\n- Test runner now supports running specific tests and choosing zsh binary\n- Return code from original widget is now correctly passed through (#135)\n- Add `vi-add-eol` to list of accept widgets (#143)\n- Escapes widget names within evals to fix problems with irregular widget names (#152)\n- Plugin now clears suggestion while within a completion menu (#149)\n- .plugin file no longer relies on symbolic link support, fixing issues on Windows (#156)\n\n## v0.3.1\n\n- Fixes issue with `vi-next-char` not accepting suggestion (#137).\n- Fixes global variable warning when WARN_CREATE_GLOBAL option enabled (#133).\n- Split out a separate test file for each widget.\n\n## v0.3.0\n\n- Adds `autosuggest-execute` widget (PR #124).\n- Adds concept of suggestion \"strategies\" for different ways of fetching suggestions.\n- Adds \"match_prev_cmd\" strategy (PR #131).\n- Uses git submodules for testing dependencies.\n- Lots of test cleanup.\n- Various bug fixes for zsh 5.0.x and `sh_word_split` option.\n\n\n## v0.2.17\n\nStart of changelog.\n"
        },
        {
          "name": "DESCRIPTION",
          "type": "blob",
          "size": 0.05,
          "content": "Fish-like fast/unobtrusive autosuggestions for zsh.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.45,
          "content": "FROM ruby:2.5.3-alpine\n\nARG TEST_ZSH_VERSION\nRUN : \"${TEST_ZSH_VERSION:?}\"\n\nRUN apk add --no-cache autoconf\nRUN apk add --no-cache libtool\nRUN apk add --no-cache libcap-dev\nRUN apk add --no-cache pcre-dev\nRUN apk add --no-cache curl\nRUN apk add --no-cache build-base\nRUN apk add --no-cache ncurses-dev\nRUN apk add --no-cache tmux\n\nWORKDIR /zsh-autosuggestions\n\nADD install_test_zsh.sh ./\nRUN ./install_test_zsh.sh\n\nADD Gemfile Gemfile.lock ./\nRUN bundle install\n"
        },
        {
          "name": "Gemfile",
          "type": "blob",
          "size": 0.08,
          "content": "source 'https://rubygems.org'\n\ngem 'rspec'\ngem 'rspec-wait'\ngem 'pry-byebug'\n"
        },
        {
          "name": "Gemfile.lock",
          "type": "blob",
          "size": 0.8,
          "content": "GEM\n  remote: https://rubygems.org/\n  specs:\n    byebug (9.0.5)\n    coderay (1.1.1)\n    diff-lcs (1.3)\n    method_source (0.8.2)\n    pry (0.10.4)\n      coderay (~> 1.1.0)\n      method_source (~> 0.8.1)\n      slop (~> 3.4)\n    pry-byebug (3.4.0)\n      byebug (~> 9.0)\n      pry (~> 0.10)\n    rspec (3.5.0)\n      rspec-core (~> 3.5.0)\n      rspec-expectations (~> 3.5.0)\n      rspec-mocks (~> 3.5.0)\n    rspec-core (3.5.4)\n      rspec-support (~> 3.5.0)\n    rspec-expectations (3.5.0)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.5.0)\n    rspec-mocks (3.5.0)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.5.0)\n    rspec-support (3.5.0)\n    rspec-wait (0.0.9)\n      rspec (>= 3, < 4)\n    slop (3.6.0)\n\nPLATFORMS\n  ruby\n\nDEPENDENCIES\n  pry-byebug\n  rspec\n  rspec-wait\n\nBUNDLED WITH\n   1.13.6\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 2.84,
          "content": "# Installation\n\n* [Packages](#packages)\n* [Antigen](#antigen)\n* [Oh My Zsh](#oh-my-zsh)\n* [HomeBrew](#homebrew)\n* [Manual](#manual-git-clone)\n\n## Packages\n\n| System  | Package |\n| ------------- | ------------- |\n| Alpine Linux | [zsh-autosuggestions](https://pkgs.alpinelinux.org/packages?name=zsh-autosuggestions) |\n| Debian / Ubuntu | [zsh-autosuggestions OBS repository](https://software.opensuse.org/download.html?project=shells%3Azsh-users%3Azsh-autosuggestions&package=zsh-autosuggestions) |\n| Fedora / CentOS / RHEL / Scientific Linux | [zsh-autosuggestions OBS repository](https://software.opensuse.org/download.html?project=shells%3Azsh-users%3Azsh-autosuggestions&package=zsh-autosuggestions) |\n| OpenSUSE / SLE | [zsh-autosuggestions OBS repository](https://software.opensuse.org/download.html?project=shells%3Azsh-users%3Azsh-autosuggestions&package=zsh-autosuggestions) |\n| Arch Linux / Manjaro / Antergos / Hyperbola | [zsh-autosuggestions](https://www.archlinux.org/packages/zsh-autosuggestions), [zsh-autosuggestions-git](https://aur.archlinux.org/packages/zsh-autosuggestions-git) |\n| NixOS | [zsh-autosuggestions](https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/zs/zsh-autosuggestions/package.nix) |\n| Void Linux | [zsh-autosuggestions](https://github.com/void-linux/void-packages/blob/master/srcpkgs/zsh-autosuggestions/template) |\n| Mac OS | [homebrew](https://github.com/Homebrew/homebrew-core/blob/master/Formula/z/zsh-autosuggestions.rb)  |\n| NetBSD | [pkgsrc](http://ftp.netbsd.org/pub/pkgsrc/current/pkgsrc/shells/zsh-autosuggestions/README.html)  |\n\n## Antigen\n\n1. Add the following to your `.zshrc`:\n\n    ```sh\n    antigen bundle zsh-users/zsh-autosuggestions\n    ```\n\n2. Start a new terminal session.\n\n## Oh My Zsh\n\n1. Clone this repository into `$ZSH_CUSTOM/plugins` (by default `~/.oh-my-zsh/custom/plugins`)\n\n    ```sh\n    git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n    ```\n\n2. Add the plugin to the list of plugins for Oh My Zsh to load (inside `~/.zshrc`):\n\n    ```sh\n    plugins=( \n        # other plugins...\n        zsh-autosuggestions\n    )\n    ```\n\n3. Start a new terminal session.\n\n## Homebrew\n\n1. Install command: \n    ```sh\n    brew install zsh-autosuggestions\n    ```\n\n2. To activate the autosuggestions, add the following at the end of your .zshrc: \n    \n    ```sh\n    source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh\n    ```\n\n3. Start a new terminal session.\n\n## Manual (Git Clone)\n\n1. Clone this repository somewhere on your machine. This guide will assume `~/.zsh/zsh-autosuggestions`.\n\n    ```sh\n    git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions\n    ```\n\n2. Add the following to your `.zshrc`:\n\n    ```sh\n    source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh\n    ```\n\n3. Start a new terminal session.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.07,
          "content": "Copyright (c) 2013 Thiago de Arruda\nCopyright (c) 2016-2021 Eric Freese\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.66,
          "content": "SRC_DIR := ./src\n\nSRC_FILES := \\\n\t$(SRC_DIR)/config.zsh \\\n\t$(SRC_DIR)/util.zsh \\\n\t$(SRC_DIR)/bind.zsh \\\n\t$(SRC_DIR)/highlight.zsh \\\n\t$(SRC_DIR)/widgets.zsh \\\n\t$(SRC_DIR)/strategies/*.zsh \\\n\t$(SRC_DIR)/fetch.zsh \\\n\t$(SRC_DIR)/async.zsh \\\n\t$(SRC_DIR)/start.zsh\n\nHEADER_FILES := \\\n\tDESCRIPTION \\\n\tURL \\\n\tVERSION \\\n\tLICENSE\n\nPLUGIN_TARGET := zsh-autosuggestions.zsh\n\nall: $(PLUGIN_TARGET)\n\n$(PLUGIN_TARGET): $(HEADER_FILES) $(SRC_FILES)\n\tcat $(HEADER_FILES) | sed -e 's/^/# /g' > $@\n\tcat $(SRC_FILES) >> $@\n\n.PHONY: clean\nclean:\n\trm $(PLUGIN_TARGET)\n\n.PHONY: test\ntest: all\n\t@test -n \"$$TEST_ZSH_BIN\" && echo \"Testing zsh binary: $(TEST_ZSH_BIN)\" || true\n\tbundle exec rspec $(TESTS)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.34,
          "content": "# zsh-autosuggestions\n\n_[Fish](http://fishshell.com/)-like fast/unobtrusive autosuggestions for zsh._\n\nIt suggests commands as you type based on history and completions.\n\nRequirements: Zsh v4.3.11 or later\n\n[![Chat on Gitter](https://img.shields.io/gitter/room/zsh-users/zsh-autosuggestions.svg)](https://gitter.im/zsh-users/zsh-autosuggestions)\n\n<a href=\"https://asciinema.org/a/37390\" target=\"_blank\"><img src=\"https://asciinema.org/a/37390.png\" width=\"400\" /></a>\n\n\n## Installation\n\nSee [INSTALL.md](INSTALL.md).\n\n\n## Usage\n\nAs you type commands, you will see a completion offered after the cursor in a muted gray color. This color can be changed by setting the `ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE` variable. See [configuration](#configuration).\n\nIf you press the <kbd>â†’</kbd> key (`forward-char` widget) or <kbd>End</kbd> (`end-of-line` widget) with the cursor at the end of the buffer, it will accept the suggestion, replacing the contents of the command line buffer with the suggestion.\n\nIf you invoke the `forward-word` widget, it will partially accept the suggestion up to the point that the cursor moves to.\n\n\n## Configuration\n\nYou may want to override the default global config variables. Default values of these variables can be found [here](src/config.zsh).\n\n**Note:** If you are using Oh My Zsh, you can put this configuration in a file in the `$ZSH_CUSTOM` directory. See their comments on [overriding internals](https://github.com/robbyrussell/oh-my-zsh/wiki/Customization#overriding-internals).\n\n\n### Suggestion Highlight Style\n\nSet `ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE` to configure the style that the suggestion is shown with. The default is `fg=8`, which will set the foreground color to color 8 from the [256-color palette](https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg). If your terminal only supports 8 colors, you will need to use a number between 0 and 7.\n\nBackground color can also be set, and the suggestion can be styled bold, underlined, or standout. For example, this would show suggestions with bold, underlined, pink text on a cyan background:\n\n```sh\nZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=\"fg=#ff00ff,bg=cyan,bold,underline\"\n```\n\nFor more info, read the Character Highlighting section of the zsh manual: `man zshzle` or [online](http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Character-Highlighting).\n\n**Note:** Some iTerm2 users have reported [not being able to see the suggestions](https://github.com/zsh-users/zsh-autosuggestions/issues/416#issuecomment-486516333). If this affects you, the problem is likely caused by incorrect color settings. In order to correct this, go into iTerm2's setting, navigate to profile > colors and make sure that the colors for Basic Colors > Background and ANSI Colors > Bright Black are **different**.\n\n\n### Suggestion Strategy\n\n`ZSH_AUTOSUGGEST_STRATEGY` is an array that specifies how suggestions should be generated. The strategies in the array are tried successively until a suggestion is found. There are currently three built-in strategies to choose from:\n\n- `history`: Chooses the most recent match from history.\n- `completion`: Chooses a suggestion based on what tab-completion would suggest. (requires `zpty` module, which is included with zsh since 4.0.1)\n- `match_prev_cmd`: Like `history`, but chooses the most recent match whose preceding history item matches the most recently executed command ([more info](src/strategies/match_prev_cmd.zsh)). Note that this strategy won't work as expected with ZSH options that don't preserve the history order such as `HIST_IGNORE_ALL_DUPS` or `HIST_EXPIRE_DUPS_FIRST`.\n\nFor example, setting `ZSH_AUTOSUGGEST_STRATEGY=(history completion)` will first try to find a suggestion from your history, but, if it can't find a match, will find a suggestion from the completion engine.\n\n\n### Widget Mapping\n\nThis plugin works by triggering custom behavior when certain [zle widgets](http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Zle-Widgets) are invoked. You can add and remove widgets from these arrays to change the behavior of this plugin:\n\n- `ZSH_AUTOSUGGEST_CLEAR_WIDGETS`: Widgets in this array will clear the suggestion when invoked.\n- `ZSH_AUTOSUGGEST_ACCEPT_WIDGETS`: Widgets in this array will accept the suggestion when invoked.\n- `ZSH_AUTOSUGGEST_EXECUTE_WIDGETS`: Widgets in this array will execute the suggestion when invoked.\n- `ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS`: Widgets in this array will partially accept the suggestion when invoked.\n- `ZSH_AUTOSUGGEST_IGNORE_WIDGETS`: Widgets in this array will not trigger any custom behavior.\n\nWidgets that modify the buffer and are not found in any of these arrays will fetch a new suggestion after they are invoked.\n\n**Note:** A widget shouldn't belong to more than one of the above arrays.\n\n\n### Disabling suggestion for large buffers\n\nSet `ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE` to an integer value to disable autosuggestion for large buffers. The default is unset, which means that autosuggestion will be tried for any buffer size. Recommended value is 20.\nThis can be useful when pasting large amount of text in the terminal, to avoid triggering autosuggestion for strings that are too long.\n\n### Asynchronous Mode\n\nSuggestions are fetched asynchronously by default in zsh versions 5.0.8 and greater. To disable asynchronous suggestions and fetch them synchronously instead, `unset ZSH_AUTOSUGGEST_USE_ASYNC` after sourcing the plugin.\n\nAlternatively, if you are using a version of zsh older than 5.0.8 and want to enable asynchronous mode, set the `ZSH_AUTOSUGGEST_USE_ASYNC` variable after sourcing the plugin (it can be set to anything). Note that there is [a bug](https://github.com/zsh-users/zsh-autosuggestions/issues/364#issuecomment-481423232) in versions of zsh older than 5.0.8 where <kbd>ctrl</kbd> + <kbd>c</kbd> will fail to reset the prompt immediately after fetching a suggestion asynchronously.\n\n### Disabling automatic widget re-binding\n\nSet `ZSH_AUTOSUGGEST_MANUAL_REBIND` (it can be set to anything) to disable automatic widget re-binding on each precmd. This can be a big boost to performance, but you'll need to handle re-binding yourself if any of the widget lists change or if you or another plugin wrap any of the autosuggest widgets. To re-bind widgets, run `_zsh_autosuggest_bind_widgets`.\n\n### Ignoring history suggestions that match a pattern\n\nSet `ZSH_AUTOSUGGEST_HISTORY_IGNORE` to a [glob pattern](http://zsh.sourceforge.net/Doc/Release/Expansion.html#Glob-Operators) to prevent offering suggestions for history entries that match the pattern. For example, set it to `\"cd *\"` to never suggest any `cd` commands from history. Or set to `\"?(#c50,)\"` to never suggest anything 50 characters or longer.\n\n**Note:** This only affects the `history` and `match_prev_cmd` suggestion strategies.\n\n### Skipping completion suggestions for certain cases\n\nSet `ZSH_AUTOSUGGEST_COMPLETION_IGNORE` to a [glob pattern](http://zsh.sourceforge.net/Doc/Release/Expansion.html#Glob-Operators) to prevent offering completion suggestions when the buffer matches that pattern. For example, set it to `\"git *\"` to disable completion suggestions for git subcommands.\n\n**Note:** This only affects the `completion` suggestion strategy.\n\n\n### Key Bindings\n\nThis plugin provides a few widgets that you can use with `bindkey`:\n\n1. `autosuggest-accept`: Accepts the current suggestion.\n2. `autosuggest-execute`: Accepts and executes the current suggestion.\n3. `autosuggest-clear`: Clears the current suggestion.\n4. `autosuggest-fetch`: Fetches a suggestion (works even when suggestions are disabled).\n5. `autosuggest-disable`: Disables suggestions.\n6. `autosuggest-enable`: Re-enables suggestions.\n7. `autosuggest-toggle`: Toggles between enabled/disabled suggestions.\n\nFor example, this would bind <kbd>ctrl</kbd> + <kbd>space</kbd> to accept the current suggestion.\n\n```sh\nbindkey '^ ' autosuggest-accept\n```\n\n\n## Troubleshooting\n\nIf you have a problem, please search through [the list of issues on GitHub](https://github.com/zsh-users/zsh-autosuggestions/issues?q=) to see if someone else has already reported it.\n\n### Reporting an Issue\n\nBefore reporting an issue, please try temporarily disabling sections of your configuration and other plugins that may be conflicting with this plugin to isolate the problem.\n\nWhen reporting an issue, please include:\n\n- The smallest, simplest `.zshrc` configuration that will reproduce the problem. See [this comment](https://github.com/zsh-users/zsh-autosuggestions/issues/102#issuecomment-180944764) for a good example of what this means.\n- The version of zsh you're using (`zsh --version`)\n- Which operating system you're running\n\n\n## Uninstallation\n\n1. Remove the code referencing this plugin from `~/.zshrc`.\n\n2. Remove the git repository from your hard drive\n\n    ```sh\n    rm -rf ~/.zsh/zsh-autosuggestions # Or wherever you installed\n    ```\n\n\n## Development\n\n### Build Process\n\nEdit the source files in `src/`. Run `make` to build `zsh-autosuggestions.zsh` from those source files.\n\n\n### Pull Requests\n\nPull requests are welcome! If you send a pull request, please:\n\n- Request to merge into the `develop` branch (*NOT* `master`)\n- Match the existing coding conventions.\n- Include helpful comments to keep the barrier-to-entry low for people new to the project.\n- Write tests that cover your code as much as possible.\n\n\n### Testing\n\nTests are written in ruby using the [`rspec`](http://rspec.info/) framework. They use [`tmux`](https://tmux.github.io/) to drive a pseudoterminal, sending simulated keystrokes and making assertions on the terminal content.\n\nTest files live in `spec/`. To run the tests, run `make test`. To run a specific test, run `TESTS=spec/some_spec.rb make test`. You can also specify a `zsh` binary to use by setting the `TEST_ZSH_BIN` environment variable (ex: `TEST_ZSH_BIN=/bin/zsh make test`).\n\nIt's possible to run the tests for any supported version of zsh in a Docker image by building an image from the provided Dockerfile. To build the docker image for a specific version of zsh (where `<version>` below is substituted with the contents of a line from the [`ZSH_VERSIONS`](ZSH_VERSIONS) file), run:\n\n```sh\ndocker build --build-arg TEST_ZSH_VERSION=<version> -t zsh-autosuggestions-test .\n```\n\nAfter building the image, run the tests via:\n\n```sh\ndocker run -it -v $PWD:/zsh-autosuggestions zsh-autosuggestions-test make test\n```\n\n\n## License\n\nThis project is licensed under [MIT license](http://opensource.org/licenses/MIT).\nFor the full text of the license, see the [LICENSE](LICENSE) file.\n"
        },
        {
          "name": "URL",
          "type": "blob",
          "size": 0.05,
          "content": "https://github.com/zsh-users/zsh-autosuggestions\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.01,
          "content": "v0.7.1\n"
        },
        {
          "name": "ZSH_VERSIONS",
          "type": "blob",
          "size": 0.15,
          "content": "# Zsh releases to run tests against\n# See https://github.com/zsh-users/zsh/releases\n4.3.11\n5.0.2\n5.0.8\n5.1.1\n5.2\n5.3.1\n5.4.2\n5.5.1\n5.6.2\n5.7.1\n5.8.1\n5.9\n"
        },
        {
          "name": "install_test_zsh.sh",
          "type": "blob",
          "size": 0.4,
          "content": "#!/bin/sh\n\nset -ex\n\nmkdir zsh-build\ncd zsh-build\n\ncurl -L https://api.github.com/repos/zsh-users/zsh/tarball/zsh-$TEST_ZSH_VERSION | tar xz --strip=1\n\n./Util/preconfig\n./configure --enable-pcre \\\n            --enable-cap \\\n            --enable-multibyte \\\n            --with-term-lib='ncursesw tinfo' \\\n            --with-tcsetpgrp\n\nmake install.bin\nmake install.modules\nmake install.fns\n\ncd ..\n\nrm -rf zsh-build\n"
        },
        {
          "name": "spec",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "zsh-autosuggestions.plugin.zsh",
          "type": "blob",
          "size": 0.04,
          "content": "source ${0:A:h}/zsh-autosuggestions.zsh\n"
        },
        {
          "name": "zsh-autosuggestions.zsh",
          "type": "blob",
          "size": 26.38,
          "content": "# Fish-like fast/unobtrusive autosuggestions for zsh.\n# https://github.com/zsh-users/zsh-autosuggestions\n# v0.7.1\n# Copyright (c) 2013 Thiago de Arruda\n# Copyright (c) 2016-2021 Eric Freese\n# \n# Permission is hereby granted, free of charge, to any person\n# obtaining a copy of this software and associated documentation\n# files (the \"Software\"), to deal in the Software without\n# restriction, including without limitation the rights to use,\n# copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the\n# Software is furnished to do so, subject to the following\n# conditions:\n# \n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n# OTHER DEALINGS IN THE SOFTWARE.\n\n#--------------------------------------------------------------------#\n# Global Configuration Variables                                     #\n#--------------------------------------------------------------------#\n\n# Color to use when highlighting suggestion\n# Uses format of `region_highlight`\n# More info: http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Zle-Widgets\n(( ! ${+ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE} )) &&\ntypeset -g ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'\n\n# Prefix to use when saving original versions of bound widgets\n(( ! ${+ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX} )) &&\ntypeset -g ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX=autosuggest-orig-\n\n# Strategies to use to fetch a suggestion\n# Will try each strategy in order until a suggestion is returned\n(( ! ${+ZSH_AUTOSUGGEST_STRATEGY} )) && {\n\ttypeset -ga ZSH_AUTOSUGGEST_STRATEGY\n\tZSH_AUTOSUGGEST_STRATEGY=(history)\n}\n\n# Widgets that clear the suggestion\n(( ! ${+ZSH_AUTOSUGGEST_CLEAR_WIDGETS} )) && {\n\ttypeset -ga ZSH_AUTOSUGGEST_CLEAR_WIDGETS\n\tZSH_AUTOSUGGEST_CLEAR_WIDGETS=(\n\t\thistory-search-forward\n\t\thistory-search-backward\n\t\thistory-beginning-search-forward\n\t\thistory-beginning-search-backward\n\t\thistory-beginning-search-forward-end\n\t\thistory-beginning-search-backward-end\n\t\thistory-substring-search-up\n\t\thistory-substring-search-down\n\t\tup-line-or-beginning-search\n\t\tdown-line-or-beginning-search\n\t\tup-line-or-history\n\t\tdown-line-or-history\n\t\taccept-line\n\t\tcopy-earlier-word\n\t)\n}\n\n# Widgets that accept the entire suggestion\n(( ! ${+ZSH_AUTOSUGGEST_ACCEPT_WIDGETS} )) && {\n\ttypeset -ga ZSH_AUTOSUGGEST_ACCEPT_WIDGETS\n\tZSH_AUTOSUGGEST_ACCEPT_WIDGETS=(\n\t\tforward-char\n\t\tend-of-line\n\t\tvi-forward-char\n\t\tvi-end-of-line\n\t\tvi-add-eol\n\t)\n}\n\n# Widgets that accept the entire suggestion and execute it\n(( ! ${+ZSH_AUTOSUGGEST_EXECUTE_WIDGETS} )) && {\n\ttypeset -ga ZSH_AUTOSUGGEST_EXECUTE_WIDGETS\n\tZSH_AUTOSUGGEST_EXECUTE_WIDGETS=(\n\t)\n}\n\n# Widgets that accept the suggestion as far as the cursor moves\n(( ! ${+ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS} )) && {\n\ttypeset -ga ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS\n\tZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS=(\n\t\tforward-word\n\t\temacs-forward-word\n\t\tvi-forward-word\n\t\tvi-forward-word-end\n\t\tvi-forward-blank-word\n\t\tvi-forward-blank-word-end\n\t\tvi-find-next-char\n\t\tvi-find-next-char-skip\n\t)\n}\n\n# Widgets that should be ignored (globbing supported but must be escaped)\n(( ! ${+ZSH_AUTOSUGGEST_IGNORE_WIDGETS} )) && {\n\ttypeset -ga ZSH_AUTOSUGGEST_IGNORE_WIDGETS\n\tZSH_AUTOSUGGEST_IGNORE_WIDGETS=(\n\t\torig-\\*\n\t\tbeep\n\t\trun-help\n\t\tset-local-history\n\t\twhich-command\n\t\tyank\n\t\tyank-pop\n\t\tzle-\\*\n\t)\n}\n\n# Pty name for capturing completions for completion suggestion strategy\n(( ! ${+ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME} )) &&\ntypeset -g ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME=zsh_autosuggest_completion_pty\n\n#--------------------------------------------------------------------#\n# Utility Functions                                                  #\n#--------------------------------------------------------------------#\n\n_zsh_autosuggest_escape_command() {\n\tsetopt localoptions EXTENDED_GLOB\n\n\t# Escape special chars in the string (requires EXTENDED_GLOB)\n\techo -E \"${1//(#m)[\\\"\\'\\\\()\\[\\]|*?~]/\\\\$MATCH}\"\n}\n\n#--------------------------------------------------------------------#\n# Widget Helpers                                                     #\n#--------------------------------------------------------------------#\n\n_zsh_autosuggest_incr_bind_count() {\n\ttypeset -gi bind_count=$((_ZSH_AUTOSUGGEST_BIND_COUNTS[$1]+1))\n\t_ZSH_AUTOSUGGEST_BIND_COUNTS[$1]=$bind_count\n}\n\n# Bind a single widget to an autosuggest widget, saving a reference to the original widget\n_zsh_autosuggest_bind_widget() {\n\ttypeset -gA _ZSH_AUTOSUGGEST_BIND_COUNTS\n\n\tlocal widget=$1\n\tlocal autosuggest_action=$2\n\tlocal prefix=$ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX\n\n\tlocal -i bind_count\n\n\t# Save a reference to the original widget\n\tcase $widgets[$widget] in\n\t\t# Already bound\n\t\tuser:_zsh_autosuggest_(bound|orig)_*)\n\t\t\tbind_count=$((_ZSH_AUTOSUGGEST_BIND_COUNTS[$widget]))\n\t\t\t;;\n\n\t\t# User-defined widget\n\t\tuser:*)\n\t\t\t_zsh_autosuggest_incr_bind_count $widget\n\t\t\tzle -N $prefix$bind_count-$widget ${widgets[$widget]#*:}\n\t\t\t;;\n\n\t\t# Built-in widget\n\t\tbuiltin)\n\t\t\t_zsh_autosuggest_incr_bind_count $widget\n\t\t\teval \"_zsh_autosuggest_orig_${(q)widget}() { zle .${(q)widget} }\"\n\t\t\tzle -N $prefix$bind_count-$widget _zsh_autosuggest_orig_$widget\n\t\t\t;;\n\n\t\t# Completion widget\n\t\tcompletion:*)\n\t\t\t_zsh_autosuggest_incr_bind_count $widget\n\t\t\teval \"zle -C $prefix$bind_count-${(q)widget} ${${(s.:.)widgets[$widget]}[2,3]}\"\n\t\t\t;;\n\tesac\n\n\t# Pass the original widget's name explicitly into the autosuggest\n\t# function. Use this passed in widget name to call the original\n\t# widget instead of relying on the $WIDGET variable being set\n\t# correctly. $WIDGET cannot be trusted because other plugins call\n\t# zle without the `-w` flag (e.g. `zle self-insert` instead of\n\t# `zle self-insert -w`).\n\teval \"_zsh_autosuggest_bound_${bind_count}_${(q)widget}() {\n\t\t_zsh_autosuggest_widget_$autosuggest_action $prefix$bind_count-${(q)widget} \\$@\n\t}\"\n\n\t# Create the bound widget\n\tzle -N -- $widget _zsh_autosuggest_bound_${bind_count}_$widget\n}\n\n# Map all configured widgets to the right autosuggest widgets\n_zsh_autosuggest_bind_widgets() {\n\temulate -L zsh\n\n \tlocal widget\n\tlocal ignore_widgets\n\n\tignore_widgets=(\n\t\t.\\*\n\t\t_\\*\n\t\t${_ZSH_AUTOSUGGEST_BUILTIN_ACTIONS/#/autosuggest-}\n\t\t$ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX\\*\n\t\t$ZSH_AUTOSUGGEST_IGNORE_WIDGETS\n\t)\n\n\t# Find every widget we might want to bind and bind it appropriately\n\tfor widget in ${${(f)\"$(builtin zle -la)\"}:#${(j:|:)~ignore_widgets}}; do\n\t\tif [[ -n ${ZSH_AUTOSUGGEST_CLEAR_WIDGETS[(r)$widget]} ]]; then\n\t\t\t_zsh_autosuggest_bind_widget $widget clear\n\t\telif [[ -n ${ZSH_AUTOSUGGEST_ACCEPT_WIDGETS[(r)$widget]} ]]; then\n\t\t\t_zsh_autosuggest_bind_widget $widget accept\n\t\telif [[ -n ${ZSH_AUTOSUGGEST_EXECUTE_WIDGETS[(r)$widget]} ]]; then\n\t\t\t_zsh_autosuggest_bind_widget $widget execute\n\t\telif [[ -n ${ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS[(r)$widget]} ]]; then\n\t\t\t_zsh_autosuggest_bind_widget $widget partial_accept\n\t\telse\n\t\t\t# Assume any unspecified widget might modify the buffer\n\t\t\t_zsh_autosuggest_bind_widget $widget modify\n\t\tfi\n\tdone\n}\n\n# Given the name of an original widget and args, invoke it, if it exists\n_zsh_autosuggest_invoke_original_widget() {\n\t# Do nothing unless called with at least one arg\n\t(( $# )) || return 0\n\n\tlocal original_widget_name=\"$1\"\n\n\tshift\n\n\tif (( ${+widgets[$original_widget_name]} )); then\n\t\tzle $original_widget_name -- $@\n\tfi\n}\n\n#--------------------------------------------------------------------#\n# Highlighting                                                       #\n#--------------------------------------------------------------------#\n\n# If there was a highlight, remove it\n_zsh_autosuggest_highlight_reset() {\n\ttypeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT\n\n\tif [[ -n \"$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT\" ]]; then\n\t\tregion_highlight=(\"${(@)region_highlight:#$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT}\")\n\t\tunset _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT\n\tfi\n}\n\n# If there's a suggestion, highlight it\n_zsh_autosuggest_highlight_apply() {\n\ttypeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT\n\n\tif (( $#POSTDISPLAY )); then\n\t\ttypeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT=\"$#BUFFER $(($#BUFFER + $#POSTDISPLAY)) $ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE\"\n\t\tregion_highlight+=(\"$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT\")\n\telse\n\t\tunset _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT\n\tfi\n}\n\n#--------------------------------------------------------------------#\n# Autosuggest Widget Implementations                                 #\n#--------------------------------------------------------------------#\n\n# Disable suggestions\n_zsh_autosuggest_disable() {\n\ttypeset -g _ZSH_AUTOSUGGEST_DISABLED\n\t_zsh_autosuggest_clear\n}\n\n# Enable suggestions\n_zsh_autosuggest_enable() {\n\tunset _ZSH_AUTOSUGGEST_DISABLED\n\n\tif (( $#BUFFER )); then\n\t\t_zsh_autosuggest_fetch\n\tfi\n}\n\n# Toggle suggestions (enable/disable)\n_zsh_autosuggest_toggle() {\n\tif (( ${+_ZSH_AUTOSUGGEST_DISABLED} )); then\n\t\t_zsh_autosuggest_enable\n\telse\n\t\t_zsh_autosuggest_disable\n\tfi\n}\n\n# Clear the suggestion\n_zsh_autosuggest_clear() {\n\t# Remove the suggestion\n\tPOSTDISPLAY=\n\n\t_zsh_autosuggest_invoke_original_widget $@\n}\n\n# Modify the buffer and get a new suggestion\n_zsh_autosuggest_modify() {\n\tlocal -i retval\n\n\t# Only available in zsh >= 5.4\n\tlocal -i KEYS_QUEUED_COUNT\n\n\t# Save the contents of the buffer/postdisplay\n\tlocal orig_buffer=\"$BUFFER\"\n\tlocal orig_postdisplay=\"$POSTDISPLAY\"\n\n\t# Clear suggestion while waiting for next one\n\tPOSTDISPLAY=\n\n\t# Original widget may modify the buffer\n\t_zsh_autosuggest_invoke_original_widget $@\n\tretval=$?\n\n\temulate -L zsh\n\n\t# Don't fetch a new suggestion if there's more input to be read immediately\n\tif (( $PENDING > 0 || $KEYS_QUEUED_COUNT > 0 )); then\n\t\tPOSTDISPLAY=\"$orig_postdisplay\"\n\t\treturn $retval\n\tfi\n\n\t# Optimize if manually typing in the suggestion or if buffer hasn't changed\n\tif [[ \"$BUFFER\" = \"$orig_buffer\"* && \"$orig_postdisplay\" = \"${BUFFER:$#orig_buffer}\"* ]]; then\n\t\tPOSTDISPLAY=\"${orig_postdisplay:$(($#BUFFER - $#orig_buffer))}\"\n\t\treturn $retval\n\tfi\n\n\t# Bail out if suggestions are disabled\n\tif (( ${+_ZSH_AUTOSUGGEST_DISABLED} )); then\n\t\treturn $?\n\tfi\n\n\t# Get a new suggestion if the buffer is not empty after modification\n\tif (( $#BUFFER > 0 )); then\n\t\tif [[ -z \"$ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE\" ]] || (( $#BUFFER <= $ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE )); then\n\t\t\t_zsh_autosuggest_fetch\n\t\tfi\n\tfi\n\n\treturn $retval\n}\n\n# Fetch a new suggestion based on what's currently in the buffer\n_zsh_autosuggest_fetch() {\n\tif (( ${+ZSH_AUTOSUGGEST_USE_ASYNC} )); then\n\t\t_zsh_autosuggest_async_request \"$BUFFER\"\n\telse\n\t\tlocal suggestion\n\t\t_zsh_autosuggest_fetch_suggestion \"$BUFFER\"\n\t\t_zsh_autosuggest_suggest \"$suggestion\"\n\tfi\n}\n\n# Offer a suggestion\n_zsh_autosuggest_suggest() {\n\temulate -L zsh\n\n\tlocal suggestion=\"$1\"\n\n\tif [[ -n \"$suggestion\" ]] && (( $#BUFFER )); then\n\t\tPOSTDISPLAY=\"${suggestion#$BUFFER}\"\n\telse\n\t\tPOSTDISPLAY=\n\tfi\n}\n\n# Accept the entire suggestion\n_zsh_autosuggest_accept() {\n\tlocal -i retval max_cursor_pos=$#BUFFER\n\n\t# When vicmd keymap is active, the cursor can't move all the way\n\t# to the end of the buffer\n\tif [[ \"$KEYMAP\" = \"vicmd\" ]]; then\n\t\tmax_cursor_pos=$((max_cursor_pos - 1))\n\tfi\n\n\t# If we're not in a valid state to accept a suggestion, just run the\n\t# original widget and bail out\n\tif (( $CURSOR != $max_cursor_pos || !$#POSTDISPLAY )); then\n\t\t_zsh_autosuggest_invoke_original_widget $@\n\t\treturn\n\tfi\n\n\t# Only accept if the cursor is at the end of the buffer\n\t# Add the suggestion to the buffer\n\tBUFFER=\"$BUFFER$POSTDISPLAY\"\n\n\t# Remove the suggestion\n\tPOSTDISPLAY=\n\n\t# Run the original widget before manually moving the cursor so that the\n\t# cursor movement doesn't make the widget do something unexpected\n\t_zsh_autosuggest_invoke_original_widget $@\n\tretval=$?\n\n\t# Move the cursor to the end of the buffer\n\tif [[ \"$KEYMAP\" = \"vicmd\" ]]; then\n\t\tCURSOR=$(($#BUFFER - 1))\n\telse\n\t\tCURSOR=$#BUFFER\n\tfi\n\n\treturn $retval\n}\n\n# Accept the entire suggestion and execute it\n_zsh_autosuggest_execute() {\n\t# Add the suggestion to the buffer\n\tBUFFER=\"$BUFFER$POSTDISPLAY\"\n\n\t# Remove the suggestion\n\tPOSTDISPLAY=\n\n\t# Call the original `accept-line` to handle syntax highlighting or\n\t# other potential custom behavior\n\t_zsh_autosuggest_invoke_original_widget \"accept-line\"\n}\n\n# Partially accept the suggestion\n_zsh_autosuggest_partial_accept() {\n\tlocal -i retval cursor_loc\n\n\t# Save the contents of the buffer so we can restore later if needed\n\tlocal original_buffer=\"$BUFFER\"\n\n\t# Temporarily accept the suggestion.\n\tBUFFER=\"$BUFFER$POSTDISPLAY\"\n\n\t# Original widget moves the cursor\n\t_zsh_autosuggest_invoke_original_widget $@\n\tretval=$?\n\n\t# Normalize cursor location across vi/emacs modes\n\tcursor_loc=$CURSOR\n\tif [[ \"$KEYMAP\" = \"vicmd\" ]]; then\n\t\tcursor_loc=$((cursor_loc + 1))\n\tfi\n\n\t# If we've moved past the end of the original buffer\n\tif (( $cursor_loc > $#original_buffer )); then\n\t\t# Set POSTDISPLAY to text right of the cursor\n\t\tPOSTDISPLAY=\"${BUFFER[$(($cursor_loc + 1)),$#BUFFER]}\"\n\n\t\t# Clip the buffer at the cursor\n\t\tBUFFER=\"${BUFFER[1,$cursor_loc]}\"\n\telse\n\t\t# Restore the original buffer\n\t\tBUFFER=\"$original_buffer\"\n\tfi\n\n\treturn $retval\n}\n\n() {\n\ttypeset -ga _ZSH_AUTOSUGGEST_BUILTIN_ACTIONS\n\n\t_ZSH_AUTOSUGGEST_BUILTIN_ACTIONS=(\n\t\tclear\n\t\tfetch\n\t\tsuggest\n\t\taccept\n\t\texecute\n\t\tenable\n\t\tdisable\n\t\ttoggle\n\t)\n\n\tlocal action\n\tfor action in $_ZSH_AUTOSUGGEST_BUILTIN_ACTIONS modify partial_accept; do\n\t\teval \"_zsh_autosuggest_widget_$action() {\n\t\t\tlocal -i retval\n\n\t\t\t_zsh_autosuggest_highlight_reset\n\n\t\t\t_zsh_autosuggest_$action \\$@\n\t\t\tretval=\\$?\n\n\t\t\t_zsh_autosuggest_highlight_apply\n\n\t\t\tzle -R\n\n\t\t\treturn \\$retval\n\t\t}\"\n\tdone\n\n\tfor action in $_ZSH_AUTOSUGGEST_BUILTIN_ACTIONS; do\n\t\tzle -N autosuggest-$action _zsh_autosuggest_widget_$action\n\tdone\n}\n\n#--------------------------------------------------------------------#\n# Completion Suggestion Strategy                                     #\n#--------------------------------------------------------------------#\n# Fetches a suggestion from the completion engine\n#\n\n_zsh_autosuggest_capture_postcompletion() {\n\t# Always insert the first completion into the buffer\n\tcompstate[insert]=1\n\n\t# Don't list completions\n\tunset 'compstate[list]'\n}\n\n_zsh_autosuggest_capture_completion_widget() {\n\t# Add a post-completion hook to be called after all completions have been\n\t# gathered. The hook can modify compstate to affect what is done with the\n\t# gathered completions.\n\tlocal -a +h comppostfuncs\n\tcomppostfuncs=(_zsh_autosuggest_capture_postcompletion)\n\n\t# Only capture completions at the end of the buffer\n\tCURSOR=$#BUFFER\n\n\t# Run the original widget wrapping `.complete-word` so we don't\n\t# recursively try to fetch suggestions, since our pty is forked\n\t# after autosuggestions is initialized.\n\tzle -- ${(k)widgets[(r)completion:.complete-word:_main_complete]}\n\n\tif is-at-least 5.0.3; then\n\t\t# Don't do any cr/lf transformations. We need to do this immediately before\n\t\t# output because if we do it in setup, onlcr will be re-enabled when we enter\n\t\t# vared in the async code path. There is a bug in zpty module in older versions\n\t\t# where the tty is not properly attached to the pty slave, resulting in stty\n\t\t# getting stopped with a SIGTTOU. See zsh-workers thread 31660 and upstream\n\t\t# commit f75904a38\n\t\tstty -onlcr -ocrnl -F /dev/tty\n\tfi\n\n\t# The completion has been added, print the buffer as the suggestion\n\techo -nE - $'\\0'$BUFFER$'\\0'\n}\n\nzle -N autosuggest-capture-completion _zsh_autosuggest_capture_completion_widget\n\n_zsh_autosuggest_capture_setup() {\n\t# There is a bug in zpty module in older zsh versions by which a\n\t# zpty that exits will kill all zpty processes that were forked\n\t# before it. Here we set up a zsh exit hook to SIGKILL the zpty\n\t# process immediately, before it has a chance to kill any other\n\t# zpty processes.\n\tif ! is-at-least 5.4; then\n\t\tzshexit() {\n\t\t\t# The zsh builtin `kill` fails sometimes in older versions\n\t\t\t# https://unix.stackexchange.com/a/477647/156673\n\t\t\tkill -KILL $$ 2>&- || command kill -KILL $$\n\n\t\t\t# Block for long enough for the signal to come through\n\t\t\tsleep 1\n\t\t}\n\tfi\n\n\t# Try to avoid any suggestions that wouldn't match the prefix\n\tzstyle ':completion:*' matcher-list ''\n\tzstyle ':completion:*' path-completion false\n\tzstyle ':completion:*' max-errors 0 not-numeric\n\n\tbindkey '^I' autosuggest-capture-completion\n}\n\n_zsh_autosuggest_capture_completion_sync() {\n\t_zsh_autosuggest_capture_setup\n\n\tzle autosuggest-capture-completion\n}\n\n_zsh_autosuggest_capture_completion_async() {\n\t_zsh_autosuggest_capture_setup\n\n\tzmodload zsh/parameter 2>/dev/null || return # For `$functions`\n\n\t# Make vared completion work as if for a normal command line\n\t# https://stackoverflow.com/a/7057118/154703\n\tautoload +X _complete\n\tfunctions[_original_complete]=$functions[_complete]\n\tfunction _complete() {\n\t\tunset 'compstate[vared]'\n\t\t_original_complete \"$@\"\n\t}\n\n\t# Open zle with buffer set so we can capture completions for it\n\tvared 1\n}\n\n_zsh_autosuggest_strategy_completion() {\n\t# Reset options to defaults and enable LOCAL_OPTIONS\n\temulate -L zsh\n\n\t# Enable extended glob for completion ignore pattern\n\tsetopt EXTENDED_GLOB\n\n\ttypeset -g suggestion\n\tlocal line REPLY\n\n\t# Exit if we don't have completions\n\twhence compdef >/dev/null || return\n\n\t# Exit if we don't have zpty\n\tzmodload zsh/zpty 2>/dev/null || return\n\n\t# Exit if our search string matches the ignore pattern\n\t[[ -n \"$ZSH_AUTOSUGGEST_COMPLETION_IGNORE\" ]] && [[ \"$1\" == $~ZSH_AUTOSUGGEST_COMPLETION_IGNORE ]] && return\n\n\t# Zle will be inactive if we are in async mode\n\tif zle; then\n\t\tzpty $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME _zsh_autosuggest_capture_completion_sync\n\telse\n\t\tzpty $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME _zsh_autosuggest_capture_completion_async \"\\$1\"\n\t\tzpty -w $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME $'\\t'\n\tfi\n\n\t{\n\t\t# The completion result is surrounded by null bytes, so read the\n\t\t# content between the first two null bytes.\n\t\tzpty -r $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME line '*'$'\\0''*'$'\\0'\n\n\t\t# Extract the suggestion from between the null bytes.  On older\n\t\t# versions of zsh (older than 5.3), we sometimes get extra bytes after\n\t\t# the second null byte, so trim those off the end.\n\t\t# See http://www.zsh.org/mla/workers/2015/msg03290.html\n\t\tsuggestion=\"${${(@0)line}[2]}\"\n\t} always {\n\t\t# Destroy the pty\n\t\tzpty -d $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME\n\t}\n}\n\n#--------------------------------------------------------------------#\n# History Suggestion Strategy                                        #\n#--------------------------------------------------------------------#\n# Suggests the most recent history item that matches the given\n# prefix.\n#\n\n_zsh_autosuggest_strategy_history() {\n\t# Reset options to defaults and enable LOCAL_OPTIONS\n\temulate -L zsh\n\n\t# Enable globbing flags so that we can use (#m) and (x~y) glob operator\n\tsetopt EXTENDED_GLOB\n\n\t# Escape backslashes and all of the glob operators so we can use\n\t# this string as a pattern to search the $history associative array.\n\t# - (#m) globbing flag enables setting references for match data\n\t# TODO: Use (b) flag when we can drop support for zsh older than v5.0.8\n\tlocal prefix=\"${1//(#m)[\\\\*?[\\]<>()|^~#]/\\\\$MATCH}\"\n\n\t# Get the history items that match the prefix, excluding those that match\n\t# the ignore pattern\n\tlocal pattern=\"$prefix*\"\n\tif [[ -n $ZSH_AUTOSUGGEST_HISTORY_IGNORE ]]; then\n\t\tpattern=\"($pattern)~($ZSH_AUTOSUGGEST_HISTORY_IGNORE)\"\n\tfi\n\n\t# Give the first history item matching the pattern as the suggestion\n\t# - (r) subscript flag makes the pattern match on values\n\ttypeset -g suggestion=\"${history[(r)$pattern]}\"\n}\n\n#--------------------------------------------------------------------#\n# Match Previous Command Suggestion Strategy                         #\n#--------------------------------------------------------------------#\n# Suggests the most recent history item that matches the given\n# prefix and whose preceding history item also matches the most\n# recently executed command.\n#\n# For example, suppose your history has the following entries:\n#   - pwd\n#   - ls foo\n#   - ls bar\n#   - pwd\n#\n# Given the history list above, when you type 'ls', the suggestion\n# will be 'ls foo' rather than 'ls bar' because your most recently\n# executed command (pwd) was previously followed by 'ls foo'.\n#\n# Note that this strategy won't work as expected with ZSH options that don't\n# preserve the history order such as `HIST_IGNORE_ALL_DUPS` or\n# `HIST_EXPIRE_DUPS_FIRST`.\n\n_zsh_autosuggest_strategy_match_prev_cmd() {\n\t# Reset options to defaults and enable LOCAL_OPTIONS\n\temulate -L zsh\n\n\t# Enable globbing flags so that we can use (#m) and (x~y) glob operator\n\tsetopt EXTENDED_GLOB\n\n\t# TODO: Use (b) flag when we can drop support for zsh older than v5.0.8\n\tlocal prefix=\"${1//(#m)[\\\\*?[\\]<>()|^~#]/\\\\$MATCH}\"\n\n\t# Get the history items that match the prefix, excluding those that match\n\t# the ignore pattern\n\tlocal pattern=\"$prefix*\"\n\tif [[ -n $ZSH_AUTOSUGGEST_HISTORY_IGNORE ]]; then\n\t\tpattern=\"($pattern)~($ZSH_AUTOSUGGEST_HISTORY_IGNORE)\"\n\tfi\n\n\t# Get all history event numbers that correspond to history\n\t# entries that match the pattern\n\tlocal history_match_keys\n\thistory_match_keys=(${(k)history[(R)$~pattern]})\n\n\t# By default we use the first history number (most recent history entry)\n\tlocal histkey=\"${history_match_keys[1]}\"\n\n\t# Get the previously executed command\n\tlocal prev_cmd=\"$(_zsh_autosuggest_escape_command \"${history[$((HISTCMD-1))]}\")\"\n\n\t# Iterate up to the first 200 history event numbers that match $prefix\n\tfor key in \"${(@)history_match_keys[1,200]}\"; do\n\t\t# Stop if we ran out of history\n\t\t[[ $key -gt 1 ]] || break\n\n\t\t# See if the history entry preceding the suggestion matches the\n\t\t# previous command, and use it if it does\n\t\tif [[ \"${history[$((key - 1))]}\" == \"$prev_cmd\" ]]; then\n\t\t\thistkey=\"$key\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\t# Give back the matched history entry\n\ttypeset -g suggestion=\"$history[$histkey]\"\n}\n\n#--------------------------------------------------------------------#\n# Fetch Suggestion                                                   #\n#--------------------------------------------------------------------#\n# Loops through all specified strategies and returns a suggestion\n# from the first strategy to provide one.\n#\n\n_zsh_autosuggest_fetch_suggestion() {\n\ttypeset -g suggestion\n\tlocal -a strategies\n\tlocal strategy\n\n\t# Ensure we are working with an array\n\tstrategies=(${=ZSH_AUTOSUGGEST_STRATEGY})\n\n\tfor strategy in $strategies; do\n\t\t# Try to get a suggestion from this strategy\n\t\t_zsh_autosuggest_strategy_$strategy \"$1\"\n\n\t\t# Ensure the suggestion matches the prefix\n\t\t[[ \"$suggestion\" != \"$1\"* ]] && unset suggestion\n\n\t\t# Break once we've found a valid suggestion\n\t\t[[ -n \"$suggestion\" ]] && break\n\tdone\n}\n\n#--------------------------------------------------------------------#\n# Async                                                              #\n#--------------------------------------------------------------------#\n\n_zsh_autosuggest_async_request() {\n\tzmodload zsh/system 2>/dev/null # For `$sysparams`\n\n\ttypeset -g _ZSH_AUTOSUGGEST_ASYNC_FD _ZSH_AUTOSUGGEST_CHILD_PID\n\n\t# If we've got a pending request, cancel it\n\tif [[ -n \"$_ZSH_AUTOSUGGEST_ASYNC_FD\" ]] && { true <&$_ZSH_AUTOSUGGEST_ASYNC_FD } 2>/dev/null; then\n\t\t# Close the file descriptor and remove the handler\n\t\tbuiltin exec {_ZSH_AUTOSUGGEST_ASYNC_FD}<&-\n\t\tzle -F $_ZSH_AUTOSUGGEST_ASYNC_FD\n\n\t\t# We won't know the pid unless the user has zsh/system module installed\n\t\tif [[ -n \"$_ZSH_AUTOSUGGEST_CHILD_PID\" ]]; then\n\t\t\t# Zsh will make a new process group for the child process only if job\n\t\t\t# control is enabled (MONITOR option)\n\t\t\tif [[ -o MONITOR ]]; then\n\t\t\t\t# Send the signal to the process group to kill any processes that may\n\t\t\t\t# have been forked by the suggestion strategy\n\t\t\t\tkill -TERM -$_ZSH_AUTOSUGGEST_CHILD_PID 2>/dev/null\n\t\t\telse\n\t\t\t\t# Kill just the child process since it wasn't placed in a new process\n\t\t\t\t# group. If the suggestion strategy forked any child processes they may\n\t\t\t\t# be orphaned and left behind.\n\t\t\t\tkill -TERM $_ZSH_AUTOSUGGEST_CHILD_PID 2>/dev/null\n\t\t\tfi\n\t\tfi\n\tfi\n\n\t# Fork a process to fetch a suggestion and open a pipe to read from it\n\tbuiltin exec {_ZSH_AUTOSUGGEST_ASYNC_FD}< <(\n\t\t# Tell parent process our pid\n\t\techo $sysparams[pid]\n\n\t\t# Fetch and print the suggestion\n\t\tlocal suggestion\n\t\t_zsh_autosuggest_fetch_suggestion \"$1\"\n\t\techo -nE \"$suggestion\"\n\t)\n\n\t# There's a weird bug here where ^C stops working unless we force a fork\n\t# See https://github.com/zsh-users/zsh-autosuggestions/issues/364\n\tautoload -Uz is-at-least\n\tis-at-least 5.8 || command true\n\n\t# Read the pid from the child process\n\tread _ZSH_AUTOSUGGEST_CHILD_PID <&$_ZSH_AUTOSUGGEST_ASYNC_FD\n\n\t# When the fd is readable, call the response handler\n\tzle -F \"$_ZSH_AUTOSUGGEST_ASYNC_FD\" _zsh_autosuggest_async_response\n}\n\n# Called when new data is ready to be read from the pipe\n# First arg will be fd ready for reading\n# Second arg will be passed in case of error\n_zsh_autosuggest_async_response() {\n\temulate -L zsh\n\n\tlocal suggestion\n\n\tif [[ -z \"$2\" || \"$2\" == \"hup\" ]]; then\n\t\t# Read everything from the fd and give it as a suggestion\n\t\tIFS='' read -rd '' -u $1 suggestion\n\t\tzle autosuggest-suggest -- \"$suggestion\"\n\n\t\t# Close the fd\n\t\tbuiltin exec {1}<&-\n\tfi\n\n\t# Always remove the handler\n\tzle -F \"$1\"\n\t_ZSH_AUTOSUGGEST_ASYNC_FD=\n}\n\n#--------------------------------------------------------------------#\n# Start                                                              #\n#--------------------------------------------------------------------#\n\n# Start the autosuggestion widgets\n_zsh_autosuggest_start() {\n\t# By default we re-bind widgets on every precmd to ensure we wrap other\n\t# wrappers. Specifically, highlighting breaks if our widgets are wrapped by\n\t# zsh-syntax-highlighting widgets. This also allows modifications to the\n\t# widget list variables to take effect on the next precmd. However this has\n\t# a decent performance hit, so users can set ZSH_AUTOSUGGEST_MANUAL_REBIND\n\t# to disable the automatic re-binding.\n\tif (( ${+ZSH_AUTOSUGGEST_MANUAL_REBIND} )); then\n\t\tadd-zsh-hook -d precmd _zsh_autosuggest_start\n\tfi\n\n\t_zsh_autosuggest_bind_widgets\n}\n\n# Mark for auto-loading the functions that we use\nautoload -Uz add-zsh-hook is-at-least\n\n# Automatically enable asynchronous mode in newer versions of zsh. Disable for\n# older versions because there is a bug when using async mode where ^C does not\n# work immediately after fetching a suggestion.\n# See https://github.com/zsh-users/zsh-autosuggestions/issues/364\nif is-at-least 5.0.8; then\n\ttypeset -g ZSH_AUTOSUGGEST_USE_ASYNC=\nfi\n\n# Start the autosuggestion widgets on the next precmd\nadd-zsh-hook precmd _zsh_autosuggest_start\n"
        }
      ]
    }
  ]
}