{
  "metadata": {
    "timestamp": 1736709054091,
    "page": 165,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/tarpc",
      "stars": 3336,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.05078125,
          "content": "target\nCargo.lock\n.cargo\n*.swp\n*.bk\ntarpc.iml\n.idea\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.41796875,
          "content": "Want to contribute? Great! First, read this page (including the small print at the end).\n\n### Before you contribute\nBefore we can use your code, you must sign the\n[Google Individual Contributor License Agreement]\n(https://cla.developers.google.com/about/google-individual)\n(CLA), which you can do online. The CLA is necessary mainly because you own the\ncopyright to your changes, even after your contribution becomes part of our\ncodebase, so we need your permission to use and distribute your code. We also\nneed to be sure of various other thingsâ€”for instance that you'll tell us if you\nknow that your code infringes on other people's patents. You don't have to sign\nthe CLA until after you've submitted your code for review and a member has\napproved it, but you must do it before we can put your code into our codebase.\nBefore you start working on a larger contribution, you should get in touch with\nus first through the issue tracker with your idea so that we can help out and\npossibly guide you. Coordinating up front makes it much easier to avoid\nfrustration later on.\n\n### Code reviews\nAll submissions, including submissions by project members, require review. We\nuse Github pull requests for this purpose.\n\n### The small print\nContributions made by corporations are covered by a different agreement than\nthe one above, the\n[Software Grant and Corporate Contributor License Agreement]\n(https://cla.developers.google.com/about/google-corporate).\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.1337890625,
          "content": "[workspace]\nresolver = \"2\"\n\nmembers = [\n    \"example-service\",\n    \"tarpc\",\n    \"plugins\",\n]\n\n[profile.dev]\nsplit-debuginfo = \"unpacked\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0693359375,
          "content": "The MIT License (MIT)\n\nCopyright 2016 Google Inc. All Rights Reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.88671875,
          "content": "[![Crates.io][crates-badge]][crates-url]\n[![MIT licensed][mit-badge]][mit-url]\n[![Build status][gh-actions-badge]][gh-actions-url]\n[![Discord chat][discord-badge]][discord-url]\n\n[crates-badge]: https://img.shields.io/crates/v/tarpc.svg\n[crates-url]: https://crates.io/crates/tarpc\n[mit-badge]: https://img.shields.io/badge/license-MIT-blue.svg\n[mit-url]: LICENSE\n[gh-actions-badge]: https://github.com/google/tarpc/workflows/Continuous%20Integration/badge.svg\n[gh-actions-url]: https://github.com/google/tarpc/actions?query=workflow%3A%22Continuous+Integration%22\n[discord-badge]: https://img.shields.io/discord/647529123996237854.svg?logo=discord&style=flat-square\n[discord-url]: https://discord.gg/gXwpdSt\n\n# tarpc\n\n<!-- cargo-sync-readme start -->\n\n*Disclaimer*: This is not an official Google product.\n\ntarpc is an RPC framework for rust with a focus on ease of use. Defining a\nservice can be done in just a few lines of code, and most of the boilerplate of\nwriting a server is taken care of for you.\n\n[Documentation](https://docs.rs/crate/tarpc/)\n\n## What is an RPC framework?\n\"RPC\" stands for \"Remote Procedure Call,\" a function call where the work of\nproducing the return value is being done somewhere else. When an rpc function is\ninvoked, behind the scenes the function contacts some other process somewhere\nand asks them to evaluate the function instead. The original function then\nreturns the value produced by the other process.\n\nRPC frameworks are a fundamental building block of most microservices-oriented\narchitectures. Two well-known ones are [gRPC](http://www.grpc.io) and\n[Cap'n Proto](https://capnproto.org/).\n\ntarpc differentiates itself from other RPC frameworks by defining the schema in code,\nrather than in a separate language such as .proto. This means there's no separate compilation\nprocess, and no context switching between different languages.\n\nSome other features of tarpc:\n- Pluggable transport: any type implementing `Stream<Item = Request> + Sink<Response>` can be\n  used as a transport to connect the client and server.\n- `Send + 'static` optional: if the transport doesn't require it, neither does tarpc!\n- Cascading cancellation: dropping a request will send a cancellation message to the server.\n  The server will cease any unfinished work on the request, subsequently cancelling any of its\n  own requests, repeating for the entire chain of transitive dependencies.\n- Configurable deadlines and deadline propagation: request deadlines default to 10s if\n  unspecified. The server will automatically cease work when the deadline has passed. Any\n  requests sent by the server that use the request context will propagate the request deadline.\n  For example, if a server is handling a request with a 10s deadline, does 2s of work, then\n  sends a request to another server, that server will see an 8s deadline.\n- Distributed tracing: tarpc is instrumented with\n  [tracing](https://github.com/tokio-rs/tracing) primitives extended with\n  [OpenTelemetry](https://opentelemetry.io/) traces. Using a compatible tracing subscriber like\n  [Jaeger](https://github.com/open-telemetry/opentelemetry-rust/tree/main/opentelemetry-jaeger),\n  each RPC can be traced through the client, server, and other dependencies downstream of the\n  server. Even for applications not connected to a distributed tracing collector, the\n  instrumentation can also be ingested by regular loggers like\n  [env_logger](https://github.com/env-logger-rs/env_logger/).\n- Serde serialization: enabling the `serde1` Cargo feature will make service requests and\n  responses `Serialize + Deserialize`. It's entirely optional, though: in-memory transports can\n  be used, as well, so the price of serialization doesn't have to be paid when it's not needed.\n\n## Usage\nAdd to your `Cargo.toml` dependencies:\n\n```toml\ntarpc = \"0.35\"\n```\n\nThe `tarpc::service` attribute expands to a collection of items that form an rpc service.\nThese generated types make it easy and ergonomic to write servers with less boilerplate.\nSimply implement the generated service trait, and you're off to the races!\n\n## Example\n\nThis example uses [tokio](https://tokio.rs), so add the following dependencies to\nyour `Cargo.toml`:\n\n```toml\nanyhow = \"1.0\"\nfutures = \"0.3\"\ntarpc = { version = \"0.35\", features = [\"tokio1\"] }\ntokio = { version = \"1.0\", features = [\"rt-multi-thread\", \"macros\"] }\n```\n\nIn the following example, we use an in-process channel for communication between\nclient and server. In real code, you will likely communicate over the network.\nFor a more real-world example, see [example-service](example-service).\n\nFirst, let's set up the dependencies and service definition.\n\n```rust\nuse futures::prelude::*;\nuse tarpc::{\n    client, context,\n    server::{self, Channel},\n};\n\n// This is the service definition. It looks a lot like a trait definition.\n// It defines one RPC, hello, which takes one arg, name, and returns a String.\n#[tarpc::service]\ntrait World {\n    /// Returns a greeting for name.\n    async fn hello(name: String) -> String;\n}\n```\n\nThis service definition generates a trait called `World`. Next we need to\nimplement it for our Server struct.\n\n```rust\n// This is the type that implements the generated World trait. It is the business logic\n// and is used to start the server.\n#[derive(Clone)]\nstruct HelloServer;\n\nimpl World for HelloServer {\n    async fn hello(self, _: context::Context, name: String) -> String {\n        format!(\"Hello, {name}!\")\n    }\n}\n```\n\nLastly let's write our `main` that will start the server. While this example uses an\n[in-process channel](transport::channel), tarpc also ships a generic [`serde_transport`]\nbehind the `serde-transport` feature, with additional [TCP](serde_transport::tcp) functionality\navailable behind the `tcp` feature.\n\n```rust\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let (client_transport, server_transport) = tarpc::transport::channel::unbounded();\n\n    let server = server::BaseChannel::with_defaults(server_transport);\n    tokio::spawn(\n        server.execute(HelloServer.serve())\n            // Handle all requests concurrently.\n            .for_each(|response| async move {\n                tokio::spawn(response);\n            }));\n\n    // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`\n    // that takes a config and any Transport as input.\n    let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();\n\n    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same\n    // args as defined, with the addition of a Context, which is always the first arg. The Context\n    // specifies a deadline and trace information which can be helpful in debugging requests.\n    let hello = client.hello(context::current(), \"Stim\".to_string()).await?;\n\n    println!(\"{hello}\");\n\n    Ok(())\n}\n```\n\n## Service Documentation\n\nUse `cargo doc` as you normally would to see the documentation created for all\nitems expanded by a `service!` invocation.\n\n<!-- cargo-sync-readme end -->\n\nLicense: MIT\n"
        },
        {
          "name": "RELEASES.md",
          "type": "blob",
          "size": 19.8857421875,
          "content": "## tarpc-plugins 0.13.1 (2024-01-21)\n\n### Fixes\n\nProc macros are more hygienic, so that there will be less collisions in symbol names between\ngenerated and user code. See https://github.com/google/tarpc/pull/420 for an example of the problems\nthat will (hopefully) no longer occur.\n\n## 0.34.0 (2023-12-29)\n\n### Breaking Changes\n\n- `#[tarpc::server]` is no more! Service traits now use async fns.\n- `Channel::execute` no longer spawns request handlers. Async-fn-in-traits makes it impossible to\n  add a Send bound to the future returned by `Serve::serve`. Instead, `Channel::execute` returns a\n  stream of futures, where each future is a request handler. To achieve the former behavior:\n  ```rust\n  channel.execute(server.serve())\n         .for_each(|rpc| { tokio::spawn(rpc); })\n  ```\n\n### New Features\n\n- Request hooks are added to the serve trait, so that it's easy to hook in cross-cutting\n  functionality like throttling, authorization, etc.\n- The Client trait is back! This makes it possible to hook in generic client functionality like load\n  balancing, retries, etc.\n\n## 0.33.0 (2023-04-01)\n\n### Breaking Changes\n\nOpentelemetry dependency version increased to 0.18.\n\n## 0.32.0 (2023-03-24)\n\n### Breaking Changes\n\n- As part of a fix to return more channel errors in RPC results, a few error types have changed:\n\n  0. `client::RpcError::Disconnected` was split into the following errors:\n    - Shutdown: the client was shutdown, either intentionally or due to an error. If due to an\n      error, pending RPCs should see the more specific errors below.\n    - Send: an RPC message failed to send over the transport. Only the RPC that failed to be sent\n      will see this error.\n    - Receive: a fatal error occurred while receiving from the transport. All in-flight RPCs will\n      receive this error.\n  0. `client::ChannelError` and `server::ChannelError` are unified in `tarpc::ChannelError`.\n     Previously, server transport errors would not indicate during which activity the transport\n     error occurred. Now, just like the client already was, it will be specific: reading, readying,\n     sending, flushing, or closing.\n\n## 0.31.0 (2022-11-03)\n\n### New Features\n\nThis release adds Unix Domain Sockets to the `serde_transport` module.\nTo use it, enable the \"unix\" feature. See the docs for more information.\n\n## 0.30.0 (2022-08-12)\n\n### Breaking Changes\n\n- Some types that impl Future are now annotated with `#[must_use]`. Code that previously created\n  these types but did not use them will now receive a warning. Code that disallows warnings will\n  receive a compilation error.\n\n### Fixes\n\n- Servers will more reliably clean up request state for requests with long deadlines when response\nprocessing is aborted without sending a response.\n\n### Other Changes\n\n- `TrackedRequest` now contains a response guard that can be used to ensure state cleanup for\n  aborted requests. (This was already handled automatically by `InFlightRequests`).\n- When the feature serde-transport is enabled, the crate tokio_serde is now re-exported.\n\n## 0.29.0 (2022-05-26)\n\n### Breaking Changes\n\n`Context.deadline` is now serialized as a Duration. This prevents clock skew from affecting deadline\nbehavior. For more details see https://github.com/google/tarpc/pull/367 and its [related\nissue](https://github.com/google/tarpc/issues/366).\n\n## 0.28.0 (2022-04-06)\n\n### Breaking Changes\n\n- The minimum supported Rust version has increased to 1.58.0.\n- The version of opentelemetry depended on by tarpc has increased to 0.17.0.\n\n## 0.27.2 (2021-10-08)\n\n### Fixes\n\nClients will now close their transport before dropping it. An attempt at a clean shutdown can help\nthe server drop its connections more quickly.\n\n## 0.27.1 (2021-09-22)\n\n### Breaking Changes\n\n#### RPC error type is changing\n\nRPC return types are changing from `Result<Response, io::Error>` to `Result<Response,\ntarpc::client::RpcError>`.\n\nBecaue tarpc is a library, not an application, it should strive to\nuse structured errors in its API so that users have maximal flexibility\nin how they handle errors. io::Error makes that hard, because it is a\nkitchen-sink error type.\n\nRPCs in particular only have 3 classes of errors:\n\n- The connection breaks.\n- The request expires.\n- The server decides not to process the request.\n\nRPC responses can also contain application-specific errors, but from the\nperspective of the RPC library, those are opaque to the framework, classified\nas successful responsees.\n\n### Open Telemetry\n\nThe Opentelemetry dependency is updated to version 0.16.x.\n\n## 0.27.0 (2021-09-22)\n\nThis version was yanked due to tarpc-plugins version mismatches.\n\n\n## 0.26.0 (2021-04-14)\n\n### New Features\n\n#### Tracing\n\ntarpc is now instrumented with tracing primitives extended with\nOpenTelemetry traces. Using a compatible tracing-opentelemetry\nsubscriber like Jaeger, each RPC can be traced through the client,\nserver, amd other dependencies downstream of the server. Even for\napplications not connected to a distributed tracing collector, the\ninstrumentation can also be ingested by regular loggers like env_logger.\n\n### Breaking Changes\n\n#### Logging\n\nLogged events are now structured using tracing. For applications using a\nlogger and not a tracing subscriber, these logs may look different or\ncontain information in a less consumable manner. The easiest solution is\nto add a tracing subscriber that logs to stdout, such as\ntracing_subscriber::fmt.\n\n####  Context\n\n- Context no longer has parent_span, which was actually never needed,\n  because the context sent in an RPC is inherently the parent context.\n  For purposes of distributed tracing, the client side of the RPC has all\n  necessary information to link the span to its parent; the server side\n  need do nothing more than export the (trace ID, span ID) tuple.\n- Context has a new field, SamplingDecision, which has two variants,\n  Sampled and Unsampled. This field can be used by downstream systems to\n  determine whether a trace needs to be exported. If the parent span is\n  sampled, the expectation is that all child spans be exported, as well;\n  to do otherwise could result in lossy traces being exported. Note that\n  if an Openetelemetry tracing subscriber is not installed, the fallback\n  context will still be used, but the Context's sampling decision will\n  always be inherited by the parent Context's sampling decision.\n- Context::scope has been removed. Context propagation is now done via\n  tracing's task-local spans. Spans can be propagated across tasks via\n  Span::in_scope. When a service receives a request, it attaches an\n  Opentelemetry context to the local Span created before request handling,\n  and this context contains the request deadline. This span-local deadline\n  is retrieved by Context::current, but it cannot be modified so that\n  future Context::current calls contain a different deadline. However, the\n  deadline in the context passed into an RPC call will override it, so\n  users can retrieve the current context and then modify the deadline\n  field, as has been historically possible.\n- Context propgation precedence changes: when an RPC is initiated, the\n  current Span's Opentelemetry context takes precedence over the trace\n  context passed into the RPC method. If there is no current Span, then\n  the trace context argument is used as it has been historically. Note\n  that Opentelemetry context propagation requires an Opentelemetry\n  tracing subscriber to be installed.\n\n#### Server\n\n- The server::Channel trait now has an additional required associated\n  type and method which returns the underlying transport. This makes it\n  more ergonomic for users to retrieve transport-specific information,\n  like IP Address. BaseChannel implements Channel::transport by returning\n  the underlying transport, and channel decorators like Throttler just\n  delegate to the Channel::transport method of the wrapped channel.\n\n#### Client\n\n- NewClient::spawn no longer returns a result, as spawn can't fail.\n\n### References\n\n1. https://github.com/tokio-rs/tracing\n2. https://opentelemetry.io\n3. https://github.com/open-telemetry/opentelemetry-rust/tree/main/opentelemetry-jaeger\n4. https://github.com/env-logger-rs/env_logger\n\n## 0.25.0 (2021-03-10)\n\n### Breaking Changes\n\n#### Major server module refactoring\n\n1. Renames\n\nSome of the items in this module were renamed to be less generic:\n\n- Handler => Incoming\n- ClientHandler => Requests\n- ResponseHandler => InFlightRequest\n- Channel::{respond_with => requests}\n\nIn the case of Handler: handler of *what*? Now it's a bit clearer that this is a stream of Channels\n(aka *incoming* connections).\n\nSimilarly, ClientHandler was a stream of requests over a single connection. Hopefully Requests\nbetter reflects that.\n\nResponseHandler was renamed InFlightRequest because it no longer contains the serving function.\nInstead, it is just the request, plus the response channel and an abort hook. As a result of this,\nChannel::respond_with underwent a big change: it used to take the serving function and return a\nClientHandler; now it has been renamed Channel::requests and does not take any args.\n\n2. Execute methods\n\nAll methods thats actually result in responses being generated have been consolidated into methods\nnamed `execute`:\n\n- InFlightRequest::execute returns a future that completes when a response has been generated and\n  sent to the server Channel.\n- Requests::execute automatically spawns response handlers for all requests over a single channel.\n- Channel::execute is a convenience for `channel.requests().execute()`.\n- Incoming::execute automatically spawns response handlers for all requests over all channels.\n\n3. Removal of Server.\n\nserver::Server was removed, as it provided no value over the Incoming/Channel abstractions.\nAdditionally, server::new was removed, since it just returned a Server.\n\n#### Client RPC methods now take &self\n\nThis required the breaking change of removing the Client trait. The intent of the Client trait was\nto facilitate the decorator pattern by allowing users to create their own Clients that added\nbehavior on top of the base client. Unfortunately, this trait had become a maintenance burden,\nconsistently causing issues with lifetimes and the lack of generic associated types. Specifically,\nit meant that Client impls could not use async fns, which is no longer tenable today, with channel\nlibraries moving to async fns.\n\n#### Servers no longer send deadline-exceed responses.\n\nThe deadline-exceeded response was largely redundant, because the client\nshouldn't normally be waiting for such a response, anyway -- the normal\nclient will automatically remove the in-flight request when it reaches\nthe deadline.\n\nThis also allows for internalizing the expiration+cleanup logic entirely\nwithin BaseChannel, without having it leak into the Channel trait and\nrequiring action taken by the Requests struct.\n\n#### Clients no longer send cancel messages when the request deadline is exceeded.\n\nThe server already knows when the request deadline was exceeded, so the client didn't need to inform\nit.\n\n### Fixes\n\n- When a channel is dropped, all in-flight requests for that channel are now aborted.\n\n## 0.24.1 (2020-12-28)\n\n### Breaking Changes\n\nUpgrades tokio to 1.0.\n\n## 0.24.0 (2020-12-28)\n\nThis release was yanked.\n\n## 0.23.0 (2020-10-19)\n\n### Breaking Changes\n\nUpgrades tokio to 0.3.\n\n## 0.22.0 (2020-08-02)\n\nThis release adds some flexibility and consistency to `serde_transport`, with one new feature and\none small breaking change.\n\n### New Features\n\n`serde_transport::tcp` now exposes framing configuration on `connect()` and `listen()`. This is\nuseful if, for instance, you want to send requests or responses that are larger than the maximum\npayload allowed by default:\n\n```rust\nlet mut transport = tarpc::serde_transport::tcp::connect(server_addr, Json::default);\ntransport.config_mut().max_frame_length(4294967296);\nlet mut client = MyClient::new(client::Config::default(), transport.await?).spawn()?;\n```\n\n### Breaking Changes\n\nThe codec argument to `serde_transport::tcp::connect` changed from a Codec to impl Fn() -> Codec,\nto be consistent with `serde_transport::tcp::listen`. While only one Codec is needed, more than one\nperson has been tripped up by the inconsistency between `connect` and `listen`. Unfortunately, the\ncompiler errors are not much help in this case, so it was decided to simply do the more intuitive\nthing so that the compiler doesn't need to step in in the first place.\n\n\n## 0.21.1 (2020-08-02)\n\n### New Features\n\n#### #[tarpc::server] diagnostics\n\nWhen a service impl uses #[tarpc::server], only `async fn`s are re-written. This can lead to\nconfusing compiler errors about missing associated types:\n\n```\nerror: not all trait items implemented, missing: `HelloFut`\n --> $DIR/tarpc_server_missing_async.rs:9:1\n  |\n9 | impl World for HelloServer {\n  | ^^^^\n```\n\nThe proc macro now provides better diagnostics for this case:\n\n```\nerror: not all trait items implemented, missing: `HelloFut`\n --> $DIR/tarpc_server_missing_async.rs:9:1\n  |\n9 | impl World for HelloServer {\n  | ^^^^\n\nerror: hint: `#[tarpc::server]` only rewrites async fns, and `fn hello` is not async\n  --> $DIR/tarpc_server_missing_async.rs:10:5\n   |\n10 |     fn hello(name: String) ->  String {\n   |     ^^\n```\n\n### Bug Fixes\n\n#### Fixed client hanging when server shuts down\n\nPreviously, clients would ignore when the read half of the transport was closed, continuing to\nwrite requests. This didn't make much sense, because without the ability to receive responses,\nclients have no way to know if requests were actually processed by the server. It basically just\nled to clients that would hang for a few seconds before shutting down. This has now been\ncorrected: clients will immediately shut down when the read-half of the transport is closed.\n\n#### More docs.rs documentation\n\nPreviously, docs.rs only documented items enabled by default, notably leaving out documentation\nfor tokio and serde features. This has now been corrected: docs.rs should have documentation\nfor all optional features.\n\n## 0.21.0 (2020-06-26)\n\n### New Features\n\nA new proc macro, `#[tarpc::server]` was added! This enables service impls to elide the boilerplate\nof specifying associated types for each RPC. With the ubiquity of async-await, most code won't have\nnameable futures and will just be boxing the return type anyway. This macro does that for you.\n\n### Breaking Changes\n\n- Enums had `_non_exhaustive` fields replaced with the #[non_exhaustive] attribute.\n\n### Bug Fixes\n\n- https://github.com/google/tarpc/issues/304\n\n  A race condition in code that limits number of connections per client caused occasional panics.\n\n- https://github.com/google/tarpc/pull/295\n\n  Made request timeouts account for time spent in the outbound buffer. Previously, a large outbound\n  queue would lead to requests not timing out correctly.\n\n## 0.20.0 (2019-12-11)\n\n### Breaking Changes\n\n1. tarpc has updated its tokio dependency to the latest 0.2 version.\n2. The tarpc crates have been unified into just `tarpc`, with new Cargo features to enable\n   functionality.\n   - The bincode-transport and json-transport crates are deprecated and superseded by\n     the `serde_transport` module, which unifies much of the logic present in both crates.\n\n## 0.13.0 (2018-10-16)\n\n### Breaking Changes\n\nVersion 0.13 marks a significant departure from previous versions of tarpc. The\nAPI has changed significantly. The tokio-proto crate has been torn out and\nreplaced with a homegrown rpc framework. Additionally, the crate has been\nmodularized, so that the tarpc crate itself contains only the macro code.\n\n### New Crates\n\n- crate rpc contains the core client/server request-response framework, as well as a transport trait.\n- crate bincode-transport implements a transport that works almost exactly as tarpc works today (not to say it's wire-compatible).\n- crate trace has some foundational types for tracing. This isn't really fleshed out yet, but it's useful for in-process log tracing, at least.\n\nAll crates are now at the top level. e.g. tarpc-plugins is now tarpc/plugins rather than tarpc/src/plugins. tarpc itself is now a *very* small code surface, as most functionality has been moved into the other more granular crates.\n\n### New Features\n- deadlines: all requests specify a deadline, and a server will stop processing a response when past its deadline.\n- client cancellation propagation: when a client drops a request, the client sends a message to the server informing it to cancel its response. This means cancellations can propagate across multiple server hops.\n- trace context stuff as mentioned above\n- more server configuration for total connection limits, per-connection request limits, etc.\n\n### Removals\n- no more shutdown handle.  I left it out for now because of time and not being sure what the right solution is.\n- all async now, no blocking stub or server interface. This helps with maintainability, and async/await makes async code much more usable. The service trait is thusly renamed Service, and the client is renamed Client.\n- no built-in transport. Tarpc is now transport agnostic (see bincode-transport for transitioning existing uses).\n- going along with the previous bullet, no preferred transport means no TLS support at this time. We could make a tls transport or make bincode-transport compatible with TLS.\n- a lot of examples were removed because I couldn't keep up with maintaining all of them. Hopefully the ones I kept are still illustrative.\n- no more plugins!\n\n## 0.10.0 (2018-04-08)\n\n### Breaking Changes\nFixed rustc breakage in tarpc-plugins. These changes require a recent version of rustc.\n\n## 0.10.0 (2018-03-26)\n\n### Breaking Changes\nUpdates bincode to version 1.0.\n\n## 0.9.0 (2017-09-17)\n\n### Breaking Changes\nUpdates tarpc to use tarpc-plugins 0.2.\n\n## 0.8.0 (2017-05-05)\n\n### Breaking Changes\nThis release updates tarpc to use serde 1.0.\nAs such, users must also update to use serde 1.0.\nThe serde 1.0 [release notes](https://github.com/serde-rs/serde/releases/tag/v1.0.0)\ndetail migration paths.\n\n## 0.7.3 (2017-04-26)\n\nThis release removes the `Sync` bound on RPC args for both sync and future\nclients. No breaking changes.\n\n## 0.7.2 (2017-04-22)\n\n### Breaking Changes\nThis release updates tarpc-plugins to work with rustc master. Thus, older\nversions of rustc are no longer supported. We chose a minor version bump\nbecause it is still source-compatible with existing code using tarpc.\n\n## 0.7.1 (2017-03-31)\n\nThis release was purely doc fixes. No breaking changes.\n\n## 0.7 (2017-03-31)\n\n### Breaking Changes\nThis release is a complete overhaul to build tarpc on top of the tokio stack.\nIt's safe to assume that everything broke with this release.\n\nTwo traits are now generated by the macro, `FutureService` and `SyncService`.\n`SyncService` is the successor to the original `Service` trait. It uses a configurable\nthread pool to serve requests. `FutureService`, as the name implies, uses futures\nto serve requests and is single-threaded by default.\n\nThe easiest way to upgrade from a 0.6 service impl is to `impl SyncService for MyService`.\nFor more complete information, see the readme and the examples directory.\n\n## 0.6 (2016-08-07)\n\n### Breaking Changes\n* Updated serde to 0.8. Requires dependents to update as well.\n\n## 0.5 (2016-04-24)\n\n### Breaking Changes\n0.5 adds support for arbitrary transports via the\n[`Transport`](tarpc/src/transport/mod.rs#L7) trait.\nOut of the box tarpc provides implementations for:\n\n* Tcp, for types `impl`ing `ToSocketAddrs`.\n* Unix sockets via the `UnixTransport` type.\n\nThis was a breaking change: `handler.local_addr()` was renamed\n`handler.dialer()`.\n\n## 0.4 (2016-04-02)\n\n### Breaking Changes\n* Updated to the latest version of serde, 0.7.0. Because tarpc exposes serde in\n  its API, this forces downstream code to update to the latest version of\n  serde, as well.\n\n## 0.3 (2016-02-20)\n\n### Breaking Changes\n* The timeout arg to `serve` was replaced with a `Config` struct, which\n  currently only contains one field, but will be expanded in the future\n  to allow configuring serialization protocol, and other things.\n* `serve` was changed to be a default method on the generated `Service` traits,\n  and it was renamed `spawn_with_config`. A second `default fn` was added:\n  `spawn`, which takes no `Config` arg.\n\n### Other Changes\n* Expanded items will no longer generate unused warnings.\n"
        },
        {
          "name": "example-service",
          "type": "tree",
          "content": null
        },
        {
          "name": "hooks",
          "type": "tree",
          "content": null
        },
        {
          "name": "plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "tarpc",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}