{
  "metadata": {
    "timestamp": 1736709130175,
    "page": 317,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pdeljanov/Symphonia",
      "stars": 2495,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6728515625,
          "content": "# Rust/Cargo\n/target\n**/*.rs.bk\nCargo.lock\n\n# Ghostwriter\n*.md.backup\n\n# Visual Studio Code\n*.code-workspace\n.vscode\n\n# Profiling data\nperf.data\nperf.data.old\n\n# Development Test Vectors\ntestvec/*/**/*.aac\ntestvec/*/**/*.flac\ntestvec/*/**/*.m4a\ntestvec/*/**/*.mp3\ntestvec/*/**/*.mp4\ntestvec/*/**/*.ogg\ntestvec/*/**/*.opus\ntestvec/*/**/*.wav\ntestvec/*/**/*.mov\n\n# Benchmarking Files\nbenchtest/*.aac\nbenchtest/*.flac\nbenchtest/*.m4a\nbenchtest/*.mp3\nbenchtest/*.mp4\nbenchtest/*.ogg\nbenchtest/*.opus\nbenchtest/*.wav\n\n# macOS\n.DS_Store\n.AppleDouble\n.LSOverride\n._*\n\n# Linux\n*~\n.directory\n\n# Windows\nThumbs.db\nThumbs.db:encryptable\nehthumbs.db\nehthumbs_vista.db\n*.stackdump\n[Dd]esktop.ini\n*.lnk\n"
        },
        {
          "name": "BENCHMARKS.md",
          "type": "blob",
          "size": 7.4677734375,
          "content": "# Benchmarks\n\n**Last Updated**: February 3, 2023\n\nThese benchmarks compare the single-thread[^1] decoding performance of Symphonia against FFmpeg with various audio files.\n\n*It is always a good idea to run your own benchmarks!*\n\n## Tools\n\n### Symphonia\n\nThe `symphonia-play` demo application is used in decode-only mode. In this mode, `symphonia-play` will decode the first audio track as fast as possible.\n\nSymphonia is built with `RUSTFLAGS=\"-C target-cpu=native\"`, SIMD optimizations enabled, and the latest Rust compiler (currently `1.67.0`).\n\n`symphonia-play` can be run in decode-only mode with the following command:\n\n```bash\nsymphonia-play --decode-only /path/to/file/to/decode\n```\n\n### FFmpeg\n\nUsing the `ffmpeg` utility with the [null](https://trac.ffmpeg.org/wiki/Null) muxer is not an acceptable benchmark because it performs audio conversion to PCM S16LE even though the output is discarded. Additionally, because the `ffmpeg` binary shipped by most package managers dynamically links the underlying `libavcodec`, `libavformat`, `libavutil`, etc. libraries, there is a non-negligible amount of time spent loading those shared libraries among others.\n\nTo benchmark FFmpeg decode performance, a new tool named [`ffbench`](https://github.com/pdeljanov/FFmpeg/blob/symphonia-ffbench/doc/examples/ffbench.c) was added to the examples of [`pdeljanov/FFmpeg`](https://github.com/pdeljanov/FFmpeg). This tool is based off the demuxing & decoding example. Since the tool is built as an example, the underlying libraries are statically linked.\n\nTo build this tool yourself, the following steps may be used:\n\n```bash\ngit clone https://github.com/pdeljanov/FFmpeg.git\ncd FFmpeg\ngit checkout symphonia-ffbench\n./configure\nmake -j16\nmake -j16 examples\n```\n\n`ffbench` can be run with the following command:\n\n```bash\n./doc/examples/ffbench /path/to/file/to/decode\n```\n\n## Methodology\n\nThe latest development versions based off the `master` branch of both projects is used.\n\n[Hyperfine](https://github.com/sharkdp/hyperfine) is used to execute the tests. Each file is benchmarked for a minimum of 30 runs after 3 discarded cache warmup runs.\n\nThe following script makes it easier to run a benchmark:\n\n```bash\n#!/bin/bash\nhyperfine --warmup 3 -m 30 \"./ffbench ${1}\" \"./symphonia-play --decode-only ${1}\"\n```\n\nThe mean relative time spent decoding is calculated by taking the mean run time of all Symphonia runs and dividing it by the mean run time of all FFmpeg runs. A value of less-than 1.0 indicates Symphonia beat FFmpeg. The lower the relative time spent decoding, the better.\n\n## Limitations\n\nThese benchmarks are basic. If you're interested in helping implement a more comprehensive and reproduceable benchmark suite, please reach out!\n\nIn these tests, only a couple files are tested per decoder from the author's personal media library and test vectors. It should be assumed that the decoders are optimized for these files the best since they were used to test and validate the decoders themselves. Different encodings may exercise different code paths of a decoder. A more robust benchmark suite would test tens or hundreds of files per decoder.\n\nSince Symphonia depends heavily on auto-vectorization and LLVM optimizations, the Rust compiler version may strongly impact performance.\n\n## Results\n\n### Intel Core i7-4790K, 4C/8T @ 4.0 GHz\n\n| Codec | Symphonia (ms) | FFmpeg (ms) | Relative (Smaller is Better) |\n|:------|:--------------:|:------------:|:----------------------------:|\n| AAC-LC #1 (44 kHz, 260 kbps) | 148.8 ± 1.5 | 123.5 ± 1.1 | 1.21 |\n| AAC-LC #2 (44 kHz, 260 kbps) | 131.0 ± 1.9 | 109.8 ± 1.0 | 1.19 |\n| ADPCM IMA (44 kHz) | 905.0 ± 15.3 | 1095.6 ± 5.7 | 0.83 |\n| ADPCM MS (44 kHz) | 1095.3 ± 7.6 | 972.3 ± 8.3 | 1.13 |\n| ALAC (44 kHz, 16 bit) | 426.7 ± 3.4 | 586.7 ± 1.5 | 0.73 |\n| ALAC (96 kHz, 32 bit) | 1363.6 ± 5.2 | 1724.8 ± 3.9 | 0.79 |\n| FLAC (44 kHz, 16 bit) | 190.9 ± 1.0 | 267.8 ± 1.3 | 0.71 |\n| FLAC (48 kHz, 24 bit) | 211.7 ± 0.8 | 295.5 ± 0.9 | 0.72 |\n| FLAC (96 kHz, 24 bit) | 176.4 ± 1.4 | 239.5 ± 1.0 | 0.74 |\n| MP1 (44 kHz, 192 kbps) | 91.9 ± 0.8 | 202.0 ± 1.8 | 0.45 |\n| MP1 (44 kHz, 448 kbps) | 106.2 ± 0.9 | 222.8 ± 1.3 | 0.48 |\n| MP2 (44 kHz, 128 kbps) | 207.1 ± 2.0 | 346.1 ± 5.0 | 0.60 |\n| MP2 (44 kHz, 384 kbps) | 239.5 ± 2.7 | 396.4 ± 3.6 | 0.60 |\n| MP3 (44 kHz, 128 kbps) | 262.2 ± 2.0 | 253.0 ± 1.0 | 1.04 |\n| MP3 (44 kHz, 320 kbps) | 187.6 ± 1.5 | 222.9 ± 1.1 | 0.84 |\n| Vorbis (44 kHz, ~256 kbps) | 317.6 ± 2.2 | 302.9 ± 2.5 | 1.05 |\n\n### Apple M1 Pro, 8C/8T Firestorm (Performance) Cores @ 3.2 GHz + 2C/2T Icestorm (Efficiency) Cores @ 2.0 GHz\n\n| Codec | Symphonia (ms) | FFmpeg (ms) | Relative (Smaller is Better) |\n|:------|:--------------:|:-----------:|:----------------------------:|\n| AAC-LC #1 (44 kHz, 260 kbps) | 127.4 ± 0.6 | 115.6 ± 0.7 | 1.10 |\n| AAC-LC #2 (44 kHz, 260 kbps) | 112.7 ± 0.3 | 102.2 ± 0.5 | 1.10 |\n| ADPCM IMA (44 kHz) | 1191.3 ± 1.6 | 789.4 ± 0.9 | 1.51 |\n| ADPCM MS (44 kHz) | 724.5 ± 1.8 | 1235.5 ± 6.0 | 0.59 |\n| ALAC (44 kHz, 16 bit) | 339.3 ± 2.6 | 420.6 ± 1.2 | 0.81 |\n| ALAC (96 kHz, 32 bit) | 1079.5 ± 1.7 | 1403.2 ± 1.5 | 0.77 |\n| FLAC (44 kHz, 16 bit) | 170.8 ± 0.9 | 267.7 ± 0.5 | 0.64 |\n| FLAC (48 kHz, 24 bit) | 179.2 ± 0.4 | 349.6 ± 0.8 | 0.51 |\n| FLAC (96 kHz, 24 bit) | 155.2 ± 0.5 | 274.4 ± 1.1 | 0.57 |\n| MP1 (44 kHz, 192 kbps) | 72.2 ± 0.3 | 114.4 ± 0.7 | 0.63 |\n| MP1 (44 kHz, 448 kbps) | 83.2 ± 0.4 | 130.5 ± 0.4 | 0.64 |\n| MP2 (44 kHz, 128 kbps) | 144.8 ± 0.4 | 202.1 ± 0.5 | 0.72 |\n| MP2 (44 kHz, 384 kbps) | 177.0 ± 0.3 | 230.8 ± 1.6 | 0.77 |\n| MP3 (44 kHz, 128 kbps) | 204.3 ± 0.5 | 203.9 ± 0.6 | 1.00 |\n| MP3 (44 kHz, 320 kbps) | 150.2 ± 0.3 | 186.5 ± 0.7 | 0.81 |\n| Vorbis (44 kHz, ~256 kbps) | 307.9 ± 0.6 | 247.6 ± 0.6 | 1.24 |\n\n### Raspberry Pi 4B, Broadcom BCM2711, 4C/4T Cortex-A72 (ARM v8) @ 1.5 GHz\n\n| Codec | Symphonia (ms) | FFmpeg (ms) | Relative (Smaller is Better) |\n|:------|:--------------:|:-----------:|:----------------------------:|\n| AAC-LC #1 (44 kHz, 260 kbps) | 566.6 ± 2.5 | 446.8 ± 2.6 | 1.27 |\n| AAC-LC #2 (44 kHz, 260 kbps) | 502.8 ± 3.0 | 401.7 ± 2.9 | 1.25 |\n| ADPCM IMA (44 kHz) | 3033.3 ± 16.9 | 2879.9 ± 5.8 | 1.05 |\n| ADPCM MS (44 kHz) | 2536.5 ± 5.9 | 2655.5 ± 7.1 | 0.96 |\n| ALAC (44 kHz, 16 bit) | 1227.2 ± 2.7 | 1512.9 ± 1.6 | 0.81 |\n| ALAC (96 kHz, 32 bit) | 3900.4 ± 13.8 | 4456.7 ± 5.7 | 0.88 |\n| FLAC (44 kHz, 16 bit) | 734.2 ± 2.6 | 704.2 ± 2.0 | 1.04 |\n| FLAC (48 kHz, 24 bit) | 818.3 ± 2.3 | 855.8 ± 2.5 | 0.96 |\n| FLAC (96 kHz, 24 bit) | 650.4 ± 1.8 | 677.0 ± 2.0 | 0.96 |\n| MP1 (44 kHz, 192 kbps) | 428.2 ± 11.7 | 514.9 ± 3.5 | 0.83 |\n| MP1 (44 kHz, 448 kbps) | 498.5 ± 6.5 | 574.1 ± 7.4 | 0.87 |\n| MP2 (44 kHz, 128 kbps) | 796.8 ± 23.6 | 879.9 ± 3.9 | 0.91 |\n| MP2 (44 kHz, 384 kbps) | 930.7 ± 6.6 | 1001.5 ± 19.0 | 0.93 |\n| MP3 (44 kHz, 128 kbps) | 964.4 ± 8.1 | 899.5 ± 6.8 | 1.07 |\n| MP3 (44 kHz, 320 kbps) | 693.3 ± 8.0 | 726.6 ± 3.8 | 0.95 |\n| Vorbis (44 kHz, ~256 kbps) | 1209.9 ± 3.0 | 1075.5 ± 6.9 | 1.12 |\n\n## Summary\n\nOverall, Symphonia is very competitive against FFmpeg across a range of common processors and codecs.\n\nInterestingly, the performance of some decoders varies wildy depending on CPU architecture. If you are up for an optimization challenge, please consider reaching out!\n\n[^1]: FFmpeg supports decoding ALAC and FLAC using multiple threads, however, this does not appear to be the default behaviour of the library. Currently, Symphonia decoders do not use more than one thread. Therefore, for these codecs, this is a fair comparison of the efficiency of both libraries.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.9658203125,
          "content": "# Contribution Guidelines\n\nThank you for your interest in contributing to Symphonia!\n\nThere are many ways you may contribute. Some ideas for possible contributions are provided below.\n\n## Ways to Contribute\n\n### Implement new format readers, decoders, and features\n\nImplement missing features from the project roadmap, or features that haven't been considered yet.\n\n### Triage and fix reported issues\n\nReproduce, root cause, and submit bug fixes for reported issues.\n\n### Benchmark and optimize\n\nBenchmark, identify, and report areas where performance could be improved. If possible, try your hand at optimizing it yourself!\n\n### Improve documentation\n\nIdentify areas of the documentation that are lacking and expand them. Adding examples is another great way to help document the project for new users.\n\n### Test your content library\n\nTest your content library against Symphonia and ensure there are no panics or audio glitches.\n\nThe [`symphonia-play`](symphonia-play/README.md) and [`symphonia-check`](symphonia-check/README.md) utilities may be used for this, but please note the section about interpreting results of the latter since false positives are not uncommon.\n\n### Answer questions\n\nAnswer questions raised in issues or discussions.\n\n## Code & Documentation Contribution Guidelines\n\nPlease read through these guidelines ahead of time to ensure a smooth contribution process.\n\n### General Considerations\n\nSymphonia is a mature project with a limited number of maintainers. Therefore, maintainability and preventing regressions are very important considerations when we accept contributions.\n\nWe welcome pull requests (PRs) for new format readers, decoders, and other missing features. It is a good idea to raise an issue ahead of time to let everyone know what you will be working on to reduce the chance of duplicate efforts, and to make sure the change is aligned with the project. Once merged, please also consider  volunteering to take responsibility for the on-going maintenance of the new code.\n\nWhile PRs containing isolated changes can usually be merged and included in the next release, PRs with the following changes may be delayed for some time:\n\n- SemVer or API breaking changes. Please read what constitutes a SemVer break in the Cargo [book](https://doc.rust-lang.org/cargo/reference/semver.html).\n- Directly or indirectly increasing the minimum supported Rust version (MSRV). We consider this a SemVer breaking change.\n\nIn general, we won't accept PRs for the following changes without prior discussion and approval:\n\n- Wholesale rewrites of a crate or feature.\n- Replacing most, or all, of a crate or feature's implementation with an out-of-tree dependency.\n- Changing an API or modifying the behaviour of Symphonia to specifically match the requirements of one project or application.\n\n### Quality\n\nSymphonia reads untrusted data which may be corrupted or deliberately malicious. It is critical that Symphonia validates and sanity-checks all data. Under no circumstance should Symphonia panic or consume an unbounded amount of system resources (e.g., RAM).\n\nA baseline level of quality is required before a PR is merged. All known audio glitches should be fixed, and the potential harm of any undiscovered audio glitch should be minimized.\n\nA clean build must be free of compiler warnings.\n\nIn addition to any compiler warnings, please also fix any warnings generated by `cargo clippy`. GitHub will not allow a PR to be merged with outstanding clippy warnings.\n\nFuzzing is recommended, but not mandatory.\n\n### Code Formatting\n\nPlease format your code prior to submission with a **nightly** build of `rustfmt`. After installing the nightly toolchain you can do this by running `cargo +nightly fmt`.\n\nGitHub will not allow a PR to be merged that does not meet the code formatting standard.\n\n### Testing\n\nAdding unit tests for your code is recommended, but not mandatory.\n\nPlease run `cargo test` before submission.\n\nGitHub will not allow a PR to be merged that has failing test cases.\n\n### Documentation\n\nIf your change modifies the behaviour of a public\nAPI, please also update the relevant documentation. This may also include [`GETTING_STARTED.md`](GETTING_STARTED.md) and any examples.\n\nIf you reference any standards, please make note of it in the comments of your implementation. For example, if your code includes a lookup table of constants, add a comment indicating the standard and the section from which it came from.\n\n### Acknowledgements\n\nIf you are a new contributor, please add yourself to the [`CONTRIBUTORS`](CONTRIBUTORS) file.\n\nIf you are introducing a new crate, add yourself as the **first** author of the crate.\n\n### Commit History\n\nUnless otherwise requested, all PRs will be squashed into a single commit to maintain a clean history. If you would prefer that the commit history is kept, please ensure that it is clean. All commits should be meaningful and have a title that follows the general `component: Description of change.` style.\n\n### License\n\nPlease be aware that all contributions must be licensed under the MPL v2.0 license.\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 1.072265625,
          "content": "# Primary Author & Maintainer\n\nPhilip Deljanov <philip.deljanov@gmail.com>\n\n# Contributors who wish to provide their name and email, please use the following format:\n#   Name <email address>\n#\n# Please keep this section sorted in ascending order.\n\nAkiyuki Okayasu <akiyuki.okayasu@gmail.com>\nIan Hobson <ian.r.hobson@gmail.com>\nKostya Shishkov <kostya.shiskov@gmail.com>\nThom Chiovoloni <chiovolonit@gmail.com>\n\n# Contributors who wish to use an online handle, please use the following format:\n#   Handle [GitHub/GitLab/BitBucket URL]\n#\n# Please keep this section sorted in ascending order.\n\naschey [https://github.com/aschey]\nBlackHoleFox [https://github.com/blackholefox]\ndarksv [https://github.com/darksv]\ndedobbin [https://github.com/dedobbin]\ndjugei [https://github.com/djugei]\nerikas-taroza [https://github.com/erikas-taroza]\nFelixMcFelix [https://github.com/FelixMcFelix]\ngeckoxx [https://github.com/geckoxx]\nHerohtar [https://github.com/herohtar]\nnicholaswyoung [https://github.com/nicholaswyoung]\nrichardmitic [https://github.com/richardmitic]\nterrorfisch [https://github.com/terrorfisch]\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.552734375,
          "content": "[workspace]\n\nmembers = [\n    \"symphonia\",\n    \"symphonia-bundle-flac\",\n    \"symphonia-bundle-mp3\",\n    \"symphonia-codec-aac\",\n    \"symphonia-codec-adpcm\",\n    \"symphonia-codec-alac\",\n    \"symphonia-codec-opus\",\n    \"symphonia-codec-pcm\",\n    \"symphonia-codec-vorbis\",\n    \"symphonia-codec-wavpack\",\n    \"symphonia-core\",\n    \"symphonia-format-isomp4\",\n    \"symphonia-format-mkv\",\n    \"symphonia-format-ogg\",\n    \"symphonia-format-riff\",\n    \"symphonia-format-wav\",\n    \"symphonia-metadata\",\n    \"symphonia-play\",\n    \"symphonia-utils-xiph\",\n    \"symphonia-check\",\n]\n"
        },
        {
          "name": "GETTING_STARTED.md",
          "type": "blob",
          "size": 18.8046875,
          "content": "# Getting Started\n\nLast updated for `v0.5.0`.\n\n## Multimedia Basics\n\nA track of audio consists of a packetized (chunked) codec bitstream. The codec bitstream is consumed by a decoder one packet at a time to produce a stream of audio samples (PCM). The audio samples can then be played back by the audio hardware.\n\nGenerally, the packetized codec bitstream is encapsulated in a multimedia container format. The container wraps the codec bitstream packets with additional information such as track ID, timestamps, duration, size, etc. This allows the container to support features such as seeking, multiple tracks, and other expected features. Additionally, a container format may also support human readable metadata such as artist, album, track title, and so on.\n\nThe process of reading a container and progressively obtaining the packets of each track's codec bitstream is called demultiplexing (demuxing). The process of converting the codec bitstream data encapsulated in a given packet back into audio samples is called decoding.\n\n## Symphonia Basics\n\nSince it is possible to encapsulate the same codec bitstream into many different container formats, Symphonia creates a hard boundary between demuxing and decoding.\n\nIn Symphonia, a container format reader is known as a format reader. All format readers implement the `symphonia::core::formats::FormatReader` trait.\n\nLikewise, a consumer of codec bitstream packets is known as a decoder and implements the `symphonia::core::codecs::Decoder` trait.\n\nTherefore, in Symphonia, the basic process of decoding a particular audio track involves obtaining packets from a `FormatReader` and then decoding them with a `Decoder`.\n\n## Basic Usage\n\n### Enable crate features\n\nBy default, Symphonia only enables support for royalty-free or open-standard media formats (OGG, Matroska/WebM, Wave) and codecs (FLAC, Vorbis, PCM).\n\nNotably, if you want MP3 support, the `mp3` feature must be enabled. For AAC or ALAC support, enable `isomp4` (to enable the MP4/M4A container), and either `aac` or `alac` for each codec respectively.\n\nMake sure to consult the README for the latest set of features available!\n\n### Create a media source\n\nSymphonia can read from any source that implements the `symphonia::core::io::MediaSource` trait.\n\n`MediaSource` is a composite trait consisting of `std::io::Read` and `std::io::Seek`. For convenience, it is already implemented for `std::fs::File` and `std::io::cursor::Cursor`.\n\nGiven a `MediaSource`, a `symphonia::core::io::MediaSourceStream` can be created.\n\n`MediaSourceStream` is Symphonia's supercharged equivalent to `std::io::BufReader`. It implements many enhancements to better support multimedia use-cases.\n\n```rust\nuse symphonia::core::io::MediaSourceStream;\n\nfn main() {\n    // Get the first command line argument.\n    let args: Vec<String> = std::env::args().collect();\n    let path = args.get(1).expect(\"file path not provided\");\n\n    // Open the media source.\n    let src = std::fs::File::open(&path).expect(\"failed to open media\");\n\n    // Create the media source stream.\n    let mss = MediaSourceStream::new(Box::new(src), Default::default());\n}\n```\n\nAdditional options to control buffering may be passed to `MediaSourceStream::new` in the second parameter, but the defaults are suitable for most cases.\n\n#### Unseekable Sources\n\nIf a source cannot implement `std::io::Seek`, then `symphonia::core::io::ReadOnlySource` can be used to wrap any source that implements `std::io::Read`.\n\nFor example, to use standard input as a `MediaSource`:\n\n```rust\nuse symphonia::core::io::ReadOnlySource;\n\nlet src = ReadOnlySource::new(std::io::stdin());\n```\n\n### Detect the media format\n\nSymphonia can automatically detect the media format of a provided source and instantiate the correct format reader. Alternately, if the specific format is known beforehand, one could just instantiate the appropriate format reader manually.\n\nAutomatic detection is the preferred option for most cases.\n\n> :warning: Please be aware that misdetection can occur! If you know for certain what format and codec to use, consider instantiating them manually. Enabling more format support can reduce the chances of misdetection. See [enable crate features](#enable-crate-features).\n\nTo automatically detect the media format, a `symphonia::core::probe::Probe` is used. A `Probe` takes a `MediaSourceStream` and examines it to determine what the media format is, and if the format is supported, returns the appropriate reader for the format. If metadata was encountered while probing, it will also be returned with the reader.\n\nBy default, a `Probe` with all enabled media formats pre-registered is provided via. `symphonia::default::get_probe()`.\n\n```rust\nuse symphonia::core::formats::FormatOptions;\nuse symphonia::core::meta::MetadataOptions;\nuse symphonia::core::io::MediaSourceStream;\nuse symphonia::core::probe::Hint;\n\nfn main() {\n    // Get the first command line argument.\n    let args: Vec<String> = std::env::args().collect();\n    let path = args.get(1).expect(\"file path not provided\");\n\n    // Open the media source.\n    let src = std::fs::File::open(&path).expect(\"failed to open media\");\n\n    // Create the media source stream.\n    let mss = MediaSourceStream::new(Box::new(src), Default::default());\n\n    // Create a probe hint using the file's extension. [Optional]\n    let mut hint = Hint::new();\n    hint.with_extension(\"mp3\");\n\n    // Use the default options for metadata and format readers.\n    let meta_opts: MetadataOptions = Default::default();\n    let fmt_opts: FormatOptions = Default::default();\n\n    // Probe the media source.\n    let probed = symphonia::default::get_probe().format(&hint, mss, &fmt_opts, &meta_opts)\n                                                .expect(\"unsupported format\");\n}\n```\n\n#### Gapless playback\n\nIf gapless playback is desired, and generally it is, set `FormatOptions::enable_gapless` to `true`.\n\n#### Custom media formats\n\nIf you want to register one or more custom media formats for automatic detection, then it is possible to instantiate your own `Probe` and register the formats manually.\n\nFor convenience, `symphonia::default::register_enabled_formats()` may be used to register all enabled media formats into your custom `Probe`.\n\n### Select a track\n\nA media format may contain more than one track. For each track that you want to play, a decoder must be instantiated.\n\nThis step will vary depending on your application, though for simple cases, selecting the default track will be sufficient.\n\n> :warning: If playing the audio from video files is desireable, then note that the default track may *not* be an audio track. For this case, it is best to select the first supported audio track.\n\nIn the example below, the first audio track will be selected and a decoder instantiated.\n\n```rust\nuse symphonia::core::codecs::{CODEC_TYPE_NULL, DecoderOptions};\nuse symphonia::core::formats::FormatOptions;\nuse symphonia::core::meta::MetadataOptions;\nuse symphonia::core::io::MediaSourceStream;\nuse symphonia::core::probe::Hint;\n\nfn main() {\n    // Get the first command line argument.\n    let args: Vec<String> = std::env::args().collect();\n    let path = args.get(1).expect(\"file path not provided\");\n\n    // Open the media source.\n    let src = std::fs::File::open(&path).expect(\"failed to open media\");\n\n    // Create the media source stream.\n    let mss = MediaSourceStream::new(Box::new(src), Default::default());\n\n    // Create a probe hint using the file's extension. [Optional]\n    let mut hint = Hint::new();\n    hint.with_extension(\"mp3\");\n\n    // Use the default options for metadata and format readers.\n    let meta_opts: MetadataOptions = Default::default();\n    let fmt_opts: FormatOptions = Default::default();\n\n    // Probe the media source.\n    let probed = symphonia::default::get_probe().format(&hint, mss, &fmt_opts, &meta_opts)\n                                                .expect(\"unsupported format\");\n\n    // Get the instantiated format reader.\n    let format = probed.format;\n\n    // Find the first audio track with a known (decodeable) codec.\n    let track = format.tracks()\n                    .iter()\n                    .find(|t| t.codec_params.codec != CODEC_TYPE_NULL)\n                    .expect(\"no supported audio tracks\");\n\n    // Use the default options for the decoder.\n    let dec_opts: DecoderOptions = Default::default();\n\n    // Create a decoder for the track.\n    let mut decoder = symphonia::default::get_codecs().make(&track.codec_params, &dec_opts)\n                                                    .expect(\"unsupported codec\");\n\n    // Store the track identifier, it will be used to filter packets.\n    let track_id = track.id;\n}\n```\n\n#### Custom Decoders\n\nMuch like how `Probe` is a registry of media formats, `symphonia_core::codecs::CodecRegistry` is a registry of codecs.\n\nA registry of all enabled codecs is provided by `symphonia::default::get_codecs()`. If a custom decoder is required, then a `CodecRegistry` can be instantiated and the custom decoder registered.\n\nFor convenience, `symphonia::default::register_enabled_codecs()` may be used to register all enabled codecs into your custom `CodecRegistry`.\n\n### Decode loop\n\nThe decode loop consists of four steps:\n\n1. Acquiring a packet from the media format (container).\n2. Consuming any new metadata.\n3. Filtering the packet.\n4. Decoding the packet into audio samples using its associated decoder.\n\nWith the addition of the decode loop, the example is now complete.\n\n```rust\nuse symphonia::core::codecs::{CODEC_TYPE_NULL, DecoderOptions};\nuse symphonia::core::errors::Error;\nuse symphonia::core::formats::FormatOptions;\nuse symphonia::core::meta::MetadataOptions;\nuse symphonia::core::io::MediaSourceStream;\nuse symphonia::core::probe::Hint;\n\nfn main() {\n    // Get the first command line argument.\n    let args: Vec<String> = std::env::args().collect();\n    let path = args.get(1).expect(\"file path not provided\");\n\n    // Open the media source.\n    let src = std::fs::File::open(&path).expect(\"failed to open media\");\n\n    // Create the media source stream.\n    let mss = MediaSourceStream::new(Box::new(src), Default::default());\n\n    // Create a probe hint using the file's extension. [Optional]\n    let mut hint = Hint::new();\n    hint.with_extension(\"mp3\");\n\n    // Use the default options for metadata and format readers.\n    let meta_opts: MetadataOptions = Default::default();\n    let fmt_opts: FormatOptions = Default::default();\n\n    // Probe the media source.\n    let probed = symphonia::default::get_probe().format(&hint, mss, &fmt_opts, &meta_opts)\n                                                .expect(\"unsupported format\");\n\n    // Get the instantiated format reader.\n    let mut format = probed.format;\n\n    // Find the first audio track with a known (decodeable) codec.\n    let track = format.tracks()\n                    .iter()\n                    .find(|t| t.codec_params.codec != CODEC_TYPE_NULL)\n                    .expect(\"no supported audio tracks\");\n\n    // Use the default options for the decoder.\n    let dec_opts: DecoderOptions = Default::default();\n\n    // Create a decoder for the track.\n    let mut decoder = symphonia::default::get_codecs().make(&track.codec_params, &dec_opts)\n                                                    .expect(\"unsupported codec\");\n\n    // Store the track identifier, it will be used to filter packets.\n    let track_id = track.id;\n\n    // The decode loop.\n    loop {\n        // Get the next packet from the media format.\n        let packet = match format.next_packet() {\n            Ok(packet) => packet,\n            Err(Error::ResetRequired) => {\n                // The track list has been changed. Re-examine it and create a new set of decoders,\n                // then restart the decode loop. This is an advanced feature and it is not\n                // unreasonable to consider this \"the end.\" As of v0.5.0, the only usage of this is\n                // for chained OGG physical streams.\n                unimplemented!();\n            }\n            Err(err) => {\n                // A unrecoverable error occured, halt decoding.\n                panic!(\"{}\", err);\n            }\n        };\n\n        // Consume any new metadata that has been read since the last packet.\n        while !format.metadata().is_latest() {\n            // Pop the old head of the metadata queue.\n            format.metadata().pop();\n\n            // Consume the new metadata at the head of the metadata queue.\n        }\n\n        // If the packet does not belong to the selected track, skip over it.\n        if packet.track_id() != track_id {\n            continue;\n        }\n\n        // Decode the packet into audio samples.\n        match decoder.decode(&packet) {\n            Ok(_decoded) => {\n                // Consume the decoded audio samples (see below).\n            }\n            Err(Error::IoError(_)) => {\n                // The packet failed to decode due to an IO error, skip the packet.\n                continue;\n            }\n            Err(Error::DecodeError(_)) => {\n                // The packet failed to decode due to invalid data, skip the packet.\n                continue;\n            }\n            Err(err) => {\n                // An unrecoverable error occured, halt decoding.\n                panic!(\"{}\", err);\n            }\n        }\n    }\n}\n```\n\n> :warning: This example will always panic when it reaches the end of the file because an end-of-stream IO error signals the end of the file. Therefore, proper error handling is required.\n\n## Consuming Audio Data\n\nAfter a packet is successfully decoded, a `Decoder` returns a reference to a copy-on-write `symphonia::core::audio::AudioBuffer<S: Sample>`. Since an audio buffer is parameterized by the sample format, and a decoder can return an audio buffer of any sample format, `Decoder::decode` actually returns the enum `symphonia::core::audio::AudioBufferRef`.\n\n### Accessing audio samples directly\n\nSamples can be directly accessed by matching on the returned `AudioBufferRef` and using the methods provided by `AudioBuffer`.\n\nFor example, to iterate over all samples in the first channel (plane) of the audio buffer:\n\n```rust\nuse symphonia_core::audio::{AudioBufferRef, Signal};\n\nlet decoded = decoder.decode(&packet).unwrap();\n\nmatch decoded {\n    AudioBufferRef::F32(buf) => {\n        for &sample in buf.chan(0) {\n            // Do something with `sample`.\n        }\n    }\n    _ => {\n        // Repeat for the different sample formats.\n        unimplemented!()\n    }\n}\n```\n\nThe last decoded audio buffer can also be obtained by using `Decoder::last_decoded`.\n\n> :warning: If the last call to decode resulted in an error, then the last decoded audio buffer will have a length of 0.\n\nAnother useful access pattern is viewing the audio buffer as a slice-of-slices wherein each slice is a complete audio plane (channel):\n\n```rust\nuse symphonia_core::audio::{AudioBufferRef, Signal};\n\nmatch decoded {\n    AudioBufferRef::F32(buf) => {\n        let planes = buf.planes();\n\n        for plane in planes.planes() {\n            for &sample in plane.iter() {\n                // Do something with `sample`.\n            }\n        }\n    }\n    _ => {\n        // Repeat for the different sample formats.\n        unimplemented!()\n    }\n}\n```\n\n### Converting to an interleaved sample buffer\n\nIf the audio samples are required to be of a certain sample format and interleaved, then a `symphonia::core::audio::SampleBuffer` can be used to perform the conversion.\n\n```rust\nuse symphonia_core::audio::SampleBuffer;\n\n// Create a sample buffer that matches the parameters of the decoded audio buffer.\nlet mut sample_buf = SampleBuffer::<f32>::new(decoded.capacity() as u64, *decoded.spec());\n\n// Copy the contents of the decoded audio buffer into the sample buffer whilst performing\n// any required conversions.\nsample_buf.copy_interleaved_ref(decoded);\n\n// The interleaved f32 samples can be accessed as follows.\nlet samples = sample_buf.samples();\n```\n\nA `SampleBuffer` should be reused for the life of the decoder. The only exception where the `SampleBuffer` must be recreated is if `Decoder::decode` returns `Error::ResetRequired`.\n\n### Converting to a byte-oriented interleaved sample buffer\n\nIf the samples must be returned as a slice of bytes, then a `symphonia::core::audio::RawSampleBuffer` can be used to perform the conversion. A `RawSampleBuffer` is effectively the same as a `SampleBuffer` except the samples can be accessed as a slice of bytes.\n\n```rust\nuse symphonia_core::audio::RawSampleBuffer;\n\n// Create a raw sample buffer that matches the parameters of the decoded audio buffer.\nlet mut byte_buf = RawSampleBuffer::<f32>::new(decoded.capacity() as u64, *decoded.spec());\n\n// Copy the contents of the decoded audio buffer into the sample buffer whilst performing\n// any required conversions.\nbyte_buf.copy_interleaved_ref(decoded);\n\n// The interleaved f32 samples can be accessed as a slice of bytes as follows.\nlet bytes = byte_buf.as_bytes();\n```\n\nJust like a `SampleBuffer`, a `RawSampleBuffer` should be reused for the life of the decoder. The only exception where the `RawSampleBuffer` must be recreated is if `Decoder::decode` returns `Error::ResetRequired`.\n\n### Converting to a planar sample buffer\n\nIf the samples in the `SampleBuffer` should be in a planar format, then use `SampleBuffer::copy_planar_ref`.\n\n### Converting to a byte-oriented planar sample buffer\n\nIf the samples in the `RawSampleBuffer` should be in a planar format, then use `RawSampleBuffer::copy_planar_ref`.\n\n## Consuming Metadata\n\nWhen creating a format reader, and then while demuxing, metadata may be encountered by the reader. Each time a format reader encounters new metadata, it creates a metadata revision and then queues it for consumption. The user should frequently check this queue and pop old revisions of the metadata off the queue.\n\n> :warning: While this may vary based on the application, a newer revision should not fully replace a previous revision. For example, assume two metadata revisions containing the following tags:\n>\n> 1. `TrackTitle = \"Title0\"; AlbumArtist = \"Artist\"; Album = \"Album\";`\n> 2. `TrackTitle = \"Title1\";`\n>\n> If both revisions are consumed, the final metadata should be:\n>\n> * `TrackTitle = \"Title1\"; AlbumArtist = \"Artist\"; Album = \"Album\";`\n>\n> In other words, a revision should generally be viewed as an \"upsert\" (update or insert) operation.\n>\n> An exception to this general rule is when the reader returns a `ResetRequired` error.\n\nIn the example shown above, metadata is consumed in an inner loop within the main decode loop:\n\n```rust\n// While there is newer metadata.\nwhile !format.metadata().is_latest() {\n    // Pop the old head of the metadata queue.\n    format.metadata().pop();\n\n    if let Some(rev) = format.metadata().current() {\n        // Consume the new metadata at the head of the metadata queue.\n    }\n}\n```\n\n### Probed Metadata\n\nMetadata may also be encountered while probing before the container begins. For example, ID3v2 tags are appended to the start of a MP3 file before the actual format data. In this case, rather than getting the metadata from the format reader, the probe result will contain the metadata. It can be obtained via the `metadata` field of `ProbeResult`.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.3330078125,
          "content": "Mozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\n    means each individual or legal entity that creates, contributes to\n    the creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n    means the combination of the Contributions of others (if any) used\n    by a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n    means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n    means Source Code Form to which the initial Contributor has attached\n    the notice in Exhibit A, the Executable Form of such Source Code\n    Form, and Modifications of such Source Code Form, in each case\n    including portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n    means\n\n    (a) that the initial Contributor has attached the notice described\n        in Exhibit B to the Covered Software; or\n\n    (b) that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the\n        terms of a Secondary License.\n\n1.6. \"Executable Form\"\n    means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n    means a work that combines Covered Software with other material, in \n    a separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n    means this document.\n\n1.9. \"Licensable\"\n    means having the right to grant, to the maximum extent possible,\n    whether at the time of the initial grant or subsequently, any and\n    all of the rights conveyed by this License.\n\n1.10. \"Modifications\"\n    means any of the following:\n\n    (a) any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered\n        Software; or\n\n    (b) any new file in Source Code Form that contains any Covered\n        Software.\n\n1.11. \"Patent Claims\" of a Contributor\n    means any patent claim(s), including without limitation, method,\n    process, and apparatus claims, in any patent Licensable by such\n    Contributor that would be infringed, but for the grant of the\n    License, by the making, using, selling, offering for sale, having\n    made, import, or transfer of either its Contributions or its\n    Contributor Version.\n\n1.12. \"Secondary License\"\n    means either the GNU General Public License, Version 2.0, the GNU\n    Lesser General Public License, Version 2.1, the GNU Affero General\n    Public License, Version 3.0, or any later versions of those\n    licenses.\n\n1.13. \"Source Code Form\"\n    means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n    means an individual or a legal entity exercising rights under this\n    License. For legal entities, \"You\" includes any entity that\n    controls, is controlled by, or is under common control with You. For\n    purposes of this definition, \"control\" means (a) the power, direct\n    or indirect, to cause the direction or management of such entity,\n    whether by contract or otherwise, or (b) ownership of more than\n    fifty percent (50%) of the outstanding shares or beneficial\n    ownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\n    Licensable by such Contributor to use, reproduce, make available,\n    modify, display, perform, distribute, and otherwise exploit its\n    Contributions, either on an unmodified basis, with Modifications, or\n    as part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\n    for sale, have made, import, and otherwise transfer either its\n    Contributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\n    or\n\n(b) for infringements caused by: (i) Your and any other third party's\n    modifications of Covered Software, or (ii) the combination of its\n    Contributions with other software (except as part of its Contributor\n    Version); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\n    its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\n    Form, as described in Section 3.1, and You must inform recipients of\n    the Executable Form how they can obtain a copy of such Source Code\n    Form by reasonable means in a timely manner, at a charge no more\n    than the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\n    License, or sublicense it under different terms, provided that the\n    license for the Executable Form does not attempt to limit or alter\n    the recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n*                                                                      *\n*  6. Disclaimer of Warranty                                           *\n*  -------------------------                                           *\n*                                                                      *\n*  Covered Software is provided under this License on an \"as is\"       *\n*  basis, without warranty of any kind, either expressed, implied, or  *\n*  statutory, including, without limitation, warranties that the       *\n*  Covered Software is free of defects, merchantable, fit for a        *\n*  particular purpose or non-infringing. The entire risk as to the     *\n*  quality and performance of the Covered Software is with You.        *\n*  Should any Covered Software prove defective in any respect, You     *\n*  (not any Contributor) assume the cost of any necessary servicing,   *\n*  repair, or correction. This disclaimer of warranty constitutes an   *\n*  essential part of this License. No use of any Covered Software is   *\n*  authorized under this License except under this disclaimer.         *\n*                                                                      *\n************************************************************************\n\n************************************************************************\n*                                                                      *\n*  7. Limitation of Liability                                          *\n*  --------------------------                                          *\n*                                                                      *\n*  Under no circumstances and under no legal theory, whether tort      *\n*  (including negligence), contract, or otherwise, shall any           *\n*  Contributor, or anyone who distributes Covered Software as          *\n*  permitted above, be liable to You for any direct, indirect,         *\n*  special, incidental, or consequential damages of any character      *\n*  including, without limitation, damages for lost profits, loss of    *\n*  goodwill, work stoppage, computer failure or malfunction, or any    *\n*  and all other commercial damages or losses, even if such party      *\n*  shall have been informed of the possibility of such damages. This   *\n*  limitation of liability shall not apply to liability for death or   *\n*  personal injury resulting from such party's negligence to the       *\n*  extent applicable law prohibits such limitation. Some               *\n*  jurisdictions do not allow the exclusion or limitation of           *\n*  incidental or consequential damages, so this exclusion and          *\n*  limitation may not apply to You.                                    *\n*                                                                      *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\n  This Source Code Form is \"Incompatible With Secondary Licenses\", as\n  defined by the Mozilla Public License, v. 2.0."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.9814453125,
          "content": "<div align=\"center\">\n<h1>Symphonia</h1>\n\n<!--\n<p>\n    <img src=\"https://raw.githubusercontent.com/pdeljanov/symphonia/master/assets/logo.png\" width=\"200px\" />\n</p>\n-->\n\n<p>\n    <a href=\"https://crates.io/crates/symphonia\">\n        <img alt=\"Crate Info\" src=\"https://img.shields.io/crates/v/symphonia.svg\"/>\n    </a>\n    <a href=\"https://docs.rs/symphonia/\">\n        <img alt=\"API Docs\" src=\"https://img.shields.io/badge/docs.rs-symphonia-brightgreen\"/>\n    </a>\n    <a href=\"https://github.com/pdeljanov/Symphonia/actions/workflows/ci.yml\">\n        <img src=\"https://github.com/pdeljanov/Symphonia/actions/workflows/ci.yml/badge.svg\" />\n    </a>\n    <a href=\"https://deps.rs/repo/github/pdeljanov/symphonia\">\n        <img src=\"https://deps.rs/repo/github/pdeljanov/symphonia/status.svg\" />\n    </a>\n    <a href=\"https://blog.rust-lang.org/2021/06/17/Rust-1.53.0.html\">\n        <img alt=\"Rustc Version 1.53.0+\" src=\"https://img.shields.io/badge/rustc-1.53%2B-lightgrey.svg\"/>\n    </a>\n</p>\n\n<p>\n    <strong>\n        Symphonia is a pure Rust audio decoding and media demuxing library supporting AAC, ADPCM, AIFF, ALAC, CAF, FLAC, MKV, MP1, MP2, MP3, MP4, OGG, Vorbis, WAV, and WebM.\n    </strong>\n</p>\n\n<p>\n    <h3>\n        <a href=\"https://github.com/pdeljanov/Symphonia/blob/master/GETTING_STARTED.md\">Getting Started</a>\n        <span> · </span>\n        <a href=\"https://docs.rs/symphonia\">Documentation</a>\n        <span> · </span>\n        <a href=\"https://github.com/pdeljanov/Symphonia/tree/master/symphonia/examples\">Examples</a>\n        <span> · </span>\n        <a href=\"https://github.com/pdeljanov/Symphonia/blob/master/BENCHMARKS.md\">Benchmarks</a>\n    </h3>\n</p>\n</div>\n\n---\n\n## Features\n\n* Decode support for the most popular audio codecs with support for gapless playback\n* Demux the most common media container formats\n* Read most metadata and tagging formats\n* Automatic format and decoder detection\n* Basic audio primitives for manipulating audio data efficiently\n* 100% safe Rust\n* Minimal dependencies\n* Fast with no compromises in performance!\n\nAdditionally, planned features include:\n\n* Providing a C API for integration into other languages\n* Providing a WASM API for web usage\n\n## Roadmap\n\nSupport for individual audio codecs and media formats are provided by separate crates. By default, Symphonia only enables support royalty-free open standard codecs and formats, but others may be enabled using feature flags.\n\n> **Tip:** All formats and codecs can be enabled with the `all` feature flag.\n\n### Status\n\nThe following status classifications are used to determine the state of development for each format or codec.\n\n| Status    | Meaning                                                                                                                  |\n|-----------|--------------------------------------------------------------------------------------------------------------------------|\n| -         | In work or not started yet.                                                                                              |\n| Good      | Many media streams play. Some streams may panic, error, or produce audible glitches. Some features may not be supported. |\n| Great     | Most media streams play. Inaudible glitches may be present. Most common features are supported.                          |\n| Excellent | All media streams play.  No audible or inaudible glitches. All required features are supported.                          |\n\nA status of *Great* indicates that major development is complete and that the feature is in a state that would be acceptable for most applications to use.\n\nA status of *Excellent* is only assigned after the feature passes all compliance tests. If no compliance tests are readily available, then a status of *Excellent* will be assigned if Symphonia's output matches that of a reference implementation, or `ffmpeg`, over a large test corpus.\n\n### Formats (Demuxers)\n\n| Format   | Status    | Gapless* | Feature Flag | Default | Crate                       |\n|----------|-----------|----------|--------------|---------|-----------------------------|\n| AIFF     | Great     | Yes      | `aiff`       | No      | [`symphonia-format-riff`]   |\n| CAF      | Good      | No       | `caf`        | No      | [`symphonia-format-caf`]    |\n| ISO/MP4  | Great     | No       | `isomp4`     | No      | [`symphonia-format-isomp4`] |\n| MKV/WebM | Good      | No       | `mkv`        | Yes     | [`symphonia-format-mkv`]    |\n| OGG      | Great     | Yes      | `ogg`        | Yes     | [`symphonia-format-ogg`]    |\n| Wave     | Excellent | Yes      | `wav`        | Yes     | [`symphonia-format-riff`]   |\n\n\\* Gapless playback requires support from both the demuxer and decoder.\n\n[`symphonia-format-caf`]: https://docs.rs/symphonia-format-caf\n[`symphonia-format-isomp4`]: https://docs.rs/symphonia-format-isomp4\n[`symphonia-format-mkv`]: https://docs.rs/symphonia-format-mkv\n[`symphonia-format-ogg`]: https://docs.rs/symphonia-format-ogg\n[`symphonia-format-riff`]: https://docs.rs/symphonia-format-riff\n\n> **Tip:** All formats can be enabled with the `all-formats` feature flag.\n\n### Codecs (Decoders)\n\n| Codec                        | Status    | Gapless | Feature Flag | Default | Crate                      |\n|------------------------------|-----------|---------|--------------|---------|----------------------------|\n| AAC-LC                       | Great     | No      | `aac`        | No      | [`symphonia-codec-aac`]    |\n| ADPCM                        | Good      | Yes     | `adpcm`      | Yes     | [`symphonia-codec-adpcm`]  |\n| ALAC                         | Great     | Yes     | `alac`       | No      | [`symphonia-codec-alac`]   |\n| HE-AAC (AAC+, aacPlus)       | -         | -       | `he-aac`     | No      | [`symphonia-codec-aac`]    |\n| HE-AACv2 (eAAC+, aacPlus v2) | -         | -       | `he-aac-v2`  | No      | [`symphonia-codec-aac`]    |\n| FLAC                         | Excellent | Yes     | `flac`       | Yes     | [`symphonia-bundle-flac`]  |\n| MP1                          | Great     | No      | `mp1`, `mpa` | No      | [`symphonia-bundle-mp3`]   |\n| MP2                          | Great     | No      | `mp2`, `mpa` | No      | [`symphonia-bundle-mp3`]   |\n| MP3                          | Excellent | Yes     | `mp3`, `mpa` | No      | [`symphonia-bundle-mp3`]   |\n| Opus                         | -         | -       | `opus`       | Yes     | `symphonia-codec-opus`     |\n| PCM                          | Excellent | Yes     | `pcm`        | Yes     | [`symphonia-codec-pcm`]    |\n| Vorbis                       | Excellent | Yes     | `vorbis`     | Yes     | [`symphonia-codec-vorbis`] |\n| WavPack                      | -         | -       | `wavpack`    | Yes     | `symphonia-codec-wavpack`  |\n\nA `symphonia-bundle-*` package is a combination of a decoder and a native demuxer.\n\n[`symphonia-codec-aac`]: https://docs.rs/symphonia-codec-aac\n[`symphonia-codec-adpcm`]: https://docs.rs/symphonia-codec-adpcm\n[`symphonia-codec-alac`]: https://docs.rs/symphonia-codec-alac\n[`symphonia-bundle-flac`]: https://docs.rs/symphonia-bundle-flac\n[`symphonia-bundle-mp3`]: https://docs.rs/symphonia-bundle-mp3\n[`symphonia-codec-pcm`]: https://docs.rs/symphonia-codec-pcm\n[`symphonia-codec-vorbis`]: https://docs.rs/symphonia-codec-vorbis\n\n> **Tip:** All codecs can be enabled with the `all-codecs` feature flag. Similarly, all MPEG audio codecs can be enabled with the `mpa` feature flag.\n\n### Tags (Readers)\n\nAll metadata readers are provided by the `symphonia-metadata` crate.\n\n| Format                | Status    |\n|-----------------------|-----------|\n| ID3v1                 | Great     |\n| ID3v2                 | Great     |\n| ISO/MP4               | Great     |\n| RIFF                  | Great     |\n| Vorbis comment (FLAC) | Perfect   |\n| Vorbis comment (OGG)  | Perfect   |\n\n## Quality\n\nIn addition to the safety guarantees afforded by Rust, Symphonia aims to:\n\n* Decode media as correctly as the leading free-and-open-source software decoders\n* Prevent denial-of-service attacks\n* Be fuzz-tested\n* Provide a powerful, consistent, and easy to use API\n\n## Performance\n\nSymphonia aims to be comparable to, or faster than, popular open-source C-based implementations. Currently, Symphonia's decoders are generally +/-15% the performance of FFMpeg. However, the exact range will depend strongly on the codec, which features of the codec are being leveraged in the encoding, the Rust compiler version, and the CPU architecture being compiled for.\n\nSee the [benchmarks](https://github.com/pdeljanov/Symphonia/blob/master/BENCHMARKS.md) for more information.\n\n### Optimizations\n\nAt this time, SIMD optimizations are not enabled by default. Enabling any SIMD support feature flags will pull in the `rustfft` dependency.\n\n| Instruction Set | Feature Flag    | Default |\n|-----------------|-----------------|---------|\n| SSE             | `opt-simd-sse`  | No      |\n| AVX             | `opt-simd-avx`  | No      |\n| Neon            | `opt-simd-neon` | No      |\n\n> **Tip:** All SIMD optimizations can be enabled with the `opt-simd` feature flag.\n\n## Examples\n\nBasic usage examples may be found [`here`](https://github.com/pdeljanov/Symphonia/tree/master/symphonia/examples).\n\nFor a more complete application, see [`symphonia-play`](https://github.com/pdeljanov/Symphonia/tree/master/symphonia-play), a simple music player.\n\n## Tools\n\nSymphonia provides the following tools for debugging purposes:\n\n* [`symphonia-play`](https://github.com/pdeljanov/Symphonia/tree/master/symphonia-play) for probing, decoding, validating, and playing back media streams.\n* [`symphonia-check`](https://github.com/pdeljanov/Symphonia/tree/master/symphonia-check) for validating Symphonia's decoded output against various decoders.\n\n## Author\n\nThe primary author is Philip Deljanov.\n\n## Special Thanks\n\n* Kostya Shishkov (AAC-LC decoder contribution, see `symphonia-codec-aac`)\n\n## License\n\nSymphonia is provided under the MPL v2.0 license. Please refer to the LICENSE file for more details.\n\n## Contributing\n\nSymphonia is a free and open-source project that welcomes contributions! To get started, please read our [Contribution Guidelines](CONTRIBUTING.md).\n"
        },
        {
          "name": "benchtest",
          "type": "tree",
          "content": null
        },
        {
          "name": "clippy.toml",
          "type": "blob",
          "size": 1.7119140625,
          "content": "# The following lints are ALLOWED in all Symphonia crates.\n#\n# --------------------------------------------------------------------------------------------------\n#\n# Lint:\n#   clippy::manual_range_contains\n#\n# Justification:\n#   Where possible, expressing an algorithm as closely as possible to the specification is\n#   preferrable. Rewriting using range syntax provides marginal benefit, but could be confusing.\n#\n# --------------------------------------------------------------------------------------------------\n#\n# Lint:\n#   clippy::comparison_chain\n#\n# Justification:\n#   There is a performance penalty associated with the recommended idiom.\n#\n# --------------------------------------------------------------------------------------------------\n#\n# Lint:\n#   clippy::excessive_precision\n#\n# Justification:\n#   Floating point constants provided by specifications and papers often provide extra digits that\n#   are truncated when using 32-bit floating point airthmetic. By keeping this precision, we can use\n#   the values provided directly & without modification, and, when investigating accuracy issues,\n#   we can easily switch to 64-bit floating point arithmetic and benefit from the higher precision.\n#\n# --------------------------------------------------------------------------------------------------\n#\n# Lint:\n#   clippy::identity_op\n#\n# Justification:\n#   Sometimes the base or initial case of an unrolled multi-iteration/step mathematical expression\n#   contains operations that are otherwise no-ops. Disable the warning for these expressions because\n#   they're instructive to the reader and improve the code aesthetics.\n#\n# --------------------------------------------------------------------------------------------------\nmsrv = \"1.53\""
        },
        {
          "name": "rustfmt.toml",
          "type": "blob",
          "size": 0.3681640625,
          "content": "# The following rustfmt.toml requires the Nightly toolchain. Please DO NOT run with the Stable\n# toolchain.\n\n# Stable Features\nmax_width = 100\nuse_small_heuristics = \"Max\"\nhard_tabs = false\ntab_spaces = 4\nnewline_style = \"Unix\"\n\n# Unstable Features (requires Nightly)\nunstable_features = true\ncontrol_brace_style = \"ClosingNextLine\"\n# wrap_comments = true\n# comment_width = 100"
        },
        {
          "name": "symphonia-bundle-flac",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-bundle-mp3",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-check",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-aac",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-adpcm",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-alac",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-opus",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-pcm",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-vorbis",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-codec-wavpack",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-core",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-format-caf",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-format-isomp4",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-format-mkv",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-format-ogg",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-format-riff",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-format-wav",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-metadata",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-play",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia-utils-xiph",
          "type": "tree",
          "content": null
        },
        {
          "name": "symphonia",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}