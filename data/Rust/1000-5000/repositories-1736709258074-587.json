{
  "metadata": {
    "timestamp": 1736709258074,
    "page": 587,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fabianlindfors/reshape",
      "stars": 1735,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.017578125,
          "content": "/target\nCargo.lock"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0185546875,
          "content": "/target\nCargo.lock\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.783203125,
          "content": "[package]\nname = \"reshape\"\nversion = \"0.7.0\"\ndescription = \"An easy-to-use, zero-downtime schema migration tool for Postgres\"\nhomepage = \"https://github.com/fabianlindfors/reshape\"\ndocumentation = \"https://github.com/fabianlindfors/reshape\"\nrepository = \"https://github.com/fabianlindfors/reshape\"\nlicense = \"MIT\"\nkeywords = [\"postgres\", \"migrations\"]\nedition = \"2021\"\nauthors = [\"Fabian Lindfors\"]\nrust-version = \"1.70\"\n\n[dependencies]\npostgres = { version = \"0.19.2\", features = [\"with-serde_json-1\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\ntypetag = \"0.1.7\"\nanyhow = { version = \"1.0.44\", features = [\"backtrace\"] }\nclap = { version = \"3.1.9\", features = [\"derive\"] }\ntoml = \"0.5\"\nversion = \"3.0.0\"\ncolored = \"2\"\nrand = \"0.8\"\ndotenv = \"0.15.0\"\nlexical-sort = \"0.3.1\"\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.236328125,
          "content": "FROM rust:1.70.0 AS builder\nWORKDIR /usr/src/reshape\nCOPY . .\nRUN cargo build --release\n\nFROM debian:bullseye AS runtime\nWORKDIR /usr/share/app\nCOPY --from=builder /usr/src/reshape/target/release/reshape /usr/local/bin/reshape\nCMD [\"reshape\"]"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2022 Fabian Lindfors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.7392578125,
          "content": "# Reshape\n\n[![Test status badge](https://github.com/fabianlindfors/Reshape/actions/workflows/test.yaml/badge.svg)](https://github.com/fabianlindfors/reshape/actions/workflows/test.yaml) [![Latest release](https://shields.io/github/v/release/fabianlindfors/reshape?display_name=tag&sort=semver&color=blue)](https://github.com/fabianlindfors/reshape/releases)\n\n> Also check out [ReshapeDB](https://reshapedb.com), a new database built from the ground up to make zero-downtime schema and data migrations as simple and safe as possible. If you'd like to chat about it, please [reach out](contact@reshapedb.com)!\n\nReshape is an easy-to-use, zero-downtime schema migration tool for Postgres. It automatically handles complex migrations that would normally require downtime or manual multi-step changes. During a migration, Reshape ensures both the old and new schema are available at the same time, allowing you to gradually roll out your application. It will also perform all changes without excessive locking, avoiding downtime caused by blocking other queries. For a more thorough introduction to Reshape, check out the [introductory blog post](https://fabianlindfors.se/blog/schema-migrations-in-postgres-using-reshape/).\n\nDesigned for Postgres 12 and later.\n\n- [How it works](#how-it-works)\n- [Getting started](#getting-started)\n  - [Installation](#installation)\n  - [Creating your first migration](#creating-your-first-migration)\n  - [Preparing your application](#preparing-your-application)\n  - [Running your migration](#running-your-migration)\n  - [Using during development](#using-during-development)\n- [Writing migrations](#writing-migrations)\n  - [Basics](#basics)\n  - [Tables](#tables)\n    - [Create table](#create-table)\n    - [Rename table](#rename-table)\n    - [Remove table](#remove-table)\n    - [Add foreign key](#add-foreign-key)\n    - [Remove foreign key](#remove-foreign-key)\n  - [Columns](#columns)\n    - [Add column](#add-column)\n    - [Alter column](#alter-column)\n    - [Remove column](#remove-column)\n  - [Indices](#indices)\n    - [Add index](#add-index)\n    - [Remove index](#remove-index)\n  - [Enums](#enums)\n    - [Create enum](#create-enum)\n    - [Remove enum](#remove-enum)\n  - [Custom](#custom)\n  - [Complex changes across tables](#complex-changes-across-tables)\n- [Commands and options](#commands-and-options)\n  - [`reshape migration start`](#reshape-migration-start)\n  - [`reshape migration complete`](#reshape-migration-complete)\n  - [`reshape migration abort`](#reshape-migration-abort)\n  - [`reshape schema-query`](#reshape-schema-query)\n  - [Connection options](#connection-options)\n- [License](#license)\n\n## How it works\n\nReshape works by creating views that encapsulate the underlying tables, which your application will interact with. During a migration, Reshape will automatically create a new set of views and set up triggers to translate inserts and updates between the old and new schema. This means that every deployment is a three-phase process:\n\n1. **Start migration** (`reshape migration start`): Sets up views and triggers to ensure both the new and old schema are usable at the same time.\n2. **Roll out application**: Your application can be gradually rolled out without downtime. The existing deployment will continue using the old schema whilst the new deployment uses the new schema.\n3. **Complete migration** (`reshape migration complete`): Removes the old schema and any intermediate data and triggers.\n\nIf the application deployment fails, you should run `reshape migration abort` which will roll back any changes made by `reshape migration start` without losing data.\n\n## Getting started\n\n### Installation\n\n#### Binaries\n\nBinaries are available for macOS and Linux under [Releases](https://github.com/fabianlindfors/reshape/releases).\n\n#### Cargo\n\nReshape can be installed using [Cargo](https://doc.rust-lang.org/cargo/) (requires Rust 1.58 or later):\n\n```shell\ncargo install reshape\n```\n\n#### Docker\n\nReshape is available as a Docker image on [Docker Hub](https://hub.docker.com/repository/docker/fabianlindfors/reshape).\n\n```shell\ndocker run -v $(pwd):/usr/share/app fabianlindfors/reshape reshape migration start\n```\n\n### Creating your first migration\n\nEach migration should be stored as a separate file in a `migrations/` directory. The files can be in either JSON or TOML format and the name of the file will become the name of your migration. We recommend prefixing every migration with an incrementing number as migrations are sorted by file name.\n\nLet's create a simple migration to set up a new table `users` with two fields, `id` and `name`. We'll create a file called `migrations/1_create_users_table.toml`:\n\n```toml\n[[actions]]\ntype = \"create_table\"\nname = \"users\"\nprimary_key = [\"id\"]\n\n\t[[actions.columns]]\n\tname = \"id\"\n\ttype = \"INTEGER\"\n\tgenerated = \"ALWAYS AS IDENTITY\"\n\n\t[[actions.columns]]\n\tname = \"name\"\n\ttype = \"TEXT\"\n```\n\nThis is the equivalent of running `CREATE TABLE users (id INTEGER GENERATED ALWAYS AS IDENTITY, name TEXT)`.\n\n### Preparing your application\n\nReshape relies on your application using a specific schema. When establishing the connection to Postgres in your application, you need to run a query to select the most recent schema. The simplest way to do this is to use one of the helper libraries:\n\n- [Rust](https://github.com/fabianlindfors/reshape-helper)\n- [Ruby (and Rails)](https://github.com/fabianlindfors/reshape-ruby)\n- [Python (and Django)](https://github.com/fabianlindfors/reshape-python)\n- [Go](https://github.com/leourbina/reshape-helper)\n\nIf your application is not using one of the languages with an available helper library, you can instead generate the query with the command: `reshape schema-query`. To pass it along to your application, you can for example use an environment variable in your run script: `RESHAPE_SCHEMA_QUERY=$(reshape schema-query)`. Then in your application:\n\n```python\n# Example for Python\nreshape_schema_query = os.getenv(\"RESHAPE_SCHEMA_QUERY\")\ndb.execute(reshape_schema_query)\n```\n\n### Running your migration\n\nTo create your new `users` table, run:\n\n```bash\nreshape migration start --complete\n```\n\nWe use the `--complete` flag to automatically complete the migration. During a production deployment, you should first run `reshape migration start` followed by `reshape migration complete` once your application has been fully rolled out.\n\nIf nothing else is specified, Reshape will try to connect to a Postgres database running on `localhost` using `postgres` as both username and password. See [Connection options](#connection-options) for details on how to change the connection settings.\n\n### Using during development\n\nWhen adding new migrations during development, we recommend running `reshape migration start` but skipping `reshape migration complete`. This way, the new migrations can be iterated on by updating the migration file and running `reshape migration abort` followed by `reshape migration start`.\n\n## Writing migrations\n\n### Basics\n\nEvery migration consists of one or more actions. The actions will be run sequentially. Here's an example of a migration with two actions to create two tables, `customers` and `products`:\n\n```toml\n[[actions]]\ntype = \"create_table\"\nname = \"customers\"\nprimary_key = [\"id\"]\n\n\t[[actions.columns]]\n\tname = \"id\"\n\ttype = \"INTEGER\"\n\tgenerated = \"ALWAYS AS IDENTITY\"\n\n[[actions]]\ntype = \"create_table\"\nname = \"products\"\nprimary_key = [\"sku\"]\n\n\t[[actions.columns]]\n\tname = \"sku\"\n\ttype = \"TEXT\"\n```\n\nEvery action has a `type`. The supported types are detailed below.\n\n### Tables\n\n#### Create table\n\nThe `create_table` action will create a new table with the specified columns, indices and constraints. You can optionally provide an `up` option to backfill values from an existing table.\n\n_Example: create a `customers` table with a few columns and a primary key_\n\n```toml\n[[actions]]\ntype = \"create_table\"\nname = \"customers\"\nprimary_key = [\"id\"]\n\n\t[[actions.columns]]\n\tname = \"id\"\n\ttype = \"INTEGER\"\n\tgenerated = \"ALWAYS AS IDENTITY\"\n\n\t[[actions.columns]]\n\tname = \"name\"\n\ttype = \"TEXT\"\n\n\t# Columns default to nullable\n\tnullable = false\n\n\t# default can be any valid SQL value, in this case a string literal\n\tdefault = \"'PLACEHOLDER'\"\n```\n\n_Example: create `users` and `items` tables with a foreign key between them_\n\n```toml\n[[actions]]\ntype = \"create_table\"\nname = \"users\"\nprimary_key = [\"id\"]\n\n\t[[actions.columns]]\n\tname = \"id\"\n\ttype = \"INTEGER\"\n\tgenerated = \"ALWAYS AS IDENTITY\"\n\n[[actions]]\ntype = \"create_table\"\nname = \"items\"\nprimary_key = [\"id\"]\n\n\t[[actions.columns]]\n\tname = \"id\"\n\ttype = \"INTEGER\"\n\tgenerated = \"ALWAYS AS IDENTITY\"\n\n\t[[actions.columns]]\n\tname = \"user_id\"\n\ttype = \"INTEGER\"\n\n\t[[actions.foreign_keys]]\n\tcolumns = [\"user_id\"]\n\treferenced_table = \"users\"\n\treferenced_columns = [\"id\"]\n```\n\n_Example: create `profiles` table based on existing `users` table_\n\n```toml\n[[actions]]\ntype = \"create_table\"\nname = \"profiles\"\nprimary_key = [\"user_id\"]\n\n\t[[actions.columns]]\n\tname = \"user_id\"\n\ttype = \"INTEGER\"\n\n\t[[actions.columns]]\n\tname = \"user_email\"\n\ttype = \"TEXT\"\n\n\t# Backfill from `users` table and copy `users.email` to `user_email` column\n\t# This will perform an upsert based on the primary key to avoid duplicate rows\n\t[actions.up]\n\ttable = \"users\"\n\tvalues = { user_id = \"id\", user_email = \"email\" }\n```\n\n#### Rename table\n\nThe `rename_table` action will change the name of an existing table.\n\n_Example: change name of `users` table to `customers`_\n\n```toml\n[[actions]]\ntype = \"rename_table\"\ntable = \"users\"\nnew_name = \"customers\"\n```\n\n#### Remove table\n\nThe `remove_table` action will remove an existing table.\n\n_Example: remove `users` table_\n\n```toml\n[[actions]]\ntype = \"remove_table\"\ntable = \"users\"\n```\n\n#### Add foreign key\n\nThe `add_foreign_key` action will add a foreign key between two existing tables. The migration will fail if the existing column values aren't valid references.\n\n_Example: create foreign key from `items` to `users` table_\n\n```toml\n[[actions]]\ntype = \"add_foreign_key\"\ntable = \"items\"\n\n\t[actions.foreign_key]\n\tcolumns = [\"user_id\"]\n\treferenced_table = \"users\"\n\treferenced_columns = [\"id\"]\n```\n\n#### Remove foreign key\n\nThe `remove_foreign_key` action will remove an existing foreign key. The foreign key will only be removed once the migration is completed, which means that your new application must continue to adhere to the foreign key constraint.\n\n_Example: remove foreign key `items_user_id_fkey` from `users` table_\n\n```toml\n[[actions]]\ntype = \"remove_foreign_key\"\ntable = \"items\"\nforeign_key = \"items_user_id_fkey\"\n```\n\n### Columns\n\n#### Add column\n\nThe `add_column` action will add a new column to an existing table. You can optionally provide an `up` setting. This should be an SQL expression which will be run for all existing rows to backfill the new column. `up` may also reference another table to perform cross-table migrations (see [\"Complex changes across tables\"](#complex-changes-across-tables)).\n\n_Example: add a new column `reference` to table `products`_\n\n```toml\n[[actions]]\ntype = \"add_column\"\ntable = \"products\"\n\n\t[actions.column]\n\tname = \"reference\"\n\ttype = \"INTEGER\"\n\tnullable = false\n\tdefault = \"10\"\n```\n\n_Example: replace an existing `name` column with two new columns, `first_name` and `last_name`_\n\n```toml\n[[actions]]\ntype = \"add_column\"\ntable = \"users\"\n\n# Extract the first name from the existing name column\nup = \"(STRING_TO_ARRAY(name, ' '))[1]\"\n\n\t[actions.column]\n\tname = \"first_name\"\n\ttype = \"TEXT\"\n\n\n[[actions]]\ntype = \"add_column\"\ntable = \"users\"\n\n# Extract the last name from the existing name column\nup = \"(STRING_TO_ARRAY(name, ' '))[2]\"\n\n\t[actions.column]\n\tname = \"last_name\"\n\ttype = \"TEXT\"\n\n\n[[actions]]\ntype = \"remove_column\"\ntable = \"users\"\ncolumn = \"name\"\n\n# Reconstruct name column by concatenating first and last name\ndown = \"first_name || ' ' || last_name\"\n```\n\n_Example: extract nested value from unstructured JSON `data` column to new `name` column_\n\n```toml\n[[actions]]\ntype = \"add_column\"\ntable = \"users\"\n\n# #>> '{}' converts the JSON string value to TEXT\nup = \"data['path']['to']['value'] #>> '{}'\"\n\n\t[actions.column]\n\tname = \"name\"\n\ttype = \"TEXT\"\n```\n\n_Example: duplicate `email` column from `users` to `profiles` table_\n\n```toml\n# `profiles` has `user_id` column which maps to `users.id`\n[[actions]]\ntype = \"add_column\"\ntable = \"profiles\"\n\n\t[actions.column]\n\tname = \"email\"\n\ttype = \"TEXT\"\n\tnullable = false\n\n\t# When `users` is updated in the old schema, we write the email value to `profiles`\n\t[actions.up]\n\ttable = \"users\"\n\tvalue = \"email\"\n\twhere = \"user_id = id\"\n```\n\n#### Alter column\n\nThe `alter_column` action enables many different changes to an existing column, for example renaming, changing type and changing existing values.\n\nWhen performing more complex changes than a rename, `up` and `down` should be provided. These should be SQL expressions which determine how to transform between the new and old version of the column. Inside those expressions, you can reference the current column value by the column name.\n\n_Example: rename `last_name` column on `users` table to `family_name`_\n\n```toml\n[[actions]]\ntype = \"alter_column\"\ntable = \"users\"\ncolumn = \"last_name\"\n\n\t[actions.changes]\n\tname = \"family_name\"\n```\n\n_Example: change the type of `reference` column from `INTEGER` to `TEXT`_\n\n```toml\n[[actions]]\ntype = \"alter_column\"\ntable = \"users\"\ncolumn = \"reference\"\n\nup = \"CAST(reference AS TEXT)\" # Converts from integer value to text\ndown = \"CAST(reference AS INTEGER)\" # Converts from text value to integer\n\n\t[actions.changes]\n\ttype = \"TEXT\" # Previous type was 'INTEGER'\n```\n\n_Example: increment all values of an `index` column by one_\n\n```toml\n[[actions]]\ntype = \"alter_column\"\ntable = \"users\"\ncolumn = \"index\"\n\nup = \"index + 1\" # Increment for new schema\ndown = \"index - 1\" # Decrement to revert for old schema\n\n\t[actions.changes]\n\tname = \"index\"\n```\n\n_Example: make `name` column not nullable_\n\n```toml\n[[actions]]\ntype = \"alter_column\"\ntable = \"users\"\ncolumn = \"name\"\n\n# Use \"N/A\" for any rows that currently have a NULL name\nup = \"COALESCE(name, 'N/A')\"\n\n\t[actions.changes]\n\tnullable = false\n```\n\n_Example: change default value of `created_at` column to current time_\n\n```toml\n[[actions]]\ntype = \"alter_column\"\ntable = \"users\"\ncolumn = \"created_at\"\n\n\t[actions.changes]\n\tdefault = \"NOW()\"\n```\n\n#### Remove column\n\nThe `remove_column` action will remove an existing column from a table. You can optionally provide a `down` setting. This should be an SQL expression which will be used to determine values for the old schema when inserting or updating rows using the new schema. `down` may also reference another table to perform cross-table migrations (see [\"Complex changes across tables\"](#complex-changes-across-tables)) . The `down` setting must be provided when the removed column is `NOT NULL` or doesn't have a default value.\n\nAny indices that cover the column will be removed.\n\n_Example: remove column `name` from table `users`_\n\n```toml\n[[actions]]\ntype = \"remove_column\"\ntable = \"users\"\ncolumn = \"name\"\n\n# Use a default value of \"N/A\" for the old schema when inserting/updating rows\ndown = \"'N/A'\"\n```\n\n_Example: remove `email` column from `users` table and use column from `profiles` table instead_\n\n```toml\n[[actions]]\ntype = \"remove_column\"\ntable = \"users\"\ncolumn = \"email\"\n\n\t# Our application will use the `profiles.email` column instead\n\t# For backwards compatibility, we will write back to the removed `email` column whenever `profiles` is changed\n\t[actions.down]\n\ttable = \"profiles\"\n\tvalue = \"profiles.email\"\n\twhere = \"users.id = profiles.user_id\"\n```\n\n### Indices\n\n#### Add index\n\nThe `add_index` action will add a new index to an existing table.\n\n_Example: create a `users` table with a unique index on the `name` column_\n\n```toml\n[[actions]]\ntype = \"create_table\"\nname = \"users\"\nprimary_key = \"id\"\n\n\t[[actions.columns]]\n\tname = \"id\"\n\ttype = \"INTEGER\"\n\tgenerated = \"ALWAYS AS IDENTITY\"\n\n\t[[actions.columns]]\n\tname = \"name\"\n\ttype = \"TEXT\"\n\n[[actions]]\ntype = \"add_index\"\ntable = \"users\"\n\n\t[actions.index]\n\tname = \"name_idx\"\n\tcolumns = [\"name\"]\n\n\t# Defaults to false\n\tunique = true\n```\n\n_Example: add GIN index to `data` column on `products` table_\n\n```toml\n[[actions]]\ntype = \"add_index\"\ntable = \"products\"\n\n\t[actions.index]\n\tname = \"data_idx\"\n\tcolumns = [\"data\"]\n\n\t# One of: btree (default), hash, gist, spgist, gin, brin\n\ttype = \"gin\"\n```\n\n#### Remove index\n\nThe `remove_index` action will remove an existing index. The index won't actually be removed until the migration is completed.\n\n_Example: remove the `name_idx` index_\n\n```toml\n[[actions]]\ntype = \"remove_index\"\nindex = \"name_idx\"\n```\n\n### Enums\n\n#### Create enum\n\nThe `create_enum` action will create a new [enum type](https://www.postgresql.org/docs/current/datatype-enum.html) with the specified values.\n\n_Example: add a new `mood` enum type with three possible values_\n\n```toml\n[[actions]]\ntype = \"create_enum\"\nname = \"mood\"\nvalues = [\"happy\", \"ok\", \"sad\"]\n```\n\n#### Remove enum\n\nThe `remove_enum` action will remove an existing [enum type](https://www.postgresql.org/docs/current/datatype-enum.html). Make sure all usages of the enum has been removed before running the migration. The enum will only be removed once the migration is completed.\n\n_Example: remove the `mood` enum type_\n\n```toml\n[[actions]]\ntype = \"remove_enum\"\nenum = \"mood\"\n```\n\n### Custom\n\nThe `custom` action lets you create a migration which runs custom SQL. It should be used with great care as it provides no guarantees of zero-downtime and will simply run whatever SQL is provided. Use other actions whenever possible as they are explicitly designed for zero downtime.\n\nThere are three optional settings available which all accept SQL queries. All queries need to be idempotent, for example by using `IF NOT EXISTS` wherever available.\n\n- `start`: run when a migration is started using `reshape migration start`\n- `complete`: run when a migration is completed using `reshape migration complete`\n- `abort`: run when a migration is aborted using `reshape migration abort`\n\n_Example: enable PostGIS and pg_stat_statements extensions_\n\n```toml\n[[actions]]\ntype = \"custom\"\n\nstart = \"\"\"\n\tCREATE EXTENSION IF NOT EXISTS postgis;\n\tCREATE EXTENSION IF NOT EXISTS pg_stat_statements;\n\"\"\"\n\nabort = \"\"\"\n\tDROP EXTENSION IF EXISTS postgis;\n\tDROP EXTENSION IF EXISTS pg_stat_statements;\n\"\"\"\n```\n\n### Complex changes across tables\n\nThe `up` and `down` options available when creating tables, adding columns and removing columns can also perform more complex changes that span tables.\n\n_Example: move `email` column from `users` to `profiles` table_\n\n```toml\n[[actions]]\ntype = \"add_column\"\ntable = \"profiles\"\n\n\t[actions.column]\n\tname = \"email\"\n\ttype = \"TEXT\"\n\tnullable = false\n\n\t# When `users` is updated in the old schema, we write the email value to `profiles`\n\t[actions.up]\n\ttable = \"users\"\n\tvalue = \"users.email\"\n\twhere = \"profiles.user_id = users.id\"\n\n[[actions]]\ntype = \"remove_column\"\ntable = \"users\"\ncolumn = \"email\"\n\n\t# When `profiles` is changed in the new schema, we write the email address back to the removed column\n\t[actions.down]\n\ttable = \"profiles\"\n\tvalue = \"profiles.email\"\n\twhere = \"users.id = profiles.user_id\"\n```\n\n_Example: turn a 1:N relationship between `users` and `accounts` into N:M and change the format of the associated `role`_\n\n```toml\n# Add `user_account_connections` as a junction table\n[[actions]]\ntype = \"create_table\"\nname = \"user_account_connections\"\nprimary_key = [\"account_id\", \"user_id\"]\n\n\t[[actions.columns]]\n\tname = \"account_id\"\n\ttype = \"INTEGER\"\n\n\t[[actions.columns]]\n\tname = \"user_id\"\n\ttype = \"INTEGER\"\n\n\t# `role` is currently stored directly on the `users` table but is part of the relationship\n\t[[actions.columns]]\n\tname = \"role\"\n\ttype = \"TEXT\"\n\tnullable = false\n\n\t# Backfill the new table from `users` and uppercase the `role`\n\t[actions.up]\n\ttable = \"users\"\n\tvalues = { user_id = \"id\", account_id = \"account_id\", role = \"UPPER(account_role)\" }\n\twhere = \"user_account_connections.user_id = users.id\"\n\n[[actions]]\ntype = \"remove_column\"\ntable = \"users\"\ncolumn = \"account_id\"\n\n\t# When `user_account_connections` is updated, we write the `account_id` back to `users`\n\t[actions.down]\n\ttable = \"user_account_connections\"\n\tvalue = \"user_account_connections.account_id\"\n\twhere = \"users.id = user_account_connections.user_id\"\n\n[[actions]]\ntype = \"remove_column\"\ntable = \"users\"\ncolumn = \"account_role\"\n\n\t# When `user_account_connections` is updated, we write the lowercase role back to `users`\n\t[actions.down]\n\ttable = \"user_account_connections\"\n\tvalue = \"LOWER(user_account_connections.role)\"\n\twhere = \"users.id = user_account_connections.user_id\"\n```\n\n## Commands and options\n\n### `reshape migration start`\n\nStarts a new migration, applying all migrations under `migrations/` that haven't yet been applied. After the command has completed, both the old and new schema will be usable at the same time. When you have rolled out the new version of your application which uses the new schema, you should run `reshape migration complete`.\n\n#### Options\n\n_See also [Connection options](#connection-options)_\n\n| Option             | Default       | Description                                                                                                     |\n| ------------------ | ------------- | --------------------------------------------------------------------------------------------------------------- |\n| `--complete`, `-c` | `false`       | Automatically complete migration after applying it.                                                             |\n| `--dirs`           | `migrations/` | Directories to search for migration files. Multiple directories can be specified using `--dirs dir1 dir2 dir3`. |\n\n### `reshape migration complete`\n\nCompletes migrations previously started with `reshape migration complete`.\n\n#### Options\n\nSee [Connection options](#connection-options)\n\n### `reshape migration abort`\n\nAborts any migrations which haven't yet been completed.\n\n#### Options\n\nSee [Connection options](#connection-options)\n\n### `reshape schema-query`\n\nGenerates the SQL query you need to run in your application before using the database. This command does not require a database connection. Instead it will generate the query based on the latest migration in the `migrations/` directory (or the directories specified by `--dirs`).\n\nIf your application is written in Rust, we recommend using the [Rust helper library](https://github.com/fabianlindfors/reshape-helper/) instead.\n\nThe query should look something like `SET search_path TO migration_1_initial_migration`.\n\n#### Options\n\n| Option   | Default       | Description                                                                                                     |\n| -------- | ------------- | --------------------------------------------------------------------------------------------------------------- |\n| `--dirs` | `migrations/` | Directories to search for migration files. Multiple directories can be specified using `--dirs dir1 dir2 dir3`. |\n\n### Connection options\n\nThe options below can be used with all commands that communicate with Postgres. Use either a [connection URL](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING) or specify each connection option individually.\n\nAll options can also be set using environment variables instead of flags. If a `.env` file exists, then variables will be automatically loaded from there.\n\n| Option       | Default     | Environment variable | Description                                 |\n| ------------ | ----------- | -------------------- | ------------------------------------------- |\n| `--url`      |             | `DB_URL`             | URL to your Postgres database               |\n| `--host`     | `localhost` | `DB_HOST`            | Hostname to use when connecting to Postgres |\n| `--port`     | `5432`      | `DB_PORT`            | Port which Postgres is listening on         |\n| `--database` | `postgres`  | `DB_NAME`            | Database name                               |\n| `--username` | `postgres`  | `DB_USERNAME`        | Postgres username                           |\n| `--password` | `postgres`  | `DB_PASSWORD`        | Postgres password                           |\n\n## License\n\nReshape is released under the [MIT license](https://choosealicense.com/licenses/mit/).\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}