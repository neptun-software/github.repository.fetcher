{
  "metadata": {
    "timestamp": 1736709026271,
    "page": 112,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zesterer/chumsky",
      "stars": 3715,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.072265625,
          "content": "# IDE projects\n.idea/\n\n# Project output\n/target\nflamegraph.svg\nperf.data*\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.21875,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n# Unreleased\n\n### Added\n\n### Removed\n\n### Changed\n\n### Fixed\n\n# [0.9.2] - 2023-03-02\n\n### Fixed\n\n- Properly fixed `skip_then_retry_until` regression\n\n# [0.9.1] - 2023-03-02\n\n### Fixed\n\n- Regression in `skip_then_retry_until` recovery strategy\n\n# [0.9.0] - 2023-02-07\n\n### Added\n\n- A `spill-stack` feature that uses `stacker` to avoid stack overflow errors for deeply recursive parsers\n- The ability to access the token span when using `select!` like `select! { |span| Token::Num(x) => (x, span) }`\n- Added a `skip_parser` recovery strategy that allows you to implement your own recovery strategies in terms of other\n  parsers. For example, `.recover_with(skip_parser(take_until(just(';'))))` skips tokens until after the next semicolon\n- A `not` combinator that consumes a single token if it is *not* the start of a given pattern. For example,\n  `just(\"\\\\n\").or(just('\"')).not()` matches any `char` that is not either the final quote of a string, and is not the\n  start of a newline escape sequence\n- A `semantic_indentation` parser for parsing indentation-sensitive languages. Note that this is likely to be\n  deprecated/removed in the future in favour of a more powerful solution\n- `#[must_use]` attribute for parsers to ensure that they're not accidentally created without being used\n- `Option<Vec<T>>` and `Vec<Option<T>>` now implement `Chain<T>` and `Option<String>` implements `Chain<char>`\n- `choice` now supports both arrays and vectors of parsers in addition to tuples\n- The `Simple` error type now implements `Eq`\n\n### Changed\n\n- `text::whitespace` returns a `Repeated` instead of an `impl Parser`, allowing you to call methods like `at_least` and\n  `exactly` on it.\n- Improved `no_std` support\n- Improved examples and documentation\n- Use zero-width spans for EoI by default\n- Don't allow defining a recursive parser more than once\n- Various minor bug fixes\n- Improved `Display` implementations for various built-in error types and `SimpleReason`\n- Use an `OrderedContainer` trait to avoid unexpected behaviour for unordered containers in combination with `just`\n\n### Fixed\n\n- Made several parsers (`todo`, `unwrapped`, etc.) more useful by reporting the parser's location on panic\n- Boxing a parser that is already boxed just gives you the original parser to avoid double indirection\n- Improved compilation speeds\n\n# [0.8.0] - 2022-02-07\n\n### Added\n\n- `then_with` combinator to allow limited support for parsing nested patterns\n- impl From<&[T; N]> for Stream\n- `SkipUntil/SkipThenRetryUntil::skip_start/consume_end` for more precise control over skip-based recovery\n\n### Changed\n\n- Allowed `Validate` to map the output type\n- Switched to zero-size End Of Input spans for default implementations of `Stream`\n- Made `delimited_by` take combinators instead of specific tokens\n- Minor optimisations\n- Documentation improvements\n\n### Fixed\n\n- Compilation error with `--no-default-features`\n- Made default behaviour of `skip_until` more sensible\n\n# [0.7.0] - 2021-12-16\n\n### Added\n\n- A new [tutorial](tutorial.md) to help new users\n\n- `select` macro, a wrapper over `filter_map` that makes extracting data from specific tokens easy\n- `choice` parser, a better alternative to long `or` chains (which sometimes have poor compilation performance)\n- `todo` parser, that panics when used (but not when created) (akin to Rust's `todo!` macro, but for parsers)\n- `keyword` parser, that parses *exact* identifiers\n\n- `from_str` combinator to allow converting a pattern to a value inline, using `std::str::FromStr`\n- `unwrapped` combinator, to automatically unwrap an output value inline\n- `rewind` combinator, that allows reverting the input stream on success. It's most useful when requiring that a\n  pattern is followed by some terminating pattern without the first parser greedily consuming it\n- `map_err_with_span` combinator, to allow fetching the span of the input that was parsed by a parser before an error\n  was encountered\n\n- `or_else` combinator, to allow processing and potentially recovering from a parser error\n- `SeparatedBy::at_most` to require that a separated pattern appear at most a specific number of times\n- `SeparatedBy::exactly` to require that a separated pattern be repeated exactly a specific number of times\n- `Repeated::exactly` to require that a pattern be repeated exactly a specific number of times\n\n- More trait implementations for various things, making the crate more useful\n\n### Changed\n\n- Made `just`, `one_of`, and `none_of` significant more useful. They can now accept strings, arrays, slices, vectors,\n  sets, or just single tokens as before\n- Added the return type of each parser to its documentation\n- More explicit documentation of parser behaviour\n- More doc examples\n- Deprecated `seq` (`just` has been generalised and can now be used to parse specific input sequences)\n- Sealed the `Character` trait so that future changes are not breaking\n- Sealed the `Chain` trait and made it more powerful\n- Moved trait constraints on `Parser` to where clauses for improved readability\n\n### Fixed\n\n- Fixed a subtle bug that allowed `separated_by` to parse an extra trailing separator when it shouldn't\n- Filled a 'hole' in the `Error` trait's API that conflated a lack of expected tokens with expectation of end of input\n- Made recursive parsers use weak reference-counting to avoid memory leaks\n\n# [0.6.0] - 2021-11-22\n\n### Added\n\n- `skip_until` error recovery strategy\n- `SeparatedBy::at_least` and `SeparatedBy::at_most` for parsing a specific number of separated items\n- `Parser::validate` for integrated AST validation\n- `Recursive::declare` and `Recursive::define` for more precise control over recursive declarations\n\n### Changed\n\n- Improved `separated_by` error messages\n- Improved documentation\n- Hid a new (probably) unused implementation details\n\n# [0.5.0] - 2021-10-30\n\n### Added\n\n- `take_until` primitive\n\n### Changed\n\n- Added span to fallback output function in `nested_delimiters`\n\n# [0.4.0] - 2021-10-28\n\n### Added\n\n- Support for LL(k) parsing\n- Custom error recovery strategies\n- Debug mode\n- Nested input flattening\n\n### Changed\n\n- Radically improved error quality\n"
        },
        {
          "name": "Cargo.lock",
          "type": "blob",
          "size": 60.939453125,
          "content": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"addr2line\"\nversion = \"0.22.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678\"\ndependencies = [\n \"gimli\",\n]\n\n[[package]]\nname = \"adler\"\nversion = \"1.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n\n[[package]]\nname = \"adler2\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627\"\n\n[[package]]\nname = \"ahash\"\nversion = \"0.8.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011\"\ndependencies = [\n \"cfg-if\",\n \"getrandom\",\n \"once_cell\",\n \"version_check\",\n \"zerocopy\",\n]\n\n[[package]]\nname = \"aho-corasick\"\nversion = \"1.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"allocator-api2\"\nversion = \"0.2.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f\"\n\n[[package]]\nname = \"anes\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299\"\n\n[[package]]\nname = \"anyhow\"\nversion = \"1.0.86\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b3d1d046238990b9cf5bcde22a3fb3584ee5cf65fb2765f454ed428c7a0063da\"\n\n[[package]]\nname = \"arc-swap\"\nversion = \"1.7.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457\"\n\n[[package]]\nname = \"ariadne\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"367fd0ad87307588d087544707bc5fbf4805ded96c7db922b70d368fa1cb5702\"\ndependencies = [\n \"unicode-width\",\n \"yansi\",\n]\n\n[[package]]\nname = \"arrayvec\"\nversion = \"0.7.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50\"\n\n[[package]]\nname = \"atty\"\nversion = \"0.2.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\ndependencies = [\n \"hermit-abi 0.1.19\",\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0\"\n\n[[package]]\nname = \"backtrace\"\nversion = \"0.3.73\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a\"\ndependencies = [\n \"addr2line\",\n \"cc\",\n \"cfg-if\",\n \"libc\",\n \"miniz_oxide 0.7.4\",\n \"object\",\n \"rustc-demangle\",\n]\n\n[[package]]\nname = \"beef\"\nversion = \"0.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3a8241f3ebb85c056b509d4327ad0358fbbba6ffb340bf388f26350aeda225b1\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"2.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de\"\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"bstr\"\nversion = \"1.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"40723b8fb387abc38f4f4a37c09073622e41dd12327033091ef8950659e6dc0c\"\ndependencies = [\n \"memchr\",\n \"regex-automata 0.4.7\",\n \"serde\",\n]\n\n[[package]]\nname = \"bumpalo\"\nversion = \"3.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c\"\n\n[[package]]\nname = \"bytemuck\"\nversion = \"1.17.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"773d90827bc3feecfb67fab12e24de0749aad83c74b9504ecde46237b5cd24e2\"\n\n[[package]]\nname = \"cast\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5\"\n\n[[package]]\nname = \"cc\"\nversion = \"1.1.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"57b6a275aa2903740dc87da01c62040406b8812552e97129a63ea8850a17c6e6\"\ndependencies = [\n \"shlex\",\n]\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"chumsky\"\nversion = \"1.0.0-alpha.7\"\ndependencies = [\n \"ariadne\",\n \"ciborium\",\n \"criterion\",\n \"either\",\n \"hashbrown 0.15.1\",\n \"lasso\",\n \"lexical\",\n \"logos\",\n \"nom\",\n \"pest\",\n \"pest_derive\",\n \"pom\",\n \"pprof\",\n \"regex-automata 0.3.9\",\n \"serde\",\n \"serde_json\",\n \"slotmap\",\n \"sn\",\n \"spin\",\n \"stacker\",\n \"unicode-ident\",\n \"unicode-segmentation\",\n \"vergen-gix\",\n \"winnow\",\n]\n\n[[package]]\nname = \"ciborium\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42e69ffd6f0917f5c029256a24d0161db17cea3997d185db0d35926308770f0e\"\ndependencies = [\n \"ciborium-io\",\n \"ciborium-ll\",\n \"serde\",\n]\n\n[[package]]\nname = \"ciborium-io\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05afea1e0a06c9be33d539b876f1ce3692f4afea2cb41f740e7743225ed1c757\"\n\n[[package]]\nname = \"ciborium-ll\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"57663b653d948a338bfb3eeba9bb2fd5fcfaecb9e199e87e1eda4d9e8b240fd9\"\ndependencies = [\n \"ciborium-io\",\n \"half\",\n]\n\n[[package]]\nname = \"clap\"\nversion = \"3.2.25\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4ea181bf566f71cb9a5d17a59e1871af638180a18fb0035c92ae62b705207123\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"clap_lex\",\n \"indexmap 1.9.3\",\n \"textwrap\",\n]\n\n[[package]]\nname = \"clap_lex\"\nversion = \"0.2.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2850f2f5a82cbf437dd5af4d49848fbdfc27c157c3d010345776f952765261c5\"\ndependencies = [\n \"os_str_bytes\",\n]\n\n[[package]]\nname = \"clru\"\nversion = \"0.6.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cbd0f76e066e64fdc5631e3bb46381254deab9ef1158292f27c8c57e3bf3fe59\"\n\n[[package]]\nname = \"cpp_demangle\"\nversion = \"0.4.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96e58d342ad113c2b878f16d5d034c03be492ae460cdbc02b7f0f2284d310c7d\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"51e852e6dc9a5bed1fae92dd2375037bf2b768725bf3be87811edee3249d09ad\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crc32fast\"\nversion = \"1.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"criterion\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e7c76e09c1aae2bc52b3d2f29e13c6572553b30c4aa1b8a49fd70de6412654cb\"\ndependencies = [\n \"anes\",\n \"atty\",\n \"cast\",\n \"ciborium\",\n \"clap\",\n \"criterion-plot\",\n \"itertools\",\n \"lazy_static\",\n \"num-traits\",\n \"oorandom\",\n \"plotters\",\n \"rayon\",\n \"regex\",\n \"serde\",\n \"serde_derive\",\n \"serde_json\",\n \"tinytemplate\",\n \"walkdir\",\n]\n\n[[package]]\nname = \"criterion-plot\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6b50826342786a51a89e2da3a28f1c32b06e387201bc2d19791f622c673706b1\"\ndependencies = [\n \"cast\",\n \"itertools\",\n]\n\n[[package]]\nname = \"crossbeam-deque\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d\"\ndependencies = [\n \"crossbeam-epoch\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-epoch\"\nversion = \"0.9.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e\"\ndependencies = [\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-utils\"\nversion = \"0.8.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80\"\n\n[[package]]\nname = \"crunchy\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7\"\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"darling\"\nversion = \"0.20.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6f63b86c8a8826a49b8c21f08a2d07338eec8d900540f8630dc76284be802989\"\ndependencies = [\n \"darling_core\",\n \"darling_macro\",\n]\n\n[[package]]\nname = \"darling_core\"\nversion = \"0.20.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"95133861a8032aaea082871032f5815eb9e98cef03fa916ab4500513994df9e5\"\ndependencies = [\n \"fnv\",\n \"ident_case\",\n \"proc-macro2\",\n \"quote\",\n \"strsim\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"darling_macro\"\nversion = \"0.20.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d336a2a514f6ccccaa3e09b02d41d35330c07ddf03a62165fcec10bb561c7806\"\ndependencies = [\n \"darling_core\",\n \"quote\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"debugid\"\nversion = \"0.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef552e6f588e446098f6ba40d89ac146c8c7b64aade83c051ee00bb5d2bc18d\"\ndependencies = [\n \"uuid\",\n]\n\n[[package]]\nname = \"deranged\"\nversion = \"0.3.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4\"\ndependencies = [\n \"powerfmt\",\n]\n\n[[package]]\nname = \"derive_builder\"\nversion = \"0.20.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cd33f37ee6a119146a1781d3356a7c26028f83d779b2e04ecd45fdc75c76877b\"\ndependencies = [\n \"derive_builder_macro\",\n]\n\n[[package]]\nname = \"derive_builder_core\"\nversion = \"0.20.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7431fa049613920234f22c47fdc33e6cf3ee83067091ea4277a3f8c4587aae38\"\ndependencies = [\n \"darling\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"derive_builder_macro\"\nversion = \"0.20.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4abae7035bf79b9877b779505d8cf3749285b80c43941eda66604841889451dc\"\ndependencies = [\n \"derive_builder_core\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n]\n\n[[package]]\nname = \"dunce\"\nversion = \"1.0.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813\"\n\n[[package]]\nname = \"either\"\nversion = \"1.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0\"\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5\"\n\n[[package]]\nname = \"errno\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba\"\ndependencies = [\n \"libc\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"faster-hex\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2a2b11eda1d40935b26cf18f6833c526845ae8c41e58d09af6adeb6f0269183\"\n\n[[package]]\nname = \"fastrand\"\nversion = \"2.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e8c02a5121d4ea3eb16a80748c74f5549a5665e4c21333c6098f283870fbdea6\"\n\n[[package]]\nname = \"filetime\"\nversion = \"0.2.25\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"libredox\",\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"findshlibs\"\nversion = \"0.10.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"40b9e59cd0f7e0806cca4be089683ecb6434e602038df21fe6bf6711b2f07f64\"\ndependencies = [\n \"cc\",\n \"lazy_static\",\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"flate2\"\nversion = \"1.0.33\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"324a1be68054ef05ad64b861cc9eaf1d623d2d8cb25b4bf2cb9cdd902b4bf253\"\ndependencies = [\n \"crc32fast\",\n \"miniz_oxide 0.8.0\",\n]\n\n[[package]]\nname = \"fnv\"\nversion = \"1.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n\n[[package]]\nname = \"foldhash\"\nversion = \"0.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f81ec6369c545a7d40e4589b5597581fa1c441fe1cce96dd1de43159910a36a2\"\n\n[[package]]\nname = \"form_urlencoded\"\nversion = \"1.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456\"\ndependencies = [\n \"percent-encoding\",\n]\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"getset\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e45727250e75cc04ff2846a66397da8ef2b3db8e40e0cef4df67950a07621eb9\"\ndependencies = [\n \"proc-macro-error\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"gimli\"\nversion = \"0.29.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd\"\n\n[[package]]\nname = \"gix\"\nversion = \"0.63.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"984c5018adfa7a4536ade67990b3ebc6e11ab57b3d6cd9968de0947ca99b4b06\"\ndependencies = [\n \"gix-actor\",\n \"gix-commitgraph\",\n \"gix-config\",\n \"gix-date\",\n \"gix-diff\",\n \"gix-discover\",\n \"gix-features\",\n \"gix-fs\",\n \"gix-glob\",\n \"gix-hash\",\n \"gix-hashtable\",\n \"gix-index\",\n \"gix-lock\",\n \"gix-macros\",\n \"gix-object\",\n \"gix-odb\",\n \"gix-pack\",\n \"gix-path\",\n \"gix-ref\",\n \"gix-refspec\",\n \"gix-revision\",\n \"gix-revwalk\",\n \"gix-sec\",\n \"gix-tempfile\",\n \"gix-trace\",\n \"gix-traverse\",\n \"gix-url\",\n \"gix-utils\",\n \"gix-validate\",\n \"once_cell\",\n \"parking_lot\",\n \"signal-hook\",\n \"smallvec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-actor\"\nversion = \"0.31.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a0e454357e34b833cc3a00b6efbbd3dd4d18b24b9fb0c023876ec2645e8aa3f2\"\ndependencies = [\n \"bstr\",\n \"gix-date\",\n \"gix-utils\",\n \"itoa\",\n \"thiserror\",\n \"winnow\",\n]\n\n[[package]]\nname = \"gix-bitmap\"\nversion = \"0.2.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a371db66cbd4e13f0ed9dc4c0fea712d7276805fccc877f77e96374d317e87ae\"\ndependencies = [\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-chunk\"\nversion = \"0.4.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"45c8751169961ba7640b513c3b24af61aa962c967aaf04116734975cd5af0c52\"\ndependencies = [\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-commitgraph\"\nversion = \"0.24.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"133b06f67f565836ec0c473e2116a60fb74f80b6435e21d88013ac0e3c60fc78\"\ndependencies = [\n \"bstr\",\n \"gix-chunk\",\n \"gix-features\",\n \"gix-hash\",\n \"memmap2 0.9.4\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-config\"\nversion = \"0.37.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"53fafe42957e11d98e354a66b6bd70aeea00faf2f62dd11164188224a507c840\"\ndependencies = [\n \"bstr\",\n \"gix-config-value\",\n \"gix-features\",\n \"gix-glob\",\n \"gix-path\",\n \"gix-ref\",\n \"gix-sec\",\n \"memchr\",\n \"once_cell\",\n \"smallvec\",\n \"thiserror\",\n \"unicode-bom\",\n \"winnow\",\n]\n\n[[package]]\nname = \"gix-config-value\"\nversion = \"0.14.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"03f76169faa0dec598eac60f83d7fcdd739ec16596eca8fb144c88973dbe6f8c\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"bstr\",\n \"gix-path\",\n \"libc\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-date\"\nversion = \"0.8.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9eed6931f21491ee0aeb922751bd7ec97b4b2fe8fbfedcb678e2a2dce5f3b8c0\"\ndependencies = [\n \"bstr\",\n \"itoa\",\n \"thiserror\",\n \"time\",\n]\n\n[[package]]\nname = \"gix-diff\"\nversion = \"0.44.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1996d5c8a305b59709467d80617c9fde48d9d75fd1f4179ea970912630886c9d\"\ndependencies = [\n \"bstr\",\n \"gix-hash\",\n \"gix-object\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-discover\"\nversion = \"0.32.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fc27c699b63da66b50d50c00668bc0b7e90c3a382ef302865e891559935f3dbf\"\ndependencies = [\n \"bstr\",\n \"dunce\",\n \"gix-fs\",\n \"gix-hash\",\n \"gix-path\",\n \"gix-ref\",\n \"gix-sec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-features\"\nversion = \"0.38.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac7045ac9fe5f9c727f38799d002a7ed3583cd777e3322a7c4b43e3cf437dc69\"\ndependencies = [\n \"crc32fast\",\n \"flate2\",\n \"gix-hash\",\n \"gix-trace\",\n \"gix-utils\",\n \"libc\",\n \"once_cell\",\n \"prodash\",\n \"sha1_smol\",\n \"thiserror\",\n \"walkdir\",\n]\n\n[[package]]\nname = \"gix-fs\"\nversion = \"0.11.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f2bfe6249cfea6d0c0e0990d5226a4cb36f030444ba9e35e0639275db8f98575\"\ndependencies = [\n \"fastrand\",\n \"gix-features\",\n \"gix-utils\",\n]\n\n[[package]]\nname = \"gix-glob\"\nversion = \"0.16.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"74908b4bbc0a0a40852737e5d7889f676f081e340d5451a16e5b4c50d592f111\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"bstr\",\n \"gix-features\",\n \"gix-path\",\n]\n\n[[package]]\nname = \"gix-hash\"\nversion = \"0.14.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f93d7df7366121b5018f947a04d37f034717e113dcf9ccd85c34b58e57a74d5e\"\ndependencies = [\n \"faster-hex\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-hashtable\"\nversion = \"0.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7ddf80e16f3c19ac06ce415a38b8591993d3f73aede049cb561becb5b3a8e242\"\ndependencies = [\n \"gix-hash\",\n \"hashbrown 0.14.5\",\n \"parking_lot\",\n]\n\n[[package]]\nname = \"gix-index\"\nversion = \"0.33.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9a9a44eb55bd84bb48f8a44980e951968ced21e171b22d115d1cdcef82a7d73f\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"bstr\",\n \"filetime\",\n \"fnv\",\n \"gix-bitmap\",\n \"gix-features\",\n \"gix-fs\",\n \"gix-hash\",\n \"gix-lock\",\n \"gix-object\",\n \"gix-traverse\",\n \"gix-utils\",\n \"gix-validate\",\n \"hashbrown 0.14.5\",\n \"itoa\",\n \"libc\",\n \"memmap2 0.9.4\",\n \"rustix\",\n \"smallvec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-lock\"\nversion = \"14.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3bc7fe297f1f4614774989c00ec8b1add59571dc9b024b4c00acb7dedd4e19d\"\ndependencies = [\n \"gix-tempfile\",\n \"gix-utils\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-macros\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"999ce923619f88194171a67fb3e6d613653b8d4d6078b529b15a765da0edcc17\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"gix-object\"\nversion = \"0.42.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"25da2f46b4e7c2fa7b413ce4dffb87f69eaf89c2057e386491f4c55cadbfe386\"\ndependencies = [\n \"bstr\",\n \"gix-actor\",\n \"gix-date\",\n \"gix-features\",\n \"gix-hash\",\n \"gix-utils\",\n \"gix-validate\",\n \"itoa\",\n \"smallvec\",\n \"thiserror\",\n \"winnow\",\n]\n\n[[package]]\nname = \"gix-odb\"\nversion = \"0.61.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"20d384fe541d93d8a3bb7d5d5ef210780d6df4f50c4e684ccba32665a5e3bc9b\"\ndependencies = [\n \"arc-swap\",\n \"gix-date\",\n \"gix-features\",\n \"gix-fs\",\n \"gix-hash\",\n \"gix-object\",\n \"gix-pack\",\n \"gix-path\",\n \"gix-quote\",\n \"parking_lot\",\n \"tempfile\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-pack\"\nversion = \"0.51.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e0594491fffe55df94ba1c111a6566b7f56b3f8d2e1efc750e77d572f5f5229\"\ndependencies = [\n \"clru\",\n \"gix-chunk\",\n \"gix-features\",\n \"gix-hash\",\n \"gix-hashtable\",\n \"gix-object\",\n \"gix-path\",\n \"memmap2 0.9.4\",\n \"smallvec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-path\"\nversion = \"0.10.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"38d5b8722112fa2fa87135298780bc833b0e9f6c56cc82795d209804b3a03484\"\ndependencies = [\n \"bstr\",\n \"gix-trace\",\n \"home\",\n \"once_cell\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-quote\"\nversion = \"0.4.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cbff4f9b9ea3fa7a25a70ee62f545143abef624ac6aa5884344e70c8b0a1d9ff\"\ndependencies = [\n \"bstr\",\n \"gix-utils\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-ref\"\nversion = \"0.44.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3394a2997e5bc6b22ebc1e1a87b41eeefbcfcff3dbfa7c4bd73cb0ac8f1f3e2e\"\ndependencies = [\n \"gix-actor\",\n \"gix-date\",\n \"gix-features\",\n \"gix-fs\",\n \"gix-hash\",\n \"gix-lock\",\n \"gix-object\",\n \"gix-path\",\n \"gix-tempfile\",\n \"gix-utils\",\n \"gix-validate\",\n \"memmap2 0.9.4\",\n \"thiserror\",\n \"winnow\",\n]\n\n[[package]]\nname = \"gix-refspec\"\nversion = \"0.23.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6868f8cd2e62555d1f7c78b784bece43ace40dd2a462daf3b588d5416e603f37\"\ndependencies = [\n \"bstr\",\n \"gix-hash\",\n \"gix-revision\",\n \"gix-validate\",\n \"smallvec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-revision\"\nversion = \"0.27.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"01b13e43c2118c4b0537ddac7d0821ae0dfa90b7b8dbf20c711e153fb749adce\"\ndependencies = [\n \"bstr\",\n \"gix-date\",\n \"gix-hash\",\n \"gix-hashtable\",\n \"gix-object\",\n \"gix-revwalk\",\n \"gix-trace\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-revwalk\"\nversion = \"0.13.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b030ccaab71af141f537e0225f19b9e74f25fefdba0372246b844491cab43e0\"\ndependencies = [\n \"gix-commitgraph\",\n \"gix-date\",\n \"gix-hash\",\n \"gix-hashtable\",\n \"gix-object\",\n \"smallvec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-sec\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0fe4d52f30a737bbece5276fab5d3a8b276dc2650df963e293d0673be34e7a5f\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"gix-path\",\n \"libc\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"gix-tempfile\"\nversion = \"14.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"046b4927969fa816a150a0cda2e62c80016fe11fb3c3184e4dddf4e542f108aa\"\ndependencies = [\n \"gix-fs\",\n \"libc\",\n \"once_cell\",\n \"parking_lot\",\n \"signal-hook\",\n \"signal-hook-registry\",\n \"tempfile\",\n]\n\n[[package]]\nname = \"gix-trace\"\nversion = \"0.1.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f924267408915fddcd558e3f37295cc7d6a3e50f8bd8b606cee0808c3915157e\"\n\n[[package]]\nname = \"gix-traverse\"\nversion = \"0.39.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e499a18c511e71cf4a20413b743b9f5bcf64b3d9e81e9c3c6cd399eae55a8840\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"gix-commitgraph\",\n \"gix-date\",\n \"gix-hash\",\n \"gix-hashtable\",\n \"gix-object\",\n \"gix-revwalk\",\n \"smallvec\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"gix-url\"\nversion = \"0.27.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fd280c5e84fb22e128ed2a053a0daeacb6379469be6a85e3d518a0636e160c89\"\ndependencies = [\n \"bstr\",\n \"gix-features\",\n \"gix-path\",\n \"home\",\n \"thiserror\",\n \"url\",\n]\n\n[[package]]\nname = \"gix-utils\"\nversion = \"0.1.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"35192df7fd0fa112263bad8021e2df7167df4cc2a6e6d15892e1e55621d3d4dc\"\ndependencies = [\n \"fastrand\",\n \"unicode-normalization\",\n]\n\n[[package]]\nname = \"gix-validate\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"82c27dd34a49b1addf193c92070bcbf3beaf6e10f16a78544de6372e146a0acf\"\ndependencies = [\n \"bstr\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"half\"\nversion = \"2.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6dd08c532ae367adf81c312a4580bc67f1d0fe8bc9c460520283f4c0ff277888\"\ndependencies = [\n \"cfg-if\",\n \"crunchy\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.14.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1\"\ndependencies = [\n \"ahash\",\n \"allocator-api2\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.15.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3a9bfc1af68b1726ea47d3d5109de126281def866b33970e10fbab11b5dafab3\"\ndependencies = [\n \"allocator-api2\",\n \"equivalent\",\n \"foldhash\",\n]\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.1.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc\"\n\n[[package]]\nname = \"home\"\nversion = \"0.5.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5\"\ndependencies = [\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"ident_case\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39\"\n\n[[package]]\nname = \"idna\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6\"\ndependencies = [\n \"unicode-bidi\",\n \"unicode-normalization\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"1.9.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\ndependencies = [\n \"autocfg\",\n \"hashbrown 0.12.3\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68b900aa2f7301e21c36462b170ee99994de34dff39a4a6a528e80e7376d07e5\"\ndependencies = [\n \"equivalent\",\n \"hashbrown 0.14.5\",\n]\n\n[[package]]\nname = \"inferno\"\nversion = \"0.11.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"232929e1d75fe899576a3d5c7416ad0d88dbfbb3c3d6aa00873a7408a50ddb88\"\ndependencies = [\n \"ahash\",\n \"indexmap 2.5.0\",\n \"is-terminal\",\n \"itoa\",\n \"log\",\n \"num-format\",\n \"once_cell\",\n \"quick-xml\",\n \"rgb\",\n \"str_stack\",\n]\n\n[[package]]\nname = \"is-terminal\"\nversion = \"0.4.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b\"\ndependencies = [\n \"hermit-abi 0.4.0\",\n \"libc\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.10.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b\"\n\n[[package]]\nname = \"js-sys\"\nversion = \"0.3.70\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a\"\ndependencies = [\n \"wasm-bindgen\",\n]\n\n[[package]]\nname = \"lasso\"\nversion = \"0.7.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6e14eda50a3494b3bf7b9ce51c52434a761e383d7238ce1dd5dcec2fbc13e9fb\"\ndependencies = [\n \"hashbrown 0.14.5\",\n]\n\n[[package]]\nname = \"lazy_static\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe\"\n\n[[package]]\nname = \"lexical\"\nversion = \"6.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c7aefb36fd43fef7003334742cbf77b243fcd36418a1d1bdd480d613a67968f6\"\ndependencies = [\n \"lexical-core\",\n]\n\n[[package]]\nname = \"lexical-core\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2cde5de06e8d4c2faabc400238f9ae1c74d5412d03a7bd067645ccbc47070e46\"\ndependencies = [\n \"lexical-parse-float\",\n \"lexical-parse-integer\",\n \"lexical-util\",\n \"lexical-write-float\",\n \"lexical-write-integer\",\n]\n\n[[package]]\nname = \"lexical-parse-float\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"683b3a5ebd0130b8fb52ba0bdc718cc56815b6a097e28ae5a6997d0ad17dc05f\"\ndependencies = [\n \"lexical-parse-integer\",\n \"lexical-util\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"lexical-parse-integer\"\nversion = \"0.8.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d0994485ed0c312f6d965766754ea177d07f9c00c9b82a5ee62ed5b47945ee9\"\ndependencies = [\n \"lexical-util\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"lexical-util\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5255b9ff16ff898710eb9eb63cb39248ea8a5bb036bea8085b1a767ff6c4e3fc\"\ndependencies = [\n \"static_assertions\",\n]\n\n[[package]]\nname = \"lexical-write-float\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"accabaa1c4581f05a3923d1b4cfd124c329352288b7b9da09e766b0668116862\"\ndependencies = [\n \"lexical-util\",\n \"lexical-write-integer\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"lexical-write-integer\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e1b6f3d1f4422866b68192d62f77bc5c700bee84f3069f2469d7bc8c77852446\"\ndependencies = [\n \"lexical-util\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.158\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439\"\n\n[[package]]\nname = \"libredox\"\nversion = \"0.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c0ff37bd590ca25063e35af745c343cb7a0271906fb7b37e4813e8f79f00268d\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"libc\",\n \"redox_syscall\",\n]\n\n[[package]]\nname = \"linux-raw-sys\"\nversion = \"0.4.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89\"\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"log\"\nversion = \"0.4.22\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24\"\n\n[[package]]\nname = \"logos\"\nversion = \"0.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c000ca4d908ff18ac99b93a062cb8958d331c3220719c52e77cb19cc6ac5d2c1\"\ndependencies = [\n \"logos-derive\",\n]\n\n[[package]]\nname = \"logos-codegen\"\nversion = \"0.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc487311295e0002e452025d6b580b77bb17286de87b57138f3b5db711cded68\"\ndependencies = [\n \"beef\",\n \"fnv\",\n \"proc-macro2\",\n \"quote\",\n \"regex-syntax 0.6.29\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"logos-derive\"\nversion = \"0.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dbfc0d229f1f42d790440136d941afd806bc9e949e2bcb8faa813b0f00d1267e\"\ndependencies = [\n \"logos-codegen\",\n]\n\n[[package]]\nname = \"memchr\"\nversion = \"2.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3\"\n\n[[package]]\nname = \"memmap2\"\nversion = \"0.5.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"memmap2\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fe751422e4a8caa417e13c3ea66452215d7d63e19e604f4980461212f3ae1322\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"minimal-lexical\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n\n[[package]]\nname = \"miniz_oxide\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08\"\ndependencies = [\n \"adler\",\n]\n\n[[package]]\nname = \"miniz_oxide\"\nversion = \"0.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e2d80299ef12ff69b16a84bb182e3b9df68b5a91574d3d4fa6e41b65deec4df1\"\ndependencies = [\n \"adler2\",\n]\n\n[[package]]\nname = \"nix\"\nversion = \"0.26.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"598beaf3cc6fdd9a5dfb1630c2800c7acd31df7aaf0f565796fba2b53ca1af1b\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"cfg-if\",\n \"libc\",\n]\n\n[[package]]\nname = \"nom\"\nversion = \"7.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a\"\ndependencies = [\n \"memchr\",\n \"minimal-lexical\",\n]\n\n[[package]]\nname = \"num-conv\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9\"\n\n[[package]]\nname = \"num-format\"\nversion = \"0.4.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a652d9771a63711fd3c3deb670acfbe5c30a4072e664d7a3bf5a9e1056ac72c3\"\ndependencies = [\n \"arrayvec\",\n \"itoa\",\n]\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"num_threads\"\nversion = \"0.1.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c7398b9c8b70908f6371f47ed36737907c87c52af34c268fed0bf0ceb92ead9\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"object\"\nversion = \"0.36.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"084f1a5821ac4c651660a94a7153d27ac9d8a53736203f58b31945ded098070a\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.19.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92\"\n\n[[package]]\nname = \"oorandom\"\nversion = \"11.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b410bbe7e14ab526a0e86877eb47c6996a2bd7746f027ba551028c925390e4e9\"\n\n[[package]]\nname = \"os_str_bytes\"\nversion = \"6.6.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e2355d85b9a3786f481747ced0e0ff2ba35213a1f9bd406ed906554d7af805a1\"\n\n[[package]]\nname = \"parking_lot\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27\"\ndependencies = [\n \"lock_api\",\n \"parking_lot_core\",\n]\n\n[[package]]\nname = \"parking_lot_core\"\nversion = \"0.9.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"redox_syscall\",\n \"smallvec\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"percent-encoding\"\nversion = \"2.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e\"\n\n[[package]]\nname = \"pest\"\nversion = \"2.7.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cd53dff83f26735fdc1ca837098ccf133605d794cdae66acfc2bfac3ec809d95\"\ndependencies = [\n \"memchr\",\n \"thiserror\",\n \"ucd-trie\",\n]\n\n[[package]]\nname = \"pest_derive\"\nversion = \"2.7.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2a548d2beca6773b1c244554d36fcf8548a8a58e74156968211567250e48e49a\"\ndependencies = [\n \"pest\",\n \"pest_generator\",\n]\n\n[[package]]\nname = \"pest_generator\"\nversion = \"2.7.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3c93a82e8d145725dcbaf44e5ea887c8a869efdcc28706df2d08c69e17077183\"\ndependencies = [\n \"pest\",\n \"pest_meta\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"pest_meta\"\nversion = \"2.7.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a941429fea7e08bedec25e4f6785b6ffaacc6b755da98df5ef3e7dcf4a124c4f\"\ndependencies = [\n \"once_cell\",\n \"pest\",\n \"sha2\",\n]\n\n[[package]]\nname = \"plotters\"\nversion = \"0.3.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a15b6eccb8484002195a3e44fe65a4ce8e93a625797a063735536fd59cb01cf3\"\ndependencies = [\n \"num-traits\",\n \"plotters-backend\",\n \"plotters-svg\",\n \"wasm-bindgen\",\n \"web-sys\",\n]\n\n[[package]]\nname = \"plotters-backend\"\nversion = \"0.3.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"414cec62c6634ae900ea1c56128dfe87cf63e7caece0852ec76aba307cebadb7\"\n\n[[package]]\nname = \"plotters-svg\"\nversion = \"0.3.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81b30686a7d9c3e010b84284bdd26a29f2138574f52f5eb6f794fc0ad924e705\"\ndependencies = [\n \"plotters-backend\",\n]\n\n[[package]]\nname = \"pom\"\nversion = \"3.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6c972d8f86e943ad532d0b04e8965a749ad1d18bb981a9c7b3ae72fe7fd7744b\"\ndependencies = [\n \"bstr\",\n]\n\n[[package]]\nname = \"powerfmt\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391\"\n\n[[package]]\nname = \"pprof\"\nversion = \"0.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"196ded5d4be535690899a4631cc9f18cdc41b7ebf24a79400f46f48e49a11059\"\ndependencies = [\n \"backtrace\",\n \"cfg-if\",\n \"criterion\",\n \"findshlibs\",\n \"inferno\",\n \"libc\",\n \"log\",\n \"nix\",\n \"once_cell\",\n \"parking_lot\",\n \"smallvec\",\n \"symbolic-demangle\",\n \"tempfile\",\n \"thiserror\",\n]\n\n[[package]]\nname = \"proc-macro-error\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c\"\ndependencies = [\n \"proc-macro-error-attr\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro-error-attr\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.86\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"prodash\"\nversion = \"28.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"744a264d26b88a6a7e37cbad97953fa233b94d585236310bcbc88474b4092d79\"\n\n[[package]]\nname = \"psm\"\nversion = \"0.1.22\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b1f9bf148c15500d44581654fb9260bc9d82970f3ef777a79a40534f6aa784f\"\ndependencies = [\n \"cc\",\n]\n\n[[package]]\nname = \"quick-xml\"\nversion = \"0.26.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f50b1c63b38611e7d4d7f68b82d3ad0cc71a2ad2e7f61fc10f1328d917c93cd\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.37\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"rayon\"\nversion = \"1.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa\"\ndependencies = [\n \"either\",\n \"rayon-core\",\n]\n\n[[package]]\nname = \"rayon-core\"\nversion = \"1.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2\"\ndependencies = [\n \"crossbeam-deque\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"redox_syscall\"\nversion = \"0.5.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4\"\ndependencies = [\n \"bitflags 2.6.0\",\n]\n\n[[package]]\nname = \"regex\"\nversion = \"1.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4219d74c6b67a3654a9fbebc4b419e22126d13d2f3c4a07ee0cb61ff79a79619\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-automata 0.4.7\",\n \"regex-syntax 0.8.4\",\n]\n\n[[package]]\nname = \"regex-automata\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"59b23e92ee4318893fa3fe3e6fb365258efbfe6ac6ab30f090cdcbb7aa37efa9\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax 0.7.5\",\n]\n\n[[package]]\nname = \"regex-automata\"\nversion = \"0.4.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax 0.8.4\",\n]\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.6.29\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1\"\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.7.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da\"\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.8.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b\"\n\n[[package]]\nname = \"rgb\"\nversion = \"0.8.50\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"57397d16646700483b67d2dd6511d79318f9d057fdbd21a4066aeac8b41d310a\"\ndependencies = [\n \"bytemuck\",\n]\n\n[[package]]\nname = \"rustc-demangle\"\nversion = \"0.1.24\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f\"\n\n[[package]]\nname = \"rustix\"\nversion = \"0.38.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a85d50532239da68e9addb745ba38ff4612a242c1c7ceea689c4bc7c2f43c36f\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"errno\",\n \"libc\",\n \"linux-raw-sys\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"rustversion\"\nversion = \"1.0.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"955d28af4278de8121b7ebeb796b6a45735dc01436d898801014aced2773a3d6\"\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f\"\n\n[[package]]\nname = \"same-file\"\nversion = \"1.0.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502\"\ndependencies = [\n \"winapi-util\",\n]\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.209\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"99fce0ffe7310761ca6bf9faf5115afbc19688edd00171d81b1bb1b116c63e09\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.209\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a5831b979fd7b5439637af1752d535ff49f4860c0f341d1baeb6faf0f4242170\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.127\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8043c06d9f82bd7271361ed64f415fe5e12a77fdb52e573e7f06a516dea329ad\"\ndependencies = [\n \"indexmap 2.5.0\",\n \"itoa\",\n \"memchr\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"sha1_smol\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbfa15b3dddfee50a0fff136974b3e1bde555604ba463834a7eb7deb6417705d\"\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"shlex\"\nversion = \"1.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\"\n\n[[package]]\nname = \"signal-hook\"\nversion = \"0.3.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8621587d4798caf8eb44879d42e56b9a93ea5dcd315a6487c357130095b62801\"\ndependencies = [\n \"libc\",\n \"signal-hook-registry\",\n]\n\n[[package]]\nname = \"signal-hook-registry\"\nversion = \"1.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"slotmap\"\nversion = \"1.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dbff4acf519f630b3a3ddcfaea6c06b42174d9a44bc70c620e9ed1649d58b82a\"\ndependencies = [\n \"version_check\",\n]\n\n[[package]]\nname = \"smallvec\"\nversion = \"1.13.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n\n[[package]]\nname = \"sn\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6fab6ae84ee9505d8786b19c3a1c68e70431d8465a835d4c59dd4a843884647b\"\n\n[[package]]\nname = \"spin\"\nversion = \"0.9.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67\"\n\n[[package]]\nname = \"stable_deref_trait\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n\n[[package]]\nname = \"stacker\"\nversion = \"0.1.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"799c883d55abdb5e98af1a7b3f23b9b6de8ecada0ecac058672d7635eb48ca7b\"\ndependencies = [\n \"cc\",\n \"cfg-if\",\n \"libc\",\n \"psm\",\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"str_stack\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9091b6114800a5f2141aee1d1b9d6ca3592ac062dc5decb3764ec5895a47b4eb\"\n\n[[package]]\nname = \"strsim\"\nversion = \"0.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f\"\n\n[[package]]\nname = \"symbolic-common\"\nversion = \"10.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b55cdc318ede251d0957f07afe5fed912119b8c1bc5a7804151826db999e737\"\ndependencies = [\n \"debugid\",\n \"memmap2 0.5.10\",\n \"stable_deref_trait\",\n \"uuid\",\n]\n\n[[package]]\nname = \"symbolic-demangle\"\nversion = \"10.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"79be897be8a483a81fff6a3a4e195b4ac838ef73ca42d348b3f722da9902e489\"\ndependencies = [\n \"cpp_demangle\",\n \"rustc-demangle\",\n \"symbolic-common\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.77\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9f35bcdf61fd8e7be6caf75f429fdca8beb3ed76584befb503b1569faee373ed\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"tempfile\"\nversion = \"3.12.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"04cbcdd0c794ebb0d4cf35e88edd2f7d2c4c3e9a5a6dab322839b321c6a87a64\"\ndependencies = [\n \"cfg-if\",\n \"fastrand\",\n \"once_cell\",\n \"rustix\",\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"textwrap\"\nversion = \"0.16.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"23d434d3f8967a09480fb04132ebe0a3e088c173e6d0ee7897abbdf4eab0f8b9\"\n\n[[package]]\nname = \"thiserror\"\nversion = \"1.0.63\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724\"\ndependencies = [\n \"thiserror-impl\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"1.0.63\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n]\n\n[[package]]\nname = \"time\"\nversion = \"0.3.36\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5dfd88e563464686c916c7e46e623e520ddc6d79fa6641390f2e3fa86e83e885\"\ndependencies = [\n \"deranged\",\n \"itoa\",\n \"libc\",\n \"num-conv\",\n \"num_threads\",\n \"powerfmt\",\n \"serde\",\n \"time-core\",\n \"time-macros\",\n]\n\n[[package]]\nname = \"time-core\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3\"\n\n[[package]]\nname = \"time-macros\"\nversion = \"0.2.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3f252a68540fde3a3877aeea552b832b40ab9a69e318efd078774a01ddee1ccf\"\ndependencies = [\n \"num-conv\",\n \"time-core\",\n]\n\n[[package]]\nname = \"tinytemplate\"\nversion = \"1.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be4d6b5f19ff7664e8c98d03e2139cb510db9b0a60b55f8e8709b689d939b6bc\"\ndependencies = [\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"tinyvec\"\nversion = \"1.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938\"\ndependencies = [\n \"tinyvec_macros\",\n]\n\n[[package]]\nname = \"tinyvec_macros\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n\n[[package]]\nname = \"typenum\"\nversion = \"1.17.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825\"\n\n[[package]]\nname = \"ucd-trie\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9\"\n\n[[package]]\nname = \"unicode-bidi\"\nversion = \"0.3.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75\"\n\n[[package]]\nname = \"unicode-bom\"\nversion = \"2.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7eec5d1121208364f6793f7d2e222bf75a915c19557537745b195b253dd64217\"\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n\n[[package]]\nname = \"unicode-normalization\"\nversion = \"0.1.23\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5\"\ndependencies = [\n \"tinyvec\",\n]\n\n[[package]]\nname = \"unicode-segmentation\"\nversion = \"1.12.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493\"\n\n[[package]]\nname = \"unicode-width\"\nversion = \"0.1.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0336d538f7abc86d282a4189614dfaa90810dfc2c6f6427eaf88e16311dd225d\"\n\n[[package]]\nname = \"url\"\nversion = \"2.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"22784dbdf76fdde8af1aeda5622b546b422b6fc585325248a2bf9f5e41e94d6c\"\ndependencies = [\n \"form_urlencoded\",\n \"idna\",\n \"percent-encoding\",\n]\n\n[[package]]\nname = \"uuid\"\nversion = \"1.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81dfa00651efa65069b0b6b651f4aaa31ba9e3c3ce0137aaad053604ee7e0314\"\n\n[[package]]\nname = \"vergen\"\nversion = \"9.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c32e7318e93a9ac53693b6caccfb05ff22e04a44c7cf8a279051f24c09da286f\"\ndependencies = [\n \"anyhow\",\n \"derive_builder\",\n \"rustversion\",\n \"vergen-lib\",\n]\n\n[[package]]\nname = \"vergen-gix\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e353ce10596ac5821aaf76e4952360f6d08d3ece9498564d066167bb0f437c94\"\ndependencies = [\n \"anyhow\",\n \"derive_builder\",\n \"gix\",\n \"rustversion\",\n \"time\",\n \"vergen\",\n \"vergen-lib\",\n]\n\n[[package]]\nname = \"vergen-lib\"\nversion = \"0.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e06bee42361e43b60f363bad49d63798d0f42fb1768091812270eca00c784720\"\ndependencies = [\n \"anyhow\",\n \"derive_builder\",\n \"getset\",\n \"rustversion\",\n]\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a\"\n\n[[package]]\nname = \"walkdir\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b\"\ndependencies = [\n \"same-file\",\n \"winapi-util\",\n]\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"wasm-bindgen\"\nversion = \"0.2.93\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5\"\ndependencies = [\n \"cfg-if\",\n \"once_cell\",\n \"wasm-bindgen-macro\",\n]\n\n[[package]]\nname = \"wasm-bindgen-backend\"\nversion = \"0.2.93\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b\"\ndependencies = [\n \"bumpalo\",\n \"log\",\n \"once_cell\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n \"wasm-bindgen-shared\",\n]\n\n[[package]]\nname = \"wasm-bindgen-macro\"\nversion = \"0.2.93\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf\"\ndependencies = [\n \"quote\",\n \"wasm-bindgen-macro-support\",\n]\n\n[[package]]\nname = \"wasm-bindgen-macro-support\"\nversion = \"0.2.93\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n \"wasm-bindgen-backend\",\n \"wasm-bindgen-shared\",\n]\n\n[[package]]\nname = \"wasm-bindgen-shared\"\nversion = \"0.2.93\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484\"\n\n[[package]]\nname = \"web-sys\"\nversion = \"0.3.70\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"26fdeaafd9bd129f65e7c031593c24d62186301e0c72c8978fa1678be7d532c0\"\ndependencies = [\n \"js-sys\",\n \"wasm-bindgen\",\n]\n\n[[package]]\nname = \"winapi\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\ndependencies = [\n \"winapi-i686-pc-windows-gnu\",\n \"winapi-x86_64-pc-windows-gnu\",\n]\n\n[[package]]\nname = \"winapi-i686-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n\n[[package]]\nname = \"winapi-util\"\nversion = \"0.1.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb\"\ndependencies = [\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"winapi-x86_64-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.52.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.59.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-targets\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_gnullvm\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b\"\n\n[[package]]\nname = \"windows_i686_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.6.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68a9bda4691f099d435ad181000724da8e5899daa10713c2d432552b9ccd3a6f\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"yansi\"\nversion = \"0.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09041cd90cf85f7f8b2df60c646f853b7f535ce68f85244eb6731cf89fa498ec\"\n\n[[package]]\nname = \"zerocopy\"\nversion = \"0.7.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0\"\ndependencies = [\n \"zerocopy-derive\",\n]\n\n[[package]]\nname = \"zerocopy-derive\"\nversion = \"0.7.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.77\",\n]\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 3.8203125,
          "content": "[package]\nname = \"chumsky\"\nversion = \"1.0.0-alpha.7\"\ndescription = \"A parser library for humans with powerful error recovery\"\nauthors = [\"Joshua Barretto <joshua.s.barretto@gmail.com>\", \"Elijah Hartvigsen <elijah.reed@hartvigsen.xyz\", \"Jakob Wiesmore <runetynan@gmail.com>\"]\nrepository = \"https://github.com/zesterer/chumsky\"\nlicense = \"MIT\"\nkeywords = [\"parser\", \"combinator\", \"token\", \"language\", \"syntax\"]\ncategories = [\"parsing\", \"text-processing\"]\nedition = \"2021\"\nexclude = [\n    \"/misc/*\",\n\t\"/benches/samples/*\",\n]\nbuild = \"build.rs\"\nrust-version = \"1.65\"\n\n[features]\ndefault = [\"std\", \"stacker\"]\n\n# Integrate with the standard library.\nstd = [\n    \"regex-automata?/std\",\n    \"serde?/std\"\n]\n\n# Enable nightly-only features like better compiler diagnostics and a Parser impl for ! (the never type).\nnightly = []\n\n# Allows deeper recursion by dynamically spilling stack state on to the heap.\nstacker = [\"dep:stacker\", \"std\"]\n\n# Allows parser memoization, speeding up heavily back-tracking parsers and allowing left recursion.\nmemoization = []\n\n# Allows extending chumsky by writing your own parser implementations.\nextension = []\n\n# Make builtin parsers such as `Boxed` use atomic instead of non-atomic internals.\nsync = [\"spin\"]\n\n# Enable Pratt parsing combinator\npratt = [\"unstable\"]\n\n# Allow the use of unstable features (aka features where the API is not settled)\nunstable = []\n\n# Allows use of the `Number` parser, which is backed by the `lexical` crate\nlexical-numbers = [\"lexical\", \"unstable\"]\n\n# Adds impl of Parser for either::Either\neither = [\"dep:either\"]\n\n# Enables regex combinators\nregex = [\"dep:regex-automata\"]\n\n# Enable serde serialization support\nserde = [\"dep:serde\"]\n\n# Enable dependencies only needed for generation of documentation on docs.rs\ndocsrs = [\"dep:vergen-gix\"]\n\n# An alias of all features that work with the stable compiler.\n# Do not use this feature, its removal is not considered a breaking change and its behaviour may change.\n# If you're working on chumsky and you're adding a feature that does not require nightly support, please add it to this list.\n_test_stable = [\"std\", \"stacker\", \"memoization\", \"extension\", \"sync\"]\n\n[package.metadata.docs.rs]\nall-features = true\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n\n[dependencies]\nhashbrown = \"0.15\"\nstacker = { version = \"0.1\", optional = true }\nregex-automata = { version = \"0.3\", default-features = false, optional = true, features = [\"alloc\", \"meta\", \"perf\", \"unicode\", \"nfa\", \"dfa\", \"hybrid\"] }\nspin = { version = \"0.9\", features = [\"once\"], default-features = false, optional = true }\nlexical = { version = \"6.1.1\", default-features = false, features = [\"parse-integers\", \"parse-floats\", \"format\"], optional = true }\neither = { version = \"1.8.1\", optional = true }\nserde = { version = \"1.0\", default-features = false, optional = true, features = [\"derive\"] }\nunicode-ident =  \"1.0.10\"\nunicode-segmentation = \"1\"\n\n[build-dependencies]\nvergen-gix = { version = \"1.0\", optional = true, features = [\"emit_and_set\"] }\n\n[dev-dependencies]\nariadne = \"0.2\"\npom = \"3.2\"\nnom = \"7.1\"\nwinnow = \"0.6.0\"\nserde_json = { version = \"1.0\", features = [\"preserve_order\"] }\nciborium = { version = \"0.2\" }\ncriterion = \"0.4.0\"\npest = \"2.5\"\npest_derive = \"2.5\"\nsn = \"0.1\"\nlogos = \"0.13\"\nlasso = \"0.7\"\nslotmap = \"1.0\"\n\n[target.'cfg(unix)'.dev-dependencies]\npprof = { version = \"0.11\", features = [\"flamegraph\", \"criterion\"] }\n\n[profile.bench]\ndebug = true\n\n[[bench]]\nname = \"json\"\nharness = false\nrequired-features = [\"std\"]\n\n[[bench]]\nname = \"lex\"\nharness = false\n\n[[bench]]\nname = \"parser\"\nharness = false\n\n[[bench]]\nname = \"backtrack\"\nharness = false\n\n[[bench]]\nname = \"cbor\"\nharness = false\n\n[[example]]\nname = \"nano_rust\"\n\n[[example]]\nname = \"json\"\nrequired-features = [\"std\"]\n\n[[example]]\nname = \"io\"\nrequired-features = [\"std\"]\n\n[[example]]\nname = \"foo\"\nrequired-features = [\"std\"]\n\n[[example]]\nname = \"mini_ml\"\nrequired-features = [\"pratt\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2021 Joshua Barretto\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3623046875,
          "content": "# Chumsky\n\n[![crates.io](https://img.shields.io/crates/v/chumsky.svg)](https://crates.io/crates/chumsky)\n[![crates.io](https://docs.rs/chumsky/badge.svg)](https://docs.rs/chumsky)\n[![License](https://img.shields.io/crates/l/chumsky.svg)](https://github.com/zesterer/chumsky)\n[![actions-badge](https://github.com/zesterer/chumsky/workflows/Rust/badge.svg?branch=main)](https://github.com/zesterer/chumsky/actions)\n\nA parser library for humans with powerful error recovery.\n\n<a href = \"https://www.github.com/zesterer/tao\">\n    <img src=\"https://raw.githubusercontent.com/zesterer/chumsky/main/misc/example.png\" alt=\"Example usage with my own language, Tao\"/>\n</a>\n\n*Note: Error diagnostic rendering is performed by [Ariadne](https://github.com/zesterer/ariadne)*\n\n## Contents\n\n- [Features](#features)\n- [Example Brainfuck Parser](#example-brainfuck-parser)\n- [Tutorial](#tutorial)\n- [*What* is a parser combinator?](#what-is-a-parser-combinator)\n- [*Why* use parser combinators?](#why-use-parser-combinators)\n- [Classification](#classification)\n- [Error Recovery](#error-recovery)\n- [Performance](#performance)\n- [Planned Features](#planned-features)\n- [Philosophy](#philosophy)\n- [Notes](#notes)\n- [License](#license)\n\n## Features\n\n- Lots of combinators!\n- Generic across input, output, error, and span types\n- Powerful error recovery strategies\n- Inline mapping to your AST\n- Text-specific parsers for both `u8`s and `char`s\n- Recursive parsers\n- Backtracking is fully supported, allowing the parsing of all known context-free grammars\n- Parsing of nesting inputs, allowing you to move delimiter parsing to the lexical stage (as Rust does!)\n- Built-in parser debugging\n\n## Example [Brainfuck](https://en.wikipedia.org/wiki/Brainfuck) Parser\n\nSee [`examples/brainfuck.rs`] for the full interpreter (`cargo run --example brainfuck -- examples/sample.bf`).\n\n```rust\nuse chumsky::prelude::*;\n\n#[derive(Clone)]\nenum Instr {\n    Left, Right,\n    Incr, Decr,\n    Read, Write,\n    Loop(Vec<Self>),\n}\n\nfn parser<'a>() -> impl Parser<'a, &'a str, Vec<Instr>> {\n    recursive(|bf| choice((\n        just('<').to(Instr::Left),\n        just('>').to(Instr::Right),\n        just('+').to(Instr::Incr),\n        just('-').to(Instr::Decr),\n        just(',').to(Instr::Read),\n        just('.').to(Instr::Write),\n        bf.delimited_by(just('['), just(']')).map(Instr::Loop),\n    ))\n        .repeated()\n        .collect())\n}\n```\n\nOther examples include:\n\n- A [JSON parser] (`cargo run --example json -- examples/sample.json`)\n- An [interpreter for a simple Rust-y language][examples/nano_rust.rs]\n  (`cargo run --example nano_rust -- examples/sample.nrs`)\n\n## Tutorial\n\nChumsky has a [tutorial] that teaches you how to write a parser and interpreter for a simple dynamic language\nwith unary and binary operators, operator precedence, functions, let declarations, and calls.\n\n## *What* is a parser combinator?\n\nParser combinators are a technique for implementing parsers by defining them in terms of other parsers. The resulting\nparsers use a [recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser) strategy to transform a stream\nof tokens into an output. Using parser combinators to define parsers is roughly analogous to using Rust's\n[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) trait to define iterative algorithms: the\ntype-driven API of `Iterator` makes it more difficult to make mistakes and easier to encode complicated iteration logic\nthan if one were to write the same code by hand. The same is true of parser combinators.\n\n## *Why* use parser combinators?\n\nWriting parsers with good error recovery is conceptually difficult and time-consuming. It requires understanding the\nintricacies of the recursive descent algorithm, and then implementing recovery strategies on top of it. If you're\ndeveloping a programming language, you'll almost certainly change your mind about syntax in the process, leading to some\nslow and painful parser refactoring. Parser combinators solve both problems by providing an ergonomic API that allows\nfor rapidly iterating upon a syntax.\n\nParser combinators are also a great fit for domain-specific languages for which an existing parser does not exist.\nWriting a reliable, fault-tolerant parser for such situations can go from being a multi-day task to a half-hour task\nwith the help of a decent parser combinator library.\n\n## Classification\n\nChumsky's parsers are [recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser) parsers and are\ncapable of parsing [parsing expression grammars (PEGs)](https://en.wikipedia.org/wiki/Parsing_expression_grammar), which\nincludes all known context-free languages. It is theoretically possible to extend Chumsky further to accept limited\ncontext-sensitive grammars too, although this is rarely required.\n\n## Error Recovery\n\nChumsky has support for error recovery, meaning that it can encounter a syntax error, report the error, and then\nattempt to recover itself into a state in which it can continue parsing so that multiple errors can be produced at once\nand a partial [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) can still be generated from the input for future\ncompilation stages to consume.\n\nHowever, there is no silver bullet strategy for error recovery. By definition, if the input to a parser is invalid then\nthe parser can only make educated guesses as to the meaning of the input. Different recovery strategies will work better\nfor different languages, and for different patterns within those languages.\n\nChumsky provides a variety of recovery strategies (each implementing the `Strategy` trait), but it's important to\nunderstand that all of\n\n- which you apply\n- where you apply them\n- what order you apply them\n\nwill greatly affect the quality of the errors that Chumsky is able to produce, along with the extent to which it is able\nto recover a useful AST. Where possible, you should attempt more 'specific' recovery strategies first rather than those\nthat mindlessly skip large swathes of the input.\n\nIt is recommended that you experiment with applying different strategies in different situations and at different levels\nof the parser to find a configuration that you are happy with. If none of the provided error recovery strategies cover\nthe specific pattern you wish to catch, you can even create your own by digging into Chumsky's internals and\nimplementing your own strategies! If you come up with a useful strategy, feel free to open a PR against the\n[main repository](https://github.com/zesterer/chumsky/)!\n\n## Performance\n\nChumsky focuses on high-quality errors and ergonomics over performance. That said, it's important that Chumsky can keep\nup with the rest of your compiler! Unfortunately, it's *extremely* difficult to come up with sensible benchmarks given\nthat exactly how Chumsky performs depends entirely on what you are parsing, how you structure your parser, which\npatterns the parser attempts to match first, how complex your error type is, what is involved in constructing your AST,\netc. All that said, here are some numbers from the\n[JSON benchmark](https://github.com/zesterer/chumsky/blob/main/benches/json.rs) included in the repository running on\nmy Ryzen 7 3700x.\n\n```ignore\ntest chumsky ... bench:   4,782,390 ns/iter (+/- 997,208)\ntest pom     ... bench:  12,793,490 ns/iter (+/- 1,954,583)\n```\n\nI've included results from [`pom`](https://github.com/J-F-Liu/pom), another parser combinator crate with a similar\ndesign, as a point of reference. The sample file being parsed is broadly representative of typical JSON data and has\n3,018 lines. This translates to a little over 630,000 lines of JSON per second.\n\nClearly, this is a little slower than a well-optimised hand-written parser: but that's okay! Chumsky's goal is to be\n*fast enough*. If you've written enough code in your language that parsing performance even starts to be a problem,\nyou've already committed enough time and resources to your language that hand-writing a parser is the best choice going!\n\n## Planned Features\n\n- An optimised 'happy path' parser mode that skips error recovery & error generation\n- An even faster 'validation' parser mode, guaranteed to not allocate, that doesn't generate outputs but just verifies\n  the validity of an input\n\n## Philosophy\n\nChumsky should:\n\n- Be easy to use, even if you don't understand exactly what the parser is doing under the hood\n- Be type-driven, pushing users away from anti-patterns at compile-time\n- Be a mature, 'batteries-included' solution for context-free parsing by default. If you need to implement either\n  `Parser` or `Strategy` by hand, that's a problem that needs fixing\n- Be 'fast enough', but no faster (i.e: when there is a tradeoff between error quality and performance, Chumsky will\n  always take the former option)\n- Be modular and extensible, allowing users to implement their own parsers, recovery strategies, error types, spans, and\n  be generic over both input tokens and the output AST\n\n## Notes\n\nMy apologies to Noam for choosing such an absurd name.\n\n## License\n\nChumsky is licensed under the MIT license (see `LICENSE` in the main repository).\n\n<!-- These link destinations are defined like this so that src/lib.rs can override them. -->\n[`examples/brainfuck.rs`]: https://github.com/zesterer/chumsky/blob/main/examples/brainfuck.rs\n[JSON parser]: https://github.com/zesterer/chumsky/blob/main/examples/json.rs\n[examples/nano_rust.rs]: https://github.com/zesterer/chumsky/blob/main/examples/nano_rust.rs\n[tutorial]: https://github.com/zesterer/chumsky/blob/main/tutorial.md\n"
        },
        {
          "name": "README2.md",
          "type": "blob",
          "size": 11.5009765625,
          "content": "# Chumsky\n\n[![crates.io](https://img.shields.io/crates/v/chumsky.svg)](https://crates.io/crates/chumsky)\n[![crates.io](https://docs.rs/chumsky/badge.svg)](https://docs.rs/chumsky)\n[![License](https://img.shields.io/crates/l/chumsky.svg)](https://github.com/zesterer/chumsky)\n[![actions-badge](https://github.com/zesterer/chumsky/workflows/Rust/badge.svg?branch=master)](https://github.com/zesterer/chumsky/actions)\n\nChumsky is a parser combinator library for Rust that makes writing expressive, high-performance parsers easy.\n\n<a href = \"https://www.github.com/zesterer/tao\">\n    <img src=\"https://raw.githubusercontent.com/zesterer/chumsky/master/misc/example.png\" alt=\"Example usage with my own language, Tao\"/>\n</a>\n\nAlthough chumsky is designed primarily for user-fancing parsers such as compilers, chumsky is just as much at home\nparsing binary protocols at the networking layer, configuration files, or any other form of complex input validation that\nyou may need. It also has `no_std` support, making it suitable for embedded environments.\n\n## Features\n\n-  **Expressive combinators** that make writing your parser a joy\n-  **Fully generic** across input, token, output, span, and error types\n-  **Zero-copy parsing** minimises allocation by having outputs hold references/slices of the input\n-  **Flexible error recovery** strategies out of the box\n-  **Internal optimiser** leverages the power of [GATs](https://smallcultfollowing.com/babysteps/blog/2022/06/27/many-modes-a-gats-pattern/) to optimise your parser for you\n-  **Text-oriented parsers** for text inputs (i.e: `&[u8]` and `&str`)\n-  **Context-free grammars** are fully supported, with support for context-sensitivity\n-  **Left recursion and memoization** have opt-in support\n-  **Nested inputs** such as token trees are fully supported both as inputs and outputs\n-  **Pattern labelling** for dynamic, user-friendly error messages\n-  **Caching** allows parsers to be created once and reused many times\n-  **Pratt parsing** support for unary and binary operators\n-  **no_std** support, allowing chumsky to run in embedded environments\n\n*Note: Error diagnostic rendering is performed by [Ariadne](https://github.com/zesterer/ariadne)*\n\n## Example\n\nSee [`examples/brainfuck.rs`](https://github.com/zesterer/chumsky/blob/master/examples/brainfuck.rs) for a full\n[Brainfuck](https://en.wikipedia.org/wiki/Brainfuck) interpreter\n(`cargo run --example brainfuck -- examples/sample.bf`).\n\n```rust,ignore\nuse chumsky::prelude::*;\n\n/// An AST (Abstract Syntax Tree) for Brainfuck instructions\n#[derive(Clone)]\nenum Instr {\n    Left, Right,\n    Incr, Decr,\n    Read, Write,\n    Loop(Vec<Self>), // In Brainfuck, `[...]` loops contain sub-blocks of instructions\n}\n\n/// A function that returns an instance of our Brainfuck parser\nfn parser<'a>() -> impl Parser<'a, &'a str, Vec<Instr>> {\n\t// Brainfuck syntax is recursive: each block can contain many sub-blocks (via `[...]` loops)\n    recursive(|bf| choice((\n\t\t// All of the basic instructions are just single characters\n        just('<').to(Instr::Left),\n        just('>').to(Instr::Right),\n        just('+').to(Instr::Incr),\n        just('-').to(Instr::Decr),\n        just(',').to(Instr::Read),\n        just('.').to(Instr::Write),\n\t\t// Loops are strings of Brainfuck instructions, delimited by square brackets\n        bf.delimited_by(just('['), just(']')).map(Instr::Loop),\n    ))\n\t\t// Brainfuck instructions are sequential, so parse as many as we need\n        .repeated()\n        .collect())\n}\n\n// Parse some Brainfuck with our parser\nparser().parse(\"--[>--->->->++>-<<<<<-------]>--.>---------.>--..+++.>----.>+++++++++.<<.+++.------.<-.>>+.\")\n```\n\nSee [`examples/`](examples/) for more example uses of chumsky, including a toy Rust-like interpreter.\n\nOther examples include:\n\n- A [JSON parser](https://github.com/zesterer/chumsky/blob/master/examples/json.rs) (`cargo run --example json --\n  examples/sample.json`)\n- An [interpreter for a simple Rust-y language](https://github.com/zesterer/chumsky/blob/master/examples/nano_rust.rs)\n  (`cargo run --example nano_rust -- examples/sample.nrs`)\n\n## Tutorial\n\nChumsky has [a tutorial](https://github.com/zesterer/chumsky/blob/master/tutorial.md) that teaches you how to write a\nparser and interpreter for a simple dynamic language with unary and binary operators, operator precedence, functions,\nlet declarations, and calls.\n\n## Cargo Features\n\nChumsky contains several optional features that extend the crate's functionality.\n\n- `pratt`: enables the [pratt parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html) combinator\n\n- `regex`: enables the regex combinator\n\n- `serde`: enables `serde` (de)serialization support for several types\n\n- `either`: implements `Parser` for `either::Either`, allowing dynamic configuration of parsers at runtime\n\n- `extension`: enables the extension API, allowing you to write your own first-class combinators that integrate with and extend chumsky\n\n- `memoization`: enables [memoization](https://en.wikipedia.org/wiki/Memoization#Parsers) features\n\n- `stacker` (enabled by default): avoid stack overflows by spilling stack data to the heap via the `stacker` crate\n\n- `unstable`: enables experimental chumsky features\n\n- `std` (enabled by default): support for standard library features\n\n- `nightly`: enable support for features only supported by the nightly Rust compiler\n\n## *What* is a parser combinator?\n\nParser combinators are a technique for implementing parsers by defining them in terms of other parsers. The resulting\nparsers use a [recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser) strategy to transform a stream\nof tokens into an output. Using parser combinators to define parsers is roughly analogous to using Rust's\n[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) trait to define iterative algorithms: the\ntype-driven API of `Iterator` makes it more difficult to make mistakes and easier to encode complicated iteration logic\nthan if one were to write the same code by hand. The same is true of parser combinators.\n\n## *Why* use parser combinators?\n\nWriting parsers with good error recovery is conceptually difficult and time-consuming. It requires understanding the\nintricacies of the recursive descent algorithm, and then implementing recovery strategies on top of it. If you're\ndeveloping a programming language, you'll almost certainly change your mind about syntax in the process, leading to some\nslow and painful parser refactoring. Parser combinators solve both problems by providing an ergonomic API that allows\nfor rapidly iterating upon a syntax.\n\nParser combinators are also a great fit for domain-specific languages for which an existing parser does not exist.\nWriting a reliable, fault-tolerant parser for such situations can go from being a multi-day task to a half-hour task\nwith the help of a decent parser combinator library.\n\n## Classification\n\nChumsky's parsers are [recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser) parsers and are\ncapable of parsing [parsing expression grammars (PEGs)](https://en.wikipedia.org/wiki/Parsing_expression_grammar), which\nincludes all known context-free languages. It is theoretically possible to extend Chumsky further to accept limited\ncontext-sensitive grammars too, although this is rarely required.\n\n## Error Recovery\n\nChumsky has support for error recovery, meaning that it can encounter a syntax error, report the error, and then\nattempt to recover itself into a state in which it can continue parsing so that multiple errors can be produced at once\nand a partial [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) can still be generated from the input for future\ncompilation stages to consume.\n\nHowever, there is no silver bullet strategy for error recovery. By definition, if the input to a parser is invalid then\nthe parser can only make educated guesses as to the meaning of the input. Different recovery strategies will work better\nfor different languages, and for different patterns within those languages.\n\nChumsky provides a variety of recovery strategies (each implementing the `Strategy` trait), but it's important to\nunderstand that all of\n\n- which you apply\n- where you apply them\n- what order you apply them\n\nwill greatly affect the quality of the errors that Chumsky is able to produce, along with the extent to which it is able\nto recover a useful AST. Where possible, you should attempt more 'specific' recovery strategies first rather than those\nthat mindlessly skip large swathes of the input.\n\nIt is recommended that you experiment with applying different strategies in different situations and at different levels\nof the parser to find a configuration that you are happy with. If none of the provided error recovery strategies cover\nthe specific pattern you wish to catch, you can even create your own by digging into Chumsky's internals and\nimplementing your own strategies! If you come up with a useful strategy, feel free to open a PR against the\n[main repository](https://github.com/zesterer/chumsky/)!\n\n## Performance\n\nChumsky focuses on high-quality errors and ergonomics over performance. That said, it's important that Chumsky can keep\nup with the rest of your compiler! Unfortunately, it's *extremely* difficult to come up with sensible benchmarks given\nthat exactly how Chumsky performs depends entirely on what you are parsing, how you structure your parser, which\npatterns the parser attempts to match first, how complex your error type is, what is involved in constructing your AST,\netc. All that said, here are some numbers from the\n[JSON benchmark](https://github.com/zesterer/chumsky/blob/master/benches/json.rs) included in the repository running on\nmy Ryzen 7 3700x.\n\n```ignore\ntest chumsky ... bench:   4,782,390 ns/iter (+/- 997,208)\ntest pom     ... bench:  12,793,490 ns/iter (+/- 1,954,583)\n```\n\nI've included results from [`pom`](https://github.com/J-F-Liu/pom), another parser combinator crate with a similar\ndesign, as a point of reference. The sample file being parsed is broadly representative of typical JSON data and has\n3,018 lines. This translates to a little over 630,000 lines of JSON per second.\n\nClearly, this is a little slower than a well-optimised hand-written parser: but that's okay! Chumsky's goal is to be\n*fast enough*. If you've written enough code in your language that parsing performance even starts to be a problem,\nyou've already committed enough time and resources to your language that hand-writing a parser is the best choice going!\n\n## Planned Features\n\n- An optimised 'happy path' parser mode that skips error recovery & error generation\n- An even faster 'validation' parser mode, guaranteed to not allocate, that doesn't generate outputs but just verifies\n  the validity of an input\n\n## Philosophy\n\nChumsky should:\n\n- Be easy to use, even if you don't understand exactly what the parser is doing under the hood\n- Be type-driven, pushing users away from anti-patterns at compile-time\n- Be a mature, 'batteries-included' solution for context-free parsing by default. If you need to implement either\n  `Parser` or `Strategy` by hand, that's a problem that needs fixing\n- Be 'fast enough', but no faster (i.e: when there is a tradeoff between error quality and performance, Chumsky will\n  always take the former option)\n- Be modular and extensible, allowing users to implement their own parsers, recovery strategies, error types, spans, and\n  be generic over both input tokens and the output AST\n\n## Notes\n\nMy apologies to Noam for choosing such an absurd name.\n\n## License\n\nChumsky is licensed under the MIT license (see `LICENSE` in the main repository).\n"
        },
        {
          "name": "benches",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.rs",
          "type": "blob",
          "size": 0.7021484375,
          "content": "use std::error::Error;\n\nconst URL_START: &str = \"https://github.com/zesterer/chumsky/blob/\";\n\nfn main() -> Result<(), Box<dyn Error>> {\n    #[cfg(feature = \"docsrs\")]\n    {\n        use vergen_gix::{Emitter, GixBuilder};\n\n        let gitcl = GixBuilder::all_git()?;\n        Emitter::default()\n            .add_instructions(&gitcl)?\n            .emit_and_set()?;\n        println!(\n            \"cargo:rustc-env=CHUMSKY_REPO_URL={URL_START}{}\",\n            std::env::var(\"VERGEN_GIT_SHA\").unwrap()\n        );\n    }\n    #[cfg(not(feature = \"docsrs\"))]\n    {\n        println!(\n            \"cargo:rustc-env=CHUMSKY_REPO_URL={URL_START}{}\",\n            std::env::var(\"CARGO_PKG_VERSION\").unwrap()\n        );\n    }\n    Ok(())\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "guide",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tutorial.md",
          "type": "blob",
          "size": 33.8291015625,
          "content": "# Chumsky: A Tutorial\n\n*Please note that this tutorial is kept up to date with the `main` branch and not the most stable release: small\ndetails may differ!*\n\nIn this tutorial, we'll develop a parser (and interpreter!) for a programming language called 'Foo'.\n\nFoo is a small language, but it's enough for us to have some fun. It isn't\n[Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness), but it is complex enough to\nallow us to get to grips with parsing using Chumsky, containing many of the elements you'd find in a 'real' programming\nlanguage. Here's some sample code written in Foo:\n\n```\nlet seven = 7;\nfn add x y = x + y;\nadd(2, 3) * -seven\n```\n\nBy the end of this tutorial, you'll have an interpreter that will let you run this code, and more.\n\nThis tutorial should take somewhere between 30 and 100 minutes to complete, depending on factors such as knowledge of Rust and compiler theory.\n\n*You can find the source code for the full interpreter in [`examples/foo.rs`](https://github.com/zesterer/chumsky/blob/main/examples/foo.rs) in the main repository.*\n\n## Assumptions\n\nThis tutorial is here to show you how to use Chumsky: it's not a general-purpose introduction to language development as a whole. For that reason, we make a few assumptions about things you should know before jumping in:\n\n- You should be happy reading and writing Rust. Particularly obscure syntax will be explained, but you should already be reasonably confident with concepts like functions, types, pattern matching, and error handling (`Result`, `?`, etc.).\n- You should be familiar with data structures like trees and vectors.\n- You should have some awareness of basic compiler theory concepts like [Abstract Syntax Trees (ASTs)](https://en.wikipedia.org/wiki/Abstract_syntax_tree), the difference between parsing and evaluation, [Backus Naur Form (BNF)](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form), etc.\n\n## Documentation\n\nAs we go, we'll be encountering many functions and concepts from Chumsky. I strongly recommend you keep [Chumsky's documentation](https://docs.rs/chumsky/) open in another browser tab and use it to cross-reference your understanding or gain more insight into specific things that you'd like more clarification on. In particular, most of the functions we'll be using come from the [`Parser`](https://docs.rs/chumsky/latest/chumsky/trait.Parser.html) trait. Chumsky's docs include extensive doc examples for almost every function, so be sure to make use of them!\n\nChumsky also has [several longer examples](https://github.com/zesterer/chumsky/tree/main/examples) in the main repository: looking at these may help improve your understanding if you get stuck.\n\n## A note on imperative vs declarative parsers\n\nIf you've tried hand-writing a parser before, you're probably expecting lots of flow control: splitting text by whitespace, matching/switching/branching on things, making a decision about whether to recurse into a function or expect another token, etc. This is an [*imperative*](https://en.wikipedia.org/wiki/Imperative_programming) approach to parser development and can be very time-consuming to write, maintain, and test.\n\nIn contrast, Chumsky parsers are [*declarative*](https://en.wikipedia.org/wiki/Declarative_programming): they still perform intricate flow control internally, but it's all hidden away so you don't need to think of it. Instead of describing *how* to parse a particular grammar, Chumsky parsers simply *describe* a grammar: and it is then Chumsky's job to figure out how to efficiently parse it.\n\nIf you've ever seen [Backus Naur Form (BNF)](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) used to describe a language's syntax, you'll have a good sense of what this means: if you squint, you'll find that a lot of parsers written in Chumsky look pretty close to the BNF definition.\n\nAnother consequence of creating parsers in a declarative style is that *defining* a parser and *using* a parser are two different things: once created, parsers won't do anything on their own unless you give them an input to parse.\n\n## Similarities between `Parser` and `Iterator`\n\nThe most important API in Chumsky is the [`Parser`](https://docs.rs/chumsky/latest/chumsky/trait.Parser.html) trait, implemented by all parsers. Because parsers don't do anything by themselves, writing Chumsky parsers often feels very similar to writing iterators in Rust using the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) trait. If you've enjoyed writing iterators in Rust before, you'll hopefully find the same satisfaction writing parsers with Chumsky. They even [share](https://docs.rs/chumsky/latest/chumsky/trait.Parser.html#method.map) [several](https://docs.rs/chumsky/latest/chumsky/trait.Parser.html#method.flatten) [functions](https://docs.rs/chumsky/latest/chumsky/trait.Parser.html#method.collect) with each other!\n\n## Setting up\n\nCreate a new project with `cargo new --bin foo`, add the latest version of Chumsky as a dependency, and place\nthe following in your `main.rs`:\n\n```rust\nuse chumsky::prelude::*;\n\nfn main() {\n    let src = std::fs::read_to_string(std::env::args().nth(1).unwrap()).unwrap();\n\n    println!(\"{}\", src);\n}\n```\n\nThis code has one purpose: it treats the first command-line argument as a path, reads the corresponding file,\nthen prints the contents to the terminal. We don't really care for handling IO errors in this tutorial, so `.unwrap()`\nwill suffice.\n\nCreate a file named `test.foo` and run `cargo run -- test.foo` (the `--` tells cargo to pass the remaining\narguments to the program instead of cargo itself). You should see that the contents of `test.foo`, if any, get\nprinted to the console.\n\nNext, we'll create a data type that represents a program written in Foo. All programs in Foo are expressions,\nso we'll call it `Expr`.\n\n```rust\n#[derive(Debug)]\nenum Expr {\n    Num(f64),\n    Var(String),\n\n    Neg(Box<Expr>),\n    Add(Box<Expr>, Box<Expr>),\n    Sub(Box<Expr>, Box<Expr>),\n    Mul(Box<Expr>, Box<Expr>),\n    Div(Box<Expr>, Box<Expr>),\n\n    Call(String, Vec<Expr>),\n    Let {\n        name: String,\n        rhs: Box<Expr>,\n        then: Box<Expr>,\n    },\n    Fn {\n        name: String,\n        args: Vec<String>,\n        body: Box<Expr>,\n        then: Box<Expr>,\n    },\n}\n```\n\nThis is Foo's [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST). It represents\nall possible Foo programs and is defined recursively in terms of itself (`Box` is used to avoid the type being\ninfinitely large). Each expression may itself contain sub-expressions.\n\nAs an example, the expression `let x = 5; x * 3` is encoded as follows using the `Expr` type:\n\n```rs\nExpr::Let {\n    name: \"x\",\n    rhs: Expr::Num(5.0),\n    then: Expr::Mul(\n        Expr::Var(\"x\"),\n        Expr::Num(3.0),\n    ),\n}\n```\n\nThe purpose of our parser will be to perform this conversion, from source code to AST.\n\nWe're also going to create a function that creates Foo's parser. Our parser takes in a `char` stream and\nproduces an `Expr`, so we'll use those types for the `I` (input) and `O` (output) type parameters.\n\n```rust\nfn parser() -> impl Parser<char, Expr, Error = Simple<char>> {\n    // To be filled in later...\n}\n```\n\nThe `Error` associated type allows us to customise the error type that Chumsky uses. For now, we'll stick to\n`Simple<I>`, a built-in error type that does everything we need.\n\nIn `main`, we'll alter the `println!` as follows:\n\n```rust\nprintln!(\"{:?}\", parser().parse(src));\n```\n\n## Parsing digits\n\nChumsky is a 'parser combinator' library. It allows the creation of parsers by combining together many smaller\nparsers. The very smallest parsers are called 'primitives' and live in the\n[`primitive`](https://docs.rs/chumsky/latest/chumsky/primitive/index.html) module.\n\nWe're going to want to start by parsing the simplest element of Foo's syntax: numbers.\n\n```rust\n// In `parser`...\nfilter(|c: &char| c.is_ascii_digit())\n```\n\nThe `filter` primitive allows us to read a single input and accept it if it passes a condition. In our case,\nthat condition simply checks that the character is a digit.\n\nIf we compile this code now, we'll encounter an error. Why?\n\nAlthough we promised that our parser would produce an `Expr`, the `filter` primitive only outputs the input\nit found. Right now, all we have is a parser from `char` to `char` instead of a parser from `char` to `Expr`!\n\nTo solve this, we need to crack open the 'combinator' part of parser combinators. We'll use Chumsky's `map`\nmethod to convert the output of the parser to an `Expr`. This method is very similar to its namesake on\n`Iterator`.\n\n```rust\nfilter(|c: &char| c.is_ascii_digit())\n    .map(|c| Expr::Num(c.to_digit(10).unwrap() as f64))\n```\n\nHere, we're converting the `char` digit to an `f64` (unwrapping is fine: `map` only gets applied to outputs\nthat successfully parsed!) and then wrapping it in `Expr::Num(_)` to convert it to a Foo expression.\n\nTry running the code. You'll see that you can type a digit into `test.foo` and have our interpreter generate\nan AST like so:\n\n```\nOk(Num(5.0))\n```\n\n## Parsing numbers\n\nIf you're more than a little adventurous, you'll quickly notice that typing in a multi-digit number doesn't\nquite behave as expected. Inputting `42` will only produce a `Num(4.0)` AST.\n\nThis is because `filter` only accepts a *single* input. But now another question arises: why did our interpreter\n*not* complain at the trailing digits that didn't get parsed?\n\nThe answer is that Chumsky's parsers are *lazy*: they will consume all of the input that they can and then stop.\nIf there's any trailing input, it'll be ignored.\n\nThis is obviously not always desirable. If the user places random nonsense at the end of the file, we want to be\nable to generate an error about it! Worse still, that 'nonsense' could be input the user intended to be part of\nthe program, but that contained a syntax error and so was not properly parsed. How can we force the parser to consume\nall of the input?\n\nTo do this, we can make use of two new parsers: the `then_ignore` combinator and the `end` primitive.\n\n```rust\nfilter(|c: &char| c.is_ascii_digit())\n    .map(|c| Expr::Num(c.to_digit(10).unwrap() as f64))\n    .then_ignore(end())\n```\n\nThe `then_ignore` combinator parses a second pattern after the first, but ignores its output in favour of that of the\nfirst.\n\nThe `end` primitive succeeds if it encounters only the end of input.\n\nCombining these together, we now get an error for longer inputs. Unfortunately, this just reveals another problem\n(particularly if you're working on a Unix-like platform): any whitespace before or after our digit will upset our\nparser and trigger an error.\n\nWe can handle whitespace by adding a call to `padded_by` (which ignores a given pattern before and after the first)\nafter our digit parser, and a repeating filter for any whitespace characters.\n\n```rust\nfilter(|c: &char| c.is_ascii_digit())\n    .map(|c| Expr::Num(c.to_digit(10).unwrap() as f64))\n    .padded_by(filter(|c: &char| c.is_whitespace()).repeated())\n    .then_ignore(end())\n```\n\nThis example should have taught you a few important things about Chumsky's parsers:\n\n1. Parsers are lazy: trailing input is ignored\n\n2. Whitespace is not automatically ignored. Chumsky is a general-purpose parsing library, and some languages care very\n   much about the structure of whitespace, so Chumsky does too\n\n## Cleaning up and taking shortcuts\n\nAt this point, things are starting to look a little messy. We've ended up writing 4 lines of code to properly parse a\nsingle digit. Let's clean things up a bit. We'll also make use of a bunch of text-based parser primitives that\ncome with Chumsky to get rid of some of this cruft.\n\n```rust\nlet int = text::int(10)\n    .map(|s: String| Expr::Num(s.parse().unwrap()))\n    .padded();\n\nint.then_ignore(end())\n```\n\nThat's better. We've also swapped out our custom digit parser with a built-in parser that parses any non-negative\ninteger.\n\n## Evaluating simple expressions\n\nWe'll now take a diversion away from the parser to create a function that can evaluate our AST. This is the 'heart' of\nour interpreter and is the thing that actually performs the computation of programs.\n\n```rust\nfn eval(expr: &Expr) -> Result<f64, String> {\n    match expr {\n        Expr::Num(x) => Ok(*x),\n        Expr::Neg(a) => Ok(-eval(a)?),\n        Expr::Add(a, b) => Ok(eval(a)? + eval(b)?),\n        Expr::Sub(a, b) => Ok(eval(a)? - eval(b)?),\n        Expr::Mul(a, b) => Ok(eval(a)? * eval(b)?),\n        Expr::Div(a, b) => Ok(eval(a)? / eval(b)?),\n        _ => todo!(), // We'll handle other cases later\n    }\n}\n```\n\nThis function might look scary at first glance, but there's not too much going on here: it just recursively calls\nitself, evaluating each node of the AST, combining the results via operators, until it has a final result. Any runtime\nerrors simply get thrown back down the stack using `?`.\n\nWe'll also change our `main` function a little so that we can pass our AST to `eval`.\n\n```rust\nfn main() {\n    let src = std::fs::read_to_string(std::env::args().nth(1).unwrap()).unwrap();\n\n    match parser().parse(src) {\n        Ok(ast) => match eval(&ast) {\n            Ok(output) => println!(\"{}\", output),\n            Err(eval_err) => println!(\"Evaluation error: {}\", eval_err),\n        },\n        Err(parse_errs) => parse_errs\n            .into_iter()\n            .for_each(|e| println!(\"Parse error: {}\", e)),\n    }\n}\n```\n\nThis looks like a big change, but it's mostly just an extension of the previous code to pass the AST on to `eval` if\nparsing is successful. If unsuccessful, we just print the errors generated by the parser. Right now, none of our\noperators can produce errors when evaluated, but this will change in the future so we make sure to handle them in\npreparation.\n\n## Parsing unary operators\n\nJumping back to our parser, let's handle unary operators. Currently, our only unary operator is `-`, the negation\noperator. We're looking to parse any number of `-`, followed by a number. More formally:\n\n```\nexpr = op* + int\n```\n\nWe'll also give our `int` parser a new name, 'atom', for reasons that will become clear later.\n\n```rust\nlet int = text::int(10)\n    .map(|s: String| Expr::Num(s.parse().unwrap()))\n    .padded();\n\nlet atom = int;\n\nlet op = |c| just(c).padded();\n\nlet unary = op('-')\n    .repeated()\n    .then(atom)\n    .foldr(|_op, rhs| Expr::Neg(Box::new(rhs)));\n\nunary.then_ignore(end())\n```\n\nHere, we meet a few new combinators:\n\n- `repeated` will parse a given pattern any number of times (including zero!), collecting the outputs into a `Vec`\n\n- `then` will parse one pattern and then another immediately afterwards, collecting both outputs into a tuple pair\n\n- `foldr` will take an output of the form `(Vec<T>, U)` and will fold it into a single `U` by repeatedly applying\n  the given function to each element of the `Vec<T>`\n\nThis last combinator is worth a little more consideration. We're trying to parse *any number* of negation operators,\nfollowed by a single atom (for now, just a number). For example, the input `---42` would generate the following input to `foldr`:\n\n```rust\n(['-', '-', '-'], Num(42.0))\n```\n\nThe `foldr` function repeatedly applies the function to 'fold' the elements into a single element, like so:\n\n```rust\n(['-',   '-',   '-'],   Num(42.0))\n  ---    ---    ---     ---------\n   |      |      |           |\n   |      |       \\         /\n   |      |      Neg(Num(42.0))\n   |      |            |\n   |       \\          /\n   |    Neg(Neg(Num(42.0)))\n   |            |\n    \\          /\nNeg(Neg(Neg(Num(42.0))))\n```\n\nThis may be a little hard to conceptualise for those used to imperative programming, but for functional programmers\nit should come naturally: `foldr` is just equivalent to `reduce`!\n\nGive the interpreter a try. You'll be able to enter inputs as before, but also values like `-17`. You can even apply\nthe negation operator multiple times: `--9` will yield a value of `9` in the command line.\n\nThis is exciting: we've finally started to see our interpreter perform useful (sort of) computations!\n\n## Parsing binary operators\n\nLet's keep the momentum going and move over to binary operators. Traditionally, these pose quite a problem for\nparsers. To parse an expression like `3 + 4 * 2`, it's necessary to understand that multiplication\n[binds more eagerly than addition](https://en.wikipedia.org/wiki/Order_of_operations) and hence is applied first.\nTherefore, the result of this expression is `11` and not `14`.\n\nParsers employ a range of strategies to handle these cases, but for Chumsky things are simple: the most eagerly binding\n(highest 'precedence') operators should be those that get considered first when parsing.\n\nIt's worth noting that summation operators (`+` and `-`) are typically considered to have the *same* precedence as\none-another. The same also applies to product operators (`*` and `/`). For this reason, we treat each group as a single\npattern.\n\nAt each stage, we're looking for a simple pattern: a unary expression, following by any number of a combination of an\noperator and a unary expression. More formally:\n\n```\nexpr = unary + (op + unary)*\n```\n\nLet's expand our parser.\n\n```rust\nlet int = text::int(10)\n    .map(|s: String| Expr::Num(s.parse().unwrap()))\n    .padded();\n\nlet atom = int;\n\nlet op = |c| just(c).padded();\n\nlet unary = op('-')\n    .repeated()\n    .then(atom)\n    .foldr(|_op, rhs| Expr::Neg(Box::new(rhs)));\n\nlet product = unary.clone()\n    .then(op('*').to(Expr::Mul as fn(_, _) -> _)\n        .or(op('/').to(Expr::Div as fn(_, _) -> _))\n        .then(unary)\n        .repeated())\n    .foldl(|lhs, (op, rhs)| op(Box::new(lhs), Box::new(rhs)));\n\nlet sum = product.clone()\n    .then(op('+').to(Expr::Add as fn(_, _) -> _)\n        .or(op('-').to(Expr::Sub as fn(_, _) -> _))\n        .then(product)\n        .repeated())\n    .foldl(|lhs, (op, rhs)| op(Box::new(lhs), Box::new(rhs)));\n\nsum.then_ignore(end())\n```\n\nThe `Expr::Mul as fn(_, _) -> _` syntax might look a little unfamiliar, but don't worry! In Rust,\n[tuple enum variants are implicitly functions](https://stackoverflow.com/questions/54802045/what-is-this-strange-syntax-where-an-enum-variant-is-used-as-a-function).\nAll we're doing here is making sure that Rust treats each of them as if they had the same type using the `as` cast, and\nthen letting type inference do the rest. Those functions then get passed through the internals of the parser and end up\nin `op` within the `foldl` call.\n\nAnother three combinators are introduced here:\n\n- `or` attempts to parse a pattern and, if unsuccessful, instead attempts another pattern\n\n- `to` is similar to `map`, but instead of mapping the output, entirely overrides the output with a new value. In our\n  case, we use it to convert each binary operator to a function that produces the relevant AST node for that operator.\n\n- `foldl` is very similar to `foldr` in the last section but, instead of operating on a `(Vec<_>, _)`, it operates\n  upon a `(_, Vec<_>)`, going backwards to combine values together with the function\n\nIn a similar manner to `foldr` in the previous section on unary expressions, `foldl` is used to fold chains of binary\noperators into a single expression tree. For example, the input `2 + 3 - 7 + 5` would generate the following input to\n`foldl`:\n\n```rust\n(Num(2.0), [(Expr::Add, Num(3.0)), (Expr::Sub, Num(7.0)), (Add, Num(5.0))])\n```\n\nThis then gets folded together by `foldl` like so:\n\n```rust\n(Num(2.0),   [(Add, Num(3.0)),   (Sub, Num(7.0)),   (Add, Num(5.0))])\n --------     ---------------     --------------    ---------------\n    |                |                 |                  |\n     \\              /                  |                  |\n Add(Num(2.0), Num(3.0))               |                  |\n            |                          |                  |\n             \\                        /                   |\n      Sub(Add(Num(2.0), Num(3.0)), Num(7.0))              |\n                       |                                  |\n                        \\                                /\n               Add(Sub(Add(Num(2.0), Num(3.0)), Num(7.0)), Num(5.0))\n```\n\nGive the interpreter a try. You should find that it can correctly handle both unary and binary operations combined in\narbitrary configurations, correctly handling precedence. You can use it as a pocket calculator!\n\n## Parsing parentheses\n\nA new challenger approaches: *nested expressions*. Sometimes, we want to override the default operator precedence rules\nentirely. We can do this by nesting expressions within parentheses, like `(3 + 4) * 2`. How do we handle this?\n\nThe creation of the `atom` pattern a few sections before was no accident: parentheses have a greater precedence than\nany operator, so we should treat a parenthesised expression as if it were equivalent to a single value. We call things\nthat behave like single values 'atoms' by convention.\n\nWe're going to hoist our entire parser up into a closure, allowing us to define it in terms of itself.\n\n```rust\nrecursive(|expr| {\n    let int = text::int(10)\n        .map(|s: String| Expr::Num(s.parse().unwrap()))\n        .padded();\n\n    let atom = int\n        .or(expr.delimited_by(just('('), just(')'))).padded();\n\n    let op = |c| just(c).padded();\n\n    let unary = op('-')\n        .repeated()\n        .then(atom)\n        .foldr(|_op, rhs| Expr::Neg(Box::new(rhs)));\n\n    let product = unary.clone()\n        .then(op('*').to(Expr::Mul as fn(_, _) -> _)\n            .or(op('/').to(Expr::Div as fn(_, _) -> _))\n            .then(unary)\n            .repeated())\n        .foldl(|lhs, (op, rhs)| op(Box::new(lhs), Box::new(rhs)));\n\n    let sum = product.clone()\n        .then(op('+').to(Expr::Add as fn(_, _) -> _)\n            .or(op('-').to(Expr::Sub as fn(_, _) -> _))\n            .then(product)\n            .repeated())\n        .foldl(|lhs, (op, rhs)| op(Box::new(lhs), Box::new(rhs)));\n\n    sum\n})\n    .then_ignore(end())\n```\n\nThere are a few things worth paying attention to here.\n\n1. `recursive` allows us to define a parser recursively in terms of itself by giving us a copy of it within the\n   closure's scope\n\n2. We use the recursive definition of `expr` within the definition of `atom`. We use the new `delimited_by` combinator\n   to allow it to sit nested within a pair of parentheses\n\n3. The `then_ignore(end())` call has *not* been hoisted inside the `recursive` call. This is because we only want to\n   parse an end of input on the outermost expression, not at every level of nesting\n\nTry running the interpreter. You'll find that it can handle a surprising number of cases elegantly. Make sure that the\nfollowing cases work correctly:\n\n| Expression    | Expected result |\n|---------------|-----------------|\n| `3 * 4 + 2`   | `14`            |\n| `3 * (4 + 2)` | `18`            |\n| `-4 + 2`      | `-2`            |\n| `-(4 + 2)`    | `-6`            |\n\n## Parsing lets\n\nOur next step is to handle `let`. Unlike Rust and other imperative languages, `let` in Foo is an expression and not an\nstatement (Foo has no statements) that takes the following form:\n\n```\nlet <ident> = <expr>; <expr>\n```\n\nWe only want `let`s to appear at the outermost level of the expression, so we leave it out of the original recursive\nexpression definition. However, we also want to be able to chain `let`s together, so we put them in their own recursive\ndefinition. We call it `decl` ('declaration') because we're eventually going to be adding `fn` syntax too.\n\n```rust\nlet ident = text::ident()\n    .padded();\n\nlet expr = recursive(|expr| {\n    let int = text::int(10)\n        .map(|s: String| Expr::Num(s.parse().unwrap()))\n        .padded();\n\n    let atom = int\n        .or(expr.delimited_by(just('('), just(')')))\n        .or(ident.map(Expr::Var));\n\n    let op = |c| just(c).padded();\n\n    let unary = op('-')\n        .repeated()\n        .then(atom)\n        .foldr(|_op, rhs| Expr::Neg(Box::new(rhs)));\n\n    let product = unary.clone()\n        .then(op('*').to(Expr::Mul as fn(_, _) -> _)\n            .or(op('/').to(Expr::Div as fn(_, _) -> _))\n            .then(unary)\n            .repeated())\n        .foldl(|lhs, (op, rhs)| op(Box::new(lhs), Box::new(rhs)));\n\n    let sum = product.clone()\n        .then(op('+').to(Expr::Add as fn(_, _) -> _)\n            .or(op('-').to(Expr::Sub as fn(_, _) -> _))\n            .then(product)\n            .repeated())\n        .foldl(|lhs, (op, rhs)| op(Box::new(lhs), Box::new(rhs)));\n\n    sum\n});\n\nlet decl = recursive(|decl| {\n    let r#let = text::keyword(\"let\")\n        .ignore_then(ident)\n        .then_ignore(just('='))\n        .then(expr.clone())\n        .then_ignore(just(';'))\n        .then(decl)\n        .map(|((name, rhs), then)| Expr::Let {\n            name,\n            rhs: Box::new(rhs),\n            then: Box::new(then),\n        });\n\n    r#let\n        // Must be later in the chain than `r#let` to avoid ambiguity\n        .or(expr)\n        .padded()\n});\n\ndecl\n    .then_ignore(end())\n```\n\n`keyword` is simply a parser that looks for an exact identifier (i.e: it doesn't match identifiers that only start with\na keyword).\n\nOther than that, there's nothing in the definition of `r#let` that you haven't seen before: familiar combinators, but\ncombined in different ways. It selectively ignores parts of the syntax that we don't care about after validating that\nit exists, then uses those elements that it does care about to create an `Expr::Let` AST node.\n\nAnother thing to note is that the definition of `ident` will parse `\"let\"`. To avoid the parser accidentally deciding\nthat `\"let\"` is a variable, we place `r#let` earlier in the or chain than `expr` so that it prioritises the correct\ninterpretation. As mentioned in previous sections, Chumsky handles ambiguity simply by choosing the first successful\nparse it encounters, so making sure that we declare things in the right order can sometimes be important.\n\nYou should now be able to run the interpreter and have it accept an input such as\n\n```\nlet five = 5;\nfive * 3\n```\n\nUnfortunately, the `eval` function will panic because we've not yet handled `Expr::Var` or `Expr::Let`. Let's do that\nnow.\n\n```rust\nfn eval<'a>(expr: &'a Expr, vars: &mut Vec<(&'a String, f64)>) -> Result<f64, String> {\n    match expr {\n        Expr::Num(x) => Ok(*x),\n        Expr::Neg(a) => Ok(-eval(a, vars)?),\n        Expr::Add(a, b) => Ok(eval(a, vars)? + eval(b, vars)?),\n        Expr::Sub(a, b) => Ok(eval(a, vars)? - eval(b, vars)?),\n        Expr::Mul(a, b) => Ok(eval(a, vars)? * eval(b, vars)?),\n        Expr::Div(a, b) => Ok(eval(a, vars)? / eval(b, vars)?),\n        Expr::Var(name) => if let Some((_, val)) = vars.iter().rev().find(|(var, _)| *var == name) {\n            Ok(*val)\n        } else {\n            Err(format!(\"Cannot find variable `{}` in scope\", name))\n        },\n        Expr::Let { name, rhs, then } => {\n            let rhs = eval(rhs, vars)?;\n            vars.push((name, rhs));\n            let output = eval(then, vars);\n            vars.pop();\n            output\n        },\n        _ => todo!(),\n    }\n}\n```\n\nWoo! That got a bit more complicated. Don't fear, there are only 3 important changes:\n\n1. Because we need to keep track of variables that were previously defined, we use a `Vec` to remember them. Because\n   `eval` is a recursive function, we also need to pass is to all recursive calls.\n\n2. When we encounter an `Expr::Let`, we first evaluate the right-hand side (`rhs`). Once evaluated, we push it to the\n   `vars` stack and evaluate the trailing `then` expression (i.e: all of the remaining code that appears after the\n   semicolon). Popping it afterwards is not *technically* necessary because Foo does not permit nested declarations,\n   but we do it anyway because it's good practice and it's what we'd want to do if we ever decided to add nesting.\n\n3. When we encounter an `Expr::Var` (i.e: an inline variable) we search the stack *backwards* (because Foo permits\n   [variable shadowing](https://en.wikipedia.org/wiki/Variable_shadowing) and we only want to find the most recently\n   declared variable with the same name) to find the variables's value. If we can't find a variable of that name, we\n   generate a runtime error which gets propagated back up the stack.\n\nObviously, the signature of `eval` has changed so we'll update the call in `main` to become:\n\n```rust\neval(&ast, &mut Vec::new())\n```\n\nMake sure to test the interpreter. Try experimenting with `let` declarations to make sure things aren't broken. In\nparticular, it's worth testing variable shadowing by ensuring that the following program produces `8`:\n\n```\nlet x = 5;\nlet x = 3 + x;\nx\n```\n\n## Parsing functions\n\nWe're almost at a complete implementation of Foo. There's just one thing left: *functions*.\n\nSurprisingly, parsing functions is the easy part. All we need to modify is the definition of `decl` to add `r#fn`. It\nlooks very much like the existing definition of `r#let`:\n\n```rust\nlet decl = recursive(|decl| {\n    let r#let = text::keyword(\"let\")\n        .ignore_then(ident)\n        .then_ignore(just('='))\n        .then(expr.clone())\n        .then_ignore(just(';'))\n        .then(decl.clone())\n        .map(|((name, rhs), then)| Expr::Let {\n            name,\n            rhs: Box::new(rhs),\n            then: Box::new(then),\n        });\n\n    let r#fn = text::keyword(\"fn\")\n        .ignore_then(ident)\n        .then(ident.repeated())\n        .then_ignore(just('='))\n        .then(expr.clone())\n        .then_ignore(just(';'))\n        .then(decl)\n        .map(|(((name, args), body), then)| Expr::Fn {\n            name,\n            args,\n            body: Box::new(body),\n            then: Box::new(then),\n        });\n\n    r#let\n        .or(r#fn)\n        .or(expr)\n        .padded()\n});\n```\n\nThere's nothing new here, you understand this all already.\n\nObviously, we also need to add support for *calling* functions by modifying `atom`:\n\n```rust\nlet call = ident\n    .then(expr.clone()\n        .separated_by(just(','))\n        .allow_trailing() // Foo is Rust-like, so allow trailing commas to appear in arg lists\n        .delimited_by(just('('), just(')')))\n    .map(|(f, args)| Expr::Call(f, args));\n\nlet atom = int\n    .or(expr.delimited_by(just('('), just(')')))\n    .or(call)\n    .or(ident.map(Expr::Var));\n```\n\nThe only new combinator here is `separated_by` which behaves like `repeated`, but requires a separator pattern between\neach element. It has a method called `allow_trailing` which allows for parsing a trailing separator at the end of the\nelements.\n\nNext, we modify our `eval` function to support a function stack.\n\n```rust\nfn eval<'a>(\n    expr: &'a Expr,\n    vars: &mut Vec<(&'a String, f64)>,\n    funcs: &mut Vec<(&'a String, &'a [String], &'a Expr)>,\n) -> Result<f64, String> {\n    match expr {\n        Expr::Num(x) => Ok(*x),\n        Expr::Neg(a) => Ok(-eval(a, vars, funcs)?),\n        Expr::Add(a, b) => Ok(eval(a, vars, funcs)? + eval(b, vars, funcs)?),\n        Expr::Sub(a, b) => Ok(eval(a, vars, funcs)? - eval(b, vars, funcs)?),\n        Expr::Mul(a, b) => Ok(eval(a, vars, funcs)? * eval(b, vars, funcs)?),\n        Expr::Div(a, b) => Ok(eval(a, vars, funcs)? / eval(b, vars, funcs)?),\n        Expr::Var(name) => if let Some((_, val)) = vars.iter().rev().find(|(var, _)| *var == name) {\n            Ok(*val)\n        } else {\n            Err(format!(\"Cannot find variable `{}` in scope\", name))\n        },\n        Expr::Let { name, rhs, then } => {\n            let rhs = eval(rhs, vars, funcs)?;\n            vars.push((name, rhs));\n            let output = eval(then, vars, funcs);\n            vars.pop();\n            output\n        },\n        Expr::Call(name, args) => if let Some((_, arg_names, body)) = funcs\n            .iter()\n            .rev()\n            .find(|(var, _, _)| *var == name)\n            .copied()\n        {\n            if arg_names.len() == args.len() {\n                let mut args = args\n                    .iter()\n                    .map(|arg| eval(arg, vars, funcs))\n                    .zip(arg_names.iter())\n                    .map(|(val, name)| Ok((name, val?)))\n                    .collect::<Result<_, String>>()?;\n                vars.append(&mut args);\n                let output = eval(body, vars, funcs);\n                vars.truncate(vars.len() - args.len());\n                output\n            } else {\n                Err(format!(\n                    \"Wrong number of arguments for function `{}`: expected {}, found {}\",\n                    name,\n                    arg_names.len(),\n                    args.len(),\n                ))\n            }\n        } else {\n            Err(format!(\"Cannot find function `{}` in scope\", name))\n        },\n        Expr::Fn { name, args, body, then } => {\n            funcs.push((name, args, body));\n            let output = eval(then, vars, funcs);\n            funcs.pop();\n            output\n        },\n    }\n}\n```\n\nAnother big change! On closer inspection, however, this looks a lot like the change we made previously when we added\nsupport for `let` declarations. Whenever we encounter an `Expr::Fn`, we just push the function to the `funcs` stack and\ncontinue. Whenever we encounter an `Expr::Call`, we search the function stack backwards, as we did for variables, and\nthen execute the body of the function (making sure to evaluate and push the arguments!).\n\nAs before, we'll need to change the `eval` call in `main` to:\n\n```rust\neval(&ast, &mut Vec::new(), &mut Vec::new())\n```\n\nGive the interpreter a test - see what you can do with it! Here's an example program to get you started:\n\n```\nlet five = 5;\nlet eight = 3 + five;\nfn add x y = x + y;\nadd(five, eight)\n```\n\n## Conclusion\n\nHere ends our exploration into Chumsky's API. We only scratched the surface of what Chumsky can do, but now you'll need\nto rely on the examples in the repository and the API doc examples for further help. Nonetheless, I hope it was an\ninteresting foray into the use of parser combinators for the development of parsers.\n\nIf nothing else, you've now got a neat little calculator language to play with.\n\nInterestingly, there is a subtle bug in Foo's `eval` function that produces unexpected scoping behaviour with function\ncalls. I'll leave finding it as an exercise for the reader.\n\n## Extension tasks\n\n- Find the interesting function scoping bug and consider how it could be fixed\n\n- Split token lexing into a separate compilation stage to avoid the need for `.padded()` in the parser\n\n- Add more operators\n\n- Add an `if <expr> then <expr> else <expr>` ternary operator\n\n- Add values of different types by turning `f64` into an `enum`\n\n- Add lambdas to the language\n\n- Format the error message in a more useful way, perhaps by providing a reference to the original code\n"
        }
      ]
    }
  ]
}