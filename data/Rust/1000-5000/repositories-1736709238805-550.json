{
  "metadata": {
    "timestamp": 1736709238805,
    "page": 550,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "audulus/rui",
      "stars": 1798,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".cargo",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3994140625,
          "content": "# Generated by Cargo\n# will have compiled files and executables\n/target/\n\n# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries\n# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html\nCargo.lock\n\n# These are backup files generated by rustfmt\n**/*.rs.bk\n\n\n# Added by cargo\n#\n# already existing elements were commented out\n\n/target\n#Cargo.lock\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 1.001953125,
          "content": "[workspace]\nresolver = \"2\" # What does this do?\n\n[package]\nname = \"rui\"\ndescription = \"Experimental Declarative UI library\"\nversion = \"0.6.1\"\nlicense = \"MIT\"\nreadme = \"README.md\"\nauthors = [\"Taylor Holliday <taylor@audulus.com>\"]\nkeywords = [\"ui\", \"gui\", \"declarative\"]\ncategories = [\"gui\"]\nrepository = \"https://github.com/audulus/rui\"\nedition = \"2018\"\nexclude = [ \"screenshots/*\" ]\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[features]\ndefault = [ \"winit\" ]\n\n[dependencies]\neuclid = \"0.22.7\"\nwgpu = \"0.20.0\"\nfutures = \"0.3\"\nvger = \"0.3\"\naccesskit = \"0.16.0\"\nlazy_static = \"1.4.0\"\nwinit = { version = \"0.30\", optional = true }\nlog = \"0.4\"\n\n# Seems we can't publish to crates.io with this dependency.\n# baseview = { git = \"https://github.com/RustAudio/baseview\", optional = true }\n\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\nwasm-bindgen = \"0.2.76\"\nweb-sys = { version = \"^0.3.61\", features = [\"Location\"] }\nconsole_log = \"1\"\nconsole_error_panic_hook = \"0.1.6\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2022 Audulus LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.3916015625,
          "content": "<p align=\"center\">\n<img src=\"rui.png\" alt=\"logo\" width=\"200\"/>\n</p>\n\n# rui\n\n![build status](https://github.com/audulus/rui/actions/workflows/rust.yml/badge.svg)\n[![dependency status](https://deps.rs/repo/github/audulus/rui/status.svg)](https://deps.rs/repo/github/audulus/rui)\n\nExperimental Rust UI library, inspired by SwiftUI. Early days, but some stuff already works. rui will be used for a future version of [Audulus](http://audulus.com/)\n\nrui is GPU rendered and updates reactively (when your state changes). The focus of rui is to have the best ergonomics, and use the simplest possible implementation. As such, there is no retained view tree (DOM) or view diffing. Everything is re-rendered when state changes, under the assumption that we can do that quickly.\n\n[discord server](https://discord.gg/JCVVBU3sCN)\n\n- macOS ✅ \n- Windows ✅\n- Linux ✅ \n- iOS ✅ (see https://github.com/audulus/rui-ios)\n- wasm (WIP)\n\n## Examples\n\nobligatory Counter (`cargo run --example counter`):\n\n```rust\nuse rui::*;\n\nfn main() {\n    state(\n        || 1,\n        |count, cx| {\n            vstack((\n                cx[count].padding(Auto),\n                button(\"increment\", move |cx| {\n                    cx[count] += 1;\n                })\n                .padding(Auto),\n            ))\n        },\n    )\n    .run()\n}\n```\n\n<img src=\"screenshots/counter.png\" alt=\"counter screenshot\" style=\"width:50%;\">\n\nsome shapes (`cargo run --example shapes`):\n\n```rust\nuse rui::*;\n\nfn main() {\n    vstack((\n        circle()\n            .color(RED_HIGHLIGHT)\n            .padding(Auto),\n        rectangle()\n            .corner_radius(5.0)\n            .color(AZURE_HIGHLIGHT)\n            .padding(Auto)\n    ))\n    .run()\n}\n```\n\n<img src=\"screenshots/shapes.png\" alt=\"shapes screenshot\" style=\"width:50%;\">\n\ncanvas for gpu drawing (`cargo run --example canvas`):\n\n```rust\nuse rui::*;\n\nfn main() {\n    canvas(|_, rect, vger| {\n        vger.translate(rect.center() - LocalPoint::zero());\n\n        let paint = vger.linear_gradient(\n            [-100.0, -100.0],\n            [100.0, 100.0],\n            AZURE_HIGHLIGHT,\n            RED_HIGHLIGHT,\n            0.0,\n        );\n\n        let radius = 100.0;\n        vger.fill_circle(LocalPoint::zero(), radius, paint);\n    })\n    .run()\n}\n```\n\n<img src=\"screenshots/canvas.png\" alt=\"canvas screenshot\" style=\"width:50%;\">\n\n`slider` with `map` (`cargo run --example slider`):\n\n```rust\nuse rui::*;\n\n#[derive(Default)]\nstruct MyState {\n    value: f32,\n}\n\n/// A slider with a value.\nfn my_slider(s: impl Binding<f32>) -> impl View {\n    with_ref(s, move |v| {\n        vstack((\n            v.to_string().font_size(10).padding(Auto),\n            hslider(s).thumb_color(RED_HIGHLIGHT).padding(Auto),\n        ))\n    })\n}\n\nfn main() {\n    state(MyState::default, |state, cx| \n        map(\n            cx[state].value,\n            move |v, cx| cx[state].value = v,\n            |s, _| my_slider(s),\n        ),\n    )\n    .run()\n}\n```\n\n<img src=\"screenshots/slider.png\" alt=\"slider screenshot\" style=\"width:50%;\">\n\nwidget gallery (`cargo run --example gallery`):\n\n<img src=\"screenshots/gallery.png\" alt=\"widgets gallery screenshot\" style=\"width:50%;\">\n\n## Goals\n\n- Encode UI in types to ensure stable identity.\n- Optimize to reduce redraw.\n- Use [vger-rs](https://github.com/audulus/vger-rs) for rendering.\n- Minimal boilerplate.\n- Good looking.\n- No `unsafe`.\n- Accessibility for assistive technologies.\n\n## Optional Features\n\n- `winit` - (*enabled by default*) use winit for windowing.\n- Use `default-features = false` if you are embedding rui (see https://github.com/audulus/rui-ios).\n\n## Why and how?\n\nIn the long term, I'd like to move [Audulus](http://audulus.com/) over to Rust. After looking at other available UI options, it seemed best to implement something resembling the existing immediate mode UI system I already have working in Audulus, but better.\n\nI had been enjoying the ergonomics of SwiftUI, but SwiftUI simply can't handle big node graphs very well ([we have tried]( https://github.com/audiokit/flow) and had to fall back to manual layout and render with [Canvas](https://developer.apple.com/documentation/swiftui/canvas), so we couldn't put custom Views within each node). What you find with SwiftUI (particularly when profiling) is that there's a lot of machinery dealing with the caching aspects of things. It's opaque, scary (crashes on occasion, parts are implemented in C++ not Swift!), and can be rather slow. Often, it seems to be caching things thare are trivial to recompute in the first place.\n\nNot so long ago, before programmable shaders, it was necessary to cache parts of a UI in textures (CoreAnimation for example does this) to get good performance. Now we have extremely fast GPUs and such caching is not necessary to achieve good performance. In fact if enough is animating, lots of texture caching can hinder performance, since the caches need to be updated so often. Plus, the textures consume a fair amount of memory, and when you have an unbounded node-graph like Audulus, that memory usage would be unbounded. And what resolution do you pick for those textures?\n\nSo rui starts from the assumption that 2D UI graphics (not general vector graphics!) are a trivial workload for a GPU. If you consider how advanced games are now, doing realtime global illumination and such, this seems intuitively correct, but Audulus more-or-less proves it. So that means we can do away with the texture caching, and we really might not even need damage regions either. I'm also skeptical of the need for parallel encoding or caching parts of the scene for 2D UI graphics, since, again, it's just a trivial GPU workload.\n\nLayout, on the other hand, can't easily be offloaded to GPU free-performance land. It's necessary to cache layout information and try not to recompute it all the time. So rui caches layout and only recomputes it when the state changes (unlike a typical immediate mode UI which computes layout on the fly and is constrained to very simple layouts). For Audulus, this isn't quite enough, since some view-local state will be changing all the time as things are animating (Audulus solves this by only recomputing layout when the central document state changes). Perhaps this is where proponents of DOM-ish things (some other OOP-ish tree of widgets) would jump in and make their case, but I'm skeptical that's really necessary. Think of what actually needs to be (re)computed: a layout box for each (ephemeral) View. Does this really require a separate tree of objects? Time will tell!\n\n## Status\n\n- ✅ basic shapes: circle, rounded rectangle\n- ✅ basic gestures: tap, drag\n- ✅ hstack/vstack\n- ✅ text\n- ✅ padding\n- ✅ offsets\n- ✅ state\n- ✅ zstack\n- ✅ canvas (GPU vector graphics with vger)\n- ✅ bindings\n- ✅ list\n- ✅ sliders\n- ✅ knobs\n- ✅ editable text (still a bit rough)\n- ✅ any_view (view type erasure)\n- ✅ layout feedback\n- ✅ animation\n- ✅ UI unit testing\n\n## References\n\n[Towards principled reactive UI](https://raphlinus.github.io/rust/druid/2020/09/25/principled-reactive-ui.html)\n\n[Towards a unified theory of reactive UI](https://raphlinus.github.io/ui/druid/2019/11/22/reactive-ui.html)\n\n[Flutter's Rendering Pipeline](https://www.youtube.com/watch?v=UUfXWzp0-DU)\n\n[Static Types in SwiftUI](https://www.objc.io/blog/2019/11/05/static-types-in-swiftui/)\n\n[How Layout Works in SwiftUI](https://www.hackingwithswift.com/books/ios-swiftui/how-layout-works-in-swiftui)\n\n[Xilem: an architecture for UI in Rust](https://raphlinus.github.io/rust/gui/2022/05/07/ui-architecture.html)\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "rui.png",
          "type": "blob",
          "size": 62.9775390625,
          "content": null
        },
        {
          "name": "rust-toolchain",
          "type": "blob",
          "size": 0.0068359375,
          "content": "stable\n"
        },
        {
          "name": "screenshots",
          "type": "tree",
          "content": null
        },
        {
          "name": "sign-examples.sh",
          "type": "blob",
          "size": 0.5869140625,
          "content": "#!/bin/zsh\n\n# This re-signs the examples so they can be profiled with Instruments on macOS.\n# See https://developer.apple.com/forums/thread/681687\n\n# Make sure to set the shell to zsh, not bash\n#\n# For Instruments, re-sign binary with get-task-allow entitlement\ncodesign -s - -v -f --entitlements =(echo -n '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"https://www.apple.com/DTDs/PropertyList-1.0.dtd\"\\>\n<plist version=\"1.0\">\n    <dict>\n        <key>com.apple.security.get-task-allow</key>\n        <true/>\n    </dict>\n</plist>') target/debug/examples/*\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}