{
  "metadata": {
    "timestamp": 1736708966559,
    "page": 1,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "WebAssembly/WASI",
      "stars": 4988,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": "*.wasm"
        },
        {
          "name": "Charter.md",
          "type": "blob",
          "size": 2.3466796875,
          "content": "# WebAssembly System Interface Subgroup Charter\n\nThe System Interface Subgroup is a sub-organization of the\n[WebAssembly Community Group](https://www.w3.org/community/webassembly/) of the W3C.\nAs such, it is intended that its charter align with that of the CG. In particular, \nthe sections of the [CG charter](https://webassembly.github.io/cg-charter/) relating to\n[Community and Business Group Process](https://webassembly.github.io/cg-charter/#process),\n[Contribution Mechanics](https://webassembly.github.io/cg-charter/#contrib),\n[Transparency](https://webassembly.github.io/cg-charter/#transparency), and\n[Decision Process](https://webassembly.github.io/cg-charter/#decision) also apply to the Subgroup.\n\n## Goals\n\nThe mission of this subgroup is to provide a forum for pre-standardization\ncollaboration on a system interface API for WebAssembly programs.\n\n## Scope\n\nThe Subgroup will consider topics related to system interface APIs, including:\n\n- APIs for host filesystems, network stacks, and other resources.\n- APIs for graphics, audio, input devices\n- APIs for encryption, format conversion, and other transformations\n  (particularly where hardware acceleration may be available on some platforms)\n\n\n## Deliverables\n\n### Specifications\nThe Subgroup may produce several kinds of specification-related work output:\n- Creation of new specifications in standards bodies or working\ngroups (e.g. Wasm WG or TC39)\n- Creation of new specifications outside of standards bodies\n(e.g. similar to the LLVM object file format documentation in Wasm tool conventions)\n\n### Non-normative reports\nThe Subgroup may produce non-normative material such as requirements\ndocuments, recommendations, and use cases.\n\n### Software\nThe Subgroup may produce software related to Wasm system interface APIs (either\nas standalone libraries, tooling, or integration of interface-related\nfunctionality in existing CG software such as Binaryen or WABT). Capabilities may\ninclude:\n- Libraries implementing external standard APIs in terms of WebAssembly\n  System Interface APIs\n- Tools for producing code that uses WebAssembly System Interface APIs\n- Tools for implementing WebAssembly APIs\n- Tools for debugging programs using WebAssembly System Interface APIs\n\n## Amendments to this Charter and Chair Selection\n\nThis charter may be amended, and Subgroup Chairs may be selected by vote of the full\nWebAssembly Community Group.\n\n"
        },
        {
          "name": "Contributing.md",
          "type": "blob",
          "size": 8.5556640625,
          "content": "# Contributing to WASI\n\nInterested in participating? Please follow\n[the same contributing guidelines as the design repository][].\n\n[the same contributing guidelines as the design repository]: https://github.com/WebAssembly/design/blob/master/Contributing.md\n\nAlso, please be sure to read [the README.md](README.md) for this repository.\n\nTo contribute to an [existing proposal](https://github.com/WebAssembly/WASI/blob/main/Proposals.md),\nrefer to the linked proposal repository.\n\nThe start a new proposal, the first step is to file an issue in the\n[WASI repository](https://github.com/WebAssembly/WASI/issues) presenting\nthe idea. A good API proposal should discuss the scope of the API,\nthe use cases, and the places it would be expected to be implemented.\nThen proceed with the rest of the steps in phase 0 described below.\n\nIf you have any questions about any step of the process, please reach out\nto one of the WASI Subgroup (SG) chairs.\n\n## The Phase Process\n\nThe following process is modeled after [WebAssembly CG's Phase Process],\nthough it differs in several areas, to reflect the unique needs of APIs.\n\nSomething is out-of-scope if it doesn't fit the [WASI Subgroup's charter](https://github.com/WebAssembly/WASI/blob/main/Charter.md) and there's agreement that the charter should not be amended to cover the proposal.\n\nIn general, the process moves forward through a series of numbered phases.\nHowever, if issues are uncovered or consensus devolves,\nproposals should back up to the appropriate prior step.\n\nNo vote is required for a proposal to enter phase 0. To advance from one phase\nto another, a vote proposing the advancement is added to a\n[WASI Subgroup meeting](https://github.com/WebAssembly/meetings/tree/main/wasi) agenda\nthrough a pull request, and the SG votes on whether to approve it, evaluating\nwhether the new phase's entry requirements have been met.\n\n### 0. Pre-Proposal [Individual Contributor]\n\nEntry requirements:\n\n  * A WASI Subgroup (SG) member has an idea. Notably, no SG vote is required to begin phase 0.\n\nDuring this phase:\n\n  1. An issue is filed on the [WASI repository](https://github.com/WebAssembly/WASI/issues) to present the idea.\n  1. Discussion on the API occurs on the issue.\n  1. A champion or champions emerge. They may add the proposal to the [proposal list](https://github.com/WebAssembly/WASI/blob/main/Proposals.md) at phase 0.\n  1. The champion(s) put together a description of the API in their own GitHub repository or on the issue. You can use the [proposal template] if you like, but it's not required in this phase.\n\n### 1. Feature Proposal [WASI Subgroup]\n\nEntry requirements:\n\n  * There is general interest within the SG in this API.\n  * The SG believes the API is in-scope and will plausibly be workable.\n\nDuring this phase:\n\n  1. If the proposal is not already listed, it should be added to the [proposal list](https://github.com/WebAssembly/WASI/blob/main/Proposals.md) at this time.\n  1. A new repository, forking the [proposal template] repo, is created by one of the SG chairs, or transferred to the WebAssembly organization by the champion.\n  1. The champion will attempt to reach broad consensus in the Subgroup.\n  1. Pull requests and issues are used to iterate on the design of the API. Specifically, an overview document must be produced that specifies the API with reasonably precise and complete language before attempting to move to phase 2 (meaning it is sufficiently precise to be implemented following this description, without obvious holes or ambiguities).\n  1. If relevant to demonstrate the viability of a API, prototype implementations of the API are implemented by interested embedders (possibly on a branch).\n\nAdditionally during this phase:\n\n * The champions define the *portability criteria* for Phase 4.\n\n   This is intended to translate the spirit of the CG Phase Process' \"Two or more Web VMs\" requirement to meet WASI's needs. The criteria should establish at least:\n    - Two or more implementations: Each proposal should say what kinds of implementations.\n    - Portability: WASI APIs should be portable, however that can mean different things to different use cases, and no one definition covers everything. Consequently, each proposal should define criteria establishing its specific portability requirements.\n    - Practicality: It's important that WASI APIs be implementable and usable in real-world use cases, so each proposal should define criteria establishing a sufficient level of confidence.\n    - Testing: APIs will have different needs in terms of environments needed to test them, so each proposal should define criteria establishing what form the testing will take.\n\n### 2. Feature Description Available [WASI Subgroup]\n\nEntry requirements:\n\n   * The portability criteria are documented in the proposal.\n   * Precise and complete overview document is available in a proposal repo around which a reasonably high level of consensus exists.\n   * A [wit](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) description of the API exists.\n   * All dependencies of the wit description must have reached phase 2.\n\nDuring this phase:\n\n   * One or more implementations proceed on prototyping the API.\n   * A plan is developed for how the portability criteria will be met.\n\n## 3. Implementation Phase [WASI Subgroup]\n\nEntry requirements:\n\n   * The portability criteria must be either met or there must be a plan for how they're expected to be met.\n   * All dependencies of the wit descriptions must have reached phase 3.\n\nDuring this phase, the following proceeds in parallel:\n\n   * Implementations are built\n   * Toolchains, libraries, and other tools using the API are built\n   * Remaining open questions are resolved.\n   * The plan for satisfying the portability criteria is followed, though the plan may change over time.\n\n### Phases 4 & 5: To be determined\n\nPhases 4 and 5 are where a feature is finished and standardized. As WASI matures, the WASI Subgroup will coordinate with its parent WebAssembly Community Group and the WebAssembly Working Group to define a process for standardization.\n\n[proposal template]: https://github.com/WebAssembly/wasi-proposal-template\n[WASI meeting agenda]: https://github.com/WebAssembly/meetings/tree/main/wasi\n[WebAssembly CG's Phase Process]: https://github.com/WebAssembly/meetings/blob/main/process/phases.md\n\n## Filing changes to existing phase 3 proposals\n\nExtending existing phase 3 WASI proposals follows a different process than filing\nnew proposals. Because the scope of a phase 3 proposal is already set, further\nchanges to its APIs are tracked independently as phase 2 proposals behind an\n`@unstable` gate in WIT. Once an extension is sufficiently developed, and meets\nthe phase 3 criteria, it must go through a vote in the WASI SG to reach\nphase 3. Once that's done, the `@unstable` gate can be replaced with `@since`,\nand the extension can be included in a future WASI release.\n\nTo submit an extension to an existing phase 3 WASI proposal, the following\nprocess should be followed:\n\n1. File a PR to a WASI proposal repo with the feature extensions behind an\n  `@unstable` gate. Feature gate names all exist in a shared namespace, so they\n  should be prefixed with the parent proposal name. An unstable \"timezone\"\n  feature for the \"clocks\" proposal should be named `clocks-timezone`.\n2. Accepting changes to proposals is done at the discretion of the proposal\n  champions. They will review and work with the PR submitter to get it to a\n  state where it can be merged, or explain why the extension is presently not\n  the right fit for the existing proposal.\n3. Once the champion is ready to merge the proposal, they will submit a PR to\n  the WASI repository (this repository) to file for a new phase 2 feature.\n4. Once the feature is tracked on the WASI repository the champion can now merge\n  the extension. This would also be a good time to inform the WASI SG that an\n  extension has landed - in the interest of keeping relevant parties informed.\n5. Implementers should now be free to begin implementing the extension behind\n  feature flags. The goal at this phase is to implement and iterate on the\n  extension until it is ready to advance to phase 3.\n6. Once the champion believes the phase 3 advancement criteria are met, they\n  should bring it to the WASI SG for a vote.\n7. Once the proposal is voted to advance to phase 3, the `@unstable` gate should\n  be replaced with a `@since` gate containing the version of the next WASI\n  release. It is encouraged to preserve the `feature` field in the `@since` gate to\n  help the transition from the `@unstable` feature to the newly stabilized\n  `@since` gate.\n8. The proposal is now ready to be released as part of the next WASI version.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 0.400390625,
          "content": "Copyright © 2019-2023 the Contributors to the WASI Specification, published\nby the [WebAssembly Community Group][cg] under the\n[W3C Community Contributor License Agreement (CLA)][cla]. A human-readable\n[summary][summary] is available.\n\n[cg]: https://www.w3.org/community/webassembly/\n[cla]: https://www.w3.org/community/about/agreements/cla/\n[summary]: https://www.w3.org/community/about/agreements/cla-deed/\n"
        },
        {
          "name": "Proposals.md",
          "type": "blob",
          "size": 9.4814453125,
          "content": "# WASI proposals\n\nWASI APIs are developed as proposals. These proposals go through 5 phases of development (following [the WASI Subgroup's Phase Process]).\n\nYou can learn more about contributing new proposals (and other ways to contribute) in our [Contributing] guide.\n\n[the WASI Subgroup's Phase Process]: https://github.com/WebAssembly/WASI/blob/main/Contributing.md#the-phase-process\n[Contributing]: https://github.com/WebAssembly/WASI/blob/main/Contributing.md\n\n## Active Proposals\n\n### Phase 5 - The Feature is Standardized (WG)\n\n| Proposal                                                                       | Champion                               | Versions |\n| ------------------------------------------------------------------------------ | -------------------------------------- | -------- |\n\n### Phase 4 - Standardize the Feature (WG)\n\n| Proposal                                                                       | Champion                               | Versions |\n| ------------------------------------------------------------------------------ | -------------------------------------- | -------- |\n\n### Phase 3 - Implementation Phase (CG + WG)\n\n| Proposal                                                                       | Champion                               | Versions |\n| ------------------------------------------------------------------------------ | -------------------------------------- | -------- |\n| [I/O][wasi-io]                                                                 | Dan Gohman                             |          |\n| [Clocks][wasi-clocks]                                                          | Dan Gohman                             |          |\n| [Random][wasi-random]                                                          | Dan Gohman                             |          |\n| [Filesystem][wasi-filesystem]                                                  | Dan Gohman                             |          |\n| [Sockets][wasi-sockets]                                                        | Dave Bakker                            |          |\n| [CLI][wasi-cli]                                                                | Dan Gohman                             |          |\n| [HTTP][wasi-http]                                                              | Piotr Sikora, Jiaxiao Zhou, Dan Chiarlone, David Justice, Luke Wagner |          |\n\n### Phase 2 - Proposed Spec Text Available (CG + WG)\n\n| Proposal                                                                       | Champion                                                      | Versions |\n| ------------------------------------------------------------------------------ |---------------------------------------------------------------| -------- |\n| [I2C][wasi-i2c]                                                                | Friedrich Vandenberghe, Merlijn Sebrechts, Maximilian Seidler |          |\n| [Key-value Store][wasi-kv-store]                                               | Jiaxiao Zhou, Dan Chiarlone, David Justice                    |          |\n| [Machine Learning (wasi-nn)][wasi-nn]                                          | Andrew Brown and Mingqiu Sun                                  |          |\n| [Runtime Config][wasi-runtime-config]                                          | Jiaxiao Zhou, Dan Chiarlone, David Justice                    |          |\n| [GFX][wasi-gfx]                                                                | Mendy Berger, Sean Isom                                       |          |\n| [Messaging][wasi-messaging]                                            | Jiaxiao Zhou, Dan Chiarlone, David Justice, Taylor Thomas     |          |\n\n### Phase 1 - Feature Proposal (CG)\n\n| Proposal                                                                       | Champion                               | Versions |\n| ------------------------------------------------------------------------------ | -------------------------------------- | -------- |\n| [Blob Store][wasi-blob-store]                                                  | Jiaxiao Zhou, Dan Chiarlone, David Justice |          |\n| [Crypto][wasi-crypto]                                                          | Frank Denis and Daiki Ueno             |          |\n| [Digital I/O][wasi-digital-io]                      | Emiel Van Severen |          |\n| [Distributed Lock Service][wasi-distributed-lock-service]                      | Jiaxiao Zhou, Dan Chiarlone, David Justice |          |\n| [Logging][wasi-logging]                                               | Dan Gohman |          |\n| [Observe][wasi-observe]    | Caleb Schoepp                           |          |\n| [Parallel][wasi-parallel]                                                      | Andrew Brown                           |          |\n| [Pattern Match][wasi-pattern-match]                                                      | Jianjun Zhu                           |          |\n| [SPI][wasi-spi]                      | Emiel Van Severen |          |\n| [SQL][wasi-sql]                                                                | Jiaxiao Zhou, Dan Chiarlone, David Justice |          |\n| [SQL Embed][wasi-sql-embed]                                                                | Robin Brown |          |\n| [Threads][wasi-threads]                                                        | Alexandru Ene, Marcin Kolny, Andrew Brown |          |\n| [TLS][wasi-tls]                                                                | Joel Dice, Dave Bakker, James Sturtevant  |          |\n| [URL][wasi-url]                                                                | Radu Matei       |          |\n| [USB][wasi-usb]                                                                | Wouter Hennen, Warre Dujardin, Merlijn Sebrechts | |\n\n### Phase 0 - Pre-Proposal (CG)\n\n**Note:** The pre-proposal phase is simply meant as a way to share ideas. This means that there may be overlap between pre-proposals. It also means that the WASI subgroup has not yet decided that the pre-proposal is in scope for WASI.\n\n| Proposal                                                                       | Champion                               | Versions |\n| ------------------------------------------------------------------------------ | -------------------------------------- | -------- |\n| [proxy-wasm/spec][wasi-proxy-wasm] (will advance as multiple, smaller proposals)    | Piotr Sikora                           |          |\n\n## Versioning\n\nOnce a proposal reaches Phase 3, we expect the champions to start creating releases, following the conventions of semantic versioning (semver). Releases for active proposals are linked in the chart above.\n\nProposals remain in the 0.x semver range until they reach Phase 5 and are fully standardized. At that point, a 1.0 release should be made available.\n\nFor some APIs, it makes sense to add new features after the API itself has reached Phase 5. These feature additions should go through the same standardization process. Once they have reached Phase 5, the minor version number of the release should be incremented.\n\nSome APIs may require backwards-incompatible changes over time. In these cases, we allow proposals to increment the major version number _only if_ the old API can be implemented in terms of the new API. As part of the new version, champions are expected to provide a tool that enables this backwards-compatibility. If that is not possible, then a new API proposal with a new name should be started. The original API can then be deprecated over time if it makes sense to do so.\n\n[WebAssembly CG Phases process]: https://github.com/WebAssembly/meetings/blob/master/process/phases.md\n[witx]: https://github.com/WebAssembly/WASI/blob/main/tools/witx-docs.md\n[ephemeral/snapshot/old process]: https://github.com/WebAssembly/WASI/blob/master/phases/README.md\n\n[wasi-blob-store]: https://github.com/WebAssembly/wasi-blob-store\n[wasi-clocks]: https://github.com/WebAssembly/wasi-clocks\n[wasi-crypto]: https://github.com/WebAssembly/wasi-crypto\n[wasi-data]: https://github.com/singlestore-labs/wasi-data\n[wasi-digital-io]: https://github.com/WebAssembly/wasi-digital-io\n[wasi-distributed-lock-service]: https://github.com/WebAssembly/wasi-distributed-lock-service\n[wasi-filesystem]: https://github.com/WebAssembly/wasi-filesystem\n[wasi-http]: https://github.com/WebAssembly/wasi-http\n[wasi-i2c]: https://github.com/WebAssembly/wasi-i2c\n[wasi-io]: https://github.com/WebAssembly/wasi-io\n[wasi-kv-store]: https://github.com/WebAssembly/wasi-kv-store\n[wasi-logging]: https://github.com/WebAssembly/wasi-logging\n[wasi-messaging]: https://github.com/WebAssembly/wasi-messaging\n[wasi-nn]: https://github.com/WebAssembly/wasi-nn\n[wasi-observe]: https://github.com/dylibso/wasi-observe\n[wasi-parallel]: https://github.com/WebAssembly/wasi-parallel\n[wasi-pattern-match]: https://github.com/WebAssembly/wasi-pattern-match\n[wasi-proxy-wasm]: https://github.com/proxy-wasm/spec\n[wasi-random]: https://github.com/WebAssembly/wasi-random\n[wasi-runtime-config]: https://github.com/WebAssembly/wasi-runtime-config\n[wasi-sockets]: https://github.com/WebAssembly/wasi-sockets\n[wasi-spi]: https://github.com/WebAssembly/wasi-spi\n[wasi-sql]: https://github.com/WebAssembly/wasi-sql\n[wasi-sql-embed]: https://github.com/WebAssembly/wasi-sql-embed\n[wasi-threads]: https://github.com/WebAssembly/wasi-native-threads\n[wasi-tls]: https://github.com/WebAssembly/wasi-tls\n[wasi-url]: https://github.com/WebAssembly/wasi-url\n[wasi-usb]: https://github.com/WebAssembly/wasi-usb\n[wasi-gfx]: https://github.com/WebAssembly/wasi-gfx\n[wasi-cli]: https://github.com/WebAssembly/wasi-cli\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4296875,
          "content": "[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.4323447.svg)](https://doi.org/10.5281/zenodo.4323447)\n    \n# WebAssembly System Interface\n\n![WASI](WASI.png)\n\nThe WebAssembly System Interface (WASI) is a set of APIs for WASI being\ndeveloped for eventual standardization by the WASI Subgroup, which is a\nsubgroup of the WebAssembly Community Group.\n\nWASI started with launching what is now called [Preview 1], an API using\nthe witx IDL, and it is now widely used. Its major influences are POSIX and\nCloudABI.\n\n[WASI Preview 2] is now stable, and is a modular collection of\nAPIs defined with the [Wit IDL], and it incorporates many of the lessons\nlearned from Preview 1, including adding support for a wider range of\nsource languages, modularity, a more expressive type system,\nvirtualizability, and more.\n\n[Preview 1]: https://github.com/WebAssembly/WASI/tree/main/legacy/README.md\n[WASI Preview 2]: https://github.com/WebAssembly/WASI/blob/main/wasip2/README.md\n[Wit IDL]: https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md\n\n## Find the APIs\n\nDevelopment of each API happens in its own repo, which you can access\nfrom the [proposals list](Proposals.md).\n\nThis repo is for general discussion, as well as documenting how we work\nand high-level goals.\n\n## Propose a new API\n\nIf you would like to create a new proposal, get started with our\n[Contributing guide](Contributing.md).\n\nAll new API proposals should use the new format and the new repo structure that is shown in the [proposal template](https://github.com/WebAssembly/wasi-proposal-template).\n\nSee the [Wit in WASI](docs/WitInWasi.md) document for more information about using Wit for WASI proposals.\n\n## WASI High Level Goals\n\n(In the spirit of [WebAssembly's High-Level Goals](https://github.com/WebAssembly/design/blob/main/HighLevelGoals.md).)\n\n1. Define a set of portable, modular, runtime-independent, and\n   WebAssembly-native APIs which can be used by WebAssembly code to interact\n   with the outside world. These APIs preserve the essential sandboxed nature of\n   WebAssembly through a [Capability-based] API design.\n2. Specify and implement incrementally. Start with a Minimum Viable Product\n   (MVP), then adding additional features, prioritized by feedback and\n   experience.\n3. Supplement API designs with documentation and tests, and, when feasible,\n   reference implementations which can be shared between wasm engines.\n4. Make a great platform:\n    * Work with WebAssembly tool and library authors to help them provide\n      WASI support for their users.\n    * When being WebAssembly-native means the platform isn't directly\n      compatible with existing applications written for other platforms,\n      design to enable compatibility to be provided by tools and libraries.\n    * Allow the overall API to evolve over time; to make changes to API\n      modules that have been standardized, build implementations of them\n      using libraries on top of new API modules to provide compatibility.\n\n[Capability-based]: https://en.wikipedia.org/wiki/Capability-based_security\n\n## WASI Design Principles\n\n### Capability-based security\n\nWASI is designed with capability-based security principles, using the\nfacilities provided by the Wasm [component model]. All access to external\nresources is provided by capabilities.\n\nThere are two kinds of capabilities:\n\n - Handles, defined in the [component-model type system], dynamically\n   identify and provide access to resources. They are unforgeable, meaning\n   there's no way for an instance to acquire access to a handle other than\n   to have another instance explicitly pass one to it.\n\n - Link-time capabilities, which are functions which require no handle\n   arguments, are used sparingly, in situations where it's not necessary\n   to identify more than one instance of a resource at runtime. Link-time\n   capabilities are *interposable*, so they are still refusable in a\n   capability-based security sense.\n\nWASI has no *ambient authorities*, meaning that there are no global\nnamespaces at runtime, and no global functions at link time.\n\n[component model]: https://github.com/WebAssembly/component-model\n[component-model type system]: https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#type-definitions\n\nNote that this is a different sense of \"capability\" than [Linux\ncapabilities](http://man7.org/linux/man-pages/man7/capabilities.7.html)\nor the withdrawn [POSIX\ncapabilities](https://archive.org/details/posix_1003.1e-990310), which\nare per-process rather than per-resource.\n\n### Interposition\n\nInterposition in the context of WASI interfaces is the ability for a\nWebassembly instance to implement a given WASI interface, and for a\nconsumer WebAssembly instance to be able to use this implementation\ntransparently. This can be used to adapt or attenuate the functionality\nof a WASI API without changing the code using it.\n\nComponent model interfaces always support link-time interposition. While\nWASI APIs are often implemented in hosts, they can also be implemented\nin Wasm, which may itself be a wrapper around the host. This may be used\nto implement *attenuation*, providing filtered access to the underlying\nhost-provided functionality.\n\nInterposition is sometimes referred to as \"virtualization\", however we\nuse \"interposition\" here because the word \"virtualization\" has several\nrelated meanings.\n\n### Compatibility\n\nCompatibility with existing applications and libraries, as well as\nexisting host platforms, is important, but will sometimes be in conflict\nwith overall API cleanliness, safety, performance, or portability.\nWhere practical, WASI seeks to keep the WASI API itself free of\ncompatibility concerns, and provides compatibility through libraries,\nsuch as WASI libc, and tools. This way, applications which don't require\ncompatibility for compatibility's sake aren't burdened by it.\n\n### Portability\n\nPortability is important to WASI, however the meaning of portability\nwill be specific to each API.\n\nWASI's modular nature means that engines don't need to implement every\nAPI in WASI, so we don't need to exclude APIs just because some host\nenvironments can't implement them. We prefer APIs which can run across\na wide variety of engines when feasible, but we'll ultimately decide\nwhether something is \"portable enough\" on an API-by-API basis.\n\n### Modularity\n\nWASI will include many interfaces that are not appropriate for every host\nenvironment, so WASI uses the component model's worlds mechanism to allow\nspecific sets of APIs to be described which meet the needs of different\nenvironments.\n"
        },
        {
          "name": "WASI.png",
          "type": "blob",
          "size": 10.7998046875,
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "legacy",
          "type": "tree",
          "content": null
        },
        {
          "name": "wasip2",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}