{
  "metadata": {
    "timestamp": 1736709241671,
    "page": 557,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tafia/calamine",
      "stars": 1788,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0673828125,
          "content": "target\nCargo.lock\n*.bk\n.vim\n/.idea/\nfuzz.xlsx\n.idea\nnyc.rs\n.DS_Store\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 1.0546875,
          "content": "[package]\nname = \"calamine\"\nversion = \"0.26.1\"\nauthors = [\"Johann Tuffe <tafia973@gmail.com>\"]\nrepository = \"https://github.com/tafia/calamine\"\ndocumentation = \"https://docs.rs/calamine\"\ndescription = \"An Excel/OpenDocument Spreadsheets reader and deserializer in pure rust\"\nlicense = \"MIT\"\nreadme = \"README.md\"\nkeywords = [\"excel\", \"ods\", \"xls\", \"xlsx\", \"xlsb\"]\ncategories = [\"encoding\", \"parsing\", \"text-processing\"]\nexclude = [\"tests/**/*\"]\nedition = \"2021\"\nrust-version = \"1.73\"\n\n[dependencies]\nbyteorder = \"1.5\"\ncodepage = \"0.1.1\"\nencoding_rs = \"0.8\"\nlog = \"0.4\"\nserde = \"1.0\"\nquick-xml = { version = \"0.36\", features = [\"encoding\"] }\nzip = { version = \"2\", default-features = false, features = [\"deflate\"] }\nchrono = { version = \"0.4\", features = [\n    \"serde\",\n], optional = true, default-features = false }\n\n[dev-dependencies]\nglob = \"0.3\"\nenv_logger = \"0.11\"\nrstest = { version = \"0.21.0\", default-features = false }\nserde_derive = \"1.0\"\nsha2 = \"0.10.8\"\n\n[features]\ndefault = []\ndates = [\"chrono\"]\npicture = []\n\n[package.metadata.docs.rs]\nfeatures = [\"dates\", \"picture\"]\n"
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 10.564453125,
          "content": "> Legend:\n  - feat: A new feature\n  - fix: A bug fix\n  - docs: Documentation only changes\n  - style: White-space, formatting, missing semi-colons, etc\n  - refactor: A code change that neither fixes a bug nor adds a feature\n  - perf: A code change that improves performance\n  - test: Adding missing tests\n  - chore: Changes to the build process or auxiliary tools/libraries/documentation\n\n## Unreleased\n\n## 0.26.1 (2024-10-10)\n\n- fix: sparse celle expect 0 index rows, even when using `header_row`\n\n## 0.26.0 (2024-10-08)\n\n- feat: add ability to merge cells from xls and xlsx\n- feat: add options to keep first empty rows for xlsx\n- feat: support consecutive repeated empty cells for ods\n- feat: add new `header_row` config\n- test: fix broken fuzzer\n- docs: fix broken links in README\n- docs: enable dates and pictures features in docs.rs build\n- chore: bump MRSV to 1.73\n\n\n## 0.25.0 (2024-05-25)\n\n- feat: added `is_error` and `get_error` methods to the `DataType` trait\n- feat: add deserializer helper functions\n- feat: support get merged region\n- feat: add `Range::headers` method\n- feat: expose some `Dimensions` methods\n- fix: use case insensitive comparison when searching for file in xlsx\n- fix: do not panic when reading cell format with invalid index\n- chore: use `OnceLock` instead of once_cell crate (MSRV: 1.71)\n\n## 0.24.0\n\n- refactor (breaking): rename `DataType` enum to `Data` and `DataTypeRef` to `DataRef`\n- feat: introduce a `DataType` trait implemented by both `Data` and `DataRef`.\n- feat: `Data` and `DataType` now return `Some(0{.0})` and `Some(1{.0})` rather than `None` when `.as_i64` or `.as_f64`\n  is used on a Bool value\n- fix: getting tables names on xlsx workbook without _rels files\n- refactor: DateTime(f64) to DateTime(ExcelDateTime)\n- feat: detect xlsb/ods password protected files\n- feat: introduce is_x methods for date and time variants\n\n## 0.23.1\n\n- fix: `worksheet_formula` not returning all formula\n\n## 0.23.0\n\n- feat: add new `DataTypeRef` available from `worksheet_range_ref` to reduce memory usage\n- docs: add benchmark plot\n- fix: truncated text in xls\n- feat: detect if workbook is password protected\n\n## 0.22.1\n\n- fix: regression on `Range::get`\n- chore: update GitHub actions\n- fix: spelling of formula error type\n- feat: support label cells for xls\n- refactor: clippy\n- perf: preallocate several buffers\n\n## 0.22.0\n\n- docs: improve `de_opt_f64` example.\n- docs: remove datetime notice from README\n- feat: add support of sheet type and visibility\n- style: clippy\n- chore: bump MSRV to 1.63 (breaking)\n- chore: set edition to 2021\n- feat: implement blank string handling\n\n## 0.21.2:\n\n- fix: formula with string not displaying properly\n\n## 0.21.1\n\n- chore: bump MSRv to 1.60.0 due to log dependencies\n- fix: xls: formula values ignored\n- fix: xls: formula (string) not displayed properly\n\n## 0.21.0\n\n- fix: (xlsx) support `r` attribute\n- fix: support `PROJECTCOMPATVERSION` in vba\n- fix: incorrect date parsing due to excel bug\n- feat: support for duration\n- test: add MSRV\n\n## 0.20.0\n\n- refactor: bump dependencies\n- feat: __(all) parse format/style information to infer cell as datetime__\n- feat: (ods) support number-columns-repeated attribute\n- refactor: multiple clippy refactorings\n\n## 0.19.2\n\n- feat: Extract picture data by turning `picture` feature on\n\n## 0.19.1\n\n- fix: wrong range len calculation\n- fix: date precision\n\n## 0.19.0\n\n- fix: Several decoding issues in xls and xlsb\n- fix: Wrong decimal parsing\n- refactor: bump dependencies (quick-xml in particular and chrono)\n- feat: always return sheet names in lexicographic order (BTreeMap)\n- chore: remove travis\n\n## 0.18.0\n\n- fix: Allow empty value cells in xlsx\n- fix: obscure xls parsing errors (#195)\n- feat: Improve conversions from raw data to primitives\n- docs: fix two typos in readme\n- feat: replace macro matches! by match expression to reduce MSRV\n\n## 0.17.0\n\n- feat: use `chunks_exact` instead of chunks where possible\n- fix: make `to_u32`, `read_slice` safe and sound\n- fix: security issue #199\n- test: add regression tests that fail with miri\n- feat: detect date/time formatted cells in XLSX\n- feat: brute force file detection if extension is not known\n- feat: support xlsx sheet sizes beyond u32::MAX\n- test: ensure doctest functions actually run\n- test: run cargo fmt to fix travis tests\n- fix: fix Float reading for XLSB\n\n## 0.16.2\n- docs: add `deserialize_with` example in readme\n- fix: Skip phonetic run\n- fix: Fix XLS float parsing error\n- docs: Correct MBSC to MBCS in vba.rs (misspelled before)\n- style: use 2018 edition paths\n- fix: Add the ability to read formula values from XLSB\n- fix: support integral date types\n\n## 0.16.1\n- feat: Make `Metadata.sheets` (and `Reader.sheet_names`) always return names in workbook order\n- style: fix warnings in tests\n\n## 0.16.0\n- feat: deprecate failure and impl `std::error::Error` for all errors.\n- feat: add `dates` feature to enrich `DataType` with date conversions fns.\n\n## 0.15.6\n- feat: update dependencies\n\n## 0.15.5\n- fix: wrong bound comparisons\n\n## 0.15.4\n- feat: improve deserializer\n- feat: bump dependencies\n\n## 0.15.3\n- feat: add several new convenient fn to `DataType`\n- feat: add a `Range::range` fn to get subranges\n- feat: add a new `Range::cells` iterator\n- feat: impl DoubleEndedIterator when possible\n- perf: add some missing `size_hint` impl in iterators\n- feat: add a `Range::get` fn (similar to slice's)\n- perf: add some `ExactSizeIterator`\n\n## 0.15.2\n- feat: consider empty cell as empty str if deserializing to str or String\n\n## 0.15.1\n- fix: xls - allow sectors ending after eof (truncate them!)\n\n## 0.15.0\n- feat: codepage/encoding_rs for codpage mapping\n\n## 0.14.10\n- fix: serde map do not stop at first empty value\n\n## 0.14.9\n- fix: do not return map keys for empty cells. Fixes not working `#[serde(default)]`\n\n## 0.14.8\n- feat: bump dependencies\n- feat: add a `RangeDeserializerBuilder::with_headers` fn to improve serde deserializer\n\n## 0.14.7\n- feat: ods, support *text:s* and *text:p*\n\n## 0.14.6\n- fix: support MulRk for xls files\n\n## 0.14.5\n- fix: properly parse richtext ods files\n- refactor: bump dependencies\n\n## 0.14.4\n- feat: ods: display sheet names in order.\n\n## 0.14.3\n- feat: handle 'covered cells' which are behind merge-cells in ODS\n\n## 0.14.2\n- fix: boolean detection and missing repeated cells in ODS\n- refactor: bump dependencies\n\n## 0.14.1\n- fix: possibility of index out of bound in get_value and eventually in Index<(usize, usize)>\n\n## 0.14.0\n- feat: have Range `start`/`end` return None if the range is actually empty\n- feat: Have `Range::get_value` return an Option if the index is out of range\n\n## 0.13.1\n- refactor: bump dependencies\n- feat: make `Range::from_sparse` public\n\n## 0.13.0\n- feat: migrate from error-chain to failure\n- refactor: simplify Reader trait (enable direct Xlsx read etc ...)\n- refactor: always initialize at creation\n- feat: more documentation on error\n- feat: bump dependencies (calamine, encoding_rs and zip)\n- feat: process any Read not only Files\n- docs: fix various typos\n\n## 0.12.1\n- feat: update dependencies\n\n## 0.12.0\n- feat: add serde deserialization\n\n## 0.11.8\n- perf: update dependencies, in particular quick-xml 0.9.1\n\n## 0.11.7\n- fix: add a bound check when decoding cfb\n- refactor: bump dependencies\n\n## 0.11.6\n- refactor: bump dependencies\n- style: ignore .bk files\n\n## 0.11.5\n- refactor: bump dependencies\n\n## 0.11.4\n- refactor: update to quick-xml 0.7.3 and encoding_rs 0.6.6\n\n## 0.11.3\n- feat: implement Display for DataType and CellTypeError\n- feat: add a CellType alias trait\n\n## 0.11.2\n- perf: update to quick-xml 0.7.1\n\n## 0.11.1\n- refactor: update encoding_rs to 0.6.2\n- perf: add benches and avoid clearing a buffer supposed to be reused\n\n## 0.11.0\n- feat: add support for formula parsing/decoding\n- refactor: make `Range` generic over its content\n- fix: convert codepage 21010 as codepage 1200\n- fix: support EUC_KR encoding\n\n## 0.10.2\n- fix: error while using a singlebyte encoding for xls files (read_dbcs)\n\n## 0.10.1\n- fix: error while using a singlebyte encoding for xls files (short_strings)\n\n## 0.10.0\n- feat: support defined names for named ranges\n- refactor: better internal logics\n\n## 0.9.0\n- refactor: rename `Excel` in `Sheets` to accommodate OpenDocuments\n- feat: add Index/IndexMut for Range\n\n## 0.8.0\n- feat: add basic support for opendocument spreadsheets\n- style: apply rustfmt\n- feat: force rustfmt on travis checks\n\n## 0.7.0\n- fix: extend appveyor paths to be able to use curl\n- refactor: update deps\n- fix: extract richtext reading from `read_shared_strings` to `read_string`,\nand use for inlineStr instead of `read_inline_str`\n- style: rustfmt\n- fix: enable namespaced xmls when parsing xlsx files\n\n## 0.6.0\n- refactor: bump dependencies\n- refactor: move from rust-encoding to encoding_rs (faster), loses some decoders ...\n\n## 0.5.1\n- refactor: bump to quick-xml 0.6.0 (supposedly faster)\n\n## 0.5.0\n- style: rustfmt the code\n- feat: xlsx - support 'inlineStr' elements (`<is>` nodes)\n- fix: xlsx - support sheetnames prefixed with 'xl/' or '/xl/'\n- chore: bump deps (error-chain 0.8.1, quick-xml 0.5.0)\n\n## 0.4.0\n- refactor: replace `try!` with `?` operator\n- feat: adds a new `worksheet_range_by_index` function.\n- feat: adds new `ErrorKind`s\n- refactor: simplify `search_error` example by using a `run()` function\n\n## 0.3.3\n- refactor: update dependencies (error-chain and byteorder)\n\n## 0.3.2\n- refactor: update dependencies\n\n## 0.3.1\n- perf: [xls] preload vba only instead of sheets only\n- refactor: [vba] consume cfb in constructor and do not store cfb\n\n## 0.3.0\n- feat: [all] better `Range` initialization via `Range::from_sparse`\n- feat: [all] several new fn in `Range` (`used_cells`, `start`, `end` ...)\n- refactor: adds a `range_eq!` macro in tests\n\n## 0.2.1\n- fix: [xls] allow directory start to empty sector if version = 3\n- fix: [vba] support all project codepage encodings\n- feat: [xls] early exit if workbook is password protected\n- fix: [xls] better decoding based on codepage\n- fix: [xlsb] simplify setting values and early exit when stepping into an invalid BrtRowHdr\n- fix: [xlsb] fix record length calculation\n\n## 0.2.0\n- fix: [all] allow range to resize when we try to set a value out of bounds\n- docs: less `unwrap`s, no unused imports\n- refactor: range bounds is not (`start`, `end`) instead of (`position`, `size`)\n- feat: add new methods for `Range`: `width`, `height`, `is_empty`\n\n## 0.1.3\n- fix: [xls] better management of continue record for rich_extended_strings\n\n## 0.1.2\n- fix: [all] return error when trying to set out of bound values in `Range`\n- fix: [xls] do a proper encoding when reading cells (force 2 bytes unicode instead of utf8)\n- fix: [xls] support continue records\n- fix: [all] allow empty rows iterator\n\n## 0.1.1\n- fix: remove some development `println!`\n\n## 0.1.0\n- first release!\n"
        },
        {
          "name": "LICENSE-MIT.md",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Johann Tuffe\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.8671875,
          "content": "# calamine\n\nAn Excel/OpenDocument Spreadsheets file reader/deserializer, in pure Rust.\n\n[![GitHub CI Rust tests](https://github.com/tafia/calamine/workflows/Rust/badge.svg)](https://github.com/tafia/calamine/actions)\n[![Build status](https://ci.appveyor.com/api/projects/status/njpnhq54h5hxsgel/branch/master?svg=true)](https://ci.appveyor.com/project/tafia/calamine/branch/master)\n\n[Documentation](https://docs.rs/calamine/)\n\n## Description\n\n**calamine** is a pure Rust library to read and deserialize any spreadsheet file:\n\n- excel like (`xls`, `xlsx`, `xlsm`, `xlsb`, `xla`, `xlam`)\n- opendocument spreadsheets (`ods`)\n\nAs long as your files are *simple enough*, this library should just work.\nFor anything else, please file an issue with a failing test or send a pull request!\n\n## Examples\n\n### Serde deserialization\n\nIt is as simple as:\n\n```rust\nuse calamine::{open_workbook, Error, Xlsx, Reader, RangeDeserializerBuilder};\n\nfn example() -> Result<(), Error> {\n    let path = format!(\"{}/tests/temperature.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut workbook: Xlsx<_> = open_workbook(path)?;\n    let range = workbook.worksheet_range(\"Sheet1\")?;\n\n\n    let mut iter = RangeDeserializerBuilder::new().from_range(&range)?;\n\n    if let Some(result) = iter.next() {\n        let (label, value): (String, f64) = result?;\n        assert_eq!(label, \"celsius\");\n        assert_eq!(value, 22.2222);\n        Ok(())\n    } else {\n        Err(From::from(\"expected at least one record but got none\"))\n    }\n}\n```\n\nCalamine provides helper functions to deal with invalid type values. For\ninstance, to deserialize a column which should contain floats but may also\ncontain invalid values (i.e. strings), you can use the\n[`deserialize_as_f64_or_none`](https://docs.rs/calamine/latest/calamine/fn.deserialize_as_f64_or_none.html)\nhelper function with Serde's\n[`deserialize_with`](https://serde.rs/field-attrs.html) field attribute:\n\n```rust\nuse calamine::{deserialize_as_f64_or_none, open_workbook, RangeDeserializerBuilder, Reader, Xlsx};\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct Record {\n    metric: String,\n    #[serde(deserialize_with = \"deserialize_as_f64_or_none\")]\n    value: Option<f64>,\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let path = format!(\"{}/tests/excel.xlsx\", env!(\"CARGO_MANIFEST_DIR\"));\n    let mut excel: Xlsx<_> = open_workbook(path)?;\n\n    let range = excel\n        .worksheet_range(\"Sheet1\")\n        .map_err(|_| calamine::Error::Msg(\"Cannot find Sheet1\"))?;\n\n    let iter_records =\n        RangeDeserializerBuilder::with_headers(&[\"metric\", \"value\"]).from_range(&range)?;\n\n    for result in iter_records {\n        let record: Record = result?;\n        println!(\"metric={:?}, value={:?}\", record.metric, record.value);\n    }\n\n    Ok(())\n}\n```\n\nThe\n[`deserialize_as_f64_or_none`](https://docs.rs/calamine/latest/calamine/fn.deserialize_as_f64_or_none.html)\nfunction discards all invalid values. If instead you would like to return them\nas `String`s, you can use the similar\n[`deserialize_as_f64_or_string`](https://docs.rs/calamine/latest/calamine/fn.deserialize_as_f64_or_string.html)\nfunction.\n\n### Reader: Simple\n\n```rust\nuse calamine::{Reader, Xlsx, open_workbook};\n\nlet mut excel: Xlsx<_> = open_workbook(\"file.xlsx\").unwrap();\nif let Ok(r) = excel.worksheet_range(\"Sheet1\") {\n    for row in r.rows() {\n        println!(\"row={:?}, row[0]={:?}\", row, row[0]);\n    }\n}\n```\n\n### Reader: With header row\n\n```rs\nuse calamine::{HeaderRow, Reader, Xlsx, open_workbook};\n\nlet mut excel: Xlsx<_> = open_workbook(\"file.xlsx\").unwrap();\n\nlet sheet1 = excel\n    .with_header_row(HeaderRow::Row(3))\n    .worksheet_range(\"Sheet1\")\n    .unwrap();\n```\n\nNote that `xlsx` and `xlsb` files support lazy loading, so specifying a\nheader row takes effect immediately when reading a sheet range.\nIn contrast, for `xls` and `ods` files, all sheets are loaded at once when\nopening the workbook with default settings.\nAs a result, setting the header row only applies afterward and does not\nprovide any performance benefits.\n\n### Reader: More complex\n\nLet's assume\n\n- the file type (xls, xlsx ...) cannot be known at static time\n- we need to get all data from the workbook\n- we need to parse the vba\n- we need to see the defined names\n- and the formula!\n\n```rust\nuse calamine::{Reader, open_workbook_auto, Xlsx, DataType};\n\n// opens a new workbook\nlet path = ...; // we do not know the file type\nlet mut workbook = open_workbook_auto(path).expect(\"Cannot open file\");\n\n// Read whole worksheet data and provide some statistics\nif let Some(Ok(range)) = workbook.worksheet_range(\"Sheet1\") {\n    let total_cells = range.get_size().0 * range.get_size().1;\n    let non_empty_cells: usize = range.used_cells().count();\n    println!(\"Found {} cells in 'Sheet1', including {} non empty cells\",\n             total_cells, non_empty_cells);\n    // alternatively, we can manually filter rows\n    assert_eq!(non_empty_cells, range.rows()\n        .flat_map(|r| r.iter().filter(|&c| c != &DataType::Empty)).count());\n}\n\n// Check if the workbook has a vba project\nif let Some(Ok(mut vba)) = workbook.vba_project() {\n    let vba = vba.to_mut();\n    let module1 = vba.get_module(\"Module 1\").unwrap();\n    println!(\"Module 1 code:\");\n    println!(\"{}\", module1);\n    for r in vba.get_references() {\n        if r.is_missing() {\n            println!(\"Reference {} is broken or not accessible\", r.name);\n        }\n    }\n}\n\n// You can also get defined names definition (string representation only)\nfor name in workbook.defined_names() {\n    println!(\"name: {}, formula: {}\", name.0, name.1);\n}\n\n// Now get all formula!\nlet sheets = workbook.sheet_names().to_owned();\nfor s in sheets {\n    println!(\"found {} formula in '{}'\",\n             workbook\n                .worksheet_formula(&s)\n                .expect(\"sheet not found\")\n                .expect(\"error while getting formula\")\n                .rows().flat_map(|r| r.iter().filter(|f| !f.is_empty()))\n                .count(),\n             s);\n}\n```\n\n## Features\n\n- `dates`: Add date related fn to `DataType`.\n- `picture`: Extract picture data.\n\n### Others\n\nBrowse the [examples](https://github.com/tafia/calamine/tree/master/examples) directory.\n\n## Performance\n\nAs `calamine` is readonly, the comparisons will only involve reading an excel `xlsx` file and then iterating over the rows. Along with `calamine`, three other libraries were chosen, from three different languages:\n\n- [`excelize`](https://github.com/qax-os/excelize) written in `go`\n- [`ClosedXML`](https://github.com/ClosedXML/ClosedXML) written in `C#`\n- [`openpyxl`](https://foss.heptapod.net/openpyxl/openpyxl) written in `python`\n\nThe benchmarks were done using this [dataset](https://raw.githubusercontent.com/wiki/jqnatividad/qsv/files/NYC_311_SR_2010-2020-sample-1M.7z), a `186MB` `xlsx` file when the `csv` is converted. The plotting data was gotten from the [`sysinfo`](https://github.com/GuillaumeGomez/sysinfo) crate, at a sample interval of `200ms`. The program samples the reported values for the running process and records it.\n\nThe programs are all structured to follow the same constructs:\n\n`calamine`:\n\n```rust\nuse calamine::{open_workbook, Reader, Xlsx};\n\nfn main() {\n    // Open workbook\n    let mut excel: Xlsx<_> =\n        open_workbook(\"NYC_311_SR_2010-2020-sample-1M.xlsx\").expect(\"failed to find file\");\n\n    // Get worksheet\n    let sheet = excel\n        .worksheet_range(\"NYC_311_SR_2010-2020-sample-1M\")\n        .unwrap()\n        .unwrap();\n\n    // iterate over rows\n    for _row in sheet.rows() {}\n}\n```\n\n`excelize`:\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n        \"github.com/xuri/excelize/v2\"\n)\n\nfunc main() {\n        // Open workbook\n        file, err := excelize.OpenFile(`NYC_311_SR_2010-2020-sample-1M.xlsx`)\n\n        if err != nil {\n                fmt.Println(err)\n                return\n        }\n\n        defer func() {\n                // Close the spreadsheet.\n                if err := file.Close(); err != nil {\n                        fmt.Println(err)\n                }\n        }()\n\n        // Select worksheet\n        rows, err := file.Rows(\"NYC_311_SR_2010-2020-sample-1M\")\n        if err != nil {\n                fmt.Println(err)\n                return\n        }\n\n        // Iterate over rows\n        for rows.Next() {\n        }\n}\n```\n\n`ClosedXML`:\n\n```csharp\nusing ClosedXML.Excel;\n\ninternal class Program\n{\n        private static void Main(string[] args)\n        {\n                // Open workbook\n                using var workbook = new XLWorkbook(\"NYC_311_SR_2010-2020-sample-1M.xlsx\");\n\n                // Get Worksheet\n                // \"NYC_311_SR_2010-2020-sample-1M\"\n                var worksheet = workbook.Worksheet(1);\n\n                // Iterate over rows\n                foreach (var row in worksheet.Rows())\n                {\n\n                }\n        }\n}\n```\n\n`openpyxl`:\n\n```python\nfrom openpyxl import load_workbook\n\n# Open workbook\nwb = load_workbook(\n    filename=r'NYC_311_SR_2010-2020-sample-1M.xlsx', read_only=True)\n\n# Get worksheet\nws = wb['NYC_311_SR_2010-2020-sample-1M']\n\n# Iterate over rows\nfor row in ws.rows:\n    _ = row\n\n# Close the workbook after reading\nwb.close()\n```\n\n### Benchmarks\n\nThe benchmarking was done using [`hyperfine`](https://github.com/sharkdp/hyperfine) with `--warmup 3` on an `AMD RYZEN 9 5900X @ 4.0GHz` running `Windows 11`. Both `calamine` and `ClosedXML` were built in release mode.\n\n```bash\n0.22.1 calamine.exe\n  Time (mean ± σ):     25.278 s ±  0.424 s    [User: 24.852 s, System: 0.470 s]\n  Range (min … max):   24.980 s … 26.369 s    10 runs\n\nv2.8.0 excelize.exe\n  Time (mean ± σ):     44.254 s ±  0.574 s    [User: 46.071 s, System: 7.754 s]\n  Range (min … max):   42.947 s … 44.911 s    10 runs\n\n0.102.1 closedxml.exe\n  Time (mean ± σ):     178.343 s ±  3.673 s    [User: 177.442 s, System: 2.612 s]\n  Range (min … max):   173.232 s … 185.086 s    10 runs\n\n3.0.10 openpyxl.py\n  Time (mean ± σ):     238.554 s ±  1.062 s    [User: 238.016 s, System: 0.661 s]\n  Range (min … max):   236.798 s … 240.167 s    10 runs\n```\n\n`calamine` is 1.75x faster than `excelize`, 7.05x faster than `ClosedXML`, and 9.43x faster than `openpyxl`.\n\nThe spreadsheet has a range of 1,000,001 rows and 41 columns, for a total of 41,000,041 cells in the range. Of those, 28,056,975 cells had values.\n\nGoing off of that number:\n\n- `calamine` =>  1,122,279 cells per second\n- `excelize` => 633,998 cells per second\n- `ClosedXML` => 157,320 cells per second\n- `openpyxl` => 117,612 cells per second\n\n### Plots\n\n#### Disk Read\n\n![bytes_from_disk](https://github.com/RoloEdits/calamine/assets/12489689/fcca1147-d73f-4d1c-b273-e7e4c183ab29)\n\nAs stated, the filesize on disk is `186MB`:\n\n- `calamine` => `186MB`\n- `ClosedXML` => `208MB`.\n- `openpyxl` =>  `192MB`.\n- `excelize` => `1.5GB`.\n\nWhen asking one of the maintainers of `excelize`, I got this [response](https://github.com/qax-os/excelize/issues/1695#issuecomment-1772239230):\n> To avoid high memory usage for reading large files, this library allows user-specific UnzipXMLSizeLimit options when opening the workbook, to set the memory limit on the unzipping worksheet and shared string table in bytes, worksheet XML will be extracted to the system temporary directory when the file size is over this value, so you can see that data written in reading mode, and you can change the default for that to avoid this behavior.\n>\n> \\- xuri\n\n#### Disk Write\n\n![bytes_to_disk](https://github.com/RoloEdits/calamine/assets/12489689/befa9893-7658-41a7-8cbd-b0ce5a7d9341)\n\nAs seen in the previous section, `excelize` is writting to disk to save memory. The others don't employ that kind of mechanism.\n\n#### Memory\n\n![mem_usage](https://github.com/RoloEdits/calamine/assets/12489689/c83fdf6b-1442-4e22-8eca-84cbc1db4a26)\n\n![virt_mem_usage](https://github.com/RoloEdits/calamine/assets/12489689/840a96ed-33d7-44f7-8276-80bb7a02557f)\n> [!NOTE]\n> `ClosedXML` was reporting a constant `2.5TB` of virtual memory usage, so it was excluded from the chart.\n\nThe stepping and falling for `calamine` is from the grows of `Vec`s and the freeing of memory right after, with the memory usage dropping down again. The sudden jump at the end is when the sheet is being read into memory. The others, being garbage collected, have a more linear climb all the way through.\n\n#### CPU\n\n![cpu_usage](https://github.com/RoloEdits/calamine/assets/12489689/c3aa55a8-b008-48ee-ba04-c08bd91c1f6f)\n\nVery noisy chart, but `excelize`'s spikes must be from the GC?\n\n## Unsupported\n\nMany (most) part of the specifications are not implemented, the focus has been put on reading cell **values** and **vba** code.\n\nThe main unsupported items are:\n\n- no support for writing excel files, this is a read-only library\n- no support for reading extra contents, such as formatting, excel parameter, encrypted components etc ...\n- no support for reading VB for opendocuments\n\n## Credits\n\nThanks to [xlsx-js](https://github.com/SheetJS/js-xlsx) developers!\nThis library is by far the simplest open source implementation I could find and helps making sense out of official documentation.\n\nThanks also to all the contributors!\n\n## License\n\nMIT\n"
        },
        {
          "name": "benches",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}