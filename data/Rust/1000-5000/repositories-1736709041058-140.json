{
  "metadata": {
    "timestamp": 1736709041058,
    "page": 140,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "salvo-rs/salvo",
      "stars": 3526,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.326171875,
          "content": "/target\r\n**/*.rs.bk\r\nCargo.lock\r\n**/Cargo.lock\r\n/.idea\r\n/.vscode\r\n**/target\r\n/.vs\r\n/examples/_*.rs\r\n/examples/_test*\r\n/examples/target\r\n/examples/*/target\r\ncobertura.xml\r\ndebug.log\r\n**/temp\r\ntarpaulin-report.*\r\n*.profraw\r\nexamples/*/.env.local\r\nexamples/**/package-lock.json\r\nexamples/**/pnpm-lock.yaml\r\n**/node_modules\r\n\r\n.DS_Store\r\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 5.1328125,
          "content": "[workspace]\nmembers = [\"crates/*\"]\nresolver = \"2\"\n\n[workspace.package]\nversion = \"0.76.0\"\nauthors = [\"Chrislearn Young <chris@acroidea.com>\"]\nedition = \"2021\"\nrust-version = \"1.80\"\ndescription = \"\"\"\nSalvo is a powerful web framework that can make your work easier.\n\"\"\"\nhomepage = \"https://salvo.rs\"\nrepository = \"https://github.com/salvo-rs/salvo\"\ndocumentation = \"https://docs.rs/salvo/\"\nreadme = \"./README.md\"\nkeywords = [\"http\", \"async\", \"web\", \"framework\", \"server\"]\nlicense = \"MIT OR Apache-2.0\"\ncategories = [\"web-programming::http-server\", \"web-programming::websocket\", \"network-programming\", \"asynchronous\"]\n\n[workspace.dependencies]\nsalvo_macros = { version = \"0.76.0\", path = \"crates/macros\", default-features = false }\nsalvo_core = { version = \"0.76.0\", path = \"crates/core\", default-features = false }\nsalvo_extra = { version = \"0.76.0\", path = \"crates/extra\", default-features = false }\nsalvo-compression = { version = \"0.76.0\", path = \"crates/compression\", default-features = false }\nsalvo-cache = { version = \"0.76.0\", path = \"crates/cache\", default-features = false }\nsalvo-cors = { version = \"0.76.0\", path = \"crates/cors\", default-features = false }\nsalvo-csrf = { version = \"0.76.0\", path = \"crates/csrf\", default-features = false }\nsalvo-flash = { version = \"0.76.0\", path = \"crates/flash\", default-features = false }\nsalvo-http3 = { version = \"0.4.0\", default-features = false }\nsalvo-jwt-auth = { version = \"0.76.0\", path = \"crates/jwt-auth\", default-features = false }\nsalvo-oapi = { version = \"0.76.0\", path = \"./crates/oapi\", default-features = false }\nsalvo-oapi-macros = { version = \"0.76.0\", path = \"crates/oapi-macros\", default-features = false }\nsalvo-otel = { version = \"0.76.0\", path = \"crates/otel\", default-features = false }\nsalvo-proxy = { version = \"0.76.0\", path = \"crates/proxy\", default-features = false }\nsalvo-rate-limiter = { version = \"0.76.0\", path = \"crates/rate-limiter\", default-features = false }\nsalvo-serde-util = { version = \"0.76.0\", path = \"crates/serde-util\", default-features = true }\nsalvo-serve-static = { version = \"0.76.0\", path = \"crates/serve-static\", default-features = false }\nsalvo-session = { version = \"0.76.0\", path = \"crates/session\", default-features = false }\nsalvo-craft = { version = \"0.76.0\", path = \"crates/craft\", default-features = false }\nsalvo-craft-macros = { version = \"0.76.0\", path = \"crates/craft-macros\", default-features = false }\n\naead = \"0.5\"\naes-gcm = \"0.10\"\nanyhow = \"1\"\nasync-session = \"3\"\nasync-trait = \"0.1\"\nassert-json-diff = \"2\"\nbase64 = \"0.22\"\nbson = \"2\"\nbytes = \"1\"\nbcrypt = \"0.16\"\ncookie = \"0.18\"\nchacha20poly1305 = \"0.10\"\nchrono = \"0.4\"\nencoding_rs = \"0.8\"\nemail_address = \"0.2\"\nenumflags2 = \"0.7\"\netag = \"4\"\neyre = \"0.6\"\nfastrand = \"2\"\nform_urlencoded = \"1\"\nfutures-channel = \"0.3\"\nfutures-util = { version = \"0.3\", default-features = false }\nheaders = \"0.4\"\nhttp = \"1\"\nhttp-body-util = \"0.1\"\nhmac = \"0.12\"\nhex = \"0.4\"\nhostname-validator = \"1\"\nhyper = { version = \"1\", features = [\"full\"] }\nhyper-rustls = { version = \"0.27\", default-features = false }\nhyper-util = { version = \"0.1\", default-features = true }\nindexmap = \"2\"\ninventory = \"0.3\"\njsonwebtoken = \"9.1\"\nmime = \"0.3\"\nmime-infer = \"3\"\nmoka = \"0.12\"\nmulter = \"3\"\nmultimap = \"0.10\"\nnative-tls = \"0.2\"\nnix = { version = \"0.29\", default-features = false }\nopenssl = \"0.10\"\nopentelemetry = { version = \"0.27\", default-features = false }\nopentelemetry-http = { version = \"0.27\", default-features = false }\nopentelemetry-prometheus = { version = \"0.27\", default-features = false }\nopentelemetry-semantic-conventions = { version = \"0.27\", default-features = false }\nparking_lot = \"0.12\"\npath-slash = \"0.2\"\npercent-encoding = \"2\"\npaste = \"1\"\npin-project = \"1\"\nproc-macro-crate = {version = \">= 2, <= 4\"}\nproc-macro2-diagnostics = { version = \"0.10\", default-features = true  }\nproc-macro2 = \"1\"\nquinn = { version = \"0.11\", default-features = false }\nquote = \"1\"\nrand = \"0.8\"\nrcgen = \"0.13\"\nregex = \"1\"\nreqwest = \"0.12\"\nring = \"0.17\"\nrust_decimal = \"1\"\nrustls = \"0.23\"\nrustls-pemfile = \"2\"\nrust-embed = { version = \">= 6, <= 9\" }\nserde = \"1\"\nserde_json = \"1\"\nserde-xml-rs = \"0.6\"\nserde_urlencoded = \"0.7\"\nserde_yaml = \"0.9\"\nserde_with = \"3\"\nsha2 = \"0.10\"\nsmallvec = \"1\"\nsocket2 = \"0.5\"\nsyn = \"2\"\nsync_wrapper = \"1\"\ntempfile = \"3\"\nthiserror = \"2\"\ntime = \"0.3\"\ntokio = \"1\"\ntokio-native-tls = \"0.3\"\ntokio-rustls = {version = \"0.26\", default-features = false }\ntokio-openssl = \"0.6\"\ntokio-stream = { version = \"0.1\", default-features = false }\ntokio-tungstenite = { version = \"0.26\", default-features = false }\ntokio-util = \"0.7\"\ntower = { version = \"0.5\", default-features = false }\ntracing-subscriber = { version = \"0.3\" }\ntracing = \"0.1\"\ntracing-test = \"0.2.1\"\nulid = { version = \"1\", default-features = false }\nurl = \"2\"\nuuid = \"1\"\nx509-parser = \"0.16\"\ncompact_str = { version = \"0.8\", features = [\"serde\"] }\n\n# Compress\nbrotli = { version = \"7\", default-features = false }\nflate2 = { version = \"1\", default-features = false }\nzstd = { version = \"0.13\", default-features = false }\n\n[workspace.lints.rust]\nunsafe_code = \"forbid\"\nunreachable_pub = \"deny\"\nmissing_docs = \"warn\"\n\n[workspace.lints.clippy]\nfuture_not_send = \"warn\"\nunwrap_used = \"warn\"\n\n[workspace.lints.rustdoc]\nbroken_intra_doc_links = \"warn\"\n"
        },
        {
          "name": "ECOSYSTEM.md",
          "type": "blob",
          "size": 3.3095703125,
          "content": "# Community Projects\n\nIf your project isn't listed here and you would like it to be, please feel free to create a PR.\n\n## Community maintained modules\n\n- [Socketioxide](https://github.com/Totodore/socketioxide): A socket.io server implementation in Rust that integrates with the Tower ecosystem and the Tokio stack.\n- [Websocket](https://gitee.com/hubert22/salvo-websocket): This crate is websocket tool for salvo.\n- [SalvoRsTool](https://github.com/mdddj/SalvoRsTool): salvo Idea RustRover插件 快速生成dto router service模板代码\n- [protect-endpoints](https://github.com/DDtKey/protect-endpoints): Collection of crates to protect your endpoints\n- [salvo-captcha](https://git.4rs.nl/awiteb/salvo-captcha): A captcha middleware for Salvo framework.\n- [salvo-casbin](https://github.com/casbin-rs/salvo-casbin): Casbin access control hoop for salvo framework.\n\n## Project showcase\n\n- [AI00 RWKV Server](https://github.com/Ai00-X/ai00_server): AI00 RWKV Server is an inference API server based on the RWKV model..\n- [Salvo Admin](https://github.com/lyqgit/salvo-admin): 基于salvo和Ruoyi-Vue3的rust快速开发框架.\n- [Salvo Admin](https://github.com/feihua/salvo-admin): 基于salvo和rbatis的rbac权限管理系统.\n- [Geospatial Web](https://gitlab.com/geospatialweb/rust-mvt-postgis): Rust REST API - Martin MVT Tile Server - PostGIS.\n- [ALLEY](https://github.com/alley-rs/alley-transfer): Software for fast file transfer between terminals in the same network segment.\n- [musicbot](https://github.com/AdrienPensart/musicbot): Music swiss army knife.\n- [Replex](https://github.com/lostb1t/replex): Remix your Plex recommendations.\n- [Pure Rust Instant Message(PRIM)](https://github.com/SuanCaiYv/prim): 使用纯Rust实现的即时通讯系统.\n- [rblog](https://github.com/prabirshrestha/rblog): Blog engine written in rust.\n- [myblog](https://github.com/driftluo/myblog): This is my personal blog.\n- [opensound](https://github.com/opensound-org/opensound): Pro-Audio system engine, using `salvo` as the default HTTP server backend（专业音频系统引擎，使用`salvo`作为默认HTTP服务器后端）.\n- [static-api](https://github.com/josejachuf/static-api-rs): This is a simple application emulating a basic REST API.\n- [palpo](https://github.com/palpo-matrix-server/palpo): A Rust Matrix Server Implementation.\n- [yiirs](https://github.com/shenghui0779/yiirs): Rust API 快速开发脚手架 (Salvo & Axum).\n- [luxy](https://github.com/alley-rs/fluxy): Software for fast file transfer between terminals in the same network segment.\n- [ffxiv-best-craft](https://github.com/Tnze/ffxiv-best-craft): A crafting simulator and solver for FF14 with friendly GUI.\n\n## Tutorials\n- [Rust Salvo零基础教程](https://www.bilibili.com/video/BV1FS421N71D/): Rust Salvo零基础入门教程.\n- [使用Tera和Salvo构建单词本](https://www.bilibili.com/video/BV1Kg411b75s): 使用Tera和Salvo构建一个简单的单词本Web应用.\n- [is salvo really the simplest rust web framework?](https://www.youtube.com/watch?v=tf9x97eTcpk)\n- [Salvo.rs - Un Framework sencillo de Backend creado en Rust](https://www.youtube.com/watch?v=HlVf4mE8V9s)\n- [rust + dioxus maybe | rust, salvo, dioxus live view, sqlx](https://www.youtube.com/watch?v=_j9tNhWbp8g)\n- [rust + dockerfile + fly | rust, salvo, dioxus live view, sqlx, docker, fly.io](https://www.youtube.com/watch?v=IuyQxpbxjb8)\n"
        },
        {
          "name": "LICENSE-APACHE",
          "type": "blob",
          "size": 11.294921875,
          "content": "                                 Apache License\r\n                           Version 2.0, January 2004\r\n                        http://www.apache.org/licenses/\r\n\r\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n\r\n   1. Definitions.\r\n\r\n      \"License\" shall mean the terms and conditions for use, reproduction,\r\n      and distribution as defined by Sections 1 through 9 of this document.\r\n\r\n      \"Licensor\" shall mean the copyright owner or entity authorized by\r\n      the copyright owner that is granting the License.\r\n\r\n      \"Legal Entity\" shall mean the union of the acting entity and all\r\n      other entities that control, are controlled by, or are under common\r\n      control with that entity. For the purposes of this definition,\r\n      \"control\" means (i) the power, direct or indirect, to cause the\r\n      direction or management of such entity, whether by contract or\r\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n      outstanding shares, or (iii) beneficial ownership of such entity.\r\n\r\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n      exercising permissions granted by this License.\r\n\r\n      \"Source\" form shall mean the preferred form for making modifications,\r\n      including but not limited to software source code, documentation\r\n      source, and configuration files.\r\n\r\n      \"Object\" form shall mean any form resulting from mechanical\r\n      transformation or translation of a Source form, including but\r\n      not limited to compiled object code, generated documentation,\r\n      and conversions to other media types.\r\n\r\n      \"Work\" shall mean the work of authorship, whether in Source or\r\n      Object form, made available under the License, as indicated by a\r\n      copyright notice that is included in or attached to the work\r\n      (an example is provided in the Appendix below).\r\n\r\n      \"Derivative Works\" shall mean any work, whether in Source or Object\r\n      form, that is based on (or derived from) the Work and for which the\r\n      editorial revisions, annotations, elaborations, or other modifications\r\n      represent, as a whole, an original work of authorship. For the purposes\r\n      of this License, Derivative Works shall not include works that remain\r\n      separable from, or merely link (or bind by name) to the interfaces of,\r\n      the Work and Derivative Works thereof.\r\n\r\n      \"Contribution\" shall mean any work of authorship, including\r\n      the original version of the Work and any modifications or additions\r\n      to that Work or Derivative Works thereof, that is intentionally\r\n      submitted to Licensor for inclusion in the Work by the copyright owner\r\n      or by an individual or Legal Entity authorized to submit on behalf of\r\n      the copyright owner. For the purposes of this definition, \"submitted\"\r\n      means any form of electronic, verbal, or written communication sent\r\n      to the Licensor or its representatives, including but not limited to\r\n      communication on electronic mailing lists, source code control systems,\r\n      and issue tracking systems that are managed by, or on behalf of, the\r\n      Licensor for the purpose of discussing and improving the Work, but\r\n      excluding communication that is conspicuously marked or otherwise\r\n      designated in writing by the copyright owner as \"Not a Contribution.\"\r\n\r\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n      on behalf of whom a Contribution has been received by Licensor and\r\n      subsequently incorporated within the Work.\r\n\r\n   2. Grant of Copyright License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      copyright license to reproduce, prepare Derivative Works of,\r\n      publicly display, publicly perform, sublicense, and distribute the\r\n      Work and such Derivative Works in Source or Object form.\r\n\r\n   3. Grant of Patent License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      (except as stated in this section) patent license to make, have made,\r\n      use, offer to sell, sell, import, and otherwise transfer the Work,\r\n      where such license applies only to those patent claims licensable\r\n      by such Contributor that are necessarily infringed by their\r\n      Contribution(s) alone or by combination of their Contribution(s)\r\n      with the Work to which such Contribution(s) was submitted. If You\r\n      institute patent litigation against any entity (including a\r\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n      or a Contribution incorporated within the Work constitutes direct\r\n      or contributory patent infringement, then any patent licenses\r\n      granted to You under this License for that Work shall terminate\r\n      as of the date such litigation is filed.\r\n\r\n   4. Redistribution. You may reproduce and distribute copies of the\r\n      Work or Derivative Works thereof in any medium, with or without\r\n      modifications, and in Source or Object form, provided that You\r\n      meet the following conditions:\r\n\r\n      (a) You must give any other recipients of the Work or\r\n          Derivative Works a copy of this License; and\r\n\r\n      (b) You must cause any modified files to carry prominent notices\r\n          stating that You changed the files; and\r\n\r\n      (c) You must retain, in the Source form of any Derivative Works\r\n          that You distribute, all copyright, patent, trademark, and\r\n          attribution notices from the Source form of the Work,\r\n          excluding those notices that do not pertain to any part of\r\n          the Derivative Works; and\r\n\r\n      (d) If the Work includes a \"NOTICE\" text file as part of its\r\n          distribution, then any Derivative Works that You distribute must\r\n          include a readable copy of the attribution notices contained\r\n          within such NOTICE file, excluding those notices that do not\r\n          pertain to any part of the Derivative Works, in at least one\r\n          of the following places: within a NOTICE text file distributed\r\n          as part of the Derivative Works; within the Source form or\r\n          documentation, if provided along with the Derivative Works; or,\r\n          within a display generated by the Derivative Works, if and\r\n          wherever such third-party notices normally appear. The contents\r\n          of the NOTICE file are for informational purposes only and\r\n          do not modify the License. You may add Your own attribution\r\n          notices within Derivative Works that You distribute, alongside\r\n          or as an addendum to the NOTICE text from the Work, provided\r\n          that such additional attribution notices cannot be construed\r\n          as modifying the License.\r\n\r\n      You may add Your own copyright statement to Your modifications and\r\n      may provide additional or different license terms and conditions\r\n      for use, reproduction, or distribution of Your modifications, or\r\n      for any such Derivative Works as a whole, provided Your use,\r\n      reproduction, and distribution of the Work otherwise complies with\r\n      the conditions stated in this License.\r\n\r\n   5. Submission of Contributions. Unless You explicitly state otherwise,\r\n      any Contribution intentionally submitted for inclusion in the Work\r\n      by You to the Licensor shall be under the terms and conditions of\r\n      this License, without any additional terms or conditions.\r\n      Notwithstanding the above, nothing herein shall supersede or modify\r\n      the terms of any separate license agreement you may have executed\r\n      with Licensor regarding such Contributions.\r\n\r\n   6. Trademarks. This License does not grant permission to use the trade\r\n      names, trademarks, service marks, or product names of the Licensor,\r\n      except as required for reasonable and customary use in describing the\r\n      origin of the Work and reproducing the content of the NOTICE file.\r\n\r\n   7. Disclaimer of Warranty. Unless required by applicable law or\r\n      agreed to in writing, Licensor provides the Work (and each\r\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n      implied, including, without limitation, any warranties or conditions\r\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n      PARTICULAR PURPOSE. You are solely responsible for determining the\r\n      appropriateness of using or redistributing the Work and assume any\r\n      risks associated with Your exercise of permissions under this License.\r\n\r\n   8. Limitation of Liability. In no event and under no legal theory,\r\n      whether in tort (including negligence), contract, or otherwise,\r\n      unless required by applicable law (such as deliberate and grossly\r\n      negligent acts) or agreed to in writing, shall any Contributor be\r\n      liable to You for damages, including any direct, indirect, special,\r\n      incidental, or consequential damages of any character arising as a\r\n      result of this License or out of the use or inability to use the\r\n      Work (including but not limited to damages for loss of goodwill,\r\n      work stoppage, computer failure or malfunction, or any and all\r\n      other commercial damages or losses), even if such Contributor\r\n      has been advised of the possibility of such damages.\r\n\r\n   9. Accepting Warranty or Additional Liability. While redistributing\r\n      the Work or Derivative Works thereof, You may choose to offer,\r\n      and charge a fee for, acceptance of support, warranty, indemnity,\r\n      or other liability obligations and/or rights consistent with this\r\n      License. However, in accepting such obligations, You may act only\r\n      on Your own behalf and on Your sole responsibility, not on behalf\r\n      of any other Contributor, and only if You agree to indemnify,\r\n      defend, and hold each Contributor harmless for any liability\r\n      incurred by, or claims asserted against, such Contributor by reason\r\n      of your accepting any such warranty or additional liability.\r\n\r\n   END OF TERMS AND CONDITIONS\r\n\r\n   APPENDIX: How to apply the Apache License to your work.\r\n\r\n      To apply the Apache License to your work, attach the following\r\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\r\n      replaced with your own identifying information. (Don't include\r\n      the brackets!)  The text should be enclosed in the appropriate\r\n      comment syntax for the file format. We also recommend that a\r\n      file or class name and description of purpose be included on the\r\n      same \"printed page\" as the copyright notice for easier\r\n      identification within third-party archives.\r\n\r\n   Copyright (c) 2019-present, The `salvo` Developers\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.0908203125,
          "content": "The MIT License (MIT)\r\n\r\nCopyright (c) 2019-present, The `salvo` Developers\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.57421875,
          "content": "<div align=\"center\">\r\n<p><img alt=\"Salvo\" width=\"132\" style=\"max-width:40%;min-width:60px;\" src=\"https://salvo.rs/images/logo-text.svg\" /></p>\r\n<p>\r\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.md\">English</a>&nbsp;&nbsp;\r\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hans.md\">简体中文</a>&nbsp;&nbsp;\r\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hant.md\">繁體中文</a>\r\n</p>\r\n<p>\r\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\r\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-linux/badge.svg\" />\r\n</a>\r\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\r\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-macos/badge.svg\" />\r\n</a>\r\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\r\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-windows/badge.svg\" />\r\n</a>\r\n<br>\r\n<a href=\"https://discord.gg/G8KfmS6ByH\">\r\n    <img src=\"https://img.shields.io/discord/1041442427006890014.svg?logo=discord\">\r\n</a>\r\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"crates.io\" src=\"https://img.shields.io/crates/v/salvo\" /></a>\r\n<a href=\"https://docs.rs/salvo\"><img alt=\"Documentation\" src=\"https://docs.rs/salvo/badge.svg\" /></a>\r\n<a href=\"https://github.com/rust-secure-code/safety-dance/\"><img alt=\"unsafe forbidden\" src=\"https://img.shields.io/badge/unsafe-forbidden-success.svg\" /></a>\r\n<a href=\"https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html\"><img alt=\"Rust Version\" src=\"https://img.shields.io/badge/rust-1.80%2B-blue\" /></a>\r\n<br>\r\n<a href=\"https://salvo.rs\">\r\n    <img alt=\"Website\" src=\"https://img.shields.io/badge/https-salvo.rs-%23f00\" />\r\n</a>\r\n<a href=\"https://codecov.io/gh/salvo-rs/salvo\"><img alt=\"codecov\" src=\"https://codecov.io/gh/salvo-rs/salvo/branch/main/graph/badge.svg\" /></a>\r\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"Download\" src=\"https://img.shields.io/crates/d/salvo.svg\" /></a>\r\n<img alt=\"License\" src=\"https://img.shields.io/crates/l/salvo.svg\" />\r\n<a href=\"https://gurubase.io/g/salvo\"><img alt=\"Gurubase\" src=\"https://img.shields.io/badge/Gurubase-Ask%20Salvo%20Guru-006BFF\" /></a>\r\n</p>\r\n</div>\r\n\r\nSalvo is an extremely simple and powerful Rust web backend framework. Only basic Rust knowledge is required to develop backend services.\r\n\r\n## 🎯 Features\r\n\r\n- Built with [Hyper 1](https://crates.io/crates/hyper) and [Tokio](https://crates.io/crates/tokio);\r\n- HTTP1, HTTP2 and **HTTP3**;\r\n- Unified middleware and handle interface;\r\n- Router can be nested infinitely, and multiple middlewares can be attached to any router;\r\n- Integrated Multipart form processing;\r\n- Support WebSocket, WebTransport;\r\n- Support OpenAPI, generate OpenAPI data automatic;\r\n- Support Acme, automatically get TLS certificate from [let's encrypt](https://letsencrypt.org/);\r\n- Support Tower Service and Layer;\r\n\r\n## ⚡️ Quick Start\r\n\r\nYou can view samples [here](https://github.com/salvo-rs/salvo/tree/main/examples), or view [official website](https://salvo.rs).\r\n\r\n### Hello World with ACME and HTTP3\r\n\r\n**It only takes a few lines of code to implement a server that supports ACME to automatically obtain certificates, and it\r\nsupports HTTP1, HTTP2, and HTTP3 protocols.**\r\n\r\n```rust\r\nuse salvo::prelude::*;\r\n\r\n#[handler]\r\nasync fn hello(res: &mut Response) {\r\n    res.render(Text::Plain(\"Hello World\"));\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let mut router = Router::new().get(hello);\r\n    let listener = TcpListener::new(\"0.0.0.0:443\")\r\n        .acme()\r\n        .add_domain(\"test.salvo.rs\") // Replace this domain name with your own.\r\n        .http01_challenge(&mut router).quinn(\"0.0.0.0:443\");\r\n    let acceptor = listener.join(TcpListener::new(\"0.0.0.0:80\")).bind().await;\r\n    Server::new(acceptor).serve(router).await;\r\n}\r\n```\r\n\r\n### Middleware\r\n\r\nThere is no difference between a Handler and a Middleware, A Middleware is just a Handler. **You can write middleware\r\nwithout knowing concepts like associated types and generic types. If you can write a function, then you can write middleware!!!**\r\n\r\n```rust\r\nuse salvo::http::header::{self, HeaderValue};\r\nuse salvo::prelude::*;\r\n\r\n#[handler]\r\nasync fn add_header(res: &mut Response) {\r\n    res.headers_mut()\r\n        .insert(header::SERVER, HeaderValue::from_static(\"Salvo\"));\r\n}\r\n```\r\n\r\nThen add it to router:\r\n\r\n```rust\r\nRouter::new().hoop(add_header).get(hello)\r\n```\r\n\r\nThis is a very simple middleware, it adds an `Header` to the `Response`, view [full source code](https://github.com/salvo-rs/salvo/blob/main/examples/middleware-add-header/src/main.rs).\r\n\r\n### Chainable tree routing system\r\n\r\nNormally we write routing like this:\r\n\r\n```rust\r\nRouter::with_path(\"articles\").get(list_articles).post(create_article);\r\nRouter::with_path(\"articles/{id}\")\r\n    .get(show_article)\r\n    .patch(edit_article)\r\n    .delete(delete_article);\r\n```\r\n\r\nOften, something like viewing articles and article lists does not require user login, but creating, editing, deleting articles, etc. require user login authentication permissions. The tree-like routing system in Salvo can meet this demand. We can write routers without user login together:\r\n\r\n```rust\r\nRouter::with_path(\"articles\")\r\n    .get(list_articles)\r\n    .push(Router::with_path(\"{id}\").get(show_article));\r\n```\r\n\r\nThen write the routers that require the user to login together, and use the corresponding middleware to verify whether the user is logged in:\r\n\r\n```rust\r\nRouter::with_path(\"articles\")\r\n    .hoop(auth_check)\r\n    .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article));\r\n```\r\n\r\nAlthough these two routes have the same\r\n`path(\"articles\")`, they can still be added to the same parent route at the same time, so the final route looks like this:\r\n\r\n```rust\r\nRouter::new()\r\n    .push(\r\n        Router::with_path(\"articles\")\r\n            .get(list_articles)\r\n            .push(Router::with_path(\"{id}\").get(show_article)),\r\n    )\r\n    .push(\r\n        Router::with_path(\"articles\")\r\n            .hoop(auth_check)\r\n            .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article)),\r\n    );\r\n```\r\n\r\n`{id}` matches a fragment in the path, under normal circumstances, the article`id` is just a number, which we can use regular expressions to restrict `id` matching rules, `r\"{id|\\d+}\"`.\r\n\r\nYou can also use `{**}`,  `{*+}` or`{*?}` to match all remaining path fragments.\r\nIn order to make the code more readable, you can also add appropriate name to make the path semantics more clear, for example: `{**file_path}`.\r\n\r\nSome regular expressions for matching paths need to be used frequently, and it can be registered in advance, such as GUID:\r\n\r\n```rust\r\nPathFilter::register_wisp_regex(\r\n    \"guid\",\r\n    Regex::new(\"[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}\").unwrap(),\r\n);\r\n```\r\n\r\nThis makes it more concise when path matching is required:\r\n\r\n```rust\r\nRouter::with_path(\"{id:guid}\").get(index)\r\n```\r\n\r\nView [full source code](https://github.com/salvo-rs/salvo/blob/main/examples/routing-guid/src/main.rs)\r\n\r\n### File upload\r\n\r\nWe can get file async by the function `file` in `Request`:\r\n\r\n```rust\r\n#[handler]\r\nasync fn upload(req: &mut Request, res: &mut Response) {\r\n    let file = req.file(\"file\").await;\r\n    if let Some(file) = file {\r\n        let dest = format!(\"temp/{}\", file.name().unwrap_or_else(|| \"file\".into()));\r\n        if let Err(e) = tokio::fs::copy(&file.path, Path::new(&dest)).await {\r\n            res.status_code(StatusCode::INTERNAL_SERVER_ERROR);\r\n        } else {\r\n            res.render(\"Ok\");\r\n        }\r\n    } else {\r\n        res.status_code(StatusCode::BAD_REQUEST);\r\n    }\r\n}\r\n```\r\n\r\n### Extract data from request\r\n\r\nYou can easily get data from multiple different data sources and assemble it into the type you want. You can define a custom type first, for example:\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize, Extractible, Debug)]\r\n/// Get the data field value from the body by default.\r\n#[salvo(extract(default_source(from = \"body\")))]\r\nstruct GoodMan<'a> {\r\n    /// The id number is obtained from the request path parameter, and the data is automatically parsed as i64 type.\r\n    #[salvo(extract(source(from = \"param\")))]\r\n    id: i64,\r\n    /// Reference types can be used to avoid memory copying.\r\n    username: &'a str,\r\n    first_name: String,\r\n    last_name: String,\r\n}\r\n```\r\n\r\nThen in `Handler` you can get the data like this:\r\n\r\n```rust\r\n#[handler]\r\nasync fn edit(req: &mut Request) {\r\n    let good_man: GoodMan<'_> = req.extract().await.unwrap();\r\n}\r\n```\r\n\r\nYou can even pass the type directly to the function as a parameter, like this:\r\n\r\n```rust\r\n#[handler]\r\nasync fn edit<'a>(good_man: GoodMan<'a>) {\r\n    res.render(Json(good_man));\r\n}\r\n```\r\n\r\nView [full source code](https://github.com/salvo-rs/salvo/blob/main/examples/extract-nested/src/main.rs)\r\n\r\n### OpenAPI Supported\r\n\r\nPerfect support for OpenAPI can be achieved without making significant changes to the project.\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize, ToSchema, Debug)]\r\nstruct MyObject<T: ToSchema + std::fmt::Debug> {\r\n    value: T,\r\n}\r\n\r\n#[endpoint]\r\nasync fn use_string(body: JsonBody<MyObject<String>>) -> String {\r\n    format!(\"{:?}\", body)\r\n}\r\n#[endpoint]\r\nasync fn use_i32(body: JsonBody<MyObject<i32>>) -> String {\r\n    format!(\"{:?}\", body)\r\n}\r\n#[endpoint]\r\nasync fn use_u64(body: JsonBody<MyObject<u64>>) -> String {\r\n    format!(\"{:?}\", body)\r\n}\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    tracing_subscriber::fmt().init();\r\n\r\n    let router = Router::new()\r\n        .push(Router::with_path(\"i32\").post(use_i32))\r\n        .push(Router::with_path(\"u64\").post(use_u64))\r\n        .push(Router::with_path(\"string\").post(use_string));\r\n\r\n    let doc = OpenApi::new(\"test api\", \"0.0.1\").merge_router(&router);\r\n\r\n    let router = router\r\n        .push(doc.into_router(\"/api-doc/openapi.json\"))\r\n        .push(SwaggerUi::new(\"/api-doc/openapi.json\").into_router(\"swagger-ui\"));\r\n\r\n    let acceptor = TcpListener::new(\"127.0.0.1:5800\").bind().await;\r\n    Server::new(acceptor).serve(router).await;\r\n}\r\n```\r\n\r\n### 🛠️ Salvo CLI\r\n\r\nSalvo CLI is a command-line tool that simplifies the creation of new Salvo projects, supporting templates for web APIs, websites, databases (including SQLite, PostgreSQL, and MySQL via SQLx, SeaORM, Diesel, Rbatis), and basic middleware.\r\nYou can use [salvo-cli](https://github.com/salvo-rs/salvo-cli) to create a new Salvo project:\r\n\r\n#### install\r\n\r\n```bash\r\ncargo install salvo-cli\r\n```\r\n\r\n#### create a new Salvo project\r\n\r\n```bash\r\nsalvo new project_name\r\n```\r\n\r\n___\r\n\r\n### More Examples\r\n\r\nYour can find more examples in [examples](./examples/) folder. You can run these examples with the following command:\r\n\r\n```bash\r\ncd examples\r\ncargo run --bin example-basic-auth\r\n```\r\n\r\nYou can use any example name you want to run instead of `basic-auth` here.\r\n\r\n## 🚀 Performance\r\n\r\nBenchmark testing result can be found from here:\r\n\r\n[https://web-frameworks-benchmark.netlify.app/result?l=rust](https://web-frameworks-benchmark.netlify.app/result?l=rust)\r\n\r\n[https://www.techempower.com/benchmarks/#section=data-r22](https://www.techempower.com/benchmarks/#section=data-r22)\r\n\r\n## 🩸 Contributors\r\n\r\n<a href=\"https://github.com/salvo-rs/salvo/graphs/contributors\">\r\n  <img src=\"https://contrib.rocks/image?repo=salvo-rs/salvo\" />\r\n</a>\r\n\r\n## ☕ Donate\r\n\r\nSalvo is an open source project. If you want to support Salvo, you can ☕ [**buy me a coffee here**](https://ko-fi.com/chrislearn).\r\n\r\n## ⚠️ License\r\n\r\nSalvo is licensed under either of\r\n\r\n- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)).\r\n\r\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or [http://opensource.org/licenses/MIT](http://opensource.org/licenses/MIT)).\r\n"
        },
        {
          "name": "README.osc.md",
          "type": "blob",
          "size": 11.294921875,
          "content": "<div align=\"center\">\n<p><img alt=\"Salvo\" width=\"132\" style=\"max-width:40%;min-width:60px;\" src=\"https://salvo.rs/images/logo-text.svg\" /></p>\n<p>\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.md\">English</a>&nbsp;&nbsp;\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hans.md\">简体中文</a>&nbsp;&nbsp;\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hant.md\">繁體中文</a>\n</p>\n<p>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-linux/badge.svg\" />\n</a>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-macos/badge.svg\" />\n</a>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-windows/badge.svg\" />\n</a>\n<br>\n<a href=\"https://discord.gg/G8KfmS6ByH\">\n    <img src=\"https://img.shields.io/discord/1041442427006890014.svg?logo=discord\">\n</a>\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"crates.io\" src=\"https://img.shields.io/crates/v/salvo\" /></a>\n<a href=\"https://docs.rs/salvo\"><img alt=\"Documentation\" src=\"https://docs.rs/salvo/badge.svg\" /></a>\n<a href=\"https://github.com/rust-secure-code/safety-dance/\"><img alt=\"unsafe forbidden\" src=\"https://img.shields.io/badge/unsafe-forbidden-success.svg\" /></a>\n<a href=\"https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html\"><img alt=\"Rust Version\" src=\"https://img.shields.io/badge/rust-1.80%2B-blue\" /></a>\n<br>\n<a href=\"https://salvo.rs\">\n    <img alt=\"Website\" src=\"https://img.shields.io/badge/https-salvo.rs-%23f00\" />\n</a>\n<a href=\"https://codecov.io/gh/salvo-rs/salvo\"><img alt=\"codecov\" src=\"https://codecov.io/gh/salvo-rs/salvo/branch/main/graph/badge.svg\" /></a>\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"Download\" src=\"https://img.shields.io/crates/d/salvo.svg\" /></a>\n<img alt=\"License\" src=\"https://img.shields.io/crates/l/salvo.svg\" />\n</p>\n</div>\n\nSalvo(赛风) 是一个极其简单且功能强大的 Rust Web 后端框架。仅仅需要基础 Rust 知识即可开发后端服务。\n\n> 中国用户可以添加我微信 (chrislearn), 拉微信讨论群或者直接加入 QQ 群：823441777.\n\n## 🎯 功能特色\n\n- 基于 [Hyper 1](https://crates.io/crates/hyper), [Tokio](https://crates.io/crates/tokio) 开发;\n- 支持 HTTP1, HTTP2 和 **HTTP3**;\n- 统一的中间件和句柄接口;\n- 路由可以无限嵌套，并且可以在任何路由中附加多个中间件;\n- 集成 Multipart 表单处理;\n- 支持 WebSocket, WebTransport;\n- 支持 OpenAPI;\n- 支持 Acme, 自动从 [let's encrypt](https://letsencrypt.org/)获取 TLS 证书。\n- 支持 Tower Service 和 Layer.\n\n## ⚡️ 快速开始\n\n你可以查看[实例代码](https://github.com/salvo-rs/salvo/tree/main/examples), 或者访问[官网](https://salvo.rs)。\n\n### 支持 ACME 自动获取证书和 HTTP3 的 Hello World\n\n**只需要几行代码就可以实现一个同时支持 ACME 自动获取证书以及支持 HTTP1，HTTP2，HTTP3 协议的服务器。**\n\n```rust\nuse salvo::prelude::*;\n\n#[handler]\nasync fn hello(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {\n    res.render(Text::Plain(\"Hello World\"));\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut router = Router::new().get(hello);\n    let listener = TcpListener::new(\"0.0.0.0:443\")\n        .acme()\n        .add_domain(\"test.salvo.rs\") // 用你自己的域名替换此域名\n        .http01_challenge(&mut router).quinn(\"0.0.0.0:443\");\n    let acceptor = listener.join(TcpListener::new(\"0.0.0.0:80\")).bind().await;\n    Server::new(acceptor).serve(router).await;\n}\n```\n\n### 中间件\n\nSalvo 中的中间件其实就是 Handler, 没有其他任何特别之处。**所以书写中间件并不需要像其他某些框架需要掌握泛型关联类型等知识。只要你会写函数就会写中间件，就是这么简单!!!**\n\n```rust\nuse salvo::http::header::{self, HeaderValue};\nuse salvo::prelude::*;\n\n#[handler]\nasync fn add_header(res: &mut Response) {\n    res.headers_mut()\n        .insert(header::SERVER, HeaderValue::from_static(\"Salvo\"));\n}\n```\n\n然后将它添加到路由中：\n\n```rust\nRouter::new().hoop(add_header).get(hello)\n```\n\n这就是一个简单的中间件，它向 `Response` 的头部添加了 `Header`, 查看[完整源码](https://github.com/salvo-rs/salvo/blob/main/examples/middleware-add-header/src/main.rs).\n\n### 可链式书写的树状路由系统\n\n正常情况下我们是这样写路由的：\n\n```rust\nRouter::with_path(\"articles\").get(list_articles).post(create_article);\nRouter::with_path(\"articles/{id}\")\n    .get(show_article)\n    .patch(edit_article)\n    .delete(delete_article);\n```\n\n往往查看文章和文章列表是不需要用户登录的，但是创建，编辑，删除文章等需要用户登录认证权限才可以。Salvo 中支持嵌套的路由系统可以很好地满足这种需求。我们可以把不需要用户登录的路由写到一起：\n\n```rust\nRouter::with_path(\"articles\")\n    .get(list_articles)\n    .push(Router::with_path(\"{id}\").get(show_article));\n```\n\n然后把需要用户登录的路由写到一起，并且使用相应的中间件验证用户是否登录：\n\n```rust\nRouter::with_path(\"articles\")\n    .hoop(auth_check)\n    .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article));\n```\n\n虽然这两个路由都有这同样的 `path(\"articles\")`, 然而它们依然可以被同时添加到同一个父路由，所以最后的路由长成了这个样子：\n\n```rust\nRouter::new()\n    .push(\n        Router::with_path(\"articles\")\n            .get(list_articles)\n            .push(Router::with_path(\"{id}\").get(show_article)),\n    )\n    .push(\n        Router::with_path(\"articles\")\n            .hoop(auth_check)\n            .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article)),\n    );\n```\n\n`{id}`匹配了路径中的一个片段，正常情况下文章的的 `id`只是一个数字，这是我们可以使用正则表达式限制制 `id`的匹配规则，`r\"{id|\\d+}\"`。\n\n还可以通过 `{**}`, `{*+}` 或者 `{*?}`匹配所有剩余的路径片段。为了代码易读性性强些，也可以添加适合的名字，让路径语义更清晰，比如：: `{**file_path}`。\n\n有些用于匹配路径的正则表达式需要经常被使用，可以将它事先注册，比如 GUID:\n\n```rust\nPathFilter::register_wisp_regex(\n    \"guid\",\n    Regex::new(\"[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}\").unwrap(),\n);\n```\n\n这样在需要路径匹配时就变得更简洁：\n\n```rust\nRouter::with_path(\"{id:guid}\").get(index)\n```\n\n查看[完整源码](https://github.com/salvo-rs/salvo/blob/main/examples/routing-guid/src/main.rs)\n\n### 文件上传\n\n可以通过 `Request` 中的 `file`异步获取上传的文件：\n\n```rust\n#[handler]\nasync fn upload(req: &mut Request, res: &mut Response) {\n    let file = req.file(\"file\").await;\n    if let Some(file) = file {\n        let dest = format!(\"temp/{}\", file.name().unwrap_or_else(|| \"file\".into()));\n        if let Err(e) = std::fs::copy(&file.path, Path::new(&dest)) {\n            res.status_code(StatusCode::INTERNAL_SERVER_ERROR);\n        } else {\n            res.render(\"Ok\");\n        }\n    } else {\n        res.status_code(StatusCode::BAD_REQUEST);\n    }\n}\n```\n\n### 提取请求数据\n\n可以轻松地从多个不同数据源获取数据，并且组装为你想要的类型。可以先定义一个自定义的类型，比如：\n\n```rust\n#[derive(Serialize, Deserialize, Extractible, Debug)]\n/// 默认从 body 中获取数据字段值\n#[salvo(extract(default_source(from = \"body\")))]\nstruct GoodMan<'a> {\n    /// 其中, id 号从请求路径参数中获取, 并且自动解析数据为 i64 类型.\n    #[salvo(extract(source(from = \"param\")))]\n    id: i64,\n    /// 可以使用引用类型, 避免内存复制.\n    username: &'a str,\n    first_name: String,\n    last_name: String,\n}\n```\n\n然后在 `Handler`中可以这样获取数据：\n\n```rust\n#[handler]\nasync fn edit(req: &mut Request) {\n    let good_man: GoodMan<'_> = req.extract().await.unwrap();\n}\n```\n\n甚至于可以直接把类型作为参数传入函数，像这样：\n\n```rust\n#[handler]\nasync fn edit<'a>(good_man: GoodMan<'a>) {\n    res.render(Json(good_man));\n}\n```\n\n查看[完整源码](https://github.com/salvo-rs/salvo/blob/main/examples/extract-nested/src/main.rs)\n\n### OpenAPI 支持\n\n无需对项目做大的改动，即可实现对 OpenAPI 的完美支持。\n\n```rust\n#[derive(Serialize, Deserialize, ToSchema, Debug)]\nstruct MyObject<T: ToSchema + std::fmt::Debug> {\n    value: T,\n}\n\n#[endpoint]\nasync fn use_string(body: JsonBody<MyObject<String>>) -> String {\n    format!(\"{:?}\", body)\n}\n#[endpoint]\nasync fn use_i32(body: JsonBody<MyObject<i32>>) -> String {\n    format!(\"{:?}\", body)\n}\n#[endpoint]\nasync fn use_u64(body: JsonBody<MyObject<u64>>) -> String {\n    format!(\"{:?}\", body)\n}\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt().init();\n\n    let router = Router::new()\n        .push(Router::with_path(\"i32\").post(use_i32))\n        .push(Router::with_path(\"u64\").post(use_u64))\n        .push(Router::with_path(\"string\").post(use_string));\n\n    let doc = OpenApi::new(\"test api\", \"0.0.1\").merge_router(&router);\n\n    let router = router\n        .unshift(doc.into_router(\"/api-doc/openapi.json\"))\n        .unshift(SwaggerUi::new(\"/api-doc/openapi.json\").into_router(\"swagger-ui\"));\n\n    let acceptor = TcpListener::new(\"127.0.0.1:5800\").bind().await;\n    Server::new(acceptor).serve(router).await;\n}\n```\n\n### 🛠️ Salvo CLI\n\nSalvo CLI 是一个命令行工具，可以简化创建新的 Salvo 项目的过程，支持 Web API、网站、数据库（包括通过 SQLx、SeaORM、Diesel、Rbatis 支持的 SQLite、PostgreSQL、MySQL）和基本的中间件的模板。\n你可以使用 [salvo-cli](https://github.com/salvo-rs/salvo-cli)来创建一个新的 Salvo 项目：\n\n#### 安装\n\n```bash\ncargo install salvo-cli\n```\n\n#### 创建一个 Salvo 项目\n\n```bash\nsalvo new project_name\n```\n\n___\n\n### 更多示例\n\n您可以从 [examples](./examples/)文件夹下查看更多示例代码，您可以通过以下命令运行这些示例：\n\n```bash\ncd examples\ncargo run --bin example-basic-auth\n```\n\n您可以使用任何你想运行的示例名称替代这里的 `basic-auth`。\n\n## 🚀 性能\n\nBenchmark 测试结果可以从这里查看：\n\n[https://web-frameworks-benchmark.netlify.app/result?l=rust](https://web-frameworks-benchmark.netlify.app/result?l=rust)\n\n[https://www.techempower.com/benchmarks/#section=data-r22](https://www.techempower.com/benchmarks/#section=data-r22)\n\n## 🩸 贡献者\n\n<a href=\"https://github.com/salvo-rs/salvo/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=salvo-rs/salvo\" />\n</a>\n\n## ☕ 捐助\n\n`Salvo`是一个开源项目，如果想支持本项目，可以 ☕ [**请我喝杯咖啡**](https://ko-fi.com/chrislearn)。\n<p style=\"text-align: center;\">\n<img src=\"https://salvo.rs/images/alipay.png\" alt=\"Alipay\" width=\"180\"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://salvo.rs/images/weixin.png\" alt=\"Weixin\" width=\"180\"/>\n</p>\n\n## ⚠️ 开源协议\n\nSalvo 项目采用以下开源协议：\n\n- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0))\n\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or [http://opensource.org/licenses/MIT](http://opensource.org/licenses/MIT))\n\n"
        },
        {
          "name": "README.zh-hans.md",
          "type": "blob",
          "size": 11.296875,
          "content": "<div align=\"center\">\n<p><img alt=\"Salvo\" width=\"132\" style=\"max-width:40%;min-width:60px;\" src=\"https://salvo.rs/images/logo-text.svg\" /></p>\n<p>\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.md\">English</a>&nbsp;&nbsp;\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hans.md\">简体中文</a>&nbsp;&nbsp;\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hant.md\">繁體中文</a>\n</p>\n<p>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-linux/badge.svg\" />\n</a>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-macos/badge.svg\" />\n</a>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-windows/badge.svg\" />\n</a>\n<br>\n<a href=\"https://discord.gg/G8KfmS6ByH\">\n    <img src=\"https://img.shields.io/discord/1041442427006890014.svg?logo=discord\">\n</a>\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"crates.io\" src=\"https://img.shields.io/crates/v/salvo\" /></a>\n<a href=\"https://docs.rs/salvo\"><img alt=\"Documentation\" src=\"https://docs.rs/salvo/badge.svg\" /></a>\n<a href=\"https://github.com/rust-secure-code/safety-dance/\"><img alt=\"unsafe forbidden\" src=\"https://img.shields.io/badge/unsafe-forbidden-success.svg\" /></a>\n<a href=\"https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html\"><img alt=\"Rust Version\" src=\"https://img.shields.io/badge/rust-1.80%2B-blue\" /></a>\n<br>\n<a href=\"https://salvo.rs\">\n    <img alt=\"Website\" src=\"https://img.shields.io/badge/https-salvo.rs-%23f00\" />\n</a>\n<a href=\"https://codecov.io/gh/salvo-rs/salvo\"><img alt=\"codecov\" src=\"https://codecov.io/gh/salvo-rs/salvo/branch/main/graph/badge.svg\" /></a>\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"Download\" src=\"https://img.shields.io/crates/d/salvo.svg\" /></a>\n<img alt=\"License\" src=\"https://img.shields.io/crates/l/salvo.svg\" />\n</p>\n</div>\n\nSalvo(赛风) 是一个极其简单且功能强大的 Rust Web 后端框架。仅仅需要基础 Rust 知识即可开发后端服务。\n\n> 中国用户可以添加我微信 (chrislearn), 拉微信讨论群或者直接加入 QQ 群：823441777.\n\n## 🎯 功能特色\n\n- 基于 [Hyper 1](https://crates.io/crates/hyper), [Tokio](https://crates.io/crates/tokio) 开发;\n- 支持 HTTP1, HTTP2 和 **HTTP3**;\n- 统一的中间件和句柄接口;\n- 路由可以无限嵌套，并且可以在任何路由中附加多个中间件;\n- 集成 Multipart 表单处理;\n- 支持 WebSocket, WebTransport;\n- 支持 OpenAPI;\n- 支持 Acme, 自动从 [let's encrypt](https://letsencrypt.org/)获取 TLS 证书。\n- 支持 Tower Service 和 Layer.\n\n## ⚡️ 快速开始\n\n你可以查看[实例代码](https://github.com/salvo-rs/salvo/tree/main/examples), 或者访问[官网](https://salvo.rs)。\n\n### 支持 ACME 自动获取证书和 HTTP3 的 Hello World\n\n**只需要几行代码就可以实现一个同时支持 ACME 自动获取证书以及支持 HTTP1，HTTP2，HTTP3 协议的服务器。**\n\n```rust\nuse salvo::prelude::*;\n\n#[handler]\nasync fn hello(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {\n    res.render(Text::Plain(\"Hello World\"));\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut router = Router::new().get(hello);\n    let listener = TcpListener::new(\"0.0.0.0:443\")\n        .acme()\n        .add_domain(\"test.salvo.rs\") // 用你自己的域名替换此域名\n        .http01_challenge(&mut router).quinn(\"0.0.0.0:443\");\n    let acceptor = listener.join(TcpListener::new(\"0.0.0.0:80\")).bind().await;\n    Server::new(acceptor).serve(router).await;\n}\n```\n\n### 中间件\n\nSalvo 中的中间件其实就是 Handler, 没有其他任何特别之处。**所以书写中间件并不需要像其他某些框架需要掌握泛型关联类型等知识。只要你会写函数就会写中间件，就是这么简单!!!**\n\n```rust\nuse salvo::http::header::{self, HeaderValue};\nuse salvo::prelude::*;\n\n#[handler]\nasync fn add_header(res: &mut Response) {\n    res.headers_mut()\n        .insert(header::SERVER, HeaderValue::from_static(\"Salvo\"));\n}\n```\n\n然后将它添加到路由中：\n\n```rust\nRouter::new().hoop(add_header).get(hello)\n```\n\n这就是一个简单的中间件，它向 `Response` 的头部添加了 `Header`, 查看[完整源码](https://github.com/salvo-rs/salvo/blob/main/examples/middleware-add-header/src/main.rs)。\n\n### 可链式书写的树状路由系统\n\n正常情况下我们是这样写路由的：\n\n```rust\nRouter::with_path(\"articles\").get(list_articles).post(create_article);\nRouter::with_path(\"articles/{id}\")\n    .get(show_article)\n    .patch(edit_article)\n    .delete(delete_article);\n```\n\n往往查看文章和文章列表是不需要用户登录的，但是创建，编辑，删除文章等需要用户登录认证权限才可以。Salvo 中支持嵌套的路由系统可以很好地满足这种需求。我们可以把不需要用户登录的路由写到一起：\n\n```rust\nRouter::with_path(\"articles\")\n    .get(list_articles)\n    .push(Router::with_path(\"{id}\").get(show_article));\n```\n\n然后把需要用户登录的路由写到一起，并且使用相应的中间件验证用户是否登录：\n\n```rust\nRouter::with_path(\"articles\")\n    .hoop(auth_check)\n    .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article));\n```\n\n虽然这两个路由都有这同样的 `path(\"articles\")`, 然而它们依然可以被同时添加到同一个父路由，所以最后的路由长成了这个样子：\n\n```rust\nRouter::new()\n    .push(\n        Router::with_path(\"articles\")\n            .get(list_articles)\n            .push(Router::with_path(\"{id}\").get(show_article)),\n    )\n    .push(\n        Router::with_path(\"articles\")\n            .hoop(auth_check)\n            .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article)),\n    );\n```\n\n`{id}`匹配了路径中的一个片段，正常情况下文章的的 `id`只是一个数字，这是我们可以使用正则表达式限制制 `id`的匹配规则，`r\"{id|\\d+}\"`。\n\n还可以通过 `{**}`, `{*+}` 或者 `{*?}`匹配所有剩余的路径片段。为了代码易读性性强些，也可以添加适合的名字，让路径语义更清晰，比如：: `{**file_path}`。\n\n有些用于匹配路径的正则表达式需要经常被使用，可以将它事先注册，比如 GUID:\n\n```rust\nPathFilter::register_wisp_regex(\n    \"guid\",\n    Regex::new(\"[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}\").unwrap(),\n);\n```\n\n这样在需要路径匹配时就变得更简洁：\n\n```rust\nRouter::with_path(\"{id:guid}\").get(index)\n```\n\n查看[完整源码](https://github.com/salvo-rs/salvo/blob/main/examples/routing-guid/src/main.rs)\n\n### 文件上传\n\n可以通过 `Request` 中的 `file`异步获取上传的文件：\n\n```rust\n#[handler]\nasync fn upload(req: &mut Request, res: &mut Response) {\n    let file = req.file(\"file\").await;\n    if let Some(file) = file {\n        let dest = format!(\"temp/{}\", file.name().unwrap_or_else(|| \"file\".into()));\n        if let Err(e) = std::fs::copy(&file.path, Path::new(&dest)) {\n            res.status_code(StatusCode::INTERNAL_SERVER_ERROR);\n        } else {\n            res.render(\"Ok\");\n        }\n    } else {\n        res.status_code(StatusCode::BAD_REQUEST);\n    }\n}\n```\n\n### 提取请求数据\n\n可以轻松地从多个不同数据源获取数据，并且组装为你想要的类型。可以先定义一个自定义的类型，比如：\n\n```rust\n#[derive(Serialize, Deserialize, Extractible, Debug)]\n/// 默认从 body 中获取数据字段值\n#[salvo(extract(default_source(from = \"body\")))]\nstruct GoodMan<'a> {\n    /// 其中, id 号从请求路径参数中获取, 并且自动解析数据为 i64 类型.\n    #[salvo(extract(source(from = \"param\")))]\n    id: i64,\n    /// 可以使用引用类型, 避免内存复制.\n    username: &'a str,\n    first_name: String,\n    last_name: String,\n}\n```\n\n然后在 `Handler`中可以这样获取数据：\n\n```rust\n#[handler]\nasync fn edit(req: &mut Request) {\n    let good_man: GoodMan<'_> = req.extract().await.unwrap();\n}\n```\n\n甚至于可以直接把类型作为参数传入函数，像这样：\n\n```rust\n#[handler]\nasync fn edit<'a>(good_man: GoodMan<'a>) {\n    res.render(Json(good_man));\n}\n```\n\n查看[完整源码](https://github.com/salvo-rs/salvo/blob/main/examples/extract-nested/src/main.rs)\n\n### OpenAPI 支持\n\n无需对项目做大的改动，即可实现对 OpenAPI 的完美支持。\n\n```rust\n#[derive(Serialize, Deserialize, ToSchema, Debug)]\nstruct MyObject<T: ToSchema + std::fmt::Debug> {\n    value: T,\n}\n\n#[endpoint]\nasync fn use_string(body: JsonBody<MyObject<String>>) -> String {\n    format!(\"{:?}\", body)\n}\n#[endpoint]\nasync fn use_i32(body: JsonBody<MyObject<i32>>) -> String {\n    format!(\"{:?}\", body)\n}\n#[endpoint]\nasync fn use_u64(body: JsonBody<MyObject<u64>>) -> String {\n    format!(\"{:?}\", body)\n}\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt().init();\n\n    let router = Router::new()\n        .push(Router::with_path(\"i32\").post(use_i32))\n        .push(Router::with_path(\"u64\").post(use_u64))\n        .push(Router::with_path(\"string\").post(use_string));\n\n    let doc = OpenApi::new(\"test api\", \"0.0.1\").merge_router(&router);\n\n    let router = router\n        .unshift(doc.into_router(\"/api-doc/openapi.json\"))\n        .unshift(SwaggerUi::new(\"/api-doc/openapi.json\").into_router(\"swagger-ui\"));\n\n    let acceptor = TcpListener::new(\"127.0.0.1:5800\").bind().await;\n    Server::new(acceptor).serve(router).await;\n}\n```\n\n### 🛠️ Salvo CLI\n\nSalvo CLI 是一个命令行工具，可以简化创建新的 Salvo 项目的过程，支持 Web API、网站、数据库（包括通过 SQLx、SeaORM、Diesel、Rbatis 支持的 SQLite、PostgreSQL、MySQL）和基本的中间件的模板。\n你可以使用 [salvo-cli](https://github.com/salvo-rs/salvo-cli)来创建一个新的 Salvo 项目：\n\n#### 安装\n\n```bash\ncargo install salvo-cli\n```\n\n#### 创建一个 Salvo 项目\n\n```bash\nsalvo new project_name\n```\n\n___\n\n### 更多示例\n\n您可以从 [examples](./examples/)文件夹下查看更多示例代码，您可以通过以下命令运行这些示例：\n\n```bash\ncd examples\ncargo run --bin example-basic-auth\n```\n\n您可以使用任何你想运行的示例名称替代这里的 `basic-auth`。\n\n## 🚀 性能\n\nBenchmark 测试结果可以从这里查看：\n\n[https://web-frameworks-benchmark.netlify.app/result?l=rust](https://web-frameworks-benchmark.netlify.app/result?l=rust)\n\n[https://www.techempower.com/benchmarks/#section=data-r22](https://www.techempower.com/benchmarks/#section=data-r22)\n\n## 🩸 贡献者\n\n<a href=\"https://github.com/salvo-rs/salvo/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=salvo-rs/salvo\" />\n</a>\n\n## ☕ 捐助\n\n`Salvo`是一个开源项目，如果想支持本项目，可以 ☕ [**请我喝杯咖啡**](https://ko-fi.com/chrislearn)。\n<p style=\"text-align: center;\">\n<img src=\"https://salvo.rs/images/alipay.png\" alt=\"Alipay\" width=\"180\"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://salvo.rs/images/weixin.png\" alt=\"Weixin\" width=\"180\"/>\n</p>\n\n## ⚠️ 开源协议\n\nSalvo 项目采用以下开源协议：\n\n- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0))\n\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or [http://opensource.org/licenses/MIT](http://opensource.org/licenses/MIT))\n\n"
        },
        {
          "name": "README.zh-hant.md",
          "type": "blob",
          "size": 11.3076171875,
          "content": "<div align=\"center\">\n<p><img alt=\"Salvo\" width=\"132\" style=\"max-width:40%;min-width:60px;\" src=\"https://salvo.rs/images/logo-text.svg\" /></p>\n<p>\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.md\">English</a>&nbsp;&nbsp;\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hans.md\">简体中文</a>&nbsp;&nbsp;\n    <a href=\"https://github.com/salvo-rs/salvo/blob/main/README.zh-hant.md\">繁體中文</a>\n</p>\n<p>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-linux/badge.svg\" />\n</a>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-macos/badge.svg\" />\n</a>\n<a href=\"https://github.com/salvo-rs/salvo/actions\">\n    <img alt=\"build status\" src=\"https://github.com/salvo-rs/salvo/workflows/ci-windows/badge.svg\" />\n</a>\n<br>\n<a href=\"https://discord.gg/G8KfmS6ByH\">\n    <img src=\"https://img.shields.io/discord/1041442427006890014.svg?logo=discord\">\n</a>\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"crates.io\" src=\"https://img.shields.io/crates/v/salvo\" /></a>\n<a href=\"https://docs.rs/salvo\"><img alt=\"Documentation\" src=\"https://docs.rs/salvo/badge.svg\" /></a>\n<a href=\"https://github.com/rust-secure-code/safety-dance/\"><img alt=\"unsafe forbidden\" src=\"https://img.shields.io/badge/unsafe-forbidden-success.svg\" /></a>\n<a href=\"https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html\"><img alt=\"Rust Version\" src=\"https://img.shields.io/badge/rust-1.80%2B-blue\" /></a>\n<br>\n<a href=\"https://salvo.rs\">\n    <img alt=\"Website\" src=\"https://img.shields.io/badge/https-salvo.rs-%23f00\" />\n</a>\n<a href=\"https://codecov.io/gh/salvo-rs/salvo\"><img alt=\"codecov\" src=\"https://codecov.io/gh/salvo-rs/salvo/branch/main/graph/badge.svg\" /></a>\n<a href=\"https://crates.io/crates/salvo\"><img alt=\"Download\" src=\"https://img.shields.io/crates/d/salvo.svg\" /></a>\n<img alt=\"License\" src=\"https://img.shields.io/crates/l/salvo.svg\" />\n</p>\n</div>\n\nSalvo(賽風) 是一個極其簡單且功能強大的 Rust Web 後端框架。僅僅需要基礎 Rust 知識即可開發後端服務。\n\n> 中国用户可以添加我微信 (chrislearn), 拉微信討論群或者直接加入 QQ 群：823441777.\n\n## 🎯 功能特色\n\n- 基於 [Hyper 1](https://crates.io/crates/hyper), [Tokio](https://crates.io/crates/tokio) 開發;\n- 統一的中間件和句柄接口;\n- 支持 HTTP1, HTTP2 和 **HTTP3**;\n- 路由可以無限嵌套，並且可以在任何路由中附加多個中間件;\n- 集成 Multipart 錶單處理;\n- 支持 WebSocket, WebTransport;\n- 支持 OpenAPI;\n- 支持 Acme, 自動從 [let's encrypt](https://letsencrypt.org/)獲取 TLS 證書。\n- 支持 Tower Service 和 Layer.\n\n## ⚡️ 快速開始\n\n你可以查看[實例代碼](https://github.com/salvo-rs/salvo/tree/main/examples), 或者訪問[官網](https://salvo.rs)。\n\n### 支持 ACME 自動獲取證書和 HTTP3 的 Hello World\n\n**隻需要幾行代碼就可以實現一個同時支持 ACME 自動獲取證書以及支持 HTTP1，HTTP2，HTTP3 協議的伺服器。**\n\n```rust\nuse salvo::prelude::*;\n\n#[handler]\nasync fn hello(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {\n    res.render(Text::Plain(\"Hello World\"));\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut router = Router::new().get(hello);\n    let listener = TcpListener::new(\"0.0.0.0:443\")\n        .acme()\n        .add_domain(\"test.salvo.rs\") // 用你自己的域名替换此域名\n        .http01_challenge(&mut router).quinn(\"0.0.0.0:443\");\n    let acceptor = listener.join(TcpListener::new(\"0.0.0.0:80\")).bind().await;\n    Server::new(acceptor).serve(router).await;\n}\n```\n\n### 中間件\n\nSalvo 中的中間件其實就是 Handler, 冇有其他任何特別之處。**所以書寫中間件並不需要像其他某些框架需要掌握泛型關聯類型等知識。隻要你會寫函數就會寫中間件，就是這麼簡單!!!**\n\n```rust\nuse salvo::http::header::{self, HeaderValue};\nuse salvo::prelude::*;\n\n#[handler]\nasync fn add_header(res: &mut Response) {\n    res.headers_mut()\n        .insert(header::SERVER, HeaderValue::from_static(\"Salvo\"));\n}\n```\n\n然後將它添加到路由中：\n\n```rust\nRouter::new().hoop(add_header).get(hello)\n```\n\n這就是一個簡單的中間件，它嚮 `Response` 的頭部添加了 `Header`, 查看[完整源碼](https://github.com/salvo-rs/salvo/blob/main/examples/middleware-add-header/src/main.rs)。\n\n### 可鏈式書寫的樹狀路由係統\n\n正常情況下我們是這樣寫路由的：\n\n```rust\nRouter::with_path(\"articles\").get(list_articles).post(create_article);\nRouter::with_path(\"articles/{id}\")\n    .get(show_article)\n    .patch(edit_article)\n    .delete(delete_article);\n```\n\n往往查看文章和文章列錶是不需要用戶登錄的，但是創建，編輯，刪除文章等需要用戶登錄認證權限才可以。Salvo 中支持嵌套的路由係統可以很好地滿足這種需求。我們可以把不需要用戶登錄的路由寫到一起：\n\n```rust\nRouter::with_path(\"articles\")\n    .get(list_articles)\n    .push(Router::with_path(\"{id}\").get(show_article));\n```\n\n然後把需要用戶登錄的路由寫到一起，並且使用相應的中間件驗證用戶是否登錄：\n\n```rust\nRouter::with_path(\"articles\")\n    .hoop(auth_check)\n    .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article));\n```\n\n雖然這兩個路由都有這同樣的 `path(\"articles\")`, 然而它們依然可以被同時添加到同一個父路由，所以最後的路由長成了這個樣子：\n\n```rust\nRouter::new()\n    .push(\n        Router::with_path(\"articles\")\n            .get(list_articles)\n            .push(Router::with_path(\"{id}\").get(show_article)),\n    )\n    .push(\n        Router::with_path(\"articles\")\n            .hoop(auth_check)\n            .push(Router::with_path(\"{id}\").patch(edit_article).delete(delete_article)),\n    );\n```\n\n`{id}`匹配了路徑中的一個片段，正常情況下文章的的 `id`隻是一個數字，這是我們可以使用正則錶達式限製製 `id`的匹配規則，`r\"{id|\\d+}\"`。\n\n還可以通過 `{**}`, `{*+}` 或者 `{*?}`匹配所有剩餘的路徑片段。為了代碼易讀性性強些，也可以添加適合的名字，讓路徑語義更清晰，比如：: `{**file_path}`。\n\n有些用於匹配路徑的正則錶達式需要經常被使用，可以將它事先註冊，比如 GUID:\n\n```rust\nPathFilter::register_wisp_regex(\n    \"guid\",\n    Regex::new(\"[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}\").unwrap(),\n);\n```\n\n這樣在需要路徑匹配時就變得更簡潔：\n\n```rust\nRouter::with_path(\"{id:guid}\").get(index)\n```\n\n查看[完整源碼](https://github.com/salvo-rs/salvo/blob/main/examples/routing-guid/src/main.rs)\n\n### 文件上傳\n\n可以通過 `Request` 中的 `file`異步獲取上傳的文件：\n\n```rust\n#[handler]\nasync fn upload(req: &mut Request, res: &mut Response) {\n    let file = req.file(\"file\").await;\n    if let Some(file) = file {\n        let dest = format!(\"temp/{}\", file.name().unwrap_or_else(|| \"file\".into()));\n        if let Err(e) = std::fs::copy(&file.path, Path::new(&dest)) {\n            res.status_code(StatusCode::INTERNAL_SERVER_ERROR);\n        } else {\n            res.render(\"Ok\");\n        }\n    } else {\n        res.status_code(StatusCode::BAD_REQUEST);\n    }\n}\n```\n\n### 提取請求數據\n\n可以輕鬆地從多個不同數據源獲取數據，並且組裝為你想要的類型。可以先定義一個自定義的類型，比如：\n\n```rust\n#[derive(Serialize, Deserialize, Extractible, Debug)]\n/// 默認從 body 中獲取數據字段值\n#[salvo(extract(default_source(from = \"body\")))]\nstruct GoodMan<'a> {\n    /// 其中, id 號從請求路徑參數中獲取, 並且自動解析數據為 i64 類型.\n    #[salvo(extract(source(from = \"param\")))]\n    id: i64,\n    /// 可以使用引用類型, 避免內存複製.\n    username: &'a str,\n    first_name: String,\n    last_name: String,\n}\n```\n\n然後在 `Handler`中可以這樣獲取數據：\n\n```rust\n#[handler]\nasync fn edit(req: &mut Request) {\n    let good_man: GoodMan<'_> = req.extract().await.unwrap();\n}\n```\n\n甚至於可以直接把類型作為參數傳入函數，像這樣：\n\n```rust\n#[handler]\nasync fn edit<'a>(good_man: GoodMan<'a>) {\n    res.render(Json(good_man));\n}\n```\n\n查看[完整源碼](https://github.com/salvo-rs/salvo/blob/main/examples/extract-nested/src/main.rs)\n\n### OpenAPI 支持\n\n無需對項目做大的改動，即可實現對 OpenAPI 的完美支持。\n\n```rust\n#[derive(Serialize, Deserialize, ToSchema, Debug)]\nstruct MyObject<T: ToSchema + std::fmt::Debug> {\n    value: T,\n}\n\n#[endpoint]\nasync fn use_string(body: JsonBody<MyObject<String>>) -> String {\n    format!(\"{:?}\", body)\n}\n#[endpoint]\nasync fn use_i32(body: JsonBody<MyObject<i32>>) -> String {\n    format!(\"{:?}\", body)\n}\n#[endpoint]\nasync fn use_u64(body: JsonBody<MyObject<u64>>) -> String {\n    format!(\"{:?}\", body)\n}\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt().init();\n\n    let router = Router::new()\n        .push(Router::with_path(\"i32\").post(use_i32))\n        .push(Router::with_path(\"u64\").post(use_u64))\n        .push(Router::with_path(\"string\").post(use_string));\n\n    let doc = OpenApi::new(\"test api\", \"0.0.1\").merge_router(&router);\n\n    let router = router\n        .unshift(doc.into_router(\"/api-doc/openapi.json\"))\n        .unshift(SwaggerUi::new(\"/api-doc/openapi.json\").into_router(\"swagger-ui\"));\n\n    let acceptor = TcpListener::new(\"127.0.0.1:5800\").bind().await;\n    Server::new(acceptor).serve(router).await;\n}\n```\n\n### 🛠️ Salvo CLI\n\nSalvo CLI 是一個命令行工具，可以簡化創建新的 Salvo 項目的過程，支援 Web API、網站、資料庫（包括透過 SQLx、SeaORM、Diesel、Rbatis 支援的 SQLite、PostgreSQL、MySQL）和基本的中介軟體的模板。\n你可以使用 [salvo-cli](https://github.com/salvo-rs/salvo-cli)来來創建一個新的 Salvo 項目：\n\n#### 安裝\n\n```bash\ncargo install salvo-cli\n```\n\n#### 創建一個新的 Salvo 項目\n\n```bash\nsalvo new project_name\n```\n\n___\n\n### 更多示例\n\n您可以從 [examples](./examples/)文件夾下查看更多示例代碼，您可以通過以下命令運行這些示例：\n\n\n```bash\ncd examples\ncargo run --bin example-basic-auth\n```\n\n您可以使用任何你想運行的示例名稱替代這裏的 `basic-auth`。\n\n## 🚀 性能\n\nBenchmark 測試結果可以從這裏查看：\n\n[https://web-frameworks-benchmark.netlify.app/result?l=rust](https://web-frameworks-benchmark.netlify.app/result?l=rust)\n\n[https://www.techempower.com/benchmarks/#section=data-r22](https://www.techempower.com/benchmarks/#section=data-r22)\n\n## 🩸 貢獻者\n\n<a href=\"https://github.com/salvo-rs/salvo/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=salvo-rs/salvo\" />\n</a>\n\n## ☕ 捐助\n\n`Salvo`是一個開源項目，如果想支持本項目，可以 ☕ [**請我喝杯咖啡**](https://ko-fi.com/chrislearn)。\n<p style=\"text-align: center;\">\n<img src=\"https://salvo.rs/images/alipay.png\" alt=\"Alipay\" width=\"180\"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://salvo.rs/images/weixin.png\" alt=\"Weixin\" width=\"180\"/>\n</p>\n\n## ⚠️ 開源協議\n\nSalvo 項目採用以下開源協議：\n\n- Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0))\n\n- MIT license ([LICENSE-MIT](LICENSE-MIT) or [http://opensource.org/licenses/MIT](http://opensource.org/licenses/MIT))"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.06640625,
          "content": "# Security Policy\n\n## Reporting a Vulnerability\n\nchris@acroidea.com\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "clippy.toml",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "crates",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "rustfmt.toml",
          "type": "blob",
          "size": 0.0390625,
          "content": "# max_width = 120\nreorder_imports = true"
        }
      ]
    }
  ]
}