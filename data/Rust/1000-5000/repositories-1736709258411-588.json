{
  "metadata": {
    "timestamp": 1736709258411,
    "page": 588,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "moka-rs/moka",
      "stars": 1735,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".cargo",
          "type": "tree",
          "content": null
        },
        {
          "name": ".ci_extras",
          "type": "tree",
          "content": null
        },
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.251953125,
          "content": "# https://docs.codecov.com/docs/quick-start#tips-and-tricks\n# https://docs.codecov.com/docs/codecovyml-reference\n\ncoverage:\n  status:\n    project:\n      default:\n        informational: true\n    patch: false\n\ncomment:\n  layout: \"diff\"\n  require_changes: true\n"
        },
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0693359375,
          "content": "**/*.rs.bk\n**/*~\n.DS_Store\n/target/\nCargo.lock\n\n# intellij cache\n.idea\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 38.451171875,
          "content": "# Moka Cache &mdash; Change Log\n\n## Version 0.12.10\n\n### Changed\n\n- Disable the `quanta` feature by default. ([#482][gh-pull-0482])\n- Replaced most uses of `quanta::Instant` with `std::time::Instant` to increase the\n  accuracy of time measurements ([#481][gh-pull-0481]):\n    - When `quanta` feature is enabled, `quanta::Instant` is used for some\n      performance critical parts in the cache, and `std::time::Instant` is used for\n      the rest of the parts.\n    - However, as of this version, enabling the `quanta` feature will not make any\n      noticeable difference in the performance.\n    - When `quanta` feature is disabled (default), `std::time::Instant` is used for\n      all time measurements.\n- Switched to `AtomicU64` of the `portable-atomic` crate, which provides fallback\n  implementations for platforms where `std` `AtomicU64` is not available\n  ([#480][gh-pull-0480]):\n    - `moka`'s `atomic64` feature no longer has any effect on the build as\n      `AtomicU64` is now always available on all platforms. But we keep the\n      `atomic64` feature in `Cargo.toml` for backward compatibility.\n\n\n## Version 0.12.9\n\nBumped the minimum supported Rust version (MSRV) to 1.70 (June 1, 2023)\n([#474][gh-pull-0474]).\n\n### Fixed\n\n- Prevent an occasional panic in an internal `to_std_instant` method when per-entry\n  expiration policy is used. ([#472][gh-issue-0472])\n- Documentation: Removed leftover mentions of background threads.\n  ([#464][gh-issue-0464])\n    - Also added the implementation details chapter to the crate top-level\n      documentation to explain some internal behavior of the cache.\n\n### Added\n\n- Added `and_try_compute_if_nobody_else` method to `future::Cache`'s `entry` API.\n  ([#460][gh-pull-0460], by [@xuehaonan27][gh-xuehaonan27])\n\n### Removed\n\n- Removed `triomphe` crate from the dependency by adding our own internal `Arc` type.\n  ([#456][gh-pull-0456])\n    - Our `Arc` will be more memory efficient than `std::sync::Arc` or\n      `triomphe::Arc` on 64-bit platforms as it uses a single `AtomicU32` counter.\n- Removed needless traits along with `async-trait` usage. ([#445][gh-pull-0445], by\n  [@Swatinem][gh-Swatinem])\n\n### Changed\n\n- Enable `atomic64` feature only when target supports `AtomicU64`.\n  ([#466][gh-pull-0466], by [@zonyitoo][gh-zonyitoo])\n- Made `once_cell` dependency optional ([#444][gh-pull-0444]).\n- Stopped creating references unnecessarily to compare pointers by-address.\n  ([#452][gh-pull-0452], by [@JoJoDeveloping][gh-JoJoDeveloping])\n\n\n## Version 0.12.8\n\n### Fixed\n\n- Avoid to use recent versions (`v0.1.12` or newer) of `triomphe` crate to keep our\n  MSRV (Minimum Supported Rust Version) at Rust 1.65\n  ([#426][gh-pull-0426], by [@eaufavor][gh-eaufavor]).\n    - `triomphe@v0.1.12` requires Rust 1.76 or newer, so it will not compile with our\n      MSRV.\n- docs: Fix per-entry expiration policy documentation ([#421][gh-pull-0421], by\n  [@arcstur][gh-arcstur]).\n\n\n## Version 0.12.7\n\n### Changed\n\n- Ensure a single call to `run_pending_tasks` to evict as many entries as possible\n  from the cache ([#417][gh-pull-0417]).\n\n\n## Version 0.12.6\n\n### Fixed\n\n- Fixed a bug in `future::Cache` that pending `run_pending_tasks` calls may cause\n  infinite busy loop in an internal `schedule_write_op` method\n  ([#412][gh-issue-0412]):\n    - This bug was introduced in `v0.12.0` when the background threads were removed\n      from `future::Cache`.\n    - This bug can occur when `run_pending_task` method is called by user code while\n      cache is receiving a very high number of concurrent cache write operations.\n      (e.g. `insert`, `get_with`, `invalidate` etc.)\n    - When it occurs, the `schedule_write_op` method will be spinning in a busy loop\n      forever, causing high CPU usage and all other async tasks to be starved.\n\n### Changed\n\n- Upgraded `async-lock` crate used by `future::Cache` from `v2.4` to the latest\n  `v3.3`.\n\n\n## Version 0.12.5\n\n### Added\n\n- Added support for a plain LRU (Least Recently Used) eviction policy\n    ([#390][gh-pull-0390]):\n    - The LRU policy is enabled by calling the `eviction_policy` method of the cache\n      builder with a policy obtained by `EvictionPolicy::lru` function.\n    - The default eviction policy remains the TinyLFU (Tiny, Least Frequently Used)\n      as it maintains better hit rate than LRU for most use cases. TinyLFU combines\n      LRU eviction policy and popularity-based admission policy. A probabilistic data\n      structure is used to estimate historical popularity of both hit and missed\n      keys. (not only the keys currently in the cache.)\n    - However, some use cases may prefer LRU policy over TinyLFU. An example is\n      recency biased workload such as streaming data processing. LRU policy can be\n      used for them to achieve better hit rate.\n    - Note that we are planning to add an adaptive eviction/admission policy called\n      Window-TinyLFU in the future. It will adjust the balance between recency and\n      frequency based on the current workload.\n\n\n## Version 0.12.4\n\n### Fixed\n\n- Ensure `crossbeam-epoch` to run GC when dropping a cache ([#384][gh-pull-0384]):\n    - `crossbeam-epoch` crate provides an epoch-based memory reclamation scheme for\n      concurrent data structures. It is used by Moka cache to safely drop cached\n      entries while they are still being accessed by other threads.\n    - `crossbeam-epoch` does its best to reclaim memory (drop the entries evicted\n      from the cache) when the epoch is advanced. However, it does not guarantee that\n      memory will be reclaimed immediately after the epoch is advanced. This means\n      that entries can remain in the memory for a while after the cache is dropped.\n    - This fix ensures that, when a cache is dropped, the epoch is advanced and\n      `crossbeam-epoch`'s thread local buffers are flushed, helping to reclaim memory\n      immediately.\n    - Note that there are still chances that some entries remain in the memory for a\n      while after a cache is dropped. We are looking for alternatives to\n      `crossbeam-epoch` to improve this situation (e.g. [#385][gh-issue-0385]).\n\n### Added\n\n- Added an example for reinserting expired entries to the cache.\n  ([#382][gh-pull-0382])\n\n\n## Version 0.12.3\n\n### Added\n\n- Added the upsert and compute methods for modifying a cached entry\n  ([#370][gh-pull-0370]):\n    - Now the `entry` and `entry_by_ref` APIs have the following methods:\n        - `and_upsert_with` method to insert or update the entry.\n        - `and_compute_with` method to insert, update, remove or do nothing on the\n          entry.\n        - `and_try_compute_with` method, which is similar to above but returns\n          `Result`.\n\n### Fixed\n\n- Raised the version requirement of the `quanta` from `>=0.11.0, <0.12.0` to\n  `>=0.12.2, <0.13.0` to avoid under-measuring the elapsed time on Apple silicon\n  Macs ([#376][gh-pull-0376]).\n    - Due to this under-measurement, cached entries on macOS arm64 can expire sightly\n      later than expected.\n\n\n## Version 0.12.2\n\n### Fixed\n\n- Prevent timing issues in writes that cause inconsistencies between the cache's\n  internal data structures ([#348][gh-pull-0348]):\n    - One way to trigger the issue is that insert the same key twice quickly, once\n      when the cache is full and a second time when there is a room in the cache.\n      - When it occurs, the cache will not return the value inserted in the second\n        call (which is wrong), and the `entry_count` method will keep returning a non\n        zero value after calling the `invalidate_all` method (which is also wrong).\n- Now the last access time of a cached entry is updated immediately after the entry\n  is read ([#363][gh-pull-0363]):\n    - When the time-to-idle of a cache is set, the last access time of a cached entry\n      is used to determine if the entry has been expired.\n    - Before this fix, the access time was updated (to the time when it was read)\n      when pending tasks were processed. This delay caused issue that some entries\n      become temporarily unavailable for reads even though they have been accessed\n      recently. And then they will become available again after the pending tasks are\n      processed.\n    - Now the last access time is updated immediately after the entry is read. The\n      entry will remain valid until the time-to-idle has elapsed.\n\nNote that both of [#348][gh-pull-0348] and [#363][gh-pull-0363] were already present\nin `v0.11.x` and older versions. However they were less likely to occur because they\nhad background threads to periodically process pending tasks. So there were much\nshorter time windows for these issues to occur.\n\n### Changed\n\n- Updated the Rust edition from 2018 to 2021. ([#339][gh-pull-0339], by\n  [@nyurik][gh-nyurik])\n    - The MSRV remains at Rust 1.65.\n- Changed to use inline format arguments throughout the code, including examples.\n  ([#340][gh-pull-0340], by [@nyurik][gh-nyurik])\n\n### Added\n\n- Added an example for cascading drop triggered by eviction ([#350][gh-pull-0350], by\n  [@peter-scholtens][gh-peter-scholtens])\n\n\n## Version 0.12.1\n\n### Fixed\n\n- Fixed memory leak in `future::Cache` that occurred when `get_with()`,\n  `entry().or_insert_with()`, and similar methods were used ([#329][gh-issue-0329]).\n    - This bug was introduced in `v0.12.0`. Versions prior to `v0.12.0` do not\n      have this bug.\n\n### Changed\n\n- (Performance)  Micro-optimize `ValueInitializer` ([#331][gh-pull-0331], by\n  [@Swatinem][gh-Swatinem]).\n\n\n## Version 0.12.0\n\n> **Note**\n> `v0.12.0` has major breaking changes on the API and internal behavior.\n\n- **`sync` caches are no longer enabled by default**: Please use a crate feature\n  `sync` to enable it.\n\n- **No more background threads**: All cache types `future::Cache`, `sync::Cache`, and\n  `sync::SegmentedCache` no longer spawn background threads.\n\n  - The `scheduled-thread-pool` crate was removed from the dependency.\n  - Because of this change, many private methods and some public methods under the\n    `future` module were converted to `async` methods. You may need to add `.await`\n    to your code for those methods.\n\n- **Immediate notification delivery**: The `notification::DeliveryMode` enum for the\n  eviction listener was removed. Now all cache types behave as if the `Immediate`\n  delivery mode is specified.\n\nPlease read the [MIGRATION-GUIDE.md][migration-guide-v012] for more details.\n\n[migration-guide-v012]: https://github.com/moka-rs/moka/blob/main/MIGRATION-GUIDE.md#migrating-to-v0120-from-a-prior-version\n\n### Changed\n\n- Removed the thread pool from `future` cache ([#294][gh-pull-0294]) and `sync`\n  caches ([#316][gh-pull-0316]).\n- Improved async cancellation safety of `future::Cache`. ([#309][gh-pull-0309])\n\n### Fixed\n\n- Fixed a bug that an internal `do_insert_with_hash` method gets the current\n  `Instant` too early when eviction listener is enabled. ([#322][gh-issue-0322])\n\n\n## Version 0.11.3\n\n### Fixed\n\n- Fixed a bug in `sync::Cache` and `sync::SegmentedCache` where memory usage kept\n  increasing when the eviction listener was set with the `Immediate` delivery mode.\n  ([#295][gh-pull-0295])\n\n\n## Version 0.11.2\n\nBumped the minimum supported Rust version (MSRV) to 1.65 (Nov 3, 2022).\n([#275][gh-pull-0275])\n\n### Removed\n\n- Removed `num_cpus` crate from the dependency. ([#277][gh-pull-0277])\n\n### Changed\n\n- Refactored internal methods of the concurrent hash table to reduce compile times.\n  ([#265][gh-pull-0265], by [@Swatinem][gh-Swatinem])\n\n\n## Version 0.11.1\n\n### Fixed\n\n-  Fixed occasional panic in internal `FrequencySketch` in debug build.\n   ([#272][gh-pull-0272])\n\n### Added\n\n- Added some example programs to the `examples` directory. ([#268][gh-pull-0268], by\n  [@peter-scholtens][gh-peter-scholtens])\n\n\n## Version 0.11.0\n\n### Added\n\n- Added support for per-entry expiration ([#248][gh-pull-0248]):\n    - In addition to the existing TTL and TTI (time-to-idle) expiration times that\n      apply to all entries in the cache, the `sync` and `future` caches can now allow\n      different expiration times for individual entries.\n- Added the `remove` method to the `sync` and `future` caches\n  ([#255](gh-issue-0255)):\n    - Like the `invalidate` method, this method discards any cached value for the\n      key, but returns a clone of the value.\n\n### Fixed\n\n- Fixed the caches mutating a deque node through a `NonNull` pointer derived from a\n  shared reference. ([#259][gh-pull-0259])\n\n### Removed\n\n- Removed `unsync` cache that was marked as deprecated in [v0.10.0](#version-0100).\n\n\n## Version 0.10.2\n\nBumped the minimum supported Rust version (MSRV) to 1.60 (Apr 7, 2022).\n([#252][gh-issue-0252])\n\n### Changed\n\n- Upgraded `quanta` crate to v0.11.0. ([#251][gh-pull-0251])\n    - This resolved \"[RUSTSEC-2020-0168]: `mach` is unmaintained\"\n      ([#243][gh-issue-0243]) by replacing `mach` with `mach2`.\n    - `quanta` v0.11.0's MSRV is 1.60, so we also bumped the MSRV of Moka to 1.60.\n\n\n## Version 0.10.1\n\n### Fixed\n\n- Fixed a bug that `future` cache's `blocking().invalidate(key)` method does not\n  trigger the eviction listener. ([#242][gh-issue-0242])\n\n### Changed\n\n- Now `sync` and `future` caches will not cache anything when the max capacity is set\n  to zero ([#230][gh-issue-0230]):\n    - Previously, they would cache some entries for short time (< 0.5 secs) even\n      though the max capacity is zero.\n\n\n## Version 0.10.0\n\n### Breaking Changes\n\n- The following caches have been moved to a separate crate called\n  [Mini-Moka][mini-moka-crate]:\n    - `moka::unsync::Cache` → `mini_moka::unsync::Cache`\n    - `moka::dash::Cache` → `mini_moka::sync::Cache`\n- The following methods have been removed from `sync` and `future` caches\n  ([#199][gh-pull-0199]). They were deprecated in v0.8.0:\n    - `get_or_insert_with` (Use `get_with` instead)\n    - `get_or_try_insert_with` (Use `try_get_with` instead)\n- The following methods of `sync` and `future` caches have been marked as deprecated\n  ([#193][gh-pull-0193]):\n    - `get_with_if` (Use `entry` API's `or_insert_with_if` instead)\n\n### Added\n\n- Add `entry` and `entry_by_ref` APIs to `sync` and `future` caches\n  ([#193][gh-pull-0193]):\n    - They allow users to perform more complex operations on a cache entry. At this\n      point, the following operations (methods) are provided:\n        - `or_default`\n        - `or_insert`\n        - `or_insert_with`\n        - `or_insert_with_if`\n        - `or_optionally_insert_with`\n        - `or_try_insert_with`\n    - The above methods return `Entry` type, which provides `is_fresh` method to\n      check if the value was freshly computed or already existed in the cache.\n\n\n## Version 0.9.7\n\n### Fixed\n\n- Fix an issue that `get_with` method of `future` cache inflates future size by ~7x,\n  sometimes causing stack overflow ([#212][gh-issue-0212]):\n    - This was caused by a known `rustc` optimization issue on async functions\n      ([rust-lang/rust#62958][gh-rust-issue-62958]).\n    - Added a workaround to our cache and now it will only inflate the size by ~2.5x.\n- Fix a bug that setting the number of segments of `sync` cache will disable\n  notifications. ([#207][gh-issue-0207])\n\n### Added\n\n- Add examples for `build_with_hasher` method of cache builders.\n  ([#216][gh-pull-0216])\n\n\n## Version 0.9.6\n\n### Fixed\n\n- Prevent race condition in `get_with` family methods to avoid evaluating `init`\n  closure or future multiple times in concurrent calls. ([#195][gh-pull-0195])\n\n\n## Version 0.9.5\n\n### Added\n\n- Add `optionally_get_with` method to `sync` and `future` caches\n  ([#187][gh-pull-0187], by [@LMJW][gh-LMJW]):\n    - It is similar to `try_get_with` but takes an init closure/future returning an\n      `Option<V>` instead of `Result<V, E>`.\n- Add `by_ref` version of API for `get_with`, `optionally_get_with`, and\n  `try_get_with` of `sync` and `future` caches ([#190][gh-pull-0190], by\n  [@LMJW][gh-LMJW]):\n    - They are similar to the non-`by_ref` versions but take a reference of the key\n      instead of an owned key. If the key does not exist in the cache, the key will\n      be cloned to create new entry in the cache.\n\n### Changed\n\n- Change the CI to run Linux AArch64 tests on real hardware using Cirrus CI.\n  ([#180][gh-pull-0180], by [@ClSlaid][gh-ClSlaid])\n\n### Fixed\n\n- Fix a typo in the documentation. ([#189][gh-pull-0189], by [@Swatinem][gh-Swatinem])\n\n\n## Version 0.9.4\n\n### Fixed\n\n- Fix memory leak after dropping a `sync` or `future` cache ([#177][gh-pull-0177]):\n    - This leaked the value part of cache entries.\n\n### Added\n\n- Add an experimental `js` feature to make `unsync` and `sync` caches to compile for\n  `wasm32-unknown-unknown` target ([#173](gh-pull-0173), by [@aspect][gh-aspect]):\n    - Note that we have not tested if these caches work correctly in wasm32\n      environment.\n\n\n## Version 0.9.3\n\n### Added\n\n- Add an option to the cache builder of the following caches not to start and use the\n  global thread pools for housekeeping tasks ([#165][gh-pull-0165]):\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n\n### Fixed\n\n- Ensure that the following caches will drop the value of evicted entries immediately\n  after eviction ([#169][gh-pull-0169]):\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n\n\n## Version 0.9.2\n\n### Fixed\n\n- Fix segmentation faults in `sync` and `future` caches under heavy loads on\n  many-core machine ([#34][gh-issue-0034]):\n    - NOTE: Although this issue was found in our testing environment ten months ago\n      (v0.5.1), no user reported that they had the same issue.\n    - NOTE: In [v0.8.4](#version-084), we added a mitigation to reduce the chance of\n      the segfaults occurring.\n\n### Changed\n\n- Upgrade crossbeam-epoch from v0.8.2 to v0.9.9 ([#157][gh-pull-0157]):\n    - This will make GitHub Dependabot to stop alerting about a security advisory\n      [CVE-2022-23639][ghsa-qc84-gqf4-9926] for crossbeam-utils versions < 0.8.7.\n    - Moka v0.9.1 or older was _not_ vulnerable to the CVE:\n        - Although the older crossbeam-epoch v0.8.2 depends on an affected version of\n          crossbeam-utils, epoch v0.8.2 does not use the affected _functions_ of\n          utils. ([#162][gh-issue-0162])\n\n\n## Version 0.9.1\n\n### Fixed\n\n- Relax a too restrictive requirement `Arc<K>: Borrow<Q>` for the key `&Q` of the\n  `contains_key`, `get` and `invalidate` methods in the following caches (with `K` as\n  the key type) ([#167][gh-pull-0167]). The requirement is now `K: Borrow<Q>` so these\n  methods will accept `&[u8]` for the key `&Q` when the stored key `K` is `Vec<u8>`.\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n\n\n## Version 0.9.0\n\n### Added\n\n- Add support for eviction listener to the following caches ([#145][gh-pull-0145]).\n  Eviction listener is a callback function that will be called when an entry is\n  removed from the cache:\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n- Add a crate feature `sync` for enabling and disabling `sync` caches.\n  ([#141][gh-pull-0141] by [@Milo123459][gh-Milo123459], and [#143][gh-pull-0143])\n    - This feature is enabled by default.\n    - When using experimental `dash` cache, opting out of `sync` will reduce the\n      number of dependencies.\n- Add a crate feature `logging` to enable optional log crate dependency.\n  ([#159][gh-pull-0159])\n    - Currently log will be emitted only when an eviction listener has panicked.\n\n\n## Version 0.8.6\n\n### Fixed\n\n- Fix a bug caused `invalidate_all` and `invalidate_entries_if` of the following\n  caches will not invalidate entries inserted just before calling them\n  ([#155][gh-issue-0155]):\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n    - Experimental `dash::Cache`\n\n\n## Version 0.8.5\n\n### Added\n\n- Add basic stats (`entry_count` and `weighted_size`) methods to all caches.\n  ([#137][gh-pull-0137])\n- Add `Debug` impl to the following caches ([#138][gh-pull-0138]):\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n    - `unsync::Cache`\n\n### Fixed\n\n- Remove unnecessary `K: Clone` bound from the following caches when they are `Clone`\n  ([#133][gh-pull-0133]):\n    - `sync::Cache`\n    - `future::Cache`\n    - Experimental `dash::Cache`\n\n\n## Version 0.8.4\n\n### Fixed\n\n- Fix the following issue by upgrading Quanta crate to v0.10.0 ([#126][gh-pull-0126]):\n    - Quanta v0.9.3 or older may not work correctly on some x86_64 machines where\n      the Time Stamp Counter (TSC) is not synched across the processor cores.\n      ([#119][gh-issue-0119])\n    - For more details about the issue, see [the relevant section][panic_in_quanta]\n      of the README.\n\n### Added\n\n- Add `get_with_if` method to the following caches ([#123][gh-issue-0123]):\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n\n### Changed\n\nThe followings are internal changes to improve memory safety in unsafe Rust usages\nin Moka:\n\n- Remove pointer-to-integer transmute by converting `UnsafeWeakPointer` from `usize`\n  to `*mut T`. ([#127][gh-pull-0127], by [saethlin][gh-saethlin])\n- Increase the num segments of the waiters hash table from 16 to 64\n  ([#129][gh-pull-0129]) to reduce the chance of the following issue occurring:\n    - Segfaults under heavy workloads on a many-core machine. ([#34][gh-issue-0034])\n\n\n## Version 0.8.3\n\n### Changed\n\n- Make [Quanta crate][quanta-crate] optional (but enabled by default)\n  ([#121][gh-pull-0121])\n    - Quanta v0.9.3 or older may not work correctly on some x86_64 machines where\n      the Time Stamp Counter (TSC) is not synched across the processor cores.\n      ([#119][gh-issue-0119])\n    - This issue was fixed by Quanta v0.10.0. You can prevent the issue by upgrading\n      Moka to v0.8.4 or newer.\n    - For more details about the issue, see [the relevant section][panic_in_quanta]\n      of the README.\n\n\n## Version 0.8.2\n\n### Added\n\n- Add iterator to the following caches: ([#114][gh-pull-0114])\n    - `sync::Cache`\n    - `sync::SegmentedCache`\n    - `future::Cache`\n    - `unsync::Cache`\n- Implement `IntoIterator` to the all caches (including experimental `dash::Cache`)\n  ([#114][gh-pull-0114])\n\n### Fixed\n\n- Fix the `dash::Cache` iterator not to return expired entries.\n  ([#116][gh-pull-0116])\n- Prevent \"index out of bounds\" error when `sync::SegmentedCache` was created with\n  a non-power-of-two segments. ([#117][gh-pull-0117])\n\n\n## Version 0.8.1\n\n### Added\n\n- Add `contains_key` method to check if a key is present without resetting the idle\n  timer or updating the historic popularity estimator. ([#107][gh-issue-0107])\n\n\n## Version 0.8.0\n\nAs a part of stabilizing the cache API, the following cache methods have been renamed:\n\n- `get_or_insert_with(K, F)` → `get_with(K, F)`\n- `get_or_try_insert_with(K, F)` → `try_get_with(K, F)`\n\nOld methods are still available but marked as deprecated. They will be removed in a\nfuture version.\n\nAlso `policy` method was added to all caches and `blocking` method was added to\n`future::Cache`. They return a `Policy` struct or `BlockingOp` struct\nrespectively. Some uncommon cache methods were moved to these structs, and old\nmethods were removed without deprecating.\n\nPlease see [#105][gh-pull-0105] for the complete list of the affected methods.\n\n### Changed\n\n- API stabilization. (Smaller core cache API, shorter names for common methods)\n  ([#105][gh-pull-0105])\n- Performance related:\n    - Improve performance of `get_with` and `try_get_with`. ([#88][gh-pull-0088])\n    - Avoid to calculate the same hash twice in `get`, `get_with`, `insert`,\n      `invalidate`, etc. ([#90][gh-pull-0090])\n- Update the minimum versions of dependencies:\n    - crossbeam-channel to v0.5.4. ([#100][gh-pull-0100])\n    - scheduled-thread-pool to v0.2.5. ([#103][gh-pull-0103], by\n      [@Milo123459][gh-Milo123459])\n    - (dev-dependency) skeptic to v0.13.5. ([#104][gh-pull-0104])\n\n### Added\n\n#### Experimental Additions\n\n- Add a synchronous cache `moka::dash::Cache`, which uses `dashmap::DashMap` as the\n  internal storage. ([#99][gh-pull-0099])\n- Add iterator to `moka::dash::Cache`. ([#101][gh-pull-0101])\n\nPlease note that the above additions are highly experimental and their APIs will\nbe frequently changed in next few releases.\n\n\n## Version 0.7.2\n\nThe minimum supported Rust version (MSRV) is now 1.51.0 (Mar 25, 2021).\n\n### Fixed\n\n- Addressed a memory utilization issue that will get worse when keys have hight\n  cardinality ([#72][gh-issue-0072]):\n    - Reduce memory overhead in the internal concurrent hash table (cht).\n      ([#79][gh-pull-0079])\n    - Fix a bug that can create oversized frequency sketch when weigher is set.\n      ([#75][gh-pull-0075])\n    - Change `EntryInfo` from `enum` to `struct` to reduce memory utilization.\n      ([#76][gh-pull-0076])\n    - Replace some `std::sync::Arc` usages with `triomphe::Arc` to reduce memory\n      utilization. ([#80][gh-pull-0080])\n    - Embed `CacheRegion` value into a 2-bit tag space of `TagNonNull` pointer.\n      ([#84][gh-pull-0084])\n- Fix a bug that will use wrong (oversized) initial capacity for the internal cht.\n  ([#83][gh-pull-0083])\n\n### Added\n\n- Add `unstable-debug-counters` feature for testing purpose. ([#82][gh-pull-0082])\n\n### Changed\n\n- Import (include) cht source files for better integration. ([#77][gh-pull-0077],\n  [#86](gh-pull-0086))\n- Improve the CI coverage for Clippy lints and fix some Clippy warnings in unit\n  tests. ([#73][gh-pull-0073], by [@06chaynes][gh-06chaynes])\n\n\n## Version 0.7.1\n\n- **Important Fix**: A memory leak issue (#65 below) was found in all previous\n  versions (since v0.1.0) and fixed in this version. All users are encouraged to\n  upgrade to this or newer version.\n\n### Fixed\n\n- Fix a memory leak that will happen when evicting/expiring an entry or manually\n  invalidating an entry. ([#65][gh-pull-0065])\n\n### Changed\n\n- Update the minimum depending version of crossbeam-channel from v0.5.0 to v0.5.2.\n  ([#67][gh-pull-0067])\n\n\n## Version 0.7.0\n\n- **Breaking change**: The type of the `max_capacity` has been changed from `usize`\n  to `u64`. This was necessary to have the weight-based cache management consistent\n  across different CPU architectures.\n\n### Added\n\n- Add support for weight-based (size aware) cache management.\n  ([#24][gh-pull-0024])\n- Add support for unbound cache. ([#24][gh-pull-0024])\n\n\n## Version 0.6.3\n\n### Fixed\n\n- Fix a bug in `get_or_insert_with` and `get_or_try_insert_with` methods of\n  `future::Cache`, which caused a panic if previously inserting task aborted.\n  ([#59][gh-issue-0059])\n\n\n## Version 0.6.2\n\n### Removed\n\n- Remove `Send` and `'static` bounds from `get_or_insert_with` and\n  `get_or_try_insert_with` methods of `future::Cache`. ([#53][gh-pull-0053], by\n  [@tinou98][gh-tinou98])\n\n### Fixed\n\n- Protect overflow when computing expiration. ([#56][gh-pull-0056], by\n  [@barkanido][gh-barkanido])\n\n\n## Version 0.6.1\n\n### Changed\n\n- Replace futures crate with futures-util. ([#47][gh-pull-0047], by\n  [@messense][gh-messense]))\n\n\n## Version 0.6.0\n\n### Fixed\n\n- Fix a bug in `get_or_insert_with` and `get_or_try_insert_with` methods of\n  `future::Cache` and `sync::Cache`; a panic in the `init` future/closure\n  causes subsequent calls on the same key to get \"unreachable code\" panics.\n  ([#43][gh-issue-0043])\n\n### Changed\n\n- Change `get_or_try_insert_with` to return a concrete error type rather\n  than a trait object. ([#23][gh-pull-0023], [#37][gh-pull-0037])\n\n\n## Version 0.5.4\n\n### Changed\n\n-  Restore quanta dependency on some 32-bit platforms such as\n   `armv5te-unknown-linux-musleabi` or `mips-unknown-linux-musl`.\n   ([#42][gh-pull-0042], by [@messense][gh-messense])\n\n\n## Version 0.5.3\n\n### Added\n\n- Add support for some 32-bit platforms where `std::sync::atomic::AtomicU64` is not\n  provided. (e.g. `armv5te-unknown-linux-musleabi` or `mips-unknown-linux-musl`)\n  ([#38][gh-issue-0038])\n    - On these platforms, you will need to disable the default features of Moka.\n      See [the relevant section][resolving-error-on-32bit] of the README.\n\n\n## Version 0.5.2\n\n### Fixed\n\n- Fix a bug in `get_or_insert_with` and `get_or_try_insert_with` methods of\n  `future::Cache` by adding missing bounds `Send` and `'static` to the `init`\n  future. Without this fix, these methods will accept non-`Send` or\n  non-`'static` future and may cause undefined behavior.\n  ([#31][gh-issue-0031])\n- Fix `usize` overflow on big cache capacity. ([#28][gh-pull-0028])\n\n### Added\n\n- Add examples for `get_or_insert_with` and `get_or_try_insert_with`\n  methods to the docs. ([#30][gh-pull-0030])\n\n### Changed\n\n- Downgrade crossbeam-epoch used in moka-cht from v0.9.x to v0.8.x as a possible\n  workaround for segmentation faults on many-core CPU machines.\n  ([#33][gh-pull-0033])\n\n\n## Version 0.5.1\n\n### Changed\n\n- Replace a dependency cht v0.4 with moka-cht v0.5. ([#22][gh-pull-0022])\n\n\n## Version 0.5.0\n\n### Added\n\n- Add `get_or_insert_with` and `get_or_try_insert_with` methods to `sync` and\n  `future` caches. ([#20][gh-pull-0020])\n\n\n## Version 0.4.0\n\n### Fixed\n\n- **Breaking change**: Now `sync::{Cache, SegmentedCache}` and `future::Cache`\n  require `Send`, `Sync` and `'static` for the generic parameters `K` (key),\n  `V` (value) and `S` (hasher state). This is necessary to prevent potential\n  undefined behaviors in applications using single-threaded async runtime such as\n  Actix-rt. ([#19][gh-pull-0019])\n\n### Added\n\n- Add `invalidate_entries_if` method to `sync`, `future` and `unsync` caches.\n  ([#12][gh-pull-0012])\n\n\n## Version 0.3.1\n\n### Changed\n\n- Stop skeptic from having to be compiled by all downstream users.\n  ([#16][gh-pull-0016], by [@paolobarbolini][gh-paolobarbolini])\n\n\n## Version 0.3.0\n\n### Added\n\n- Add an unsync cache (`moka::unsync::Cache`) and its builder for single-thread\n  applications. ([#9][gh-pull-0009])\n- Add `invalidate_all` method to `sync`, `future` and `unsync` caches.\n  ([#11][gh-pull-0011])\n\n### Fixed\n\n- Fix problems including segfault caused by race conditions between the sync/eviction\n  thread and client writes. (Addressed as a part of [#11][gh-pull-0011]).\n\n\n## Version 0.2.0\n\n### Added\n\n- Add an asynchronous, futures aware cache (`moka::future::Cache`) and its builder.\n  ([#7][gh-pull-0007])\n\n\n## Version 0.1.0\n\n### Added\n\n- Add thread-safe, highly concurrent in-memory cache implementations\n  (`moka::sync::{Cache, SegmentedCache}`) with the following features:\n    - Bounded by the maximum number of elements.\n    - Maintains good hit rate by using entry replacement algorithms inspired by\n      [Caffeine][caffeine-git]:\n        - Admission to a cache is controlled by the Least Frequently Used (LFU) policy.\n        - Eviction from a cache is controlled by the Least Recently Used (LRU) policy.\n    - Expiration policies:\n        - Time to live\n        - Time to idle\n\n\n<!-- Links -->\n\n[caffeine-git]: https://github.com/ben-manes/caffeine\n[mini-moka-crate]: https://crates.io/crates/mini-moka\n[quanta-crate]: https://crates.io/crates/quanta\n\n[panic_in_quanta]: https://github.com/moka-rs/moka#integer-overflow-in-quanta-crate-on-some-x86_64-machines\n[resolving-error-on-32bit]: https://github.com/moka-rs/moka#compile-errors-on-some-32-bit-platforms\n\n[ghsa-qc84-gqf4-9926]: https://github.com/advisories/GHSA-qc84-gqf4-9926\n[gh-rust-issue-62958]: https://github.com/rust-lang/rust/issues/62958\n\n[RUSTSEC-2020-0168]: https://rustsec.org/advisories/RUSTSEC-2020-0168.html\n\n[gh-06chaynes]: https://github.com/06chaynes\n[gh-arcstur]: https://github.com/arcstur\n[gh-aspect]: https://github.com/aspect\n[gh-barkanido]: https://github.com/barkanido\n[gh-ClSlaid]: https://github.com/ClSlaid\n[gh-eaufavor]: https://github.com/eaufavor\n[gh-JoJoDeveloping]: https://github.com/JoJoDeveloping\n[gh-LMJW]: https://github.com/LMJW\n[gh-messense]: https://github.com/messense\n[gh-Milo123459]: https://github.com/Milo123459\n[gh-nyurik]: https://github.com/nyurik\n[gh-paolobarbolini]: https://github.com/paolobarbolini\n[gh-peter-scholtens]: https://github.com/peter-scholtens\n[gh-saethlin]: https://github.com/saethlin\n[gh-Swatinem]: https://github.com/Swatinem\n[gh-tinou98]: https://github.com/tinou98\n[gh-xuehaonan27]: https://github.com/xuehaonan27\n[gh-zonyitoo]: https://github.com/zonyitoo\n\n[gh-issue-0472]: https://github.com/moka-rs/moka/issues/472/\n[gh-issue-0464]: https://github.com/moka-rs/moka/issues/464/\n[gh-issue-0412]: https://github.com/moka-rs/moka/issues/412/\n[gh-issue-0385]: https://github.com/moka-rs/moka/issues/385/\n[gh-issue-0329]: https://github.com/moka-rs/moka/issues/329/\n[gh-issue-0322]: https://github.com/moka-rs/moka/issues/322/\n[gh-issue-0255]: https://github.com/moka-rs/moka/issues/255/\n[gh-issue-0252]: https://github.com/moka-rs/moka/issues/252/\n[gh-issue-0243]: https://github.com/moka-rs/moka/issues/243/\n[gh-issue-0242]: https://github.com/moka-rs/moka/issues/242/\n[gh-issue-0230]: https://github.com/moka-rs/moka/issues/230/\n[gh-issue-0212]: https://github.com/moka-rs/moka/issues/212/\n[gh-issue-0207]: https://github.com/moka-rs/moka/issues/207/\n[gh-issue-0162]: https://github.com/moka-rs/moka/issues/162/\n[gh-issue-0155]: https://github.com/moka-rs/moka/issues/155/\n[gh-issue-0123]: https://github.com/moka-rs/moka/issues/123/\n[gh-issue-0119]: https://github.com/moka-rs/moka/issues/119/\n[gh-issue-0107]: https://github.com/moka-rs/moka/issues/107/\n[gh-issue-0072]: https://github.com/moka-rs/moka/issues/72/\n[gh-issue-0059]: https://github.com/moka-rs/moka/issues/59/\n[gh-issue-0043]: https://github.com/moka-rs/moka/issues/43/\n[gh-issue-0038]: https://github.com/moka-rs/moka/issues/38/\n[gh-issue-0034]: https://github.com/moka-rs/moka/issues/34/\n[gh-issue-0031]: https://github.com/moka-rs/moka/issues/31/\n\n[gh-pull-0482]: https://github.com/moka-rs/moka/pull/482/\n[gh-pull-0481]: https://github.com/moka-rs/moka/pull/481/\n[gh-pull-0480]: https://github.com/moka-rs/moka/pull/480/\n[gh-pull-0474]: https://github.com/moka-rs/moka/pull/474/\n[gh-pull-0466]: https://github.com/moka-rs/moka/pull/466/\n[gh-pull-0460]: https://github.com/moka-rs/moka/pull/460/\n[gh-pull-0456]: https://github.com/moka-rs/moka/pull/456/\n[gh-pull-0452]: https://github.com/moka-rs/moka/pull/452/\n[gh-pull-0445]: https://github.com/moka-rs/moka/pull/445/\n[gh-pull-0444]: https://github.com/moka-rs/moka/pull/444/\n[gh-pull-0426]: https://github.com/moka-rs/moka/pull/426/\n[gh-pull-0421]: https://github.com/moka-rs/moka/pull/421/\n[gh-pull-0417]: https://github.com/moka-rs/moka/pull/417/\n[gh-pull-0390]: https://github.com/moka-rs/moka/pull/390/\n[gh-pull-0384]: https://github.com/moka-rs/moka/pull/384/\n[gh-pull-0382]: https://github.com/moka-rs/moka/pull/382/\n[gh-pull-0376]: https://github.com/moka-rs/moka/pull/376/\n[gh-pull-0370]: https://github.com/moka-rs/moka/pull/370/\n[gh-pull-0363]: https://github.com/moka-rs/moka/pull/363/\n[gh-pull-0350]: https://github.com/moka-rs/moka/pull/350/\n[gh-pull-0348]: https://github.com/moka-rs/moka/pull/348/\n[gh-pull-0340]: https://github.com/moka-rs/moka/pull/340/\n[gh-pull-0339]: https://github.com/moka-rs/moka/pull/339/\n[gh-pull-0331]: https://github.com/moka-rs/moka/pull/331/\n[gh-pull-0316]: https://github.com/moka-rs/moka/pull/316/\n[gh-pull-0309]: https://github.com/moka-rs/moka/pull/309/\n[gh-pull-0295]: https://github.com/moka-rs/moka/pull/295/\n[gh-pull-0294]: https://github.com/moka-rs/moka/pull/294/\n[gh-pull-0277]: https://github.com/moka-rs/moka/pull/277/\n[gh-pull-0275]: https://github.com/moka-rs/moka/pull/275/\n[gh-pull-0272]: https://github.com/moka-rs/moka/pull/272/\n[gh-pull-0268]: https://github.com/moka-rs/moka/pull/268/\n[gh-pull-0265]: https://github.com/moka-rs/moka/pull/265/\n[gh-pull-0259]: https://github.com/moka-rs/moka/pull/259/\n[gh-pull-0251]: https://github.com/moka-rs/moka/pull/251/\n[gh-pull-0248]: https://github.com/moka-rs/moka/pull/248/\n[gh-pull-0216]: https://github.com/moka-rs/moka/pull/216/\n[gh-pull-0199]: https://github.com/moka-rs/moka/pull/199/\n[gh-pull-0195]: https://github.com/moka-rs/moka/pull/195/\n[gh-pull-0193]: https://github.com/moka-rs/moka/pull/193/\n[gh-pull-0190]: https://github.com/moka-rs/moka/pull/190/\n[gh-pull-0189]: https://github.com/moka-rs/moka/pull/189/\n[gh-pull-0187]: https://github.com/moka-rs/moka/pull/187/\n[gh-pull-0180]: https://github.com/moka-rs/moka/pull/180/\n[gh-pull-0177]: https://github.com/moka-rs/moka/pull/177/\n[gh-pull-0173]: https://github.com/moka-rs/moka/pull/173/\n[gh-pull-0169]: https://github.com/moka-rs/moka/pull/169/\n[gh-pull-0167]: https://github.com/moka-rs/moka/pull/167/\n[gh-pull-0165]: https://github.com/moka-rs/moka/pull/165/\n[gh-pull-0159]: https://github.com/moka-rs/moka/pull/159/\n[gh-pull-0157]: https://github.com/moka-rs/moka/pull/157/\n[gh-pull-0145]: https://github.com/moka-rs/moka/pull/145/\n[gh-pull-0143]: https://github.com/moka-rs/moka/pull/143/\n[gh-pull-0141]: https://github.com/moka-rs/moka/pull/141/\n[gh-pull-0138]: https://github.com/moka-rs/moka/pull/138/\n[gh-pull-0137]: https://github.com/moka-rs/moka/pull/137/\n[gh-pull-0133]: https://github.com/moka-rs/moka/pull/133/\n[gh-pull-0129]: https://github.com/moka-rs/moka/pull/129/\n[gh-pull-0127]: https://github.com/moka-rs/moka/pull/127/\n[gh-pull-0126]: https://github.com/moka-rs/moka/pull/126/\n[gh-pull-0121]: https://github.com/moka-rs/moka/pull/121/\n[gh-pull-0117]: https://github.com/moka-rs/moka/pull/117/\n[gh-pull-0116]: https://github.com/moka-rs/moka/pull/116/\n[gh-pull-0114]: https://github.com/moka-rs/moka/pull/114/\n[gh-pull-0105]: https://github.com/moka-rs/moka/pull/105/\n[gh-pull-0104]: https://github.com/moka-rs/moka/pull/104/\n[gh-pull-0103]: https://github.com/moka-rs/moka/pull/103/\n[gh-pull-0101]: https://github.com/moka-rs/moka/pull/101/\n[gh-pull-0100]: https://github.com/moka-rs/moka/pull/100/\n[gh-pull-0099]: https://github.com/moka-rs/moka/pull/99/\n[gh-pull-0090]: https://github.com/moka-rs/moka/pull/90/\n[gh-pull-0088]: https://github.com/moka-rs/moka/pull/88/\n[gh-pull-0086]: https://github.com/moka-rs/moka/pull/86/\n[gh-pull-0084]: https://github.com/moka-rs/moka/pull/84/\n[gh-pull-0083]: https://github.com/moka-rs/moka/pull/83/\n[gh-pull-0082]: https://github.com/moka-rs/moka/pull/82/\n[gh-pull-0080]: https://github.com/moka-rs/moka/pull/80/\n[gh-pull-0079]: https://github.com/moka-rs/moka/pull/79/\n[gh-pull-0077]: https://github.com/moka-rs/moka/pull/77/\n[gh-pull-0076]: https://github.com/moka-rs/moka/pull/76/\n[gh-pull-0075]: https://github.com/moka-rs/moka/pull/75/\n[gh-pull-0073]: https://github.com/moka-rs/moka/pull/73/\n[gh-pull-0067]: https://github.com/moka-rs/moka/pull/67/\n[gh-pull-0065]: https://github.com/moka-rs/moka/pull/65/\n[gh-pull-0056]: https://github.com/moka-rs/moka/pull/56/\n[gh-pull-0053]: https://github.com/moka-rs/moka/pull/53/\n[gh-pull-0047]: https://github.com/moka-rs/moka/pull/47/\n[gh-pull-0042]: https://github.com/moka-rs/moka/pull/42/\n[gh-pull-0037]: https://github.com/moka-rs/moka/pull/37/\n[gh-pull-0033]: https://github.com/moka-rs/moka/pull/33/\n[gh-pull-0030]: https://github.com/moka-rs/moka/pull/30/\n[gh-pull-0028]: https://github.com/moka-rs/moka/pull/28/\n[gh-pull-0024]: https://github.com/moka-rs/moka/pull/24/\n[gh-pull-0023]: https://github.com/moka-rs/moka/pull/23/\n[gh-pull-0022]: https://github.com/moka-rs/moka/pull/22/\n[gh-pull-0020]: https://github.com/moka-rs/moka/pull/20/\n[gh-pull-0019]: https://github.com/moka-rs/moka/pull/19/\n[gh-pull-0016]: https://github.com/moka-rs/moka/pull/16/\n[gh-pull-0012]: https://github.com/moka-rs/moka/pull/12/\n[gh-pull-0011]: https://github.com/moka-rs/moka/pull/11/\n[gh-pull-0009]: https://github.com/moka-rs/moka/pull/9/\n[gh-pull-0007]: https://github.com/moka-rs/moka/pull/7/\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 4.6474609375,
          "content": "[package]\nname = \"moka\"\nversion = \"0.12.10\"\nedition = \"2021\"\n# Rust 1.70 was released on June 1, 2023.\nrust-version = \"1.70\"\ndescription = \"A fast and concurrent cache library inspired by Java Caffeine\"\nlicense = \"MIT OR Apache-2.0\"\n# homepage = \"https://\"\ndocumentation = \"https://docs.rs/moka/\"\nrepository = \"https://github.com/moka-rs/moka\"\nkeywords = [\"cache\", \"concurrent\"]\ncategories = [\"caching\", \"concurrency\"]\nreadme = \"README.md\"\nexclude = [\".devcontainer\", \".github\", \".gitpod.yml\", \".vscode\"]\nbuild = \"build.rs\"\n\n[features]\ndefault = []\n\n# Enable this feature to use `moka::sync::{Cache, SegmentedCache}`\nsync = []\n\n# Enable this feature to use `moka::future::Cache`.\nfuture = [\"async-lock\", \"event-listener\", \"futures-util\"]\n\n# Enable this feature to activate optional logging from caches.\n# Currently cache will emit log only when it encounters a panic in user provided\n# callback closure.\nlogging = [\"log\"]\n\n# Enable this feature to use `quanta::Instant` for some performance critical\n# operations in the cache instead of `std::time::Instant`. As of v0.12.10, this\n# feature will not make any noticeable performance difference, but in the future\n# when cache metrics are added, it will be useful to have this feature enabled.\nquanta = [\"dep:quanta\"]\n\n# This is an old feature and has no effect in v0.12.10 or newer. It is kept for\n# backward compatibility and will be removed in v0.13.0.\natomic64 = []\n\n# This unstable feature adds `GlobalDebugCounters::current` function, which returns\n# counters of internal object construction and destruction. It will have some\n# performance impacts and is intended for debugging.\nunstable-debug-counters = [\"future\", \"once_cell\"]\n\n[dependencies]\ncrossbeam-channel = \"0.5.5\"\ncrossbeam-epoch = \"0.9.9\"\ncrossbeam-utils = \"0.8\"\nparking_lot = \"0.12\"\nportable-atomic = \"1.6\"\nsmallvec = \"1.8\"\ntagptr = \"0.2\"\nthiserror = \"1.0\"\nuuid = { version = \"1.1\", features = [\"v4\"] }\n\n# Optional dependencies (enabled by default)\nquanta = { version = \"0.12.2\", optional = true }\n\n# Optional dependencies (future)\nasync-lock = { version = \"3.3\", optional = true }\nevent-listener = { version = \"5.3\", optional = true }\nfutures-util = { version = \"0.3.17\", optional = true }\n\n# Optional dependencies (logging)\nlog = { version = \"0.4\", optional = true }\n\n# Optional dependencies (unstable-debug-counters)\nonce_cell = { version = \"1.7\", optional = true }\n\n[dev-dependencies]\nactix-rt = \"2.8\"\nahash = \"0.8.3\"\nanyhow = \"1.0.19\"\nasync-std = { version = \"1.12\", features = [\"attributes\"] }\nenv_logger = \"0.10.0\"\ngetrandom = \"0.2\"\nonce_cell = \"1.7\"\npaste = \"1.0.9\"\nrand = \"0.8.5\"\nreqwest = { version = \"0.11.11\", default-features = false, features = [\"rustls-tls\"] }\ntokio = { version = \"1.19\", features = [\"fs\", \"io-util\", \"macros\", \"rt-multi-thread\", \"sync\", \"time\" ] }\n\n# We cannot use `cfg(loom)` here because an indirect dependency `concurrent-queue`\n# uses it.\n[target.'cfg(moka_loom)'.dependencies]\nloom = \"0.7\"\n\n[target.'cfg(trybuild)'.dev-dependencies]\ntrybuild = \"1.0\"\n\n[target.'cfg(rustver)'.build-dependencies]\nrustc_version = \"0.4.0\"\n\n[lints.rust]\nunexpected_cfgs = { level = \"warn\", check-cfg = [\n    \"cfg(armv5te)\",\n    \"cfg(beta_clippy)\",\n    \"cfg(kani)\",\n    \"cfg(moka_loom)\",\n    \"cfg(mips)\",\n    \"cfg(rustver)\",\n    \"cfg(skip_large_mem_tests)\",\n    \"cfg(trybuild)\",\n] }\n\n# https://docs.rs/about/metadata\n[package.metadata.docs.rs]\n# Build the doc at docs.rs with some features enabled.\n#\n# You can test locally with:\n# ```\n# cargo +nightly -Z unstable-options --config 'build.rustdocflags=\"--cfg docsrs\"' \\\n#    doc --no-deps --features 'future, sync'\n# ```\nfeatures = [\"future\", \"sync\"]\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n\n# Examples\n\n[[example]]\nname = \"append_value_async\"\nrequired-features = [\"future\"]\n\n[[example]]\nname = \"append_value_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"basics_async\"\nrequired-features = [\"future\"]\n\n[[example]]\nname = \"basics_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"bounded_counter_async\"\nrequired-features = [\"future\"]\n\n[[example]]\nname = \"bounded_counter_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"cascading_drop_async\"\nrequired-features = [\"future\"]\n\n[[example]]\nname = \"counter_async\"\nrequired-features = [\"future\"]\n\n[[example]]\nname = \"counter_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"eviction_listener_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"jittered_expiry_policy_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"reinsert_expired_entries_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"size_aware_eviction_sync\"\nrequired-features = [\"sync\"]\n\n[[example]]\nname = \"try_append_value_async\"\nrequired-features = [\"future\"]\n\n[[example]]\nname = \"try_append_value_sync\"\nrequired-features = [\"sync\"]\n"
        },
        {
          "name": "LICENSE-APACHE",
          "type": "blob",
          "size": 11.0849609375,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2020 - 2025 Tatsuya Kawano\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.052734375,
          "content": "MIT License\n\nCopyright (c) 2020 - 2025 Tatsuya Kawano\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MIGRATION-GUIDE.md",
          "type": "blob",
          "size": 11.1513671875,
          "content": "# Moka Cache &mdash; Migration Guide\n\n## Migrating to v0.12 from a prior version\n\nv0.12.0 had major breaking changes on the API and internal behavior. This section\ndescribes the code changes required to migrate to v0.12.0.\n\n### Highlights v0.12\n\n- **`sync` caches are no longer enabled by default**: Please use a crate feature\n  `sync` to enable it.\n\n- **No more background threads**: All cache types `future::Cache`, `sync::Cache`, and\n  `sync::SegmentedCache` no longer spawn background threads.\n  - The `scheduled-thread-pool` crate was removed from the dependency.\n  - Because of this change, many private methods and some public methods under the\n    `future` module were converted to `async` methods. You will need to add `.await`\n    to your code for those methods.\n\n- **Immediate notification delivery**: The `notification::DeliveryMode` enum for the\n  eviction listener was removed. Now all cache types behave as if the `Immediate`\n  delivery mode is specified.\n\n  - `DeliveryMode` enum had two variants `Immediate` and `Queued`.\n      - The former should be easier to use than other as it guarantees to preserve\n        the order of events on a given cache key.\n      - The latter did not use internal locks and would provide higher performance\n        under heavy cache writes.\n  - Now all cache types work as if the `Immediate` mode is specified.\n      - **`future::Cache`**: In earlier versions of `future::Cache`, the queued mode\n        was used. Now it behaves as if the immediate mode is specified.\n      - **`sync` caches**: From earlier versions of `sync::Cache` and\n        `sync::SegmentedCache`, the immediate mode is the default mode. So this\n        change should only affects those of you who are explicitly using the queued\n        mode.\n  - The queued mode was implemented by using a background thread. The queued mode was\n    removed because there is no thread pool available anymore.\n  - If you need the queued mode back, please file a GitHub issue. We could provide\n    a way to use a user supplied thread pool.\n\nThe following sections will describe about the changes you might need to make to your\ncode.\n\n- [`sync::Cache` and `sync::SegmentedCache`](#synccache-and-syncsegmentedcache-v012)\n- [`future::Cache`](#futurecache-v012)\n- [The maintenance tasks](#the-maintenance-tasks)\n\n### `sync::Cache` and `sync::SegmentedCache` v0.12\n\n1. Please use a crate feature `sync` to enable `sync` caches.\n2. Since the background threads were removed, the maintenance tasks such as removing\n   expired entries are not executed periodically anymore.\n   - The `thread_pool_enabled` method of the `sync::CacheBuilder` was removed. The\n     thread pool is always disabled.\n   - See the [maintenance tasks](#the-maintenance-tasks) section for more details.\n3. The `sync` method of the `sync::ConcurrentCacheExt` trait was moved to\n   `sync::Cache` and `sync::SegmentedCache` types. It is also renamed to\n   `run_pending_tasks`.\n4. Now `sync` caches always work as if the immediate delivery mode is specified\n   for the eviction listener.\n   - In older versions, the immediate mode was the default mode, and the queued\n     mode could be optionally selected.\n\n### `future::Cache` v0.12\n\n#### API changes\n\n1. The `get` method is now `async fn`, so you must `await` for the result.\n2. The `blocking` method was removed.\n   - Please use async runtime's blocking API instead.\n   - See the [replacing the blocking API](#replacing-the-blocking-api) section for\n     more details.\n3. Now the `or_insert_with_if` method of the entry API requires `Send` bound for the\n   `replace_if` closure.\n4. The `eviction_listener_with_queued_delivery_mode` method of `future::CacheBuilder`\n   was removed.\n   - Please use one of the new methods instead:\n     - `eviction_listener`\n     - `async_eviction_listener`\n   - See the [updating the eviction listener](#updating-the-eviction-listener)\n     section for more details.\n5. The `sync` method of the `future::ConcurrentCacheExt` trait was moved to\n   `future::Cache` type and renamed to `run_pending_tasks`. It was also changed to\n   `async fn`.\n\n#### Behavior changes\n\n1. Since the background threads were removed, the maintenance tasks such as removing\n   expired entries are not executed periodically anymore.\n   - See the [maintenance tasks](#the-maintenance-tasks) section for more details.\n2. Now `future::Cache` always behaves as if the immediate delivery mode is specified\n   for the eviction listener.\n   - In older versions, the queued delivery mode was used.\n\n#### Replacing the blocking API\n\nThe `blocking` method of `future::Cache` was removed. Please use async runtime's\nblocking API instead.\n\n**Tokio**\n\n1. Call the `tokio::runtime::Handle::current()` method in async context to obtain a\n   handle to the current Tokio runtime.\n2. From outside async context, call cache's async function using `block_on` method of\n   the runtime.\n\n```rust\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() {\n    // Create a future cache.\n    let cache = Arc::new(moka::future::Cache::new(100));\n\n    // In async context, you can obtain a handle to the current Tokio runtime.\n    let rt = tokio::runtime::Handle::current();\n\n    // Spawn an OS thread. Pass the handle and cache.\n    let thread = {\n        let cache = Arc::clone(&cache);\n\n        std::thread::spawn(move || {\n            // Call async function using block_on method of Tokio runtime.\n            rt.block_on(cache.insert(0, 'a'));\n        })\n    };\n\n    // Wait for the threads to complete.\n    thread.join().unwrap();\n\n    // Check the result.\n    assert_eq!(cache.get(&0).await, Some('a'));\n}\n```\n\n**async-std**\n\n- From outside async context, call cache's async function using the\n  `async_std::task::block_on` method.\n\n```rust\nuse std::sync::Arc;\n\n#[async_std::main]\nasync fn main() {\n    // Create a future cache.\n    let cache = Arc::new(moka::future::Cache::new(100));\n\n    // Spawn an OS thread. Pass the cache.\n    let thread = {\n        let cache = Arc::clone(&cache);\n\n        std::thread::spawn(move || {\n            use async_std::task::block_on;\n\n            // Call async function using block_on method of async_std.\n            block_on(cache.insert(0, 'a'));\n        })\n    };\n\n    // Wait for the threads to complete.\n    thread.join().unwrap();\n\n    // Check the result.\n    assert_eq!(cache.get(&0).await, Some('a'));\n}\n```\n\n#### Updating the eviction listener\n\nThe `eviction_listener_with_queued_delivery_mode` method of `future::CacheBuilder`\nwas removed. Please use one of the new methods `eviction_listener` or\n`async_eviction_listener` instead.\n\n##### `eviction_listener` method\n\nThe `eviction_listener` method takes the same closure as the old method. If you do\nnot need to `.await` anything in the eviction listener, use this method.\n\nThis code snippet is borrowed from [an example][listener-ex1] in the document of\n`future::Cache`:\n\n```rust\nlet eviction_listener = |key, _value, cause| {\n    println!(\"Evicted key {key}. Cause: {cause:?}\");\n};\n\nlet cache = Cache::builder()\n    .max_capacity(100)\n    .expire_after(expiry)\n    .eviction_listener(eviction_listener)\n    .build();\n```\n\n[listener-ex1]: https://docs.rs/moka/latest/moka/future/struct.Cache.html#per-entry-expiration-policy\n\n##### `async_eviction_listener` method\n\nThe `async_eviction_listener` takes a closure that returns a `Future`. If you need to\n`await` something in the eviction listener, use this method. The actual return type\nof the closure is `notification::ListenerFuture`, which is a type alias of\n`Pin<Box<dyn Future<Output = ()> + Send>>`. You can use the `boxed` method of\n`future::FutureExt` trait to convert a regular `Future` into this type.\n\nThis code snippet is borrowed from [an example][listener-ex2] in the document of\n`future::Cache`:\n\n```rust\nuse moka::notification::ListenerFuture;\n// FutureExt trait provides the boxed method.\nuse moka::future::FutureExt;\n\nlet eviction_listener = move |k, v: PathBuf, cause| -> ListenerFuture {\n    println!(\"\\n== An entry has been evicted. k: {k:?}, v: {v:?}, cause: {cause:?}\");\n    let file_mgr2 = Arc::clone(&file_mgr1);\n\n    // Create a Future that removes the data file at the path `v`.\n    async move {\n        // Acquire the write lock of the DataFileManager.\n        let mut mgr = file_mgr2.write().await;\n        // Remove the data file. We must handle error cases here to\n        // prevent the listener from panicking.\n        if let Err(_e) = mgr.remove_data_file(v.as_path()).await {\n            eprintln!(\"Failed to remove a data file at {v:?}\");\n        }\n    }\n    // Convert the regular Future into ListenerFuture. This method is\n    // provided by moka::future::FutureExt trait.\n    .boxed()\n};\n\n// Create the cache. Set time to live for two seconds and set the\n// eviction listener.\nlet cache = Cache::builder()\n    .max_capacity(100)\n    .time_to_live(Duration::from_secs(2))\n    .async_eviction_listener(eviction_listener)\n    .build();\n```\n\n[listener-ex2]: https://docs.rs/moka/latest/moka/future/struct.Cache.html#example-eviction-listener\n\n### The maintenance tasks\n\nIn older versions, the maintenance tasks needed by the cache were periodically\nexecuted in background by a global thread pool managed by `moka`. Now all cache types\ndo not use the thread pool anymore, so those maintenance tasks are executed\n_sometimes_ in foreground when certain cache methods (`get`, `get_with`, `insert`,\netc.) are called by user code.\n\n![The lifecycle of cached entries](https://github.com/moka-rs/moka/wiki/images/benchmarks/moka-tiny-lfu.png)\n\nFigure 1. The lifecycle of cached entries\n\nThese maintenance tasks include:\n\n1. Determine whether to admit a \"temporary admitted\" entry or not.\n2. Apply the recording of cache reads and writes to the internal data structures for\n   the cache policies, such as the LFU filter, LRU queues, and hierarchical timer\n   wheels.\n3. When cache's max capacity is exceeded, remove least recently used (LRU) entries.\n4. Remove expired entries.\n5. Find and remove the entries that have been invalidated by the `invalidate_all` or\n   `invalidate_entries_if` methods.\n6. Deliver removal notifications to the eviction listener. (Call the eviction\n   listener closure with the information about the evicted entry)\n\nThey will be executed in the following cache methods when one of the following\nconditions is met:\n\nCache Methods:\n\n- All cache write methods: `insert`, `get_with`, `invalidate`, etc., except for\n  `invalidate_all` and `invalidate_entries_if`.\n- Some of the cache read methods: `get`\n- `run_pending_tasks` method, which executes the pending maintenance tasks\n  explicitly.\n\nConditions:\n\n- When one of the numbers of pending read and write recordings exceeds the threshold.\n    - The threshold is currently hard-coded to 64 items.\n- When the time since the last execution of the maintenance tasks exceeds the\n  threshold.\n    - The threshold is currently hard-coded to 300 milliseconds.\n\n#### `run_pending_tasks` method\n\nYou can execute the pending maintenance tasks explicitly by calling the\n`run_pending_tasks` method. This method is available for all cache types.\n\nNote that cache read methods such as the `get`, `get_with` and `contains_key` never\nreturn expired entries although they are not removed immediately from the cache when\nthey expire. You will not need to call `run_pending_tasks` method to remove expired\nentries unless you want to remove them immediately (e.g. to free some resources).\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.1728515625,
          "content": "# Moka\n\n[![GitHub Actions][gh-actions-badge]][gh-actions]\n[![crates.io release][release-badge]][crate]\n[![docs][docs-badge]][docs]\n[![dependency status][deps-rs-badge]][deps-rs]\n[![codecov][codecov-badge]][codecov]\n[![license][license-badge]](#license)\n\n> **note**\n> `v0.12.0` had major breaking changes on the API and internal behavior. Please read\n> the [MIGRATION-GUIDE.md][migration-guide-v012] for the details.\n\n* * *\n\nMoka is a fast, concurrent cache library for Rust. Moka is inspired by the\n[Caffeine][caffeine-git] library for Java.\n\nMoka provides cache implementations on top of hash maps. They support full\nconcurrency of retrievals and a high expected concurrency for updates.\n\nAll caches perform a best-effort bounding of a hash map using an entry replacement\nalgorithm to determine which entries to evict when the capacity is exceeded.\n\n[gh-actions-badge]: https://github.com/moka-rs/moka/workflows/CI/badge.svg\n[release-badge]: https://img.shields.io/crates/v/moka.svg\n[docs-badge]: https://docs.rs/moka/badge.svg\n[deps-rs-badge]: https://deps.rs/repo/github/moka-rs/moka/status.svg\n[codecov-badge]: https://codecov.io/gh/moka-rs/moka/graph/badge.svg?token=7GYZNS7O67\n[license-badge]: https://img.shields.io/crates/l/moka.svg\n\n[gh-actions]: https://github.com/moka-rs/moka/actions?query=workflow%3ACI\n[crate]: https://crates.io/crates/moka\n[docs]: https://docs.rs/moka\n[deps-rs]: https://deps.rs/repo/github/moka-rs/moka\n[codecov]: https://codecov.io/gh/moka-rs/moka\n\n[caffeine-git]: https://github.com/ben-manes/caffeine\n\n\n## Features\n\nMoka provides a rich and flexible feature set while maintaining high hit ratio and a\nhigh level of concurrency for concurrent access.\n\n- Thread-safe, highly concurrent in-memory cache implementations:\n    - Synchronous caches that can be shared across OS threads.\n    - An asynchronous (futures aware) cache.\n- A cache can be bounded by one of the followings:\n    - The maximum number of entries.\n    - The total weighted size of entries. (Size aware eviction)\n- Maintains near optimal hit ratio by using an entry replacement algorithms inspired\n  by Caffeine:\n    - Admission to a cache is controlled by the Least Frequently Used (LFU) policy.\n    - Eviction from a cache is controlled by the Least Recently Used (LRU) policy.\n    - [More details and some benchmark results are available here][tiny-lfu].\n- Supports expiration policies:\n    - Time to live.\n    - Time to idle.\n    - Per-entry variable expiration.\n- Supports eviction listener, a callback function that will be called when an entry\n  is removed from the cache.\n\n### Choosing the right cache for your use case\n\nNo cache implementation is perfect for every use cases. Moka is a complex software\nand can be overkill for your use case. Sometimes simpler caches like\n[Mini Moka][mini-moka-crate] or [Quick Cache][quick-cache] might be a better fit.\n\nThe following table shows the trade-offs between the different cache implementations:\n\n| Feature | Moka v0.12 | Mini Moka v0.10 | Quick Cache v0.6 |\n|:------- |:---- |:--------- |:----------- |\n| Thread-safe, sync cache | ✅ | ✅ | ✅ |\n| Thread-safe, async cache | ✅ | ❌ | ✅ |\n| Non-concurrent cache | ❌ | ✅ | ✅ |\n| Bounded by the maximum number of entries | ✅ | ✅ | ✅ |\n| Bounded by the total weighted size of entries | ✅ | ✅ | ✅ |\n| Near optimal hit ratio | ✅ TinyLFU | ✅ TinyLFU | ✅ S3-FIFO |\n| Per-key, atomic insertion. (e.g. `get_with` method) | ✅ | ❌ | ✅ |\n| Cache-level expiration policies (time-to-live and time-to-idle) | ✅ | ✅ | ❌ |\n| Per-entry variable expiration | ✅ | ❌ | ❌ |\n| Eviction listener | ✅ | ❌ | ✅ (via lifecycle hook) |\n| Lock-free, concurrent iterator | ✅ | ❌ | ❌ |\n| Lock-per-shard, concurrent iterator | ❌ | ✅ | ❌ |\n\n| Performance, etc. | Moka v0.12 | Mini Moka v0.10 | Quick Cache v0.6 |\n|:------- |:---- |:--------- |:----------- |\n| Small overhead compared to a concurrent hash table | ❌ | ❌ | ✅ |\n| Does not use background threads | ❌ → ✅ Removed from v0.12 | ✅ | ✅ |\n| Small dependency tree | ❌ | ✅ | ✅ |\n\n[tiny-lfu]: https://github.com/moka-rs/moka/wiki#admission-and-eviction-policies\n[quick-cache]: https://crates.io/crates/quick_cache\n[mini-moka-crate]: https://crates.io/crates/mini-moka\n\n## Moka in Production\n\nMoka is powering production services as well as embedded Linux devices like home\nrouters. Here are some highlights:\n\n- [crates.io](https://crates.io/): The official crate registry has been using Moka in\n  its API service to reduce the loads on PostgreSQL. Moka is maintaining\n  [cache hit rates of ~85%][gh-discussions-51] for the high-traffic download endpoint.\n  (Moka used: Nov 2021 &mdash; present)\n- [aliyundrive-webdav][aliyundrive-webdav-git]: This WebDAV gateway for a cloud drive\n  may have been deployed in hundreds of home Wi-Fi routers, including inexpensive\n  models with 32-bit MIPS or ARMv5TE-based SoCs. Moka is used to cache the metadata\n  of remote files. (Moka used: Aug 2021 &mdash; present)\n\n[gh-discussions-51]: https://github.com/moka-rs/moka/discussions/51\n[aliyundrive-webdav-git]: https://github.com/messense/aliyundrive-webdav\n\n\n## Recent Changes\n\n> **Note**\n> `v0.12.0` had major breaking changes on the API and internal behavior. Please read\n> the [MIGRATION-GUIDE.md][migration-guide-v012] for the details.\n\n- [MIGRATION-GUIDE.md][migration-guide-v012]\n- [CHANGELOG.md](https://github.com/moka-rs/moka/blob/main/CHANGELOG.md)\n\n[migration-guide-v012]: https://github.com/moka-rs/moka/blob/main/MIGRATION-GUIDE.md\n\n\n## Table of Contents\n\n- [Features](#features)\n    - [Choosing the right cache for your use case](#choosing-the-right-cache-for-your-use-case)\n- [Moka in Production](#moka-in-production)\n- [Change Log](#change-log)\n- [Supported Platforms](#supported-platforms)\n- [Usage](#usage)\n- Examples (Part 1)\n    - [Synchronous Cache](#example-synchronous-cache)\n    - [Asynchronous Cache](#example-asynchronous-cache)\n- [Avoiding to clone the value at `get`](#avoiding-to-clone-the-value-at-get)\n- Example (Part 2)\n    - [Size Aware Eviction](#example-size-aware-eviction)\n- [Expiration Policies](#expiration-policies)\n- [Minimum Supported Rust Versions](#minimum-supported-rust-versions)\n- Troubleshooting\n    - [Compile Errors on Some 32-bit Platforms](#compile-errors-on-some-32-bit-platforms)\n- [Developing Moka](#developing-moka)\n- [Road Map](#road-map)\n- [About the Name](#about-the-name)\n- [Credits](#credits)\n- [License](#license)\n\n\n## Supported Platforms\n\nMoka should work on most 64-bit and 32-bit platforms if Rust `std` library is\navailable with threading support. However, WebAssembly (Wasm) and WASI targets are\nnot supported.\n\nThe following platforms are tested on CI:\n\n- Linux 64-bit (x86_64, arm aarch64)\n- Linux 32-bit (i646, armv7, armv5, mips)\n    - If you get compile errors on 32-bit platforms, see\n      [troubleshooting](#compile-errors-on-some-32-bit-platforms).\n\nThe following platforms are not tested on CI but should work:\n\n- macOS (arm64)\n- Windows (x86_64 msvc and gnu)\n- iOS (arm64)\n\nThe following platforms are _not_ supported:\n\n- WebAssembly (Wasm) and WASI targets are not supported.\n  (See [this project task][gh-proj-49877487])\n- `nostd` environment (platforms without `std` library) are not supported.\n- 16-bit platforms are not supported.\n\n[gh-proj-49877487]: https://github.com/orgs/moka-rs/projects/1?pane=issue&itemId=49877487\n\n\n## Usage\n\nTo add Moka to your dependencies, run `cargo add` as the followings:\n\n```console\n# To use the synchronous cache:\ncargo add moka --features sync\n\n# To use the asynchronous cache:\ncargo add moka --features future\n```\n\nIf you want to use the cache under an async runtime such as `tokio` or `async-std`, you should specify the `future` feature. Otherwise, specify the `sync` feature.\n\n\n## Example: Synchronous Cache\n\nThe thread-safe, synchronous caches are defined in the `sync` module.\n\nCache entries are manually added using `insert` or `get_with` method, and\nare stored in the cache until either evicted or manually invalidated.\n\nHere's an example of reading and updating a cache by using multiple threads:\n\n```rust\n// Use the synchronous cache.\nuse moka::sync::Cache;\n\nuse std::thread;\n\nfn value(n: usize) -> String {\n    format!(\"value {n}\")\n}\n\nfn main() {\n    const NUM_THREADS: usize = 16;\n    const NUM_KEYS_PER_THREAD: usize = 64;\n\n    // Create a cache that can store up to 10,000 entries.\n    let cache = Cache::new(10_000);\n\n    // Spawn threads and read and update the cache simultaneously.\n    let threads: Vec<_> = (0..NUM_THREADS)\n        .map(|i| {\n            // To share the same cache across the threads, clone it.\n            // This is a cheap operation.\n            let my_cache = cache.clone();\n            let start = i * NUM_KEYS_PER_THREAD;\n            let end = (i + 1) * NUM_KEYS_PER_THREAD;\n\n            thread::spawn(move || {\n                // Insert 64 entries. (NUM_KEYS_PER_THREAD = 64)\n                for key in start..end {\n                    my_cache.insert(key, value(key));\n                    // get() returns Option<String>, a clone of the stored value.\n                    assert_eq!(my_cache.get(&key), Some(value(key)));\n                }\n\n                // Invalidate every 4 element of the inserted entries.\n                for key in (start..end).step_by(4) {\n                    my_cache.invalidate(&key);\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete.\n    threads.into_iter().for_each(|t| t.join().expect(\"Failed\"));\n\n    // Verify the result.\n    for key in 0..(NUM_THREADS * NUM_KEYS_PER_THREAD) {\n        if key % 4 == 0 {\n            assert_eq!(cache.get(&key), None);\n        } else {\n            assert_eq!(cache.get(&key), Some(value(key)));\n        }\n    }\n}\n```\n\nYou can try the synchronous example by cloning the repository and running the\nfollowing cargo instruction:\n\n```console\n$ cargo run --example sync_example\n```\n\nIf you want to atomically initialize and insert a value when the key is not present,\nyou might want to check [the document][doc-sync-cache] for other insertion methods\n`get_with` and `try_get_with`.\n\n[doc-sync-cache]: https://docs.rs/moka/*/moka/sync/struct.Cache.html#method.get_with\n\n\n## Example: Asynchronous Cache\n\nThe asynchronous (futures aware) cache is defined in the `future` module.\nIt works with asynchronous runtime such as [Tokio][tokio-crate],\n[async-std][async-std-crate] or [actix-rt][actix-rt-crate].\nTo use the asynchronous cache, [enable a crate feature called \"future\"](#usage).\n\n[tokio-crate]: https://crates.io/crates/tokio\n[async-std-crate]: https://crates.io/crates/async-std\n[actix-rt-crate]: https://crates.io/crates/actix-rt\n\nCache entries are manually added using an insert method, and are stored in the cache\nuntil either evicted or manually invalidated:\n\n- Inside an async context (`async fn` or `async` block), use `insert` or `invalidate`\n  method for updating the cache and `await` them.\n- Outside any async context, use `blocking` method to access blocking version of\n  `insert` or `invalidate` methods.\n\nHere is a similar program to the previous example, but using asynchronous cache with\n[Tokio][tokio-crate] runtime:\n\n```rust,ignore\n// Cargo.toml\n//\n// [dependencies]\n// moka = { version = \"0.12\", features = [\"future\"] }\n// tokio = { version = \"1\", features = [\"rt-multi-thread\", \"macros\" ] }\n// futures-util = \"0.3\"\n\n// Use the asynchronous cache.\nuse moka::future::Cache;\n\n#[tokio::main]\nasync fn main() {\n    const NUM_TASKS: usize = 16;\n    const NUM_KEYS_PER_TASK: usize = 64;\n\n    fn value(n: usize) -> String {\n        format!(\"value {n}\")\n    }\n\n    // Create a cache that can store up to 10,000 entries.\n    let cache = Cache::new(10_000);\n\n    // Spawn async tasks and write to and read from the cache.\n    let tasks: Vec<_> = (0..NUM_TASKS)\n        .map(|i| {\n            // To share the same cache across the async tasks, clone it.\n            // This is a cheap operation.\n            let my_cache = cache.clone();\n            let start = i * NUM_KEYS_PER_TASK;\n            let end = (i + 1) * NUM_KEYS_PER_TASK;\n\n            tokio::spawn(async move {\n                // Insert 64 entries. (NUM_KEYS_PER_TASK = 64)\n                for key in start..end {\n                    // insert() is an async method, so await it.\n                    my_cache.insert(key, value(key)).await;\n                    // get() returns Option<String>, a clone of the stored value.\n                    assert_eq!(my_cache.get(&key).await, Some(value(key)));\n                }\n\n                // Invalidate every 4 element of the inserted entries.\n                for key in (start..end).step_by(4) {\n                    // invalidate() is an async method, so await it.\n                    my_cache.invalidate(&key).await;\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all tasks to complete.\n    futures_util::future::join_all(tasks).await;\n\n    // Verify the result.\n    for key in 0..(NUM_TASKS * NUM_KEYS_PER_TASK) {\n        if key % 4 == 0 {\n            assert_eq!(cache.get(&key).await, None);\n        } else {\n            assert_eq!(cache.get(&key).await, Some(value(key)));\n        }\n    }\n}\n```\n\nYou can try the asynchronous example by cloning the repository and running the\nfollowing cargo instruction:\n\n```console\n$ cargo run --example async_example --features future\n```\n\nIf you want to atomically initialize and insert a value when the key is not present,\nyou might want to check [the document][doc-future-cache] for other insertion methods\n`get_with` and `try_get_with`.\n\n[doc-future-cache]: https://docs.rs/moka/*/moka/future/struct.Cache.html#method.get_with\n\n\n## Avoiding to clone the value at `get`\n\nFor the concurrent caches (`sync` and `future` caches), the return type of `get`\nmethod is `Option<V>` instead of `Option<&V>`, where `V` is the value type. Every\ntime `get` is called for an existing key, it creates a clone of the stored value `V`\nand returns it. This is because the `Cache` allows concurrent updates from threads so\na value stored in the cache can be dropped or replaced at any time by any other\nthread. `get` cannot return a reference `&V` as it is impossible to guarantee the\nvalue outlives the reference.\n\nIf you want to store values that will be expensive to clone, wrap them by\n`std::sync::Arc` before storing in a cache. [`Arc`][rustdoc-std-arc] is a thread-safe\nreference-counted pointer and its `clone()` method is cheap.\n\n[rustdoc-std-arc]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html\n\n```rust,ignore\nuse std::sync::Arc;\n\nlet key = ...\nlet large_value = vec![0u8; 2 * 1024 * 1024]; // 2 MiB\n\n// When insert, wrap the large_value by Arc.\ncache.insert(key.clone(), Arc::new(large_value));\n\n// get() will call Arc::clone() on the stored value, which is cheap.\ncache.get(&key);\n```\n\n\n## Example: Size Aware Eviction\n\nIf different cache entries have different \"weights\" &mdash; e.g. each entry has\ndifferent memory footprints &mdash; you can specify a `weigher` closure at the cache\ncreation time. The closure should return a weighted size (relative size) of an entry\nin `u32`, and the cache will evict entries when the total weighted size exceeds its\n`max_capacity`.\n\n```rust\nuse moka::sync::Cache;\n\nfn main() {\n    let cache = Cache::builder()\n        // A weigher closure takes &K and &V and returns a u32 representing the\n        // relative size of the entry. Here, we use the byte length of the value\n        // String as the size.\n        .weigher(|_key, value: &String| -> u32 {\n            value.len().try_into().unwrap_or(u32::MAX)\n        })\n        // This cache will hold up to 32MiB of values.\n        .max_capacity(32 * 1024 * 1024)\n        .build();\n    cache.insert(0, \"zero\".to_string());\n}\n```\n\nNote that weighted sizes are not used when making eviction selections.\n\nYou can try the size aware eviction example by cloning the repository and running the\nfollowing cargo instruction:\n\n```console\n$ cargo run --example size_aware_eviction\n```\n\n\n## Expiration Policies\n\nMoka supports the following expiration policies:\n\n- **Cache-level expiration policies:**\n    - Cache-level policies are applied to all entries in the cache.\n    - **Time to live (TTL)**: A cached entry will be expired after the specified\n      duration past from `insert`.\n    - **Time to idle (TTI)**: A cached entry will be expired after the specified\n      duration past from `get` or `insert`.\n- **Per-entry expiration policy:**\n    - The per-entry expiration lets you sets a different expiration time for each\n      entry.\n\nFor details and examples of above policies, see the \"Example: Time-based Expiration\"\nsection ([`sync::Cache`][doc-sync-cache-expiration],\n[`future::Cache`][doc-future-cache-expiration]) of the document.\n\n[doc-sync-cache-expiration]: https://docs.rs/moka/latest/moka/sync/struct.Cache.html#example-time-based-expirations\n[doc-future-cache-expiration]: https://docs.rs/moka/latest/moka/future/struct.Cache.html#example-time-based-expirations\n\n\n## Minimum Supported Rust Versions\n\nMoka's minimum supported Rust versions (MSRV) are the followings:\n\n| Feature  | MSRV                       |\n|:---------|:--------------------------:|\n| `future` | Rust 1.70.0 (June 1, 2023) |\n| `sync`   | Rust 1.70.0 (June 1, 2023) |\n\nIt will keep a rolling MSRV policy of at least 6 months. If the default features with\na mandatory features (`future` or `sync`) are enabled, MSRV will be updated\nconservatively. When using other features, MSRV might be updated more frequently, up\nto the latest stable.\n\nIn both cases, increasing MSRV is _not_ considered a semver-breaking change.\n\n<!--\n- quanta v0.12.4 requires 1.70.0.\n-->\n\n## Troubleshooting\n\n### Compile Errors on Some 32-bit Platforms\n\n#### Symptoms\n\nWhen using Moka v0.12.9 or earlier on some 32-bit platforms, you may get compile\nerrors:\n\n```console\nerror[E0432]: unresolved import `std::sync::atomic::AtomicU64`\n  --> ... /moka-0.5.3/src/sync.rs:10:30\n   |\n10 |         atomic::{AtomicBool, AtomicU64, Ordering},\n   |                              ^^^^^^^^^\n   |                              |\n   |                              no `AtomicU64` in `sync::atomic`\n```\n\nor\n\n```console\nerror[E0583]: file not found for module `atomic_time`\n  --> ... /moka-0.12.9/src/common/concurrent.rs:23:1\n   |\n23 | pub(crate) mod atomic_time;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n```\n\n#### How to Fix\n\nYou can fix these compilation errors by one of the following:\n\n1. (Recommended) Upgrade Moka to v0.12.10 or later. (`cargo update -p moka`)\n2. Or, keep using Moka v0.12.9 or earlier but disable the default features in\n   `Cargo.toml`. (`default-features = false`)\n    - The default features include the `atomic64` feature, which need to be disabled.\n\nThese error messages are caused by the absence of `std::sync::atomic::AtomicU64` on\nsome 32-bit platforms. Moka v0.12.10 and later will automatically use a fallback\nimplementation when `AtomicU64` is not available. With v0.12.9 and earlier, you must\nmanually disable the `atomic64` feature to use the fallback implementation.\n\n## Developing Moka\n\n**Running All Tests**\n\nTo run all tests including `future` feature and doc tests on the README, use the\nfollowing command:\n\n```console\n$ RUSTFLAGS='--cfg trybuild' cargo test --all-features\n```\n\n**Running All Tests without Default Features**\n\n```console\n$ RUSTFLAGS='--cfg trybuild' cargo test \\\n    --no-default-features --features 'future, sync'\n```\n\n**Generating the Doc**\n\n```console\n$ cargo +nightly -Z unstable-options --config 'build.rustdocflags=\"--cfg docsrs\"' \\\n    doc --no-deps --features 'future, sync'\n```\n\n## Roadmap\n\nSee the [project roadmap][gh-proj-1] for the updated and detailed plans.\n\nBut here are some highlights:\n\n[gh-proj-1]: https://github.com/orgs/moka-rs/projects/1/views/1\n\n- [x] Size-aware eviction. (`v0.7.0` via [#24][gh-pull-024])\n- [x] API stabilization. (Smaller core API, shorter names for frequently used\n       methods) (`v0.8.0` via [#105][gh-pull-105])\n    - e.g.\n    - `get_or_insert_with(K, F)` → `get_with(K, F)`\n    - `get_or_try_insert_with(K, F)` → `try_get_with(K, F)`\n    - `time_to_live()` → `policy().time_to_live()`\n- [x] Notifications on eviction. (`v0.9.0` via [#145][gh-pull-145])\n- [x] Variable (per-entry) expiration, using hierarchical timer wheels.\n  (`v0.11.0` via [#248][gh-pull-248])\n- [x] Remove background threads. (`v0.12.0` via [#294][gh-pull-294] and\n  [#316][gh-pull-316])\n- [x] Add upsert and compute methods. (`v0.12.3` via [#370][gh-pull-370])\n- [ ] Cache statistics (Hit rate, etc.). ([details][cache-stats])\n- [ ] Upgrade TinyLFU to Window-TinyLFU. ([details][tiny-lfu])\n- [ ] Restore cache from a snapshot. ([details][restore])\n\n[gh-pull-024]: https://github.com/moka-rs/moka/pull/24\n[gh-pull-105]: https://github.com/moka-rs/moka/pull/105\n[gh-pull-145]: https://github.com/moka-rs/moka/pull/145\n[gh-pull-248]: https://github.com/moka-rs/moka/pull/248\n[gh-pull-294]: https://github.com/moka-rs/moka/pull/294\n[gh-pull-316]: https://github.com/moka-rs/moka/pull/316\n[gh-pull-370]: https://github.com/moka-rs/moka/pull/370\n\n[cache-stats]: https://github.com/moka-rs/moka/issues/234\n[restore]: https://github.com/moka-rs/moka/issues/314\n\n## About the Name\n\nMoka is named after the [moka pot][moka-pot-wikipedia], a stove-top coffee maker that\nbrews espresso-like coffee using boiling water pressurized by steam.\n\nThis name would imply the following facts and hopes:\n\n- Moka is a part of the Java Caffeine cache family.\n- It is written in Rust. (Many moka pots are made of aluminum alloy or stainless\n  steel. We know they don't rust though)\n- It should be fast. (\"Espresso\" in Italian means express)\n- It should be easy to use, like a moka pot.\n\n[moka-pot-wikipedia]: https://en.wikipedia.org/wiki/Moka_pot\n\n\n## Credits\n\n### Caffeine\n\nMoka's architecture is heavily inspired by the [Caffeine][caffeine-git] library for\nJava. Thanks go to Ben Manes and all contributors of Caffeine.\n\n\n### cht\n\nThe source files of the concurrent hash table under `moka::cht` module were copied\nfrom the [cht crate v0.4.1][cht-v041] and modified by us. We did so for better\nintegration. cht v0.4.1 and earlier are licensed under the MIT license.\n\nThanks go to Gregory Meyer.\n\n[cht-v041]: https://github.com/Gregory-Meyer/cht/tree/v0.4.1\n\n\n## License\n\nMoka is distributed under either of\n\n- The MIT license\n- The Apache License (Version 2.0)\n\nat your option.\n\nSee [LICENSE-MIT](LICENSE-MIT) and [LICENSE-APACHE](LICENSE-APACHE) for details.\n\n<!--\n[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Fmoka-rs%2Fmoka.svg?type=large)](https://app.fossa.com/projects/git%2Bgithub.com%2Fmoka-rs%2Fmoka?ref=badge_large)\n-->\n"
        },
        {
          "name": "build.rs",
          "type": "blob",
          "size": 0.26171875,
          "content": "#[cfg(rustver)]\nfn main() {\n    use rustc_version::version;\n    let version = version().expect(\"Can't get the rustc version\");\n    println!(\n        \"cargo:rustc-env=RUSTC_SEMVER={}.{}\",\n        version.major, version.minor\n    );\n}\n\n#[cfg(not(rustver))]\nfn main() {}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}