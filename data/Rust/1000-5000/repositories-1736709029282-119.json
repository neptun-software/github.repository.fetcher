{
  "metadata": {
    "timestamp": 1736709029282,
    "page": 119,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nrc/r4cppp",
      "stars": 3680,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 0.333984375,
          "content": "Copyright 2015 The Rust for C++ programmers Developers.\n\nLicensed under the Apache License, Version 2.0 <LICENSE-APACHE or\nhttp://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n<LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\noption. This file may not be copied, modified, or distributed\nexcept according to those terms.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.82421875,
          "content": "# Rust For Systems Programmers\n\nA Rust tutorial for experienced C and C++ programmers.\n\nJump to [contents](#contents).\nJump to [contributing](#contributing).\n\nThis tutorial is intended for programmers who already know how pointers and\nreferences work and are used to systems programming concepts such as integer\nwidths and memory management. We intend to cover, primarily, the differences\nbetween Rust and C++ to get you writing Rust programs quickly without lots of\nfluff you probably already know.\n\nHopefully, Rust is a pretty intuitive language for C++ programmers. Most of the\nsyntax is pretty similar. The big difference (in my experience) is that the\nsometimes vague concepts of good systems programming are strictly enforced by\nthe compiler. This can be infuriating at first - there are things you want to\ndo, but the compiler won't let you (at least in safe code), and sometimes these\nthings *are* safe, but you can't convince the compiler of that. However, you'll\nquickly develop a good intuition for what is allowed. Communicating your own\nnotions of memory safety to the compiler requires some new and sometimes\ncomplicated type annotations. But if you have a strong idea of lifetimes for\nyour objects and experience with generic programming, they shouldn't be too\ntough to learn.\n\nThis tutorial started as a [series of blog posts](http://featherweightmusings.blogspot.co.nz/search/label/rust-for-c).\nPartly as an aid for me (@nrc) learning Rust (there is no better way to\ncheck that you have learnt something than to try and explain it to somebody\nelse) and partly because I found the existing resources for learning Rust\nunsatisfactory - they spent too much time on the basics that I already knew and\nused higher level intuitions to describe concepts that could better be explained\nto me using lower level intuitions. Since then, the documentation for Rust has\ngot *much* better, but I still think that existing C++ programmers are an\naudience who are a natural target for Rust, but are not particularly well\ncatered for.\n\n\n## Contents\n\n1. [Introduction - Hello world!](hello-world.md)\n1. [Control flow](control-flow.md)\n1. [Primitive types and operators](primitives.md)\n1. [Unique pointers](unique.md)\n1. [Borrowed pointers](borrowed.md)\n1. [Rc and raw pointers](rc-raw.md)\n1. [Data types](data-types.md)\n1. [Destructuring pt 1](destructuring.md)\n1. [Destructuring pt 2](destructuring-2.md)\n1. [Arrays and vecs](arrays.md)\n1. [Graphs and arena allocation](graphs/README.md)\n1. [Closures and first-class functions](closures.md)\n\n\n## Other resources\n\n* [The Rust book/guide](http://doc.rust-lang.org/book/) - the best place for\n  learning Rust in general and probably the best place to go for a second opinion\n  on stuff here or for stuff not covered.\n* [Rust API documentation](http://doc.rust-lang.org/std/index.html) - detailed\n  documentation for the Rust libraries.\n* [The Rust reference manual](https://doc.rust-lang.org/reference/) - a little\n  out of date in places, but thorough; good for looking up details.\n* [Discuss forum](http://users.rust-lang.org/) - general forum for discussion or\n  questions about using and learning Rust.\n* [StackOverflow Rust questions](https://stackoverflow.com/questions/tagged/rust) - answers\n  to many beginner and advanced questions about Rust, but be careful though - Rust\n  has changed *a lot* over the years and some of the answers might be very out of date.\n* [A Firehose of Rust](https://www.youtube.com/watch?v=IPmRDS0OSxM) - a recorded talk\n  introducing C++ programmers to how lifetimes, mutable aliasing, and move semantics work\n  in Rust\n\n\n## Contributing\n\nYes please!\n\nIf you spot a typo or mistake, please submit a PR, don't be shy! Please feel\nfree to file [an issue](https://github.com/nrc/r4cppp/issues/new) for\nlarger changes or for new chapters you'd like to see. I'd also be happy to see\nre-organisation of existing work or expanded examples, if you feel the tutorial\ncould be improved in those ways.\n\nIf you'd like to contribute a paragraph, section, or chapter please do! If you\nwant ideas for things to cover, see the [list of issues](https://github.com/nrc/r4cppp/issues),\nin particular those tagged [new material](https://github.com/nrc/r4cppp/labels/new%20material).\nIf you're not sure of something, please get in touch by pinging me here\n(@nrc) or on irc (nrc, on #rust or #rust-internals).\n\n\n### Style\n\nObviously, the intended audience is C++ programmers. The tutorial should\nconcentrate on things that will be new to experienced C++ programmers, rather\nthan a general audience (although, I don't assume the audience is familiar with\nthe most recent versions of C++). I'd like to avoid too much basic material and\ndefinitely avoid too much overlap with other resources, in particular the Rust\nguide/book.\n\nWork on edge case use cases (e.g., using a different build system from Cargo, or\nwriting syntax extensions, using unstable APIs) is definitely welcome, as is\nin-depth work on topics already covered at a high level.\n\nI'd like to avoid recipe-style examples for converting C++ code to Rust code,\nbut small examples of this kind are OK.\n\nUse of different formats (e.g., question and answer/FAQs, or larger worked\nexamples) are welcome.\n\nI don't plan on adding exercises or suggestions for mini-projects, but if you're\ninterested in that, let me know.\n\nI'm aiming for a fairly academic tone, but not too dry. All writing should be in\nEnglish (British English, not American English; although I would be very happy\nto have localisations/translations into any language, including American\nEnglish) and be valid GitHub markdown. For advice on writing style, grammar,\npunctuation, etc. see the Oxford Style Manual\nor [The Economist Style Guide](http://www.economist.com/styleguide/introduction).\nPlease limit width to 80 columns. I am a fan of the Oxford comma.\n\nDon't feel like work has to be perfect to be submitted, I'm happy to edit and\nI'm sure other people will be in the future.\n"
        },
        {
          "name": "arrays.md",
          "type": "blob",
          "size": 11.3203125,
          "content": "# Arrays and Vectors\n\nRust arrays are pretty different from C arrays. For starters they come in\nstatically and dynamically sized flavours. These are more commonly known as\nfixed length arrays and slices. As we'll see, the former is kind of a bad name\nsince both kinds of array have fixed (as opposed to growable) length. For a\ngrowable 'array', Rust provides the `Vec` collection.\n\n\n## Fixed length arrays\n\nThe length of a fixed length array is known statically and features in its\ntype. E.g., `[i32; 4]` is the type of an array of `i32`s with length four.\n\nArray literal and array access syntax is the same as C:\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];     // As usual, the type annotation is optional.\nprintln!(\"The second element is {}\", a[1]);\n```\n\nYou'll notice that array indexing is zero-based, just like C.\n\nHowever, unlike C/C++[^1], array indexing is bounds checked. In\nfact all access to arrays is bounds checked, which is another way Rust is a\nsafer language.\n\nIf you try to do `a[4]`, then you will get a runtime panic. Unfortunately, the\nRust compiler is not clever enough to give you a compile time error, even when\nit is obvious (as in this example).\n\nIf you like to live dangerously, or just need to get every last ounce of\nperformance out of your program, you can still get unchecked access to arrays.\nTo do this, use the `get_unchecked` method on an array. Unchecked array accesses\nmust be inside an unsafe block. You should only need to do this in the rarest\ncircumstances.\n\nJust like other data structures in Rust, arrays are immutable by default and\nmutability is inherited. Mutation is also done via the indexing syntax:\n\n```rust\nlet mut a = [1, 2, 3, 4];\na[3] = 5;\nprintln!(\"{:?}\", a);\n```\n\nAnd just like other data, you can borrow an array by taking a reference to it:\n\n```rust\nfn foo(a: &[i32; 4]) {\n    println!(\"First: {}; last: {}\", a[0], a[3]);\n}\n\nfn main() {\n    foo(&[1, 2, 3, 4]);\n}\n```\n\nNotice that indexing still works on a borrowed array.\n\nThis is a good time to talk about the most interesting aspect of Rust arrays for\nC++ programmers - their representation. Rust arrays are value types: they are\nallocated on the stack like other values and an array object is a sequence of\nvalues, not a pointer to those values (as in C). So from our examples above, `let\na = [1_i32, 2, 3, 4];` will allocate 16 bytes on the stack and executing `let b\n= a;` will copy 16 bytes. If you want a C-like array, you have to explicitly\nmake a pointer to the array, this will give you a pointer to the first element.\n\nA final point of difference between arrays in Rust and C++ is that Rust arrays\ncan implement traits, and thus have methods. To find the length of an array, for\nexample, you use `a.len()`.\n\n\n## Slices\n\nA slice in Rust is just an array whose length is not known at compile time. The\nsyntax of the type is just like a fixed length array, except there is no length:\ne.g., `[i32]` is a slice of 32 bit integers (with no statically known length).\n\nThere is a catch with slices: since the compiler must know the size of all\nobjects in Rust, and it can't know the size of a slice, then we can never have a\nvalue with slice type. If you try and write `fn foo(x: [i32])`, for example, the\ncompiler will give you an error.\n\nSo, you must always have pointers to slices (there are some very technical\nexceptions to this rule so that you can implement your own smart pointers, but\nyou can safely ignore them for now). You must write `fn foo(x: &[i32])` (a\nborrowed reference to a slice) or `fn foo(x: *mut [i32])` (a mutable raw pointer\nto a slice), etc.\n\nThe simplest way to create a slice is by coercion. There are far fewer implicit\ncoercions in Rust than there are in C++. One of them is the coercion from fixed\nlength arrays to slices. Since slices must be pointer values, this is\neffectively a coercion between pointers. For example, we can coerce `&[i32; 4]`\nto `&[i32]`, e.g.,\n\n```rust\nlet a: &[i32] = &[1, 2, 3, 4];\n```\n\nHere the right hand side is a fixed length array of length four, allocated on\nthe stack. We then take a reference to it (type `&[i32; 4]`). That reference is\ncoerced to type `&[i32]` and given the name `a` by the let statement.\n\nAgain, access is just like C (using `[...]`), and access is bounds checked. You\ncan also check the length yourself by using `len()`. So clearly the length of\nthe array is known somewhere. In fact all arrays of any kind in Rust have known\nlength, since this is essential for bounds checking, which is an integral part\nof memory safety. The size is known dynamically (as opposed to statically in the\ncase of fixed length arrays), and we say that slice types are dynamically sized\ntypes (DSTs, there are other kinds of dynamically sized types too, they'll be\ncovered elsewhere).\n\nSince a slice is just a sequence of values, the size cannot be stored as part of\nthe slice. Instead it is stored as part of the pointer (remember that slices\nmust always exist as pointer types). A pointer to a slice (like all pointers to\nDSTs) is a fat pointer - it is two words wide, rather than one, and contains the\npointer to the data plus a payload. In the case of slices, the payload is the\nlength of the slice.\n\nSo in the example above, the pointer `a` will be 128 bits wide (on a 64 bit\nsystem). The first 64 bits will store the address of the `1` in the sequence\n`[1, 2, 3, 4]`, and the second 64 bits will contain `4`. Usually, as a Rust\nprogrammer, these fat pointers can just be treated as regular pointers. But it\nis good to know about (it can affect the things you can do with casts, for\nexample).\n\n\n### Slicing notation and ranges\n\nA slice can be thought of as a (borrowed) view of an array. So far we have only\nseen a slice of the whole array, but we can also take a slice of part of an\narray. There is a special notation for this which is like the indexing\nsyntax, but takes a range instead of a single integer. E.g., `a[0..4]`, which\ntakes a slice of the first four elements of `a`. Note that the range is\nexclusive at the top and inclusive at the bottom. Examples:\n\n```rust\nlet a: [i32; 4] = [1, 2, 3, 4];\nlet b: &[i32] = &a;   // Slice of the whole array.\nlet c = &a[0..4];     // Another slice of the whole array, also has type &[i32].\nlet c = &a[1..3];     // The middle two elements, &[i32].\nlet c = &a[1..];      // The last three elements.\nlet c = &a[..3];      // The first three elements.\nlet c = &a[..];       // The whole array, again.\nlet c = &b[1..3];     // We can also slice a slice.\n```\n\nNote that in the last example, we still need to borrow the result of slicing.\nThe slicing syntax produces an unborrowed slice (type: `[i32]`) which we must\nthen borrow (to give a `&[i32]`), even if we are slicing a borrowed slice.\n\nRange syntax can also be used outside of slicing syntax. `a..b` produces an\niterator which runs from `a` to `b-1`. This can be combined with other iterators\nin the usual way, or can be used in `for` loops:\n\n```rust\n// Print all numbers from 1 to 10.\nfor i in 1..11 {\n    println!(\"{}\", i);\n}\n```\n\n## Vecs\n\nA vector is heap allocated and is an owning reference. Therefore (and like\n`Box<_>`), it has move semantics. We can think of a fixed length array\nanalogously to a value, a slice to a borrowed reference. Similarly, a vector in\nRust is analogous to a `Box<_>` pointer.\n\nIt helps to think of `Vec<_>` as a kind of smart pointer, just like `Box<_>`,\nrather than as a value itself. Similarly to a slice, the length is stored in the\n'pointer', in this case the 'pointer' is the Vec value.\n\nA vector of `i32`s has type `Vec<i32>`. There are no vector literals, but we can\nget the same effect by using the `vec!` macro. We can also create an empty\nvector using `Vec::new()`:\n\n```rust\nlet v = vec![1, 2, 3, 4];      // A Vec<i32> with length 4.\nlet v: Vec<i32> = Vec::new();  // An empty vector of i32s.\n```\n\nIn the second case above, the type annotation is necessary so the compiler can\nknow what the vector is a vector of. If we were to use the vector, the type\nannotation would probably not be necessary.\n\nJust like arrays and slices, we can use indexing notation to get a value from\nthe vector (e.g., `v[2]`). Again, these are bounds checked. We can also use\nslicing notation to take a slice of a vector (e.g., `&v[1..3]`).\n\nThe extra feature of vectors is that their size can change - they can get longer\nor shorter as needed. For example, `v.push(5)` would add the element `5` to the\nend of the vector (this would require that `v` is mutable). Note that growing a\nvector can cause reallocation, which for large vectors can mean a lot of\ncopying. To guard against this you can pre-allocate space in a vector using\n`with_capacity`, see the [Vec docs](https://doc.rust-lang.org/std/vec/struct.Vec.html)\nfor more details.\n\n\n## The `Index` traits\n\nNote for readers: there is a lot of material in this section that I haven't\ncovered properly yet. If you're following the tutorial, you can skip this\nsection, it is a somewhat advanced topic in any case.\n\nThe same indexing syntax used for arrays and vectors is also used for other\ncollections, such as `HashMap`s. And you can use it yourself for your own\ncollections. You opt-in to using the indexing (and slicing) syntax by\nimplementing the `Index` trait. This is a good example of how Rust makes\navailable nice syntax to user types, as well as built-ins (`Deref` for\ndereferencing smart pointers, as well as `Add` and various other traits, work in\na similar way).\n\nThe `Index` trait looks like\n\n```rust\npub trait Index<Idx: ?Sized> {\n    type Output: ?Sized;\n\n    fn index(&self, index: Idx) -> &Self::Output;\n}\n```\n\n`Idx` is the type used for indexing. For most uses of indexing this is `usize`.\nFor slicing this is one of the `std::ops::Range` types. `Output` is the type\nreturned by indexing, this will be different for each collection. For slicing it\nwill be a slice, rather than the type of a single element. `index` is a method\nwhich does the work of getting the element(s) out of the collection. Note that\nthe collection is taken by reference and the method returns a reference to the\nelement with the same lifetime.\n\nLet's look at the implementation for `Vec` to see how what an implementation\nlooks like:\n\n```rust\nimpl<T> Index<usize> for Vec<T> {\n    type Output = T;\n\n    fn index(&self, index: usize) -> &T {\n        &(**self)[index]\n    }\n}\n```\n\nAs we said above, indexing is done using `usize`. For a `Vec<T>`, indexing will\nreturn a single element of type `T`, thus the value of `Output`. The\nimplementation of `index` is a bit weird - `(**self)` gets a view of the whole\nvec as a slice, then we use indexing on slices to get the element, and finally\ntake a reference to it.\n\nIf you have your own collections, you can implement `Index` in a similar way to\nget indexing and slicing syntax for your collection.\n\n\n## Initialiser syntax\n\nAs with all data in Rust, arrays and vectors must be properly initialised. Often\nyou just want an array full of zeros to start with and using the array literal\nsyntax is a pain. So Rust gives you a little syntactic sugar to initialise an\narray full of a given value: `[value; len]`. So for example to create an array\nwith length 100 full of zeros, we'd use `[0; 100]`.\n\nSimilarly for vectors, `vec![42; 100]` would give you a vector with 100\nelements, each with the value 42.\n\nThe initial value is not limited to integers, it can be any expression. For\narray initialisers, the length must be an integer constant expression. For\n`vec!`, it can be any expression with type `usize`.\n\n\n[^1]: In C++11 there is `std::array<T, N>` that provides boundary checking when\n`at()` method is used.\n"
        },
        {
          "name": "borrowed.md",
          "type": "blob",
          "size": 8.240234375,
          "content": "# Borrowed pointers\n\nIn the last post I introduced unique pointers. This time I will talk about\nanother kind of pointer which is much more common in most Rust programs:\nborrowed pointers (aka borrowed references, or just references).\n\nIf we want to have a reference to an existing value (as opposed to creating a\nnew value on the heap and pointing to it, as with unique pointers), we must use\n`&`, a borrowed reference. These are probably the most common kind of pointer in\nRust, and if you want something to fill in for a C++ pointer or reference (e.g.,\nfor passing a parameter to a function by reference), this is probably it.\n\nWe use the `&` operator to create a borrowed reference and to indicate reference\ntypes, and `*` to dereference them. The same rules about automatic dereferencing\napply as for unique pointers. For example,\n\n```rust\nfn foo() {\n    let x = &3;   // type: &i32\n    let y = *x;   // 3, type: i32\n    bar(x, *x);\n    bar(&y, y);\n}\n\nfn bar(z: &i32, i: i32) {\n    // ...\n}\n```\n\nThe `&` operator does not allocate memory (we can only create a borrowed\nreference to an existing value) and if a borrowed reference goes out of scope,\nno memory gets deleted.\n\nBorrowed references are not unique - you can have multiple borrowed references\npointing to the same value. E.g.,\n\n```rust\nfn foo() {\n    let x = 5;                // type: i32\n    let y = &x;               // type: &i32\n    let z = y;                // type: &i32\n    let w = y;                // type: &i32\n    println!(\"These should all be 5: {} {} {}\", *w, *y, *z);\n}\n```\n\nLike values, borrowed references are immutable by default. You can also use\n`&mut` to take a mutable reference, or to denote mutable reference types.\nMutable borrowed references are unique (you can only take a single mutable\nreference to a value, and you can only have a mutable reference if there are no\nimmutable references). You can use a mutable reference where an immutable one is\nwanted, but not vice versa. Putting all that together in an example:\n\n```rust\nfn bar(x: &i32) { ... }\nfn bar_mut(x: &mut i32) { ... }  // &mut i32 is a reference to an i32 which\n                                 // can be mutated\n\nfn foo() {\n    let x = 5;\n    //let xr = &mut x;     // Error - can't make a mutable reference to an\n                           // immutable variable\n    let xr = &x;           // Ok (creates an immutable ref)\n    bar(xr);\n    //bar_mut(xr);         // Error - expects a mutable ref\n\n    let mut x = 5;\n    let xr = &x;           // Ok (creates an immutable ref)\n    //*xr = 4;             // Error - mutating immutable ref\n    //let xr = &mut x;     // Error - there is already an immutable ref, so we\n                           // can't make a mutable one\n\n    let mut x = 5;\n    let xr = &mut x;       // Ok (creates a mutable ref)\n    *xr = 4;               // Ok\n    //let xr2 = &x;        // Error - there is already a mutable ref, so we\n                           // can't make an immutable one\n    //let xr2 = &mut x;    // Error - can only have one mutable ref at a time\n    bar(xr);               // Ok\n    bar_mut(xr);           // Ok\n}\n```\n\nNote that the reference may be mutable (or not) independently of the mutableness\nof the variable holding the reference. This is similar to C++ where pointers can\nbe const (or not) independently of the data they point to. This is in contrast\nto unique pointers, where the mutableness of the pointer is linked to the\nmutableness of the data. For example,\n\n```rust\nfn foo() {\n    let mut x = 5;\n    let mut y = 6;\n    let xr = &mut x;\n    //xr = &mut y;        // Error xr is immutable\n\n    let mut x = 5;\n    let mut y = 6;\n    let mut xr = &mut x;\n    xr = &mut y;          // Ok\n\n    let x = 5;\n    let y = 6;\n    let mut xr = &x;\n    xr = &y;              // Ok - xr is mut, even though the referenced data is not\n}\n```\n\nIf a mutable value is borrowed, it becomes immutable for the duration of the\nborrow. Once the borrowed pointer goes out of scope, the value can be mutated\nagain. This is in contrast to unique pointers, which once moved can never be\nused again. For example,\n\n```rust\nfn foo() {\n    let mut x = 5;            // type: i32\n    {\n        let y = &x;           // type: &i32\n        //x = 4;              // Error - x has been borrowed\n        println!(\"{} {}\", y, x);    // Ok - x can be read\n    }\n    x = 4;                    // OK - y no longer exists\n}\n```\n\nThe same thing happens if we take a mutable reference to a value - the value\nstill cannot be modified. In general in Rust, data can only ever be modified via\none variable or pointer. Furthermore, since we have a mutable reference, we\ncan't take an immutable reference. That limits how we can use the underlying\nvalue:\n\n```rust\nfn foo() {\n    let mut x = 5;            // type: i32\n    {\n        let y = &mut x;       // type: &mut i32\n        //x = 4;              // Error - x has been borrowed\n        //println!(\"{}\", x);  // Error - requires borrowing x\n    }\n    x = 4;                    // OK - y no longer exists\n}\n```\n\nUnlike C++, Rust won't automatically reference a value for you. So if a function\ntakes a parameter by reference, the caller must reference the actual parameter.\nHowever, pointer types will automatically be converted to a reference:\n\n```rust\nfn foo(x: &i32) { ... }\n\nfn bar(x: i32, y: Box<i32>) {\n    foo(&x);\n    // foo(x);   // Error - expected &i32, found i32\n    foo(y);      // Ok\n    foo(&*y);    // Also ok, and more explicit, but not good style\n}\n```\n\n## `mut` vs `const`\n\nAt this stage it is probably worth comparing `mut` in Rust to `const` in C++.\nSuperficially they are opposites. Values are immutable by default in Rust and\ncan be made mutable by using `mut`. Values are mutable by default in C++, but\ncan be made constant by using `const`. The subtler and more important difference\nis that C++ const-ness applies only to the current use of a value, whereas\nRust's immutability applies to all uses of a value. So in C++ if I have a\n`const` variable, someone else could have a non-const reference to it and it\ncould change without me knowing. In Rust if you have an immutable variable, you\nare guaranteed it won't change.\n\nAs we mentioned above, all mutable variables are unique. So if you have a\nmutable value, you know it is not going to change unless you change it.\nFurthermore, you can change it freely since you know that no one else is relying\non it not changing.\n\n## Borrowing and lifetimes\n\nOne of the primary safety goals of Rust is to avoid dangling pointers (where a\npointer outlives the memory it points to). In Rust, it is impossible to have a\ndangling borrowed reference. It is only legal to create a borrowed reference to\nmemory which will be alive longer than the reference (well, at least as long as\nthe reference). In other words, the lifetime of the reference must be shorter\nthan the lifetime of the referenced value.\n\nThat has been accomplished in all the examples in this post. Scopes introduced\nby `{}` or functions are bounds on lifetimes - when a variable goes out of scope\nits lifetime ends. If we try to take a reference to a shorter lifetime, such as\nin a narrower scope, the compiler will give us an error. For example,\n\n```rust\nfn foo() {\n    let x = 5;\n    let mut xr = &x;        // Ok - x and xr have the same lifetime\n    {\n        let y = 6;\n        xr = &y             // Error - xr will outlive y\n    }                       // y is released here\n    println!(\"{:?}\", xr);   // xr is used here so it outlives y. Try to comment out this line.\n}                           // x and xr are released here\n```\n\nIn the above example, xr and y don't have the same lifetime because y starts\nlater than xr, but it's the end of lifetimes which is more interesting, since you\ncan't reference a variable before it exists in any case - something else which\nRust enforces and which makes it safer than C++.\n\n## Explicit lifetimes\n\nAfter playing with borrowed pointers for a while, you'll probably come across\nborrowed pointers with an explicit lifetime. These have the syntax `&'a T` ([cf.](https://en.wikipedia.org/wiki/Cf.)\n`&T`). They're kind of a big topic since I need to cover lifetime-polymorphism\nat the same time so I'll leave it for another post (there are a few more less\ncommon pointer types to cover first though). For now, I just want to say that\n`&T` is a shorthand for `&'a T` where `a` is the current scope, that is the\nscope in which the type is declared.\n"
        },
        {
          "name": "closures.md",
          "type": "blob",
          "size": 18.47265625,
          "content": "# Closures and first-class functions\n\nClosures and first-class and higher order functions are a core part of Rust. In\nC and C++ there are function pointers (and those weird member/method pointer\nthings in C++ that I never got the hang of). However, they are used relatively\nrarely and are not very ergonomic. C++11 introduced lambdas, and these are\npretty close to Rust closures, in particular they have a very similar\nimplementation strategy.\n\nTo start with, I want to establish some intuition for these things. Then, we'll\ndive in to the details.\n\nLets say we have a function `foo`: `pub fn foo() -> u32 { 42 }`. Now let's\nimagine another function `bar` which takes a function as an argument (I'll leave\n`bar`'s signature for later): `fn bar(f: ...) { ... }`. We can pass `foo` to\n`bar` kind of like we would pass a function pointer in C: `bar(foo)`. In the\nbody of `bar` we can call `f` as if it were a function: `let x = f();`.\n\nWe say that Rust has first-class functions because we can pass them around and\nuse them like we can with other values. We say `bar` is a higher-order function\nbecause it takes a function as an argument, i.e., it is a function that operates\non functions.\n\nClosures in Rust are anonymous functions with a nice syntax. A closure `|x| x +\n2` takes an argument and returns it with `2` added. Note that we don't have to\ngive types for the arguments to a closure (they can usually be inferred). We\nalso don't need to specify a return type. If we want the closure body to be more\nthan just one expression, we can use braces: `|x: i32| { let y = x + 2; y }`. We\ncan pass closures just like functions: `bar(|| 42)`.\n\nThe big difference between closures and other functions is that closures capture\ntheir environment. This means that we can refer to variables outside the closure\nfrom the closure. E.g.,\n\n```rust\nlet x = 42;\nbar(|| x);\n```\n\nNote how `x` is in scope in the closure.\n\nWe've seen closures before, used with iterators, and this is a common use case\nfor them. E.g., to add a value to each element of a vector:\n\n```rust\nfn baz(v: Vec<i32>) -> Vec<i32> {\n    let z = 3;\n    v.iter().map(|x| x + z).collect()\n}\n```\n\nHere `x` is an argument to the closure, each member of `v` will be passed as an\n`x`. `z` is declared outside of the closure, but because it's a closure, `z` can\nbe referred to. We could also pass a function to map:\n\n```rust\nfn add_two(x: i32) -> i32 {\n    x + 2\n}\n\nfn baz(v: Vec<i32>) -> Vec<i32> {\n    v.iter().map(add_two).collect()\n}\n```\n\nNote that Rust also allows declaring functions inside of functions. These are\n*not* closures - they can't access their environment. They are merely a\nconvenience for scoping.\n\n```rust\nfn qux(x: i32) {\n    fn quxx() -> i32 {\n        x // ERROR x is not in scope.\n    }\n\n    let a = quxx();\n}\n```\n\n## Function types\n\nLets introduce a new example function:\n\n```rust\nfn add_42(x: i32) -> i64 {\n    x as i64 + 42\n}\n```\n\nAs we saw before, we can store a function in a variable: `let a = add_42;`. The\nmost precise type of `a` cannot be written in Rust. You'll sometimes see the\ncompiler render it as `fn(i32) -> i64 {add_42}` in error messages. Each function\nhas its own unique and anonymous type. `fn add_41(x: i32) -> i64` has a different\ntype, even though it has the same signature.\n\nWe can write less precise types, for example, `let a: fn(i32) -> i64 = add_42;`.\nAll function types with the same signature can be coerced to a `fn` type\n(which can be written by the programmer).\n\n`a` is represented by the compiler as a function pointer, however, if the\ncompiler knows the precise type, it doesn't actually use that function pointer.\nA call like a() is statically dispatched based on the type of a. If the\ncompiler doesn't know the precise type (e.g., it only knows the fn type), then\nthe call is dispatched using the function pointer in the value.\n\nThere are also `Fn` types (note the capital 'F'). These `Fn` types are bounds,\njust like traits (in fact they *are* traits, as we'll see later). `Fn(i32) -> i64`\nis a bound on the types of all function-like objects with that signature. When\nwe take a reference to a function pointer, we're actually creating a trait\nobject which is represented by a fat pointer (see DSTs).\n\nTo pass a function to another function, or to store the function in a field, we\nmust write a type. We have several choices, we can either use either a `fn` type\nor a `Fn` type. The latter is better because it includes closures (and\npotentially other function-like things), whereas `fn` types don't. The `Fn`\ntypes are dynamically sized which means we cannot use them as value types. We\nmust either pass function objects or use generics. Let's look at the generic\napproach first. For example,\n\n```rust\nfn bar<F>(f: F) -> i64\n    where F: Fn(i32) -> i64\n{\n    f(0)\n}\n```\n\n`bar` takes any function with the signature `Fn(i32) -> i64`, i.e., we can\ninstantiate the `F` type parameter with any function-like type. We could call\n`bar(add_42)` to pass `add_42` to `bar` which would instantiate `F` with\n`add_42`'s anonymous type. We could also call `bar(add_41)` and that would work\ntoo.\n\nYou can also pass closures to `bar`, e.g., `bar(|x| x as i64)`. This works\nbecause closure types are also bounded by the `Fn` bound matching their\nsignature (like functions, each closure has it's own anonymous type).\n\nFinally, you can pass references to functions or closures too: `bar(&add_42)` or\n`bar(&|x| x as i64)`.\n\nOne could also write `bar` as `fn bar(f: &Fn(i32) -> i64) ...`. These two\napproaches (generics vs a function/trait object) have quite different semantics.\nIn the generics case, `bar` will be monomorphised so when code is generated, the\ncompiler know the exact type of `f`, that means it can be statically dispatched.\nIf using a function object, the function is not monomorphised. The exact type of\n`f` is not known, and so the compiler must generate a virtual dispatch. The\nlatter is slower, but the former will produce more code (one monomorphised\nfunction per type parameter instance).\n\nThere are actually more function traits than just `Fn`; there are `FnMut` and\n`FnOnce` too. These are used in the same way as `Fn`, e.g., `FnOnce(i32) ->\ni64`. A `FnMut` represents an object which can be called and can be mutated\nduring that call. This doesn't apply to normal functions, but for closures it\nmeans the closure can mutate its environment. `FnOnce` is a function which can\nonly be called (at most) once. Again, this is only relevant for closures.\n\n`Fn`, `FnMut`, and `FnOnce` are in a sub-trait hierarchy. `Fn`s are `FnMut`s\n(because one can call a `Fn` function with permission to mutate and no harm is\ndone, but the opposite is not true). `Fn`s and `FnMut`s are `FnOnce`s (because\nthere is no harm done if a regular function is only called once, but not the\nopposite).\n\nSo, to make a higher-order function as flexible as possible, you should use the\n`FnOnce` bound, rather than the `Fn` bound (or use the `FnMut` bound if you must\ncall the function more than once).\n\n\n### Methods\n\nYou can use methods in the same way as functions - take pointers to them store\nthem in variables, etc. You can't use the dot syntax, you must explicitly name\nthe method using the fully explicit form of naming (sometimes called UFCS for\nuniversal function call syntax). The `self` parameter is the first argument to\nthe method. E.g.,\n\n```rust\nstruct Foo;\n\nimpl Foo {\n    fn bar(&self) {}\n}\n\ntrait T {\n    fn baz(&self);\n}\n\nimpl T for Foo {\n    fn baz(&self) {}\n}\n\nfn main() {\n    // Inherent method.\n    let x = Foo::bar;\n    x(&Foo);\n    \n    // Trait method, note the fully explicit naming form.\n    let y = <Foo as T>::baz;\n    y(&Foo);\n}\n```\n\n\n### Generic functions\n\nYou can't take a pointer to a generic function and there is no way to express a\ngeneric function type. However, you can take a reference to a function if all\nits type parameters are instantiated. E.g.,\n\n```rust\nfn foo<T>(x: &T) {}\n\nfn main() {\n    let x = &foo::<i32>;\n    x(&42);\n}\n```\n\nThere is no way to define a generic closure. If you need a closure to work over\nmany types you can use trait objects, macros (for generating closures), or pass\na closure which returns closures (each returned closure can operate on a\ndifferent type).\n\n\n### Lifetime-generic functions and higher-ranked types\n\nIt *is* possible to have function types and closures which are generic over\nlifetimes. \n\nImagine we have a closure which takes a borrowed reference. The closure can work\nthe same way no matter what lifetime the reference has (and indeed in the\ncompiled code, the lifetime will have been erased). But, what does the type look\nlike?\n\nFor example,\n\n```rust\nfn foo<F>(x: &Bar, f: F) -> &Baz\n    where F: Fn(&Bar) -> &Baz\n{\n    f(x)\n}\n```\n\nwhat are the lifetimes of the references here? In this simple example, we can\nuse a single lifetime (no need for a generic closure):\n\n```rust\nfn foo<'b, F>(x: &'b Bar, f: F) -> &'b Baz\n    where F: Fn(&'b Bar) -> &'b Baz\n{\n    f(x)\n}\n```\n\nBut what if we want `f` to work on inputs with different lifetimes? Then we need\na generic function type:\n\n```rust\nfn foo<'b, 'c, F>(x: &'b Bar, y: &'c Bar, f: F) -> (&'b Baz, &'c Baz)\n    where F: for<'a> Fn(&'a Bar) -> &'a Baz\n{\n    (f(x), f(y))\n}\n```\n\nThe novelty here is the `for<'a>` syntax, this is used to denote a function type\nwhich is generic over a lifetime. It is read \"for all 'a, ...\". In theoretical\nterms, the function type is universally quantified.\n\nNote that we cannot hoist up `'a` to `foo` in the above example. Counter-example:\n\n```rust\nfn foo<'a, 'b, 'c, F>(x: &'b Bar, y: &'c Bar, f: F) -> (&'b Baz, &'c Baz)\n    where F: Fn(&'a Bar) -> &'a Baz\n{\n    (f(x), f(y))\n}\n```\n\nwill not compile because when the compiler infers lifetimes for a call to `foo`,\nit must pick a single lifetime for `'a`, which it can't do if `'b` and `'c` are\ndifferent.\n\nA function type which is generic in this way is called a higher-ranked type.\nLifetime variables at the outer level have rank one. Because `'a` in the above\nexample cannot be moved to the outer level, it's rank is higher than one.\n\nCalling functions with higher-ranked function type arguments is easy - the\ncompiler will infer the lifetime parameters. E.g., `foo(&Bar { ... }, &Bar\n{...}, |b| &b.field)`.\n\nIn fact, most of the time you don't even need to worry about such things. The\ncompiler will allow you to elide the quantified lifetimes in the same way that\nyou are allowed to elide many lifetimes on function arguments. For example, the\nexample above can just be written as\n\n```rust\nfn foo<'b, 'c, F>(x: &'b Bar, y: &'c Bar, f: F) -> (&'b Baz, &'c Baz)\n    where F: Fn(&Bar) -> &Baz\n{\n    (f(x), f(y))\n}\n```\n\n(and you only need `'b` and `'c` because it is a contrived example).\n\nWhere Rust sees a function type with a borrowed references, it will apply the\nusual elision rules, and quantify the elided variables at the scope of the\nfunction type (i.e., with higher rank).\n\nYou might be wondering why bother with all this complexity for what looks like a\nfairly niche use case. The real motivation is functions which take a function\nto operate on some data provided by the outer function. For example,\n\n```rust\nfn foo<F>(f: F)\n    where F: Fn(&i32) // Fully explicit type: for<'a> Fn(&'a i32)\n{\n    let data = 42;\n    f(&data)\n}\n```\n\nIn these cases, we *need* higher-ranked types. If we added a lifetime parameter\nto `foo` instead, we could never infer a correct lifetime. To see why, let's\nlook at how it might work, consider `fn foo<'a, F: Fn(&'a i32)> ...`. Rust\nrequires that any lifetime parameter must outlive the item it is declared on (if\nthis were not the case, an argument with that lifetime could be used inside that\nfunction, where it is not guaranteed to be live). In the body of `foo` we use\n`f(&data)`, the lifetime Rust will infer for that reference will last (at most)\nfrom where `data` is declared to where it goes out of scope. Since `'a` must\noutlive `foo`, but that inferred lifetime does not, we cannot call `f` in this\nway.\n\nHowever, with higher-ranked lifetimes `f` can accept any lifetime and so the\nanonymous one from `&data` is fine and the function type checks.\n\n\n### Enum constructors\n\nThis is something of a digression, but it is sometimes a useful trick. All\nvariants of an enum define a function from the fields of the variant to the enum\ntype. For example,\n\n```rust\nenum Foo {\n    Bar,\n    Baz(i32),\n}\n```\n\ndefines two functions, `Foo::Bar: Fn() -> Foo` and `Foo::Baz: Fn(i32) -> Foo`.\nWe don't normally use the variants in this way, we treat them as data types\nrather than functions. But sometimes it is useful, for example if we have a list\nof `i32`s we can create a list of `Foo`s with\n\n```rust\nlist_of_i32.iter().map(Foo::Baz).collect()\n```\n\n\n## Closure flavours\n\nA closure has two forms of input: the arguments which are passed to it explicitly\nand the variables it *captures* from its environment. Usually, everything about\nboth kinds of input is inferred, but you can have more control if you want it.\n\nFor the arguments, you can declare types instead of letting Rust infer them. You\ncan also declare a return type. Rather than writing `|x| { ... }` you can write\n`|x: i32| -> String { ... }`. Whether an argument is owned or borrowed is \ndetermined by the types (either declared or inferred).\n\nFor the captured variables, the type is mostly known from the environment, but\nRust does a little extra magic. Should a variable be captured by reference or\nvalue? Rust infers this from the body of the closure. If possible, Rust captures\nby reference. E.g.,\n\n```rust\nfn foo(x: Bar) {\n    let f = || { ... x ... };\n}\n```\n\nAll being well, in the body of `f`, `x` has the type `&Bar` with a lifetime\nbounded by the scope of `foo`. However, if `x` is mutated, then Rust will infer\nthat the capture is by mutable reference, i.e., `x` has type `&mut Bar`. If `x`\nis moved in `f` (e.g., is stored into a variable or field with value type), then\nRust infers that the variable must be captured by value, i.e., it has the type\n`Bar`.\n\nThis can be overridden by the programmer (sometimes necessary if the closure\nwill be stored in a field or returned from a function). By using the `move`\nkeyword in front of a closure. Then, all of the captured variables are captured\nby value. E.g., in `let f = move || { ... x ... };`, `x` would always have type\n`Bar`.\n\nWe talked earlier about the different function kinds: `Fn`, `FnMut`, and `FnOnce`.\nWe can now explain why we need them. For closures, the mutable-ness and once-ness\nrefer to the captured variables. If a capture mutates any of the variables it\ncaptures then it will have a `FnMut` type (note that this is completely inferred\nby the compiler, no annotation is necessary). If a variable is moved into a\nclosure, i.e., it is captured by value (either because of an explicit `move` or\ndue to inference), then the closure will have a `FnOnce` type. It would be unsafe\nto call such a closure multiple times because the captured variable would be\nmoved more than once.\n\nRust will do its best to infer the most flexible type for the closure if it can.\n\n\n## Implementation\n\nA closure is implemented as an anonymous struct. That struct has a field for\neach variable captured by the closure. It is lifetime-parametric with a single\nlifetime parameter which is a bound on the lifetime of captured variables. The\nanonymous struct implements a `call` method which is called to execute the\nclosure.\n\nFor example, consider\n\n```rust\nfn main() {\n    let x = Foo { ... };\n    let f = |y| x.get_number() + y;\n    let z = f(42);\n}\n```\n\nthe compiler treats this as\n\n```rust\nstruct Closure14<'env> {\n    x: &'env Foo,\n}\n\n// Not actually implemented like this, see below.\nimpl<'env> Closure14<'env> {\n    fn call(&self, y: i32) -> i32 {\n        self.x.get_number() + y\n    }\n}\n\nfn main() {\n    let x = Foo { ... };\n    let f = Closure14 { x: x }\n    let z = f.call(42);\n}\n```\n\nAs we mentioned above, there are three different function traits - `Fn`,\n`FnMut`, and `FnOnce`. In reality the `call` method is required by these traits\nrather than being in an inherent impl. `Fn` has a method `call` which takes\n`self` by reference, `FnMut` has `call_mut` taking `self` by mutable reference,\nand `FnOnce` has `call_once` which takes `self` by values.\n\nWhen we've seen function types above, they look like `Fn(i32) -> i32` which\ndoesn't look much like a trait type. There is a little bit of magic here. Rust allows\nthis round bracket sugar only for function types. To desugar to a regular type\n(an 'angle bracket type'), the argument types are treated as a tuple type and\npassed as a type parameter and the return type as an associated type called\n`Output`. So, `Fn(i32) -> i32` is desugared to `Fn<(i32,), Output=i32>` and the\n`Fn` trait definition looks like\n\n```rust\npub trait Fn<Args> : FnMut<Args> {\n    fn call(&self, args: Args) -> Self::Output;\n}\n```\n\nThe implementation for `Closure14` above would therefore look more like\n\n```rust\nimpl<'env> FnOnce<(i32,)> for Closure14<'env> {\n    type Output = i32;\n    fn call_once(self, args: (i32,)) -> i32 {\n        ...\n    }\n}\nimpl<'env> FnMut<(i32,)> for Closure14<'env> {\n    fn call_mut(&mut self, args: (i32,)) -> i32 {\n        ...\n    }\n}\nimpl<'env> Fn<(i32,)> for Closure14<'env> {\n    fn call(&self, args: (i32,)) -> i32 {\n        ...\n    }\n}\n```\n\nYou can find the function traits in\n[core::ops](https://dxr.mozilla.org/rust/source/src/libcore/ops.rs)\n\nWe talked above about how using generics gives static dispatch and using trait\nobjects gives virtual dispatch. We can now see in a bit more detail why.\n\nWhen we call `call`, it is a statically dispatched method call, there is no\nvirtual dispatch. If we pass it to a monomorphised function, we still know the\ntype statically, and we still get a static dispatch.\n\nWe can make the closure into a trait object, e.g., `&f` or `Box::new(f)` with\ntypes `&Fn(i32)->i32` or `Box<Fn(i32)->i32>`. These are pointer types, and\nbecause they are pointer-to-trait types, the pointers are fat pointers. That\nmeans they consist of the pointer to the data itself and a pointer to a vtable.\nThe vtable is used to lookup the address of `call` (or `call_mut` or whatever).\n\nYou'll sometimes hear these two representations of closures called boxed and\nunboxed closures. An unboxed closure is the by-value version with static\ndispatch. A boxed version is the trait object version with dynamic dispatch. In\nthe olden days, Rust only had boxed closures (and the system was quite a bit\ndifferent).\n\n## References\n\n* [RFC 114 - Closures](https://github.com/rust-lang/rfcs/blob/master/text/0114-closures.md)\n* [Finding Closure in Rust blog post](http://huonw.github.io/blog/2015/05/finding-closure-in-rust/)\n* [RFC 387 - Higher ranked trait bounds](https://github.com/rust-lang/rfcs/blob/master/text/0387-higher-ranked-trait-bounds.md)\n* [Purging proc blog post](http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/)\n\nFIXME: relate to closures in C++ 11\n"
        },
        {
          "name": "compile_pdf.sh",
          "type": "blob",
          "size": 0.2158203125,
          "content": "#!/usr/bin/env bash\n\npandoc -s README.md hello-world.md control-flow.md primitives.md unique.md borrowed.md data-types.md rc-raw.md destructuring.md destructuring-2.md arrays.md graphs/README.md closures.md -o r4cppp.pdf\n"
        },
        {
          "name": "control-flow.md",
          "type": "blob",
          "size": 6.828125,
          "content": "# Control flow\n\n## If\n\nThe `if` statement is pretty much the same in Rust as C++. One difference is\nthat the braces are mandatory, but parentheses around the expression being tested\nare not. Another is that `if` is an expression, so you can use it the same way\nas the ternary `?:` operator in C++ (remember from the previous section that if the last\nexpression in a block is not terminated by a semi-colon, then it becomes the\nvalue of the block). There is no ternary `?:` in Rust. So, the following two\nfunctions do the same thing:\n\n```rust\nfn foo(x: i32) -> &'static str {\n    let result: &'static str;\n    if x < 10 {\n        result = \"less than 10\";\n    } else {\n        result = \"10 or more\";\n    }\n    return result;\n}\n\nfn bar(x: i32) -> &'static str {\n    if x < 10 {\n        \"less than 10\"\n    } else {\n        \"10 or more\"\n    }\n}\n```\n\n(Why not `mut result`? The code in `foo` makes `result` immutable, it's just initialized in two possible places. Rust can see that by the time of `return result`, it is guaranteed to have been initialized.)\n\nThe first is a fairly literal translation of what you might write in C++. The\nsecond is better Rust style.\n\nYou can also write `let result = if x < 10 ...`, etc.\n\n\n## Loops\n\nRust has while loops, again just like C++:\n\n```rust\nfn main() {\n    let mut x = 10;\n    while x > 0 {\n        println!(\"Current value: {}\", x);\n        x -= 1;\n    }\n}\n```\n\nThere is no `do...while` loop in Rust, but there is the `loop` statement which\njust loops forever:\n\n```rust\nfn main() {\n    loop {\n        println!(\"Just looping\");\n    }\n}\n```\n\nRust has `break` and `continue` just like C++.\n\n\n## For loops\n\nRust also has `for` loops, but these are a bit different. Let's say you have a\nvector of integers and you want to print them all (we'll cover vectors/arrays,\niterators, and generics in more detail in the future. For now, know that a\n`Vec<T>` is a sequence of `T`s and `iter()` returns an iterator from anything\nyou might reasonably want to iterate over). A simple `for` loop would look like:\n\n```rust\nfn print_all(all: Vec<i32>) {\n    for a in all.iter() {\n        println!(\"{}\", a);\n    }\n}\n```\n\nTODO also &all/all instead of all.iter()\n\nIf we want to index over the indices of `all` (a bit more like a standard C++\nfor loop over an array), you could do\n\n```rust\nfn print_all(all: Vec<i32>) {\n    for i in 0..all.len() {\n        println!(\"{}: {}\", i, all[i]);\n    }\n}\n```\n\nHopefully, it is obvious what the `len` function does. TODO range notation\n\nA more Rust-like equivalent of the preceding example would be to use an\nenumerating iterator:\n\n```rust\nfn print_all(all: Vec<i32>) {\n    for (i, a) in all.iter().enumerate() {\n        println!(\"{}: {}\", i, a);\n    }\n}\n```\n\nWhere `enumerate()` chains from the iterator `iter()` and yields the current\ncount and the element during iteration.\n\n*The following example incorporates more advanced topics covered in the section\non [Borrowed Pointers](borrowed.md).* Let's say you have a vector of integers\nand want to call the function, passing the vector by reference and have the\nvector modified in place. Here the `for` loop uses a mutable iterator which\ngives mutable refererences - the `*` dereferencing should be familiar to C++\nprogrammers:\n\n```rust\nfn double_all(all: &mut Vec<i32>) {\n    for a in all.iter_mut() {\n        *a += *a;\n    }\n}\n```\n\n\n## Switch/Match\n\nRust has a match expression which is similar to a C++ switch statement, but much\nmore powerful. This simple version should look pretty familiar:\n\n```rust\nfn print_some(x: i32) {\n    match x {\n        0 => println!(\"x is zero\"),\n        1 => println!(\"x is one\"),\n        10 => println!(\"x is ten\"),\n        y => println!(\"x is something else {}\", y),\n    }\n}\n```\n\nThere are some syntactic differences - we use `=>` to go from the matched value\nto the expression to execute, and the match arms are separated by `,` (that last\n`,` is optional). There are also some semantic differences which are not so\nobvious: the matched patterns must be exhaustive, that is all possible values of\nthe matched expression (`x` in the above example) must be covered. Try removing\nthe `y => ...` line and see what happens; that is because we only have matches\nfor 0, 1, and 10, but there are obviously lots of other integers which don't get\nmatched. In that last arm, `y` is bound to the value being matched (`x` in this\ncase). We could also write:\n\n```rust\nfn print_some(x: i32) {\n    match x {\n        x => println!(\"x is something else {}\", x)\n    }\n}\n```\n\nHere the `x` in the match arm introduces a new variable which hides the argument\n`x`, just like declaring a variable in an inner scope.\n\nIf we don't want to name the variable, we can use `_` for an unnamed variable,\nwhich is like having a wildcard match. If we don't want to do anything, we can\nprovide an empty branch:\n\n```rust\nfn print_some(x: i32) {\n    match x {\n        0 => println!(\"x is zero\"),\n        1 => println!(\"x is one\"),\n        10 => println!(\"x is ten\"),\n        _ => {}\n    }\n}\n```\n\nAnother semantic difference is that there is no fall through from one arm to the\nnext so it works like `if...else if...else`.\n\nWe'll see in later posts that match is extremely powerful. For now I want to\nintroduce just a couple more features - the 'or' operator for values and `if`\nclauses on arms. Hopefully an example is self-explanatory:\n\n```rust\nfn print_some_more(x: i32) {\n    match x {\n        0 | 1 | 10 => println!(\"x is one of zero, one, or ten\"),\n        y if y < 20 => println!(\"x is less than 20, but not zero, one, or ten\"),\n        y if y == 200 => println!(\"x is 200 (but this is not very stylish)\"),\n        _ => {}\n    }\n}\n```\n\nJust like `if` expressions, `match` statements are actually expressions so we\ncould re-write the last example as:\n\n```rust\nfn print_some_more(x: i32) {\n    let msg = match x {\n        0 | 1 | 10 => \"one of zero, one, or ten\",\n        y if y < 20 => \"less than 20, but not zero, one, or ten\",\n        y if y == 200 => \"200 (but this is not very stylish)\",\n        _ => \"something else\"\n    };\n\n    println!(\"x is {}\", msg);\n}\n```\n\nNote the semi-colon after the closing brace, that is because the `let` statement\nis a statement and must take the form `let msg = ...;`. We fill the rhs with a\nmatch expression (which doesn't usually need a semi-colon), but the `let`\nstatement does. This catches me out all the time.\n\nMotivation: Rust match statements avoid the common bugs with C++ switch\nstatements - you can't forget a `break` and unintentionally fall through; if you\nadd a case to an enum (more later on) the compiler will make sure it is covered\nby your `match` statement.\n\n\n## Method call\n\nFinally, just a quick note that methods exist in Rust, similarly to C++. They\nare always called via the `.` operator (no `->`, more on this in another post).\nWe saw a few examples above (`len`, `iter`). We'll go into more detail in the\nfuture about how they are defined and called. Most assumptions you might make\nfrom C++ or Java are probably correct.\n"
        },
        {
          "name": "data-types.md",
          "type": "blob",
          "size": 11.767578125,
          "content": "# Data types\n\nIn this post I'll discuss Rust's data types. These are roughly equivalent to\nclasses, structs, and enums in C++. One difference with Rust is that data and\nbehaviour are much more strictly separated in Rust than C++ (or Java, or other\nOO languages). Behaviour is defined by functions and those can be defined in\ntraits and `impl`s (implementations), but traits cannot contain data, they are\nsimilar to Java's interfaces in that respect. I'll cover traits and impls in a\nlater post, this one is all about data.\n\n## Structs\n\nA rust struct is similar to a C struct or a C++ struct without methods. Simply a\nlist of named fields. The syntax is best seen with an example:\n\n```rust\nstruct S {\n    field1: i32,\n    field2: SomeOtherStruct\n}\n```\n\nHere we define a struct called `S` with two fields. The fields are comma\nseparated; if you like, you can comma-terminate the last field too.\n\nStructs introduce a type. In the example, we could use `S` as a type.\n`SomeOtherStruct` is assumed to be another struct (used as a type in the\nexample), and (like C++) it is included by value, that is, there is no pointer\nto another struct object in memory.\n\nFields in structs are accessed using the `.` operator and their name. An example\nof struct use:\n\n```rust\nfn foo(s1: S, s2: &S) {\n    let f = s1.field1;\n    if f == s2.field1 {\n        println!(\"field1 matches!\");\n    }\n}\n```\n\nHere `s1` is struct object passed by value and `s2` is a struct object passed by\nreference. As with method calls, we use the same `.` to access fields in both, no\nneed for `->`.\n\nStructs are initialised using struct literals. These are the name of the struct\nand values for each field. For example,\n\n```rust\nfn foo(sos: SomeOtherStruct) {\n    let x = S { field1: 45, field2: sos };  // initialise x with a struct literal\n    println!(\"x.field1 = {}\", x.field1);\n}\n```\n\nStructs cannot be recursive; that is, you can't have cycles of struct names\ninvolving definitions and field types. This is because of the value semantics of\nstructs. So for example, `struct R { r: Option<R> }` is illegal and will cause a\ncompiler error (see below for more about Option). If you need such a structure\nthen you should use some kind of pointer; cycles with pointers are allowed:\n\n```rust\nstruct R {\n    r: Option<Box<R>>\n}\n```\n\nIf we didn't have the `Option` in the above struct, there would be no way to\ninstantiate the struct and Rust would signal an error.\n\nStructs with no fields do not use braces in either their definition or literal\nuse. Definitions do need a terminating semi-colon though, presumably just to\nfacilitate parsing.\n\n```rust\nstruct Empty;\n\nfn foo() {\n    let e = Empty;\n}\n```\n\n## Tuples\n\nTuples are anonymous, heterogeneous sequences of data. As a type, they are\ndeclared as a sequence of types in parentheses. Since there is no name, they are\nidentified by structure. For example, the type `(i32, i32)` is a pair of\nintegers and `(i32, f32, S)` is a triple. Tuple values are initialised in the\nsame way as tuple types are declared, but with values instead of types for the\ncomponents, e.g., `(4, 5)`. An example:\n\n```rust\n// foo takes a struct and returns a tuple\nfn foo(x: SomeOtherStruct) -> (i32, f32, S) {\n    (23, 45.82, S { field1: 54, field2: x })\n}\n```\n\nTuples can be used by destructuring using a `let` expression, e.g.,\n\n```rust\nfn bar(x: (i32, i32)) {\n    let (a, b) = x;\n    println!(\"x was ({}, {})\", a, b);\n}\n```\n\nWe'll talk more about destructuring next time.\n\n\n## Tuple structs\n\nTuple structs are named tuples, or alternatively, structs with unnamed fields.\nThey are declared using the `struct` keyword, a list of types in parentheses,\nand a semicolon. Such a declaration introduces their name as a type. Their\nfields must be accessed by destructuring (like a tuple), rather than by name.\nTuple structs are not very common.\n\n```rust\nstruct IntPoint (i32, i32);\n\nfn foo(x: IntPoint) {\n    let IntPoint(a, b) = x;  // Note that we need the name of the tuple\n                             // struct to destructure.\n    println!(\"x was ({}, {})\", a, b);\n}\n```\n\n## Enums\n\nEnums are types like C++ enums or unions, in that they are types which can take\nmultiple values. The simplest kind of enum is just like a C++ enum:\n\n```rust\nenum E1 {\n    Var1,\n    Var2,\n    Var3\n}\n\nfn foo() {\n    let x: E1 = Var2;\n    match x {\n        Var2 => println!(\"var2\"),\n        _ => {}\n    }\n}\n```\n\nHowever, Rust enums are much more powerful than that. Each variant can contain\ndata. Like tuples, these are defined by a list of types. In this case they are\nmore like unions than enums in C++. Rust enums are tagged unions rather than untagged unions (as in C++).\nThat means you can't mistake one variant of an enum for another at runtime[^1]. An example:\n\n```rust\nenum Expr {\n    Add(i32, i32),\n    Or(bool, bool),\n    Lit(i32)\n}\n\nfn foo() {\n    let x = Or(true, false);   // x has type Expr\n}\n```\n\nMany simple cases of object-oriented polymorphism are better handled in Rust\nusing enums.\n\nTo use enums we usually use a match expression. Remember that these are similar\nto C++ switch statements. I'll go into more depth on these and other ways to\ndestructure data next time. Here's an example:\n\n```rust\nfn bar(e: Expr) {\n    match e {\n        Add(x, y) => println!(\"An `Add` variant: {} + {}\", x, y),\n        Or(..) => println!(\"An `Or` variant\"),\n        _ => println!(\"Something else (in this case, a `Lit`)\"),\n    }\n}\n```\n\nEach arm of the match expression matches a variant of `Expr`. All variants must\nbe covered. The last case (`_`) covers all remaining variants, although in the\nexample there is only `Lit`. Any data in a variant can be bound to a variable.\nIn the `Add` arm we are binding the two i32s in an `Add` to `x` and `y`. If we\ndon't care about the data, we can use `..` to match any data, as we do for `Or`.\n\n\n## Option\n\nOne particularly common enum in Rust is `Option`. This has two variants - `Some`\nand `None`. `None` has no data and `Some` has a single field with type `T`\n(`Option` is a generic enum, which we will cover later, but hopefully the\ngeneral idea is clear from C++). Options are used to indicate a value might be\nthere or might not. Any place you use a null pointer in C++[^2]\nto indicate a value which is in some way undefined, uninitialised, or false,\nyou should probably use an Option in Rust. Using Option is safer because you\nmust always check it before use; there is no way to do the equivalent of\ndereferencing a null pointer. They are also more general, you can use them with\nvalues as well as pointers. An example:\n\n```rust\nuse std::rc::Rc;\n\nstruct Node {\n    parent: Option<Rc<Node>>,\n    value: i32\n}\n\nfn is_root(node: Node) -> bool {\n    match node.parent {\n        Some(_) => false,\n        None => true\n    }\n}\n```\n\nHere, the parent field could be either a `None` or a `Some` containing an\n`Rc<Node>`. In the example, we never actually use that payload, but in real life\nyou usually would.\n\n\nThere are also convenience methods on Option, so you could write the body of\n`is_root` as `node.parent.is_none()` or `!node.parent.is_some()`.\n\n## Inherited mutability and Cell/RefCell\n\nLocal variables in Rust are immutable by default and can be marked mutable using\n`mut`. We don't mark fields in structs or enums as mutable, their mutability is\ninherited. This means that a field in a struct object is mutable or immutable\ndepending on whether the object itself is mutable or immutable. Example:\n\n```rust\nstruct S1 {\n    field1: i32,\n    field2: S2\n}\nstruct S2 {\n    field: i32\n}\n\nfn main() {\n    let s = S1 { field1: 45, field2: S2 { field: 23 } };\n    // s is deeply immutable, the following mutations are forbidden\n    // s.field1 = 46;\n    // s.field2.field = 24;\n\n    let mut s = S1 { field1: 45, field2: S2 { field: 23 } };\n    // s is mutable, these are OK\n    s.field1 = 46;\n    s.field2.field = 24;\n}\n```\n\nInherited mutability in Rust stops at references. This is similar to C++ where\nyou can modify a non-const object via a pointer from a const object. If you want\na reference field to be mutable, you have to use `&mut` on the field type:\n\n```rust\nstruct S1 {\n    f: i32\n}\nstruct S2<'a> {\n    f: &'a mut S1   // mutable reference field\n}\nstruct S3<'a> {\n    f: &'a S1       // immutable reference field\n}\n\nfn main() {\n    let mut s1 = S1{f:56};\n    let s2 = S2 { f: &mut s1};\n    s2.f.f = 45;   // legal even though s2 is immutable\n    // s2.f = &mut s1; // illegal - s2 is not mutable\n    let s1 = S1{f:56};\n    let mut s3 = S3 { f: &s1};\n    s3.f = &s1;     // legal - s3 is mutable\n    // s3.f.f = 45; // illegal - s3.f is immutable\n}\n```\n\n(The `'a` parameter on `S2` and `S3` is a lifetime parameter, we'll cover those soon).\n\nSometimes whilst an object is logically immutable, it has parts which need to be\ninternally mutable. Think of various kinds of caching or a reference count\n(which would not give true logical immutability since the effect of changing the\nref count can be observed via destructors). In C++, you would use the `mutable`\nkeyword to allow such mutation even when the object is const. In Rust we have\nthe Cell and RefCell structs. These allow parts of immutable objects to be\nmutated. Whilst that is useful, it means you need to be aware that when you see\nan immutable object in Rust, it is possible that some parts may actually be\nmutable.\n\nRefCell and Cell let you get around Rust's strict rules on mutation and\naliasability. They are safe to use because they ensure that Rust's invariants\nare respected dynamically, even though the compiler cannot ensure that those\ninvariants hold statically. Cell and RefCell are both single threaded objects.\n\nUse Cell for types which have copy semantics (pretty much just primitive types).\nCell has `get` and `set` methods for changing the stored value, and a `new`\nmethod to initialise the cell with a value. Cell is a very simple object - it\ndoesn't need to do anything smart since objects with copy semantics can't keep\nreferences elsewhere (in Rust) and they can't be shared across threads, so there\nis not much to go wrong.\n\nUse RefCell for types which have move semantics, that means nearly everything in\nRust, struct objects are a common example. RefCell is also created using `new`\nand has a `set` method. To get the value in a RefCell, you must borrow it using\nthe borrow methods (`borrow`, `borrow_mut`, `try_borrow`, `try_borrow_mut`)\nthese will give you a borrowed reference to the object in the RefCell. These\nmethods follow the same rules as static borrowing - you can only have one\nmutable borrow, and can't borrow mutably and immutably at the same time.\nHowever, rather than a compile error you get a runtime failure. The `try_`\nvariants return an Option - you get `Some(val)` if the value can be borrowed and\n`None` if it can't. If a value is borrowed, calling `set` will fail too.\n\nHere's an example using a ref-counted pointer to a RefCell (a common use-case):\n\n```rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nstruct S {\n    field: i32\n}\n\nfn foo(x: Rc<RefCell<S>>) {\n    {\n        let s = x.borrow();\n        println!(\"the field, twice {} {}\", s.field, x.borrow().field);\n        // let s = x.borrow_mut(); // Error - we've already borrowed the contents of x\n    }\n\n    let mut s = x.borrow_mut(); // OK, the earlier borrows are out of scope\n    s.field = 45;\n    // println!(\"The field {}\", x.borrow().field); // Error - can't mut and immut borrow\n    println!(\"The field {}\", s.field);\n}\n\nfn main() {\n    let s = S{field:12};\n    let x: Rc<RefCell<S>> = Rc::new(RefCell::new(s));\n    foo(x.clone());\n\n    println!(\"The field {}\", x.borrow().field);\n}\n```\n\nIf you're using Cell/RefCell, you should try to put them on the smallest object\nyou can. That is, prefer to put them on a few fields of a struct, rather than\nthe whole struct. Think of them like single threaded locks, finer grained\nlocking is better since you are more likely to avoid colliding on a lock.\n\n\n[^1]: In C++17 there is `std::variant<T>` type that is closer to Rust enums than unions.\n\n[^2]: Since C++17 `std::optional<T>` is the best alternative of Option in Rust.\n"
        },
        {
          "name": "destructuring-2.md",
          "type": "blob",
          "size": 10.337890625,
          "content": "# Destructuring pt2 - match and borrowing\n\nWhen destructuring there are some surprises in store where borrowing is\nconcerned. Hopefully, nothing surprising once you understand borrowed references\nreally well, but worth discussing (it took me a while to figure out, that's for\nsure. Longer than I realised, in fact, since I screwed up the first version of\nthis blog post).\n\nImagine you have some `&Enum` variable `x` (where `Enum` is some enum type). You\nhave two choices: you can match `*x` and list all the variants (`Variant1 =>\n...`, etc.) or you can match `x` and list reference to variant patterns\n(`&Variant1 => ...`, etc.). (As a matter of style, prefer the first form where\npossible since there is less syntactic noise). `x` is a borrowed reference and\nthere are strict rules for how a borrowed reference can be dereferenced, these\ninteract with match expressions in surprising ways (at least surprising to me),\nespecially when you are modifying an existing enum in a seemingly innocuous way\nand then the compiler explodes on a match somewhere.\n\nBefore we get into the details of the match expression, lets recap Rust's rules\nfor value passing. In C++, when assigning a value into a variable or passing it\nto a function there are two choices - pass-by-value and pass-by-reference. The\nformer is the default case and means a value is copied either using a copy\nconstructor or a bitwise copy. If you annotate the destination of the parameter\npass or assignment with `&`, then the value is passed by reference - only a\npointer to the value is copied and when you operate on the new variable, you are\nalso operating on the old value.\n\nRust has the pass-by-reference option, although in Rust the source as well as\nthe destination must be annotated with `&`. For pass-by-value in Rust, there are\ntwo further choices - copy or move. A copy is the same as C++'s semantics\n(except that there are no copy constructors in Rust). A move copies the value\nbut destroys the old value - Rust's type system ensures you can no longer access\nthe old value. As examples, `i32` has copy semantics and `Box<i32>` has move\nsemantics:\n\n```rust\nfn foo() {\n    let x = 7i32;\n    let y = x;                // x is copied\n    println!(\"x is {}\", x);   // OK\n\n    let x = Box::new(7i32);\n    let y = x;                // x is moved\n    //println!(\"x is {}\", x); // error: use of moved value: `x`\n}\n```\n\nYou can also choose to have copy semantics for user-defined types\nby implementing the `Copy` trait. One straightforward way to do that is \nto add `#[derive(Copy)]` before the definition of the `struct`. Not all\nuser-defined types are allowed to implement the `Copy` trait. All fields of \na type must implement `Copy` and the type must not have a destructor. \nDestructors probably need a post of their own, but for now, an object \nin Rust has a destructor if it implements the `Drop`trait. \nJust like C++, the destructor is executed just before an object is \ndestroyed.\n\nNow, it is important that a borrowed object is not moved, otherwise you would\nhave a reference to the old object which is no longer valid. This is equivalent\nto holding a reference to an object which has been destroyed after going out of\nscope - it is a kind of dangling pointer. If you have a pointer to an object,\nthere could be other references to it. So if an object has move semantics and\nyou have a pointer to it, it is unsafe to dereference that pointer. (If the\nobject has copy semantics, dereferencing creates a copy and the old object will\nstill exist, so other references will be fine).\n\nOK, back to match expressions. As I said earlier, if you want to match some `x`\nwith type `&T` you can dereference once in the match clause or match the\nreference in every arm of the match expression. Example:\n\n```rust\nenum Enum1 {\n    Var1,\n    Var2,\n    Var3\n}\n\nfn foo(x: &Enum1) {\n    match *x {  // Option 1: deref here.\n        Enum1::Var1 => {}\n        Enum1::Var2 => {}\n        Enum1::Var3 => {}\n    }\n\n    match x {\n        // Option 2: 'deref' in every arm.\n        &Enum1::Var1 => {}\n        &Enum1::Var2 => {}\n        &Enum1::Var3 => {}\n    }\n}\n```\n\nIn this case you can take either approach because `Enum1` has copy semantics.\nLet's take a closer look at each approach: in the first approach we dereference\n`x` to a temporary variable with type `Enum1` (which copies the value in `x`)\nand then do a match against the three variants of `Enum1`. This is a 'one level'\nmatch because we don't go deep into the value's type. In the second approach\nthere is no dereferencing. We match a value with type `&Enum1` against a\nreference to each variant. This match goes two levels deep - it matches the type\n(always a reference) and looks inside the type to match the referred type (which\nis `Enum1`).\n\nEither way, we must ensure that we (that is, the compiler) respect \nRust's invariants around moves and references - we must not move any\npart of an object if it is referenced. If the value being matched has copy\nsemantics, that is trivial. If it has move semantics then we must make sure that\nmoves don't happen in any match arm. This is accomplished either by ignoring\ndata which would move, or making references to it (so we get by-reference\npassing rather than by-move).\n\n```rust\nenum Enum2 {\n    // Box has a destructor so Enum2 has move semantics.\n    Var1(Box<i32>),\n    Var2,\n    Var3\n}\n\nfn foo(x: &Enum2) {\n    match *x {\n        // We're ignoring nested data, so this is OK\n        Enum2::Var1(..) => {}\n        // No change to the other arms.\n        Enum2::Var2 => {}\n        Enum2::Var3 => {}\n    }\n\n    match x {\n        // We're ignoring nested data, so this is OK\n        &Enum2::Var1(..) => {}\n        // No change to the other arms.\n        &Enum2::Var2 => {}\n        &Enum2::Var3 => {}\n    }\n}\n```\n\nIn either approach we don't refer to any of the nested data, so none of it is\nmoved. In the first approach, even though `x` is referenced, we don't touch its\ninnards in the scope of the dereference (i.e., the match expression) so nothing\ncan escape. We also don't bind the whole value (i.e., bind `*x` to a variable),\nso we can't move the whole object either.\n\nWe can take a reference to any variant in the second match, but not in the\ndereferenced version. So, in the second approach replacing the second arm with `a\n@ &Var2 => {}` is OK (`a` is a reference), but under the first approach we\ncouldn't write `a @ Var2 => {}` since that would mean moving `*x` into `a`. We\ncould write `ref a @ Var2 => {}` (in which `a` is also a reference), although\nit's not a construct you see very often.\n\nBut what about if we want to use the data nested inside `Var1`? We can't write:\n\n```rust\nmatch *x {\n    Enum2::Var1(y) => {}\n    _ => {}\n}\n```\n\nor\n\n```rust\nmatch x {\n    &Enum2::Var1(y) => {}\n    _ => {}\n}\n```\n\nbecause in both cases it means moving part of `x` into `y`. We can use the 'ref'\nkeyword to get a reference to the data in `Var1`: `&Var1(ref y) => {}`. That is\nOK, because now we are not dereferencing anywhere and thus not moving any part\nof `x`. Instead we are creating a pointer which points into the interior of `x`.\n\nAlternatively, we could destructure the Box (this match is going three levels\ndeep): `&Var1(box y) => {}` (note `box` pattern syntax is experimental as of rustc 1.58 \nand is available only in nightly version of rustc). \nThis is OK because `i32` has copy semantics and `y`\nis a copy of the `i32` inside the `Box` inside `Var1` (which is 'inside' a\nborrowed reference). Since `i32` has copy semantics, we don't need to move any\npart of `x`. We could also create a reference to the int rather than copy it:\n`&Var1(box ref y) => {}`. Again, this is OK, because we don't do any\ndereferencing and thus don't need to move any part of `x`. If the contents of\nthe Box had move semantics, then we could not write `&Var1(box y) => {}`, we\nwould be forced to use the reference version. We could also use similar\ntechniques with the first approach to matching, which look the same but without\nthe first `&`. For example, `Var1(box ref y) => {}`.\n\nNow lets get more complex. Lets say you want to match against a pair of\nreference-to-enum values. Now we can't use the first approach at all:\n\n```rust\nfn bar(x: &Enum2, y: &Enum2) {\n    // Error: x and y are being moved.\n    // match (*x, *y) {\n    //     (Enum2::Var2, _) => {}\n    //     _ => {}\n    // }\n\n    // OK.\n    match (x, y) {\n        (&Enum2::Var2, _) => {}\n        _ => {}\n    }\n}\n```\n\nThe first approach is illegal because the value being matched is created by\ndereferencing `x` and `y` and then moving them both into a new tuple object. So\nin this circumstance, only the second approach works. And of course, you still\nhave to follow the rules above for avoiding moving parts of `x` and `y`.\n\nIf you do end up only being able to get a reference to some data and you need\nthe value itself, you have no option except to copy that data. Usually that\nmeans using `clone()`. If the data doesn't implement clone, you're going to have\nto further destructure to make a manual copy or implement clone yourself.\n\nWhat if we don't have a reference to a value with move semantics, but the value\nitself. Now moves are OK, because we know no one else has a reference to the\nvalue (the compiler ensures that if they do, we can't use the value). For\nexample,\n\n```rust\nfn baz(x: Enum2) {\n    match x {\n        Enum2::Var1(y) => {}\n        _ => {}\n    }\n}\n```\n\nThere are still a few things to be aware of. Firstly, you can only move to one\nplace. In the above example we are moving part of `x` into `y` and we'll forget\nabout the rest. If we wrote `a @ Var1(y) => {}` we would be attempting to move\nall of `x` into `a` and part of `x` into `y`. That is not allowed, an arm like\nthat is illegal. Making one of `a` or `y` a reference (using `ref a`, etc.) is\nnot an option either, then we'd have the problem described above where we move\nwhilst holding a reference. We can make both `a` and `y` references and then\nwe're OK - neither is moving, so `x` remains intact and we have pointers to the\nwhole and a part of it.\n\nSimilarly (and more common), if we have a variant with multiple pieces of nested\ndata, we can't take a reference to one datum and move another. For example if we\nhad a `Var4` declared as `Var4(Box<int>, Box<int>)` we can have a match arm\nwhich references both (`Var4(ref y, ref z) => {}`) or a match arm which moves\nboth (`Var4(y, z) => {}`) but you cannot have a match arm which moves one and\nreferences the other (`Var4(ref y, z) => {}`). This is because a partial move\nstill destroys the whole object, so the reference would be invalid.\n"
        },
        {
          "name": "destructuring.md",
          "type": "blob",
          "size": 6.091796875,
          "content": "# Destructuring\n\nLast time we looked at Rust's data types. Once you have some data inside a structure, you\nwill want to get that data out. For structs, Rust has field access, just like\nC++. For tuples, tuple structs, and enums you must use destructuring (there are\nvarious convenience functions in the library, but they use destructuring\ninternally). Destructuring of data structures exists in C++ only since C++17, so\nit most likely familiar from languages such as Python or various functional\nlanguages.  The idea is that just as you can initialize a data structure by\nfilling out its fields with data from a bunch of local variables, you can fill\nout a bunch of local variables with data from a data structure.  From this\nsimple beginning, destructuring has become one of Rust's most powerful\nfeatures. To put it another way, destructuring combines pattern matching with\nassignment into local variables.\n\nDestructuring is done primarily through the let and match statements. The match\nstatement is used when the structure being destructured can have different\nvariants (such as an enum). A let expression pulls the variables out into the\ncurrent scope, whereas match introduces a new scope. To compare:\n\n```rust\nfn foo(pair: (int, int)) {\n    let (x, y) = pair;\n    // we can now use x and y anywhere in foo\n\n    match pair {\n        (x, y) => {\n            // x and y can only be used in this scope\n        }\n    }\n}\n```\n\nThe syntax for patterns (used after `let` and before `=>` in the above example)\nin both cases is (pretty much) the same. You can also use these patterns in\nargument position in function declarations:\n\n```rust\nfn foo((x, y): (int, int)) {\n}\n```\n\n(Which is more useful for structs or tuple-structs than tuples).\n\nMost initialisation expressions can appear in a destructuring pattern and they\ncan be arbitrarily complex. That can include references and primitive literals\nas well as data structures. For example,\n\n```rust\nstruct St {\n    f1: int,\n    f2: f32\n}\n\nenum En {\n    Var1,\n    Var2,\n    Var3(int),\n    Var4(int, St, int)\n}\n\nfn foo(x: &En) {\n    match x {\n        &Var1 => println!(\"first variant\"),\n        &Var3(5) => println!(\"third variant with number 5\"),\n        &Var3(x) => println!(\"third variant with number {} (not 5)\", x),\n        &Var4(3, St { f1: 3, f2: x }, 45) => {\n            println!(\"destructuring an embedded struct, found {} in f2\", x)\n        }\n        &Var4(_, ref x, _) => {\n            println!(\"Some other Var4 with {} in f1 and {} in f2\", x.f1, x.f2)\n        }\n        _ => println!(\"other (Var2)\")\n    }\n}\n```\n\nNote how we destructure through a reference by using `&` in the patterns and how\nwe use a mix of literals (`5`, `3`, `St { ... }`), wildcards (`_`), and\nvariables (`x`).\n\nYou can use `_` wherever a variable is expected if you want to ignore a single\nitem in a pattern, so we could have used `&Var3(_)` if we didn't care about the\ninteger. In the first `Var4` arm we destructure the embedded struct (a nested\npattern) and in the second `Var4` arm we bind the whole struct to a variable.\nYou can also use `..` to stand in for all fields of a tuple or struct. So if you\nwanted to do something for each enum variant but don't care about the content of\nthe variants, you could write:\n\n```rust\nfn foo(x: En) {\n    match x {\n        Var1 => println!(\"first variant\"),\n        Var2 => println!(\"second variant\"),\n        Var3(..) => println!(\"third variant\"),\n        Var4(..) => println!(\"fourth variant\")\n    }\n}\n```\n\nWhen destructuring structs, the fields don't need to be in order and you can use\n`..` to elide the remaining fields. E.g.,\n\n```rust\nstruct Big {\n    field1: int,\n    field2: int,\n    field3: int,\n    field4: int,\n    field5: int,\n    field6: int,\n    field7: int,\n    field8: int,\n    field9: int,\n}\n\nfn foo(b: Big) {\n    let Big { field6: x, field3: y, ..} = b;\n    println!(\"pulled out {} and {}\", x, y);\n}\n```\n\nAs a shorthand with structs you can use just the field name which creates a\nlocal variable with that name. The let statement in the above example created\ntwo new local variables `x` and `y`. Alternatively, you could write\n\n```rust\nfn foo(b: Big) {\n    let Big { field6, field3, .. } = b;\n    println!(\"pulled out {} and {}\", field3, field6);\n}\n```\n\nNow we create local variables with the same names as the fields, in this case\n`field3` and `field6`.\n\nThere are a few more tricks to Rust's destructuring. Lets say you want a\nreference to a variable in a pattern. You can't use `&` because that matches a\nreference, rather than creates one (and thus has the effect of dereferencing the\nobject). For example,\n\n```rust\nstruct Foo {\n    field: &'static int\n}\n\nfn foo(x: Foo) {\n    let Foo { field: &y } = x;\n}\n```\n\nHere, `y` has type `int` and is a copy of the field in `x`.\n\nTo create a reference to something in a pattern, you use the `ref` keyword. For\nexample,\n\n```rust\nfn foo(b: Big) {\n    let Big { field3: ref x, ref field6, ..} = b;\n    println!(\"pulled out {} and {}\", *x, *field6);\n}\n```\n\nHere, `x` and `field6` both have type `&int` and are references to the fields in `b`.\n\nOne last trick when destructuring is that if you are destructuring a complex\nobject, you might want to name intermediate objects as well as individual\nfields. Going back to an earlier example, we had the pattern `&Var4(3, St{ f1:\n3, f2: x }, 45)`. In that pattern we named one field of the struct, but you\nmight also want to name the whole struct object. You could write `&Var4(3, s,\n45)` which would bind the struct object to `s`, but then you would have to use\nfield access for the fields, or if you wanted to only match with a specific\nvalue in a field you would have to use a nested match. That is not fun. Rust\nlets you name parts of a pattern using `@` syntax. For example `&Var4(3, s @ St{\nf1: 3, f2: x }, 45)` lets us name both a field (`x`, for `f2`) and the whole\nstruct (`s`).\n\nThat just about covers your options with Rust pattern matching. There are a few\nfeatures I haven't covered, such as matching vectors, but hopefully you know how\nto use `match` and `let` and have seen some of the powerful things you can do.\nNext time I'll cover some of the subtle interactions between match and borrowing\nwhich tripped me up a fair bit when learning Rust.\n"
        },
        {
          "name": "graphs",
          "type": "tree",
          "content": null
        },
        {
          "name": "hello-world.md",
          "type": "blob",
          "size": 8.2041015625,
          "content": "# Introduction - hello world!\n\nIf you are using C or C++, it is probably because you have to - either you need\nlow-level access to the system, or need every last drop of performance, or both.\nRust aims to offer the same level of abstraction around memory, the same\nperformance, but be safer and make you more productive.\n\nConcretely, there are many languages out there that you might prefer to use to\nC++: Java, Scala, Haskell, Python, and so forth, but you can't because either\nthe level of abstraction is too high (you don't get direct access to memory,\nyou are forced to use garbage collection, etc.), or there are performance issues\n(either performance is unpredictable or it's simply not fast enough). Rust does\nnot force you to use garbage collection, and as in C++, you get raw pointers to\nmemory to play with. Rust subscribes to the 'pay for what you use' philosophy of\nC++. If you don't use a feature, then you don't pay any performance overhead for\nits existence. Furthermore, all language features in Rust have a predictable (and\nusually small) cost.\n\nWhilst these constraints make Rust a (rare) viable alternative to C++, Rust also\nhas benefits: it is memory safe - Rust's type system ensures that you don't get\nthe kind of memory errors which are common in C++ - accessing un-initialised\nmemory, and dangling pointers - all are impossible in Rust. Furthermore,\nwhenever other constraints allow, Rust strives to prevent other safety issues\ntoo - for example, all array indexing is bounds checked (of course, if you want\nto avoid the cost, you can (at the expense of safety) - Rust allows you to do\nthis in unsafe blocks, along with many other unsafe things. Crucially, Rust\nensures that unsafety in unsafe blocks stays in unsafe blocks and can't affect\nthe rest of your program). Finally, Rust takes many concepts from modern\nprogramming languages and introduces them to the systems language space.\nHopefully, that makes programming in Rust more productive, efficient, and\nenjoyable.\n\nIn the rest of this section we'll download and install Rust, create a minimal\nCargo project, and implement Hello World.\n\n\n## Getting Rust\n\nYou can get Rust from [http://www.rust-lang.org/tools/install](http://www.rust-lang.org/tools/install).\nThe downloads from there include the Rust compiler, standard libraries, and\nCargo, which is a package manager and build tool for Rust.\n\nRust is available on three channels: stable, beta, and nightly. Rust works on a\nrapid-release, schedule with new releases every six weeks. On the release date,\nnightly becomes beta and beta becomes stable.\n\nNightly is updated every night and is ideal for users who want to experiment with\ncutting edge features and ensure that their libraries will work with future Rust.\n\nStable is the right choice for most users. Rust's stability guarantees only\napply to the stable channel.\n\nBeta is designed to mostly be used in users' CI to check that their code will\ncontinue to work as expected.\n\nSo, you probably want the stable channel. If you're on Linux or OS X, the\neasiest way to get it is to run\n\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\nOn Windows, a similarly easy way would be to run\n\n```\nchoco install rust\n```\n\nFor other ways to install, see [http://www.rust-lang.org/tools/install](http://www.rust-lang.org/tools/install).\n\nYou can find the source at [github.com/rust-lang/rust](https://github.com/rust-lang/rust).\nTo build the compiler, run `./configure && make rustc`. See\n[building-from-source](https://github.com/rust-lang/rust#building-from-source)\nfor more detailed instructions.\n\n\n## Hello World!\n\nThe easiest and most common way to build Rust programs is to use Cargo. To start\na project called `hello` using Cargo, run `cargo new --bin hello`. This will\ncreate a new directory called `hello` inside which is a `Cargo.toml` file and\na `src` directory with a file called `main.rs`.\n\n`Cargo.toml` defines dependencies and other metadata about our project. We'll\ncome back to it in detail later.\n\nAll our source code will go in the `src` directory. `main.rs` already contains\na Hello World program. It looks like this:\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\nTo build the program, run `cargo build`. To build and run it, `cargo run`. If\nyou do the latter, you should be greeted in the console. Success!\n\nCargo will have made a `target` directory and put the executable in there.\n\nIf you want to use the compiler directly you can run `rustc src/main.rs` which\nwill create an executable called `main`. See `rustc --help` for lots of\noptions.\n\nOK, back to the code. A few interesting points - we use `fn` to define a\nfunction or method. `main()` is the default entry point for our programs (we'll\nleave program args for later). There are no separate declarations or header\nfiles as with C++. `println!` is Rust's equivalent of printf. The `!` means that\nit is a macro. A subset of the standard library is available without needing to\nbe explicitly imported/included (the prelude). The `println!` macro is included\nas part of that subset.\n\nLet's change our example a little bit:\n\n```rust\nfn main() {\n    let world = \"world\";\n    println!(\"Hello {}!\", world);\n}\n```\n\n`let` is used to introduce a variable, world is the variable name and it is a\nstring (technically the type is `&'static str`, but more on that later). We\ndon't need to specify the type, it will be inferred for us.\n\nUsing `{}` in the `println!` statement is like using `%s` in printf. In fact, it\nis a bit more general than that because Rust will try to convert the variable to\na string if it is not one already[^1] (like `operator<<()` in C++).\nYou can easily play around with this sort of thing - try multiple strings and\nusing numbers (integer and float literals will work).\n\nIf you like, you can explicitly give the type of `world`:\n\n```rust\nlet world: &'static str = \"world\";\n```\n\nIn C++ we write `T x` to declare a variable `x` with type `T`. In Rust we write\n`x: T`, whether in `let` statements or function signatures, etc. Mostly we omit\nexplicit types in `let` statements, but they are required for function\narguments. Let's add another function to see it work:\n\n```rust\nfn foo(_x: &'static str) -> &'static str {\n    \"world\"\n}\n\nfn main() {\n    println!(\"Hello {}!\", foo(\"bar\"));\n}\n```\n\nThe function `foo` has a single argument `_x` which is a string literal (we pass\nit \"bar\" from `main`)[^2].\n\nThe return type for a function is given after `->`. If the function doesn't\nreturn anything (a void function in C++), we don't need to give a return type at\nall (as in `main`). If you want to be super-explicit, you can write `-> ()`,\n`()` is the void type in Rust.\n\nYou don't need the `return` keyword in Rust, if the last expression in a\nfunction body (or any other block, we'll see more of this later) is not finished\nwith a semicolon, then it is the return value. So `foo` will return\n\"world\". The `return` keyword still exists so we can do early returns. You can\nreplace `\"world\"` with `return \"world\";` and it will have the same effect.\n\n\n## Why?\n\nI would like to motivate some of the language features above. Local type\ninference is convenient and useful without sacrificing safety or performance\n(it's even in modern versions of C++ now). A minor convenience is that language\nitems are consistently denoted by keyword (`fn`, `let`, etc.), this makes\nscanning by eye or by tools easier, in general the syntax of Rust is simpler and\nmore consistent than C++. The `println!` macro is safer than printf - the number\nof arguments is statically checked against the number of 'holes' in the string\nand the arguments are type checked. This means you can't make the printf\nmistakes of printing memory as if it had a different type or addressing memory\nfurther down the stack by mistake. These are fairly minor things, but I hope\nthey illustrate the philosophy behind the design of Rust.\n\n\n[^1]: This is a programmer specified conversion which uses the `Display` trait, which\nworks a bit like `toString` in Java. You can also use `{:?}` which gives a\ncompiler generated representation which is sometimes useful for debugging. As\nwith printf, there are many other options.\n\n[^2]: We don't actually use that argument in `foo`. Usually,\nRust will warn us about this. By prefixing the argument name with `_` we avoid\nthese warnings. In fact, we don't need to name the argument at all, we could\njust use `_`.\n"
        },
        {
          "name": "primitives.md",
          "type": "blob",
          "size": 3.7177734375,
          "content": "# Primitive types and operators\n\nRust has pretty much the same arithmetic and logical operators as C++. `bool` is\nthe same in both languages (as are the `true` and `false` literals). Rust has\nsimilar concepts of integers, unsigned integers, and floats. However the syntax\nis a bit different. Rust uses `isize` to mean an integer and `usize` to mean an\nunsigned integer. These types are pointer sized. E.g., on a 32 bit system,\n`usize` means a 32 bit unsigned integer. Rust also has explicitly sized types\nwhich are `u` or `i` followed by 8, 16, 32, 64, or 128. So, for example, `u8` is\nan 8 bit unsigned integer and `i32` is a 32 bit signed integer. For floats, Rust\nhas `f32` and `f64`.\n\nNumeric literals can take suffixes to indicate their type. If no suffix is given, Rust tries to infer the\ntype. If it can't infer, it uses `i32` or `f64` (if there is a decimal point).\nExamples:\n\n```rust\nfn main() {\n    let x: bool = true;\n    let x = 34;   // type i32\n    // let x = 2147483648; // error: literal out of range for `i32`\n    let x = 34isize;\n    let x = 34usize;\n    let x = 34u8;\n    let x = 34i64;\n    let x = 34f32;\n}\n```\n\nAs a side note, Rust lets you redefine variables so the above code is legal -\neach `let` statement creates a new variable `x` and hides the previous one. This\nis more useful than you might expect due to variables being immutable by\ndefault.\n\nNumeric literals can be given as binary, octal, and hexadecimal, as well as\ndecimal. Use the `0b`, `0o`, and `0x` prefixes, respectively. You can use an\nunderscore anywhere in a numeric literal and it will be ignored. E.g,\n\n```rust\nfn main() {\n    let x = 12;\n    let x = 0b1100;\n    let x = 0o14;\n    let x = 0xe;\n    let y = 0b_1100_0011_1011_0001;\n}\n```\n\nRust has chars and strings, but since they are Unicode, they are a bit different\nfrom C++. I'm going to postpone talking about them until after I've introduced\npointers, references, and vectors (arrays).\n\nRust does not implicitly coerce numeric types. In general, Rust has much less\nimplicit coercion and subtyping than C++. Rust uses the `as` keyword for\nexplicit coercions and casting. Any numeric value can be cast to another numeric\ntype. `as` cannot be used to convert from numeric types to boolean types, but\nthe reverse can be done. E.g.,\n\n```rust\nfn main() {\n    let x = 34usize as isize;   // cast usize to isize\n    let x = 10 as f32;      // isize to float\n    let x = 10.45f64 as i8; // float to i8 (loses precision)\n    let x = 4u8 as u64;     // gains precision\n    let x = 400u16 as u8;   // 144, loses precision (and thus changes the value)\n    println!(\"`400u16 as u8` gives {}\", x);\n    let x = -3i8 as u8;     // 253, signed to unsigned (changes sign)\n    println!(\"`-3i8 as u8` gives {}\", x);\n    //let x = 45 as bool;  // FAILS! (use 45 != 0 instead)\n    let x = true as usize;  // cast bool to usize (gives a 1)\n}\n```\n\nRust has the following operators:\n\n|         Type          |            Operators             |\n| --------------------- | -------------------------------- |\n| Numeric               | `+`, `-`, `*`, `/`, `%`          |\n| Bitwise               | `\\|`, `&`, `^`, `<<`, `>>`       |\n| Comparison            | `==`, `!=`, `>`, `<`, `>=`, `<=` |\n| Short-circuit logical | `\\|\\|`, `&&`                     |\n\nAll of these behave as in C++, however, Rust is a bit stricter about the types\nthe operators can be applied to - the bitwise operators can only be applied to\nintegers and the logical operators can only be applied to booleans. Rust has the\n`-` unary operator which negates a number. The `!` operator negates a boolean\nand inverts every bit on an integer type (equivalent to `~` in C++ in the latter\ncase). Rust has compound assignment operators as in C++, e.g., `+=`, but does\nnot have increment or decrement operators (e.g., `++`).\n"
        },
        {
          "name": "rc-raw.md",
          "type": "blob",
          "size": 6.724609375,
          "content": "# Reference counted and raw pointers\n\nTODO add discussion of custom pointers and Deref trait (maybe later, not here)\n\nSo far we've covered unique and borrowed pointers. Unique pointers are very\nsimilar to the new std::unique_ptr in C++ and borrowed references are the\n'default' pointer you usually reach for if you would use a pointer or reference\nin C++. Rust has a few more, rarer pointers either in the libraries or built in\nto the language. These are mostly similar to various kinds of smart pointers you\nmight be used to in C++.\n\nThis post took a while to write and I still don't like it. There are a lot of\nloose ends here, both in my write up and in Rust itself. I hope some will get\nbetter with later posts and some will get better as the language develops. If\nyou are learning Rust, you might even want to skip this stuff for now, hopefully\nyou won't need it. Its really here just for completeness after the posts on\nother pointer types.\n\nIt might feel like Rust has a lot of pointer types, but it is pretty similar to\nC++ once you think about the various kinds of smart pointers available in\nlibraries. In Rust, however, you are more likely to meet them when you first\nstart learning the language. Because Rust pointers have compiler support, you\nare also much less likely to make errors when using them.\n\nI'm not going to cover these in as much detail as unique and borrowed references\nbecause, frankly, they are not as important. I might come back to them in more\ndetail later on.\n\n## Rc<T>\n\nReference counted pointers come as part of the rust standard library. They are\nin the `std::rc` module (we'll cover modules soon-ish. The modules are the\nreason for the `use` incantations in the examples). A reference counted pointer\nto an object of type `T` has type `Rc<T>`. You create reference counted pointers\nusing a static method (which for now you can think of like C++'s, but we'll see\nlater they are a bit different) - `Rc::new(...)` which takes a value to create\nthe pointer to. This constructor method follows Rust's usual move/copy semantics\n(like we discussed for unique pointers) - in either case, after calling Rc::new,\nyou will only be able to access the value via the pointer.\n\nAs with the other pointer types, the `.` operator does all the dereferencing you\nneed it to. You can use `*` to manually dereference.\n\nTo pass a ref-counted pointer you need to use the `clone` method. This kinda\nsucks, and hopefully we'll fix that, but that is not for sure (sadly). You can\ntake a (borrowed) reference to the pointed at value, so hopefully you don't need\nto clone too often. Rust's type system ensures that the ref-counted variable\nwill not be deleted before any references expire. Taking a reference has the\nadded advantage that it doesn't need to increment or decrement the ref count,\nand so will give better performance (although, that difference is probably\nmarginal since Rc objects are limited to a single thread and so the ref count\noperations don't have to be atomic). As in C++, you can also take a reference to\nthe Rc pointer.\n\nAn Rc example:\n\n```rust\nuse std::rc::Rc;\n\nfn bar(x: Rc<i32>) { }\nfn baz(x: &i32) { }\n\nfn foo() {\n    let x = Rc::new(45);\n    bar(x.clone());   // Increments the ref-count\n    baz(&*x);         // Does not increment\n    println!(\"{}\", 100 - *x);\n}  // Once this scope closes, all Rc pointers are gone, so ref-count == 0\n   // and the memory will be deleted.\n```\n\nRef counted pointers are always immutable. If you want a mutable ref-counted\nobject you need to use a RefCell (or Cell) wrapped in an `Rc`.\n\n## Cell and RefCell\n\nCell and RefCell are structs which allow you to 'cheat' the mutability rules.\nThis is kind of hard to explain without first covering Rust data structures and\nhow they work with mutability, so I'm going to come back to these slightly\ntricky objects later. For now, you should know that if you want a mutable, ref\ncounted object you need a Cell or RefCell wrapped in an Rc. As a first\napproximation, you probably want Cell for primitive data and RefCell for objects\nwith move semantics. So, for a mutable, ref-counted int you would use\n`Rc<Cell<int>>`.\n\n## \\*T - raw pointers\n\nFinally, Rust has two kinds of raw pointers (aka unsafe pointers): `*const T`\nfor an immutable raw pointer, and `*mut T` for a mutable raw pointer. They are\ncreated using `&` or `&mut` (you might need to specify a type to get a `*T`\nrather than a `&T` since the `&` operator can create either a borrowed reference\nor a raw pointer). Raw pointers are like C pointers, just a pointer to memory\nwith no restrictions on how they are used (you can't do pointer arithmetic\nwithout casting, but you can do it that way if you must). Raw pointers are the\nonly pointer type in Rust which can be null. There is no automatic dereferencing\nof raw pointers (so to call a method you have to write `(*x).foo()`) and no\nautomatic referencing. The most important restriction is that they can't be\ndereferenced (and thus can't be used) outside of an unsafe block. In regular\nRust code you can only pass them around.\n\nSo, what is unsafe code? Rust has strong safety guarantees, and (rarely) they\nprevent you doing something you need to do. Since Rust aims to be a systems\nlanguage, it has to be able to do anything that is possible and sometimes that\nmeans doing things the compiler can't verify is safe. To accomplish that, Rust\nhas the concept of unsafe blocks, marked by the `unsafe` keyword. In unsafe code\nyou can do unsafe things - dereference a raw pointer, index into an array\nwithout bounds checking, call code written in another language via the FFI, or\ncast variables. Obviously, you have to be much more careful writing unsafe code\nthan writing regular Rust code. In fact, you should only very rarely write\nunsafe code. Mostly it is used in very small chunks in libraries, rather than in\nclient code. In unsafe code you must do all the things you normally do in C++ to\nensure safety. Furthermore, you must manually ensure that you maintain the\ninvariants which the compiler would usually enforce. Unsafe blocks allow you to\nmanually enforce Rust's invariants, it does not allow you to break those\ninvariants. If you do, you can introduce bugs both in safe and unsafe code.\n\nAn example of using an raw pointer:\n\n```rust\nfn foo() {\n    let mut x = 5;\n    let x_p: *mut i32 = &mut x;\n    println!(\"x+5={}\", add_5(x_p));\n}\n\nfn add_5(p: *mut i32) -> i32 {\n    unsafe {\n        if !p.is_null() { // Note that *-pointers do not auto-deref, so this is\n                          // a method implemented on *i32, not i32.\n            *p + 5\n        } else {\n            -1            // Not a recommended error handling strategy.\n        }\n    }\n}\n```\n\nAnd that concludes our tour of Rust's pointers. Next time we'll take a break\nfrom pointers and look at Rust's data structures. We'll come back to borrowed\nreferences again in a later post though.\n"
        },
        {
          "name": "unique.md",
          "type": "blob",
          "size": 6.833984375,
          "content": "# Unique pointers\n\nRust is a systems language and therefore must give you raw access to memory. It\ndoes this (as in C++) via pointers. Pointers are one area where Rust and C++ are\nvery different, both in syntax and semantics. Rust enforces memory safety by\ntype checking pointers. That is one of its major advantages over other\nlanguages. Although the type system is a bit complex, you get memory safety and\nbare-metal performance in return.\n\nI had intended to cover all of Rust's pointers in one post, but I think the\nsubject is too large. So this post will cover just one kind - unique pointers -\nand other kinds will be covered in follow up posts.\n\nFirst, an example without pointers:\n\n```rust\nfn foo() {\n    let x = 75;\n\n    // ... do something with `x` ...\n}\n```\n\nWhen we reach the end of `foo`, `x` goes out of scope (in Rust as in C++). That\nmeans the variable can no longer be accessed and the memory for the variable can\nbe reused.\n\nIn Rust, for every type `T` we can write `Box<T>` for an owning (aka unique)\npointer to `T`. We use `Box::new(...)` to allocate space on the heap and\ninitialise that space with the supplied value. This is similar to `new` in C++.\nFor example,\n\n```rust\nfn foo() {\n    let x = Box::new(75);\n}\n```\n\nHere `x` is a pointer to a location on the heap which contains the value `75`.\n`x` has type `Box<i32>`; we could have written `let x: Box<i32> =\nBox::new(75);`. This is similar to writing `int* x = new int(75);` in C++.\nUnlike in C++, Rust will tidy up the memory for us, so there is no need to call\n`free` or `delete`[^1]. Unique pointers behave similarly to\nvalues - they are deleted when the variable goes out of scope. In our example,\nat the end of the function `foo`, `x` can no longer be accessed and the memory\npointed at by `x` can be reused.\n\nOwning pointers are dereferenced using the `*` as in C++. E.g.,\n\n```rust\nfn foo() {\n    let x = Box::new(75);\n    println!(\"`x` points to {}\", *x);\n}\n```\n\nAs with primitive types in Rust, owning pointers and the data they point to are\nimmutable by default. Unlike in C++, you can't have a mutable (unique) pointer to\nimmutable data or vice versa. Mutability of the data follows from the pointer.\nE.g.,\n\n```rust\nfn foo() {\n    let x = Box::new(75);\n    let y = Box::new(42);\n    // x = y;         // Not allowed, x is immutable.\n    // *x = 43;       // Not allowed, *x is immutable.\n    let mut x = Box::new(75);\n    x = y;            // OK, x is mutable.\n    *x = 43;          // OK, *x is mutable.\n}\n```\n\nOwning pointers can be returned from a function and continue to live on. If they\nare returned, then their memory will not be freed, i.e., there are no dangling\npointers in Rust. The memory will not leak. However, it will eventually go out of\nscope and then it will be freed. E.g.,\n\n```rust\nfn foo() -> Box<i32> {\n    let x = Box::new(75);\n    x\n}\n\nfn bar() {\n    let y = foo();\n    // ... use y ...\n}\n```\n\nHere, memory is initialised in `foo`, and returned to `bar`. `x` is returned\nfrom `foo` and stored in `y`, so it is not deleted. At the end of `bar`, `y`\ngoes out of scope and so the memory is reclaimed.\n\nOwning pointers are unique (also called linear) because there can be only one\n(owning) pointer to any piece of memory at any time. This is accomplished by\nmove semantics. When one pointer points at a value, any previous pointer can no\nlonger be accessed. E.g.,\n\n```rust\nfn foo() {\n    let x = Box::new(75);\n    let y = x;\n    // x can no longer be accessed\n    // let z = *x;   // Error.\n}\n```\n\nLikewise, if an owning pointer is passed to another function or stored in a\nfield, it can no longer be accessed:\n\n```rust\nfn bar(y: Box<isize>) {\n}\n\nfn foo() {\n    let x = Box::new(75);\n    bar(x);\n    // x can no longer be accessed\n    // let z = *x;   // Error.\n}\n```\n\nRust's unique pointers are similar to C++ `std::unique_ptr`s. In Rust, as in\nC++, there can be only one unique pointer to a value and that value is deleted\nwhen the pointer goes out of scope. Rust does most of its checking statically\nrather than at runtime. So, in C++ accessing a unique pointer whose value has\nmoved will result in a runtime error (since it will be null). In Rust this\nproduces a compile time error and you cannot go wrong at runtime.\n\nWe'll see later that it is possible to create other pointer types which point at\na unique pointer's value in Rust. This is similar to C++. However, in C++ this\nallows you to cause errors at runtime by holding a pointer to freed memory. That\nis not possible in Rust (we'll see how when we cover Rust's other pointer\ntypes).\n\nAs shown above, owning pointers must be dereferenced to use their values.\nHowever, method calls automatically dereference, so there is no need for a `->`\noperator or to use `*` for method calls. In this way, Rust pointers are a bit\nsimilar to both pointers and references in C++. E.g.,\n\n```rust\nfn bar(x: Box<Foo>, y: Box<Box<Box<Box<Foo>>>>) {\n    x.foo();\n    y.foo();\n}\n```\n\nAssuming that the type `Foo` has a method `foo()`, both these expressions are OK.\n\nCalling `Box::new()` with an existing value does not take a reference to that\nvalue, it copies that value. So,\n\n```rust\nfn foo() {\n    let x = 3;\n    let mut y = Box::new(x);\n    *y = 45;\n    println!(\"x is still {}\", x);\n}\n```\n\nIn general, Rust has move rather than copy semantics (as seen above with unique\npointers). Primitive types have copy semantics, so in the above example the\nvalue `3` is copied, but for more complex values it would be moved. We'll cover\nthis in more detail later.\n\nSometimes when programming, however, we need more than one reference to a value.\nFor that, Rust has borrowed pointers. I'll cover those in the next post.\n\n\n[^1]: The `std::unique_ptr<T>`, introduced in C++11, is similar in some aspects\n    to Rust's `Box<T>` but there are also significant differences.\n\n    Similarities:\n    * The memory pointed to by a `std::unique_ptr<T>` in C++11 and a `Box<T>` in Rust\n    is automatically released once the `std::unique_ptr<T>` goes out of the scope.\n    * Both C++11's `std::unique_ptr<T>` and Rust's `Box<T>` only exhibit move semantics.\n\n    Differences:\n\n    1. C++11 allows for a `std::unique_ptr<T>` to be constructed from an existing pointer,\n       thereby allowing multiple unique pointers to the same memory.\n       This behaviour is not permitted with `Box<T>`.\n    2. Dereferencing a `std::unique_ptr<T>` that has been moved to another variable or function,\n       causes undefined behavior in C++11. This would be caught at compile time in Rust.\n    3. Mutability or immutability does not go \"through\" `std::unique_ptr<T>`\n       -- dereferencing a `const std::unique_ptr<T>` still yields a mutable\n       (non-`const`) reference to the underlying data. In Rust, an immutable\n       `Box<T>` does not allow mutation of the data it points to.\n\n    `let x = Box::new(75)` in Rust may be interpreted as `const auto x =\n    std::unique_ptr<const int>{new int{75}};` in C++11 and `const auto x =\n    std::make_unique<const int>(75);` in C++14.\n"
        }
      ]
    }
  ]
}