{
  "metadata": {
    "timestamp": 1736709036122,
    "page": 130,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rust-lang/regex",
      "stars": 3595,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.06640625,
          "content": "target\nCargo.lock\nbench-log\n.*.swp\nwiki\ntags\nexamples/debug.rs\ntmp/\n"
        },
        {
          "name": ".vim",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 66.080078125,
          "content": "1.11.1 (2024-10-24)\n===================\nThis is a new patch release of `regex` that fixes compilation on nightly\nRust when the unstable `pattern` crate feature is enabled. Users on nightly\nRust without this feature enabled are unaffected.\n\nBug fixes:\n\n* [BUG #1231](https://github.com/rust-lang/regex/issues/1231):\nFix the `Pattern` trait implementation as a result of nightly API breakage.\n\n\n1.11.0 (2024-09-29)\n===================\nThis is a new minor release of `regex` that brings in an update to the\nUnicode Character Database. Specifically, this updates the Unicode data\nused by `regex` internally to the version 16 release.\n\nNew features:\n\n* [FEATURE #1228](https://github.com/rust-lang/regex/pull/1228):\nAdd new `regex::SetMatches::matched_all` method.\n* [FEATURE #1229](https://github.com/rust-lang/regex/pull/1229):\nUpdate to Unicode Character Database (UCD) version 16.\n\n\n1.10.6 (2024-08-02)\n===================\nThis is a new patch release with a fix for the `unstable` crate feature that\nenables `std::str::Pattern` trait integration.\n\nBug fixes:\n\n* [BUG #1219](https://github.com/rust-lang/regex/pull/1219):\nFix the `Pattern` trait implementation as a result of nightly API breakage.\n\n\n1.10.5 (2024-06-09)\n===================\nThis is a new patch release with some minor fixes.\n\nBug fixes:\n\n* [BUG #1203](https://github.com/rust-lang/regex/pull/1203):\nEscape invalid UTF-8 when in the `Debug` impl of `regex::bytes::Match`.\n\n\n1.10.4 (2024-03-22)\n===================\nThis is a new patch release with some minor fixes.\n\n* [BUG #1169](https://github.com/rust-lang/regex/issues/1169):\nFixes a bug with compiling a reverse NFA automaton in `regex-automata`.\n* [BUG #1178](https://github.com/rust-lang/regex/pull/1178):\nClarifies that when `Cow::Borrowed` is returned from replace APIs, it is\nequivalent to the input.\n\n\n1.10.3 (2024-01-21)\n===================\nThis is a new patch release that fixes the feature configuration of optional\ndependencies, and fixes an unsound use of bounds check elision.\n\nBug fixes:\n\n* [BUG #1147](https://github.com/rust-lang/regex/issues/1147):\nSet `default-features=false` for the `memchr` and `aho-corasick` dependencies.\n* [BUG #1154](https://github.com/rust-lang/regex/pull/1154):\nFix unsound bounds check elision.\n\n\n1.10.2 (2023-10-16)\n===================\nThis is a new patch release that fixes a search regression where incorrect\nmatches could be reported.\n\nBug fixes:\n\n* [BUG #1110](https://github.com/rust-lang/regex/issues/1110):\nRevert broadening of reverse suffix literal optimization introduced in 1.10.1.\n\n\n1.10.1 (2023-10-14)\n===================\nThis is a new patch release with a minor increase in the number of valid\npatterns and a broadening of some literal optimizations.\n\nNew features:\n\n* [FEATURE 04f5d7be](https://github.com/rust-lang/regex/commit/04f5d7be4efc542864cc400f5d43fbea4eb9bab6):\nLoosen ASCII-compatible rules such that regexes like `(?-u:â˜ƒ)` are now allowed.\n\nPerformance improvements:\n\n* [PERF 8a8d599f](https://github.com/rust-lang/regex/commit/8a8d599f9d2f2d78e9ad84e4084788c2d563afa5):\nBroader the reverse suffix optimization to apply in more cases.\n\n\n1.10.0 (2023-10-09)\n===================\nThis is a new minor release of `regex` that adds support for start and end\nword boundary assertions. That is, `\\<` and `\\>`. The minimum supported Rust\nversion has also been raised to 1.65, which was released about one year ago.\n\nThe new word boundary assertions are:\n\n* `\\<` or `\\b{start}`: a Unicode start-of-word boundary (`\\W|\\A` on the left,\n`\\w` on the right).\n* `\\>` or `\\b{end}`: a Unicode end-of-word boundary (`\\w` on the left, `\\W|\\z`\non the right)).\n* `\\b{start-half}`: half of a Unicode start-of-word boundary (`\\W|\\A` on the\nleft).\n* `\\b{end-half}`: half of a Unicode end-of-word boundary (`\\W|\\z` on the\nright).\n\nThe `\\<` and `\\>` are GNU extensions to POSIX regexes. They have been added\nto the `regex` crate because they enjoy somewhat broad support in other regex\nengines as well (for example, vim). The `\\b{start}` and `\\b{end}` assertions\nare aliases for `\\<` and `\\>`, respectively.\n\nThe `\\b{start-half}` and `\\b{end-half}` assertions are not found in any\nother regex engine (although regex engines with general look-around support\ncan certainly express them). They were added principally to support the\nimplementation of word matching in grep programs, where one generally wants to\nbe a bit more flexible in what is considered a word boundary.\n\nNew features:\n\n* [FEATURE #469](https://github.com/rust-lang/regex/issues/469):\nAdd support for `\\<` and `\\>` word boundary assertions.\n* [FEATURE(regex-automata) #1031](https://github.com/rust-lang/regex/pull/1031):\nDFAs now have a `start_state` method that doesn't use an `Input`.\n\nPerformance improvements:\n\n* [PERF #1051](https://github.com/rust-lang/regex/pull/1051):\nUnicode character class operations have been optimized in `regex-syntax`.\n* [PERF #1090](https://github.com/rust-lang/regex/issues/1090):\nMake patterns containing lots of literal characters use less memory.\n\nBug fixes:\n\n* [BUG #1046](https://github.com/rust-lang/regex/issues/1046):\nFix a bug that could result in incorrect match spans when using a Unicode word\nboundary and searching non-ASCII strings.\n* [BUG(regex-syntax) #1047](https://github.com/rust-lang/regex/issues/1047):\nFix panics that can occur in `Ast->Hir` translation (not reachable from `regex`\ncrate).\n* [BUG(regex-syntax) #1088](https://github.com/rust-lang/regex/issues/1088):\nRemove guarantees in the API that connect the `u` flag with a specific HIR\nrepresentation.\n\n`regex-automata` breaking change release:\n\nThis release includes a `regex-automata 0.4.0` breaking change release, which\nwas necessary in order to support the new word boundary assertions. For\nexample, the `Look` enum has new variants and the `LookSet` type now uses `u32`\ninstead of `u16` to represent a bitset of look-around assertions. These are\noverall very minor changes, and most users of `regex-automata` should be able\nto move to `0.4` from `0.3` without any changes at all.\n\n`regex-syntax` breaking change release:\n\nThis release also includes a `regex-syntax 0.8.0` breaking change release,\nwhich, like `regex-automata`, was necessary in order to support the new word\nboundary assertions. This release also includes some changes to the `Ast`\ntype to reduce heap usage in some cases. If you are using the `Ast` type\ndirectly, your code may require some minor modifications. Otherwise, users of\n`regex-syntax 0.7` should be able to migrate to `0.8` without any code changes.\n\n`regex-lite` release:\n\nThe `regex-lite 0.1.1` release contains support for the new word boundary\nassertions. There are no breaking changes.\n\n\n1.9.6 (2023-09-30)\n==================\nThis is a patch release that fixes a panic that can occur when the default\nregex size limit is increased to a large number.\n\n* [BUG aa4e4c71](https://github.com/rust-lang/regex/commit/aa4e4c7120b0090ce0624e3c42a2ed06dd8b918a):\nFix a bug where computing the maximum haystack length for the bounded\nbacktracker could result underflow and thus provoke a panic later in a search\ndue to a broken invariant.\n\n\n1.9.5 (2023-09-02)\n==================\nThis is a patch release that hopefully mostly fixes a performance bug that\noccurs when sharing a regex across multiple threads.\n\nIssue [#934](https://github.com/rust-lang/regex/issues/934)\nexplains this in more detail. It is [also noted in the crate\ndocumentation](https://docs.rs/regex/latest/regex/#sharing-a-regex-across-threads-can-result-in-contention).\nThe bug can appear when sharing a regex across multiple threads simultaneously,\nas might be the case when using a regex from a `OnceLock`, `lazy_static` or\nsimilar primitive. Usually high contention only results when using many threads\nto execute searches on small haystacks.\n\nOne can avoid the contention problem entirely through one of two methods.\nThe first is to use lower level APIs from `regex-automata` that require passing\nstate explicitly, such as [`meta::Regex::search_with`](https://docs.rs/regex-automata/latest/regex_automata/meta/struct.Regex.html#method.search_with).\nThe second is to clone a regex and send it to other threads explicitly. This\nwill not use any additional memory usage compared to sharing the regex. The\nonly downside of this approach is that it may be less convenient, for example,\nit won't work with things like `OnceLock` or `lazy_static` or `once_cell`.\n\nWith that said, as of this release, the contention performance problems have\nbeen greatly reduced. This was achieved by changing the free-list so that it\nwas sharded across threads, and that ensuring each sharded mutex occupies a\nsingle cache line to mitigate false sharing. So while contention may still\nimpact performance in some cases, it should be a lot better now.\n\nBecause of the changes to how the free-list works, please report any issues you\nfind with this release. That not only includes search time regressions but also\nsignificant regressions in memory usage. Reporting improvements is also welcome\nas well! If possible, provide a reproduction.\n\nBug fixes:\n\n* [BUG #934](https://github.com/rust-lang/regex/issues/934):\nFix a performance bug where high contention on a single regex led to massive\nslow downs.\n\n\n1.9.4 (2023-08-26)\n==================\nThis is a patch release that fixes a bug where `RegexSet::is_match(..)` could\nincorrectly return false (even when `RegexSet::matches(..).matched_any()`\nreturns true).\n\nBug fixes:\n\n* [BUG #1070](https://github.com/rust-lang/regex/issues/1070):\nFix a bug where a prefilter was incorrectly configured for a `RegexSet`.\n\n\n1.9.3 (2023-08-05)\n==================\nThis is a patch release that fixes a bug where some searches could result in\nincorrect match offsets being reported. It is difficult to characterize the\ntypes of regexes susceptible to this bug. They generally involve patterns\nthat contain no prefix or suffix literals, but have an inner literal along with\na regex prefix that can conditionally match.\n\nBug fixes:\n\n* [BUG #1060](https://github.com/rust-lang/regex/issues/1060):\nFix a bug with the reverse inner literal optimization reporting incorrect match\noffsets.\n\n\n1.9.2 (2023-08-05)\n==================\nThis is a patch release that fixes another memory usage regression. This\nparticular regression occurred only when using a `RegexSet`. In some cases,\nmuch more heap memory (by one or two orders of magnitude) was allocated than in\nversions prior to 1.9.0.\n\nBug fixes:\n\n* [BUG #1059](https://github.com/rust-lang/regex/issues/1059):\nFix a memory usage regression when using a `RegexSet`.\n\n\n1.9.1 (2023-07-07)\n==================\nThis is a patch release which fixes a memory usage regression. In the regex\n1.9 release, one of the internal engines used a more aggressive allocation\nstrategy than what was done previously. This patch release reverts to the\nprior on-demand strategy.\n\nBug fixes:\n\n* [BUG #1027](https://github.com/rust-lang/regex/issues/1027):\nChange the allocation strategy for the backtracker to be less aggressive.\n\n\n1.9.0 (2023-07-05)\n==================\nThis release marks the end of a [years long rewrite of the regex crate\ninternals](https://github.com/rust-lang/regex/issues/656). Since this is\nsuch a big release, please report any issues or regressions you find. We would\nalso love to hear about improvements as well.\n\nIn addition to many internal improvements that should hopefully result in\n\"my regex searches are faster,\" there have also been a few API additions:\n\n* A new `Captures::extract` method for quickly accessing the substrings\nthat match each capture group in a regex.\n* A new inline flag, `R`, which enables CRLF mode. This makes `.` match any\nUnicode scalar value except for `\\r` and `\\n`, and also makes `(?m:^)` and\n`(?m:$)` match after and before both `\\r` and `\\n`, respectively, but never\nbetween a `\\r` and `\\n`.\n* `RegexBuilder::line_terminator` was added to further customize the line\nterminator used by `(?m:^)` and `(?m:$)` to be any arbitrary byte.\n* The `std` Cargo feature is now actually optional. That is, the `regex` crate\ncan be used without the standard library.\n* Because `regex 1.9` may make binary size and compile times even worse, a\nnew experimental crate called `regex-lite` has been published. It prioritizes\nbinary size and compile times over functionality (like Unicode) and\nperformance. It shares no code with the `regex` crate.\n\nNew features:\n\n* [FEATURE #244](https://github.com/rust-lang/regex/issues/244):\nOne can opt into CRLF mode via the `R` flag.\ne.g., `(?mR:$)` matches just before `\\r\\n`.\n* [FEATURE #259](https://github.com/rust-lang/regex/issues/259):\nMulti-pattern searches with offsets can be done with `regex-automata 0.3`.\n* [FEATURE #476](https://github.com/rust-lang/regex/issues/476):\n`std` is now an optional feature. `regex` may be used with only `alloc`.\n* [FEATURE #644](https://github.com/rust-lang/regex/issues/644):\n`RegexBuilder::line_terminator` configures how `(?m:^)` and `(?m:$)` behave.\n* [FEATURE #675](https://github.com/rust-lang/regex/issues/675):\nAnchored search APIs are now available in `regex-automata 0.3`.\n* [FEATURE #824](https://github.com/rust-lang/regex/issues/824):\nAdd new `Captures::extract` method for easier capture group access.\n* [FEATURE #961](https://github.com/rust-lang/regex/issues/961):\nAdd `regex-lite` crate with smaller binary sizes and faster compile times.\n* [FEATURE #1022](https://github.com/rust-lang/regex/pull/1022):\nAdd `TryFrom` implementations for the `Regex` type.\n\nPerformance improvements:\n\n* [PERF #68](https://github.com/rust-lang/regex/issues/68):\nAdded a one-pass DFA engine for faster capture group matching.\n* [PERF #510](https://github.com/rust-lang/regex/issues/510):\nInner literals are now used to accelerate searches, e.g., `\\w+@\\w+` will scan\nfor `@`.\n* [PERF #787](https://github.com/rust-lang/regex/issues/787),\n[PERF #891](https://github.com/rust-lang/regex/issues/891):\nMakes literal optimizations apply to regexes of the form `\\b(foo|bar|quux)\\b`.\n\n(There are many more performance improvements as well, but not all of them have\nspecific issues devoted to them.)\n\nBug fixes:\n\n* [BUG #429](https://github.com/rust-lang/regex/issues/429):\nFix matching bugs related to `\\B` and inconsistencies across internal engines.\n* [BUG #517](https://github.com/rust-lang/regex/issues/517):\nFix matching bug with capture groups.\n* [BUG #579](https://github.com/rust-lang/regex/issues/579):\nFix matching bug with word boundaries.\n* [BUG #779](https://github.com/rust-lang/regex/issues/779):\nFix bug where some regexes like `(re)+` were not equivalent to `(re)(re)*`.\n* [BUG #850](https://github.com/rust-lang/regex/issues/850):\nFix matching bug inconsistency between NFA and DFA engines.\n* [BUG #921](https://github.com/rust-lang/regex/issues/921):\nFix matching bug where literal extraction got confused by `$`.\n* [BUG #976](https://github.com/rust-lang/regex/issues/976):\nAdd documentation to replacement routines about dealing with fallibility.\n* [BUG #1002](https://github.com/rust-lang/regex/issues/1002):\nUse corpus rejection in fuzz testing.\n\n\n1.8.4 (2023-06-05)\n==================\nThis is a patch release that fixes a bug where `(?-u:\\B)` was allowed in\nUnicode regexes, despite the fact that the current matching engines can report\nmatch offsets between the code units of a single UTF-8 encoded codepoint. That\nin turn means that match offsets that split a codepoint could be reported,\nwhich in turn results in panicking when one uses them to slice a `&str`.\n\nThis bug occurred in the transition to `regex 1.8` because the underlying\nsyntactical error that prevented this regex from compiling was intentionally\nremoved. That's because `(?-u:\\B)` will be permitted in Unicode regexes in\n`regex 1.9`, but the matching engines will guarantee to never report match\noffsets that split a codepoint. When the underlying syntactical error was\nremoved, no code was added to ensure that `(?-u:\\B)` didn't compile in the\n`regex 1.8` transition release. This release, `regex 1.8.4`, adds that code\nsuch that `Regex::new(r\"(?-u:\\B)\")` returns to the `regex <1.8` behavior of\nnot compiling. (A `bytes::Regex` can still of course compile it.)\n\nBug fixes:\n\n* [BUG #1006](https://github.com/rust-lang/regex/issues/1006):\nFix a bug where `(?-u:\\B)` was allowed in Unicode regexes, and in turn could\nlead to match offsets that split a codepoint in `&str`.\n\n\n1.8.3 (2023-05-25)\n==================\nThis is a patch release that fixes a bug where the regex would report a\nmatch at every position even when it shouldn't. This could occur in a very\nsmall subset of regexes, usually an alternation of simple literals that\nhave particular properties. (See the issue linked below for a more precise\ndescription.)\n\nBug fixes:\n\n* [BUG #999](https://github.com/rust-lang/regex/issues/999):\nFix a bug where a match at every position is erroneously reported.\n\n\n1.8.2 (2023-05-22)\n==================\nThis is a patch release that fixes a bug where regex compilation could panic\nin debug mode for regexes with large counted repetitions. For example,\n`a{2147483516}{2147483416}{5}` resulted in an integer overflow that wrapped\nin release mode but panicking in debug mode. Despite the unintended wrapping\narithmetic in release mode, it didn't cause any other logical bugs since the\nerrant code was for new analysis that wasn't used yet.\n\nBug fixes:\n\n* [BUG #995](https://github.com/rust-lang/regex/issues/995):\nFix a bug where regex compilation with large counted repetitions could panic.\n\n\n1.8.1 (2023-04-21)\n==================\nThis is a patch release that fixes a bug where a regex match could be reported\nwhere none was found. Specifically, the bug occurs when a pattern contains some\nliteral prefixes that could be extracted _and_ an optional word boundary in the\nprefix.\n\nBug fixes:\n\n* [BUG #981](https://github.com/rust-lang/regex/issues/981):\nFix a bug where a word boundary could interact with prefix literal\noptimizations and lead to a false positive match.\n\n\n1.8.0 (2023-04-20)\n==================\nThis is a sizeable release that will be soon followed by another sizeable\nrelease. Both of them will combined close over 40 existing issues and PRs.\n\nThis first release, despite its size, essentially represents preparatory work\nfor the second release, which will be even bigger. Namely, this release:\n\n* Increases the MSRV to Rust 1.60.0, which was released about 1 year ago.\n* Upgrades its dependency on `aho-corasick` to the recently released 1.0\nversion.\n* Upgrades its dependency on `regex-syntax` to the simultaneously released\n`0.7` version. The changes to `regex-syntax` principally revolve around a\nrewrite of its literal extraction code and a number of simplifications and\noptimizations to its high-level intermediate representation (HIR).\n\nThe second release, which will follow ~shortly after the release above, will\ncontain a soup-to-nuts rewrite of every regex engine. This will be done by\nbringing [`regex-automata`](https://github.com/BurntSushi/regex-automata) into\nthis repository, and then changing the `regex` crate to be nothing but an API\nshim layer on top of `regex-automata`'s API.\n\nThese tandem releases are the culmination of about 3\nyears of on-and-off work that [began in earnest in March\n2020](https://github.com/rust-lang/regex/issues/656).\n\nBecause of the scale of changes involved in these releases, I would love to\nhear about your experience. Especially if you notice undocumented changes in\nbehavior or performance changes (positive *or* negative).\n\nMost changes in the first release are listed below. For more details, please\nsee the commit log, which reflects a linear and decently documented history\nof all changes.\n\nNew features:\n\n* [FEATURE #501](https://github.com/rust-lang/regex/issues/501):\nPermit many more characters to be escaped, even if they have no significance.\nMore specifically, any ASCII character except for `[0-9A-Za-z<>]` can now be\nescaped. Also, a new routine, `is_escapeable_character`, has been added to\n`regex-syntax` to query whether a character is escapeable or not.\n* [FEATURE #547](https://github.com/rust-lang/regex/issues/547):\nAdd `Regex::captures_at`. This fills a hole in the API, but doesn't otherwise\nintroduce any new expressive power.\n* [FEATURE #595](https://github.com/rust-lang/regex/issues/595):\nCapture group names are now Unicode-aware. They can now begin with either a `_`\nor any \"alphabetic\" codepoint. After the first codepoint, subsequent codepoints\ncan be any sequence of alpha-numeric codepoints, along with `_`, `.`, `[` and\n`]`. Note that replacement syntax has not changed.\n* [FEATURE #810](https://github.com/rust-lang/regex/issues/810):\nAdd `Match::is_empty` and `Match::len` APIs.\n* [FEATURE #905](https://github.com/rust-lang/regex/issues/905):\nAdd an `impl Default for RegexSet`, with the default being the empty set.\n* [FEATURE #908](https://github.com/rust-lang/regex/issues/908):\nA new method, `Regex::static_captures_len`, has been added which returns the\nnumber of capture groups in the pattern if and only if every possible match\nalways contains the same number of matching groups.\n* [FEATURE #955](https://github.com/rust-lang/regex/issues/955):\nNamed captures can now be written as `(?<name>re)` in addition to\n`(?P<name>re)`.\n* FEATURE: `regex-syntax` now supports empty character classes.\n* FEATURE: `regex-syntax` now has an optional `std` feature. (This will come\nto `regex` in the second release.)\n* FEATURE: The `Hir` type in `regex-syntax` has had a number of simplifications\nmade to it.\n* FEATURE: `regex-syntax` has support for a new `R` flag for enabling CRLF\nmode. This will be supported in `regex` proper in the second release.\n* FEATURE: `regex-syntax` now has proper support for \"regex that never\nmatches\" via `Hir::fail()`.\n* FEATURE: The `hir::literal` module of `regex-syntax` has been completely\nre-worked. It now has more documentation, examples and advice.\n* FEATURE: The `allow_invalid_utf8` option in `regex-syntax` has been renamed\nto `utf8`, and the meaning of the boolean has been flipped.\n\nPerformance improvements:\n\n* PERF: The upgrade to `aho-corasick 1.0` may improve performance in some\ncases. It's difficult to characterize exactly which patterns this might impact,\nbut if there are a small number of longish (>= 4 bytes) prefix literals, then\nit might be faster than before.\n\nBug fixes:\n\n* [BUG #514](https://github.com/rust-lang/regex/issues/514):\nImprove `Debug` impl for `Match` so that it doesn't show the entire haystack.\n* BUGS [#516](https://github.com/rust-lang/regex/issues/516),\n[#731](https://github.com/rust-lang/regex/issues/731):\nFix a number of issues with printing `Hir` values as regex patterns.\n* [BUG #610](https://github.com/rust-lang/regex/issues/610):\nAdd explicit example of `foo|bar` in the regex syntax docs.\n* [BUG #625](https://github.com/rust-lang/regex/issues/625):\nClarify that `SetMatches::len` does not (regretably) refer to the number of\nmatches in the set.\n* [BUG #660](https://github.com/rust-lang/regex/issues/660):\nClarify \"verbose mode\" in regex syntax documentation.\n* BUG [#738](https://github.com/rust-lang/regex/issues/738),\n[#950](https://github.com/rust-lang/regex/issues/950):\nFix `CaptureLocations::get` so that it never panics.\n* [BUG #747](https://github.com/rust-lang/regex/issues/747):\nClarify documentation for `Regex::shortest_match`.\n* [BUG #835](https://github.com/rust-lang/regex/issues/835):\nFix `\\p{Sc}` so that it is equivalent to `\\p{Currency_Symbol}`.\n* [BUG #846](https://github.com/rust-lang/regex/issues/846):\nAdd more clarifying documentation to the `CompiledTooBig` error variant.\n* [BUG #854](https://github.com/rust-lang/regex/issues/854):\nClarify that `regex::Regex` searches as if the haystack is a sequence of\nUnicode scalar values.\n* [BUG #884](https://github.com/rust-lang/regex/issues/884):\nReplace `__Nonexhaustive` variants with `#[non_exhaustive]` attribute.\n* [BUG #893](https://github.com/rust-lang/regex/pull/893):\nOptimize case folding since it can get quite slow in some pathological cases.\n* [BUG #895](https://github.com/rust-lang/regex/issues/895):\nReject `(?-u:\\W)` in `regex::Regex` APIs.\n* [BUG #942](https://github.com/rust-lang/regex/issues/942):\nAdd a missing `void` keyword to indicate \"no parameters\" in C API.\n* [BUG #965](https://github.com/rust-lang/regex/issues/965):\nFix `\\p{Lc}` so that it is equivalent to `\\p{Cased_Letter}`.\n* [BUG #975](https://github.com/rust-lang/regex/issues/975):\nClarify documentation for `\\pX` syntax.\n\n\n1.7.3 (2023-03-24)\n==================\nThis is a small release that fixes a bug in `Regex::shortest_match_at` that\ncould cause it to panic, even when the offset given is valid.\n\nBug fixes:\n\n* [BUG #969](https://github.com/rust-lang/regex/issues/969):\n  Fix a bug in how the reverse DFA was called for `Regex::shortest_match_at`.\n\n\n1.7.2 (2023-03-21)\n==================\nThis is a small release that fixes a failing test on FreeBSD.\n\nBug fixes:\n\n* [BUG #967](https://github.com/rust-lang/regex/issues/967):\n  Fix \"no stack overflow\" test which can fail due to the small stack size.\n\n\n1.7.1 (2023-01-09)\n==================\nThis release was done principally to try and fix the doc.rs rendering for the\nregex crate.\n\nPerformance improvements:\n\n* [PERF #930](https://github.com/rust-lang/regex/pull/930):\n  Optimize `replacen`. This also applies to `replace`, but not `replace_all`.\n\nBug fixes:\n\n* [BUG #945](https://github.com/rust-lang/regex/issues/945):\n  Maybe fix rustdoc rendering by just bumping a new release?\n\n\n1.7.0 (2022-11-05)\n==================\nThis release principally includes an upgrade to Unicode 15.\n\nNew features:\n\n* [FEATURE #832](https://github.com/rust-lang/regex/issues/916):\n  Upgrade to Unicode 15.\n\n\n1.6.0 (2022-07-05)\n==================\nThis release principally includes an upgrade to Unicode 14.\n\nNew features:\n\n* [FEATURE #832](https://github.com/rust-lang/regex/pull/832):\n  Clarify that `Captures::len` includes all groups, not just matching groups.\n* [FEATURE #857](https://github.com/rust-lang/regex/pull/857):\n  Add an `ExactSizeIterator` impl for `SubCaptureMatches`.\n* [FEATURE #861](https://github.com/rust-lang/regex/pull/861):\n  Improve `RegexSet` documentation examples.\n* [FEATURE #877](https://github.com/rust-lang/regex/issues/877):\n  Upgrade to Unicode 14.\n\nBug fixes:\n\n* [BUG #792](https://github.com/rust-lang/regex/issues/792):\n  Fix error message rendering bug.\n\n\n1.5.6 (2022-05-20)\n==================\nThis release includes a few bug fixes, including a bug that produced incorrect\nmatches when a non-greedy `?` operator was used.\n\n* [BUG #680](https://github.com/rust-lang/regex/issues/680):\n  Fixes a bug where `[[:alnum:][:^ascii:]]` dropped `[:alnum:]` from the class.\n* [BUG #859](https://github.com/rust-lang/regex/issues/859):\n  Fixes a bug where `Hir::is_match_empty` returned `false` for `\\b`.\n* [BUG #862](https://github.com/rust-lang/regex/issues/862):\n  Fixes a bug where 'ab??' matches 'ab' instead of 'a' in 'ab'.\n\n\n1.5.5 (2022-03-08)\n==================\nThis releases fixes a security bug in the regex compiler. This bug permits a\nvector for a denial-of-service attack in cases where the regex being compiled\nis untrusted. There are no known problems where the regex is itself trusted,\nincluding in cases of untrusted haystacks.\n\n* [SECURITY #GHSA-m5pq-gvj9-9vr8](https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8):\n  Fixes a bug in the regex compiler where empty sub-expressions subverted the\n  existing mitigations in place to enforce a size limit on compiled regexes.\n  The Rust Security Response WG published an advisory about this:\n  https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw\n\n\n1.5.4 (2021-05-06)\n==================\nThis release fixes another compilation failure when building regex. This time,\nthe fix is for when the `pattern` feature is enabled, which only works on\nnightly Rust. CI has been updated to test this case.\n\n* [BUG #772](https://github.com/rust-lang/regex/pull/772):\n  Fix build when `pattern` feature is enabled.\n\n\n1.5.3 (2021-05-01)\n==================\nThis releases fixes a bug when building regex with only the `unicode-perl`\nfeature. It turns out that while CI was building this configuration, it wasn't\nactually failing the overall build on a failed compilation.\n\n* [BUG #769](https://github.com/rust-lang/regex/issues/769):\n  Fix build in `regex-syntax` when only the `unicode-perl` feature is enabled.\n\n\n1.5.2 (2021-05-01)\n==================\nThis release fixes a performance bug when Unicode word boundaries are used.\nNamely, for certain regexes on certain inputs, it's possible for the lazy DFA\nto stop searching (causing a fallback to a slower engine) when it doesn't\nactually need to.\n\n[PR #768](https://github.com/rust-lang/regex/pull/768) fixes the bug, which was\noriginally reported in\n[ripgrep#1860](https://github.com/BurntSushi/ripgrep/issues/1860).\n\n\n1.5.1 (2021-04-30)\n==================\nThis is a patch release that fixes a compilation error when the `perf-literal`\nfeature is not enabled.\n\n\n1.5.0 (2021-04-30)\n==================\nThis release primarily updates to Rust 2018 (finally) and bumps the MSRV to\nRust 1.41 (from Rust 1.28). Rust 1.41 was chosen because it's still reasonably\nold, and is what's in Debian stable at the time of writing.\n\nThis release also drops this crate's own bespoke substring search algorithms\nin favor of a new\n[`memmem` implementation provided by the `memchr` crate](https://docs.rs/memchr/2.4.0/memchr/memmem/index.html).\nThis will change the performance profile of some regexes, sometimes getting a\nlittle worse, and hopefully more frequently, getting a lot better. Please\nreport any serious performance regressions if you find them.\n\n\n1.4.6 (2021-04-22)\n==================\nThis is a small patch release that fixes the compiler's size check on how much\nheap memory a regex uses. Previously, the compiler did not account for the\nheap usage of Unicode character classes. Now it does. It's possible that this\nmay make some regexes fail to compile that previously did compile. If that\nhappens, please file an issue.\n\n* [BUG OSS-fuzz#33579](https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=33579):\n  Some regexes can use more heap memory than one would expect.\n\n\n1.4.5 (2021-03-14)\n==================\nThis is a small patch release that fixes a regression in the size of a `Regex`\nin the 1.4.4 release. Prior to 1.4.4, a `Regex` was 552 bytes. In the 1.4.4\nrelease, it was 856 bytes due to internal changes. In this release, a `Regex`\nis now 16 bytes. In general, the size of a `Regex` was never something that was\non my radar, but this increased size in the 1.4.4 release seems to have crossed\na threshold and resulted in stack overflows in some programs.\n\n* [BUG #750](https://github.com/rust-lang/regex/pull/750):\n  Fixes stack overflows seemingly caused by a large `Regex` size by decreasing\n  its size.\n\n\n1.4.4 (2021-03-11)\n==================\nThis is a small patch release that contains some bug fixes. Notably, it also\ndrops the `thread_local` (and `lazy_static`, via transitivity) dependencies.\n\nBug fixes:\n\n* [BUG #362](https://github.com/rust-lang/regex/pull/362):\n  Memory leaks caused by an internal caching strategy should now be fixed.\n* [BUG #576](https://github.com/rust-lang/regex/pull/576):\n  All regex types now implement `UnwindSafe` and `RefUnwindSafe`.\n* [BUG #728](https://github.com/rust-lang/regex/pull/749):\n  Add missing `Replacer` impls for `Vec<u8>`, `String`, `Cow`, etc.\n\n\n1.4.3 (2021-01-08)\n==================\nThis is a small patch release that adds some missing standard trait\nimplementations for some types in the public API.\n\nBug fixes:\n\n* [BUG #734](https://github.com/rust-lang/regex/pull/734):\n  Add `FusedIterator` and `ExactSizeIterator` impls to iterator types.\n* [BUG #735](https://github.com/rust-lang/regex/pull/735):\n  Add missing `Debug` impls to public API types.\n\n\n1.4.2 (2020-11-01)\n==================\nThis is a small bug fix release that bans `\\P{any}`. We previously banned empty\nclasses like `[^\\w\\W]`, but missed the `\\P{any}` case. In the future, we hope\nto permit empty classes.\n\n* [BUG #722](https://github.com/rust-lang/regex/issues/722):\n  Ban `\\P{any}` to avoid a panic in the regex compiler. Found by OSS-Fuzz.\n\n\n1.4.1 (2020-10-13)\n==================\nThis is a small bug fix release that makes `\\p{cf}` work. Previously, it would\nreport \"property not found\" even though `cf` is a valid abbreviation for the\n`Format` general category.\n\n* [BUG #719](https://github.com/rust-lang/regex/issues/719):\n  Fixes bug that prevented `\\p{cf}` from working.\n\n\n1.4.0 (2020-10-11)\n==================\nThis releases has a few minor documentation fixes as well as some very minor\nAPI additions. The MSRV remains at Rust 1.28 for now, but this is intended to\nincrease to at least Rust 1.41.1 soon.\n\nThis release also adds support for OSS-Fuzz. Kudos to\n[@DavidKorczynski](https://github.com/DavidKorczynski)\nfor doing the heavy lifting for that!\n\nNew features:\n\n* [FEATURE #649](https://github.com/rust-lang/regex/issues/649):\n  Support `[`, `]` and `.` in capture group names.\n* [FEATURE #687](https://github.com/rust-lang/regex/issues/687):\n  Add `is_empty` predicate to `RegexSet`.\n* [FEATURE #689](https://github.com/rust-lang/regex/issues/689):\n  Implement `Clone` for `SubCaptureMatches`.\n* [FEATURE #715](https://github.com/rust-lang/regex/issues/715):\n  Add `empty` constructor to `RegexSet` for convenience.\n\nBug fixes:\n\n* [BUG #694](https://github.com/rust-lang/regex/issues/694):\n  Fix doc example for `Replacer::replace_append`.\n* [BUG #698](https://github.com/rust-lang/regex/issues/698):\n  Clarify docs for `s` flag when using a `bytes::Regex`.\n* [BUG #711](https://github.com/rust-lang/regex/issues/711):\n  Clarify `is_match` docs to indicate that it can match anywhere in string.\n\n\n1.3.9 (2020-05-28)\n==================\nThis release fixes a MSRV (Minimum Support Rust Version) regression in the\n1.3.8 release. Namely, while 1.3.8 compiles on Rust 1.28, it actually does not\ncompile on other Rust versions, such as Rust 1.39.\n\nBug fixes:\n\n* [BUG #685](https://github.com/rust-lang/regex/issues/685):\n  Remove use of `doc_comment` crate, which cannot be used before Rust 1.43.\n\n\n1.3.8 (2020-05-28)\n==================\nThis release contains a couple of important bug fixes driven\nby better support for empty-subexpressions in regexes. For\nexample, regexes like `b|` are now allowed. Major thanks to\n[@sliquister](https://github.com/sliquister) for implementing support for this\nin [#677](https://github.com/rust-lang/regex/pull/677).\n\nBug fixes:\n\n* [BUG #523](https://github.com/rust-lang/regex/pull/523):\n  Add note to documentation that spaces can be escaped in `x` mode.\n* [BUG #524](https://github.com/rust-lang/regex/issues/524):\n  Add support for empty sub-expressions, including empty alternations.\n* [BUG #659](https://github.com/rust-lang/regex/issues/659):\n  Fix match bug caused by an empty sub-expression miscompilation.\n\n\n1.3.7 (2020-04-17)\n==================\nThis release contains a small bug fix that fixes how `regex` forwards crate\nfeatures to `regex-syntax`. In particular, this will reduce recompilations in\nsome cases.\n\nBug fixes:\n\n* [BUG #665](https://github.com/rust-lang/regex/pull/665):\n  Fix feature forwarding to `regex-syntax`.\n\n\n1.3.6 (2020-03-24)\n==================\nThis release contains a sizable (~30%) performance improvement when compiling\nsome kinds of large regular expressions.\n\nPerformance improvements:\n\n* [PERF #657](https://github.com/rust-lang/regex/pull/657):\n  Improvement performance of compiling large regular expressions.\n\n\n1.3.5 (2020-03-12)\n==================\nThis release updates this crate to Unicode 13.\n\nNew features:\n\n* [FEATURE #653](https://github.com/rust-lang/regex/pull/653):\n  Update `regex-syntax` to Unicode 13.\n\n\n1.3.4 (2020-01-30)\n==================\nThis is a small bug fix release that fixes a bug related to the scoping of\nflags in a regex. Namely, before this fix, a regex like `((?i)a)b)` would\nmatch `aB` despite the fact that `b` should not be matched case insensitively.\n\nBug fixes:\n\n* [BUG #640](https://github.com/rust-lang/regex/issues/640):\n  Fix bug related to the scoping of flags in a regex.\n\n\n1.3.3 (2020-01-09)\n==================\nThis is a small maintenance release that upgrades the dependency on\n`thread_local` from `0.3` to `1.0`. The minimum supported Rust version remains\nat Rust 1.28.\n\n\n1.3.2 (2020-01-09)\n==================\nThis is a small maintenance release with some house cleaning and bug fixes.\n\nNew features:\n\n* [FEATURE #631](https://github.com/rust-lang/regex/issues/631):\n  Add a `Match::range` method an a `From<Match> for Range` impl.\n\nBug fixes:\n\n* [BUG #521](https://github.com/rust-lang/regex/issues/521):\n  Corrects `/-/.splitn(\"a\", 2)` to return `[\"a\"]` instead of `[\"a\", \"\"]`.\n* [BUG #594](https://github.com/rust-lang/regex/pull/594):\n  Improve error reporting when writing `\\p\\`.\n* [BUG #627](https://github.com/rust-lang/regex/issues/627):\n  Corrects `/-/.split(\"a-\")` to return `[\"a\", \"\"]` instead of `[\"a\"]`.\n* [BUG #633](https://github.com/rust-lang/regex/pull/633):\n  Squash deprecation warnings for the `std::error::Error::description` method.\n\n\n1.3.1 (2019-09-04)\n==================\nThis is a maintenance release with no changes in order to try to work-around\na [docs.rs/Cargo issue](https://github.com/rust-lang/docs.rs/issues/400).\n\n\n1.3.0 (2019-09-03)\n==================\nThis release adds a plethora of new crate features that permit users of regex\nto shrink its size considerably, in exchange for giving up either functionality\n(such as Unicode support) or runtime performance. When all such features are\ndisabled, the dependency tree for `regex` shrinks to exactly 1 crate\n(`regex-syntax`). More information about the new crate features can be\n[found in the docs](https://docs.rs/regex/*/#crate-features).\n\nNote that while this is a new minor version release, the minimum supported\nRust version for this crate remains at `1.28.0`.\n\nNew features:\n\n* [FEATURE #474](https://github.com/rust-lang/regex/issues/474):\n  The `use_std` feature has been deprecated in favor of the `std` feature.\n  The `use_std` feature will be removed in regex 2. Until then, `use_std` will\n  remain as an alias for the `std` feature.\n* [FEATURE #583](https://github.com/rust-lang/regex/issues/583):\n  Add a substantial number of crate features shrinking `regex`.\n\n\n1.2.1 (2019-08-03)\n==================\nThis release does a bit of house cleaning. Namely:\n\n* This repository is now using rustfmt.\n* License headers have been removed from all files, in following suit with the\n  Rust project.\n* Teddy has been removed from the `regex` crate, and is now part of the\n  `aho-corasick` crate.\n  [See `aho-corasick`'s new `packed` sub-module for details](https://docs.rs/aho-corasick/0.7.6/aho_corasick/packed/index.html).\n* The `utf8-ranges` crate has been deprecated, with its functionality moving\n  into the\n  [`utf8` sub-module of `regex-syntax`](https://docs.rs/regex-syntax/0.6.11/regex_syntax/utf8/index.html).\n* The `ucd-util` dependency has been dropped, in favor of implementing what\n  little we need inside of `regex-syntax` itself.\n\nIn general, this is part of an ongoing (long term) effort to make optimizations\nin the regex engine easier to reason about. The current code is too convoluted\nand thus it is very easy to introduce new bugs. This simplification effort is\nthe primary motivation behind re-working the `aho-corasick` crate to not only\nbundle algorithms like Teddy, but to also provide regex-like match semantics\nautomatically.\n\nMoving forward, the plan is to join up with the `bstr` and `regex-automata`\ncrates, with the former providing more sophisticated substring search\nalgorithms (thereby deleting existing code in `regex`) and the latter providing\nahead-of-time compiled DFAs for cases where they are inexpensive to compute.\n\n\n1.2.0 (2019-07-20)\n==================\nThis release updates regex's minimum supported Rust version to 1.28, which was\nrelease almost 1 year ago. This release also updates regex's Unicode data\ntables to 12.1.0.\n\n\n1.1.9 (2019-07-06)\n==================\nThis release contains a bug fix that caused regex's tests to fail, due to a\ndependency on an unreleased behavior in regex-syntax.\n\n* [BUG #593](https://github.com/rust-lang/regex/issues/593):\n  Move an integration-style test on error messages into regex-syntax.\n\n\n1.1.8 (2019-07-04)\n==================\nThis release contains a few small internal refactorings. One of which fixes\nan instance of undefined behavior in a part of the SIMD code.\n\nBug fixes:\n\n* [BUG #545](https://github.com/rust-lang/regex/issues/545):\n  Improves error messages when a repetition operator is used without a number.\n* [BUG #588](https://github.com/rust-lang/regex/issues/588):\n  Removes use of a repr(Rust) union used for type punning in the Teddy matcher.\n* [BUG #591](https://github.com/rust-lang/regex/issues/591):\n  Update docs for running benchmarks and improve failure modes.\n\n\n1.1.7 (2019-06-09)\n==================\nThis release fixes up a few warnings as a result of recent deprecations.\n\n\n1.1.6 (2019-04-16)\n==================\nThis release fixes a regression introduced by a bug fix (for\n[BUG #557](https://github.com/rust-lang/regex/issues/557)) which could cause\nthe regex engine to enter an infinite loop. This bug was originally\n[reported against ripgrep](https://github.com/BurntSushi/ripgrep/issues/1247).\n\n\n1.1.5 (2019-04-01)\n==================\nThis release fixes a bug in regex's dependency specification where it requires\na newer version of regex-syntax, but this wasn't communicated correctly in the\nCargo.toml. This would have been caught by a minimal version check, but this\ncheck was disabled because the `rand` crate itself advertises incorrect\ndependency specifications.\n\nBug fixes:\n\n* [BUG #570](https://github.com/rust-lang/regex/pull/570):\n  Fix regex-syntax minimal version.\n\n\n1.1.4 (2019-03-31)\n==================\nThis release fixes a backwards compatibility regression where Regex was no\nlonger UnwindSafe. This was caused by the upgrade to aho-corasick 0.7, whose\nAhoCorasick type was itself not UnwindSafe. This has been fixed in aho-corasick\n0.7.4, which we now require.\n\nBug fixes:\n\n* [BUG #568](https://github.com/rust-lang/regex/pull/568):\n  Fix an API regression where Regex was no longer UnwindSafe.\n\n\n1.1.3 (2019-03-30)\n==================\nThis releases fixes a few bugs and adds a performance improvement when a regex\nis a simple alternation of literals.\n\nPerformance improvements:\n\n* [OPT #566](https://github.com/rust-lang/regex/pull/566):\n  Upgrades `aho-corasick` to 0.7 and uses it for `foo|bar|...|quux` regexes.\n\nBug fixes:\n\n* [BUG #527](https://github.com/rust-lang/regex/issues/527):\n  Fix a bug where the parser would panic on patterns like `((?x))`.\n* [BUG #555](https://github.com/rust-lang/regex/issues/555):\n  Fix a bug where the parser would panic on patterns like `(?m){1,1}`.\n* [BUG #557](https://github.com/rust-lang/regex/issues/557):\n  Fix a bug where captures could lead to an incorrect match.\n\n\n1.1.2 (2019-02-27)\n==================\nThis release fixes a bug found in the fix introduced in 1.1.1.\n\nBug fixes:\n\n* [BUG edf45e6f](https://github.com/rust-lang/regex/commit/edf45e6f):\n  Fix bug introduced in reverse suffix literal matcher in the 1.1.1 release.\n\n\n1.1.1 (2019-02-27)\n==================\nThis is a small release with one fix for a bug caused by literal optimizations.\n\nBug fixes:\n\n* [BUG 661bf53d](https://github.com/rust-lang/regex/commit/661bf53d):\n  Fixes a bug in the reverse suffix literal optimization. This was originally\n  reported\n  [against ripgrep](https://github.com/BurntSushi/ripgrep/issues/1203).\n\n\n1.1.0 (2018-11-30)\n==================\nThis is a small release with a couple small enhancements. This release also\nincreases the minimal supported Rust version (MSRV) to 1.24.1 (from 1.20.0). In\naccordance with this crate's MSRV policy, this release bumps the minor version\nnumber.\n\nPerformance improvements:\n\n* [OPT #511](https://github.com/rust-lang/regex/pull/511),\n  [OPT #540](https://github.com/rust-lang/regex/pull/540):\n  Improve lazy DFA construction for large regex sets.\n\nNew features:\n\n* [FEATURE #538](https://github.com/rust-lang/regex/pull/538):\n  Add Emoji and \"break\" Unicode properties. See [UNICODE.md](UNICODE.md).\n\nBug fixes:\n\n* [BUG #530](https://github.com/rust-lang/regex/pull/530):\n  Add Unicode license (for data tables).\n* Various typo/doc fixups.\n\n\n1.0.6 (2018-11-06)\n==================\nThis is a small release.\n\nPerformance improvements:\n\n* [OPT #513](https://github.com/rust-lang/regex/pull/513):\n  Improve performance of compiling large Unicode classes by 8-10%.\n\nBug fixes:\n\n* [BUG #533](https://github.com/rust-lang/regex/issues/533):\n  Fix definition of `[[:blank:]]` class that regressed in `regex-syntax 0.5`.\n\n\n1.0.5 (2018-09-06)\n==================\nThis is a small release with an API enhancement.\n\nNew features:\n\n* [FEATURE #509](https://github.com/rust-lang/regex/pull/509):\n  Generalize impls of the `Replacer` trait.\n\n\n1.0.4 (2018-08-25)\n==================\nThis is a small release that bumps the quickcheck dependency.\n\n\n1.0.3 (2018-08-24)\n==================\nThis is a small bug fix release.\n\nBug fixes:\n\n* [BUG #504](https://github.com/rust-lang/regex/pull/504):\n  Fix for Cargo's \"minimal version\" support.\n* [BUG 1e39165f](https://github.com/rust-lang/regex/commit/1e39165f):\n  Fix doc examples for byte regexes.\n\n\n1.0.2 (2018-07-18)\n==================\nThis release exposes some new lower level APIs on `Regex` that permit\namortizing allocation and controlling the location at which a search is\nperformed in a more granular way. Most users of the regex crate will not\nneed or want to use these APIs.\n\nNew features:\n\n* [FEATURE #493](https://github.com/rust-lang/regex/pull/493):\n  Add a few lower level APIs for amortizing allocation and more fine grained\n  searching.\n\nBug fixes:\n\n* [BUG 3981d2ad](https://github.com/rust-lang/regex/commit/3981d2ad):\n  Correct outdated documentation on `RegexBuilder::dot_matches_new_line`.\n* [BUG 7ebe4ae0](https://github.com/rust-lang/regex/commit/7ebe4ae0):\n  Correct outdated documentation on `Parser::allow_invalid_utf8` in the\n  `regex-syntax` crate.\n* [BUG 24c7770b](https://github.com/rust-lang/regex/commit/24c7770b):\n  Fix a bug in the HIR printer where it wouldn't correctly escape meta\n  characters in character classes.\n\n\n1.0.1 (2018-06-19)\n==================\nThis release upgrades regex's Unicode tables to Unicode 11, and enables SIMD\noptimizations automatically on Rust stable (1.27 or newer).\n\nNew features:\n\n* [FEATURE #486](https://github.com/rust-lang/regex/pull/486):\n  Implement `size_hint` on `RegexSet` match iterators.\n* [FEATURE #488](https://github.com/rust-lang/regex/pull/488):\n  Update Unicode tables for Unicode 11.\n* [FEATURE #490](https://github.com/rust-lang/regex/pull/490):\n  SIMD optimizations are now enabled automatically in Rust stable, for versions\n  1.27 and up. No compilation flags or features need to be set. CPU support\n  SIMD is detected automatically at runtime.\n\nBug fixes:\n\n* [BUG #482](https://github.com/rust-lang/regex/pull/482):\n  Present a better compilation error when the `use_std` feature isn't used.\n\n\n1.0.0 (2018-05-01)\n==================\nThis release marks the 1.0 release of regex.\n\nWhile this release includes some breaking changes, most users of older versions\nof the regex library should be able to migrate to 1.0 by simply bumping the\nversion number. The important changes are as follows:\n\n* We adopt Rust 1.20 as the new minimum supported version of Rust for regex.\n  We also tentativley adopt a policy that permits bumping the minimum supported\n  version of Rust in minor version releases of regex, but no patch releases.\n  That is, with respect to semver, we do not strictly consider bumping the\n  minimum version of Rust to be a breaking change, but adopt a conservative\n  stance as a compromise.\n* Octal syntax in regular expressions has been disabled by default. This\n  permits better error messages that inform users that backreferences aren't\n  available. Octal syntax can be re-enabled via the corresponding option on\n  `RegexBuilder`.\n* `(?-u:\\B)` is no longer allowed in Unicode regexes since it can match at\n  invalid UTF-8 code unit boundaries. `(?-u:\\b)` is still allowed in Unicode\n  regexes.\n* The `From<regex_syntax::Error>` impl has been removed. This formally removes\n  the public dependency on `regex-syntax`.\n* A new feature, `use_std`, has been added and enabled by default. Disabling\n  the feature will result in a compilation error. In the future, this may\n  permit us to support `no_std` environments (w/ `alloc`) in a backwards\n  compatible way.\n\nFor more information and discussion, please see\n[1.0 release tracking issue](https://github.com/rust-lang/regex/issues/457).\n\n\n0.2.11 (2018-05-01)\n===================\nThis release primarily contains bug fixes. Some of them resolve bugs where\nthe parser could panic.\n\nNew features:\n\n* [FEATURE #459](https://github.com/rust-lang/regex/pull/459):\n  Include C++'s standard regex library and Boost's regex library in the\n  benchmark harness. We now include D/libphobos, C++/std, C++/boost, Oniguruma,\n  PCRE1, PCRE2, RE2 and Tcl in the harness.\n\nBug fixes:\n\n* [BUG #445](https://github.com/rust-lang/regex/issues/445):\n  Clarify order of indices returned by RegexSet match iterator.\n* [BUG #461](https://github.com/rust-lang/regex/issues/461):\n  Improve error messages for invalid regexes like `[\\d-a]`.\n* [BUG #464](https://github.com/rust-lang/regex/issues/464):\n  Fix a bug in the error message pretty printer that could cause a panic when\n  a regex contained a literal `\\n` character.\n* [BUG #465](https://github.com/rust-lang/regex/issues/465):\n  Fix a panic in the parser that was caused by applying a repetition operator\n  to `(?flags)`.\n* [BUG #466](https://github.com/rust-lang/regex/issues/466):\n  Fix a bug where `\\pC` was not recognized as an alias for `\\p{Other}`.\n* [BUG #470](https://github.com/rust-lang/regex/pull/470):\n  Fix a bug where literal searches did more work than necessary for anchored\n  regexes.\n\n\n0.2.10 (2018-03-16)\n===================\nThis release primarily updates the regex crate to changes made in `std::arch`\non nightly Rust.\n\nNew features:\n\n* [FEATURE #458](https://github.com/rust-lang/regex/pull/458):\n  The `Hir` type in `regex-syntax` now has a printer.\n\n\n0.2.9 (2018-03-12)\n==================\nThis release introduces a new nightly only feature, `unstable`, which enables\nSIMD optimizations for certain types of regexes. No additional compile time\noptions are necessary, and the regex crate will automatically choose the\nbest CPU features at run time. As a result, the `simd` (nightly only) crate\ndependency has been dropped.\n\nNew features:\n\n* [FEATURE #456](https://github.com/rust-lang/regex/pull/456):\n  The regex crate now includes AVX2 optimizations in addition to the extant\n  SSSE3 optimization.\n\nBug fixes:\n\n* [BUG #455](https://github.com/rust-lang/regex/pull/455):\n  Fix a bug where `(?x)[ / - ]` failed to parse.\n\n\n0.2.8 (2018-03-12)\n==================\nBug gixes:\n\n* [BUG #454](https://github.com/rust-lang/regex/pull/454):\n  Fix a bug in the nest limit checker being too aggressive.\n\n\n0.2.7 (2018-03-07)\n==================\nThis release includes a ground-up rewrite of the regex-syntax crate, which has\nbeen in development for over a year.\n731\nNew features:\n\n* Error messages for invalid regexes have been greatly improved. You get these\n  automatically; you don't need to do anything. In addition to better\n  formatting, error messages will now explicitly call out the use of look\n  around. When regex 1.0 is released, this will happen for backreferences as\n  well.\n* Full support for intersection, difference and symmetric difference of\n  character classes. These can be used via the `&&`, `--` and `~~` binary\n  operators within classes.\n* A Unicode Level 1 conformat implementation of `\\p{..}` character classes.\n  Things like `\\p{scx:Hira}`, `\\p{age:3.2}` or `\\p{Changes_When_Casefolded}`\n  now work. All property name and value aliases are supported, and properties\n  are selected via loose matching. e.g., `\\p{Greek}` is the same as\n  `\\p{G r E e K}`.\n* A new `UNICODE.md` document has been added to this repository that\n  exhaustively documents support for UTS#18.\n* Empty sub-expressions are now permitted in most places. That is, `()+` is\n  now a valid regex.\n* Almost everything in regex-syntax now uses constant stack space, even when\n  performing analysis that requires structural induction. This reduces the risk\n  of a user provided regular expression causing a stack overflow.\n* [FEATURE #174](https://github.com/rust-lang/regex/issues/174):\n  The `Ast` type in `regex-syntax` now contains span information.\n* [FEATURE #424](https://github.com/rust-lang/regex/issues/424):\n  Support `\\u`, `\\u{...}`, `\\U` and `\\U{...}` syntax for specifying code points\n  in a regular expression.\n* [FEATURE #449](https://github.com/rust-lang/regex/pull/449):\n  Add a `Replace::by_ref` adapter for use of a replacer without consuming it.\n\nBug fixes:\n\n* [BUG #446](https://github.com/rust-lang/regex/issues/446):\n  We re-enable the Boyer-Moore literal matcher.\n\n\n0.2.6 (2018-02-08)\n==================\nBug fixes:\n\n* [BUG #446](https://github.com/rust-lang/regex/issues/446):\n  Fixes a bug in the new Boyer-Moore searcher that results in a match failure.\n  We fix this bug by temporarily disabling Boyer-Moore.\n\n\n0.2.5 (2017-12-30)\n==================\nBug fixes:\n\n* [BUG #437](https://github.com/rust-lang/regex/issues/437):\n  Fixes a bug in the new Boyer-Moore searcher that results in a panic.\n\n\n0.2.4 (2017-12-30)\n==================\nNew features:\n\n* [FEATURE #348](https://github.com/rust-lang/regex/pull/348):\n  Improve performance for capture searches on anchored regex.\n  (Contributed by @ethanpailes. Nice work!)\n* [FEATURE #419](https://github.com/rust-lang/regex/pull/419):\n  Expand literal searching to include Tuned Boyer-Moore in some cases.\n  (Contributed by @ethanpailes. Nice work!)\n\nBug fixes:\n\n* [BUG](https://github.com/rust-lang/regex/pull/436):\n  The regex compiler plugin has been removed.\n* [BUG](https://github.com/rust-lang/regex/pull/436):\n  `simd` has been bumped to `0.2.1`, which fixes a Rust nightly build error.\n* [BUG](https://github.com/rust-lang/regex/pull/436):\n  Bring the benchmark harness up to date.\n\n\n0.2.3 (2017-11-30)\n==================\nNew features:\n\n* [FEATURE #374](https://github.com/rust-lang/regex/pull/374):\n  Add `impl From<Match> for &str`.\n* [FEATURE #380](https://github.com/rust-lang/regex/pull/380):\n  Derive `Clone` and `PartialEq` on `Error`.\n* [FEATURE #400](https://github.com/rust-lang/regex/pull/400):\n  Update to Unicode 10.\n\nBug fixes:\n\n* [BUG #375](https://github.com/rust-lang/regex/issues/375):\n  Fix a bug that prevented the bounded backtracker from terminating.\n* [BUG #393](https://github.com/rust-lang/regex/issues/393),\n  [BUG #394](https://github.com/rust-lang/regex/issues/394):\n  Fix bug with `replace` methods for empty matches.\n\n\n0.2.2 (2017-05-21)\n==================\nNew features:\n\n* [FEATURE #341](https://github.com/rust-lang/regex/issues/341):\n  Support nested character classes and intersection operation.\n  For example, `[\\p{Greek}&&\\pL]` matches greek letters and\n  `[[0-9]&&[^4]]` matches every decimal digit except `4`.\n  (Much thanks to @robinst, who contributed this awesome feature.)\n\nBug fixes:\n\n* [BUG #321](https://github.com/rust-lang/regex/issues/321):\n  Fix bug in literal extraction and UTF-8 decoding.\n* [BUG #326](https://github.com/rust-lang/regex/issues/326):\n  Add documentation tip about the `(?x)` flag.\n* [BUG #333](https://github.com/rust-lang/regex/issues/333):\n  Show additional replacement example using curly braces.\n* [BUG #334](https://github.com/rust-lang/regex/issues/334):\n  Fix bug when resolving captures after a match.\n* [BUG #338](https://github.com/rust-lang/regex/issues/338):\n  Add example that uses `Captures::get` to API documentation.\n* [BUG #353](https://github.com/rust-lang/regex/issues/353):\n  Fix RegexSet bug that caused match failure in some cases.\n* [BUG #354](https://github.com/rust-lang/regex/pull/354):\n  Fix panic in parser when `(?x)` is used.\n* [BUG #358](https://github.com/rust-lang/regex/issues/358):\n  Fix literal optimization bug with RegexSet.\n* [BUG #359](https://github.com/rust-lang/regex/issues/359):\n  Fix example code in README.\n* [BUG #365](https://github.com/rust-lang/regex/pull/365):\n  Fix bug in `rure_captures_len` in the C binding.\n* [BUG #367](https://github.com/rust-lang/regex/issues/367):\n  Fix byte class bug that caused a panic.\n\n\n0.2.1\n=====\nOne major bug with `replace_all` has been fixed along with a couple of other\ntouchups.\n\n* [BUG #312](https://github.com/rust-lang/regex/issues/312):\n  Fix documentation for `NoExpand` to reference correct lifetime parameter.\n* [BUG #314](https://github.com/rust-lang/regex/issues/314):\n  Fix a bug with `replace_all` when replacing a match with the empty string.\n* [BUG #316](https://github.com/rust-lang/regex/issues/316):\n  Note a missing breaking change from the `0.2.0` CHANGELOG entry.\n  (`RegexBuilder::compile` was renamed to `RegexBuilder::build`.)\n* [BUG #324](https://github.com/rust-lang/regex/issues/324):\n  Compiling `regex` should only require one version of `memchr` crate.\n\n\n0.2.0\n=====\nThis is a new major release of the regex crate, and is an implementation of the\n[regex 1.0 RFC](https://github.com/rust-lang/rfcs/blob/master/text/1620-regex-1.0.md).\nWe are releasing a `0.2` first, and if there are no major problems, we will\nrelease a `1.0` shortly. For `0.2`, the minimum *supported* Rust version is\n1.12.\n\nThere are a number of **breaking changes** in `0.2`. They are split into two\ntypes. The first type correspond to breaking changes in regular expression\nsyntax. The second type correspond to breaking changes in the API.\n\nBreaking changes for regex syntax:\n\n* POSIX character classes now require double bracketing. Previously, the regex\n  `[:upper:]` would parse as the `upper` POSIX character class. Now it parses\n  as the character class containing the characters `:upper:`. The fix to this\n  change is to use `[[:upper:]]` instead. Note that variants like\n  `[[:upper:][:blank:]]` continue to work.\n* The character `[` must always be escaped inside a character class.\n* The characters `&`, `-` and `~` must be escaped if any one of them are\n  repeated consecutively. For example, `[&]`, `[\\&]`, `[\\&\\&]`, `[&-&]` are all\n  equivalent while `[&&]` is illegal. (The motivation for this and the prior\n  change is to provide a backwards compatible path for adding character class\n  set notation.)\n* A `bytes::Regex` now has Unicode mode enabled by default (like the main\n  `Regex` type). This means regexes compiled with `bytes::Regex::new` that\n  don't have the Unicode flag set should add `(?-u)` to recover the original\n  behavior.\n\nBreaking changes for the regex API:\n\n* `find` and `find_iter` now **return `Match` values instead of\n  `(usize, usize)`.** `Match` values have `start` and `end` methods, which\n  return the match offsets. `Match` values also have an `as_str` method,\n  which returns the text of the match itself.\n* The `Captures` type now only provides a single iterator over all capturing\n  matches, which should replace uses of `iter` and `iter_pos`. Uses of\n  `iter_named` should use the `capture_names` method on `Regex`.\n* The `at` method on the `Captures` type has been renamed to `get`, and it\n  now returns a `Match`. Similarly, the `name` method on `Captures` now returns\n  a `Match`.\n* The `replace` methods now return `Cow` values. The `Cow::Borrowed` variant\n  is returned when no replacements are made.\n* The `Replacer` trait has been completely overhauled. This should only\n  impact clients that implement this trait explicitly. Standard uses of\n  the `replace` methods should continue to work unchanged. If you implement\n  the `Replacer` trait, please consult the new documentation.\n* The `quote` free function has been renamed to `escape`.\n* The `Regex::with_size_limit` method has been removed. It is replaced by\n  `RegexBuilder::size_limit`.\n* The `RegexBuilder` type has switched from owned `self` method receivers to\n  `&mut self` method receivers. Most uses will continue to work unchanged, but\n  some code may require naming an intermediate variable to hold the builder.\n* The `compile` method on `RegexBuilder` has been renamed to `build`.\n* The free `is_match` function has been removed. It is replaced by compiling\n  a `Regex` and calling its `is_match` method.\n* The `PartialEq` and `Eq` impls on `Regex` have been dropped. If you relied\n  on these impls, the fix is to define a wrapper type around `Regex`, impl\n  `Deref` on it and provide the necessary impls.\n* The `is_empty` method on `Captures` has been removed. This always returns\n  `false`, so its use is superfluous.\n* The `Syntax` variant of the `Error` type now contains a string instead of\n  a `regex_syntax::Error`. If you were examining syntax errors more closely,\n  you'll need to explicitly use the `regex_syntax` crate to re-parse the regex.\n* The `InvalidSet` variant of the `Error` type has been removed since it is\n  no longer used.\n* Most of the iterator types have been renamed to match conventions. If you\n  were using these iterator types explicitly, please consult the documentation\n  for its new name. For example, `RegexSplits` has been renamed to `Split`.\n\nA number of bugs have been fixed:\n\n* [BUG #151](https://github.com/rust-lang/regex/issues/151):\n  The `Replacer` trait has been changed to permit the caller to control\n  allocation.\n* [BUG #165](https://github.com/rust-lang/regex/issues/165):\n  Remove the free `is_match` function.\n* [BUG #166](https://github.com/rust-lang/regex/issues/166):\n  Expose more knobs (available in `0.1`) and remove `with_size_limit`.\n* [BUG #168](https://github.com/rust-lang/regex/issues/168):\n  Iterators produced by `Captures` now have the correct lifetime parameters.\n* [BUG #175](https://github.com/rust-lang/regex/issues/175):\n  Fix a corner case in the parsing of POSIX character classes.\n* [BUG #178](https://github.com/rust-lang/regex/issues/178):\n  Drop the `PartialEq` and `Eq` impls on `Regex`.\n* [BUG #179](https://github.com/rust-lang/regex/issues/179):\n  Remove `is_empty` from `Captures` since it always returns false.\n* [BUG #276](https://github.com/rust-lang/regex/issues/276):\n  Position of named capture can now be retrieved from a `Captures`.\n* [BUG #296](https://github.com/rust-lang/regex/issues/296):\n  Remove winapi/kernel32-sys dependency on UNIX.\n* [BUG #307](https://github.com/rust-lang/regex/issues/307):\n  Fix error on emscripten.\n\n\n0.1.80\n======\n* [PR #292](https://github.com/rust-lang/regex/pull/292):\n  Fixes bug #291, which was introduced by PR #290.\n\n0.1.79\n======\n* Require regex-syntax 0.3.8.\n\n0.1.78\n======\n* [PR #290](https://github.com/rust-lang/regex/pull/290):\n  Fixes bug #289, which caused some regexes with a certain combination\n  of literals to match incorrectly.\n\n0.1.77\n======\n* [PR #281](https://github.com/rust-lang/regex/pull/281):\n  Fixes bug #280 by disabling all literal optimizations when a pattern\n  is partially anchored.\n\n0.1.76\n======\n* Tweak criteria for using the Teddy literal matcher.\n\n0.1.75\n======\n* [PR #275](https://github.com/rust-lang/regex/pull/275):\n  Improves match verification performance in the Teddy SIMD searcher.\n* [PR #278](https://github.com/rust-lang/regex/pull/278):\n  Replaces slow substring loop in the Teddy SIMD searcher with Aho-Corasick.\n* Implemented DoubleEndedIterator on regex set match iterators.\n\n0.1.74\n======\n* Release regex-syntax 0.3.5 with a minor bug fix.\n* Fix bug #272.\n* Fix bug #277.\n* [PR #270](https://github.com/rust-lang/regex/pull/270):\n  Fixes bugs #264, #268 and an unreported where the DFA cache size could be\n  drastically under estimated in some cases (leading to high unexpected memory\n  usage).\n\n0.1.73\n======\n* Release `regex-syntax 0.3.4`.\n* Bump `regex-syntax` dependency version for `regex` to `0.3.4`.\n\n0.1.72\n======\n* [PR #262](https://github.com/rust-lang/regex/pull/262):\n  Fixes a number of small bugs caught by fuzz testing (AFL).\n\n0.1.71\n======\n* [PR #236](https://github.com/rust-lang/regex/pull/236):\n  Fix a bug in how suffix literals were extracted, which could lead\n  to invalid match behavior in some cases.\n\n0.1.70\n======\n* [PR #231](https://github.com/rust-lang/regex/pull/231):\n  Add SIMD accelerated multiple pattern search.\n* [PR #228](https://github.com/rust-lang/regex/pull/228):\n  Reintroduce the reverse suffix literal optimization.\n* [PR #226](https://github.com/rust-lang/regex/pull/226):\n  Implements NFA state compression in the lazy DFA.\n* [PR #223](https://github.com/rust-lang/regex/pull/223):\n  A fully anchored RegexSet can now short-circuit.\n\n0.1.69\n======\n* [PR #216](https://github.com/rust-lang/regex/pull/216):\n  Tweak the threshold for running backtracking.\n* [PR #217](https://github.com/rust-lang/regex/pull/217):\n  Add upper limit (from the DFA) to capture search (for the NFA).\n* [PR #218](https://github.com/rust-lang/regex/pull/218):\n  Add rure, a C API.\n\n0.1.68\n======\n* [PR #210](https://github.com/rust-lang/regex/pull/210):\n  Fixed a performance bug in `bytes::Regex::replace` where `extend` was used\n  instead of `extend_from_slice`.\n* [PR #211](https://github.com/rust-lang/regex/pull/211):\n  Fixed a bug in the handling of word boundaries in the DFA.\n* [PR #213](https://github.com/rust-lang/pull/213):\n  Added RE2 and Tcl to the benchmark harness. Also added a CLI utility from\n  running regexes using any of the following regex engines: PCRE1, PCRE2,\n  Oniguruma, RE2, Tcl and of course Rust's own regexes.\n\n0.1.67\n======\n* [PR #201](https://github.com/rust-lang/regex/pull/201):\n  Fix undefined behavior in the `regex!` compiler plugin macro.\n* [PR #205](https://github.com/rust-lang/regex/pull/205):\n  More improvements to DFA performance. Competitive with RE2. See PR for\n  benchmarks.\n* [PR #209](https://github.com/rust-lang/regex/pull/209):\n  Release 0.1.66 was semver incompatible since it required a newer version\n  of Rust than previous releases. This PR fixes that. (And `0.1.66` was\n  yanked.)\n\n0.1.66\n======\n* Speculative support for Unicode word boundaries was added to the DFA. This\n  should remove the last common case that disqualified use of the DFA.\n* An optimization that scanned for suffix literals and then matched the regular\n  expression in reverse was removed because it had worst case quadratic time\n  complexity. It was replaced with a more limited optimization where, given any\n  regex of the form `re$`, it will be matched in reverse from the end of the\n  haystack.\n* [PR #202](https://github.com/rust-lang/regex/pull/202):\n  The inner loop of the DFA was heavily optimized to improve cache locality\n  and reduce the overall number of instructions run on each iteration. This\n  represents the first use of `unsafe` in `regex` (to elide bounds checks).\n* [PR #200](https://github.com/rust-lang/regex/pull/200):\n  Use of the `mempool` crate (which used thread local storage) was replaced\n  with a faster version of a similar API in @Amanieu's `thread_local` crate.\n  It should reduce contention when using a regex from multiple threads\n  simultaneously.\n* PCRE2 JIT benchmarks were added. A benchmark comparison can be found\n  [here](https://gist.github.com/anonymous/14683c01993e91689f7206a18675901b).\n  (Includes a comparison with PCRE1's JIT and Oniguruma.)\n* A bug where word boundaries weren't being matched correctly in the DFA was\n  fixed. This only affected use of `bytes::Regex`.\n* [#160](https://github.com/rust-lang/regex/issues/160):\n  `Captures` now has a `Debug` impl.\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 8.1357421875,
          "content": "[package]\nname = \"regex\"\nversion = \"1.11.1\"  #:version\nauthors = [\"The Rust Project Developers\", \"Andrew Gallant <jamslam@gmail.com>\"]\nlicense = \"MIT OR Apache-2.0\"\nreadme = \"README.md\"\nrepository = \"https://github.com/rust-lang/regex\"\ndocumentation = \"https://docs.rs/regex\"\nhomepage = \"https://github.com/rust-lang/regex\"\ndescription = \"\"\"\nAn implementation of regular expressions for Rust. This implementation uses\nfinite automata and guarantees linear time matching on all inputs.\n\"\"\"\ncategories = [\"text-processing\"]\nautotests = false\nexclude = [\"/scripts/*\", \"/.github/*\"]\nedition = \"2021\"\nrust-version = \"1.65\"\n\n[workspace]\nmembers = [\n  \"regex-automata\",\n  \"regex-capi\",\n  \"regex-cli\",\n  \"regex-lite\",\n  \"regex-syntax\",\n  \"regex-test\",\n]\n\n# Features are documented in the \"Crate features\" section of the crate docs:\n# https://docs.rs/regex/*/#crate-features\n[features]\ndefault = [\"std\", \"perf\", \"unicode\", \"regex-syntax/default\"]\n\n# ECOSYSTEM FEATURES\n\n# The 'std' feature permits the regex crate to use the standard library. This\n# is intended to support future use cases where the regex crate may be able\n# to compile without std, and instead just rely on 'core' and 'alloc' (for\n# example). Currently, this isn't supported, and removing the 'std' feature\n# will prevent regex from compiling.\nstd = [\n  \"aho-corasick?/std\",\n  \"memchr?/std\",\n  \"regex-automata/std\",\n  \"regex-syntax/std\",\n]\n# This feature enables the 'log' crate to emit messages. This is usually\n# only useful for folks working on the regex crate itself, but can be useful\n# if you're trying hard to do some performance hacking on regex patterns\n# themselves. Note that you'll need to pair this with a crate like 'env_logger'\n# to actually emit the log messages somewhere.\nlogging = [\n  \"aho-corasick?/logging\",\n  \"memchr?/logging\",\n  \"regex-automata/logging\",\n]\n# The 'use_std' feature is DEPRECATED. It will be removed in regex 2. Until\n# then, it is an alias for the 'std' feature.\nuse_std = [\"std\"]\n\n\n# PERFORMANCE FEATURES\n\n# Enables all default performance features. Note that this specifically does\n# not include perf-dfa-full, because it leads to higher compile times and\n# bigger binaries, and the runtime performance improvement is not obviously\n# worth it.\nperf = [\n  \"perf-cache\",\n  \"perf-dfa\",\n  \"perf-onepass\",\n  \"perf-backtrack\",\n  \"perf-inline\",\n  \"perf-literal\",\n]\n# Enables use of a lazy DFA when possible.\nperf-dfa = [\"regex-automata/hybrid\"]\n# Enables use of a fully compiled DFA when possible.\nperf-dfa-full = [\"regex-automata/dfa-build\", \"regex-automata/dfa-search\"]\n# Enables use of the one-pass regex matcher, which speeds up capture searches\n# even beyond the backtracker.\nperf-onepass = [\"regex-automata/dfa-onepass\"]\n# Enables use of a bounded backtracker, which speeds up capture searches.\nperf-backtrack = [\"regex-automata/nfa-backtrack\"]\n# Enables aggressive use of inlining.\nperf-inline = [\"regex-automata/perf-inline\"]\n# Enables literal optimizations.\nperf-literal = [\n  \"dep:aho-corasick\",\n  \"dep:memchr\",\n  \"regex-automata/perf-literal\",\n]\n# Enables fast caching. (If disabled, caching is still used, but is slower.)\n# Currently, this feature has no effect. It used to remove the thread_local\n# dependency and use a slower internal cache, but now the default cache has\n# been improved and thread_local is no longer a dependency at all.\nperf-cache = []\n\n\n# UNICODE DATA FEATURES\n\n# Enables all Unicode features. This expands if new Unicode features are added.\nunicode = [\n  \"unicode-age\",\n  \"unicode-bool\",\n  \"unicode-case\",\n  \"unicode-gencat\",\n  \"unicode-perl\",\n  \"unicode-script\",\n  \"unicode-segment\",\n  \"regex-automata/unicode\",\n  \"regex-syntax/unicode\",\n]\n# Enables use of the `Age` property, e.g., `\\p{Age:3.0}`.\nunicode-age = [\n  \"regex-automata/unicode-age\",\n  \"regex-syntax/unicode-age\",\n]\n# Enables use of a smattering of boolean properties, e.g., `\\p{Emoji}`.\nunicode-bool = [\n  \"regex-automata/unicode-bool\",\n  \"regex-syntax/unicode-bool\",\n]\n# Enables Unicode-aware case insensitive matching, e.g., `(?i)Î²`.\nunicode-case = [\n  \"regex-automata/unicode-case\",\n  \"regex-syntax/unicode-case\",\n]\n# Enables Unicode general categories, e.g., `\\p{Letter}` or `\\pL`.\nunicode-gencat = [\n  \"regex-automata/unicode-gencat\",\n  \"regex-syntax/unicode-gencat\",\n]\n# Enables Unicode-aware Perl classes corresponding to `\\w`, `\\s` and `\\d`.\nunicode-perl = [\n  \"regex-automata/unicode-perl\",\n  \"regex-automata/unicode-word-boundary\",\n  \"regex-syntax/unicode-perl\",\n]\n# Enables Unicode scripts and script extensions, e.g., `\\p{Greek}`.\nunicode-script = [\n  \"regex-automata/unicode-script\",\n  \"regex-syntax/unicode-script\",\n]\n# Enables Unicode segmentation properties, e.g., `\\p{gcb=Extend}`.\nunicode-segment = [\n  \"regex-automata/unicode-segment\",\n  \"regex-syntax/unicode-segment\",\n]\n\n\n# UNSTABLE FEATURES (requires Rust nightly)\n\n# A blanket feature that governs whether unstable features are enabled or not.\n# Unstable features are disabled by default, and typically rely on unstable\n# features in rustc itself.\nunstable = [\"pattern\"]\n\n# Enable to use the unstable pattern traits defined in std. This is enabled\n# by default if the unstable feature is enabled.\npattern = []\n\n# For very fast multi-prefix literal matching.\n[dependencies.aho-corasick]\nversion = \"1.0.0\"\noptional = true\ndefault-features = false\n\n# For skipping along search text quickly when a leading byte is known.\n[dependencies.memchr]\nversion = \"2.6.0\"\noptional = true\ndefault-features = false\n\n# For the actual regex engines.\n[dependencies.regex-automata]\npath = \"regex-automata\"\nversion = \"0.4.8\"\ndefault-features = false\nfeatures = [\"alloc\", \"syntax\", \"meta\", \"nfa-pikevm\"]\n\n# For parsing regular expressions.\n[dependencies.regex-syntax]\npath = \"regex-syntax\"\nversion = \"0.8.5\"\ndefault-features = false\n\n[dev-dependencies]\n# For examples.\nonce_cell = \"1.17.1\"\n# For property based tests.\nquickcheck = { version = \"1.0.3\", default-features = false }\n# To check README's example\ndoc-comment = \"0.3\"\n# For easy error handling in integration tests.\nanyhow = \"1.0.69\"\n# A library for testing regex engines.\nregex-test = { path = \"regex-test\", version = \"0.1.0\" }\n\n[dev-dependencies.env_logger]\n# Note that this is currently using an older version because of the dependency\n# tree explosion that happened in 0.10.\nversion = \"0.9.3\"\ndefault-features = false\nfeatures = [\"atty\", \"humantime\", \"termcolor\"]\n\n# This test suite reads a whole boatload of tests from the top-level testdata\n# directory, and then runs them against the regex crate API.\n#\n# regex-automata has its own version of them, and runs them against each\n# internal regex engine individually.\n#\n# This means that if you're seeing a failure in this test suite, you should\n# try running regex-automata's tests:\n#\n#     cargo test --manifest-path regex-automata/Cargo.toml --test integration\n#\n# That *might* give you a more targeted test failure. i.e., \"only the\n# PikeVM fails this test.\" Which gives you a narrower place to search. If\n# regex-automata's test suite passes, then the bug might be in the integration\n# of the regex crate and regex-automata. But generally speaking, a failure\n# in this test suite *should* mean there is a corresponding failure in\n# regex-automata's test suite.\n[[test]]\npath = \"tests/lib.rs\"\nname = \"integration\"\n\n[package.metadata.docs.rs]\n# We want to document all features.\nall-features = true\n# Since this crate's feature setup is pretty complicated, it is worth opting\n# into a nightly unstable option to show the features that need to be enabled\n# for public API items. To do that, we set 'docsrs', and when that's enabled,\n# we enable the 'doc_auto_cfg' feature.\n#\n# To test this locally, run:\n#\n#     RUSTDOCFLAGS=\"--cfg docsrs\" cargo +nightly doc --all-features\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n\n[profile.release]\ndebug = true\n\n[profile.bench]\ndebug = true\n\n[profile.dev]\n# Running tests takes too long in debug mode, so we forcefully always build\n# with optimizations. Unfortunate, but, Â¯\\_(ãƒ„)_/Â¯.\n#\n# It's counter-intuitive that this needs to be set on dev *and* test, but\n# it's because the tests that take a long time to run are run as integration\n# tests in a separate crate. The test.opt-level setting won't apply there, so\n# we need to set the opt-level across the entire build.\nopt-level = 3\ndebug = true\n\n[profile.test]\nopt-level = 3\ndebug = true\n"
        },
        {
          "name": "Cross.toml",
          "type": "blob",
          "size": 0.109375,
          "content": "[build.env]\npassthrough = [\n    \"RUST_BACKTRACE\",\n    \"RUST_LOG\",\n    \"REGEX_TEST\",\n    \"REGEX_TEST_VERBOSE\",\n]\n"
        },
        {
          "name": "LICENSE-APACHE",
          "type": "blob",
          "size": 10.5927734375,
          "content": "                              Apache License\n                        Version 2.0, January 2004\n                     http://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n   \"License\" shall mean the terms and conditions for use, reproduction,\n   and distribution as defined by Sections 1 through 9 of this document.\n\n   \"Licensor\" shall mean the copyright owner or entity authorized by\n   the copyright owner that is granting the License.\n\n   \"Legal Entity\" shall mean the union of the acting entity and all\n   other entities that control, are controlled by, or are under common\n   control with that entity. For the purposes of this definition,\n   \"control\" means (i) the power, direct or indirect, to cause the\n   direction or management of such entity, whether by contract or\n   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n   outstanding shares, or (iii) beneficial ownership of such entity.\n\n   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n   exercising permissions granted by this License.\n\n   \"Source\" form shall mean the preferred form for making modifications,\n   including but not limited to software source code, documentation\n   source, and configuration files.\n\n   \"Object\" form shall mean any form resulting from mechanical\n   transformation or translation of a Source form, including but\n   not limited to compiled object code, generated documentation,\n   and conversions to other media types.\n\n   \"Work\" shall mean the work of authorship, whether in Source or\n   Object form, made available under the License, as indicated by a\n   copyright notice that is included in or attached to the work\n   (an example is provided in the Appendix below).\n\n   \"Derivative Works\" shall mean any work, whether in Source or Object\n   form, that is based on (or derived from) the Work and for which the\n   editorial revisions, annotations, elaborations, or other modifications\n   represent, as a whole, an original work of authorship. For the purposes\n   of this License, Derivative Works shall not include works that remain\n   separable from, or merely link (or bind by name) to the interfaces of,\n   the Work and Derivative Works thereof.\n\n   \"Contribution\" shall mean any work of authorship, including\n   the original version of the Work and any modifications or additions\n   to that Work or Derivative Works thereof, that is intentionally\n   submitted to Licensor for inclusion in the Work by the copyright owner\n   or by an individual or Legal Entity authorized to submit on behalf of\n   the copyright owner. For the purposes of this definition, \"submitted\"\n   means any form of electronic, verbal, or written communication sent\n   to the Licensor or its representatives, including but not limited to\n   communication on electronic mailing lists, source code control systems,\n   and issue tracking systems that are managed by, or on behalf of, the\n   Licensor for the purpose of discussing and improving the Work, but\n   excluding communication that is conspicuously marked or otherwise\n   designated in writing by the copyright owner as \"Not a Contribution.\"\n\n   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n   on behalf of whom a Contribution has been received by Licensor and\n   subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   copyright license to reproduce, prepare Derivative Works of,\n   publicly display, publicly perform, sublicense, and distribute the\n   Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   (except as stated in this section) patent license to make, have made,\n   use, offer to sell, sell, import, and otherwise transfer the Work,\n   where such license applies only to those patent claims licensable\n   by such Contributor that are necessarily infringed by their\n   Contribution(s) alone or by combination of their Contribution(s)\n   with the Work to which such Contribution(s) was submitted. If You\n   institute patent litigation against any entity (including a\n   cross-claim or counterclaim in a lawsuit) alleging that the Work\n   or a Contribution incorporated within the Work constitutes direct\n   or contributory patent infringement, then any patent licenses\n   granted to You under this License for that Work shall terminate\n   as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the\n   Work or Derivative Works thereof in any medium, with or without\n   modifications, and in Source or Object form, provided that You\n   meet the following conditions:\n\n   (a) You must give any other recipients of the Work or\n       Derivative Works a copy of this License; and\n\n   (b) You must cause any modified files to carry prominent notices\n       stating that You changed the files; and\n\n   (c) You must retain, in the Source form of any Derivative Works\n       that You distribute, all copyright, patent, trademark, and\n       attribution notices from the Source form of the Work,\n       excluding those notices that do not pertain to any part of\n       the Derivative Works; and\n\n   (d) If the Work includes a \"NOTICE\" text file as part of its\n       distribution, then any Derivative Works that You distribute must\n       include a readable copy of the attribution notices contained\n       within such NOTICE file, excluding those notices that do not\n       pertain to any part of the Derivative Works, in at least one\n       of the following places: within a NOTICE text file distributed\n       as part of the Derivative Works; within the Source form or\n       documentation, if provided along with the Derivative Works; or,\n       within a display generated by the Derivative Works, if and\n       wherever such third-party notices normally appear. The contents\n       of the NOTICE file are for informational purposes only and\n       do not modify the License. You may add Your own attribution\n       notices within Derivative Works that You distribute, alongside\n       or as an addendum to the NOTICE text from the Work, provided\n       that such additional attribution notices cannot be construed\n       as modifying the License.\n\n   You may add Your own copyright statement to Your modifications and\n   may provide additional or different license terms and conditions\n   for use, reproduction, or distribution of Your modifications, or\n   for any such Derivative Works as a whole, provided Your use,\n   reproduction, and distribution of the Work otherwise complies with\n   the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise,\n   any Contribution intentionally submitted for inclusion in the Work\n   by You to the Licensor shall be under the terms and conditions of\n   this License, without any additional terms or conditions.\n   Notwithstanding the above, nothing herein shall supersede or modify\n   the terms of any separate license agreement you may have executed\n   with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade\n   names, trademarks, service marks, or product names of the Licensor,\n   except as required for reasonable and customary use in describing the\n   origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or\n   agreed to in writing, Licensor provides the Work (and each\n   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n   implied, including, without limitation, any warranties or conditions\n   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n   PARTICULAR PURPOSE. You are solely responsible for determining the\n   appropriateness of using or redistributing the Work and assume any\n   risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory,\n   whether in tort (including negligence), contract, or otherwise,\n   unless required by applicable law (such as deliberate and grossly\n   negligent acts) or agreed to in writing, shall any Contributor be\n   liable to You for damages, including any direct, indirect, special,\n   incidental, or consequential damages of any character arising as a\n   result of this License or out of the use or inability to use the\n   Work (including but not limited to damages for loss of goodwill,\n   work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses), even if such Contributor\n   has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing\n   the Work or Derivative Works thereof, You may choose to offer,\n   and charge a fee for, acceptance of support, warranty, indemnity,\n   or other liability obligations and/or rights consistent with this\n   License. However, in accepting such obligations, You may act only\n   on Your own behalf and on Your sole responsibility, not on behalf\n   of any other Contributor, and only if You agree to indemnify,\n   defend, and hold each Contributor harmless for any liability\n   incurred by, or claims asserted against, such Contributor by reason\n   of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work.\n\n   To apply the Apache License to your work, attach the following\n   boilerplate notice, with the fields enclosed by brackets \"[]\"\n   replaced with your own identifying information. (Don't include\n   the brackets!)  The text should be enclosed in the appropriate\n   comment syntax for the file format. We also recommend that a\n   file or class name and description of purpose be included on the\n   same \"printed page\" as the copyright notice for easier\n   identification within third-party archives.\n\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.0458984375,
          "content": "Copyright (c) 2014 The Rust Project Developers\n\nPermission is hereby granted, free of charge, to any\nperson obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without\nlimitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice\nshall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\nSHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.7412109375,
          "content": "regex\n=====\nThis crate provides routines for searching strings for matches of a [regular\nexpression] (aka \"regex\"). The regex syntax supported by this crate is similar\nto other regex engines, but it lacks several features that are not known how to\nimplement efficiently. This includes, but is not limited to, look-around and\nbackreferences. In exchange, all regex searches in this crate have worst case\n`O(m * n)` time complexity, where `m` is proportional to the size of the regex\nand `n` is proportional to the size of the string being searched.\n\n[regular expression]: https://en.wikipedia.org/wiki/Regular_expression\n\n[![Build status](https://github.com/rust-lang/regex/workflows/ci/badge.svg)](https://github.com/rust-lang/regex/actions)\n[![Crates.io](https://img.shields.io/crates/v/regex.svg)](https://crates.io/crates/regex)\n\n### Documentation\n\n[Module documentation with examples](https://docs.rs/regex).\nThe module documentation also includes a comprehensive description of the\nsyntax supported.\n\nDocumentation with examples for the various matching functions and iterators\ncan be found on the\n[`Regex` type](https://docs.rs/regex/*/regex/struct.Regex.html).\n\n### Usage\n\nTo bring this crate into your repository, either add `regex` to your\n`Cargo.toml`, or run `cargo add regex`.\n\nHere's a simple example that matches a date in YYYY-MM-DD format and prints the\nyear, month and day:\n\n```rust\nuse regex::Regex;\n\nfn main() {\n    let re = Regex::new(r\"(?x)\n(?P<year>\\d{4})  # the year\n-\n(?P<month>\\d{2}) # the month\n-\n(?P<day>\\d{2})   # the day\n\").unwrap();\n\n    let caps = re.captures(\"2010-03-14\").unwrap();\n    assert_eq!(\"2010\", &caps[\"year\"]);\n    assert_eq!(\"03\", &caps[\"month\"]);\n    assert_eq!(\"14\", &caps[\"day\"]);\n}\n```\n\nIf you have lots of dates in text that you'd like to iterate over, then it's\neasy to adapt the above example with an iterator:\n\n```rust\nuse regex::Regex;\n\nfn main() {\n    let re = Regex::new(r\"(\\d{4})-(\\d{2})-(\\d{2})\").unwrap();\n    let hay = \"On 2010-03-14, foo happened. On 2014-10-14, bar happened.\";\n\n    let mut dates = vec![];\n    for (_, [year, month, day]) in re.captures_iter(hay).map(|c| c.extract()) {\n        dates.push((year, month, day));\n    }\n    assert_eq!(dates, vec![\n      (\"2010\", \"03\", \"14\"),\n      (\"2014\", \"10\", \"14\"),\n    ]);\n}\n```\n\n### Usage: Avoid compiling the same regex in a loop\n\nIt is an anti-pattern to compile the same regular expression in a loop since\ncompilation is typically expensive. (It takes anywhere from a few microseconds\nto a few **milliseconds** depending on the size of the regex.) Not only is\ncompilation itself expensive, but this also prevents optimizations that reuse\nallocations internally to the matching engines.\n\nIn Rust, it can sometimes be a pain to pass regular expressions around if\nthey're used from inside a helper function. Instead, we recommend using the\n[`once_cell`](https://crates.io/crates/once_cell) crate to ensure that\nregular expressions are compiled exactly once. For example:\n\n```rust\nuse {\n    once_cell::sync::Lazy,\n    regex::Regex,\n};\n\nfn some_helper_function(haystack: &str) -> bool {\n    static RE: Lazy<Regex> = Lazy::new(|| Regex::new(r\"...\").unwrap());\n    RE.is_match(haystack)\n}\n\nfn main() {\n    assert!(some_helper_function(\"abc\"));\n    assert!(!some_helper_function(\"ac\"));\n}\n```\n\nSpecifically, in this example, the regex will be compiled when it is used for\nthe first time. On subsequent uses, it will reuse the previous compilation.\n\n### Usage: match regular expressions on `&[u8]`\n\nThe main API of this crate (`regex::Regex`) requires the caller to pass a\n`&str` for searching. In Rust, an `&str` is required to be valid UTF-8, which\nmeans the main API can't be used for searching arbitrary bytes.\n\nTo match on arbitrary bytes, use the `regex::bytes::Regex` API. The API is\nidentical to the main API, except that it takes an `&[u8]` to search on instead\nof an `&str`. The `&[u8]` APIs also permit disabling Unicode mode in the regex\neven when the pattern would match invalid UTF-8. For example, `(?-u:.)` is\nnot allowed in `regex::Regex` but is allowed in `regex::bytes::Regex` since\n`(?-u:.)` matches any byte except for `\\n`. Conversely, `.` will match the\nUTF-8 encoding of any Unicode scalar value except for `\\n`.\n\nThis example shows how to find all null-terminated strings in a slice of bytes:\n\n```rust\nuse regex::bytes::Regex;\n\nlet re = Regex::new(r\"(?-u)(?<cstr>[^\\x00]+)\\x00\").unwrap();\nlet text = b\"foo\\xFFbar\\x00baz\\x00\";\n\n// Extract all of the strings without the null terminator from each match.\n// The unwrap is OK here since a match requires the `cstr` capture to match.\nlet cstrs: Vec<&[u8]> =\n    re.captures_iter(text)\n      .map(|c| c.name(\"cstr\").unwrap().as_bytes())\n      .collect();\nassert_eq!(vec![&b\"foo\\xFFbar\"[..], &b\"baz\"[..]], cstrs);\n```\n\nNotice here that the `[^\\x00]+` will match any *byte* except for `NUL`,\nincluding bytes like `\\xFF` which are not valid UTF-8. When using the main API,\n`[^\\x00]+` would instead match any valid UTF-8 sequence except for `NUL`.\n\n### Usage: match multiple regular expressions simultaneously\n\nThis demonstrates how to use a `RegexSet` to match multiple (possibly\noverlapping) regular expressions in a single scan of the search text:\n\n```rust\nuse regex::RegexSet;\n\nlet set = RegexSet::new(&[\n    r\"\\w+\",\n    r\"\\d+\",\n    r\"\\pL+\",\n    r\"foo\",\n    r\"bar\",\n    r\"barfoo\",\n    r\"foobar\",\n]).unwrap();\n\n// Iterate over and collect all of the matches.\nlet matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\nassert_eq!(matches, vec![0, 2, 3, 4, 6]);\n\n// You can also test whether a particular regex matched:\nlet matches = set.matches(\"foobar\");\nassert!(!matches.matched(5));\nassert!(matches.matched(6));\n```\n\n\n### Usage: regex internals as a library\n\nThe [`regex-automata` directory](./regex-automata/) contains a crate that\nexposes all of the internal matching engines used by the `regex` crate. The\nidea is that the `regex` crate exposes a simple API for 99% of use cases, but\n`regex-automata` exposes oodles of customizable behaviors.\n\n[Documentation for `regex-automata`.](https://docs.rs/regex-automata)\n\n\n### Usage: a regular expression parser\n\nThis repository contains a crate that provides a well tested regular expression\nparser, abstract syntax and a high-level intermediate representation for\nconvenient analysis. It provides no facilities for compilation or execution.\nThis may be useful if you're implementing your own regex engine or otherwise\nneed to do analysis on the syntax of a regular expression. It is otherwise not\nrecommended for general use.\n\n[Documentation for `regex-syntax`.](https://docs.rs/regex-syntax)\n\n\n### Crate features\n\nThis crate comes with several features that permit tweaking the trade off\nbetween binary size, compilation time and runtime performance. Users of this\ncrate can selectively disable Unicode tables, or choose from a variety of\noptimizations performed by this crate to disable.\n\nWhen all of these features are disabled, runtime match performance may be much\nworse, but if you're matching on short strings, or if high performance isn't\nnecessary, then such a configuration is perfectly serviceable. To disable\nall such features, use the following `Cargo.toml` dependency configuration:\n\n```toml\n[dependencies.regex]\nversion = \"1.3\"\ndefault-features = false\n# Unless you have a specific reason not to, it's good sense to enable standard\n# library support. It enables several optimizations and avoids spin locks. It\n# also shouldn't meaningfully impact compile times or binary size.\nfeatures = [\"std\"]\n```\n\nThis will reduce the dependency tree of `regex` down to two crates:\n`regex-syntax` and `regex-automata`.\n\nThe full set of features one can disable are\n[in the \"Crate features\" section of the documentation](https://docs.rs/regex/1.*/#crate-features).\n\n\n### Performance\n\nOne of the goals of this crate is for the regex engine to be \"fast.\" What that\nis a somewhat nebulous goal, it is usually interpreted in one of two ways.\nFirst, it means that all searches take worst case `O(m * n)` time, where\n`m` is proportional to `len(regex)` and `n` is proportional to `len(haystack)`.\nSecond, it means that even aside from the time complexity constraint, regex\nsearches are \"fast\" in practice.\n\nWhile the first interpretation is pretty unambiguous, the second one remains\nnebulous. While nebulous, it guides this crate's architecture and the sorts of\nthe trade offs it makes. For example, here are some general architectural\nstatements that follow as a result of the goal to be \"fast\":\n\n* When given the choice between faster regex searches and faster _Rust compile\ntimes_, this crate will generally choose faster regex searches.\n* When given the choice between faster regex searches and faster _regex compile\ntimes_, this crate will generally choose faster regex searches. That is, it is\ngenerally acceptable for `Regex::new` to get a little slower if it means that\nsearches get faster. (This is a somewhat delicate balance to strike, because\nthe speed of `Regex::new` needs to remain somewhat reasonable. But this is why\none should avoid re-compiling the same regex over and over again.)\n* When given the choice between faster regex searches and simpler API\ndesign, this crate will generally choose faster regex searches. For example,\nif one didn't care about performance, we could like get rid of both of\nthe `Regex::is_match` and `Regex::find` APIs and instead just rely on\n`Regex::captures`.\n\nThere are perhaps more ways that being \"fast\" influences things.\n\nWhile this repository used to provide its own benchmark suite, it has since\nbeen moved to [rebar](https://github.com/BurntSushi/rebar). The benchmarks are\nquite extensive, and there are many more than what is shown in rebar's README\n(which is just limited to a \"curated\" set meant to compare performance between\nregex engines). To run all of this crate's benchmarks, first start by cloning\nand installing `rebar`:\n\n```text\n$ git clone https://github.com/BurntSushi/rebar\n$ cd rebar\n$ cargo install --path ./\n```\n\nThen build the benchmark harness for just this crate:\n\n```text\n$ rebar build -e '^rust/regex$'\n```\n\nRun all benchmarks for this crate as tests (each benchmark is executed once to\nensure it works):\n\n```text\n$ rebar measure -e '^rust/regex$' -t\n```\n\nRecord measurements for all benchmarks and save them to a CSV file:\n\n```text\n$ rebar measure -e '^rust/regex$' | tee results.csv\n```\n\nExplore benchmark timings:\n\n```text\n$ rebar cmp results.csv\n```\n\nSee the `rebar` documentation for more details on how it works and how to\ncompare results with other regex engines.\n\n\n### Hacking\n\nThe `regex` crate is, for the most part, a pretty thin wrapper around the\n[`meta::Regex`](https://docs.rs/regex-automata/latest/regex_automata/meta/struct.Regex.html)\nfrom the\n[`regex-automata` crate](https://docs.rs/regex-automata/latest/regex_automata/).\nTherefore, if you're looking to work on the internals of this crate, you'll\nlikely either want to look in `regex-syntax` (for parsing) or `regex-automata`\n(for construction of finite automata and the search routines).\n\nMy [blog on regex internals](https://blog.burntsushi.net/regex-internals/)\ngoes into more depth.\n\n\n### Minimum Rust version policy\n\nThis crate's minimum supported `rustc` version is `1.65.0`.\n\nThe policy is that the minimum Rust version required to use this crate can be\nincreased in minor version updates. For example, if regex 1.0 requires Rust\n1.20.0, then regex 1.0.z for all values of `z` will also require Rust 1.20.0 or\nnewer. However, regex 1.y for `y > 0` may require a newer minimum version of\nRust.\n\n\n### License\n\nThis project is licensed under either of\n\n * Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or\n   https://www.apache.org/licenses/LICENSE-2.0)\n * MIT license ([LICENSE-MIT](LICENSE-MIT) or\n   https://opensource.org/licenses/MIT)\n\nat your option.\n\nThe data in `regex-syntax/src/unicode_tables/` is licensed under the Unicode\nLicense Agreement\n([LICENSE-UNICODE](https://www.unicode.org/copyright.html#License)).\n"
        },
        {
          "name": "UNICODE.md",
          "type": "blob",
          "size": 10.201171875,
          "content": "# Unicode conformance\n\nThis document describes the regex crate's conformance to Unicode's\n[UTS#18](https://unicode.org/reports/tr18/)\nreport, which lays out 3 levels of support: Basic, Extended and Tailored.\n\nFull support for Level 1 (\"Basic Unicode Support\") is provided with two\nexceptions:\n\n1. Line boundaries are not Unicode aware. Namely, only the `\\n`\n   (`END OF LINE`) character is recognized as a line boundary by default.\n   One can opt into `\\r\\n|\\r|\\n` being a line boundary via CRLF mode.\n2. The compatibility properties specified by\n   [RL1.2a](https://unicode.org/reports/tr18/#RL1.2a)\n   are ASCII-only definitions.\n\nLittle to no support is provided for either Level 2 or Level 3. For the most\npart, this is because the features are either complex/hard to implement, or at\nthe very least, very difficult to implement without sacrificing performance.\nFor example, tackling canonical equivalence such that matching worked as one\nwould expect regardless of normalization form would be a significant\nundertaking. This is at least partially a result of the fact that this regex\nengine is based on finite automata, which admits less flexibility normally\nassociated with backtracking implementations.\n\n\n## RL1.1 Hex Notation\n\n[UTS#18 RL1.1](https://unicode.org/reports/tr18/#Hex_notation)\n\nHex Notation refers to the ability to specify a Unicode code point in a regular\nexpression via its hexadecimal code point representation. This is useful in\nenvironments that have poor Unicode font rendering or if you need to express a\ncode point that is not normally displayable. All forms of hexadecimal notation\nare supported\n\n    \\x7F        hex character code (exactly two digits)\n    \\x{10FFFF}  any hex character code corresponding to a Unicode code point\n    \\u007F      hex character code (exactly four digits)\n    \\u{7F}      any hex character code corresponding to a Unicode code point\n    \\U0000007F  hex character code (exactly eight digits)\n    \\U{7F}      any hex character code corresponding to a Unicode code point\n\nBriefly, the `\\x{...}`, `\\u{...}` and `\\U{...}` are all exactly equivalent ways\nof expressing hexadecimal code points. Any number of digits can be written\nwithin the brackets. In contrast, `\\xNN`, `\\uNNNN`, `\\UNNNNNNNN` are all\nfixed-width variants of the same idea.\n\nNote that when Unicode mode is disabled, any non-ASCII Unicode codepoint is\nbanned. Additionally, the `\\xNN` syntax represents arbitrary bytes when Unicode\nmode is disabled. That is, the regex `\\xFF` matches the Unicode codepoint\nU+00FF (encoded as `\\xC3\\xBF` in UTF-8) while the regex `(?-u)\\xFF` matches\nthe literal byte `\\xFF`.\n\n\n## RL1.2 Properties\n\n[UTS#18 RL1.2](https://unicode.org/reports/tr18/#Categories)\n\nFull support for Unicode property syntax is provided. Unicode properties\nprovide a convenient way to construct character classes of groups of code\npoints specified by Unicode. The regex crate does not provide exhaustive\nsupport, but covers a useful subset. In particular:\n\n* [General categories](https://unicode.org/reports/tr18/#General_Category_Property)\n* [Scripts and Script Extensions](https://unicode.org/reports/tr18/#Script_Property)\n* [Age](https://unicode.org/reports/tr18/#Age)\n* A smattering of boolean properties, including all of those specified by\n  [RL1.2](https://unicode.org/reports/tr18/#RL1.2) explicitly.\n\nIn all cases, property name and value abbreviations are supported, and all\nnames/values are matched loosely without regard for case, whitespace or\nunderscores. Property name aliases can be found in Unicode's\n[`PropertyAliases.txt`](https://www.unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt)\nfile, while property value aliases can be found in Unicode's\n[`PropertyValueAliases.txt`](https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt)\nfile.\n\nThe syntax supported is also consistent with the UTS#18 recommendation:\n\n* `\\p{Greek}` selects the `Greek` script. Equivalent expressions follow:\n  `\\p{sc:Greek}`, `\\p{Script:Greek}`, `\\p{Sc=Greek}`, `\\p{script=Greek}`,\n  `\\P{sc!=Greek}`. Similarly for `General_Category` (or `gc` for short) and\n  `Script_Extensions` (or `scx` for short).\n* `\\p{age:3.2}` selects all code points in Unicode 3.2.\n* `\\p{Alphabetic}` selects the \"alphabetic\" property and can be abbreviated\n  via `\\p{alpha}` (for example).\n* Single letter variants for properties with single letter abbreviations.\n  For example, `\\p{Letter}` can be equivalently written as `\\pL`.\n\nThe following is a list of all properties supported by the regex crate (starred\nproperties correspond to properties required by RL1.2):\n\n* `General_Category` \\* (including `Any`, `ASCII` and `Assigned`)\n* `Script` \\*\n* `Script_Extensions` \\*\n* `Age`\n* `ASCII_Hex_Digit`\n* `Alphabetic` \\*\n* `Bidi_Control`\n* `Case_Ignorable`\n* `Cased`\n* `Changes_When_Casefolded`\n* `Changes_When_Casemapped`\n* `Changes_When_Lowercased`\n* `Changes_When_Titlecased`\n* `Changes_When_Uppercased`\n* `Dash`\n* `Default_Ignorable_Code_Point` \\*\n* `Deprecated`\n* `Diacritic`\n* `Emoji`\n* `Emoji_Presentation`\n* `Emoji_Modifier`\n* `Emoji_Modifier_Base`\n* `Emoji_Component`\n* `Extended_Pictographic`\n* `Extender`\n* `Grapheme_Base`\n* `Grapheme_Cluster_Break`\n* `Grapheme_Extend`\n* `Hex_Digit`\n* `IDS_Binary_Operator`\n* `IDS_Trinary_Operator`\n* `ID_Continue`\n* `ID_Start`\n* `Join_Control`\n* `Logical_Order_Exception`\n* `Lowercase` \\*\n* `Math`\n* `Noncharacter_Code_Point` \\*\n* `Pattern_Syntax`\n* `Pattern_White_Space`\n* `Prepended_Concatenation_Mark`\n* `Quotation_Mark`\n* `Radical`\n* `Regional_Indicator`\n* `Sentence_Break`\n* `Sentence_Terminal`\n* `Soft_Dotted`\n* `Terminal_Punctuation`\n* `Unified_Ideograph`\n* `Uppercase` \\*\n* `Variation_Selector`\n* `White_Space` \\*\n* `Word_Break`\n* `XID_Continue`\n* `XID_Start`\n\n\n## RL1.2a Compatibility Properties\n\n[UTS#18 RL1.2a](https://unicode.org/reports/tr18/#RL1.2a)\n\nThe regex crate only provides ASCII definitions of the\n[compatibility properties documented in UTS#18 Annex C](https://unicode.org/reports/tr18/#Compatibility_Properties)\n(sans the `\\X` class, for matching grapheme clusters, which isn't provided\nat all). This is because it seems to be consistent with most other regular\nexpression engines, and in particular, because these are often referred to as\n\"ASCII\" or \"POSIX\" character classes.\n\nNote that the `\\w`, `\\s` and `\\d` character classes **are** Unicode aware.\nTheir traditional ASCII definition can be used by disabling Unicode. That is,\n`[[:word:]]` and `(?-u)\\w` are equivalent.\n\n\n## RL1.3 Subtraction and Intersection\n\n[UTS#18 RL1.3](https://unicode.org/reports/tr18/#Subtraction_and_Intersection)\n\nThe regex crate provides full support for nested character classes, along with\nunion, intersection (`&&`), difference (`--`) and symmetric difference (`~~`)\noperations on arbitrary character classes.\n\nFor example, to match all non-ASCII letters, you could use either\n`[\\p{Letter}--\\p{Ascii}]` (difference) or `[\\p{Letter}&&[^\\p{Ascii}]]`\n(intersecting the negation).\n\n\n## RL1.4 Simple Word Boundaries\n\n[UTS#18 RL1.4](https://unicode.org/reports/tr18/#Simple_Word_Boundaries)\n\nThe regex crate provides basic Unicode aware word boundary assertions. A word\nboundary assertion can be written as `\\b`, or `\\B` as its negation. A word\nboundary negation corresponds to a zero-width match, where its adjacent\ncharacters correspond to word and non-word, or non-word and word characters.\n\nConformance in this case chooses to define word character in the same way that\nthe `\\w` character class is defined: a code point that is a member of one of\nthe following classes:\n\n* `\\p{Alphabetic}`\n* `\\p{Join_Control}`\n* `\\p{gc:Mark}`\n* `\\p{gc:Decimal_Number}`\n* `\\p{gc:Connector_Punctuation}`\n\nIn particular, this differs slightly from the\n[prescription given in RL1.4](https://unicode.org/reports/tr18/#Simple_Word_Boundaries)\nbut is permissible according to\n[UTS#18 Annex C](https://unicode.org/reports/tr18/#Compatibility_Properties).\nNamely, it is convenient and simpler to have `\\w` and `\\b` be in sync with\none another.\n\nFinally, Unicode word boundaries can be disabled, which will cause ASCII word\nboundaries to be used instead. That is, `\\b` is a Unicode word boundary while\n`(?-u)\\b` is an ASCII-only word boundary. This can occasionally be beneficial\nif performance is important, since the implementation of Unicode word\nboundaries is currently sub-optimal on non-ASCII text.\n\n\n## RL1.5 Simple Loose Matches\n\n[UTS#18 RL1.5](https://unicode.org/reports/tr18/#Simple_Loose_Matches)\n\nThe regex crate provides full support for case insensitive matching in\naccordance with RL1.5. That is, it uses the \"simple\" case folding mapping. The\n\"simple\" mapping was chosen because of a key convenient property: every\n\"simple\" mapping is a mapping from exactly one code point to exactly one other\ncode point. This makes case insensitive matching of character classes, for\nexample, straight-forward to implement.\n\nWhen case insensitive mode is enabled (e.g., `(?i)[a]` is equivalent to `a|A`),\nthen all characters classes are case folded as well.\n\n\n## RL1.6 Line Boundaries\n\n[UTS#18 RL1.6](https://unicode.org/reports/tr18/#Line_Boundaries)\n\nThe regex crate only provides support for recognizing the `\\n` (`END OF LINE`)\ncharacter as a line boundary by default. One can also opt into treating\n`\\r\\n|\\r|\\n` as a line boundary via CRLF mode. This choice was made mostly for\nimplementation convenience, and to avoid performance cliffs that Unicode word\nboundaries are subject to.\n\n\n## RL1.7 Code Points\n\n[UTS#18 RL1.7](https://unicode.org/reports/tr18/#Supplementary_Characters)\n\nThe regex crate provides full support for Unicode code point matching. Namely,\nthe fundamental atom of any match is always a single code point.\n\nGiven Rust's strong ties to UTF-8, the following guarantees are also provided:\n\n* All matches are reported on valid UTF-8 code unit boundaries. That is, any\n  match range returned by the public regex API is guaranteed to successfully\n  slice the string that was searched.\n* By consequence of the above, it is impossible to match surrogode code points.\n  No support for UTF-16 is provided, so this is never necessary.\n\nNote that when Unicode mode is disabled, the fundamental atom of matching is\nno longer a code point but a single byte. When Unicode mode is disabled, many\nUnicode features are disabled as well. For example, `(?-u)\\pL` is not a valid\nregex but `\\pL(?-u)\\xFF` (matches any Unicode `Letter` followed by the literal\nbyte `\\xFF`) is, for example.\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "record",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex-automata",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex-capi",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex-cli",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex-lite",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex-syntax",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex-test",
          "type": "tree",
          "content": null
        },
        {
          "name": "rustfmt.toml",
          "type": "blob",
          "size": 0.04296875,
          "content": "max_width = 79\nuse_small_heuristics = \"max\"\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "blob",
          "size": 1.4140625,
          "content": "#!/bin/bash\n\nset -e\n\n# cd to the directory containing this crate's Cargo.toml so that we don't need\n# to pass --manifest-path to every `cargo` command.\ncd \"$(dirname \"$0\")\"\n\n# This is a convenience script for running a broad swath of tests across\n# features. We don't test the complete space, since the complete space is quite\n# large. Hopefully once we migrate the test suite to better infrastructure\n# (like regex-automata), we'll be able to test more of the space.\necho \"===== DEFAULT FEATURES =====\"\ncargo test\n\n# no-std mode is annoyingly difficult to test. Currently, the integration tests\n# don't run. So for now, we just test that library tests run. (There aren't\n# many because `regex` is just a wrapper crate.)\ncargo test --no-default-features --lib\n\necho \"===== DOC TESTS =====\"\ncargo test --doc\n\nfeatures=(\n    \"std\"\n    \"std unicode\"\n    \"std unicode-perl\"\n    \"std perf\"\n    \"std perf-cache\"\n    \"std perf-dfa\"\n    \"std perf-inline\"\n    \"std perf-literal\"\n    \"std perf-dfa-full\"\n    \"std perf-onepass\"\n    \"std perf-backtrack\"\n)\nfor f in \"${features[@]}\"; do\n    echo \"===== FEATURE: $f =====\"\n    cargo test --test integration --no-default-features --features \"$f\"\ndone\n\n# And test the probably-forever-nightly-only 'pattern' feature...\nif rustc --version | grep -q nightly; then\n    echo \"===== FEATURE: std,pattern,unicode-perl =====\"\n    cargo test --test integration --no-default-features --features std,pattern,unicode-perl\nfi\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}