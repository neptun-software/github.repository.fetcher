{
  "metadata": {
    "timestamp": 1736708978864,
    "page": 26,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "anordal/shellharden",
      "stars": 4646,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1708984375,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\nindent_style = tab\nindent_size = 4\n\n[*.md]\nindent_style = spaces\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.2841796875,
          "content": "# Changelog\n\n## 4.3.1\n\n* Fix misdetection of line continuation as a command\n* Fix undetected opening quote in word\n* Give more context on syntax error\n\n## 4.3.0\n\n*One long awaited rule change*\n\n* Unnecessary braces on variable expansions in string interpolations are now\n  allowed.\n\n## 4.2.0\n\n*More helpful with `for` and `test`*\n\n* Variables that must necessarily be arrays in order to be quoted now become\n  array expansions instead of simply being quoted\n  (they must still manually be changed to arrays):\n  * `for i in $a` → `for i in \"${a[@]}\"`\n* Rewriting array serialization to array expansion in contexts where quoting\n  is needed, now also for named arrays\n  (analogous to `$*` → `\"$@\"`):\n  * `${a[*]}` → `\"${a[@]}\"`\n* `test` command normalization (see the howto for justification):\n  * Empty string tests:\n    * `test -n \"$s\"` → `test \"$s\" != \"\"`\n    * `test -z \"$s\"` → `test \"$s\" = \"\"`\n  * xyes deemed unnecessary:\n    * `test x\"$s\" = xyes` → `test \"$s\" = yes`\n* Bugfix: Fix lookahead on short read. See commit 21904cce1.\n\n## 4.1.3\n\n*A pandemy's worth of maintenance*\n(when \"Covid\" stopped being a perfect name for a video conferencing company)\n\n* Syntactic fixes\n  * Fix nested case (#37)\n  * Recognise nested variable expansion (#39)\n  * Recognise arithmetic statement (#42)\n  * Recognise export assignments (like local, declare, readonly)\n  * Allow unquoted $* in contexts where quoting is not required, such as s=$*\n  * Recognise negation, or rather that what follows is in command position,\n    as needed to recognise assignments like || ! s=$i in loop conditons.\n  * \\`pwd\\` rewrites to $PWD, also where quoting is not required\n    (this was an oversight)\n* Feature fixes\n  * --check no longer leaks out syntax errors or other error output.\n* Testing\n  * Make tests run on GitHub\n  * Find & test the right build's executable (debug/release), not just both.\n  * Test that Shellharden is idempotent and exercise --check on current tests\n* Color:\n  * Brighten the comment color 3× for readability on IPS screens where dark\n    colors look black (or KDE Breeze's not so black terminal background).\n  * Change 'single quoted string' from yellow to gold.\n  * Use 3-bit background color for terminals that don't support 24-bit color.\n    This is merely the most important coloring; the syntax is still\n    highlighted in 24-bit color and requires a 24-bit terminal to see.\n  * Change color lazily (less work for the terminal).\n\n## 4.1.2\n\n*One refactoring, plenty of necessary fixes*\n\n* Fix old bug: Wrong quoting of associative array assignments (#31)\n* More permissive: Allow unquoted arguments to local, declare and readonly (#30)\n* Consistency: Rewrite `` `pwd` `` → `$PWD` directly, not via `$(pwd)`\n* Compatibility with newer Rust: rustc 1.37 through 1.41 and 2018 edition\n* Less code: Collapse nested enums in oft-used return type\n* Maintainers: Cargo.lock is now included (#28)\n\n## 4.1.1\n\n*More testing*\n\n* Allow \"$*\" (no need to rewrite it to \"$@\" as long as the quotes are on).\n* Recognise premature esac to avoid parse error (seen on rustup.sh).\n* Write this changelog.\n* Cargo Clippy compliant.\n* Unittests! Currently focused on corner cases that are hard to moduletest,\n  namely lookahead.\n* Corner cases in the keyword detection inside the `case` statement were fixed.\n  This would manifest as false positive and false negative detection of the `in`\n  and `esac` keywords, followed by a likely parse error.\n  This stems from version 4.0 and was not seen in the wild AFAIK.\n  The most glaring bug was false positive detection when prefixed.\n  Less so were the false negatives related to lookahead.\n* The special variables $$, $! and $- are now recognized.\n\n## 4.1\n\n*The feature continuation of 4.0*\n\nAllow non-quoting in more contexts exposed by the 4.0 parser.\n\n* Allow unquoted rvalues (the value part of an assignment).\n* Allow unquoted switch and case expressions.\n* Allow backticks where quoting is unneeded.\n\n## 4.0.1\n\n* Implement the --version option.\n* Expand help text to account for the fact that there is no manpage (I gave that up).\n\n## 4.0\n\n*The version with the one big feature*\n\n* Recognise double square brackets as a context where all quoting rules are off.\n    * More detailed syntax highlighting to reflect the added parser states, such as keywords and command position\n\nBecause not all double square brackets start a double square bracket context\n(because they are not in command position),\nit is necessary to recognise where commands begin.\nBefore this, Shellharden kept track of little more than words, quotes and the occasional heredoc.\nTo track the command position, it is necessary to add a lot more states to the state machine, including control structures, keywords, assignments, redirection, arrays and group commands (hereunder, functions).\nThe code was also split from one file into many, and I failed to convince git to track most of the code across the split.\n\nSmaller changes:\n\n* Holistic quoting fix: Don't swallow the question sign glob as part of the string.\n* Hook the tests into `cargo --test`.\n* Implement the -- option.\n\n## 3.2\n\n*The second publicity feedback version*\n\n* Make it build with Cargo (instead of just rustc).\n* Add the -h option (as an alias to --help).\n* Tests that actually run. Thanks, Robert!\n* Fix crash when the file ends prematurely in a heredoc.\n\n## 3.1\n\n*The immediate publicity feedback version*\n\n* Typo fixes\n* Add license\n* Add the --check and --replace options\n\n## 3.0\n\n*The publicity compatible version*\n\n* Project rename\n    * Rename an option for consistency\n* Support arithmetic expansion\n\nHindsight: This release made some headlines and took the project out of obscurity:\n\n* [lobste.rs](https://lobste.rs/s/4jegyk/how_do_things_safely_bash) (by me)\n* [Hacker News](https://news.ycombinator.com/item?id=17057596) (not by me)\n\n## 2.0\n\n*The even better version*\n\n* Holistic quoting:\n    * $a$b → \"$a$b\"\n    * $a\"string\" → \"${a}string\"\n* Smaller replacement diff\n* Bail, and print a big warning, on multi-decimal numbered args like $10.\n* Improved support for heredocs\n\n## 1.0\n\n*The first usable version.* I could have stopped here.\n\n* Modes of operation\n* Visible replacements\n* Limited support for heredocs\n\n## Commit fe7b3eb\n\n*Proof of concept*\n\nThe first usable syntax highlighter that\nsneaks in quotes relatively unnoticeably.\n\n* Parsing works except for heredocs\n* One mode of operation\n\n## First commit\n\n*Reinvent cat.*\n"
        },
        {
          "name": "Cargo.lock",
          "type": "blob",
          "size": 0.1513671875,
          "content": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"shellharden\"\nversion = \"4.3.1\"\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.21875,
          "content": "[package]\nname = \"shellharden\"\nversion = \"4.3.1\"\nauthors = [\"Andreas Nordal\"]\nrepository = \"https://github.com/anordal/shellharden/\"\ndescription = \"The corrective bash syntax highlighter\"\nlicense = \"MPL-2.0\"\n\n[dependencies]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 15.28125,
          "content": " Mozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\nmeans each individual or legal entity that creates, contributes to\nthe creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\nmeans the combination of the Contributions of others (if any) used\nby a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\nmeans Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\nmeans Source Code Form to which the initial Contributor has attached\nthe notice in Exhibit A, the Executable Form of such Source Code\nForm, and Modifications of such Source Code Form, in each case\nincluding portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\nmeans\n\n(a) that the initial Contributor has attached the notice described\nin Exhibit B to the Covered Software; or\n\n(b) that the Covered Software was made available under the terms of\nversion 1.1 or earlier of the License, but not also under the\nterms of a Secondary License.\n\n1.6. \"Executable Form\"\nmeans any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\nmeans a work that combines Covered Software with other material, in\na separate file or files, that is not Covered Software.\n\n1.8. \"License\"\nmeans this document.\n\n1.9. \"Licensable\"\nmeans having the right to grant, to the maximum extent possible,\nwhether at the time of the initial grant or subsequently, any and\nall of the rights conveyed by this License.\n\n1.10. \"Modifications\"\nmeans any of the following:\n\n(a) any file in Source Code Form that results from an addition to,\ndeletion from, or modification of the contents of Covered\nSoftware; or\n\n(b) any new file in Source Code Form that contains any Covered\nSoftware.\n\n1.11. \"Patent Claims\" of a Contributor\nmeans any patent claim(s), including without limitation, method,\nprocess, and apparatus claims, in any patent Licensable by such\nContributor that would be infringed, but for the grant of the\nLicense, by the making, using, selling, offering for sale, having\nmade, import, or transfer of either its Contributions or its\nContributor Version.\n\n1.12. \"Secondary License\"\nmeans either the GNU General Public License, Version 2.0, the GNU\nLesser General Public License, Version 2.1, the GNU Affero General\nPublic License, Version 3.0, or any later versions of those\nlicenses.\n\n1.13. \"Source Code Form\"\nmeans the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\nmeans an individual or a legal entity exercising rights under this\nLicense. For legal entities, \"You\" includes any entity that\ncontrols, is controlled by, or is under common control with You. For\npurposes of this definition, \"control\" means (a) the power, direct\nor indirect, to cause the direction or management of such entity,\nwhether by contract or otherwise, or (b) ownership of more than\nfifty percent (50%) of the outstanding shares or beneficial\nownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\nLicensable by such Contributor to use, reproduce, make available,\nmodify, display, perform, distribute, and otherwise exploit its\nContributions, either on an unmodified basis, with Modifications, or\nas part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\nfor sale, have made, import, and otherwise transfer either its\nContributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\nor\n\n(b) for infringements caused by: (i) Your and any other third party's\nmodifications of Covered Software, or (ii) the combination of its\nContributions with other software (except as part of its Contributor\nVersion); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\nits Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\nForm, as described in Section 3.1, and You must inform recipients of\nthe Executable Form how they can obtain a copy of such Source Code\nForm by reasonable means in a timely manner, at a charge no more\nthan the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\nLicense, or sublicense it under different terms, provided that the\nlicense for the Executable Form does not attempt to limit or alter\nthe recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n* *\n* 6. Disclaimer of Warranty *\n* ------------------------- *\n* *\n* Covered Software is provided under this License on an \"as is\" *\n* basis, without warranty of any kind, either expressed, implied, or *\n* statutory, including, without limitation, warranties that the *\n* Covered Software is free of defects, merchantable, fit for a *\n* particular purpose or non-infringing. The entire risk as to the *\n* quality and performance of the Covered Software is with You. *\n* Should any Covered Software prove defective in any respect, You *\n* (not any Contributor) assume the cost of any necessary servicing, *\n* repair, or correction. This disclaimer of warranty constitutes an *\n* essential part of this License. No use of any Covered Software is *\n* authorized under this License except under this disclaimer. *\n* *\n************************************************************************\n\n************************************************************************\n* *\n* 7. Limitation of Liability *\n* -------------------------- *\n* *\n* Under no circumstances and under no legal theory, whether tort *\n* (including negligence), contract, or otherwise, shall any *\n* Contributor, or anyone who distributes Covered Software as *\n* permitted above, be liable to You for any direct, indirect, *\n* special, incidental, or consequential damages of any character *\n* including, without limitation, damages for lost profits, loss of *\n* goodwill, work stoppage, computer failure or malfunction, or any *\n* and all other commercial damages or losses, even if such party *\n* shall have been informed of the possibility of such damages. This *\n* limitation of liability shall not apply to liability for death or *\n* personal injury resulting from such party's negligence to the *\n* extent applicable law prohibits such limitation. Some *\n* jurisdictions do not allow the exclusion or limitation of *\n* incidental or consequential damages, so this exclusion and *\n* limitation may not apply to You. *\n* *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\nThis Source Code Form is \"Incompatible With Secondary Licenses\", as\ndefined by the Mozilla Public License, v. 2.0.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.0380859375,
          "content": "<img src=\"img/logo.png\" align=\"right\"/>\n\n[![Build and test status](https://github.com/anordal/shellharden/workflows/build-and-tests/badge.svg?branch=master)](https://github.com/anordal/shellharden/actions)\n\nShellharden\n===========\n\nShellharden is a syntax highlighter and a tool to semi-automate the rewriting\nof scripts to ShellCheck conformance, mainly focused on quoting.\n\nThe default mode of operation is like `cat`, but with syntax highlighting in\nforeground colors and suggestive changes in background colors:\n\n![real-world example](img/ex-realworld.png)\n\nAbove: Selected portions of `xdg-desktop-menu` as highlighted by Shellharden.\nThe foreground colors are syntax highlighting, whereas the background colors\n(green and red) show characters that Shellharden would have added or removed\nif let loose with the `--transform` option.\nBelow: An artificial example that shows more tricky cases and special features.\n\n![artificial example](img/ex-artificial.png)\n\nWhy\n---\n\nA variable in bash is like a hand grenade – take off its quotes, and it starts ticking. Hence, rule zero of [bash pitfalls][1]: Always use quotes.\n\nName\n----\n\nShellharden can do what Shellcheck can't: Apply the suggested changes.\n\nIn other words, harden vulnerable shellscripts.\nThe builtin assumption is that the script does not *depend* on the vulnerable behavior –\nthe user is responsible for the code review.\n\nShellharden was previously known as \"Naziquote\".\nIn the right jargon, that was the best name ever,\nbut oh so misleading and unspeakable to outsiders.\n\nI couldn't call it \"bash cleaner\" either, as that means \"poo smearer\" in Norwegian.\n\nPrior art\n---------\n\n* [Shellcheck][2] is a wonderful tool to *detect*, and give general advice, about vulnerable bash code. The only thing missing is something to say yes with, and *apply* those advice (assuming proper review of course).\n\n* I asked [this SO question][3], for a tool that could rewrite bash scripts with proper quoting. One answerer beat me to it. But if it was me, I would do a syntax highlighter in the same tool (as a way to see if the parser gets lost, and make the most out of the parser, because bash is like quantum mechanics – nobody really knows how it works).\n\nGet it\n------\n\nDistro packages:\n\n[![Packaging status](https://repology.org/badge/vertical-allrepos/shellharden.svg)](https://repology.org/project/shellharden/versions)\n\n[Official rust package](https://crates.io/crates/shellharden):\n\n    cargo install shellharden\n\nBuild from source\n-----------------\n\n    cargo build --release\n\n### Install\n\n    mv target/release/shellharden ~/.local/bin/\n\n### Run tests\n\n    cargo test\n\n(requires bash)\n\n### Test coverage\n\n    env RUSTFLAGS=\"-C instrument-coverage\" LLVM_PROFILE_FILE='run-%m.profraw' cargo test\n    grcov . --binary-path ./target/debug/ -s . -t html -o ./coverage/\n    rm run-*.profraw\n    open coverage/src/index.html\n\n### Fuzz test\n\n    cargo install cargo-afl\n    cargo afl build --release\n    cargo afl fuzz -i moduletests/original -o /tmp/fuzz-shellharden target/release/shellharden ''\n\nUsage advice\n------------\n\nDon't apply `--transform` blindly; code review is still necessary: A script that *relies* on unquoted behavior (implicit word splitting and glob expansion from variables and command substitutions) to work as intended will do none of that after getting the `--transform` treatment!\n\nIn that unlucky case, ask yourself whether the script has any business in doing that. All too often, it's just a product of classical shellscripting, and would be better off rewritten, such as by using arrays. Even in the opposite case, say the business logic involves word splitting; that can still be done without invoking globbing. In short: There is always a better way than the forbidden syntax (if not more explicit), but some times, a human must step in to rewrite. See how, in the accompanying [how to do things safely in bash](how_to_do_things_safely_in_bash.md).\n\n[1]: http://mywiki.wooledge.org/BashPitfalls\n[2]: https://www.shellcheck.net/\n[3]: http://stackoverflow.com/questions/41104131/tool-to-automatically-rewrite-a-bash-script-with-proper-quoting\n"
        },
        {
          "name": "TODO.md",
          "type": "blob",
          "size": 0.6337890625,
          "content": "\n# Features\n* -c 'check this'\n* Things that never work: $10 and [ -n $var ]:\n  Fail by default, add --unbreak/--fix-neverworking\n* --keep-varbraces\n\n# Rewriting\n* sort | uniq → sort -u (man 1p sort approves)\n* alias → function\n* eval is evil: Color blinking red?\n* for i in seq → for ((i…))\n* for i in … → while read < <(…)\n\n# Code organisation\n* reduce perilous boilerplate\n  * make flush an error for easier propagation\n* approach agreement with rust-fmt\n\n# Write about:\n* errexit → errtrace ?\n* Gotcha: Command substitution \"$()\" trims whitespace\n* Useless uses of find\n* cp file dir → cp file dir/\n* realpath → readlink -f ?\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "how_to_do_things_safely_in_bash.md",
          "type": "blob",
          "size": 36.4111328125,
          "content": "Safe ways to do things in bash\n==============================\n\nLike programming in C or driving a car,\ncontemporary shellscript languages require some knowledge and discipline to use safely,\nbut that's not to say it can't be done.\n\nPurpose of this guide\n---------------------\n\nThis guide accompanies Shellharden, the corrective syntax highlighter.\n\nShellharden suggests, and can apply, changes to remove vulnerabilities in shellscripts. This is in accordance with [ShellCheck](https://github.com/koalaman/shellcheck/) and [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls) – Shellharden shall not disagree with these.\n\nThe problem is that not all scripts will work with their vulnerabilities simply removed, because *that* was their working principle, and must be rewritten quite differently.\nThus the need for a human in the loop and a holistic methodology.\n\nWhy focus on bash?\n------------------\n\nThis guide is here to show that bash *can* be used safely.\n\nIt is the goal and realization of this methodology that\nall bash scripts are possible to rewrite into wellformedness,\na representation free of those idiomatic bugs that the language otherwise practically imposes.\nThis is because the set of bad language features is finite, and each has a substitute.\n\nUnfortunately, [it is hard to defend the correct way of doing something when it isn't also the seemingly simplest][Jussi's two ways].\nWith this in mind, the python manifesto (`python3 -c 'import this'`),\nwhich says that there should only be one obvious way to do things, and that \"explicit is better than implicit\",\nmakes a lot of sense.\nWhile that says something about the impossibility of convincing the vast number of users to adopt a safe methodology,\nit is nevertheless possible for those who care.\n\nClearly, bash is a bad choice, but other prevalent alternatives are not better:\n\n* POSIX shell (a language subset that many shells support) lacks arrays. → Disqualified.\n    * Hereunder: dash, busybox ash\n* Fish is a relief – easy to use correctly, but (still) lacks a strict mode. → Disqualified.\n* Zsh is largely compatible with Bash. → Also qualifies.\n\n### What about non-shellscript languages?\n\nThat is in principle the wrong question. Always use the right tool for the job™.\nShellscript languages are languages for running programs, and for using that as a building block.\nThat is a domain of its own.\n\nThis is by no means a defense of shellscripting.\nShellscripts keep getting written, and this is how to do it safely.\nHowever, there is one greater sin than writing something that is obviously a shellscript.\nWhen you know you have a shellscript, you know what to worry about, you can bring in the right expertise, and you have the full arsenal of shell linters.\nNot so much if [implicitly invoking the shell with improper quoting](#how-to-avoid-invoking-the-shell-with-improper-quoting).\n\nThe first thing to know about bash coding\n-----------------------------------------\n\nIf there is anything like a driver's license for safe bash coding,\nit must be rule zero of [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls):\n**Always use quotes.**\n\nAn unquoted variable is to be treated as an armed bomb: It explodes upon contact with whitespace and wildcards. Yes, \"explode\" as in [splitting a string into an array](http://php.net/manual/en/function.explode.php). Specifically, variable expansions, like `$var`, and also command substitutions, like `$(cmd)`, undergo *word splitting*, whereby the string is split on any of the characters in the special `$IFS` variable, which is whitespace by default. Furthermore, any wildcard characters (`*?`) in the resulting words are used to expand those words to match files on your filesystem (*indirect pathname expansion*). This is mostly invisible, because most of the time, the result is a 1-element array, which is indistinguishable from the original string value.\n\nQuoting inhibits word splitting and indirect pathname expansion, both for variables and command substitutions.\n\nVariable expansion:\n\n* Good: `\"$my_var\"`\n* Bad: `$my_var`\n\nCommand substitution:\n\n* Good: `\"$(cmd)\"`\n* Bad: `$(cmd)`\n\nThere are exceptions where quoting is not necessary, but because it never hurts to quote, and the general rule is to be scared when you see an unquoted variable, pursuing the non-obvious exceptions is, for the sake of your readers, questionable. It looks wrong, and the wrong practice is common enough to raise suspicion: Enough scripts are being written with broken handling of filenames that whitespace in filenames is often avoided…\n\nThe exceptions only matter in discussions of style – feel welcome to ignore them. For the sake of style neutrality, Shellharden does honor a few exceptions:\n\n* variables of invariably numeric content: `$?`, `$$`, `$!`, `$#` and array length `${#array[@]}`\n* assignments: `a=$b`\n* the magical case command: `case $var in … esac`\n* the magical context between double-brackets (`[[` and `]]`) – this is a language of its own.\n\n### What quoting is not about\n\nShellscript is not a macro (read: injection prone) language. This is not scary:\n\n```\ninput=\"\\\"; rm -rf /\"\necho \"$input\"\n```\n\n### Should I use backticks?\n\nCommand substitutions also come in this form:\n\n* Correct: `` \"`cmd`\" ``\n* Bad: `` `cmd` ``\n\nWhile it is possible to use this style correctly, it is harder: [Backticks require escaping when nested, and examples in the wild are improperly quoted more often than not](http://mywiki.wooledge.org/BashFAQ/082).\n\nNot to mention this insidious trick:\n\n```\n> x=`echo \"This is a doublequote: \\\"\"`; echo \"$x\"\nThis is a doublequote: \"\n> x=\"`echo \"This is a doublequote: \\\"\"`\"; echo \"$x\"\nbash: command substitution: line 1: unexpected EOF while looking for matching `\"'\n```\n\nThe [Bash documentation](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html)\ndescribes the escaping rules as is correct of an unquoted backtick command substitution,\nbut does not say that a quoted one is different.\nWhich is perplexing enough, understandably, to be a documentation bug.\n\nShellharden accepts unquoted backticks in contexts that don't require quotes, but otherwise rewrites them into the dollar-parenthesis form.\n\n### Should I use curly braces?\n\nVariable substitution: This is not the controversy, but just to get it out of the way: These braces are of course needed:\n\n    \"${image%.png}.jpg\"\n\nString interpolation: Braces also have this role:\n\n    \"${var}string literal\"\n\nWhen expanding a variable inside a string, a closing brace can be used to delimit the end of the variable name from subsequent characters of the string literal.\nThis makes a difference if and only if the next character can take part in a variable name, in other words, if it is an identifier tail character, in regex `[_0-9a-zA-Z]`.\n\nStrictly speaking, it never hurts to always use braces. Does that make it a good idea?\n\nNote that this is not a question of correctness, but of brittleness\n(the script would have to be edited, and a mistake be made, before it becomes incorrect).\nStrictly speaking not that either, because the problem itself is unnecessary:\nQuotes are obligatory anyway; just quote variables individually to avoid the problem\n(quotes can always replace braces, but not the opposite, and you never need both).\nThe result is a concatenation instead of interpolation:\n\n    \"$var\"'string literal'\n\nNow that the question is clear, your author would say: Mostly not.\nIn terms of which way to go for consistency's sake, considert that\nmost variable expansions aren't interpolations. And they shouldn't:\nThe noble thing to do for a shellscript (or any glue code) is to pass arguments cleanly.\nLet's focus on passing arguments cleanly:\n\n* Bad: `some_command $arg1 $arg2 $arg3`\n* Bad and verbose: `some_command ${arg1} ${arg2} ${arg3}`\n* Good but verbose: `some_command \"${arg1}\" \"${arg2}\" \"${arg3}\"`\n* Good: `some_command \"$arg1\" \"$arg2\" \"$arg3\"`\n\nThe braces don't do anything objectively good here.\n\nIn your author's experience, there is rather a negative correlation between unnecessary use of braces and proper use of quotes – nearly everyone chooses the \"bad and verbose\" instead of \"good but verbose\" form! My speculations:\n\n* Fear of the wrong thing: Instead of worrying about the real danger (missing quotes), a beginner might worry that a variable named `$prefix` would influence the expansion of `\"$prefix_postfix\"` – this is simply not how it works.\n* Cargo cult – writing code in testament to the wrong fear perpetuates it.\n* Braces compete with quotes under the limits of tolerable verbosity.\n\nShellharden will add and remove braces on an as-needed basis when it needs to add quotes:\n\n`${arg} $arg\"ument\"` → `\"$arg\" \"${arg}ument\"`\n\nIt will also remove braces on individually quoted variables:\n\n`\"${arg}\"` → `\"$arg\"`\n\nAs of Shellharden 4.3.0, braces are allowed in string interpolations (not that it adds them):\n\n    \"${var} \"\n    \" ${var}\"\n    \"${var}${var}\"\n\nThus, a neutral stance in interpolations\n(being not a style formatter, Shellharden is not supposed to make subjective changes).\nPreviously, it rewrote interpolations too on an as-needed basis,\nbut as noted here, this could indeed be relaxed.\n\n#### Gotcha: Numbered arguments\n\nUnlike normal *identifier* variable names (in regex: `[_a-zA-Z][_a-zA-Z0-9]*`), numbered arguments require braces (string interpolation or not). ShellCheck says:\n\n    echo \"$10\"\n          ^-- SC1037: Braces are required for positionals over 9, e.g. ${10}.\n\nThis was deemed too subtle to either fix or ignore: Shellharden will print a big error message and bail if it sees this.\n\nSince braces are required above 9, Shellharden permits them on all numbered arguments.\n\nUse arrays FTW\n--------------\n\nIn order to be able to quote all variables, you must use real arrays when that's what you need, not whitespace delimited strings.\n\nThe syntax is verbose, but get over it. This bashism single-handedly disqualifies the POSIX shell for the purpose of this guide.\n\nGood:\n\n    files=(\n        a\n        b\n    )\n    duplicates=()\n    for f in \"${files[@]}\"; do\n        if cmp -- \"$f\" other/\"$f\"; then\n            duplicates+=(\"$f\")\n        fi\n    done\n    if [ \"${#duplicates[@]}\" -gt 0 ]; then\n        rm -- \"${duplicates[@]}\"\n    fi\n\nBad:\n\n    files=\" \\\n        a \\\n        b \\\n    \"\n    duplicates=\n    for f in $files; do\n        if cmp -- \"$f\" other/\"$f\"; then\n            duplicates+=\" $f\"\n        fi\n    done\n    if ! [ \"$duplicates\" = '' ]; then\n        rm -- $duplicates\n    fi\n\nLook how similar the two examples are: There is no algorithmical difference between using real arrays instead of strings as a (bad) substitute.\nA bonus point goes to the array syntax for not needing line continuations, making those lines possible to comment.\nThey are not equivalent, of course, as the \"bad\" example uses a whitespace delimited string,\nwhich breaks down as soon as a filename contains whitespace, and risks deleting the wrong files.\n\nIs the second example fixable? In theory, yes; in practice, no.\nWhile it is *possible* to represent a list in a string,\neven approachable if a suitable delimiter is known,\nit becomes hairy (escaping and unescaping the delimiter) to do 100% generically correct.\nWorse, getting it back into array form can not be abstracted away (try `set -- a b c` in a function).\nThe final blow is that fighting such an abstraction failure of the language is pointless if you can choose a different language.\n\nArrays is the feature that becomes absurdly impractical to program correctly without. Here is why:\n* You need *some* datastructure, that can take zero or more values, for passing zero or more values around cleanly.\n* In particular, [command arguments are fundamentally arrays](http://manpag.es/RHEL6/3p+exec). Hint: Shell scripting is all about commands and arguments.\n* All POSIX shells secretly support arrays anyway, in the form of the argument list `\"$@\"`.\n\nThe recommendation of this guide must therefore be to not give POSIX compatibility a second thought.\nThe POSIX shell standard is hereby declared unfit for our purposes.\nLikewise, sadly, for minimalistic POSIX compatible shells like [Dash](https://wiki.ubuntu.com/DashAsBinSh#A.24.7B....7D) and Ash that don't support arrays either.\nAs for Zsh, it supports a superset of Bash's array syntax, so it is good.\n\nThe lack of a minimalistic shell with array support is a bummer for embedded computuers, where shipping another language is cost sensitive, yet expectations for safety are high. Busybox is impressive for what you get in a small size, but as part of it, you get Ash, which is a hair puller.\n\n### Those exceptional cases where you actually intend to split the string\n\nSplitting `$string` on the separator `$sep` into `$array`:\n\nBad (indirect pathname expansion):\n\n    IFS=\"$sep\"\n    array=($string)\n\nGood:\n\n    array=()\n    while read -rd \"$sep\" i; do\n        array+=(\"$i\")\n    done < <(printf '%s%s' \"$string\" \"$sep\")\n\nThis works for any separator byte (no UTF-8 or multi-character separator string) except NUL. To make it work for NUL, hardcode the literal `$'\\0'` in place of `$sep`.\n\nThe reason for appending the separator to the end is that the field separator is really a field *terminator* (postfix, not infix). The distinction matters to the notion of an empty field at the end. Skip this if your input is already field terminated.\n\nAlternatively, for Bash 4:\n\n    readarray -td \"$sep\" array < <(printf '%s%s' \"$string\" \"$sep\")\n\nThe same notes apply to readarray (hardcoding of NUL, already field terminated input):\n\n    readarray -td $'\\0' array < <(find -print0)\n\nReadarray gets a small minus point for only working with ASCII separators (still no UTF-8).\n\nIf the separator consists of multiple bytes, it is also possible to do this correctly by string processing (such as by [parameter substitution](https://www.tldp.org/LDP/abs/html/parameter-substitution.html#PSOREX2)).\n\n#### An alternative with 3 corner cases\n\nThe otherwise evil IFS variable has a legitimate use in the `read` command, where it can be used as another way to separate fields without invoking indirect pathname expansion.\nIFS is brought into significance by requesting either multiple variables or using the array option to `read`.\nBy disabling the delimiter `-d ''`, we read all the way to the end.\nBecause read returns nonzero when it encounters the end, it must be guarded against errexit (`|| true`) if that is enabled.\n\nSplit to separate variables:\n\n    IFS=\"$sep\" read -rd '' a b rest < <(printf '%s%s' \"$string\" \"$sep\") || true\n\nSplit to an array:\n\n    IFS=\"$sep\" read -rd '' -a array < <(printf '%s%s' \"$string\" \"$sep\") || true\n\nThe 3 corner cases are tab, newline and space – when IFS is set to one of these as above, `read` drops empty fields!\nBecause this is often useful though, this method makes the bottom of the recommendation list instead of disqualification.\n\n### Corollary: Use while loops to iterate strings and command output\n\nShellharden won't let you get away with this:\n\n    for i in $(seq 1 10); do\n        printf '%s\\n' \"$i\"\n    done\n\nThe intuitive fix – piping into the loop – is not always cool,\nbecause the pipe operator's right operand becomes a subshell.\nNot that it matters for this silly example, but it would surprise many\nto find that this loop can't manipulate outside variables:\n\n    seq 1 10 | while read -r i; do\n        printf '%s\\n' \"$i\"\n    done\n\nTo avoid future surprises, the bulk of the code should typically not be the subshell.\nThis is all right:\n\n    while read -r i; do\n        printf '%s\\n' \"$i\"\n    done < <(seq 1 10)\n\nHow to begin a bash script\n--------------------------\n\n### hashbang\n\n    #!/usr/bin/env bash\n\n* Portability consideration: The absolute path to `env` is likely more portable than the absolute path to `bash`. Case in point: [NixOS](https://nixos.wiki/wiki/NixOS). POSIX mandates [the existence of `env`](http://manpag.es/RHEL6/1p+env), but bash is not a posix thing.\n* Safety consideration: No language flavor options like `-euo pipefail` here! It is not actually possible when using the `env` redirection, but even if your hashbang begins with `#!/bin/bash`, it is not the right place for options that influence the meaning of the script, because it can be overridden, which would make it possible to run your script the wrong way. However, options that don't influence the meaning of the script, such as `set -x` would be a bonus to make overridable (if used).\n\n### Safer and better globbing\n\n    shopt -s nullglob globstar\n\n* `nullglob` is what makes `for f in *.txt` work also when zero files happen to match the expression. It removes a special case in the default behavior:\n    * The default behavior (unofficially called [passglob](https://github.com/fish-shell/fish-shell/issues/2394#issuecomment-182047129)) is to pass the pattern as-is in that event.\n    As always, special cases are an enemy of correctness: It creates a two-sided source of bugs that likes to defy test coverage:\n    On one side, it necessitates workarounds when you wanted the general behavior (file existence checks in this case);\n    on the other side, it supports a convenient and wrong use case ([nothing is worse than the intersection between convenient and wrong][Jussi's two ways]).\n    When you mean to pass the pattern literally, the safe thing to do is to just do that instead: Quote it.\n    * `failglob` is also a fine alternative, but not as generally usable:\n    It can be used if zero matches would always be an error (and conveniently makes it so),\n    whereas `nullglob` makes it both non-special and easy to check for\n    (`txt_files=(*.txt); test \"${#txt_files[@]}\" -eq 0`).\n    Also, `failglob` depends on `errexit` (aka. `set -e`) to actually exit on failure.\n* `globstar` enables recursive globbing. Since globbing is easier to use correctly than `find`, use it.\n\n### Strict Mode – safe and relevant subset edition\n\n    if test \"$BASH\" = \"\" || \"$BASH\" -uc \"a=();true \\\"\\${a[@]}\\\"\" 2>/dev/null; then\n        # Bash 4.4, Zsh\n        set -euo pipefail\n    else\n        # Bash 4.3 and older chokes on empty arrays with set -u.\n        set -eo pipefail\n    fi\n\nThis is [Bash's unofficial strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) except:\n\n* `nounset` (aka. `set -u`) is behind a feature check.\n* Setting IFS to something safer (but still unsafe): Doesn't hurt, but is irrelevant: Being shellcheck/shellharden compliant means quoting everything – implicit use of IFS is forbidden anyway.\n\nAs it turns out, `nounset` **is dangerous** in Bash 4.3 and earlier: In those versions, it [treats empty arrays as unset](http://stackoverflow.com/questions/7577052/bash-empty-array-expansion-with-set-u). What have we just learned about special cases? They are an enemy of correctness. Also, this can't be worked around, and since using arrays is rather basic in this methodology, and they definitely need to be able to hold empty values, this is far from an ignorable problem. If using `nounset` at all, make sure to use Bash 4.4 or another sane shell like Zsh (easier said than done if you are writing a script and someone else is using it). Fortunately, what works with `nounset` will also work without (unlike `errexit`). Thus why putting it behind a feature check is sane at all.\n\nOther alternatives:\n\n* Setting IFS (the *internal field separator*) to the empty string disables word splitting. Sounds like the holy grail, but isn't: Firstly, empty strings still become empty arrays (very uncool in expressions like `test $x = \"\"`) – you still need to quote everything that *can* be an empty string, and for purposes of static verification, *everything* can (with the exception of a handful of special variables). Secondly, indirect pathname expansion is still a thing (can be turned off, se the next point). Thirdly, it interferes with commands like `read` that also use it, breaking constructs like `cat /etc/fstab | while read -r dev mnt fs opt dump pass; do printf '%s\\n' \"$fs\"; done'`.\n* Disabling pathname expansion (globbing) altogether: If there was an option to only disable indirect pathname expansion, I would. Giving up the unproblematic direct one too, that I'm saying you should want to use, is a tradeoff that I can't imagine being necessary, yet currently is.\n\n### Assert that command dependencies are installed\n\n[Declaring your dependencies](https://12factor.net/dependencies) has many benefits, but until this becomes statically verifiable, concentrate on uncommon commands here.\nThis prevents your script from failing for external reasons in hard-to-reach sections of code, such as in error handling or the end of a long-running script.\nIt also prevents misbehavior such as `make -j\"$(nproc)\"` becoming a fork bomb.\n\n    require(){ hash \"$@\" || exit 127; }\n    require …\n    require …\n    require …\n\nBenefits of using `hash` for this purpose are its low overhead and that it gives you an error message in the failure case.\nThis doesn't check option compatibility, of course, but it's also not forbidden to add feature checks for that.\n\nHow to end a bash script\n------------------------\n\nGoal: The script's exit status should convey its overall success or failure.\n\nReality: The script's exit status is that of the last command executed.\n\nThere is a wrong way to end a bash script:\nLetting a command used as a condition be the last command executed, so that the script \"fails\" iff the last condition is false.\nWhile that might happen to be correct for a script, it is a way to encode the exit status that looks accidental and is easily broken by adding or removing code to the end.\n\nThe rightness criterion here is that the last statement follows the \"Errexit basics\" below. When in doubt, end the script with an explicit exit status:\n\n    exit 0\n\nHow to use errexit\n------------------\n\nAka `set -e`.\n\n### Errexit basics\n\nBackground: If a command that is not used as a condition returns nonzero, the interpreter exits at that point.\n\nFailure is trivial to suppress:\n\n    command || true\n\nDon't skimp on if-statements. You can't use `&&` as a shorthand if-statement without always using `||` as an else-branch. Otherwise, the script terminates if the condition is false.\n\nBad:\n\n    command && …\n\nGood (contrived):\n\n    command && … || true\n\nGood (contrived):\n\n    ! command || …\n\nGood (idiomatic):\n\n    if command; then\n        …\n    fi\n\nTo capture a command's output while using it as a condition, use an assignment as the condition (but see below on not using `local` on assignments):\n\n    if output=\"$(command)\"; then\n        …\n    fi\n\nIf at all using the exit status variable `$?` with errexit, it is of course no substitute for the direct check for command success (otherwise, your script won't live to see this variable whenever it is nonzero). Corollary: The failure case is the only place it makes sense to expand the exit status variable `$?` (because success only has one exit status, which we are checking). A second pitfall is that if we negate the command as part of the check, the exit status will be that of the negated command – a boolean with precisely the useful information removed.\n\nBad:\n\n    command\n    if test $? -ne 0; then\n        echo Command returned $?\n    fi\n\nBad:\n\n    if ! command; then\n        echo Command returned $?\n    fi\n\nGood:\n\n    if command; then\n        true\n    else\n        echo Command returned $?\n    fi\n\nGood:\n\n    command || echo Command returned $?\n\n### Program-level deferred cleanup\n\nIn case errexit does its thing, use this to set up any necessary cleanup to happen at exit.\n\n    tmpfile=\"$(mktemp -t myprogram-XXXXXX)\"\n    cleanup() {\n        rm -f \"$tmpfile\"\n    }\n    trap cleanup EXIT\n\n### Gotcha: Errexit is ignored in command arguments\n\nHere is a nice underhanded fork bomb that I learnt the hard way – my build script worked fine on various developer machines, but brought my company's buildserver to its knees:\n\n    set -e # Fail if nproc is not installed\n    make -j\"$(nproc)\"\n\nCorrect (command substitution in assignment):\n\n    set -e # Fail if nproc is not installed\n    jobs=\"$(nproc)\"\n    make -j\"$jobs\"\n\nCaution: Builtins like `local` and `export` are also commands, so this is still wrong:\n\n    set -e # Fail if nproc is not installed\n    local jobs=\"$(nproc)\"\n    make -j\"$jobs\"\n\nShellCheck warns only about special commands like `local` in this case.\n\nTo use `local`, separate the declaration from the assignment:\n\n    set -e # Fail if nproc is not installed\n    local jobs\n    jobs=\"$(nproc)\"\n    make -j\"$jobs\"\n\n### Gotcha: Errexit is ignored depending on caller context\n\nSometimes, POSIX is cruel. Errexit is ignored in functions, group commands and even subshells if the caller is checking its success. These examples all print `Unreachable` and `Great success`, despite all sanity.\n\nSubshell:\n\n    (\n        set -e\n        false\n        echo Unreachable\n    ) && echo Great success\n\nGroup command:\n\n    {\n        set -e\n        false\n        echo Unreachable\n    } && echo Great success\n\nFunction:\n\n    f() {\n        set -e\n        false\n        echo Unreachable\n    }\n    f && echo Great success\n\nThis makes bash with errexit practically incomposable – it is *possible* to wrap your errexit functions so that they still work, but the effort it saves (over explicit error handling) becomes questionable. Consider splitting into completely standalone scripts instead.\n\nHow to write conditions\n-----------------------\n\n### Should I use double-bracket conditions?\n\nThat is unimportant, but let's dispel some myths about these largely interchangeable forms of conditions:\n\n```\ntest …\n[ … ]\n[[ … ]]\n```\n\nWhen in doubt, ask your shell:\n\n    > type test\n    test is a shell builtin\n    > type [\n    [ is a shell builtin\n    > type [[\n    [[ is a shell keyword\n\n* None of them are external commands (even in Fish).\n* The two first are mere commands; the third has syntactic superpowers.\n* Double brackets are not POSIX. Busybox `ash` supports them, but the wrong way.\n\nThe thing about double-bracket conditions is that, being magic syntax,\nit has access to its arguments before expansion, unlike any command.\nWhat it does is make many unsafe habits safe, such as not quoting variable expansions.\nIs that a good thing?\n\nUnderstanding and exploiting its improved safety aspects requires more of your readers,\nand the problems it solves are problems you don't have if you are following this guide.\n\nFor pedagogical purposes, the `test` command is the most honest about being a command. Issues like whitespace sensitivity and how to combine them (unambiguously) become self-evident when looked at the right way.\n\nDouble-bracket conditions also have more features. But they have good POSIX substitutes for the most part:\n\n* Pattern matching (`[[ $path == *.png || $path == *.gif ]]`): This is what `case` is for.\n* Logical operators: The usual suspects `&&` and `||` work just fine – outside commands – and can be grouped with group commands: `if { true || false; } && true; then echo 1; else echo 0; fi`.\n* Checking if a variable exists (`[[ -v varname ]]`): Yes, this is possibly a killer argument, but consider the programming style of always setting variables, so you don't need to check if they exist.\n\n### Are empty string comparisons any special?\n\nOf course not:\nQuoting also works when strings are empty on purpose!\nFor readability, prefer normal string comparisons.\n\nGood:\n\n    test \"$s\" != \"\"\n    test \"$s\" = \"\"\n    [ \"$s\" != \"\" ]\n    [ \"$s\" = \"\" ]\n\n(Many shells also support `==`, but a single equal-sign is posixly correct.)\n\nBad (readability):\n\n    test -n \"$s\"\n    test -z \"$s\"\n    [ -n \"$s\" ]\n    [ -z \"$s\" ]\n\nPlain wrong (always true):\n\n    test -n $s\n    [ -n $s ]\n\nShellharden replaces the `-z/-n` flags with their equivalent string comparisons.\n\n### How to check if a variable exists\n\nThe correct way to check if a variable exists came with Bash 4.2 (also verified for zsh 5.6.2) and is not a feature of POSIX.\nConsider therefore to avoid the problem by always setting variables, so you don't need to check if they exist.\n\nAlternative (POSIX blessed):\n\n    \"${var-val}\" # default value if unset\n    \"${var:-val}\" # default value if unset or empty\n\nPOSIX allows expanding a possibly unset variable (even with `set -u`) by giving a default value.\n\nGood (if you must):\n\n```\n# Feature check to fail early on Mac OS with Bash 3.9:\n[[ -v PWD ]]\n\n[[ -v var ]]\n```\n\nIf using this and there is any chance someone might try to run your script with an earlier Bash version, it is best to fail early. The feature check above tests for a variable that we know exists and results in a syntax error and termination in earlier versions.\n\nBad:\n\n    test -n \"$var\"\n    [ -n \"$var\" ]\n    [[ -n $var ]]\n    [[ -n \"$var\" ]]\n\nThese don't distinguish being unset with being empty (as a string or array) and obviously precludes the use of `set -u`.\n\nRecall that the `-z/-n` flags are effectively string comparisons in disguise. As such, they are even less suitable as variable existence checks. Other than to distinguish intent – a fair but not good argument.\n\n### How to combine conditions (unambiguously)\n\nThis problem evaporates when realizing that conditions are commands – POSIX already defines this:\nThe shell syntax for conjunction `&&`, disjunction `||`, negation `!` and grouping `{}` of commands applies to all commands,\nand the arguments to those commands can contain shell syntax all they want.\n\nThe confusing part is that the `test` or `[` command has operators for the same:\nPOSIX (man 1p test) defines these as `-a`, `-o`, `!`, and parentheses.\nBut is everything that POSIX standardizes safe? Hint: POSIX is more about portability.\n\nThese operators are ill-conceived because strings can evaluate to operators,\nand different operators take different numbers of operands,\nwhich together can lead to desynchronization.\nTo prevent string content from changing the meaning of the test,\nthe same standard prescribes that the number of arguments has the highest precedence:\nPOSIX defines the unambiguous meaning of a test, from 0 to 4 arguments, but not more.\nThese definitions do not include any conjunctions or disjunctions\n(likely because the unambiguity breaks down in the combinatorial explosion).\n\nBad (unless your shell can unambiguously interpret a 13-argument test):\n\n    test ! -e \"$f\" -a \\( \"$s\" = yes -o \"$s\" = y \\)\n    [ ! -e \"$f\" -a \\( \"$s\" = yes -o \"$s\" = y \\) ]\n\nGood:\n\n    ! test -e \"$f\" && { test \"$s\" = yes || test \"$s\" = y; }\n    ! [ -e \"$f\" ] && { [ \"$s\" = yes ] || [ \"$s\" = y ]; }\n\n### xyes deemed unnecessary\n\nIs this idiom of any use?\n\n    test x\"$s\" = xyes\n\n1. Not to preserve empty strings: Use quoting.\n2. Not to prevent ambiguity in case the variable contains a valid operator: The number of arguments has highter precedence.\n3. When used with the AND/OR operators (`-a/-o`), it can prevent ambiguity. However, this use is unnecessary (see above).\n\nShellharden simplifies \"xyes\" conditions when the \"x\" part is unquoted.\n\nCommands with better alternatives\n---------------------------------\n\n### echo → printf\n\nAs with any command, there must be a way to control its option parsing to prevent it from interpreting data as options.\nThe standard way to signify the end of options is with a double-dash `--` argument.\n\nSignificance of the double-dash `--` argument, explained in error messages:\n\n    > shellharden --hlep\n    --hlep: No such option\n    > shellharden -- --hlep\n    --hlep: No such file or directory\n\nAs such, the GNU version of `echo` (both the bash builtin and `command echo`) is fatally flawed.\nUnlike the POSIX version, it takes options, yet it offers no way to suppress further option parsing.\n(Specifically, it interprets any number of leading arguments as options until the first argument that is not an option.)\n\nThe result is that `echo` is not *generally* possible to use correctly.\n(It is safe as long as its first non-option character is provably not a dash – we can not just print anything unpredictable like a variable or command substitution; we must first print *some* literal character, that is not the dash, and *then* the unpredictable data!)\n\nIn contrast, `printf` is always possible to use correctly (not saying it is easier)\nand can do a superset of `echo` (including its bashisms, just without bashisms).\n\nBad:\n\n    echo \"$var\"\n    echo -n \"$var\"\n    echo -en \"$var\\r\"\n\n    echo \"$a\" \"$b\"\n    echo \"${array[@]}\"\n\nGood:\n\n    printf '%s\\n' \"$var\"\n    printf '%s' \"$var\"\n    printf '%s\\r' \"$var\"\n\n    printf '%s %s\\n' \"$a\" \"$b\"\n    printf '%s\\n' \"${array[*]}\"\n\nAt this point, it gets tempting to redefine `echo` to something sane,\nexcept that overloading existing functionality is generally not a robust and reassuring practice – it breaks unnoticeably.\nFor verifiability's sake, better leave `echo` forever broken, and call yours something else:\n\n    println() {\n        printf '%s\\n' \"$*\"\n    }\n\nHow to avoid invoking the shell with improper quoting\n-----------------------------------------------------\n\nWhen invoking a command from other programming languages, the wrong thing to do is often the easiest: implicitly invoking the shell. If that shell command is static, fine – either it works, or it doesn't. But if your program is doing any kind of string processing to assemble that command, realize that you are **generating a shellscript**! Rarely what you want, and tedious to do correctly:\n\n* quote each argument\n* escape relevant characters in the arguments\n\nNo matter which programming language you are doing this from, there are at least 3 ways to construct the command correctly. In order of preferece:\n\n### Plan A: Avoid the shell\n\nIf it's just a command with arguments (i.e. no shell features like piping or redirection), choose the array representation.\n\n* Bad (python3): `subprocess.check_call('rm -rf ' + path)`\n* Good (python3): `subprocess.check_call(['rm', '-rf', path])`\n\nBad (C++):\n\n    std::string cmd = \"rm -rf \";\n    cmd += path;\n    system(cmd);\n\nGood (C/POSIX), minus error handling:\n\n    char* const args[] = {\"rm\", \"-rf\", path, NULL};\n    pid_t child;\n    posix_spawnp(&child, args[0], NULL, NULL, args, NULL);\n    int status;\n    waitpid(child, &status, 0);\n\n### Plan B: Static shellscript\n\nIf the shell is needed, let arguments be arguments. You might think this was cumbersome – writing a special-purpose shellscript to its own file and invoking that – until you have seen this trick:\n\n* Bad (python3): `subprocess.check_call('docker exec {} bash -ec \"printf %s {} > {}\"'.format(instance, content, path))`\n* Good (python3): `subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s \"$0\" > \"$1\"', content, path])`\n\nCan you spot the shellscript?\n\nThat's right, the printf command with the redirection. Note the correctly quoted numbered arguments. Embedding a static shellscript is fine.\n\nThe examples run in Docker because they wouldn't be as useful otherwise, but Docker is also a fine example of a command that runs other commands based on arguments. This is unlike Ssh, as we will see.\n\n### Last option: String processing\n\nIf it *has* to be a string (e.g. because it has to run over `ssh`), there is no way around it. We must quote each argument and escape whatever characters are necessary to escape within those quotes. The simplest is to go for single quotes, since these have the simplest escaping rules – only one: `'` → `'\\''`.\n\nA very typical filename, in single quotes:\n\n    echo 'Don'\\''t stop (12\" dub mix).mp3'\n\nNow, how to use this trick to run commands safely over ssh? It's impossible! Well, here is an \"often correct\" solution:\n\n* Often correct (python3): `subprocess.check_call(['ssh', 'user@host', \"sha1sum '{}'\".format(path.replace(\"'\", \"'\\\\''\"))])`\n\nThe reason we have to concatenate all the args to a string in the first place, is so that Ssh won't do it the wrong way for us: If you try to give multiple arguments to ssh, it will treacherously space-concatenate the arguments without quoting.\n\nThe reason this is not generally possible is that the correct solution depends on user preference at the other end, namely the remote shell, which can be anything. It can be your mother, in principle. Assuming that the remote shell is bash or another POSIX compatible shell, the \"often correct\" will in fact be correct, but [fish is incompatible on this point](https://github.com/fish-shell/fish-shell/issues/4907).\n\n#### How to be Fish compatible\n\nThis is only necessary if you are forced to interoperate with a user's favourite shell, such as when implementing [ssh-copy-id](https://github.com/fish-shell/fish-shell/issues/2292).\n\nThe issue with supporting Fish is that the subset of common syntax with POSIX/Bash is mostly useless.\nThe general approach is therefore to duplicate the code – obviously against any safety recommendation.\n\nBut if you must, so be it:\n\n    test '\\'\n\n    echo \"This is POSIX!\"\n\n    test '\n\n    echo \"This is fish!\"\n\n    test \\'\n\n[Jussi's two ways]: <https://web.archive.org/web/20150905075810/http://voices.canonical.com/jussi.pakkanen/2014/07/22/the-two-ways-of-doing-something/> \"If there is an easy way to do something, and another, correct way to do the same, programmers will always choose the easy way. As a corollary for language design, the correct thing to do must also be the easiest.\"\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "moduletests",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}