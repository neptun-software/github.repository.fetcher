{
  "metadata": {
    "timestamp": 1736709255469,
    "page": 581,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mlua-rs/rlua",
      "stars": 1742,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0595703125,
          "content": "target/\n**/*.rs.bk\nCargo.lock\n.DS_Store\n.#*\n.envrc\nshell.nix\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 16.7236328125,
          "content": "## [0.20.1]\n- Add \"deprecated\" badge\n\n## [0.20.0]\n- Switch to being a wrapper around mlua\n\n## [0.19.8]\n- Update rustyline dev-dependency (thanks @salexan2001)\n- Fix builds for iOS (thanks @w-ensink)\n- Add an example changing `package.path` (thanks @paulfrische)\n- Fix crash on empty source with LuaJIT\n- Update some dependencies\n- Fix a leak when destroying `Lua` object with `LuaJIT`.\n\n## [0.19.7]\n- Cosmetic fixes to README.md\n\n## [0.19.6]\n- Initial support for LuaJIT (thanks lazytiger)\n\n## [0.19.5]\n- Update to Lua 5.4.6 (thanks @0x2ec)\n\n## [0.19.4]\n- Fix the `lua-no-oslib` feature introduced with a bug in 0.19.3.\n\n## [0.19.3]\n- Add new features `lua-no-oslib` to not compile in the `os` lib to the\n  Lua library.  Useful for targets (e.g. iOS) where the `os` lib is unavailable.\n\n## [0.19.2]\n- Fix issue #253 (userdata types with alignment > 8 bytes could cause crashes)\n\n## [0.19.1]\n- The -sys crates (bumped to 0.1.1) now use pregenerated bindgen outputs in the\n  package instead of running bindgen at build time.  This means that libclang is\n  no longer needed when building.\n- A Windows build has been added to CI.\n\n## [0.19.0]\n- The Lua C library build now uses separate -sys crates, and bindgen rather than\n  hand-maintained declarations.  (Thanks @pollend!)  The \"builtin-lua51\" feature\n  is now available.\n- Value::Integer is now no longer available when building for Lua 5.1.  (In Lua 5.1\n  there is no integer type).\n- Add `Function::dump()` which produces the compiled version of a function (like\n  the `string.dump` Lua function or `lua_dump()` C API).\n- Add unsafe `Chunk::into_function_allow_binary()`.  This allows loading a compiled\n  binary generated from `Function::dump()`.\n- Add `Initflags` to control some settings done when `Lua` is initialised.  They\n  can be specified with the new unsafe `Lua::unsafe_new_with_flags()` constructor.\n  The flags available (all set by default with the other constructors):\n  * PCALL_WRAPPERS:\n    - wrap pcall and xpcall so that they don't allow catching Rust panics\n  * LOAD_WRAPPERS:\n    - wrap functions load, loadfile, dofile (and loadstring for lua 5.1) to prevent\n      loading compiled/bytecode modules.\n  * REMOVE_LOADLIB:\n    - Remove `package.loadlib` and the module finding functions which allow loading\n      compiled C libraries.\n- `String<'lua>` now implements `Eq` and `Hash` (can be useful for local collections\n  within a context callback).\n\n## [0.18.0]\n- Add support for multiple Lua versions, including 5.1, 5.3 and 5.4 (the default)\n- Add implementations of `FromLua` and `ToLua` for `[T;N]`.\n\n## [0.17.1]\n- Add \"lua-compat-mathlib\" feature, which enables Lua's LUA_COMPAT_MATHLIB\n  option.\n- Bump num-traits version to 0.2.14 and fix some incompatibilities\n- Fix some tests from improved diagnostics in recent rustc.\n\n## [0.17]\n- API incompatible change: depend on `bstr` crate and implement `ToLua` /\n  `FromLua` for `BString` and `BStr` types (thanks @azdle!)\n- Add methods (`Lua::[unsafe]_load_from_stdlib` load from the Lua stdlib on an\n  existing instance (thanks @azdle!)\n- Actually print the cause error in `Error::CallbackError` (thanks @LPGhatguy!)\n- API incompatible change: Add `MetaMethod::Pairs` for the metamethod used by\n  the bult-in `pairs` function (thanks @steven-aerts!)\n\n## [0.16.3]\n- Add a `Context::current_thread` method to get a reference to the `Thread`\n  backing a given `Context`.\n- Portability fix: Remove a needless cast, fixing builds targetting armv7.\n- Small documentation improvements, additional tests\n\n## [0.16.2]\n- Documentation fixes\n- Performance improvement to scoped and non-scoped UserDataMethods.  Still could be much better,\n  further improvements coming eventually.\n- API incompatible change (soundness fix): Remove unintentional ability to load bytecode via\n  `Context::load`.  Now only loads text source, bytecode can cause UB in the Lua VM.\n\n## [0.16.1]\n- Documentation fixes\n\n## [0.16]\n- Small fixes for the way new `Lua` states are created, preventing some potential unhandled errors\n- Propery mark all internal panics as internal and indicative of a bug\n- HUGE API incompatible change: move most of the `Lua` API into `Context` and require context\n  callbacks to generate a branding lifetime, and use this branding lifetime on handle types.  Fixes\n  a hard to trigger soundness issue, and removes the only remaining API panic (that is not a bug).\n  See the documentation for the `Lua` type for more details.\n- Fix `error_traceback` to work in all cases (thanks @yasumutte!)\n- Use compiletest_rs on stable\n- API incompatible change: Change to use 2018 edition, `rlua` now requires rustc 1.31 to use.\n- Implement `ToLua` for `CStr` and `CString`, implement `FromLua` for `CString` (thanks @althonos!)\n- Add ability to control what std libraries are loaded in a Lua state on startup\n  (huge thanks to @Shiroy!)\n- Add ability to set the Lua \"hook function\", which allows for limiting the execution of running scripts\n  (huge thanks to @lemarcuspoilus!)\n- API incompatible change: remove `failure` as a dependency, `Error` no longer implements\n  `failure::Fail`.\n- API incompatible change: change the API for loading Lua chunks to allow for changing _ENV.\n  `Context::load` now returns a builder on which you can set the chunk name and _ENV.\n- API incompatible change: remove `str` assumptions from the remaining places: the `UserData` trait\n  and named registry keys\n- (Painstakingly!) remove the need for the `gc_guard` garbage collector hack, and thus also the\n  \"abort on OOM\" hack.\n- Add an API for memory limits, now possible because of removal of `gc_guard`.\n- Add an API for controlling the garbage collector, also now possible due to the removal of `gc_guard`.\n- Remove the last internal aborts from `rlua`, possible to make safe due to the removal of `gc_guard`.\n\n## [0.15.3]\n- Fix improper num-traits dependency, proper [ui]128 support only added\n  later in 0.2 series (thanks @sakridge for catching this!)\n\n## [0.15.2]\n- API Incompatible change: Allow `Lua::load` `Lua::exec` and `Lua::eval` to take\n  &String &str and &[u8] like `Lua::create_string` does.  I think this might be\n  technically allowed in a minor revision, but due to how rlua is used it's\n  definitely more like an API incompatible change.  This is a last minute\n  same-day change to 0.15 though, so there's no sense in adding another version\n  bump.\n\n## [0.15.1]\n- Docs and changelog fixes\n\n## [0.15.0]\n- Implement MultiValue conversion up to 16\n- Small fix to prevent leaking on errors in metatable creation\n- API incompatible change: New API for non-'static UserData!  Scoped UserData is\n  now split into `create_static_userdata` and `create_nonstatic_userdata`\n  because there are certain limitations on `create_nonstatic_userdata` that mean\n  that nonstatic is not always what you want.\n- API incompatible change: In order to support the new non-'static scoped\n  UserData, the API for UserData methods has changed, and UserDataMethods is now\n  a trait rather than a concrete type.\n- Added pkg-config feature that can be used if builtin-lua is disabled to use\n  pkg-config to find lua5.3 externally (thanks @acrisci!).\n- API incompatible change: Add conversions for i128 and u128 and change the\n  behavior of numeric conversions to not implicitly `as` cast.  Numeric\n  conversions now use `num_traits::cast` internally and error when the cast\n  function fails.  This errors on out of range but *not* loss of precision, so\n  casting 1.1f64 to i32 will succeed, but casting (1i64 << 32) to i32 will not.\n  When casting *to* lua, integers that are out of range of the lua_Integer type\n  are instead converted to lua_Number.\n- Allow arbitrary &[u8]-like data in `Lua::create_string`.  This uses\n  `AsRef<[u8]>` so you can use &str and &String, but you can also now use\n  `&[u8]`, which enables you to create non-utf8 Lua strings.\n\n## [0.14.2]\n- Another soundness fix for `Lua::scope` that is related to the last soundness\n  fix, forbidding capturing 'lua arguments inside callbacks.  This, like the\n  previous fix, is a breaking change, but anything that it breaks was *probably*\n  unsound.\n\n## [0.14.1]\n- Update to require failure 0.1.2 and fix deprecation warnings.\n- Update embedded Lua to 5.3.5\n- Important soundness fix for `Lua::scope`, no longer allow callbacks created\n  from `Scope` to leak their parameters.\n\n## [0.14.0]\n- Lots of performance improvements, including one major change: Lua handles no\n  longer use the registry, they now instead are stored in an auxiliary thread\n  stack created solely for the purpose of holding ref values.  This may seem\n  extremely weird, but it is vastly faster than using the registry or raw tables\n  for this purpose.  The first attempt here was to use the same stack and to do\n  a lot of complex bookkeeping to manage the references, and this DOES work, but\n  it comes with a lot of complexity and downsides along with it.  The second\n  approach of using an auxiliary thread turned out to be equally fast and with\n  no real downsides over the previous approach.  With all the performance\n  improvements together, you can expect (VERY rough estimate) somewhere on the\n  order of 30%-60% CPU time reduction in the cost of bindings, depending on\n  usage patterns.\n- Addition of some simple criterion.rs based benchmarking.  This is the first\n  `rlua` release to focus on performance, but performance will hopefully remain\n  a focus going forward.\n- API incompatible change: `Lua` is no longer `RefUnwindSafe` and associated\n  handle values are no longer `UnwindSafe` or `RefUnwindSafe`.  They should not\n  have been marked as such before, because they are *extremely* internally\n  mutable, so this can be considered a bugfix.  All `rlua` types should actually\n  be perfectly panic safe as far as *internal* invariants are concerned, but\n  (afaict) they should not be marked as `RefUnwindSafe` due to internal\n  mutability and thus potentially breaking *user* invariants.\n- Upgrade to require `cc` 1.0.\n- Several Lua stack checking bugs have been fixed that could have lead to\n  unsafety in release mode.\n\n## [0.13.0]\n- Small API incompatible change which fixes unsafety: Scope and scope created\n  handle lifetimes have been changed to disallow them from escaping the scope\n  callback.  Otherwise, this could lead to dangling registry handles, which can\n  be used to cause UB.  This is the only API change for 0.13.\n- Small fixes for potential panics / longjmps around the embedded traceback\n  function.\n- Temporary fix for #71 that works on stable rust without dirty tricks, while\n  waiting for the larger fix for rust #48251 to make its way to stable.\n\n## [0.12.2]\n- Some minor documentation fixes.\n- Fix for some rare panics which might result in an abort from panicking across\n  a C API boundary.\n\n## [0.12.1]\n- Fix a stupid bug where `AnyUserData::set_user_value` /\n  `AnyUserData::get_user_value` could panic if the `ToLua` / `FromLua` type\n  conversion failed.\n- Add `UserDataMethods::add_function_mut` and\n  `UserDataMethods::add_meta_function_mut` for symmetry.\n- Add some more documentation for changes in 0.12, and fix some minor problems.\n\n## [0.12.0]\n- Changed how userdata values are garbage collected, both to fix potential\n  panics and to simplify it.  Now, when userdata is garbage collected, it will\n  be given a special \"destructed userdata\" metatable, and all interactions with\n  it will error with `CallbackDestructed`.  From the rust side, an expired\n  userdata `AnyUserData` will not appear to be any rust type.\n- Changed the `RegistryKey` API to be more useful and general.  Now, it is not\n  100% necessary to manually remove `RegistryKey`s in order to clean up the\n  registry, instead you can periodically call `Lua::expire_registry_values` to\n  remove registry values with `RegistryKey`s that have all been dropped.  Also,\n  it is no longer a panic to use a `RegistryKey` from a mismatched Lua instance,\n  it is simply an error.\n- Lua is now `Send`, and all userdata / callback functions have a Send\n  requirement.  This is a potentially annoying breaking change, but there is a\n  new way to pass !Send types to Lua in a limited way.\n- HUGE change, there is now a `Lua::scope` method, which allows passing\n  non-'static functions to Lua in a controlled way.  It also allows passing\n  !Send functions and !Send userdata to Lua, with the same limitations.  In\n  order to make this safe, the scope method behaves similarly to the `crossbeam`\n  crate's `crossbeam::scope` method, which ensures that types created within the\n  scope are destructed at the end of the scope.  When using callbacks / userdata\n  created within the scope, the callbacks / userdata are guaranteed to be\n  destructed at the end of the scope, and inside Lua references to them are in\n  an invalidated \"destructed\" state.  This destructed state was already possible\n  to observe through `__gc` methods, so it doesn't introduce anything new, but\n  it has been fixed so that it cannot cause panics, and has a specific error\n  type.\n- Correctly error on passing too many arguments to an `rlua::Function`, and\n  correctly error when returning too many results from a callback.  Previously,\n  this was a panic.\n- `Lua::create_function` is now split into `Lua::create_function` and\n  `Lua::create_function_mut`, where the first takes a Fn and the second takes a\n  FnMut.  This allows for recursion into rust functions if the function is not\n  FnMut.  There is a similar change for `UserDataMethods`, where the mut\n  variants of the functions now take `FnMut`, and the non-mut variants take\n  `Fn`.  There is not a way to make a non-mut `UserDataMethods` method with a\n  FnMut function.\n\n## [0.11.0]\n- `rlua::Error` now implements `failure::Fail` and not `std::error::Error`, and\n  external errors now require `failure::Fail`.  This is the only API\n  incompatible change for 0.11, and my hope is that it is relatively minor.\n  There are no additional bounds on external errors, since there is a blanket\n  impl for `T: std::error::Error + Send + Sync` of `failure::Fail`, but\n  `rlua::Error` no longer implements `std::error::Error` and there is an\n  additional dependency, and that is more likely to cause breakage.\n- protect a call to `luaL_ref` when creating new userdata types.\n- Some documentation improvements for `Error`, `Lua::create_function`, and\n  `MetaMethod`, and a rustdoc warning fix (thanks @jonas-schievink!)\n- Expose the `RegistryKey` type in the API properly, which makes the API around\n  it vastly easier to use!  Also fixes a safety hole around using the\n  `RegistryKey` API with the wrong `Lua` instance.\n- Add an API for \"user values\", which are arbitrary Lua values that can be\n  attached to userdata.\n\n## [0.10.2]\n- Registry API for storing values inside the `Lua` instance, either by string or\n  by automatically generated keys.\n- Important memory safety fix for `luaL_ref`.\n\n## [0.10.1]\n- Documentation spelling fix\n\n## [0.10.0]\n- Handle all 'm' functions in the Lua C API correctly, remove LUA_ERRGCMM hacks.\n- Lots and lots of internal changes to support handling all 'm' errors\n- Change the API in a lot of places due to functions that can trigger the gc now\n  potentially causing Error::GarbageCollectorError errors.\n\n## [0.9.7]\n- Add unsafe function to load the debug Lua module (thanks @Timidger!)\n- Fix setmetatable wrapper with nil metatable (thanks again to @Timidger!)\n\n## [0.9.6]\n- Fix an annoying bug that made external errors appear to have no further cause\n  errors in the cause chain.\n\n## [0.9.5]\n- Fix incorrect `xpcall` behavior\n- Change FromLua / ToLua impls for HashMap to be generic over the hasher.  This\n  may be technically a backwards incompatible change, but this would be really\n  unusual though, and I don't think it deserves an API bump.\n\n## [0.9.4]\n- Fix quadratic behavior in ``Function::bind``\n- `lua_checkstack` fixes, particularly fixing a crash bug due to luaL_ref using\n  a single extra stack space.\n\n## [0.9.3]\n- Soundness fix for recursive function calls, now causes a panic.\n  This is temporary while I work on a more major update that\n  prevents panics / aborts from scripts.\n\n## [0.9.2]\n- Bugfix, don't load the \"base\" library into the \"base\" global variable\n  @jonas-schievink\n- Additional documentation work, a link fix for `Variadic` docs, new crate\n  documentation @jonas-schievink\n- Metatable access on `Table`\n- `gcc` crate warning fix for 0.3.52 and up\n- Bugfix for `Table::raw_get`, now actually calls raw_get and is sound.\n\n## [0.9.1]\n- Add travis badge\n\n## [0.9.0]\n- Huge API change, removed the `Lua` prefix on all types, changes to callback\n  signature that remove the need for manual wrapping and unwrapping in most\n  cases.\n- Tons of soundness bugfixes, very few soundness problems remain.\n- Tons of documentation and bugifx work @jonas-schievink\n\n## [0.8.0]\n- Major API change, out of stack space is no longer an Err, you should not be\n  able to run out of stack space by using this API, except through bugs.\n- Simplification of error types\n\n## [0.7.0]\n- API change to remove dependency on `error_chain`, major changes to error\n  handling strategy to allow Lua to catch and rethrow rust errors sanely.\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 1.0966796875,
          "content": "[package]\nname = \"rlua\"\nversion = \"0.20.1\"\nauthors = [\"kyren <kerriganw@gmail.com>\"]\nedition = \"2018\"\ndescription = \"High level bindings to Lua 5.x\"\nrepository = \"https://github.com/mlua-rs/rlua\"\ndocumentation = \"https://docs.rs/rlua\"\nreadme = \"README.md\"\nkeywords = [\"lua\"]\nlicense = \"MIT\"\ncategories = [ \"api-bindings\", \"development-tools::ffi\" ]\nrust-version = \"1.75\"\n\n[badges]\ncircle-ci = { repository = \"mlua-rs/rlua\", branch = \"master\" }\n\n[badges.maintenance]\nstatus = \"deprecated\"\n\n[dependencies]\nmlua = { version = \"0.9.5\", features = [\"macros\"] }\n\n[features]\ndefault=[\"builtin-lua54\"]\nbuiltin-lua54=[\"mlua/lua54\", \"mlua/vendored\"]\nbuiltin-lua53=[\"mlua/lua53\", \"mlua/vendored\"]\nbuiltin-lua51=[\"mlua/lua51\", \"mlua/vendored\"]\n\nsystem-lua54=[\"mlua/lua54\"]\nsystem-lua53=[\"mlua/lua53\"]\nsystem-lua51=[\"mlua/lua51\"]\nsystem-luajit=[\"mlua/luajit\"]\n\n# Remove Lua's os lib\n#lua-no-oslib=[\"rlua-lua54-sys/lua-no-oslib\",\"rlua-lua53-sys/lua-no-oslib\",\"rlua-lua51-sys/lua-no-oslib\"]\n\n# Enabled functions from the math module that have been deprecated\n#lua-compat-mathlib = []\n\n[dev-dependencies]\nrustyline = \"13.0\"\nbstr = \"1.9.0\"\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 1.931640625,
          "content": "# FAQ\n\n### Why 'static lifetime is required when passing data to Lua as UserData?\n\n> Since we don't know when Lua will get around to garbage collecting our userdata, we can't make any assumptions about the lifetimes of any references in the userdata.\n\n* https://github.com/amethyst/rlua/issues/74#issuecomment-370152884\n* https://github.com/amethyst/rlua/issues/20#issuecomment-405751583\n\n### What is `scope` and why should I need it?\n\nNormally, Rust types passed to `Lua` must be `Send`, because `Lua` itself is `Send`, and must be `'static`, because there is no way to tell when Lua might garbage collect them.  There is, however, a limited way to lift both of these restrictions.  You can call `Lua::scope` to create userdata types that do not have to be `Send`, and callback types that do not have to be `Send` OR `'static`.  However, after `scope` returns any `UserData` passed to Lua are invalidated (access from Lua will error).\n\n### How can I store Lua values (like `Table`) outside of `Lua::context()`?\n\nThe Lua API in general doesn't give out references to Lua values - you can only interact with them indirectly throught the API.  In `rlua`, types like `rlua::Table` internally store an index into the current `Lua` stack, which is why they are only valid within the `context` callback.\n\nThere are some options for keeping longer references:\n\n#### Store it in the registry.\n\nThe Lua registry is a global `Table` available for use through the API.  Add references using `Context::create_registry_value()` which returns a key which can be later used with `Context::registry_value()`, or provide your own key with `Context::set_named_registry_value()`/`Context::named_registry_value()`.\n\n#### Store it with a `UserData` value\n\nA Lua value can be attached with a `UserData` value using `AnyUserData::set_user_value()`/`AnyUserData::get_user_value()`.  With Lua 5.4+ multiple values can be stored using `AnyUserData::set_i_user_value()`/`AnyUserData::get_i_user_value()`.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.1953125,
          "content": "Both rlua and Lua are distributed under the MIT license, which are reproduced\nbelow:\n\n== rlua license ==\n\nMIT License\n\nCopyright (c) 2017\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n== lua license ==\n\nCopyright © 1994–2017 Lua.org, PUC-Rio.\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.3505859375,
          "content": "# rlua -- High level bindings between Rust and Lua\n\n*rlua is now deprecated in favour of mlua: see below for migration information*\n\n`rlua` is now a thin transitional wrapper around\n[`mlua`](https://github.com/mlua-rs/mlua); it is recommended to use mlua\ndirectly for new projects and to migrate to it when convenient.  `mlua` was a\nfork of `rlua` which has recently seen more development activity and new\nfeatures.\n\n## Migration\n\n`rlua` 0.20 includes some utilities to help transition to `mlua`, but is otherwise\njust re-exporting `mlua` directly.\n\nThe main changes are:\n\n* In `mlua`, `Lua::context()` is no longer necessary.  The methods previously on\n  `Context` can now be called directly on the `Lua` object.  `rlua` 0.20 includes\n  an `RluaCompat` extension trait which adds a `context()` method which can be used\n  to avoid having to update code all at once.\n\n* The `ToLua` trait has been renamed to `IntoLua`, and its conversion method `to_lua`\n  is now `into_lua`.  `rlua` 0.20 includes `ToLua` as an alias for `IntoLua` and an\n  extension `ToLuaCompat` which adds a `to_lua` method as a temporary convenience.\n\nA few other changes which should be less disruptive:\n\n* `mlua` has different defaults and options for blocking loading C libraries or\n  compiled modules from Lua code or catching Rust panics.  Check the `Lua::new_with`\n  and unsafe variants for the new options.\n"
        },
        {
          "name": "RELEASE.md",
          "type": "blob",
          "size": 0.62890625,
          "content": "# rlua release checklist\n\n* Basic README.md check\n* Update CHANGELOG.md with important changes since last release\n* For a maintenance release:\n  * Check if there are any bugfixes on master which should be included\n* Update version number in Cargo.toml\n* Check other fields in Cargo.toml are sensible\n* Check that CI is passing\n* Tag the commit for the release\n* Run `cargo publish --dry-run` -sys crates if updated.\n* Run `cargo publish --dry-run` on main crate.\n* Run `cargo publish` on -sys crates if updated.\n* Run `cargo publish`\n* Check that the version from crates.io looks good\n* Update version number on branch to (next version)-alpha.\n"
        },
        {
          "name": "build.rs",
          "type": "blob",
          "size": 1.296875,
          "content": "fn main() {\n    let mut lua_version_features = 0;\n    #[cfg(feature = \"builtin-lua54\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua54\");\n        lua_version_features += 1;\n    }\n\n    #[cfg(feature = \"builtin-lua53\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua53\");\n        lua_version_features += 1;\n    }\n\n    #[cfg(feature = \"builtin-lua51\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua51\");\n        lua_version_features += 1;\n    }\n\n    #[cfg(feature = \"system-lua54\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua54\");\n        lua_version_features += 1;\n    }\n\n    #[cfg(feature = \"system-lua53\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua53\");\n        lua_version_features += 1;\n    }\n\n    #[cfg(feature = \"system-lua51\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua51\");\n        lua_version_features += 1;\n    }\n\n    #[cfg(feature = \"system-luajit\")]\n    {\n        println!(\"cargo:rustc-cfg=rlua_lua51\");\n        println!(\"cargo:rustc-cfg=rlua_luajit\");\n        lua_version_features += 1;\n    }\n\n    if lua_version_features < 1 {\n        panic!(\"No Lua version specified.  Please enable one of the features. use --no-default-features to disable default lua feature.\");\n    } else if lua_version_features > 1 {\n        panic!(\"Cannot enable more than one Lua interpreter feature.\");\n    }\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}