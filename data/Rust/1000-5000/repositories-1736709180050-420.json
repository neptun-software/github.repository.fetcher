{
  "metadata": {
    "timestamp": 1736709180050,
    "page": 420,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Keats/validator",
      "stars": 2114,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.0751953125,
          "content": "[*.rs]\nend_of_line = lf\ncharset = utf-8\nindent_style = space\nindent_size = 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0458984375,
          "content": "/*.iml\n/.idea\ntarget/\nCargo.lock\ntesting-bugs/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.1650390625,
          "content": "## Changelog\n\n## Unreleased\n- Implement `AsRegex` for `std::sync::LazyLock<Regex>`\n- Bug fix for nested issue with custom only running nested if outer passes\n\n## 0.19.0 (2024/11/03)\n\n- Swap to using proc-macro-error-2 instead of proc-macro-error for Syn\n- Bumped MSRV to 1.81 because of error naming changes.\n- Add more ValidateRegex impl\n\n\n## 0.18.1 (2024/04/11)\n\n- Fix multiple custom validation\n- Fix nested error handling\n\n\n## 0.18.0 (2024/04/05)\n\n- Fix regressions from the derive rewrite, some things are back to 0.16 (eg custom functions)\n- Remove require_nested, use required and nested validators instead\n- Always require `nested` on the field for nested validation\n\n\n## 0.17.0 (2024/03/04)\n\n- Derive macro has been entirely rewritten\n- Validation is now done through traits that you can implement\n- Remove phone validator\n- Remove automatic use of serde rename for fields name (temporary)\n\n## 0.16.0 (2022/06/27)\n\n- Allow passing code/message to `required`\n- Add `does_not_contain` validator\n- Check email length before validating it\n\n## 0.15.0 (2022/05/03)\n\n- Allow passing args to schema validator\n- Implement HasLen for map/set types\n- Remove `validator_types` from validator crate\n- Add ValidationErrors::errors_mut\n- Ignore unsupported fields rather than erroring\n\n## 0.14.0 (2021/06/29)\n\n- Allow passing arguments to custom functions\n- Better `Display` implementation\n- Better parsing of schema validation function in derive\n\n## 0.13.0 (2021/03/22)\n\n- Allow multiple schema-level validations\n\n## 0.12.0 (2020/11/26)\n\n- Allow `length` and `range` validators to take a reference to a variable\n- Make validator work with `Option<Vec<_>>`\n- Support reference for length types\n- Fix `phone`, `unic` and `card` feature to actually work\n\n## 0.11.0 (2020/09/09)\n\n- Add a `derive` feature so you don't need to add `validator_derive` to your `Cargo.toml`\n\n## 0.10.1 (2020/06/09)\n\n- Add a blanket Validate implementation for references\n- Add `Required` and `RequiredNested` validators\n\n## 0.10.0 (2019/10/18)\n\n- Add `non_control_characters` validation\n\n## 0.9.0 (2019/05/xx)\n\n- `ValidationErrors::errors` and `ValidationErrors::field_errors` now use `&self` instead of `self`\n- Move to edition 2018\n\n## 0.8.0 (2018/09/19)\n\n- Change error type to allow use with nested validation\n\n## 0.7.1 (2018/07/27)\n\n- Make validators work on `Cow`\n\n## 0.7.0 (2018/05/29)\n\n- Feature gate the card validator\n\n## 0.6.2 (2017/11/08)\n\n- Fix credit card validation being incorrect in enum\n\n## 0.6.1 (2017/11/08)\n\n- Add international phone number and credit card validation\n\n## 0.6.0 (2017/08/12)\n\n- Re-design `ValidationError` and `Validate` trait\n\n## 0.11.0 (2020/09/09)\n\n- Errors in the proc macro attributes will now point to the exact place the error is\n\n## 0.10.1 (2020/06/09)\n\n- Handle `Required` and `RequiredNested` validators\n\n## 0.10.0 (2019/10/18)\n\n- Update syn & quote\n- Move to edition 2018\n\n## 0.9.0 (2019/05/xx)\n\n- Use literals in macros now that it's stable -> bumping minimum Rust version to 1.30\n\n## 0.8.0 (2018/09/19)\n\n- Allow nested validation\n\n## 0.7.2 (2018/07/27)\n\n- Make validators work on `Cow`\n\n## 0.7.1 (2018/06/28)\n\n- Update dependencies\n\n## 0.7.0 (2018/05/29)\n\n- Feature gate the card validator\n\n## 0.6.5 (2018/04/14)\n\n- Fix path for regex starting with `::`\n- Update syn and quote\n\n## 0.6.4 (2018/03/20)\n\n- Support `Option<Option<T>>` types\n\n## 0.6.3 (2018/03/19)\n\n- Fix path for custom validators starting with `::`\n\n## 0.6.2 (2018/03/17)\n\n- Update syn and quote\n\n## 0.6.1 (2017/11/08)\n\n- Add international phone number and credit card derive\n\n## 0.6.0 (2017/08/12)\n\n- Change generated code to make the new design of errors work\n\n## 0.5.0 (2017/05/22) > validator_derive only\n\n- Fix range validator not working on Option\n- Update to serde 1.0\n\n## 0.4.1 (2017/02/14) > validator_derive only\n\n- Fix potential conflicts with other attributes\n\n## 0.4.0 (2017/01/30)\n\n- Validators now work on `Option` field and struct/fields with lifetimes\n\n## 0.3.0 (2017/01/17)\n\n- Add `contains` and `regex` validator\n- BREAKING: change `Errors` type to be a newtype in order to extend it\n\n## 0.2.0 (2017/01/17)\n\n- Remove need for `attr_literals` feature\n- Fix error when not having validation on each field\n- Add struct level validation\n- Add `must_match` validator\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.1357421875,
          "content": "[workspace]\nresolver = \"2\"\nmembers = [\"validator\", \"validator_derive\", \"validator_derive_tests\"]\n\n[workspace.package]\nrust-version = \"1.81\""
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Vincent Prouillet\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.013671875,
          "content": "# validator\n\n<div align=\"center\">\n  <!-- Github Actions -->\n  <img src=\"https://github.com/Keats/validator/workflows/ci/badge.svg\" alt=\"actions status\" />\n  <!-- Version -->\n  <a href=\"https://crates.io/crates/validator\">\n    <img src=\"https://img.shields.io/crates/v/validator.svg?style=flat-square\"\n    alt=\"Crates.io version\" />\n  </a>\n  <!-- Docs -->\n  <a href=\"https://docs.rs/validator\">\n    <img src=\"https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square\"\n      alt=\"docs.rs docs\" />\n  </a>\n  <!-- Downloads -->\n  <a href=\"https://crates.io/crates/validator\">\n    <img src=\"https://img.shields.io/crates/d/validator.svg?style=flat-square\"\n      alt=\"Download\" />\n  </a>\n</div>\n\n\nMacros 1.1 custom derive to simplify struct validation inspired by [marshmallow](http://marshmallow.readthedocs.io/en/latest/) and\n[Django validators](https://docs.djangoproject.com/en/1.10/ref/validators/).\n\nInstallation:\n\n```toml\n[dependencies]\nvalidator = { version = \"0.19\", features = [\"derive\"] }\n```\n\nA short example:\n\n```rust\nuse serde::Deserialize;\n\n// A trait that the Validate derive will impl\nuse validator::{Validate, ValidationError};\n\n#[derive(Debug, Validate, Deserialize)]\nstruct SignupData {\n    #[validate(email)]\n    mail: String,\n    #[validate(url)]\n    site: String,\n    #[validate(length(min = 1), custom(function = \"validate_unique_username\"))]\n    #[serde(rename = \"firstName\")]\n    first_name: String,\n    #[validate(range(min = 18, max = 20))]\n    age: u32,\n    #[validate(range(exclusive_min = 0.0, max = 100.0))]\n    height: f32,\n}\n\nfn validate_unique_username(username: &str) -> Result<(), ValidationError> {\n    if username == \"xXxShad0wxXx\" {\n        // the value of the username will automatically be added later\n        return Err(ValidationError::new(\"terrible_username\"));\n    }\n\n    Ok(())\n}\n\nmatch signup_data.validate() {\n  Ok(_) => (),\n  Err(e) => return e;\n};\n```\n\nA validation on an `Option<_>` field will be executed on the contained type if the option is `Some`. The `validate()`\n method returns a `Result<(), ValidationErrors>`. In the case of an invalid result, the `ValidationErrors` instance includes\na map of errors keyed against the struct's field names. Errors may be represented in three ways, as described by the \n`ValidationErrorsKind` enum:\n\n```rust\n#[derive(Debug, Serialize, Clone, PartialEq)]\n#[serde(untagged)]\npub enum ValidationErrorsKind {\n    Struct(Box<ValidationErrors>),\n    List(BTreeMap<usize, Box<ValidationErrors>>),\n    Field(Vec<ValidationError>),\n}\n```\n\nIn the simple example above, any errors would be of the `Field(Vec<ValidationError>)` type, where a single\n`ValidationError` has the following structure:\n\n```rust\n#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]\npub struct ValidationError {\n  pub code: Cow<'static, str>,\n  pub message: Option<Cow<'static, str>>,\n  pub params: HashMap<Cow<'static, str>, Value>,\n}\n```\nThe value of the field will automatically be added to the params with a key of `value`.\n\nThe other two `ValidationErrorsKind` types represent errors discovered in nested (vectors of) structs, as described in\nthis example:\n\n ```rust\nuse serde::Deserialize;\n// A trait that the Validate derive will impl\nuse validator::Validate;\n\n#[derive(Debug, Validate, Deserialize)]\nstruct SignupData {\n    #[validate(nested)]\n    contact_details: ContactDetails,\n    #[validate(nested)]\n    preferences: Vec<Preference>,\n    #[validate(required)]\n    allow_cookies: Option<bool>,\n}\n\n#[derive(Debug, Validate, Deserialize)]\nstruct ContactDetails {\n    #[validate(email)]\n    mail: String,\n}\n\n#[derive(Debug, Validate, Deserialize)]\nstruct Preference {\n    #[validate(length(min = 4))]\n    name: String,\n    value: bool,\n}\n\nmatch signup_data.validate() {\n  Ok(_) => (),\n  Err(e) => return e;\n};\n ```\n\nHere, the `ContactDetails` and `Preference` structs are nested within the parent `SignupData` struct. Because\nthese child types also derive `Validate`, the fields where they appear can be tagged for inclusion in the parent\nstruct's validation method.\n\nAny errors found in a single nested struct (the `contact_details` field in this example) would be returned as a\n`Struct(Box<ValidationErrors>)` type in the parent's `ValidationErrors` result.\n\nAny errors found in a vector of nested structs (the `preferences` field in this example) would be returned as a\n`List(BTreeMap<usize, Box<ValidationErrors>>)` type in the parent's `ValidationErrors` result, where the map is keyed on\nthe index of invalid vector entries.\n\n\n## Usage\nYou will need to import the `Validate` trait.\n\nThe `validator` crate can also be used without the custom derive as it exposes all the\nvalidation functions and types.\n\n## Validators\nThe crate comes with some built-in validators and you can have several validators for a given field.\n\n### email\nTests whether the String is a valid email according to the HTML5 regex, which means it will mark\nsome esoteric emails as invalid that won't be valid in a `email` input as well.\nThis validator doesn't take any arguments: `#[validate(email)]`.\n\n### url\nTests whether the String is a valid URL.\nThis validator doesn't take any arguments: `#[validate(url)]`;\n\n### length\nTests whether a String or a Vec match the length requirement given. `length` has 3 integer arguments:\n\n- min\n- max\n- equal\n\nUsing `equal` excludes the `min` or `max` and will result in a compilation error if they are found.\n\nAt least one argument is required with a maximum of 2 (having `min` and `max` at the same time).\n\nExamples:\n\n```rust\nconst MIN_CONST: u64 = 1;\nconst MAX_CONST: u64 = 10;\n\n#[validate(length(min = 1, max = 10))]\n#[validate(length(min = 1))]\n#[validate(length(max = 10))]\n#[validate(length(equal = 10))]\n#[validate(length(min = \"MIN_CONST\", max = \"MAX_CONST\"))]\n```\n\n### range\nTests whether a number is in the given range. `range` takes 1 or 2 arguments, and they can be normal (`min` and `max`) or exclusive (`exclusive_min`, `exclusive_max`, unreachable limits).\nThese can be a number or a value path.\n\nExamples:\n\n```rust\nconst MAX_CONSTANT: i32 = 10;\nconst MIN_CONSTANT: i32 = 0;\n\n#[validate(range(min = 1))]\n#[validate(range(min = \"MIN_CONSTANT\"))]\n#[validate(range(min = 1, max = 10))]\n#[validate(range(min = 1.1, max = 10.8))]\n#[validate(range(max = 10.8))]\n#[validate(range(min = \"MAX_CONSTANT\"))]\n#[validate(range(min = \"crate::MAX_CONSTANT\"))]\n#[validate(range(exclusive_min = 0.0, max = 100.0))]\n#[validate(range(exclusive_max = 10))]\n// If you get an error saying the literal doesn't fit in i32, specify a number type in the literal directly\n#[validate(range(max = 1000000000u64))]\n\n```\n\n### must_match\nTests whether the 2 fields are equal. `must_match` takes 1 string argument. It will error if the field\nmentioned is missing or has a different type than the field the attribute is on.\n\nExamples:\n\n```rust\n#[validate(must_match(other = \"password2\"))]\n```\n\n### contains\nTests whether the string contains the substring given or if a key is present in a hashmap. `contains` takes\n1 string argument.\n\nExamples:\n\n```rust\n#[validate(contains = \"gmail\")]\n#[validate(contains(pattern = \"gmail\"))]\n```\n\n### does_not_contain\nPretty much the opposite of contains, provided just for ease-of-use. Tests whether a container does not contain\nthe substring given if it's a string or if a key is NOT present in a hashmap. `does_not_contain` takes 1 string argument.\n\nExamples:\n\n```rust\n#[validate(does_not_contain = \"gmail\")]\n#[validate(does_not_contain(pattern = \"gmail\"))]\n```\n\n### regex\nTests whether the string matches the regex given. `regex` takes\n1 string argument: the path to a static Regex instance.\n\nExamples:\n\n```rust\nuse once_cell::sync::Lazy;\n\nstatic RE_TWO_CHARS: Lazy<Regex> = Lazy::new(|| {\n    Regex::new(r\"[a-z]{2}$\").unwrap()\n});\n\n#[validate(regex(path = *RE_TWO_CHARS)]\n```\n\n### credit\\_card\nTest whether the string is a valid credit card number.\n\nExamples:\n\n```rust\n#[validate(credit_card)]\n```\n\n### custom\nCalls one of your functions to perform a custom validation. The field reference (or value if it can be copied cheaply like numbers) will be given as a parameter to the function,\nwhich should return a `Result<(), ValidationError>`.\n\nExamples:\n\n```rust\n#[validate(custom(function = \"validate_something\"))]\n#[validate(custom(function = \"::utils::validate_something\"))]\n```\n\nYou can also do your own validation by parsing the arguments from the validation function by setting `context` for struct.　Applying custom validation using the `use_context` argument is accomplished by setting the `use_context` parameter. Defining the `context` parameter will implement the `ValidateArgs` trait with the corresponding function types like this:\n\n```rust\nuse validator::{Validate, ValidateArgs, ValidationError};\n\nfn validate(value: &str, context: &TestContext) -> Result<(), ValidationError> {\n    [...]\n}\n\nstruct TestContext(i64, i64);\n\n#[derive(Debug, Validate)]\n#[validate(context = TestContext)]\nstruct TestStruct {\n    #[validate(custom(function = \"validate\", use_context))]\n    value: String,\n}\n\nlet test_struct: TestStruct = [...];\nlet test_context: TestContext = [...];\ntest_struct.validate_with_args(&test_context).is_ok();\n```\n\nIt is also possible to pass references by using the lifetime `'v_a` note that this lifetime should only be used for the function parameters like this:\n\n```rust\nfn validate_value(_: &str, arg: &mut Database) -> Result<(), ValidationError> {\n    [...]\n}\n\n#[derive(Debug, Validate)] //   vvvv This is the lifetime for references\n#[validate(context = \"Database<'v_a>\", mutable)]\nstruct TestStruct {\n    #[validate(custom(function = \"validate_value\", use_context))]\n    value: String,\n}\n\nlet mut database: Database = [...];\nlet test_struct: TestStruct = [...];\ntest_struct.validate_with_args(&mut database).is_ok();\n```\n\nCustom validation with arguments doesn't work on nested validation. See [`validator_derive_tests/tests/custom.rs`](https://github.com/Keats/validator/blob/master/validator_derive_tests/tests/custom.rs) and [`validator_derive_tests/tests/custom_args.rs`](https://github.com/Keats/validator/blob/master/validator_derive_tests/tests/custom_args.rs) for more examples.\n\n### nested\nPerforms validation on a field with a type that also implements the Validate trait (or a vector of such types).\n\nExamples:\n\n```rust\n#[validate(nested)]\n```\n\n### non_control_character\nTests whether the String has any utf-8 control characters, fails validation if it does.\nTo use this validator, you must enable the `unic` feature for the `validator` crate.\nThis validator doesn't take any arguments: `#[validate(non_control_character)]`;\n\n### required\nTests whether the `Option<T>` field is `Some`;\n\n## Struct level validation\nOften, some error validation can only be applied when looking at the full struct, here's how it works here:\n\n```rust\n#[derive(Debug, Validate, Deserialize)]\n#[validate(schema(function = \"validate_category\", skip_on_field_errors = false))]\nstruct CategoryData {\n    category: String,\n    name: String,\n}\n```\n\nThe function mentioned should return a `Result<(), ValidationError>` and will be called after validation is done for all fields.\n\nThe `skip_on_field_errors` defaults to `true` if not present and will ensure that the function is not called\nif an error happened while validating the struct fields.\n\nAny error on the struct level validation will appear in the key `__all__` of the hashmap of errors.\n\n## Message and code\n\nEach validator can take 2 optional arguments in addition to their own arguments:\n\n- `message`: a message to go with the error, for example if you want to do i18n\n- `code`: each validator has a default error code (for example the `regex` validator code is `regex`) but it can be overridden\nif necessary, mainly needed for the `custom` validator\n\nNote that these arguments can't be applied to nested validation calls with `#[validate]`.\n\nFor example, the following attributes all work:\n\n```rust\n// code attribute\n#[validate(email(code = \"code_str\"))]\n#[validate(credit_card(code = \"code_str\"))]\n#[validate(length(min = 5, max = 10, code = \"code_str\"))]\n\n#[validate(regex(path = *static_regex, code = \"code_str\"))]\n#[validate(custom(function = \"custom_fn\", code = \"code_str\"))]\n#[validate(contains(pattern = \"pattern_str\", code = \"code_str\"))]\n#[validate(does_not_contain(pattern = \"pattern_str\", code = \"code_str\"))]\n#[validate(must_match(other = \"match_value\", code = \"code_str\"))]\n\n// message attribute\n#[validate(url(message = \"message_str\"))]\n#[validate(length(min = 5, max = 10, message = \"message_str\"))]\n\n#[validate(regex(path = *static_regex, message = \"message_str\"))]\n#[validate(custom(function = \"custom_fn\", message = \"message_str\"))]\n#[validate(contains(pattern = \"pattern_str\", message = \"message_str\"))]\n#[validate(does_not_contain(pattern = \"pattern_str\", message = \"message_str\"))]\n#[validate(must_match(other = \"match_value\", message = \"message_str\"))]\n\n// both attributes\n#[validate(url(message = \"message\", code = \"code_str\"))]\n#[validate(email(code = \"code_str\", message = \"message\"))]\n#[validate(custom(function = \"custom_fn\", code = \"code_str\", message = \"message_str\"))]\n\n```\n\n## Features\n`derive` - This allows for the use of the derive macro.\n`derive_nightly_features` - This imports both derive as well as proc-macro-error2 nightly features. This allows proc-macro-error2 to emit extra nightly warnings.\n"
        },
        {
          "name": "rustfmt.toml",
          "type": "blob",
          "size": 0.0283203125,
          "content": "use_small_heuristics = \"Max\"\n"
        },
        {
          "name": "validator",
          "type": "tree",
          "content": null
        },
        {
          "name": "validator_derive",
          "type": "tree",
          "content": null
        },
        {
          "name": "validator_derive_tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}