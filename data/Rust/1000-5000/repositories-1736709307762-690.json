{
  "metadata": {
    "timestamp": 1736709307762,
    "page": 690,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "slawlor/ractor",
      "stars": 1582,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".cargo.config",
          "type": "blob",
          "size": 0.0400390625,
          "content": "[alias]\nxtask = \"run --package xtask --\"\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.4775390625,
          "content": "# Generated by Cargo\n# will have compiled files and executables\n/target/\n\n# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries\n# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html\nCargo.lock\n\n# These are backup files generated by rustfmt\n**/*.rs.bk\n\n# Remove all target compilation folders from all sub-folders as well\n**/target/\n\n# Remove code-coverage generated files from git\ndebug/\ncoverage/\n**/*.profraw\n\n.github/"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.48046875,
          "content": "# Generated by Cargo\n# will have compiled files and executables\n/target/\n\n# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries\n# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html\nCargo.lock\n\n# These are backup files generated by rustfmt\n**/*.rs.bk\n\n# Remove all target compilation folders from all sub-folders as well\n**/target/\n\n# Remove code-coverage generated files from git\ndebug/\ncoverage/\n**/*.profraw\n**/.DS_Store"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE_COVERAGE.md",
          "type": "blob",
          "size": 0.2744140625,
          "content": "# Current code coverage\n\n## Current code coverage\n\n[![codecov](https://codecov.io/gh/slawlor/ractor/branch/main/graph/badge.svg?token=61AGYYPWBA)](https://codecov.io/gh/slawlor/ractor)\n\n<img src=\"https://codecov.io/gh/facebook/akd/branch/main/graphs/sunburst.svg?token=61AGYYPWBA\">"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.8173828125,
          "content": "# Contributing to this library\n\nWe want to make contributing to this project as easy and transparent as\npossible.\n\n## Be respectful\n\nDuh.\n\n## Pull Requests\n\nWe actively welcome your pull requests!\n\n1. Fork the repo and create your branch from `main`.\n2. If you've added code that should be tested, add tests.\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n\n## Issues\n\nWe use GitHub issues to track issues.\n\nFor reported bugs, please ensure your description is clear and has sufficient instructions to be able to reproduce the issue.\n\nFor feature requests, please try to be detailed in what you'd like to see so we can address it properly!\n\n## License\n\nBy contributing to `ractor`, you agree that your contributions will be\nlicensed under the LICENSE file in the root directory of this source tree.\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.177734375,
          "content": "[workspace]\nmembers = [\n    \"ractor\",\n    \"ractor_cluster\",\n    \"ractor_cluster_derive\",\n    \"ractor_playground\",\n    \"ractor_cluster_integration_tests\",\n    \"xtask\"\n]\nresolver = \"2\""
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2023 Sean Lawlor\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.890625,
          "content": "# ractor\n\n<p align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/slawlor/ractor/main/docs/ractor_logo.svg\" width=\"50%\" />\n</p>\n\n*Pronounced rak-ter*\n\nA pure-Rust actor framework. Inspired from [Erlang's `gen_server`](https://www.erlang.org/doc/man/gen_server.html), with the speed + performance of Rust!\n\n* [<img alt=\"github\" src=\"https://img.shields.io/badge/github-slawlor/ractor-8da0cb?style=for-the-badge&labelColor=555555&logo=github\" height=\"20\">](https://github.com/slawlor/ractor)\n* [<img alt=\"crates.io\" src=\"https://img.shields.io/crates/v/ractor.svg?style=for-the-badge&color=fc8d62&logo=rust\" height=\"20\">](https://crates.io/crates/ractor)\n* [<img alt=\"docs.rs\" src=\"https://img.shields.io/badge/docs.rs-ractor-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs\" height=\"20\">](https://docs.rs/ractor)\n* [<img alt=\"docs.rs\" src=\"https://img.shields.io/badge/docs.rs-ractor_cluster-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs\" height=\"20\">](https://docs.rs/ractor_cluster)\n* [![CI/main](https://github.com/slawlor/ractor/actions/workflows/ci.yaml/badge.svg?branch=main)](https://github.com/slawlor/ractor/actions/workflows/ci.yaml)\n* [![codecov](https://codecov.io/gh/slawlor/ractor/branch/main/graph/badge.svg?token=61AGYYPWBA)](https://codecov.io/gh/slawlor/ractor)\n* `ractor`: ![ractor Downloads](https://img.shields.io/crates/d/ractor.svg)\n* `ractor_cluster`: ![ractor_cluster Downloads](https://img.shields.io/crates/d/ractor_cluster.svg)\n\n## Updates\n\n* **Website**: Ractor has a companion website for more detailed getting-started guides along with some best practices and is updated regularly. Api docs will still be available at [docs.rs](https://docs.rs/ractor) however this will be a supplimentary site for `ractor`. Try it out! <https://slawlor.github.io/ractor/>\n* **RustConf'24** Ractor was a key part of a presentation at [RustConf'24](https://rustconf.com/schedule/#wednesday). It's used as the basis for Meta's Rust [thrift](https://github.com/facebook/fbthrift) overload protection scheme. The presentation's slides are [available here](https://slawlor.github.io/ractor/assets/rustconf2024_presentation.pdf).\n\n## About\n\n`ractor` tries to solve the problem of building and maintaining an Erlang-like actor framework in Rust. It gives\na set of generic primitives and helps automate the supervision tree and management of our actors along with the traditional actor message processing logic. It was originally designed to use the `tokio` runtime, however does now support the `async-std` runtime.\n\n`ractor` is a modern actor framework written in 100% Rust.\n\nAdditionally `ractor` has a companion library, `ractor_cluster` which is needed for `ractor` to be deployed in a distributed (cluster-like) scenario. `ractor_cluster` shouldn't be considered production ready, but it is relatively stable and we'd love your feedback!\n\n### Why ractor?\n\nThere are other actor frameworks written in Rust ([Actix](https://github.com/actix/actix), [riker](https://github.com/riker-rs/riker), or [just actors in Tokio](https://ryhl.io/blog/actors-with-tokio/)) plus a bunch of others like this list compiled on [this Reddit post](https://www.reddit.com/r/rust/comments/n2cmvd/there_are_a_lot_of_actor_framework_projects_on/).\n\nRactor tries to be different by modelling more on a pure Erlang `gen_server`. This means that each actor can also simply be a supervisor to other actors with no additional cost (simply link them together!). Additionally we're aiming to maintain close logic with Erlang's patterns, as they work quite well and are well utilized in the industry.\n\nAdditionally we wrote `ractor` without building on some kind of \"Runtime\" or \"System\" which needs to be spawned. Actors can be run independently, in conjunction with other basic `tokio` runtimes with little additional overhead.\n\nWe currently have full support for:\n\n1. Single-threaded message processing\n2. Actor supervision tree\n3. Remote procedure calls to actors in the `rpc` module\n4. Timers in the `time` module\n5. Named actor registry (`registry` module) from [Erlang's `Registered processes`](https://www.erlang.org/doc/reference_manual/processes.html)\n6. Process groups (`ractor::pg` module) from [Erlang's `pg` module](https://www.erlang.org/doc/man/pg.html)\n\nOn our roadmap is to add more of the Erlang functionality including potentially a distributed actor cluster.\n\n### Performance\n\nActors in `ractor` are generally quite lightweight and there are benchmarks which you are welcome to run on your own host system with:\n\n```bash\ncargo bench -p ractor\n```\n\nFurther performance improvements are being tracked in [#262](https://github.com/slawlor/ractor/issues/262)\n\n## Installation\n\nInstall `ractor` by adding the following to your Cargo.toml dependencies.\n\n```toml\n[dependencies]\nractor = \"0.14\"\n```\n\nThe minimum supported Rust version (MSRV) of `ractor` is `1.64`. However to utilize the native `async fn` support in traits and not rely on the `async-trait` crate's desugaring functionliaty, you need to be on Rust version `>= 1.75`. The stabilization of `async fn` in traits [was recently added](https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html).\n\n## Features\n\n`ractor` exposes the following features:\n\n1. `cluster`, which exposes various functionality required for `ractor_cluster` to set up and manage a cluster of actors over a network link. This is work-in-progress and is being tracked in [#16](https://github.com/slawlor/ractor/issues/16).\n2. `async-std`, which enables usage of `async-std`'s asynchronous runtime instead of the `tokio` runtime. **However** `tokio` with the `sync` feature remains a dependency because we utilize the messaging synchronization primatives from `tokio` regardless of runtime as they are not specific to the `tokio` runtime. This work is tracked in [#173](https://github.com/slawlor/ractor/pull/173). You can remove default features to \"minimize\" the tokio dependencies to just the synchronization primatives.\n3. `monitors`, Adds support for an erlang-style monitoring api which is an alternative to direct linkage. Akin to [Process Monitors](https://www.erlang.org/doc/system/ref_man_processes.html#monitors)\n4. `message_span_propogation`, Propagates the span through the message between actors to keep tracing context.\n\n## Working with Actors\n\nActors in `ractor` are very lightweight and can be treated as thread-safe. Each actor will only call one of its handler functions at a time, and they will\nnever be executed in parallel. Following the actor model leads to microservices with well-defined state and processing logic.\n\nAn example `ping-pong` actor might be the following\n\n```rust\nuse ractor::{async_trait, cast, Actor, ActorProcessingErr, ActorRef};\n\n/// [PingPong] is a basic actor that will print\n/// ping..pong.. repeatedly until some exit\n/// condition is met (a counter hits 10). Then\n/// it will exit\npub struct PingPong;\n\n/// This is the types of message [PingPong] supports\n#[derive(Debug, Clone)]\npub enum Message {\n    Ping,\n    Pong,\n}\n\nimpl Message {\n    // retrieve the next message in the sequence\n    fn next(&self) -> Self {\n        match self {\n            Self::Ping => Self::Pong,\n            Self::Pong => Self::Ping,\n        }\n    }\n    // print out this message\n    fn print(&self) {\n        match self {\n            Self::Ping => print!(\"ping..\"),\n            Self::Pong => print!(\"pong..\"),\n        }\n    }\n}\n\n#[async_trait]\n// the implementation of our actor's \"logic\"\nimpl Actor for PingPong {\n    // An actor has a message type\n    type Msg = Message;\n    // and (optionally) internal state\n    type State = u8;\n    // Startup initialization args\n    type Arguments = ();\n\n    // Initially we need to create our state, and potentially\n    // start some internal processing (by posting a message for\n    // example)\n    async fn pre_start(\n        &self,\n        myself: ActorRef<Self::Msg>,\n        _: (),\n    ) -> Result<Self::State, ActorProcessingErr> {\n        // startup the event processing\n        cast!(myself, Message::Ping)?;\n        // create the initial state\n        Ok(0u8)\n    }\n\n    // This is our main message handler\n    async fn handle(\n        &self,\n        myself: ActorRef<Self::Msg>,\n        message: Self::Msg,\n        state: &mut Self::State,\n    ) -> Result<(), ActorProcessingErr> {\n        if *state < 10u8 {\n            message.print();\n            cast!(myself, message.next())?;\n            *state += 1;\n        } else {\n            println!();\n            myself.stop(None);\n            // don't send another message, rather stop the agent after 10 iterations\n        }\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let (_actor, handle) = Actor::spawn(None, PingPong, ())\n        .await\n        .expect(\"Failed to start ping-pong actor\");\n    handle\n        .await\n        .expect(\"Ping-pong actor failed to exit properly\");\n}\n```\n\nwhich will output\n\n```bash\n$ cargo run\nping..pong..ping..pong..ping..pong..ping..pong..ping..pong..\n$\n```\n\n## Messaging actors\n\nThe means of communication between actors is that they pass messages to each other. A developer can define any message type which is `Send + 'static` and it\nwill be supported by `ractor`. There are 4 concurrent message types, which are listened to in priority. They are\n\n1. Signals: Signals are the highest-priority of all and will interrupt the actor wherever processing currently is (this includes terminating async work). There\nis only 1 signal today, which is `Signal::Kill`, and it immediately terminates all work. This includes message processing or supervision event processing.\n2. Stop: There is also the pre-defined stop signal. You can give a \"stop reason\" if you want, but it's optional. Stop is a graceful exit, meaning currently executing async work will complete, and on the next message processing iteration Stop will take priority over future supervision events or regular messages. It will **not** terminate currently executing work, regardless of the provided reason.\n3. SupervisionEvent: Supervision events are messages from child actors to their supervisors in the event of their startup, death, and/or unhandled panic. Supervision events are how an actor's supervisor(parent) or peer monitors are notified of events of their children/peers and can handle lifetime events for them. If you set `panic = 'abort'` in your `Cargo.toml`, panics **will** start cause program termination and not be caught in the supervision flow.\n4. Messages: Regular, user-defined, messages are the last channel of communication to actors. They are the lowest priority of the 4 message types and denote general actor work. The first\n3 messages types (signals, stop, supervision) are generally quiet unless it's a lifecycle event for the actor, but this channel is the \"work\" channel doing what your actor wants to do!\n\n## Ractor in distributed clusters\n\nRactor actors can also be used to build a distributed pool of actors, similar to [Erlang's EPMD](https://www.erlang.org/doc/man/epmd.html) which manages inter-node connections + node naming. In our implementation, we have [`ractor_cluster`](https://crates.io/crates/ractor_cluster) in order to facilitate distributed `ractor` actors.\n\n`ractor_cluster` has a single main type in it, namely the `NodeServer` which represents a host of a `node()` process. It additionally has some macros and a procedural macros to facilitate developer efficiency when building distributed actors. The `NodeServer` is responsible for\n\n1. Managing all incoming and outgoing `NodeSession` actors which represent a remote node connected to this host.\n2. Managing the `TcpListener` which hosts the server socket to accept incoming session requests.\n\nThe bulk of the logic for node interconnections however is held in the `NodeSession` which manages\n\n1. The underlying TCP connection managing reading and writing to the stream.\n2. The authentication between this node and the connection to the peer\n3. Managing actor lifecycle for actors spawned on the remote system.\n4. Transmitting all inter-actor messages between nodes.\n5. Managing PG group synchronization\n\netc..\n\nThe `NodeSession` makes local actors available on a remote system by spawning `RemoteActor`s which are essentially untyped actors that only handle serialized messages, leaving message deserialization up to the originating system. It also keeps track of pending RPC requests, to match request to response upon reply. There are special extension points in `ractor` which are added to specifically support `RemoteActor`s that aren't generally meant to be used outside of the standard\n\n```rust\nActor::spawn(Some(\"name\".to_string()), MyActor).await\n```\n\npattern.\n\n### Designing remote-supported actors\n\n**Note** not all actors are created equal. Actors need to support having their message types sent over the network link. This is done by overriding specific methods of the `ractor::Message` trait all messages need to support. Due to the lack of specialization support in Rust, if you choose to use `ractor_cluster` you'll need to derive the `ractor::Message` trait for **all** message types in your crate. However to support this, we have a few procedural macros to make this a more painless process\n\n#### Deriving the basic Message trait for in-process only actors\n\nMany actors are going to be local-only and have no need sending messages over the network link. This is the most basic scenario and in this case the default `ractor::Message` trait implementation is fine. You can derive it quickly with:\n\n```rust\nuse ractor_cluster::RactorMessage;\nuse ractor::RpcReplyPort;\n\n#[derive(RactorMessage)]\nenum MyBasicMessageType {\n    Cast1(String, u64),\n    Call1(u8, i64, RpcReplyPort<Vec<String>>),\n}\n```\n\nThis will implement the default ```ractor::Message``` trait for you without you having to write it out by hand.\n\n#### Deriving the network serializable message trait for remote actors\n\nIf you want your actor to *support* remoting, then you should use a different derive statement, namely:\n\n```rust\nuse ractor_cluster::RactorClusterMessage;\nuse ractor::RpcReplyPort;\n\n#[derive(RactorClusterMessage)]\nenum MyBasicMessageType {\n    Cast1(String, u64),\n    #[rpc]\n    Call1(u8, i64, RpcReplyPort<Vec<String>>),\n}\n```\n\nwhich adds a significant amount of underlying boilerplate (take a look yourself with `cargo expand`) for the implementation. But the short answer is, each enum variant needs to serialize to a byte array of arguments, a variant name, and if it's an RPC give a port that receives a byte array and de-serialize the reply back. Each of the types inside of either the arguments or reply type need to implement the ```ractor_cluster::BytesConvertable``` trait which just says this value can be written to a byte array and decoded from a byte array. If you're using `prost` for your message type definitions (protobuf), we have a macro to auto-implement this for your types.\n\n```rust\nractor_cluster::derive_serialization_for_prost_type! {MyProtobufType}\n```\n\nBesides that, just write your actor as you would. The actor itself will live where you define it and will be capable of receiving messages sent over the network link from other clusters!\n\n## Differences between an actor's \"state\" and `self`\n\nActors can (but don't need to!) have internal state. In order to facilitate this `ractor` gives implementors of the `Actor` trait the ability to define the state type for an actor. The actor's `pre_start` routine is what initializes and sets up this state. You can imagine doing things like\n\n1. Opening a network socket + storing the `TcpListener` in the state\n2. Setting up a database connection + authenticating to the DB\n3. Initializing basic state variables (counters, stats, whatever)\n\nBecause of this and the possibility that some of these operations are fallible, `pre_start` captures panic's in the method during the initialization and returns them to the caller of `Actor::spawn`.\n\nWhen designing `ractor`, we made the explicit decision to make a separate state type for an actor, rather than passing around a mutable `self` reference. The reason for this is that if we were to use a `&mut self` reference, creation + instantiation of the `Self` struct would be outside of the actor's specification (i.e. not in `pre_start`) and the safety it gives would be potentially lost, causing potential crashes in the caller when it maybe shouldn't.\n\nLastly is that we would need to change some of the ownership properties that `ractor` is currently based on to pass an owned `self` in each call, returning a `Self` reference which seems clunky in this context.\n\n**In the current realization** an actor's `self` is passed as a read-only reference which shouldn't ideally contain state information, but could contain configuration / startup information if you want. However there is also `Arguments` to each `Actor` which allows passing owned values to the state of an actor. In an ideal world, all actor structs would be empty with no stored values.\n\n## Contributors\n\nThe original author of `ractor` is Sean Lawlor (@slawlor). To learn more about contributing to `ractor` please see [CONTRIBUTING.md](https://github.com/slawlor/ractor/blob/main/CONTRIBUTING.md).\n\n## License\n\nThis project is licensed under [MIT](https://github.com/slawlor/ractor/blob/main/LICENSE).\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.404296875,
          "content": "codecov:\n  require_ci_to_pass: false\n\nignore:\n  # This is the code coverage tool.\n  - \"xtask\"\n  # Tests are not covered\n  - \"ractor_playground\"\n  # Tests are not covered\n  - \"ractor/examples\"\n  # Tests are not covered\n  - \"ractor/benches\"\n  # Tests are not covered\n  - \"ractor_cluster_integration_tests\"\n  # Protocol is all generated code and should be excluded from code coverage\n  - \"ractor_cluster/src/protocol\""
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 1.171875,
          "content": "\nservices:\n  node-a:\n    container_name: \"node-a\"\n    build:\n      context: .\n      dockerfile: ractor_cluster_integration_tests/Dockerfile\n      args:\n        - FEATURES=${FEATURES}\n    image: ractor_cluster_tests:latest\n    networks:\n      - test-net\n    entrypoint: ''\n    command: ractor_cluster_integration_tests test ${A_TEST}\n    environment:\n      RUST_LOG: debug\n  node-b:\n    depends_on: \n      - node-a\n    container_name: \"node-b\"\n    build:\n      context: .\n      dockerfile: ractor_cluster_integration_tests/Dockerfile\n      args:\n        - FEATURES=${FEATURES}\n    image: ractor_cluster_tests:latest\n    networks:\n      - test-net\n    entrypoint: ''\n    command: ractor_cluster_integration_tests test ${B_TEST}\n    environment:\n      RUST_LOG: debug\n\n  node-c:\n    depends_on: \n      - node-b\n    container_name: \"node-c\"\n    build:\n      context: .\n      dockerfile: ractor_cluster_integration_tests/Dockerfile\n      args:\n        - FEATURES=${FEATURES}\n    image: ractor_cluster_tests:latest\n    networks:\n      - test-net\n    entrypoint: ''\n    command: ractor_cluster_integration_tests test ${C_TEST}\n    environment:\n      RUST_LOG: debug\nnetworks:\n  test-net:\n    external: false"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "ractor",
          "type": "tree",
          "content": null
        },
        {
          "name": "ractor_cluster",
          "type": "tree",
          "content": null
        },
        {
          "name": "ractor_cluster_derive",
          "type": "tree",
          "content": null
        },
        {
          "name": "ractor_cluster_integration_tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "ractor_playground",
          "type": "tree",
          "content": null
        },
        {
          "name": "xtask",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}