{
  "metadata": {
    "timestamp": 1736709213487,
    "page": 494,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "BurntSushi/jiff",
      "stars": 1911,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1123046875,
          "content": "/Cargo.lock\n/target\n/tmp\n/ecma-test262\n/BREADCRUMBS\n# Criterion seems to vomit this out to CWD. wat.\n/profile.json\n"
        },
        {
          "name": ".rgignore",
          "type": "blob",
          "size": 0.0146484375,
          "content": "!/ecma-test262\n"
        },
        {
          "name": ".vim",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 21.05078125,
          "content": "# CHANGELOG\n\n0.1.21 (2025-01-04)\n===================\nThis release includes a new API for setting the unit designator label in a\nfriendly formatted duration for zero-length durations.\n\nEnhancements:\n\n* [#192](https://github.com/BurntSushi/jiff/issues/192):\nAdd option to the friendly printer for setting the unit when writing a\nzero-length duration.\n\n\n0.1.20 (2025-01-03)\n===================\nThis release inclues a new type, `Pieces`, in the `jiff::fmt::temporal`\nsub-module. This exposes the individual components of a parsed Temporal\nISO 8601 datetime string. It allows users of Jiff to circumvent the checks\nin the higher level parsing routines that prevent you from shooting yourself\nin the foot.\n\nFor example, parsing into a `Zoned` will return an error for raw RFC 3339\ntimestamps like `2025-01-03T22:03-05` because there is no time zone annotation.\nWithout a time zone, Jiff cannot do time zone aware arithmetic and rounding.\nInstead, such a datetime can only be parsed into a `Timestamp`. This lower\nlevel `Pieces` API now permits users of Jiff to parse this string into its\ncomponent parts and assemble it into a `Zoned` if they so choose.\n\nEnhancements:\n\n* [#188](https://github.com/BurntSushi/jiff/issues/188):\nAdd `fmt::temporal::Pieces` for granular datetime parsing and formatting.\n\n\n0.1.19 (2025-01-02)\n===================\nThis releases includes a UTF-8 related bug fix and a few enhancements.\n\nFirstly, a `Span`'s default `Display` implementation now writes uppercase\nunit designator labels. That means you'll get `P1Y2M3DT4H5M6S` instead\nof `P1y2m3dT4h5m6s` by default. You can restore previous behavior via\n`jiff::fmt::temporal::SpanPrinter::lowercase`. This change was made to improve\ninteroperability.\n\nSecondly, `SignedDuration` now supports rounding via `SignedDuration::round`.\nNote that it only supports rounding time units (hours or smaller). In order to\nround with calendar units, you'll still need to use a `Span`.\n\nEnhancements:\n\n* [#130](https://github.com/BurntSushi/jiff/issues/130):\nDocument value ranges for methods like `year`, `day`, `hour` and so on.\n* [#187](https://github.com/BurntSushi/jiff/issues/187):\nAdd a rounding API (for time units only) on `SignedDuration`.\n* [#190](https://github.com/BurntSushi/jiff/issues/190):\n`Span` and `SignedDuration` now use uppercase unit designator labels in their\ndefault ISO 8601 `Display` implementation.\n\nBug fixes:\n\n* [#155](https://github.com/BurntSushi/jiff/issues/155):\nRelax `strftime` format strings from ASCII-only to all of UTF-8.\n\n\n0.1.18 (2024-12-31)\n===================\nThis release includes a few minor enhancements. Namely, the ability to iterate\nover time zone transitions (in the future or the past), and some improvements\nto failure modes when `Timestamp` and `Span` arithmetic fails.\n\nEnhancements:\n\n* [#144](https://github.com/BurntSushi/jiff/issues/144):\nAdd APIs for iterating over the transitions of a time zone.\n* [#145](https://github.com/BurntSushi/jiff/issues/145):\nImprove docs and error messages around fallible `Timestamp` arithmetic.\n\n\n0.1.17 (2024-12-31)\n===================\nThis release enhances Jiff's support for `no_std` environments by making its\n`alloc` feature optional. When `alloc` is disabled, only fixed offset time\nzones are supported and error messages are significantly degraded. If you have\ncore-only use cases for Jiff, I'd love to hear about them on the issue tracker.\n\nEnhancements:\n\n* [#162](https://github.com/BurntSushi/jiff/issues/162):\nSupport platforms that do not have atomics in `std`.\n* [#168](https://github.com/BurntSushi/jiff/issues/168):\nJiff now supports disabling the `alloc` feature, which enables core-only mode.\n* [#169](https://github.com/BurntSushi/jiff/issues/169):\nAdd `TimeZone::to_fixed_offset` for accessing an invariant offset if possible.\n\n\n0.1.16 (2024-12-26)\n===================\nThis release includes a new `jiff::fmt::friendly` module for formatting and\nparsing durations in a more human readable format than what ISO 8601 specifies.\nISO 8601 remains the \"default\" duration format in Jiff due to its widespread\nsupport. Here are some examples:\n\n```text\n40d\n40 days\n1y1d\n1yr 1d\n3d4h59m\n3 days, 4 hours, 59 minutes\n3d 4h 59m\n2h30m\n2h 30m\n1mo\n1w\n1 week\n1w4d\n1 wk 4 days\n1m\n0.0021s\n0s\n0d\n0 days\n3 mins 34s 123ms\n3 mins 34.123 secs\n3 mins 34,123s\n1y1mo1d1h1m1.1s\n1yr 1mo 1day 1hr 1min 1.1sec\n1 year, 1 month, 1 day, 1 hour, 1 minute 1.1 seconds\n1 year, 1 month, 1 day, 01:01:01.1\n```\n\nTo quickly demonstrate this new feature, here's a simple CLI program using\nClap:\n\n```rust,no_run\nuse clap::Parser;\nuse jiff::{Span, Zoned};\n\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    duration: Span,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"adding duration to now: {}\", &Zoned::now() + args.duration);\n}\n```\n\nAnd running the program:\n\n```text\n$ cargo run -q -- '1 year, 2 months, 5 hours'\nadding duration to now: 2026-02-26T18:58:22-05:00[America/New_York]\n$ cargo run -q -- 'P1Y2MT5H'  # ISO 8601 durations are supported too!\nadding duration to now: 2026-02-26T19:00:57-05:00[America/New_York]\n```\n\nWith Jiff, you should no longer need to pull in crates like\n[`humantime`](https://docs.rs/humantime) and\n[`humantime-serde`](https://docs.rs/humantime-serde)\nto accomplish a similar task.\n\nWhile this new format doesn't support any kind of internationalization, the\nprevalence of the `humantime` crate suggests there's a desire for something\nlike this. The \"friendly\" format is meant to service all the same use cases\nas `humantime` does for durations, but in a way that doesn't let you shoot\nyourself in the foot.\n\nThe new \"friendly\" format is now the default for the `Debug` implementations\nof both `Span` and `SignedDuration`. It's also available via the \"alternate\"\n`Display` implementations for `Span` and `SignedDuration` as well. Moreover,\nthe `FromStr` trait implementations for both `Span` and `SignedDuration` will\nparse _both_ the ISO 8601 duration and this new \"friendly\" format. Finally,\nwhen `serde` integration is enabled, the `Deserialize` implementations for\n`SignedDuration` and `Span` also automatically parse either ISO 8601 or the\nfriendly format. For serialization, ISO 8601 remains the default, but the\n`jiff::fmt::serde` module provides easy to use helpers to switch to the\nfriendly format.\n\nThe `jiff::fmt::friendly` module documentation provides many more details,\nincluding a complete grammar for the format.\n\nEnhancements:\n\n* [#143](https://github.com/BurntSushi/jiff/pull/143):\nAdd `Hash` implementation for `Zoned` and `Timestamp`.\n\nBug fixes:\n\n* [#60](https://github.com/BurntSushi/jiff/issues/60):\nUse a better `Debug` output format for `SignedDuration` and `Span`.\n* [#111](https://github.com/BurntSushi/jiff/issues/111):\nAdd a new \"friendly\" duration format.\n* [#138](https://github.com/BurntSushi/jiff/issues/138):\nFix deserialization in `serde_yml` and `serde_yaml` crates.\n* [#161](https://github.com/BurntSushi/jiff/pull/161):\nFix `serde` dependency configuration so that it builds in no-std mode.\n\n\n0.1.15 (2024-11-30)\n===================\nThis release fixes a bug where Jiff would sometimes fail to parse TZif files\n(found, typically, in `/usr/share/zoneinfo` on Unix systems). This occurred\nwhen the TZif file contained a time zone transition outside the range of Jiff's\n`Timestamp` type (which is `-9999-01-01` to `9999-12-31`). The bug fix works by\nclamping the out-of-range transitions to Jiff's supported range.\n\nThis bug only seems to occur in some environments where their TZif files\ncontain more extreme values than what is typically found.\n\nBug fixes:\n\n* [#163](https://github.com/BurntSushi/jiff/issues/163):\nFix a bug where Jiff would fail to parse some TZif files.\n\n\n0.1.14 (2024-11-01)\n===================\nThis release introduces new APIs to the RFC 2822 printer that explicitly\nprint timestamps in a format strictly compatible with [RFC 9110].\n\nEnhancements:\n\n* [#151](https://github.com/BurntSushi/jiff/issues/151):\nAdd `rfc2822::DateTimePrinter::timestamp_to_rfc9110_string` method.\n\n\n0.1.13 (2024-09-07)\n===================\nThis release introduces a new `jiff::tz::TimeZone::try_system` API. It is like\n`TimeZone::system`, but returns an error instead of an automatic fall back to\nUTC when the system time zone could not be discovered.\n\nThis also includes an update to the bundled [IANA Time Zone Database] to the\n`2024b` release in the `jiff-tzdb` crate. As a reminder, the bundled database\nis not used or included on Unix platforms by default. See [PLATFORM] for more\ndetails.\n\nEnhancements:\n\n* [#65](https://github.com/BurntSushi/jiff/issues/65):\nAdd `TimeZone::try_system` for fallibly determining the system's time zone.\n* [#125](https://github.com/BurntSushi/jiff/pull/125):\nUpdate to the `2024b` release of the [IANA Time Zone Database].\n\n\n0.1.12 (2024-08-31)\n===================\nThis release introduces some new minor APIs that support formatting\n`Timestamp` values as RFC 3339 strings with a specific offset.\n\nPreviously, using the standard formatting routines that Jiff provides, it was\nonly possible to format a `Timestamp` using Zulu time. For example:\n\n```rust\nuse jiff::Timestamp;\n\nassert_eq!(\n    Timestamp::UNIX_EPOCH.to_string(),\n    \"1970-01-01T00:00:00Z\",\n);\n```\n\nThis is fine most use cases, but it can be useful on occasion to format\na `Timestamp` with a specific offset. While this isn't as expressive\nas formatting a datetime with a time zone (e.g., with an IANA time\nzone identifier), it may be useful in contexts where you just want to\n\"hint\" at what a user's local time is. To that end, there is a new\n`Timestamp::display_with_offset` method that makes this possible:\n\n```rust\nuse jiff::{tz, Timestamp};\n\nassert_eq!(\n    Timestamp::UNIX_EPOCH.display_with_offset(tz::offset(-5)).to_string(),\n    \"1969-12-31T19:00:00-05:00\",\n);\n```\n\nA corresponding API was added to `jiff::fmt::temporal::DateTimePrinter` for\nlower level use.\n\nMoreover, this release also includes new convenience APIs on the Temporal and\nRFC 2822 printer types for returning strings. For example, previously, if you\nwere using the RFC 2822 printer to format a `Timestamp`, you had to do this:\n\n```rust\nuse jiff::{fmt::rfc2822::DateTimePrinter, Timestamp};\n\nlet mut buf = String::new();\nDateTimePrinter::new().print_timestamp(&Timestamp::UNIX_EPOCH, &mut buf).unwrap();\nassert_eq!(buf, \"Thu, 1 Jan 1970 00:00:00 -0000\");\n```\n\nBut now you can just do this:\n\n```rust\nuse jiff::{fmt::rfc2822::DateTimePrinter, Timestamp};\n\nassert_eq!(\n    DateTimePrinter::new().timestamp_to_string(&Timestamp::UNIX_EPOCH).unwrap(),\n    \"Thu, 1 Jan 1970 00:00:00 -0000\",\n);\n```\n\nEnhancements:\n\n* [#122](https://github.com/BurntSushi/jiff/pull/122):\nSupport formatting `Timestamp` to an RFC 3339 string with a specific offset.\n\n\n0.1.11 (2024-08-28)\n===================\nThis release includes a few small enhancements that have been requested over\nthe last several weeks. The biggest enhancement is a new `jiff::fmt::serde`\nsub-module. It provides convenience routines similar to Chrono's\n`chrono::serde` sub-module for serializing and deserializing between a\n`jiff::Timestamp` and an integer number of seconds, milliseconds, microseconds\nor nanoseconds. For example:\n\n```rust\nuse jiff::Timestamp;\n\n#[derive(serde::Serialize, serde::Deserialize)]\nstruct Record {\n    #[serde(with = \"jiff::fmt::serde::timestamp::second::required\")]\n    timestamp: Timestamp,\n}\n\nlet json = r#\"{\"timestamp\":1517644800}\"#;\nlet got: Record = serde_json::from_str(&json).unwrap();\nassert_eq!(got.timestamp, Timestamp::from_second(1517644800).unwrap());\nassert_eq!(serde_json::to_string(&got).unwrap(), json);\n```\n\nIf you need to support optional timestamps via `Option<Timestamp>`, then use\n`jiff::fmt::serde::timestamp::second::optional` instead. Similarly, if you\nneed to support milliseconds instead of seconds, then replace `second` with\n`millisecond` in the module path.\n\nEnhancements:\n\n* [#78](https://github.com/BurntSushi/jiff/issues/78):\nAdd `BrokenDownTime::set_{offset,iana_time_zone}` APIs.\n* [#93](https://github.com/BurntSushi/jiff/issues/93):\nAdd note about using `Timestamp::now().to_zoned()` instead of\n`Zoned::now().with_time_zone()`.\n* [#101](https://github.com/BurntSushi/jiff/issues/101):\nAdd new `jiff::fmt::serde` module for integration with integer timestamps.\n* [#117](https://github.com/BurntSushi/jiff/pull/117):\nRemove `unsafe` usage in `libm` functions (applicable only to no-std users).\n\n\n0.1.10 (2024-08-23)\n===================\nThis release features a small bug fix where Jiff will detect an IANA time\nzone identifier in some cases where it wouldn't before. While Jiff would\npreviously read the symlink metadata on `/etc/localtime` by default to discover\nthe system configured time zone on Unix systems, it *wouldn't* do so when\n`TZ=/etc/localtime`. There's really no reason not to, so this release of Jiff\nis fixed to use symlink sniffing on file paths provided by thw `TZ` environment\nvariable.\n\nBug fixes:\n\n* [#113](https://github.com/BurntSushi/jiff/issues/113):\nWhen `TZ=/etc/localtime`, use symlink metadata to detect IANA identifier.\n\n\n0.1.9 (2024-08-23)\n==================\nThis release introduces new options for controlling the precision\nof fractional seconds when printing `Zoned`, `Timestamp`,\n`civil::DateTime` or `civil::Time` values. This is principally exposed\nvia `jiff::fmt::temporal::DateTimePrinter::precision`, but it's also\navailable via the standard library's formatting machinery. For example,\nif `zdt` is a `jiff::Zoned`, then `format!(\"{zdt:.6}\")` will format\nit into a string with microsecond precision, even if its fractional\ncomponent is zero.\n\nEnhancements:\n\n* [#92](https://github.com/BurntSushi/jiff/issues/92):\nSupport setting the precision of fractional seconds when printing datetimes.\n\n\n0.1.8 (2024-08-19)\n==================\nThis releases fixes a build error in Jiff's `alloc`-only configuration. This\nregression was introduced in `jiff 0.1.6`.\n\nBug fixes:\n\n* [#108](https://github.com/BurntSushi/jiff/issues/108):\nUse `core::time::Duration` everywhere instead of `std::time::Duration`.\n\n\n0.1.7 (2024-08-18)\n==================\nThis release relaxes Jiff's dependency on `windows-sys` to include multiple\nsemver incompatible releases. The purpose of this relaxation is to enable\nJiff to work with different versions of `windows-sys` in the hopes that this\nreduces the likelihood that multiple copies of `windows-sys` are included in\nyour dependency tree.\n\nDependencies:\n\n* [#106](https://github.com/BurntSushi/jiff/pull/106):\nRelax `windows-sys` dependency constraint to `>=0.52.0, <=0.59.*`.\n\n\n0.1.6 (2024-08-18)\n==================\nThis release includes a new top-level type, `SignedDuration`, that provides a\nnear exact replica of `std::time::Duration`, but signed. It is meant to provide\nalternative APIs for working with durations at a lower level than what `Span`\nprovides, and to facilitate better integration with the standard library.\n\nA `SignedDuration` has also been integrated with all of Jiff's datetime types.\nFor example, previously, `Zoned::checked_add` only accepted a concrete\n`jiff::Span`. But now it accepts a `jiff::Span`, `jiff::SignedDuration` or even\na `std::time::Duration`. Moreover, all of the `until` and `since` APIs on\ndatetime types have been ported and copied to return `SignedDuration` under the\n`duration_until` and `duration_since` names.\n\nThis marks an initial integration phase with `SignedDuration`. It is planned\nto integrate it more with the datetime types. Currently, there are integrations\non `Timestamp` and `Span`, but more will be added in the future.\n\nOverall, folks should still use `Span`. That is the intended default duration\ntype in Jiff and will continue to be. Users of Jiff may find `SignedDuration`\nuseful in contexts where speed is important or when one needs to integrate\nwith the standard library.\n\nThis release also includes a few related deprecations as the APIs involving\n`std::time::Duration` are phased out in favor of `SignedDuration`.\n\nDeprecations:\n\n* `Timestamp::as_duration`: replaced with `as_jiff_duration`, which will be\nrenamed to `as_duration` in `jiff 0.2`.\n* `Timestamp::from_duration`: replaced with `from_jiff_duration`, which will be\nrenamed to `from_duration` in `jiff 0.2`.\n* `Timestamp::from_signed_duration`: replaced with `from_jiff_duration`.\n* `Span::to_duration`: replaced with `to_jiff_duration`, which will be renamed\nto `to_duration` in `jiff 0.2`.\n\nBasically, all of the above APIs either accept or return a\n`std::time::Duration`. To avoid breaking chnages at this point, new methods\nfor `SignedDuration` were added. For example, `Timestamp::as_jiff_duration`.\nIn `jiff 0.2`, the above deprecated methods will be removed and replaced with\nequivalent methods that accept or return a `SignedDuration` instead. Callers\ncan then convert between a `SignedDuration` and a `std::time::Duration` using\nappropriate `TryFrom` trait implementations.\n\nEnhancements:\n\n* [#21](https://github.com/BurntSushi/jiff/issues/21):\nAdd new top-level `SignedDuration` type.\n* [#90](https://github.com/BurntSushi/jiff/issues/90):\nImprove error message when using `Span` with >=day units with a `Timestamp`.\n\nPerformance:\n\n* [#104](https://github.com/BurntSushi/jiff/pull/104)\nOptimize offset calculations in time zones without DST.\n* [#105](https://github.com/BurntSushi/jiff/pull/105)\nOptimize offset calculations for timestamps after last DST rule change.\n\n\n0.1.5 (2024-08-09)\n==================\nThis release includes some improvements and bug fixes, particularly for Jiff's\n`strtime` APIs.\n\nEnhancements:\n\n* [#63](https://github.com/BurntSushi/jiff/issues/63):\nAdd link to original Chrono maintainer's commentary in `DESIGN.md`.\n* [#75](https://github.com/BurntSushi/jiff/issues/75):\nAdd support for `%V` for formatting _and_ parsing IANA time zone identifiers.\n* [#79](https://github.com/BurntSushi/jiff/pull/79):\nAdd `devcontainer.json` to support GitHub Codespaces.\n* [#85](https://github.com/BurntSushi/jiff/pull/85):\nSet correct ranges for internal tracking in return value of `days_in_month`.\n\nBug fixes:\n\n* [#59](https://github.com/BurntSushi/jiff/issues/59):\nFixes a bug where some `Span`s could not be roundtripped through ISO 8601.\n* [#71](https://github.com/BurntSushi/jiff/issues/71):\nTweak wording in documentation of \"printf\"-style API.\n* [#73](https://github.com/BurntSushi/jiff/issues/73):\nMake it so `%.Nf` only formats to `N` decimal places.\n* [#77](https://github.com/BurntSushi/jiff/pull/77):\nDisable optimizations when running tests.\n\n\n0.1.4 (2024-08-01)\n==================\nThis release includes a small improvement for `strptime` that permits\n`%Y%m%d` to parse `20240730` correctly.\n\nEnhancements:\n\n* [#62](https://github.com/BurntSushi/jiff/issues/62):\nTweak `strptime` so that things like `%Y` aren't unceremoniously greedy.\n\n\n0.1.3 (2024-07-30)\n==================\nThis release features support for `wasm32-unknown-unknown`. That is, when\nJiff's new `js` crate feature is enabled, Jiff will automatically use\nJavaScript APIs to determine the current time and time zone.\n\nEnhancements:\n\n* [#58](https://github.com/BurntSushi/jiff/pull/58):\nAdd WASM support and a new `PLATFORM.md` guide.\n\n\n0.1.2 (2024-07-28)\n==================\nThis release features a few new APIs that a need for arose while experimenting\nwith actually using Jiff in real projects. Namely, the `jiff::fmt::strtime`\nmodule now has `%f` and `%.f` directives for parsing and formatting fractional\nseconds. And both `jiff::fmt::rfc2822` and `jiff::fmt::strtime` now have\nsupport for skipping weekday checks during parsing. (Previously, Jiff required\nthat an English weekday be consistent with the date parsed, and there was no\nway to opt out. While this is still the default behavior, callers can disable\nthis check.)\n\nEnhancements:\n\n* [#52](https://github.com/BurntSushi/jiff/pull/52):\nImprove documentation for `Span` getter methods.\n* [#53](https://github.com/BurntSushi/jiff/pull/53):\nAdd support for skipping weekday checking when parsing datetimes.\n* [#55](https://github.com/BurntSushi/jiff/pull/55):\nAdd support for fractional seconds in `jiff::fmt::strtime`.\n\nBug fixes:\n\n* [#49](https://github.com/BurntSushi/jiff/pull/49):\nFix informational regex describing ISO 8601 format.\n* [#51](https://github.com/BurntSushi/jiff/pull/51):\nExplicitly allow new deny-by-default lint `ambiguous_negative_literals`.\n\n\n0.1.1 (2024-07-25)\n==================\nThis is a new semver compatible release. The principle addition are APIs for\nconverting between a `jiff::Span` and a `std::time::Duration`. Specifically,\nthere are now `TryFrom<Span> for Duration` and `TryFrom<Duration> for Span`\ntrait implementations. There is also a `Span::to_duration`, which requires a\nrelative date, for converting spans with non-uniform units (like months) to a\n`Duration`.\n\nEnhancements:\n\n* [#21](https://github.com/BurntSushi/jiff/issues/21),\n  [#40](https://github.com/BurntSushi/jiff/issues/40):\nAdds APIs for converting between `Span` and `std::time::Duration`.\n\nBug fixes:\n\n* [#36](https://github.com/BurntSushi/jiff/issues/36):\nSaturating arithmetic for `Timestamp` panics with day-or-greater units.\n* [#38](https://github.com/BurntSushi/jiff/issues/38):\nFix some bugs in the micro-benchmarks.\n* [#39](https://github.com/BurntSushi/jiff/issues/39):\nDocument that the RFC 2822 parser is not technically fully spec compliant.\n\n\n0.1.0 (2024-07-21)\n==================\nThe initial release of Jiff.\n\n[IANA Time Zone Database]: https://www.iana.org/time-zones\n[PLATFORM]: PLATFORM.md\n[RFC 9110]: https://datatracker.ietf.org/doc/html/rfc9110#section-5.6.7-15\n"
        },
        {
          "name": "COMPARE.md",
          "type": "blob",
          "size": 42.6748046875,
          "content": "# Comparison with other Rust datetime crates\n\nThis document is meant to be a comparison between Jiff and each of the other\nprominent open source datetime libraries for Rust. If you feel like there is a\nlibrary missing from this list, please file an issue about it. I would prefer\nto only add libraries to this list that are being used in production or have a\nsubstantial number of users.\n\nThe goal of this document is to be as _descriptive_ and _substantively\ncomplete_ as possible. For example, \"Chrono has a better API design than Jiff\"\nwould be a pretty vague value judgment that someone could easily disagree with.\nBut, \"Chrono allows using a zone-aware datetime type that is `Copy` while Jiff\ndoes not\" would be a factual comparison that someone might use to _support_ an\nopinion that Chrono's API design is better than Jiff's. In other words, this\ndocument should provide the \"facts of comparison\" but refrain from assigning\nvalue judgments.\n\nIn terms of completeness, it is probably not realistic to expect 100%\ncompletion here. We aren't hunting for Korok Seeds. Instead, this document\naims for _substantive_ completion. That is, if there's a point of difference\nbetween Jiff and another library that would likely influence someone's decision\nof which library to use, and can be articulated descriptively, then it should\nprobably be in this document.\n\nThe current status of this document is that it is both _incomplete_ and\n_biased_. That is, this first draft was written by the author of Jiff without\nany input from other crate maintainers. (To other crate maintainers: I welcome\nfeedback. Even if it's just filing an issue.)\n\nNote that this document contains many code snippets. They can be tested with\n`cargo test --doc _documentation::comparison` from the root of this repository.\n\n## [`chrono`](https://docs.rs/chrono) (v0.4.38)\n\nChrono is a Rust datetime library that provides a time zone aware datetime\ntype.\n\nFor the following comparisons, a `Cargo.toml` with the following dependencies\nshould be able to run any of the programs in this section:\n\n```toml\nanyhow = \"1.0.81\"\nchrono = \"0.4.38\"\nchrono-tz = { version = \"0.9.0\", features = [\"serde\"] }\njiff = { version = \"0.1.0\", features = [\"serde\"] }\nserde = \"1.0.203\"\nserde_json = \"1.0.117\"\ntzfile = \"0.1.3\"\n```\n\n### Time zone database integration\n\nJiff gives you automatic integration with your copy of the Time Zone Database.\nOn Unix, it's usually found at `/usr/share/zoneinfo`. On Windows, since there\nis no canonical location, Jiff will depend on `jiff-tzdb` by default, which\nwill embed the entire database into your binary. Jiff hides these details from\nyou. For example, to convert a civil time into an absolute time in a particular\ntime zone:\n\n```rust\nuse jiff::civil::date;\n\nfn main() -> anyhow::Result<()> {\n    let zdt = date(2024, 6, 30).at(9, 46, 0, 0).intz(\"America/New_York\")?;\n    assert_eq!(zdt.to_string(), \"2024-06-30T09:46:00-04:00[America/New_York]\");\n    Ok(())\n}\n```\n\nFor Chrono, one recommended option is to use the\n[`chrono-tz`](https://docs.rs/chrono-tz) crate:\n\n```rust\nuse anyhow::Context;\nuse chrono::TimeZone;\nuse chrono_tz::America::New_York;\n\nfn main() -> anyhow::Result<()> {\n    let zdt = New_York.with_ymd_and_hms(2024, 6, 30, 9, 46, 0)\n        .single()\n        .context(\"invalid naive time\")?;\n    assert_eq!(zdt.to_string(), \"2024-06-30 09:46:00 EDT\");\n    Ok(())\n}\n```\n\n`chrono-tz` works by embedding an entire copy of the Time Zone Database into\nyour binary, where each time zone is represented as a Rust value that can be\nimported via `use`. A disadvantage of this approach is that you're reliant on\n`chrono-tz` updates to get the most recent time zone information. An advantage\nof this approach is that you never need to worry about an end user's system\nstate. Another advantage is that this allows a `TimeZone` trait implementation\nto be `Copy` via a `&Tz`, and that in turn allows a `chrono::DateTime` to be\n`Copy`. In contrast, in Jiff, a `TimeZone` is never `Copy`. Since a `Zoned`\nembeds a `TimeZone`, a `Zoned` is never `Copy` either.\n\nAnother recommended option is the [`tzfile`](https://docs.rs/tzfile) crate.\nUnlike `chrono-tz`, the `tzfile` crate will try to read time zone data from\nyour system's copy of the Time Zone Database.\n\n```rust\nuse anyhow::Context;\nuse chrono::{NaiveDate, NaiveDateTime, NaiveTime, TimeZone};\nuse tzfile::Tz;\n\n#[cfg(unix)]\nfn main() -> anyhow::Result<()> {\n    let tz = Tz::named(\"America/New_York\")?;\n    let zdt = (&tz).with_ymd_and_hms(2024, 6, 30, 9, 46, 0)\n        .single()\n        .context(\"invalid naive time\")?;\n    assert_eq!(zdt.to_string(), \"2024-06-30 09:46:00 EDT\");\n    Ok(())\n}\n\n// `tzfile` exposes a platform specific API, which means\n// users of the crate have to deal with platform differences\n// themselves.\n#[cfg(not(unix))]\nfn main() -> anyhow::Result<()> {\n    Ok(())\n}\n```\n\nNote though that at time of writing (2024-07-11), `tzfile::Tz::named` will\nread and parse the corresponding time zone rules from disk on every call.\nConversely, in Jiff, all time zone lookups by name are cached. This may or may\nnot matter for your use case.\n\n### Jiff losslessly roundtrips time zone aware datetimes\n\nIn Jiff, with `serde` support enabled, one can serialize and deserialize a\n`Zoned` value losslessly. This means that, after deserialization, you can\nexpect it to still perform DST arithmetic:\n\n```rust\nuse jiff::{civil::date, ToSpan, Zoned};\n\nfn main() -> anyhow::Result<()> {\n    let zdt = date(2024, 3, 10).at(1, 59, 59, 0).intz(\"America/New_York\")?;\n\n    let json = serde_json::to_string_pretty(&zdt)?;\n    assert_eq!(json, \"\\\"2024-03-10T01:59:59-05:00[America/New_York]\\\"\");\n\n    let got: Zoned = serde_json::from_str(&json)?;\n    assert_eq!(got.to_string(), \"2024-03-10T01:59:59-05:00[America/New_York]\");\n    let next = got.checked_add(1.minute())?;\n    assert_eq!(next.to_string(), \"2024-03-10T03:00:59-04:00[America/New_York]\");\n\n    Ok(())\n}\n```\n\nNotice that when we add a minute, it jumps to `03:00` civil time because of the\ntransition into daylight saving time in my selected time zone. Notice also the\noffset change from `-05` to `-04`.\n\nCompare this with Chrono which also supports `serde`, but not with `chrono-tz`\nor `tzfile`. One option is to use its `Local` implementation of its `TimeZone`\ntrait:\n\n```rust,no_run\nuse anyhow::Context;\nuse chrono::{DateTime, FixedOffset, Local, TimeDelta, TimeZone};\n\nfn main() -> anyhow::Result<()> {\n    let zdt = Local.with_ymd_and_hms(2024, 3, 10, 1, 59, 59)\n        .single()\n        .context(\"invalid naive time\")?;\n\n    let json = serde_json::to_string_pretty(&zdt)?;\n    // Chrono only serializes the offset, which makes lossless\n    // deserialization impossible. Chrono loses the time zone\n    // information.\n    assert_eq!(json, \"\\\"2024-03-10T01:59:59-05:00\\\"\");\n\n    // The serialized datetime has no time zone information,\n    // so unless there is some out-of-band information saying\n    // what its time zone is, we're forced to use a fixed offset:\n    let got: DateTime<FixedOffset> = serde_json::from_str(&json)?;\n    assert_eq!(got.to_string(), \"2024-03-10 01:59:59 -05:00\");\n    let next = got.checked_add_signed(TimeDelta::minutes(1))\n        .context(\"arithmetic failed\")?;\n    // This is correct for fixed offset, but it's no longer\n    // DST aware.\n    assert_eq!(next.to_string(), \"2024-03-10 02:00:59 -05:00\");\n\n    // We could deserialize into a `DateTime<Local>`, but this\n    // requires knowing that the time zone of the datetime matches\n    // local time zone. Which you might know. But you might not.\n    let got: DateTime<Local> = serde_json::from_str(&json)?;\n    assert_eq!(got.to_string(), \"2024-03-10 01:59:59 -05:00\");\n    let next = got.checked_add_signed(TimeDelta::minutes(1))\n        .context(\"arithmetic failed\")?;\n    assert_eq!(next.to_string(), \"2024-03-10 03:00:59 -04:00\");\n\n    Ok(())\n}\n```\n\nOr, if you have a `Tz` from `chrono-tz`. But in this case, since `chrono-tz`\ndoesn't support Serde, you have to convert to a `DateTime<FixedOffset>`. Like\nabove, you'll lose DST safe arithmetic after deserialization:\n\n```rust\nuse anyhow::Context;\nuse chrono::{DateTime, FixedOffset, TimeDelta, TimeZone};\nuse chrono_tz::America::New_York;\n\nfn main() -> anyhow::Result<()> {\n    let zdt = New_York.with_ymd_and_hms(2024, 3, 10, 1, 59, 59)\n        .single()\n        .context(\"invalid naive time\")?;\n\n    let json = serde_json::to_string_pretty(&zdt.fixed_offset())?;\n    // Chrono only serializes the offset, which makes lossless\n    // deserialization impossible. Chrono loses the time zone\n    // information.\n    assert_eq!(json, \"\\\"2024-03-10T01:59:59-05:00\\\"\");\n\n    // The serialized datetime has no time zone information,\n    // so unless there is some out-of-band information saying\n    // what its time zone is, we're forced to use a fixed offset:\n    let got: DateTime<FixedOffset> = serde_json::from_str(&json)?;\n    assert_eq!(got.to_string(), \"2024-03-10 01:59:59 -05:00\");\n    let next = got.checked_add_signed(TimeDelta::minutes(1))\n        .context(\"arithmetic failed\")?;\n    // This is correct for fixed offset, but it's no longer\n    // DST aware.\n    assert_eq!(next.to_string(), \"2024-03-10 02:00:59 -05:00\");\n\n    Ok(())\n}\n```\n\nThe main way to solve this problem (and is how `java.time`, Temporal and Jiff\nsolve it), is by supporting [RFC 9557]. Otherwise, the only way to fully\ncapture Jiff's functionality in Chrono is to define a custom serialization\nformat that includes the instant, the time zone identifier *and* the offset.\n(The offset is used for conflict resolution when deserializing datetimes made\nin the future for which their offset has changed due to changes in the time\nzone database.)\n\n[RFC 9557]: https://datatracker.ietf.org/doc/rfc9557/\n\n### Jiff provides support for zone aware calendar arithmetic\n\nWith Jiff, you can add non-uniform units like days to time zone aware datetimes,\nand get non-uniform units like days as a representation of a span between\ndatetimes. And they agree on the results.\n\n```rust\nuse jiff::{civil::date, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = date(2024, 3, 9).at(21, 0, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = zdt1.checked_add(1.day())?;\n\n    // Even though 2 o'clock didn't occur on 2024-03-10, adding 1 day\n    // returns the same civil time the next day.\n    assert_eq!(zdt2.to_string(), \"2024-03-10T21:00:00-04:00[America/New_York]\");\n    // The span of time is 23 hours:\n    assert_eq!(&zdt2 - &zdt1, 23.hours());\n    // But if you ask for the span in units of days, you get exactly 1:\n    assert_eq!(zdt1.until((Unit::Day, &zdt2))?, 1.day());\n\n    Ok(())\n}\n```\n\nThis is important and difficult to get right because some days are only 23\nhours long (typically the day of the year where DST starts) and some days are\n25 hours long (typically the day of the year where DST ends). With Jiff, you\ncan seamlessly go back-and-forth between calendar units and clock units without\nworrying about whether \"day\" will be interpreted differently.\n\nChrono has some support for this. Namely, it can add units of days in a time\nzone aware fashion, but it cannot produce spans of time involving days between\ntwo zone aware datetimes that is consistent with adding days.\n\n```rust\nuse anyhow::Context;\nuse chrono::{Days, TimeDelta, TimeZone};\nuse chrono_tz::America::New_York;\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = New_York.with_ymd_and_hms(2024, 3, 9, 21, 0, 0)\n        .single()\n        .context(\"invalid naive time\")?;\n\n    // Adding 1 day via TimeDelta leads to a result that is\n    // 24 hours later, including the gap at 2am on 2024-03-10.\n    // As a result, you get a different civil time, which is\n    // usually not what is intended.\n    let zdt2 = zdt1.checked_add_signed(TimeDelta::days(1))\n        .context(\"adding a time delta failed\")?;\n    assert_eq!(zdt2.to_string(), \"2024-03-10 22:00:00 EDT\");\n\n    // However, Chrono does expose a separate API for adding\n    // units of days specifically. This does get you the\n    // correct result.\n    let zdt2 = zdt1.checked_add_days(Days::new(1))\n        .context(\"adding days failed\")?;\n    assert_eq!(zdt2.to_string(), \"2024-03-10 21:00:00 EDT\");\n\n    // The only way to compute a duration between two datetimes\n    // in Chrono is with a `TimeDelta`:\n    let delta = zdt2.signed_duration_since(&zdt1);\n    // And since `TimeDelta` assumes all days are exactly 24\n    // hours long, you get a result of `0` days. If this were\n    // a fold, the number of days would be `1`, but you'd also\n    // have a number of hours equal to `1`.\n    assert_eq!(delta.num_days(), 0);\n\n    Ok(())\n}\n```\n\n### Jiff losslessly roundtrips durations\n\nJiff implements something close to ISO 8601 to provide lossless serialization\nand deserialization of its `Span` type. A `Span` covers both calendar and clock\nunits.\n\n```rust\nuse jiff::{Span, ToSpan};\n\nfn main() -> anyhow::Result<()> {\n    let span = 5.years().months(2).days(1).hours(20);\n    let json = serde_json::to_string_pretty(&span)?;\n    assert_eq!(json, \"\\\"P5Y2M1DT20H\\\"\");\n\n    let got: Span = serde_json::from_str(&json)?;\n    assert_eq!(got, span);\n\n    Ok(())\n}\n```\n\nChrono [does not currently have Serde support for its duration type][serde-duration].\n\n[serde-duration]: https://github.com/chronotope/chrono/issues/117\n\n### Jiff supports dealing with gaps in civil time\n\nA gap in civil time most typically occurs when a particular region enters\ndaylight saving time. When this happens, some time on the clocks in that region\nis skipped. It never appears. (A fold happens when the clocks are rolled back,\nusually when leaving daylight saving time. In this case, some time on the clock\nis repeated.)\n\nJiff supports automatically selecting a \"reasonable\" choice in either case\nvia its \"compatible\" strategy (as specified by [RFC 5545]).\n\n```rust\nuse jiff::Zoned;\n\nfn main() -> anyhow::Result<()> {\n    // This is a gap. The default strategy takes the time after the gap.\n    let zdt: Zoned = \"2024-03-10 02:30[America/New_York]\".parse()?;\n    assert_eq!(zdt.to_string(), \"2024-03-10T03:30:00-04:00[America/New_York]\");\n\n    // This is a fold. The default strategy takes the time before the fold.\n    let zdt: Zoned = \"2024-11-03 01:30[America/New_York]\".parse()?;\n    // The time after the fold would be identical,\n    // except the offset would be -05.\n    assert_eq!(zdt.to_string(), \"2024-11-03T01:30:00-04:00[America/New_York]\");\n\n    Ok(())\n}\n```\n\nJiff also exposes all information available with respect to ambiguous civil\ndatetimes via `tz::AmbiguousZoned`, `tz::AmbiguousTimestamp` and\n`tz::AmbiguousOffset`. This enables callers to implement whatever strategy\nthey want.\n\nWhile Chrono will let you deal with folds, it returns `MappedLocalTime::None`\nin the case of a gap with no additional information. So there's really nothing\nelse you can conveniently do in this case except return an error:\n\n```rust\nuse anyhow::Context;\nuse chrono::{offset::MappedLocalTime, TimeZone};\nuse chrono_tz::America::New_York;\n\nfn main() -> anyhow::Result<()> {\n    // For gaps, Chrono exposes no additional information.\n    let mapped = New_York.with_ymd_and_hms(2024, 3, 10, 2, 30, 0);\n    assert_eq!(mapped, MappedLocalTime::None);\n\n    // For folds, Chrono gives you the two choices.\n    // This is approximately equivalent to what Jiff exposes\n    // in the case of a fold.\n    let zdt = New_York.with_ymd_and_hms(2024, 11, 3, 1, 30, 0)\n        .earliest()\n        .context(\"invalid datetime\")?;\n    assert_eq!(zdt.to_string(), \"2024-11-03 01:30:00 EDT\");\n\n    Ok(())\n}\n```\n\n[RFC 5545]: https://datatracker.ietf.org/doc/html/rfc5545\n\n### Jiff supports rounding durations\n\nIn Jiff, one can round the duration computed between two datetimes:\n\n```rust\nuse jiff::{civil::date, RoundMode, ToSpan, Unit, ZonedDifference};\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = date(2001, 11, 18).at(8, 30, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = date(2024, 7, 11).at(22, 38, 0, 0).intz(\"America/New_York\")?;\n\n    let round_options = ZonedDifference::new(&zdt2)\n        .largest(Unit::Year)\n        .smallest(Unit::Day)\n        .mode(RoundMode::HalfExpand);\n    let span = zdt1.until(round_options)?;\n    assert_eq!(span, 22.years().months(7).days(24));\n\n    Ok(())\n}\n```\n\nWhile Chrono supports rounding datetimes themselves via its\n`chrono::duration::DurationRound` trait, it does not support rounding durations\nthemselves. Indeed, its principle duration type, `TimeDelta`, is an \"absolute\"\nduration like `std::time::Duration` (except that it is signed). It doesn't keep\ntrack of individual units like Jiff does. Instead, everything gets normalized\ninto a 96-bit integer number of nanoseconds. With this representation, it is\nimpossible to do DST safe rounding to non-uniform units like days.\n\n### Jiff supports zone-aware rounding of durations\n\nJiff's duration rounding is time zone aware. For example, if you're rounding to\na number of days, it knows to round 11.5 hours up to 1 day on days with gaps,\nand round 12 hours down to 0 days on days with folds. The only requirement\nis that we provide a reference datetime with which to interpret the span.\n\n```rust\nuse jiff::{civil::date, SpanRound, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    let gapday = date(2024, 3, 10).intz(\"America/New_York\")?;\n    let foldday = date(2024, 11, 3).intz(\"America/New_York\")?;\n\n    let span1 = 11.hours().minutes(30);\n    let span2 = span1.round(\n        SpanRound::new().smallest(Unit::Day).relative(&gapday),\n    )?;\n    // rounds up, even though on a normal day 11.5 hours would round down.\n    assert_eq!(span2, 1.day());\n\n    let span1 = 12.hours();\n    let span2 = span1.round(\n        SpanRound::new().smallest(Unit::Day).relative(&foldday),\n    )?;\n    // rounds down, even though on a normal day 12 hours would round up.\n    assert_eq!(span2, 0.days());\n\n    Ok(())\n}\n```\n\nAs with the previous section, Chrono does not support rounding durations or\nrounding units like `Days` with respect to a reference datetime.\n\n### Jiff supports re-balancing durations\n\nThis example is like the one above, except we choose a smaller \"largest\" unit:\n\n```rust\nuse jiff::{civil::date, RoundMode, ToSpan, Unit, ZonedDifference};\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = date(2001, 11, 18).at(8, 30, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = date(2024, 7, 11).at(22, 38, 0, 0).intz(\"America/New_York\")?;\n\n    let round_options = ZonedDifference::new(&zdt2)\n        .largest(Unit::Month)\n        .smallest(Unit::Day)\n        .mode(RoundMode::HalfExpand);\n    let span = zdt1.until(round_options)?;\n    assert_eq!(span, 271.months().days(24));\n\n    Ok(())\n}\n```\n\n### Jiff supports getting the `nth` weekday from the current date\n\n```rust\nuse jiff::civil::{date, Weekday};\n\nfn main() -> anyhow::Result<()> {\n    let zdt = date(2024, 7, 11).at(22, 59, 0, 0).intz(\"America/New_York\")?;\n    assert_eq!(zdt.weekday(), Weekday::Thursday);\n\n    let next_tuesday = zdt.nth_weekday(1, Weekday::Tuesday)?;\n    assert_eq!(\n        next_tuesday.to_string(),\n        \"2024-07-16T22:59:00-04:00[America/New_York]\",\n    );\n\n    Ok(())\n}\n```\n\nChrono does have `NaiveDate::from_weekday_of_month_opt`, but it only counts\nthe number of weekdays for a particular month. (The Jiff equivalent is\n`nth_weekday_of_month`.) Moreover, Chrono's method is only available on naive\ndates and not zone aware datetimes.\n\n### Jiff supports detecting time zone offset conflicts\n\nOne of the problems with storing datetimes in the future is that time\nzone rules can change. For example, if you stored the zone aware datetime\n`2020-01-15T12:00-02[America/Sao_Paulo]` in 2018, then it would be considered\nto be in daylight saving time with an offset of `-2`. However, in 2019,\ndaylight saving time was abolished in this time zone, which renders the\ndatetime invalid because its offset *should* be `-3`.\n\nJiff can detect these sorts of conflicts and will actually return a parse error\nby default. We exemplify this by creating and serializing a zoned datetime from\nan old copy of the Time Zone Database, and then try to parse it back using our\nsystem's current copy of the Time Zone Database. (This also demonstrate's Jiff\nsupport for using multiple copies of the Time Zone Database simultaneously.\nBut the main point here is to simulate the process of \"serialize datetime,\ntime zone rules change, deserialize datetime.\")\n\n```rust,no_run\nuse jiff::{fmt::temporal::DateTimeParser, tz::{self, TimeZoneDatabase}};\n\n// We use a custom parser with a default configuration because we need\n// to ask the parser to use a different time zone database than the\n// default. This can't be done via the nice `\"...\".parse()` API one\n// would typically use.\nstatic PARSER: DateTimeParser = DateTimeParser::new();\n\nfn main() -> anyhow::Result<()> {\n    // Open a version of tzdb from before Brazil announced its abolition\n    // of daylight saving time.\n    let tzdb2018 = TimeZoneDatabase::from_dir(\"path/to/tzdb-2018b\")?;\n    // Open the system tzdb.\n    let tzdb = tz::db();\n\n    // Parse the same datetime string with the same parser, but using two\n    // different versions of tzdb.\n    let dt = \"2020-01-15T12:00[America/Sao_Paulo]\";\n    let zdt2018 = PARSER.parse_zoned_with(&tzdb2018, dt)?;\n    let zdt = PARSER.parse_zoned_with(tzdb, dt)?;\n\n    // Before DST was abolished, 2020-01-15 was in DST, which corresponded\n    // to UTC offset -02. Since DST rules applied to datetimes in the\n    // future, the 2018 version of tzdb would lead one to interpret\n    // 2020-01-15 as being in DST.\n    assert_eq!(zdt2018.offset(), tz::offset(-2));\n    // But DST was abolished in 2019, which means that 2020-01-15 was no\n    // no longer in DST. So after a tzdb update, the same datetime as above\n    // now has a different offset.\n    assert_eq!(zdt.offset(), tz::offset(-3));\n\n    // So if you try to parse a datetime serialized from an older copy of\n    // tzdb with a new copy of tzdb, you'll get an error under the default\n    // configuration because of `OffsetConflict::Reject`. This would succeed if\n    // you parsed it using tzdb2018!\n    assert!(PARSER.parse_zoned_with(tzdb, zdt2018.to_string()).is_err());\n\n    Ok(())\n}\n```\n\nWith Chrono, this sort of checking isn't possible in the first place because\nit doesn't support an interchange format that includes the IANA time zone\nidentifier.\n\n### Jiff supports adding durations with calendar units\n\nSince `Span` is Jiff's single duration type that combines calendar and clock\nunits, one can freely add them together. The only requirement is that if a span\nhas calendar units, you need to provide a reference date. (Because 1 month from\nApril 1 is shorter than 1 month from May 1.)\n\n```rust\nuse jiff::{civil::date, ToSpan};\n\nfn main() -> anyhow::Result<()> {\n    let span1 = 2.years().months(4).days(25).hours(23);\n    let span2 = 3.hours();\n    let span3 = span1.checked_add((span2, date(2024, 1, 1)))?;\n    assert_eq!(span3, 2.years().months(4).days(26).hours(2));\n\n    Ok(())\n}\n```\n\nWhile Chrono has types like `Months` and `Days`, there's no way to combine\nthem into one, and Chrono does not provide operations on both at the same time.\n\n### Jiff supports zone-aware re-balancing of durations\n\nIf you have a span of `1.day()` and want to convert it to hours, then that\ncalculation depends on how long the day is. If you don't provide any reference\ndatetime, then Jiff assumes the day is always 24 hours long:\n\n```rust\nuse jiff::{SpanRound, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    let span1 = 1.day();\n    let span2 = span1.round(SpanRound::new().largest(Unit::Hour))?;\n    assert_eq!(span2, 24.hours());\n\n    Ok(())\n}\n```\n\nBut if a reference date is provided with a time zone, then the re-balancing is\nDST safe:\n\n```rust\nuse jiff::{civil::date, SpanRound, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    // In the case of a gap (typically transitioning in DST):\n    let zdt = date(2024, 3, 9).at(21, 0, 0, 0).intz(\"America/New_York\")?;\n    let span1 = 1.day();\n    let span2 = span1.round(\n        SpanRound::new().largest(Unit::Hour).relative(&zdt)\n    )?;\n    assert_eq!(span2, 23.hours());\n\n    // In the case of a fold (typically transitioning out of DST):\n    let zdt = date(2024, 11, 2).at(21, 0, 0, 0).intz(\"America/New_York\")?;\n    let span1 = 1.day();\n    let span2 = span1.round(\n        SpanRound::new().largest(Unit::Hour).relative(&zdt)\n    )?;\n    assert_eq!(span2, 25.hours());\n\n    Ok(())\n}\n```\n\n### Chrono is faster than Jiff in some cases\n\n.. and in other cases, Jiff is a little faster than Chrono. But Chrono does\nseem to have the edge. These benchmark results were collected on `2024-07-11`.\n\n```text\n$ cd bench\n$ cargo bench -- --save-baseline base\n[.. snip ..]\n$ critcmp -g '^[^/]+/(.*)$' -f '^(chrono|chrono-tzfile|jiff)/' base\ngroup                                         base/chrono-tzfile/                    base/chrono/                           base/jiff/\n-----                                         -------------------                    ------------                           ----------\ncivil_datetime_to_instant_static              1.00     19.2±0.26ns        ? ?/sec    1.16     22.1±0.20ns        ? ?/sec    1.00     19.2±0.74ns        ? ?/sec\ncivil_datetime_to_instant_with_tzdb_lookup    21.31     2.2±0.03µs        ? ?/sec                                           1.00    103.0±4.99ns        ? ?/sec\ninstant_to_civil_datetime_offset                                                     1.00      6.9±0.02ns        ? ?/sec    3.45     23.8±1.11ns        ? ?/sec\ninstant_to_civil_datetime_static              1.17     20.1±0.16ns        ? ?/sec    1.00     17.3±0.12ns        ? ?/sec    2.32     40.1±0.22ns        ? ?/sec\noffset_to_civil_datetime                                                             6.22      5.5±0.02ns        ? ?/sec    1.00      0.9±0.02ns        ? ?/sec\noffset_to_instant                                                                    3.61      1.4±0.02ns        ? ?/sec    1.00      0.4±0.00ns        ? ?/sec\nparse_civil_datetime                                                                 2.00     69.1±1.33ns        ? ?/sec    1.00     34.5±0.15ns        ? ?/sec\nparse_rfc2822                                                                        1.36     57.5±0.58ns        ? ?/sec    1.00     42.1±0.46ns        ? ?/sec\nparse_strptime                                                                       2.59    169.4±3.96ns        ? ?/sec    1.00     65.5±0.90ns        ? ?/sec\nzoned_add_time_duration                                                              1.00      5.6±0.06ns        ? ?/sec    5.85     32.8±0.25ns        ? ?/sec\n```\n\nIt's plausible that in cases where Jiff is slower (for example,\n`zoned_add_time_duration`), users could use `Timestamp` instead of `Zoned`.\nNamely, `Zoned` has some overhead associated with it due to the fact that\nit stores a `civil::DateTime`, `Timestamp` and a `TimeZone`. Where as a\n`Timestamp` is just a 96-bit integer number of nanoseconds.\n\n## [`time`](https://docs.rs/time) (v0.3.36)\n\n`time` is a Rust datetime library that provides a time zone offset aware\ndatetime type.\n\nFor the following comparisons, a `Cargo.toml` with the following dependencies\nshould be able to run any of the programs in this section:\n\n```toml\nanyhow = \"1.0.81\"\njiff = { version = \"0.1.0\", features = [\"serde\"] }\ntime = { version = \"0.3.36\", features = [\"local-offset\", \"macros\", \"parsing\"] }\n```\n\n### Time zone database integration\n\nLike `chrono`, the `time` crate does not come with any out of the box\nfunctionality for reading your system's copy of the Time Zone Database. Unlike\nChrono, however, `time` does not have any way to use the Time Zone Database at\nall. That is, there is nothing like `chrono-tz` or `tzfile` for `time`, and\n`time` does not provide the extension points necessary in its API for such\na thing to exist. (The `chrono-tz` and `tzfile` crates work by implementing\nChrono's `TimeZone` trait.)\n\nThe main thing `time` supports is a concept of \"local\" time. In particular, it\nis limited to determining your system's default time zone offset, but nothing\nmore. That is, it doesn't support DST safe arithmetic:\n\n```rust\nuse anyhow::Context;\nuse time::{ext::NumericalDuration, macros::datetime, Duration};\n\nfn main() -> anyhow::Result<()> {\n    // We create a fixed datetime for testing purposes,\n    // but it's the same sort of value we would get back\n    // from `OffsetDateTime::now_local()`.\n    let dt1 = datetime!(2024-03-10 01:30:00 -05:00);\n    let dt2 = dt1.checked_add(1.hours())\n      .context(\"datetime arithmetic failed\")?;\n    // The 2 o'clock hour didn't exist on 2024-03-10\n    // in New York.\n    assert_eq!(dt2.to_string(), \"2024-03-10 2:30:00.0 -05:00:00\");\n\n    Ok(())\n}\n```\n\n`time`, in its present design, is fundamentally incapable of doing daylight\nsaving time safe arithmetic because its `OffsetDateTime` type doesn't know\nanything about the time zone rules. Compare this with Jiff, which lets you not\nonly create a datetime with an offset, but with a _time zone_:\n\n```rust\nuse jiff::{civil::date, ToSpan};\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = date(2024, 3, 10).at(1, 30, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = zdt1.checked_add(1.hour())?;\n    assert_eq!(zdt2.to_string(), \"2024-03-10T03:30:00-04:00[America/New_York]\");\n\n    Ok(())\n}\n```\n\nIn my comparison with Chrono I went through a lot of examples involving\ntime zones. I did this because Chrono supports DST safe arithmetic generally,\nbut with a lot of nuanced differences from what Jiff supports. Conversely,\n`time` doesn't really support time zones at all. (The main exception is that\n`time` can return the system configured offset by virtue of platform APIs like\n`libc`. But time zone support stops there.) So at this time, in this document,\nwe won't belabor the point.\n\n### Jiff allows getting the current time safely from multiple threads\n\n```rust\nuse jiff::Zoned;\n\nfn main() -> anyhow::Result<()> {\n    let handle = std::thread::spawn(|| {\n        println!(\"{}\", Zoned::now());\n    });\n    handle.join().unwrap();\n\n    Ok(())\n}\n```\n\nThe output on my system of the above program is:\n\n```text\n2024-07-12T15:02:15.92054241-04:00[America/New_York]\n```\n\nConversely, this program using the `time` crate:\n\n```rust,no_run\nuse time::OffsetDateTime;\n\nfn main() -> anyhow::Result<()> {\n    let handle = std::thread::spawn(|| {\n        println!(\"{}\", OffsetDateTime::now_local().unwrap());\n    });\n    handle.join().unwrap();\n\n    Ok(())\n}\n```\n\nHas this output:\n\n```text\nthread '<unnamed>' panicked at main.rs:7:52:\ncalled `Result::unwrap()` on an `Err` value: IndeterminateOffset\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread 'main' panicked at main.rs:9:19:\ncalled `Result::unwrap()` on an `Err` value: Any { .. }\n```\n\nThe reason for this is that `time` uses `libc` APIs for querying the local\ntime. These `libc` APIs may access the environment in a way that is not\nsynchronized with Rust's standard library, which leads to a path where safe\nRust code can be written to cause undefined behavior. `time` mitigates this\nby checking how many threads are active. If it's a value other than `1`, then\n`now_local()` fails.\n\nJiff avoids this by avoiding `libc`. Jiff does still read environment\nvariables, but only does so through Rust's standard library `std::env` module.\nThis makes Jiff's access to the environment sound.\n\nThe `time` crate does provide a way to change this behavior by\nexplicitly opting into the possibility of undefined behavior via\n`time::util::local_offset::set_soundness`. Aside from that, it is likely that\nthis is a temporary state for `time` until it either implements the `libc`\nfunctionality it needs by itself, or until [`std::env::set_var`] is marked\n`unsafe`. (Which will likely happen in Rust 2024.)\n\n[`std::env::set_var`]: https://doc.rust-lang.org/std/env/fn.set_var.html\n\n### `time` supports its own custom format description\n\n```rust\nuse time::{macros::format_description, OffsetDateTime};\n\nfn main() -> anyhow::Result<()> {\n    let format = format_description!(\n        \"[year]-[month]-[day] [hour]:[minute]:[second] \\\n         [offset_hour sign:mandatory]:[offset_minute]:[offset_second]\"\n    );\n    let odt = OffsetDateTime::parse(\"2024-07-11 22:49:00 -04:00:00\", &format)?;\n    assert_eq!(odt.to_string(), \"2024-07-11 22:49:00.0 -04:00:00\");\n\n    Ok(())\n}\n```\n\nJiff does support a `strptime`/`strftime` style API via the\n`jiff::fmt::strtime` module.\n\n### Jiff supports rounding datetimes\n\nWe use a `Zoned` with a `TimeZone` that has a fixed offset. This is same as\n`time`'s `OffsetDateTime` type:\n\n```rust\nuse jiff::{civil::date, tz::{self, TimeZone}, Unit, Zoned};\n\nfn main() -> anyhow::Result<()> {\n    let tz = TimeZone::fixed(tz::offset(-4));\n    let zdt1 = date(2024, 7, 11).at(16, 46, 0, 0).to_zoned(tz)?;\n    let zdt2 = zdt1.round(Unit::Hour)?;\n    assert_eq!(zdt2.to_string(), \"2024-07-11T17:00:00-04:00[-04:00]\");\n\n    Ok(())\n}\n```\n\nNote though that because Jiff has support for time zones, you generally\nshouldn't need to (and shouldn't _want_ to) use fixed offset datetimes. It's\nbecause they don't take time zone rules into account and thus do not provide\nDST safe arithmetic. Instead, the code above should be written like this\n(unless you have a very specific reason to do otherwise):\n\n```rust\nuse jiff::{civil::date, Unit, Zoned};\n\nfn main() -> anyhow::Result<()> {\n    // Can also use `.to_zoned(TimeZone::system())` to use your system's\n    // default time zone.\n    let zdt1 = date(2024, 7, 11).at(16, 46, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = zdt1.round(Unit::Hour)?;\n    assert_eq!(zdt2.to_string(), \"2024-07-11T17:00:00-04:00[America/New_York]\");\n\n    Ok(())\n}\n```\n\nFrom here on, we won't use fixed offset datetimes in order to avoid encouraging\ntheir use.\n\nThe `time` crate has no rounding APIs.\n\n### Jiff supports rounding durations\n\nIn Jiff, one can round the duration computed between two datetimes\n\n```rust\nuse jiff::{civil::date, RoundMode, ToSpan, Unit, ZonedDifference};\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = date(2001, 11, 18).at(8, 30, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = date(2024, 7, 11).at(22, 38, 0, 0).intz(\"America/New_York\")?;\n\n    let round_options = ZonedDifference::new(&zdt2)\n        .largest(Unit::Year)\n        .smallest(Unit::Day)\n        .mode(RoundMode::HalfExpand);\n    let span = zdt1.until(round_options)?;\n    assert_eq!(span, 22.years().months(7).days(24));\n\n    Ok(())\n}\n```\n\nThe `time` crate has no rounding APIs.\n\n### Jiff provides support for calendar arithmetic\n\nWith Jiff, you can add durations with calendar units:\n\n```rust\nuse jiff::{civil::date, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    let zdt1 = date(2024, 7, 11).at(21, 0, 0, 0).intz(\"America/New_York\")?;\n    let zdt2 = zdt1.checked_add(2.years().months(6).days(1))?;\n    assert_eq!(zdt2.to_string(), \"2027-01-12T21:00:00-05:00[America/New_York]\");\n\n    Ok(())\n}\n```\n\nThe `time` crate does provide a way to construct a `Duration` from units of\ndays via `Duration::days`, but this of course requires assuming that all days\nare 24 hours long. And `time` does not support adding years or months.\n\n### Jiff supports conveniently re-balancing durations\n\nAside from calendar arithmetic, Jiff also supports re-balancing durations\nbased on what you want the largest unit to be:\n\n```rust\nuse jiff::{SpanRound, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    // Balance down to seconds.\n    let span1 = 4.hours().minutes(36).seconds(59);\n    let span2 = span1.round(SpanRound::new().largest(Unit::Second))?;\n    assert_eq!(span2, 16_619.seconds());\n\n    // Now go back by balancing up to hours.\n    let span1 = 16_619.seconds();\n    let span2 = span1.round(SpanRound::new().largest(Unit::Hour))?;\n    assert_eq!(span2, 4.hours().minutes(36).seconds(59));\n\n    Ok(())\n}\n```\n\nThe `time` crate's `Duration` type can go from bigger units down to smaller\nunits easily enough:\n\n```rust\nuse time::{ext::NumericalDuration, Duration};\n\nfn main() -> anyhow::Result<()> {\n    let span = 4.hours() + 36.minutes() + 59.seconds();\n    assert_eq!(span.whole_seconds(), 16_619);\n    Ok(())\n}\n```\n\nBut going from smaller units back up to larger units is difficult:\n\n```rust\nuse time::{ext::NumericalDuration, Duration};\n\nfn main() -> anyhow::Result<()> {\n    let span = 16_619.seconds();\n    assert_eq!(span.whole_hours(), 4);\n    assert_eq!(span.whole_minutes(), 276);\n    assert_eq!(span.whole_seconds(), 16_619);\n\n    Ok(())\n}\n```\n\nNotice that the accessors just report how many whole units the span is. You\ncan't get the span broken down into smaller units. To achieve that, you need to\ndo the arithmetic yourself:\n\n```rust\nuse time::{convert::{Hour, Minute, Second}, ext::NumericalDuration, Duration};\n\nfn main() -> anyhow::Result<()> {\n    let mut span = 16_619.seconds();\n    assert_eq!(span.whole_hours(), 4);\n    assert_eq!(span.whole_minutes() % Minute::per(Hour) as i64, 36);\n    assert_eq!(span.whole_seconds() % Second::per(Minute) as i64, 59);\n\n    Ok(())\n}\n```\n\n### Jiff is faster than `time` in some cases\n\n.. and in other cases, `time` is a little faster than Jiff. These benchmark\nresults were collected on `2024-07-11`.\n\n```text\n$ cd bench\n$ cargo bench -- --save-baseline base\n[.. snip ..]\n$ critcmp -g '^[^/]+/(.*)$' -f '^(time|jiff)/' base\ngroup                                         base/jiff/                             base/time/\n-----                                         ----------                             ----------\ninstant_to_civil_datetime_offset              1.65     23.8±1.11ns        ? ?/sec    1.00     14.4±0.14ns        ? ?/sec\noffset_to_civil_datetime                      1.14      0.9±0.02ns        ? ?/sec    1.00      0.8±0.00ns        ? ?/sec\noffset_to_instant                             1.00      0.4±0.00ns        ? ?/sec    6.29      2.4±0.03ns        ? ?/sec\nparse_civil_datetime                          1.00     34.5±0.15ns        ? ?/sec    1.95     67.2±1.49ns        ? ?/sec\nparse_rfc2822                                 1.00     42.1±0.46ns        ? ?/sec    1.75     73.8±0.66ns        ? ?/sec\nparse_strptime                                1.00     65.5±0.90ns        ? ?/sec    1.71    112.0±0.92ns        ? ?/sec\nzoned_add_time_duration                       1.42     32.8±0.25ns        ? ?/sec    1.00     23.1±0.15ns        ? ?/sec\n```\n\nIt's plausible that in cases where Jiff is slower (for example,\n`zoned_add_time_duration`), users could use `Timestamp` instead of `Zoned`.\nNamely, `Zoned` has some overhead associated with it due to the fact that\nit stores a `civil::DateTime`, `Timestamp` and a `TimeZone`. Where as a\n`Timestamp` is just a 96-bit integer number of nanoseconds.\n\nNote that some benchmarks were omitted here since `time` does not support time\nzones.\n\n## [`hifitime`](https://docs.rs/hifitime) (v3.9.0)\n\n`hifitime` is a datetime library with a focus on engineering and scientific\ncalculations where general relativity and time dilation matter. It supports\nconversion between many different time scales: TAI, Terrestrial Time, UTC, GPST\nand more. It also supports leap seconds.\n\nFor the following comparisons, a `Cargo.toml` with the following dependencies\nshould be able to run any of the programs in this section:\n\n```toml\nanyhow = \"1.0.81\"\nhifitime = \"3.9.0\"\njiff = { version = \"0.1.0\", features = [\"serde\"] }\n```\n\n### Time zone database integration\n\nLike the `time` crate, `hifitime` does not support time zones and does not have\nany integration with the Time Zone Database. `hifitime` doesn't have any\nequivalent to `OffsetDateTime` like in `time` either. The only datetime type\nthat `hifitime` has is `Epoch`, and it is an absolute time. While you can\nconvert between it and civil time (assuming civil time is in UTC), there is no\ndata type in `hifitime` for representing civil time.\n\n### `hifitime` supports leap seconds\n\nIn particular, when computing a duration from two `Epoch` values that spans\na positive leap second (a second gets repeated), `hifitime` will correctly\nreport the accurate duration:\n\n```rust\nuse hifitime::{Duration, Epoch};\n\nfn main() -> anyhow::Result<()> {\n    let e1: Epoch = \"2015-06-30T23:00:00 UTC\".parse()?;\n    let e2: Epoch = \"2015-07-01T00:00:00 UTC\".parse()?;\n    let duration = e2 - e1;\n    assert_eq!(duration, Duration::from_seconds(3_601.0));\n\n    Ok(())\n}\n```\n\nJiff, however, [does not support leap seconds][jiff-leap-seconds]:\n\n```rust\nuse jiff::{Timestamp, ToSpan};\n\nfn main() -> anyhow::Result<()> {\n    let ts1: Timestamp = \"2015-06-30T23:00:00Z\".parse()?;\n    let ts2: Timestamp = \"2015-07-01T00:00:00Z\".parse()?;\n    let span = ts2 - ts1;\n    assert_eq!(span, 3_600.seconds());\n\n    Ok(())\n}\n```\n\nSo in this case, Jiff reports `3,600` seconds as the duration, but the _actual_\nduration was `3,601` seconds, as reported by `hifitime`.\n\n[jiff-leap-seconds]: https://github.com/BurntSushi/jiff/issues/7\n\n### Jiff makes checked or saturating arithmetic explicit\n\nFor Jiff, whether you want to saturate or not is an explicit part of the API.\nAnd implementations of the `Add` operator will panic on overflow:\n\n```rust\nuse jiff::{Timestamp, ToSpan};\n\nfn main() -> anyhow::Result<()> {\n    let ts = Timestamp::MAX;\n    assert!(ts.checked_add(1.day()).is_err());\n    assert_eq!(ts.saturating_add(1.hour()), ts);\n\n    Ok(())\n}\n```\n\nIn contrast, `hifitime` appears to use saturating arithmetic everywhere (I've\nnot been able to find this behavior documented though, so I'm not clear on what\nthe intended semantics are):\n\n```rust\nuse hifitime::{Duration, Epoch};\n\nfn main() -> anyhow::Result<()> {\n    let e1 = Epoch::from_unix_seconds(f64::MAX);\n    let e2 = e1 + Duration::from_days(1.0);\n    assert_eq!(e1, e2);\n\n    Ok(())\n}\n```\n\n\n## [`icu`](https://docs.rs/icu) (v1.5.0)\n\nThe `icu` crate fulfils a slightly different need than `jiff`. Its main\nfeatures are calendrical calculations (`icu::calendar`), supporting conversions\nbetween different calendar systems such as Gregorian, Buddhist, Islamic,\nJapanese, etc., as well as localized datetime formatting (`icu::datetime`).\n\nIt does not perform datetime or time-zone arithmetic, and does not have a\ntimestamp or duration type.\n\n`icu` can be used to complement `jiff` when localized date formatting or\ncalendar conversions are required:\n\n```rust\nuse icu::{\n    calendar::{japanese::Japanese, DateTime},\n    datetime::TypedDateTimeFormatter,\n    locid::locale,\n};\nuse jiff::Timestamp;\n\nfn main() -> anyhow::Result<()> {\n    let ts: Timestamp = \"2024-09-10T23:37:20Z\".parse()?;\n    let zoned = ts.intz(\"Asia/Tokyo\")?;\n\n    // Create ICU datetime.\n    let datetime = DateTime::try_new_iso_datetime(\n        i32::from(zoned.year()),\n        // These unwraps are all guaranteed to be\n        // correct because Jiff's bounds on allowable\n        // values fit within icu's bounds.\n        u8::try_from(zoned.month()).unwrap(),\n        u8::try_from(zoned.day()).unwrap(),\n        u8::try_from(zoned.hour()).unwrap(),\n        u8::try_from(zoned.minute()).unwrap(),\n        u8::try_from(zoned.second()).unwrap(),\n    )?;\n\n    // Convert to Japanese calendar.\n    let japanese_datetime = DateTime::new_from_iso(datetime, Japanese::new());\n\n    // Format for the en-GB locale.\n    let formatter = TypedDateTimeFormatter::try_new(\n        &locale!(\"en-GB\").into(),\n        Default::default(),\n    )?;\n\n    // Assert that we get the expected result.\n    assert_eq!(\n        formatter.format(&japanese_datetime).to_string(),\n        \"Sept 11, 6 Reiwa, 08:37:20\",\n    );\n\n    Ok(())\n}\n```\n\nThe above example requires the following dependency specifications:\n\n```toml\nanyhow = \"1.0.81\"\nicu = { version = \"1.5.0\", features = [\"std\"] }\njiff = { version = \"0.1.0\", features = [\"serde\"] }\n```\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 0.123046875,
          "content": "This project is dual-licensed under the Unlicense and MIT licenses.\n\nYou may use this code under the terms of either license.\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 6.5537109375,
          "content": "[package]\nname = \"jiff\"\nversion = \"0.1.21\"  #:version\nauthors = [\"Andrew Gallant <jamslam@gmail.com>\"]\nlicense = \"Unlicense OR MIT\"\nrepository = \"https://github.com/BurntSushi/jiff\"\ndocumentation = \"https://docs.rs/jiff\"\ndescription = '''\nA date-time library that encourages you to jump into the pit of success.\n\nThis library is heavily inspired by the Temporal project.\n'''\ncategories = [\"date-and-time\", \"no-std\"]\nkeywords = [\"date\", \"time\", \"calendar\", \"zone\", \"duration\"]\nedition = \"2021\"\nexclude = [\"/.github\", \"/tmp\"]\nautotests = false\nautoexamples = false\nrust-version = \"1.70\"\n\n[workspace]\nmembers = [\n  \"jiff-cli\",\n  \"jiff-tzdb\",\n  \"jiff-tzdb-platform\",\n  \"examples/*\",\n]\n\n# Features are documented in the \"Crate features\" section of the crate docs:\n# https://docs.rs/jiff/*/#crate-features\n[features]\ndefault = [\"std\", \"tz-system\", \"tzdb-bundle-platform\", \"tzdb-zoneinfo\"]\nstd = [\"alloc\", \"log?/std\", \"serde?/std\"]\nalloc = [\"serde?/alloc\", \"portable-atomic-util/alloc\"]\nserde = [\"dep:serde\"]\nlogging = [\"dep:log\"]\n\n# When enabled, Jiff will include code that attempts to determine the \"system\"\n# time zone. For example, on Unix systems, this is usually determined by\n# looking at the symlink information on /etc/localtime. But in general, it's\n# very platform specific and heuristic oriented. On some platforms, this may\n# require extra dependencies. (For example, `windows-sys` on Windows.)\ntz-system = [\"std\", \"dep:windows-sys\"]\n\n# This conditionally bundles tzdb into the binary depending on which platform\n# Jiff is being built for.\ntzdb-bundle-platform = [\"dep:jiff-tzdb-platform\", \"alloc\"]\n\n# This forces the jiff-tzdb crate to be included. If tzdb-zoneinfo is enabled,\n# then the system tzdb will take priority over the bundled database.\ntzdb-bundle-always = [\"dep:jiff-tzdb\", \"alloc\"]\n\n# This enables the system or \"zoneinfo\" time zone database. This is the\n# database that is typically found at /usr/share/zoneinfo on macOS and Linux.\ntzdb-zoneinfo = [\"std\"]\n\n# This enables bindings to web browser APIs for retrieving the current time\n# and configured time zone. This ONLY applies on wasm32-unknown-unknown and\n# wasm64-unknown-unknown targets. Specifically, *not* on wasm32-wasi or\n# wasm32-unknown-emscripten targets.\n#\n# This is an \"ecosystem\" compromise due to the fact that there is no general\n# way to determine at compile time whether a wasm target is intended for use\n# on the \"web.\" In practice, only wasm{32,64}-unknown-unknown targets are used\n# on the web, but wasm{32,64}-unknown-unknown targets can be used in non-web\n# contexts as well. Thus, the `js` feature should be enabled only by binaries,\n# tests or benchmarks when it is *known* that the application will be used in a\n# web context.\n#\n# Libraries that depend on Jiff should not need to define their own `js`\n# feature just to forward it to Jiff. Instead, application authors can depend\n# on Jiff directly and enable the `js` feature themselves.\n#\n# (This is the same dependency setup that the `getrandom` crate uses.)\njs = [\"dep:wasm-bindgen\", \"dep:js-sys\"]\n\n[dependencies]\njiff-tzdb = { version = \"0.1.1\", path = \"jiff-tzdb\", optional = true }\nlog = { version = \"0.4.21\", optional = true, default-features = false }\nserde = { version = \"1.0.203\", optional = true, default-features = false }\n\n# Note that the `cfg` gate for the `tzdb-bundle-platform` must repeat the\n# target gate on this dependency. The intent is that `tzdb-bundle-platform`\n# is enabled by default, but that the `tzdb-bundle-platform` crate is only\n# actually used on platforms without a system tzdb (i.e., Windows and wasm).\n[target.'cfg(any(windows, target_family = \"wasm\"))'.dependencies]\njiff-tzdb-platform = { version = \"0.1.1\", path = \"jiff-tzdb-platform\", optional = true }\n\n[target.'cfg(windows)'.dependencies.windows-sys]\nversion = \">=0.52.0, <=0.59.*\"\ndefault-features = false\nfeatures = [\"Win32_Foundation\", \"Win32_System_Time\"]\noptional = true\n\n[target.'cfg(all(any(target_arch = \"wasm32\", target_arch = \"wasm64\"), target_os = \"unknown\"))'.dependencies]\njs-sys = { version = \"0.3.50\", optional = true }\nwasm-bindgen = { version = \"0.2.70\", optional = true }\n\n# For targets that have no atomics in `std`, we add a dependency on\n# `portable-atomic-util` for its Arc implementation.\n#\n# Note that for this to work, you may need to enable a `portable-atomic`\n# feature like `portable-atomic/unsafe-assume-single-core` or\n# `portable-atomic/critical-section`.\n[target.'cfg(not(target_has_atomic = \"ptr\"))'.dependencies]\nportable-atomic = { version = \"1.10.0\", default-features = false }\nportable-atomic-util = { version = \"0.2.4\", default-features = false }\n\n[dev-dependencies]\nanyhow = \"1.0.81\"\nchrono = { version = \"0.4.38\", features = [\"serde\"] }\nchrono-tz = \"0.10.0\"\nclap = { version = \"4.5.23\", features = [\"derive\"] }\nhumantime = \"2.1.0\"\n# This adds approximately 50 new compilation units when running `cargo test`\n# locally on Unix. Blech.\nicu = { version = \"1.5.0\", features = [\"std\"] }\ninsta = \"1.39.0\"\n# We force `serde` to be enabled in dev mode so that the docs render and test\n# correctly. This is highly suspicious.\njiff = { path = \"./\", default-features = false, features = [\"serde\"] }\nquickcheck = { version = \"1.0.3\", default-features = false }\nserde = { version = \"1.0.203\", features = [\"derive\"] }\nserde_json = \"1.0.117\"\nserde_yml = \"0.0.12\"\ntabwriter = \"1.4.0\"\ntime = { version = \"0.3.36\", features = [\"local-offset\", \"macros\", \"parsing\"] }\ntzfile = \"0.1.3\"\nwalkdir = \"2.5.0\"\n\n# hifitime doesn't build on wasm for some reason, so exclude it there.\n[target.'cfg(not(target_family = \"wasm\"))'.dev-dependencies.hifitime]\nversion = \"3.9.0\"\n\n[[test]]\npath = \"tests/lib.rs\"\nname = \"integration\"\n\n# This is just like the default 'test' profile, but debug_assertions are\n# disabled. This is important to cover for Jiff because we do a lot of extra\n# work in our internal ranged integer types when debug_assertions are enabled.\n# It also makes types fatter. It's very useful for catching overflow bugs.\n# But since there's a fair bit of logic there, it's also worth running tests\n# without debug_assertions enabled to exercise the *actual* code paths used\n# in production.\n[profile.testrelease]\ninherits = \"test\"\ndebug-assertions = false\n\n[package.metadata.docs.rs]\n# We want to document all features.\nall-features = true\n# Since this crate's feature setup is pretty complicated, it is worth opting\n# into a nightly unstable option to show the features that need to be enabled\n# for public API items. To do that, we set 'docsrs', and when that's enabled,\n# we enable the 'doc_auto_cfg' feature.\n#\n# To test this locally, run:\n#\n#     RUSTDOCFLAGS=\"--cfg docsrs\" cargo +nightly doc --all-features\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n"
        },
        {
          "name": "Cross.toml",
          "type": "blob",
          "size": 0.0703125,
          "content": "[build.env]\npassthrough = [\n  \"TZ\",\n  \"RUST_LOG\",\n  \"RUST_BACKTRACE\",\n]\n"
        },
        {
          "name": "DESIGN.md",
          "type": "blob",
          "size": 33.0390625,
          "content": "# The API design rationale for Jiff\n\nThis document discusses some of the design decisions that led to Jiff's API.\nThe purpose of writing this document is to help folks understand _why_ Jiff's\nAPI is the way it is, above and beyond \"Jiff did it this way to match\n[Temporal].\"\n\nThis document is written as an FAQ, although it is restricted in scope to the\nAPI design of Jiff. This isn't a FAQ for questions like, \"How do I add 1 day\nto a zoned datetime?\"\n\nUnlike \"[Comparison with other Rust datetime crates][comparison],\" this\ndocument is _opinionated_. That is, some value judgments are expressed that are\nopinion based, and on which reasonable people may disagree.\n\n\n## Why name the library \"jiff\"?\n\nI wanted something short and related to time for the library name. Most of the\n\"obvious\" names are taken.\n\nI thought a lot about phrases or words that had some connection to time. There\nare more than you think. One phrase I heard a lot as a kid who grew up in New\nEngland was, \"I'll be back in a jiff\" or \"I'll be back in a jiffy.\" The meaning\nof that phrase was, roughly, \"I'll be back very soon.\" So \"jiff\" refers to some\n\"short span of time.\" Since \"jiff\" was shorter than \"jiffy,\" that's what I went\nwith.\n\nJiff is pronounced like \"gif\" with a soft \"g,\" as in \"gem.\"\n\n\n## Why build another datetime library?\n\nAt the time of writing, there are four existing prominent datetime libraries\nfor Rust: [`chrono`], [`time`], [`hifitime`] and [`icu`]. \"[Comparison with\nother Rust datetime crates][comparison]\" goes over the \"facts of comparison\"\nbetween the crates (mostly for just `chrono` and `time`), but it intentionally\nleaves out value judgments. To answer this question, I have to introduce value\njudgments and my opinions on existing libraries. **These are opinions on which\nreasonable people can disagree.** Moreover, since these are opinions meant to\njustify an alternative, these opinions tend to be oriented on the faults (as\nthis author sees them) in existing crates as opposed to their benefits.\n\nBroadly speaking, my view on Rust datetime libraries was that they had reached\na local maximum, and there didn't seem to be much movement toward breaking out\nof that local maximum and getting to something that was categorically better.\nMuch of my thoughts revolve around not just the functionality provided, but\nalso the API design of these crates. Thus, I perceived a gap in the ecosystem\nthat I felt like I could fill.\n\nI'll share my brief thoughts on each crate. I'll cover \"why not contribute to\nan existing library and make it better\" in the next question.\n\n### `chrono`\n\nIn my view, Chrono is the closest to Jiff in terms of the functionality it\nprovides. It has some support for DST safe arithmetic for example, and even\nsome support for doing calendar math. But its support is incomplete. While one\ncan add units of days to Chrono datetimes, Chrono lacks the ability to do math\non multiple calendar units at the same time. Moreover, Chrono cannot _produce_\ncalendar durations between two time zone aware datetimes.\n\nMoreover, Chrono's integration with the [IANA Time Zone Database] is somewhat\nspotty. Support for it isn't included in the `chrono` crate itself, but\nis instead something you need to opt into with additional crates, such\nas [`chrono-tz`] or [`tzfile`]. And each crate comes with its own set of\ntrade-offs. `chrono-tz` embeds the entire database into your binary and makes\nthe time zones available at compile time, while `tzfile` reads the database\nfrom your system's copy of the database (i.e., `/usr/share/zoneinfo` on Unix).\nIn my view, this creates a difficult situation for non-expert users of Chrono\nwhere the \"right\" choice isn't obvious. In my opinion, the _default_ should be\nto read time zone transition data from the system's copy of the database on\ndisk, and only bundle the data into the binary as a last resort when a copy of\nthe database isn't reliably available (like on Windows). The main reason for\nthis is that the database is frequently updated (a few times each year) since\nthe rules for time zone transitions can change. If that time zone data is\nembedded into your binary, then you need to 1) wait for `chrono-tz` to update\ntheir data and 2) re-compile your application and ship it out to users.\n\nIn contrast, Jiff _abstracts_ the method of time zone data discovery. That\nis, there are no API differences between \"read time zone data from the system\ndatabase\" and \"read embedded time zone data.\" Of course, Jiff provides options\nto choose which method to use (like forcing bundling on Unix), but all of this\nis transparent to users of Jiff itself. That is, _Jiff tries to do the right\nthing by default_. There's no need to go off and find a different crate to\nhandle time zone data for you.\n\nWhile on the topic of time zones, Chrono also has no support for serializing\nIANA time zone identifiers. This implies that if you have a time zone aware\ndatetime in Chrono (whether by `chrono-tz` or `tzfile`), then you can't\nlosslessly serialize and deserialize it. Namely, serialization will lose\nthe time zone the datetime is associated with, and instead only include\nthe offset. Then when it's deserialized, you're left with an offset-only\ndatetime that won't, for example, provide DST safe arithmetic based on the\noriginal time zone. In contrast, Jiff follows [RFC 9557] to support embedding\nIANA time zone identifiers in the serialized representation. For example,\n`2024-07-21T17:11-04[America/New_York]`.\n\nThere are a variety of other things that Jiff supports which Chrono does\nnot, but that's covered in [the comparison section between Jiff and\nChrono][comparison-chrono].\n\nAs for API design, I found Chrono's API to be overengineered and difficult to\ndeal with. This is a frustratingly vague complaint, but here are some things\nthat I believe contribute to that opinion:\n\n* I've used Chrono for various things, and I found it very difficult to figure\nout from its API what the right operations to use were.\n* Chrono has been steadily deprecating huge portions of its API in favor of\nfallible routines. I find the resulting documentation difficult to read and the\nnaming to be very clunky.\n* The fallible routines return a mixture of `Option<T>` and `Result<T, E>`.\nThis is frustrating in my experience because the `Option<T>` _usually_ needs to\nbe converted to a human readable error message, and I think the library should\nmake use of its contextual information to do this for you. Indeed, Jiff rarely\nreturns `Option<T>` and instead returns `Result<T, E>` with a contextualized\nhuman readable error message. (Although I'm sure the error messages could use a\nlot of improvement.)\n* I find the use of generics in Chrono to be overengineered. It has some\nkey benefits, for example, making the notion of \"time zone\" an open concept\nthat can be defined by users of the crate. But in my opinion, this is rarely\nneeded. The Chrono crate ecosystem makes use of this via the `chrono-tz` and\n`tzfile` crates, but Jiff covers both of those use cases (broadly speaking)\nautomatically.\n* Chrono overall puts a large emphasis on \"fixed offset\" datetimes, but these\nare rarely the right abstraction to use. It's possible this is due to the fact\nthat IANA time zone support is external to Chrono itself. Instead, Jiff just\ntries to do the right thing by default, and gives users IANA time zone support\nout of the box. Jiff does support fixed offset datetimes as well, but they are\nde-emphasized.\n* I find generic traits like `Datelike` to also be very confusing because they\nsplit the APIs of types like `NaiveDate` into concrete methods and generic\nmethods, and there's no obvious rhyme or reason as to how those methods are\nsplit up.\n* Chrono's API doesn't offer clean on-ramps from civil (\"naive\") datetimes to\ntime zone aware datetimes. For example, Chrono provides `NaiveDate::succ_opt`\nto get the next day, but this method isn't available on `NaiveDateTime` or\n`DateTime`. Instead, to implement it correctly on `DateTime`, you have to get\nthe naive date, get the date for tomorrow via `succ_opt`, and then convert\nit back to the same `NaiveDateTime` and finally make it time zone aware by\napplying the original time zone to it. In contrast, in Jiff, it's just a matter\nof calling `Zoned::tomorrow`. Indeed, (almost) any method you can call on\n`civil::Date` in Jiff is also available on `civil::DateTime` and likewise for\n`Zoned`. This makes transitioning between datetime types very easy. Chrono\nalmost appears to provide this same experience via traits like `Datelike`,\nbut doesn't fully commit and, in my opinion, the end result has a feeling of\narbitrariness to it.\n* Chrono lacks a standard timestamp type. You can approximate this with a\n`DateTime<Utc>`, but it's a more complicated type that includes a full datetime\nrepresentation. In contrast, Jiff provides a `Timestamp` type for when you just\nwant the number of seconds from the Unix epoch. And then integrates it with the\nrest of the datetime types in a consistent way.\n\n### `time`\n\nMy main gripe with the `time` crate is that it has no [IANA Time Zone Database]\nsupport at all. This means it cannot do DST safe arithmetic. Consequently, it\nemphasizes the use of \"fixed offset\" datetimes in a similar fashion as Chrono,\nexcept `time` does not provide any extension mechanism like a `TimeZone` trait.\nIn my view, fixed offset datetimes are rarely the right thing to use. In my\nopinion, this makes writing correct datetime code with the `time` crate rather\ndifficult. In contrast, Jiff provides full [IANA Time Zone Database] support,\nand it should be very rare to need fixed offset datetimes (although Jiff does\nsupport them via `TimeZone::fixed`).\n\nThe `time` crate also, at present, relies on unsound `libc` APIs for\ndetermining the current time zone offset, but makes them sound by requiring (by\ndefault) that `UtcOffset::current_local_offset` is only called when there is\nonly 1 thread. This is a result of the `libc` APIs accessing the environment\nin a way that is unsynchronized with Rust's standard library access to the\nenvironment. This is likely a temporary limitation, but at time of writing,\nthis state has persisted for quite some time already. In contrast, Jiff detects\nthe current time zone of the platform on its own without use of `libc`, and\nthus sidesteps this issue. (This is also what Chrono does.)\n\nI overall find the API of `time` to be easier to understand than Chrono, likely\nbecause there are fewer generics. But `time` is also supporting a lot less than\nChrono and Jiff (because of the missing time zone support).\n\nAs with Chrono, I've done a\n[more detailed comparison between Jiff and `time`][comparison-time].\n\n### `hifitime`\n\n`hifitime` is more of a specialized datetime library suited to scientific\napplications, and so while Jiff and `hifitime` have overlapping use cases,\n`hifitime` fundamentally has a different target demographic than Jiff. As noted\nin a [comparison between Jiff and `hifitime`][comparison-hifitime], `hifitime`\ndoesn't have any time zone support, but it does support conversions between\nmany different time scales and leap second support. Leap second support, in\nthis context, means that the durations between two points in time take leap\nseconds into account in `hifitime`, but Jiff pretends as if they don't exist.\n\nIn terms of building a new datetime library, I felt like `hifitime` wasn't\nreally targeting the \"general purpose datetime library\" use case that I felt\n`chrono` and `time` were. And so, whether it existed or not didn't really\nimpact whether another _general purpose_ datetime library should be built.\n\n### `icu`\n\n`icu` is, as I understand it, still under construction with respect to datetime\nsupport. For example, it doesn't have [IANA Time Zone Database] support.\nBut, it does support locale aware formatting of datetimes and non-Gregorian\ncalendars.\n\nWhen I started working on Jiff, I didn't have a good understanding of what the\n`icu` crate offers. I still don't really. In part because the API is difficult\nfor me to understand and in part because I haven't dedicated a ton of time to\nstudying its API. But either way, I don't think it is currently in a position\nto be a general purpose datetime library and I wasn't clear on what its goals\nwere.\n\nSince I haven't spent a lot of time with `icu`, I didn't have much to say about\nit in my [comparison with it and Jiff][comparison-icu].\n\n\n## Why not contribute to an existing library instead of building a new one?\n\nGiven that Rust already has at least two prominent datetime libraries, doesn't\nadding another one just make things worse? And why not contribute to an\nexisting library to make it better instead of starting over from scratch?\n\nI first want to say that I acknowledge that throwing a new crate into the\necosystem, and adding yet another choice, does actually come with downsides.\nThere is a cost to having too many choices, and when possible, I do believe it\nis better to improve an existing project rather than start a new one.\n\nImproving existing projects can be difficult. Jiff has a different design than\nboth `chrono` and `time`. Evolving either one of those crates into what Jiff is\nwould, in my view, require a huge amount of resources. Not just in time, but in\nsocial capital as well. Because it wouldn't be greenfield development done by\none person making all of the design choices, but instead someone from outside\nthe project trying to convince the maintainers of established projects to move\nin a radically different direction. I know what it's like to be on the side of\nmaintaining an established API for a library with a lot of users. There is a\nhuge inertial cost to making sweeping API changes.\n\nMoreover, when I started Jiff, I was not a domain expert in datetime libraries\nor datetime handling in general. Therefore, my opinion that `chrono` and `time`\n_could_ be better would arguably not carry a lot of weight. It was only through\nthe process of actually building a datetime library did I learn enough to form\nnuanced opinions about the status quo. When I started, my opinions were much\nmore vague (but still strong enough to start this project).\n\nOn top of all of this, I was _intrinsically_ motivated to work on this problem.\nI found it very interesting, and especially because I perceived there to be a\ngap in the ecosystem that I thought I could fill in. I had a vision for what\na datetime library _should_ look like. And it took a lot of iteration to get\nfrom my initial vision to something that works in practice. Doing this on an\nexisting datetime library with real users would be extremely difficult.\n\nAnd speaking as someone who has had folks publish _better_ versions of some of\nmy own crates, I know what it's like to be on the other end of this. Sometimes\nyou just have to start fresh.\n\n\n## Are there any published alternative perspectives on Rust datetime libraries?\n\nHere's a list. More may be added in the future:\n\n* [Commentary from the original author of the `chrono` crate.][alt1]\n\n[alt1]: https://github.com/BurntSushi/jiff/issues/63\n\n\n## Why are there two duration types?\n\nThe two duration types provided by Jiff are `Span` and `SignedDuration`. A\n`SignedDuration` is effectively identical to a `std::time::Duration`, but it's\nsigned instead of unsigned. A `Span` is also a duration type, but is likely\ndifferent than most other duration types you've used before.\n\nWhile a `SignedDuration` can be thought of as a single integer corresponding\nto the number of nanoseconds between two points in time, a `Span` is a\ncollection of individual unit values that combine to represent the difference\nbetween two point in time. Stated more concretely, while the spans `2\nhours` and `120 minutes` both correspond to the same duration of time, when\nrepresented as a Jiff `Span`, they correspond to two distinct values in\nmemory. This is something that is fundamentally not expressible by a type\nlike `SignedDuration`, where `2 hours` and `120 minutes` are completely\nindistinguishable.\n\nOne of the key advantages of a `Span` is that it can represent units of\nnon-uniform length. For example, not every month has the same number of days,\nbut a `Span` can still represent units of months because it tracks the values\nof each unit independently. For example, Jiff is smart enough to know that the\ndifference between `2024-03-01` and `2024-04-01` is the same number of months\nas `2024-04-01` and `2024-05-01`, even though the number of days is different:\n\n```rust\nuse jiff::{civil::date, ToSpan, Unit};\n\nfn main() -> anyhow::Result<()> {\n    let date1 = date(2024, 3, 1);\n    let date2 = date(2024, 4, 1);\n    let date3 = date(2024, 5, 1);\n\n    // When computing durations between `Date` values,\n    // the spans default to days.\n    assert_eq!(date1.until(date2)?, 31.days());\n    assert_eq!(date2.until(date3)?, 30.days());\n\n    // But we can request bigger units!\n    assert_eq!(date1.until((Unit::Month, date2))?, 1.month());\n    assert_eq!(date2.until((Unit::Month, date3))?, 1.month());\n\n    Ok(())\n}\n```\n\nWhile most folks are very in tune with the fact that years and months have\nnon-uniform length, a less obvious truth is that days themselves also have\nnon-uniform length in the presence of time zones. For example, `2024-03-10` in\n`America/New_York` was only 23 hours long (the region entered daylight saving\ntime, creating a gap in time), while `2024-11-03` was 25 hours long (the region\nleft daylight saving time, creating a fold in time). Being unaware of this\ncorner case leads to folks assuming that \"1 day\" and \"24 hours\" are _always_\nexactly equivalent. But they aren't. The design of Jiff leans into this and\nensures that so long as you're using `Span` to encode a concept of days and are\ndoing arithmetic with it on `Zoned` values, then you can never get it wrong.\nJiff will always take time zones into account when dealing with units of days\nor bigger.\n\nThe design of `Span` comes from [Temporal], which [uses only one duration\ntype][temporal-one-duration]. From that issue, there are some significant\nadvantages to using a `Span`. In my own words:\n\n* It more closely lines up with ISO 8601 durations, which themselves combine\ncalendar and clock units.\n* With a `Span`, it is very easy to move between `5 years 2 months` and\nthe number of hours in that same span.\n* Jiff's `Span` type specifically represents each unit as distinct from the\nothers. In contrast, most absolute duration types (like `std::time::Duration`\nand Jiff's own `SignedDuration`), are \"just\" a 96-bit integer number of\nnanoseconds. This means that, for example, `1 hour 30 minutes` is impossible to\ndifferentiate from `90 minutes`. But depending on the use case, you might want\none or the other. Jiff's `Span` design (copied from Temporal) enables users\nto express durations in whatever units they want. And this expression can be\nmanipulated via APIs like `Span::round` in intuitive ways.\n\nA `SignedDuration` is still useful in some respects. For example, when you\nneed tighter integration with the standard library's `std::time::Duration`\n(since a `SignedDuration` is the same, but just signed), or when you need\nbetter performance than what `Span` gives you. In particular, since a `Span`\nkeeps track of the values for each individual unit, it is a much heavier type\nthan a `SignedDuration`. It uses up more stack space and also required more\ncomputation to do arithmetic with it.\n\n\n## Why isn't there a `TimeZone` trait?\n\nFirst, let's start by explaining what a `TimeZone` is. In Jiff, a `TimeZone`\nis a concrete type that cannot be extended by users of Jiff. Instead, users of\nJiff are forced to use one of three different kinds of time zones:\n\n* A \"fixed offset\" time zone where the civil time for any particular instant\nis computed by simply adding or subtracting a fixed number of seconds from UTC.\nThe `TimeZone::fixed` constructor enables callers to build time zones with any\noffset within the limits imposed by Jiff.\n* A [POSIX time zone][POSIX TZ], typically set via the `TZ` environment\nvariable. These are rarely used by end users, but do provide a way to specify\na rule for when daylight saving time transitions occur thoughtout the year.\n(But it does not support historical transitions that might not conform to the\ncurrent rule.) The `TimeZone::posix` constructor enables callers to build a\n`TimeZone` with a POSIX time zone string.\n* [TZif formatted data][RFC 8536], usually from the\n[IANA Time Zone Database]. This data contains historical time zone transitions\nin addition to rules governing the future in the form of POSIX TZ strings.The\n`TimeZone::tzif` constructor enables callers to build a `TimeZone` with any\nTZif formatted data.\n\nThe `jiff::tz::TimeZoneDatabase` automatically looks for TZif formatted\nfiles in your system's copy of the IANA Time Zone Database, usually at\n`/usr/share/zoneinfo`. (On Windows, Jiff embeds a copy of the IANA Time Zone\nDatabase into the compiled artifact itself.)\n\nSo why isn't `TimeZone` a trait? Well, the above formulation should cover the\n_vast majority_ of use cases. And even if that doesn't cover everything, it\nis possible for callers to use `TimeZone::tzif` to construct arbitrary time\nzones by building their own TZif data. This is a somewhat large hurdle though,\nso if this is something that is commonly needed, I'm open to exploring other\noptions for building custom time zones. For example, perhaps we introduce a way\nto describe time zone transitions in Rust code that can then be used to build a\n`TimeZone` directly. But, the benefit of TZif is that it is inter-operable and\na standard. There are tools that can build them.\n\nAn important thing to note here is that I actually approach questions like\n\"Why isn't `TimeZone` a trait?\" as instead \"Why _should_ `TimeZone` be a trait?\"\nIn particular, I personally perceive costs to introducing generics, especially\non a fundamental type in the crate. For example, if `TimeZone` were a trait,\nthen `Zoned` would not be a concrete type. It would be generic over a type\nparameter that implements the `TimeZone` trait. This in turn implies that\nanyone _using_ a `Zoned` in their own types or APIs needs to think about the\n`TimeZone` trait and likely incorporate it into their own type signatures. This\nis because a `TimeZone` trait implies an open system that infects everything\nit touches. The complexity isn't contained. But a concrete `TimeZone` type,\nlike what Jiff has, encapsulates everything there is about time zones.\n\n(Making `Zoned` generic over a type parameter with a _default_ type does\ncontain the complexity in some cases, but not all. I explored using default\ntype parameters in Jiff for supporting [leap seconds][github-issue-leap], and\nit was overall quite awkward in my opinion.)\n\nThe trade off is that we do give up some flexibility. For example, Chrono uses\na `TimeZone` trait design. This enables external crates to provide their own\nimplementations of the `TimeZone` trait. But the two principle instances of\nthis occurring, `chrono-tz` and `tzfile`, are both supported by Jiff itself.\nWith that said, one key advantage of Chrono's design is that it permits its\nzone aware datetime type (`DateTime<T>`) to be `Copy` if `T` is `Copy`. It is\nsomewhat difficult (although not literally impossible) to make a TZif-backed\ntime zone implement `Copy`, but a _reference_ to it is `Copy` and a reference\nto it can still implement Chrono's `TimeZone` trait. (And indeed, this is what\nthe `tzfile` crate does.) This ultimately leads to more flexibility compared\nto Jiff, where its `Zoned` type embeds a `TimeZone` and a `TimeZone` cannot\neasily be made `Copy` without giving up something else.\n\nMy opinions on the costs of generics tend to overestimate them compared to many\nothers in my experience, so your mileage may vary on where you land on this\nissue. Buy in my opinion, being able to just write `Zoned` as a concrete type\nwithout any generics is a huge win for comprehensibility.\n\n\n## Why doesn't `TimeZone` implement `Copy`?\n\nWhen initially setting out to build Jiff, I _really_ wanted the `TimeZone` type\nto implement `Copy`. The reason why I wanted it to implement `Copy` is because\nI wanted all datetime types to have \"plain old data\" semantics. That is, I want\ncallers to think of them as small immutable bits of data that can be freely\ncopied without worry. This makes APIs a little nicer because you can ask for a\n`Zoned` instead of a `&Zoned`, assuming the `Zoned` type is small enough.\n\nBut, in order for `Zoned` to be `Copy`, it must be the case that `TimeZone` is\n`Copy`. This is because `Zoned` embeds a `TimeZone`. Indeed, this is the reason\nfor its existence: it couples an instant in time with a particular geographic\nregion. This makes it possible to expose very ergonomic high level APIs that\ndon't require the caller to keep passing in a `TimeZone` value repeatedly.\n\nSo, how can a `TimeZone` be `Copy`? Well, both fixed offset and POSIX time\nzones could be `Copy`. There's no huge challenge in that. (Internally, a POSIX\ntime zone is not currently `Copy` because there's no reason for it given what\nwe're about to discuss.) The main challenge is the TZif-backed time zone. TZif\nformatted data can contain an arbitrary number of time zone transitions. There\nis just no way to avoid some kind of dynamic memory allocation.\n\nSince we need dynamic memory allocation, there is really only one way to\nmake it `Copy` at this point: introduce some kind of caching mechanism with\na small `Copy` identifier that lets us \"look up\" the time zone in some kind\nof global or thread-local cache. I thought a lot about how I might wire this\ntogether, and I could not come up with a satisfactory design. I believe\ngarbage collection is the main challenge, but also synchronization overhead\nfor accessing a time zone is likely also a problem. The nice benefit of the\n`TimeZone` type as it exists now is that it's just data. While _getting_ a\n`TimeZone` from a `TimeZoneDatabase` might require synchronization and possibly\neven I/O if the cache for it was invalidated, a `TimeZone` itself requires no\nsynchronization whatsoever to use it. It is just an `Arc` internally to make it\npointer-sized.\n\n\n## Why isn't there a `SystemZoned` type? Or a `OffsetZoned` type?\n\nSome datetime libraries have multiple different zone aware datetime types. Jiff\nopts to have just one, and embeds support for the different types of time zones\nthat most people will ever need into that one type. Jiff does this via the\n`TimeZone` type, which can be a fixed offset, a POSIX time zone or TZif-backed\n(usually from the [IANA Time Zone Database]).\n\n\n## Why doesn't Jiff support leap seconds?\n\nThe short summary is that the use cases for leap second support are rather\nlimited, and the effect they have on overall API complexity is quite large.\nThat is, I believe they would make the API of Jiff more complicated than the\nvalue they bring to the domain.\n\nA standard work-around for _part_ of the leap second problem---and usually the\none people care about---is to use custom TZif data that describes when each of\nthe leap seconds occurs. In effect, you can treat [TAI] as its own time zone.\nThis enables callers to compute accurate durations of time that span a leap\nsecond (positive or negative). And indeed, so long as you build that TZif\ndata, Jiff supports this via `TimeZone::tzif`.\n\nI wrote a lot more [about leap seconds on the issue\ntracker][github-issue-leap].\n\n\n## Why isn't there any integration with `std::time::Duration`?\n\nThe omission of `std::time::Duration` from the `jiff 0.1.0` release was quite\nintentional. Firstly, a `Duration` is an absolute time, meaning there is no way\nto distinguish between `3600 seconds` and `1 hour`. Secondly, a `Duration` is\nunsigned, which makes some API interactions awkward.\n\nIt is likely that there will eventually be at least some integration points\nwith `std::time::Duration`. [This issue][github-issue-duration] discusses some\nof the challenges.\n\n\n## What are the `ZoneDifference` and `ZonedRound` types for?\n\nThe `ZonedDifference` and `ZonedRound` are builders for expressing the\nparameters to the functions `Zoned::{since, until}` and `Zoned::round`,\nrespectively. For example, this:\n\n```rust\nuse jiff::{civil::date, ToSpan};\n\nlet zdt1 = date(2024, 7, 16).at(22, 3, 23, 0).intz(\"America/New_York\")?;\nlet zdt2 = date(2024, 8, 16).at(22, 3, 59, 0).intz(\"America/New_York\")?;\nassert_eq!(zdt1.until(&zdt2)?, 744.hours().seconds(36));\n\n# Ok::<(), Box<dyn std::error::Error>>(())\n```\n\nIs equivalent to:\n\n```rust\nuse jiff::{civil::date, ToSpan, ZonedDifference};\n\nlet zdt1 = date(2024, 7, 16).at(22, 3, 23, 0).intz(\"America/New_York\")?;\nlet zdt2 = date(2024, 8, 16).at(22, 3, 59, 0).intz(\"America/New_York\")?;\nassert_eq!(zdt1.until(ZonedDifference::new(&zdt2))?, 744.hours().seconds(36));\n\n# Ok::<(), Box<dyn std::error::Error>>(())\n```\n\nThe point of this is that `ZonedDifference` permits specifying additional\nconfiguration. For example, rounding the span returned:\n\n```rust\nuse jiff::{civil::date, ToSpan, Unit, ZonedDifference};\n\nlet zdt1 = date(2024, 7, 16).at(22, 3, 23, 0).intz(\"America/New_York\")?;\nlet zdt2 = date(2024, 8, 16).at(22, 3, 59, 0).intz(\"America/New_York\")?;\nassert_eq!(\n    zdt1.until(ZonedDifference::new(&zdt2).smallest(Unit::Minute))?,\n    744.hours(),\n);\n\n# Ok::<(), Box<dyn std::error::Error>>(())\n```\n\nBy using a dedicated type to represent the parameters, we can enable ergonomic\nuses of the API for common cases (by using `From<&Zoned> for ZonedDifference`\ntrait implementations) while still permitting callers to provide additional\nconfiguration.\n\nAn alternative API would be to remove the additional parameters to\n`Zoned::until`, and instead require callers to do span rounding themselves\nexplicitly. But this is more verbose and requires repeating the correct\nzoned datetime to indicate how to interpret non-uniform units. For example,\ninstead of this:\n\n```rust\nuse jiff::{civil::date, ToSpan, Unit, ZonedDifference};\n\nlet zdt1 = date(2024, 7, 16).at(22, 3, 23, 0).intz(\"America/New_York\")?;\nlet zdt2 = date(2024, 8, 16).at(22, 3, 59, 0).intz(\"America/New_York\")?;\nlet diff = ZonedDifference::new(&zdt2)\n    .largest(Unit::Month)\n    .smallest(Unit::Minute);\nassert_eq!(zdt1.until(diff)?, 1.month());\n\n# Ok::<(), Box<dyn std::error::Error>>(())\n```\n\nOne would need to do this:\n\n```rust\nuse jiff::{civil::date, RoundMode, SpanRound, ToSpan, Unit};\n\nlet zdt1 = date(2024, 7, 16).at(22, 3, 23, 0).intz(\"America/New_York\")?;\nlet zdt2 = date(2024, 8, 16).at(22, 3, 59, 0).intz(\"America/New_York\")?;\nlet span = zdt1.until(&zdt2)?;\nlet rounded = span.round(\n    SpanRound::new()\n        .largest(Unit::Month)\n        .smallest(Unit::Minute)\n        .relative(&zdt1)\n        .mode(RoundMode::Trunc),\n)?;\nassert_eq!(rounded, 1.month());\n\n# Ok::<(), Box<dyn std::error::Error>>(())\n```\n\nThis is somewhat fiddly and easy to get wrong. Moreover, the `Zoned::until`\nAPI, when rounding is enabled, will automatically use `RoundMode::Trunc`, since\nthis is what usually expects when computing the span between two datetimes. But\nspan rounding uses `RoundMode::HalfExpand` by default, corresponding to how you\nwere likely taught to round in school. (Rounds to the nearest unit, with ties\nbreaking away from zero.)\n\nSimilar reasoning applies to other \"parameter builder\" types like\n`civil::DateTimeDifference` as well.\n\n\n## Why isn't `Timestamp` called `Instant`?\n\nThe main reason why is because of the existence of `std::time::Instant`. While\nthat doesn't in and of itself prevent Jiff from using the name `Instant`, it\ncreates a naming clash with something that is _similar_ but different. Namely,\na Jiff `Timestamp` corresponds to a time from your system clock, where as an\n`Instant` represents _monotonic_ time. The system clock might change or even\ngo backwards, where as a monotonic instant will always produce time that is\ngreater than or equal to a previous time.\n\nAn `Instant` is, for example, something you might use to measure the time\nsomething takes in a program. Like in capturing a measurement for a benchmark.\nConversely, a `Timestamp` is something you use to represent time as represented\nby the system. In particular, a `Timestamp` is like a `std::time::SystemTime`\nand _not_ a `std::time::Instant`.\n\nWhile [Temporal] uses the name `Instant` for their equivalent of Jiff's\n`Timestamp` type, using the name `Instant` in Jiff would likely result in\nserious confusion and conflicts in names when someone wants to use both an\n`Instant` and a `Timestamp` in the same namespace.\n\n[Temporal]: https://tc39.es/proposal-temporal/docs/\n[temporal-one-duration]: https://github.com/tc39/proposal-temporal/issues/2915\n[comparison]: http://docs.rs/jiff/*/jiff/_documentation/comparison/index.html\n[comparison-chrono]: https://docs.rs/jiff/*/jiff/_documentation/comparison/index.html#chrono-v0438\n[comparison-time]: https://docs.rs/jiff/*/jiff/_documentation/comparison/index.html#time-v0336\n[comparison-hifitime]: https://docs.rs/jiff/*/jiff/_documentation/comparison/index.html#hifitime-v0390\n[comparison-icu]: https://docs.rs/jiff/*/jiff/_documentation/comparison/index.html#icu-v150\n[RFC 8536]: https://datatracker.ietf.org/doc/draft-murchison-rfc8536bis/\n[RFC 9557]: https://datatracker.ietf.org/doc/rfc9557/\n[POSIX TZ]: https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html\n[IANA Time Zone Database]: https://en.wikipedia.org/wiki/Tz_database\n[TAI]: https://en.wikipedia.org/wiki/International_Atomic_Time\n[github-issue-duration]: https://github.com/BurntSushi/jiff/issues/21\n[github-issue-leap]: https://github.com/BurntSushi/jiff/issues/7\n[`java.time`]: https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\n[NodaTime]: https://nodatime.org/\n[`chrono-tz`]: https://docs.rs/chrono-tz\n[`tzfile`]: https://docs.rs/tzfile\n[`chrono`]: https://docs.rs/chrono\n[`time`]: https://docs.rs/time\n[`hifitime`]: https://docs.rs/hifitime\n[`icu`]: https://docs.rs/icu\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Andrew Gallant\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "PLATFORM.md",
          "type": "blob",
          "size": 15.69921875,
          "content": "# Platform support\n\nThis document describes Jiff's platform support. That is, it describes the\ninteraction points between this library and its environment. Most of the\ndetails in this document are written down elsewhere on individual APIs, but\nthis document serves to centralize everything in one place.\n\nAs a general rule, interaction with the environment requires that Jiff's\n`std` feature is enabled. The `std` feature is what allows Jiff to read\nenvironment variables and files, for example.\n\nBefore starting, let's cover some vocabulary first.\n\n## Vocabulary\n\nThis section defines the key terms used below when describing platform support.\nWe also try to contextualize the concepts to make their meaning concrete in a\nway that hopefully relates to your lived experience.\n\n* [Civil time]: The time you see on your clock. And in general, the time that\nthe humans in your approximate geographic vicinity also see. That is, civil\ntime is a human coordinated agreement for communicating time in a particular\ngeographic region. Civil time is also known as: local time, plain time, naive\ntime, clock time and others.\n* [Time zone]: A set of rules for determining the civil (or \"local\") time,\nvia an offset from UTC, in a particular geographic region. In many cases, the\noffset in a particular time zone can vary over the course of a year through\ntransitions into and out of [daylight saving time]. A time zone is necessary\nto convert civil time into a precise unambiguous instant in time.\n* [IANA Time Zone Database]: A directory on your system containing a store of\nfiles, one per time zone, which encode the time at which transitions between\nUTC offsets occur in a specific geographic region. In effect, each time zone\nfile provides a mapping between civil (or \"local\") time and UTC. The format\nof each file is called TZif and is specified by [RFC 8536]. This database is\ntypically found at `/usr/share/zoneinfo` and only on Unix systems (including\nmacOS). Other environments, like Windows and WASM, do not have a standard copy\nof the Time Zone Database. (Jiff will instead embed it into your program by\ndefault on these platforms.)\n* [IANA time zone identifier]: A short ASCII human readable string identifying\na time zone in the IANA Time Zone Database. The time zone for where I live,\n`America/New_York`, has an entry at `/usr/share/zoneinfo/America/New_York`\non my system. IANA time zone identifiers are used by Jiff's `Zoned` type\nto losslessly roundtrip datetimes via an interchange format specified by\n[Temporal] that draws inspiration from [RFC 3339], [RFC 9557] and [ISO 8601].\n\n## Environment variables\n\nJiff reads exactly two environment variables. These variables are read on\nall platforms that support environment variables. So for example, Jiff\nwill respect `TZ` on Windows. Note though that some environments, like\n`wasm32-wasip1` or `wasm32-unknown-emscripten`, are sandboxed by default. A\nsandboxed environment typically makes reading environment variables set outside\nthe sandbox impossible (or require opt-in support, such as [wasmtime]'s `-S\ninherit-env` or `--env` flags).\n\n### `TZDIR`\n\nThe `TZDIR` environment variable tells Jiff where to look for the\n[IANA Time Zone Database]. When it isn't set, Jiff will check a few standard\nlocations for the database. It's usually found at `/usr/share/zoneinfo`.\n\nIt can be useful to set this for non-standard environments or when you\nspecifically want Jiff to prefer using a non-system copy of the database.\n(If you want Jiff to _only_ use a non-system copy of the database, then you'll\nneed to use `TimeZoneDatabase::from_dir` and use the resulting handle\nexplicitly.)\n\nIf a IANA Time Zone Database could not be found a `TZDIR`, then Jiff will\nstill attempt to look for a database at the standard locations (like\n`/usr/share/zoneinfo`).\n\n### `TZ`\n\nThe `TZ` environment variable overrides and sets the default system time zone.\nIt is [specified by POSIX][POSIX TZ]. Jiff implements the POSIX specification\n(even on non-POSIX platforms like Windows) with some common extensions.\n\nIt is useful to set `TZ` when Jiff could not detect (or had a problem\ndetecting) the system time zone, or if the system time zone is wrong in a\nspecific circumstance.\n\nSummarizing POSIX (and common extensions supported by GNU libc and musl), the\n`TZ` environment variable accepts these kinds of values:\n\n* `America/New_York` sets the time zone via a IANA time zone identifier.\n* `/usr/share/zoneinfo/America/New_York` sets the time zone by providing a path\nto a TZif formatted file.\n* `EST5EDT,M3.2.0,M11.1.0` sets the time zone using a POSIX daylight saving\ntime rule. The rule shown here is for `US/Eastern` at time of writing (2024).\nThis is useful for specifying a custom time zone with generating TZif data,\nbut is rarely used in practice.\n\nWhen `TZ` isn't set, then Jiff uses heuristics to detect the system's\nconfigured time zone. If this automatic detection fails, please first check\nfor an [existing issue for your platform][issue-platform], and if one doesn't\nexist, please [file a new issue][issue-new]. Otherwise, setting `TZ` should be\nconsidered as a work-around.\n\n## Platforms\n\nThis section lists the platforms that Jiff has explicit support for. Support\nmay not be perfect, so if something isn't working as it should, check the\nlist of [existing platform related issues][issue-platform]. If you can't find\none that matches your specific problem, [create a new issue][issue-new].\n\nFor each platform, there are generally three things to consider:\n\n1. Whether getting the current time is supported.\n2. How Jiff finds the IANA Time Zone Database.\n3. How Jiff finds the system configured time zone.\n\nWe answer these questions for each platform.\n\n### Unix\n\n#### Current time\n\nAll Unix platforms should be supported in terms of getting the current time.\nThis support comes from Rust's standard library.\n\n#### IANA Time Zone Database\n\nThe vast majority of Unix systems, including macOS, store a copy of the IANA\ntime zone database at `/usr/share/zoneinfo`, which Jiff will automatically\ndetect. If your Unix system uses a different directory, you may try to submit\na PR adding support for it in Jiff proper, or just set the `TZDIR` environment\nvariable.\n\nThe existence of `/usr/share/zoneinfo` is not guaranteed in all Unix environments.\nFor example, stripped down Docker containers might omit a full copy of the\ntime zone database. Jiff will still work in such environments, but all IANA\ntime zone identifier lookups will fail. To fix this, you can either install the\nIANA Time Zone Database into your environment, or you can enable the Jiff\ncrate feature `tzdb-bundle-always`. This compile time setting will cause Jiff\nto depend on `jiff-tzdb`, which includes a complete copy of the IANA Time Zone\nDatabase embedded into the compiled artifact.\n\nBundling the IANA Time Zone Database should only be done as a last resort.\nEspecially on Unix systems, it is greatly preferred to use the system copy of\nthe database, as the database is typically updated a few times each year. By\nusing the system copy, Jiff will automatically pick up updates without needing\nto be recompiled.\n\nBut if bundling is needed, it is a fine solution. It just means that Jiff will\nneed to be re-compiled after `jiff-tzdb` is updated when a new IANA Time Zone\nDatabase release is published.\n\n#### System time zone\n\nOn most Unix systems, the system configured time zone manifests as a symbolic\nlink at `/etc/localtime`. The symbolic link usually points to a file in\nyour system copy of the IANA Time Zone Database. For example, on my Linux\nsystem:\n\n```text\n$ ls -l /etc/localtime\nlrwxrwxrwx 1 root root 36 Jul 15 20:26 /etc/localtime -> /usr/share/zoneinfo/America/New_York\n```\n\nAnd my macOS system:\n\n```text\n$ ls -l /etc/localtime\nlrwxr-xr-x  1 root  wheel  42 Jun 20 07:13 /etc/localtime -> /var/db/timezone/zoneinfo/America/New_York\n```\n\nJiff examines the symbolic link metadata to extract the IANA time zone\nidentifier from the file path. In the above two examples, that would be\n`America/New_York`. The identifier is then used to do a lookup in the system\ncopy of the IANA Time Zone Database.\n\nIf `/etc/localtime` is not a symbolic link, then Jiff reads it directly as a\nTZif file. When this happens, Jiff cannot feasibly know the IANA time zone\nidentifier. While arithmetic on the resulting `Zoned` value will still be DST\nsafe, one cannot losslessly serialize and deserialize it since Jiff won't be\nable to include the IANA time zone identifier in the serialized format. When\nsuch a `Zoned` value is serialized, the offset of the datetime will be used\nin lieu of the IANA time zone identifier.\n\n(NOTE: Not all Unix systems follow this pattern. If your system uses a\ndifferent way to configure the system time zone, please check [available\nplatform issues][issue-platform] for a related issue. If one doesn't exist,\nplease [create a new issue][issue-new].)\n\n### Windows\n\n#### Current time\n\nAll Windows platforms should be supported in terms of getting the current time.\nThis support comes from Rust's standard library.\n\n#### IANA Time Zone Database\n\nWindows does not have a canonical installation of the IANA Time Zone Database\nlike Unix. Because of this, and because of the importance of time zone support\nto Jiff's design, Jiff will automatically embed an entire copy of the IANA Time\nZone Database into your binary on Windows.\n\nThe automatic bundling is done via the Jiff crate feature\n`tzdb-bundle-platform`. This is a _target activated feature_. Namely, it is\nenabled by default, but only results in a bundled database on an enumerated set\nof platforms (where Windows is one of them). If you want to opt out of bundling\nthe database on Windows, you'll need to disable this feature.\n\nBundling the IANA Time Zone Database is not ideal, since after a new release of\nthe database, you'll need to wait for the `jiff-tzdb` crate to be updated. Then\nyou'll need to update your dependency version and re-compile your software to\nget the database updates.\n\nOne alternative is to point Jiff to a copy of the IANA Time Zone Database via\nthe `TZDIR` environment variable. Even on Windows, Jiff will attempt to read\nthe directory specified as a time zone database. But you'll likely need to\nmanage the database yourself.\n\n#### System time zone\n\nJiff currently uses [`GetDynamicTimeZoneInformation`] from the Windows C API\nto query the current time zone information. This provides a value of type\n[`DYNAMIC_TIME_ZONE_INFORMATION`]. Jiff uses the `TimeZoneKeyName` member\nof that type to do a lookup in Unicode's [CLDR XML data] that maps Windows\ntime zone names to IANA time zone identifiers. The resulting IANA time zone\nidentifier is then used as a key to find a time zone in the configured IANA\nTime Zone Database.\n\n### WASM\n\nThere are a variety of WASM targets available for Rust that service different\nuse cases. Here is a possibly incomplete list of those targets and a short\nimprecise blurb about them:\n\n* `wasm32-unknown-emscripten`: Sandboxed and emulates Unix as much as possible.\n* `wasm32-wasi` and `wasm32-wasip1`: Provides a sandbox with capability-based\nsecurity. This is not typically used in web browsers. [wasmtime] is an example\nof a runtime that can run programs compiled for these targets.\n* `wasm{32,64}-unknown-unknown`: Typically used for web deployments to run in\na browser via `wasm-pack`. But, crucially, not exclusively so.\n\nJiff supports all of these targets, but the nature of that support varies. Each\ntarget is discussed in the sections below.\n\n#### The `js` crate feature\n\nJiff comes with a `js` crate feature that is disabled by default. It is a\n_target activated feature_ that enables dependencies on the `js-sys` and\n`wasm-bindgen` crates. This feature is intended to be enabled only in binaries,\ntests and benchmarks when it is known that the code will be running in a\nweb context. Consequently, this feature only activates this support for the\n`wasm{32,64}-unknown-unknown` targets. It has no effect on any other target,\nincluding other WASM targets.\n\nLibrary crates should generally never enable Jiff's `js` feature or even\nforward it. Applications using your library can depend on Jiff directly and\nenable the feature.\n\n#### Current time\n\n* `wasm32-unknown-emscripten`: Supported via Rust's standard library.\n* `wasm32-wasi*`: Supported via Rust's standard library.\n* `wasm{32,64}-unknown-unknown`: `std::time::SystemTime::now()`, and thus\n`Zoned::now()`, panics in Jiff's default configuration. Enabling Jiff's `js`\nfeature will cause Jiff to assume a web context and use JavaScript's\n[`Date.now`] API to determine the current time.\n\n#### IANA Time Zone Database\n\nNone of the WASM targets have a canonical installation of the IANA Time Zone\nDatabase. Because of this, and because of the important of time zone support\nto Jiff's design, Jiff will automatically embed an entire copy of the IANA\nTime Zone Database into your binary on all WASM targets.\n\nThe automatic bundling is done via the Jiff crate feature\n`tzdb-bundle-platform`. This is a _target activated feature_. Namely, it is\nenabled by default, but only results in a bundled database on an enumerated set\nof platforms (where WASM is one of them). If you want to opt out of bundling\nthe database on WASM targets, you'll need to disable this feature.\n\nBundling the IANA Time Zone Database is not ideal, since after a new release of\nthe database, you'll need to wait for the `jiff-tzdb` crate to be updated. Then\nyou'll need to update your dependency version and re-compile your software to\nget the database updates.\n\nSome WASM targets, like `wasm32-wasip1`, can actually read the host's\nIANA Time Zone Database (e.g., on Unix), but this requires relaxing its\nsandbox restrictions so that the code can read system directories like\n`/usr/share/zoneinfo`. That is, it won't work out of the box. The same applies\nto the `wasm32-unknown-emscripten` target. (Although this author could not\nfigure out how to relax emscripten's sandbox.)\n\n#### System time zone\n\n* `wasm32-unknown-emscripten`: Unsupported.\n* `wasm32-wasi*`: Unsupported. But you may set the `TZ` environment variable\nvia your WASM runtime, and Jiff will respect it. For example, with [wasmtime],\nthat's `--env TZ=America/New_York`.\n* `wasm{32,64}-unknown-unknown`: Unsupported in Jiff's default configuration.\nEnabling Jiff's `js` feature will cause Jiff to assume a web context and use\nJavaScript's [`Intl.DateTimeFormat`] API to determine the system configured\nIANA time zone identifier. This time zone identifier is then used to look up\nthe time zone in Jiff's configured IANA Time Zone Database.\n\n[Civil time]: https://en.wikipedia.org/wiki/Civil_time\n[Time zone]: https://en.wikipedia.org/wiki/Time_zone\n[daylight saving time]: https://en.wikipedia.org/wiki/Daylight_saving_time\n[IANA Time Zone Database]: https://en.wikipedia.org/wiki/Tz_database\n[IANA time zone identifier]: https://data.iana.org/time-zones/theory.html#naming\n[RFC 8536]: https://datatracker.ietf.org/doc/html/rfc8536\n[wasmtime]: https://wasmtime.dev/\n[POSIX TZ]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html\n[RFC 3339]: https://www.rfc-editor.org/rfc/rfc3339\n[RFC 9557]: https://www.rfc-editor.org/rfc/rfc9557.html\n[ISO 8601]: https://www.iso.org/iso-8601-date-and-time-format.html\n[Temporal]: https://tc39.es/proposal-temporal\n[issue-platform]: https://github.com/BurntSushi/jiff/labels/platform\n[issue-new]: https://github.com/BurntSushi/jiff/issues/new\n[`GetDynamicTimeZoneInformation`]: https://learn.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-getdynamictimezoneinformation\n[`DYNAMIC_TIME_ZONE_INFORMATION`]: https://learn.microsoft.com/en-us/windows/win32/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information\n[CLDR XML data]: https://github.com/unicode-org/cldr/raw/main/common/supplemental/windowsZones.xml\n[`Intl.DateTimeFormat`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/resolvedOptions#timezone\n[`Date.now`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.2802734375,
          "content": "Jiff\n====\nJiff is a datetime library for Rust that encourages you to jump into the\npit of success. The focus of this library is providing high level datetime\nprimitives that are difficult to misuse and have reasonable performance. Jiff\nsupports automatic and seamless integration with the Time Zone Database, DST\naware arithmetic and rounding, formatting and parsing zone aware datetimes\nlosslessly, opt-in Serde support and a whole lot more.\n\nJiff takes enormous inspiration from [Temporal], which is a [TC39] proposal to\nimprove datetime handling in JavaScript.\n\n[![Build status](https://github.com/BurntSushi/jiff/workflows/ci/badge.svg)](https://github.com/BurntSushi/jiff/actions)\n[![Crates.io](https://img.shields.io/crates/v/jiff.svg)](https://crates.io/crates/jiff)\n[![Docs.rs](https://img.shields.io/docsrs/jiff)](https://docs.rs/jiff)\n\nDual-licensed under MIT or the [UNLICENSE](https://unlicense.org/).\n\n[TC39]: https://tc39.es/\n[Temporal]: https://tc39.es/proposal-temporal/docs/index.html\n\n### Documentation\n\n* [API documentation on docs.rs](https://docs.rs/jiff)\n* [Comparison with `chrono`, `time`, `hifitime` and `icu`](COMPARE.md)\n* [The API design rationale for Jiff](DESIGN.md)\n* [Platform support](PLATFORM.md)\n* [CHANGELOG](CHANGELOG.md)\n\n### Example\n\nHere is a quick example that shows how to parse a typical RFC 3339 instant,\nconvert it to a zone aware datetime, add a span of time and losslessly print\nit:\n\n```rust\nuse jiff::{Timestamp, ToSpan};\n\nfn main() -> Result<(), jiff::Error> {\n    let time: Timestamp = \"2024-07-11T01:14:00Z\".parse()?;\n    let zoned = time.intz(\"America/New_York\")?.checked_add(1.month().hours(2))?;\n    assert_eq!(zoned.to_string(), \"2024-08-10T23:14:00-04:00[America/New_York]\");\n    // Or, if you want an RFC3339 formatted string:\n    assert_eq!(zoned.timestamp().to_string(), \"2024-08-11T03:14:00Z\");\n    Ok(())\n}\n```\n\nThere are many more examples in the [documentation](https://docs.rs/jiff).\n\n### Usage\n\nJiff is [on crates.io](https://crates.io/crates/jiff) and can be\nused by adding `jiff` to your dependencies in your project's `Cargo.toml`.\nOr more simply, just run `cargo add jiff`.\n\nHere is a complete example that creates a new Rust project, adds a dependency\non `jiff`, creates the source code for a simple datetime program and then runs\nit.\n\nFirst, create the project in a new directory:\n\n```text\n$ cargo new jiff-example\n$ cd jiff-example\n```\n\nSecond, add a dependency on `jiff`:\n\n```text\n$ cargo add jiff\n```\n\nThird, edit `src/main.rs`. Delete what's there and replace it with this:\n\n```rust\nuse jiff::{Unit, Zoned};\n\nfn main() -> Result<(), jiff::Error> {\n    let now = Zoned::now().round(Unit::Second)?;\n    println!(\"{now}\");\n    Ok(())\n}\n```\n\nFourth, run it with `cargo run`:\n\n```text\n$ cargo run\n   Compiling jiff v0.1.0 (/home/andrew/rust/jiff)\n   Compiling jiff-play v0.1.0 (/home/andrew/tmp/scratch/rust/jiff-play)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.37s\n     Running `target/debug/jiff-play`\n2024-07-10T19:54:20-04:00[America/New_York]\n```\n\nThe first time you run the program will show more output like above. But\nsubsequent runs shouldn't have to re-compile the dependencies.\n\n### Crate features\n\nJiff has several crate features for customizing support for Rust's standard\nlibrary, `serde` support and whether to embed a copy of the Time Zone Database\ninto your binary.\n\nThe \"[crate features](https://docs.rs/jiff/#crate-features)\" section of the\ndocumentation lists the full set of supported features.\n\n### Future plans\n\nMy plan is to iterate on the Jiff API and make occasional breaking change\nreleases over the next ~year. Assuming API breaking changes have settled down\nafter about one year's time, my plan will be to release Jiff 1.0 and commit to\nthe API for a long period of time. (Measured, at least, in years.)\n\nThe purpose of this plan is to get Jiff to a 1.0 stable state as quickly as\npossible. The reason is so that others feel comfortable relying on Jiff as\na public dependency that won't cause ecosystem churn.\n\n### Performance\n\nThe most important design goal of Jiff is to be a high level datetime library\nthat makes it hard to do the wrong thing. Second to that is performance. Jiff\nshould have reasonable performance, but there are likely areas in which it\ncould improve. See the `bench` directory for benchmarks.\n\n### Platform support\n\nThe question of platform support in the context of datetime libraries comes up\nprimarily in relation to time zone support. Specifically:\n\n* How should Jiff determine the time zone transitions for an IANA time zone\nidentifier like `Antarctica/Troll`?\n* How should Jiff determine the default time zone for the current system?\n\nBoth of these require some level of platform interaction.\n\nFor discovering time zone transition data, Jiff relies on the\n[IANA Time Zone Database]. On Unix systems, this is usually found at\n`/usr/share/zoneinfo`, although it can be configured via the `TZDIR`\nenvironment variable (which Jiff respects). On Windows, Jiff will automatically\nembed a copy of the time zone database into the compiled library.\n\nFor discovering the system time zone, Jiff reads `/etc/localtime` on Unix. On\nWindows, Jiff reads the Windows-specific time zone identifier via\n[`GetDynamicTimeZoneInformation`] and then maps it to an IANA time zone\nidentifier via Unicode's [CLDR XML data].\n\nI expect Jiff to grow more support for other platforms over time. Please file\nissues, although I will likely be reliant on contributor pull requests for more\nobscure platforms that aren't easy for me to test.\n\nFor more on platform support, see [`PLATFORM.md`](PLATFORM.md).\n\n[IANA Time Zone Database]: https://en.wikipedia.org/wiki/Tz_database\n[`GetDynamicTimeZoneInformation`]: https://learn.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-getdynamictimezoneinformation\n[CLDR XML data]: https://github.com/unicode-org/cldr/raw/main/common/supplemental/windowsZones.xml\n\n### Dependencies\n\nAt time of writing, it is no accident that Jiff has zero dependencies on Unix.\nIn general, my philosophy on adding new dependencies in an ecosystem crate like\nJiff is very conservative. I consider there to be two primary use cases for\nadding new dependencies:\n\n1. When a dependency is _practically_ required in order to interact with a\nplatform. For example, `windows-sys` for discovering the system time zone on\nWindows.\n2. When a dependency is necessary for inter-operability. For example, `serde`.\nBut even here, I expect to be conservative, where I'm generally only willing\nto depend on things that have fewer breaking change releases than Jiff.\n\nA secondary use case for new dependencies is if Jiff gets split into multiple\ncrates. I did a similar thing for the `regex` crate for very compelling\nreasons. It is possible that will happen with Jiff as well, although there are\nno plans for that. And in general, I expect the number of crates to stay small,\nif only to make keep maintenance lightweight. (Managing lots of semver API\nboundaries has a lot of overhead in my experience.)\n\n### Minimum Rust version policy\n\nThis crate's minimum supported `rustc` version is `1.70.0`.\n\nThe policy is that the minimum Rust version required to use this crate can be\nincreased in minor version updates. For example, if jiff 1.0 requires Rust\n1.20.0, then jiff 1.0.z for all values of `z` will also require Rust 1.20.0 or\nnewer. However, jiff 1.y for `y > 0` may require a newer minimum version of\nRust.\n"
        },
        {
          "name": "UNLICENSE",
          "type": "blob",
          "size": 1.1826171875,
          "content": "This is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "jiff-cli",
          "type": "tree",
          "content": null
        },
        {
          "name": "jiff-tzdb-platform",
          "type": "tree",
          "content": null
        },
        {
          "name": "jiff-tzdb",
          "type": "tree",
          "content": null
        },
        {
          "name": "jiff-wasm",
          "type": "tree",
          "content": null
        },
        {
          "name": "rustfmt.toml",
          "type": "blob",
          "size": 0.04296875,
          "content": "max_width = 79\nuse_small_heuristics = \"max\"\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "blob",
          "size": 2.810546875,
          "content": "#!/bin/bash\n\nset -e\n\n# cd to the directory containing this crate's Cargo.toml so that we don't need\n# to pass --manifest-path to every `cargo` command.\ncd \"$(dirname \"$0\")\"\n\n# This is a convenience script for running a broad swath of tests across\n# features. We don't test the complete space, since the complete space is quite\n# large.\necho \"===== DEFAULT FEATURES =====\"\ncargo test\n\n# This one is useful because sometimes the bundled time zone database can\n# behave differently than the system time zone database depending on the\n# inputs. For example, the bundled database uses as few transitions as possible\n# (this is tzdb's \"slim\" data model) and thus relies more heavily on POSIX\n# time zone strings. So if there's a bug in POSIX time zone handling, you're\n# likely to see it with the bundled database while missing it completely with\n# the system database.\necho \"===== WITH ONLY THE BUNDLED TIME ZONE DATABASE =====\"\ncargo test --no-default-features --features std,tz-system,tzdb-bundle-always\n\n# We test core-only mode specially. Sadly, in core-only mode, error messages\n# are quite a bit worse. And this wreaks havoc with Jiff's snapshot tests on\n# error messages. We could `cfg` all of them, but that's a huge pain and it's\n# not clear that it's worth it.\n#\n# Since we use snapshot tests for more than error messages, this technique also\n# risks accidentally passing a test that doesn't involve error messages. Sigh.\n# We accept this risk because this still runs a lot of tests, and the tests\n# that aren't covered are run in other configurations. Still, it's not ideal.\necho \"===== CORE ONLY =====\"\ncargo build --no-default-features\nINSTA_FORCE_PASS=1 INSTA_UPDATE=no cargo test --lib --no-default-features\nINSTA_FORCE_PASS=1 INSTA_UPDATE=no cargo test --test integration --no-default-features\n\n# More core-only tests, when combined with compatible features.\nfeatures=(\n    \"serde\"\n    \"logging\"\n    \"serde logging\"\n)\nfor f in \"${features[@]}\"; do\n    echo \"===== COREONLY PLUS '$f' =====\"\n    cargo build --no-default-features --features \"$f\"\n    INSTA_FORCE_PASS=1 INSTA_UPDATE=no cargo test --lib --no-default-features --features \"$f\"\n    INSTA_FORCE_PASS=1 INSTA_UPDATE=no cargo test --test integration --no-default-features --features \"$f\"\ndone\n\nfeatures=(\n    \"alloc\"\n    \"alloc tzdb-bundle-always\"\n    \"alloc serde\"\n    \"std\"\n    \"std tzdb-bundle-platform tzdb-bundle-always\"\n    \"std tzdb-bundle-platform tzdb-bundle-always tzdb-zoneinfo\"\n    \"std tzdb-bundle-platform tzdb-zoneinfo\"\n    \"std tzdb-bundle-always tzdb-zoneinfo\"\n    \"std tzdb-bundle-always logging\"\n    \"std tzdb-bundle-always serde\"\n)\nfor f in \"${features[@]}\"; do\n    echo \"===== FEATURES: '$f' =====\"\n    cargo build --no-default-features --features \"$f\"\n    cargo test --lib --no-default-features --features \"$f\"\n    cargo test --test integration --no-default-features --features \"$f\"\ndone\n"
        },
        {
          "name": "test-wasm",
          "type": "blob",
          "size": 0.681640625,
          "content": "#!/bin/sh\n\nif [ $# = 0 ]; then\n  echo \"Usage: ./test-wasm <cargo command>\" >&2\n  echo \"Example: ./test-wasm cargo test --lib -- --nocapture\" >&2\n  exit 1\nfi\nif ! command -V rustup &> /dev/null; then\n  echo 'please install rustup' >&2\n  exit 1\nfi\nif ! rustup target list | grep installed | grep -q wasm32-wasip1; then\n  echo 'please run `rustup target add wasm32-wasip1` first' >&2\n  exit 1\nfi\n\nexport WASMTIME_BACKTRACE_DETAILS=1\nexport CARGO_BUILD_TARGET=wasm32-wasip1\n# Not sure exactly why this is needed, but without it,\n# `insta` tries to run `cargo`, and wasip1 doesn't like that.\nexport INSTA_WORKSPACE_ROOT=\"$PWD\"\nexport CARGO_TARGET_WASM32_WASIP1_RUNNER=\"wasmtime run -S inherit-env\"\n\"$@\"\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}