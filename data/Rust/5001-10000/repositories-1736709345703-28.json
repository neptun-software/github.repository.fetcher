{
  "metadata": {
    "timestamp": 1736709345703,
    "page": 28,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "johnthagen/min-sized-rust",
      "stars": 8445,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.0380859375,
          "content": "root = true\n\n[*]\nmax_line_length = 100\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0634765625,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0234375,
          "content": "/target\n**/*.rs.bk\n.idea"
        },
        {
          "name": "Cargo.lock",
          "type": "blob",
          "size": 0.1416015625,
          "content": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\n[[package]]\nname = \"min-sized-rust\"\nversion = \"0.1.0\"\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.400390625,
          "content": "[package]\nname = \"min-sized-rust\"\nversion = \"0.1.0\"\nedition = \"2021\"\nlicense-file = \"LICENSE.txt\"\n\n[dependencies]\n\n[profile.release]\nopt-level = \"z\"     # Optimize for size.\nlto = true          # Enable Link Time Optimization\ncodegen-units = 1   # Reduce number of codegen units to increase optimizations.\npanic = \"abort\"     # Abort on panic\nstrip = true        # Automatically strip symbols from the binary.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0341796875,
          "content": "Copyright (c) 2018-2022 John Hagen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.001953125,
          "content": "# Minimizing Rust Binary Size\n\n[![GitHub Actions][github-actions-badge]](https://github.com/johnthagen/min-sized-rust/actions)\n\n[github-actions-badge]: https://github.com/johnthagen/min-sized-rust/workflows/build/badge.svg\n\nThis repository demonstrates how to minimize the size of a Rust binary.\n\nBy default, Rust optimizes for execution speed, compilation speed, and ease of debugging\nrather than binary size, since for the vast majority of applications this is ideal. But\nfor situations where a developer wants to optimize for binary size instead, Rust provides\nmechanisms to accomplish this.\n\n# Build in Release Mode\n\n![Minimum Rust: 1.0](https://img.shields.io/badge/Minimum%20Rust%20Version-1.0-brightgreen.svg)\n\nBy default, `cargo build` builds the Rust binary in debug mode. Debug mode disables many\noptimizations, which helps debuggers (and IDEs that run them) provide a better debugging\nexperience. Debug binaries can be 30% or more larger than release binaries.\n\nTo minimize binary size, build in release mode:\n\n```bash\n$ cargo build --release\n```\n\n# `strip` Symbols from Binary\n\n![OS: *nix](https://img.shields.io/badge/OS-*nix-brightgreen.svg)\n![Minimum Rust: 1.59](https://img.shields.io/badge/Minimum%20Rust%20Version-1.59-brightgreen.svg)\n\nBy default on Linux and macOS, symbol information is included in the compiled `.elf` file. This\ninformation is not needed to properly execute the binary.\n\nCargo can be configured to\n[automatically `strip` binaries](https://doc.rust-lang.org/cargo/reference/profiles.html#strip).\nModify `Cargo.toml` in this way:\n\n```toml\n[profile.release]\nstrip = true  # Automatically strip symbols from the binary.\n```\n\n**Prior to Rust 1.59**, run [`strip`](https://linux.die.net/man/1/strip) directly on\nthe `.elf` file instead:\n\n```bash\n$ strip target/release/min-sized-rust\n```\n\n# Optimize For Size\n\n![Minimum Rust: 1.28](https://img.shields.io/badge/Minimum%20Rust%20Version-1.28-brightgreen.svg)\n\n[Cargo defaults its optimization level to `3` for release builds][cargo-profile],\nwhich optimizes the binary for **speed**. To instruct Cargo to optimize for minimal binary\n**size**, use the `z` optimization level in\n[`Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html):\n\n[cargo-profile]: https://doc.rust-lang.org/cargo/reference/profiles.html#default-profiles\n\n```toml\n[profile.release]\nopt-level = \"z\"  # Optimize for size.\n```\n\n> [!NOTE]\n> In some cases the `\"s\"` level may result in a smaller binary than `\"z\"`, as explained in the\n> [`opt-level` documentation](https://doc.rust-lang.org/cargo/reference/profiles.html#opt-level):\n> \n> It is recommended to experiment with different levels to find the right balance for your project.\n> There may be surprising results, such as ... the `\"s\"` and `\"z\"` levels not being necessarily\n> smaller.\n\n# Enable Link Time Optimization (LTO)\n\n![Minimum Rust: 1.0](https://img.shields.io/badge/Minimum%20Rust%20Version-1.0-brightgreen.svg)\n\nBy default,\n[Cargo instructs compilation units to be compiled and optimized in isolation][cargo-profile].\n[LTO](https://llvm.org/docs/LinkTimeOptimization.html) instructs the linker to optimize at the\nlink stage. This can, for example, remove dead code and often times reduces binary size.\n\nEnable LTO in `Cargo.toml`:\n\n```toml\n[profile.release]\nlto = true\n```\n\n# Reduce Parallel Code Generation Units to Increase Optimization\n\n[By default][cargo-profile], Cargo specifies 16 parallel codegen units for release builds.\nThis improves compile times, but prevents some optimizations.\n\nSet this to `1` in `Cargo.toml` to allow for maximum size reduction optimizations:\n\n```toml\n[profile.release]\ncodegen-units = 1\n```\n\n# Abort on Panic\n\n![Minimum Rust: 1.10](https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg)\n\n> [!IMPORTANT]\n> Up to this point, the features discussed to reduce binary size did not have an\n> impact on the behaviour of the program (only its execution speed). This feature does\n> have an impact on behavior.\n\n[By default][cargo-profile], when Rust code encounters a situation when it must call `panic!()`,\nit unwinds the stack and produces a helpful backtrace. The unwinding code, however, does require\nextra binary size. `rustc` can be instructed to abort immediately rather than unwind, which\nremoves the need for this extra unwinding code.\n\nEnable this in `Cargo.toml`:\n\n```toml\n[profile.release]\npanic = \"abort\"\n```\n\n# Remove Location Details\n\n![Minimum Rust: Nightly](https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-orange.svg)\n\nBy default, Rust includes file, line, and column information for `panic!()` and `[track_caller]`\nto provide more useful traceback information. This information requires space in the binary and\nthus increases the size of the compiled binaries.\n\nTo remove this file, line, and column information, use the unstable\n[`rustc` `-Zlocation-detail`](https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md#location-detail-control)\nflag:\n\n```bash\n$ RUSTFLAGS=\"-Zlocation-detail=none\" cargo +nightly build --release\n```\n\n# Remove `fmt::Debug`\n\n![Minimum Rust: Nightly](https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-orange.svg)\n\nWith the \n[`-Zfmt-debug`](https://doc.rust-lang.org/nightly/unstable-book/compiler-flags/fmt-debug.html) flag\nyou can turn `#[derive(Debug)]`and \n[`{:?}`](https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html) formatting into no-ops. This\nwill ruin output of `dbg!()`, `assert!()`, `unwrap()`, etc., and may break code that unwisely\nrelies on the debug formatting, but it will remove derived `fmt` functions and their strings.\n\n```bash\n$ RUSTFLAGS=\"-Zfmt-debug=none\" cargo +nightly build --release\n```\n\n# Optimize `libstd` with `build-std`\n\n![Minimum Rust: Nightly](https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-orange.svg)\n\n> [!NOTE]\n> See also [Xargo](https://github.com/japaric/xargo), the predecessor to `build-std`.\n[Xargo is currently in maintenance status](https://github.com/japaric/xargo/issues/193).\n\n> [!NOTE]\n> Example project is located in the [`build_std`](build_std) folder.\n\nRust ships pre-built copies of the standard library (`libstd`) with its toolchains. This means\nthat developers don't need to build `libstd` every time they build their applications. `libstd`\nis statically linked into the binary instead.\n\nWhile this is very convenient there are several drawbacks if a developer is trying to\naggressively optimize for size.\n\n1. The prebuilt `libstd` is optimized for speed, not size.\n\n2. It's not possible to remove portions of `libstd` that are not used in a particular application\n   (e.g. LTO and panic behaviour).\n\nThis is where [`build-std`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std)\ncomes in. The `build-std` feature is able to compile `libstd` with your application from the\nsource. It does this with the `rust-src` component that `rustup` conveniently provides.\n\nInstall the appropriate toolchain and the `rust-src` component:\n\n```bash\n$ rustup toolchain install nightly\n$ rustup component add rust-src --toolchain nightly\n```\n\nBuild using `build-std`:\n\n```bash\n# Find your host's target triple.\n$ rustc -vV\n...\nhost: x86_64-apple-darwin\n\n# Use that target triple when building with build-std.\n# Add the =std,panic_abort to the option to make panic = \"abort\" Cargo.toml option work.\n# See: https://github.com/rust-lang/wg-cargo-std-aware/issues/56\n$ RUSTFLAGS=\"-Zlocation-detail=none -Zfmt-debug=none\" cargo +nightly build \\\n  -Z build-std=std,panic_abort \\\n  -Z build-std-features=\"optimize_for_size\" \\\n  --target x86_64-apple-darwin --release\n```\n\nThe `optimize_for_size` flag provides a hint to `libstd` that it should try to use algorithms\noptimized for binary size. More information about it can be found in the \n[tracking issue](https://github.com/rust-lang/rust/issues/125612).\n\nOn macOS, the final stripped binary size is reduced to 51KB.\n\n# Remove `panic` String Formatting with `panic_immediate_abort`\n\n![Minimum Rust: Nightly](https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-orange.svg)\n\nEven if `panic = \"abort\"` is specified in `Cargo.toml`, `rustc` will still include panic strings\nand formatting code in final binary by default.\n[An unstable `panic_immediate_abort` feature](https://github.com/rust-lang/rust/pull/55011)\nhas been merged into the `nightly` `rustc` compiler to address this.\n\nTo use this, repeat the instructions above to use `build-std`, but also pass the following\n[`-Z build-std-features=panic_immediate_abort`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features)\noption.\n\n```bash\n$ cargo +nightly build -Z build-std=std,panic_abort -Z build-std-features=panic_immediate_abort \\\n    --target x86_64-apple-darwin --release\n```\n\nOn macOS, the final stripped binary size is reduced to 30KB.\n\n# Remove `core::fmt` with `#![no_main]` and Careful Usage of `libstd`\n\n![Minimum Rust: Nightly](https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-orange.svg)\n\n> [!NOTE]\n> Example projects are located in the [`no_main`](no_main) folder.\n\nUp until this point, we haven't restricted what utilities we used from `libstd`. In this section\nwe will restrict our usage of `libstd` in order to reduce binary size further.\n\nIf you want an executable smaller than 20 kilobytes, Rust's string formatting code,\n[`core::fmt`](https://doc.rust-lang.org/core/fmt/index.html) must\nbe removed. `panic_immediate_abort` only removes some usages of this code. There is a lot of other\ncode that uses formatting in some cases. That includes Rust's \"pre-main\" code in `libstd`.\n\nBy using a C entry point (by adding the `#![no_main]` attribute) , managing stdio manually, and\ncarefully analyzing which chunks of code you or your dependencies include, you can sometimes\nmake use of `libstd` while avoiding bloated `core::fmt`.\n\nExpect the code to be hacky and unportable, with more `unsafe{}`s than usual. It feels like\n`no_std`, but with `libstd`.\n\nStart with an empty executable, ensure\n[`xargo bloat --release --target=...`](https://github.com/RazrFalcon/cargo-bloat) contains no\n`core::fmt` or something about padding. Add (uncomment) a little bit. See that `xargo bloat` now\nreports drastically more. Review source code that you've just added. Probably some external crate or\na new `libstd` function is used. Recurse into that with your review process\n(it requires `[replace]` Cargo dependencies and maybe digging in `libstd`), find out why it\nweighs more than it should. Choose alternative way or patch dependencies to avoid unnecessary\nfeatures. Uncomment a bit more of your code, debug exploded size with `xargo bloat` and so on.\n\nOn macOS, the final stripped binary is reduced to 8KB.\n\n# Removing `libstd` with `#![no_std]`\n\n![Minimum Rust: 1.30](https://img.shields.io/badge/Minimum%20Rust%20Version-1.30-brightgreen.svg)\n\n> [!NOTE]\n> Example projects are located in the [`no_std`](no_std) folder.\n\nUp until this point, our application was using the Rust standard library, `libstd`. `libstd`\nprovides many convenient, well tested cross-platform APIs and data types. But if a user wants\nto reduce binary size to an equivalent C program size, it is possible to depend only on `libc`.\n\nIt's important to understand that there are many drawbacks to this approach. For one, you'll\nlikely need to write a lot of `unsafe` code and lose access to a majority of Rust crates\nthat depend on `libstd`. Nevertheless, it is one (albeit extreme) option to reducing binary size.\n\nA `strip`ed binary built this way is around 8KB.\n\n```rust\n#![no_std]\n#![no_main]\n\nextern crate libc;\n\n#[no_mangle]\npub extern \"C\" fn main(_argc: isize, _argv: *const *const u8) -> isize {\n    // Since we are passing a C string the final null character is mandatory.\n    const HELLO: &'static str = \"Hello, world!\\n\\0\";\n    unsafe {\n        libc::printf(HELLO.as_ptr() as *const _);\n    }\n    0\n}\n\n#[panic_handler]\nfn my_panic(_info: &core::panic::PanicInfo) -> ! {\n    loop {}\n}\n```\n\n# Compress the binary\n\n> [!NOTE]\n> Up until this point, all size-reducing techniques were Rust-specific. This section describes\n> a language-agnostic binary packing tool that is an option to reduce binary size further.\n\n[UPX](https://github.com/upx/upx) is a powerful tool for creating a self-contained, compressed\nbinary with no addition runtime requirements. It claims to typically reduce binary size by 50-70%,\nbut the actual result depends on your executable.\n\n```bash\n$ upx --best --lzma target/release/min-sized-rust\n```\n\n> [!WARNING]\n> There have been times that UPX-packed binaries have flagged heuristic-based antivirus software\n> because malware often uses UPX.\n\n# Tools\n\n- [`cargo-bloat`](https://github.com/RazrFalcon/cargo-bloat) - Find out what takes most of the\n  space in your executable.\n- [`cargo-unused-features`](https://github.com/TimonPost/cargo-unused-features) - Find and prune\n  enabled but potentially unused feature flags from your project.\n- [`momo`](https://github.com/llogiq/momo) - `proc_macro` crate to help keeping the code footprint\n  of generic methods in check.\n- [Twiggy](https://rustwasm.github.io/twiggy/index.html) - A code size profiler for Wasm.\n\n# Containers\n\nSometimes it's advantageous to deploy Rust into containers\n(e.g. [Docker](https://www.docker.com/)). There are several great existing resources to help\ncreate minimum sized container images that run Rust binaries.\n\n- [Official `rust:alpine` image](https://hub.docker.com/_/rust)\n- [mini-docker-rust](https://github.com/kpcyrd/mini-docker-rust)\n- [muslrust](https://github.com/clux/muslrust)\n- [docker-slim](https://github.com/docker-slim/docker-slim) - Minify Docker images\n- [dive](https://github.com/wagoodman/dive) - A tool for exploring a container image and\n  discovering ways to shrink the size of the image.\n\n# References\n\n- [151-byte static Linux binary in Rust - 2015][151-byte-static-linux-binary]\n- [Why is a Rust executable large? - 2016][why-rust-binary-large]\n- [Tiny Rocket - 2018](https://jamesmunns.com/blog/tinyrocket/)\n- [Formatting is Unreasonably Expensive for Embedded Rust - 2019][fmt-unreasonably-expensive]\n- [Tiny Windows executable in Rust - 2019][tiny-windows-exe]\n- [Making a really tiny WebAssembly graphics demos - 2019][tiny-webassembly-graphics]\n- [Reducing the size of the Rust GStreamer plugin - 2020][gstreamer-plugin]\n- [Optimizing Rust Binary Size - 2020][optimizing-rust-binary-size]\n- [Minimizing Mender-Rust - 2020][minimizing-mender-rust]\n- [Optimize Rust binaries size with cargo and Semver - 2021][optimize-with-cargo-and-semver]\n- [Tighten rustâ€™s belt: shrinking embedded Rust binaries - 2022][tighten-rusts-belt]\n- [Avoiding allocations in Rust to shrink Wasm modules - 2022][avoiding-allocations-shrink-wasm]\n- [A very small Rust binary indeed - 2022][a-very-small-rust-binary]\n- [The dark side of inlining and monomorphization - 2023][dark-side-of-inlining]\n- [Making Rust binaries smaller by default - 2024][making-rust-binaries-smaller-by-default]\n- [Tock Binary Size - 2024][tock-binary-size]\n- [Trimming down a rust binary in half - 2024][trimming-down-a-rust-binary-in-half]\n- [Reducing WASM binary size: lessons from building a web terminal - 2024][reducing-wasm-binary-size]\n- [`min-sized-rust-windows`][min-sized-rust-windows] - Windows-specific tricks to reduce binary size\n- [Shrinking `.wasm` Code Size][shrinking-wasm-code-size]\n\n[151-byte-static-linux-binary]: https://mainisusuallyafunction.blogspot.com/2015/01/151-byte-static-linux-binary-in-rust.html\n\n[why-rust-binary-large]: https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html\n\n[fmt-unreasonably-expensive]: https://jamesmunns.com/blog/fmt-unreasonably-expensive/\n\n[tiny-windows-exe]: https://www.codeslow.com/2019/12/tiny-windows-executable-in-rust.html\n\n[tiny-webassembly-graphics]: https://cliffle.com/blog/bare-metal-wasm/\n\n[gstreamer-plugin]: https://www.collabora.com/news-and-blog/blog/2020/04/28/reducing-size-rust-gstreamer-plugin/\n\n[optimizing-rust-binary-size]: https://arusahni.net/blog/2020/03/optimizing-rust-binary-size.html\n\n[minimizing-mender-rust]: https://mender.io/blog/building-mender-rust-in-yocto-and-minimizing-the-binary-size\n\n[optimize-with-cargo-and-semver]: https://oknozor.github.io/blog/optimize-rust-binary-size/\n\n[tighten-rusts-belt]: https://dl.acm.org/doi/abs/10.1145/3519941.3535075\n\n[avoiding-allocations-shrink-wasm]: https://nickb.dev/blog/avoiding-allocations-in-rust-to-shrink-wasm-modules/\n\n[a-very-small-rust-binary]: https://darkcoding.net/software/a-very-small-rust-binary-indeed/\n\n[dark-side-of-inlining]: https://nickb.dev/blog/the-dark-side-of-inlining-and-monomorphization/\n\n[making-rust-binaries-smaller-by-default]: https://kobzol.github.io/rust/cargo/2024/01/23/making-rust-binaries-smaller-by-default.html\n\n[tock-binary-size]: https://tweedegolf.nl/en/blog/126/tock-binary-size\n\n[trimming-down-a-rust-binary-in-half]: https://tech.dreamleaves.org/trimming-down-a-rust-binary-in-half/\n\n[reducing-wasm-binary-size]: https://www.warp.dev/blog/reducing-wasm-binary-size\n\n[min-sized-rust-windows]: https://github.com/mcountryman/min-sized-rust-windows\n\n[shrinking-wasm-code-size]: https://rustwasm.github.io/docs/book/reference/code-size.html\n\n# Organizations\n\n- [wg-binary-size]: Working group for improving the size of Rust programs and libraries.\n\n[wg-binary-size]: https://github.com/rust-lang/wg-binary-size\n\n# Legacy Techniques\n\nThe following techniques are no longer relevant for modern Rust development, but may apply to older\nversions of Rust and are maintained for historical purposes.\n\n## Remove Jemalloc\n\n![Minimum Rust: 1.28](https://img.shields.io/badge/Minimum%20Rust%20Version-1.28-brightgreen.svg)\n![Maximum Rust: 1.31](https://img.shields.io/badge/Maximum%20Rust%20Version-1.31-brightgreen.svg)\n\n> [!IMPORTANT]\n> As of Rust 1.32,\n> [`jemalloc` is removed by default](https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html).\n> **If using Rust 1.32 or newer, no action is needed to reduce binary size regarding this\n> feature**.\n\n**Prior to Rust 1.32**, to improve performance on some platforms Rust bundled\n[jemalloc](https://github.com/jemalloc/jemalloc), an allocator that often\noutperforms the default system allocator. Bundling jemalloc added around 200KB\nto the resulting binary, however.\n\nTo remove `jemalloc` on Rust 1.28 - Rust 1.31, add this code to the top of `main.rs`:\n\n```rust\nuse std::alloc::System;\n\n#[global_allocator]\nstatic A: System = System;\n```"
        },
        {
          "name": "build_std",
          "type": "tree",
          "content": null
        },
        {
          "name": "no_main",
          "type": "tree",
          "content": null
        },
        {
          "name": "no_std",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}