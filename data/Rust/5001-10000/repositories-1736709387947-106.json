{
  "metadata": {
    "timestamp": 1736709387947,
    "page": 106,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tokio-rs/tracing",
      "stars": 5630,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cargo",
          "type": "tree",
          "content": null
        },
        {
          "name": ".config",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.98828125,
          "content": "\n# Created by https://www.gitignore.io/api/rust,macos,visualstudiocode\n\n### macOS ###\n# General\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \\r\nIcon\n\n# Thumbnails\n._*\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n### Rust ###\n# Generated by Cargo\n# will have compiled files and executables\ntarget/\n\n# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries\n# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html\nCargo.lock\n\n# These are backup files generated by rustfmt\n**/*.rs.bk\n\n### VisualStudioCode ###\n.vscode/*\n!.vscode/settings.json\n!.vscode/tasks.json\n!.vscode/launch.json\n!.vscode/extensions.json\n\n\n# End of https://www.gitignore.io/api/rust,macos,visualstudiocode\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 19.3466796875,
          "content": "# Contributing to Tracing\n\n:balloon: Thanks for your help improving the project! We are so happy to have\nyou!\n\nThere are opportunities to contribute to Tracing at any level. It doesn't\nmatter if you are just getting started with Rust or are the most weathered\nexpert, we can use your help.\n\n**No contribution is too small and all contributions are valued.**\n\nThis guide will help you get started. **Do not let this guide intimidate you**.\nIt should be considered a map to help you navigate the process.\n\nYou may also get help with contributing in [Tokio's Discord server][discord],\n`#tracing-dev` channel. Please join us!\n\nTracing is a part of the [Tokio][tokio] project, and follows the project's\nguidelines for contributing. This document is based on the\n[`CONTRIBUTING.md` file][tokio-contrib] in the `tokio-rs/tokio` repository.\n\n[discord]: https://discord.gg/tokio\n[tokio]: https://tokio.rs\n[tokio-contrib]: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md\n\n## Conduct\n\nThe Tokio project adheres to the [Rust Code of Conduct][coc]. This describes\nthe _minimum_ behavior expected from all contributors.\n\n[coc]: https://github.com/rust-lang/rust/blob/master/CODE_OF_CONDUCT.md\n\n## Contributing in Issues\n\nFor any issue, there are fundamentally three ways an individual can contribute:\n\n1. By opening the issue for discussion: For instance, if you believe that you\n   have uncovered a bug in a Tracing crate, creating a new issue in the\n   tokio-rs/tracing [issue tracker][issues] is the way to report it.\n\n2. By helping to triage the issue: This can be done by providing\n   supporting details (a test case that demonstrates a bug), providing\n   suggestions on how to address the issue, or ensuring that the issue is tagged\n   correctly.\n\n3. By helping to resolve the issue: Typically this is done either in the form of\n   demonstrating that the issue reported is not a problem after all, or more\n   often, by opening a Pull Request that changes some bit of something in\n   Tokio in a concrete and reviewable manner.\n\n**Anybody can participate in any stage of contribution**. We urge you to\nparticipate in the discussion around bugs and participate in reviewing PRs.\n\n[issues]: https://github.com/tokio-rs/tracing/issues\n\n### Asking for General Help\n\nIf you have reviewed existing documentation and still have questions or are\nhaving problems, you can open an issue asking for help.\n\nIn exchange for receiving help, we ask that you contribute back a documentation\nPR that helps others avoid the problems that you encountered.\n\n### Submitting a Bug Report\n\nWhen opening a new issue in the `tracing` issue tracker, users will\nbe presented with a [basic template][issue-template] that should be filled in. If you\nbelieve that you have uncovered a bug, please fill out this form, following the\ntemplate to the best of your ability. Do not worry if you cannot answer every\ndetail, just fill in what you can.\n\nThe two most important pieces of information we need in order to properly\nevaluate the report is a description of the behavior you are seeing and a simple\ntest case we can use to recreate the problem on our own. If we cannot recreate\nthe issue, it becomes impossible for us to fix.\n\nIn order to rule out the possibility of bugs introduced by userland code, test\ncases should be limited, as much as possible, to using only Tokio APIs.\n\nSee [How to create a Minimal, Complete, and Verifiable example][mcve].\n\n[mcve]: https://stackoverflow.com/help/mcve\n[issue-template]: .github/ISSUE_TEMPLATE/bug_report.md\n\n### Triaging a Bug Report\n\nOnce an issue has been opened, it is not uncommon for there to be discussion\naround it. Some contributors may have differing opinions about the issue,\nincluding whether the behavior being seen is a bug or a feature. This discussion\nis part of the process and should be kept focused, helpful, and professional.\n\nShort, clipped responses—that provide neither additional context nor supporting\ndetail—are not helpful or professional. To many, such responses are simply\nannoying and unfriendly.\n\nContributors are encouraged to help one another make forward progress as much as\npossible, empowering one another to solve issues collaboratively. If you choose\nto comment on an issue that you feel either is not a problem that needs to be\nfixed, or if you encounter information in an issue that you feel is incorrect,\nexplain why you feel that way with additional supporting context, and be willing\nto be convinced that you may be wrong. By doing so, we can often reach the\ncorrect outcome much faster.\n\n### Resolving a Bug Report\n\nIn the majority of cases, issues are resolved by opening a Pull Request. The\nprocess for opening and reviewing a Pull Request is similar to that of opening\nand triaging issues, but carries with it a necessary review and approval\nworkflow that ensures that the proposed changes meet the minimal quality and\nfunctional guidelines of the Tokio project.\n\n## Pull Requests\n\nPull Requests are the way concrete changes are made to the code, documentation,\nand dependencies in the `tracing` repository.\n\nEven tiny pull requests (e.g., one character pull request fixing a typo in API\ndocumentation) are greatly appreciated. Before making a large change, it is\nusually a good idea to first open an issue describing the change to solicit\nfeedback and guidance. This will increase the likelihood of the PR getting\nmerged.\n\n### Tests\n\nIf the change being proposed alters code (as opposed to only documentation for\nexample), it is either adding new functionality to a crate or it is fixing\nexisting, broken functionality. In both of these cases, the pull request should\ninclude one or more tests to ensure that the crate does not regress in the future.\nThere are two ways to write tests: integration tests and documentation tests\n(Tokio avoids unit tests as much as possible).\n\n#### Integration tests\n\nIntegration tests go in the same crate as the code they are testing. Each sub\ncrate should have a `dev-dependency` on `tracing` itself. This makes all\n`tracing` utilities available to use in tests, no matter the crate being\ntested.\n\nThe best strategy for writing a new integration test is to look at existing\nintegration tests in the crate and follow the style.\n\n#### Documentation tests\n\nIdeally, every API has at least one [documentation test] that demonstrates how to\nuse the API. Documentation tests are run with `cargo test --doc`. This ensures\nthat the example is correct and provides additional test coverage.\n\nThe trick to documentation tests is striking a balance between being succinct\nfor a reader to understand and actually testing the API.\n\nThe type level example for `tokio_timer::Timeout` provides a good example of a\ndocumentation test:\n\n```\n/// // import the `timeout` function, usually this is done\n/// // with `use tokio::prelude::*`\n/// use tokio::prelude::FutureExt;\n/// use futures::Stream;\n/// use futures::sync::mpsc;\n/// use std::time::Duration;\n///\n/// # fn main() {\n/// let (tx, rx) = mpsc::unbounded();\n/// # tx.unbounded_send(()).unwrap();\n/// # drop(tx);\n///\n/// let process = rx.for_each(|item| {\n///     // do something with `item`\n/// # drop(item);\n/// # Ok(())\n/// });\n///\n/// # tokio::runtime::current_thread::block_on_all(\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// process.timeout(Duration::from_millis(10))\n/// # ).unwrap();\n/// # }\n```\n\nGiven that this is a *type* level documentation test and the primary way users\nof `tokio` will create an instance of `Timeout` is by using\n`FutureExt::timeout`, this is how the documentation test is structured.\n\nLines that start with `/// #` are removed when the documentation is generated.\nThey are only there to get the test to run. The `block_on_all` function is the\neasiest way to execute a future from a test.\n\nIf this were a documentation test for the `Timeout::new` function, then the\nexample would explicitly use `Timeout::new`. For example:\n\n```\n/// use tokio::timer::Timeout;\n/// use futures::Future;\n/// use futures::sync::oneshot;\n/// use std::time::Duration;\n///\n/// # fn main() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// # tokio::runtime::current_thread::block_on_all(\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// Timeout::new(rx, Duration::from_millis(10))\n/// # ).unwrap();\n/// # }\n```\n\nTo reduce the effort required to review documentation-related changes,\n`tracing`'s CI system generates preview websites containing the\n`rustdoc` output for the entire repository for each PR. The preview can\nbe viewed by clicking the `details` link on the\n`netlify/tracing-rs/deploy-preview check` on all pull requests.\n\n### Building Documentation\n\nTracing's documentation uses nightly-only RustDoc features and lints, like\n`doc(cfg)` and `broken_intra_doc_lints`. These features are enabled by\npassing `--cfg docsrs` to RustDoc. Therefore, in order to build Tracing's\ndocumentation the same way it would be built by docs.rs, it's necessary to\nuse the following command:\n\n```bash\nRUSTDOCFLAGS=\"--cfg docsrs\" cargo +nightly doc --no-deps\n```\n\n### Commits\n\nIt is a recommended best practice to keep your changes as logically grouped as\npossible within individual commits. There is no limit to the number of commits\nany single Pull Request may have, and many contributors find it easier to review\nchanges that are split across multiple commits.\n\nThat said, if you have a number of commits that are \"checkpoints\" and don't\nrepresent a single logical change, please squash those together.\n\nNote that multiple commits often get squashed when they are landed (see the\nnotes about [commit squashing]).\n\n#### Commit message guidelines\n\nA good commit message should describe what changed and why.\n\n1. The first line should:\n\n  * contain a short description of the change (preferably 50 characters or less,\n    and no more than 72 characters)\n  * be entirely in lowercase with the exception of proper nouns, acronyms, and\n    the words that refer to code, like function/variable names\n  * be prefixed with the name of the crate being changed (without the\n    `tracing` prefix) and start with an imperative verb.\n\n  Examples:\n\n  * fmt: add regex for parsing field filters\n  * tower-http: add `Clone` impl for `Service` and `MakeService`\n\n2. Keep the second line blank.\n3. Wrap all other lines at 72 columns (except for long URLs).\n4. If your patch fixes an open issue, you can add a reference to it at the end\n   of the log. Use the `Fixes: #` prefix and the issue number. For other\n   references use `Refs: #`. `Refs` may include multiple issues, separated by a\n   comma.\n\n   Examples:\n\n   - `Fixes: #1337`\n   - `Refs: #1234`\n\nSample complete commit message:\n\n```txt\nsubcrate: explain the commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message can be several paragraphs, and\nplease do proper word-wrap and keep columns shorter than about\n72 characters or so. That way, `git log` will show things\nnicely even when it is indented.\n\nFixes: #1337\nRefs: #453, #154\n```\n\n### Opening the Pull Request\n\nFrom within GitHub, opening a new Pull Request will present you with a\n[pull-request-template] that should be filled out. Please try to do your best at filling out\nthe details, but feel free to skip parts if you're not sure what to put.\n\n[pull-request-template]: .github/PULL_REQUEST_TEMPLATE.md\n\n### Discuss and update\n\nYou will probably get feedback or requests for changes to your Pull Request.\nThis is a big part of the submission process so don't be discouraged! Some\ncontributors may sign off on the Pull Request right away, others may have\nmore detailed comments or feedback. This is a necessary part of the process\nin order to evaluate whether the changes are correct and necessary.\n\n**Any community member can review a PR and you might get conflicting feedback**.\nKeep an eye out for comments from code owners to provide guidance on conflicting\nfeedback.\n\n**Once the PR is open, do not rebase the commits**. See [Commit Squashing] for\nmore details.\n\n### Commit Squashing\n\nIn most cases, **do not squash commits that you add to your Pull Request during\nthe review process**. When the commits in your Pull Request land, they may be\nsquashed into one commit per logical change. Metadata will be added to the\ncommit message (including links to the Pull Request, links to relevant issues,\nand the names of the reviewers). The commit history of your Pull Request,\nhowever, will stay intact on the Pull Request page.\n\n## Reviewing Pull Requests\n\n**Any Tokio community member is welcome to review any pull request**.\n\nAll Tokio contributors who choose to review and provide feedback on Pull\nRequests have a responsibility to both the project and the individual making the\ncontribution. Reviews and feedback must be helpful, insightful, and geared\ntowards improving the contribution as opposed to simply blocking it. If there\nare reasons why you feel the PR should not land, explain what those are. Do not\nexpect to be able to block a Pull Request from advancing simply because you say\n\"No\" without giving an explanation. Be open to having your mind changed. Be open\nto working with the contributor to make the Pull Request better.\n\nReviews that are dismissive or disrespectful of the contributor or any other\nreviewers are strictly counter to the Code of Conduct.\n\nWhen reviewing a Pull Request, the primary goals are for the codebase to improve\nand for the person submitting the request to succeed. **Even if a Pull Request\ndoes not land, the submitters should come away from the experience feeling like\ntheir effort was not wasted or unappreciated**. Every Pull Request from a new\ncontributor is an opportunity to grow the community.\n\n### Review a bit at a time.\n\nDo not overwhelm new contributors.\n\nIt is tempting to micro-optimize and make everything about relative performance,\nperfect grammar, or exact style matches. Do not succumb to that temptation.\n\nFocus first on the most significant aspects of the change:\n\n1. Does this change make sense for Tokio?\n2. Does this change make Tokio better, even if only incrementally?\n3. Are there clear bugs or larger scale issues that need attending to?\n4. Is the commit message readable and correct? If it contains a breaking change\n   is it clear enough?\n\nNote that only **incremental** improvement is needed to land a PR. This means\nthat the PR does not need to be perfect, only better than the status quo. Follow\nup PRs may be opened to continue iterating.\n\nWhen changes are necessary, *request* them, do not *demand* them, and **do not\nassume that the submitter already knows how to add a test or run a benchmark**.\n\nSpecific performance optimization techniques, coding styles and conventions\nchange over time. The first impression you give to a new contributor never does.\n\nNits (requests for small changes that are not essential) are fine, but try to\navoid stalling the Pull Request. Most nits can typically be fixed by the Tokio\nCollaborator landing the Pull Request but they can also be an opportunity for\nthe contributor to learn a bit more about the project.\n\nIt is always good to clearly indicate nits when you comment: e.g.\n`Nit: change foo() to bar(). But this is not blocking.`\n\nIf your comments were addressed but were not folded automatically after new\ncommits or if they proved to be mistaken, please, [hide them][hiding-a-comment]\nwith the appropriate reason to keep the conversation flow concise and relevant.\n\n### Be aware of the person behind the code\n\nBe aware that *how* you communicate requests and reviews in your feedback can\nhave a significant impact on the success of the Pull Request. Yes, we may land\na particular change that makes `tracing` better, but the individual might\njust not want to have anything to do with `tracing` ever again. The goal is\nnot just having good code.\n\n### Abandoned or Stalled Pull Requests\n\nIf a Pull Request appears to be abandoned or stalled, it is polite to first\ncheck with the contributor to see if they intend to continue the work before\nchecking if they would mind if you took it over (especially if it just has nits\nleft). When doing so, it is courteous to give the original contributor credit\nfor the work they started (either by preserving their name and email address in\nthe commit log, or by using an `Author: ` meta-data tag in the commit.\n\n_Adapted from the [Node.js contributing guide][node]_.\n\n[node]: https://github.com/nodejs/node/blob/master/CONTRIBUTING.md\n[hiding-a-comment]: https://help.github.com/articles/managing-disruptive-comments/#hiding-a-comment\n[documentation test]: https://doc.rust-lang.org/rustdoc/documentation-tests.html\n\n## Releasing\n\nSince the Tracing project consists of a number of crates, many of which depend on\neach other, releasing new versions to crates.io can involve some complexities.\nWhen releasing a new version of a crate, follow these steps:\n\n1. **Ensure that the release crate has no path dependencies.** When the HEAD\n   version of a Tracing crate requires unreleased changes in another Tracing crate,\n   the crates.io dependency on the second crate will be replaced with a path\n   dependency. Crates with path dependencies cannot be published, so before\n   publishing the dependent crate, any path dependencies must also be published.\n   This should be done through a form of depth-first tree traversal:\n\n   1. Starting with the first path dependency in the crate to be released,\n      inspect the `Cargo.toml` for the dependency. If the dependency has any\n      path dependencies of its own, repeat this step with the first such\n      dependency.\n   2. Begin the release process for the path dependency.\n   3. Once the path dependency has been published to crates.io, update the\n      dependent crate to depend on the crates.io version.\n   4. When all path dependencies have been published, the dependent crate may\n      be published.\n\n   To verify that a crate is ready to publish, run:\n\n   ```bash\n   bin/publish --dry-run <CRATE NAME> <CRATE VERSION>\n   ```\n\n2. **Update Cargo metadata.** After releasing any path dependencies, update the\n   `version` field in `Cargo.toml` to the new version, and the `documentation`\n   field to the docs.rs URL of the new version.\n3. **Update the \"Documentation\" link in the crate's\n   `README.md` to point to the docs.rs URL of the new version.\n4. **Update the changelog for the crate.** Each crate in the Tokio repository\n   has its own `CHANGELOG.md` in that crate's subdirectory. Any changes to that\n   crate since the last release should be added to the changelog. Change\n   descriptions may be taken from the Git history, but should be edited to\n   ensure a consistent format, based on [Keep A Changelog][keep-a-changelog].\n   Other entries in that crate's changelog may also be used for reference.\n5. **Perform a final audit for breaking changes.** Compare the HEAD version of\n   crate with the Git tag for the most recent release version. If there are any\n   breaking API changes, determine if those changes can be made without breaking\n   existing APIs. If so, resolve those issues. Otherwise, if it is necessary to\n   make a breaking release, update the version numbers to reflect this.\n6. **Open a pull request with your changes.** Once that pull request has been\n   approved by a maintainer and the pull request has been merged, continue to\n   the next step.\n7. **Release the crate.** Run the following command:\n\n   ```bash\n   bin/publish <NAME OF CRATE> <VERSION>\n   ```\n\n   Your editor and prompt you to edit a message for the tag. Copy the changelog\n   entry for that release version into your editor and close the window.\n\n[keep-a-changelog]: https://github.com/olivierlacan/keep-a-changelog/blob/master/CHANGELOG.md\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 0.640625,
          "content": "[workspace]\nresolver = \"2\"\nmembers = [\n    \"tracing\",\n    \"tracing-core\",\n    \"tracing-attributes\",\n    \"tracing-error\",\n    \"tracing-flame\",\n    \"tracing-futures\",\n    \"tracing-tower\",\n    \"tracing-log\",\n    \"tracing-macros\",\n    \"tracing-mock\",\n    \"tracing-subscriber\",\n    \"tracing-serde\",\n    \"tracing-test\",\n    \"tracing-appender\",\n    \"tracing-journald\",\n    \"examples\"\n]\n\n # This will be ignored with Rust older than 1.74, but for now that's okay;\n # we're only using it to fix check-cfg issues that first appeared in Rust 1.80.\n[workspace.lints.rust]\nunexpected_cfgs = { level = \"warn\", check-cfg = [\"cfg(flaky_tests)\", \"cfg(tracing_unstable)\"] }\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "Copyright (c) 2019 Tokio Contributors\n\nPermission is hereby granted, free of charge, to any\nperson obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without\nlimitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice\nshall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\nSHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.4091796875,
          "content": "![Tracing — Structured, application-level diagnostics][splash]\n\n[splash]: https://raw.githubusercontent.com/tokio-rs/tracing/master/assets/splash.svg\n\n[![Crates.io][crates-badge]][crates-url]\n[![Documentation][docs-badge]][docs-url]\n[![Documentation (master)][docs-master-badge]][docs-master-url]\n[![MIT licensed][mit-badge]][mit-url]\n[![Build Status][actions-badge]][actions-url]\n[![Discord chat][discord-badge]][discord-url]\n\n[crates-badge]: https://img.shields.io/crates/v/tracing.svg\n[crates-url]: https://crates.io/crates/tracing\n[docs-badge]: https://docs.rs/tracing/badge.svg\n[docs-url]: https://docs.rs/tracing\n[docs-master-badge]: https://img.shields.io/badge/docs-master-blue\n[docs-master-url]: https://tracing.rs\n[mit-badge]: https://img.shields.io/badge/license-MIT-blue.svg\n[mit-url]: LICENSE\n[actions-badge]: https://github.com/tokio-rs/tracing/workflows/CI/badge.svg\n[actions-url]:https://github.com/tokio-rs/tracing/actions?query=workflow%3ACI\n[discord-badge]: https://img.shields.io/discord/500028886025895936?logo=discord&label=discord&logoColor=white\n[discord-url]: https://discord.gg/EeF3cQw\n\n[Website](https://tokio.rs) |\n[Chat](https://discord.gg/EeF3cQw) | [Documentation (master branch)](https://tracing-rs.netlify.com/)\n\n# The master branch is the pre-release, development version of `tracing`. Please see the [v0.1.x](https://github.com/tokio-rs/tracing/tree/v0.1.x) branch for the versions of `tracing` released to crates.io.\n\n## Overview\n\n`tracing` is a framework for instrumenting Rust programs to collect\nstructured, event-based diagnostic information. `tracing` is maintained by the\nTokio project, but does _not_ require the `tokio` runtime to be used.\n\n## Usage\n\n### In Applications\n\nIn order to record trace events, executables have to use a collector\nimplementation compatible with `tracing`. A collector implements a way of\ncollecting trace data, such as by logging it to standard output.\n[`tracing-subscriber`][tracing-subscriber-docs]'s [`fmt` module][fmt] provides\na collector for logging traces with reasonable defaults. Additionally,\n`tracing-subscriber` is able to consume messages emitted by `log`-instrumented\nlibraries and modules.\n\nTo use `tracing-subscriber`, add the following to your `Cargo.toml`:\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\nThen create and install a collector, for example using [`init()`]:\n\n```rust\nuse tracing::info;\nuse tracing_subscriber;\n\nfn main() {\n    // install global collector configured based on RUST_LOG env var.\n    tracing_subscriber::fmt::init();\n\n    let number_of_yaks = 3;\n    // this creates a new event, outside of any spans.\n    info!(number_of_yaks, \"preparing to shave yaks\");\n\n    let number_shaved = yak_shave::shave_all(number_of_yaks);\n    info!(\n        all_yaks_shaved = number_shaved == number_of_yaks,\n        \"yak shaving completed.\"\n    );\n}\n```\n\nUsing `init()` calls [`set_global_default()`] so this collector will be used\nas the default in all threads for the remainder of the duration of the\nprogram, similar to how loggers work in the `log` crate.\n\n[tracing-subscriber-docs]: https://docs.rs/tracing-subscriber/\n[fmt]: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/index.html\n[`set_global_default`]: https://docs.rs/tracing/latest/tracing/subscriber/fn.set_global_default.html\n\n\nFor more control, a collector can be built in stages and not set globally,\nbut instead used to locally override the default collector. For example:\n\n```rust\nuse tracing::{info, Level};\nuse tracing_subscriber;\n\nfn main() {\n    let collector = tracing_subscriber::fmt()\n        // filter spans/events with level TRACE or higher.\n        .with_max_level(Level::TRACE)\n        // build but do not install the subscriber.\n        .finish();\n\n    tracing::collect::with_default(collector, || {\n        info!(\"This will be logged to stdout\");\n    });\n    info!(\"This will _not_ be logged to stdout\");\n}\n```\n\nAny trace events generated outside the context of a collector will not be collected.\n\nThis approach allows trace data to be collected by multiple collectors\nwithin different contexts in the program. Note that the override only applies to the\ncurrently executing thread; other threads will not see the change from with_default.\n\nOnce a collector has been set, instrumentation points may be added to the\nexecutable using the `tracing` crate's macros.\n\n[`tracing-subscriber`]: https://docs.rs/tracing-subscriber/\n[fmt]: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/index.html\n[`init()`]: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/fn.init.html\n[`set_global_default()`]: https://docs.rs/tracing/latest/tracing/subscriber/fn.set_global_default.html\n\n### In Libraries\n\nLibraries should only rely on the `tracing` crate and use the provided macros\nand types to collect whatever information might be useful to downstream consumers.\n\n```rust\nuse std::{error::Error, io};\nuse tracing::{debug, error, info, span, warn, Level};\n\n// the `#[tracing::instrument]` attribute creates and enters a span\n// every time the instrumented function is called. The span is named after\n// the function or method. Parameters passed to the function are recorded as fields.\n#[tracing::instrument]\npub fn shave(yak: usize) -> Result<(), Box<dyn Error + 'static>> {\n    // this creates an event at the DEBUG level with two fields:\n    // - `excitement`, with the key \"excitement\" and the value \"yay!\"\n    // - `message`, with the key \"message\" and the value \"hello! I'm gonna shave a yak.\"\n    //\n    // unlike other fields, `message`'s shorthand initialization is just the string itself.\n    debug!(excitement = \"yay!\", \"hello! I'm gonna shave a yak.\");\n    if yak == 3 {\n        warn!(\"could not locate yak!\");\n        // note that this is intended to demonstrate `tracing`'s features, not idiomatic\n        // error handling! in a library or application, you should consider returning\n        // a dedicated `YakError`. libraries like snafu or thiserror make this easy.\n        return Err(io::Error::new(io::ErrorKind::Other, \"shaving yak failed!\").into());\n    } else {\n        debug!(\"yak shaved successfully\");\n    }\n    Ok(())\n}\n\npub fn shave_all(yaks: usize) -> usize {\n    // Constructs a new span named \"shaving_yaks\" at the TRACE level,\n    // and a field whose key is \"yaks\". This is equivalent to writing:\n    //\n    // let span = span!(Level::TRACE, \"shaving_yaks\", yaks = yaks);\n    //\n    // local variables (`yaks`) can be used as field values\n    // without an assignment, similar to struct initializers.\n    let span = span!(Level::TRACE, \"shaving_yaks\", yaks);\n    let _enter = span.enter();\n\n    info!(\"shaving yaks\");\n\n    let mut yaks_shaved = 0;\n    for yak in 1..=yaks {\n        let res = shave(yak);\n        debug!(yak, shaved = res.is_ok());\n\n        if let Err(ref error) = res {\n            // Like spans, events can also use the field initialization shorthand.\n            // In this instance, `yak` is the field being initialized.\n            error!(yak, error = error.as_ref(), \"failed to shave yak!\");\n        } else {\n            yaks_shaved += 1;\n        }\n        debug!(yaks_shaved);\n    }\n\n    yaks_shaved\n}\n```\n\n```toml\n[dependencies]\ntracing = \"0.1\"\n```\n\nNote: Libraries should *NOT* install a collector by using a method that calls\n[`set_global_default()`], as this will cause conflicts when executables try to\nset the default later.\n\n### In Asynchronous Code\n\nTo trace `async fn`s, the preferred method is using the [`#[instrument]`][instrument] attribute:\n\n```rust\nuse tracing::{info, instrument};\nuse tokio::{io::AsyncWriteExt, net::TcpStream};\nuse std::io;\n\n#[instrument]\nasync fn write(stream: &mut TcpStream) -> io::Result<usize> {\n    let result = stream.write(b\"hello world\\n\").await;\n    info!(\"wrote to stream; success={:?}\", result.is_ok());\n    result\n}\n```\n\nSpecial handling is needed for the general case of code using\n[`std::future::Future`][std-future] or blocks with `async`/`await`, as the\nfollowing example _will not_ work:\n\n```rust\nasync {\n    let _s = span.enter();\n    // ...\n}\n```\n\nThe span guard `_s` will not exit until the future generated by the `async` block is complete.\nSince futures and spans can be entered and exited _multiple_ times without them completing,\nthe span remains entered for as long as the future exists, rather than being entered only when\nit is polled, leading to very confusing and incorrect output.\nFor more details, see [the documentation on closing spans][closing].\n\nThis problem can be solved using the [`Future::instrument`] combinator:\n\n```rust\nuse tracing::Instrument;\n\nlet my_future = async {\n    // ...\n};\n\nmy_future\n    .instrument(tracing::info_span!(\"my_future\"))\n    .await\n```\n\n`Future::instrument` attaches a span to the future, ensuring that the span's lifetime\nis as long as the future's.\n\nUnder the hood, the [`#[instrument]`][instrument] macro performs the same explicit span\nattachment that `Future::instrument` does.\n\n[std-future]: https://doc.rust-lang.org/stable/std/future/trait.Future.html\n[closing]: https://docs.rs/tracing/latest/tracing/span/index.html#closing-spans\n[`Future::instrument`]: https://docs.rs/tracing/latest/tracing/trait.Instrument.html#method.instrument\n[instrument]: https://docs.rs/tracing/latest/tracing/attr.instrument.html\n\n## Supported Rust Versions\n\nTracing is built against the latest stable release. The minimum supported\nversion is 1.63. The current Tracing version is not guaranteed to build on Rust\nversions earlier than the minimum supported version.\n\nTracing follows the same compiler support policies as the rest of the Tokio\nproject. The current stable Rust compiler and the three most recent minor\nversions before it will always be supported. For example, if the current stable\ncompiler version is 1.69, the minimum supported version will not be increased\npast 1.66, three minor versions prior. Increasing the minimum supported compiler\nversion is not considered a semver breaking change as long as doing so complies\nwith this policy.\n\n## Getting Help\n\nFirst, see if the answer to your question can be found in the API documentation.\nIf the answer is not there, there is an active community in\nthe [Tracing Discord channel][chat]. We would be happy to try to answer your\nquestion. Last, if that doesn't work, try opening an [issue] with the question.\n\n[chat]: https://discord.gg/EeF3cQw\n[issue]: https://github.com/tokio-rs/tracing/issues/new\n\n## Contributing\n\n:balloon: Thanks for your help improving the project! We are so happy to have\nyou! We have a [contributing guide][guide] to help you get involved in the Tracing\nproject.\n\n[guide]: CONTRIBUTING.md\n\n## Project layout\n\nThe [`tracing`] crate contains the primary _instrumentation_ API, used for\ninstrumenting libraries and applications to emit trace data. The [`tracing-core`]\ncrate contains the _core_ API primitives on which the rest of `tracing` is\ninstrumented. Authors of trace subscribers may depend on `tracing-core`, which\nguarantees a higher level of stability.\n\nAdditionally, this repository contains several compatibility and utility\nlibraries built on top of `tracing`. Some of these crates are in a pre-release\nstate, and are less stable than the `tracing` and `tracing-core` crates.\n\nThe crates included as part of Tracing are:\n\n* [`tracing-futures`]: Utilities for instrumenting `futures`.\n  ([crates.io][fut-crates]|[docs][fut-docs])\n\n* [`tracing-macros`]: Experimental macros for emitting trace events (unstable).\n\n* [`tracing-attributes`]: Procedural macro attributes for automatically\n    instrumenting functions. ([crates.io][attr-crates]|[docs][attr-docs])\n\n* [`tracing-log`]: Compatibility with the `log` crate (unstable).\n\n* [`tracing-serde`]: A compatibility layer for serializing trace data with\n    `serde` (unstable).\n\n* [`tracing-subscriber`]: Collector implementations, and utilities for\n  implementing and composing `Collector`s.\n  ([crates.io][sub-crates]|[docs][sub-docs])\n\n* [`tracing-tower`]: Compatibility with the `tower` ecosystem (unstable).\n\n* [`tracing-appender`]: Utilities for outputting tracing data, including a file appender\n   and non-blocking writer. ([crates.io][app-crates]|[docs][app-docs])\n\n* [`tracing-error`]: Provides `SpanTrace`, a type for instrumenting errors with\n  tracing spans\n\n* [`tracing-flame`]; Provides a layer for generating flame graphs based on\n  tracing span entry / exit events.\n\n* [`tracing-journald`]: Provides a layer for recording events to the\n  Linux `journald` service, preserving structured data.\n\n[`tracing`]: tracing\n[`tracing-core`]: tracing-core\n[`tracing-futures`]: tracing-futures\n[`tracing-macros`]: tracing-macros\n[`tracing-attributes`]: tracing-attributes\n[`tracing-log`]: tracing-log\n[`tracing-serde`]: tracing-serde\n[`tracing-subscriber`]: tracing-subscriber\n[`tracing-tower`]: tracing-tower\n[`tracing-appender`]: tracing-appender\n[`tracing-error`]: tracing-error\n[`tracing-flame`]: tracing-flame\n[`tracing-journald`]: tracing-journald\n\n[fut-crates]: https://crates.io/crates/tracing-futures\n[fut-docs]: https://docs.rs/tracing-futures\n\n[attr-crates]: https://crates.io/crates/tracing-attributes\n[attr-docs]: https://docs.rs/tracing-attributes\n\n[sub-crates]: https://crates.io/crates/tracing-subscriber\n[sub-docs]: https://docs.rs/tracing-subscriber\n\n[otel-crates]: https://crates.io/crates/tracing-opentelemetry\n[otel-docs]: https://docs.rs/tracing-opentelemetry\n[OpenTelemetry]: https://opentelemetry.io/\n\n[app-crates]: https://crates.io/crates/tracing-appender\n[app-docs]: https://docs.rs/tracing-appender\n\n## Related Crates\n\nIn addition to this repository, here are also several third-party crates which\nare not maintained by the `tokio` project. These include:\n\n- [`tracing-timing`] implements inter-event timing metrics on top of `tracing`.\n  It provides a subscriber that records the time elapsed between pairs of\n  `tracing` events and generates histograms.\n- [`tracing-honeycomb`] Provides a layer that reports traces spanning multiple machines to [honeycomb.io]. Backed by [`tracing-distributed`].\n- [`tracing-distributed`] Provides a generic implementation of a layer that reports traces spanning multiple machines to some backend.\n- [`tracing-actix-web`] provides `tracing` integration for the `actix-web` web framework.\n- [`tracing-actix`] provides `tracing` integration for the `actix` actor\n  framework.\n- [`axum-insights`] provides `tracing` integration and Application insights export for the `axum` web framework.\n- [`tracing-gelf`] implements a subscriber for exporting traces in Greylog\n  GELF format.\n- [`tracing-coz`] provides integration with the [coz] causal profiler\n  (Linux-only).\n- [`tracing-bunyan-formatter`] provides a layer implementation that reports events and spans in [bunyan] format, enriched with timing information.\n- [`tide-tracing`] provides a [tide] middleware to trace all incoming requests and responses.\n- [`color-spantrace`] provides a formatter for rendering span traces in the\n  style of `color-backtrace`\n- [`color-eyre`] provides customized panic and eyre report handlers for\n  `eyre::Report` for capturing span traces and backtraces with new errors and\n  pretty printing them.\n- [`spandoc`] provides a proc macro for constructing spans from doc comments\n  _inside_ of functions.\n- [`tracing-wasm`] provides a `Collector`/`Subscriber` implementation that reports\n  events and spans via browser `console.log` and [User Timing API (`window.performance`)].\n- [`tracing-web`] provides a layer implementation of level-aware logging of events\n  to web browsers' `console.*` and span events to the [User Timing API (`window.performance`)].\n- [`test-log`] takes care of initializing `tracing` for tests, based on\n  environment variables with an `env_logger` compatible syntax.\n- [`tracing-unwrap`] provides convenience methods to report failed unwraps on `Result` or `Option` types to a `Collector`.\n- [`diesel-tracing`] provides integration with [`diesel`] database connections.\n- [`tracing-tracy`] provides a way to collect [Tracy] profiles in instrumented\n  applications.\n- [`tracing-elastic-apm`] provides a layer for reporting traces to [Elastic APM].\n- [`tracing-etw`] provides a layer for emitting Windows [ETW] events.\n- [`sentry-tracing`] provides a layer for reporting events and traces to [Sentry].\n- [`tracing-forest`] provides a subscriber that preserves contextual coherence by \n  grouping together logs from the same spans during writing.\n- [`tracing-loki`] provides a layer for shipping logs to [Grafana Loki].\n- [`tracing-logfmt`] provides a layer that formats events and spans into the logfmt format.\n- [`tracing-chrome`] provides a layer that exports trace data that can be viewed in `chrome://tracing`.\n- [`reqwest-tracing`] provides a middleware to trace [`reqwest`] HTTP requests.\n- [`tracing-cloudwatch`] provides a layer that sends events to AWS CloudWatch Logs.\n- [`clippy-tracing`] provides a tool to add, remove and check for `tracing::instrument`.\n\n(if you're the maintainer of a `tracing` ecosystem crate not in this list,\nplease let us know!)\n\n[`tracing-timing`]: https://crates.io/crates/tracing-timing\n[`tracing-honeycomb`]: https://crates.io/crates/tracing-honeycomb\n[`tracing-distributed`]: https://crates.io/crates/tracing-distributed\n[honeycomb.io]: https://www.honeycomb.io/\n[`tracing-actix`]: https://crates.io/crates/tracing-actix\n[`tracing-actix-web`]: https://crates.io/crates/tracing-actix-web\n[`axum-insights`]: https://crates.io/crates/axum-insights\n[`tracing-gelf`]: https://crates.io/crates/tracing-gelf\n[`tracing-coz`]: https://crates.io/crates/tracing-coz\n[coz]: https://github.com/plasma-umass/coz\n[`tracing-bunyan-formatter`]: https://crates.io/crates/tracing-bunyan-formatter\n[`tide-tracing`]: https://crates.io/crates/tide-tracing\n[tide]: https://crates.io/crates/tide\n[bunyan]: https://github.com/trentm/node-bunyan\n[`color-spantrace`]: https://docs.rs/color-spantrace\n[`color-eyre`]: https://docs.rs/color-eyre\n[`spandoc`]: https://docs.rs/spandoc\n[`tracing-wasm`]: https://docs.rs/tracing-wasm\n[`tracing-web`]: https://crates.io/crates/tracing-web\n[`test-log`]: https://crates.io/crates/test-log\n[User Timing API (`window.performance`)]: https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API\n[`tracing-unwrap`]: https://docs.rs/tracing-unwrap\n[`diesel`]: https://crates.io/crates/diesel\n[`diesel-tracing`]: https://crates.io/crates/diesel-tracing\n[`tracing-tracy`]: https://crates.io/crates/tracing-tracy\n[Tracy]: https://github.com/wolfpld/tracy\n[`tracing-elastic-apm`]: https://crates.io/crates/tracing-elastic-apm\n[Elastic APM]: https://www.elastic.co/apm\n[`tracing-etw`]: https://github.com/microsoft/rust_win_etw/tree/main/win_etw_tracing\n[ETW]: https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing\n[`sentry-tracing`]: https://crates.io/crates/sentry-tracing\n[Sentry]: https://sentry.io/welcome/\n[`tracing-forest`]: https://crates.io/crates/tracing-forest\n[`tracing-loki`]: https://crates.io/crates/tracing-loki\n[Grafana Loki]: https://grafana.com/oss/loki/\n[`tracing-logfmt`]: https://crates.io/crates/tracing-logfmt\n[`tracing-chrome`]: https://crates.io/crates/tracing-chrome\n[`reqwest-tracing`]: https://crates.io/crates/reqwest-tracing\n[`reqwest`]: https://crates.io/crates/reqwest\n[`tracing-cloudwatch`]: https://crates.io/crates/tracing-cloudwatch\n[`clippy-tracing`]: https://crates.io/crates/clippy-tracing\n\n**Note:** that some of the ecosystem crates are currently unreleased and\nundergoing active development. They may be less stable than `tracing` and\n`tracing-core`.\n\n## External Resources\n\nThis is a list of links to blog posts, conference talks, and tutorials about\nTracing.\n\n#### Blog Posts\n\n* [Diagnostics with Tracing][tokio-blog-2019-08] on the Tokio blog, August 2019\n* [Production-Grade Logging in Rust Applications][production-logging-2020], November 2020\n* [Custom Logging in Rust using `tracing` and `tracing-subscriber`, part 1][custom-logging-part-1] and [part 2][custom-logging-part-2], October 2021\n* [Instrumenting Axum projects][detsys-blog-2023-08], August 2023\n\n[tokio-blog-2019-08]: https://tokio.rs/blog/2019-08-tracing/\n[detsys-blog-2023-08]: https://determinate.systems/posts/instrumenting-axum\n\n#### Talks\n\n* [Bay Area Rust Meetup talk and Q&A][bay-rust-2019-03], March 2019\n* [RustConf 2019 talk][rust-conf-2019-08-video] and [slides][rust-conf-2019-08-slides], August 2019\n* [Are we observable yet? @ RustyDays talk][rusty-days-2020-08-video] and [slides][rusty-days-2020-08-slides], August 2020\n* [Crabs with instruments!][tremorcon-2021-09], September 2021\n* [Decrusting the tracing crate by Jon Gjengset][decrusting-tracing-2024-02], February 2024\n\n[bay-rust-2019-03]: https://www.youtube.com/watch?v=j_kXRg3zlec\n[rust-conf-2019-08-video]: https://www.youtube.com/watch?v=JjItsfqFIdo\n[rust-conf-2019-08-slides]: https://www.elizas.website/slides/rustconf-8-2019.pdf\n[rusty-days-2020-08-video]: https://youtu.be/HtKnLiFwHJM\n[rusty-days-2020-08-slides]: https://docs.google.com/presentation/d/1zrxJs7fJgQ29bKfnAll1bYTo9cYZxsCZUwDDtyp5Fak/edit?usp=sharing\n[production-logging-2020]: https://medium.com/better-programming/production-grade-logging-in-rust-applications-2c7fffd108a6\n[custom-logging-part-1]: https://burgers.io/custom-logging-in-rust-using-tracing\n[custom-logging-part-2]: https://burgers.io/custom-logging-in-rust-using-tracing-part-2\n[tremorcon-2021-09]: https://www.youtube.com/watch?v=ZC7fyqshun8\n[decrusting-tracing-2024-02]: https://www.youtube.com/watch?v=21rtHinFA40\n\nHelp us expand this list! If you've written or spoken about Tracing, or\nknow of resources that aren't listed, please open a pull request adding them.\n\n## License\n\nThis project is licensed under the [MIT license](LICENSE).\n\n### Contribution\n\nUnless you explicitly state otherwise, any contribution intentionally submitted\nfor inclusion in Tracing by you, shall be licensed as MIT, without any additional\nterms or conditions.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.341796875,
          "content": "# Security Policy\n\nTracing is part of the Tokio project and uses the same security policy as [Tokio][tokio-security].\n\n## Report a security issue\n\nThe process for reporting an issue is the same as for [Tokio][tokio-security]. This includes private reporting via security@tokio.rs.\n\n[tokio-security]: https://github.com/tokio-rs/tokio/security/policy\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "clippy.toml",
          "type": "blob",
          "size": 0.12109375,
          "content": "disallowed-names = []\ncognitive-complexity-threshold = 100\ntoo-many-arguments-threshold = 8\ntype-complexity-threshold = 375\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "netlify.toml",
          "type": "blob",
          "size": 0.5498046875,
          "content": "[build]\n  command = \"\"\"\n    rustup install nightly --profile minimal \\\n      && cargo doc --no-deps --all-features\n    \"\"\"\n  publish = \"target/doc\"\n\n[build.environment]\n  RUSTDOCFLAGS=\"\"\"\n    -D warnings \\\n    --force-warn rustdoc::redundant-explicit-links \\\n    --force-warn renamed-and-removed-lints \\\n    --cfg docsrs \\\n    --html-before-content /opt/build/repo/assets/warning.html \\\n    --html-in-header /opt/build/repo/assets/noindex.html \\\n    --html-in-header /opt/build/repo/assets/warning-css.html \\\n    \"\"\"\n\n[[redirects]]\n  from = \"/\"\n  to = \"/tracing\"\n"
        },
        {
          "name": "tracing-appender",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-attributes",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-core",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-error",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-flame",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-futures",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-journald",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-log",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-macros",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-mock",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-serde",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-subscriber",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing-tower",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}