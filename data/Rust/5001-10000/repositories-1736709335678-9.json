{
  "metadata": {
    "timestamp": 1736709335678,
    "page": 9,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rust-bakery/nom",
      "stars": 9617,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.111328125,
          "content": "target/*\nCargo.lock\nFullRecognition.jpg\nmap.rs\noldsrc/\nrealworld/\nsrc/generator.rs\n.DS_Store\nprivate-docs/\n.idea/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 59.4892578125,
          "content": "# Change Log\n\n## [Unreleased][unreleased]\n\n### Thanks\n\n### Removed\n\n- `nom::bits::*` is no longer re-exported at the crate root. This export caused frequent confusion, since e.g. `nom::complete::tag` referred to `nom::bits::complete::tag` instead of the much more commonly used `nom::bytes::complete::tag`. To migrate, change any imports of `nom::{complete::*, streaming::*, bits, bytes}` to `nom::bits::[...]`.\n\n### Changed\n\n## 7.1.2 - 2023-01-01\n\n### Thanks\n\n- @joubs\n- @Fyko\n- @LoganDark\n- @darnuria\n- @jkugelman\n- @barower\n- @puzzlewolf\n- @epage\n- @cky\n- @wolthom\n- @w1ll-i-code\n\n### Changed\n\n- documentation fixes\n- tests fixes\n- limit the initial capacity of the result vector of `many_m_n` to 64kiB\n- bits parser now accept `Parser` implementors instead of only functions\n\n### Added\n\n- implement `Tuple` parsing for the unit type as a special case\n- implement `ErrorConvert` on the unit type to make it usable as error type for bits parsers\n- bool parser for bits input\n\n## 7.1.1 - 2022-03-14\n\n### Thanks\n\n- @ThomasdenH\n- @@SphinxKnight\n- @irevoire\n- @doehyunbaek\n- @pxeger\n- @punkeel\n- @max-sixty\n- @Xiretza\n- @5c077m4n\n- @erihsu\n- @TheNeikos\n- @LoganDark\n- @nickelc\n- @chotchki\n- @ctrlcctrlv\n\n\n### Changed\n\n- documentation fixes\n- more examples\n\n## 7.1.0 - 2021-11-04\n\n### Thanks\n\n- @nickelc\n- @Stargateur\n- @NilsIrl\n- @clonejo\n- @Strytyp\n- @schubart\n- @jihchi\n- @nipunn1313\n- @Gungy2\n- @Drumato\n- @Alexhuszagh\n- @Aehmlo\n- @homersimpsons\n- @dne\n- @epage\n- @saiintbrisson\n- @pymongo\n\n### Changed\n\n- documentation fixes\n- Ci fixes\n- the move to minimal-lexical for float parsing introduced bugs that cannot be resolved right now, so this version moves back to using the standard lib' parser. *This is a performance regression**. If you have specific requirements around float parsing, you are strongly encouraged to use [recognize_float](https://docs.rs/nom/latest/nom/number/complete/fn.recognize_float.html) and another library to convert to a f32 or f64\n\n### Added\n\n- alt now works with 1 elment tuples\n\n## 7.0.0 - 2021-08-21\n\nThis release fixes dependency compilation issues and strengthen the minimum supported Rust version (MSRV) policy. This is also the first release without the macros that were used since nom's beginning.\n\n### Thanks\n\n- @djc\n- @homersimpsons\n- @lo48576\n- @myrrlyn\n- @RalXYZ\n- @nickelc\n- @cenodis\n\n### Added\n\n- `take_until1` combinator\n- more `to_owned` implementations\n- `fail`: a parser that always fail, useful as default condition in other combinators\n- text to number parsers: in the `character::streaming` and `character::complete` modules, there are parsers named `i8, u16, u32, u64, u128` and `u8 ,u16, u32, u64, u128` that recognize decimal digits and directly convert to a number in the target size (checking for max int size)\n\n### Removed\n\n- now that function combinators are the main way to write parsers, the old macro combinators are confusing newcomers. THey have been removed\n- the `BitSlice` input type from bitvec has been moved into the [nom-bitvec](https://crates.io/crates/nom-bitvec) crate. nom does not depend on bitvec now\n- regex parsers have been moved into the [nom-regex](https://crates.io/crates/nom-regex) crate. nom does not depend on regex now\n- `ErrorKind::PArseTo` was not needed anymore\n\n### Changed\n\n- relax trait bounds\n- some performance fixes\n- `split_at_position*` functions should now be guaranteed panic free\n- the `lexical-core` crate used for float parsing has now been replaced with `minimal-lexical`: the new crate is faster to compile, faster to parse, and has no dependencies\n\n### Fixed\n\n- infinite loop in `escaped` combinator\n- `many_m_n` now fails if min > max\n\n\n## 6.2.1 - 2021-06-23\n\n### Thanks\n\nThis release was done thanks to the hard work of (by order of appearance in the commit list):\n\n- @homersimpsons\n\n### Fixed\n\n- fix documentation building\n\n## 6.2.0 - 2021-02-15\n\n### Thanks\n\nThis release was done thanks to the hard work of (by order of appearance in the commit list):\n\n- @DavidKorczynski\n- @homersimpsons\n- @kornelski\n- @lf-\n- @lewisbelcher\n- @ronan-d\n- @weirane\n- @heymind\n- @marcianx\n- @Nukesor\n\n### Added\n\n- nom is now regularly fuzzed through the OSSFuzz project\n\n### Changed\n\n- lots of documentation fixes\n- relax trait bounds\n- workarounds for dependency issues with bitvec and memchr\n\n## 6.1.2 - 2021-02-15\n\n### Changed\n\n- Fix cargo feature usage in previous release\n\n## 6.1.1 - 2021-02-15\n\n### Thanks\n\nThis release was done thanks to the hard work of (by order of appearance in the commit list):\n\n- @nickelc\n\n### Changed\n\n- Fix dependenciy incompatibilities: Restrict the bitvec->funty dependency to <=1.1\n\n## 6.1.0 - 2021-01-23\n\n### Thanks\n\nThis release was done thanks to the hard work of (by order of appearance in the commit list):\n\n- @sachaarbonel\n- @vallentin\n- @Lucretiel\n- @meiomorphism\n- @jufajardini\n- @neithernut\n- @drwilco\n\n### Changed\n\n- readme and documentation fixes\n- rewrite of fold_many_m_n\n- relax trait bounds on some parsers\n- implement `std::error::Error` on `VerboseError`\n\n\n## 6.0.1 - 2020-11-24\n\n### Thanks\n\nThis release was done thanks to the hard work of (by order of appearance in the commit list):\n\n- @Leonqn\n- @nickelc\n- @toshokan\n- @juchiast\n- @shssoichiro\n- @jlkiri\n- @chifflier\n- @fkloiber\n- @Kaoet\n- @Matthew Plant\n\n### Added\n\n- `ErrorConvert` implementation for `VerboseError`\n\n### Changed\n\n- CI fixes\n- `fold_many*` now accept `FnMut` for the accumulation function\n- relaxed input bounds on `length_count`\n\n# Fixed\n\n- documentation fixes\n- the `#[deprecated]` attribute was removed from traits because it does not compile anymore on nightly\n- bits and bytes combinators from the bits modules are now converted to use `FnMut`\n\n## 6.0.0 - 2020-10-31\n\n### Thanks\n\nThis release was done thanks to the hard work of (by order of appearance in the commit list):\n- @chifflier\n- @shepmaster\n- @amerelo\n- @razican\n- @Palladinium\n- @0ndorio\n- Sebastian Zivota\n- @keruspe\n- @devonhollowood\n- @parasyte\n- @nnt0\n- @AntoineCezar\n- @GuillaumeGomez\n- @eijebong\n- @stadelmanma\n- @sphynx\n- @snawaz\n- @fosskers\n- @JamesHarrison\n- @calebsander\n- @jthornber\n- @ahmedcharles\n- @rljacobson\n- @benkay86\n- @georgeclaghorn\n- @TianyiShi2001\n- @shnewto\n- @alfriadox\n- @resistor\n- @myrrlyn\n- @chipsenkbeil\n- @ruza-net\n- @fanf2\n- @jameysharp\n- @FallenWarrior2k\n- @jmg-duarte\n- @ericseppanen\n- @hbina\n- Andreas Molzer\n- @nickelc\n- @bgourlie\n\n## Notable changes\n\nThis release is a more polished version of nom 5, that came with a focus on\nfunction parsers, by relaxing the requirements: combinators will return a\n`impl FnMut` instead of `impl Fn`, allowing closures that change their context,\nand parsers can be any type now, as long as they implement the new `Parser` trait.\nThat parser trait also comes with a few helper methods.\n\nError management was often a pain point, so a lot of work went into making it easier.\nNow it integrates with `std:error::Error`, the `IResult::finish()` method allows you\nto convert to a more usable type, the `into` combinator can convert the error type\nif there's a `From` implementation, and there are more specific error traits like\n`ContextError` for the `context` combinator, and `FromExternalError` for `map_res`.\nWhile the `VerboseError` type and its `convert_error` function saw some changes,\nnot many features ill be added to it, instead you are encouraged to build the error\ntype that corresponds to your needs if you are building a language parser.\n\nThis version also integrates with the excellent [bitvec](https://crates.io/crates/bitvec)\ncrate for better bit level parsing. This part of nom was not great and a bit of a hack,\nso this will give better options for those parsers.\n\nAt last, documentation! There are now more code examples, functions and macros that require\nspecific cargo features are now clearly indicated, and there's a new `recipes` module\ncontaining example patterns.\n\n### Breaking changes\n\n- the minimal Rust version is now 1.44 (1.37 if building without the `alloc` or `std` features)\n- streaming parsers return the number of additional bytes they need, not the total. This was supposed to be the case everywhere, but some parsers were forgotten\n- removed the `regexp_macros` cargo feature\n- the `context` combinator is not linked to `ParseError` anymore, instead it come with its own `ContextError` trait\n- `Needed::Size` now contains a `NonZeroUsize`, so we can reduce the structure's size by 8 bytes. When upgrading, `Needed::Size(number)` can be replaced with `Needed::new(number)`\n- there is now a more general `Parser` trait, so parsers can be something else than a function. This trait also comes with combinator methods like `map`, `flat_map`, `or`. Since it is implemented on `Fn*` traits, it should not affect existing code too much\n- combinators that returned a `impl Fn` now return a `impl FnMut` to allow parser closures that capture some mutable value from the context\n- `separated_list` is now `separated_list0`\n- removed the deprecated `methods` module\n- removed the deprecated `whitespace` module\n- the default error type is now a struct (`nom::error::Error`) instead of a tuple\n- the `FromExternalError` allows wrapping the error returned by the function in the `map_res` combinator\n- renamed the `dbg!` macro to avoid conflicts with `std::dbg!`\n- `separated_list` now allows empty elements\n\n\n### Added\n\n- function version of regex parsers\n- `fill`: attempts to fill the output slice passed as argument\n- `success`: returns a value without consuming the input\n- `satisfy`: checks a predicate over the next character\n- `eof` function combinator\n- `consumed`: returns the produced value and the consumed input\n- `length_count` function combinator\n- `into`: converts a parser's output and error values if `From` implementations are available\n- `IResult::finish()`: converts a parser's result to `Result<(I, O), E>` by removing the distinction between `Error` and `Failure` and panicking on `Incomplete`\n- non macro versions of `u16`, `i32`, etc, with configurable endianness\n- `is_newline` function\n- `std::error::Error` implementation for nom's error types\n- recipes section of the documentation, outlining common patterns in nom\n- custom errors example\n- bitstream parsing with the `BitSlice` type from the bitvec crate\n- native endianness parsers\n- github actions for CI\n\n### Changed\n\n- allows lexical-core 0.7\n- number parsers are now generic over the input type\n- stabilized the `alloc` feature\n- `convert_error` accepts a type that derefs to `&str`\n- the JSON example now follows the spec better\n\n### Fixed\n- use `fold_many0c` in the `fold_many0` macro\n\n## 5.1.1 - 2020-02-24\n\n### Thanks\n\n- @Alexhuszagh for float fixes\n- @AlexanderEkdahl, @JoshOrndorff, @akitsu-sanae for docs fixes\n- @ignatenkobrain: dependency update\n- @derekdreery: `map` implementation for errors\n- @Lucretiel for docs fixes and compilation fixes\n- adytzu2007: warning fixes\n- @lo48576: error management fixes\n\n### Fixed\n\n- C symbols compilation errors due to old lexical-core version\n\n### Added\n\n- `Err` now has a `map` function\n\n### Changed\n\n- Make `error::context()` available without `alloc` feature\n\n## 5.1.0 - 2020-01-07\n\n### Thanks\n\n- @Hywan, @nickmooney, @jplatte, @ngortheone, @ejmg, @SirWindfield, @demurgos, @spazm, @nyarly, @guedou, @adamnemecek, for docs fixes\n- @Alxandr for error management bugfixes\n- @Lucretiel for example fixes and optimizations\n- @adytzu2007 for optimizations\n- @audunhalland for utf8 fixes\n\n### Fixed\n\n- panic in `convert_error`\n- `compile_error` macro usage\n\n### Added\n\n- `std::error::Error`, `std::fmt::Display`, `Eq`, `ToOwned` implementations for errors\n- inline attribute for  `ToUsize`\n\n### Changed\n\n- `convert_error` optimization\n- `alt` optimization\n\n## 5.0.1 - 2019-08-22\n\n### Thanks\n\n- @waywardmonkeys, @phaazon, @dalance for docs fixes\n- @kali for `many0_m_n` fixes\n- @ia0 for macros fixes\n\n### Fixed\n\n- `many0_m_n` now supports the n=1 case\n- relaxed trait requirements in `cut`\n- `peek!` macro reimplementation\n- type inference in `value!`\n\n## 5.0.0 - 2019-06-24\n\nThis version comes with a complete rewrite of nom internals to use functions as a base\nfor parsers, instead of macros. Macros have been updated to use functions under\nthe hood, so that most existing parsers will work directly or require minimal changes.\n\nThe `CompleteByteSlice` and `CompleteStr` input types were removed. To get different\nbehaviour related to streaming or complete input, there are different versions of some\nparsers in different submodules, like `nom::character::streaming::alpha0` and\n`nom::character::complete::alpha0`.\n\nThe `verbose-errors` feature is gone, now the error type is decided through a generic\nbound. To get equivalent behaviour to `verbose-errors`, check out `nom::error::VerboseError`\n\n### Thanks\n\n- @lowenheim helped in refactoring and error management\n- @Keruspe helped in refactoring and fixing tests\n- @pingiun, @Songbird0, @jeremystucki, @BeatButton, @NamsooCho, @Waelwindows, @rbtcollins, @MarkMcCaskey for a lot of help in rewriting the documentation and adding code examples\n- @GuillaumeGomez for documentation rewriting and checking\n- @iosmanthus for bug fixes\n- @lo48576 for error management fixes\n- @vaffeine for macros visibility fixes\n- @webholik and @Havvy for `escaped` and `escaped_transform` fixes\n- @proman21 for help on porting bits parsers\n\n### Added\n\n- the `VerboseError` type accumulates position info and error codes, and can generate a trace with span information\n- the `lexical-core` crate is now used by default (through the `lexical` compilation feature) to parse floats from text\n- documentation and code examples for all functions and macros\n\n### Changed\n\n- nom now uses functions instead of macros to generate parsers\n- macros now use the functions under the hood\n- the minimal Rust version is now 1.31\n- the verify combinator's condition function now takes its argument by reference\n- `cond` will now return the error of the parser instead of None\n- `alpha*`, `digit*`, `hex_digit*`, `alphanumeric*` now recognize only ASCII characters\n\n### Removed\n\n- deprecated string parsers (with the `_s` suffix), the normal version can be used instead\n- `verbose-errors` is not needed anymore, now the error type can be decided when writing the parsers, and parsers provided by nom are generic over the error type\n- `AtEof`, `CompleteByteSlice` and `CompleteStr` are gone, instead some parsers are specialized to work on streaming or complete input, and provided in different modules\n- character parsers that were aliases to their `*1` version: eol, alpha, digit, hex_digit, oct_digit, alphanumeric, space, multispace\n- `count_fixed` macro\n- `whitespace::sp` can be replaced by `character::complete::multispace0`\n- method combinators are now in the nom-methods crate\n- `take_until_either`, `take_until_either1`, `take_until_either_and_consume` and `take_until_either_and_consume1`: they can be replaced with `is_not` (possibly combined with something else)\n- `take_until_and_consume`, `take_until_and_consume1`: they can be replaced with `take_until` combined with `take`\n- `sized_buffer` and `length_bytes!`: they can be replaced with the `length_data` function\n- `non_empty`, `begin` and `rest_s` function\n- `cond_reduce!`, `cond_with_error!`, `closure!`, `apply`, `map_res_err!`, `expr_opt!`, `expr_res!`\n- `alt_complete`, `separated_list_complete`, `separated_nonempty_list_complete`\n\n## 4.2.3 - 2019-03-23\n\n### Fixed\n\n- add missing `build.rs` file to the package\n- fix code comparison links in changelog\n\n## 4.2.2 - 2019-03-04\n\n### Fixed\n\n- regression in do_parse macro import for edition 2018\n\n## 4.2.1 - 2019-02-27\n\n### Fixed\n\n- macro expansion error in `do_parse` due to `compile_error` macro usage\n\n## 4.2.0 - 2019-01-29\n\n### Thanks\n\n- @JoshMcguigan for unit test fixes\n- @oza for documentation fixes\n- @wackywendell for better error conversion\n- @Zebradil for documentation fixes\n- @tsraom for new combinators\n- @hcpl for minimum Rust version tests\n- @KellerFuchs for removing some unsafe uses in float parsing\n\n### Changed\n\n- macro import in edition 2018 code should work without importing internal macros now\n- the regex parsers do not require the calling code to have imported the regex crate anymore\n- error conversions are more ergonomic\n- method combinators are now deprecated. They might be moved to a separate crate\n- nom now specifies Rust 1.24.1 as minimum version. This was already the case before, now it is made explicit\n\n### Added\n\n- `many0_count` and `many1_count` to count applications of a parser instead of\naccumulating its results in a `Vec`\n\n### Fixed\n\n- overflow in the byte wrapper for bit level parsers\n- `f64` parsing does not use `transmute` anymore\n\n## 4.1.1 - 2018-10-14\n\n### Fixed\n\n- compilation issue in verbose-errors mode for `add_return_error`\n\n## 4.1.0 - 2018-10-06\n\n### Thanks\n\n- @xfix for fixing warnings, simplifying examples and performance fixes\n- @dvberkel for documentation fixes\n- @chifflier for fixing warnings\n- @myrrlyn for dead code elimination\n- @petrochenkov for removing redundant test macros\n- @tbelaire for documentation fixes\n- @khernyo for fixing warnings\n- @linkmauve for documentation fixes\n- @ProgVal for documentation fixes, warning fixes and error management\n- @Nemo157 for compilation fixes\n- @RReverser for documentation fixes\n- @xpayn for fixing warnings\n- Blas Rodriguez Irizar for documentation fixes\n- @badboy for documentation fixes\n- @kyrias for compilation fixes\n- @kurnevsky for the `rest_len` parser\n- @hjr3 for new documentation examples\n- @fengalin for error management\n- @ithinuel for the pcap example project\n- @phaazon for documentation fixes\n- @juchiast for documentation fixes\n- @jrakow for the `u128` and `i128` parsers\n- @smarnach for documentation fixes\n- @derekdreery for `pub(crate)` support\n- @YaLTeR for `map_res_err!`\n\n### Added\n\n- `rest_len` parser, returns the length of the remaining input\n- `parse_to` has its own error code now\n- `u128` and `i128` parsers in big and little endian modes\n- support for `pub(crate)` syntax\n- `map_res_err!` combinator that appends the error of its argument function in verbose errors mode\n\n### Fixed\n\n- lots of unused imports warnings were removed\n- the `bytes` combinator was not compiling in some cases\n- the big and little endian combinators now work without external imports\n- CI is now faster and uses less cache\n- in `add_return_error`, the provided error code is now evaluated only once\n\n### Changed\n\n- `fold_many1` will now transmit a `Failure` instead of transforming it to an `Error`\n- `float` and `double` now work on all of nom's input types (`&[u8]`, `&str`, `CompleteByteSlice`, `CompleteStr` and any type that implements the required traits). `float_s` and `double_s` got the same modification, but are now deprecated\n- `CompleteByteSlice` and `CompleteStr` get a small optimization by inlining some functions\n\n\n## 4.0.0 - 2018-05-14\n\n### Thanks\n\n- @jsgf for the new `AtEof` trait\n- @tmccombs for fixes on `escaped*` combinators\n- @s3bk for fixes around non Copy input types and documentation help\n- @kamarkiewicz for fixes to no_std and CI\n- @bheisler for documentation and examples\n- @target-san for simplifying the `InputIter` trait for `&[u8]`\n- @willmurphyscode for documentation and examples\n- @Chaitanya1416 for typo fixes\n- @fflorent for `input_len()` usage fixes\n- @dbrgn for typo fixes\n- @iBelieve for no_std fixes\n- @kpp for warning fixes and clippy fixes\n- @keruspe for fixes on FindToken\n- @dtrebbien for fixes on take_until_and_consume1\n- @Henning-K for typo fixes\n- @vthriller for documentation fixes\n- @federicomenaquintero and @veprbl for their help fixing the float parsers\n- @vmchale for new named_args versions\n- @hywan for documentation fixes\n- @fbenkstein for typo fixes\n- @CAD97 for catching missing trait implementations\n- @goldenlentils for &str optimizations\n- @passy for typo fixes\n- @ayrat555 for typo fixes\n- @GuillaumeGomez for documentation fixes\n- @jrakow for documentation fixes and fixes for `switch!`\n- @phlosioneer for documentation fixes\n- @creativcoder for typo fixes\n- @derekdreery for typo fixes\n- @lucasem for implementing `Deref` on `CompleteStr` and `CompleteByteSlice`\n- @lowenheim for `parse_to!` fixes\n- @myrrlyn for trait fixes around `CompleteStr` and `CompleteByteSlice`\n- @NotBad4U for fixing code coverage analysis\n- @murarth for code formatting\n- @glandium for fixing build in no_std\n- @csharad for regex compatibility with `CompleteStr`\n- @FauxFaux for implementing `AsRef<str>` on `CompleteStr`\n- @jaje for implementing `std::Error` on `nom:Err`\n- @fengalin for warning fixes\n- @@khernyo for doc formatting\n\nSpecial thanks to @corkami for the logo :)\n\n### Breaking changes\n\n- the `IResult` type now becomes a `Result` from the standard library\n- `Incomplete` now returns the additional data size needed, not the total data size needed\n- verbose-errors is now a superset of basic errors\n- all the errors now include  the related input slice\n- the arguments from `error_position` and other such macros were swapped to be more consistent with the rest of nom\n- automatic error conversion: to fix error type inference issues, a custom error type must now implement `std::convert::From<u32>`\n- the `not!` combinator returns unit `()`\n- FindToken's calling convention was swapped\n- the `take_*` combinators are now more coherent and stricter, see commit 484f6724ea3ccb for more information\n- `many0` and other related parsers will now return `Incomplete` if the reach the end of input without an error of the child parser. They will also return `Incomplete` on an empty input\n- the `sep!` combinator for whitespace only consumes whitespace in the prefix, while the `ws!` combinator takes care of consuming the remaining whitespace\n\n### Added\n\n- the `AtEof` trait for input type: indicate if we can get more input data later (related to streaming parsers and `Incomplete` handling)\n- the `escaped*` parsers now support the `&str`input type\n- the `Failure` error variant represents an unrecoverable error, for which `alt` and other combinators will not try other branches. This error means we got in the right part of the code (like, a prefix was checked correctly), but there was an error in the following parts\n- the `CompleteByteSlice` and `CompleteStr` input types consider there will be no more refill of the input. They fixed the `Incomplete` related issues when we have all of the data\n- the `exact!()` combinator will fail if we did not consume the whole input\n- the `take_while_m_n!` combinator will match a specified number of characters\n- `ErrorKind::TakeUntilAndConsume1`\n- the `recognize_float` parser will match a float number's characters, but will not transform to a `f32` or `f64`\n- `alpha` and other basic parsers are now much stricter about partial inputs. We also introduce the  `*0` and `*1` versions of those parsers\n- `named_args` can now specify the input type as well\n- `HexDisplay` is now implemented for `&str`\n- `alloc` feature\n- the `InputTakeAtposition` trait allows specialized implementations of parsers like `take_while!`\n\n### Removed\n\n- the producers and consumers were removed\n- the `error_code` and `error_node` macros are not used anymore\n\n### Fixed\n\n- `anychar!` now works correctly with multibyte characters\n- `take_until_and_consume1!` no longer results in \"no method named \\`find_substring\\`\" and \"no method named \\`slice\\`\" compilation errors\n- `take_until_and_consume1!` returns the correct Incomplete(Needed) amount\n- `no_std` compiles properly, and nom can work with `alloc` too\n- `parse_to!` now consumes its input\n\n### Changed\n\n- `alt` and other combinators will now clone the input if necessary. If the input is already `Copy` there is no performance impact\n- the `rest` parser now works on various input types\n- `InputIter::Item` for `&[u8]` is now a `u8` directly, not a reference\n- we now use the `compile_error` macro to return a compile time error if there was a syntax issue\n- the permutation combinator now supports optional child parsers\n- the float numbers parsers have been refactored to use one common implementation that is nearly 2 times faster than the previous one\n- the float number parsers now accept more variants\n\n\n## 3.2.1 - 2017-10-27\n\n### Thanks\n\n- @ordian for `alt_complete` fixes\n- @friedm for documentation fixes\n- @kali for improving error management\n\n### Fixed\n\n- there were cases where `alt_complete` could return `Incomplete`\n\n### Added\n\n- an `into_error_kind` method can be used to transform any error to a common value. This helps when the library is included multiple times as dependency with different feature sets\n\n\n## 3.2.0 - 2017-07-24\n\n### Thanks\n\n- @jedireza for documentation fixes\n- @gmorenz for the `bytes` combinator\n- @meh for character combinator fixes for UTF-8\n- @jethrogb for avoiding move issues in `separated_list`\n\n### Changed\n\n- new layout for the main page of documentation\n- `anychar` can now work on any input type\n- `length_bytes` is now an alias for `length_data`\n\n### Fixed\n\n- `one_of`, `none_of` and `char` will now index correctly UTF-8 characters\n- the `compiler_error` macro is now correctly exported\n\n\n### Added\n\n- the `bytes` combinator transforms a bit stream back to a byte slice for child parsers\n\n## 3.1.0 - 2017-06-16\n\n### Thanks\n\n- @sdroege: implementing be_i24 and le_i24\n- @Hywan: integrating faster substring search using memchr\n- @nizox: fixing type issues in bit stream parsing\n- @grissiom: documentation fixes\n- @doomrobo: implementing separated_list_complete and separated_nonempty_list_complete\n- @CWood1: fixing memchr integration in no_std\n- @lu_zero: integrating the compiler_error crate\n- @dtolnay: helping debug a type inference issue in map\n\n### Changed\n\n- memchr is used for substring search if possible\n- if building on nightly, some common syntax errors will display a specific error message. If building no stable, display the documentation to activate those messages\n- `count` no longer preallocates its vector\n\n### Fixed\n\n- better type inference in alt_complete\n- `alt` should now work with whitespace parsing\n- `map` should not make type inference errors anymore\n\n### Added\n\n- be_i24 and le_i24, parsing big endian and little endian signed 24 bit integers\n- `separated_list_complete` and `separated_nonempty_list_complete` will treat incomplete from sub parsers as error\n\n## 3.0.0 - 2017-05-12\n\n### Thanks\n\n- Chris Pick for some `Incomplete` related refactors\n- @dbrgn for documentation fixes\n- @valarauca for adding `be_u24`\n- @ithinuel for usability fixes\n- @evuez for README readability fixes and improvements to `IResult`\n- @s3bk for allowing non-`Copy` types as input\n- @keruspe for documentation fixes\n- @0xd34d10cc for trait fixes on `InputIter`\n- @sdleffler for lifetime shenanigans on `named_args`\n- @chengsun for type inference fixes in `alt`\n- @iBelieve for adding str to no_std\n- @Hywan for simplifying code in input traits\n- @azerupi for extensive documentation of `alt` and `alt_complete`\n\n### Breaking Changes\n\n- `escaped`, `separated_list` and `separated_nonempty_list` can now return `Incomplete` when necessary\n- `InputIter` does not require `AsChar` on its `Item` type anymore\n- the `core` feature that was putting nom in `no_std` mode has been removed. There is now a `std` feature, activated by default. If it is not activated, nom is in `no_std`\n- in `verbose-errors` mode, the error list is now stored in a `Vec` instead of a box based linked list\n- `chain!` has finally been removed\n\n### Changed\n\n- `Endianness` now implements `Debug`, `PartialEq`, `Eq`, `Clone` and `Copy`\n- custom input types can now be cloned if they're not `Copy`\n- the infamous 'Cannot infer type for E' error should happen less often now\n- `str` is now available in `no_std` mode\n\n### Fixed\n\n- `FileProducer` will be marked as `Eof` on full buffer\n- `named_args!` now has lifetimes that cannot conflict with the lifetimes from other arguments\n\n### Added\n\n- `be_u24`: big endian 24 bit unsigned integer parsing\n- `IResult` now has a `unwrap_or` method\n\n\n## 2.2.1 - 2017-04-03\n\n### Thanks\n\n- @Victor-Savu for formatting fixes in the README\n- @chifflier for detecting and fixing integer overflows\n- @utkarshkukreti for some performance improvements in benchmarks\n\n### Changed\n\n- when calculating how much data is needed in `IResult::Incomplete`, the addition could overflow (it is stored as a usize). This would apparently not result in any security vulnerability on release code\n\n## 2.2.0 - 2017-03-20\n\n### Thanks\n\n- @seppo0010 for fixing `named_args`\n- @keruspe for implementing or() on `IResult`, adding the option of default cases in `switch!`, adding support for `cargo-travis`\n- @timlyo for documentation fixes\n- @JayKickliter for extending `hex_u32`\n- @1011X for fixing regex integration\n- @Kerollmops for actually marking `chain!` as deprecated\n- @joliss for documentation fixes\n- @utkarshkukreti for tests refactoring and performance improvement\n- @tmccombs for documentation fixes\n\n### Added\n\n- `IResult` gets an `or()` method\n- `take_until1`, `take_until_and_consume1`, `take_till1!` and `take_till1_s!` require at least 1 character\n\n### Changed\n\n- `hex_u32` accepts uppercase digits as well\n- the character based combinators leverage the input traits\n- the whitespace parsers now work on &str and other types\n- `take_while1` returns `Incomplete` on empty input\n- `switch!` can now take a default case\n\n### Fixed\n\n- `named_args!` now imports `IResult` directly\n- the upgrade to regex 0.2 broke the regex combinators, they work now\n\n## 2.1.0 - 2017-01-27\n\n### Thanks\n\n- @nickbabcock for documentation fixes\n- @derekdreery for documentation fixes\n- @DirkyJerky for documentation fixes\n- @saschagrunert for documentation fixes\n- @lucab for documentation fixes\n- @hyone for documentation fixes\n- @tstorch for factoring `Slice`\n- @shepmaster for adding crate categories\n- @antoyo for adding `named_args!`\n\n### Added\n\n- `verify!` uses a first parser, then applies a function to check that its result satisfies some conditions\n- `named_args!` creates a parser function that can accept other arguments along with the input\n- `parse_to!` will use the `parse` method from `FromStr` to parse a value. It will automatically translate the input to a string if necessary\n- `float`, `float_s`, `double`, `double_s` can recognize floating point numbers in text\n\n### Changed\n\n- `escaped!` will now return `Incomplete` if needed\n- `permutation!` supports up to 20 child parsers\n\n## 2.0.1 - 2016-12-10\n\nBugfix release\n\n*Warning*: there is a small breaking change, `add_error!` is renamed to `add_return_error!`. This was planned for the 2.0 release but was forgotten. This is a small change in a feature that not many people use, for a release that is not yet widely in use, so there will be no 3.0 release for that change.\n\n### Thanks\n\n- @nickbabcock for catching and fixing the `add_error!` mixup\n- @lucab for documentation fixes\n- @jtdowney for noticing that `tag_no_case!` was not working at all for byte slices\n\n### Fixed\n\n- `add_error!` has been renamed to `add_return_error!`\n- the `not!` combinator now accepts functions\n- `tag_no_case!` is now working as accepted (before, it accepted everything)\n\n\n## 2.0 - 2016-11-25\n\nThe 2.0 release is one of the biggest yet. It was a good opportunity to clean up some badly named combinators and fix invalid behaviours.\n\nSince this version introduces a few breaking changes, an [upgrade documentation](https://github.com/rust-bakery/nom/blob/main/doc/archive/upgrading_to_nom_2.md) is available, detailing the steps to fix the most common migration issues. After testing on a set of 30 crates, most of them will build directly, a large part will just need to activate the \"verbose-errors\" compilation feature. The remaining fixes are documented.\n\nThis version also adds a lot of interesting features, like the permutation combinator or whitespace separated formats support.\n\n### Thanks\n\n- @lu-zero for license help\n- @adamgreig for type inference fixes\n- @keruspe for documentation and example fixes, for the `IResult => Result` conversion work, making `AsChar`'s method more consistent, and adding `many_till!`\n- @jdeeny for implementing `Offset` on `&str`\n- @vickenty for documentation fixes and his refactoring of `length_value!` and `length_bytes!`\n- @overdrivenpotato for refactoring some combinators\n- @taralx for documentation fixes\n- @keeperofdakeys for fixing eol behaviour, writing documentation and adding `named_attr!`\n- @jturner314 for writing documentation\n- @bozaro for fixing compilation errors\n- @uniphil for adding a `crates.io` badge\n- @badboy for documentation fixes\n- @jugglerchris for fixing `take_s!`\n- @AndyShiue for implementing `Error` and `Display` on `ErrorKind` and detecting incorrect UTF-8 string indexing\n\n### Added\n\n- the \"simple\" error management system does not accumulates errors when backtracking. This is a big perf gain, and is activated by default in nom 2.0\n- nom can now work on any type that implement the traits defined in `src/traits.rs`: `InputLength`, `InputIter`, `InputTake`, `Compare`, `FindToken`, `FindSubstring`, `Slice`\n- the documentation from Github's wiki has been moved to the `doc/` directory. They are markdown files that you can build with [cargo-external-doc](https://crates.io/crates/cargo-external-doc)\n- whitespace separated format support: with the `ws!` combinator, you can automatically introduce whitespace parsers between all parsers and combinators\n- the `permutation!` combinator applies its child parsers in any order, as long as they all succeed once, and return a tuple of the results\n- `do_parse!` is a simpler alternative to `chain!`, which is now deprecated\n- you can now transform an `IResult` in a `std::result::Result`\n- `length_data!` parses a length, and returns a subslice of that length\n- `tag_no_case!` provides case independent comparison. It works nicely, without any allocation, for ASCII strings, but for UTF-8 strings, it defaults to an unsatisfying (and incorrect) comparison by lowercasing both strings\n- `named_attr!` creates functions like `named!` but can add attributes like documentation\n- `many_till!` applies repeatedly its first child parser until the second succeeds\n\n### Changed\n\n- the \"verbose\" error management that was available in previous versions is now activated by the \"verbose-errors\" compilation feature\n- code reorganization: most of the parsers were moved in separate files to make the source easier to navigate\n- most of the combinators are now independent from the input type\n- the `eof` function was replaced with the `eof!` macro\n- `error!` and `add_error!` were replaced with `return_error!` and `add_return_error!` to fix the name conflict with the log crate\n- the `offset()` method is now in the `Offset` trait\n- `length_value!` has been renamed to `length_count!`. The new `length_value!` selects a slice and applies the second parser once on that slice\n- `AsChar::is_0_to_9` is now `AsChar::is_dec_digit`\n- the combinators with configurable endianness now take an enum instead of a boolean as parameter\n\n### Fixed\n- the `count!`, `count_fixed!` and `length_*!` combinator calculate incomplete data needs correctly\n- `eol`, `line_ending` and `not_line_ending` now have a consistent behaviour that works correctly with incomplete data\n- `take_s!` didn't correctly handle the case when the slice is exactly the right length\n\n## 1.2.4 - 2016-07-20\n\n### Thanks\n- @Phlosioneer for documentation fixes\n- @sourrust for fixing offsets in `take_bits!`\n- @ChrisMacNaughton for the XFS crate\n- @pwoolcoc for `rest_s`\n- @fitzgen for more `IResult` methods\n- @gtors for the negative lookahead feature\n- @frk1 and @jeandudey for little endian float parsing\n- @jethrogb for fixing input usage in `many1`\n- @acatton for beating me at nom golf :D\n\n### Added\n- the `rest_s` method on `IResult` returns the remaining `&str` input\n- `unwrap_err` and `unwrap_inc` methods on `IResult`\n- `not!` will peek at the input and return `Done` if the underlying parser returned `Error` or `Incomplete`, without consuming the input\n- `le_f32` and `le_f64` parse little endian floating point numbers (IEEE 754)\n-\n\n### Fixed\n- documentation fixes\n- `take_bits!` is now more precise\n- `many1` inccorectly used the `len` function instead of `input_len`\n- the INI parser is simpler\n- `recognize!` had an early `return` that is removed now\n\n## 1.2.3 - 2016-05-10\n\n### Thanks\n- @lu-zero for the contribution guidelines\n- @GuillaumeGomez for fixes on `length_bytes` and some documentation\n- @Hywan for documentation and test fixes\n- @Xirdus for correct trait import issues\n- @mspiegel for the new AST example\n- @cholcombe973 for adding the `cond_with_error!` combinator\n- @tstorch for refactoring `many0!`\n- @panicbit for the folding combinators\n- @evestera for `separated_list!` fixes\n- @DanielKeep for correcting some enum imports\n\n### Added\n- Regular expression combinators starting with `re_bytes_` work on byte slices\n- example parsing arithmetic expressions to an AST\n- `cond_with_error!` works like `cond!` but will return `None` if the condition is false, and `Some(value)` if the underlying parser succeeded\n- `fold_many0!`, `fold_many1!` and `fold_many_m_n!` will take a parser, an initial value and a combining function, and fold over the successful applications of the parser\n\n### Fixed\n- `length_bytes!` converts the result of its child parser to usize\n- `take_till!` now imports `InputLength` instead of assuming it's in scope\n- `separated_list!` and `separated_nonempty_list!` will not consume the separator if there's no following successfully parsed value\n- no more warnings on build\n\n### Changed\n- simpler implementation of `many0!`\n\n## 1.2.2 - 2016-03-09\n\n### Thanks\n- @conradev for fixing `take_until_s!`\n- @GuillaumeGomez for some documentation fixes\n- @frewsxcv for some documentation fixes\n- @tstorch for some test refactorings\n\n### Added\n- `nom::Err` now implements `std::error::Error`\n\n### Fixed\n- `hex_u32` does not parses more than 8 chars now\n- `take_while!` and `take_while1!` will not perturb the behaviour of `recognize!` anymore\n\n## 1.2.1 - 2016-02-23\n\n### Thanks\n- @sourrust for adding methods to `IResult`\n- @tstorch for the test refactoring, and for adding methods to `IResult` and `Needed`\n- @joelself for fixing the method system\n\n### Added\n\n- mapping methods over `IResult` and `Needed`\n\n### Changed\n\n- `apply_rf` is renamed to `apply_m`. This will not warrant a major version, since it is part missing from the methods feture added in the 1.2.0 release\n- the `regexp_macros` feature that used `regex!` to precompile regular expressions has been replaced by the normal regex engine combined with `lazy_static`\n\n### Fixed\n\n- when a parser or combinator was returning an empty buffer as remaining part, it was generating one from a static empty string. This was messing with buffer offset calculation. Now, that empty slice is taken like this: `&input[input.len()..]`.\n- The `regexp_macros` and `no_std` feature build again and are now tested with Travis CI\n\n## 1.2.0 - 2016-02-08\n\n### Thanks\n- @zentner-kyle for type inference fixes\n- @joelself for his work on `&str` parsing and method parsers\n- @GuillaumeGomez for implementing methods on `IResult`\n- @dirk for the `alt_complete!` combinator\n- @tstorch for a lot of refactoring work and unit tests additions\n- @jansegre for the hex digit parsers\n- @belgum for some documentation fixes\n- @lwandrebeck for some documentation fixes and code fixes in `hex_digit`\n\n### Added\n- `take_until_and_consume_s!` for consumption of string data until a tag\n- more function patterns in `named!`. The error type can now be specified\n- `alt_complete!` works like the `alt!` combinator, but tries the next branch if the current one returned `Incomplete`, instead of returning directly\n- more unit tests for a lot of combinators\n- hexadecimal digit parsers\n- the `tuple!` combinator takes a list of parsers as argument, and applies them serially on the input. If all of them are successful, it willr eturn a tuple accumulating all the values. This combinator will (hopefully) replace most uses of `chain!`\n- parsers can now be implemented as a method for a struct thanks to the `method!`, `call_m!` and `apply_rf!` combinators\n\n### Fixed\n- there were type inference issues in a few combinators. They will now be easier to compile\n- `peek!` compilation with bare functions\n- `&str` parsers were splitting data at the byte level, not at the char level, which can result in inconsistencies in parsing UTF-8 characters. They now use character indexes\n- some method implementations were missing on `IResult<I,O,E>` (with specified error type instead of implicit)\n\n## 1.1.0 - 2016-01-01\n\nThis release adds a lot of features related to `&str` parsing. The previous versions\nwere focused on `&[u8]` and bit streams parsing, but there's a need for more text\nparsing with nom. The parsing functions like `alpha`, `digit` and others will now\naccept either a `&[u8]` or a `&str`, so there is no breaking change on that part.\n\nThere are also a few performance improvements and documentation fixes.\n\n### Thanks\n- @Binero for pushing the work on `&str` parsing\n- @meh for fixing `Option` and `Vec` imports\n- @hoodie for a documentation fix\n- @joelself for some documentation fixes\n- @vberger for his traits magic making nom functions more generic\n\n### Added\n\n- string related parsers: `tag_s!`, `take_s!`, `is_a_s!`, `is_not_s!`, `take_while_s!`, `take_while1_s!`, `take_till_s!`\n- `value!` is a combinator that always returns the same value. If a child parser is passed as second argument, that value is returned when the child parser succeeds\n\n### Changed\n\n- `tag!` will now compare even on partial input. If it expects \"abcd\" but receives \"ef\", it will now return an `Error` instead of `Incomplete`\n- `many0!` and others will preallocate a larger vector to avoid some copies and reallocations\n- `alpha`, `digit`, `alphanumeric`, `space` and `multispace` now accept as input a `&[u8]` or a `&str`. Additionally, they return an error if they receive an empty input\n- `take_while!`, `take_while1!`, `take_while_s!`, `take_while1_s!` wilreturn an error on empty input\n\n### Fixed\n\n- if the child parser of `many0!` or `many1!` returns `Incomplete`, it will return `Incomplete` too, possibly updating the needed size\n- `Option,` `Some`, `None` and `Vec` are now used with full path imports\n\n## 1.0.1 - 2015-11-22\n\nThis releases makes the 1.0 version compatible with Rust 1.2 and 1.3\n\n### Thanks\n- @steveklabnik for fixing lifetime issues in Producers and Consumers\n\n## 1.0.0 - 2015-11-16\n\nStable release for nom. A lot of new features, a few breaking changes\n\n### Thanks\n- @ahenry for macro fixes\n- @bluss for fixing documentation\n- @sourrust for cleaning code and debugging the new streaming utilities\n- @meh for inline optimizations\n- @ccmtaylor for fixing function imports\n- @soro for improvements to the streaming utilities\n- @breard-r for catching my typos\n- @nelsonjchen for catching my typos too\n- @divarvel for hex string parsers\n- @mrordinaire for the `length_bytes!` combinator\n\n### Breaking changes\n- `IResult::Error` can now use custom error types, and is generic over the input type\n- Producers and consumers have been replaced. The new implementation uses less memory and integrates more with parsers\n- `nom::ErrorCode` is now `nom::ErrorKind`\n- `filter!` has been renamed to `take_while!`\n- `chain!` will count how much data is consumed and use that number to calculate how much data is needed if a parser returned `Incomplete`\n- `alt!` returns `Incomplete` if a child parser returned `Incomplete`, instead of skipping to the next parser\n- `IResult` does not require a lifetime tag anymore, yay!\n\n### Added\n\n- `complete!` will return an error if the child parser returned `Incomplete`\n- `add_error!` will wrap an error, but allow backtracking\n- `hex_u32` parser\n\n### Fixed\n- the behaviour around `Incomplete` is better for most parsers now\n\n## 0.5.0 - 2015-10-16\n\nThis release fixes a few issues and stabilizes the code.\n\n### Thanks\n- @nox for documentation fixes\n- @daboross for linting fixes\n- @ahenry for fixing `tap!` and extending `dbg!` and `dbg_dmp!`\n- @bluss for tracking down and fixing issues with unsafe code\n- @meh for inlining parser functions\n- @ccmtaylor for fixing import of `str::from_utf8`\n\n### Fixed\n- `tap!`, `dbg!` and `dbg_dmp!` now accept function parameters\n\n### Changed\n- the type used in `count_fixed!` must be `Copy`\n- `chain!` calculates how much data is needed if one of the parsers returns `Incomplete\n- optional parsers in `chain!` can return `Incomplete`\n\n## 0.4.0 - 2015-09-08\n\nConsidering the number of changes since the last release, this version can contain breaking changes, so the version number becomes 0.4.0. A lot of new features and performance improvements!\n\n### Thanks\n- @frewsxcv for documentation fixes\n- @ngrewe for his work on producers and consumers\n- @meh for fixes on `chain!` and for the `rest` parser\n- @daboross for refactoring `many0!` and `many1!`\n- @aleksander for the `switch!` combinator idea\n- @TechnoMancer for his help with bit level parsing\n- @sxeraverx for pointing out a bug in `is_a!`\n\n### Fixed\n- `count_fixed!` must take an explicit type as argument to generate the fixed-size array\n- optional parsing behaviour in `chain!`\n- `count!` can take 0 elements\n- `is_a!` and `is_not!` can now consume the whole input\n\n### Added\n- it is now possible to seek to the end of a `MemProducer`\n- `opt!` returns `Done(input, None)` if `the child parser returned `Incomplete`\n- `rest` will return the remaining input\n- consumers can now seek to and from the end of input\n- `switch!` applies a first parser then matches on its result to choose the next parser\n- bit-level parsers\n- character-level parsers\n- regular expression parsers\n- implementation of `take_till!`, `take_while!` and `take_while1!`\n\n### Changed\n- `alt!` can return `Incomplete`\n- the error analysis functions will now take references to functions instead of moving them\n- performance improvements on producers\n- performance improvement for `filter!`\n- performance improvement for `count!`: a `Vec` of the right size is directly allocated\n\n## 0.3.11 - 2015-08-04\n\n### Thanks\n- @bluss for remarking that the crate included random junk lying non committed in my local repository\n\n### Fixed\n- cleanup of my local repository will ship less files in the crates, resulting in a smaller download\n\n## 0.3.10 - 2015-08-03\n\n### Added\n\n- `bits!` for bit level parsing. It indicates that all child parsers will take a `(&[u8], usize)`as input, with the second parameter indicating the bit offset in the first byte. This allows viewing a byte slice as a bit stream. Most combinators can be used directly under `bits!`\n- `take_bits!` takes an integer type and a number of bits, consumes that number of bits and updates the offset, possibly by crossing byte boundaries\n- bit level parsers are all written in `src/bits.rs`\n\n### Changed\n\n- Parsers that specifically handle bytes have been moved to src/bytes.rs`. This applies to `tag!`, `is_not!`, `is_a!`, `filter!`, `take!`, `take_str!`, `take_until_and_consume!`, `take_until!`, `take_until_either_and_consume!`, `take_until_either!`\n\n## 0.3.9 - 2015-07-20\n\n### Thanks\n- @badboy for fixing `filter!`\n- @idmit for some documentation fixes\n\n### Added\n- `opt_res!` applies a parser and transform its result in a Result. This parser never fails\n- `cond_reduce!` takes an expression as parameter, applies the parser if the expression is true, and returns an error if the expression is false\n- `tap!` pass the result of a parser to a block to manipulate it, but do not affect the parser's result\n- `AccReader` is a Read+BufRead that supports data accumulation and partial consumption. The `consume` method must be called afterwardsto indicate how much was consumed\n- Arithmetic expression evaluation and parsing example\n- `u16!`, `u32!`, `u64!`, `i16!`, `i32!`, `i64!` take an expression as parameter, if the expression is true, apply the big endian integer parser, if false, the little endian version\n- type information for combinators. This will make the documentation a bit easier to navigate\n\n### Fixed\n- `map_opt!` and `map_res!` had issues with argument order due to bad macros\n- `delimited!` did not compile for certain combinations of arguments\n- `filter!` did not return a byte slice but a fixed array\n\n## 0.3.8 - 2015-07-03\n\n### Added\n- code coverage is now calculated automatically on Travis CI\n- `Stepper`: wrap a `Producer`, and call the method `step` with a parser. This method will buffer data if there is not enough, apply the parser if there is, and keep the rest of the input in memory for the next call\n- `ReadProducer`: takes something implementing `Read`, and makes a `Producer` out of it\n\n### Fixed\n- the combinators `separated_pair!` and `delimited!` did not work because an implementation macro was not exported\n- if a `MemProducer` reached its end, it should always return `Eof`\n- `map!` had issues with argument matching\n\n## 0.3.7 - 2015-06-24\n\n### Added\n- `expr_res!` and `expr_opt!` evaluate an expression returning a Result or Opt and convert it to IResult\n- `AsBytes` is implemented for fixed size arrays. This allows `tag!([41u8, 42u8])`\n\n### Fixed\n- `count_fixed!` argument parsing works again\n\n## 0.3.6 - 2015-06-15\n\n### Added\n- documentation for a few functions\n- the consumer trait now requires the `failed(&self, error_code)` method in case of parsing error\n- `named!` now handles the alternative `named!(pub fun_name<OutputType>, ...)`\n\n### Fixed\n- `filter!` now returns the whole input if the filter function never returned false\n- `take!` casts its argument as usize, so it can accepts any integer type now\n\n## 0.3.5 - 2015-06-10\n\n### Thanks\n- @cmr for some documentation fixes\n\n### Added\n- `count_fixed!` returns a fixed array\n\n### Fixed\n- `count!` is back to the previous behaviour, returning a `Vec` for sizes known at runtime\n\n### Changed\n- functions and traits exported from `nom::util` are now directly in `nom::`\n\n## 0.3.4 - 2015-06-09\n\n### Thanks\n- @andrew-d for fixes on `cond!`\n- @keruspe for features in `chain!`\n\n### Added\n- `chain!` can now have mutable fields\n\n### Fixed\n- `cond!` had an infinite macro recursion\n\n### Changed\n- `chain!` generates less code now. No apprent compilation time improvement\n\n## 0.3.3 - 2015-06-09\n\n### Thanks\n- @andrew-d for the little endian signed integer parsers\n- @keruspe for fixes on `count!`\n\n### Added\n- `le_i8`, `le_i16`, `le_i32`, `le_i64`: little endian signed integer parsers\n\n### Changed\n- the `alt!` parser compiles much faster, even with more than 8 branches\n- `count!` can now return a fixed size array instead of a growable vector\n\n## 0.3.2 - 2015-05-31\n\n### Thanks\n- @keruspe for the `take_str` parser and the function application combinator\n\n### Added\n- `take_str!`: takes the specified number of bytes and return a UTF-8 string\n- `apply!`: do partial application on the parameters of a function\n\n### Changed\n- `Needed::Size` now contains a `usize` instead of a `u32`\n\n## 0.3.1 - 2015-05-21\n\n### Thanks\n- @divarvel for the big endian signed integer parsers\n\n### Added\n- `be_i8`, `be_i16`, `be_i32`, `be_i64`: big endian signed integer parsers\n- the `core` feature can be passed to cargo to build with `no_std`\n- colored hexdump can be generated from error chains\n\n## 0.3.0 - 2015-05-07\n\n### Thanks\n- @filipegoncalves for some documentation and the new eof parser\n- @CrimsonVoid for putting fully qualified types in the macros\n- @lu_zero for some documentation fixes\n\n### Added\n- new error types that can contain an error code, an input slice, and a list of following errors\n- `error!` will cut backtracking and return directly from the parser, with a specified error code\n- `eof` parser, successful if there is no more input\n- specific error codes for the parsers provided by nom\n\n### Changed\n- fully qualified types in macros. A lot of imports are not needed anymore\n\n### Removed\n- `FlatMap`, `FlatpMapOpt` and `Functor` traits (replaced by `map!`, `map_opt!` and `map_res!`)\n\n## 0.2.2 - 2015-04-12\n\n### Thanks\n- @filipegoncalves and @thehydroimpulse for debugging an infinite loop in many0 and many1\n- @thehydroimpulse for suggesting public named parsers\n- @skade for removing the dependency on the collections gate\n\n### Added\n- `named!` can now declare public functions like this: `named!(pub tst, tag!(\"abcd\"));`\n- `pair!(X,Y)` returns a tuple `(x, y)`\n- `separated_pair!(X, sep, Y)` returns a tuple `(x, y)`\n- `preceded!(opening, X)` returns `x`\n- `terminated!(X, closing)` returns `x`\n- `delimited(opening, X, closing)` returns `x`\n- `separated_list(sep, X)` returns a `Vec<X>`\n- `separated_nonempty_list(sep, X)` returns a `Vec<X>` of at list one element\n\n### Changed\n- `many0!` and `many1!` forbid parsers that do not consume input\n- `is_a!`, `is_not!`, `alpha`, `digit`, `space`, `multispace` will now return an error if they do not consume at least one byte\n\n## 0.2.1 - 2015-04-04\n\n### Thanks\n- @mtsr for catching the remaining debug println!\n- @jag426 who killed a lot of warnings\n- @skade for removing the dependency on the core feature gate\n\n\n### Added\n- little endian unsigned int parsers le_u8, le_u16, le_u32, le_u64\n- `count!` to apply a parser a specified number of times\n- `cond!` applies a parser if the condition is met\n- more parser development tools in `util::*`\n\n### Fixed\n- in one case, `opt!` would not compile\n\n### Removed\n- most of the feature gates are now removed. The only one still needed is `collections`\n\n## 0.2.0 - 2015-03-24\n*works with `rustc 1.0.0-dev (81e2396c7 2015-03-19) (built 2015-03-19)`*\n\n### Thanks\n- Ryman for the AsBytes implementation\n- jag426 and jaredly for documentation fixes\n- eternaleye on #rust IRC for his help on the new macro syntax\n\n### Changed\n- the AsBytes trait improves readability, no more b\"...\", but \"...\" instead\n- Incomplete will now hold either Needed;;Unknown, or Needed::Size(u32). Matching on Incomplete without caring for the value is done with `Incomplete(_)`, but if more granularity is mandatory, `Needed` can be matched too\n- `alt!` can pass the result of the parser to a closure\n- the `take_*` macros changed behaviour, the default case is now not to consume the separator. The macros have been renamed as follows: `take_until!` -> `take_until_and_consume!`, `take_until_and_leave!` -> `take_until!`, `take_until_either_and_leave!` -> `take_until_either!`, `take_until_either!` -> `take_until_either_and_consume!`\n\n### Added\n- `peek!` macro: matches the future input but does not consume it\n- `length_value!` macro: the first argument is a parser returning a `n` that can cast to usize, then applies the second parser `n` times. The macro has a variant with a third argument indicating the expected input size for the second parser\n- benchmarks are available at https://github.com/rust-bakery/parser_benchmarks\n- more documentation\n- **Unnamed parser syntax**: warning, this is a breaking change. With this new syntax, the macro combinators do not generate functions anymore, they create blocks. That way, they can be nested, for better readability. The `named!` macro is provided to create functions from parsers. Please be aware that nesting parsers comes with a small cost of compilation time, negligible in most cases, but can quickly get to the minutes scale if not careful. If this happens, separate your parsers in multiple subfunctions.\n- `named!`, `closure!` and `call!` macros used to support the unnamed syntax\n- `map!`, `map_opt!` and `map_res!` to combine a parser with a normal function, transforming the input directly, or returning an `Option` or `Result`\n\n### Fixed\n- `is_a!` is now working properly\n\n### Removed\n- the `o!` macro does less than `chain!`, so it has been removed\n- the `fold0!` and `fold1!` macros were too complex and awkward to use, the `many*` combinators will be useful for most uses for now\n\n## 0.1.6 - 2015-02-24\n### Changed\n- consumers must have an end method that will be called after parsing\n\n### Added\n- big endian unsigned int and float parsers: be_u8, be_u16, be_u32, be_u64, be_f32, be_f64\n- producers can seek\n- function and macros documentation\n- README documentation\n### Fixed\n- lifetime declarations\n- tag! can return Incomplete\n\n## 0.1.5 - 2015-02-17\n### Changed\n- traits were renamed: FlatMapper -> FlatMap, Mapper -> FlatMapOpt, Mapper2 -> Functor\n\n### Fixed\n- woeks with rustc f1bb6c2f4\n\n## 0.1.4 - 2015-02-17\n### Changed\n- the chaining macro can take optional arguments with '?'\n\n## 0.1.3 - 2015-02-16\n### Changed\n- the chaining macro now takes the closure at the end of the argument list\n\n## 0.1.2 - 2015-02-16\n### Added\n- flat_map implementation for <&[u8], &[u8]>\n- chaining macro\n- partial MP4 parser example\n\n\n## 0.1.1 - 2015-02-06\n### Fixed\n- closure syntax change\n\n## Compare code\n\n* [unreleased](https://github.com/rust-bakery/nom/compare/7.1.2...HEAD)\n* [7.1.2](https://github.com/rust-bakery/nom/compare/7.1.1...7.1.2)\n* [7.1.1](https://github.com/rust-bakery/nom/compare/7.1.0...7.1.1)\n* [7.1.0](https://github.com/rust-bakery/nom/compare/7.0.0...7.1.0)\n* [7.0.0](https://github.com/rust-bakery/nom/compare/6.2.1...7.0.0)\n* [6.2.1](https://github.com/rust-bakery/nom/compare/6.2.0...6.2.1)\n* [6.2.0](https://github.com/rust-bakery/nom/compare/6.1.2...6.2.0)\n* [6.1.2](https://github.com/rust-bakery/nom/compare/6.1.1...6.1.2)\n* [6.1.1](https://github.com/rust-bakery/nom/compare/6.1.0...6.1.1)\n* [6.1.0](https://github.com/rust-bakery/nom/compare/6.0.1...6.1.0)\n* [6.0.1](https://github.com/rust-bakery/nom/compare/6.0.0...6.0.1)\n* [6.0.0](https://github.com/rust-bakery/nom/compare/5.1.1...6.0.0)\n* [5.1.1](https://github.com/rust-bakery/nom/compare/5.1.0...5.1.1)\n* [5.1.0](https://github.com/rust-bakery/nom/compare/5.0.1...5.1.0)\n* [5.0.1](https://github.com/rust-bakery/nom/compare/5.0.0...5.0.1)\n* [5.0.0](https://github.com/rust-bakery/nom/compare/4.2.3...5.0.0)\n* [4.2.3](https://github.com/rust-bakery/nom/compare/4.2.2...4.2.3)\n* [4.2.2](https://github.com/rust-bakery/nom/compare/4.2.1...4.2.2)\n* [4.2.1](https://github.com/rust-bakery/nom/compare/4.2.0...4.2.1)\n* [4.2.0](https://github.com/rust-bakery/nom/compare/4.1.1...4.2.0)\n* [4.1.1](https://github.com/rust-bakery/nom/compare/4.1.0...4.1.1)\n* [4.1.0](https://github.com/rust-bakery/nom/compare/4.0.0...4.1.0)\n* [4.0.0](https://github.com/rust-bakery/nom/compare/3.2.1...4.0.0)\n* [3.2.1](https://github.com/rust-bakery/nom/compare/3.2.0...3.2.1)\n* [3.2.0](https://github.com/rust-bakery/nom/compare/3.1.0...3.2.0)\n* [3.1.0](https://github.com/rust-bakery/nom/compare/3.0.0...3.1.0)\n* [3.0.0](https://github.com/rust-bakery/nom/compare/2.2.1...3.0.0)\n* [2.2.1](https://github.com/rust-bakery/nom/compare/2.2.0...2.2.1)\n* [2.2.0](https://github.com/rust-bakery/nom/compare/2.1.0...2.2.0)\n* [2.1.0](https://github.com/rust-bakery/nom/compare/2.0.1...2.1.0)\n* [2.0.1](https://github.com/rust-bakery/nom/compare/2.0.0...2.0.1)\n* [2.0.0](https://github.com/rust-bakery/nom/compare/1.2.4...2.0.0)\n* [1.2.4](https://github.com/rust-bakery/nom/compare/1.2.3...1.2.4)\n* [1.2.3](https://github.com/rust-bakery/nom/compare/1.2.2...1.2.3)\n* [1.2.2](https://github.com/rust-bakery/nom/compare/1.2.1...1.2.2)\n* [1.2.1](https://github.com/rust-bakery/nom/compare/1.2.0...1.2.1)\n* [1.2.0](https://github.com/rust-bakery/nom/compare/1.1.0...1.2.0)\n* [1.1.0](https://github.com/rust-bakery/nom/compare/1.0.1...1.1.0)\n* [1.0.1](https://github.com/rust-bakery/nom/compare/1.0.0...1.0.1)\n* [1.0.0](https://github.com/rust-bakery/nom/compare/0.5.0...1.0.0)\n* [0.5.0](https://github.com/rust-bakery/nom/compare/0.4.0...0.5.0)\n* [0.4.0](https://github.com/rust-bakery/nom/compare/0.3.11...0.4.0)\n* [0.3.11](https://github.com/rust-bakery/nom/compare/0.3.10...0.3.11)\n* [0.3.10](https://github.com/rust-bakery/nom/compare/0.3.9...0.3.10)\n* [0.3.9](https://github.com/rust-bakery/nom/compare/0.3.8...0.3.9)\n* [0.3.8](https://github.com/rust-bakery/nom/compare/0.3.7...0.3.8)\n* [0.3.7](https://github.com/rust-bakery/nom/compare/0.3.6...0.3.7)\n* [0.3.6](https://github.com/rust-bakery/nom/compare/0.3.5...0.3.6)\n* [0.3.5](https://github.com/rust-bakery/nom/compare/0.3.4...0.3.5)\n* [0.3.4](https://github.com/rust-bakery/nom/compare/0.3.3...0.3.4)\n* [0.3.3](https://github.com/rust-bakery/nom/compare/0.3.2...0.3.3)\n* [0.3.2](https://github.com/rust-bakery/nom/compare/0.3.1...0.3.2)\n* [0.3.1](https://github.com/rust-bakery/nom/compare/0.3.0...0.3.1)\n* [0.3.0](https://github.com/rust-bakery/nom/compare/0.2.2...0.3.0)\n* [0.2.2](https://github.com/rust-bakery/nom/compare/0.2.1...0.2.2)\n* [0.2.1](https://github.com/rust-bakery/nom/compare/0.2.0...0.2.1)\n* [0.2.0](https://github.com/rust-bakery/nom/compare/0.1.6...0.2.0)\n* [0.1.6](https://github.com/rust-bakery/nom/compare/0.1.5...0.1.6)\n* [0.1.5](https://github.com/rust-bakery/nom/compare/0.1.4...0.1.5)\n* [0.1.4](https://github.com/rust-bakery/nom/compare/0.1.3...0.1.4)\n* [0.1.3](https://github.com/rust-bakery/nom/compare/0.1.2...0.1.3)\n* [0.1.2](https://github.com/rust-bakery/nom/compare/0.1.1...0.1.2)\n* [0.1.1](https://github.com/rust-bakery/nom/compare/0.1.0...0.1.1)\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.1748046875,
          "content": "# Contributing to nom\n\nThanks a lot for contributing to this project!\n\nThe following is a set of guidelines for contributing to [nom][1].\n\n**Since the project is young**: consider those best practices prone to change. Please suggest improvements!\n\n[1]: https://github.com/rust-bakery/nom\n\n## Basics\n\n### License\n\nThe project uses the [MIT][l1] license. By contributing to this project you agree to license\nyour changes under this license.\n\n[l1]: https://opensource.org/license/mit/\n\n\n## What to do\n\n### Issues\n\nThere is plenty of [features missing][i1] and possibly bugs might be already there. Feel free to add new [issues][i2]\nand to wrangle over those already [open][i3] and help fixing them.\n\n[i1]: https://github.com/rust-bakery/nom/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement\n[i2]: https://github.com/rust-bakery/nom/issues\n[i3]: https://github.com/rust-bakery/nom/issues?q=is%3Aopen+is%3Aissue\n\n### Code\n\nImplementing new codecs, container formats or protocols is always welcome!\n\n### Tests\n\nIt is strongly suggested to provide test along changes so the coverage stays around the **85%**, helping to\nget to full coverage is pretty welcome.\n\n### Benchmark\n\nHelp in making sure the code does not have performance regression, by improving the benchmark suite or just by\nrunning it weekly, is welcome as well.\n\n### Documentation\n\nTo preview changes to the documentation: use `cargo doc` with [`cargo\nexternal-doc`](https://github.com/Geal/cargo-external-doc)\n\n## Style\n\n### Issue style\n\nTry to write at least 3 short paragraphs describing what were you trying to achieve, what is not working and\nthe step by step actions that lead to the unwanted outcome.\n\nIf possible provide:\n\n- a code snippet or a link to a [gist][is1] showcasing the problem, if is a library usage issue.\n- a backtrace, if it is a crash.\n- a sample file, if it is a decoding or encoding issue.\n\n[is1]: https://gist.github.com/\n\n### Coding style\n\nThe normal rust coding style is checked by [rustfmt][cs1].\nReadable code is the first step on having good and safe libraries.\n\nTo avoid slight differences appearing in nightly versions, please\nuse the following command to run rustfmt: `cargo +stable fmt`\n\n[cs1]: https://github.com/rust-lang/rustfmt\n\n"
        },
        {
          "name": "Cargo.toml",
          "type": "blob",
          "size": 2.5771484375,
          "content": "[package]\n\nname = \"nom\"\nversion = \"8.0.0-beta.1\"\nauthors = [\"contact@geoffroycouprie.com\"]\ndescription = \"A byte-oriented, zero-copy, parser combinators library\"\nlicense = \"MIT\"\nrepository = \"https://github.com/rust-bakery/nom\"\nreadme = \"README.md\"\ndocumentation = \"https://docs.rs/nom\"\nkeywords = [\"parser\", \"parser-combinators\", \"parsing\", \"streaming\", \"bit\"]\ncategories = [\"parsing\"]\nedition = \"2021\"\nautoexamples = false\n\n# also update in README.md (badge and \"Rust version requirements\" section)\nrust-version = \"1.65.0\"\n\ninclude = [\n  \"CHANGELOG.md\",\n  \"LICENSE\",\n  \"README.md\",\n  \".gitignore\",\n  \"Cargo.toml\",\n  \"src/*.rs\",\n  \"src/*/*.rs\",\n  \"tests/*.rs\",\n  \"doc/nom_recipes.md\",\n]\n\n[features]\nalloc = []\nstd = [\"alloc\", \"memchr/std\"]\ndefault = [\"std\"]\ndocsrs = []\n\n[dependencies.memchr]\nversion = \"2.3\"\ndefault-features = false\n\n[dev-dependencies]\ndoc-comment = \"0.3\"\nproptest = \"=1.0.0\"\nnom-language = { path = \"./nom-language\" }\n\n[package.metadata.docs.rs]\nfeatures = [\"alloc\", \"std\", \"docsrs\"]\nall-features = true\nrustdoc-args = [\"--generate-link-to-definition\"]\n\n[profile.bench]\ndebug = true\nlto = true\ncodegen-units = 1\n\n[[test]]\nname = \"arithmetic\"\n\n[[test]]\nname = \"arithmetic_ast\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"css\"\n\n[[test]]\nname = \"custom_errors\"\n\n[[test]]\nname = \"expression_ast\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"float\"\n\n[[test]]\nname = \"ini\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"ini_str\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"issues\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"json\"\n\n[[test]]\nname = \"mp4\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"multiline\"\nrequired-features = [\"alloc\"]\n\n[[test]]\nname = \"overflow\"\n\n[[test]]\nname = \"reborrow_fold\"\n\n[[test]]\nname = \"fnmut\"\nrequired-features = [\"alloc\"]\n\n[[example]]\nname = \"custom_error\"\nrequired-features = [\"alloc\"]\npath = \"examples/custom_error.rs\"\n\n[[example]]\nname = \"json\"\nrequired-features = [\"alloc\"]\npath = \"examples/json.rs\"\n\n[[example]]\nname = \"json2\"\nrequired-features = [\"alloc\"]\npath = \"examples/json2.rs\"\n\n[[example]]\nname = \"json_iterator\"\nrequired-features = [\"alloc\"]\npath = \"examples/json_iterator.rs\"\n\n[[example]]\nname = \"iterator\"\npath = \"examples/iterator.rs\"\n\n[[example]]\nname = \"s_expression\"\npath = \"examples/s_expression.rs\"\nrequired-features = [\"alloc\"]\n\n[[example]]\nname = \"string\"\nrequired-features = [\"alloc\"]\npath = \"examples/string.rs\"\n\n[badges]\ntravis-ci = { repository = \"Geal/nom\" }\ncoveralls = { repository = \"Geal/nom\", branch = \"main\", service = \"github\" }\nmaintenance = { status = \"actively-developed\" }\n\n[workspace]\nmembers = [\".\", \"benchmarks/\", \"nom-language\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "Copyright (c) 2014-2019 Geoffroy Couprie\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.6982421875,
          "content": "# nom, eating data byte by byte\n\n[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Join the chat at https://gitter.im/Geal/nom](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/Geal/nom?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://github.com/rust-bakery/nom/actions/workflows/ci.yml/badge.svg)](https://github.com/rust-bakery/nom/actions/workflows/ci.yml)\n[![Coverage Status](https://coveralls.io/repos/github/rust-bakery/nom/badge.svg?branch=main)](https://coveralls.io/github/rust-bakery/nom?branch=main)\n[![crates.io Version](https://img.shields.io/crates/v/nom.svg)](https://crates.io/crates/nom)\n[![Minimum rustc version](https://img.shields.io/badge/rustc-1.56.0+-lightgray.svg)](#rust-version-requirements-msrv)\n\nnom is a parser combinators library written in Rust. Its goal is to provide tools\nto build safe parsers without compromising the speed or memory consumption. To\nthat end, it uses extensively Rust's *strong typing* and *memory safety* to produce\nfast and correct parsers, and provides functions, macros and traits to abstract most of the\nerror prone plumbing.\n\n![nom logo in CC0 license, by Ange Albertini](https://raw.githubusercontent.com/Geal/nom/main/assets/nom.png)\n\n*nom will happily take a byte out of your files :)*\n\n<!-- toc -->\n\n- [Example](#example)\n- [Documentation](#documentation)\n- [Why use nom?](#why-use-nom)\n    - [Binary format parsers](#binary-format-parsers)\n    - [Text format parsers](#text-format-parsers)\n    - [Programming language parsers](#programming-language-parsers)\n    - [Streaming formats](#streaming-formats)\n- [Parser combinators](#parser-combinators)\n- [Technical features](#technical-features)\n- [Rust version requirements](#rust-version-requirements-msrv)\n- [Installation](#installation)\n- [Related projects](#related-projects)\n- [Parsers written with nom](#parsers-written-with-nom)\n- [Contributors](#contributors)\n\n<!-- tocstop -->\n\n## Example\n\n[Hexadecimal color](https://developer.mozilla.org/en-US/docs/Web/CSS/color) parser:\n\n```rust\nuse nom::{\n  bytes::complete::{tag, take_while_m_n},\n  combinator::map_res,\n  sequence::Tuple,\n  IResult,\n  Parser,\n};\n\n#[derive(Debug, PartialEq)]\npub struct Color {\n  pub red: u8,\n  pub green: u8,\n  pub blue: u8,\n}\n\nfn from_hex(input: &str) -> Result<u8, std::num::ParseIntError> {\n  u8::from_str_radix(input, 16)\n}\n\nfn is_hex_digit(c: char) -> bool {\n  c.is_digit(16)\n}\n\nfn hex_primary(input: &str) -> IResult<&str, u8> {\n  map_res(\n    take_while_m_n(2, 2, is_hex_digit),\n    from_hex\n  ).parse(input)\n}\n\nfn hex_color(input: &str) -> IResult<&str, Color> {\n  let (input, _) = tag(\"#\")(input)?;\n  let (input, (red, green, blue)) = (hex_primary, hex_primary, hex_primary).parse(input)?;\n  Ok((input, Color { red, green, blue }))\n}\n\nfn main() {\n  println!(\"{:?}\", hex_color(\"#2F14DF\"))\n}\n\n#[test]\nfn parse_color() {\n  assert_eq!(\n    hex_color(\"#2F14DF\"),\n    Ok((\n      \"\",\n      Color {\n        red: 47,\n        green: 20,\n        blue: 223,\n      }\n    ))\n  );\n}\n```\n\n## Documentation\n\n- [Reference documentation](https://docs.rs/nom)\n- [The Nominomicon: A Guide To Using Nom](https://tfpk.github.io/nominomicon/)\n- [Various design documents and tutorials](https://github.com/rust-bakery/nom/tree/main/doc)\n- [List of combinators and their behaviour](https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md)\n\nIf you need any help developing your parsers, please ping `geal` on IRC (Libera, Geeknode, OFTC), go to `#nom-parsers` on Libera IRC, or on the [Gitter chat room](https://gitter.im/Geal/nom).\n\n## Why use nom\n\nIf you want to write:\n\n### Binary format parsers\n\nnom was designed to properly parse binary formats from the beginning. Compared\nto the usual handwritten C parsers, nom parsers are just as fast, free from\nbuffer overflow vulnerabilities, and handle common patterns for you:\n\n- [TLV](https://en.wikipedia.org/wiki/Type-length-value)\n- Bit level parsing\n- Hexadecimal viewer in the debugging macros for easy data analysis\n- Streaming parsers for network formats and huge files\n\nExample projects:\n\n- [FLV parser](https://github.com/rust-av/flavors)\n- [Matroska parser](https://github.com/rust-av/matroska)\n- [tar parser](https://github.com/Keruspe/tar-parser.rs)\n\n### Text format parsers\n\nWhile nom was made for binary format at first, it soon grew to work just as\nwell with text formats. From line based formats like CSV, to more complex, nested\nformats such as JSON, nom can manage it, and provides you with useful tools:\n\n- Fast case insensitive comparison\n- Recognizers for escaped strings\n- Regular expressions can be embedded in nom parsers to represent complex character patterns succinctly\n- Special care has been given to managing non ASCII characters properly\n\nExample projects:\n\n- [HTTP proxy](https://github.com/sozu-proxy/sozu/blob/main/lib/src/protocol/h2/parser.rs)\n- [TOML parser](https://github.com/joelself/tomllib)\n\n### Programming language parsers\n\nWhile programming language parsers are usually written manually for more\nflexibility and performance, nom can be (and has been successfully) used\nas a prototyping parser for a language.\n\nnom will get you started quickly with powerful custom error types, that you\ncan leverage with [nom_locate](https://github.com/fflorent/nom_locate) to\npinpoint the exact line and column of the error. No need for separate\ntokenizing, lexing and parsing phases: nom can automatically handle whitespace\nparsing, and construct an AST in place.\n\nExample projects:\n\n- [PHP VM](https://github.com/tagua-vm/parser)\n- [xshade shading language](https://github.com/xshade-lang/xshade)\n\n### Streaming formats\n\nWhile a lot of formats (and the code handling them) assume that they can fit\nthe complete data in memory, there are formats for which we only get a part\nof the data at once, like network formats, or huge files.\nnom has been designed for a correct behaviour with partial data: If there is\nnot enough data to decide, nom will tell you it needs more instead of silently\nreturning a wrong result. Whether your data comes entirely or in chunks, the\nresult should be the same.\n\nIt allows you to build powerful, deterministic state machines for your protocols.\n\nExample projects:\n\n- [HTTP proxy](https://github.com/sozu-proxy/sozu/blob/main/lib/src/protocol/h2/parser.rs)\n- [Using nom with generators](https://github.com/rust-bakery/generator_nom)\n\n## Parser combinators\n\nParser combinators are an approach to parsers that is very different from\nsoftware like [lex](https://en.wikipedia.org/wiki/Lex_(software)) and\n[yacc](https://en.wikipedia.org/wiki/Yacc). Instead of writing the grammar\nin a separate file and generating the corresponding code, you use very\nsmall functions with very specific purpose, like \"take 5 bytes\", or\n\"recognize the word 'HTTP'\", and assemble them in meaningful patterns\nlike \"recognize 'HTTP', then a space, then a version\".\nThe resulting code is small, and looks like the grammar you would have\nwritten with other parser approaches.\n\nThis has a few advantages:\n\n- The parsers are small and easy to write\n- The parsers components are easy to reuse (if they're general enough, please add them to nom!)\n- The parsers components are easy to test separately (unit tests and property-based tests)\n- The parser combination code looks close to the grammar you would have written\n- You can build partial parsers, specific to the data you need at the moment, and ignore the rest\n\n## Technical features\n\nnom parsers are for:\n- [x] **byte-oriented**: The basic type is `&[u8]` and parsers will work as much as possible on byte array slices (but are not limited to them)\n- [x] **bit-oriented**: nom can address a byte slice as a bit stream\n- [x] **string-oriented**: The same kind of combinators can apply on UTF-8 strings as well\n- [x] **zero-copy**: If a parser returns a subset of its input data, it will return a slice of that input, without copying\n- [x] **streaming**: nom can work on partial data and detect when it needs more data to produce a correct result\n- [x] **descriptive errors**: The parsers can aggregate a list of error codes with pointers to the incriminated input slice. Those error lists can be pattern matched to provide useful messages.\n- [x] **custom error types**: You can provide a specific type to improve errors returned by parsers\n- [x] **safe parsing**: nom leverages Rust's safe memory handling and powerful types, and parsers are routinely fuzzed and tested with real world data. So far, the only flaws found by fuzzing were in code written outside of nom\n- [x] **speed**: Benchmarks have shown that nom parsers often outperform many parser combinators library like Parsec and attoparsec, some regular expression engines and even handwritten C parsers\n\nSome benchmarks are available on [GitHub](https://github.com/rust-bakery/parser_benchmarks).\n\n## Rust version requirements (MSRV)\n\nThe 7.0 series of nom supports **Rustc version 1.56 or greater**.\n\nThe current policy is that this will only be updated in the next major nom release.\n\n## Installation\n\nnom is available on [crates.io](https://crates.io/crates/nom) and can be included in your Cargo enabled project like this:\n\n```toml\n[dependencies]\nnom = \"7\"\n```\n\nThere are a few compilation features:\n\n* `alloc`: (activated by default) if disabled, nom can work in `no_std` builds without memory allocators. If enabled, combinators that allocate (like `many0`) will be available\n* `std`: (activated by default, activates `alloc` too) if disabled, nom can work in `no_std` builds\n\nYou can configure those features like this:\n\n```toml\n[dependencies.nom]\nversion = \"7\"\ndefault-features = false\nfeatures = [\"alloc\"]\n```\n\n# Related projects\n\n- [Get line and column info in nom's input type](https://github.com/fflorent/nom_locate)\n- [Using nom as lexer and parser](https://github.com/Rydgel/monkey-rust)\n\n# Parsers written with nom\n\nHere is a (non exhaustive) list of known projects using nom:\n\n- Text file formats: [Ceph Crush](https://github.com/cholcombe973/crushtool),\n[Cronenberg](https://github.com/ayrat555/cronenberg),\n[Email](https://github.com/deuxfleurs-org/eml-codec),\n[XFS Runtime Stats](https://github.com/ChrisMacNaughton/xfs-rs),\n[CSV](https://github.com/GuillaumeGomez/csv-parser),\n[FASTA](https://github.com/TianyiShi2001/nom-fasta),\n[FASTQ](https://github.com/elij/fastq.rs),\n[INI](https://github.com/rust-bakery/nom/blob/main/tests/ini.rs),\n[ISO 8601 dates](https://github.com/badboy/iso8601),\n[libconfig-like configuration file format](https://github.com/filipegoncalves/rust-config),\n[Web archive](https://github.com/sbeckeriv/warc_nom_parser),\n[PDB](https://github.com/TianyiShi2001/nom-pdb),\n[proto files](https://github.com/tafia/protobuf-parser),\n[Fountain screenplay markup](https://github.com/adamchalmers/fountain-rs),\n[vimwiki](https://github.com/chipsenkbeil/vimwiki-rs/tree/master/vimwiki) & [vimwiki_macros](https://github.com/chipsenkbeil/vimwiki-rs/tree/master/vimwiki_macros),\n[Kconfig language](https://github.com/Mcdostone/nom-kconfig), [Askama templates](https://crates.io/crates/askama_parser/)\n- Programming languages:\n[PHP](https://github.com/tagua-vm/parser),\n[Basic Calculator](https://github.com/balajisivaraman/basic_calculator_rs),\n[GLSL](https://github.com/phaazon/glsl),\n[Lua](https://github.com/rozbb/nom-lua53),\n[Python](https://github.com/ProgVal/rust-python-parser),\n[SQL](https://github.com/ms705/nom-sql),\n[Elm](https://github.com/cout970/Elm-interpreter),\n[SystemVerilog](https://github.com/dalance/sv-parser),\n[Turtle](https://github.com/vandenoever/rome/tree/master/src/io/turtle),\n[CSML](https://github.com/CSML-by-Clevy/csml-engine/tree/dev/csml_interpreter),\n[Wasm](https://github.com/fabrizio-m/wasm-nom),\n[Pseudocode](https://github.com/Gungy2/pseudocod),\n[Filter for MeiliSearch](https://github.com/meilisearch/meilisearch),\n[PotterScript](https://github.com/fmiras/potterscript)\n- Interface definition formats: [Thrift](https://github.com/thehydroimpulse/thrust)\n- Audio, video and image formats:\n[GIF](https://github.com/Geal/gif.rs),\n[MagicaVoxel .vox](https://github.com/dust-engine/dot_vox),\n[MIDI](https://github.com/derekdreery/nom-midi-rs),\n[SWF](https://github.com/open-flash/swf-parser),\n[WAVE](https://github.com/Noise-Labs/wave),\n[Matroska (MKV)](https://github.com/rust-av/matroska),\n[Exif/Metadata parser for JPEG/HEIF/HEIC/MOV/MP4](https://github.com/mindeng/nom-exif)\n- Document formats:\n[TAR](https://github.com/Keruspe/tar-parser.rs),\n[GZ](https://github.com/nharward/nom-gzip),\n[GDSII](https://github.com/erihsu/gds2-io)\n- Cryptographic formats:\n[X.509](https://github.com/rusticata/x509-parser)\n- Network protocol formats:\n[Bencode](https://github.com/jbaum98/bencode.rs),\n[D-Bus](https://github.com/toshokan/misato),\n[DHCP](https://github.com/rusticata/dhcp-parser),\n[HTTP](https://github.com/sozu-proxy/sozu/tree/main/lib/src/protocol/http),\n[URI](https://github.com/santifa/rrp/blob/master/src/uri.rs),\n[IMAP](https://github.com/djc/tokio-imap) ([alt](https://github.com/duesee/imap-codec)),\n[IRC](https://github.com/Detegr/RBot-parser),\n[Pcap-NG](https://github.com/richo/pcapng-rs),\n[Pcap](https://github.com/ithinuel/pcap-rs),\n[Pcap + PcapNG](https://github.com/rusticata/pcap-parser),\n[IKEv2](https://github.com/rusticata/ipsec-parser),\n[NTP](https://github.com/rusticata/ntp-parser),\n[SNMP](https://github.com/rusticata/snmp-parser),\n[Kerberos v5](https://github.com/rusticata/kerberos-parser),\n[DER](https://github.com/rusticata/der-parser),\n[TLS](https://github.com/rusticata/tls-parser),\n[V5, V7, V9, IPFIX / Netflow v10](https://github.com/mikemiles-dev/netflow_parser),\n[GTP](https://github.com/fuerstenau/gorrosion-gtp),\n[SIP](https://github.com/kurotych/sipcore/tree/master/crates/sipmsg),\n[SMTP](https://github.com/Ekleog/kannader),\n[Prometheus](https://github.com/vectordotdev/vector/blob/master/lib/prometheus-parser/src/line.rs),\n[DNS](https://github.com/adiSuper94/dns-rs)\n- Language specifications:\n[BNF](https://github.com/shnewto/bnf)\n- Misc formats:\n[Game Boy ROM](https://github.com/MarkMcCaskey/gameboy-rom-parser),\n[ANT FIT](https://github.com/stadelmanma/fitparse-rs),\n[Version Numbers](https://github.com/fosskers/rs-versions),\n[Telcordia/Bellcore SR-4731 SOR OTDR files](https://github.com/JamesHarrison/otdrs),\n[MySQL binary log](https://github.com/PrivateRookie/boxercrab),\n[URI](https://github.com/Skasselbard/nom-uri),\n[Furigana](https://github.com/sachaarbonel/furigana.rs),\n[Wordle Result](https://github.com/Fyko/wordle-stats/tree/main/parser),\n[NBT](https://github.com/phoenixr-codes/mcnbt)\n\nWant to create a new parser using `nom`? A list of not yet implemented formats is available [here](https://github.com/rust-bakery/nom/issues/14).\n\nWant to add your parser here? Create a pull request for it!\n\n# Contributors\n\nnom is the fruit of the work of many contributors over the years, many thanks for your help!\n\n<a href=\"https://github.com/rust-bakery/nom/graphs/contributors\">\n  <img src=\"https://contributors-img.web.app/image?repo=rust-bakery/nom\" />\n</a>\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "nom-language",
          "type": "tree",
          "content": null
        },
        {
          "name": "proptest-regressions",
          "type": "tree",
          "content": null
        },
        {
          "name": "rustfmt.toml",
          "type": "blob",
          "size": 0.0302734375,
          "content": "tab_spaces = 2\nmax_width = 100\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}