{
  "metadata": {
    "timestamp": 1736557280133,
    "page": 166,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ocornut/imgui",
      "stars": 62425,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 1.04,
          "content": "# See http://editorconfig.org to read about the EditorConfig format.\n# - In theory automatically supported by VS2017+ and most common IDE or text editors.\n# - In practice VS2019-VS2022 stills don't trim trailing whitespaces correctly :(\n#   - Suggest installing this to trim whitespaces:\n#      GitHub https://github.com/madskristensen/TrailingWhitespace\n#      VS2019 https://marketplace.visualstudio.com/items?itemName=MadsKristensen.TrailingWhitespaceVisualizer\n#      VS2022 https://marketplace.visualstudio.com/items?itemName=MadsKristensen.TrailingWhitespace64\n#     (in spite of its name doesn't only visualize but also trims)\n#   - Alternative for older VS2010 to VS2015: https://marketplace.visualstudio.com/items?itemName=EditorConfigTeam.EditorConfig\n\n# top-most EditorConfig file\nroot = true\n\n# Default settings:\n# Use 4 spaces as indentation\n[*]\nindent_style = space\nindent_size = 4\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[imstb_*]\nindent_size = 3\ntrim_trailing_whitespace = false\n\n[Makefile]\nindent_style = tab\nindent_size = 4\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.39,
          "content": "* text=auto\n\n*.c text\n*.cpp text\n*.h text\n*.m text\n*.mm text\n*.md text\n*.txt text\n*.html text\n*.bat text\n*.frag text\n*.vert text\n*.mkb text\n*.icf text\n\n*.sln text eol=crlf\n*.vcxproj text eol=crlf\n*.vcxproj.filters text eol=crlf\n*.natvis text eol=crlf\n\nMakefile text eol=lf\n*.sh text eol=lf\n*.pbxproj text eol=lf\n*.storyboard text eol=lf\n*.plist text eol=lf\n\n*.png binary\n*.ttf binary\n*.lib binary\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.19,
          "content": "## OSX artifacts\n.DS_Store\n\n## Dear ImGui artifacts\nimgui.ini\nimgui*.ini\n\n## General build artifacts\n*.o\n*.obj\n*.exe\nexamples/*/Debug/*\nexamples/*/Release/*\nexamples/*/x64/*\n\n## Visual Studio artifacts\n.vs\nipch\n*.opensdf\n*.log\n*.pdb\n*.ilk\n*.user\n*.sdf\n*.suo\n*.VC.db\n*.VC.VC.opendb\n\n## Getting files created in JSON/Schemas/Catalog/ from a VS2022 update\nJSON/\n\n## Commonly used CMake directories\nbuild*/\n\n## Xcode artifacts\nproject.xcworkspace\nxcuserdata\n\n## Emscripten artifacts\nexamples/*.o.tmp\nexamples/*.out.js\nexamples/*.out.wasm\nexamples/example_glfw_opengl3/web/*\nexamples/example_glfw_wgpu/web/*\nexamples/example_glfw_wgpu/external/*\nexamples/example_sdl2_opengl3/web/*\n\n## JetBrains IDE artifacts\n.idea\ncmake-build-*\n\n## Unix executables from our example Makefiles\nexamples/example_glfw_metal/example_glfw_metal\nexamples/example_glfw_opengl2/example_glfw_opengl2\nexamples/example_glfw_opengl3/example_glfw_opengl3\nexamples/example_glut_opengl2/example_glut_opengl2\nexamples/example_null/example_null\nexamples/example_sdl2_metal/example_sdl2_metal\nexamples/example_sdl2_opengl2/example_sdl2_opengl2\nexamples/example_sdl2_opengl3/example_sdl2_opengl3\nexamples/example_sdl2_sdlrenderer/example_sdl2_sdlrenderer\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.06,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014-2025 Omar Cornut\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "backends",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "imconfig.h",
          "type": "blob",
          "size": 11.39,
          "content": "//-----------------------------------------------------------------------------\n// DEAR IMGUI COMPILE-TIME OPTIONS\n// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.\n// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.\n//-----------------------------------------------------------------------------\n// A) You may edit imconfig.h (and not overwrite it when updating Dear ImGui, or maintain a patch/rebased branch with your modifications to it)\n// B) or '#define IMGUI_USER_CONFIG \"my_imgui_config.h\"' in your project and then add directives in your own file without touching this template.\n//-----------------------------------------------------------------------------\n// You need to make sure that configuration settings are defined consistently _everywhere_ Dear ImGui is used, which include the imgui*.cpp\n// files but also _any_ of your code that uses Dear ImGui. This is because some compile-time options have an affect on data structures.\n// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.\n// Call IMGUI_CHECKVERSION() from your .cpp file to verify that the data structures your files are using are matching the ones imgui.cpp is using.\n//-----------------------------------------------------------------------------\n\n#pragma once\n\n//---- Define assertion handler. Defaults to calling assert().\n// If your macro uses multiple statements, make sure is enclosed in a 'do { .. } while (0)' block so it can be used as a single statement.\n//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)\n//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts\n\n//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows\n// Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.\n// - Windows DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()\n//   for each static/DLL boundary you are calling from. Read \"Context and Memory Allocators\" section of imgui.cpp for more details.\n//#define IMGUI_API __declspec(dllexport)                   // MSVC Windows: DLL export\n//#define IMGUI_API __declspec(dllimport)                   // MSVC Windows: DLL import\n//#define IMGUI_API __attribute__((visibility(\"default\")))  // GCC/Clang: override visibility when set is hidden\n\n//---- Don't define obsolete functions/enums/behaviors. Consider enabling from time to time after updating to clean your code of obsolete function/names.\n//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n\n//---- Disable all of Dear ImGui or don't implement standard windows/tools.\n// It is very strongly recommended to NOT disable the demo windows and debug tool during development. They are extremely useful in day to day work. Please read comments in imgui_demo.cpp.\n//#define IMGUI_DISABLE                                     // Disable everything: all headers and source files will be empty.\n//#define IMGUI_DISABLE_DEMO_WINDOWS                        // Disable demo windows: ShowDemoWindow()/ShowStyleEditor() will be empty.\n//#define IMGUI_DISABLE_DEBUG_TOOLS                         // Disable metrics/debugger and other debug tools: ShowMetricsWindow(), ShowDebugLogWindow() and ShowIDStackToolWindow() will be empty.\n\n//---- Don't implement some functions to reduce linkage requirements.\n//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc. (user32.lib/.a, kernel32.lib/.a)\n//#define IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS          // [Win32] [Default with Visual Studio] Implement default IME handler (require imm32.lib/.a, auto-link for Visual Studio, -limm32 on command-line for MinGW)\n//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] [Default with non-Visual Studio compilers] Don't implement default IME handler (won't require imm32.lib/.a)\n//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function (clipboard, IME).\n//#define IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS      // [OSX] Implement default OSX clipboard handler (need to link with '-framework ApplicationServices', this is why this is not the default).\n//#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS             // Don't implement default platform_io.Platform_OpenInShellFn() handler (Win32: ShellExecute(), require shell32.lib/.a, Mac/Linux: use system(\"\")).\n//#define IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS            // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself (e.g. if you don't want to link with vsnprintf)\n//#define IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS              // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 so you can implement them yourself.\n//#define IMGUI_DISABLE_FILE_FUNCTIONS                      // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle at all (replace them with dummies)\n//#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS              // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle so you can implement them yourself if you don't want to link with fopen/fclose/fread/fwrite. This will also disable the LogToTTY() function.\n//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().\n//#define IMGUI_DISABLE_DEFAULT_FONT                        // Disable default embedded font (ProggyClean.ttf), remove ~9.5 KB from output binary. AddFontDefault() will assert.\n//#define IMGUI_DISABLE_SSE                                 // Disable use of SSE intrinsics even if available\n\n//---- Enable Test Engine / Automation features.\n//#define IMGUI_ENABLE_TEST_ENGINE                          // Enable imgui_test_engine hooks. Generally set automatically by include \"imgui_te_config.h\", see Test Engine for details.\n\n//---- Include imgui_user.h at the end of imgui.h as a convenience\n// May be convenient for some users to only explicitly include vanilla imgui.h and have extra stuff included.\n//#define IMGUI_INCLUDE_IMGUI_USER_H\n//#define IMGUI_USER_H_FILENAME         \"my_folder/my_imgui_user.h\"\n\n//---- Pack vertex colors as BGRA8 instead of RGBA8 (to avoid converting from one to another). Need dedicated backend support.\n//#define IMGUI_USE_BGRA_PACKED_COLOR\n\n//---- Use legacy CRC32-adler tables (used before 1.91.6), in order to preserve old .ini data that you cannot afford to invalidate.\n//#define IMGUI_USE_LEGACY_CRC32_ADLER\n\n//---- Use 32-bit for ImWchar (default is 16-bit) to support Unicode planes 1-16. (e.g. point beyond 0xFFFF like emoticons, dingbats, symbols, shapes, ancient languages, etc...)\n//#define IMGUI_USE_WCHAR32\n\n//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version\n// By default the embedded implementations are declared static and not available outside of Dear ImGui sources files.\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack.h\"\n//#define IMGUI_STB_SPRINTF_FILENAME    \"my_folder/stb_sprintf.h\"    // only used if IMGUI_USE_STB_SPRINTF is defined.\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\n//#define IMGUI_DISABLE_STB_SPRINTF_IMPLEMENTATION                   // only disabled if IMGUI_USE_STB_SPRINTF is defined.\n\n//---- Use stb_sprintf.h for a faster implementation of vsnprintf instead of the one from libc (unless IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS is defined)\n// Compatibility checks of arguments and formats done by clang and GCC will be disabled in order to support the extra formats provided by stb_sprintf.h.\n//#define IMGUI_USE_STB_SPRINTF\n\n//---- Use FreeType to build and rasterize the font atlas (instead of stb_truetype which is embedded by default in Dear ImGui)\n// Requires FreeType headers to be available in the include path. Requires program to be compiled with 'misc/freetype/imgui_freetype.cpp' (in this repository) + the FreeType library (not provided).\n// On Windows you may use vcpkg with 'vcpkg install freetype --triplet=x64-windows' + 'vcpkg integrate install'.\n//#define IMGUI_ENABLE_FREETYPE\n\n//---- Use FreeType + plutosvg or lunasvg to render OpenType SVG fonts (SVGinOT)\n// Only works in combination with IMGUI_ENABLE_FREETYPE.\n// - lunasvg is currently easier to acquire/install, as e.g. it is part of vcpkg.\n// - plutosvg will support more fonts and may load them faster. It currently requires to be built manually but it is fairly easy. See misc/freetype/README for instructions.\n// - Both require headers to be available in the include path + program to be linked with the library code (not provided).\n// - (note: lunasvg implementation is based on Freetype's rsvg-port.c which is licensed under CeCILL-C Free Software License Agreement)\n//#define IMGUI_ENABLE_FREETYPE_PLUTOSVG\n//#define IMGUI_ENABLE_FREETYPE_LUNASVG\n\n//---- Use stb_truetype to build and rasterize the font atlas (default)\n// The only purpose of this define is if you want force compilation of the stb_truetype backend ALONG with the FreeType backend.\n//#define IMGUI_ENABLE_STB_TRUETYPE\n\n//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.\n// This will be inlined as part of ImVec2 and ImVec4 class declarations.\n/*\n#define IM_VEC2_CLASS_EXTRA                                                     \\\n        constexpr ImVec2(const MyVec2& f) : x(f.x), y(f.y) {}                   \\\n        operator MyVec2() const { return MyVec2(x,y); }\n\n#define IM_VEC4_CLASS_EXTRA                                                     \\\n        constexpr ImVec4(const MyVec4& f) : x(f.x), y(f.y), z(f.z), w(f.w) {}   \\\n        operator MyVec4() const { return MyVec4(x,y,z,w); }\n*/\n//---- ...Or use Dear ImGui's own very basic math operators.\n//#define IMGUI_DEFINE_MATH_OPERATORS\n\n//---- Use 32-bit vertex indices (default is 16-bit) is one way to allow large meshes with more than 64K vertices.\n// Your renderer backend will need to support it (most example renderer backends support both 16/32-bit indices).\n// Another way to allow large meshes while keeping 16-bit indices is to handle ImDrawCmd::VtxOffset in your renderer.\n// Read about ImGuiBackendFlags_RendererHasVtxOffset for details.\n//#define ImDrawIdx unsigned int\n\n//---- Override ImDrawCallback signature (will need to modify renderer backends accordingly)\n//struct ImDrawList;\n//struct ImDrawCmd;\n//typedef void (*MyImDrawCallback)(const ImDrawList* draw_list, const ImDrawCmd* cmd, void* my_renderer_user_data);\n//#define ImDrawCallback MyImDrawCallback\n\n//---- Debug Tools: Macro to break in Debugger (we provide a default implementation of this in the codebase)\n// (use 'Metrics->Tools->Item Picker' to pick widgets with the mouse and break into them for easy debugging.)\n//#define IM_DEBUG_BREAK  IM_ASSERT(0)\n//#define IM_DEBUG_BREAK  __debugbreak()\n\n//---- Debug Tools: Enable slower asserts\n//#define IMGUI_DEBUG_PARANOID\n\n//---- Tip: You can add extra functions within the ImGui:: namespace from anywhere (e.g. your own sources/header files)\n/*\nnamespace ImGui\n{\n    void MyFunction(const char* name, MyMatrix44* mtx);\n}\n*/\n"
        },
        {
          "name": "imgui.cpp",
          "type": "blob",
          "size": 850.4,
          "content": "// dear imgui, v1.91.7 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2025 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ID STACK\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING, STATE RECOVERY\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] WINDOW FOCUS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Minimize state synchronization.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed primarily for developers and content-creators, not the typical end-user!\n Some of the current weaknesses (which we aim to address in the future) includes:\n\n - Doesn't look fancy.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n CONTROLS GUIDE\n ==============\n\n - MOUSE CONTROLS\n   - Mouse wheel:                   Scroll vertically.\n   - SHIFT+Mouse wheel:             Scroll horizontally.\n   - Click [X]:                     Close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n   - Click ^, Double-Click title:   Collapse window.\n   - Drag on corner/border:         Resize window (double-click to auto fit window to its contents).\n   - Drag on any empty space:       Move window (unless io.ConfigWindowsMoveFromTitleBarOnly = true).\n   - Left-click outside popup:      Close popup stack (right-click over underlying popup: Partially close popup stack).\n\n - TEXT EDITOR\n   - Hold SHIFT or Drag Mouse:      Select text.\n   - CTRL+Left/Right:               Word jump.\n   - CTRL+Shift+Left/Right:         Select words.\n   - CTRL+A or Double-Click:        Select All.\n   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.\n   - CTRL+Z, CTRL+Y:                Undo, Redo.\n   - ESCAPE:                        Revert text to its original value.\n   - On OSX, controls are automatically adjusted to match standard OSX text editing 2ts and behaviors.\n\n - KEYBOARD CONTROLS\n   - Basic:\n     - Tab, SHIFT+Tab               Cycle through text editable fields.\n     - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.\n     - CTRL+Click                   Input text into a Slider or Drag widget.\n   - Extended features with `io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard`:\n     - Tab, SHIFT+Tab:              Cycle through every items.\n     - Arrow keys                   Move through items using directional navigation. Tweak value.\n     - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow keys).\n     - Enter                        Activate item (prefer text input when possible).\n     - Space                        Activate item (prefer tweaking with arrows when possible).\n     - Escape                       Deactivate item, leave child window, close popup.\n     - Page Up, Page Down           Previous page, next page.\n     - Home, End                    Scroll to top, scroll to bottom.\n     - Alt                          Toggle between scrolling layer and menu layer.\n     - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of moving.\n   - Output when ImGuiConfigFlags_NavEnableKeyboard set,\n     - io.WantCaptureKeyboard flag is set when keyboard is claimed.\n     - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.\n     - io.NavVisible: true when the navigation cursor is visible (usually goes to back false when mouse is used).\n\n - GAMEPAD CONTROLS\n   - Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n   - Particularly useful to use Dear ImGui on a console system (e.g. PlayStation, Switch, Xbox) without a mouse!\n   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets\n   - Backend support: backend needs to:\n      - Set 'io.BackendFlags |= ImGuiBackendFlags_HasGamepad' + call io.AddKeyEvent/AddKeyAnalogEvent() with ImGuiKey_Gamepad_XXX keys.\n      - For analog values (0.0f to 1.0f), backend is responsible to handling a dead-zone and rescaling inputs accordingly.\n        Backend code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).\n   - If you need to share inputs between your game and the Dear ImGui interface, the easiest approach is to go all-or-nothing,\n     with a buttons combo to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.\n\n - REMOTE INPUTS SHARING & MOUSE EMULATION\n   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad or a spare analog stick as a mouse-emulation fallback.\n   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)\n     in order to share your PC mouse/keyboard.\n   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for other remoting solutions.\n   - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the io.ConfigNavMoveSetMousePos flag.\n     Enabling io.ConfigNavMoveSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs Dear ImGui to move your mouse cursor along with navigation movements.\n     When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.\n     When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.\n     (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, Dear ImGui will misbehave as it will see your mouse moving back & forth!)\n     (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want\n     to set a boolean to ignore your other external mouse positions until the external source is moved again.)\n\n\n PROGRAMMER GUIDE\n ================\n\n READ FIRST\n ----------\n - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)\n - Your code creates the UI every frame of your application loop, if your code doesn't run the UI is gone!\n   The UI can be highly dynamic, there are no construction or destruction steps, less superfluous\n   data retention on your side, less state duplication, less state synchronization, fewer bugs.\n - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.\n   Or browse https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html for interactive web version.\n - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.\n - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).\n   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.\n - Dear ImGui is a \"single pass\" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.\n   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,\n   where the UI code is called multiple times (\"multiple passes\") from a single entry point. There are pros and cons to both approaches.\n - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.\n - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).\n   If you get an assert, read the messages and comments around the assert.\n - This codebase aims to be highly optimized:\n   - A typical idle frame should never call malloc/free.\n   - We rely on a maximum of constant-time or O(N) algorithms. Limiting searches/scans as much as possible.\n   - We put particular energy in making sure performances are decent with typical \"Debug\" build settings as well.\n     Which mean we tend to avoid over-relying on \"zero-cost abstraction\" as they aren't zero-cost at all.\n - This codebase aims to be both highly opinionated and highly flexible:\n   - This code works because of the things it choose to solve or not solve.\n   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features, we don't include C++ headers,\n     and ImGui:: is a namespace. We rarely use member functions (and when we did, I am mostly regretting it now).\n     This is to increase compatibility, increase maintainability and facilitate use from other languages.\n   - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.\n     See FAQ \"How can I use my own math types instead of ImVec2/ImVec4?\" for details about setting up imconfig.h for that.\n     We can can optionally export math operators for ImVec2/ImVec4 using IMGUI_DEFINE_MATH_OPERATORS, which we use internally.\n   - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction\n     (so don't use ImVector in your code or at our own risk!).\n   - Building: We don't use nor mandate a build system for the main library.\n     This is in an effort to ensure that it works in the real world aka with any esoteric build setup.\n     This is also because providing a build system for the main library would be of little-value.\n     The build problems are almost never coming from the main library but from specific backends.\n\n\n HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n ----------------------------------------------\n - Update submodule or copy/overwrite every file.\n - About imconfig.h:\n   - You may modify your copy of imconfig.h, in this case don't overwrite it.\n   - or you may locally branch to modify imconfig.h and merge/rebase latest.\n   - or you may '#define IMGUI_USER_CONFIG \"my_config_file.h\"' globally from your build system to\n     specify a custom path for your imconfig.h file and instead not have to modify the default one.\n\n - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)\n - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over \"master\".\n - You can also use '#define IMGUI_USER_CONFIG \"my_config_file.h\" to redirect configuration to your own file.\n - Read the \"API BREAKING CHANGES\" section (below). This is where we list occasional API breaking changes.\n   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed\n   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will\n   likely be a comment about it. Please report any issue to the GitHub page!\n - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.\n - Try to keep your copy of Dear ImGui reasonably up to date!\n\n\n GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n ---------------------------------------------------------------\n - See https://github.com/ocornut/imgui/wiki/Getting-Started.\n - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.\n - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.\n - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.\n   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).\n - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.\n - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.\n - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.\n   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in \"update\" vs \"render\"\n   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling ImGui::Render().\n - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.\n - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.\n\n\n HOW A SIMPLE APPLICATION MAY LOOK LIKE\n --------------------------------------\n EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).\n The sub-folders in examples/ contain examples applications following this structure.\n\n     // Application init: create a dear imgui context, setup some options, load fonts\n     ImGui::CreateContext();\n     ImGuiIO& io = ImGui::GetIO();\n     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.\n     // TODO: Fill optional fields of the io structure later.\n     // TODO: Load TTF/OTF fonts if you don't want to use the default font.\n\n     // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)\n     ImGui_ImplWin32_Init(hwnd);\n     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);\n\n     // Application main loop\n     while (true)\n     {\n         // Feed inputs to dear imgui, start new frame\n         ImGui_ImplDX11_NewFrame();\n         ImGui_ImplWin32_NewFrame();\n         ImGui::NewFrame();\n\n         // Any application code here\n         ImGui::Text(\"Hello, world!\");\n\n         // Render dear imgui into screen\n         ImGui::Render();\n         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());\n         g_pSwapChain->Present(1, 0);\n     }\n\n     // Shutdown\n     ImGui_ImplDX11_Shutdown();\n     ImGui_ImplWin32_Shutdown();\n     ImGui::DestroyContext();\n\n EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE\n\n     // Application init: create a dear imgui context, setup some options, load fonts\n     ImGui::CreateContext();\n     ImGuiIO& io = ImGui::GetIO();\n     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.\n     // TODO: Fill optional fields of the io structure later.\n     // TODO: Load TTF/OTF fonts if you don't want to use the default font.\n\n     // Build and load the texture atlas into a texture\n     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)\n     int width, height;\n     unsigned char* pixels = nullptr;\n     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);\n\n     // At this point you've got the texture data and you need to upload that to your graphic system:\n     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.\n     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.\n     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)\n     io.Fonts->SetTexID((void*)texture);\n\n     // Application main loop\n     while (true)\n     {\n        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.\n        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)\n        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)\n        io.DisplaySize.x = 1920.0f;             // set the current display width\n        io.DisplaySize.y = 1280.0f;             // set the current display height here\n        io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position\n        io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states\n        io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states\n\n        // Call NewFrame(), after this point you can use ImGui::* functions anytime\n        // (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)\n        ImGui::NewFrame();\n\n        // Most of your application code here\n        ImGui::Text(\"Hello, world!\");\n        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin(\"My window\"); ImGui::Text(\"Hello, world!\"); ImGui::End();\n        MyGameRender(); // may use any Dear ImGui functions as well!\n\n        // Render dear imgui, swap buffers\n        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)\n        ImGui::EndFrame();\n        ImGui::Render();\n        ImDrawData* draw_data = ImGui::GetDrawData();\n        MyImGuiRenderFunction(draw_data);\n        SwapBuffers();\n     }\n\n     // Shutdown\n     ImGui::DestroyContext();\n\n To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,\n you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!\n Please read the FAQ entry \"How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?\" about this.\n\n\n HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n ---------------------------------------------\n The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.\n\n    void MyImGuiRenderFunction(ImDrawData* draw_data)\n    {\n       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled\n       // TODO: Setup texture sampling state: sample with bilinear filtering (NOT point/nearest filtering). Use 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.\n       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize\n       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize\n       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.\n       ImVec2 clip_off = draw_data->DisplayPos;\n       for (int n = 0; n < draw_data->CmdListsCount; n++)\n       {\n          const ImDrawList* cmd_list = draw_data->CmdLists[n];\n          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui\n          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui\n          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)\n          {\n             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];\n             if (pcmd->UserCallback)\n             {\n                 pcmd->UserCallback(cmd_list, pcmd);\n             }\n             else\n             {\n                 // Project scissor/clipping rectangles into framebuffer space\n                 ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);\n                 ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);\n                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)\n                     continue;\n\n                 // We are using scissoring to clip some objects. All low-level graphics API should support it.\n                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches\n                 //   (some elements visible outside their bounds) but you can fix that once everything else works!\n                 // - Clipping coordinates are provided in imgui coordinates space:\n                 //   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size\n                 //   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.\n                 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),\n                 //     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.\n                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)\n                 MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);\n\n                 // The texture for the draw call is specified by pcmd->GetTexID().\n                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.\n                 MyEngineBindTexture((MyTexture*)pcmd->GetTexID());\n\n                 // Render 'pcmd->ElemCount/3' indexed triangles.\n                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.\n                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);\n             }\n          }\n       }\n    }\n\n\n API BREAKING CHANGES\n ====================\n\n Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.\n Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.\n When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.\n You can read releases logs https://github.com/ocornut/imgui/releases for more details.\n\n - 2024/11/27 (1.91.6) - changed CRC32 table from CRC32-adler to CRC32c polynomial in order to be compatible with the result of SSE 4.2 instructions.\n                         As a result, old .ini data may be partially lost (docking and tables information particularly).\n                         Because some users have crafted and storing .ini data as a way to workaround limitations of the docking API, we are providing a '#define IMGUI_USE_LEGACY_CRC32_ADLER' compile-time option to keep using old CRC32 tables if you cannot afford invalidating old .ini data.\n - 2024/11/06 (1.91.5) - commented/obsoleted out pre-1.87 IO system (equivalent to using IMGUI_DISABLE_OBSOLETE_KEYIO or IMGUI_DISABLE_OBSOLETE_FUNCTIONS before)\n                            - io.KeyMap[] and io.KeysDown[] are removed (obsoleted February 2022).\n                            - io.NavInputs[] and ImGuiNavInput are removed (obsoleted July 2022).\n                            - pre-1.87 backends are not supported:\n                               - backends need to call io.AddKeyEvent(), io.AddMouseEvent() instead of writing to io.KeysDown[], io.MouseDown[] fields.\n                               - backends need to call io.AddKeyAnalogEvent() for gamepad values instead of writing to io.NavInputs[] fields.\n                            - for more reference:\n                              - read 1.87 and 1.88 part of this section or read Changelog for 1.87 and 1.88.\n                              - read https://github.com/ocornut/imgui/issues/4921\n                            - if you have trouble updating a very old codebase using legacy backend-specific key codes: consider updating to 1.91.4 first, then #define IMGUI_DISABLE_OBSOLETE_KEYIO, then update to latest.\n                       - obsoleted ImGuiKey_COUNT (it is unusually error-prone/misleading since valid keys don't start at 0). probably use ImGuiKey_NamedKey_BEGIN/ImGuiKey_NamedKey_END?\n                       - fonts: removed const qualifiers from most font functions in prevision for upcoming font improvements.\n - 2024/10/18 (1.91.4) - renamed ImGuiCol_NavHighlight to ImGuiCol_NavCursor (for consistency with newly exposed and reworked features). Kept inline redirection enum (will obsolete).\n - 2024/10/14 (1.91.4) - moved ImGuiConfigFlags_NavEnableSetMousePos to standalone io.ConfigNavMoveSetMousePos bool.\n                         moved ImGuiConfigFlags_NavNoCaptureKeyboard to standalone io.ConfigNavCaptureKeyboard bool (note the inverted value!).\n                         kept legacy names (will obsolete) + code that copies settings once the first time. Dynamically changing the old value won't work. Switch to using the new value!\n - 2024/10/10 (1.91.4) - the typedef for ImTextureID now defaults to ImU64 instead of void*. (#1641)\n                         this removes the requirement to redefine it for backends which are e.g. storing descriptor sets or other 64-bits structures when building on 32-bits archs. It therefore simplify various building scripts/helpers.\n                         you may have compile-time issues if you were casting to 'void*' instead of 'ImTextureID' when passing your types to functions taking ImTextureID values, e.g. ImGui::Image().\n                         in doubt it is almost always better to do an intermediate intptr_t cast, since it allows casting any pointer/integer type without warning:\n                            - May warn:    ImGui::Image((void*)MyTextureData, ...);\n                            - May warn:    ImGui::Image((void*)(intptr_t)MyTextureData, ...);\n                            - Won't warn:  ImGui::Image((ImTextureID)(intptr_t)MyTextureData), ...);\n  -                      note that you can always define ImTextureID to be your own high-level structures (with dedicated constructors) if you like.\n - 2024/10/03 (1.91.3) - drags: treat v_min==v_max as a valid clamping range when != 0.0f. Zero is a still special value due to legacy reasons, unless using ImGuiSliderFlags_ClampZeroRange. (#7968, #3361, #76)\n                       - drags: extended behavior of ImGuiSliderFlags_AlwaysClamp to include _ClampZeroRange. It considers v_min==v_max==0.0f as a valid clamping range (aka edits not allowed).\n                         although unlikely, it you wish to only clamp on text input but want v_min==v_max==0.0f to mean unclamped drags, you can use _ClampOnInput instead of _AlwaysClamp. (#7968, #3361, #76)\n - 2024/09/10 (1.91.2) - internals: using multiple overlayed ButtonBehavior() with same ID will now have io.ConfigDebugHighlightIdConflicts=true feature emit a warning. (#8030)\n                         it was one of the rare case where using same ID is legal. workarounds: (1) use single ButtonBehavior() call with multiple _MouseButton flags, or (2) surround the calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()\n - 2024/08/23 (1.91.1) - renamed ImGuiChildFlags_Border to ImGuiChildFlags_Borders for consistency. kept inline redirection flag.\n - 2024/08/22 (1.91.1) - moved some functions from ImGuiIO to ImGuiPlatformIO structure:\n                            - io.GetClipboardTextFn         -> platform_io.Platform_GetClipboardTextFn + changed 'void* user_data' to 'ImGuiContext* ctx'. Pull your user data from platform_io.ClipboardUserData.\n                            - io.SetClipboardTextFn         -> platform_io.Platform_SetClipboardTextFn + same as above line.\n                            - io.PlatformOpenInShellFn      -> platform_io.Platform_OpenInShellFn (#7660)\n                            - io.PlatformSetImeDataFn       -> platform_io.Platform_SetImeDataFn\n                            - io.PlatformLocaleDecimalPoint -> platform_io.Platform_LocaleDecimalPoint (#7389, #6719, #2278)\n                            - access those via GetPlatformIO() instead of GetIO().\n                         some were introduced very recently and often automatically setup by core library and backends, so for those we are exceptionally not maintaining a legacy redirection symbol.\n                       - commented the old ImageButton() signature obsoleted in 1.89 (~August 2022). As a reminder:\n                            - old ImageButton() before 1.89 used ImTextureId as item id (created issue with e.g. multiple buttons in same scope, transient texture id values, opaque computation of ID)\n                            - new ImageButton() since 1.89 requires an explicit 'const char* str_id'\n                            - old ImageButton() before 1.89 had frame_padding' override argument.\n                            - new ImageButton() since 1.89 always use style.FramePadding, which you can freely override with PushStyleVar()/PopStyleVar().\n - 2024/07/25 (1.91.0) - obsoleted GetContentRegionMax(), GetWindowContentRegionMin() and GetWindowContentRegionMax(). (see #7838 on GitHub for more info)\n                         you should never need those functions. you can do everything with GetCursorScreenPos() and GetContentRegionAvail() in a more simple way.\n                            - instead of:  GetWindowContentRegionMax().x - GetCursorPos().x\n                            - you can use: GetContentRegionAvail().x\n                            - instead of:  GetWindowContentRegionMax().x + GetWindowPos().x\n                            - you can use: GetCursorScreenPos().x + GetContentRegionAvail().x // when called from left edge of window\n                            - instead of:  GetContentRegionMax()\n                            - you can use: GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos() // right edge in local coordinates\n                            - instead of:  GetWindowContentRegionMax().x - GetWindowContentRegionMin().x\n                            - you can use: GetContentRegionAvail() // when called from left edge of window\n - 2024/07/15 (1.91.0) - renamed ImGuiSelectableFlags_DontClosePopups to ImGuiSelectableFlags_NoAutoClosePopups. (#1379, #1468, #2200, #4936, #5216, #7302, #7573)\n                         (internals: also renamed ImGuiItemFlags_SelectableDontClosePopup into ImGuiItemFlags_AutoClosePopups with inverted behaviors)\n - 2024/07/15 (1.91.0) - obsoleted PushButtonRepeat()/PopButtonRepeat() in favor of using new PushItemFlag(ImGuiItemFlags_ButtonRepeat, ...)/PopItemFlag().\n - 2024/07/02 (1.91.0) - commented out obsolete ImGuiModFlags (renamed to ImGuiKeyChord in 1.89). (#4921, #456)\n                       - commented out obsolete ImGuiModFlags_XXX values (renamed to ImGuiMod_XXX in 1.89). (#4921, #456)\n                            - ImGuiModFlags_Ctrl -> ImGuiMod_Ctrl, ImGuiModFlags_Shift -> ImGuiMod_Shift etc.\n - 2024/07/02 (1.91.0) - IO, IME: renamed platform IME hook and added explicit context for consistency and future-proofness.\n                            - old: io.SetPlatformImeDataFn(ImGuiViewport* viewport, ImGuiPlatformImeData* data);\n                            - new: io.PlatformSetImeDataFn(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);\n - 2024/06/21 (1.90.9) - BeginChild: added ImGuiChildFlags_NavFlattened as a replacement for the window flag ImGuiWindowFlags_NavFlattened: the feature only ever made sense for BeginChild() anyhow.\n                            - old: BeginChild(\"Name\", size, 0, ImGuiWindowFlags_NavFlattened);\n                            - new: BeginChild(\"Name\", size, ImGuiChildFlags_NavFlattened, 0);\n - 2024/06/21 (1.90.9) - io: ClearInputKeys() (first exposed in 1.89.8) doesn't clear mouse data, newly added ClearInputMouse() does.\n - 2024/06/20 (1.90.9) - renamed ImGuiDragDropFlags_SourceAutoExpirePayload to ImGuiDragDropFlags_PayloadAutoExpire.\n - 2024/06/18 (1.90.9) - style: renamed ImGuiCol_TabActive -> ImGuiCol_TabSelected, ImGuiCol_TabUnfocused -> ImGuiCol_TabDimmed, ImGuiCol_TabUnfocusedActive -> ImGuiCol_TabDimmedSelected.\n - 2024/06/10 (1.90.9) - removed old nested structure: renaming ImGuiStorage::ImGuiStoragePair type to ImGuiStoragePair (simpler for many languages).\n - 2024/06/06 (1.90.8) - reordered ImGuiInputTextFlags values. This should not be breaking unless you are using generated headers that have values not matching the main library.\n - 2024/06/06 (1.90.8) - removed 'ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft', was mostly unused and misleading.\n - 2024/05/27 (1.90.7) - commented out obsolete symbols marked obsolete in 1.88 (May 2022):\n                            - old: CaptureKeyboardFromApp(bool)\n                            - new: SetNextFrameWantCaptureKeyboard(bool)\n                            - old: CaptureMouseFromApp(bool)\n                            - new: SetNextFrameWantCaptureMouse(bool)\n - 2024/05/22 (1.90.7) - inputs (internals): renamed ImGuiKeyOwner_None to ImGuiKeyOwner_NoOwner, to make use more explicit and reduce confusion with the default it is a non-zero value and cannot be the default value (never made public, but disclosing as I expect a few users caught on owner-aware inputs).\n                       - inputs (internals): renamed ImGuiInputFlags_RouteGlobalLow -> ImGuiInputFlags_RouteGlobal, ImGuiInputFlags_RouteGlobal -> ImGuiInputFlags_RouteGlobalOverFocused, ImGuiInputFlags_RouteGlobalHigh -> ImGuiInputFlags_RouteGlobalHighest.\n                       - inputs (internals): Shortcut(), SetShortcutRouting(): swapped last two parameters order in function signatures:\n                            - old: Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);\n                            - new: Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0, ImGuiID owner_id = 0);\n                       - inputs (internals): owner-aware versions of IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(): swapped last two parameters order in function signatures.\n                            - old: IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);\n                            - new: IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);\n                            - old: IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);\n                            - new: IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);\n                         for various reasons those changes makes sense. They are being made because making some of those API public.\n                         only past users of imgui_internal.h with the extra parameters will be affected. Added asserts for valid flags in various functions to detect _some_ misuses, BUT NOT ALL.\n - 2024/05/16 (1.90.7) - inputs: on macOS X, Cmd and Ctrl keys are now automatically swapped by io.AddKeyEvent() as this naturally align with how macOS X uses those keys.\n                           - it shouldn't really affect you unless you had custom shortcut swapping in place for macOS X apps.\n                           - removed ImGuiMod_Shortcut which was previously dynamically remapping to Ctrl or Cmd/Super. It is now unnecessary to specific cross-platform idiomatic shortcuts. (#2343, #4084, #5923, #456)\n - 2024/05/14 (1.90.7) - backends: SDL_Renderer2 and SDL_Renderer3 backend now take a SDL_Renderer* in their RenderDrawData() functions.\n - 2024/04/18 (1.90.6) - TreeNode: Fixed a layout inconsistency when using an empty/hidden label followed by a SameLine() call. (#7505, #282)\n                           - old: TreeNode(\"##Hidden\"); SameLine(); Text(\"Hello\");     // <-- This was actually incorrect! BUT appeared to look ok with the default style where ItemSpacing.x == FramePadding.x * 2 (it didn't look aligned otherwise).\n                           - new: TreeNode(\"##Hidden\"); SameLine(0, 0); Text(\"Hello\"); // <-- This is correct for all styles values.\n                         with the fix, IF you were successfully using TreeNode(\"\")+SameLine(); you will now have extra spacing between your TreeNode and the following item.\n                         You'll need to change the SameLine() call to SameLine(0,0) to remove this extraneous spacing. This seemed like the more sensible fix that's not making things less consistent.\n                         (Note: when using this idiom you are likely to also use ImGuiTreeNodeFlags_SpanAvailWidth).\n - 2024/03/18 (1.90.5) - merged the radius_x/radius_y parameters in ImDrawList::AddEllipse(), AddEllipseFilled() and PathEllipticalArcTo() into a single ImVec2 parameter. Exceptionally, because those functions were added in 1.90, we are not adding inline redirection functions. The transition is easy and should affect few users. (#2743, #7417)\n - 2024/03/08 (1.90.5) - inputs: more formally obsoleted GetKeyIndex() when IMGUI_DISABLE_OBSOLETE_FUNCTIONS is set. It has been unnecessary and a no-op since 1.87 (it returns the same value as passed when used with a 1.87+ backend using io.AddKeyEvent() function). (#4921)\n                           - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX)) -> use IsKeyPressed(ImGuiKey_XXX)\n - 2024/01/15 (1.90.2) - commented out obsolete ImGuiIO::ImeWindowHandle marked obsolete in 1.87, favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.\n - 2023/12/19 (1.90.1) - commented out obsolete ImGuiKey_KeyPadEnter redirection to ImGuiKey_KeypadEnter.\n - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86. Prefer using ImGuiListClipper which can return non-contiguous ranges.\n - 2023/11/05 (1.90.1) - imgui_freetype: commented out ImGuiFreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define IMGUI_ENABLE_FREETYPE or see commented code for manual calls.\n - 2023/11/05 (1.90.1) - internals,columns: commented out legacy ImGuiColumnsFlags_XXX symbols redirecting to ImGuiOldColumnsFlags_XXX, obsoleted from imgui_internal.h in 1.80.\n - 2023/11/09 (1.90.0) - removed IM_OFFSETOF() macro in favor of using offsetof() available in C++11. Kept redirection define (will obsolete).\n - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of using BeginChild() with the ImGuiChildFlags_FrameStyle flag. kept inline redirection function (will obsolete).\n                         those functions were merely PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to add the feature in BeginChild(), but by the necessity to avoid BeginChildFrame() signature mismatching BeginChild() signature and features.\n - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to 'ImGuiChildFlags flags' type, added ImGuiChildFlags_Border equivalent. As with our prior \"bool-to-flags\" API updates, the ImGuiChildFlags_Border value is guaranteed to be == true forever to ensure a smoother transition, meaning all existing calls will still work.\n                           - old: BeginChild(\"Name\", size, true)\n                           - new: BeginChild(\"Name\", size, ImGuiChildFlags_Border)\n                           - old: BeginChild(\"Name\", size, false)\n                           - new: BeginChild(\"Name\", size) or BeginChild(\"Name\", 0) or BeginChild(\"Name\", size, ImGuiChildFlags_None)\n                         **AMEND FROM THE FUTURE: from 1.91.1, 'ImGuiChildFlags_Border' is called 'ImGuiChildFlags_Borders'**\n - 2023/11/02 (1.90.0) - BeginChild: added child-flag ImGuiChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag ImGuiWindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for BeginChild() anyhow.\n                           - old: BeginChild(\"Name\", size, 0, ImGuiWindowFlags_AlwaysUseWindowPadding);\n                           - new: BeginChild(\"Name\", size, ImGuiChildFlags_AlwaysUseWindowPadding, 0);\n - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed in Metrics, unlikely to be accessed by end-user).\n - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() (\"Stack Tool\") to ShowIDStackToolWindow() (\"ID Stack Tool\"), as earlier name was misleading. Kept inline redirection function. (#4631)\n - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of \"name getter\" callback in old one-liner ListBox()/Combo() apis. kept inline redirection function (will obsolete).\n                           - old: bool Combo(const char* label, int* current_item, bool (*getter)(void* user_data, int idx, const char** out_text), ...)\n                           - new: bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);\n                           - old: bool ListBox(const char* label, int* current_item, bool (*getting)(void* user_data, int idx, const char** out_text), ...);\n                           - new: bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);\n - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:\n                           - GetWindowContentRegionWidth()  -> use GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that generally 'GetContentRegionAvail().x' is more useful.\n                           - ImDrawCornerFlags_XXX          -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep commented names in sources.\n                       - commented out runtime support for hardcoded ~0 or 0x01..0x0F rounding flags values for AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details\n - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept inline redirection function. Sorry!\n - 2023/07/12 (1.89.8) - ImDrawData: CmdLists now owned, changed from ImDrawList** to ImVector<ImDrawList*>. Majority of users shouldn't be affected, but you cannot compare to NULL nor reassign manually anymore. Instead use AddDrawList(). (#6406, #4879, #1878)\n - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()' (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably since 1.89 (2022-11-15).\n - 2023/06/28 (1.89.7) - overlapping items: renamed 'ImGuiTreeNodeFlags_AllowItemOverlap' to 'ImGuiTreeNodeFlags_AllowOverlap', 'ImGuiSelectableFlags_AllowItemOverlap' to 'ImGuiSelectableFlags_AllowOverlap'. Kept redirecting enums (will obsolete).\n - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default return false when querying an item using AllowOverlap mode which is being overlapped. Use ImGuiHoveredFlags_AllowWhenOverlappedByItem to revert to old behavior.\n - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow overlap when active so overlapping widgets won't appear as hovered. While this fixes a common small visual issue, it also means that calling IsItemHovered() after a non-reactive elements - e.g. Text() - overlapping an active one may fail if you don't use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem). (#6610)\n - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89 and expected to be left unchanged by most users, or only tweaked once during app initialization, we are exceptionally accepting the breakage.\n - 2023/05/30 (1.89.6) - backends: renamed \"imgui_impl_sdlrenderer.cpp\" to \"imgui_impl_sdlrenderer2.cpp\" and \"imgui_impl_sdlrenderer.h\" to \"imgui_impl_sdlrenderer2.h\". This is in prevision for the future release of SDL3.\n - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions that were marked obsolete more than two years ago:\n                           - ListBoxHeader()  -> use BeginListBox() (note how two variants of ListBoxHeader() existed. Check commented versions in imgui.h for reference)\n                           - ListBoxFooter()  -> use EndListBox()\n - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor 'ImGuiListClipper(int items_count, float items_height = -1.0f)' that was marked obsolete in 1.79. Use default constructor + clipper.Begin().\n - 2023/05/15 (1.89.6) - clipper: renamed ImGuiListClipper::ForceDisplayRangeByIndices() to ImGuiListClipper::IncludeRangeByIndices().\n - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that were marked obsolete two years ago:\n                           - ImGuiSliderFlags_ClampOnInput        -> use ImGuiSliderFlags_AlwaysClamp\n                           - ImGuiInputTextFlags_AlwaysInsertMode -> use ImGuiInputTextFlags_AlwaysOverwrite\n                           - ImDrawList::AddBezierCurve()         -> use ImDrawList::AddBezierCubic()\n                           - ImDrawList::PathBezierCurveTo()      -> use ImDrawList::PathBezierCubicCurveTo()\n - 2023/03/09 (1.89.4) - renamed PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop(). Kept inline redirection functions (will obsolete).\n - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip() for API consistency. Please only submit contents and call EndTooltip() if BeginTooltip() returns true. In reality the function will _currently_ always return true, but further changes down the line may change this, best to clarify API sooner.\n - 2023/02/15 (1.89.4) - moved the optional \"courtesy maths operators\" implementation from imgui_internal.h in imgui.h.\n                         Even though we encourage using your own maths types and operators by setting up IM_VEC2_CLASS_EXTRA,\n                         it has been frequently requested by people to use our own. We had an opt-in define which was\n                         previously fulfilled in imgui_internal.h. It is now fulfilled in imgui.h. (#6164)\n                           - OK:     #define IMGUI_DEFINE_MATH_OPERATORS / #include \"imgui.h\" / #include \"imgui_internal.h\"\n                           - Error:  #include \"imgui.h\" / #define IMGUI_DEFINE_MATH_OPERATORS / #include \"imgui_internal.h\"\n - 2023/02/07 (1.89.3) - backends: renamed \"imgui_impl_sdl.cpp\" to \"imgui_impl_sdl2.cpp\" and \"imgui_impl_sdl.h\" to \"imgui_impl_sdl2.h\". (#6146) This is in prevision for the future release of SDL3.\n - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.\n - 2022/10/12 (1.89)   - removed runtime patching of invalid \"%f\"/\"%0.f\" format strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018). See 1.61 changelog for details.\n - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and flags into a same set. Kept inline redirection enums (will obsolete).\n                           - ImGuiKey_ModCtrl  and ImGuiModFlags_Ctrl  -> ImGuiMod_Ctrl\n                           - ImGuiKey_ModShift and ImGuiModFlags_Shift -> ImGuiMod_Shift\n                           - ImGuiKey_ModAlt   and ImGuiModFlags_Alt   -> ImGuiMod_Alt\n                           - ImGuiKey_ModSuper and ImGuiModFlags_Super -> ImGuiMod_Super\n                         the ImGuiKey_ModXXX were introduced in 1.87 and mostly used by backends.\n                         the ImGuiModFlags_XXX have been exposed in imgui.h but not really used by any public api only by third-party extensions.\n                         exceptionally commenting out the older ImGuiKeyModFlags_XXX names ahead of obsolescence schedule to reduce confusion and because they were not meant to be used anyway.\n - 2022/09/20 (1.89)   - ImGuiKey is now a typed enum, allowing ImGuiKey_XXX symbols to be named in debuggers.\n                         this will require uses of legacy backend-dependent indices to be casted, e.g.\n                            - with imgui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) -> IsKeyPressed((ImGuiKey)GLFW_KEY_A);\n                            - with imgui_impl_win32: IsKeyPressed('A')        -> IsKeyPressed((ImGuiKey)'A')\n                            - etc. However if you are upgrading code you might well use the better, backend-agnostic IsKeyPressed(ImGuiKey_A) now!\n - 2022/09/12 (1.89) - removed the bizarre legacy default argument for 'TreePush(const void* ptr = NULL)', always pass a pointer value explicitly. NULL/nullptr is ok but require cast, e.g. TreePush((void*)nullptr);\n - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were marked obsolete in 1.77 and 1.78 (June 2020):\n                         - DragScalar(), DragScalarN(), DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.\n                         - SliderScalar(), SliderScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.\n                         - BeginPopupContextWindow(const char*, ImGuiMouseButton, bool) -> use BeginPopupContextWindow(const char*, ImGuiPopupFlags)\n - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to extend parent window/cell boundaries.\n                       this relates to when moving the cursor position beyond current boundaries WITHOUT submitting an item.\n                         - previously this would make the window content size ~200x200:\n                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();\n                         - instead, please submit an item:\n                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End();\n                         - alternative:\n                              Begin(...) + Dummy(ImVec2(200,200)) + End();\n                         - content size is now only extended when submitting an item!\n                         - with '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will now be detected and assert.\n                         - without '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will silently be fixed until we obsolete it.\n - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept redirection function (will obsolete).\n                        - added 'const char* str_id' parameter + removed 'int frame_padding = -1' parameter.\n                        - old signature: bool ImageButton(ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), int frame_padding = -1, ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));\n                          - used the ImTextureID value to create an ID. This was inconsistent with other functions, led to ID conflicts, and caused problems with engines using transient ImTextureID values.\n                          - had a FramePadding override which was inconsistent with other functions and made the already-long signature even longer.\n                        - new signature: bool ImageButton(const char* str_id, ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));\n                          - requires an explicit identifier. You may still use e.g. PushID() calls and then pass an empty identifier.\n                          - always uses style.FramePadding for padding, to be consistent with other buttons. You may use PushStyleVar() to alter this.\n - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and ImGuiNavInput enum (following 1.87 changes).\n                        - Official backends from 1.87+                  -> no issue.\n                        - Official backends from 1.60 to 1.86           -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need updating!\n                        - Custom backends not writing to io.NavInputs[] -> no issue.\n                        - Custom backends writing to io.NavInputs[]     -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need fixing!\n                        - TL;DR: Backends should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values instead of filling io.NavInput[].\n - 2022/06/15 (1.88) - renamed IMGUI_DISABLE_METRICS_WINDOW to IMGUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will obsolete).\n - 2022/05/03 (1.88) - backends: osx: removed ImGui_ImplOSX_HandleEvent() from backend API in favor of backend automatically handling event capture. All ImGui_ImplOSX_HandleEvent() calls should be removed as they are now unnecessary.\n - 2022/04/05 (1.88) - inputs: renamed ImGuiKeyModFlags to ImGuiModFlags. Kept inline redirection enums (will obsolete). This was never used in public API functions but technically present in imgui.h and ImGuiIO.\n - 2022/01/20 (1.87) - inputs: reworded gamepad IO.\n                        - Backend writing to io.NavInputs[]            -> backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values.\n - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a feature that used to be accessible by end-users (which seemingly no one used).\n - 2022/01/17 (1.87) - inputs: reworked mouse IO.\n                        - Backend writing to io.MousePos               -> backend should call io.AddMousePosEvent()\n                        - Backend writing to io.MouseDown[]            -> backend should call io.AddMouseButtonEvent()\n                        - Backend writing to io.MouseWheel             -> backend should call io.AddMouseWheelEvent()\n                        - Backend writing to io.MouseHoveredViewport   -> backend should call io.AddMouseViewportEvent() [Docking branch w/ multi-viewports only]\n                       note: for all calls to IO new functions, the Dear ImGui context should be bound/current.\n                       read https://github.com/ocornut/imgui/issues/4921 for details.\n - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[], io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now unnecessary. All IsKeyXXX() functions now take ImGuiKey values. All features are still functional until IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog and Release Notes for details.\n                        - IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use IsKeyPressed(ImGuiKey_XXX)\n                        - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX))      -> use IsKeyPressed(ImGuiKey_XXX)\n                        - Backend writing to io.KeyMap[],io.KeysDown[] -> backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you want legacy user code to stil function with legacy key codes).\n                        - Backend writing to io.KeyCtrl, io.KeyShift.. -> backend should call io.AddKeyEvent() with ImGuiMod_XXX values. *IF YOU PULLED CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent() function which was now replaced by io.AddKeyEvent() with ImGuiMod_XXX values.*\n                     - one case won't work with backward compatibility: if your custom backend used ImGuiKey as mock native indices (e.g. \"io.KeyMap[ImGuiKey_A] = ImGuiKey_A\") because those values are now larger than the legacy KeyDown[] array. Will assert.\n                     - inputs: added ImGuiKey_ModCtrl/ImGuiKey_ModShift/ImGuiKey_ModAlt/ImGuiKey_ModSuper values to submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.\n - 2022/01/05 (1.87) - inputs: renamed ImGuiKey_KeyPadEnter to ImGuiKey_KeypadEnter to align with new symbols. Kept redirection enum.\n - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more flexible io.SetPlatformImeDataFn(). Removed 'void* io.ImeWindowHandle' in favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.\n - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)\n                        - ImGui::SetNextTreeNodeOpen()        -> use ImGui::SetNextItemOpen()\n                        - ImGui::GetContentRegionAvailWidth() -> use ImGui::GetContentRegionAvail().x\n                        - ImGui::TreeAdvanceToLabelPos()      -> use ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetTreeNodeToLabelSpacing());\n                        - ImFontAtlas::CustomRect             -> use ImFontAtlasCustomRect\n                        - ImGuiColorEditFlags_RGB/HSV/HEX     -> use ImGuiColorEditFlags_DisplayRGB/HSV/Hex\n - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend (imgui_impl_marmalade.cpp) + example. Find last supported version at https://github.com/ocornut/imgui/wiki/Bindings\n - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using ImGuiListClipper which can return non-contiguous ranges. Please open an issue if you think you really need this function.\n - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep inline redirection helper. can use 'GetWindowContentRegionMax().x - GetWindowContentRegionMin().x' instead for generally 'GetContentRegionAvail().x' is more useful.\n - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were marked obsolete in 1.67 and 1.69 (March 2019):\n                        - ImGui::GetOverlayDrawList() -> use ImGui::GetForegroundDrawList()\n                        - ImFont::GlyphRangesBuilder  -> use ImFontGlyphRangesBuilder\n - 2021/05/19 (1.83) - backends: obsoleted direct access to ImDrawCmd::TextureId in favor of calling ImDrawCmd::GetTexID().\n                        - if you are using official backends from the source tree: you have nothing to do.\n                        - if you have copied old backend code or using your own: change access to draw_cmd->TextureId to draw_cmd->GetTexID().\n - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.\n                        - ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft\n                        - ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight\n                        - ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.\n                       flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.\n                       breaking: the default with rounding > 0.0f is now \"round all corners\" vs old implicit \"round no corners\":\n                        - rounding == 0.0f + flags == 0 --> meant no rounding  --> unchanged (common use)\n                        - rounding  > 0.0f + flags != 0 --> meant rounding     --> unchanged (common use)\n                        - rounding == 0.0f + flags != 0 --> meant no rounding  --> unchanged (unlikely use)\n                        - rounding  > 0.0f + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0f.\n                       this ONLY matters for hard coded use of 0 + rounding > 0.0f. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.\n                       the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify \"round all corners\" and we sometimes encouraged using them as shortcuts.\n                       legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).\n - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):\n                        - ImGui::SetScrollHere()              -> use ImGui::SetScrollHereY()\n - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0f. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.\n - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() \"bool closed\" parameter to \"ImDrawFlags flags\". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.\n - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.\n - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as the meaning of the value changed.\n - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).\n                     - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).\n                     - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).\n - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.\n                     - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.\n                     - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.\n - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):\n                        - ImGui::IsItemDeactivatedAfterChange() -> use ImGui::IsItemDeactivatedAfterEdit().\n                        - ImGuiCol_ModalWindowDarkening       -> use ImGuiCol_ModalWindowDimBg\n                        - ImGuiInputTextCallback              -> use ImGuiTextEditCallback\n                        - ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData\n - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).\n - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!\n - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.\n - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures\n - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.\n - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):\n                        - io.RenderDrawListsFn pointer        -> use ImGui::GetDrawData() value and call the render function of your backend\n                        - ImGui::IsAnyWindowFocused()         -> use ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)\n                        - ImGui::IsAnyWindowHovered()         -> use ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)\n                        - ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT\n                        - ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT\n                      - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):\n                        - InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = \"%.Xf\" where X is your value for decimal_precision.\n                        - same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.\n - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).\n - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).\n - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.\n - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.\n - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.\n - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!\n - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().\n                       replaced the 'float power=1.0f' argument with integer-based flags defaulting to 0 (as with all our flags).\n                       worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:\n                       - if you omitted the 'power' parameter (likely!), you are not affected.\n                       - if you set the 'power' parameter to 1.0f (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0f value with 0 to fix the warning, and be technically correct.\n                       - if you set the 'power' parameter to >1.0f (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0f.\n                       see https://github.com/ocornut/imgui/issues/3361 for all details.\n                       kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version was removed directly as they were most unlikely ever used.\n                       for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.\n                     - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.\n - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.\n - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]\n - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.\n - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().\n - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.\n - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.\n - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.\n - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):\n                       - ShowTestWindow()                    -> use ShowDemoWindow()\n                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)\n                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)\n                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2(w, 0.0f)\n                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()\n                       - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg\n                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding\n                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap\n                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS\n - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.\n - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).\n - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.\n - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.\n - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.\n - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):\n                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed\n                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)\n                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()\n                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)\n                       - ImFont::Glyph                       -> use ImFontGlyph\n - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse \"typematic\" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.\n                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.\n                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).\n                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.\n - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).\n - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).\n - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.\n - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have\n                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.\n                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.\n                       Please reach out if you are affected.\n - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).\n - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).\n - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.\n - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).\n - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).\n - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).\n - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!\n - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).\n - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!\n - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).\n - 2018/12/20 (1.67) - made it illegal to call Begin(\"\") with an empty string. This somehow half-worked before but had various undesirable side-effects.\n - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.\n - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.\n - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).\n - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.\n                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.\n - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)\n - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.\n                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.\n                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.\n - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).\n - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).\n - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).\n - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.\n - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.\n - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.\n - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).\n - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).\n                       old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.\n                       when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.\n                       in particular, note that old backends called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.\n - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.\n - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.\n - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from \"%.0f\" to \"%d\", as we are not using integers internally any more.\n                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.\n                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.\n                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. \"DragInt.*%f\" to help you find them.\n - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional \"int decimal_precision\" in favor of an equivalent and more flexible \"const char* format\",\n                       consistent with other functions. Kept redirection functions (will obsolete).\n - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.\n - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).\n - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.\n - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.\n - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.\n - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.\n - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.\n - 2018/02/07 (1.60) - reorganized context handling to be more explicit,\n                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.\n                       - removed Shutdown() function, as DestroyContext() serve this purpose.\n                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.\n                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.\n                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.\n - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.\n - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).\n - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).\n - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.\n - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.\n - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).\n - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags\n - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.\n - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.\n - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).\n - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).\n                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).\n - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).\n - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).\n - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.\n - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.\n                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.\n - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.\n - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.\n - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.\n - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);\n - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.\n - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.\n - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.\n                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.\n                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)\n                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)\n                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]\n - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!\n - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).\n - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).\n - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).\n - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace \"io.MousePos = ImVec2(-1,-1)\" with \"io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)\".\n - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!\n                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).\n                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).\n - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.\n - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an \"ambiguous call\" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.\n - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.\n - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.\n - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).\n - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).\n - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().\n - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.\n                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under \"Color/Picker Widgets\", to understand the various new options.\n                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0))'\n - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse\n - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.\n - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.\n - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().\n - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.\n - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.\n - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.\n - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.\n                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.\n                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:\n                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }\n                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.\n - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().\n - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.\n - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the \"default_open = true\" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).\n - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.\n - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref GitHub issue #337).\n - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)\n - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).\n - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.\n - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.\n - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.\n - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.\n - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.\n                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.\n                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!\n - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize\n - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.\n - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason\n - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.\n                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.\n - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.\n                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(\n                     - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.\n                     - the signature of the io.RenderDrawListsFn handler has changed!\n                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)\n                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).\n                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'\n                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.\n                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.\n                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.\n                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!\n                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!\n - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.\n - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).\n - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.\n - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence\n - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!\n - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).\n - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).\n - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.\n - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the \"open\" state of a popup. BeginPopup() returns true if the popup is opened.\n - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).\n - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.\n - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API\n - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.\n - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.\n - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.\n - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing\n - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.\n - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)\n - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.\n - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.\n - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.\n - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior\n - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()\n - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)\n - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.\n - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.\n - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.\n                       - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];\n                       - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->SetTexID(YourTexIdentifier);\n                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.\n - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts->SetTexID()\n - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)\n - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets\n - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)\n - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)\n - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility\n - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()\n - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)\n - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)\n - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()\n - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn\n - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)\n - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite\n - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes\n\n\n FREQUENTLY ASKED QUESTIONS (FAQ)\n ================================\n\n Read all answers online:\n   https://www.dearimgui.com/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)\n Read all answers locally (with a text editor or ideally a Markdown viewer):\n   docs/FAQ.md\n Some answers are copied down here to facilitate searching in code.\n\n Q&A: Basics\n ===========\n\n Q: Where is the documentation?\n A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.\n    - Run the examples/ applications and explore them.\n    - Read Getting Started (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.\n    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.\n    - The demo covers most features of Dear ImGui, so you can read the code and see its output.\n    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.\n    - 20+ standalone example applications using e.g. OpenGL/DirectX are provided in the\n      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.\n    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.\n    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.\n    - Your programming IDE is your friend, find the type or function declaration to find comments\n      associated with it.\n\n Q: What is this library called?\n Q: Which version should I get?\n >> This library is called \"Dear ImGui\", please don't call it \"ImGui\" :)\n >> See https://www.dearimgui.com/faq for details.\n\n Q&A: Integration\n ================\n\n Q: How to get started?\n A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.\n\n Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?\n A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!\n >> See https://www.dearimgui.com/faq for a fully detailed answer. You really want to read this.\n\n Q. How can I enable keyboard or gamepad controls?\n Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)\n Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...\n Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...\n Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...\n >> See https://www.dearimgui.com/faq\n\n Q&A: Usage\n ----------\n\n Q: About the ID Stack system..\n   - Why is my widget not reacting when I click on it?\n   - How can I have widgets with an empty label?\n   - How can I have multiple widgets with the same label?\n   - How can I have multiple windows with the same label?\n Q: How can I display an image? What is ImTextureID, how does it work?\n Q: How can I use my own math types instead of ImVec2?\n Q: How can I interact with standard C++ types (such as std::string and std::vector)?\n Q: How can I display custom shapes? (using low-level ImDrawList API)\n >> See https://www.dearimgui.com/faq\n\n Q&A: Fonts, Text\n ================\n\n Q: How should I handle DPI in my application?\n Q: How can I load a different font than the default?\n Q: How can I easily use icons in my application?\n Q: How can I load multiple fonts?\n Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?\n >> See https://www.dearimgui.com/faq and https://github.com/ocornut/imgui/blob/master/docs/FONTS.md\n\n Q&A: Concerns\n =============\n\n Q: Who uses Dear ImGui?\n Q: Can you create elaborate/serious tools with Dear ImGui?\n Q: Can you reskin the look of Dear ImGui?\n Q: Why using C++ (as opposed to C)?\n >> See https://www.dearimgui.com/faq\n\n Q&A: Community\n ==============\n\n Q: How can I help?\n A: - Businesses: please reach out to \"omar AT dearimgui DOT com\" if you work in a place using Dear ImGui!\n      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.\n      This is among the most useful thing you can do for Dear ImGui. With increased funding, we sustain and grow work on this project.\n      >>> See https://github.com/ocornut/imgui/wiki/Funding\n    - Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n    - If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, and see how you want to help and can help!\n    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.\n      You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.\n      But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.\n    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).\n\n*/\n\n//-------------------------------------------------------------------------\n// [SECTION] INCLUDES\n//-------------------------------------------------------------------------\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#include <stdint.h>     // intptr_t\n\n// [Windows] On non-Visual Studio compilers, we default to IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS unless explicitly enabled\n#if defined(_WIN32) && !defined(_MSC_VER) && !defined(IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)\n#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS\n#endif\n\n// [Windows] OS specific includes (optional)\n#if defined(_WIN32) && defined(IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS) && defined(IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)\n#define IMGUI_DISABLE_WIN32_FUNCTIONS\n#endif\n#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#ifndef __MINGW32__\n#include <Windows.h>        // _wfopen, OpenClipboard\n#else\n#include <windows.h>\n#endif\n#if defined(WINAPI_FAMILY) && ((defined(WINAPI_FAMILY_APP) && WINAPI_FAMILY == WINAPI_FAMILY_APP) || (defined(WINAPI_FAMILY_GAMES) && WINAPI_FAMILY == WINAPI_FAMILY_GAMES))\n// The UWP and GDK Win32 API subsets don't support clipboard nor IME functions\n#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS\n#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS\n#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS\n#endif\n#endif\n\n// [Apple] OS specific includes\n#if defined(__APPLE__)\n#include <TargetConditionals.h>\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)             // condition expression is constant\n#pragma warning (disable: 4996)             // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922   // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)             // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)            // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to an 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26495)            // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).\n#pragma warning (disable: 26812)            // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"          // warning: declaration requires an exit-time destructor     // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wformat-pedantic\"                // warning: format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.\n#pragma clang diagnostic ignored \"-Wint-to-void-pointer-cast\"       // warning: cast to 'void *' from smaller integer type 'int'\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#elif defined(__GNUC__)\n// We disable -Wpragmas because GCC doesn't provide a has_warning equivalent and some forks/patches may not follow the warning/version association.\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"                  // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wint-to-pointer-cast\"              // warning: cast to pointer from integer of different size\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wformat\"                           // warning: format '%p' expects argument of type 'int'/'void*', but argument X has type 'unsigned int'/'ImGuiWindow*'\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"                       // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"                  // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                        // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers\n#endif\n\n// Debug options\n#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Hold CTRL to display for all candidates. CTRL+Arrow to change last direction.\n#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window\n\n// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.\nstatic const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in\nstatic const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear\n\nstatic const float NAV_ACTIVATE_HIGHLIGHT_TIMER             = 0.10f;    // Time to highlight an item activated by a shortcut.\n\n// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)\nstatic const float WINDOWS_HOVER_PADDING                    = 4.0f;     // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().\nstatic const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.\nstatic const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER    = 0.70f;    // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.\n\n// Tooltip offset\nstatic const ImVec2 TOOLTIP_DEFAULT_OFFSET_MOUSE = ImVec2(16, 10);      // Multiplied by g.Style.MouseCursorScale\nstatic const ImVec2 TOOLTIP_DEFAULT_OFFSET_TOUCH = ImVec2(0, -20);      // Multiplied by g.Style.MouseCursorScale\nstatic const ImVec2 TOOLTIP_DEFAULT_PIVOT_TOUCH = ImVec2(0.5f, 1.0f);   // Multiplied by g.Style.MouseCursorScale\n\n//-------------------------------------------------------------------------\n// [SECTION] FORWARD DECLARATIONS\n//-------------------------------------------------------------------------\n\nstatic void             SetCurrentWindow(ImGuiWindow* window);\nstatic ImGuiWindow*     CreateNewWindow(const char* name, ImGuiWindowFlags flags);\nstatic ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window);\n\nstatic void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);\n\n// Settings\nstatic void             WindowSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*);\nstatic void*            WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);\nstatic void             WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);\nstatic void             WindowSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*);\nstatic void             WindowSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer* buf);\n\n// Platform Dependents default implementation for ImGuiPlatformIO functions\nstatic const char*      Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext* ctx);\nstatic void             Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text);\nstatic void             Platform_SetImeDataFn_DefaultImpl(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);\nstatic bool             Platform_OpenInShellFn_DefaultImpl(ImGuiContext* ctx, const char* path);\n\nnamespace ImGui\n{\n// Item\nstatic void             ItemHandleShortcut(ImGuiID id);\n\n// Window Focus\nstatic int              FindWindowFocusIndex(ImGuiWindow* window);\nstatic void             UpdateWindowInFocusOrderList(ImGuiWindow* window, bool just_created, ImGuiWindowFlags new_flags);\n\n// Navigation\nstatic void             NavUpdate();\nstatic void             NavUpdateWindowing();\nstatic void             NavUpdateWindowingOverlay();\nstatic void             NavUpdateCancelRequest();\nstatic void             NavUpdateCreateMoveRequest();\nstatic void             NavUpdateCreateTabbingRequest();\nstatic float            NavUpdatePageUpPageDown();\nstatic inline void      NavUpdateAnyRequestFlag();\nstatic void             NavUpdateCreateWrappingRequest();\nstatic void             NavEndFrame();\nstatic bool             NavScoreItem(ImGuiNavItemData* result);\nstatic void             NavApplyItemToResult(ImGuiNavItemData* result);\nstatic void             NavProcessItem();\nstatic void             NavProcessItemForTabbingRequest(ImGuiID id, ImGuiItemFlags item_flags, ImGuiNavMoveFlags move_flags);\nstatic ImGuiInputSource NavCalcPreferredRefPosSource();\nstatic ImVec2           NavCalcPreferredRefPos();\nstatic void             NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window);\nstatic ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);\nstatic void             NavRestoreLayer(ImGuiNavLayer layer);\n\n// Error Checking and Debug Tools\nstatic void             ErrorCheckNewFrameSanityChecks();\nstatic void             ErrorCheckEndFrameSanityChecks();\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\nstatic void             UpdateDebugToolItemPicker();\nstatic void             UpdateDebugToolStackQueries();\nstatic void             UpdateDebugToolFlashStyleColor();\n#endif\n\n// Inputs\nstatic void             UpdateKeyboardInputs();\nstatic void             UpdateMouseInputs();\nstatic void             UpdateMouseWheel();\nstatic void             UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt);\n\n// Misc\nstatic void             UpdateSettings();\nstatic int              UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_hovered, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect);\nstatic void             RenderWindowOuterBorders(ImGuiWindow* window);\nstatic void             RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size);\nstatic void             RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open);\nstatic void             RenderDimmedBackgroundBehindWindow(ImGuiWindow* window, ImU32 col);\nstatic void             RenderDimmedBackgrounds();\nstatic void             SetLastItemDataForWindow(ImGuiWindow* window, const ImRect& rect);\n\n// Viewports\nconst ImGuiID           IMGUI_VIEWPORT_DEFAULT_ID = 0x11111111; // Using an arbitrary constant instead of e.g. ImHashStr(\"ViewportDefault\", 0); so it's easier to spot in the debugger. The exact value doesn't matter.\nstatic void             UpdateViewportsNewFrame();\n\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n//-----------------------------------------------------------------------------\n\n// DLL users:\n// - Heaps and globals are not shared across DLL boundaries!\n// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.\n// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).\n// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.\n// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).\n\n// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.\n// - ImGui::CreateContext() will automatically set this pointer if it is NULL.\n//   Change to a different context by calling ImGui::SetCurrentContext().\n// - Important: Dear ImGui functions are not thread-safe because of this pointer.\n//   If you want thread-safety to allow N threads to access N different contexts:\n//   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:\n//         struct ImGuiContext;\n//         extern thread_local ImGuiContext* MyImGuiTLS;\n//         #define GImGui MyImGuiTLS\n//     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.\n//   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586\n//   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.\n// - DLL users: read comments above.\n#ifndef GImGui\nImGuiContext*   GImGui = NULL;\n#endif\n\n// Memory Allocator functions. Use SetAllocatorFunctions() to change them.\n// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.\n// - DLL users: read comments above.\n#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS\nstatic void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }\nstatic void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }\n#else\nstatic void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }\nstatic void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }\n#endif\nstatic ImGuiMemAllocFunc    GImAllocatorAllocFunc = MallocWrapper;\nstatic ImGuiMemFreeFunc     GImAllocatorFreeFunc = FreeWrapper;\nstatic void*                GImAllocatorUserData = NULL;\n\n//-----------------------------------------------------------------------------\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)\n//-----------------------------------------------------------------------------\n\nImGuiStyle::ImGuiStyle()\n{\n    Alpha                       = 1.0f;             // Global alpha applies to everything in Dear ImGui.\n    DisabledAlpha               = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.\n    WindowPadding               = ImVec2(8,8);      // Padding within a window\n    WindowRounding              = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.\n    WindowBorderSize            = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.\n    WindowMinSize               = ImVec2(32,32);    // Minimum window size\n    WindowTitleAlign            = ImVec2(0.0f,0.5f);// Alignment for title bar text\n    WindowMenuButtonPosition    = ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.\n    ChildRounding               = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows\n    ChildBorderSize             = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.\n    PopupRounding               = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows\n    PopupBorderSize             = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.\n    FramePadding                = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)\n    FrameRounding               = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).\n    FrameBorderSize             = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.\n    ItemSpacing                 = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines\n    ItemInnerSpacing            = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)\n    CellPadding                 = ImVec2(4,2);      // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.\n    TouchExtraPadding           = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\n    IndentSpacing               = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\n    ColumnsMinSpacing           = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).\n    ScrollbarSize               = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar\n    ScrollbarRounding           = 9.0f;             // Radius of grab corners rounding for scrollbar\n    GrabMinSize                 = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar\n    GrabRounding                = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\n    LogSliderDeadzone           = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.\n    TabRounding                 = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.\n    TabBorderSize               = 0.0f;             // Thickness of border around tabs.\n    TabMinWidthForCloseButton   = 0.0f;             // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.\n    TabBarBorderSize            = 1.0f;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.\n    TabBarOverlineSize          = 2.0f;             // Thickness of tab-bar overline, which highlights the selected tab-bar.\n    TableAngledHeadersAngle     = 35.0f * (IM_PI / 180.0f); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).\n    TableAngledHeadersTextAlign = ImVec2(0.5f,0.0f);// Alignment of angled headers within the cell\n    ColorButtonPosition         = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.\n    ButtonTextAlign             = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.\n    SelectableTextAlign         = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.\n    SeparatorTextBorderSize     = 3.0f;             // Thickness of border in SeparatorText()\n    SeparatorTextAlign          = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).\n    SeparatorTextPadding        = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.\n    DisplayWindowPadding        = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.\n    DisplaySafeAreaPadding      = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.\n    MouseCursorScale            = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.\n    AntiAliasedLines            = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.\n    AntiAliasedLinesUseTex      = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).\n    AntiAliasedFill             = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).\n    CurveTessellationTol        = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\n    CircleTessellationMaxError  = 0.30f;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.\n\n    // Behaviors\n    HoverStationaryDelay        = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.\n    HoverDelayShort             = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.\n    HoverDelayNormal            = 0.40f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). \"\n    HoverFlagsForTooltipMouse   = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled;    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.\n    HoverFlagsForTooltipNav     = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.\n\n    // Default theme\n    ImGui::StyleColorsDark(this);\n}\n\n// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.\n// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.\nvoid ImGuiStyle::ScaleAllSizes(float scale_factor)\n{\n    WindowPadding = ImTrunc(WindowPadding * scale_factor);\n    WindowRounding = ImTrunc(WindowRounding * scale_factor);\n    WindowMinSize = ImTrunc(WindowMinSize * scale_factor);\n    ChildRounding = ImTrunc(ChildRounding * scale_factor);\n    PopupRounding = ImTrunc(PopupRounding * scale_factor);\n    FramePadding = ImTrunc(FramePadding * scale_factor);\n    FrameRounding = ImTrunc(FrameRounding * scale_factor);\n    ItemSpacing = ImTrunc(ItemSpacing * scale_factor);\n    ItemInnerSpacing = ImTrunc(ItemInnerSpacing * scale_factor);\n    CellPadding = ImTrunc(CellPadding * scale_factor);\n    TouchExtraPadding = ImTrunc(TouchExtraPadding * scale_factor);\n    IndentSpacing = ImTrunc(IndentSpacing * scale_factor);\n    ColumnsMinSpacing = ImTrunc(ColumnsMinSpacing * scale_factor);\n    ScrollbarSize = ImTrunc(ScrollbarSize * scale_factor);\n    ScrollbarRounding = ImTrunc(ScrollbarRounding * scale_factor);\n    GrabMinSize = ImTrunc(GrabMinSize * scale_factor);\n    GrabRounding = ImTrunc(GrabRounding * scale_factor);\n    LogSliderDeadzone = ImTrunc(LogSliderDeadzone * scale_factor);\n    TabRounding = ImTrunc(TabRounding * scale_factor);\n    TabMinWidthForCloseButton = (TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(TabMinWidthForCloseButton * scale_factor) : FLT_MAX;\n    TabBarOverlineSize = ImTrunc(TabBarOverlineSize * scale_factor);\n    SeparatorTextPadding = ImTrunc(SeparatorTextPadding * scale_factor);\n    DisplayWindowPadding = ImTrunc(DisplayWindowPadding * scale_factor);\n    DisplaySafeAreaPadding = ImTrunc(DisplaySafeAreaPadding * scale_factor);\n    MouseCursorScale = ImTrunc(MouseCursorScale * scale_factor);\n}\n\nImGuiIO::ImGuiIO()\n{\n    // Most fields are initialized with zero\n    memset(this, 0, sizeof(*this));\n    IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);\n\n    // Settings\n    ConfigFlags = ImGuiConfigFlags_None;\n    BackendFlags = ImGuiBackendFlags_None;\n    DisplaySize = ImVec2(-1.0f, -1.0f);\n    DeltaTime = 1.0f / 60.0f;\n    IniSavingRate = 5.0f;\n    IniFilename = \"imgui.ini\"; // Important: \"imgui.ini\" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).\n    LogFilename = \"imgui_log.txt\";\n    UserData = NULL;\n\n    Fonts = NULL;\n    FontGlobalScale = 1.0f;\n    FontDefault = NULL;\n    FontAllowUserScaling = false;\n    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);\n\n    // Keyboard/Gamepad Navigation options\n    ConfigNavSwapGamepadButtons = false;\n    ConfigNavMoveSetMousePos = false;\n    ConfigNavCaptureKeyboard = true;\n    ConfigNavEscapeClearFocusItem = true;\n    ConfigNavEscapeClearFocusWindow = false;\n    ConfigNavCursorVisibleAuto = true;\n    ConfigNavCursorVisibleAlways = false;\n\n    // Miscellaneous options\n    MouseDrawCursor = false;\n#ifdef __APPLE__\n    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag\n#else\n    ConfigMacOSXBehaviors = false;\n#endif\n    ConfigInputTrickleEventQueue = true;\n    ConfigInputTextCursorBlink = true;\n    ConfigInputTextEnterKeepActive = false;\n    ConfigDragClickToInputText = false;\n    ConfigWindowsResizeFromEdges = true;\n    ConfigWindowsMoveFromTitleBarOnly = false;\n    ConfigWindowsCopyContentsWithCtrlC = false;\n    ConfigScrollbarScrollByPage = true;\n    ConfigMemoryCompactTimer = 60.0f;\n    ConfigDebugIsDebuggerPresent = false;\n    ConfigDebugHighlightIdConflicts = true;\n    ConfigDebugBeginReturnValueOnce = false;\n    ConfigDebugBeginReturnValueLoop = false;\n\n    ConfigErrorRecovery = true;\n    ConfigErrorRecoveryEnableAssert = true;\n    ConfigErrorRecoveryEnableDebugLog = true;\n    ConfigErrorRecoveryEnableTooltip = true;\n\n    // Inputs Behaviors\n    MouseDoubleClickTime = 0.30f;\n    MouseDoubleClickMaxDist = 6.0f;\n    MouseDragThreshold = 6.0f;\n    KeyRepeatDelay = 0.275f;\n    KeyRepeatRate = 0.050f;\n\n    // Platform Functions\n    // Note: Initialize() will setup default clipboard/ime handlers.\n    BackendPlatformName = BackendRendererName = NULL;\n    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;\n\n    // Input (NB: we already have memset zero the entire structure!)\n    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);\n    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);\n    MouseSource = ImGuiMouseSource_Mouse;\n    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;\n    for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }\n    AppAcceptingEvents = true;\n}\n\n// Pass in translated ASCII characters for text input.\n// - with glfw you can get those from the callback set in glfwSetCharCallback()\n// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message\n// FIXME: Should in theory be called \"AddCharacterEvent()\" to be consistent with new API\nvoid ImGuiIO::AddInputCharacter(unsigned int c)\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n    if (c == 0 || !AppAcceptingEvents)\n        return;\n\n    ImGuiInputEvent e;\n    e.Type = ImGuiInputEventType_Text;\n    e.Source = ImGuiInputSource_Keyboard;\n    e.EventId = g.InputEventsNextEventId++;\n    e.Text.Char = c;\n    g.InputEventsQueue.push_back(e);\n}\n\n// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so\n// we should save the high surrogate.\nvoid ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)\n{\n    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)\n        return;\n\n    if ((c & 0xFC00) == 0xD800) // High surrogate, must save\n    {\n        if (InputQueueSurrogate != 0)\n            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);\n        InputQueueSurrogate = c;\n        return;\n    }\n\n    ImWchar cp = c;\n    if (InputQueueSurrogate != 0)\n    {\n        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate\n        {\n            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);\n        }\n        else\n        {\n#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF\n            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar\n#else\n            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);\n#endif\n        }\n\n        InputQueueSurrogate = 0;\n    }\n    AddInputCharacter((unsigned)cp);\n}\n\nvoid ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)\n{\n    if (!AppAcceptingEvents)\n        return;\n    while (*utf8_chars != 0)\n    {\n        unsigned int c = 0;\n        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);\n        AddInputCharacter(c);\n    }\n}\n\n// Clear all incoming events.\nvoid ImGuiIO::ClearEventsQueue()\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n    g.InputEventsQueue.clear();\n}\n\n// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.\nvoid ImGuiIO::ClearInputKeys()\n{\n    ImGuiContext& g = *Ctx;\n    for (int key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key++)\n    {\n        if (ImGui::IsMouseKey((ImGuiKey)key))\n            continue;\n        ImGuiKeyData* key_data = &g.IO.KeysData[key - ImGuiKey_NamedKey_BEGIN];\n        key_data->Down = false;\n        key_data->DownDuration = -1.0f;\n        key_data->DownDurationPrev = -1.0f;\n    }\n    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;\n    KeyMods = ImGuiMod_None;\n    InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().\n}\n\nvoid ImGuiIO::ClearInputMouse()\n{\n    for (ImGuiKey key = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key = (ImGuiKey)(key + 1))\n    {\n        ImGuiKeyData* key_data = &KeysData[key - ImGuiKey_NamedKey_BEGIN];\n        key_data->Down = false;\n        key_data->DownDuration = -1.0f;\n        key_data->DownDurationPrev = -1.0f;\n    }\n    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);\n    for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)\n    {\n        MouseDown[n] = false;\n        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;\n    }\n    MouseWheel = MouseWheelH = 0.0f;\n}\n\n// Removed this as it is ambiguous/misleading and generally incorrect to use with the existence of a higher-level input queue.\n// Current frame character buffer is now also cleared by ClearInputKeys().\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\nvoid ImGuiIO::ClearInputCharacters()\n{\n    InputQueueCharacters.resize(0);\n}\n#endif\n\nstatic ImGuiInputEvent* FindLatestInputEvent(ImGuiContext* ctx, ImGuiInputEventType type, int arg = -1)\n{\n    ImGuiContext& g = *ctx;\n    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)\n    {\n        ImGuiInputEvent* e = &g.InputEventsQueue[n];\n        if (e->Type != type)\n            continue;\n        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)\n            continue;\n        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)\n            continue;\n        return e;\n    }\n    return NULL;\n}\n\n// Queue a new key down/up event.\n// - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)\n// - bool down:          Is the key down? use false to signify a key release.\n// - float analog_value: 0.0f..1.0f\n// IMPORTANT: THIS FUNCTION AND OTHER \"ADD\" GRABS THE CONTEXT FROM OUR INSTANCE.\n// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.\nvoid ImGuiIO::AddKeyAnalogEvent(ImGuiKey key, bool down, float analog_value)\n{\n    //if (e->Down) { IMGUI_DEBUG_LOG_IO(\"AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\\n\", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }\n    IM_ASSERT(Ctx != NULL);\n    if (key == ImGuiKey_None || !AppAcceptingEvents)\n        return;\n    ImGuiContext& g = *Ctx;\n    IM_ASSERT(ImGui::IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.\n    IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.\n\n    // MacOS: swap Cmd(Super) and Ctrl\n    if (g.IO.ConfigMacOSXBehaviors)\n    {\n        if (key == ImGuiMod_Super)          { key = ImGuiMod_Ctrl; }\n        else if (key == ImGuiMod_Ctrl)      { key = ImGuiMod_Super; }\n        else if (key == ImGuiKey_LeftSuper) { key = ImGuiKey_LeftCtrl; }\n        else if (key == ImGuiKey_RightSuper){ key = ImGuiKey_RightCtrl; }\n        else if (key == ImGuiKey_LeftCtrl)  { key = ImGuiKey_LeftSuper; }\n        else if (key == ImGuiKey_RightCtrl) { key = ImGuiKey_RightSuper; }\n    }\n\n    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)\n    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);\n    const ImGuiKeyData* key_data = ImGui::GetKeyData(&g, key);\n    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;\n    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;\n    if (latest_key_down == down && latest_key_analog == analog_value)\n        return;\n\n    // Add event\n    ImGuiInputEvent e;\n    e.Type = ImGuiInputEventType_Key;\n    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;\n    e.EventId = g.InputEventsNextEventId++;\n    e.Key.Key = key;\n    e.Key.Down = down;\n    e.Key.AnalogValue = analog_value;\n    g.InputEventsQueue.push_back(e);\n}\n\nvoid ImGuiIO::AddKeyEvent(ImGuiKey key, bool down)\n{\n    if (!AppAcceptingEvents)\n        return;\n    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);\n}\n\n// [Optional] Call after AddKeyEvent().\n// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.\n// If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.\nvoid ImGuiIO::SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index)\n{\n    if (key == ImGuiKey_None)\n        return;\n    IM_ASSERT(ImGui::IsNamedKey(key)); // >= 512\n    IM_ASSERT(native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)); // >= 0 && <= 511\n    IM_UNUSED(key);                 // Yet unused\n    IM_UNUSED(native_keycode);      // Yet unused\n    IM_UNUSED(native_scancode);     // Yet unused\n    IM_UNUSED(native_legacy_index); // Yet unused\n}\n\n// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.\nvoid ImGuiIO::SetAppAcceptingEvents(bool accepting_events)\n{\n    AppAcceptingEvents = accepting_events;\n}\n\n// Queue a mouse move event\nvoid ImGuiIO::AddMousePosEvent(float x, float y)\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n    if (!AppAcceptingEvents)\n        return;\n\n    // Apply same flooring as UpdateMouseInputs()\n    ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);\n\n    // Filter duplicate\n    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);\n    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;\n    if (latest_pos.x == pos.x && latest_pos.y == pos.y)\n        return;\n\n    ImGuiInputEvent e;\n    e.Type = ImGuiInputEventType_MousePos;\n    e.Source = ImGuiInputSource_Mouse;\n    e.EventId = g.InputEventsNextEventId++;\n    e.MousePos.PosX = pos.x;\n    e.MousePos.PosY = pos.y;\n    e.MousePos.MouseSource = g.InputEventsNextMouseSource;\n    g.InputEventsQueue.push_back(e);\n}\n\nvoid ImGuiIO::AddMouseButtonEvent(int mouse_button, bool down)\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n    IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);\n    if (!AppAcceptingEvents)\n        return;\n\n    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.\n    if (ConfigMacOSXBehaviors && mouse_button == 0 && MouseCtrlLeftAsRightClick)\n    {\n        // Order of both statements matterns: this event will still release mouse button 1\n        mouse_button = 1;\n        if (!down)\n            MouseCtrlLeftAsRightClick = false;\n    }\n\n    // Filter duplicate\n    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);\n    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];\n    if (latest_button_down == down)\n        return;\n\n    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click.\n    // - Note that this is actual physical Ctrl which is ImGuiMod_Super for us.\n    // - At this point we want from !down to down, so this is handling the initial press.\n    if (ConfigMacOSXBehaviors && mouse_button == 0 && down)\n    {\n        const ImGuiInputEvent* latest_super_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)ImGuiMod_Super);\n        if (latest_super_event ? latest_super_event->Key.Down : g.IO.KeySuper)\n        {\n            IMGUI_DEBUG_LOG_IO(\"[io] Super+Left Click aliased into Right Click\\n\");\n            MouseCtrlLeftAsRightClick = true;\n            AddMouseButtonEvent(1, true); // This is just quicker to write that passing through, as we need to filter duplicate again.\n            return;\n        }\n    }\n\n    ImGuiInputEvent e;\n    e.Type = ImGuiInputEventType_MouseButton;\n    e.Source = ImGuiInputSource_Mouse;\n    e.EventId = g.InputEventsNextEventId++;\n    e.MouseButton.Button = mouse_button;\n    e.MouseButton.Down = down;\n    e.MouseButton.MouseSource = g.InputEventsNextMouseSource;\n    g.InputEventsQueue.push_back(e);\n}\n\n// Queue a mouse wheel event (some mouse/API may only have a Y component)\nvoid ImGuiIO::AddMouseWheelEvent(float wheel_x, float wheel_y)\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n\n    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)\n    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))\n        return;\n\n    ImGuiInputEvent e;\n    e.Type = ImGuiInputEventType_MouseWheel;\n    e.Source = ImGuiInputSource_Mouse;\n    e.EventId = g.InputEventsNextEventId++;\n    e.MouseWheel.WheelX = wheel_x;\n    e.MouseWheel.WheelY = wheel_y;\n    e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;\n    g.InputEventsQueue.push_back(e);\n}\n\n// This is not a real event, the data is latched in order to be stored in actual Mouse events.\n// This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.\nvoid ImGuiIO::AddMouseSourceEvent(ImGuiMouseSource source)\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n    g.InputEventsNextMouseSource = source;\n}\n\nvoid ImGuiIO::AddFocusEvent(bool focused)\n{\n    IM_ASSERT(Ctx != NULL);\n    ImGuiContext& g = *Ctx;\n\n    // Filter duplicate\n    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);\n    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;\n    if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))\n        return;\n\n    ImGuiInputEvent e;\n    e.Type = ImGuiInputEventType_Focus;\n    e.EventId = g.InputEventsNextEventId++;\n    e.AppFocused.Focused = focused;\n    g.InputEventsQueue.push_back(e);\n}\n\nImGuiPlatformIO::ImGuiPlatformIO()\n{\n    // Most fields are initialized with zero\n    memset(this, 0, sizeof(*this));\n    Platform_LocaleDecimalPoint = '.';\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n//-----------------------------------------------------------------------------\n\nImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)\n{\n    IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()\n    ImVec2 p_last = p1;\n    ImVec2 p_closest;\n    float p_closest_dist2 = FLT_MAX;\n    float t_step = 1.0f / (float)num_segments;\n    for (int i_step = 1; i_step <= num_segments; i_step++)\n    {\n        ImVec2 p_current = ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step);\n        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);\n        float dist2 = ImLengthSqr(p - p_line);\n        if (dist2 < p_closest_dist2)\n        {\n            p_closest = p_line;\n            p_closest_dist2 = dist2;\n        }\n        p_last = p_current;\n    }\n    return p_closest;\n}\n\n// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp\nstatic void ImBezierCubicClosestPointCasteljauStep(const ImVec2& p, ImVec2& p_closest, ImVec2& p_last, float& p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)\n{\n    float dx = x4 - x1;\n    float dy = y4 - y1;\n    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);\n    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);\n    d2 = (d2 >= 0) ? d2 : -d2;\n    d3 = (d3 >= 0) ? d3 : -d3;\n    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))\n    {\n        ImVec2 p_current(x4, y4);\n        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);\n        float dist2 = ImLengthSqr(p - p_line);\n        if (dist2 < p_closest_dist2)\n        {\n            p_closest = p_line;\n            p_closest_dist2 = dist2;\n        }\n        p_last = p_current;\n    }\n    else if (level < 10)\n    {\n        float x12 = (x1 + x2)*0.5f,       y12 = (y1 + y2)*0.5f;\n        float x23 = (x2 + x3)*0.5f,       y23 = (y2 + y3)*0.5f;\n        float x34 = (x3 + x4)*0.5f,       y34 = (y3 + y4)*0.5f;\n        float x123 = (x12 + x23)*0.5f,    y123 = (y12 + y23)*0.5f;\n        float x234 = (x23 + x34)*0.5f,    y234 = (y23 + y34)*0.5f;\n        float x1234 = (x123 + x234)*0.5f, y1234 = (y123 + y234)*0.5f;\n        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);\n        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);\n    }\n}\n\n// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol\n// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.\nImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol)\n{\n    IM_ASSERT(tess_tol > 0.0f);\n    ImVec2 p_last = p1;\n    ImVec2 p_closest;\n    float p_closest_dist2 = FLT_MAX;\n    ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0);\n    return p_closest;\n}\n\nImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)\n{\n    ImVec2 ap = p - a;\n    ImVec2 ab_dir = b - a;\n    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;\n    if (dot < 0.0f)\n        return a;\n    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;\n    if (dot > ab_len_sqr)\n        return b;\n    return a + ab_dir * dot / ab_len_sqr;\n}\n\nbool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)\n{\n    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;\n    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;\n    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;\n    return ((b1 == b2) && (b2 == b3));\n}\n\nvoid ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)\n{\n    ImVec2 v0 = b - a;\n    ImVec2 v1 = c - a;\n    ImVec2 v2 = p - a;\n    const float denom = v0.x * v1.y - v1.x * v0.y;\n    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;\n    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;\n    out_u = 1.0f - out_v - out_w;\n}\n\nImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)\n{\n    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);\n    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);\n    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);\n    float dist2_ab = ImLengthSqr(p - proj_ab);\n    float dist2_bc = ImLengthSqr(p - proj_bc);\n    float dist2_ca = ImLengthSqr(p - proj_ca);\n    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));\n    if (m == dist2_ab)\n        return proj_ab;\n    if (m == dist2_bc)\n        return proj_bc;\n    return proj_ca;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n//-----------------------------------------------------------------------------\n\n// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.\nint ImStricmp(const char* str1, const char* str2)\n{\n    int d;\n    while ((d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) { str1++; str2++; }\n    return d;\n}\n\nint ImStrnicmp(const char* str1, const char* str2, size_t count)\n{\n    int d = 0;\n    while (count > 0 && (d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) { str1++; str2++; count--; }\n    return d;\n}\n\nvoid ImStrncpy(char* dst, const char* src, size_t count)\n{\n    if (count < 1)\n        return;\n    if (count > 1)\n        strncpy(dst, src, count - 1);\n    dst[count - 1] = 0;\n}\n\nchar* ImStrdup(const char* str)\n{\n    size_t len = strlen(str);\n    void* buf = IM_ALLOC(len + 1);\n    return (char*)memcpy(buf, (const void*)str, len + 1);\n}\n\nchar* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)\n{\n    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;\n    size_t src_size = strlen(src) + 1;\n    if (dst_buf_size < src_size)\n    {\n        IM_FREE(dst);\n        dst = (char*)IM_ALLOC(src_size);\n        if (p_dst_size)\n            *p_dst_size = src_size;\n    }\n    return (char*)memcpy(dst, (const void*)src, src_size);\n}\n\nconst char* ImStrchrRange(const char* str, const char* str_end, char c)\n{\n    const char* p = (const char*)memchr(str, (int)c, str_end - str);\n    return p;\n}\n\nint ImStrlenW(const ImWchar* str)\n{\n    //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit\n    int n = 0;\n    while (*str++) n++;\n    return n;\n}\n\n// Find end-of-line. Return pointer will point to either first \\n, either str_end.\nconst char* ImStreolRange(const char* str, const char* str_end)\n{\n    const char* p = (const char*)memchr(str, '\\n', str_end - str);\n    return p ? p : str_end;\n}\n\nconst char* ImStrbol(const char* buf_mid_line, const char* buf_begin) // find beginning-of-line\n{\n    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\\n')\n        buf_mid_line--;\n    return buf_mid_line;\n}\n\nconst char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)\n{\n    if (!needle_end)\n        needle_end = needle + strlen(needle);\n\n    const char un0 = (char)ImToUpper(*needle);\n    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))\n    {\n        if (ImToUpper(*haystack) == un0)\n        {\n            const char* b = needle + 1;\n            for (const char* a = haystack + 1; b < needle_end; a++, b++)\n                if (ImToUpper(*a) != ImToUpper(*b))\n                    break;\n            if (b == needle_end)\n                return haystack;\n        }\n        haystack++;\n    }\n    return NULL;\n}\n\n// Trim str by offsetting contents when there's leading data + writing a \\0 at the trailing position. We use this in situation where the cost is negligible.\nvoid ImStrTrimBlanks(char* buf)\n{\n    char* p = buf;\n    while (p[0] == ' ' || p[0] == '\\t')     // Leading blanks\n        p++;\n    char* p_start = p;\n    while (*p != 0)                         // Find end of string\n        p++;\n    while (p > p_start && (p[-1] == ' ' || p[-1] == '\\t'))  // Trailing blanks\n        p--;\n    if (p_start != buf)                     // Copy memory if we had leading blanks\n        memmove(buf, p_start, p - p_start);\n    buf[p - p_start] = 0;                   // Zero terminate\n}\n\nconst char* ImStrSkipBlank(const char* str)\n{\n    while (str[0] == ' ' || str[0] == '\\t')\n        str++;\n    return str;\n}\n\n// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).\n// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.\n// B) When buf==NULL vsnprintf() will return the output size.\n#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\n\n// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)\n// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\n// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are\n// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)\n#ifdef IMGUI_USE_STB_SPRINTF\n#ifndef IMGUI_DISABLE_STB_SPRINTF_IMPLEMENTATION\n#define STB_SPRINTF_IMPLEMENTATION\n#endif\n#ifdef IMGUI_STB_SPRINTF_FILENAME\n#include IMGUI_STB_SPRINTF_FILENAME\n#else\n#include \"stb_sprintf.h\"\n#endif\n#endif // #ifdef IMGUI_USE_STB_SPRINTF\n\n#if defined(_MSC_VER) && !defined(vsnprintf)\n#define vsnprintf _vsnprintf\n#endif\n\nint ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n#ifdef IMGUI_USE_STB_SPRINTF\n    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);\n#else\n    int w = vsnprintf(buf, buf_size, fmt, args);\n#endif\n    va_end(args);\n    if (buf == NULL)\n        return w;\n    if (w == -1 || w >= (int)buf_size)\n        w = (int)buf_size - 1;\n    buf[w] = 0;\n    return w;\n}\n\nint ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)\n{\n#ifdef IMGUI_USE_STB_SPRINTF\n    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);\n#else\n    int w = vsnprintf(buf, buf_size, fmt, args);\n#endif\n    if (buf == NULL)\n        return w;\n    if (w == -1 || w >= (int)buf_size)\n        w = (int)buf_size - 1;\n    buf[w] = 0;\n    return w;\n}\n#endif // #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\n\nvoid ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    ImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args);\n    va_end(args);\n}\n\n// FIXME: Should rework API toward allowing multiple in-flight temp buffers (easier and safer for caller)\n// by making the caller acquire a temp buffer token, with either explicit or destructor release, e.g.\n//  ImGuiTempBufferToken token;\n//  ImFormatStringToTempBuffer(token, ...);\nvoid ImFormatStringToTempBufferV(const char** out_buf, const char** out_buf_end, const char* fmt, va_list args)\n{\n    ImGuiContext& g = *GImGui;\n    if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0)\n    {\n        const char* buf = va_arg(args, const char*); // Skip formatting when using \"%s\"\n        if (buf == NULL)\n            buf = \"(null)\";\n        *out_buf = buf;\n        if (out_buf_end) { *out_buf_end = buf + strlen(buf); }\n    }\n    else if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' && fmt[4] == 0)\n    {\n        int buf_len = va_arg(args, int); // Skip formatting when using \"%.*s\"\n        const char* buf = va_arg(args, const char*);\n        if (buf == NULL)\n        {\n            buf = \"(null)\";\n            buf_len = ImMin(buf_len, 6);\n        }\n        *out_buf = buf;\n        *out_buf_end = buf + buf_len; // Disallow not passing 'out_buf_end' here. User is expected to use it.\n    }\n    else\n    {\n        int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);\n        *out_buf = g.TempBuffer.Data;\n        if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }\n    }\n}\n\n#ifndef IMGUI_ENABLE_SSE4_2_CRC\n// CRC32 needs a 1KB lookup table (not cache friendly)\n// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:\n// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.\nstatic const ImU32 GCrc32LookupTable[256] =\n{\n#ifdef IMGUI_USE_LEGACY_CRC32_ADLER\n    // Legacy CRC32-adler table used pre 1.91.6 (before 2024/11/27). Only use if you cannot afford invalidating old .ini data.\n    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,\n    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,\n    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,\n    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,\n    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,\n    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,\n    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,\n    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,\n    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,\n    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,\n    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,\n    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,\n    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,\n    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,\n    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,\n    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,\n#else\n    // CRC32c table compatible with SSE 4.2 instructions\n    0x00000000,0xF26B8303,0xE13B70F7,0x1350F3F4,0xC79A971F,0x35F1141C,0x26A1E7E8,0xD4CA64EB,0x8AD958CF,0x78B2DBCC,0x6BE22838,0x9989AB3B,0x4D43CFD0,0xBF284CD3,0xAC78BF27,0x5E133C24,\n    0x105EC76F,0xE235446C,0xF165B798,0x030E349B,0xD7C45070,0x25AFD373,0x36FF2087,0xC494A384,0x9A879FA0,0x68EC1CA3,0x7BBCEF57,0x89D76C54,0x5D1D08BF,0xAF768BBC,0xBC267848,0x4E4DFB4B,\n    0x20BD8EDE,0xD2D60DDD,0xC186FE29,0x33ED7D2A,0xE72719C1,0x154C9AC2,0x061C6936,0xF477EA35,0xAA64D611,0x580F5512,0x4B5FA6E6,0xB93425E5,0x6DFE410E,0x9F95C20D,0x8CC531F9,0x7EAEB2FA,\n    0x30E349B1,0xC288CAB2,0xD1D83946,0x23B3BA45,0xF779DEAE,0x05125DAD,0x1642AE59,0xE4292D5A,0xBA3A117E,0x4851927D,0x5B016189,0xA96AE28A,0x7DA08661,0x8FCB0562,0x9C9BF696,0x6EF07595,\n    0x417B1DBC,0xB3109EBF,0xA0406D4B,0x522BEE48,0x86E18AA3,0x748A09A0,0x67DAFA54,0x95B17957,0xCBA24573,0x39C9C670,0x2A993584,0xD8F2B687,0x0C38D26C,0xFE53516F,0xED03A29B,0x1F682198,\n    0x5125DAD3,0xA34E59D0,0xB01EAA24,0x42752927,0x96BF4DCC,0x64D4CECF,0x77843D3B,0x85EFBE38,0xDBFC821C,0x2997011F,0x3AC7F2EB,0xC8AC71E8,0x1C661503,0xEE0D9600,0xFD5D65F4,0x0F36E6F7,\n    0x61C69362,0x93AD1061,0x80FDE395,0x72966096,0xA65C047D,0x5437877E,0x4767748A,0xB50CF789,0xEB1FCBAD,0x197448AE,0x0A24BB5A,0xF84F3859,0x2C855CB2,0xDEEEDFB1,0xCDBE2C45,0x3FD5AF46,\n    0x7198540D,0x83F3D70E,0x90A324FA,0x62C8A7F9,0xB602C312,0x44694011,0x5739B3E5,0xA55230E6,0xFB410CC2,0x092A8FC1,0x1A7A7C35,0xE811FF36,0x3CDB9BDD,0xCEB018DE,0xDDE0EB2A,0x2F8B6829,\n    0x82F63B78,0x709DB87B,0x63CD4B8F,0x91A6C88C,0x456CAC67,0xB7072F64,0xA457DC90,0x563C5F93,0x082F63B7,0xFA44E0B4,0xE9141340,0x1B7F9043,0xCFB5F4A8,0x3DDE77AB,0x2E8E845F,0xDCE5075C,\n    0x92A8FC17,0x60C37F14,0x73938CE0,0x81F80FE3,0x55326B08,0xA759E80B,0xB4091BFF,0x466298FC,0x1871A4D8,0xEA1A27DB,0xF94AD42F,0x0B21572C,0xDFEB33C7,0x2D80B0C4,0x3ED04330,0xCCBBC033,\n    0xA24BB5A6,0x502036A5,0x4370C551,0xB11B4652,0x65D122B9,0x97BAA1BA,0x84EA524E,0x7681D14D,0x2892ED69,0xDAF96E6A,0xC9A99D9E,0x3BC21E9D,0xEF087A76,0x1D63F975,0x0E330A81,0xFC588982,\n    0xB21572C9,0x407EF1CA,0x532E023E,0xA145813D,0x758FE5D6,0x87E466D5,0x94B49521,0x66DF1622,0x38CC2A06,0xCAA7A905,0xD9F75AF1,0x2B9CD9F2,0xFF56BD19,0x0D3D3E1A,0x1E6DCDEE,0xEC064EED,\n    0xC38D26C4,0x31E6A5C7,0x22B65633,0xD0DDD530,0x0417B1DB,0xF67C32D8,0xE52CC12C,0x1747422F,0x49547E0B,0xBB3FFD08,0xA86F0EFC,0x5A048DFF,0x8ECEE914,0x7CA56A17,0x6FF599E3,0x9D9E1AE0,\n    0xD3D3E1AB,0x21B862A8,0x32E8915C,0xC083125F,0x144976B4,0xE622F5B7,0xF5720643,0x07198540,0x590AB964,0xAB613A67,0xB831C993,0x4A5A4A90,0x9E902E7B,0x6CFBAD78,0x7FAB5E8C,0x8DC0DD8F,\n    0xE330A81A,0x115B2B19,0x020BD8ED,0xF0605BEE,0x24AA3F05,0xD6C1BC06,0xC5914FF2,0x37FACCF1,0x69E9F0D5,0x9B8273D6,0x88D28022,0x7AB90321,0xAE7367CA,0x5C18E4C9,0x4F48173D,0xBD23943E,\n    0xF36E6F75,0x0105EC76,0x12551F82,0xE03E9C81,0x34F4F86A,0xC69F7B69,0xD5CF889D,0x27A40B9E,0x79B737BA,0x8BDCB4B9,0x988C474D,0x6AE7C44E,0xBE2DA0A5,0x4C4623A6,0x5F16D052,0xAD7D5351\n#endif\n};\n#endif\n\n// Known size hash\n// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.\n// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.\nImGuiID ImHashData(const void* data_p, size_t data_size, ImGuiID seed)\n{\n    ImU32 crc = ~seed;\n    const unsigned char* data = (const unsigned char*)data_p;\n    const unsigned char *data_end = (const unsigned char*)data_p + data_size;\n#ifndef IMGUI_ENABLE_SSE4_2_CRC\n    const ImU32* crc32_lut = GCrc32LookupTable;\n    while (data < data_end)\n        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];\n    return ~crc;\n#else\n    while (data + 4 <= data_end)\n    {\n        crc = _mm_crc32_u32(crc, *(ImU32*)data);\n        data += 4;\n    }\n    while (data < data_end)\n        crc = _mm_crc32_u8(crc, *data++);\n    return ~crc;\n#endif\n}\n\n// Zero-terminated string hash, with support for ### to reset back to seed value\n// We support a syntax of \"label###id\" where only \"###id\" is included in the hash, and only \"label\" gets displayed.\n// Because this syntax is rarely used we are optimizing for the common case.\n// - If we reach ### in the string we discard the hash so far and reset to the seed.\n// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)\n// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.\nImGuiID ImHashStr(const char* data_p, size_t data_size, ImGuiID seed)\n{\n    seed = ~seed;\n    ImU32 crc = seed;\n    const unsigned char* data = (const unsigned char*)data_p;\n#ifndef IMGUI_ENABLE_SSE4_2_CRC\n    const ImU32* crc32_lut = GCrc32LookupTable;\n#endif\n    if (data_size != 0)\n    {\n        while (data_size-- != 0)\n        {\n            unsigned char c = *data++;\n            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')\n                crc = seed;\n#ifndef IMGUI_ENABLE_SSE4_2_CRC\n            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];\n#else\n            crc = _mm_crc32_u8(crc, c);\n#endif\n        }\n    }\n    else\n    {\n        while (unsigned char c = *data++)\n        {\n            if (c == '#' && data[0] == '#' && data[1] == '#')\n                crc = seed;\n#ifndef IMGUI_ENABLE_SSE4_2_CRC\n            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];\n#else\n            crc = _mm_crc32_u8(crc, c);\n#endif\n        }\n    }\n    return ~crc;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n//-----------------------------------------------------------------------------\n\n// Default file functions\n#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS\n\nImFileHandle ImFileOpen(const char* filename, const char* mode)\n{\n#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && (defined(__MINGW32__) || (!defined(__CYGWIN__) && !defined(__GNUC__)))\n    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.\n    // Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!\n    const int filename_wsize = ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);\n    const int mode_wsize = ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, NULL, 0);\n\n    // Use stack buffer if possible, otherwise heap buffer. Sizes include zero terminator.\n    // We don't rely on current ImGuiContext as this is implied to be a helper function which doesn't depend on it (see #7314).\n    wchar_t local_temp_stack[FILENAME_MAX];\n    ImVector<wchar_t> local_temp_heap;\n    if (filename_wsize + mode_wsize > IM_ARRAYSIZE(local_temp_stack))\n        local_temp_heap.resize(filename_wsize + mode_wsize);\n    wchar_t* filename_wbuf = local_temp_heap.Data ? local_temp_heap.Data : local_temp_stack;\n    wchar_t* mode_wbuf = filename_wbuf + filename_wsize;\n    ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_wbuf, filename_wsize);\n    ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, mode_wbuf, mode_wsize);\n    return ::_wfopen(filename_wbuf, mode_wbuf);\n#else\n    return fopen(filename, mode);\n#endif\n}\n\n// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.\nbool    ImFileClose(ImFileHandle f)     { return fclose(f) == 0; }\nImU64   ImFileGetSize(ImFileHandle f)   { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1; }\nImU64   ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f)           { return fread(data, (size_t)sz, (size_t)count, f); }\nImU64   ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f)    { return fwrite(data, (size_t)sz, (size_t)count, f); }\n#endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS\n\n// Helper: Load file content into memory\n// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()\n// This can't really be used with \"rt\" because fseek size won't match read size.\nvoid*   ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)\n{\n    IM_ASSERT(filename && mode);\n    if (out_file_size)\n        *out_file_size = 0;\n\n    ImFileHandle f;\n    if ((f = ImFileOpen(filename, mode)) == NULL)\n        return NULL;\n\n    size_t file_size = (size_t)ImFileGetSize(f);\n    if (file_size == (size_t)-1)\n    {\n        ImFileClose(f);\n        return NULL;\n    }\n\n    void* file_data = IM_ALLOC(file_size + padding_bytes);\n    if (file_data == NULL)\n    {\n        ImFileClose(f);\n        return NULL;\n    }\n    if (ImFileRead(file_data, 1, file_size, f) != file_size)\n    {\n        ImFileClose(f);\n        IM_FREE(file_data);\n        return NULL;\n    }\n    if (padding_bytes > 0)\n        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);\n\n    ImFileClose(f);\n    if (out_file_size)\n        *out_file_size = file_size;\n\n    return file_data;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n//-----------------------------------------------------------------------------\n\nIM_MSVC_RUNTIME_CHECKS_OFF\n\n// Convert UTF-8 to 32-bit character, process single character input.\n// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).\n// We handle UTF-8 decoding error by skipping forward.\nint ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)\n{\n    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };\n    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };\n    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };\n    static const int shiftc[] = { 0, 18, 12, 6, 0 };\n    static const int shifte[] = { 0, 6, 4, 2, 0 };\n    int len = lengths[*(const unsigned char*)in_text >> 3];\n    int wanted = len + (len ? 0 : 1);\n\n    if (in_text_end == NULL)\n        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.\n\n    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,\n    // so it is fast even with excessive branching.\n    unsigned char s[4];\n    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;\n    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;\n    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;\n    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;\n\n    // Assume a four-byte character and load four bytes. Unused bits are shifted out.\n    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;\n    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;\n    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;\n    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;\n    *out_char >>= shiftc[len];\n\n    // Accumulate the various error conditions.\n    int e = 0;\n    e  = (*out_char < mins[len]) << 6; // non-canonical encoding\n    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?\n    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?\n    e |= (s[1] & 0xc0) >> 2;\n    e |= (s[2] & 0xc0) >> 4;\n    e |= (s[3]       ) >> 6;\n    e ^= 0x2a; // top two bits of each tail byte correct?\n    e >>= shifte[len];\n\n    if (e)\n    {\n        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.\n        // One byte is consumed in case of invalid first byte of in_text.\n        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.\n        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.\n        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);\n        *out_char = IM_UNICODE_CODEPOINT_INVALID;\n    }\n\n    return wanted;\n}\n\nint ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)\n{\n    ImWchar* buf_out = buf;\n    ImWchar* buf_end = buf + buf_size;\n    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)\n    {\n        unsigned int c;\n        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);\n        *buf_out++ = (ImWchar)c;\n    }\n    *buf_out = 0;\n    if (in_text_remaining)\n        *in_text_remaining = in_text;\n    return (int)(buf_out - buf);\n}\n\nint ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)\n{\n    int char_count = 0;\n    while ((!in_text_end || in_text < in_text_end) && *in_text)\n    {\n        unsigned int c;\n        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);\n        char_count++;\n    }\n    return char_count;\n}\n\n// Based on stb_to_utf8() from github.com/nothings/stb/\nstatic inline int ImTextCharToUtf8_inline(char* buf, int buf_size, unsigned int c)\n{\n    if (c < 0x80)\n    {\n        buf[0] = (char)c;\n        return 1;\n    }\n    if (c < 0x800)\n    {\n        if (buf_size < 2) return 0;\n        buf[0] = (char)(0xc0 + (c >> 6));\n        buf[1] = (char)(0x80 + (c & 0x3f));\n        return 2;\n    }\n    if (c < 0x10000)\n    {\n        if (buf_size < 3) return 0;\n        buf[0] = (char)(0xe0 + (c >> 12));\n        buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));\n        buf[2] = (char)(0x80 + ((c ) & 0x3f));\n        return 3;\n    }\n    if (c <= 0x10FFFF)\n    {\n        if (buf_size < 4) return 0;\n        buf[0] = (char)(0xf0 + (c >> 18));\n        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));\n        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));\n        buf[3] = (char)(0x80 + ((c ) & 0x3f));\n        return 4;\n    }\n    // Invalid code point, the max unicode is 0x10FFFF\n    return 0;\n}\n\nconst char* ImTextCharToUtf8(char out_buf[5], unsigned int c)\n{\n    int count = ImTextCharToUtf8_inline(out_buf, 5, c);\n    out_buf[count] = 0;\n    return out_buf;\n}\n\n// Not optimal but we very rarely use this function.\nint ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)\n{\n    unsigned int unused = 0;\n    return ImTextCharFromUtf8(&unused, in_text, in_text_end);\n}\n\nstatic inline int ImTextCountUtf8BytesFromChar(unsigned int c)\n{\n    if (c < 0x80) return 1;\n    if (c < 0x800) return 2;\n    if (c < 0x10000) return 3;\n    if (c <= 0x10FFFF) return 4;\n    return 3;\n}\n\nint ImTextStrToUtf8(char* out_buf, int out_buf_size, const ImWchar* in_text, const ImWchar* in_text_end)\n{\n    char* buf_p = out_buf;\n    const char* buf_end = out_buf + out_buf_size;\n    while (buf_p < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)\n    {\n        unsigned int c = (unsigned int)(*in_text++);\n        if (c < 0x80)\n            *buf_p++ = (char)c;\n        else\n            buf_p += ImTextCharToUtf8_inline(buf_p, (int)(buf_end - buf_p - 1), c);\n    }\n    *buf_p = 0;\n    return (int)(buf_p - out_buf);\n}\n\nint ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)\n{\n    int bytes_count = 0;\n    while ((!in_text_end || in_text < in_text_end) && *in_text)\n    {\n        unsigned int c = (unsigned int)(*in_text++);\n        if (c < 0x80)\n            bytes_count++;\n        else\n            bytes_count += ImTextCountUtf8BytesFromChar(c);\n    }\n    return bytes_count;\n}\n\nconst char* ImTextFindPreviousUtf8Codepoint(const char* in_text_start, const char* in_text_curr)\n{\n    while (in_text_curr > in_text_start)\n    {\n        in_text_curr--;\n        if ((*in_text_curr & 0xC0) != 0x80)\n            return in_text_curr;\n    }\n    return in_text_start;\n}\n\nint ImTextCountLines(const char* in_text, const char* in_text_end)\n{\n    if (in_text_end == NULL)\n        in_text_end = in_text + strlen(in_text); // FIXME-OPT: Not optimal approach, discourage use for now.\n    int count = 0;\n    while (in_text < in_text_end)\n    {\n        const char* line_end = (const char*)memchr(in_text, '\\n', in_text_end - in_text);\n        in_text = line_end ? line_end + 1 : in_text_end;\n        count++;\n    }\n    return count;\n}\n\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n//-----------------------------------------------------------------------------\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// Note: The Convert functions are early design which are not consistent with other API.\n//-----------------------------------------------------------------------------\n\nIMGUI_API ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b)\n{\n    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;\n    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);\n    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);\n    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);\n    return IM_COL32(r, g, b, 0xFF);\n}\n\nImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)\n{\n    float s = 1.0f / 255.0f;\n    return ImVec4(\n        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,\n        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,\n        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,\n        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);\n}\n\nImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)\n{\n    ImU32 out;\n    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;\n    return out;\n}\n\n// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592\n// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\nvoid ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)\n{\n    float K = 0.f;\n    if (g < b)\n    {\n        ImSwap(g, b);\n        K = -1.f;\n    }\n    if (r < g)\n    {\n        ImSwap(r, g);\n        K = -2.f / 6.f - K;\n    }\n\n    const float chroma = r - (g < b ? g : b);\n    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));\n    out_s = chroma / (r + 1e-20f);\n    out_v = r;\n}\n\n// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593\n// also http://en.wikipedia.org/wiki/HSL_and_HSV\nvoid ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)\n{\n    if (s == 0.0f)\n    {\n        // gray\n        out_r = out_g = out_b = v;\n        return;\n    }\n\n    h = ImFmod(h, 1.0f) / (60.0f / 360.0f);\n    int   i = (int)h;\n    float f = h - (float)i;\n    float p = v * (1.0f - s);\n    float q = v * (1.0f - s * f);\n    float t = v * (1.0f - s * (1.0f - f));\n\n    switch (i)\n    {\n    case 0: out_r = v; out_g = t; out_b = p; break;\n    case 1: out_r = q; out_g = v; out_b = p; break;\n    case 2: out_r = p; out_g = v; out_b = t; break;\n    case 3: out_r = p; out_g = q; out_b = v; break;\n    case 4: out_r = t; out_g = p; out_b = v; break;\n    case 5: default: out_r = v; out_g = p; out_b = q; break;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiStorage\n// Helper: Key->value storage\n//-----------------------------------------------------------------------------\n\n// std::lower_bound but without the bullshit\nImGuiStoragePair* ImLowerBound(ImGuiStoragePair* in_begin, ImGuiStoragePair* in_end, ImGuiID key)\n{\n    ImGuiStoragePair* in_p = in_begin;\n    for (size_t count = (size_t)(in_end - in_p); count > 0; )\n    {\n        size_t count2 = count >> 1;\n        ImGuiStoragePair* mid = in_p + count2;\n        if (mid->key < key)\n        {\n            in_p = ++mid;\n            count -= count2 + 1;\n        }\n        else\n        {\n            count = count2;\n        }\n    }\n    return in_p;\n}\n\nIM_MSVC_RUNTIME_CHECKS_OFF\nstatic int IMGUI_CDECL PairComparerByID(const void* lhs, const void* rhs)\n{\n    // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.\n    ImGuiID lhs_v = ((const ImGuiStoragePair*)lhs)->key;\n    ImGuiID rhs_v = ((const ImGuiStoragePair*)rhs)->key;\n    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);\n}\n\n// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\nvoid ImGuiStorage::BuildSortByKey()\n{\n    ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), PairComparerByID);\n}\n\nint ImGuiStorage::GetInt(ImGuiID key, int default_val) const\n{\n    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        return default_val;\n    return it->val_i;\n}\n\nbool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const\n{\n    return GetInt(key, default_val ? 1 : 0) != 0;\n}\n\nfloat ImGuiStorage::GetFloat(ImGuiID key, float default_val) const\n{\n    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        return default_val;\n    return it->val_f;\n}\n\nvoid* ImGuiStorage::GetVoidPtr(ImGuiID key) const\n{\n    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        return NULL;\n    return it->val_p;\n}\n\n// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\nint* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)\n{\n    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        it = Data.insert(it, ImGuiStoragePair(key, default_val));\n    return &it->val_i;\n}\n\nbool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)\n{\n    return (bool*)GetIntRef(key, default_val ? 1 : 0);\n}\n\nfloat* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)\n{\n    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        it = Data.insert(it, ImGuiStoragePair(key, default_val));\n    return &it->val_f;\n}\n\nvoid** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)\n{\n    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        it = Data.insert(it, ImGuiStoragePair(key, default_val));\n    return &it->val_p;\n}\n\n// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)\nvoid ImGuiStorage::SetInt(ImGuiID key, int val)\n{\n    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        Data.insert(it, ImGuiStoragePair(key, val));\n    else\n        it->val_i = val;\n}\n\nvoid ImGuiStorage::SetBool(ImGuiID key, bool val)\n{\n    SetInt(key, val ? 1 : 0);\n}\n\nvoid ImGuiStorage::SetFloat(ImGuiID key, float val)\n{\n    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        Data.insert(it, ImGuiStoragePair(key, val));\n    else\n        it->val_f = val;\n}\n\nvoid ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)\n{\n    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);\n    if (it == Data.Data + Data.Size || it->key != key)\n        Data.insert(it, ImGuiStoragePair(key, val));\n    else\n        it->val_p = val;\n}\n\nvoid ImGuiStorage::SetAllInt(int v)\n{\n    for (int i = 0; i < Data.Size; i++)\n        Data[i].val_i = v;\n}\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiTextFilter\n//-----------------------------------------------------------------------------\n\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\nImGuiTextFilter::ImGuiTextFilter(const char* default_filter) //-V1077\n{\n    InputBuf[0] = 0;\n    CountGrep = 0;\n    if (default_filter)\n    {\n        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));\n        Build();\n    }\n}\n\nbool ImGuiTextFilter::Draw(const char* label, float width)\n{\n    if (width != 0.0f)\n        ImGui::SetNextItemWidth(width);\n    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));\n    if (value_changed)\n        Build();\n    return value_changed;\n}\n\nvoid ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange>* out) const\n{\n    out->resize(0);\n    const char* wb = b;\n    const char* we = wb;\n    while (we < e)\n    {\n        if (*we == separator)\n        {\n            out->push_back(ImGuiTextRange(wb, we));\n            wb = we + 1;\n        }\n        we++;\n    }\n    if (wb != we)\n        out->push_back(ImGuiTextRange(wb, we));\n}\n\nvoid ImGuiTextFilter::Build()\n{\n    Filters.resize(0);\n    ImGuiTextRange input_range(InputBuf, InputBuf + strlen(InputBuf));\n    input_range.split(',', &Filters);\n\n    CountGrep = 0;\n    for (ImGuiTextRange& f : Filters)\n    {\n        while (f.b < f.e && ImCharIsBlankA(f.b[0]))\n            f.b++;\n        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))\n            f.e--;\n        if (f.empty())\n            continue;\n        if (f.b[0] != '-')\n            CountGrep += 1;\n    }\n}\n\nbool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const\n{\n    if (Filters.Size == 0)\n        return true;\n\n    if (text == NULL)\n        text = text_end = \"\";\n\n    for (const ImGuiTextRange& f : Filters)\n    {\n        if (f.b == f.e)\n            continue;\n        if (f.b[0] == '-')\n        {\n            // Subtract\n            if (ImStristr(text, text_end, f.b + 1, f.e) != NULL)\n                return false;\n        }\n        else\n        {\n            // Grep\n            if (ImStristr(text, text_end, f.b, f.e) != NULL)\n                return true;\n        }\n    }\n\n    // Implicit * grep\n    if (CountGrep == 0)\n        return true;\n\n    return false;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n//-----------------------------------------------------------------------------\n\n// On some platform vsnprintf() takes va_list by reference and modifies it.\n// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.\n#ifndef va_copy\n#if defined(__GNUC__) || defined(__clang__)\n#define va_copy(dest, src) __builtin_va_copy(dest, src)\n#else\n#define va_copy(dest, src) (dest = src)\n#endif\n#endif\n\nchar ImGuiTextBuffer::EmptyString[1] = { 0 };\n\nvoid ImGuiTextBuffer::append(const char* str, const char* str_end)\n{\n    int len = str_end ? (int)(str_end - str) : (int)strlen(str);\n\n    // Add zero-terminator the first time\n    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;\n    const int needed_sz = write_off + len;\n    if (write_off + len >= Buf.Capacity)\n    {\n        int new_capacity = Buf.Capacity * 2;\n        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);\n    }\n\n    Buf.resize(needed_sz);\n    memcpy(&Buf[write_off - 1], str, (size_t)len);\n    Buf[write_off - 1 + len] = 0;\n}\n\nvoid ImGuiTextBuffer::appendf(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    appendfv(fmt, args);\n    va_end(args);\n}\n\n// Helper: Text buffer for logging/accumulating text\nvoid ImGuiTextBuffer::appendfv(const char* fmt, va_list args)\n{\n    va_list args_copy;\n    va_copy(args_copy, args);\n\n    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.\n    if (len <= 0)\n    {\n        va_end(args_copy);\n        return;\n    }\n\n    // Add zero-terminator the first time\n    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;\n    const int needed_sz = write_off + len;\n    if (write_off + len >= Buf.Capacity)\n    {\n        int new_capacity = Buf.Capacity * 2;\n        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);\n    }\n\n    Buf.resize(needed_sz);\n    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);\n    va_end(args_copy);\n}\n\nvoid ImGuiTextIndex::append(const char* base, int old_size, int new_size)\n{\n    IM_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= EndOffset);\n    if (old_size == new_size)\n        return;\n    if (EndOffset == 0 || base[EndOffset - 1] == '\\n')\n        LineOffsets.push_back(EndOffset);\n    const char* base_end = base + new_size;\n    for (const char* p = base + old_size; (p = (const char*)memchr(p, '\\n', base_end - p)) != 0; )\n        if (++p < base_end) // Don't push a trailing offset on last \\n\n            LineOffsets.push_back((int)(intptr_t)(p - base));\n    EndOffset = ImMax(EndOffset, new_size);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiListClipper\n//-----------------------------------------------------------------------------\n\n// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.\n// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.\nstatic bool GetSkipItemForListClipping()\n{\n    ImGuiContext& g = *GImGui;\n    return (g.CurrentTable ? g.CurrentTable->HostSkipItems : g.CurrentWindow->SkipItems);\n}\n\nstatic void ImGuiListClipper_SortAndFuseRanges(ImVector<ImGuiListClipperRange>& ranges, int offset = 0)\n{\n    if (ranges.Size - offset <= 1)\n        return;\n\n    // Helper to order ranges and fuse them together if possible (bubble sort is fine as we are only sorting 2-3 entries)\n    for (int sort_end = ranges.Size - offset - 1; sort_end > 0; --sort_end)\n        for (int i = offset; i < sort_end + offset; ++i)\n            if (ranges[i].Min > ranges[i + 1].Min)\n                ImSwap(ranges[i], ranges[i + 1]);\n\n    // Now fuse ranges together as much as possible.\n    for (int i = 1 + offset; i < ranges.Size; i++)\n    {\n        IM_ASSERT(!ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert);\n        if (ranges[i - 1].Max < ranges[i].Min)\n            continue;\n        ranges[i - 1].Min = ImMin(ranges[i - 1].Min, ranges[i].Min);\n        ranges[i - 1].Max = ImMax(ranges[i - 1].Max, ranges[i].Max);\n        ranges.erase(ranges.Data + i);\n        i--;\n    }\n}\n\nstatic void ImGuiListClipper_SeekCursorAndSetupPrevLine(float pos_y, float line_height)\n{\n    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.\n    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.\n    // The clipper should probably have a final step to display the last item in a regular manner, maybe with an opt-out flag for data sets which may have costly seek?\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    float off_y = pos_y - window->DC.CursorPos.y;\n    window->DC.CursorPos.y = pos_y;\n    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y);\n    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;  // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.\n    window->DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y);      // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.\n    if (ImGuiOldColumns* columns = window->DC.CurrentColumns)\n        columns->LineMinY = window->DC.CursorPos.y;                         // Setting this so that cell Y position are set properly\n    if (ImGuiTable* table = g.CurrentTable)\n    {\n        if (table->IsInsideRow)\n            ImGui::TableEndRow(table);\n        table->RowPosY2 = window->DC.CursorPos.y;\n        const int row_increase = (int)((off_y / line_height) + 0.5f);\n        //table->CurrentRow += row_increase; // Can't do without fixing TableEndRow()\n        table->RowBgColorCounter += row_increase;\n    }\n}\n\nImGuiListClipper::ImGuiListClipper()\n{\n    memset(this, 0, sizeof(*this));\n}\n\nImGuiListClipper::~ImGuiListClipper()\n{\n    End();\n}\n\nvoid ImGuiListClipper::Begin(int items_count, float items_height)\n{\n    if (Ctx == NULL)\n        Ctx = ImGui::GetCurrentContext();\n\n    ImGuiContext& g = *Ctx;\n    ImGuiWindow* window = g.CurrentWindow;\n    IMGUI_DEBUG_LOG_CLIPPER(\"Clipper: Begin(%d,%.2f) in '%s'\\n\", items_count, items_height, window->Name);\n\n    if (ImGuiTable* table = g.CurrentTable)\n        if (table->IsInsideRow)\n            ImGui::TableEndRow(table);\n\n    StartPosY = window->DC.CursorPos.y;\n    ItemsHeight = items_height;\n    ItemsCount = items_count;\n    DisplayStart = -1;\n    DisplayEnd = 0;\n\n    // Acquire temporary buffer\n    if (++g.ClipperTempDataStacked > g.ClipperTempData.Size)\n        g.ClipperTempData.resize(g.ClipperTempDataStacked, ImGuiListClipperData());\n    ImGuiListClipperData* data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];\n    data->Reset(this);\n    data->LossynessOffset = window->DC.CursorStartPosLossyness.y;\n    TempData = data;\n    StartSeekOffsetY = data->LossynessOffset;\n}\n\nvoid ImGuiListClipper::End()\n{\n    if (ImGuiListClipperData* data = (ImGuiListClipperData*)TempData)\n    {\n        // In theory here we should assert that we are already at the right position, but it seems saner to just seek at the end and not assert/crash the user.\n        ImGuiContext& g = *Ctx;\n        IMGUI_DEBUG_LOG_CLIPPER(\"Clipper: End() in '%s'\\n\", g.CurrentWindow->Name);\n        if (ItemsCount >= 0 && ItemsCount < INT_MAX && DisplayStart >= 0)\n            SeekCursorForItem(ItemsCount);\n\n        // Restore temporary buffer and fix back pointers which may be invalidated when nesting\n        IM_ASSERT(data->ListClipper == this);\n        data->StepNo = data->Ranges.Size;\n        if (--g.ClipperTempDataStacked > 0)\n        {\n            data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];\n            data->ListClipper->TempData = data;\n        }\n        TempData = NULL;\n    }\n    ItemsCount = -1;\n}\n\nvoid ImGuiListClipper::IncludeItemsByIndex(int item_begin, int item_end)\n{\n    ImGuiListClipperData* data = (ImGuiListClipperData*)TempData;\n    IM_ASSERT(DisplayStart < 0); // Only allowed after Begin() and if there has not been a specified range yet.\n    IM_ASSERT(item_begin <= item_end);\n    if (item_begin < item_end)\n        data->Ranges.push_back(ImGuiListClipperRange::FromIndices(item_begin, item_end));\n}\n\n// This is already called while stepping.\n// The ONLY reason you may want to call this is if you passed INT_MAX to ImGuiListClipper::Begin() because you couldn't step item count beforehand.\nvoid ImGuiListClipper::SeekCursorForItem(int item_n)\n{\n    // - Perform the add and multiply with double to allow seeking through larger ranges.\n    // - StartPosY starts from ItemsFrozen, by adding SeekOffsetY we generally cancel that out (SeekOffsetY == LossynessOffset - ItemsFrozen * ItemsHeight).\n    // - The reason we store SeekOffsetY instead of inferring it, is because we want to allow user to perform Seek after the last step, where ImGuiListClipperData is already done.\n    float pos_y = (float)((double)StartPosY + StartSeekOffsetY + (double)item_n * ItemsHeight);\n    ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, ItemsHeight);\n}\n\nstatic bool ImGuiListClipper_StepInternal(ImGuiListClipper* clipper)\n{\n    ImGuiContext& g = *clipper->Ctx;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiListClipperData* data = (ImGuiListClipperData*)clipper->TempData;\n    IM_ASSERT(data != NULL && \"Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?\");\n\n    ImGuiTable* table = g.CurrentTable;\n    if (table && table->IsInsideRow)\n        ImGui::TableEndRow(table);\n\n    // No items\n    if (clipper->ItemsCount == 0 || GetSkipItemForListClipping())\n        return false;\n\n    // While we are in frozen row state, keep displaying items one by one, unclipped\n    // FIXME: Could be stored as a table-agnostic state.\n    if (data->StepNo == 0 && table != NULL && !table->IsUnfrozenRows)\n    {\n        clipper->DisplayStart = data->ItemsFrozen;\n        clipper->DisplayEnd = ImMin(data->ItemsFrozen + 1, clipper->ItemsCount);\n        if (clipper->DisplayStart < clipper->DisplayEnd)\n            data->ItemsFrozen++;\n        return true;\n    }\n\n    // Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)\n    bool calc_clipping = false;\n    if (data->StepNo == 0)\n    {\n        clipper->StartPosY = window->DC.CursorPos.y;\n        if (clipper->ItemsHeight <= 0.0f)\n        {\n            // Submit the first item (or range) so we can measure its height (generally the first range is 0..1)\n            data->Ranges.push_front(ImGuiListClipperRange::FromIndices(data->ItemsFrozen, data->ItemsFrozen + 1));\n            clipper->DisplayStart = ImMax(data->Ranges[0].Min, data->ItemsFrozen);\n            clipper->DisplayEnd = ImMin(data->Ranges[0].Max, clipper->ItemsCount);\n            data->StepNo = 1;\n            return true;\n        }\n        calc_clipping = true;   // If on the first step with known item height, calculate clipping.\n    }\n\n    // Step 1: Let the clipper infer height from first range\n    if (clipper->ItemsHeight <= 0.0f)\n    {\n        IM_ASSERT(data->StepNo == 1);\n        if (table)\n            IM_ASSERT(table->RowPosY1 == clipper->StartPosY && table->RowPosY2 == window->DC.CursorPos.y);\n\n        clipper->ItemsHeight = (window->DC.CursorPos.y - clipper->StartPosY) / (float)(clipper->DisplayEnd - clipper->DisplayStart);\n        bool affected_by_floating_point_precision = ImIsFloatAboveGuaranteedIntegerPrecision(clipper->StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window->DC.CursorPos.y);\n        if (affected_by_floating_point_precision)\n            clipper->ItemsHeight = window->DC.PrevLineSize.y + g.Style.ItemSpacing.y; // FIXME: Technically wouldn't allow multi-line entries.\n        if (clipper->ItemsHeight == 0.0f && clipper->ItemsCount == INT_MAX) // Accept that no item have been submitted if in indeterminate mode.\n            return false;\n        IM_ASSERT(clipper->ItemsHeight > 0.0f && \"Unable to calculate item height! First item hasn't moved the cursor vertically!\");\n        calc_clipping = true;   // If item height had to be calculated, calculate clipping afterwards.\n    }\n\n    // Step 0 or 1: Calculate the actual ranges of visible elements.\n    const int already_submitted = clipper->DisplayEnd;\n    if (calc_clipping)\n    {\n        // Record seek offset, this is so ImGuiListClipper::Seek() can be called after ImGuiListClipperData is done\n        clipper->StartSeekOffsetY = (double)data->LossynessOffset - data->ItemsFrozen * (double)clipper->ItemsHeight;\n\n        if (g.LogEnabled)\n        {\n            // If logging is active, do not perform any clipping\n            data->Ranges.push_back(ImGuiListClipperRange::FromIndices(0, clipper->ItemsCount));\n        }\n        else\n        {\n            // Add range selected to be included for navigation\n            const bool is_nav_request = (g.NavMoveScoringItems && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);\n            if (is_nav_request)\n                data->Ranges.push_back(ImGuiListClipperRange::FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0));\n            if (is_nav_request && (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && g.NavTabbingDir == -1)\n                data->Ranges.push_back(ImGuiListClipperRange::FromIndices(clipper->ItemsCount - 1, clipper->ItemsCount));\n\n            // Add focused/active item\n            ImRect nav_rect_abs = ImGui::WindowRectRelToAbs(window, window->NavRectRel[0]);\n            if (g.NavId != 0 && window->NavLastIds[0] == g.NavId)\n                data->Ranges.push_back(ImGuiListClipperRange::FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0));\n\n            // Add visible range\n            float min_y = window->ClipRect.Min.y;\n            float max_y = window->ClipRect.Max.y;\n\n            // Add box selection range\n            ImGuiBoxSelectState* bs = &g.BoxSelectState;\n            if (bs->IsActive && bs->Window == window)\n            {\n                // FIXME: Selectable() use of half-ItemSpacing isn't consistent in matter of layout, as ItemAdd(bb) stray above ItemSize()'s CursorPos.\n                // RangeSelect's BoxSelect relies on comparing overlap of previous and current rectangle and is sensitive to that.\n                // As a workaround we currently half ItemSpacing worth on each side.\n                min_y -= g.Style.ItemSpacing.y;\n                max_y += g.Style.ItemSpacing.y;\n\n                // Box-select on 2D area requires different clipping.\n                if (bs->UnclipMode)\n                    data->Ranges.push_back(ImGuiListClipperRange::FromPositions(bs->UnclipRect.Min.y, bs->UnclipRect.Max.y, 0, 0));\n            }\n\n            const int off_min = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Up) ? -1 : 0;\n            const int off_max = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Down) ? 1 : 0;\n            data->Ranges.push_back(ImGuiListClipperRange::FromPositions(min_y, max_y, off_min, off_max));\n        }\n\n        // Convert position ranges to item index ranges\n        // - Very important: when a starting position is after our maximum item, we set Min to (ItemsCount - 1). This allows us to handle most forms of wrapping.\n        // - Due to how Selectable extra padding they tend to be \"unaligned\" with exact unit in the item list,\n        //   which with the flooring/ceiling tend to lead to 2 items instead of one being submitted.\n        for (ImGuiListClipperRange& range : data->Ranges)\n            if (range.PosToIndexConvert)\n            {\n                int m1 = (int)(((double)range.Min - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight);\n                int m2 = (int)((((double)range.Max - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight) + 0.999999f);\n                range.Min = ImClamp(already_submitted + m1 + range.PosToIndexOffsetMin, already_submitted, clipper->ItemsCount - 1);\n                range.Max = ImClamp(already_submitted + m2 + range.PosToIndexOffsetMax, range.Min + 1, clipper->ItemsCount);\n                range.PosToIndexConvert = false;\n            }\n        ImGuiListClipper_SortAndFuseRanges(data->Ranges, data->StepNo);\n    }\n\n    // Step 0+ (if item height is given in advance) or 1+: Display the next range in line.\n    while (data->StepNo < data->Ranges.Size)\n    {\n        clipper->DisplayStart = ImMax(data->Ranges[data->StepNo].Min, already_submitted);\n        clipper->DisplayEnd = ImMin(data->Ranges[data->StepNo].Max, clipper->ItemsCount);\n        if (clipper->DisplayStart > already_submitted) //-V1051\n            clipper->SeekCursorForItem(clipper->DisplayStart);\n        data->StepNo++;\n        if (clipper->DisplayStart == clipper->DisplayEnd && data->StepNo < data->Ranges.Size)\n            continue;\n        return true;\n    }\n\n    // After the last step: Let the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),\n    // Advance the cursor to the end of the list and then returns 'false' to end the loop.\n    if (clipper->ItemsCount < INT_MAX)\n        clipper->SeekCursorForItem(clipper->ItemsCount);\n\n    return false;\n}\n\nbool ImGuiListClipper::Step()\n{\n    ImGuiContext& g = *Ctx;\n    bool need_items_height = (ItemsHeight <= 0.0f);\n    bool ret = ImGuiListClipper_StepInternal(this);\n    if (ret && (DisplayStart == DisplayEnd))\n        ret = false;\n    if (g.CurrentTable && g.CurrentTable->IsUnfrozenRows == false)\n        IMGUI_DEBUG_LOG_CLIPPER(\"Clipper: Step(): inside frozen table row.\\n\");\n    if (need_items_height && ItemsHeight > 0.0f)\n        IMGUI_DEBUG_LOG_CLIPPER(\"Clipper: Step(): computed ItemsHeight: %.2f.\\n\", ItemsHeight);\n    if (ret)\n    {\n        IMGUI_DEBUG_LOG_CLIPPER(\"Clipper: Step(): display %d to %d.\\n\", DisplayStart, DisplayEnd);\n    }\n    else\n    {\n        IMGUI_DEBUG_LOG_CLIPPER(\"Clipper: Step(): End.\\n\");\n        End();\n    }\n    return ret;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] STYLING\n//-----------------------------------------------------------------------------\n\nImGuiStyle& ImGui::GetStyle()\n{\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?\");\n    return GImGui->Style;\n}\n\nImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)\n{\n    ImGuiStyle& style = GImGui->Style;\n    ImVec4 c = style.Colors[idx];\n    c.w *= style.Alpha * alpha_mul;\n    return ColorConvertFloat4ToU32(c);\n}\n\nImU32 ImGui::GetColorU32(const ImVec4& col)\n{\n    ImGuiStyle& style = GImGui->Style;\n    ImVec4 c = col;\n    c.w *= style.Alpha;\n    return ColorConvertFloat4ToU32(c);\n}\n\nconst ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)\n{\n    ImGuiStyle& style = GImGui->Style;\n    return style.Colors[idx];\n}\n\nImU32 ImGui::GetColorU32(ImU32 col, float alpha_mul)\n{\n    ImGuiStyle& style = GImGui->Style;\n    alpha_mul *= style.Alpha;\n    if (alpha_mul >= 1.0f)\n        return col;\n    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;\n    a = (ImU32)(a * alpha_mul); // We don't need to clamp 0..255 because alpha is in 0..1 range.\n    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);\n}\n\n// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32\nvoid ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiColorMod backup;\n    backup.Col = idx;\n    backup.BackupValue = g.Style.Colors[idx];\n    g.ColorStack.push_back(backup);\n    if (g.DebugFlashStyleColorIdx != idx)\n        g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);\n}\n\nvoid ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiColorMod backup;\n    backup.Col = idx;\n    backup.BackupValue = g.Style.Colors[idx];\n    g.ColorStack.push_back(backup);\n    if (g.DebugFlashStyleColorIdx != idx)\n        g.Style.Colors[idx] = col;\n}\n\nvoid ImGui::PopStyleColor(int count)\n{\n    ImGuiContext& g = *GImGui;\n    if (g.ColorStack.Size < count)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopStyleColor() too many times!\");\n        count = g.ColorStack.Size;\n    }\n    while (count > 0)\n    {\n        ImGuiColorMod& backup = g.ColorStack.back();\n        g.Style.Colors[backup.Col] = backup.BackupValue;\n        g.ColorStack.pop_back();\n        count--;\n    }\n}\n\nstatic const ImGuiDataVarInfo GStyleVarInfo[] =\n{\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, Alpha) },                     // ImGuiStyleVar_Alpha\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, DisabledAlpha) },             // ImGuiStyleVar_DisabledAlpha\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowPadding) },             // ImGuiStyleVar_WindowPadding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, WindowRounding) },            // ImGuiStyleVar_WindowRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, WindowBorderSize) },          // ImGuiStyleVar_WindowBorderSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowMinSize) },             // ImGuiStyleVar_WindowMinSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowTitleAlign) },          // ImGuiStyleVar_WindowTitleAlign\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ChildRounding) },             // ImGuiStyleVar_ChildRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ChildBorderSize) },           // ImGuiStyleVar_ChildBorderSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, PopupRounding) },             // ImGuiStyleVar_PopupRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, PopupBorderSize) },           // ImGuiStyleVar_PopupBorderSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, FramePadding) },              // ImGuiStyleVar_FramePadding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, FrameRounding) },             // ImGuiStyleVar_FrameRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, FrameBorderSize) },           // ImGuiStyleVar_FrameBorderSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ItemSpacing) },               // ImGuiStyleVar_ItemSpacing\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ItemInnerSpacing) },          // ImGuiStyleVar_ItemInnerSpacing\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, IndentSpacing) },             // ImGuiStyleVar_IndentSpacing\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, CellPadding) },               // ImGuiStyleVar_CellPadding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ScrollbarSize) },             // ImGuiStyleVar_ScrollbarSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ScrollbarRounding) },         // ImGuiStyleVar_ScrollbarRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, GrabMinSize) },               // ImGuiStyleVar_GrabMinSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, GrabRounding) },              // ImGuiStyleVar_GrabRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabRounding) },               // ImGuiStyleVar_TabRounding\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBorderSize) },             // ImGuiStyleVar_TabBorderSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBarBorderSize) },          // ImGuiStyleVar_TabBarBorderSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBarOverlineSize) },        // ImGuiStyleVar_TabBarOverlineSize\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TableAngledHeadersAngle)},    // ImGuiStyleVar_TableAngledHeadersAngle\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, TableAngledHeadersTextAlign)},// ImGuiStyleVar_TableAngledHeadersTextAlign\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ButtonTextAlign) },           // ImGuiStyleVar_ButtonTextAlign\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SelectableTextAlign) },       // ImGuiStyleVar_SelectableTextAlign\n    { ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, SeparatorTextBorderSize)},    // ImGuiStyleVar_SeparatorTextBorderSize\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextAlign) },        // ImGuiStyleVar_SeparatorTextAlign\n    { ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextPadding) },      // ImGuiStyleVar_SeparatorTextPadding\n};\n\nconst ImGuiDataVarInfo* ImGui::GetStyleVarInfo(ImGuiStyleVar idx)\n{\n    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);\n    IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);\n    return &GStyleVarInfo[idx];\n}\n\nvoid ImGui::PushStyleVar(ImGuiStyleVar idx, float val)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);\n    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 1)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PushStyleVar() variant with wrong type!\");\n        return;\n    }\n    float* pvar = (float*)var_info->GetVarPtr(&g.Style);\n    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));\n    *pvar = val;\n}\n\nvoid ImGui::PushStyleVarX(ImGuiStyleVar idx, float val_x)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);\n    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PushStyleVar() variant with wrong type!\");\n        return;\n    }\n    ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);\n    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));\n    pvar->x = val_x;\n}\n\nvoid ImGui::PushStyleVarY(ImGuiStyleVar idx, float val_y)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);\n    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PushStyleVar() variant with wrong type!\");\n        return;\n    }\n    ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);\n    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));\n    pvar->y = val_y;\n}\n\nvoid ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);\n    if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PushStyleVar() variant with wrong type!\");\n        return;\n    }\n    ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);\n    g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));\n    *pvar = val;\n}\n\nvoid ImGui::PopStyleVar(int count)\n{\n    ImGuiContext& g = *GImGui;\n    if (g.StyleVarStack.Size < count)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopStyleVar() too many times!\");\n        count = g.StyleVarStack.Size;\n    }\n    while (count > 0)\n    {\n        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.\n        ImGuiStyleMod& backup = g.StyleVarStack.back();\n        const ImGuiDataVarInfo* info = GetStyleVarInfo(backup.VarIdx);\n        void* data = info->GetVarPtr(&g.Style);\n        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }\n        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }\n        g.StyleVarStack.pop_back();\n        count--;\n    }\n}\n\nconst char* ImGui::GetStyleColorName(ImGuiCol idx)\n{\n    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\\1: return \"\\1\";\n    switch (idx)\n    {\n    case ImGuiCol_Text: return \"Text\";\n    case ImGuiCol_TextDisabled: return \"TextDisabled\";\n    case ImGuiCol_WindowBg: return \"WindowBg\";\n    case ImGuiCol_ChildBg: return \"ChildBg\";\n    case ImGuiCol_PopupBg: return \"PopupBg\";\n    case ImGuiCol_Border: return \"Border\";\n    case ImGuiCol_BorderShadow: return \"BorderShadow\";\n    case ImGuiCol_FrameBg: return \"FrameBg\";\n    case ImGuiCol_FrameBgHovered: return \"FrameBgHovered\";\n    case ImGuiCol_FrameBgActive: return \"FrameBgActive\";\n    case ImGuiCol_TitleBg: return \"TitleBg\";\n    case ImGuiCol_TitleBgActive: return \"TitleBgActive\";\n    case ImGuiCol_TitleBgCollapsed: return \"TitleBgCollapsed\";\n    case ImGuiCol_MenuBarBg: return \"MenuBarBg\";\n    case ImGuiCol_ScrollbarBg: return \"ScrollbarBg\";\n    case ImGuiCol_ScrollbarGrab: return \"ScrollbarGrab\";\n    case ImGuiCol_ScrollbarGrabHovered: return \"ScrollbarGrabHovered\";\n    case ImGuiCol_ScrollbarGrabActive: return \"ScrollbarGrabActive\";\n    case ImGuiCol_CheckMark: return \"CheckMark\";\n    case ImGuiCol_SliderGrab: return \"SliderGrab\";\n    case ImGuiCol_SliderGrabActive: return \"SliderGrabActive\";\n    case ImGuiCol_Button: return \"Button\";\n    case ImGuiCol_ButtonHovered: return \"ButtonHovered\";\n    case ImGuiCol_ButtonActive: return \"ButtonActive\";\n    case ImGuiCol_Header: return \"Header\";\n    case ImGuiCol_HeaderHovered: return \"HeaderHovered\";\n    case ImGuiCol_HeaderActive: return \"HeaderActive\";\n    case ImGuiCol_Separator: return \"Separator\";\n    case ImGuiCol_SeparatorHovered: return \"SeparatorHovered\";\n    case ImGuiCol_SeparatorActive: return \"SeparatorActive\";\n    case ImGuiCol_ResizeGrip: return \"ResizeGrip\";\n    case ImGuiCol_ResizeGripHovered: return \"ResizeGripHovered\";\n    case ImGuiCol_ResizeGripActive: return \"ResizeGripActive\";\n    case ImGuiCol_TabHovered: return \"TabHovered\";\n    case ImGuiCol_Tab: return \"Tab\";\n    case ImGuiCol_TabSelected: return \"TabSelected\";\n    case ImGuiCol_TabSelectedOverline: return \"TabSelectedOverline\";\n    case ImGuiCol_TabDimmed: return \"TabDimmed\";\n    case ImGuiCol_TabDimmedSelected: return \"TabDimmedSelected\";\n    case ImGuiCol_TabDimmedSelectedOverline: return \"TabDimmedSelectedOverline\";\n    case ImGuiCol_PlotLines: return \"PlotLines\";\n    case ImGuiCol_PlotLinesHovered: return \"PlotLinesHovered\";\n    case ImGuiCol_PlotHistogram: return \"PlotHistogram\";\n    case ImGuiCol_PlotHistogramHovered: return \"PlotHistogramHovered\";\n    case ImGuiCol_TableHeaderBg: return \"TableHeaderBg\";\n    case ImGuiCol_TableBorderStrong: return \"TableBorderStrong\";\n    case ImGuiCol_TableBorderLight: return \"TableBorderLight\";\n    case ImGuiCol_TableRowBg: return \"TableRowBg\";\n    case ImGuiCol_TableRowBgAlt: return \"TableRowBgAlt\";\n    case ImGuiCol_TextLink: return \"TextLink\";\n    case ImGuiCol_TextSelectedBg: return \"TextSelectedBg\";\n    case ImGuiCol_DragDropTarget: return \"DragDropTarget\";\n    case ImGuiCol_NavCursor: return \"NavCursor\";\n    case ImGuiCol_NavWindowingHighlight: return \"NavWindowingHighlight\";\n    case ImGuiCol_NavWindowingDimBg: return \"NavWindowingDimBg\";\n    case ImGuiCol_ModalWindowDimBg: return \"ModalWindowDimBg\";\n    }\n    IM_ASSERT(0);\n    return \"Unknown\";\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] RENDER HELPERS\n// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,\n// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.\n// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.\n//-----------------------------------------------------------------------------\n\nconst char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)\n{\n    const char* text_display_end = text;\n    if (!text_end)\n        text_end = (const char*)-1;\n\n    while (text_display_end < text_end && *text_display_end != '\\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))\n        text_display_end++;\n    return text_display_end;\n}\n\n// Internal ImGui functions to render text\n// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()\nvoid ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    // Hide anything after a '##' string\n    const char* text_display_end;\n    if (hide_text_after_hash)\n    {\n        text_display_end = FindRenderedTextEnd(text, text_end);\n    }\n    else\n    {\n        if (!text_end)\n            text_end = text + strlen(text); // FIXME-OPT\n        text_display_end = text_end;\n    }\n\n    if (text != text_display_end)\n    {\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);\n        if (g.LogEnabled)\n            LogRenderedText(&pos, text, text_display_end);\n    }\n}\n\nvoid ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    if (!text_end)\n        text_end = text + strlen(text); // FIXME-OPT\n\n    if (text != text_end)\n    {\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);\n        if (g.LogEnabled)\n            LogRenderedText(&pos, text, text_end);\n    }\n}\n\n// Default clip_rect uses (pos_min,pos_max)\n// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)\n// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.\n// Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take\n// better advantage of the render function taking size into account for coarse clipping.\nvoid ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)\n{\n    // Perform CPU side clipping for single clipped element to avoid using scissor state\n    ImVec2 pos = pos_min;\n    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);\n\n    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;\n    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;\n    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);\n    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min\n        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);\n\n    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.\n    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);\n    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);\n\n    // Render\n    if (need_clipping)\n    {\n        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);\n        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);\n    }\n    else\n    {\n        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);\n    }\n}\n\nvoid ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)\n{\n    // Hide anything after a '##' string\n    const char* text_display_end = FindRenderedTextEnd(text, text_end);\n    const int text_len = (int)(text_display_end - text);\n    if (text_len == 0)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);\n    if (g.LogEnabled)\n        LogRenderedText(&pos_min, text, text_display_end);\n}\n\n// Another overly complex function until we reorganize everything into a nice all-in-one helper.\n// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.\n// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.\nvoid ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)\n{\n    ImGuiContext& g = *GImGui;\n    if (text_end_full == NULL)\n        text_end_full = FindRenderedTextEnd(text);\n    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_end_full, false, 0.0f);\n\n    //draw_list->AddLine(ImVec2(pos_max.x, pos_min.y - 4), ImVec2(pos_max.x, pos_max.y + 4), IM_COL32(0, 0, 255, 255));\n    //draw_list->AddLine(ImVec2(ellipsis_max_x, pos_min.y-2), ImVec2(ellipsis_max_x, pos_max.y+2), IM_COL32(0, 255, 0, 255));\n    //draw_list->AddLine(ImVec2(clip_max_x, pos_min.y), ImVec2(clip_max_x, pos_max.y), IM_COL32(255, 0, 0, 255));\n    // FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.\n    if (text_size.x > pos_max.x - pos_min.x)\n    {\n        // Hello wo...\n        // |       |   |\n        // min   max   ellipsis_max\n        //          <-> this is generally some padding value\n\n        ImFont* font = draw_list->_Data->Font;\n        const float font_size = draw_list->_Data->FontSize;\n        const float font_scale = draw_list->_Data->FontScale;\n        const char* text_end_ellipsis = NULL;\n        const float ellipsis_width = font->EllipsisWidth * font_scale;\n\n        // We can now claim the space between pos_max.x and ellipsis_max.x\n        const float text_avail_width = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0f);\n        float text_size_clipped_x = font->CalcTextSizeA(font_size, text_avail_width, 0.0f, text, text_end_full, &text_end_ellipsis).x;\n        if (text == text_end_ellipsis && text_end_ellipsis < text_end_full)\n        {\n            // Always display at least 1 character if there's no room for character + ellipsis\n            text_end_ellipsis = text + ImTextCountUtf8BytesFromChar(text, text_end_full);\n            text_size_clipped_x = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text, text_end_ellipsis).x;\n        }\n        while (text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1]))\n        {\n            // Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)\n            text_end_ellipsis--;\n            text_size_clipped_x -= font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text_end_ellipsis, text_end_ellipsis + 1).x; // Ascii blanks are always 1 byte\n        }\n\n        // Render text, render ellipsis\n        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_ellipsis, &text_size, ImVec2(0.0f, 0.0f));\n        ImVec2 ellipsis_pos = ImTrunc(ImVec2(pos_min.x + text_size_clipped_x, pos_min.y));\n        if (ellipsis_pos.x + ellipsis_width <= ellipsis_max_x)\n            for (int i = 0; i < font->EllipsisCharCount; i++, ellipsis_pos.x += font->EllipsisCharStep * font_scale)\n                font->RenderChar(draw_list, font_size, ellipsis_pos, GetColorU32(ImGuiCol_Text), font->EllipsisChar);\n    }\n    else\n    {\n        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_full, &text_size, ImVec2(0.0f, 0.0f));\n    }\n\n    if (g.LogEnabled)\n        LogRenderedText(&pos_min, text, text_end_full);\n}\n\n// Render a rectangle shaped with optional rounding and borders\nvoid ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool borders, float rounding)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);\n    const float border_size = g.Style.FrameBorderSize;\n    if (borders && border_size > 0.0f)\n    {\n        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);\n        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);\n    }\n}\n\nvoid ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    const float border_size = g.Style.FrameBorderSize;\n    if (border_size > 0.0f)\n    {\n        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);\n        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);\n    }\n}\n\nvoid ImGui::RenderNavCursor(const ImRect& bb, ImGuiID id, ImGuiNavRenderCursorFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    if (id != g.NavId)\n        return;\n    if (!g.NavCursorVisible && !(flags & ImGuiNavRenderCursorFlags_AlwaysDraw))\n        return;\n    if (id == g.LastItemData.ID && (g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav))\n        return;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->DC.NavHideHighlightOneFrame)\n        return;\n\n    float rounding = (flags & ImGuiNavRenderCursorFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;\n    ImRect display_rect = bb;\n    display_rect.ClipWith(window->ClipRect);\n    const float thickness = 2.0f;\n    if (flags & ImGuiNavRenderCursorFlags_Compact)\n    {\n        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavCursor), rounding, 0, thickness);\n    }\n    else\n    {\n        const float distance = 3.0f + thickness * 0.5f;\n        display_rect.Expand(ImVec2(distance, distance));\n        bool fully_visible = window->ClipRect.Contains(display_rect);\n        if (!fully_visible)\n            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);\n        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavCursor), rounding, 0, thickness);\n        if (!fully_visible)\n            window->DrawList->PopClipRect();\n    }\n}\n\nvoid ImGui::RenderMouseCursor(ImVec2 base_pos, float base_scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow)\n{\n    ImGuiContext& g = *GImGui;\n    if (mouse_cursor <= ImGuiMouseCursor_None || mouse_cursor >= ImGuiMouseCursor_COUNT) // We intentionally accept out of bound values.\n        mouse_cursor = ImGuiMouseCursor_Arrow;\n    ImFontAtlas* font_atlas = g.DrawListSharedData.Font->ContainerAtlas;\n    for (ImGuiViewportP* viewport : g.Viewports)\n    {\n        // We scale cursor with current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor.\n        ImVec2 offset, size, uv[4];\n        if (!font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))\n            continue;\n        const ImVec2 pos = base_pos - offset;\n        const float scale = base_scale;\n        if (!viewport->GetMainRect().Overlaps(ImRect(pos, pos + ImVec2(size.x + 2, size.y + 2) * scale)))\n            continue;\n        ImDrawList* draw_list = GetForegroundDrawList(viewport);\n        ImTextureID tex_id = font_atlas->TexID;\n        draw_list->PushTextureID(tex_id);\n        draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);\n        draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);\n        draw_list->AddImage(tex_id, pos,                        pos + size * scale,                  uv[2], uv[3], col_border);\n        draw_list->AddImage(tex_id, pos,                        pos + size * scale,                  uv[0], uv[1], col_fill);\n        draw_list->PopTextureID();\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] INITIALIZATION, SHUTDOWN\n//-----------------------------------------------------------------------------\n\n// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself\n// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module\nImGuiContext* ImGui::GetCurrentContext()\n{\n    return GImGui;\n}\n\nvoid ImGui::SetCurrentContext(ImGuiContext* ctx)\n{\n#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC\n    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.\n#else\n    GImGui = ctx;\n#endif\n}\n\nvoid ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)\n{\n    GImAllocatorAllocFunc = alloc_func;\n    GImAllocatorFreeFunc = free_func;\n    GImAllocatorUserData = user_data;\n}\n\n// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)\nvoid ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)\n{\n    *p_alloc_func = GImAllocatorAllocFunc;\n    *p_free_func = GImAllocatorFreeFunc;\n    *p_user_data = GImAllocatorUserData;\n}\n\nImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)\n{\n    ImGuiContext* prev_ctx = GetCurrentContext();\n    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);\n    SetCurrentContext(ctx);\n    Initialize();\n    if (prev_ctx != NULL)\n        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.\n    return ctx;\n}\n\nvoid ImGui::DestroyContext(ImGuiContext* ctx)\n{\n    ImGuiContext* prev_ctx = GetCurrentContext();\n    if (ctx == NULL) //-V1051\n        ctx = prev_ctx;\n    SetCurrentContext(ctx);\n    Shutdown();\n    SetCurrentContext((prev_ctx != ctx) ? prev_ctx : NULL);\n    IM_DELETE(ctx);\n}\n\n// IMPORTANT: interactive elements requires a fixed ###xxx suffix, it must be same in ALL languages to allow for automation.\nstatic const ImGuiLocEntry GLocalizationEntriesEnUS[] =\n{\n    { ImGuiLocKey_VersionStr,           \"Dear ImGui \" IMGUI_VERSION \" (\" IM_STRINGIFY(IMGUI_VERSION_NUM) \")\" },\n    { ImGuiLocKey_TableSizeOne,         \"Size column to fit###SizeOne\"          },\n    { ImGuiLocKey_TableSizeAllFit,      \"Size all columns to fit###SizeAll\"     },\n    { ImGuiLocKey_TableSizeAllDefault,  \"Size all columns to default###SizeAll\" },\n    { ImGuiLocKey_TableResetOrder,      \"Reset order###ResetOrder\"              },\n    { ImGuiLocKey_WindowingMainMenuBar, \"(Main menu bar)\"                       },\n    { ImGuiLocKey_WindowingPopup,       \"(Popup)\"                               },\n    { ImGuiLocKey_WindowingUntitled,    \"(Untitled)\"                            },\n    { ImGuiLocKey_OpenLink_s,           \"Open '%s'\"                             },\n    { ImGuiLocKey_CopyLink,             \"Copy Link###CopyLink\"                  },\n};\n\nImGuiContext::ImGuiContext(ImFontAtlas* shared_font_atlas)\n{\n    IO.Ctx = this;\n    InputTextState.Ctx = this;\n\n    Initialized = false;\n    FontAtlasOwnedByContext = shared_font_atlas ? false : true;\n    Font = NULL;\n    FontSize = FontBaseSize = FontScale = CurrentDpiScale = 0.0f;\n    IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();\n    Time = 0.0f;\n    FrameCount = 0;\n    FrameCountEnded = FrameCountRendered = -1;\n    WithinEndChildID = 0;\n    WithinFrameScope = WithinFrameScopeWithImplicitWindow = false;\n    GcCompactAll = false;\n    TestEngineHookItems = false;\n    TestEngine = NULL;\n    memset(ContextName, 0, sizeof(ContextName));\n\n    InputEventsNextMouseSource = ImGuiMouseSource_Mouse;\n    InputEventsNextEventId = 1;\n\n    WindowsActiveCount = 0;\n    CurrentWindow = NULL;\n    HoveredWindow = NULL;\n    HoveredWindowUnderMovingWindow = NULL;\n    HoveredWindowBeforeClear = NULL;\n    MovingWindow = NULL;\n    WheelingWindow = NULL;\n    WheelingWindowStartFrame = WheelingWindowScrolledFrame = -1;\n    WheelingWindowReleaseTimer = 0.0f;\n\n    DebugDrawIdConflicts = 0;\n    DebugHookIdInfo = 0;\n    HoveredId = HoveredIdPreviousFrame = 0;\n    HoveredIdPreviousFrameItemCount = 0;\n    HoveredIdAllowOverlap = false;\n    HoveredIdIsDisabled = false;\n    HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;\n    ItemUnclipByLog = false;\n    ActiveId = 0;\n    ActiveIdIsAlive = 0;\n    ActiveIdTimer = 0.0f;\n    ActiveIdIsJustActivated = false;\n    ActiveIdAllowOverlap = false;\n    ActiveIdNoClearOnFocusLoss = false;\n    ActiveIdHasBeenPressedBefore = false;\n    ActiveIdHasBeenEditedBefore = false;\n    ActiveIdHasBeenEditedThisFrame = false;\n    ActiveIdFromShortcut = false;\n    ActiveIdClickOffset = ImVec2(-1, -1);\n    ActiveIdWindow = NULL;\n    ActiveIdSource = ImGuiInputSource_None;\n    ActiveIdMouseButton = -1;\n    ActiveIdPreviousFrame = 0;\n    ActiveIdPreviousFrameIsAlive = false;\n    ActiveIdPreviousFrameHasBeenEditedBefore = false;\n    ActiveIdPreviousFrameWindow = NULL;\n    memset(&ActiveIdValueOnActivation, 0, sizeof(ActiveIdValueOnActivation));\n    LastActiveId = 0;\n    LastActiveIdTimer = 0.0f;\n\n    LastKeyboardKeyPressTime = LastKeyModsChangeTime = LastKeyModsChangeFromNoneTime = -1.0;\n\n    ActiveIdUsingNavDirMask = 0x00;\n    ActiveIdUsingAllKeyboardKeys = false;\n\n    CurrentFocusScopeId = 0;\n    CurrentItemFlags = ImGuiItemFlags_None;\n    DebugShowGroupRects = false;\n\n    NavCursorVisible = false;\n    NavHighlightItemUnderNav = false;\n    NavMousePosDirty = false;\n    NavIdIsAlive = false;\n    NavId = 0;\n    NavWindow = NULL;\n    NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = 0;\n    NavLayer = ImGuiNavLayer_Main;\n    NavNextActivateId = 0;\n    NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;\n    NavHighlightActivatedId = 0;\n    NavHighlightActivatedTimer = 0.0f;\n    NavInputSource = ImGuiInputSource_Keyboard;\n    NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;\n    NavCursorHideFrames = 0;\n\n    NavAnyRequest = false;\n    NavInitRequest = false;\n    NavInitRequestFromMove = false;\n    NavMoveSubmitted = false;\n    NavMoveScoringItems = false;\n    NavMoveForwardToNextFrame = false;\n    NavMoveFlags = ImGuiNavMoveFlags_None;\n    NavMoveScrollFlags = ImGuiScrollFlags_None;\n    NavMoveKeyMods = ImGuiMod_None;\n    NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;\n    NavScoringDebugCount = 0;\n    NavTabbingDir = 0;\n    NavTabbingCounter = 0;\n\n    NavJustMovedFromFocusScopeId = NavJustMovedToId = NavJustMovedToFocusScopeId = 0;\n    NavJustMovedToKeyMods = ImGuiMod_None;\n    NavJustMovedToIsTabbing = false;\n    NavJustMovedToHasSelectionData = false;\n\n    // All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...\n    // FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..\n    ConfigNavWindowingKeyNext = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiKey_Tab);\n    ConfigNavWindowingKeyPrev = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab);\n    NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;\n    NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;\n    NavWindowingToggleLayer = false;\n    NavWindowingToggleKey = ImGuiKey_None;\n\n    DimBgRatio = 0.0f;\n\n    DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;\n    DragDropSourceFlags = ImGuiDragDropFlags_None;\n    DragDropSourceFrameCount = -1;\n    DragDropMouseButton = -1;\n    DragDropTargetId = 0;\n    DragDropAcceptFlags = ImGuiDragDropFlags_None;\n    DragDropAcceptIdCurrRectSurface = 0.0f;\n    DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;\n    DragDropAcceptFrameCount = -1;\n    DragDropHoldJustPressedId = 0;\n    memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));\n\n    ClipperTempDataStacked = 0;\n\n    CurrentTable = NULL;\n    TablesTempDataStacked = 0;\n    CurrentTabBar = NULL;\n    CurrentMultiSelect = NULL;\n    MultiSelectTempDataStacked = 0;\n\n    HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;\n    HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;\n\n    MouseCursor = ImGuiMouseCursor_Arrow;\n    MouseStationaryTimer = 0.0f;\n\n    TempInputId = 0;\n    memset(&DataTypeZeroValue, 0, sizeof(DataTypeZeroValue));\n    BeginMenuDepth = BeginComboDepth = 0;\n    ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;\n    ColorEditCurrentID = ColorEditSavedID = 0;\n    ColorEditSavedHue = ColorEditSavedSat = 0.0f;\n    ColorEditSavedColor = 0;\n    WindowResizeRelativeMode = false;\n    ScrollbarSeekMode = 0;\n    ScrollbarClickDeltaToGrabCenter = 0.0f;\n    SliderGrabClickOffset = 0.0f;\n    SliderCurrentAccum = 0.0f;\n    SliderCurrentAccumDirty = false;\n    DragCurrentAccumDirty = false;\n    DragCurrentAccum = 0.0f;\n    DragSpeedDefaultRatio = 1.0f / 100.0f;\n    DisabledAlphaBackup = 0.0f;\n    DisabledStackSize = 0;\n    TooltipOverrideCount = 0;\n    TooltipPreviousWindow = NULL;\n\n    PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);\n    PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission\n\n    SettingsLoaded = false;\n    SettingsDirtyTimer = 0.0f;\n    HookIdNext = 0;\n\n    memset(LocalizationTable, 0, sizeof(LocalizationTable));\n\n    LogEnabled = false;\n    LogFlags = ImGuiLogFlags_None;\n    LogWindow = NULL;\n    LogNextPrefix = LogNextSuffix = NULL;\n    LogFile = NULL;\n    LogLinePosY = FLT_MAX;\n    LogLineFirstItem = false;\n    LogDepthRef = 0;\n    LogDepthToExpand = LogDepthToExpandDefault = 2;\n\n    ErrorCallback = NULL;\n    ErrorCallbackUserData = NULL;\n    ErrorFirst = true;\n    ErrorCountCurrentFrame = 0;\n    StackSizesInBeginForCurrentWindow = NULL;\n\n    DebugDrawIdConflictsCount = 0;\n    DebugLogFlags = ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_OutputToTTY;\n    DebugLocateId = 0;\n    DebugLogSkippedErrors = 0;\n    DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;\n    DebugLogAutoDisableFrames = 0;\n    DebugLocateFrames = 0;\n    DebugBeginReturnValueCullDepth = -1;\n    DebugItemPickerActive = false;\n    DebugItemPickerMouseButton = ImGuiMouseButton_Left;\n    DebugItemPickerBreakId = 0;\n    DebugFlashStyleColorTime = 0.0f;\n    DebugFlashStyleColorIdx = ImGuiCol_COUNT;\n\n    // Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations\n    DebugBreakInWindow = 0;\n    DebugBreakInTable = 0;\n    DebugBreakInLocateId = false;\n    DebugBreakKeyChord = ImGuiKey_Pause;\n    DebugBreakInShortcutRouting = ImGuiKey_None;\n\n    memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));\n    FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;\n    FramerateSecPerFrameAccum = 0.0f;\n    WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;\n    memset(TempKeychordName, 0, sizeof(TempKeychordName));\n}\n\nvoid ImGui::Initialize()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);\n\n    // Add .ini handle for ImGuiWindow and ImGuiTable types\n    {\n        ImGuiSettingsHandler ini_handler;\n        ini_handler.TypeName = \"Window\";\n        ini_handler.TypeHash = ImHashStr(\"Window\");\n        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;\n        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;\n        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;\n        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;\n        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;\n        AddSettingsHandler(&ini_handler);\n    }\n    TableSettingsAddSettingsHandler();\n\n    // Setup default localization table\n    LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));\n\n    // Setup default ImGuiPlatformIO clipboard/IME handlers.\n    g.PlatformIO.Platform_GetClipboardTextFn = Platform_GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations\n    g.PlatformIO.Platform_SetClipboardTextFn = Platform_SetClipboardTextFn_DefaultImpl;\n    g.PlatformIO.Platform_OpenInShellFn = Platform_OpenInShellFn_DefaultImpl;\n    g.PlatformIO.Platform_SetImeDataFn = Platform_SetImeDataFn_DefaultImpl;\n\n    // Create default viewport\n    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();\n    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;\n    g.Viewports.push_back(viewport);\n    g.TempBuffer.resize(1024 * 3 + 1, 0);\n\n    // Build KeysMayBeCharInput[] lookup table (1 bool per named key)\n    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))\n        if ((key >= ImGuiKey_0 && key <= ImGuiKey_9) || (key >= ImGuiKey_A && key <= ImGuiKey_Z) || (key >= ImGuiKey_Keypad0 && key <= ImGuiKey_Keypad9)\n            || key == ImGuiKey_Tab || key == ImGuiKey_Space || key == ImGuiKey_Apostrophe || key == ImGuiKey_Comma || key == ImGuiKey_Minus || key == ImGuiKey_Period\n            || key == ImGuiKey_Slash || key == ImGuiKey_Semicolon || key == ImGuiKey_Equal || key == ImGuiKey_LeftBracket || key == ImGuiKey_RightBracket || key == ImGuiKey_GraveAccent\n            || key == ImGuiKey_KeypadDecimal || key == ImGuiKey_KeypadDivide || key == ImGuiKey_KeypadMultiply || key == ImGuiKey_KeypadSubtract || key == ImGuiKey_KeypadAdd || key == ImGuiKey_KeypadEqual)\n            g.KeysMayBeCharInput.SetBit(key);\n\n#ifdef IMGUI_HAS_DOCK\n#endif\n\n    g.Initialized = true;\n}\n\n// This function is merely here to free heap allocations.\nvoid ImGui::Shutdown()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == NULL, \"Forgot to shutdown Platform backend?\");\n    IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == NULL, \"Forgot to shutdown Renderer backend?\");\n\n    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)\n    if (g.IO.Fonts && g.FontAtlasOwnedByContext)\n    {\n        g.IO.Fonts->Locked = false;\n        IM_DELETE(g.IO.Fonts);\n    }\n    g.IO.Fonts = NULL;\n    g.DrawListSharedData.TempBuffer.clear();\n\n    // Cleanup of other data are conditional on actually having initialized Dear ImGui.\n    if (!g.Initialized)\n        return;\n\n    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)\n    if (g.SettingsLoaded && g.IO.IniFilename != NULL)\n        SaveIniSettingsToDisk(g.IO.IniFilename);\n\n    CallContextHooks(&g, ImGuiContextHookType_Shutdown);\n\n    // Clear everything else\n    g.Windows.clear_delete();\n    g.WindowsFocusOrder.clear();\n    g.WindowsTempSortBuffer.clear();\n    g.CurrentWindow = NULL;\n    g.CurrentWindowStack.clear();\n    g.WindowsById.Clear();\n    g.NavWindow = NULL;\n    g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;\n    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;\n    g.MovingWindow = NULL;\n\n    g.KeysRoutingTable.Clear();\n\n    g.ColorStack.clear();\n    g.StyleVarStack.clear();\n    g.FontStack.clear();\n    g.OpenPopupStack.clear();\n    g.BeginPopupStack.clear();\n    g.TreeNodeStack.clear();\n\n    g.Viewports.clear_delete();\n\n    g.TabBars.Clear();\n    g.CurrentTabBarStack.clear();\n    g.ShrinkWidthBuffer.clear();\n\n    g.ClipperTempData.clear_destruct();\n\n    g.Tables.Clear();\n    g.TablesTempData.clear_destruct();\n    g.DrawChannelsTempMergeBuffer.clear();\n\n    g.MultiSelectStorage.Clear();\n    g.MultiSelectTempData.clear_destruct();\n\n    g.ClipboardHandlerData.clear();\n    g.MenusIdSubmittedThisFrame.clear();\n    g.InputTextState.ClearFreeMemory();\n    g.InputTextDeactivatedState.ClearFreeMemory();\n\n    g.SettingsWindows.clear();\n    g.SettingsHandlers.clear();\n\n    if (g.LogFile)\n    {\n#ifndef IMGUI_DISABLE_TTY_FUNCTIONS\n        if (g.LogFile != stdout)\n#endif\n            ImFileClose(g.LogFile);\n        g.LogFile = NULL;\n    }\n    g.LogBuffer.clear();\n    g.DebugLogBuf.clear();\n    g.DebugLogIndex.clear();\n\n    g.Initialized = false;\n}\n\n// No specific ordering/dependency support, will see as needed\nImGuiID ImGui::AddContextHook(ImGuiContext* ctx, const ImGuiContextHook* hook)\n{\n    ImGuiContext& g = *ctx;\n    IM_ASSERT(hook->Callback != NULL && hook->HookId == 0 && hook->Type != ImGuiContextHookType_PendingRemoval_);\n    g.Hooks.push_back(*hook);\n    g.Hooks.back().HookId = ++g.HookIdNext;\n    return g.HookIdNext;\n}\n\n// Deferred removal, avoiding issue with changing vector while iterating it\nvoid ImGui::RemoveContextHook(ImGuiContext* ctx, ImGuiID hook_id)\n{\n    ImGuiContext& g = *ctx;\n    IM_ASSERT(hook_id != 0);\n    for (ImGuiContextHook& hook : g.Hooks)\n        if (hook.HookId == hook_id)\n            hook.Type = ImGuiContextHookType_PendingRemoval_;\n}\n\n// Call context hooks (used by e.g. test engine)\n// We assume a small number of hooks so all stored in same array\nvoid ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)\n{\n    ImGuiContext& g = *ctx;\n    for (ImGuiContextHook& hook : g.Hooks)\n        if (hook.Type == hook_type)\n            hook.Callback(&g, &hook);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n//-----------------------------------------------------------------------------\n\n// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods\nImGuiWindow::ImGuiWindow(ImGuiContext* ctx, const char* name) : DrawListInst(NULL)\n{\n    memset(this, 0, sizeof(*this));\n    Ctx = ctx;\n    Name = ImStrdup(name);\n    NameBufLen = (int)strlen(name) + 1;\n    ID = ImHashStr(name);\n    IDStack.push_back(ID);\n    MoveId = GetID(\"#MOVE\");\n    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);\n    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);\n    AutoFitFramesX = AutoFitFramesY = -1;\n    AutoPosLastDirection = ImGuiDir_None;\n    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = 0;\n    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);\n    LastFrameActive = -1;\n    LastTimeActive = -1.0f;\n    FontWindowScale = 1.0f;\n    SettingsOffset = -1;\n    DrawList = &DrawListInst;\n    DrawList->_OwnerName = Name;\n    DrawList->_Data = &Ctx->DrawListSharedData;\n    NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);\n}\n\nImGuiWindow::~ImGuiWindow()\n{\n    IM_ASSERT(DrawList == &DrawListInst);\n    IM_DELETE(Name);\n    ColumnsStorage.clear_destruct();\n}\n\nstatic void SetCurrentWindow(ImGuiWindow* window)\n{\n    ImGuiContext& g = *GImGui;\n    g.CurrentWindow = window;\n    g.StackSizesInBeginForCurrentWindow = g.CurrentWindow ? &g.CurrentWindowStack.back().StackSizesInBegin : NULL;\n    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;\n    g.CurrentDpiScale = 1.0f; // FIXME-DPI: WIP this is modified in docking\n    if (window)\n    {\n        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();\n        g.FontScale = g.DrawListSharedData.FontScale = g.FontSize / g.Font->FontSize;\n        ImGui::NavUpdateCurrentWindowIsScrollPushableX();\n    }\n}\n\nvoid ImGui::GcCompactTransientMiscBuffers()\n{\n    ImGuiContext& g = *GImGui;\n    g.ItemFlagsStack.clear();\n    g.GroupStack.clear();\n    g.MultiSelectTempDataStacked = 0;\n    g.MultiSelectTempData.clear_destruct();\n    TableGcCompactSettings();\n}\n\n// Free up/compact internal window buffers, we can use this when a window becomes unused.\n// Not freed:\n// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)\n// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.\nvoid ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)\n{\n    window->MemoryCompacted = true;\n    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;\n    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;\n    window->IDStack.clear();\n    window->DrawList->_ClearFreeMemory();\n    window->DC.ChildWindows.clear();\n    window->DC.ItemWidthStack.clear();\n    window->DC.TextWrapPosStack.clear();\n}\n\nvoid ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)\n{\n    // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.\n    // The other buffers tends to amortize much faster.\n    window->MemoryCompacted = false;\n    window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);\n    window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);\n    window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;\n}\n\nvoid ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)\n{\n    ImGuiContext& g = *GImGui;\n\n    // Clear previous active id\n    if (g.ActiveId != 0)\n    {\n        // While most behaved code would make an effort to not steal active id during window move/drag operations,\n        // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch\n        // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.\n        if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)\n        {\n            IMGUI_DEBUG_LOG_ACTIVEID(\"SetActiveID() cancel MovingWindow\\n\");\n            g.MovingWindow = NULL;\n        }\n\n        // This could be written in a more general way (e.g associate a hook to ActiveId),\n        // but since this is currently quite an exception we'll leave it as is.\n        // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveID()\n        if (g.InputTextState.ID == g.ActiveId)\n            InputTextDeactivateHook(g.ActiveId);\n    }\n\n    // Set active id\n    g.ActiveIdIsJustActivated = (g.ActiveId != id);\n    if (g.ActiveIdIsJustActivated)\n    {\n        IMGUI_DEBUG_LOG_ACTIVEID(\"SetActiveID() old:0x%08X (window \\\"%s\\\") -> new:0x%08X (window \\\"%s\\\")\\n\", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : \"\", id, window ? window->Name : \"\");\n        g.ActiveIdTimer = 0.0f;\n        g.ActiveIdHasBeenPressedBefore = false;\n        g.ActiveIdHasBeenEditedBefore = false;\n        g.ActiveIdMouseButton = -1;\n        if (id != 0)\n        {\n            g.LastActiveId = id;\n            g.LastActiveIdTimer = 0.0f;\n        }\n    }\n    g.ActiveId = id;\n    g.ActiveIdAllowOverlap = false;\n    g.ActiveIdNoClearOnFocusLoss = false;\n    g.ActiveIdWindow = window;\n    g.ActiveIdHasBeenEditedThisFrame = false;\n    g.ActiveIdFromShortcut = false;\n    if (id)\n    {\n        g.ActiveIdIsAlive = id;\n        g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;\n        IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);\n    }\n\n    // Clear declaration of inputs claimed by the widget\n    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)\n    g.ActiveIdUsingNavDirMask = 0x00;\n    g.ActiveIdUsingAllKeyboardKeys = false;\n}\n\nvoid ImGui::ClearActiveID()\n{\n    SetActiveID(0, NULL); // g.ActiveId = 0;\n}\n\nvoid ImGui::SetHoveredID(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    g.HoveredId = id;\n    g.HoveredIdAllowOverlap = false;\n    if (id != 0 && g.HoveredIdPreviousFrame != id)\n        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;\n}\n\nImGuiID ImGui::GetHoveredID()\n{\n    ImGuiContext& g = *GImGui;\n    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;\n}\n\nvoid ImGui::MarkItemEdited(ImGuiID id)\n{\n    // This marking is to be able to provide info for IsItemDeactivatedAfterEdit().\n    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need to fill the data.\n    ImGuiContext& g = *GImGui;\n    if (g.LastItemData.ItemFlags & ImGuiItemFlags_NoMarkEdited)\n        return;\n    if (g.ActiveId == id || g.ActiveId == 0)\n    {\n        g.ActiveIdHasBeenEditedThisFrame = true;\n        g.ActiveIdHasBeenEditedBefore = true;\n    }\n\n    // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)\n    // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)\n    IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id || (g.CurrentMultiSelect != NULL && g.BoxSelectState.IsActive));\n\n    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);\n    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;\n}\n\nbool ImGui::IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)\n{\n    // An active popup disable hovering on other windows (apart from its own children)\n    // FIXME-OPT: This could be cached/stored within the window.\n    ImGuiContext& g = *GImGui;\n    if (g.NavWindow)\n        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)\n            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)\n            {\n                // For the purpose of those flags we differentiate \"standard popup\" from \"modal popup\"\n                // NB: The 'else' is important because Modal windows are also Popups.\n                bool want_inhibit = false;\n                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)\n                    want_inhibit = true;\n                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))\n                    want_inhibit = true;\n\n                // Inhibit hover unless the window is within the stack of our modal/popup\n                if (want_inhibit)\n                    if (!IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))\n                        return false;\n            }\n    return true;\n}\n\nstatic inline float CalcDelayFromHoveredFlags(ImGuiHoveredFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    if (flags & ImGuiHoveredFlags_DelayNormal)\n        return g.Style.HoverDelayNormal;\n    if (flags & ImGuiHoveredFlags_DelayShort)\n        return g.Style.HoverDelayShort;\n    return 0.0f;\n}\n\nstatic ImGuiHoveredFlags ApplyHoverFlagsForTooltip(ImGuiHoveredFlags user_flags, ImGuiHoveredFlags shared_flags)\n{\n    // Allow instance flags to override shared flags\n    if (user_flags & (ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal))\n        shared_flags &= ~(ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal);\n    return user_flags | shared_flags;\n}\n\n// This is roughly matching the behavior of internal-facing ItemHoverable()\n// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()\n// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId\nbool ImGui::IsItemHovered(ImGuiHoveredFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT_USER_ERROR((flags & ~ImGuiHoveredFlags_AllowedMaskForIsItemHovered) == 0, \"Invalid flags for IsItemHovered()!\");\n\n    if (g.NavHighlightItemUnderNav && g.NavCursorVisible && !(flags & ImGuiHoveredFlags_NoNavOverride))\n    {\n        if (!IsItemFocused())\n            return false;\n        if ((g.LastItemData.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))\n            return false;\n\n        if (flags & ImGuiHoveredFlags_ForTooltip)\n            flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav);\n    }\n    else\n    {\n        // Test for bounding box overlap, as updated as ItemAdd()\n        ImGuiItemStatusFlags status_flags = g.LastItemData.StatusFlags;\n        if (!(status_flags & ImGuiItemStatusFlags_HoveredRect))\n            return false;\n\n        if (flags & ImGuiHoveredFlags_ForTooltip)\n            flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);\n\n        // Done with rectangle culling so we can perform heavier checks now\n        // Test if we are hovering the right window (our window could be behind another window)\n        // [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)\n        // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable\n        // to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was\n        // the test that has been running for a long while.\n        if (g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_HoveredWindow) == 0)\n            if ((flags & ImGuiHoveredFlags_AllowWhenOverlappedByWindow) == 0)\n                return false;\n\n        // Test if another item is active (e.g. being dragged)\n        const ImGuiID id = g.LastItemData.ID;\n        if ((flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == 0)\n            if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)\n                if (g.ActiveId != window->MoveId)\n                    return false;\n\n        // Test if interactions on this window are blocked by an active popup or modal.\n        // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.\n        if (!IsWindowContentHoverable(window, flags) && !(g.LastItemData.ItemFlags & ImGuiItemFlags_NoWindowHoverableCheck))\n            return false;\n\n        // Test if the item is disabled\n        if ((g.LastItemData.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))\n            return false;\n\n        // Special handling for calling after Begin() which represent the title bar or tab.\n        // When the window is skipped/collapsed (SkipItems==true) that last item (always ->MoveId submitted by Begin)\n        // will never be overwritten so we need to detect the case.\n        if (id == window->MoveId && window->WriteAccessed)\n            return false;\n\n        // Test if using AllowOverlap and overlapped\n        if ((g.LastItemData.ItemFlags & ImGuiItemFlags_AllowOverlap) && id != 0)\n            if ((flags & ImGuiHoveredFlags_AllowWhenOverlappedByItem) == 0)\n                if (g.HoveredIdPreviousFrame != g.LastItemData.ID)\n                    return false;\n    }\n\n    // Handle hover delay\n    // (some ideas: https://www.nngroup.com/articles/timing-exposing-content)\n    const float delay = CalcDelayFromHoveredFlags(flags);\n    if (delay > 0.0f || (flags & ImGuiHoveredFlags_Stationary))\n    {\n        ImGuiID hover_delay_id = (g.LastItemData.ID != 0) ? g.LastItemData.ID : window->GetIDFromPos(g.LastItemData.Rect.Min);\n        if ((flags & ImGuiHoveredFlags_NoSharedDelay) && (g.HoverItemDelayIdPreviousFrame != hover_delay_id))\n            g.HoverItemDelayTimer = 0.0f;\n        g.HoverItemDelayId = hover_delay_id;\n\n        // When changing hovered item we requires a bit of stationary delay before activating hover timer,\n        // but once unlocked on a given item we also moving.\n        //if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime < delay || g.MouseStationaryTimer - g.IO.DeltaTime < g.Style.HoverStationaryDelay)) { IMGUI_DEBUG_LOG(\"HoverDelayTimer = %f/%f, MouseStationaryTimer = %f\\n\", g.HoverDelayTimer, delay, g.MouseStationaryTimer); }\n        if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverItemUnlockedStationaryId != hover_delay_id)\n            return false;\n\n        if (g.HoverItemDelayTimer < delay)\n            return false;\n    }\n\n    return true;\n}\n\n// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().\n// (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)\n// FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.\n// If you used this in your legacy/custom widgets code:\n// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.ItemFlags'.\n// - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.\nbool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id, ImGuiItemFlags item_flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    // Detect ID conflicts\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (id != 0 && g.HoveredIdPreviousFrame == id && (item_flags & ImGuiItemFlags_AllowDuplicateId) == 0)\n    {\n        g.HoveredIdPreviousFrameItemCount++;\n        if (g.DebugDrawIdConflicts == id)\n            window->DrawList->AddRect(bb.Min - ImVec2(1,1), bb.Max + ImVec2(1,1), IM_COL32(255, 0, 0, 255), 0.0f, ImDrawFlags_None, 2.0f);\n    }\n#endif\n\n    if (g.HoveredWindow != window)\n        return false;\n    if (!IsMouseHoveringRect(bb.Min, bb.Max))\n        return false;\n\n    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)\n        return false;\n    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)\n        if (!g.ActiveIdFromShortcut)\n            return false;\n\n    // Done with rectangle culling so we can perform heavier checks now.\n    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))\n    {\n        g.HoveredIdIsDisabled = true;\n        return false;\n    }\n\n    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level\n    // hover test in widgets code. We could also decide to split this function is two.\n    if (id != 0)\n    {\n        // Drag source doesn't report as hovered\n        if (g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))\n            return false;\n\n        SetHoveredID(id);\n\n        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.\n        // This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.\n        if (item_flags & ImGuiItemFlags_AllowOverlap)\n        {\n            g.HoveredIdAllowOverlap = true;\n            if (g.HoveredIdPreviousFrame != id)\n                return false;\n        }\n\n        // Display shortcut (only works with mouse)\n        // (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)\n        if (id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut) && g.ActiveId != id)\n            if (IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal))\n                SetTooltip(\"%s\", GetKeyChordName(g.LastItemData.Shortcut));\n    }\n\n    // When disabled we'll return false but still set HoveredId\n    if (item_flags & ImGuiItemFlags_Disabled)\n    {\n        // Release active id if turning disabled\n        if (g.ActiveId == id && id != 0)\n            ClearActiveID();\n        g.HoveredIdIsDisabled = true;\n        return false;\n    }\n\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (id != 0)\n    {\n        // [DEBUG] Item Picker tool!\n        // We perform the check here because reaching is path is rare (1~ time a frame),\n        // making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered\n        // items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.\n        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)\n            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));\n        if (g.DebugItemPickerBreakId == id)\n            IM_DEBUG_BREAK();\n    }\n#endif\n\n    if (g.NavHighlightItemUnderNav && (item_flags & ImGuiItemFlags_NoNavDisableMouseHover) == 0)\n        return false;\n\n    return true;\n}\n\n// FIXME: This is inlined/duplicated in ItemAdd()\n// FIXME: The id != 0 path is not used by our codebase, may get rid of it?\nbool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (!bb.Overlaps(window->ClipRect))\n        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))\n            if (!g.ItemUnclipByLog)\n                return true;\n    return false;\n}\n\n// This is also inlined in ItemAdd()\n// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.\nvoid ImGui::SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)\n{\n    ImGuiContext& g = *GImGui;\n    g.LastItemData.ID = item_id;\n    g.LastItemData.ItemFlags = in_flags;\n    g.LastItemData.StatusFlags = item_flags;\n    g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;\n}\n\nfloat ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)\n{\n    if (wrap_pos_x < 0.0f)\n        return 0.0f;\n\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (wrap_pos_x == 0.0f)\n    {\n        // We could decide to setup a default wrapping max point for auto-resizing windows,\n        // or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?\n        //if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))\n        //    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);\n        //else\n        wrap_pos_x = window->WorkRect.Max.x;\n    }\n    else if (wrap_pos_x > 0.0f)\n    {\n        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space\n    }\n\n    return ImMax(wrap_pos_x - pos.x, 1.0f);\n}\n\n// IM_ALLOC() == ImGui::MemAlloc()\nvoid* ImGui::MemAlloc(size_t size)\n{\n    void* ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (ImGuiContext* ctx = GImGui)\n        DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);\n#endif\n    return ptr;\n}\n\n// IM_FREE() == ImGui::MemFree()\nvoid ImGui::MemFree(void* ptr)\n{\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (ptr != NULL)\n        if (ImGuiContext* ctx = GImGui)\n            DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);\n#endif\n    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);\n}\n\n// We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of \"no allocations on idle/repeating frames\"\nvoid ImGui::DebugAllocHook(ImGuiDebugAllocInfo* info, int frame_count, void* ptr, size_t size)\n{\n    ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[info->LastEntriesIdx];\n    IM_UNUSED(ptr);\n    if (entry->FrameCount != frame_count)\n    {\n        info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);\n        entry = &info->LastEntriesBuf[info->LastEntriesIdx];\n        entry->FrameCount = frame_count;\n        entry->AllocCount = entry->FreeCount = 0;\n    }\n    if (size != (size_t)-1)\n    {\n        //printf(\"[%05d] MemAlloc(%d) -> 0x%p\\n\", frame_count, (int)size, ptr);\n        entry->AllocCount++;\n        info->TotalAllocCount++;\n    }\n    else\n    {\n        //printf(\"[%05d] MemFree(0x%p)\\n\", frame_count, ptr);\n        entry->FreeCount++;\n        info->TotalFreeCount++;\n    }\n}\n\nconst char* ImGui::GetClipboardText()\n{\n    ImGuiContext& g = *GImGui;\n    return g.PlatformIO.Platform_GetClipboardTextFn ? g.PlatformIO.Platform_GetClipboardTextFn(&g) : \"\";\n}\n\nvoid ImGui::SetClipboardText(const char* text)\n{\n    ImGuiContext& g = *GImGui;\n    if (g.PlatformIO.Platform_SetClipboardTextFn != NULL)\n        g.PlatformIO.Platform_SetClipboardTextFn(&g, text);\n}\n\nconst char* ImGui::GetVersion()\n{\n    return IMGUI_VERSION;\n}\n\nImGuiIO& ImGui::GetIO()\n{\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?\");\n    return GImGui->IO;\n}\n\n// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)\nImGuiIO& ImGui::GetIOEx(ImGuiContext* ctx)\n{\n    IM_ASSERT(ctx != NULL);\n    return ctx->IO;\n}\n\nImGuiPlatformIO& ImGui::GetPlatformIO()\n{\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext()?\");\n    return GImGui->PlatformIO;\n}\n\n// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()\nImDrawData* ImGui::GetDrawData()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiViewportP* viewport = g.Viewports[0];\n    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;\n}\n\ndouble ImGui::GetTime()\n{\n    return GImGui->Time;\n}\n\nint ImGui::GetFrameCount()\n{\n    return GImGui->FrameCount;\n}\n\nstatic ImDrawList* GetViewportBgFgDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)\n{\n    // Create the draw list on demand, because they are not frequently used for all viewports\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport->BgFgDrawLists));\n    ImDrawList* draw_list = viewport->BgFgDrawLists[drawlist_no];\n    if (draw_list == NULL)\n    {\n        draw_list = IM_NEW(ImDrawList)(&g.DrawListSharedData);\n        draw_list->_OwnerName = drawlist_name;\n        viewport->BgFgDrawLists[drawlist_no] = draw_list;\n    }\n\n    // Our ImDrawList system requires that there is always a command\n    if (viewport->BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount)\n    {\n        draw_list->_ResetForNewFrame();\n        draw_list->PushTextureID(g.IO.Fonts->TexID);\n        draw_list->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size, false);\n        viewport->BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount;\n    }\n    return draw_list;\n}\n\nImDrawList* ImGui::GetBackgroundDrawList(ImGuiViewport* viewport)\n{\n    return GetViewportBgFgDrawList((ImGuiViewportP*)viewport, 0, \"##Background\");\n}\n\nImDrawList* ImGui::GetBackgroundDrawList()\n{\n    ImGuiContext& g = *GImGui;\n    return GetBackgroundDrawList(g.Viewports[0]);\n}\n\nImDrawList* ImGui::GetForegroundDrawList(ImGuiViewport* viewport)\n{\n    return GetViewportBgFgDrawList((ImGuiViewportP*)viewport, 1, \"##Foreground\");\n}\n\nImDrawList* ImGui::GetForegroundDrawList()\n{\n    ImGuiContext& g = *GImGui;\n    return GetForegroundDrawList(g.Viewports[0]);\n}\n\nImDrawListSharedData* ImGui::GetDrawListSharedData()\n{\n    return &GImGui->DrawListSharedData;\n}\n\nvoid ImGui::StartMouseMovingWindow(ImGuiWindow* window)\n{\n    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.\n    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.\n    // This is because we want ActiveId to be set even when the window is not permitted to move.\n    ImGuiContext& g = *GImGui;\n    FocusWindow(window);\n    SetActiveID(window->MoveId, window);\n    if (g.IO.ConfigNavCursorVisibleAuto)\n        g.NavCursorVisible = false;\n    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindow->Pos;\n    g.ActiveIdNoClearOnFocusLoss = true;\n    SetActiveIdUsingAllKeyboardKeys();\n\n    bool can_move_window = true;\n    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))\n        can_move_window = false;\n    if (can_move_window)\n        g.MovingWindow = window;\n}\n\n// Handle mouse moving window\n// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()\n// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.\n// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,\n// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.\nvoid ImGui::UpdateMouseMovingWindowNewFrame()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.MovingWindow != NULL)\n    {\n        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).\n        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.\n        KeepAliveID(g.ActiveId);\n        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);\n        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;\n        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))\n        {\n            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;\n            SetWindowPos(moving_window, pos, ImGuiCond_Always);\n            FocusWindow(g.MovingWindow);\n        }\n        else\n        {\n            g.MovingWindow = NULL;\n            ClearActiveID();\n        }\n    }\n    else\n    {\n        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.\n        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)\n        {\n            KeepAliveID(g.ActiveId);\n            if (!g.IO.MouseDown[0])\n                ClearActiveID();\n        }\n    }\n}\n\n// Initiate focusing and moving window when clicking on empty space or title bar.\n// Initiate focusing window when clicking on a disabled item.\n// Handle left-click and right-click focus.\nvoid ImGui::UpdateMouseMovingWindowEndFrame()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.ActiveId != 0 || (g.HoveredId != 0 && !g.HoveredIdIsDisabled))\n        return;\n\n    // Unless we just made a window/popup appear\n    if (g.NavWindow && g.NavWindow->Appearing)\n        return;\n\n    // Click on empty space to focus window and start moving\n    // (after we're done with all our widgets)\n    if (g.IO.MouseClicked[0])\n    {\n        // Handle the edge case of a popup being closed while clicking in its empty space.\n        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.\n        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;\n        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);\n\n        if (root_window != NULL && !is_closed_popup)\n        {\n            StartMouseMovingWindow(g.HoveredWindow); //-V595\n\n            // Cancel moving if clicked outside of title bar\n            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)\n                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar))\n                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))\n                        g.MovingWindow = NULL;\n\n            // Cancel moving if clicked over an item which was disabled or inhibited by popups\n            // (when g.HoveredIdIsDisabled == true && g.HoveredId == 0 we are inhibited by popups, when g.HoveredIdIsDisabled == true && g.HoveredId != 0 we are over a disabled item)0 already)\n            if (g.HoveredIdIsDisabled)\n                g.MovingWindow = NULL;\n        }\n        else if (root_window == NULL && g.NavWindow != NULL)\n        {\n            // Clicking on void disable focus\n            FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);\n        }\n    }\n\n    // With right mouse button we close popups without changing focus based on where the mouse is aimed\n    // Instead, focus will be restored to the window under the bottom-most closed popup.\n    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)\n    if (g.IO.MouseClicked[1] && g.HoveredId == 0)\n    {\n        // Find the top-most window between HoveredWindow and the top-most Modal Window.\n        // This is where we can trim the popup stack.\n        ImGuiWindow* modal = GetTopMostPopupModal();\n        bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));\n        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);\n    }\n}\n\nstatic bool IsWindowActiveAndVisible(ImGuiWindow* window)\n{\n    return (window->Active) && (!window->Hidden);\n}\n\n// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)\nvoid ImGui::UpdateHoveredWindowAndCaptureFlags()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiIO& io = g.IO;\n\n    // FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING\n    // by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.\n    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));\n\n    // Find the window hovered by mouse:\n    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.\n    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.\n    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.\n    bool clear_hovered_windows = false;\n    FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow);\n    g.HoveredWindowBeforeClear = g.HoveredWindow;\n\n    // Modal windows prevents mouse from hovering behind them.\n    ImGuiWindow* modal_window = GetTopMostPopupModal();\n    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window))\n        clear_hovered_windows = true;\n\n    // Disabled mouse hovering (we don't currently clear MousePos, we could)\n    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)\n        clear_hovered_windows = true;\n\n    // We track click ownership. When clicked outside of a window the click is owned by the application and\n    // won't report hovering nor request capture even while dragging over our windows afterward.\n    const bool has_open_popup = (g.OpenPopupStack.Size > 0);\n    const bool has_open_modal = (modal_window != NULL);\n    int mouse_earliest_down = -1;\n    bool mouse_any_down = false;\n    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)\n    {\n        if (io.MouseClicked[i])\n        {\n            io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;\n            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;\n        }\n        mouse_any_down |= io.MouseDown[i];\n        if (io.MouseDown[i] || io.MouseReleased[i]) // Increase release frame for our evaluation of earliest button (#1392)\n            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])\n                mouse_earliest_down = i;\n    }\n    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];\n    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];\n\n    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.\n    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)\n    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;\n    if (!mouse_avail && !mouse_dragging_extern_payload)\n        clear_hovered_windows = true;\n\n    if (clear_hovered_windows)\n        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;\n\n    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)\n    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag\n    if (g.WantCaptureMouseNextFrame != -1)\n    {\n        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);\n    }\n    else\n    {\n        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;\n        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;\n    }\n\n    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)\n    io.WantCaptureKeyboard = false;\n    if ((io.ConfigFlags & ImGuiConfigFlags_NoKeyboard) == 0)\n    {\n        if ((g.ActiveId != 0) || (modal_window != NULL))\n            io.WantCaptureKeyboard = true;\n        else if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && io.ConfigNavCaptureKeyboard)\n            io.WantCaptureKeyboard = true;\n    }\n    if (g.WantCaptureKeyboardNextFrame != -1) // Manual override\n        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);\n\n    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible\n    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;\n}\n\n// Called once a frame. Followed by SetCurrentFont() which sets up the remaining data.\nstatic void SetupDrawListSharedData()\n{\n    ImGuiContext& g = *GImGui;\n    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);\n    for (ImGuiViewportP* viewport : g.Viewports)\n        virtual_space.Add(viewport->GetMainRect());\n    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();\n    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;\n    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);\n    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;\n    if (g.Style.AntiAliasedLines)\n        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;\n    if (g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts->Flags & ImFontAtlasFlags_NoBakedLines))\n        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;\n    if (g.Style.AntiAliasedFill)\n        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;\n    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)\n        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;\n}\n\nvoid ImGui::NewFrame()\n{\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?\");\n    ImGuiContext& g = *GImGui;\n\n    // Remove pending delete hooks before frame start.\n    // This deferred removal avoid issues of removal while iterating the hook vector\n    for (int n = g.Hooks.Size - 1; n >= 0; n--)\n        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)\n            g.Hooks.erase(&g.Hooks[n]);\n\n    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);\n\n    // Check and assert for various common IO and Configuration mistakes\n    ErrorCheckNewFrameSanityChecks();\n\n    // Load settings on first frame, save settings when modified (after a delay)\n    UpdateSettings();\n\n    g.Time += g.IO.DeltaTime;\n    g.WithinFrameScope = true;\n    g.FrameCount += 1;\n    g.TooltipOverrideCount = 0;\n    g.WindowsActiveCount = 0;\n    g.MenusIdSubmittedThisFrame.resize(0);\n\n    // Calculate frame-rate for the user, as a purely luxurious feature\n    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];\n    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;\n    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);\n    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));\n    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;\n\n    // Process input queue (trickle as many events as possible), turn events into writes to IO structure\n    g.InputEventsTrail.resize(0);\n    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);\n\n    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)\n    UpdateViewportsNewFrame();\n\n    // Setup current font and draw list shared data\n    g.IO.Fonts->Locked = true;\n    SetupDrawListSharedData();\n    SetCurrentFont(GetDefaultFont());\n    IM_ASSERT(g.Font->IsLoaded());\n\n    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.\n    for (ImGuiViewportP* viewport : g.Viewports)\n        viewport->DrawDataP.Valid = false;\n\n    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent\n    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)\n        KeepAliveID(g.DragDropPayload.SourceId);\n\n    // [DEBUG]\n    if (!g.IO.ConfigDebugHighlightIdConflicts || !g.IO.KeyCtrl) // Count is locked while holding CTRL\n        g.DebugDrawIdConflicts = 0;\n    if (g.IO.ConfigDebugHighlightIdConflicts && g.HoveredIdPreviousFrameItemCount > 1)\n        g.DebugDrawIdConflicts = g.HoveredIdPreviousFrame;\n\n    // Update HoveredId data\n    if (!g.HoveredIdPreviousFrame)\n        g.HoveredIdTimer = 0.0f;\n    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))\n        g.HoveredIdNotActiveTimer = 0.0f;\n    if (g.HoveredId)\n        g.HoveredIdTimer += g.IO.DeltaTime;\n    if (g.HoveredId && g.ActiveId != g.HoveredId)\n        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;\n    g.HoveredIdPreviousFrame = g.HoveredId;\n    g.HoveredIdPreviousFrameItemCount = 0;\n    g.HoveredId = 0;\n    g.HoveredIdAllowOverlap = false;\n    g.HoveredIdIsDisabled = false;\n\n    // Clear ActiveID if the item is not alive anymore.\n    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().\n    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.\n    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)\n    {\n        IMGUI_DEBUG_LOG_ACTIVEID(\"NewFrame(): ClearActiveID() because it isn't marked alive anymore!\\n\");\n        ClearActiveID();\n    }\n\n    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)\n    if (g.ActiveId)\n        g.ActiveIdTimer += g.IO.DeltaTime;\n    g.LastActiveIdTimer += g.IO.DeltaTime;\n    g.ActiveIdPreviousFrame = g.ActiveId;\n    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;\n    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;\n    g.ActiveIdIsAlive = 0;\n    g.ActiveIdHasBeenEditedThisFrame = false;\n    g.ActiveIdPreviousFrameIsAlive = false;\n    g.ActiveIdIsJustActivated = false;\n    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)\n        g.TempInputId = 0;\n    if (g.ActiveId == 0)\n    {\n        g.ActiveIdUsingNavDirMask = 0x00;\n        g.ActiveIdUsingAllKeyboardKeys = false;\n    }\n\n    // Record when we have been stationary as this state is preserved while over same item.\n    // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.\n    // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.\n    if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)\n        g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;\n    else if (g.HoverItemDelayId == 0)\n        g.HoverItemUnlockedStationaryId = 0;\n    if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)\n        g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;\n    else if (g.HoveredWindow == NULL)\n        g.HoverWindowUnlockedStationaryId = 0;\n\n    // Update hover delay for IsItemHovered() with delays and tooltips\n    g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;\n    if (g.HoverItemDelayId != 0)\n    {\n        g.HoverItemDelayTimer += g.IO.DeltaTime;\n        g.HoverItemDelayClearTimer = 0.0f;\n        g.HoverItemDelayId = 0;\n    }\n    else if (g.HoverItemDelayTimer > 0.0f)\n    {\n        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps\n        // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.\n        g.HoverItemDelayClearTimer += g.IO.DeltaTime;\n        if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate\n            g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.\n    }\n\n    // Drag and drop\n    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;\n    g.DragDropAcceptIdCurr = 0;\n    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;\n    g.DragDropWithinSource = false;\n    g.DragDropWithinTarget = false;\n    g.DragDropHoldJustPressedId = 0;\n    g.TooltipPreviousWindow = NULL;\n\n    // Close popups on focus lost (currently wip/opt-in)\n    //if (g.IO.AppFocusLost)\n    //    ClosePopupsExceptModals();\n\n    // Update keyboard input state\n    UpdateKeyboardInputs();\n\n    //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));\n    //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));\n    //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));\n    //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));\n\n    // Update keyboard/gamepad navigation\n    NavUpdate();\n\n    // Update mouse input state\n    UpdateMouseInputs();\n\n    // Mark all windows as not visible and compact unused memory.\n    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);\n    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;\n    for (ImGuiWindow* window : g.Windows)\n    {\n        window->WasActive = window->Active;\n        window->Active = false;\n        window->WriteAccessed = false;\n        window->BeginCountPreviousFrame = window->BeginCount;\n        window->BeginCount = 0;\n\n        // Garbage collect transient buffers of recently unused windows\n        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)\n            GcCompactTransientWindowBuffers(window);\n    }\n\n    // Find hovered window\n    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)\n    // (currently needs to be done after the WasActive=Active loop and FindHoveredWindowEx uses ->Active)\n    UpdateHoveredWindowAndCaptureFlags();\n\n    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)\n    UpdateMouseMovingWindowNewFrame();\n\n    // Background darkening/whitening\n    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))\n        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);\n    else\n        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);\n\n    g.MouseCursor = ImGuiMouseCursor_Arrow;\n    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;\n\n    // Platform IME data: reset for the frame\n    g.PlatformImeDataPrev = g.PlatformImeData;\n    g.PlatformImeData.WantVisible = false;\n\n    // Mouse wheel scrolling, scale\n    UpdateMouseWheel();\n\n    // Garbage collect transient buffers of recently unused tables\n    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)\n        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)\n            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));\n    for (ImGuiTableTempData& table_temp_data : g.TablesTempData)\n        if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)\n            TableGcCompactTransientBuffers(&table_temp_data);\n    if (g.GcCompactAll)\n        GcCompactTransientMiscBuffers();\n    g.GcCompactAll = false;\n\n    // Closing the focused window restore focus to the first active root window in descending z-order\n    if (g.NavWindow && !g.NavWindow->WasActive)\n        FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);\n\n    // No window should be open at the beginning of the frame.\n    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.\n    g.CurrentWindowStack.resize(0);\n    g.BeginPopupStack.resize(0);\n    g.ItemFlagsStack.resize(0);\n    g.ItemFlagsStack.push_back(ImGuiItemFlags_AutoClosePopups); // Default flags\n    g.CurrentItemFlags = g.ItemFlagsStack.back();\n    g.GroupStack.resize(0);\n\n    // [DEBUG] Update debug features\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    UpdateDebugToolItemPicker();\n    UpdateDebugToolStackQueries();\n    UpdateDebugToolFlashStyleColor();\n    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)\n    {\n        g.DebugLocateId = 0;\n        g.DebugBreakInLocateId = false;\n    }\n    if (g.DebugLogAutoDisableFrames > 0 && --g.DebugLogAutoDisableFrames == 0)\n    {\n        DebugLog(\"(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\\n\");\n        g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;\n        g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;\n    }\n#endif\n\n    // Create implicit/fallback window - which we will only render it if the user has added something to it.\n    // We don't use \"Debug\" to avoid colliding with user trying to create a \"Debug\" window with custom flags.\n    // This fallback is particularly important as it prevents ImGui:: calls from crashing.\n    g.WithinFrameScopeWithImplicitWindow = true;\n    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);\n    Begin(\"Debug##Default\");\n    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);\n\n    // Store stack sizes\n    g.ErrorCountCurrentFrame = 0;\n    ErrorRecoveryStoreState(&g.StackSizesInNewFrame);\n\n    // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,\n    // allowing to validate correct Begin/End behavior in user code.\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (g.IO.ConfigDebugBeginReturnValueLoop)\n        g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);\n    else\n        g.DebugBeginReturnValueCullDepth = -1;\n#endif\n\n    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);\n}\n\n// FIXME: Add a more explicit sort order in the window structure.\nstatic int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)\n{\n    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;\n    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;\n    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))\n        return d;\n    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))\n        return d;\n    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);\n}\n\nstatic void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)\n{\n    out_sorted_windows->push_back(window);\n    if (window->Active)\n    {\n        int count = window->DC.ChildWindows.Size;\n        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);\n        for (int i = 0; i < count; i++)\n        {\n            ImGuiWindow* child = window->DC.ChildWindows[i];\n            if (child->Active)\n                AddWindowToSortBuffer(out_sorted_windows, child);\n        }\n    }\n}\n\nstatic void AddWindowToDrawData(ImGuiWindow* window, int layer)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiViewportP* viewport = g.Viewports[0];\n    g.IO.MetricsRenderWindows++;\n    if (window->DrawList->_Splitter._Count > 1)\n        window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.\n    ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);\n    for (ImGuiWindow* child : window->DC.ChildWindows)\n        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active\n            AddWindowToDrawData(child, layer);\n}\n\nstatic inline int GetWindowDisplayLayer(ImGuiWindow* window)\n{\n    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;\n}\n\n// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)\nstatic inline void AddRootWindowToDrawData(ImGuiWindow* window)\n{\n    AddWindowToDrawData(window, GetWindowDisplayLayer(window));\n}\n\nstatic void FlattenDrawDataIntoSingleLayer(ImDrawDataBuilder* builder)\n{\n    int n = builder->Layers[0]->Size;\n    int full_size = n;\n    for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)\n        full_size += builder->Layers[i]->Size;\n    builder->Layers[0]->resize(full_size);\n    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++)\n    {\n        ImVector<ImDrawList*>* layer = builder->Layers[layer_n];\n        if (layer->empty())\n            continue;\n        memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList*));\n        n += layer->Size;\n        layer->resize(0);\n    }\n}\n\nstatic void InitViewportDrawData(ImGuiViewportP* viewport)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    ImDrawData* draw_data = &viewport->DrawDataP;\n\n    viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;\n    viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;\n    viewport->DrawDataBuilder.Layers[0]->resize(0);\n    viewport->DrawDataBuilder.Layers[1]->resize(0);\n\n    draw_data->Valid = true;\n    draw_data->CmdListsCount = 0;\n    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;\n    draw_data->DisplayPos = viewport->Pos;\n    draw_data->DisplaySize = viewport->Size;\n    draw_data->FramebufferScale = io.DisplayFramebufferScale;\n    draw_data->OwnerViewport = viewport;\n}\n\n// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.\n// - When using this function it is sane to ensure that float are perfectly rounded to integer values,\n//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.\n// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():\n//   some frequently called functions which to modify both channels and clipping simultaneously tend to use the\n//   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.\n// - This is analoguous to PushFont()/PopFont() in the sense that are a mixing a global stack and a window stack,\n//   which in the case of ClipRect is not so problematic but tends to be more restrictive for fonts.\nvoid ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);\n    window->ClipRect = window->DrawList->_ClipRectStack.back();\n}\n\nvoid ImGui::PopClipRect()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    window->DrawList->PopClipRect();\n    window->ClipRect = window->DrawList->_ClipRectStack.back();\n}\n\nstatic void ImGui::RenderDimmedBackgroundBehindWindow(ImGuiWindow* window, ImU32 col)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    ImGuiViewportP* viewport = (ImGuiViewportP*)GetMainViewport();\n    ImRect viewport_rect = viewport->GetMainRect();\n\n    // Draw behind window by moving the draw command at the FRONT of the draw list\n    {\n        // We've already called AddWindowToDrawData() which called DrawList->ChannelsMerge() on DockNodeHost windows,\n        // and draw list have been trimmed already, hence the explicit recreation of a draw command if missing.\n        // FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.\n        ImDrawList* draw_list = window->RootWindow->DrawList;\n        if (draw_list->CmdBuffer.Size == 0)\n            draw_list->AddDrawCmd();\n        draw_list->PushClipRect(viewport_rect.Min - ImVec2(1, 1), viewport_rect.Max + ImVec2(1, 1), false); // FIXME: Need to stricty ensure ImDrawCmd are not merged (ElemCount==6 checks below will verify that)\n        draw_list->AddRectFilled(viewport_rect.Min, viewport_rect.Max, col);\n        ImDrawCmd cmd = draw_list->CmdBuffer.back();\n        IM_ASSERT(cmd.ElemCount == 6);\n        draw_list->CmdBuffer.pop_back();\n        draw_list->CmdBuffer.push_front(cmd);\n        draw_list->AddDrawCmd(); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.\n        draw_list->PopClipRect();\n    }\n}\n\nImGuiWindow* ImGui::FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* parent_window)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* bottom_most_visible_window = parent_window;\n    for (int i = FindWindowDisplayIndex(parent_window); i >= 0; i--)\n    {\n        ImGuiWindow* window = g.Windows[i];\n        if (window->Flags & ImGuiWindowFlags_ChildWindow)\n            continue;\n        if (!IsWindowWithinBeginStackOf(window, parent_window))\n            break;\n        if (IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window))\n            bottom_most_visible_window = window;\n    }\n    return bottom_most_visible_window;\n}\n\nstatic void ImGui::RenderDimmedBackgrounds()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();\n    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)\n        return;\n    const bool dim_bg_for_modal = (modal_window != NULL);\n    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);\n    if (!dim_bg_for_modal && !dim_bg_for_window_list)\n        return;\n\n    if (dim_bg_for_modal)\n    {\n        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.\n        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);\n        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window->DC.ModalDimBgColor, g.DimBgRatio));\n    }\n    else if (dim_bg_for_window_list)\n    {\n        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window\n        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));\n\n        // Draw border around CTRL+Tab target window\n        ImGuiWindow* window = g.NavWindowingTargetAnim;\n        ImGuiViewport* viewport = GetMainViewport();\n        float distance = g.FontSize;\n        ImRect bb = window->Rect();\n        bb.Expand(distance);\n        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)\n            bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward\n        if (window->DrawList->CmdBuffer.Size == 0)\n            window->DrawList->AddDrawCmd();\n        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);\n        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);\n        window->DrawList->PopClipRect();\n    }\n}\n\n// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.\nvoid ImGui::EndFrame()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.Initialized);\n\n    // Don't process EndFrame() multiple times.\n    if (g.FrameCountEnded == g.FrameCount)\n        return;\n    IM_ASSERT(g.WithinFrameScope && \"Forgot to call ImGui::NewFrame()?\");\n\n    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);\n\n    // [EXPERIMENTAL] Recover from errors\n    if (g.IO.ConfigErrorRecovery)\n        ErrorRecoveryTryToRecoverState(&g.StackSizesInNewFrame);\n    ErrorCheckEndFrameSanityChecks();\n    ErrorCheckEndFrameFinalizeErrorTooltip();\n\n    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)\n    ImGuiPlatformImeData* ime_data = &g.PlatformImeData;\n    if (g.PlatformIO.Platform_SetImeDataFn != NULL && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)\n    {\n        IMGUI_DEBUG_LOG_IO(\"[io] Calling Platform_SetImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\\n\", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);\n        ImGuiViewport* viewport = GetMainViewport();\n        g.PlatformIO.Platform_SetImeDataFn(&g, viewport, ime_data);\n    }\n\n    // Hide implicit/fallback \"Debug\" window if it hasn't been used\n    g.WithinFrameScopeWithImplicitWindow = false;\n    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)\n        g.CurrentWindow->Active = false;\n    End();\n\n    // Update navigation: CTRL+Tab, wrap-around requests\n    NavEndFrame();\n\n    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)\n    if (g.DragDropActive)\n    {\n        bool is_delivered = g.DragDropPayload.Delivery;\n        bool is_elapsed = (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_PayloadAutoExpire) || g.DragDropMouseButton == -1 || !IsMouseDown(g.DragDropMouseButton));\n        if (is_delivered || is_elapsed)\n            ClearDragDrop();\n    }\n\n    // Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.\n    // If you want to handle source item disappearing: instead of submitting your description tooltip\n    // in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot\n    // (e.g. end of your item loop, or before EndFrame) by reading payload data.\n    // In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.\n    if (g.DragDropActive && g.DragDropSourceFrameCount + 1 < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))\n    {\n        g.DragDropWithinSource = true;\n        SetTooltip(\"...\");\n        g.DragDropWithinSource = false;\n    }\n\n    // End frame\n    g.WithinFrameScope = false;\n    g.FrameCountEnded = g.FrameCount;\n\n    // Initiate moving window + handle left-click and right-click focus\n    UpdateMouseMovingWindowEndFrame();\n\n    // Sort the window list so that all child windows are after their parent\n    // We cannot do that on FocusWindow() because children may not exist yet\n    g.WindowsTempSortBuffer.resize(0);\n    g.WindowsTempSortBuffer.reserve(g.Windows.Size);\n    for (ImGuiWindow* window : g.Windows)\n    {\n        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it\n            continue;\n        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);\n    }\n\n    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.\n    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);\n    g.Windows.swap(g.WindowsTempSortBuffer);\n    g.IO.MetricsActiveWindows = g.WindowsActiveCount;\n\n    // Unlock font atlas\n    g.IO.Fonts->Locked = false;\n\n    // Clear Input data for next frame\n    g.IO.MousePosPrev = g.IO.MousePos;\n    g.IO.AppFocusLost = false;\n    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;\n    g.IO.InputQueueCharacters.resize(0);\n\n    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);\n}\n\n// Prepare the data for rendering so you can call GetDrawData()\n// (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:\n// it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)\nvoid ImGui::Render()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.Initialized);\n\n    if (g.FrameCountEnded != g.FrameCount)\n        EndFrame();\n    if (g.FrameCountRendered == g.FrameCount)\n        return;\n    g.FrameCountRendered = g.FrameCount;\n\n    g.IO.MetricsRenderWindows = 0;\n    CallContextHooks(&g, ImGuiContextHookType_RenderPre);\n\n    // Add background ImDrawList (for each active viewport)\n    for (ImGuiViewportP* viewport : g.Viewports)\n    {\n        InitViewportDrawData(viewport);\n        if (viewport->BgFgDrawLists[0] != NULL)\n            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));\n    }\n\n    // Draw modal/window whitening backgrounds\n    RenderDimmedBackgrounds();\n\n    // Add ImDrawList to render\n    ImGuiWindow* windows_to_render_top_most[2];\n    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;\n    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);\n    for (ImGuiWindow* window : g.Windows)\n    {\n        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive \"warning C6011: Dereferencing NULL pointer 'window'\"\n        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])\n            AddRootWindowToDrawData(window);\n    }\n    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)\n        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window\n            AddRootWindowToDrawData(windows_to_render_top_most[n]);\n\n    // Draw software mouse cursor if requested by io.MouseDrawCursor flag\n    if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)\n        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));\n\n    // Setup ImDrawData structures for end-user\n    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;\n    for (ImGuiViewportP* viewport : g.Viewports)\n    {\n        FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);\n\n        // Add foreground ImDrawList (for each active viewport)\n        if (viewport->BgFgDrawLists[1] != NULL)\n            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));\n\n        // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).\n        ImDrawData* draw_data = &viewport->DrawDataP;\n        IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);\n        for (ImDrawList* draw_list : draw_data->CmdLists)\n            draw_list->_PopUnusedDrawCmd();\n\n        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;\n        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;\n    }\n\n    CallContextHooks(&g, ImGuiContextHookType_RenderPost);\n}\n\n// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.\n// CalcTextSize(\"\") should return ImVec2(0.0f, g.FontSize)\nImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)\n{\n    ImGuiContext& g = *GImGui;\n\n    const char* text_display_end;\n    if (hide_text_after_double_hash)\n        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string\n    else\n        text_display_end = text_end;\n\n    ImFont* font = g.Font;\n    const float font_size = g.FontSize;\n    if (text == text_display_end)\n        return ImVec2(0.0f, font_size);\n    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);\n\n    // Round\n    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.\n    // FIXME: Investigate using ceilf or e.g.\n    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c\n    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html\n    text_size.x = IM_TRUNC(text_size.x + 0.99999f);\n\n    return text_size;\n}\n\n// Find window given position, search front-to-back\n// - Typically write output back to g.HoveredWindow and g.HoveredWindowUnderMovingWindow.\n// - FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically\n//   with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is\n//   called, aka before the next Begin(). Moving window isn't affected.\n// - The 'find_first_and_in_any_viewport = true' mode is only used by TestEngine. It is simpler to maintain here.\nvoid ImGui::FindHoveredWindowEx(const ImVec2& pos, bool find_first_and_in_any_viewport, ImGuiWindow** out_hovered_window, ImGuiWindow** out_hovered_window_under_moving_window)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* hovered_window = NULL;\n    ImGuiWindow* hovered_window_under_moving_window = NULL;\n\n    if (find_first_and_in_any_viewport == false && g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))\n        hovered_window = g.MovingWindow;\n\n    ImVec2 padding_regular = g.Style.TouchExtraPadding;\n    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;\n    for (int i = g.Windows.Size - 1; i >= 0; i--)\n    {\n        ImGuiWindow* window = g.Windows[i];\n        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.\n        if (!window->WasActive || window->Hidden)\n            continue;\n        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)\n            continue;\n\n        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)\n        ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;\n        if (!window->OuterRectClipped.ContainsWithPad(pos, hit_padding))\n            continue;\n\n        // Support for one rectangular hole in any given window\n        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)\n        if (window->HitTestHoleSize.x != 0)\n        {\n            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);\n            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);\n            if (ImRect(hole_pos, hole_pos + hole_size).Contains(pos))\n                continue;\n        }\n\n        if (find_first_and_in_any_viewport)\n        {\n            hovered_window = window;\n            break;\n        }\n        else\n        {\n            if (hovered_window == NULL)\n                hovered_window = window;\n            IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.\n            if (hovered_window_under_moving_window == NULL && (!g.MovingWindow || window->RootWindow != g.MovingWindow->RootWindow))\n                hovered_window_under_moving_window = window;\n            if (hovered_window && hovered_window_under_moving_window)\n                break;\n        }\n    }\n\n    *out_hovered_window = hovered_window;\n    if (out_hovered_window_under_moving_window != NULL)\n        *out_hovered_window_under_moving_window = hovered_window_under_moving_window;\n}\n\nbool ImGui::IsItemActive()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.ActiveId)\n        return g.ActiveId == g.LastItemData.ID;\n    return false;\n}\n\nbool ImGui::IsItemActivated()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.ActiveId)\n        if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)\n            return true;\n    return false;\n}\n\nbool ImGui::IsItemDeactivated()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDeactivated)\n        return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Deactivated) != 0;\n    return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID);\n}\n\nbool ImGui::IsItemDeactivatedAfterEdit()\n{\n    ImGuiContext& g = *GImGui;\n    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));\n}\n\n// == (GetItemID() == GetFocusID() && GetFocusID() != 0)\nbool ImGui::IsItemFocused()\n{\n    ImGuiContext& g = *GImGui;\n    return g.NavId == g.LastItemData.ID && g.NavId != 0;\n}\n\n// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!\n// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.\nbool ImGui::IsItemClicked(ImGuiMouseButton mouse_button)\n{\n    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);\n}\n\nbool ImGui::IsItemToggledOpen()\n{\n    ImGuiContext& g = *GImGui;\n    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledOpen) ? true : false;\n}\n\n// Call after a Selectable() or TreeNode() involved in multi-selection.\n// Useful if you need the per-item information before reaching EndMultiSelect(), e.g. for rendering purpose.\n// This is only meant to be called inside a BeginMultiSelect()/EndMultiSelect() block.\n// (Outside of multi-select, it would be misleading/ambiguous to report this signal, as widgets\n// return e.g. a pressed event and user code is in charge of altering selection in ways we cannot predict.)\nbool ImGui::IsItemToggledSelection()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.CurrentMultiSelect != NULL); // Can only be used inside a BeginMultiSelect()/EndMultiSelect()\n    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;\n}\n\n// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,\n// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!\n// Refer to FAQ entry \"How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?\" for details.\nbool ImGui::IsAnyItemHovered()\n{\n    ImGuiContext& g = *GImGui;\n    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;\n}\n\nbool ImGui::IsAnyItemActive()\n{\n    ImGuiContext& g = *GImGui;\n    return g.ActiveId != 0;\n}\n\nbool ImGui::IsAnyItemFocused()\n{\n    ImGuiContext& g = *GImGui;\n    return g.NavId != 0 && g.NavCursorVisible;\n}\n\nbool ImGui::IsItemVisible()\n{\n    ImGuiContext& g = *GImGui;\n    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible) != 0;\n}\n\nbool ImGui::IsItemEdited()\n{\n    ImGuiContext& g = *GImGui;\n    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Edited) != 0;\n}\n\n// Allow next item to be overlapped by subsequent items.\n// This works by requiring HoveredId to match for two subsequent frames,\n// so if a following items overwrite it our interactions will naturally be disabled.\nvoid ImGui::SetNextItemAllowOverlap()\n{\n    ImGuiContext& g = *GImGui;\n    g.NextItemData.ItemFlags |= ImGuiItemFlags_AllowOverlap;\n}\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.\n// FIXME-LEGACY: Use SetNextItemAllowOverlap() *before* your item instead.\nvoid ImGui::SetItemAllowOverlap()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiID id = g.LastItemData.ID;\n    if (g.HoveredId == id)\n        g.HoveredIdAllowOverlap = true;\n    if (g.ActiveId == id) // Before we made this obsolete, most calls to SetItemAllowOverlap() used to avoid this path by testing g.ActiveId != id.\n        g.ActiveIdAllowOverlap = true;\n}\n#endif\n\n// This is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations.\n// FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version if needed?\nvoid ImGui::SetActiveIdUsingAllKeyboardKeys()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.ActiveId != 0);\n    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;\n    g.ActiveIdUsingAllKeyboardKeys = true;\n    NavMoveRequestCancel();\n}\n\nImGuiID ImGui::GetItemID()\n{\n    ImGuiContext& g = *GImGui;\n    return g.LastItemData.ID;\n}\n\nImVec2 ImGui::GetItemRectMin()\n{\n    ImGuiContext& g = *GImGui;\n    return g.LastItemData.Rect.Min;\n}\n\nImVec2 ImGui::GetItemRectMax()\n{\n    ImGuiContext& g = *GImGui;\n    return g.LastItemData.Rect.Max;\n}\n\nImVec2 ImGui::GetItemRectSize()\n{\n    ImGuiContext& g = *GImGui;\n    return g.LastItemData.Rect.GetSize();\n}\n\n// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border = false' parameter instead of 'ImGuiChildFlags child_flags = 0'.\n// ImGuiChildFlags_Borders is defined as always == 1 in order to allow old code passing 'true'. Read comments in imgui.h for details!\nbool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags)\n{\n    ImGuiID id = GetCurrentWindow()->GetID(str_id);\n    return BeginChildEx(str_id, id, size_arg, child_flags, window_flags);\n}\n\nbool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags)\n{\n    return BeginChildEx(NULL, id, size_arg, child_flags, window_flags);\n}\n\nbool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* parent_window = g.CurrentWindow;\n    IM_ASSERT(id != 0);\n\n    // Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.\n    const ImGuiChildFlags ImGuiChildFlags_SupportedMask_ = ImGuiChildFlags_Borders | ImGuiChildFlags_AlwaysUseWindowPadding | ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY | ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_FrameStyle | ImGuiChildFlags_NavFlattened;\n    IM_UNUSED(ImGuiChildFlags_SupportedMask_);\n    IM_ASSERT((child_flags & ~ImGuiChildFlags_SupportedMask_) == 0 && \"Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?\");\n    IM_ASSERT((window_flags & ImGuiWindowFlags_AlwaysAutoResize) == 0 && \"Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!\");\n    if (child_flags & ImGuiChildFlags_AlwaysAutoResize)\n    {\n        IM_ASSERT((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0 && \"Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!\");\n        IM_ASSERT((child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY)) != 0 && \"Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!\");\n    }\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    if (window_flags & ImGuiWindowFlags_AlwaysUseWindowPadding)\n        child_flags |= ImGuiChildFlags_AlwaysUseWindowPadding;\n    if (window_flags & ImGuiWindowFlags_NavFlattened)\n        child_flags |= ImGuiChildFlags_NavFlattened;\n#endif\n    if (child_flags & ImGuiChildFlags_AutoResizeX)\n        child_flags &= ~ImGuiChildFlags_ResizeX;\n    if (child_flags & ImGuiChildFlags_AutoResizeY)\n        child_flags &= ~ImGuiChildFlags_ResizeY;\n\n    // Set window flags\n    window_flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar;\n    window_flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove); // Inherit the NoMove flag\n    if (child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize))\n        window_flags |= ImGuiWindowFlags_AlwaysAutoResize;\n    if ((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0)\n        window_flags |= ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;\n\n    // Special framed style\n    if (child_flags & ImGuiChildFlags_FrameStyle)\n    {\n        PushStyleColor(ImGuiCol_ChildBg, g.Style.Colors[ImGuiCol_FrameBg]);\n        PushStyleVar(ImGuiStyleVar_ChildRounding, g.Style.FrameRounding);\n        PushStyleVar(ImGuiStyleVar_ChildBorderSize, g.Style.FrameBorderSize);\n        PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.FramePadding);\n        child_flags |= ImGuiChildFlags_Borders | ImGuiChildFlags_AlwaysUseWindowPadding;\n        window_flags |= ImGuiWindowFlags_NoMove;\n    }\n\n    // Forward size\n    // Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.\n    // (the alternative would to store conditional flags per axis, which is possible but more code)\n    const ImVec2 size_avail = GetContentRegionAvail();\n    const ImVec2 size_default((child_flags & ImGuiChildFlags_AutoResizeX) ? 0.0f : size_avail.x, (child_flags & ImGuiChildFlags_AutoResizeY) ? 0.0f : size_avail.y);\n    ImVec2 size = CalcItemSize(size_arg, size_default.x, size_default.y);\n\n    // A SetNextWindowSize() call always has priority (#8020)\n    // (since the code in Begin() never supported SizeVal==0.0f aka auto-resize via SetNextWindowSize() call, we don't support it here for now)\n    // FIXME: We only support ImGuiCond_Always in this path. Supporting other paths would requires to obtain window pointer.\n    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) != 0 && (g.NextWindowData.SizeCond & ImGuiCond_Always) != 0)\n    {\n        if (g.NextWindowData.SizeVal.x > 0.0f)\n        {\n            size.x = g.NextWindowData.SizeVal.x;\n            child_flags &= ~ImGuiChildFlags_ResizeX;\n        }\n        if (g.NextWindowData.SizeVal.y > 0.0f)\n        {\n            size.y = g.NextWindowData.SizeVal.y;\n            child_flags &= ~ImGuiChildFlags_ResizeY;\n        }\n    }\n    SetNextWindowSize(size);\n\n    // Forward child flags (we allow prior settings to merge but it'll only work for adding flags)\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags)\n        g.NextWindowData.ChildFlags |= child_flags;\n    else\n        g.NextWindowData.ChildFlags = child_flags;\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasChildFlags;\n\n    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.\n    // FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.\n    // e.g. \"ParentName###ParentIdentifier/ChildName###ChildIdentifier\" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.\n    const char* temp_window_name;\n    /*if (name && parent_window->IDStack.back() == parent_window->ID)\n        ImFormatStringToTempBuffer(&temp_window_name, NULL, \"%s/%s\", parent_window->Name, name); // May omit ID if in root of ID stack\n    else*/\n    if (name)\n        ImFormatStringToTempBuffer(&temp_window_name, NULL, \"%s/%s_%08X\", parent_window->Name, name, id);\n    else\n        ImFormatStringToTempBuffer(&temp_window_name, NULL, \"%s/%08X\", parent_window->Name, id);\n\n    // Set style\n    const float backup_border_size = g.Style.ChildBorderSize;\n    if ((child_flags & ImGuiChildFlags_Borders) == 0)\n        g.Style.ChildBorderSize = 0.0f;\n\n    // Begin into window\n    const bool ret = Begin(temp_window_name, NULL, window_flags);\n\n    // Restore style\n    g.Style.ChildBorderSize = backup_border_size;\n    if (child_flags & ImGuiChildFlags_FrameStyle)\n    {\n        PopStyleVar(3);\n        PopStyleColor();\n    }\n\n    ImGuiWindow* child_window = g.CurrentWindow;\n    child_window->ChildId = id;\n\n    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.\n    // While this is not really documented/defined, it seems that the expected thing to do.\n    if (child_window->BeginCount == 1)\n        parent_window->DC.CursorPos = child_window->Pos;\n\n    // Process navigation-in immediately so NavInit can run on first frame\n    // Can enter a child if (A) it has navigable items or (B) it can be scrolled.\n    const ImGuiID temp_id_for_activation = ImHashStr(\"##Child\", 0, id);\n    if (g.ActiveId == temp_id_for_activation)\n        ClearActiveID();\n    if (g.NavActivateId == id && !(child_flags & ImGuiChildFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY))\n    {\n        FocusWindow(child_window);\n        NavInitWindow(child_window, false);\n        SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item\n        g.ActiveIdSource = g.NavInputSource;\n    }\n    return ret;\n}\n\nvoid ImGui::EndChild()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* child_window = g.CurrentWindow;\n\n    const ImGuiID backup_within_end_child_id = g.WithinEndChildID;\n    IM_ASSERT(child_window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls\n\n    g.WithinEndChildID = child_window->ID;\n    ImVec2 child_size = child_window->Size;\n    End();\n    if (child_window->BeginCount == 1)\n    {\n        ImGuiWindow* parent_window = g.CurrentWindow;\n        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + child_size);\n        ItemSize(child_size);\n        const bool nav_flattened = (child_window->ChildFlags & ImGuiChildFlags_NavFlattened) != 0;\n        if ((child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY) && !nav_flattened)\n        {\n            ItemAdd(bb, child_window->ChildId);\n            RenderNavCursor(bb, child_window->ChildId);\n\n            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)\n            if (child_window->DC.NavLayersActiveMask == 0 && child_window == g.NavWindow)\n                RenderNavCursor(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavRenderCursorFlags_Compact);\n        }\n        else\n        {\n            // Not navigable into\n            // - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.\n            // - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.\n            ItemAdd(bb, child_window->ChildId, NULL, ImGuiItemFlags_NoNav);\n\n            // But when flattened we directly reach items, adjust active layer mask accordingly\n            if (nav_flattened)\n                parent_window->DC.NavLayersActiveMaskNext |= child_window->DC.NavLayersActiveMaskNext;\n        }\n        if (g.HoveredWindow == child_window)\n            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;\n    }\n    g.WithinEndChildID = backup_within_end_child_id;\n    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return\n}\n\nstatic void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)\n{\n    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);\n    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);\n    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);\n}\n\nImGuiWindow* ImGui::FindWindowByID(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);\n}\n\nImGuiWindow* ImGui::FindWindowByName(const char* name)\n{\n    ImGuiID id = ImHashStr(name);\n    return FindWindowByID(id);\n}\n\nstatic void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)\n{\n    window->Pos = ImTrunc(ImVec2(settings->Pos.x, settings->Pos.y));\n    if (settings->Size.x > 0 && settings->Size.y > 0)\n        window->Size = window->SizeFull = ImTrunc(ImVec2(settings->Size.x, settings->Size.y));\n    window->Collapsed = settings->Collapsed;\n}\n\nstatic void InitOrLoadWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)\n{\n    // Initial window state with e.g. default/arbitrary window position\n    // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.\n    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();\n    window->Pos = main_viewport->Pos + ImVec2(60, 60);\n    window->Size = window->SizeFull = ImVec2(0, 0);\n    window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;\n\n    if (settings != NULL)\n    {\n        SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);\n        ApplyWindowSettings(window, settings);\n    }\n    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values\n\n    if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)\n    {\n        window->AutoFitFramesX = window->AutoFitFramesY = 2;\n        window->AutoFitOnlyGrows = false;\n    }\n    else\n    {\n        if (window->Size.x <= 0.0f)\n            window->AutoFitFramesX = 2;\n        if (window->Size.y <= 0.0f)\n            window->AutoFitFramesY = 2;\n        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);\n    }\n}\n\nstatic ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)\n{\n    // Create window the first time\n    //IMGUI_DEBUG_LOG(\"CreateNewWindow '%s', flags = 0x%08X\\n\", name, flags);\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);\n    window->Flags = flags;\n    g.WindowsById.SetVoidPtr(window->ID, window);\n\n    ImGuiWindowSettings* settings = NULL;\n    if (!(flags & ImGuiWindowFlags_NoSavedSettings))\n        if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)\n            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);\n\n    InitOrLoadWindowSettings(window, settings);\n\n    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)\n        g.Windows.push_front(window); // Quite slow but rare and only once\n    else\n        g.Windows.push_back(window);\n\n    return window;\n}\n\nstatic inline ImVec2 CalcWindowMinSize(ImGuiWindow* window)\n{\n    // We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)\n    // FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.\n    // Perhaps should tend further a neater test for this.\n    ImGuiContext& g = *GImGui;\n    ImVec2 size_min;\n    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))\n    {\n        size_min.x = (window->ChildFlags & ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0f;\n        size_min.y = (window->ChildFlags & ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0f;\n    }\n    else\n    {\n        size_min.x = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0f;\n        size_min.y = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0f;\n    }\n\n    // Reduce artifacts with very small windows\n    ImGuiWindow* window_for_height = window;\n    size_min.y = ImMax(size_min.y, window_for_height->TitleBarHeight + window_for_height->MenuBarHeight + ImMax(0.0f, g.Style.WindowRounding - 1.0f));\n    return size_min;\n}\n\nstatic ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)\n{\n    ImGuiContext& g = *GImGui;\n    ImVec2 new_size = size_desired;\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)\n    {\n        // See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.\n        ImRect cr = g.NextWindowData.SizeConstraintRect;\n        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;\n        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;\n        if (g.NextWindowData.SizeCallback)\n        {\n            ImGuiSizeCallbackData data;\n            data.UserData = g.NextWindowData.SizeCallbackUserData;\n            data.Pos = window->Pos;\n            data.CurrentSize = window->SizeFull;\n            data.DesiredSize = new_size;\n            g.NextWindowData.SizeCallback(&data);\n            new_size = data.DesiredSize;\n        }\n        new_size.x = IM_TRUNC(new_size.x);\n        new_size.y = IM_TRUNC(new_size.y);\n    }\n\n    // Minimum size\n    ImVec2 size_min = CalcWindowMinSize(window);\n    return ImMax(new_size, size_min);\n}\n\nstatic void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)\n{\n    bool preserve_old_content_sizes = false;\n    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)\n        preserve_old_content_sizes = true;\n    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)\n        preserve_old_content_sizes = true;\n    if (preserve_old_content_sizes)\n    {\n        *content_size_current = window->ContentSize;\n        *content_size_ideal = window->ContentSizeIdeal;\n        return;\n    }\n\n    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);\n    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);\n    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);\n    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);\n}\n\nstatic ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiStyle& style = g.Style;\n    const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;\n    const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;\n    ImVec2 size_pad = window->WindowPadding * 2.0f;\n    ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);\n    if (window->Flags & ImGuiWindowFlags_Tooltip)\n    {\n        // Tooltip always resize\n        return size_desired;\n    }\n    else\n    {\n        // Maximum window size is determined by the viewport size or monitor size\n        ImVec2 size_min = CalcWindowMinSize(window);\n        ImVec2 size_max = ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup)) ? ImVec2(FLT_MAX, FLT_MAX) : ImGui::GetMainViewport()->WorkSize - style.DisplaySafeAreaPadding * 2.0f;\n        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, size_max);\n\n        // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,\n        // we may need to compute/store three variants of size_auto_fit, for x/y/xy.\n        // Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:\n        if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && !(window->ChildFlags & ImGuiChildFlags_ResizeY))\n            size_auto_fit.y = window->SizeFull.y;\n        else if (!(window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->ChildFlags & ImGuiChildFlags_ResizeY))\n            size_auto_fit.x = window->SizeFull.x;\n\n        // When the window cannot fit all contents (either because of constraints, either because screen is too small),\n        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.\n        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);\n        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);\n        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);\n        if (will_have_scrollbar_x)\n            size_auto_fit.y += style.ScrollbarSize;\n        if (will_have_scrollbar_y)\n            size_auto_fit.x += style.ScrollbarSize;\n        return size_auto_fit;\n    }\n}\n\nImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)\n{\n    ImVec2 size_contents_current;\n    ImVec2 size_contents_ideal;\n    CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);\n    ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);\n    ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);\n    return size_final;\n}\n\nstatic ImGuiCol GetWindowBgColorIdx(ImGuiWindow* window)\n{\n    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))\n        return ImGuiCol_PopupBg;\n    if (window->Flags & ImGuiWindowFlags_ChildWindow)\n        return ImGuiCol_ChildBg;\n    return ImGuiCol_WindowBg;\n}\n\nstatic void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)\n{\n    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left\n    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right\n    ImVec2 size_expected = pos_max - pos_min;\n    ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);\n    *out_pos = pos_min;\n    if (corner_norm.x == 0.0f)\n        out_pos->x -= (size_constrained.x - size_expected.x);\n    if (corner_norm.y == 0.0f)\n        out_pos->y -= (size_constrained.y - size_expected.y);\n    *out_size = size_constrained;\n}\n\n// Data for resizing from resize grip / corner\nstruct ImGuiResizeGripDef\n{\n    ImVec2  CornerPosN;\n    ImVec2  InnerDir;\n    int     AngleMin12, AngleMax12;\n};\nstatic const ImGuiResizeGripDef resize_grip_def[4] =\n{\n    { ImVec2(1, 1), ImVec2(-1, -1), 0, 3 },  // Lower-right\n    { ImVec2(0, 1), ImVec2(+1, -1), 3, 6 },  // Lower-left\n    { ImVec2(0, 0), ImVec2(+1, +1), 6, 9 },  // Upper-left (Unused)\n    { ImVec2(1, 0), ImVec2(-1, +1), 9, 12 }  // Upper-right (Unused)\n};\n\n// Data for resizing from borders\nstruct ImGuiResizeBorderDef\n{\n    ImVec2  InnerDir;               // Normal toward inside\n    ImVec2  SegmentN1, SegmentN2;   // End positions, normalized (0,0: upper left)\n    float   OuterAngle;             // Angle toward outside\n};\nstatic const ImGuiResizeBorderDef resize_border_def[4] =\n{\n    { ImVec2(+1, 0), ImVec2(0, 1), ImVec2(0, 0), IM_PI * 1.00f }, // Left\n    { ImVec2(-1, 0), ImVec2(1, 0), ImVec2(1, 1), IM_PI * 0.00f }, // Right\n    { ImVec2(0, +1), ImVec2(0, 0), ImVec2(1, 0), IM_PI * 1.50f }, // Up\n    { ImVec2(0, -1), ImVec2(1, 1), ImVec2(0, 1), IM_PI * 0.50f }  // Down\n};\n\nstatic ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)\n{\n    ImRect rect = window->Rect();\n    if (thickness == 0.0f)\n        rect.Max -= ImVec2(1, 1);\n    if (border_n == ImGuiDir_Left)  { return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding); }\n    if (border_n == ImGuiDir_Right) { return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding); }\n    if (border_n == ImGuiDir_Up)    { return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);    }\n    if (border_n == ImGuiDir_Down)  { return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);    }\n    IM_ASSERT(0);\n    return ImRect();\n}\n\n// 0..3: corners (Lower-right, Lower-left, Unused, Unused)\nImGuiID ImGui::GetWindowResizeCornerID(ImGuiWindow* window, int n)\n{\n    IM_ASSERT(n >= 0 && n < 4);\n    ImGuiID id = window->ID;\n    id = ImHashStr(\"#RESIZE\", 0, id);\n    id = ImHashData(&n, sizeof(int), id);\n    return id;\n}\n\n// Borders (Left, Right, Up, Down)\nImGuiID ImGui::GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir)\n{\n    IM_ASSERT(dir >= 0 && dir < 4);\n    int n = (int)dir + 4;\n    ImGuiID id = window->ID;\n    id = ImHashStr(\"#RESIZE\", 0, id);\n    id = ImHashData(&n, sizeof(int), id);\n    return id;\n}\n\n// Handle resize for: Resize Grips, Borders, Gamepad\n// Return true when using auto-fit (double-click on resize grip)\nstatic int ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_hovered, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindowFlags flags = window->Flags;\n\n    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)\n        return false;\n    if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.\n        return false;\n\n    int ret_auto_fit_mask = 0x00;\n    const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));\n    const float grip_hover_inner_size = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75f) : 0.0f;\n    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;\n\n    ImRect clamp_rect = visibility_rect;\n    const bool window_move_from_title_bar = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar);\n    if (window_move_from_title_bar)\n        clamp_rect.Min.y -= window->TitleBarHeight;\n\n    ImVec2 pos_target(FLT_MAX, FLT_MAX);\n    ImVec2 size_target(FLT_MAX, FLT_MAX);\n\n    // Resize grips and borders are on layer 1\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;\n\n    // Manual resize grips\n    PushID(\"#RESIZE\");\n    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)\n    {\n        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];\n        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);\n\n        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window\n        bool hovered, held;\n        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);\n        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);\n        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);\n        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()\n        ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);\n        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);\n        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));\n        if (hovered || held)\n            SetMouseCursor((resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE);\n\n        if (held && g.IO.MouseDoubleClicked[0])\n        {\n            // Auto-fit when double-clicking\n            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);\n            ret_auto_fit_mask = 0x03; // Both axises\n            ClearActiveID();\n        }\n        else if (held)\n        {\n            // Resize from any of the four corners\n            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position\n            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0f || (def.CornerPosN.y == 0.0f && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX);\n            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? clamp_rect.Max.y : +FLT_MAX);\n            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip\n            corner_target = ImClamp(corner_target, clamp_min, clamp_max);\n            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);\n        }\n\n        // Only lower-left grip is visible before hovering/activating\n        if (resize_grip_n == 0 || held || hovered)\n            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);\n    }\n\n    int resize_border_mask = 0x00;\n    if (window->Flags & ImGuiWindowFlags_ChildWindow)\n        resize_border_mask |= ((window->ChildFlags & ImGuiChildFlags_ResizeX) ? 0x02 : 0) | ((window->ChildFlags & ImGuiChildFlags_ResizeY) ? 0x08 : 0);\n    else\n        resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00;\n    for (int border_n = 0; border_n < 4; border_n++)\n    {\n        if ((resize_border_mask & (1 << border_n)) == 0)\n            continue;\n        const ImGuiResizeBorderDef& def = resize_border_def[border_n];\n        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;\n\n        bool hovered, held;\n        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);\n        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()\n        ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);\n        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);\n        //GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));\n        if (hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER)\n            hovered = false;\n        if (hovered || held)\n            SetMouseCursor((axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS);\n        if (held && g.IO.MouseDoubleClicked[0])\n        {\n            // Double-clicking bottom or right border auto-fit on this axis\n            // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.\n            // FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.\n            if (border_n == 1 || border_n == 3) // Right and bottom border\n            {\n                size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis];\n                ret_auto_fit_mask |= (1 << axis);\n                hovered = held = false; // So border doesn't show highlighted at new position\n            }\n            ClearActiveID();\n        }\n        else if (held)\n        {\n            // Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.\n            // Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.\n            // FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!\n            const bool just_scrolled_manually_while_resizing = (g.WheelingWindow != NULL && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false));\n            if (g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing)\n            {\n                g.WindowResizeBorderExpectedRect = border_rect;\n                g.WindowResizeRelativeMode = false;\n            }\n            if ((window->Flags & ImGuiWindowFlags_ChildWindow) && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, sizeof(ImRect)) != 0)\n                g.WindowResizeRelativeMode = true;\n\n            const ImVec2 border_curr = (window->Pos + ImMin(def.SegmentN1, def.SegmentN2) * window->Size);\n            const float border_target_rel_mode_for_axis = border_curr[axis] + g.IO.MouseDelta[axis];\n            const float border_target_abs_mode_for_axis = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.\n\n            // Use absolute mode position\n            ImVec2 border_target = window->Pos;\n            border_target[axis] = border_target_abs_mode_for_axis;\n\n            // Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.\n            bool ignore_resize = false;\n            if (g.WindowResizeRelativeMode)\n            {\n                //GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, \"Relative Mode\");\n                border_target[axis] = border_target_rel_mode_for_axis;\n                if (g.IO.MouseDelta[axis] == 0.0f || (g.IO.MouseDelta[axis] > 0.0f) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis))\n                    ignore_resize = true;\n            }\n\n            // Clamp, apply\n            ImVec2 clamp_min(border_n == ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down || (border_n == ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX);\n            ImVec2 clamp_max(border_n == ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX);\n            border_target = ImClamp(border_target, clamp_min, clamp_max);\n            if (flags & ImGuiWindowFlags_ChildWindow) // Clamp resizing of childs within parent\n            {\n                ImGuiWindow* parent_window = window->ParentWindow;\n                ImGuiWindowFlags parent_flags = parent_window->Flags;\n                ImRect border_limit_rect = parent_window->InnerRect;\n                border_limit_rect.Expand(ImVec2(-ImMax(parent_window->WindowPadding.x, parent_window->WindowBorderSize), -ImMax(parent_window->WindowPadding.y, parent_window->WindowBorderSize)));\n                if ((axis == ImGuiAxis_X) && ((parent_flags & (ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == 0 || (parent_flags & ImGuiWindowFlags_NoScrollbar)))\n                    border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x);\n                if ((axis == ImGuiAxis_Y) && (parent_flags & ImGuiWindowFlags_NoScrollbar))\n                    border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y);\n            }\n            if (!ignore_resize)\n                CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);\n        }\n        if (hovered)\n            *border_hovered = border_n;\n        if (held)\n            *border_held = border_n;\n    }\n    PopID();\n\n    // Restore nav layer\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n\n    // Navigation resize (keyboard/gamepad)\n    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.\n    // Not even sure the callback works here.\n    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)\n    {\n        ImVec2 nav_resize_dir;\n        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)\n            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);\n        if (g.NavInputSource == ImGuiInputSource_Gamepad)\n            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);\n        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)\n        {\n            const float NAV_RESIZE_SPEED = 600.0f;\n            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);\n            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;\n            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window->Pos - window->Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size\n            g.NavWindowingToggleLayer = false;\n            g.NavHighlightItemUnderNav = true;\n            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);\n            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaSize);\n            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)\n            {\n                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.\n                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);\n                g.NavWindowingAccumDeltaSize -= accum_floored;\n            }\n        }\n    }\n\n    // Apply back modified position/size to window\n    const ImVec2 curr_pos = window->Pos;\n    const ImVec2 curr_size = window->SizeFull;\n    if (size_target.x != FLT_MAX && (window->Size.x != size_target.x || window->SizeFull.x != size_target.x))\n        window->Size.x = window->SizeFull.x = size_target.x;\n    if (size_target.y != FLT_MAX && (window->Size.y != size_target.y || window->SizeFull.y != size_target.y))\n        window->Size.y = window->SizeFull.y = size_target.y;\n    if (pos_target.x != FLT_MAX && window->Pos.x != ImTrunc(pos_target.x))\n        window->Pos.x = ImTrunc(pos_target.x);\n    if (pos_target.y != FLT_MAX && window->Pos.y != ImTrunc(pos_target.y))\n        window->Pos.y = ImTrunc(pos_target.y);\n    if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y || curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)\n        MarkIniSettingsDirty(window);\n\n    // Recalculate next expected border expected coordinates\n    if (*border_held != -1)\n        g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);\n\n    return ret_auto_fit_mask;\n}\n\nstatic inline void ClampWindowPos(ImGuiWindow* window, const ImRect& visibility_rect)\n{\n    ImGuiContext& g = *GImGui;\n    ImVec2 size_for_clamping = window->Size;\n    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar))\n        size_for_clamping.y = window->TitleBarHeight;\n    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);\n}\n\nstatic void RenderWindowOuterSingleBorder(ImGuiWindow* window, int border_n, ImU32 border_col, float border_size)\n{\n    const ImGuiResizeBorderDef& def = resize_border_def[border_n];\n    const float rounding = window->WindowRounding;\n    const ImRect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);\n    window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);\n    window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);\n    window->DrawList->PathStroke(border_col, ImDrawFlags_None, border_size);\n}\n\nstatic void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)\n{\n    ImGuiContext& g = *GImGui;\n    const float border_size = window->WindowBorderSize;\n    const ImU32 border_col = GetColorU32(ImGuiCol_Border);\n    if (border_size > 0.0f && (window->Flags & ImGuiWindowFlags_NoBackground) == 0)\n        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, border_col, window->WindowRounding, 0, window->WindowBorderSize);\n    else if (border_size > 0.0f)\n    {\n        if (window->ChildFlags & ImGuiChildFlags_ResizeX) // Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.\n            RenderWindowOuterSingleBorder(window, 1, border_col, border_size);\n        if (window->ChildFlags & ImGuiChildFlags_ResizeY)\n            RenderWindowOuterSingleBorder(window, 3, border_col, border_size);\n    }\n    if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1)\n    {\n        const int border_n = (window->ResizeBorderHeld != -1) ? window->ResizeBorderHeld : window->ResizeBorderHovered;\n        const ImU32 border_col_resizing = GetColorU32((window->ResizeBorderHeld != -1) ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);\n        RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0f, window->WindowBorderSize)); // Thicker than usual\n    }\n    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar))\n    {\n        float y = window->Pos.y + window->TitleBarHeight - 1;\n        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), border_col, g.Style.FrameBorderSize);\n    }\n}\n\n// Draw background and borders\n// Draw and handle scrollbars\nvoid ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiStyle& style = g.Style;\n    ImGuiWindowFlags flags = window->Flags;\n\n    // Ensure that Scrollbar() doesn't read last frame's SkipItems\n    IM_ASSERT(window->BeginCount == 0);\n    window->SkipItems = false;\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;\n\n    // Draw window + handle manual resize\n    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.\n    const float window_rounding = window->WindowRounding;\n    const float window_border_size = window->WindowBorderSize;\n    if (window->Collapsed)\n    {\n        // Title bar only\n        const float backup_border_size = style.FrameBorderSize;\n        g.Style.FrameBorderSize = window->WindowBorderSize;\n        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && g.NavCursorVisible) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);\n        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);\n        g.Style.FrameBorderSize = backup_border_size;\n    }\n    else\n    {\n        // Window background\n        if (!(flags & ImGuiWindowFlags_NoBackground))\n        {\n            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));\n            bool override_alpha = false;\n            float alpha = 1.0f;\n            if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)\n            {\n                alpha = g.NextWindowData.BgAlphaVal;\n                override_alpha = true;\n            }\n            if (override_alpha)\n                bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);\n            window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);\n        }\n\n        // Title bar\n        if (!(flags & ImGuiWindowFlags_NoTitleBar))\n        {\n            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);\n            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);\n        }\n\n        // Menu bar\n        if (flags & ImGuiWindowFlags_MenuBar)\n        {\n            ImRect menu_bar_rect = window->MenuBarRect();\n            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.\n            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);\n            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)\n                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);\n        }\n\n        // Scrollbars\n        if (window->ScrollbarX)\n            Scrollbar(ImGuiAxis_X);\n        if (window->ScrollbarY)\n            Scrollbar(ImGuiAxis_Y);\n\n        // Render resize grips (after their input handling so we don't have a frame of latency)\n        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))\n        {\n            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)\n            {\n                const ImU32 col = resize_grip_col[resize_grip_n];\n                if ((col & IM_COL32_A_MASK) == 0)\n                    continue;\n                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];\n                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);\n                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));\n                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));\n                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);\n                window->DrawList->PathFillConvex(col);\n            }\n        }\n\n        // Borders\n        if (handle_borders_and_resize_grips)\n            RenderWindowOuterBorders(window);\n    }\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n}\n\n// Render title text, collapse button, close button\nvoid ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiStyle& style = g.Style;\n    ImGuiWindowFlags flags = window->Flags;\n\n    const bool has_close_button = (p_open != NULL);\n    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);\n\n    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)\n    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?\n    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;\n    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;\n\n    // Layout buttons\n    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.\n    float pad_l = style.FramePadding.x;\n    float pad_r = style.FramePadding.x;\n    float button_sz = g.FontSize;\n    ImVec2 close_button_pos;\n    ImVec2 collapse_button_pos;\n    if (has_close_button)\n    {\n        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);\n        pad_r += button_sz + style.ItemInnerSpacing.x;\n    }\n    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)\n    {\n        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);\n        pad_r += button_sz + style.ItemInnerSpacing.x;\n    }\n    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)\n    {\n        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);\n        pad_l += button_sz + style.ItemInnerSpacing.x;\n    }\n\n    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)\n    if (has_collapse_button)\n        if (CollapseButton(window->GetID(\"#COLLAPSE\"), collapse_button_pos))\n            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function\n\n    // Close button\n    if (has_close_button)\n        if (CloseButton(window->GetID(\"#CLOSE\"), close_button_pos))\n            *p_open = false;\n\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n    g.CurrentItemFlags = item_flags_backup;\n\n    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional \"unsaved document\" marker)\n    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..\n    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;\n    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);\n\n    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,\n    // while uncentered title text will still reach edges correctly.\n    if (pad_l > style.FramePadding.x)\n        pad_l += g.Style.ItemInnerSpacing.x;\n    if (pad_r > style.FramePadding.x)\n        pad_r += g.Style.ItemInnerSpacing.x;\n    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)\n    {\n        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center\n        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);\n        pad_l = ImMax(pad_l, pad_extend * centerness);\n        pad_r = ImMax(pad_r, pad_extend * centerness);\n    }\n\n    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);\n    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);\n    if (flags & ImGuiWindowFlags_UnsavedDocument)\n    {\n        ImVec2 marker_pos;\n        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);\n        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;\n        if (marker_pos.x > layout_r.Min.x)\n        {\n            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));\n            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));\n        }\n    }\n    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]\n    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]\n    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);\n}\n\nvoid ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)\n{\n    window->ParentWindow = parent_window;\n    window->RootWindow = window->RootWindowPopupTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;\n    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))\n        window->RootWindow = parent_window->RootWindow;\n    if (parent_window && (flags & ImGuiWindowFlags_Popup))\n        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;\n    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))\n        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;\n    while (window->RootWindowForNav->ChildFlags & ImGuiChildFlags_NavFlattened)\n    {\n        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);\n        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;\n    }\n}\n\n// [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.\n// This is designed as a toy/test-bed for\nvoid ImGui::UpdateWindowSkipRefresh(ImGuiWindow* window)\n{\n    ImGuiContext& g = *GImGui;\n    window->SkipRefresh = false;\n    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0)\n        return;\n    if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh)\n    {\n        // FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.\n        if (window->Appearing) // If currently appearing\n            return;\n        if (window->Hidden) // If was hidden (previous frame)\n            return;\n        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow)\n            if (window->RootWindow == g.HoveredWindow->RootWindow || IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, window))\n                return;\n        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow)\n            if (window->RootWindow == g.NavWindow->RootWindow || IsWindowWithinBeginStackOf(g.NavWindow->RootWindow, window))\n                return;\n        window->DrawList = NULL;\n        window->SkipRefresh = true;\n    }\n}\n\nstatic void SetWindowActiveForSkipRefresh(ImGuiWindow* window)\n{\n    window->Active = true;\n    for (ImGuiWindow* child : window->DC.ChildWindows)\n        if (!child->Hidden)\n        {\n            child->Active = child->SkipRefresh = true;\n            SetWindowActiveForSkipRefresh(child);\n        }\n}\n\n// Push a new Dear ImGui window to add widgets to.\n// - A default window called \"Debug\" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.\n// - Begin/End can be called multiple times during the frame with the same window name to append content.\n// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).\n//   You can use the \"##\" or \"###\" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.\n// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.\n// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.\nbool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    IM_ASSERT(name != NULL && name[0] != '\\0');     // Window name required\n    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()\n    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet\n\n    // Find or create\n    ImGuiWindow* window = FindWindowByName(name);\n    const bool window_just_created = (window == NULL);\n    if (window_just_created)\n        window = CreateNewWindow(name, flags);\n\n    // [DEBUG] Debug break requested by user\n    if (g.DebugBreakInWindow == window->ID)\n        IM_DEBUG_BREAK();\n\n    // Automatically disable manual moving/resizing when NoInputs is set\n    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)\n        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;\n\n    const int current_frame = g.FrameCount;\n    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);\n    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);\n\n    // Update the Appearing flag\n    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit \"Debug\" window would always toggle off->on\n    if (flags & ImGuiWindowFlags_Popup)\n    {\n        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];\n        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed\n        window_just_activated_by_user |= (window != popup_ref.Window);\n    }\n    window->Appearing = window_just_activated_by_user;\n    if (window->Appearing)\n        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);\n\n    // Update Flags, LastFrameActive, BeginOrderXXX fields\n    if (first_begin_of_the_frame)\n    {\n        UpdateWindowInFocusOrderList(window, window_just_created, flags);\n        window->Flags = (ImGuiWindowFlags)flags;\n        window->ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0;\n        window->LastFrameActive = current_frame;\n        window->LastTimeActive = (float)g.Time;\n        window->BeginOrderWithinParent = 0;\n        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);\n    }\n    else\n    {\n        flags = window->Flags;\n    }\n\n    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack\n    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;\n    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;\n    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));\n\n    // We allow window memory to be compacted so recreate the base stack when needed.\n    if (window->IDStack.Size == 0)\n        window->IDStack.push_back(window->ID);\n\n    // Add to stack\n    g.CurrentWindow = window;\n    g.CurrentWindowStack.resize(g.CurrentWindowStack.Size + 1);\n    ImGuiWindowStackData& window_stack_data = g.CurrentWindowStack.back();\n    window_stack_data.Window = window;\n    window_stack_data.ParentLastItemDataBackup = g.LastItemData;\n    window_stack_data.DisabledOverrideReenable = (flags & ImGuiWindowFlags_Tooltip) && (g.CurrentItemFlags & ImGuiItemFlags_Disabled);\n    ErrorRecoveryStoreState(&window_stack_data.StackSizesInBegin);\n    g.StackSizesInBeginForCurrentWindow = &window_stack_data.StackSizesInBegin;\n    if (flags & ImGuiWindowFlags_ChildMenu)\n        g.BeginMenuDepth++;\n\n    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)\n    if (first_begin_of_the_frame)\n    {\n        UpdateWindowParentAndRootLinks(window, flags, parent_window);\n        window->ParentWindowInBeginStack = parent_window_in_stack;\n\n        // There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,\n        // e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)\n        window->ParentWindowForFocusRoute = (flags & ImGuiWindowFlags_ChildWindow) ? parent_window_in_stack : NULL;\n    }\n\n    // Add to focus scope stack\n    PushFocusScope((window->ChildFlags & ImGuiChildFlags_NavFlattened) ? g.CurrentFocusScopeId : window->ID);\n    window->NavRootFocusScopeId = g.CurrentFocusScopeId;\n\n    // Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]\n    if (flags & ImGuiWindowFlags_Popup)\n    {\n        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];\n        popup_ref.Window = window;\n        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;\n        g.BeginPopupStack.push_back(popup_ref);\n        window->PopupId = popup_ref.PopupId;\n    }\n\n    // Process SetNextWindow***() calls\n    // (FIXME: Consider splitting the HasXXX flags into X/Y components\n    bool window_pos_set_by_api = false;\n    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)\n    {\n        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;\n        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)\n        {\n            // May be processed on the next frame if this is our first frame and we are measuring size\n            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.\n            window->SetWindowPosVal = g.NextWindowData.PosVal;\n            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;\n            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\n        }\n        else\n        {\n            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);\n        }\n    }\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)\n    {\n        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);\n        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);\n        if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0) // Axis-specific conditions for BeginChild()\n            g.NextWindowData.SizeVal.x = window->SizeFull.x;\n        if ((window->ChildFlags & ImGuiChildFlags_ResizeY) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0)\n            g.NextWindowData.SizeVal.y = window->SizeFull.y;\n        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);\n    }\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)\n    {\n        if (g.NextWindowData.ScrollVal.x >= 0.0f)\n        {\n            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;\n            window->ScrollTargetCenterRatio.x = 0.0f;\n        }\n        if (g.NextWindowData.ScrollVal.y >= 0.0f)\n        {\n            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;\n            window->ScrollTargetCenterRatio.y = 0.0f;\n        }\n    }\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)\n        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;\n    else if (first_begin_of_the_frame)\n        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)\n        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)\n        FocusWindow(window);\n    if (window->Appearing)\n        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);\n\n    // [EXPERIMENTAL] Skip Refresh mode\n    UpdateWindowSkipRefresh(window);\n\n    // Nested root windows (typically tooltips) override disabled state\n    if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)\n        BeginDisabledOverrideReenable();\n\n    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()\n    g.CurrentWindow = NULL;\n\n    // When reusing window again multiple times a frame, just append content (don't need to setup again)\n    if (first_begin_of_the_frame && !window->SkipRefresh)\n    {\n        // Initialize\n        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)\n        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);\n        window->Active = true;\n        window->HasCloseButton = (p_open != NULL);\n        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);\n        window->IDStack.resize(1);\n        window->DrawList->_ResetForNewFrame();\n        window->DC.CurrentTableIdx = -1;\n\n        // Restore buffer capacity when woken from a compacted state, to avoid\n        if (window->MemoryCompacted)\n            GcAwakeTransientWindowBuffers(window);\n\n        // Update stored window name when it changes (which can _only_ happen with the \"###\" operator, so the ID would stay unchanged).\n        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.\n        bool window_title_visible_elsewhere = false;\n        if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB\n            window_title_visible_elsewhere = true;\n        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)\n        {\n            size_t buf_len = (size_t)window->NameBufLen;\n            window->Name = ImStrdupcpy(window->Name, &buf_len, name);\n            window->NameBufLen = (int)buf_len;\n        }\n\n        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS\n\n        // Update contents size from last frame for auto-fitting (or use explicit size)\n        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);\n        if (window->HiddenFramesCanSkipItems > 0)\n            window->HiddenFramesCanSkipItems--;\n        if (window->HiddenFramesCannotSkipItems > 0)\n            window->HiddenFramesCannotSkipItems--;\n        if (window->HiddenFramesForRenderOnly > 0)\n            window->HiddenFramesForRenderOnly--;\n\n        // Hide new windows for one frame until they calculate their size\n        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))\n            window->HiddenFramesCannotSkipItems = 1;\n\n        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)\n        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.\n        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)\n        {\n            window->HiddenFramesCannotSkipItems = 1;\n            if (flags & ImGuiWindowFlags_AlwaysAutoResize)\n            {\n                if (!window_size_x_set_by_api)\n                    window->Size.x = window->SizeFull.x = 0.f;\n                if (!window_size_y_set_by_api)\n                    window->Size.y = window->SizeFull.y = 0.f;\n                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);\n            }\n        }\n\n        // SELECT VIEWPORT\n        // FIXME-VIEWPORT: In the docking/viewport branch, this is the point where we select the current viewport (which may affect the style)\n\n        ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)GetMainViewport();\n        SetWindowViewport(window, viewport);\n        SetCurrentWindow(window);\n\n        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)\n\n        if (flags & ImGuiWindowFlags_ChildWindow)\n            window->WindowBorderSize = style.ChildBorderSize;\n        else\n            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;\n        window->WindowPadding = style.WindowPadding;\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !(window->ChildFlags & ImGuiChildFlags_AlwaysUseWindowPadding) && window->WindowBorderSize == 0.0f)\n            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);\n\n        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.\n        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);\n        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;\n        window->TitleBarHeight = (flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : g.FontSize + g.Style.FramePadding.y * 2.0f;\n        window->MenuBarHeight = (flags & ImGuiWindowFlags_MenuBar) ? window->DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0f : 0.0f;\n\n        // Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.\n        // Those flags will be altered further down in the function depending on more conditions.\n        bool use_current_size_for_scrollbar_x = window_just_created;\n        bool use_current_size_for_scrollbar_y = window_just_created;\n        if (window_size_x_set_by_api && window->ContentSizeExplicit.x != 0.0f)\n            use_current_size_for_scrollbar_x = true;\n        if (window_size_y_set_by_api && window->ContentSizeExplicit.y != 0.0f) // #7252\n            use_current_size_for_scrollbar_y = true;\n\n        // Collapse window by double-clicking on title bar\n        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing\n        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))\n        {\n            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed),\n            // so verify that we don't have items over the title bar.\n            ImRect title_bar_rect = window->TitleBarRect();\n            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && g.ActiveId == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max))\n                if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey_MouseLeft) == ImGuiKeyOwner_NoOwner)\n                    window->WantCollapseToggle = true;\n            if (window->WantCollapseToggle)\n            {\n                window->Collapsed = !window->Collapsed;\n                if (!window->Collapsed)\n                    use_current_size_for_scrollbar_y = true;\n                MarkIniSettingsDirty(window);\n            }\n        }\n        else\n        {\n            window->Collapsed = false;\n        }\n        window->WantCollapseToggle = false;\n\n        // SIZE\n\n        // Outer Decoration Sizes\n        // (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).\n        const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;\n        window->DecoOuterSizeX1 = 0.0f;\n        window->DecoOuterSizeX2 = 0.0f;\n        window->DecoOuterSizeY1 = window->TitleBarHeight + window->MenuBarHeight;\n        window->DecoOuterSizeY2 = 0.0f;\n        window->ScrollbarSizes = ImVec2(0.0f, 0.0f);\n\n        // Calculate auto-fit size, handle automatic resize\n        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);\n        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)\n        {\n            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.\n            if (!window_size_x_set_by_api)\n            {\n                window->SizeFull.x = size_auto_fit.x;\n                use_current_size_for_scrollbar_x = true;\n            }\n            if (!window_size_y_set_by_api)\n            {\n                window->SizeFull.y = size_auto_fit.y;\n                use_current_size_for_scrollbar_y = true;\n            }\n        }\n        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)\n        {\n            // Auto-fit may only grow window during the first few frames\n            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.\n            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)\n            {\n                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;\n                use_current_size_for_scrollbar_x = true;\n            }\n            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)\n            {\n                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;\n                use_current_size_for_scrollbar_y = true;\n            }\n            if (!window->Collapsed)\n                MarkIniSettingsDirty(window);\n        }\n\n        // Apply minimum/maximum window size constraints and final size\n        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);\n        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;\n\n        // POSITION\n\n        // Popup latch its initial position, will position itself when it appears next frame\n        if (window_just_activated_by_user)\n        {\n            window->AutoPosLastDirection = ImGuiDir_None;\n            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()\n                window->Pos = g.BeginPopupStack.back().OpenPopupPos;\n        }\n\n        // Position child window\n        if (flags & ImGuiWindowFlags_ChildWindow)\n        {\n            IM_ASSERT(parent_window && parent_window->Active);\n            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;\n            parent_window->DC.ChildWindows.push_back(window);\n            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)\n                window->Pos = parent_window->DC.CursorPos;\n        }\n\n        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);\n        if (window_pos_with_pivot)\n            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)\n        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)\n            window->Pos = FindBestWindowPosForPopup(window);\n        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)\n            window->Pos = FindBestWindowPosForPopup(window);\n        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)\n            window->Pos = FindBestWindowPosForPopup(window);\n\n        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)\n        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.\n        ImRect viewport_rect(viewport->GetMainRect());\n        ImRect viewport_work_rect(viewport->GetWorkRect());\n        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);\n        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);\n\n        // Clamp position/size so window stays visible within its viewport or monitor\n        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.\n        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))\n            if (viewport_rect.GetWidth() > 0.0f && viewport_rect.GetHeight() > 0.0f)\n                ClampWindowPos(window, visibility_rect);\n        window->Pos = ImTrunc(window->Pos);\n\n        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)\n        // Large values tend to lead to variety of artifacts and are not recommended.\n        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;\n\n        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.\n        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))\n        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);\n\n        // Apply window focus (new and reactivated windows are moved to front)\n        bool want_focus = false;\n        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))\n        {\n            if (flags & ImGuiWindowFlags_Popup)\n                want_focus = true;\n            else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)\n                want_focus = true;\n        }\n\n        // [Test Engine] Register whole window in the item system (before submitting further decorations)\n#ifdef IMGUI_ENABLE_TEST_ENGINE\n        if (g.TestEngineHookItems)\n        {\n            IM_ASSERT(window->IDStack.Size == 1);\n            window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.\n            window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;\n            IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);\n            IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);\n            window->IDStack.Size = 1;\n            window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n\n        }\n#endif\n\n        // Handle manual resize: Resize Grips, Borders, Gamepad\n        int border_hovered = -1, border_held = -1;\n        ImU32 resize_grip_col[4] = {};\n        const int resize_grip_count = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.\n        const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));\n        if (!window->Collapsed)\n            if (int auto_fit_mask = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))\n            {\n                if (auto_fit_mask & (1 << ImGuiAxis_X))\n                    use_current_size_for_scrollbar_x = true;\n                if (auto_fit_mask & (1 << ImGuiAxis_Y))\n                    use_current_size_for_scrollbar_y = true;\n            }\n        window->ResizeBorderHovered = (signed char)border_hovered;\n        window->ResizeBorderHeld = (signed char)border_held;\n\n        // SCROLLBAR VISIBILITY\n\n        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).\n        if (!window->Collapsed)\n        {\n            // When reading the current size we need to read it after size constraints have been applied.\n            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.\n            // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.\n            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));\n            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;\n            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;\n            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;\n            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;\n            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?\n            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));\n            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));\n            if (window->ScrollbarX && !window->ScrollbarY)\n                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);\n            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);\n\n            // Amend the partially filled window->DecorationXXX values.\n            window->DecoOuterSizeX2 += window->ScrollbarSizes.x;\n            window->DecoOuterSizeY2 += window->ScrollbarSizes.y;\n        }\n\n        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)\n        // Update various regions. Variables they depend on should be set above in this function.\n        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.\n\n        // Outer rectangle\n        // Not affected by window border size. Used by:\n        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)\n        // - Begin() initial clipping rect for drawing window background and borders.\n        // - Begin() clipping whole child\n        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;\n        const ImRect outer_rect = window->Rect();\n        const ImRect title_bar_rect = window->TitleBarRect();\n        window->OuterRectClipped = outer_rect;\n        window->OuterRectClipped.ClipWith(host_rect);\n\n        // Inner rectangle\n        // Not affected by window border size. Used by:\n        // - InnerClipRect\n        // - ScrollToRectEx()\n        // - NavUpdatePageUpPageDown()\n        // - Scrollbar()\n        window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;\n        window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;\n        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;\n        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;\n\n        // Inner clipping rectangle.\n        // - Extend a outside of normal work region up to borders.\n        // - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.\n        // - It also makes clipped items be more noticeable.\n        // - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312\n        // - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.\n        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.\n        // Affected by window/frame border size. Used by:\n        // - Begin() initial clip rect\n        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);\n\n        // Try to match the fact that our border is drawn centered over the window rectangle, rather than inner.\n        // This is why we do a *0.5f here. We don't currently even technically support large values for WindowBorderSize,\n        // see e.g #7887 #7888, but may do after we move the window border to become an inner border (and then we can remove the 0.5f here).\n        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + window->WindowBorderSize * 0.5f);\n        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size * 0.5f);\n        window->InnerClipRect.Max.x = ImFloor(window->InnerRect.Max.x - window->WindowBorderSize * 0.5f);\n        window->InnerClipRect.Max.y = ImFloor(window->InnerRect.Max.y - window->WindowBorderSize * 0.5f);\n        window->InnerClipRect.ClipWithFull(host_rect);\n\n        // Default item width. Make it proportional to window size if window manually resizes\n        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))\n            window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);\n        else\n            window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);\n\n        // SCROLLING\n\n        // Lock down maximum scrolling\n        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate\n        // for right/bottom aligned items without creating a scrollbar.\n        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());\n        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());\n\n        // Apply scrolling\n        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);\n        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);\n        window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;\n\n        // DRAWING\n\n        // Setup draw list and outer clipping rectangle\n        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);\n        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);\n        PushClipRect(host_rect.Min, host_rect.Max, false);\n\n        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)\n        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.\n        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)\n        {\n            bool render_decorations_in_parent = false;\n            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)\n            {\n                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)\n                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs\n                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;\n                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;\n                bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);\n                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)\n                    render_decorations_in_parent = true;\n            }\n            if (render_decorations_in_parent)\n                window->DrawList = parent_window->DrawList;\n\n            // Handle title bar, scrollbar, resize grips and resize borders\n            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;\n            const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);\n            const bool handle_borders_and_resize_grips = true; // This exists to facilitate merge with 'docking' branch.\n            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);\n\n            if (render_decorations_in_parent)\n                window->DrawList = &window->DrawListInst;\n        }\n\n        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)\n\n        // Work rectangle.\n        // Affected by window padding and border size. Used by:\n        // - Columns() for right-most edge\n        // - TreeNode(), CollapsingHeader() for right-most edge\n        // - BeginTabBar() for right-most edge\n        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);\n        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);\n        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));\n        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));\n        window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));\n        window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));\n        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;\n        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;\n        window->ParentWorkRect = window->WorkRect;\n\n        // [LEGACY] Content Region\n        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.\n        // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.\n        // Used by:\n        // - Mouse wheel scrolling + many other things\n        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;\n        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;\n        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));\n        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));\n\n        // Setup drawing context\n        // (NB: That term \"drawing context / DC\" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)\n        window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;\n        window->DC.GroupOffset.x = 0.0f;\n        window->DC.ColumnsOffset.x = 0.0f;\n\n        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.\n        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.\n        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;\n        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;\n        window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);\n        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));\n        window->DC.CursorPos = window->DC.CursorStartPos;\n        window->DC.CursorPosPrevLine = window->DC.CursorPos;\n        window->DC.CursorMaxPos = window->DC.CursorStartPos;\n        window->DC.IdealMaxPos = window->DC.CursorStartPos;\n        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);\n        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;\n        window->DC.IsSameLine = window->DC.IsSetPos = false;\n\n        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;\n        window->DC.NavLayersActiveMaskNext = 0x00;\n        window->DC.NavIsScrollPushableX = true;\n        window->DC.NavHideHighlightOneFrame = false;\n        window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);\n\n        window->DC.MenuBarAppending = false;\n        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);\n        window->DC.TreeDepth = 0;\n        window->DC.TreeHasStackDataDepthMask = 0x00;\n        window->DC.ChildWindows.resize(0);\n        window->DC.StateStorage = &window->StateStorage;\n        window->DC.CurrentColumns = NULL;\n        window->DC.LayoutType = ImGuiLayoutType_Vertical;\n        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;\n\n        window->DC.ItemWidth = window->ItemWidthDefault;\n        window->DC.TextWrapPos = -1.0f; // disabled\n        window->DC.ItemWidthStack.resize(0);\n        window->DC.TextWrapPosStack.resize(0);\n        if (flags & ImGuiWindowFlags_Modal)\n            window->DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_ModalWindowDimBg));\n\n        if (window->AutoFitFramesX > 0)\n            window->AutoFitFramesX--;\n        if (window->AutoFitFramesY > 0)\n            window->AutoFitFramesY--;\n\n        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)\n        // We ImGuiFocusRequestFlags_UnlessBelowModal to:\n        // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.\n        // - Position window behind the modal that is not a begin-parent of this window.\n        if (want_focus)\n            FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);\n        if (want_focus && window == g.NavWindow)\n            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls\n\n        // Pressing CTRL+C copy window content into the clipboard\n        // [EXPERIMENTAL] Breaks on nested Begin/End pairs. We need to work that out and add better logging scope.\n        // [EXPERIMENTAL] Text outputs has many issues.\n        if (g.IO.ConfigWindowsCopyContentsWithCtrlC)\n            if (g.NavWindow && g.NavWindow->RootWindow == window && g.ActiveId == 0 && Shortcut(ImGuiMod_Ctrl | ImGuiKey_C))\n                LogToClipboard(0);\n\n        // Title bar\n        if (!(flags & ImGuiWindowFlags_NoTitleBar))\n            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);\n\n        // Clear hit test shape every frame\n        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;\n\n        if (flags & ImGuiWindowFlags_Tooltip)\n            g.TooltipPreviousWindow = window;\n\n        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().\n        // This is useful to allow creating context menus on title bar only, etc.\n        SetLastItemDataForWindow(window, title_bar_rect);\n\n        // [DEBUG]\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))\n            DebugLocateItemResolveWithLastItem();\n#endif\n\n        // [Test Engine] Register title bar / tab with MoveId.\n#ifdef IMGUI_ENABLE_TEST_ENGINE\n        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))\n        {\n            window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;\n            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);\n            window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n        }\n#endif\n    }\n    else\n    {\n        // Skip refresh always mark active\n        if (window->SkipRefresh)\n            SetWindowActiveForSkipRefresh(window);\n\n        // Append\n        SetCurrentWindow(window);\n        SetLastItemDataForWindow(window, window->TitleBarRect());\n    }\n\n    if (!window->SkipRefresh)\n        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);\n\n    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default \"Debug\" window is unused)\n    window->WriteAccessed = false;\n    window->BeginCount++;\n    g.NextWindowData.ClearFlags();\n\n    // Update visibility\n    if (first_begin_of_the_frame && !window->SkipRefresh)\n    {\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_ChildMenu))\n        {\n            // Child window can be out of sight and have \"negative\" clip windows.\n            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).\n            IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);\n            const bool nav_request = (window->ChildFlags & ImGuiChildFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);\n            if (!g.LogEnabled && !nav_request)\n                if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)\n                {\n                    if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)\n                        window->HiddenFramesCannotSkipItems = 1;\n                    else\n                        window->HiddenFramesCanSkipItems = 1;\n                }\n\n            // Hide along with parent or if parent is collapsed\n            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))\n                window->HiddenFramesCanSkipItems = 1;\n            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))\n                window->HiddenFramesCannotSkipItems = 1;\n        }\n\n        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)\n        if (style.Alpha <= 0.0f)\n            window->HiddenFramesCanSkipItems = 1;\n\n        // Update the Hidden flag\n        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);\n        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);\n\n        // Disable inputs for requested number of frames\n        if (window->DisableInputsFrames > 0)\n        {\n            window->DisableInputsFrames--;\n            window->Flags |= ImGuiWindowFlags_NoInputs;\n        }\n\n        // Update the SkipItems flag, used to early out of all items functions (no layout required)\n        bool skip_items = false;\n        if (window->Collapsed || !window->Active || hidden_regular)\n            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)\n                skip_items = true;\n        window->SkipItems = skip_items;\n    }\n    else if (first_begin_of_the_frame)\n    {\n        // Skip refresh mode\n        window->SkipItems = true;\n    }\n\n    // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.\n    // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (!window->IsFallbackWindow)\n        if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size))\n        {\n            if (window->AutoFitFramesX > 0) { window->AutoFitFramesX++; }\n            if (window->AutoFitFramesY > 0) { window->AutoFitFramesY++; }\n            return false;\n        }\n#endif\n\n    return !window->SkipItems;\n}\n\nstatic void ImGui::SetLastItemDataForWindow(ImGuiWindow* window, const ImRect& rect)\n{\n    ImGuiContext& g = *GImGui;\n    SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, rect);\n}\n\nvoid ImGui::End()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    // Error checking: verify that user hasn't called End() too many times!\n    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)\n    {\n        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, \"Calling End() too many times!\");\n        return;\n    }\n    ImGuiWindowStackData& window_stack_data = g.CurrentWindowStack.back();\n\n    // Error checking: verify that user doesn't directly call End() on a child window.\n    if (window->Flags & ImGuiWindowFlags_ChildWindow)\n        IM_ASSERT_USER_ERROR(g.WithinEndChildID == window->ID, \"Must call EndChild() and not End()!\");\n\n    // Close anything that is open\n    if (window->DC.CurrentColumns)\n        EndColumns();\n    if (!window->SkipRefresh)\n        PopClipRect();   // Inner window clip rectangle\n    PopFocusScope();\n    if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)\n        EndDisabledOverrideReenable();\n\n    if (window->SkipRefresh)\n    {\n        IM_ASSERT(window->DrawList == NULL);\n        window->DrawList = &window->DrawListInst;\n    }\n\n    // Stop logging\n    if (g.LogWindow == window) // FIXME: add more options for scope of logging\n        LogFinish();\n\n    if (window->DC.IsSetPos)\n        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();\n\n    // Pop from window stack\n    g.LastItemData = window_stack_data.ParentLastItemDataBackup;\n    if (window->Flags & ImGuiWindowFlags_ChildMenu)\n        g.BeginMenuDepth--;\n    if (window->Flags & ImGuiWindowFlags_Popup)\n        g.BeginPopupStack.pop_back();\n\n    // Error handling, state recovery\n    if (g.IO.ConfigErrorRecovery)\n        ErrorRecoveryTryToRecoverWindowState(&window_stack_data.StackSizesInBegin);\n\n    g.CurrentWindowStack.pop_back();\n    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);\n}\n\n// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.\nvoid ImGui::SetCurrentFont(ImFont* font)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?\n    IM_ASSERT(font->Scale > 0.0f);\n    g.Font = font;\n    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);\n    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;\n    g.FontScale = g.FontSize / g.Font->FontSize;\n\n    ImFontAtlas* atlas = g.Font->ContainerAtlas;\n    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;\n    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;\n    g.DrawListSharedData.Font = g.Font;\n    g.DrawListSharedData.FontSize = g.FontSize;\n    g.DrawListSharedData.FontScale = g.FontScale;\n}\n\n// Use ImDrawList::_SetTextureID(), making our shared g.FontStack[] authorative against window-local ImDrawList.\n// - Whereas ImDrawList::PushTextureID()/PopTextureID() is not to be used across Begin() calls.\n// - Note that we don't propagate current texture id when e.g. Begin()-ing into a new window, we never really did...\n//   - Some code paths never really fully worked with multiple atlas textures.\n//   - The right-ish solution may be to remove _SetTextureID() and make AddText/RenderText lazily call PushTextureID()/PopTextureID()\n//     the same way AddImage() does, but then all other primitives would also need to? I don't think we should tackle this problem\n//     because we have a concrete need and a test bed for multiple atlas textures.\nvoid ImGui::PushFont(ImFont* font)\n{\n    ImGuiContext& g = *GImGui;\n    if (font == NULL)\n        font = GetDefaultFont();\n    g.FontStack.push_back(font);\n    SetCurrentFont(font);\n    g.CurrentWindow->DrawList->_SetTextureID(font->ContainerAtlas->TexID);\n}\n\nvoid  ImGui::PopFont()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.FontStack.Size <= 0)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopFont() too many times!\");\n        return;\n    }\n    g.FontStack.pop_back();\n    ImFont* font = g.FontStack.Size == 0 ? GetDefaultFont() : g.FontStack.back();\n    SetCurrentFont(font);\n    g.CurrentWindow->DrawList->_SetTextureID(font->ContainerAtlas->TexID);\n}\n\nvoid ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiItemFlags item_flags = g.CurrentItemFlags;\n    IM_ASSERT(item_flags == g.ItemFlagsStack.back());\n    if (enabled)\n        item_flags |= option;\n    else\n        item_flags &= ~option;\n    g.CurrentItemFlags = item_flags;\n    g.ItemFlagsStack.push_back(item_flags);\n}\n\nvoid ImGui::PopItemFlag()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.ItemFlagsStack.Size <= 1)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopItemFlag() too many times!\");\n        return;\n    }\n    g.ItemFlagsStack.pop_back();\n    g.CurrentItemFlags = g.ItemFlagsStack.back();\n}\n\n// BeginDisabled()/EndDisabled()\n// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)\n// - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.\n// - Feedback welcome at https://github.com/ocornut/imgui/issues/211\n// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions.\n//   (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)\n// - Note: mixing up BeginDisabled() and PushItemFlag(ImGuiItemFlags_Disabled) is currently NOT SUPPORTED.\nvoid ImGui::BeginDisabled(bool disabled)\n{\n    ImGuiContext& g = *GImGui;\n    bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;\n    if (!was_disabled && disabled)\n    {\n        g.DisabledAlphaBackup = g.Style.Alpha;\n        g.Style.Alpha *= g.Style.DisabledAlpha; // PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * g.Style.DisabledAlpha);\n    }\n    if (was_disabled || disabled)\n        g.CurrentItemFlags |= ImGuiItemFlags_Disabled;\n    g.ItemFlagsStack.push_back(g.CurrentItemFlags); // FIXME-OPT: can we simply skip this and use DisabledStackSize?\n    g.DisabledStackSize++;\n}\n\nvoid ImGui::EndDisabled()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.DisabledStackSize <= 0)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling EndDisabled() too many times!\");\n        return;\n    }\n    g.DisabledStackSize--;\n    bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;\n    //PopItemFlag();\n    g.ItemFlagsStack.pop_back();\n    g.CurrentItemFlags = g.ItemFlagsStack.back();\n    if (was_disabled && (g.CurrentItemFlags & ImGuiItemFlags_Disabled) == 0)\n        g.Style.Alpha = g.DisabledAlphaBackup; //PopStyleVar();\n}\n\n// Could have been called BeginDisabledDisable() but it didn't want to be award nominated for most awkward function name.\n// Ideally we would use a shared e.g. BeginDisabled()->BeginDisabledEx() but earlier needs to be optimal.\n// The whole code for this is awkward, will reevaluate if we find a way to implement SetNextItemDisabled().\nvoid ImGui::BeginDisabledOverrideReenable()\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.CurrentItemFlags & ImGuiItemFlags_Disabled);\n    g.Style.Alpha = g.DisabledAlphaBackup;\n    g.CurrentItemFlags &= ~ImGuiItemFlags_Disabled;\n    g.ItemFlagsStack.push_back(g.CurrentItemFlags);\n    g.DisabledStackSize++;\n}\n\nvoid ImGui::EndDisabledOverrideReenable()\n{\n    ImGuiContext& g = *GImGui;\n    g.DisabledStackSize--;\n    IM_ASSERT(g.DisabledStackSize > 0);\n    g.ItemFlagsStack.pop_back();\n    g.CurrentItemFlags = g.ItemFlagsStack.back();\n    g.Style.Alpha = g.DisabledAlphaBackup * g.Style.DisabledAlpha;\n}\n\nvoid ImGui::PushTextWrapPos(float wrap_pos_x)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    window->DC.TextWrapPosStack.push_back(window->DC.TextWrapPos);\n    window->DC.TextWrapPos = wrap_pos_x;\n}\n\nvoid ImGui::PopTextWrapPos()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->DC.TextWrapPosStack.Size <= 0)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopTextWrapPos() too many times!\");\n        return;\n    }\n    window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();\n    window->DC.TextWrapPosStack.pop_back();\n}\n\nstatic ImGuiWindow* GetCombinedRootWindow(ImGuiWindow* window, bool popup_hierarchy)\n{\n    ImGuiWindow* last_window = NULL;\n    while (last_window != window)\n    {\n        last_window = window;\n        window = window->RootWindow;\n        if (popup_hierarchy)\n            window = window->RootWindowPopupTree;\n    }\n    return window;\n}\n\nbool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy)\n{\n    ImGuiWindow* window_root = GetCombinedRootWindow(window, popup_hierarchy);\n    if (window_root == potential_parent)\n        return true;\n    while (window != NULL)\n    {\n        if (window == potential_parent)\n            return true;\n        if (window == window_root) // end of chain\n            return false;\n        window = window->ParentWindow;\n    }\n    return false;\n}\n\nbool ImGui::IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent)\n{\n    if (window->RootWindow == potential_parent)\n        return true;\n    while (window != NULL)\n    {\n        if (window == potential_parent)\n            return true;\n        window = window->ParentWindowInBeginStack;\n    }\n    return false;\n}\n\nbool ImGui::IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below)\n{\n    ImGuiContext& g = *GImGui;\n\n    // It would be saner to ensure that display layer is always reflected in the g.Windows[] order, which would likely requires altering all manipulations of that array\n    const int display_layer_delta = GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below);\n    if (display_layer_delta != 0)\n        return display_layer_delta > 0;\n\n    for (int i = g.Windows.Size - 1; i >= 0; i--)\n    {\n        ImGuiWindow* candidate_window = g.Windows[i];\n        if (candidate_window == potential_above)\n            return true;\n        if (candidate_window == potential_below)\n            return false;\n    }\n    return false;\n}\n\n// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options.\n// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,\n// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!\n// Refer to FAQ entry \"How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?\" for details.\nbool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT_USER_ERROR((flags & ~ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0, \"Invalid flags for IsWindowHovered()!\");\n\n    ImGuiWindow* ref_window = g.HoveredWindow;\n    ImGuiWindow* cur_window = g.CurrentWindow;\n    if (ref_window == NULL)\n        return false;\n\n    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)\n    {\n        IM_ASSERT(cur_window); // Not inside a Begin()/End()\n        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;\n        if (flags & ImGuiHoveredFlags_RootWindow)\n            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);\n\n        bool result;\n        if (flags & ImGuiHoveredFlags_ChildWindows)\n            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy);\n        else\n            result = (ref_window == cur_window);\n        if (!result)\n            return false;\n    }\n\n    if (!IsWindowContentHoverable(ref_window, flags))\n        return false;\n    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\n        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)\n            return false;\n\n    // When changing hovered window we requires a bit of stationary delay before activating hover timer.\n    // FIXME: We don't support delay other than stationary one for now, other delay would need a way\n    // to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true\n    // for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.\n    // We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.\n    if (flags & ImGuiHoveredFlags_ForTooltip)\n        flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);\n    if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window->ID)\n        return false;\n\n    return true;\n}\n\nfloat ImGui::GetWindowWidth()\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->Size.x;\n}\n\nfloat ImGui::GetWindowHeight()\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->Size.y;\n}\n\nImVec2 ImGui::GetWindowPos()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    return window->Pos;\n}\n\nvoid ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)\n{\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\n    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)\n        return;\n\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\n    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\n    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);\n\n    // Set\n    const ImVec2 old_pos = window->Pos;\n    window->Pos = ImTrunc(pos);\n    ImVec2 offset = window->Pos - old_pos;\n    if (offset.x == 0.0f && offset.y == 0.0f)\n        return;\n    MarkIniSettingsDirty(window);\n    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor\n    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.\n    window->DC.IdealMaxPos += offset;\n    window->DC.CursorStartPos += offset;\n}\n\nvoid ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    SetWindowPos(window, pos, cond);\n}\n\nvoid ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)\n{\n    if (ImGuiWindow* window = FindWindowByName(name))\n        SetWindowPos(window, pos, cond);\n}\n\nImVec2 ImGui::GetWindowSize()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    return window->Size;\n}\n\nvoid ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)\n{\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\n    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)\n        return;\n\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\n    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\n\n    // Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)\n    if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)\n        window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;\n    if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)\n        window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;\n\n    // Set\n    ImVec2 old_size = window->SizeFull;\n    if (size.x <= 0.0f)\n        window->AutoFitOnlyGrows = false;\n    else\n        window->SizeFull.x = IM_TRUNC(size.x);\n    if (size.y <= 0.0f)\n        window->AutoFitOnlyGrows = false;\n    else\n        window->SizeFull.y = IM_TRUNC(size.y);\n    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)\n        MarkIniSettingsDirty(window);\n}\n\nvoid ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)\n{\n    SetWindowSize(GImGui->CurrentWindow, size, cond);\n}\n\nvoid ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)\n{\n    if (ImGuiWindow* window = FindWindowByName(name))\n        SetWindowSize(window, size, cond);\n}\n\nvoid ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)\n{\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\n    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)\n        return;\n    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\n\n    // Set\n    window->Collapsed = collapsed;\n}\n\nvoid ImGui::SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size)\n{\n    IM_ASSERT(window->HitTestHoleSize.x == 0);     // We don't support multiple holes/hit test filters\n    window->HitTestHoleSize = ImVec2ih(size);\n    window->HitTestHoleOffset = ImVec2ih(pos - window->Pos);\n}\n\nvoid ImGui::SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindow* window)\n{\n    window->Hidden = window->SkipItems = true;\n    window->HiddenFramesCanSkipItems = 1;\n}\n\nvoid ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)\n{\n    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);\n}\n\nbool ImGui::IsWindowCollapsed()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    return window->Collapsed;\n}\n\nbool ImGui::IsWindowAppearing()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    return window->Appearing;\n}\n\nvoid ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)\n{\n    if (ImGuiWindow* window = FindWindowByName(name))\n        SetWindowCollapsed(window, collapsed, cond);\n}\n\nvoid ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;\n    g.NextWindowData.PosVal = pos;\n    g.NextWindowData.PosPivotVal = pivot;\n    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;\n}\n\nvoid ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;\n    g.NextWindowData.SizeVal = size;\n    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;\n}\n\n// For each axis:\n// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.\n// - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.\n// - See \"Demo->Examples->Constrained-resizing window\" for examples.\nvoid ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)\n{\n    ImGuiContext& g = *GImGui;\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;\n    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);\n    g.NextWindowData.SizeCallback = custom_callback;\n    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;\n}\n\n// Content size = inner scrollable rectangle, padded with WindowPadding.\n// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.\nvoid ImGui::SetNextWindowContentSize(const ImVec2& size)\n{\n    ImGuiContext& g = *GImGui;\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;\n    g.NextWindowData.ContentSizeVal = ImTrunc(size);\n}\n\nvoid ImGui::SetNextWindowScroll(const ImVec2& scroll)\n{\n    ImGuiContext& g = *GImGui;\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;\n    g.NextWindowData.ScrollVal = scroll;\n}\n\nvoid ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;\n    g.NextWindowData.CollapsedVal = collapsed;\n    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;\n}\n\nvoid ImGui::SetNextWindowBgAlpha(float alpha)\n{\n    ImGuiContext& g = *GImGui;\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;\n    g.NextWindowData.BgAlphaVal = alpha;\n}\n\n// This is experimental and meant to be a toy for exploring a future/wider range of features.\nvoid ImGui::SetNextWindowRefreshPolicy(ImGuiWindowRefreshFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasRefreshPolicy;\n    g.NextWindowData.RefreshFlagsVal = flags;\n}\n\nImDrawList* ImGui::GetWindowDrawList()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    return window->DrawList;\n}\n\nImFont* ImGui::GetFont()\n{\n    return GImGui->Font;\n}\n\nfloat ImGui::GetFontSize()\n{\n    return GImGui->FontSize;\n}\n\nImVec2 ImGui::GetFontTexUvWhitePixel()\n{\n    return GImGui->DrawListSharedData.TexUvWhitePixel;\n}\n\nvoid ImGui::SetWindowFontScale(float scale)\n{\n    IM_ASSERT(scale > 0.0f);\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    window->FontWindowScale = scale;\n    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();\n    g.FontScale = g.DrawListSharedData.FontScale = g.FontSize / g.Font->FontSize;\n}\n\nvoid ImGui::PushFocusScope(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiFocusScopeData data;\n    data.ID = id;\n    data.WindowID = g.CurrentWindow->ID;\n    g.FocusScopeStack.push_back(data);\n    g.CurrentFocusScopeId = id;\n}\n\nvoid ImGui::PopFocusScope()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.FocusScopeStack.Size <= g.StackSizesInBeginForCurrentWindow->SizeOfFocusScopeStack)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopFocusScope() too many times!\");\n        return;\n    }\n    g.FocusScopeStack.pop_back();\n    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back().ID : 0;\n}\n\nvoid ImGui::SetNavFocusScope(ImGuiID focus_scope_id)\n{\n    ImGuiContext& g = *GImGui;\n    g.NavFocusScopeId = focus_scope_id;\n    g.NavFocusRoute.resize(0); // Invalidate\n    if (focus_scope_id == 0)\n        return;\n    IM_ASSERT(g.NavWindow != NULL);\n\n    // Store current path (in reverse order)\n    if (focus_scope_id == g.CurrentFocusScopeId)\n    {\n        // Top of focus stack contains local focus scopes inside current window\n        for (int n = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow->ID; n--)\n            g.NavFocusRoute.push_back(g.FocusScopeStack.Data[n]);\n    }\n    else if (focus_scope_id == g.NavWindow->NavRootFocusScopeId)\n        g.NavFocusRoute.push_back({ focus_scope_id, g.NavWindow->ID });\n    else\n        return;\n\n    // Then follow on manually set ParentWindowForFocusRoute field (#6798)\n    for (ImGuiWindow* window = g.NavWindow->ParentWindowForFocusRoute; window != NULL; window = window->ParentWindowForFocusRoute)\n        g.NavFocusRoute.push_back({ window->NavRootFocusScopeId, window->ID });\n    IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3\n}\n\n// Focus = move navigation cursor, set scrolling, set focus window.\nvoid ImGui::FocusItem()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IMGUI_DEBUG_LOG_FOCUS(\"FocusItem(0x%08x) in window \\\"%s\\\"\\n\", g.LastItemData.ID, window->Name);\n    if (g.DragDropActive || g.MovingWindow != NULL) // FIXME: Opt-in flags for this?\n    {\n        IMGUI_DEBUG_LOG_FOCUS(\"FocusItem() ignored while DragDropActive!\\n\");\n        return;\n    }\n\n    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavCursorVisible | ImGuiNavMoveFlags_NoSelect;\n    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;\n    SetNavWindow(window);\n    NavMoveRequestSubmit(ImGuiDir_None, ImGuiDir_Up, move_flags, scroll_flags);\n    NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);\n}\n\nvoid ImGui::ActivateItemByID(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    g.NavNextActivateId = id;\n    g.NavNextActivateFlags = ImGuiActivateFlags_None;\n}\n\n// Note: this will likely be called ActivateItem() once we rework our Focus/Activation system!\n// But ActivateItem() should function without altering scroll/focus?\nvoid ImGui::SetKeyboardFocusHere(int offset)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT(offset >= -1);    // -1 is allowed but not below\n    IMGUI_DEBUG_LOG_FOCUS(\"SetKeyboardFocusHere(%d) in window \\\"%s\\\"\\n\", offset, window->Name);\n\n    // It makes sense in the vast majority of cases to never interrupt a drag and drop.\n    // When we refactor this function into ActivateItem() we may want to make this an option.\n    // MovingWindow is protected from most user inputs using SetActiveIdUsingNavAndKeys(), but\n    // is also automatically dropped in the event g.ActiveId is stolen.\n    if (g.DragDropActive || g.MovingWindow != NULL)\n    {\n        IMGUI_DEBUG_LOG_FOCUS(\"SetKeyboardFocusHere() ignored while DragDropActive!\\n\");\n        return;\n    }\n\n    SetNavWindow(window);\n\n    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavCursorVisible;\n    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;\n    NavMoveRequestSubmit(ImGuiDir_None, offset < 0 ? ImGuiDir_Up : ImGuiDir_Down, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.\n    if (offset == -1)\n    {\n        NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);\n    }\n    else\n    {\n        g.NavTabbingDir = 1;\n        g.NavTabbingCounter = offset + 1;\n    }\n}\n\nvoid ImGui::SetItemDefaultFocus()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (!window->Appearing)\n        return;\n    if (g.NavWindow != window->RootWindowForNav || (!g.NavInitRequest && g.NavInitResult.ID == 0) || g.NavLayer != window->DC.NavLayerCurrent)\n        return;\n\n    g.NavInitRequest = false;\n    NavApplyItemToResult(&g.NavInitResult);\n    NavUpdateAnyRequestFlag();\n\n    // Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we however don't want regular init requests to scroll)\n    if (!window->ClipRect.Contains(g.LastItemData.Rect))\n        ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_None);\n}\n\nvoid ImGui::SetStateStorage(ImGuiStorage* tree)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    window->DC.StateStorage = tree ? tree : &window->StateStorage;\n}\n\nImGuiStorage* ImGui::GetStateStorage()\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->DC.StateStorage;\n}\n\nbool ImGui::IsRectVisible(const ImVec2& size)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));\n}\n\nbool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ID STACK\n//-----------------------------------------------------------------------------\n\n// This is one of the very rare legacy case where we use ImGuiWindow methods,\n// it should ideally be flattened at some point but it's been used a lots by widgets.\nIM_MSVC_RUNTIME_CHECKS_OFF\nImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)\n{\n    ImGuiID seed = IDStack.back();\n    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    ImGuiContext& g = *Ctx;\n    if (g.DebugHookIdInfo == id)\n        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);\n#endif\n    return id;\n}\n\nImGuiID ImGuiWindow::GetID(const void* ptr)\n{\n    ImGuiID seed = IDStack.back();\n    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    ImGuiContext& g = *Ctx;\n    if (g.DebugHookIdInfo == id)\n        ImGui::DebugHookIdInfo(id, ImGuiDataType_Pointer, ptr, NULL);\n#endif\n    return id;\n}\n\nImGuiID ImGuiWindow::GetID(int n)\n{\n    ImGuiID seed = IDStack.back();\n    ImGuiID id = ImHashData(&n, sizeof(n), seed);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    ImGuiContext& g = *Ctx;\n    if (g.DebugHookIdInfo == id)\n        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);\n#endif\n    return id;\n}\n\n// This is only used in rare/specific situations to manufacture an ID out of nowhere.\n// FIXME: Consider instead storing last non-zero ID + count of successive zero-ID, and combine those?\nImGuiID ImGuiWindow::GetIDFromPos(const ImVec2& p_abs)\n{\n    ImGuiID seed = IDStack.back();\n    ImVec2 p_rel = ImGui::WindowPosAbsToRel(this, p_abs);\n    ImGuiID id = ImHashData(&p_rel, sizeof(p_rel), seed);\n    return id;\n}\n\n// \"\nImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)\n{\n    ImGuiID seed = IDStack.back();\n    ImRect r_rel = ImGui::WindowRectAbsToRel(this, r_abs);\n    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);\n    return id;\n}\n\nvoid ImGui::PushID(const char* str_id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiID id = window->GetID(str_id);\n    window->IDStack.push_back(id);\n}\n\nvoid ImGui::PushID(const char* str_id_begin, const char* str_id_end)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiID id = window->GetID(str_id_begin, str_id_end);\n    window->IDStack.push_back(id);\n}\n\nvoid ImGui::PushID(const void* ptr_id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiID id = window->GetID(ptr_id);\n    window->IDStack.push_back(id);\n}\n\nvoid ImGui::PushID(int int_id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiID id = window->GetID(int_id);\n    window->IDStack.push_back(id);\n}\n\n// Push a given id value ignoring the ID stack as a seed.\nvoid ImGui::PushOverrideID(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    if (g.DebugHookIdInfo == id)\n        DebugHookIdInfo(id, ImGuiDataType_ID, NULL, NULL);\n#endif\n    window->IDStack.push_back(id);\n}\n\n// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call\n// (note that when using this pattern, ID Stack Tool will tend to not display the intermediate stack level.\n//  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)\nImGuiID ImGui::GetIDWithSeed(const char* str, const char* str_end, ImGuiID seed)\n{\n    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    ImGuiContext& g = *GImGui;\n    if (g.DebugHookIdInfo == id)\n        DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);\n#endif\n    return id;\n}\n\nImGuiID ImGui::GetIDWithSeed(int n, ImGuiID seed)\n{\n    ImGuiID id = ImHashData(&n, sizeof(n), seed);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    ImGuiContext& g = *GImGui;\n    if (g.DebugHookIdInfo == id)\n        DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);\n#endif\n    return id;\n}\n\nvoid ImGui::PopID()\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    if (window->IDStack.Size <= 1)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Calling PopID() too many times!\");\n        return;\n    }\n    window->IDStack.pop_back();\n}\n\nImGuiID ImGui::GetID(const char* str_id)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->GetID(str_id);\n}\n\nImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->GetID(str_id_begin, str_id_end);\n}\n\nImGuiID ImGui::GetID(const void* ptr_id)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->GetID(ptr_id);\n}\n\nImGuiID ImGui::GetID(int int_id)\n{\n    ImGuiWindow* window = GImGui->CurrentWindow;\n    return window->GetID(int_id);\n}\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n//-----------------------------------------------------------------------------\n// [SECTION] INPUTS\n//-----------------------------------------------------------------------------\n// - GetModForLRModKey() [Internal]\n// - FixupKeyChord() [Internal]\n// - GetKeyData() [Internal]\n// - GetKeyIndex() [Internal]\n// - GetKeyName()\n// - GetKeyChordName() [Internal]\n// - CalcTypematicRepeatAmount() [Internal]\n// - GetTypematicRepeatRate() [Internal]\n// - GetKeyPressedAmount() [Internal]\n// - GetKeyMagnitude2d() [Internal]\n//-----------------------------------------------------------------------------\n// - UpdateKeyRoutingTable() [Internal]\n// - GetRoutingIdFromOwnerId() [Internal]\n// - GetShortcutRoutingData() [Internal]\n// - CalcRoutingScore() [Internal]\n// - SetShortcutRouting() [Internal]\n// - TestShortcutRouting() [Internal]\n//-----------------------------------------------------------------------------\n// - IsKeyDown()\n// - IsKeyPressed()\n// - IsKeyReleased()\n//-----------------------------------------------------------------------------\n// - IsMouseDown()\n// - IsMouseClicked()\n// - IsMouseReleased()\n// - IsMouseDoubleClicked()\n// - GetMouseClickedCount()\n// - IsMouseHoveringRect() [Internal]\n// - IsMouseDragPastThreshold() [Internal]\n// - IsMouseDragging()\n// - GetMousePos()\n// - SetMousePos() [Internal]\n// - GetMousePosOnOpeningCurrentPopup()\n// - IsMousePosValid()\n// - IsAnyMouseDown()\n// - GetMouseDragDelta()\n// - ResetMouseDragDelta()\n// - GetMouseCursor()\n// - SetMouseCursor()\n//-----------------------------------------------------------------------------\n// - UpdateAliasKey()\n// - GetMergedModsFromKeys()\n// - UpdateKeyboardInputs()\n// - UpdateMouseInputs()\n//-----------------------------------------------------------------------------\n// - LockWheelingWindow [Internal]\n// - FindBestWheelingWindow [Internal]\n// - UpdateMouseWheel() [Internal]\n//-----------------------------------------------------------------------------\n// - SetNextFrameWantCaptureKeyboard()\n// - SetNextFrameWantCaptureMouse()\n//-----------------------------------------------------------------------------\n// - GetInputSourceName() [Internal]\n// - DebugPrintInputEvent() [Internal]\n// - UpdateInputEvents() [Internal]\n//-----------------------------------------------------------------------------\n// - GetKeyOwner() [Internal]\n// - TestKeyOwner() [Internal]\n// - SetKeyOwner() [Internal]\n// - SetItemKeyOwner() [Internal]\n// - Shortcut() [Internal]\n//-----------------------------------------------------------------------------\n\nstatic ImGuiKeyChord GetModForLRModKey(ImGuiKey key)\n{\n    if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)\n        return ImGuiMod_Ctrl;\n    if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)\n        return ImGuiMod_Shift;\n    if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)\n        return ImGuiMod_Alt;\n    if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)\n        return ImGuiMod_Super;\n    return ImGuiMod_None;\n}\n\nImGuiKeyChord ImGui::FixupKeyChord(ImGuiKeyChord key_chord)\n{\n    // Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.\n    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);\n    if (IsLRModKey(key))\n        key_chord |= GetModForLRModKey(key);\n    return key_chord;\n}\n\nImGuiKeyData* ImGui::GetKeyData(ImGuiContext* ctx, ImGuiKey key)\n{\n    ImGuiContext& g = *ctx;\n\n    // Special storage location for mods\n    if (key & ImGuiMod_Mask_)\n        key = ConvertSingleModFlagToKey(key);\n\n    IM_ASSERT(IsNamedKey(key) && \"Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.\");\n    return &g.IO.KeysData[key - ImGuiKey_NamedKey_BEGIN];\n}\n\n// Those names a provided for debugging purpose and are not meant to be saved persistently not compared.\nstatic const char* const GKeyNames[] =\n{\n    \"Tab\", \"LeftArrow\", \"RightArrow\", \"UpArrow\", \"DownArrow\", \"PageUp\", \"PageDown\",\n    \"Home\", \"End\", \"Insert\", \"Delete\", \"Backspace\", \"Space\", \"Enter\", \"Escape\",\n    \"LeftCtrl\", \"LeftShift\", \"LeftAlt\", \"LeftSuper\", \"RightCtrl\", \"RightShift\", \"RightAlt\", \"RightSuper\", \"Menu\",\n    \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n    \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"F10\", \"F11\", \"F12\",\n    \"F13\", \"F14\", \"F15\", \"F16\", \"F17\", \"F18\", \"F19\", \"F20\", \"F21\", \"F22\", \"F23\", \"F24\",\n    \"Apostrophe\", \"Comma\", \"Minus\", \"Period\", \"Slash\", \"Semicolon\", \"Equal\", \"LeftBracket\",\n    \"Backslash\", \"RightBracket\", \"GraveAccent\", \"CapsLock\", \"ScrollLock\", \"NumLock\", \"PrintScreen\",\n    \"Pause\", \"Keypad0\", \"Keypad1\", \"Keypad2\", \"Keypad3\", \"Keypad4\", \"Keypad5\", \"Keypad6\",\n    \"Keypad7\", \"Keypad8\", \"Keypad9\", \"KeypadDecimal\", \"KeypadDivide\", \"KeypadMultiply\",\n    \"KeypadSubtract\", \"KeypadAdd\", \"KeypadEnter\", \"KeypadEqual\",\n    \"AppBack\", \"AppForward\",\n    \"GamepadStart\", \"GamepadBack\",\n    \"GamepadFaceLeft\", \"GamepadFaceRight\", \"GamepadFaceUp\", \"GamepadFaceDown\",\n    \"GamepadDpadLeft\", \"GamepadDpadRight\", \"GamepadDpadUp\", \"GamepadDpadDown\",\n    \"GamepadL1\", \"GamepadR1\", \"GamepadL2\", \"GamepadR2\", \"GamepadL3\", \"GamepadR3\",\n    \"GamepadLStickLeft\", \"GamepadLStickRight\", \"GamepadLStickUp\", \"GamepadLStickDown\",\n    \"GamepadRStickLeft\", \"GamepadRStickRight\", \"GamepadRStickUp\", \"GamepadRStickDown\",\n    \"MouseLeft\", \"MouseRight\", \"MouseMiddle\", \"MouseX1\", \"MouseX2\", \"MouseWheelX\", \"MouseWheelY\",\n    \"ModCtrl\", \"ModShift\", \"ModAlt\", \"ModSuper\", // ReservedForModXXX are showing the ModXXX names.\n};\nIM_STATIC_ASSERT(ImGuiKey_NamedKey_COUNT == IM_ARRAYSIZE(GKeyNames));\n\nconst char* ImGui::GetKeyName(ImGuiKey key)\n{\n    if (key == ImGuiKey_None)\n        return \"None\";\n    IM_ASSERT(IsNamedKeyOrMod(key) && \"Support for user key indices was dropped in favor of ImGuiKey. Please update backend and user code.\");\n    if (key & ImGuiMod_Mask_)\n        key = ConvertSingleModFlagToKey(key);\n    if (!IsNamedKey(key))\n        return \"Unknown\";\n\n    return GKeyNames[key - ImGuiKey_NamedKey_BEGIN];\n}\n\n// Return untranslated names: on macOS, Cmd key will show as Ctrl, Ctrl key will show as super.\n// Lifetime of return value: valid until next call to same function.\nconst char* ImGui::GetKeyChordName(ImGuiKeyChord key_chord)\n{\n    ImGuiContext& g = *GImGui;\n\n    const ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);\n    if (IsLRModKey(key))\n        key_chord &= ~GetModForLRModKey(key); // Return \"Ctrl+LeftShift\" instead of \"Ctrl+Shift+LeftShift\"\n    ImFormatString(g.TempKeychordName, IM_ARRAYSIZE(g.TempKeychordName), \"%s%s%s%s%s\",\n        (key_chord & ImGuiMod_Ctrl) ? \"Ctrl+\" : \"\",\n        (key_chord & ImGuiMod_Shift) ? \"Shift+\" : \"\",\n        (key_chord & ImGuiMod_Alt) ? \"Alt+\" : \"\",\n        (key_chord & ImGuiMod_Super) ? \"Super+\" : \"\",\n        (key != ImGuiKey_None || key_chord == ImGuiKey_None) ? GetKeyName(key) : \"\");\n    size_t len;\n    if (key == ImGuiKey_None && key_chord != 0)\n        if ((len = strlen(g.TempKeychordName)) != 0) // Remove trailing '+'\n            g.TempKeychordName[len - 1] = 0;\n    return g.TempKeychordName;\n}\n\n// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)\n// t1 = current time (e.g.: g.Time)\n// An event is triggered at:\n//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N\nint ImGui::CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)\n{\n    if (t1 == 0.0f)\n        return 1;\n    if (t0 >= t1)\n        return 0;\n    if (repeat_rate <= 0.0f)\n        return (t0 < repeat_delay) && (t1 >= repeat_delay);\n    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);\n    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);\n    const int count = count_t1 - count_t0;\n    return count;\n}\n\nvoid ImGui::GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeat_delay, float* repeat_rate)\n{\n    ImGuiContext& g = *GImGui;\n    switch (flags & ImGuiInputFlags_RepeatRateMask_)\n    {\n    case ImGuiInputFlags_RepeatRateNavMove:             *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;\n    case ImGuiInputFlags_RepeatRateNavTweak:            *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;\n    case ImGuiInputFlags_RepeatRateDefault: default:    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;\n    }\n}\n\n// Return value representing the number of presses in the last time period, for the given repeat rate\n// (most often returns 0 or 1. The result is generally only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or fast RepeatRate)\nint ImGui::GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float repeat_rate)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiKeyData* key_data = GetKeyData(key);\n    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)\n        return 0;\n    const float t = key_data->DownDuration;\n    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);\n}\n\n// Return 2D vector representing the combination of four cardinal direction, with analog value support (for e.g. ImGuiKey_GamepadLStick* values).\nImVec2 ImGui::GetKeyMagnitude2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down)\n{\n    return ImVec2(\n        GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,\n        GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);\n}\n\n// Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.\n//   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D\n//   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6\n// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.\nstatic void ImGui::UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt)\n{\n    ImGuiContext& g = *GImGui;\n    rt->EntriesNext.resize(0);\n    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))\n    {\n        const int new_routing_start_idx = rt->EntriesNext.Size;\n        ImGuiKeyRoutingData* routing_entry;\n        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)\n        {\n            routing_entry = &rt->Entries[old_routing_idx];\n            routing_entry->RoutingCurrScore = routing_entry->RoutingNextScore;\n            routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry\n            routing_entry->RoutingNext = ImGuiKeyOwner_NoOwner;\n            routing_entry->RoutingNextScore = 255;\n            if (routing_entry->RoutingCurr == ImGuiKeyOwner_NoOwner)\n                continue;\n            rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer\n\n            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)\n            // This is the result of previous frame's SetShortcutRouting() call.\n            if (routing_entry->Mods == g.IO.KeyMods)\n            {\n                ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);\n                if (owner_data->OwnerCurr == ImGuiKeyOwner_NoOwner)\n                {\n                    owner_data->OwnerCurr = routing_entry->RoutingCurr;\n                    //IMGUI_DEBUG_LOG(\"SetKeyOwner(%s, owner_id=0x%08X) via Routing\\n\", GetKeyName(key), routing_entry->RoutingCurr);\n                }\n            }\n        }\n\n        // Rewrite linked-list\n        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);\n        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)\n            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);\n    }\n    rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes\n}\n\n// owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().\nstatic inline ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;\n}\n\nImGuiKeyRoutingData* ImGui::GetShortcutRoutingData(ImGuiKeyChord key_chord)\n{\n    // Majority of shortcuts will be Key + any number of Mods\n    // We accept _Single_ mod with ImGuiKey_None.\n    //  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl);                    // Legal\n    //  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl | ImGuiMod_Shift);   // Legal\n    //  - Shortcut(ImGuiMod_Ctrl);                                 // Legal\n    //  - Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift);                // Not legal\n    ImGuiContext& g = *GImGui;\n    ImGuiKeyRoutingTable* rt = &g.KeysRoutingTable;\n    ImGuiKeyRoutingData* routing_data;\n    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);\n    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);\n    if (key == ImGuiKey_None)\n        key = ConvertSingleModFlagToKey(mods);\n    IM_ASSERT(IsNamedKey(key));\n\n    // Get (in the majority of case, the linked list will have one element so this should be 2 reads.\n    // Subsequent elements will be contiguous in memory as list is sorted/rebuilt in NewFrame).\n    for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1; idx = routing_data->NextEntryIndex)\n    {\n        routing_data = &rt->Entries[idx];\n        if (routing_data->Mods == mods)\n            return routing_data;\n    }\n\n    // Add to linked-list\n    ImGuiKeyRoutingIndex routing_data_idx = (ImGuiKeyRoutingIndex)rt->Entries.Size;\n    rt->Entries.push_back(ImGuiKeyRoutingData());\n    routing_data = &rt->Entries[routing_data_idx];\n    routing_data->Mods = (ImU16)mods;\n    routing_data->NextEntryIndex = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; // Setup linked list\n    rt->Index[key - ImGuiKey_NamedKey_BEGIN] = routing_data_idx;\n    return routing_data;\n}\n\n// Current score encoding (lower is highest priority):\n//  -   0: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverActive\n//  -   1: ImGuiInputFlags_ActiveItem or ImGuiInputFlags_RouteFocused (if item active)\n//  -   2: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused\n//  -  3+: ImGuiInputFlags_RouteFocused (if window in focus-stack)\n//  - 254: ImGuiInputFlags_RouteGlobal\n//  - 255: never route\n// 'flags' should include an explicit routing policy\nstatic int CalcRoutingScore(ImGuiID focus_scope_id, ImGuiID owner_id, ImGuiInputFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    if (flags & ImGuiInputFlags_RouteFocused)\n    {\n        // ActiveID gets top priority\n        // (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if input ownership is tested later it may discard it)\n        if (owner_id != 0 && g.ActiveId == owner_id)\n            return 1;\n\n        // Score based on distance to focused window (lower is better)\n        // Assuming both windows are submitting a routing request,\n        // - When Window....... is focused -> Window scores 3 (best), Window/ChildB scores 255 (no match)\n        // - When Window/ChildB is focused -> Window scores 4,        Window/ChildB scores 3 (best)\n        // Assuming only WindowA is submitting a routing request,\n        // - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB doesn't have a score.\n        // This essentially follow the window->ParentWindowForFocusRoute chain.\n        if (focus_scope_id == 0)\n            return 255;\n        for (int index_in_focus_path = 0; index_in_focus_path < g.NavFocusRoute.Size; index_in_focus_path++)\n            if (g.NavFocusRoute.Data[index_in_focus_path].ID == focus_scope_id)\n                return 3 + index_in_focus_path;\n        return 255;\n    }\n    else if (flags & ImGuiInputFlags_RouteActive)\n    {\n        if (owner_id != 0 && g.ActiveId == owner_id)\n            return 1;\n        return 255;\n    }\n    else if (flags & ImGuiInputFlags_RouteGlobal)\n    {\n        if (flags & ImGuiInputFlags_RouteOverActive)\n            return 0;\n        if (flags & ImGuiInputFlags_RouteOverFocused)\n            return 2;\n        return 254;\n    }\n    IM_ASSERT(0);\n    return 0;\n}\n\n// - We need this to filter some Shortcut() routes when an item e.g. an InputText() is active\n//   e.g. ImGuiKey_G won't be considered a shortcut when item is active, but ImGuiMod|ImGuiKey_G can be.\n// - This is also used by UpdateInputEvents() to avoid trickling in the most common case of e.g. pressing ImGuiKey_G also emitting a G character.\nstatic bool IsKeyChordPotentiallyCharInput(ImGuiKeyChord key_chord)\n{\n    // Mimic 'ignore_char_inputs' logic in InputText()\n    ImGuiContext& g = *GImGui;\n\n    // When the right mods are pressed it cannot be a char input so we won't filter the shortcut out.\n    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);\n    const bool ignore_char_inputs = ((mods & ImGuiMod_Ctrl) && !(mods & ImGuiMod_Alt)) || (g.IO.ConfigMacOSXBehaviors && (mods & ImGuiMod_Ctrl));\n    if (ignore_char_inputs)\n        return false;\n\n    // Return true for A-Z, 0-9 and other keys associated to char inputs. Other keys such as F1-F12 won't be filtered.\n    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);\n    if (key == ImGuiKey_None)\n        return false;\n    return g.KeysMayBeCharInput.TestBit(key);\n}\n\n// Request a desired route for an input chord (key + mods).\n// Return true if the route is available this frame.\n// - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.\n//   (Conceptually this does a \"Submit for next frame\" + \"Test for current frame\".\n//   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)\nbool ImGui::SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)\n        flags |= ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()\n    else\n        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteTypeMask_)); // Check that only 1 routing flag is used\n    IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner);\n    if (flags & (ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused))\n        IM_ASSERT(flags & ImGuiInputFlags_RouteGlobal);\n\n    // Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.\n    key_chord = FixupKeyChord(key_chord);\n\n    // [DEBUG] Debug break requested by user\n    if (g.DebugBreakInShortcutRouting == key_chord)\n        IM_DEBUG_BREAK();\n\n    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)\n        if (g.NavWindow == NULL)\n            return false;\n\n    // Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?\n    if (flags & ImGuiInputFlags_RouteAlways)\n    {\n        IMGUI_DEBUG_LOG_INPUTROUTING(\"SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\\n\", GetKeyChordName(key_chord), flags, owner_id);\n        return true;\n    }\n\n    // Specific culling when there's an active item.\n    if (g.ActiveId != 0 && g.ActiveId != owner_id)\n    {\n        if (flags & ImGuiInputFlags_RouteActive)\n            return false;\n\n        // Cull shortcuts with no modifiers when it could generate a character.\n        // e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.\n        // but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.\n        // TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.\n        // (We cannot filter based on io.InputQueueCharacters[] contents because of trickling and key<>chars submission order are undefined)\n        if (g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord))\n        {\n            IMGUI_DEBUG_LOG_INPUTROUTING(\"SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential char input\\n\", GetKeyChordName(key_chord), flags, owner_id);\n            return false;\n        }\n\n        // ActiveIdUsingAllKeyboardKeys trumps all for ActiveId\n        if ((flags & ImGuiInputFlags_RouteOverActive) == 0 && g.ActiveIdUsingAllKeyboardKeys)\n        {\n            ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);\n            if (key == ImGuiKey_None)\n                key = ConvertSingleModFlagToKey((ImGuiKey)(key_chord & ImGuiMod_Mask_));\n            if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)\n                return false;\n        }\n    }\n\n    // Where do we evaluate route for?\n    ImGuiID focus_scope_id = g.CurrentFocusScopeId;\n    if (flags & ImGuiInputFlags_RouteFromRootWindow)\n        focus_scope_id = g.CurrentWindow->RootWindow->ID; // See PushFocusScope() call in Begin()\n\n    const int score = CalcRoutingScore(focus_scope_id, owner_id, flags);\n    IMGUI_DEBUG_LOG_INPUTROUTING(\"SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\\n\", GetKeyChordName(key_chord), flags, owner_id, score);\n    if (score == 255)\n        return false;\n\n    // Submit routing for NEXT frame (assuming score is sufficient)\n    // FIXME: Could expose a way to use a \"serve last\" policy for same score resolution (using <= instead of <).\n    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);\n    //const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);\n    if (score < routing_data->RoutingNextScore)\n    {\n        routing_data->RoutingNext = owner_id;\n        routing_data->RoutingNextScore = (ImU8)score;\n    }\n\n    // Return routing state for CURRENT frame\n    if (routing_data->RoutingCurr == owner_id)\n        IMGUI_DEBUG_LOG_INPUTROUTING(\"--> granting current route\\n\");\n    return routing_data->RoutingCurr == owner_id;\n}\n\n// Currently unused by core (but used by tests)\n// Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.\nbool ImGui::TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id)\n{\n    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);\n    key_chord = FixupKeyChord(key_chord);\n    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.\n    return routing_data->RoutingCurr == routing_id;\n}\n\n// Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.\n// Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)\nbool ImGui::IsKeyDown(ImGuiKey key)\n{\n    return IsKeyDown(key, ImGuiKeyOwner_Any);\n}\n\nbool ImGui::IsKeyDown(ImGuiKey key, ImGuiID owner_id)\n{\n    const ImGuiKeyData* key_data = GetKeyData(key);\n    if (!key_data->Down)\n        return false;\n    if (!TestKeyOwner(key, owner_id))\n        return false;\n    return true;\n}\n\nbool ImGui::IsKeyPressed(ImGuiKey key, bool repeat)\n{\n    return IsKeyPressed(key, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);\n}\n\n// Important: unlike legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.\nbool ImGui::IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id)\n{\n    const ImGuiKeyData* key_data = GetKeyData(key);\n    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)\n        return false;\n    const float t = key_data->DownDuration;\n    if (t < 0.0f)\n        return false;\n    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!\n    if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) // Setting any _RepeatXXX option enables _Repeat\n        flags |= ImGuiInputFlags_Repeat;\n\n    bool pressed = (t == 0.0f);\n    if (!pressed && (flags & ImGuiInputFlags_Repeat) != 0)\n    {\n        float repeat_delay, repeat_rate;\n        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);\n        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;\n        if (pressed && (flags & ImGuiInputFlags_RepeatUntilMask_))\n        {\n            // Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.\n            // Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.\n            ImGuiContext& g = *GImGui;\n            double key_pressed_time = g.Time - t + 0.00001f;\n            if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChange) && (g.LastKeyModsChangeTime > key_pressed_time))\n                pressed = false;\n            if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone) && (g.LastKeyModsChangeFromNoneTime > key_pressed_time))\n                pressed = false;\n            if ((flags & ImGuiInputFlags_RepeatUntilOtherKeyPress) && (g.LastKeyboardKeyPressTime > key_pressed_time))\n                pressed = false;\n        }\n    }\n    if (!pressed)\n        return false;\n    if (!TestKeyOwner(key, owner_id))\n        return false;\n    return true;\n}\n\nbool ImGui::IsKeyReleased(ImGuiKey key)\n{\n    return IsKeyReleased(key, ImGuiKeyOwner_Any);\n}\n\nbool ImGui::IsKeyReleased(ImGuiKey key, ImGuiID owner_id)\n{\n    const ImGuiKeyData* key_data = GetKeyData(key);\n    if (key_data->DownDurationPrev < 0.0f || key_data->Down)\n        return false;\n    if (!TestKeyOwner(key, owner_id))\n        return false;\n    return true;\n}\n\nbool ImGui::IsMouseDown(ImGuiMouseButton button)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.\n}\n\nbool ImGui::IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.\n}\n\nbool ImGui::IsMouseClicked(ImGuiMouseButton button, bool repeat)\n{\n    return IsMouseClicked(button, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);\n}\n\nbool ImGui::IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)\n        return false;\n    const float t = g.IO.MouseDownDuration[button];\n    if (t < 0.0f)\n        return false;\n    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsMouseClicked) == 0); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.\n\n    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;\n    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);\n    if (!pressed)\n        return false;\n\n    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))\n        return false;\n\n    return true;\n}\n\nbool ImGui::IsMouseReleased(ImGuiMouseButton button)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // Should be same as IsKeyReleased(MouseButtonToKey(button), ImGuiKeyOwner_Any)\n}\n\nbool ImGui::IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)\n}\n\nbool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);\n}\n\nbool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button, ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), owner_id);\n}\n\nint ImGui::GetMouseClickedCount(ImGuiMouseButton button)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    return g.IO.MouseClickedCount[button];\n}\n\n// Test if mouse cursor is hovering given rectangle\n// NB- Rectangle is clipped by our current clip setting\n// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)\nbool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)\n{\n    ImGuiContext& g = *GImGui;\n\n    // Clip\n    ImRect rect_clipped(r_min, r_max);\n    if (clip)\n        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);\n\n    // Hit testing, expanded for touch input\n    if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))\n        return false;\n    return true;\n}\n\n// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.\n// [Internal] This doesn't test if the button is pressed\nbool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    if (lock_threshold < 0.0f)\n        lock_threshold = g.IO.MouseDragThreshold;\n    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;\n}\n\nbool ImGui::IsMouseDragging(ImGuiMouseButton button, float lock_threshold)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    if (!g.IO.MouseDown[button])\n        return false;\n    return IsMouseDragPastThreshold(button, lock_threshold);\n}\n\nImVec2 ImGui::GetMousePos()\n{\n    ImGuiContext& g = *GImGui;\n    return g.IO.MousePos;\n}\n\n// This is called TeleportMousePos() and not SetMousePos() to emphasis that setting MousePosPrev will effectively clear mouse delta as well.\n// It is expected you only call this if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos) is set and supported by backend.\nvoid ImGui::TeleportMousePos(const ImVec2& pos)\n{\n    ImGuiContext& g = *GImGui;\n    g.IO.MousePos = g.IO.MousePosPrev = pos;\n    g.IO.MouseDelta = ImVec2(0.0f, 0.0f);\n    g.IO.WantSetMousePos = true;\n    //IMGUI_DEBUG_LOG_IO(\"TeleportMousePos: (%.1f,%.1f)\\n\", io.MousePos.x, io.MousePos.y);\n}\n\n// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!\nImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()\n{\n    ImGuiContext& g = *GImGui;\n    if (g.BeginPopupStack.Size > 0)\n        return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;\n    return g.IO.MousePos;\n}\n\n// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.\nbool ImGui::IsMousePosValid(const ImVec2* mouse_pos)\n{\n    // The assert is only to silence a false-positive in XCode Static Analysis.\n    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).\n    IM_ASSERT(GImGui != NULL);\n    const float MOUSE_INVALID = -256000.0f;\n    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;\n    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;\n}\n\n// [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.\nbool ImGui::IsAnyMouseDown()\n{\n    ImGuiContext& g = *GImGui;\n    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)\n        if (g.IO.MouseDown[n])\n            return true;\n    return false;\n}\n\n// Return the delta from the initial clicking position while the mouse button is clicked or was just released.\n// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.\n// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.\nImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    if (lock_threshold < 0.0f)\n        lock_threshold = g.IO.MouseDragThreshold;\n    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])\n        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)\n            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))\n                return g.IO.MousePos - g.IO.MouseClickedPos[button];\n    return ImVec2(0.0f, 0.0f);\n}\n\nvoid ImGui::ResetMouseDragDelta(ImGuiMouseButton button)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\n    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr\n    g.IO.MouseClickedPos[button] = g.IO.MousePos;\n}\n\n// Get desired mouse cursor shape.\n// Important: this is meant to be used by a platform backend, it is reset in ImGui::NewFrame(),\n// updated during the frame, and locked in EndFrame()/Render().\n// If you use software rendering by setting io.MouseDrawCursor then Dear ImGui will render those for you\nImGuiMouseCursor ImGui::GetMouseCursor()\n{\n    ImGuiContext& g = *GImGui;\n    return g.MouseCursor;\n}\n\n// We intentionally accept values of ImGuiMouseCursor that are outside our bounds, in case users needs to hack-in a custom cursor value.\n// Custom cursors may be handled by custom backends. If you are using a standard backend and want to hack in a custom cursor, you may\n// handle it before the backend _NewFrame() call and temporarily set ImGuiConfigFlags_NoMouseCursorChange during the backend _NewFrame() call.\nvoid ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)\n{\n    ImGuiContext& g = *GImGui;\n    g.MouseCursor = cursor_type;\n}\n\nstatic void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)\n{\n    IM_ASSERT(ImGui::IsAliasKey(key));\n    ImGuiKeyData* key_data = ImGui::GetKeyData(key);\n    key_data->Down = v;\n    key_data->AnalogValue = analog_value;\n}\n\n// [Internal] Do not use directly\nstatic ImGuiKeyChord GetMergedModsFromKeys()\n{\n    ImGuiKeyChord mods = 0;\n    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }\n    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }\n    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }\n    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }\n    return mods;\n}\n\nstatic void ImGui::UpdateKeyboardInputs()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiIO& io = g.IO;\n\n    if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)\n        io.ClearInputKeys();\n\n    // Update aliases\n    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)\n        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);\n    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);\n    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);\n\n    // Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.\n    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.\n    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.\n    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.\n    const ImGuiKeyChord prev_key_mods = io.KeyMods;\n    io.KeyMods = GetMergedModsFromKeys();\n    io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;\n    io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;\n    io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;\n    io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;\n    if (prev_key_mods != io.KeyMods)\n        g.LastKeyModsChangeTime = g.Time;\n    if (prev_key_mods != io.KeyMods && prev_key_mods == 0)\n        g.LastKeyModsChangeFromNoneTime = g.Time;\n\n    // Clear gamepad data if disabled\n    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)\n        for (int key = ImGuiKey_Gamepad_BEGIN; key < ImGuiKey_Gamepad_END; key++)\n        {\n            io.KeysData[key - ImGuiKey_NamedKey_BEGIN].Down = false;\n            io.KeysData[key - ImGuiKey_NamedKey_BEGIN].AnalogValue = 0.0f;\n        }\n\n    // Update keys\n    for (int key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key++)\n    {\n        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_NamedKey_BEGIN];\n        key_data->DownDurationPrev = key_data->DownDuration;\n        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;\n        if (key_data->DownD"
        },
        {
          "name": "imgui.h",
          "type": "blob",
          "size": 365.73,
          "content": "// dear imgui, v1.91.7 WIP\n// (headers)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n// - Add '#define IMGUI_DEFINE_MATH_OPERATORS' before including this file (or in imconfig.h) to access courtesy maths operators for ImVec2 and ImVec4.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Library Version\n// (Integer encoded as XYYZZ for use in #if preprocessor conditionals, e.g. '#if IMGUI_VERSION_NUM >= 12345')\n#define IMGUI_VERSION       \"1.91.7 WIP\"\n#define IMGUI_VERSION_NUM   19164\n#define IMGUI_HAS_TABLE\n\n/*\n\nIndex of this file:\n// [SECTION] Header mess\n// [SECTION] Forward declarations and basic types\n// [SECTION] Dear ImGui end-user API functions\n// [SECTION] Flags & Enumerations\n// [SECTION] Tables API flags and structures (ImGuiTableFlags, ImGuiTableColumnFlags, ImGuiTableRowFlags, ImGuiTableBgTarget, ImGuiTableSortSpecs, ImGuiTableColumnSortSpecs)\n// [SECTION] Helpers: Debug log, Memory allocations macros, ImVector<>\n// [SECTION] ImGuiStyle\n// [SECTION] ImGuiIO\n// [SECTION] Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)\n// [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)\n// [SECTION] Multi-Select API flags and structures (ImGuiMultiSelectFlags, ImGuiMultiSelectIO, ImGuiSelectionRequest, ImGuiSelectionBasicStorage, ImGuiSelectionExternalStorage)\n// [SECTION] Drawing API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawFlags, ImDrawListFlags, ImDrawList, ImDrawData)\n// [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)\n// [SECTION] Viewports (ImGuiViewportFlags, ImGuiViewport)\n// [SECTION] ImGuiPlatformIO + other Platform Dependent Interfaces (ImGuiPlatformImeData)\n// [SECTION] Obsolete functions and types\n\n*/\n\n#pragma once\n\n// Configuration file with compile-time options\n// (edit imconfig.h or '#define IMGUI_USER_CONFIG \"myfilename.h\" from your build system)\n#ifdef IMGUI_USER_CONFIG\n#include IMGUI_USER_CONFIG\n#endif\n#include \"imconfig.h\"\n\n#ifndef IMGUI_DISABLE\n\n//-----------------------------------------------------------------------------\n// [SECTION] Header mess\n//-----------------------------------------------------------------------------\n\n// Includes\n#include <float.h>                  // FLT_MIN, FLT_MAX\n#include <stdarg.h>                 // va_list, va_start, va_end\n#include <stddef.h>                 // ptrdiff_t, NULL\n#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp\n\n// Define attributes of all API symbols declarations (e.g. for DLL under Windows)\n// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default backends files (imgui_impl_xxx.h)\n// Using dear imgui via a shared library is not recommended: we don't guarantee backward nor forward ABI compatibility + this is a call-heavy library and function call overhead adds up.\n#ifndef IMGUI_API\n#define IMGUI_API\n#endif\n#ifndef IMGUI_IMPL_API\n#define IMGUI_IMPL_API              IMGUI_API\n#endif\n\n// Helper Macros\n#ifndef IM_ASSERT\n#include <assert.h>\n#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h\n#endif\n#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!\n#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence \"unused variable warnings\". Often useful as asserts may be stripped out from final builds.\n\n// Check that version and structures layouts are matching between compiled imgui code and caller. Read comments above DebugCheckVersionAndDataLayout() for details.\n#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert), sizeof(ImDrawIdx))\n\n// Helper Macros - IM_FMTARGS, IM_FMTLIST: Apply printf-style warnings to our formatting functions.\n// (MSVC provides an equivalent mechanism via SAL Annotations but it would require the macros in a different\n//  location. e.g. #include <sal.h> + void myprintf(_Printf_format_string_ const char* format, ...))\n#if !defined(IMGUI_USE_STB_SPRINTF) && defined(__MINGW32__) && !defined(__clang__)\n#define IM_FMTARGS(FMT)             __attribute__((format(gnu_printf, FMT, FMT+1)))\n#define IM_FMTLIST(FMT)             __attribute__((format(gnu_printf, FMT, 0)))\n#elif !defined(IMGUI_USE_STB_SPRINTF) && (defined(__clang__) || defined(__GNUC__))\n#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1)))\n#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))\n#else\n#define IM_FMTARGS(FMT)\n#define IM_FMTLIST(FMT)\n#endif\n\n// Disable some of MSVC most aggressive Debug runtime checks in function header/footer (used in some simple/low-level functions)\n#if defined(_MSC_VER) && !defined(__clang__)  && !defined(__INTEL_COMPILER) && !defined(IMGUI_DEBUG_PARANOID)\n#define IM_MSVC_RUNTIME_CHECKS_OFF      __pragma(runtime_checks(\"\",off))     __pragma(check_stack(off)) __pragma(strict_gs_check(push,off))\n#define IM_MSVC_RUNTIME_CHECKS_RESTORE  __pragma(runtime_checks(\"\",restore)) __pragma(check_stack())    __pragma(strict_gs_check(pop))\n#else\n#define IM_MSVC_RUNTIME_CHECKS_OFF\n#define IM_MSVC_RUNTIME_CHECKS_RESTORE\n#endif\n\n// Warnings\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 26495)    // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).\n#endif\n#if defined(__clang__)\n#pragma clang diagnostic push\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#elif defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Forward declarations and basic types\n//-----------------------------------------------------------------------------\n\n// Scalar data types\ntypedef unsigned int        ImGuiID;// A unique ID used by widgets (typically the result of hashing a stack of string)\ntypedef signed char         ImS8;   // 8-bit signed integer\ntypedef unsigned char       ImU8;   // 8-bit unsigned integer\ntypedef signed short        ImS16;  // 16-bit signed integer\ntypedef unsigned short      ImU16;  // 16-bit unsigned integer\ntypedef signed int          ImS32;  // 32-bit signed integer == int\ntypedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)\ntypedef signed   long long  ImS64;  // 64-bit signed integer\ntypedef unsigned long long  ImU64;  // 64-bit unsigned integer\n\n// Forward declarations\nstruct ImDrawChannel;               // Temporary storage to output draw commands out of order, used by ImDrawListSplitter and ImDrawList::ChannelsSplit()\nstruct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)\nstruct ImDrawData;                  // All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.\nstruct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic \"mesh\" builder)\nstruct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)\nstruct ImDrawListSplitter;          // Helper to split a draw list into different layers which can be drawn into out of order, then flattened back.\nstruct ImDrawVert;                  // A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)\nstruct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas\nstruct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader\nstruct ImFontBuilderIO;             // Opaque interface to a font builder (stb_truetype or FreeType).\nstruct ImFontConfig;                // Configuration data when adding a font or merging fonts\nstruct ImFontGlyph;                 // A single font glyph (code point + coordinates within in ImFontAtlas + offset)\nstruct ImFontGlyphRangesBuilder;    // Helper to build glyph ranges from text/string data\nstruct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)\nstruct ImGuiContext;                // Dear ImGui context (opaque structure, unless including imgui_internal.h)\nstruct ImGuiIO;                     // Main configuration and I/O between your application and ImGui (also see: ImGuiPlatformIO)\nstruct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)\nstruct ImGuiKeyData;                // Storage for ImGuiIO and IsKeyDown(), IsKeyPressed() etc functions.\nstruct ImGuiListClipper;            // Helper to manually clip large list of items\nstruct ImGuiMultiSelectIO;          // Structure to interact with a BeginMultiSelect()/EndMultiSelect() block\nstruct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame\nstruct ImGuiPayload;                // User data payload for drag and drop operations\nstruct ImGuiPlatformIO;             // Interface between platform/renderer backends and ImGui (e.g. Clipboard, IME hooks). Extends ImGuiIO. In docking branch, this gets extended to support multi-viewports.\nstruct ImGuiPlatformImeData;        // Platform IME data for io.PlatformSetImeDataFn() function.\nstruct ImGuiSelectionBasicStorage;  // Optional helper to store multi-selection state + apply multi-selection requests.\nstruct ImGuiSelectionExternalStorage;//Optional helper to apply multi-selection requests to existing randomly accessible storage.\nstruct ImGuiSelectionRequest;       // A selection request (stored in ImGuiMultiSelectIO)\nstruct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)\nstruct ImGuiStorage;                // Helper for key->value storage (container sorted by key)\nstruct ImGuiStoragePair;            // Helper for key->value storage (pair)\nstruct ImGuiStyle;                  // Runtime data for styling/colors\nstruct ImGuiTableSortSpecs;         // Sorting specifications for a table (often handling sort specs for a single column, occasionally more)\nstruct ImGuiTableColumnSortSpecs;   // Sorting specification for one column of a table\nstruct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)\nstruct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. \"aaaaa[,bbbbb][,ccccc]\")\nstruct ImGuiViewport;               // A Platform Window (always only one in 'master' branch), in the future may represent Platform Monitor\n\n// Enumerations\n// - We don't use strongly typed enums much because they add constraints (can't extend in private code, can't store typed in bit fields, extra casting on iteration)\n// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!\n//   - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n//   - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\nenum ImGuiDir : int;                // -> enum ImGuiDir              // Enum: A cardinal direction (Left, Right, Up, Down)\nenum ImGuiKey : int;                // -> enum ImGuiKey              // Enum: A key identifier (ImGuiKey_XXX or ImGuiMod_XXX value)\nenum ImGuiMouseSource : int;        // -> enum ImGuiMouseSource      // Enum; A mouse input source identifier (Mouse, TouchScreen, Pen)\nenum ImGuiSortDirection : ImU8;     // -> enum ImGuiSortDirection    // Enum: A sorting direction (ascending or descending)\ntypedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling\ntypedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for many Set*() functions\ntypedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type\ntypedef int ImGuiMouseButton;       // -> enum ImGuiMouseButton_     // Enum: A mouse button identifier (0=left, 1=right, 2=middle)\ntypedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor shape\ntypedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling\ntypedef int ImGuiTableBgTarget;     // -> enum ImGuiTableBgTarget_   // Enum: A color target for TableSetBgColor()\n\n// Flags (declared as int to allow using as flags without overhead, and to not pollute the top of this file)\n// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!\n//   - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n//   - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\ntypedef int ImDrawFlags;            // -> enum ImDrawFlags_          // Flags: for ImDrawList functions\ntypedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList instance\ntypedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas build\ntypedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags\ntypedef int ImGuiButtonFlags;       // -> enum ImGuiButtonFlags_     // Flags: for InvisibleButton()\ntypedef int ImGuiChildFlags;        // -> enum ImGuiChildFlags_      // Flags: for BeginChild()\ntypedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit4(), ColorPicker4() etc.\ntypedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags\ntypedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()\ntypedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for BeginDragDropSource(), AcceptDragDropPayload()\ntypedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()\ntypedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.\ntypedef int ImGuiInputFlags;        // -> enum ImGuiInputFlags_      // Flags: for Shortcut(), SetNextItemShortcut()\ntypedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText(), InputTextMultiline()\ntypedef int ImGuiItemFlags;         // -> enum ImGuiItemFlags_       // Flags: for PushItemFlag(), shared by all items\ntypedef int ImGuiKeyChord;          // -> ImGuiKey | ImGuiMod_XXX    // Flags: for IsKeyChordPressed(), Shortcut() etc. an ImGuiKey optionally OR-ed with one or more ImGuiMod_XXX values.\ntypedef int ImGuiPopupFlags;        // -> enum ImGuiPopupFlags_      // Flags: for OpenPopup*(), BeginPopupContext*(), IsPopupOpen()\ntypedef int ImGuiMultiSelectFlags;  // -> enum ImGuiMultiSelectFlags_// Flags: for BeginMultiSelect()\ntypedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()\ntypedef int ImGuiSliderFlags;       // -> enum ImGuiSliderFlags_     // Flags: for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.\ntypedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()\ntypedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()\ntypedef int ImGuiTableFlags;        // -> enum ImGuiTableFlags_      // Flags: For BeginTable()\ntypedef int ImGuiTableColumnFlags;  // -> enum ImGuiTableColumnFlags_// Flags: For TableSetupColumn()\ntypedef int ImGuiTableRowFlags;     // -> enum ImGuiTableRowFlags_   // Flags: For TableNextRow()\ntypedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()\ntypedef int ImGuiViewportFlags;     // -> enum ImGuiViewportFlags_   // Flags: for ImGuiViewport\ntypedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin(), BeginChild()\n\n// ImTexture: user data for renderer backend to identify a texture [Compile-time configurable type]\n// - To use something else than an opaque void* pointer: override with e.g. '#define ImTextureID MyTextureType*' in your imconfig.h file.\n// - This can be whatever to you want it to be! read the FAQ about ImTextureID for details.\n// - You can make this a structure with various constructors if you need. You will have to implement ==/!= operators.\n// - (note: before v1.91.4 (2024/10/08) the default type for ImTextureID was void*. Use intermediary intptr_t cast and read FAQ if you have casting warnings)\n#ifndef ImTextureID\ntypedef ImU64 ImTextureID;          // Default: store a pointer or an integer fitting in a pointer (most renderer backends are ok with that)\n#endif\n\n// ImDrawIdx: vertex index. [Compile-time configurable type]\n// - To use 16-bit indices + allow large meshes: backend need to set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset (recommended).\n// - To use 32-bit indices: override with '#define ImDrawIdx unsigned int' in your imconfig.h file.\n#ifndef ImDrawIdx\ntypedef unsigned short ImDrawIdx;   // Default: 16-bit (for maximum compatibility with renderer backends)\n#endif\n\n// Character types\n// (we generally use UTF-8 encoded string in the API. This is storage specifically for a decoded character used for keyboard input and display)\ntypedef unsigned int ImWchar32;     // A single decoded U32 character/code point. We encode them as multi bytes UTF-8 when used in strings.\ntypedef unsigned short ImWchar16;   // A single decoded U16 character/code point. We encode them as multi bytes UTF-8 when used in strings.\n#ifdef IMGUI_USE_WCHAR32            // ImWchar [configurable type: override in imconfig.h with '#define IMGUI_USE_WCHAR32' to support Unicode planes 1-16]\ntypedef ImWchar32 ImWchar;\n#else\ntypedef ImWchar16 ImWchar;\n#endif\n\n// Multi-Selection item index or identifier when using BeginMultiSelect()\n// - Used by SetNextItemSelectionUserData() + and inside ImGuiMultiSelectIO structure.\n// - Most users are likely to use this store an item INDEX but this may be used to store a POINTER/ID as well. Read comments near ImGuiMultiSelectIO for details.\ntypedef ImS64 ImGuiSelectionUserData;\n\n// Callback and functions types\ntypedef int     (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData* data);    // Callback function for ImGui::InputText()\ntypedef void    (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);              // Callback function for ImGui::SetNextWindowSizeConstraints()\ntypedef void*   (*ImGuiMemAllocFunc)(size_t sz, void* user_data);               // Function signature for ImGui::SetAllocatorFunctions()\ntypedef void    (*ImGuiMemFreeFunc)(void* ptr, void* user_data);                // Function signature for ImGui::SetAllocatorFunctions()\n\n// ImVec2: 2D vector used to store positions, sizes etc. [Compile-time configurable type]\n// - This is a frequently used type in the API. Consider using IM_VEC2_CLASS_EXTRA to create implicit cast from/to our preferred type.\n// - Add '#define IMGUI_DEFINE_MATH_OPERATORS' before including this file (or in imconfig.h) to access courtesy maths operators for ImVec2 and ImVec4.\nIM_MSVC_RUNTIME_CHECKS_OFF\nstruct ImVec2\n{\n    float                                   x, y;\n    constexpr ImVec2()                      : x(0.0f), y(0.0f) { }\n    constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }\n    float& operator[] (size_t idx)          { IM_ASSERT(idx == 0 || idx == 1); return ((float*)(void*)(char*)this)[idx]; } // We very rarely use this [] operator, so the assert overhead is fine.\n    float  operator[] (size_t idx) const    { IM_ASSERT(idx == 0 || idx == 1); return ((const float*)(const void*)(const char*)this)[idx]; }\n#ifdef IM_VEC2_CLASS_EXTRA\n    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.\n#endif\n};\n\n// ImVec4: 4D vector used to store clipping rectangles, colors etc. [Compile-time configurable type]\nstruct ImVec4\n{\n    float                                                     x, y, z, w;\n    constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }\n    constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }\n#ifdef IM_VEC4_CLASS_EXTRA\n    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.\n#endif\n};\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n//-----------------------------------------------------------------------------\n// [SECTION] Dear ImGui end-user API functions\n// (Note that ImGui:: being a namespace, you can add extra ImGui:: functions in your own separate file. Please don't modify imgui source files!)\n//-----------------------------------------------------------------------------\n\nnamespace ImGui\n{\n    // Context creation and access\n    // - Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between contexts.\n    // - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()\n    //   for each static/DLL boundary you are calling from. Read \"Context and Memory Allocators\" section of imgui.cpp for details.\n    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);\n    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context\n    IMGUI_API ImGuiContext* GetCurrentContext();\n    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);\n\n    // Main\n    IMGUI_API ImGuiIO&      GetIO();                                    // access the ImGuiIO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)\n    IMGUI_API ImGuiPlatformIO& GetPlatformIO();                         // access the ImGuiPlatformIO structure (mostly hooks/functions to connect to platform/renderer and OS Clipboard, IME etc.)\n    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleColor(), PushStyleVar() to modify style mid-frame!\n    IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().\n    IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!\n    IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().\n    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.\n\n    // Demo, Debug, Information\n    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!\n    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.\n    IMGUI_API void          ShowDebugLogWindow(bool* p_open = NULL);    // create Debug Log window. display a simplified log of important dear imgui events.\n    IMGUI_API void          ShowIDStackToolWindow(bool* p_open = NULL); // create Stack Tool window. hover items with mouse to query information about the source of their unique ID.\n    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create About window. display Dear ImGui version, credits and build/system information.\n    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)\n    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.\n    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.\n    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as an end-user (mouse/keyboard controls).\n    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. \"1.80 WIP\" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)\n\n    // Styles\n    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)\n    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font\n    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style\n\n    // Windows\n    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.\n    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,\n    //   which clicking will set the boolean to false when clicked.\n    // - You may append multiple times to the same window during the same frame by calling Begin()/End() pairs multiple times.\n    //   Some information such as 'flags' or 'p_open' will only be considered by the first call to Begin().\n    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting\n    //   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!\n    //   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions\n    //    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding\n    //    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]\n    // - Note that the bottom of window stack always contains a window called \"Debug\".\n    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);\n    IMGUI_API void          End();\n\n    // Child Windows\n    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.\n    // - Before 1.90 (November 2023), the \"ImGuiChildFlags child_flags = 0\" parameter was \"bool border = false\".\n    //   This API is backward compatible with old code, as we guarantee that ImGuiChildFlags_Borders == true.\n    //   Consider updating your old code:\n    //      BeginChild(\"Name\", size, false)   -> Begin(\"Name\", size, 0); or Begin(\"Name\", size, ImGuiChildFlags_None);\n    //      BeginChild(\"Name\", size, true)    -> Begin(\"Name\", size, ImGuiChildFlags_Borders);\n    // - Manual sizing (each axis can use a different setting e.g. ImVec2(0.0f, 400.0f)):\n    //     == 0.0f: use remaining parent window size for this axis.\n    //      > 0.0f: use specified size for this axis.\n    //      < 0.0f: right/bottom-align to specified distance from available content boundaries.\n    // - Specifying ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY makes the sizing automatic based on child contents.\n    //   Combining both ImGuiChildFlags_AutoResizeX _and_ ImGuiChildFlags_AutoResizeY defeats purpose of a scrolling region and is NOT recommended.\n    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting\n    //   anything to the window. Always call a matching EndChild() for each BeginChild() call, regardless of its return value.\n    //   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions\n    //    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding\n    //    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]\n    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0, 0), ImGuiChildFlags child_flags = 0, ImGuiWindowFlags window_flags = 0);\n    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), ImGuiChildFlags child_flags = 0, ImGuiWindowFlags window_flags = 0);\n    IMGUI_API void          EndChild();\n\n    // Windows Utilities\n    // - 'current window' = the window we are appending into while inside a Begin()/End() block. 'next window' = next window we will Begin() into.\n    IMGUI_API bool          IsWindowAppearing();\n    IMGUI_API bool          IsWindowCollapsed();\n    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.\n    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry \"How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?\" for details.\n    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the current window, to append your own drawing primitives\n    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)\n    IMGUI_API ImVec2        GetWindowSize();                            // get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)\n    IMGUI_API float         GetWindowWidth();                           // get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.\n    IMGUI_API float         GetWindowHeight();                          // get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.\n\n    // Window manipulation\n    // - Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).\n    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0, 0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.\n    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()\n    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.\n    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()\n    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()\n    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / top-most. call before Begin()\n    IMGUI_API void          SetNextWindowScroll(const ImVec2& scroll);                                  // set next window scrolling value (use < 0.0f to not affect a given axis).\n    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.\n    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.\n    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.\n    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().\n    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().\n    IMGUI_API void          SetWindowFontScale(float scale);                                            // [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().\n    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.\n    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.\n    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state\n    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / top-most. use NULL to remove focus.\n\n    // Windows Scrolling\n    // - Any change of Scroll will be applied at the beginning of next frame in the first call to Begin().\n    // - You may instead use SetNextWindowScroll() prior to calling Begin() to avoid this delay, as an alternative to using SetScrollX()/SetScrollY().\n    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0 .. GetScrollMaxX()]\n    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0 .. GetScrollMaxY()]\n    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0 .. GetScrollMaxX()]\n    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0 .. GetScrollMaxY()]\n    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x\n    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y\n    IMGUI_API void          SetScrollHereX(float center_x_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead.\n    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead.\n    IMGUI_API void          SetScrollFromPosX(float local_x, float center_x_ratio = 0.5f);  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.\n    IMGUI_API void          SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.\n\n    // Parameters stacks (shared)\n    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font\n    IMGUI_API void          PopFont();\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);                        // modify a style color. always use this if you modify the style after NewFrame().\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);\n    IMGUI_API void          PopStyleColor(int count = 1);\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);                     // modify a style float variable. always use this if you modify the style after NewFrame()!\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);             // modify a style ImVec2 variable. \"\n    IMGUI_API void          PushStyleVarX(ImGuiStyleVar idx, float val_x);                  // modify X component of a style ImVec2 variable. \"\n    IMGUI_API void          PushStyleVarY(ImGuiStyleVar idx, float val_y);                  // modify Y component of a style ImVec2 variable. \"\n    IMGUI_API void          PopStyleVar(int count = 1);\n    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);              // modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)\n    IMGUI_API void          PopItemFlag();\n\n    // Parameters stacks (current window)\n    IMGUI_API void          PushItemWidth(float item_width);                                // push width of items for common large \"item+label\" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).\n    IMGUI_API void          PopItemWidth();\n    IMGUI_API void          SetNextItemWidth(float item_width);                             // set width of the _next_ common large \"item+label\" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)\n    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.\n    IMGUI_API void          PushTextWrapPos(float wrap_local_pos_x = 0.0f);                 // push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space\n    IMGUI_API void          PopTextWrapPos();\n\n    // Style read access\n    // - Use the ShowStyleEditor() function to interactively see/edit the colors.\n    IMGUI_API ImFont*       GetFont();                                                      // get current font\n    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied\n    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API\n    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList\n    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList\n    IMGUI_API ImU32         GetColorU32(ImU32 col, float alpha_mul = 1.0f);                 // retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList\n    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.\n\n    // Layout cursor positioning\n    // - By \"cursor\" we mean the current output position.\n    // - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.\n    // - You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceding widget.\n    // - YOU CAN DO 99% OF WHAT YOU NEED WITH ONLY GetCursorScreenPos() and GetContentRegionAvail().\n    // - Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API:\n    //    - Absolute coordinate:        GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions. -> this is the preferred way forward.\n    //    - Window-local coordinates:   SameLine(offset), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), PushTextWrapPos()\n    //    - Window-local coordinates:   GetContentRegionMax(), GetWindowContentRegionMin(), GetWindowContentRegionMax() --> all obsoleted. YOU DON'T NEED THEM.\n    // - GetCursorScreenPos() = GetCursorPos() + GetWindowPos(). GetWindowPos() is almost only ever useful to convert from window-local to absolute coordinates. Try not to use it.\n    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).\n    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                          // cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.\n    IMGUI_API ImVec2        GetContentRegionAvail();                                        // available space from current position. THIS IS YOUR BEST FRIEND.\n    IMGUI_API ImVec2        GetCursorPos();                                                 // [window-local] cursor position in window-local coordinates. This is not your best friend.\n    IMGUI_API float         GetCursorPosX();                                                // [window-local] \"\n    IMGUI_API float         GetCursorPosY();                                                // [window-local] \"\n    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          // [window-local] \"\n    IMGUI_API void          SetCursorPosX(float local_x);                                   // [window-local] \"\n    IMGUI_API void          SetCursorPosY(float local_y);                                   // [window-local] \"\n    IMGUI_API ImVec2        GetCursorStartPos();                                            // [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.\n\n    // Other layout functions\n    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.\n    IMGUI_API void          SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);  // call between widgets or groups to layout them horizontally. X position given in window coordinates.\n    IMGUI_API void          NewLine();                                                      // undo a SameLine() or force a new line when in a horizontal-layout context.\n    IMGUI_API void          Spacing();                                                      // add vertical spacing.\n    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.\n    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0\n    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0\n    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position\n    IMGUI_API void          EndGroup();                                                     // unlock horizontal starting position + capture the whole group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\n    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)\n    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize\n    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)\n    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2\n    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)\n\n    // ID stack/scopes\n    // Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about how ID are handled in dear imgui.\n    // - Those questions are answered and impacted by understanding of the ID stack system:\n    //   - \"Q: Why is my widget not reacting when I click on it?\"\n    //   - \"Q: How can I have widgets with an empty label?\"\n    //   - \"Q: How can I have multiple widgets with the same label?\"\n    // - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely\n    //   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.\n    // - You can also use the \"Label##foobar\" syntax within widget label to distinguish them from each others.\n    // - In this header file we use the \"label\"/\"name\" terminology to denote a string that will be displayed + used as an ID,\n    //   whereas \"str_id\" denote a string that is only used as an ID and not normally displayed.\n    IMGUI_API void          PushID(const char* str_id);                                     // push string into the ID stack (will hash string).\n    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);       // push string into the ID stack (will hash string).\n    IMGUI_API void          PushID(const void* ptr_id);                                     // push pointer into the ID stack (will hash pointer).\n    IMGUI_API void          PushID(int int_id);                                             // push integer into the ID stack (will hash integer).\n    IMGUI_API void          PopID();                                                        // pop from the ID stack.\n    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself\n    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);\n    IMGUI_API ImGuiID       GetID(const void* ptr_id);\n    IMGUI_API ImGuiID       GetID(int int_id);\n\n    // Widgets: Text\n    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL); // raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.\n    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // formatted text\n    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);\n    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();\n    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);\n    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();\n    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);\n    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().\n    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);\n    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets\n    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);\n    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()\n    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);\n    IMGUI_API void          SeparatorText(const char* label);                               // currently: formatted text with an horizontal line\n\n    // Widgets: Main\n    // - Most widgets return true when the value has been changed or when pressed/selected\n    // - You may also use one of the many IsItemXXX functions (e.g. IsItemActive, IsItemHovered, etc.) to query widget state.\n    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0, 0));   // button\n    IMGUI_API bool          SmallButton(const char* label);                                 // button with (FramePadding.y == 0) to easily embed within text\n    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size, ImGuiButtonFlags flags = 0); // flexible button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)\n    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape\n    IMGUI_API bool          Checkbox(const char* label, bool* v);\n    IMGUI_API bool          CheckboxFlags(const char* label, int* flags, int flags_value);\n    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);\n    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton(\"one\", my_value==1)) { my_value = 1; }\n    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer\n    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-FLT_MIN, 0), const char* overlay = NULL);\n    IMGUI_API void          Bullet();                                                       // draw a small circle + keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses\n    IMGUI_API bool          TextLink(const char* label);                                    // hyperlink text button, return true when clicked\n    IMGUI_API void          TextLinkOpenURL(const char* label, const char* url = NULL);     // hyperlink text button, automatically open file/url when clicked\n\n    // Widgets: Images\n    // - Read about ImTextureID here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples\n    // - 'uv0' and 'uv1' are texture coordinates. Read about them from the same link above.\n    // - Note that Image() may add +2.0f to provided size if a border is visible, ImageButton() adds style.FramePadding*2.0f to provided size.\n    // - ImageButton() draws a background based on regular Button() color + optionally an inner background if specified.\n    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1), const ImVec4& border_col = ImVec4(0, 0, 0, 0));\n    IMGUI_API bool          ImageButton(const char* str_id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1));\n\n    // Widgets: Combo Box (Dropdown)\n    // - The BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.\n    // - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose. This is analogous to how ListBox are created.\n    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);\n    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\"\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int popup_max_height_in_items = -1);\n\n    // Widgets: Drag Sliders\n    // - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped by default and can go off-bounds. Use ImGuiSliderFlags_AlwaysClamp to always clamp.\n    // - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every function, note that a 'float v[X]' function argument is the same as 'float* v',\n    //   the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x\n    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc.\n    // - Format string may also be set to NULL or use the default format (\"%f\" or \"%d\").\n    // - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For keyboard/gamepad navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).\n    // - Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click manual input can override those limits if ImGuiSliderFlags_AlwaysClamp is not used.\n    // - Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum.\n    // - We use the same sets of flags for DragXXX() and SliderXXX() functions as the features are the same and it makes it easier to swap them.\n    // - Legacy: Pre-1.78 there are DragXXX() function signatures that take a final `float power=1.0f' argument instead of the `ImGuiSliderFlags flags=0' argument.\n    //   If you get a warning converting a float to ImGuiSliderFlags, read https://github.com/ocornut/imgui/issues/3361\n    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);     // If v_min >= v_max we have no bound\n    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", const char* format_max = NULL, ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", ImGuiSliderFlags flags = 0);  // If v_min >= v_max we have no bound\n    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", const char* format_max = NULL, ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed = 1.0f, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed = 1.0f, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, ImGuiSliderFlags flags = 0);\n\n    // Widgets: Regular Sliders\n    // - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped by default and can go off-bounds. Use ImGuiSliderFlags_AlwaysClamp to always clamp.\n    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc.\n    // - Format string may also be set to NULL or use the default format (\"%f\" or \"%d\").\n    // - Legacy: Pre-1.78 there are SliderXXX() function signatures that take a final `float power=1.0f' argument instead of the `ImGuiSliderFlags flags=0' argument.\n    //   If you get a warning converting a float to ImGuiSliderFlags, read https://github.com/ocornut/imgui/issues/3361\n    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display.\n    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = \"%.0f deg\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format = NULL, ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = \"%.3f\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = \"%d\", ImGuiSliderFlags flags = 0);\n    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, ImGuiSliderFlags flags = 0);\n\n    // Widgets: Input with Keyboard\n    // - If you want to use InputText() with std::string or any custom dynamic string type, see misc/cpp/imgui_stdlib.h and comments in imgui_demo.cpp.\n    // - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.\n    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\n    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\n    IMGUI_API bool          InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\n    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = \"%.3f\", ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = \"%.3f\", ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = \"%.3f\", ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = \"%.3f\", ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = \"%.6f\", ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);\n    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);\n\n    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little color square that can be left-clicked to open a picker, and right-clicked to open an option menu.)\n    // - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible.\n    // - You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x\n    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\n    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);\n    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\n    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);\n    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, const ImVec2& size = ImVec2(0, 0)); // display a color square/button, hover for details, return true when pressed.\n    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.\n\n    // Widgets: Trees\n    // - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.\n    IMGUI_API bool          TreeNode(const char* label);\n    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().\n    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // \"\n    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);\n    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);\n    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);\n    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\n    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\n    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\n    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\n    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.\n    IMGUI_API void          TreePush(const void* ptr_id);                                       // \"\n    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopID()\n    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode\n    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().\n    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags = 0); // when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.\n    IMGUI_API void          SetNextItemOpen(bool is_open, ImGuiCond cond = 0);                  // set next TreeNode/CollapsingHeader open state.\n    IMGUI_API void          SetNextItemStorageID(ImGuiID storage_id);                           // set id to use for open/close storage (default to same as item id).\n\n    // Widgets: Selectables\n    // - A selectable highlights when hovered, and can display another color when selected.\n    // - Neighbors selectable extend their highlight bounds in order to leave no gap between them. This is so a series of selected Selectable appear contiguous.\n    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0)); // \"bool selected\" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height\n    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));      // \"bool* p_selected\" point to the selection state (read-write), as a convenient helper.\n\n    // Multi-selection system for Selectable(), Checkbox(), TreeNode() functions [BETA]\n    // - This enables standard multi-selection/range-selection idioms (CTRL+Mouse/Keyboard, SHIFT+Mouse/Keyboard, etc.) in a way that also allow a clipper to be used.\n    // - ImGuiSelectionUserData is often used to store your item index within the current view (but may store something else).\n    // - Read comments near ImGuiMultiSelectIO for instructions/details and see 'Demo->Widgets->Selection State & Multi-Select' for demo.\n    // - TreeNode() is technically supported but... using this correctly is more complicated. You need some sort of linear/random access to your tree,\n    //   which is suited to advanced trees setups already implementing filters and clipper. We will work simplifying the current demo.\n    // - 'selection_size' and 'items_count' parameters are optional and used by a few features. If they are costly for you to compute, you may avoid them.\n    IMGUI_API ImGuiMultiSelectIO*   BeginMultiSelect(ImGuiMultiSelectFlags flags, int selection_size = -1, int items_count = -1);\n    IMGUI_API ImGuiMultiSelectIO*   EndMultiSelect();\n    IMGUI_API void                  SetNextItemSelectionUserData(ImGuiSelectionUserData selection_user_data);\n    IMGUI_API bool                  IsItemToggledSelection();                                   // Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.\n\n    // Widgets: List Boxes\n    // - This is essentially a thin wrapper to using BeginChild/EndChild with the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.\n    // - If you don't need a label you can probably simply use BeginChild() with the ImGuiChildFlags_FrameStyle flag for the same result.\n    // - You can submit contents and manage your selection state however you want it, by creating e.g. Selectable() or any other items.\n    // - The simplified/old ListBox() api are helpers over BeginListBox()/EndListBox() which are kept available for convenience purpose. This is analoguous to how Combos are created.\n    // - Choose frame width:   size.x > 0.0f: custom  /  size.x < 0.0f or -FLT_MIN: right-align   /  size.x = 0.0f (default): use current ItemWidth\n    // - Choose frame height:  size.y > 0.0f: custom  /  size.y < 0.0f or -FLT_MIN: bottom-align  /  size.y = 0.0f (default): arbitrary default height which can fit ~7 items\n    IMGUI_API bool          BeginListBox(const char* label, const ImVec2& size = ImVec2(0, 0)); // open a framed scrolling region\n    IMGUI_API void          EndListBox();                                                       // only call EndListBox() if BeginListBox() returned true!\n    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);\n    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int height_in_items = -1);\n\n    // Widgets: Data Plotting\n    // - Consider using ImPlot (https://github.com/epezent/implot) which is much better!\n    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));\n    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));\n    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));\n    IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));\n\n    // Widgets: Value() Helpers.\n    // - Those are merely shortcut to calling Text() with a format string. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)\n    IMGUI_API void          Value(const char* prefix, bool b);\n    IMGUI_API void          Value(const char* prefix, int v);\n    IMGUI_API void          Value(const char* prefix, unsigned int v);\n    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);\n\n    // Widgets: Menus\n    // - Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar.\n    // - Use BeginMainMenuBar() to create a menu bar at the top of the screen and append to it.\n    // - Use BeginMenu() to create a menu. You can call BeginMenu() multiple time with the same identifier to append more items to it.\n    // - Not that MenuItem() keyboardshortcuts are displayed as a convenience but _not processed_ by Dear ImGui at the moment.\n    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).\n    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!\n    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.\n    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!\n    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!\n    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated.\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL\n\n    // Tooltips\n    // - Tooltips are windows following the mouse. They do not take focus away.\n    // - A tooltip window can contain items of any types.\n    // - SetTooltip() is more or less a shortcut for the 'if (BeginTooltip()) { Text(...); EndTooltip(); }' idiom (with a subtlety that it discard any previously submitted tooltip)\n    IMGUI_API bool          BeginTooltip();                                                     // begin/append a tooltip window.\n    IMGUI_API void          EndTooltip();                                                       // only call EndTooltip() if BeginTooltip()/BeginItemTooltip() returns true!\n    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip. Often used after a ImGui::IsItemHovered() check. Override any previous call to SetTooltip().\n    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);\n\n    // Tooltips: helpers for showing a tooltip when hovering an item\n    // - BeginItemTooltip() is a shortcut for the 'if (IsItemHovered(ImGuiHoveredFlags_ForTooltip) && BeginTooltip())' idiom.\n    // - SetItemTooltip() is a shortcut for the 'if (IsItemHovered(ImGuiHoveredFlags_ForTooltip)) { SetTooltip(...); }' idiom.\n    // - Where 'ImGuiHoveredFlags_ForTooltip' itself is a shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' depending on active input type. For mouse it defaults to 'ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort'.\n    IMGUI_API bool          BeginItemTooltip();                                                 // begin/append a tooltip window if preceding item was hovered.\n    IMGUI_API void          SetItemTooltip(const char* fmt, ...) IM_FMTARGS(1);                 // set a text-only tooltip if preceding item was hovered. override any previous call to SetTooltip().\n    IMGUI_API void          SetItemTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);\n\n    // Popups, Modals\n    //  - They block normal mouse hovering detection (and therefore most mouse interactions) behind them.\n    //  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.\n    //  - Their visibility state (~bool) is held internally instead of being held by the programmer as we are used to with regular Begin*() calls.\n    //  - The 3 properties above are related: we need to retain popup visibility state in the library because popups may be closed as any time.\n    //  - You can bypass the hovering restriction by using ImGuiHoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or IsWindowHovered().\n    //  - IMPORTANT: Popup identifiers are relative to the current ID stack, so OpenPopup and BeginPopup generally needs to be at the same level of the stack.\n    //    This is sometimes leading to confusing mistakes. May rework this in the future.\n    //  - BeginPopup(): query popup state, if open start appending into the window. Call EndPopup() afterwards if returned true. ImGuiWindowFlags are forwarded to the window.\n    //  - BeginPopupModal(): block every interaction behind the window, cannot be closed by user, add a dimming background, has a title bar.\n    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                         // return true if the popup is open, and you can start outputting to it.\n    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0); // return true if the modal is open, and you can start outputting to it.\n    IMGUI_API void          EndPopup();                                                                         // only call EndPopup() if BeginPopupXXX() returns true!\n\n    // Popups: open/close functions\n    //  - OpenPopup(): set popup state to open. ImGuiPopupFlags are available for opening options.\n    //  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.\n    //  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close manually.\n    //  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when activated (FIXME: need some options).\n    //  - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there's already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().\n    //  - Use IsWindowAppearing() after BeginPopup() to tell if a window just opened.\n    //  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter\n    IMGUI_API void          OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags = 0);                     // call to mark popup as open (don't call every frame!).\n    IMGUI_API void          OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags = 0);                             // id overload to facilitate calling from nested stacks\n    IMGUI_API void          OpenPopupOnItemClick(const char* str_id = NULL, ImGuiPopupFlags popup_flags = 1);   // helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)\n    IMGUI_API void          CloseCurrentPopup();                                                                // manually close the popup we have begin-ed into.\n\n    // Popups: open+begin combined functions helpers\n    //  - Helpers to do OpenPopup+BeginPopup where the Open action is triggered by e.g. hovering an item and right-clicking.\n    //  - They are convenient to easily create context menus, hence the name.\n    //  - IMPORTANT: Notice that BeginPopupContextXXX takes ImGuiPopupFlags just like OpenPopup() and unlike BeginPopup(). For full consistency, we may add ImGuiWindowFlags to the BeginPopupContextXXX functions in the future.\n    //  - IMPORTANT: Notice that we exceptionally default their flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter, so if you add other flags remember to re-add the ImGuiPopupFlags_MouseButtonRight.\n    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, ImGuiPopupFlags popup_flags = 1);  // open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!\n    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, ImGuiPopupFlags popup_flags = 1);// open+begin popup when clicked on current window.\n    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, ImGuiPopupFlags popup_flags = 1);  // open+begin popup when clicked in void (where there are no windows).\n\n    // Popups: query functions\n    //  - IsPopupOpen(): return true if the popup is open at the current BeginPopup() level of the popup stack.\n    //  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId: return true if any popup is open at the current BeginPopup() level of the popup stack.\n    //  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId + ImGuiPopupFlags_AnyPopupLevel: return true if any popup is open.\n    IMGUI_API bool          IsPopupOpen(const char* str_id, ImGuiPopupFlags flags = 0);                         // return true if the popup is open.\n\n    // Tables\n    // - Full-featured replacement for old Columns API.\n    // - See Demo->Tables for demo code. See top of imgui_tables.cpp for general commentary.\n    // - See ImGuiTableFlags_ and ImGuiTableColumnFlags_ enums for a description of available flags.\n    // The typical call flow is:\n    // - 1. Call BeginTable(), early out if returning false.\n    // - 2. Optionally call TableSetupColumn() to submit column name/flags/defaults.\n    // - 3. Optionally call TableSetupScrollFreeze() to request scroll freezing of columns/rows.\n    // - 4. Optionally call TableHeadersRow() to submit a header row. Names are pulled from TableSetupColumn() data.\n    // - 5. Populate contents:\n    //    - In most situations you can use TableNextRow() + TableSetColumnIndex(N) to start appending into a column.\n    //    - If you are using tables as a sort of grid, where every column is holding the same type of contents,\n    //      you may prefer using TableNextColumn() instead of TableNextRow() + TableSetColumnIndex().\n    //      TableNextColumn() will automatically wrap-around into the next row if needed.\n    //    - IMPORTANT: Comparatively to the old Columns() API, we need to call TableNextColumn() for the first column!\n    //    - Summary of possible call flow:\n    //        - TableNextRow() -> TableSetColumnIndex(0) -> Text(\"Hello 0\") -> TableSetColumnIndex(1) -> Text(\"Hello 1\")  // OK\n    //        - TableNextRow() -> TableNextColumn()      -> Text(\"Hello 0\") -> TableNextColumn()      -> Text(\"Hello 1\")  // OK\n    //        -                   TableNextColumn()      -> Text(\"Hello 0\") -> TableNextColumn()      -> Text(\"Hello 1\")  // OK: TableNextColumn() automatically gets to next row!\n    //        - TableNextRow()                           -> Text(\"Hello 0\")                                               // Not OK! Missing TableSetColumnIndex() or TableNextColumn()! Text will not appear!\n    // - 5. Call EndTable()\n    IMGUI_API bool          BeginTable(const char* str_id, int columns, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0.0f, 0.0f), float inner_width = 0.0f);\n    IMGUI_API void          EndTable();                                         // only call EndTable() if BeginTable() returns true!\n    IMGUI_API void          TableNextRow(ImGuiTableRowFlags row_flags = 0, float min_row_height = 0.0f); // append into the first cell of a new row.\n    IMGUI_API bool          TableNextColumn();                                  // append into the next column (or first column of next row if currently in last column). Return true when column is visible.\n    IMGUI_API bool          TableSetColumnIndex(int column_n);                  // append into the specified column. Return true when column is visible.\n\n    // Tables: Headers & Columns declaration\n    // - Use TableSetupColumn() to specify label, resizing policy, default width/weight, id, various other flags etc.\n    // - Use TableHeadersRow() to create a header row and automatically submit a TableHeader() for each column.\n    //   Headers are required to perform: reordering, sorting, and opening the context menu.\n    //   The context menu can also be made available in columns body using ImGuiTableFlags_ContextMenuInBody.\n    // - You may manually submit headers using TableNextRow() + TableHeader() calls, but this is only useful in\n    //   some advanced use cases (e.g. adding custom widgets in header row).\n    // - Use TableSetupScrollFreeze() to lock columns/rows so they stay visible when scrolled.\n    IMGUI_API void          TableSetupColumn(const char* label, ImGuiTableColumnFlags flags = 0, float init_width_or_weight = 0.0f, ImGuiID user_id = 0);\n    IMGUI_API void          TableSetupScrollFreeze(int cols, int rows);         // lock columns/rows so they stay visible when scrolled.\n    IMGUI_API void          TableHeader(const char* label);                     // submit one header cell manually (rarely used)\n    IMGUI_API void          TableHeadersRow();                                  // submit a row with headers cells based on data provided to TableSetupColumn() + submit context menu\n    IMGUI_API void          TableAngledHeadersRow();                            // submit a row with angled headers for every column with the ImGuiTableColumnFlags_AngledHeader flag. MUST BE FIRST ROW.\n\n    // Tables: Sorting & Miscellaneous functions\n    // - Sorting: call TableGetSortSpecs() to retrieve latest sort specs for the table. NULL when not sorting.\n    //   When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have\n    //   changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,\n    //   else you may wastefully sort your data every frame!\n    // - Functions args 'int column_n' treat the default value of -1 as the same as passing the current column index.\n    IMGUI_API ImGuiTableSortSpecs*  TableGetSortSpecs();                        // get latest sort specs for the table (NULL if not sorting).  Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().\n    IMGUI_API int                   TableGetColumnCount();                      // return number of columns (value passed to BeginTable)\n    IMGUI_API int                   TableGetColumnIndex();                      // return current column index.\n    IMGUI_API int                   TableGetRowIndex();                         // return current row index.\n    IMGUI_API const char*           TableGetColumnName(int column_n = -1);      // return \"\" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.\n    IMGUI_API ImGuiTableColumnFlags TableGetColumnFlags(int column_n = -1);     // return column flags so you can query their Enabled/Visible/Sorted/Hovered status flags. Pass -1 to use current column.\n    IMGUI_API void                  TableSetColumnEnabled(int column_n, bool v);// change user accessible enabled/disabled state of a column. Set to false to hide the column. User can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)\n    IMGUI_API int                   TableGetHoveredColumn();                    // return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered. Can also use (TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered) instead.\n    IMGUI_API void                  TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n = -1);  // change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.\n\n    // Legacy Columns API (prefer using Tables!)\n    // - You can also use SameLine(pos_x) to mimic simplified columns.\n    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool borders = true);\n    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished\n    IMGUI_API int           GetColumnIndex();                                                   // get current column index\n    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column\n    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column\n    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f\n    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column\n    IMGUI_API int           GetColumnsCount();\n\n    // Tab Bars, Tabs\n    // - Note: Tabs are automatically created by the docking system (when in 'docking' branch). Use this to create tab bars/tabs yourself.\n    IMGUI_API bool          BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);        // create and append into a TabBar\n    IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true!\n    IMGUI_API bool          BeginTabItem(const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0); // create a Tab. Returns true if the Tab is selected.\n    IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true!\n    IMGUI_API bool          TabItemButton(const char* label, ImGuiTabItemFlags flags = 0);      // create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.\n    IMGUI_API void          SetTabItemClosed(const char* tab_or_docked_window_label);           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.\n\n    // Logging/Capture\n    // - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.\n    IMGUI_API void          LogToTTY(int auto_open_depth = -1);                                 // start logging to tty (stdout)\n    IMGUI_API void          LogToFile(int auto_open_depth = -1, const char* filename = NULL);   // start logging to file\n    IMGUI_API void          LogToClipboard(int auto_open_depth = -1);                           // start logging to OS clipboard\n    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)\n    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard\n    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)\n    IMGUI_API void          LogTextV(const char* fmt, va_list args) IM_FMTLIST(1);\n\n    // Drag and Drop\n    // - On source items, call BeginDragDropSource(), if it returns true also call SetDragDropPayload() + EndDragDropSource().\n    // - On target candidates, call BeginDragDropTarget(), if it returns true also call AcceptDragDropPayload() + EndDragDropTarget().\n    // - If you stop calling BeginDragDropSource() the payload is preserved however it won't have a preview tooltip (we currently display a fallback \"...\" tooltip, see #1725)\n    // - An item can be both drag source and drop target.\n    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()\n    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);  // type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.\n    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!\n    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()\n    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.\n    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!\n    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.\n\n    // Disabling [BETA API]\n    // - Disable all user interactions and dim items visuals (applying style.DisabledAlpha over current colors)\n    // - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)\n    // - Tooltips windows by exception are opted out of disabling.\n    // - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)\n    IMGUI_API void          BeginDisabled(bool disabled = true);\n    IMGUI_API void          EndDisabled();\n\n    // Clipping\n    // - Mouse hovering is affected by ImGui::PushClipRect() calls, unlike direct calls to ImDrawList::PushClipRect() which are render only.\n    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);\n    IMGUI_API void          PopClipRect();\n\n    // Focus, Activation\n    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of of a newly appearing window.\n    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.\n\n    // Keyboard/Gamepad Navigation\n    IMGUI_API void          SetNavCursorVisible(bool visible);                                  // alter visibility of keyboard/gamepad cursor. by default: show when using an arrow key, hide when clicking with mouse.\n\n    // Overlapping mode\n    IMGUI_API void          SetNextItemAllowOverlap();                                          // allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.\n\n    // Item/Widgets Utilities and Query Functions\n    // - Most of the functions are referring to the previous Item that has been submitted.\n    // - See Demo Window under \"Widgets->Querying Status\" for an interactive visualization of most of those functions.\n    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.\n    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)\n    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?\n    IMGUI_API bool          IsItemClicked(ImGuiMouseButton mouse_button = 0);                   // is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.\n    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)\n    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the \"bool\" return value of many widgets.\n    IMGUI_API bool          IsItemActivated();                                                  // was the last item just made active (item was previously inactive).\n    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that require continuous editing.\n    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).\n    IMGUI_API bool          IsItemToggledOpen();                                                // was the last item open state toggled? set by TreeNode().\n    IMGUI_API bool          IsAnyItemHovered();                                                 // is any item hovered?\n    IMGUI_API bool          IsAnyItemActive();                                                  // is any item active?\n    IMGUI_API bool          IsAnyItemFocused();                                                 // is any item focused?\n    IMGUI_API ImGuiID       GetItemID();                                                        // get ID of last item (~~ often same ImGui::GetID(label) beforehand)\n    IMGUI_API ImVec2        GetItemRectMin();                                                   // get upper-left bounding rectangle of the last item (screen space)\n    IMGUI_API ImVec2        GetItemRectMax();                                                   // get lower-right bounding rectangle of the last item (screen space)\n    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item\n\n    // Viewports\n    // - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.\n    // - In 'docking' branch with multi-viewport enabled, we extend this concept to have multiple active viewports.\n    // - In the future we will extend this concept further to also represent Platform Monitor and support a \"no main platform window\" operation mode.\n    IMGUI_API ImGuiViewport* GetMainViewport();                                                 // return primary/default viewport. This can never be NULL.\n\n    // Background/Foreground Draw Lists\n    IMGUI_API ImDrawList*   GetBackgroundDrawList();                                            // this draw list will be the first rendered one. Useful to quickly draw shapes/text behind dear imgui contents.\n    IMGUI_API ImDrawList*   GetForegroundDrawList();                                            // this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.\n\n    // Miscellaneous Utilities\n    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.\n    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.\n    IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.\n    IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.\n    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances.\n    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);                                    // get a string corresponding to the enum value (for display, saving, etc.).\n    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)\n    IMGUI_API ImGuiStorage* GetStateStorage();\n\n    // Text Utilities\n    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);\n\n    // Color Utilities\n    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);\n    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);\n    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);\n    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);\n\n    // Inputs Utilities: Keyboard/Mouse/Gamepad\n    // - the ImGuiKey enum contains all possible keyboard, mouse and gamepad inputs (e.g. ImGuiKey_A, ImGuiKey_MouseLeft, ImGuiKey_GamepadDpadUp...).\n    // - (legacy: before v1.87, we used ImGuiKey to carry native/user indices as defined by each backends. This was obsoleted in 1.87 (2022-02) and completely removed in 1.91.5 (2024-11). See https://github.com/ocornut/imgui/issues/4921)\n    // - (legacy: any use of ImGuiKey will assert when key < 512 to detect passing legacy native/user indices)\n    IMGUI_API bool          IsKeyDown(ImGuiKey key);                                            // is key being held.\n    IMGUI_API bool          IsKeyPressed(ImGuiKey key, bool repeat = true);                     // was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate\n    IMGUI_API bool          IsKeyReleased(ImGuiKey key);                                        // was key released (went from Down to !Down)?\n    IMGUI_API bool          IsKeyChordPressed(ImGuiKeyChord key_chord);                         // was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.\n    IMGUI_API int           GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float rate);  // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate\n    IMGUI_API const char*   GetKeyName(ImGuiKey key);                                           // [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.\n    IMGUI_API void          SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard);        // Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting \"io.WantCaptureKeyboard = want_capture_keyboard\"; after the next NewFrame() call.\n\n    // Inputs Utilities: Shortcut Testing & Routing [BETA]\n    // - ImGuiKeyChord = a ImGuiKey + optional ImGuiMod_Alt/ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Super.\n    //       ImGuiKey_C                          // Accepted by functions taking ImGuiKey or ImGuiKeyChord arguments)\n    //       ImGuiMod_Ctrl | ImGuiKey_C          // Accepted by functions taking ImGuiKeyChord arguments)\n    //   only ImGuiMod_XXX values are legal to combine with an ImGuiKey. You CANNOT combine two ImGuiKey values.\n    // - The general idea is that several callers may register interest in a shortcut, and only one owner gets it.\n    //      Parent   -> call Shortcut(Ctrl+S)    // When Parent is focused, Parent gets the shortcut.\n    //        Child1 -> call Shortcut(Ctrl+S)    // When Child1 is focused, Child1 gets the shortcut (Child1 overrides Parent shortcuts)\n    //        Child2 -> no call                  // When Child2 is focused, Parent gets the shortcut.\n    //   The whole system is order independent, so if Child1 makes its calls before Parent, results will be identical.\n    //   This is an important property as it facilitate working with foreign code or larger codebase.\n    // - To understand the difference:\n    //   - IsKeyChordPressed() compares mods and call IsKeyPressed() -> function has no side-effect.\n    //   - Shortcut() submits a route, routes are resolved, if it currently can be routed it calls IsKeyChordPressed() -> function has (desirable) side-effects as it can prevents another call from getting the route.\n    // - Visualize registered routes in 'Metrics/Debugger->Inputs'.\n    IMGUI_API bool          Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0);\n    IMGUI_API void          SetNextItemShortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0);\n\n    // Inputs Utilities: Key/Input Ownership [BETA]\n    // - One common use case would be to allow your items to disable standard inputs behaviors such\n    //   as Tab or Alt key handling, Mouse Wheel scrolling, etc.\n    //   e.g. Button(...); SetItemKeyOwner(ImGuiKey_MouseWheelY); to make hovering/activating a button disable wheel for scrolling.\n    // - Reminder ImGuiKey enum include access to mouse buttons and gamepad, so key ownership can apply to them.\n    // - Many related features are still in imgui_internal.h. For instance, most IsKeyXXX()/IsMouseXXX() functions have an owner-id-aware version.\n    IMGUI_API void          SetItemKeyOwner(ImGuiKey key);                                      // Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.\n\n    // Inputs Utilities: Mouse\n    // - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.\n    // - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.\n    // - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')\n    IMGUI_API bool          IsMouseDown(ImGuiMouseButton button);                               // is mouse button held?\n    IMGUI_API bool          IsMouseClicked(ImGuiMouseButton button, bool repeat = false);       // did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.\n    IMGUI_API bool          IsMouseReleased(ImGuiMouseButton button);                           // did mouse button released? (went from Down to !Down)\n    IMGUI_API bool          IsMouseDoubleClicked(ImGuiMouseButton button);                      // did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)\n    IMGUI_API int           GetMouseClickedCount(ImGuiMouseButton button);                      // return the number of successive mouse-clicks at the time where a click happen (otherwise 0).\n    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.\n    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    // by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available\n    IMGUI_API bool          IsAnyMouseDown();                                                   // [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.\n    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls\n    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)\n    IMGUI_API bool          IsMouseDragging(ImGuiMouseButton button, float lock_threshold = -1.0f);         // is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)\n    IMGUI_API ImVec2        GetMouseDragDelta(ImGuiMouseButton button = 0, float lock_threshold = -1.0f);   // return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)\n    IMGUI_API void          ResetMouseDragDelta(ImGuiMouseButton button = 0);                   //\n    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you\n    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor cursor_type);                       // set desired mouse cursor shape\n    IMGUI_API void          SetNextFrameWantCaptureMouse(bool want_capture_mouse);              // Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting \"io.WantCaptureMouse = want_capture_mouse;\" after the next NewFrame() call.\n\n    // Clipboard Utilities\n    // - Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard.\n    IMGUI_API const char*   GetClipboardText();\n    IMGUI_API void          SetClipboardText(const char* text);\n\n    // Settings/.Ini Utilities\n    // - The disk functions are automatically called if io.IniFilename != NULL (default is \"imgui.ini\").\n    // - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.\n    // - Important: default value \"imgui.ini\" is relative to current working dir! Most apps will want to lock this to an absolute path (e.g. same path as executables).\n    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).\n    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.\n    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);                    // this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).\n    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.\n\n    // Debug Utilities\n    // - Your main debugging friend is the ShowMetricsWindow() function, which is also accessible from Demo->Tools->Metrics Debugger\n    IMGUI_API void          DebugTextEncoding(const char* text);\n    IMGUI_API void          DebugFlashStyleColor(ImGuiCol idx);\n    IMGUI_API void          DebugStartItemPicker();\n    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx); // This is called by IMGUI_CHECKVERSION() macro.\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    IMGUI_API void          DebugLog(const char* fmt, ...)           IM_FMTARGS(1); // Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!\n    IMGUI_API void          DebugLogV(const char* fmt, va_list args) IM_FMTLIST(1);\n#endif\n\n    // Memory Allocators\n    // - Those functions are not reliant on the current context.\n    // - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()\n    //   for each static/DLL boundary you are calling from. Read \"Context and Memory Allocators\" section of imgui.cpp for more details.\n    IMGUI_API void          SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data = NULL);\n    IMGUI_API void          GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data);\n    IMGUI_API void*         MemAlloc(size_t size);\n    IMGUI_API void          MemFree(void* ptr);\n\n} // namespace ImGui\n\n//-----------------------------------------------------------------------------\n// [SECTION] Flags & Enumerations\n//-----------------------------------------------------------------------------\n\n// Flags for ImGui::Begin()\n// (Those are per-window flags. There are shared flags in ImGuiIO: io.ConfigWindowsResizeFromEdges and io.ConfigWindowsMoveFromTitleBarOnly)\nenum ImGuiWindowFlags_\n{\n    ImGuiWindowFlags_None                   = 0,\n    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar\n    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip\n    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window\n    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)\n    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.\n    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).\n    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame\n    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).\n    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file\n    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.\n    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar\n    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section.\n    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state\n    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)\n    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)\n    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)\n    ImGuiWindowFlags_NoNavInputs            = 1 << 16,  // No keyboard/gamepad navigation within the window\n    ImGuiWindowFlags_NoNavFocus             = 1 << 17,  // No focusing toward this window with keyboard/gamepad navigation (e.g. skipped by CTRL+TAB)\n    ImGuiWindowFlags_UnsavedDocument        = 1 << 18,  // Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.\n    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,\n    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,\n    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,\n\n    // [Internal]\n    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()\n    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()\n    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()\n    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()\n    ImGuiWindowFlags_ChildMenu              = 1 << 28,  // Don't use! For internal use by BeginMenu()\n\n    // Obsolete names\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 30,  // Obsoleted in 1.90.0: Use ImGuiChildFlags_AlwaysUseWindowPadding in BeginChild() call.\n    ImGuiWindowFlags_NavFlattened           = 1 << 31,  // Obsoleted in 1.90.9: Use ImGuiChildFlags_NavFlattened in BeginChild() call.\n#endif\n};\n\n// Flags for ImGui::BeginChild()\n// (Legacy: bit 0 must always correspond to ImGuiChildFlags_Borders to be backward compatible with old API using 'bool border = false'.\n// About using AutoResizeX/AutoResizeY flags:\n// - May be combined with SetNextWindowSizeConstraints() to set a min/max size for each axis (see \"Demo->Child->Auto-resize with Constraints\").\n// - Size measurement for a given axis is only performed when the child window is within visible boundaries, or is just appearing.\n//   - This allows BeginChild() to return false when not within boundaries (e.g. when scrolling), which is more optimal. BUT it won't update its auto-size while clipped.\n//     While not perfect, it is a better default behavior as the always-on performance gain is more valuable than the occasional \"resizing after becoming visible again\" glitch.\n//   - You may also use ImGuiChildFlags_AlwaysAutoResize to force an update even when child window is not in view.\n//     HOWEVER PLEASE UNDERSTAND THAT DOING SO WILL PREVENT BeginChild() FROM EVER RETURNING FALSE, disabling benefits of coarse clipping.\nenum ImGuiChildFlags_\n{\n    ImGuiChildFlags_None                    = 0,\n    ImGuiChildFlags_Borders                 = 1 << 0,   // Show an outer border and enable WindowPadding. (IMPORTANT: this is always == 1 == true for legacy reason)\n    ImGuiChildFlags_AlwaysUseWindowPadding  = 1 << 1,   // Pad with style.WindowPadding even if no border are drawn (no padding by default for non-bordered child windows because it makes more sense)\n    ImGuiChildFlags_ResizeX                 = 1 << 2,   // Allow resize from right border (layout direction). Enable .ini saving (unless ImGuiWindowFlags_NoSavedSettings passed to window flags)\n    ImGuiChildFlags_ResizeY                 = 1 << 3,   // Allow resize from bottom border (layout direction). \"\n    ImGuiChildFlags_AutoResizeX             = 1 << 4,   // Enable auto-resizing width. Read \"IMPORTANT: Size measurement\" details above.\n    ImGuiChildFlags_AutoResizeY             = 1 << 5,   // Enable auto-resizing height. Read \"IMPORTANT: Size measurement\" details above.\n    ImGuiChildFlags_AlwaysAutoResize        = 1 << 6,   // Combined with AutoResizeX/AutoResizeY. Always measure size even when child is hidden, always return true, always disable clipping optimization! NOT RECOMMENDED.\n    ImGuiChildFlags_FrameStyle              = 1 << 7,   // Style the child window like a framed item: use FrameBg, FrameRounding, FrameBorderSize, FramePadding instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.\n    ImGuiChildFlags_NavFlattened            = 1 << 8,   // [BETA] Share focus scope, allow keyboard/gamepad navigation to cross over parent border to this child or between sibling child windows.\n\n    // Obsolete names\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiChildFlags_Border                  = ImGuiChildFlags_Borders,  // Renamed in 1.91.1 (August 2024) for consistency.\n#endif\n};\n\n// Flags for ImGui::PushItemFlag()\n// (Those are shared by all items)\nenum ImGuiItemFlags_\n{\n    ImGuiItemFlags_None                     = 0,        // (Default)\n    ImGuiItemFlags_NoTabStop                = 1 << 0,   // false    // Disable keyboard tabbing. This is a \"lighter\" version of ImGuiItemFlags_NoNav.\n    ImGuiItemFlags_NoNav                    = 1 << 1,   // false    // Disable any form of focusing (keyboard/gamepad directional navigation and SetKeyboardFocusHere() calls).\n    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 2,   // false    // Disable item being a candidate for default focus (e.g. used by title bar items).\n    ImGuiItemFlags_ButtonRepeat             = 1 << 3,   // false    // Any button-like behavior will have repeat mode enabled (based on io.KeyRepeatDelay and io.KeyRepeatRate values). Note that you can also call IsItemActive() after any button to tell if it is being held.\n    ImGuiItemFlags_AutoClosePopups          = 1 << 4,   // true     // MenuItem()/Selectable() automatically close their parent popup window.\n    ImGuiItemFlags_AllowDuplicateId         = 1 << 5,   // false    // Allow submitting an item with the same identifier as an item already submitted this frame without triggering a warning tooltip if io.ConfigDebugHighlightIdConflicts is set.\n};\n\n// Flags for ImGui::InputText()\n// (Those are per-item flags. There are shared flags in ImGuiIO: io.ConfigInputTextCursorBlink and io.ConfigInputTextEnterKeepActive)\nenum ImGuiInputTextFlags_\n{\n    // Basic filters (also see ImGuiInputTextFlags_CallbackCharFilter)\n    ImGuiInputTextFlags_None                = 0,\n    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/\n    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef\n    ImGuiInputTextFlags_CharsScientific     = 1 << 2,   // Allow 0123456789.+-*/eE (Scientific notation input)\n    ImGuiInputTextFlags_CharsUppercase      = 1 << 3,   // Turn a..z into A..Z\n    ImGuiInputTextFlags_CharsNoBlank        = 1 << 4,   // Filter out spaces, tabs\n\n    // Inputs\n    ImGuiInputTextFlags_AllowTabInput       = 1 << 5,   // Pressing TAB input a '\\t' character into the text field\n    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 6,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider using IsItemDeactivatedAfterEdit() instead!\n    ImGuiInputTextFlags_EscapeClearsAll     = 1 << 7,   // Escape key clears content if not empty, and deactivate otherwise (contrast to default behavior of Escape to revert)\n    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 8,   // In multi-line mode, validate with Enter, add new line with Ctrl+Enter (default is opposite: validate with Ctrl+Enter, add line with Enter).\n\n    // Other options\n    ImGuiInputTextFlags_ReadOnly            = 1 << 9,   // Read-only mode\n    ImGuiInputTextFlags_Password            = 1 << 10,  // Password mode, display all characters as '*', disable copy\n    ImGuiInputTextFlags_AlwaysOverwrite     = 1 << 11,  // Overwrite mode\n    ImGuiInputTextFlags_AutoSelectAll       = 1 << 12,  // Select entire text when first taking mouse focus\n    ImGuiInputTextFlags_ParseEmptyRefVal    = 1 << 13,  // InputFloat(), InputInt(), InputScalar() etc. only: parse empty string as zero value.\n    ImGuiInputTextFlags_DisplayEmptyRefVal  = 1 << 14,  // InputFloat(), InputInt(), InputScalar() etc. only: when value is zero, do not display it. Generally used with ImGuiInputTextFlags_ParseEmptyRefVal.\n    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 15,  // Disable following the cursor horizontally\n    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().\n\n    // Elide display / Alignment\n    ImGuiInputTextFlags_ElideLeft\t\t\t= 1 << 17,\t// When text doesn't fit, elide left side to ensure right side stays visible. Useful for path/filenames. Single-line only!\n\n    // Callback features\n    ImGuiInputTextFlags_CallbackCompletion  = 1 << 18,  // Callback on pressing TAB (for completion handling)\n    ImGuiInputTextFlags_CallbackHistory     = 1 << 19,  // Callback on pressing Up/Down arrows (for history handling)\n    ImGuiInputTextFlags_CallbackAlways      = 1 << 20,  // Callback on each iteration. User code may query cursor position, modify text buffer.\n    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 21,  // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\n    ImGuiInputTextFlags_CallbackResize      = 1 << 22,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)\n    ImGuiInputTextFlags_CallbackEdit        = 1 << 23,  // Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)\n\n    // Obsolete names\n    //ImGuiInputTextFlags_AlwaysInsertMode  = ImGuiInputTextFlags_AlwaysOverwrite   // [renamed in 1.82] name was not matching behavior\n};\n\n// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()\nenum ImGuiTreeNodeFlags_\n{\n    ImGuiTreeNodeFlags_None                 = 0,\n    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected\n    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Draw frame with background (e.g. for CollapsingHeader)\n    ImGuiTreeNodeFlags_AllowOverlap         = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one\n    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack\n    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)\n    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open\n    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Open on double-click instead of simple click (default for multi-select unless any _OpenOnXXX behavior is set explicitly). Both behaviors may be combined.\n    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Open when clicking on the arrow part (default for multi-select unless any _OpenOnXXX behavior is set explicitly). Both behaviors may be combined.\n    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).\n    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow. IMPORTANT: node can still be marked open/close if you don't set the _Leaf flag!\n    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding() before the node.\n    ImGuiTreeNodeFlags_SpanAvailWidth       = 1 << 11,  // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line without using AllowOverlap mode.\n    ImGuiTreeNodeFlags_SpanFullWidth        = 1 << 12,  // Extend hit box to the left-most and right-most edges (cover the indent area).\n    ImGuiTreeNodeFlags_SpanTextWidth        = 1 << 13,  // Narrow hit box + narrow hovering highlight, will only cover the label text.\n    ImGuiTreeNodeFlags_SpanAllColumns       = 1 << 14,  // Frame will span all columns of its container table (text will still fit in current column)\n    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 15,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)\n    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 16,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible\n    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog,\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiTreeNodeFlags_AllowItemOverlap     = ImGuiTreeNodeFlags_AllowOverlap,  // Renamed in 1.89.7\n#endif\n};\n\n// Flags for OpenPopup*(), BeginPopupContext*(), IsPopupOpen() functions.\n// - To be backward compatible with older API which took an 'int mouse_button = 1' argument instead of 'ImGuiPopupFlags flags',\n//   we need to treat small flags values as a mouse button index, so we encode the mouse button in the first few bits of the flags.\n//   It is therefore guaranteed to be legal to pass a mouse button index in ImGuiPopupFlags.\n// - For the same reason, we exceptionally default the ImGuiPopupFlags argument of BeginPopupContextXXX functions to 1 instead of 0.\n//   IMPORTANT: because the default parameter is 1 (==ImGuiPopupFlags_MouseButtonRight), if you rely on the default parameter\n//   and want to use another flag, you need to pass in the ImGuiPopupFlags_MouseButtonRight flag explicitly.\n// - Multiple buttons currently cannot be combined/or-ed in those functions (we could allow it later).\nenum ImGuiPopupFlags_\n{\n    ImGuiPopupFlags_None                    = 0,\n    ImGuiPopupFlags_MouseButtonLeft         = 0,        // For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)\n    ImGuiPopupFlags_MouseButtonRight        = 1,        // For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)\n    ImGuiPopupFlags_MouseButtonMiddle       = 2,        // For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)\n    ImGuiPopupFlags_MouseButtonMask_        = 0x1F,\n    ImGuiPopupFlags_MouseButtonDefault_     = 1,\n    ImGuiPopupFlags_NoReopen                = 1 << 5,   // For OpenPopup*(), BeginPopupContext*(): don't reopen same popup if already open (won't reposition, won't reinitialize navigation)\n    //ImGuiPopupFlags_NoReopenAlwaysNavInit = 1 << 6,   // For OpenPopup*(), BeginPopupContext*(): focus and initialize navigation even when not reopening.\n    ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 7,   // For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack\n    ImGuiPopupFlags_NoOpenOverItems         = 1 << 8,   // For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space\n    ImGuiPopupFlags_AnyPopupId              = 1 << 10,  // For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.\n    ImGuiPopupFlags_AnyPopupLevel           = 1 << 11,  // For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)\n    ImGuiPopupFlags_AnyPopup                = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel,\n};\n\n// Flags for ImGui::Selectable()\nenum ImGuiSelectableFlags_\n{\n    ImGuiSelectableFlags_None               = 0,\n    ImGuiSelectableFlags_NoAutoClosePopups  = 1 << 0,   // Clicking this doesn't close parent popup window (overrides ImGuiItemFlags_AutoClosePopups)\n    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Frame will span all columns of its container table (text will still fit in current column)\n    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too\n    ImGuiSelectableFlags_Disabled           = 1 << 3,   // Cannot be selected, display grayed out text\n    ImGuiSelectableFlags_AllowOverlap       = 1 << 4,   // (WIP) Hit testing to allow subsequent widgets to overlap this one\n    ImGuiSelectableFlags_Highlight          = 1 << 5,   // Make the item be displayed as if it is hovered\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiSelectableFlags_DontClosePopups    = ImGuiSelectableFlags_NoAutoClosePopups,   // Renamed in 1.91.0\n    ImGuiSelectableFlags_AllowItemOverlap   = ImGuiSelectableFlags_AllowOverlap,        // Renamed in 1.89.7\n#endif\n};\n\n// Flags for ImGui::BeginCombo()\nenum ImGuiComboFlags_\n{\n    ImGuiComboFlags_None                    = 0,\n    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default\n    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()\n    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)\n    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible\n    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible\n    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button\n    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button\n    ImGuiComboFlags_WidthFitPreview         = 1 << 7,   // Width dynamically calculated from preview contents\n    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest,\n};\n\n// Flags for ImGui::BeginTabBar()\nenum ImGuiTabBarFlags_\n{\n    ImGuiTabBarFlags_None                           = 0,\n    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list\n    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear\n    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,   // Disable buttons to open the tab list popup\n    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You may handle this behavior manually on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.\n    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,   // Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)\n    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   // Disable tooltips when hovering a tab\n    ImGuiTabBarFlags_DrawSelectedOverline           = 1 << 6,   // Draw selected overline markers over selected tab\n    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 7,   // Resize tabs when they don't fit\n    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 8,   // Add scroll buttons when tabs don't fit\n    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,\n    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown,\n};\n\n// Flags for ImGui::BeginTabItem()\nenum ImGuiTabItemFlags_\n{\n    ImGuiTabItemFlags_None                          = 0,\n    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   // Display a dot next to the title + set ImGuiTabItemFlags_NoAssumedClosure.\n    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()\n    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You may handle this behavior manually on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.\n    ImGuiTabItemFlags_NoPushId                      = 1 << 3,   // Don't call PushID()/PopID() on BeginTabItem()/EndTabItem()\n    ImGuiTabItemFlags_NoTooltip                     = 1 << 4,   // Disable tooltip for the given tab\n    ImGuiTabItemFlags_NoReorder                     = 1 << 5,   // Disable reordering this tab or having another tab cross over this tab\n    ImGuiTabItemFlags_Leading                       = 1 << 6,   // Enforce the tab position to the left of the tab bar (after the tab list popup button)\n    ImGuiTabItemFlags_Trailing                      = 1 << 7,   // Enforce the tab position to the right of the tab bar (before the scrolling buttons)\n    ImGuiTabItemFlags_NoAssumedClosure              = 1 << 8,   // Tab is selected when trying to close + closure is not immediately assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.\n};\n\n// Flags for ImGui::IsWindowFocused()\nenum ImGuiFocusedFlags_\n{\n    ImGuiFocusedFlags_None                          = 0,\n    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // Return true if any children of the window is focused\n    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // Test from root window (top most parent of the current hierarchy)\n    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!\n    ImGuiFocusedFlags_NoPopupHierarchy              = 1 << 3,   // Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)\n    //ImGuiFocusedFlags_DockHierarchy               = 1 << 4,   // Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)\n    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows,\n};\n\n// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()\n// Note: if you are trying to check whether your mouse should be dispatched to Dear ImGui or to your app, you should use 'io.WantCaptureMouse' instead! Please read the FAQ!\n// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.\nenum ImGuiHoveredFlags_\n{\n    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.\n    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered\n    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)\n    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered\n    ImGuiHoveredFlags_NoPopupHierarchy              = 1 << 3,   // IsWindowHovered() only: Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)\n    //ImGuiHoveredFlags_DockHierarchy               = 1 << 4,   // IsWindowHovered() only: Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)\n    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 5,   // Return true even if a popup window is normally blocking access to this item/window\n    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 6,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.\n    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 7,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.\n    ImGuiHoveredFlags_AllowWhenOverlappedByItem     = 1 << 8,   // IsItemHovered() only: Return true even if the item uses AllowOverlap mode and is overlapped by another hoverable item.\n    ImGuiHoveredFlags_AllowWhenOverlappedByWindow   = 1 << 9,   // IsItemHovered() only: Return true even if the position is obstructed or overlapped by another window.\n    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 10,  // IsItemHovered() only: Return true even if the item is disabled\n    ImGuiHoveredFlags_NoNavOverride                 = 1 << 11,  // IsItemHovered() only: Disable using keyboard/gamepad navigation state when active, always query mouse\n    ImGuiHoveredFlags_AllowWhenOverlapped           = ImGuiHoveredFlags_AllowWhenOverlappedByItem | ImGuiHoveredFlags_AllowWhenOverlappedByWindow,\n    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,\n    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows,\n\n    // Tooltips mode\n    // - typically used in IsItemHovered() + SetTooltip() sequence.\n    // - this is a shortcut to pull flags from 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' where you can reconfigure desired behavior.\n    //   e.g. 'TooltipHoveredFlagsForMouse' defaults to 'ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort'.\n    // - for frequently actioned or hovered items providing a tooltip, you want may to use ImGuiHoveredFlags_ForTooltip (stationary + delay) so the tooltip doesn't show too often.\n    // - for items which main purpose is to be hovered, or items with low affordance, or in less consistent apps, prefer no delay or shorter delay.\n    ImGuiHoveredFlags_ForTooltip                    = 1 << 12,  // Shortcut for standard flags when using IsItemHovered() + SetTooltip() sequence.\n\n    // (Advanced) Mouse Hovering delays.\n    // - generally you can use ImGuiHoveredFlags_ForTooltip to use application-standardized flags.\n    // - use those if you need specific overrides.\n    ImGuiHoveredFlags_Stationary                    = 1 << 13,  // Require mouse to be stationary for style.HoverStationaryDelay (~0.15 sec) _at least one time_. After this, can move on same item/window. Using the stationary test tends to reduces the need for a long delay.\n    ImGuiHoveredFlags_DelayNone                     = 1 << 14,  // IsItemHovered() only: Return true immediately (default). As this is the default you generally ignore this.\n    ImGuiHoveredFlags_DelayShort                    = 1 << 15,  // IsItemHovered() only: Return true after style.HoverDelayShort elapsed (~0.15 sec) (shared between items) + requires mouse to be stationary for style.HoverStationaryDelay (once per item).\n    ImGuiHoveredFlags_DelayNormal                   = 1 << 16,  // IsItemHovered() only: Return true after style.HoverDelayNormal elapsed (~0.40 sec) (shared between items) + requires mouse to be stationary for style.HoverStationaryDelay (once per item).\n    ImGuiHoveredFlags_NoSharedDelay                 = 1 << 17,  // IsItemHovered() only: Disable shared delay system where moving from one item to the next keeps the previous timer for a short time (standard for tooltips with long delays)\n};\n\n// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()\nenum ImGuiDragDropFlags_\n{\n    ImGuiDragDropFlags_None                         = 0,\n    // BeginDragDropSource() flags\n    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // Disable preview tooltip. By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disables this behavior.\n    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disables this behavior so you can still call IsItemHovered() on the source item.\n    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.\n    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.\n    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.\n    ImGuiDragDropFlags_PayloadAutoExpire            = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)\n    ImGuiDragDropFlags_PayloadNoCrossContext        = 1 << 6,   // Hint to specify that the payload may not be copied outside current dear imgui context.\n    ImGuiDragDropFlags_PayloadNoCrossProcess        = 1 << 7,   // Hint to specify that the payload may not be copied outside current process.\n    // AcceptDragDropPayload() flags\n    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.\n    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.\n    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.\n    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect, // For peeking ahead and inspecting the payload before delivery.\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiDragDropFlags_SourceAutoExpirePayload = ImGuiDragDropFlags_PayloadAutoExpire, // Renamed in 1.90.9\n#endif\n};\n\n// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.\n#define IMGUI_PAYLOAD_TYPE_COLOR_3F     \"_COL3F\"    // float[3]: Standard type for colors, without alpha. User code may use this type.\n#define IMGUI_PAYLOAD_TYPE_COLOR_4F     \"_COL4F\"    // float[4]: Standard type for colors. User code may use this type.\n\n// A primary data type\nenum ImGuiDataType_\n{\n    ImGuiDataType_S8,       // signed char / char (with sensible compilers)\n    ImGuiDataType_U8,       // unsigned char\n    ImGuiDataType_S16,      // short\n    ImGuiDataType_U16,      // unsigned short\n    ImGuiDataType_S32,      // int\n    ImGuiDataType_U32,      // unsigned int\n    ImGuiDataType_S64,      // long long / __int64\n    ImGuiDataType_U64,      // unsigned long long / unsigned __int64\n    ImGuiDataType_Float,    // float\n    ImGuiDataType_Double,   // double\n    ImGuiDataType_Bool,     // bool (provided for user convenience, not supported by scalar widgets)\n    ImGuiDataType_String,   // char* (provided for user convenience, not supported by scalar widgets)\n    ImGuiDataType_COUNT\n};\n\n// A cardinal direction\nenum ImGuiDir : int\n{\n    ImGuiDir_None    = -1,\n    ImGuiDir_Left    = 0,\n    ImGuiDir_Right   = 1,\n    ImGuiDir_Up      = 2,\n    ImGuiDir_Down    = 3,\n    ImGuiDir_COUNT\n};\n\n// A sorting direction\nenum ImGuiSortDirection : ImU8\n{\n    ImGuiSortDirection_None         = 0,\n    ImGuiSortDirection_Ascending    = 1,    // Ascending = 0->9, A->Z etc.\n    ImGuiSortDirection_Descending   = 2     // Descending = 9->0, Z->A etc.\n};\n\n// A key identifier (ImGuiKey_XXX or ImGuiMod_XXX value): can represent Keyboard, Mouse and Gamepad values.\n// All our named keys are >= 512. Keys value 0 to 511 are left unused and were legacy native/opaque key values (< 1.87).\n// Support for legacy keys was completely removed in 1.91.5.\n// Read details about the 1.87+ transition : https://github.com/ocornut/imgui/issues/4921\n// Note that \"Keys\" related to physical keys and are not the same concept as input \"Characters\", the later are submitted via io.AddInputCharacter().\n// The keyboard key enum values are named after the keys on a standard US keyboard, and on other keyboard types the keys reported may not match the keycaps.\nenum ImGuiKey : int\n{\n    // Keyboard\n    ImGuiKey_None = 0,\n    ImGuiKey_NamedKey_BEGIN = 512,  // First valid key value (other than 0)\n\n    ImGuiKey_Tab = 512,             // == ImGuiKey_NamedKey_BEGIN\n    ImGuiKey_LeftArrow,\n    ImGuiKey_RightArrow,\n    ImGuiKey_UpArrow,\n    ImGuiKey_DownArrow,\n    ImGuiKey_PageUp,\n    ImGuiKey_PageDown,\n    ImGuiKey_Home,\n    ImGuiKey_End,\n    ImGuiKey_Insert,\n    ImGuiKey_Delete,\n    ImGuiKey_Backspace,\n    ImGuiKey_Space,\n    ImGuiKey_Enter,\n    ImGuiKey_Escape,\n    ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,\n    ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,\n    ImGuiKey_Menu,\n    ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,\n    ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,\n    ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,\n    ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,\n    ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,\n    ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,\n    ImGuiKey_F13, ImGuiKey_F14, ImGuiKey_F15, ImGuiKey_F16, ImGuiKey_F17, ImGuiKey_F18,\n    ImGuiKey_F19, ImGuiKey_F20, ImGuiKey_F21, ImGuiKey_F22, ImGuiKey_F23, ImGuiKey_F24,\n    ImGuiKey_Apostrophe,        // '\n    ImGuiKey_Comma,             // ,\n    ImGuiKey_Minus,             // -\n    ImGuiKey_Period,            // .\n    ImGuiKey_Slash,             // /\n    ImGuiKey_Semicolon,         // ;\n    ImGuiKey_Equal,             // =\n    ImGuiKey_LeftBracket,       // [\n    ImGuiKey_Backslash,         // \\ (this text inhibit multiline comment caused by backslash)\n    ImGuiKey_RightBracket,      // ]\n    ImGuiKey_GraveAccent,       // `\n    ImGuiKey_CapsLock,\n    ImGuiKey_ScrollLock,\n    ImGuiKey_NumLock,\n    ImGuiKey_PrintScreen,\n    ImGuiKey_Pause,\n    ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,\n    ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,\n    ImGuiKey_KeypadDecimal,\n    ImGuiKey_KeypadDivide,\n    ImGuiKey_KeypadMultiply,\n    ImGuiKey_KeypadSubtract,\n    ImGuiKey_KeypadAdd,\n    ImGuiKey_KeypadEnter,\n    ImGuiKey_KeypadEqual,\n    ImGuiKey_AppBack,               // Available on some keyboard/mouses. Often referred as \"Browser Back\"\n    ImGuiKey_AppForward,\n\n    // Gamepad (some of those are analog values, 0.0f to 1.0f)                          // NAVIGATION ACTION\n    // (download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets)\n    ImGuiKey_GamepadStart,          // Menu (Xbox)      + (Switch)   Start/Options (PS)\n    ImGuiKey_GamepadBack,           // View (Xbox)      - (Switch)   Share (PS)\n    ImGuiKey_GamepadFaceLeft,       // X (Xbox)         Y (Switch)   Square (PS)        // Tap: Toggle Menu. Hold: Windowing mode (Focus/Move/Resize windows)\n    ImGuiKey_GamepadFaceRight,      // B (Xbox)         A (Switch)   Circle (PS)        // Cancel / Close / Exit\n    ImGuiKey_GamepadFaceUp,         // Y (Xbox)         X (Switch)   Triangle (PS)      // Text Input / On-screen Keyboard\n    ImGuiKey_GamepadFaceDown,       // A (Xbox)         B (Switch)   Cross (PS)         // Activate / Open / Toggle / Tweak\n    ImGuiKey_GamepadDpadLeft,       // D-pad Left                                       // Move / Tweak / Resize Window (in Windowing mode)\n    ImGuiKey_GamepadDpadRight,      // D-pad Right                                      // Move / Tweak / Resize Window (in Windowing mode)\n    ImGuiKey_GamepadDpadUp,         // D-pad Up                                         // Move / Tweak / Resize Window (in Windowing mode)\n    ImGuiKey_GamepadDpadDown,       // D-pad Down                                       // Move / Tweak / Resize Window (in Windowing mode)\n    ImGuiKey_GamepadL1,             // L Bumper (Xbox)  L (Switch)   L1 (PS)            // Tweak Slower / Focus Previous (in Windowing mode)\n    ImGuiKey_GamepadR1,             // R Bumper (Xbox)  R (Switch)   R1 (PS)            // Tweak Faster / Focus Next (in Windowing mode)\n    ImGuiKey_GamepadL2,             // L Trig. (Xbox)   ZL (Switch)  L2 (PS) [Analog]\n    ImGuiKey_GamepadR2,             // R Trig. (Xbox)   ZR (Switch)  R2 (PS) [Analog]\n    ImGuiKey_GamepadL3,             // L Stick (Xbox)   L3 (Switch)  L3 (PS)\n    ImGuiKey_GamepadR3,             // R Stick (Xbox)   R3 (Switch)  R3 (PS)\n    ImGuiKey_GamepadLStickLeft,     // [Analog]                                         // Move Window (in Windowing mode)\n    ImGuiKey_GamepadLStickRight,    // [Analog]                                         // Move Window (in Windowing mode)\n    ImGuiKey_GamepadLStickUp,       // [Analog]                                         // Move Window (in Windowing mode)\n    ImGuiKey_GamepadLStickDown,     // [Analog]                                         // Move Window (in Windowing mode)\n    ImGuiKey_GamepadRStickLeft,     // [Analog]\n    ImGuiKey_GamepadRStickRight,    // [Analog]\n    ImGuiKey_GamepadRStickUp,       // [Analog]\n    ImGuiKey_GamepadRStickDown,     // [Analog]\n\n    // Aliases: Mouse Buttons (auto-submitted from AddMouseButtonEvent() calls)\n    // - This is mirroring the data also written to io.MouseDown[], io.MouseWheel, in a format allowing them to be accessed via standard key API.\n    ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,\n\n    // [Internal] Reserved for mod storage\n    ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,\n    ImGuiKey_NamedKey_END,\n\n    // Keyboard Modifiers (explicitly submitted by backend via AddKeyEvent() calls)\n    // - This is mirroring the data also written to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper, in a format allowing\n    //   them to be accessed via standard key API, allowing calls such as IsKeyPressed(), IsKeyReleased(), querying duration etc.\n    // - Code polling every key (e.g. an interface to detect a key press for input mapping) might want to ignore those\n    //   and prefer using the real keys (e.g. ImGuiKey_LeftCtrl, ImGuiKey_RightCtrl instead of ImGuiMod_Ctrl).\n    // - In theory the value of keyboard modifiers should be roughly equivalent to a logical or of the equivalent left/right keys.\n    //   In practice: it's complicated; mods are often provided from different sources. Keyboard layout, IME, sticky keys and\n    //   backends tend to interfere and break that equivalence. The safer decision is to relay that ambiguity down to the end-user...\n    // - On macOS, we swap Cmd(Super) and Ctrl keys at the time of the io.AddKeyEvent() call.\n    ImGuiMod_None                   = 0,\n    ImGuiMod_Ctrl                   = 1 << 12, // Ctrl (non-macOS), Cmd (macOS)\n    ImGuiMod_Shift                  = 1 << 13, // Shift\n    ImGuiMod_Alt                    = 1 << 14, // Option/Menu\n    ImGuiMod_Super                  = 1 << 15, // Windows/Super (non-macOS), Ctrl (macOS)\n    ImGuiMod_Mask_                  = 0xF000,  // 4-bits\n\n    // [Internal] If you need to iterate all keys (for e.g. an input mapper) you may use ImGuiKey_NamedKey_BEGIN..ImGuiKey_NamedKey_END.\n    ImGuiKey_NamedKey_COUNT         = ImGuiKey_NamedKey_END - ImGuiKey_NamedKey_BEGIN,\n    //ImGuiKey_KeysData_SIZE        = ImGuiKey_NamedKey_COUNT,  // Size of KeysData[]: only hold named keys\n    //ImGuiKey_KeysData_OFFSET      = ImGuiKey_NamedKey_BEGIN,  // Accesses to io.KeysData[] must use (key - ImGuiKey_NamedKey_BEGIN) index.\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiKey_COUNT                  = ImGuiKey_NamedKey_END,    // Obsoleted in 1.91.5 because it was extremely misleading (since named keys don't start at 0 anymore)\n    ImGuiMod_Shortcut               = ImGuiMod_Ctrl,            // Removed in 1.90.7, you can now simply use ImGuiMod_Ctrl\n    ImGuiKey_ModCtrl = ImGuiMod_Ctrl, ImGuiKey_ModShift = ImGuiMod_Shift, ImGuiKey_ModAlt = ImGuiMod_Alt, ImGuiKey_ModSuper = ImGuiMod_Super, // Renamed in 1.89\n    //ImGuiKey_KeyPadEnter = ImGuiKey_KeypadEnter,              // Renamed in 1.87\n#endif\n};\n\n// Flags for Shortcut(), SetNextItemShortcut(),\n// (and for upcoming extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner() that are still in imgui_internal.h)\n// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)\nenum ImGuiInputFlags_\n{\n    ImGuiInputFlags_None                    = 0,\n    ImGuiInputFlags_Repeat                  = 1 << 0,   // Enable repeat. Return true on successive repeats. Default for legacy IsKeyPressed(). NOT Default for legacy IsMouseClicked(). MUST BE == 1.\n\n    // Flags for Shortcut(), SetNextItemShortcut()\n    // - Routing policies: RouteGlobal+OverActive >> RouteActive or RouteFocused (if owner is active item) >> RouteGlobal+OverFocused >> RouteFocused (if in focused window stack) >> RouteGlobal.\n    // - Default policy is RouteFocused. Can select only 1 policy among all available.\n    ImGuiInputFlags_RouteActive             = 1 << 10,  // Route to active item only.\n    ImGuiInputFlags_RouteFocused            = 1 << 11,  // Route to windows in the focus stack (DEFAULT). Deep-most focused window takes inputs. Active item takes inputs over deep-most focused window.\n    ImGuiInputFlags_RouteGlobal             = 1 << 12,  // Global route (unless a focused window or active item registered the route).\n    ImGuiInputFlags_RouteAlways             = 1 << 13,  // Do not register route, poll keys directly.\n    // - Routing options\n    ImGuiInputFlags_RouteOverFocused        = 1 << 14,  // Option: global route: higher priority than focused route (unless active item in focused route).\n    ImGuiInputFlags_RouteOverActive         = 1 << 15,  // Option: global route: higher priority than active item. Unlikely you need to use that: will interfere with every active items, e.g. CTRL+A registered by InputText will be overridden by this. May not be fully honored as user/internal code is likely to always assume they can access keys when active.\n    ImGuiInputFlags_RouteUnlessBgFocused    = 1 << 16,  // Option: global route: will not be applied if underlying background/void is focused (== no Dear ImGui windows are focused). Useful for overlay applications.\n    ImGuiInputFlags_RouteFromRootWindow     = 1 << 17,  // Option: route evaluated from the point of view of root window rather than current window.\n\n    // Flags for SetNextItemShortcut()\n    ImGuiInputFlags_Tooltip                 = 1 << 18,  // Automatically display a tooltip when hovering item [BETA] Unsure of right api (opt-in/opt-out)\n};\n\n// Configuration flags stored in io.ConfigFlags. Set by user/application.\nenum ImGuiConfigFlags_\n{\n    ImGuiConfigFlags_None                   = 0,\n    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. Enable full Tabbing + directional arrows + space/enter to activate.\n    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. Backend also needs to set ImGuiBackendFlags_HasGamepad.\n    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct dear imgui to disable mouse inputs and interactions.\n    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.\n    ImGuiConfigFlags_NoKeyboard             = 1 << 6,   // Instruct dear imgui to disable keyboard inputs and interactions. This is done by ignoring keyboard events and clearing existing states.\n\n    // User storage (to allow your backend/engine to communicate to code that may be shared between multiple projects. Those flags are NOT used by core Dear ImGui)\n    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.\n    ImGuiConfigFlags_IsTouchScreen          = 1 << 21,  // Application is using a touch screen instead of a mouse.\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // [moved/renamed in 1.91.4] -> use bool io.ConfigNavMoveSetMousePos\n    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // [moved/renamed in 1.91.4] -> use bool io.ConfigNavCaptureKeyboard\n#endif\n};\n\n// Backend capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom backend.\nenum ImGuiBackendFlags_\n{\n    ImGuiBackendFlags_None                  = 0,\n    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Backend Platform supports gamepad and currently has one connected.\n    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.\n    ImGuiBackendFlags_HasSetMousePos        = 1 << 2,   // Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if io.ConfigNavMoveSetMousePos is set).\n    ImGuiBackendFlags_RendererHasVtxOffset  = 1 << 3,   // Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.\n};\n\n// Enumeration for PushStyleColor() / PopStyleColor()\nenum ImGuiCol_\n{\n    ImGuiCol_Text,\n    ImGuiCol_TextDisabled,\n    ImGuiCol_WindowBg,              // Background of normal windows\n    ImGuiCol_ChildBg,               // Background of child windows\n    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows\n    ImGuiCol_Border,\n    ImGuiCol_BorderShadow,\n    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input\n    ImGuiCol_FrameBgHovered,\n    ImGuiCol_FrameBgActive,\n    ImGuiCol_TitleBg,               // Title bar\n    ImGuiCol_TitleBgActive,         // Title bar when focused\n    ImGuiCol_TitleBgCollapsed,      // Title bar when collapsed\n    ImGuiCol_MenuBarBg,\n    ImGuiCol_ScrollbarBg,\n    ImGuiCol_ScrollbarGrab,\n    ImGuiCol_ScrollbarGrabHovered,\n    ImGuiCol_ScrollbarGrabActive,\n    ImGuiCol_CheckMark,             // Checkbox tick and RadioButton circle\n    ImGuiCol_SliderGrab,\n    ImGuiCol_SliderGrabActive,\n    ImGuiCol_Button,\n    ImGuiCol_ButtonHovered,\n    ImGuiCol_ButtonActive,\n    ImGuiCol_Header,                // Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem\n    ImGuiCol_HeaderHovered,\n    ImGuiCol_HeaderActive,\n    ImGuiCol_Separator,\n    ImGuiCol_SeparatorHovered,\n    ImGuiCol_SeparatorActive,\n    ImGuiCol_ResizeGrip,            // Resize grip in lower-right and lower-left corners of windows.\n    ImGuiCol_ResizeGripHovered,\n    ImGuiCol_ResizeGripActive,\n    ImGuiCol_TabHovered,            // Tab background, when hovered\n    ImGuiCol_Tab,                   // Tab background, when tab-bar is focused & tab is unselected\n    ImGuiCol_TabSelected,           // Tab background, when tab-bar is focused & tab is selected\n    ImGuiCol_TabSelectedOverline,   // Tab horizontal overline, when tab-bar is focused & tab is selected\n    ImGuiCol_TabDimmed,             // Tab background, when tab-bar is unfocused & tab is unselected\n    ImGuiCol_TabDimmedSelected,     // Tab background, when tab-bar is unfocused & tab is selected\n    ImGuiCol_TabDimmedSelectedOverline,//..horizontal overline, when tab-bar is unfocused & tab is selected\n    ImGuiCol_PlotLines,\n    ImGuiCol_PlotLinesHovered,\n    ImGuiCol_PlotHistogram,\n    ImGuiCol_PlotHistogramHovered,\n    ImGuiCol_TableHeaderBg,         // Table header background\n    ImGuiCol_TableBorderStrong,     // Table outer and header borders (prefer using Alpha=1.0 here)\n    ImGuiCol_TableBorderLight,      // Table inner borders (prefer using Alpha=1.0 here)\n    ImGuiCol_TableRowBg,            // Table row background (even rows)\n    ImGuiCol_TableRowBgAlt,         // Table row background (odd rows)\n    ImGuiCol_TextLink,              // Hyperlink color\n    ImGuiCol_TextSelectedBg,\n    ImGuiCol_DragDropTarget,        // Rectangle highlighting a drop target\n    ImGuiCol_NavCursor,             // Color of keyboard/gamepad navigation cursor/rectangle, when visible\n    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB\n    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active\n    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active\n    ImGuiCol_COUNT,\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiCol_TabActive = ImGuiCol_TabSelected,                  // [renamed in 1.90.9]\n    ImGuiCol_TabUnfocused = ImGuiCol_TabDimmed,                 // [renamed in 1.90.9]\n    ImGuiCol_TabUnfocusedActive = ImGuiCol_TabDimmedSelected,   // [renamed in 1.90.9]\n    ImGuiCol_NavHighlight = ImGuiCol_NavCursor,                 // [renamed in 1.91.4]\n#endif\n};\n\n// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.\n// - The enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code.\n//   During initialization or between frames, feel free to just poke into ImGuiStyle directly.\n// - Tip: Use your programming IDE navigation facilities on the names in the _second column_ below to find the actual members and their description.\n//   - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n//   - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n// - When changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.\nenum ImGuiStyleVar_\n{\n    // Enum name -------------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)\n    ImGuiStyleVar_Alpha,                    // float     Alpha\n    ImGuiStyleVar_DisabledAlpha,            // float     DisabledAlpha\n    ImGuiStyleVar_WindowPadding,            // ImVec2    WindowPadding\n    ImGuiStyleVar_WindowRounding,           // float     WindowRounding\n    ImGuiStyleVar_WindowBorderSize,         // float     WindowBorderSize\n    ImGuiStyleVar_WindowMinSize,            // ImVec2    WindowMinSize\n    ImGuiStyleVar_WindowTitleAlign,         // ImVec2    WindowTitleAlign\n    ImGuiStyleVar_ChildRounding,            // float     ChildRounding\n    ImGuiStyleVar_ChildBorderSize,          // float     ChildBorderSize\n    ImGuiStyleVar_PopupRounding,            // float     PopupRounding\n    ImGuiStyleVar_PopupBorderSize,          // float     PopupBorderSize\n    ImGuiStyleVar_FramePadding,             // ImVec2    FramePadding\n    ImGuiStyleVar_FrameRounding,            // float     FrameRounding\n    ImGuiStyleVar_FrameBorderSize,          // float     FrameBorderSize\n    ImGuiStyleVar_ItemSpacing,              // ImVec2    ItemSpacing\n    ImGuiStyleVar_ItemInnerSpacing,         // ImVec2    ItemInnerSpacing\n    ImGuiStyleVar_IndentSpacing,            // float     IndentSpacing\n    ImGuiStyleVar_CellPadding,              // ImVec2    CellPadding\n    ImGuiStyleVar_ScrollbarSize,            // float     ScrollbarSize\n    ImGuiStyleVar_ScrollbarRounding,        // float     ScrollbarRounding\n    ImGuiStyleVar_GrabMinSize,              // float     GrabMinSize\n    ImGuiStyleVar_GrabRounding,             // float     GrabRounding\n    ImGuiStyleVar_TabRounding,              // float     TabRounding\n    ImGuiStyleVar_TabBorderSize,            // float     TabBorderSize\n    ImGuiStyleVar_TabBarBorderSize,         // float     TabBarBorderSize\n    ImGuiStyleVar_TabBarOverlineSize,       // float     TabBarOverlineSize\n    ImGuiStyleVar_TableAngledHeadersAngle,  // float     TableAngledHeadersAngle\n    ImGuiStyleVar_TableAngledHeadersTextAlign,// ImVec2  TableAngledHeadersTextAlign\n    ImGuiStyleVar_ButtonTextAlign,          // ImVec2    ButtonTextAlign\n    ImGuiStyleVar_SelectableTextAlign,      // ImVec2    SelectableTextAlign\n    ImGuiStyleVar_SeparatorTextBorderSize,  // float     SeparatorTextBorderSize\n    ImGuiStyleVar_SeparatorTextAlign,       // ImVec2    SeparatorTextAlign\n    ImGuiStyleVar_SeparatorTextPadding,     // ImVec2    SeparatorTextPadding\n    ImGuiStyleVar_COUNT\n};\n\n// Flags for InvisibleButton() [extended in imgui_internal.h]\nenum ImGuiButtonFlags_\n{\n    ImGuiButtonFlags_None                   = 0,\n    ImGuiButtonFlags_MouseButtonLeft        = 1 << 0,   // React on left mouse button (default)\n    ImGuiButtonFlags_MouseButtonRight       = 1 << 1,   // React on right mouse button\n    ImGuiButtonFlags_MouseButtonMiddle      = 1 << 2,   // React on center mouse button\n    ImGuiButtonFlags_MouseButtonMask_       = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle, // [Internal]\n    ImGuiButtonFlags_EnableNav              = 1 << 3,   // InvisibleButton(): do not disable navigation/tabbing. Otherwise disabled by default.\n};\n\n// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()\nenum ImGuiColorEditFlags_\n{\n    ImGuiColorEditFlags_None            = 0,\n    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).\n    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on color square.\n    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.\n    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)\n    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).\n    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.\n    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).\n    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.\n    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.\n    ImGuiColorEditFlags_NoBorder        = 1 << 10,  //              // ColorButton: disable border (which is enforced by default)\n\n    // User Options (right-click on widget to change some of them).\n    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.\n    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.\n    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.\n    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).\n    ImGuiColorEditFlags_DisplayRGB      = 1 << 20,  // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.\n    ImGuiColorEditFlags_DisplayHSV      = 1 << 21,  // [Display]    // \"\n    ImGuiColorEditFlags_DisplayHex      = 1 << 22,  // [Display]    // \"\n    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.\n    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.\n    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.\n    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.\n    ImGuiColorEditFlags_InputRGB        = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.\n    ImGuiColorEditFlags_InputHSV        = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.\n\n    // Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to\n    // override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.\n    ImGuiColorEditFlags_DefaultOptions_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,\n\n    // [Internal] Masks\n    ImGuiColorEditFlags_DisplayMask_    = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,\n    ImGuiColorEditFlags_DataTypeMask_   = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,\n    ImGuiColorEditFlags_PickerMask_     = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,\n    ImGuiColorEditFlags_InputMask_      = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV,\n\n    // Obsolete names\n    //ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  // [renamed in 1.69]\n};\n\n// Flags for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.\n// We use the same sets of flags for DragXXX() and SliderXXX() functions as the features are the same and it makes it easier to swap them.\n// (Those are per-item flags. There is shared behavior flag too: ImGuiIO: io.ConfigDragClickToInputText)\nenum ImGuiSliderFlags_\n{\n    ImGuiSliderFlags_None               = 0,\n    ImGuiSliderFlags_Logarithmic        = 1 << 5,       // Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.\n    ImGuiSliderFlags_NoRoundToFormat    = 1 << 6,       // Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits).\n    ImGuiSliderFlags_NoInput            = 1 << 7,       // Disable CTRL+Click or Enter key allowing to input text directly into the widget.\n    ImGuiSliderFlags_WrapAround         = 1 << 8,       // Enable wrapping around from max to min and from min to max. Only supported by DragXXX() functions for now.\n    ImGuiSliderFlags_ClampOnInput       = 1 << 9,       // Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.\n    ImGuiSliderFlags_ClampZeroRange     = 1 << 10,      // Clamp even if min==max==0.0f. Otherwise due to legacy reason DragXXX functions don't clamp with those values. When your clamping limits are dynamic you almost always want to use it.\n    ImGuiSliderFlags_NoSpeedTweaks      = 1 << 11,      // Disable keyboard modifiers altering tweak speed. Useful if you want to alter tweak speed yourself based on your own logic.\n    ImGuiSliderFlags_AlwaysClamp        = ImGuiSliderFlags_ClampOnInput | ImGuiSliderFlags_ClampZeroRange,\n    ImGuiSliderFlags_InvalidMask_       = 0x7000000F,   // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.\n};\n\n// Identify a mouse button.\n// Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience.\nenum ImGuiMouseButton_\n{\n    ImGuiMouseButton_Left = 0,\n    ImGuiMouseButton_Right = 1,\n    ImGuiMouseButton_Middle = 2,\n    ImGuiMouseButton_COUNT = 5\n};\n\n// Enumeration for GetMouseCursor()\n// User code may request backend to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here\nenum ImGuiMouseCursor_\n{\n    ImGuiMouseCursor_None = -1,\n    ImGuiMouseCursor_Arrow = 0,\n    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.\n    ImGuiMouseCursor_ResizeAll,         // (Unused by Dear ImGui functions)\n    ImGuiMouseCursor_ResizeNS,          // When hovering over a horizontal border\n    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column\n    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window\n    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window\n    ImGuiMouseCursor_Hand,              // (Unused by Dear ImGui functions. Use for e.g. hyperlinks)\n    ImGuiMouseCursor_NotAllowed,        // When hovering something with disallowed interaction. Usually a crossed circle.\n    ImGuiMouseCursor_COUNT\n};\n\n// Enumeration for AddMouseSourceEvent() actual source of Mouse Input data.\n// Historically we use \"Mouse\" terminology everywhere to indicate pointer data, e.g. MousePos, IsMousePressed(), io.AddMousePosEvent()\n// But that \"Mouse\" data can come from different source which occasionally may be useful for application to know about.\n// You can submit a change of pointer type using io.AddMouseSourceEvent().\nenum ImGuiMouseSource : int\n{\n    ImGuiMouseSource_Mouse = 0,         // Input is coming from an actual mouse.\n    ImGuiMouseSource_TouchScreen,       // Input is coming from a touch screen (no hovering prior to initial press, less precise initial press aiming, dual-axis wheeling possible).\n    ImGuiMouseSource_Pen,               // Input is coming from a pressure/magnetic pen (often used in conjunction with high-sampling rates).\n    ImGuiMouseSource_COUNT\n};\n\n// Enumeration for ImGui::SetNextWindow***(), SetWindow***(), SetNextItem***() functions\n// Represent a condition.\n// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.\nenum ImGuiCond_\n{\n    ImGuiCond_None          = 0,        // No condition (always set the variable), same as _Always\n    ImGuiCond_Always        = 1 << 0,   // No condition (always set the variable), same as _None\n    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call will succeed)\n    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)\n    ImGuiCond_Appearing     = 1 << 3,   // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Tables API flags and structures (ImGuiTableFlags, ImGuiTableColumnFlags, ImGuiTableRowFlags, ImGuiTableBgTarget, ImGuiTableSortSpecs, ImGuiTableColumnSortSpecs)\n//-----------------------------------------------------------------------------\n\n// Flags for ImGui::BeginTable()\n// - Important! Sizing policies have complex and subtle side effects, much more so than you would expect.\n//   Read comments/demos carefully + experiment with live demos to get acquainted with them.\n// - The DEFAULT sizing policies are:\n//    - Default to ImGuiTableFlags_SizingFixedFit    if ScrollX is on, or if host window has ImGuiWindowFlags_AlwaysAutoResize.\n//    - Default to ImGuiTableFlags_SizingStretchSame if ScrollX is off.\n// - When ScrollX is off:\n//    - Table defaults to ImGuiTableFlags_SizingStretchSame -> all Columns defaults to ImGuiTableColumnFlags_WidthStretch with same weight.\n//    - Columns sizing policy allowed: Stretch (default), Fixed/Auto.\n//    - Fixed Columns (if any) will generally obtain their requested width (unless the table cannot fit them all).\n//    - Stretch Columns will share the remaining width according to their respective weight.\n//    - Mixed Fixed/Stretch columns is possible but has various side-effects on resizing behaviors.\n//      The typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.\n//      (this is because the visible order of columns have subtle but necessary effects on how they react to manual resizing).\n// - When ScrollX is on:\n//    - Table defaults to ImGuiTableFlags_SizingFixedFit -> all Columns defaults to ImGuiTableColumnFlags_WidthFixed\n//    - Columns sizing policy allowed: Fixed/Auto mostly.\n//    - Fixed Columns can be enlarged as needed. Table will show a horizontal scrollbar if needed.\n//    - When using auto-resizing (non-resizable) fixed columns, querying the content width to use item right-alignment e.g. SetNextItemWidth(-FLT_MIN) doesn't make sense, would create a feedback loop.\n//    - Using Stretch columns OFTEN DOES NOT MAKE SENSE if ScrollX is on, UNLESS you have specified a value for 'inner_width' in BeginTable().\n//      If you specify a value for 'inner_width' then effectively the scrolling space is known and Stretch or mixed Fixed/Stretch columns become meaningful again.\n// - Read on documentation at the top of imgui_tables.cpp for details.\nenum ImGuiTableFlags_\n{\n    // Features\n    ImGuiTableFlags_None                       = 0,\n    ImGuiTableFlags_Resizable                  = 1 << 0,   // Enable resizing columns.\n    ImGuiTableFlags_Reorderable                = 1 << 1,   // Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)\n    ImGuiTableFlags_Hideable                   = 1 << 2,   // Enable hiding/disabling columns in context menu.\n    ImGuiTableFlags_Sortable                   = 1 << 3,   // Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.\n    ImGuiTableFlags_NoSavedSettings            = 1 << 4,   // Disable persisting columns order, width and sort settings in the .ini file.\n    ImGuiTableFlags_ContextMenuInBody          = 1 << 5,   // Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().\n    // Decorations\n    ImGuiTableFlags_RowBg                      = 1 << 6,   // Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)\n    ImGuiTableFlags_BordersInnerH              = 1 << 7,   // Draw horizontal borders between rows.\n    ImGuiTableFlags_BordersOuterH              = 1 << 8,   // Draw horizontal borders at the top and bottom.\n    ImGuiTableFlags_BordersInnerV              = 1 << 9,   // Draw vertical borders between columns.\n    ImGuiTableFlags_BordersOuterV              = 1 << 10,  // Draw vertical borders on the left and right sides.\n    ImGuiTableFlags_BordersH                   = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH, // Draw horizontal borders.\n    ImGuiTableFlags_BordersV                   = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV, // Draw vertical borders.\n    ImGuiTableFlags_BordersInner               = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH, // Draw inner borders.\n    ImGuiTableFlags_BordersOuter               = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH, // Draw outer borders.\n    ImGuiTableFlags_Borders                    = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter,   // Draw all borders.\n    ImGuiTableFlags_NoBordersInBody            = 1 << 11,  // [ALPHA] Disable vertical borders in columns Body (borders will always appear in Headers). -> May move to style\n    ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12,  // [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers). -> May move to style\n    // Sizing Policy (read above for defaults)\n    ImGuiTableFlags_SizingFixedFit             = 1 << 13,  // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.\n    ImGuiTableFlags_SizingFixedSame            = 2 << 13,  // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.\n    ImGuiTableFlags_SizingStretchProp          = 3 << 13,  // Columns default to _WidthStretch with default weights proportional to each columns contents widths.\n    ImGuiTableFlags_SizingStretchSame          = 4 << 13,  // Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().\n    // Sizing Extra Options\n    ImGuiTableFlags_NoHostExtendX              = 1 << 16,  // Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.\n    ImGuiTableFlags_NoHostExtendY              = 1 << 17,  // Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.\n    ImGuiTableFlags_NoKeepColumnsVisible       = 1 << 18,  // Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.\n    ImGuiTableFlags_PreciseWidths              = 1 << 19,  // Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.\n    // Clipping\n    ImGuiTableFlags_NoClip                     = 1 << 20,  // Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().\n    // Padding\n    ImGuiTableFlags_PadOuterX                  = 1 << 21,  // Default if BordersOuterV is on. Enable outermost padding. Generally desirable if you have headers.\n    ImGuiTableFlags_NoPadOuterX                = 1 << 22,  // Default if BordersOuterV is off. Disable outermost padding.\n    ImGuiTableFlags_NoPadInnerX                = 1 << 23,  // Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).\n    // Scrolling\n    ImGuiTableFlags_ScrollX                    = 1 << 24,  // Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this creates a child window, ScrollY is currently generally recommended when using ScrollX.\n    ImGuiTableFlags_ScrollY                    = 1 << 25,  // Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.\n    // Sorting\n    ImGuiTableFlags_SortMulti                  = 1 << 26,  // Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).\n    ImGuiTableFlags_SortTristate               = 1 << 27,  // Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).\n    // Miscellaneous\n    ImGuiTableFlags_HighlightHoveredColumn     = 1 << 28,  // Highlight column headers when hovered (may evolve into a fuller highlight)\n\n    // [Internal] Combinations and masks\n    ImGuiTableFlags_SizingMask_                = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame,\n};\n\n// Flags for ImGui::TableSetupColumn()\nenum ImGuiTableColumnFlags_\n{\n    // Input configuration flags\n    ImGuiTableColumnFlags_None                  = 0,\n    ImGuiTableColumnFlags_Disabled              = 1 << 0,   // Overriding/master disable flag: hide column, won't show in context menu (unlike calling TableSetColumnEnabled() which manipulates the user accessible state)\n    ImGuiTableColumnFlags_DefaultHide           = 1 << 1,   // Default as a hidden/disabled column.\n    ImGuiTableColumnFlags_DefaultSort           = 1 << 2,   // Default as a sorting column.\n    ImGuiTableColumnFlags_WidthStretch          = 1 << 3,   // Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).\n    ImGuiTableColumnFlags_WidthFixed            = 1 << 4,   // Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).\n    ImGuiTableColumnFlags_NoResize              = 1 << 5,   // Disable manual resizing.\n    ImGuiTableColumnFlags_NoReorder             = 1 << 6,   // Disable manual reordering this column, this will also prevent other columns from crossing over this column.\n    ImGuiTableColumnFlags_NoHide                = 1 << 7,   // Disable ability to hide/disable this column.\n    ImGuiTableColumnFlags_NoClip                = 1 << 8,   // Disable clipping for this column (all NoClip columns will render in a same draw command).\n    ImGuiTableColumnFlags_NoSort                = 1 << 9,   // Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).\n    ImGuiTableColumnFlags_NoSortAscending       = 1 << 10,  // Disable ability to sort in the ascending direction.\n    ImGuiTableColumnFlags_NoSortDescending      = 1 << 11,  // Disable ability to sort in the descending direction.\n    ImGuiTableColumnFlags_NoHeaderLabel         = 1 << 12,  // TableHeadersRow() will submit an empty label for this column. Convenient for some small columns. Name will still appear in context menu or in angled headers. You may append into this cell by calling TableSetColumnIndex() right after the TableHeadersRow() call.\n    ImGuiTableColumnFlags_NoHeaderWidth         = 1 << 13,  // Disable header text width contribution to automatic column width.\n    ImGuiTableColumnFlags_PreferSortAscending   = 1 << 14,  // Make the initial sort direction Ascending when first sorting on this column (default).\n    ImGuiTableColumnFlags_PreferSortDescending  = 1 << 15,  // Make the initial sort direction Descending when first sorting on this column.\n    ImGuiTableColumnFlags_IndentEnable          = 1 << 16,  // Use current Indent value when entering cell (default for column 0).\n    ImGuiTableColumnFlags_IndentDisable         = 1 << 17,  // Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.\n    ImGuiTableColumnFlags_AngledHeader          = 1 << 18,  // TableHeadersRow() will submit an angled header row for this column. Note this will add an extra row.\n\n    // Output status flags, read-only via TableGetColumnFlags()\n    ImGuiTableColumnFlags_IsEnabled             = 1 << 24,  // Status: is enabled == not hidden by user/api (referred to as \"Hide\" in _DefaultHide and _NoHide) flags.\n    ImGuiTableColumnFlags_IsVisible             = 1 << 25,  // Status: is visible == is enabled AND not clipped by scrolling.\n    ImGuiTableColumnFlags_IsSorted              = 1 << 26,  // Status: is currently part of the sort specs\n    ImGuiTableColumnFlags_IsHovered             = 1 << 27,  // Status: is hovered by mouse\n\n    // [Internal] Combinations and masks\n    ImGuiTableColumnFlags_WidthMask_            = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,\n    ImGuiTableColumnFlags_IndentMask_           = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,\n    ImGuiTableColumnFlags_StatusMask_           = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,\n    ImGuiTableColumnFlags_NoDirectResize_       = 1 << 30,  // [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)\n};\n\n// Flags for ImGui::TableNextRow()\nenum ImGuiTableRowFlags_\n{\n    ImGuiTableRowFlags_None                     = 0,\n    ImGuiTableRowFlags_Headers                  = 1 << 0,   // Identify header row (set default background color + width of its contents accounted differently for auto column width)\n};\n\n// Enum for ImGui::TableSetBgColor()\n// Background colors are rendering in 3 layers:\n//  - Layer 0: draw with RowBg0 color if set, otherwise draw with ColumnBg0 if set.\n//  - Layer 1: draw with RowBg1 color if set, otherwise draw with ColumnBg1 if set.\n//  - Layer 2: draw with CellBg color if set.\n// The purpose of the two row/columns layers is to let you decide if a background color change should override or blend with the existing color.\n// When using ImGuiTableFlags_RowBg on the table, each row has the RowBg0 color automatically set for odd/even rows.\n// If you set the color of RowBg0 target, your color will override the existing RowBg0 color.\n// If you set the color of RowBg1 or ColumnBg1 target, your color will blend over the RowBg0 color.\nenum ImGuiTableBgTarget_\n{\n    ImGuiTableBgTarget_None                     = 0,\n    ImGuiTableBgTarget_RowBg0                   = 1,        // Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)\n    ImGuiTableBgTarget_RowBg1                   = 2,        // Set row background color 1 (generally used for selection marking)\n    ImGuiTableBgTarget_CellBg                   = 3,        // Set cell background color (top-most color)\n};\n\n// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)\n// Obtained by calling TableGetSortSpecs().\n// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.\n// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!\nstruct ImGuiTableSortSpecs\n{\n    const ImGuiTableColumnSortSpecs* Specs;     // Pointer to sort spec array.\n    int                         SpecsCount;     // Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.\n    bool                        SpecsDirty;     // Set to true when specs have changed since last time! Use this to sort again, then clear the flag.\n\n    ImGuiTableSortSpecs()       { memset(this, 0, sizeof(*this)); }\n};\n\n// Sorting specification for one column of a table (sizeof == 12 bytes)\nstruct ImGuiTableColumnSortSpecs\n{\n    ImGuiID                     ColumnUserID;       // User id of the column (if specified by a TableSetupColumn() call)\n    ImS16                       ColumnIndex;        // Index of the column\n    ImS16                       SortOrder;          // Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)\n    ImGuiSortDirection          SortDirection;      // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending\n\n    ImGuiTableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Helpers: Debug log, memory allocations macros, ImVector<>\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Debug Logging into ShowDebugLogWindow(), tty and more.\n//-----------------------------------------------------------------------------\n\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n#define IMGUI_DEBUG_LOG(...)        ImGui::DebugLog(__VA_ARGS__)\n#else\n#define IMGUI_DEBUG_LOG(...)        ((void)0)\n#endif\n\n//-----------------------------------------------------------------------------\n// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()\n// We call C++ constructor on own allocated memory via the placement \"new(ptr) Type()\" syntax.\n// Defining a custom placement new() with a custom parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.\n//-----------------------------------------------------------------------------\n\nstruct ImNewWrapper {};\ninline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }\ninline void  operator delete(void*, ImNewWrapper, void*)   {} // This is only required so we can use the symmetrical new()\n#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)\n#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)\n#define IM_PLACEMENT_NEW(_PTR)              new(ImNewWrapper(), _PTR)\n#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE\ntemplate<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }\n\n//-----------------------------------------------------------------------------\n// ImVector<>\n// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).\n//-----------------------------------------------------------------------------\n// - You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our public structures are relying on it.\n// - We use std-like naming convention here, which is a little unusual for this codebase.\n// - Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.\n// - Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,\n//   Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.\n//-----------------------------------------------------------------------------\n\nIM_MSVC_RUNTIME_CHECKS_OFF\ntemplate<typename T>\nstruct ImVector\n{\n    int                 Size;\n    int                 Capacity;\n    T*                  Data;\n\n    // Provide standard typedefs but we don't use them ourselves.\n    typedef T                   value_type;\n    typedef value_type*         iterator;\n    typedef const value_type*   const_iterator;\n\n    // Constructors, destructor\n    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }\n    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }\n    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); if (src.Data) memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }\n    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything\n\n    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything\n    inline void         clear_delete()                      { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.\n    inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.\n\n    inline bool         empty() const                       { return Size == 0; }\n    inline int          size() const                        { return Size; }\n    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }\n    inline int          max_size() const                    { return 0x7FFFFFFF / (int)sizeof(T); }\n    inline int          capacity() const                    { return Capacity; }\n    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }\n    inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }\n\n    inline T*           begin()                             { return Data; }\n    inline const T*     begin() const                       { return Data; }\n    inline T*           end()                               { return Data + Size; }\n    inline const T*     end() const                         { return Data + Size; }\n    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }\n    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }\n    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }\n    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }\n    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }\n\n    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }\n    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }\n    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }\n    inline void         shrink(int new_size)                { IM_ASSERT(new_size <= Size); Size = new_size; } // Resize a vector to a smaller size, guaranteed not to cause a reallocation\n    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }\n    inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }\n\n    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.\n    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }\n    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }\n    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }\n    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }\n    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }\n    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data + Size);  const ptrdiff_t off = it - Data; if (it < Data + Size - 1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }\n    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }\n    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }\n    inline T*           find(const T& v)                    { T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }\n    inline const T*     find(const T& v) const              { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }\n    inline int          find_index(const T& v) const        { const T* data_end = Data + Size; const T* it = find(v); if (it == data_end) return -1; const ptrdiff_t off = it - Data; return (int)off; }\n    inline bool         find_erase(const T& v)              { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }\n    inline bool         find_erase_unsorted(const T& v)     { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }\n    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }\n};\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiStyle\n//-----------------------------------------------------------------------------\n// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().\n// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,\n// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.\n//-----------------------------------------------------------------------------\n\nstruct ImGuiStyle\n{\n    float       Alpha;                      // Global alpha applies to everything in Dear ImGui.\n    float       DisabledAlpha;              // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.\n    ImVec2      WindowPadding;              // Padding within a window.\n    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.\n    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\n    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().\n    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\n    ImGuiDir    WindowMenuButtonPosition;   // Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.\n    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.\n    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\n    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)\n    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\n    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).\n    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).\n    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\n    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.\n    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).\n    ImVec2      CellPadding;                // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.\n    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\n    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\n    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).\n    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.\n    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.\n    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.\n    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\n    float       LogSliderDeadzone;          // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.\n    float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.\n    float       TabBorderSize;              // Thickness of border around tabs.\n    float       TabMinWidthForCloseButton;  // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.\n    float       TabBarBorderSize;           // Thickness of tab-bar separator, which takes on the tab active color to denote focus.\n    float       TabBarOverlineSize;         // Thickness of tab-bar overline, which highlights the selected tab-bar.\n    float       TableAngledHeadersAngle;    // Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees).\n    ImVec2      TableAngledHeadersTextAlign;// Alignment of angled headers within the cell\n    ImGuiDir    ColorButtonPosition;        // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.\n    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).\n    ImVec2      SelectableTextAlign;        // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.\n    float       SeparatorTextBorderSize;    // Thickness of border in SeparatorText()\n    ImVec2      SeparatorTextAlign;         // Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).\n    ImVec2      SeparatorTextPadding;       // Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.\n    ImVec2      DisplayWindowPadding;       // Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.\n    ImVec2      DisplaySafeAreaPadding;     // Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).\n    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.\n    bool        AntiAliasedLines;           // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).\n    bool        AntiAliasedLinesUseTex;     // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).\n    bool        AntiAliasedFill;            // Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).\n    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\n    float       CircleTessellationMaxError; // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.\n    ImVec4      Colors[ImGuiCol_COUNT];\n\n    // Behaviors\n    // (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO)\n    float             HoverStationaryDelay;     // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.\n    float             HoverDelayShort;          // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.\n    float             HoverDelayNormal;         // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). \"\n    ImGuiHoveredFlags HoverFlagsForTooltipMouse;// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.\n    ImGuiHoveredFlags HoverFlagsForTooltipNav;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.\n\n    IMGUI_API ImGuiStyle();\n    IMGUI_API void ScaleAllSizes(float scale_factor);\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiIO\n//-----------------------------------------------------------------------------\n// Communicate most settings and inputs/outputs to Dear ImGui using this structure.\n// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.\n// It is generally expected that:\n// - initialization: backends and user code writes to ImGuiIO.\n// - main loop: backends writes to ImGuiIO, user code and imgui code reads from ImGuiIO.\n//-----------------------------------------------------------------------------\n// Also see ImGui::GetPlatformIO() and ImGuiPlatformIO struct for OS/platform related functions: clipboard, IME etc.\n//-----------------------------------------------------------------------------\n\n// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.\n// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.\nstruct ImGuiKeyData\n{\n    bool        Down;               // True for if key is down\n    float       DownDuration;       // Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)\n    float       DownDurationPrev;   // Last frame duration the key has been down\n    float       AnalogValue;        // 0.0f..1.0f for gamepad values\n};\n\nstruct ImGuiIO\n{\n    //------------------------------------------------------------------\n    // Configuration                            // Default value\n    //------------------------------------------------------------------\n\n    ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.\n    ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.\n    ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.\n    float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.\n    float       IniSavingRate;                  // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.\n    const char* IniFilename;                    // = \"imgui.ini\"    // Path to .ini file (important: default \"imgui.ini\" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.\n    const char* LogFilename;                    // = \"imgui_log.txt\"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).\n    void*       UserData;                       // = NULL           // Store your own data.\n\n    // Font system\n    ImFontAtlas*Fonts;                          // <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.\n    float       FontGlobalScale;                // = 1.0f           // Global scale all fonts\n    bool        FontAllowUserScaling;           // = false          // [OBSOLETE] Allow user scaling text of individual window with CTRL+Wheel.\n    ImFont*     FontDefault;                    // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].\n    ImVec2      DisplayFramebufferScale;        // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.\n\n    // Keyboard/Gamepad Navigation options\n    bool        ConfigNavSwapGamepadButtons;    // = false          // Swap Activate<>Cancel (A<>B) buttons, matching typical \"Nintendo/Japanese style\" gamepad layout.\n    bool        ConfigNavMoveSetMousePos;       // = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.\n    bool        ConfigNavCaptureKeyboard;       // = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.\n    bool        ConfigNavEscapeClearFocusItem;  // = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.\n    bool        ConfigNavEscapeClearFocusWindow;// = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).\n    bool        ConfigNavCursorVisibleAuto;     // = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.\n    bool        ConfigNavCursorVisibleAlways;   // = false          // Navigation cursor is always visible.\n\n    // Miscellaneous options\n    // (you can visualize and interact with all options in 'Demo->Configuration')\n    bool        MouseDrawCursor;                // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.\n    bool        ConfigMacOSXBehaviors;          // = defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.\n    bool        ConfigInputTrickleEventQueue;   // = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.\n    bool        ConfigInputTextCursorBlink;     // = true           // Enable blinking cursor (optional as some users consider it to be distracting).\n    bool        ConfigInputTextEnterKeepActive; // = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).\n    bool        ConfigDragClickToInputText;     // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.\n    bool        ConfigWindowsResizeFromEdges;   // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)\n    bool        ConfigWindowsMoveFromTitleBarOnly;  // = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.\n    bool        ConfigWindowsCopyContentsWithCtrlC; // = false      // [EXPERIMENTAL] CTRL+C copy the contents of focused window into the clipboard. Experimental because: (1) has known issues with nested Begin/End pairs (2) text output quality varies (3) text output is in submission order rather than spatial order.\n    bool        ConfigScrollbarScrollByPage;    // = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.\n    float       ConfigMemoryCompactTimer;       // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.\n\n    // Inputs Behaviors\n    // (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)\n    float       MouseDoubleClickTime;           // = 0.30f          // Time for a double-click, in seconds.\n    float       MouseDoubleClickMaxDist;        // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.\n    float       MouseDragThreshold;             // = 6.0f           // Distance threshold before considering we are dragging.\n    float       KeyRepeatDelay;                 // = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).\n    float       KeyRepeatRate;                  // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.\n\n    //------------------------------------------------------------------\n    // Debug options\n    //------------------------------------------------------------------\n\n    // Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]\n    // - Error recovery is provided as a way to facilitate:\n    //    - Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).\n    //    - Recovery after running an exception handler or any error processing which may skip code after an error has been detected.\n    // - Error recovery is not perfect nor guaranteed! It is a feature to ease development.\n    //   You not are not supposed to rely on it in the course of a normal application run.\n    // - Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().\n    // - By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!\n    // - Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!\n    //   Otherwise it would severely hinder your ability to catch and correct mistakes!\n    // Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.\n    // - Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)\n    // - Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)\n    // - Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.\n    bool        ConfigErrorRecovery;                // = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.\n    bool        ConfigErrorRecoveryEnableAssert;    // = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()\n    bool        ConfigErrorRecoveryEnableDebugLog;  // = true       // Enable debug log output on recoverable errors.\n    bool        ConfigErrorRecoveryEnableTooltip;   // = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.\n\n    // Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.\n    // - The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.\n    // - Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.\n    //   e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).\n    bool        ConfigDebugIsDebuggerPresent;   // = false          // Enable various tools calling IM_DEBUG_BREAK().\n\n    // Tools to detect code submitting items with conflicting/duplicate IDs\n    // - Code should use PushID()/PopID() in loops, or append \"##xx\" to same-label identifiers.\n    // - Empty label e.g. Button(\"\") == same ID as parent widget/node. Use Button(\"##xx\") instead!\n    // - See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system\n    bool        ConfigDebugHighlightIdConflicts;// = true           // Highlight and show an error message when multiple items have conflicting identifiers.\n\n    // Tools to test correct Begin/End and BeginChild/EndChild behaviors.\n    // - Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()\n    // - This is inconsistent with other BeginXXX functions and create confusion for many users.\n    // - We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.\n    bool        ConfigDebugBeginReturnValueOnce;// = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.\n    bool        ConfigDebugBeginReturnValueLoop;// = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add \"io.ConfigDebugBeginReturnValue = io.KeyShift\" in your main loop then occasionally press SHIFT. Windows should be flickering while running.\n\n    // Option to deactivate io.AddFocusEvent(false) handling.\n    // - May facilitate interactions with a debugger when focus loss leads to clearing inputs data.\n    // - Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.\n    bool        ConfigDebugIgnoreFocusLoss;     // = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.\n\n    // Option to audit .ini data\n    bool        ConfigDebugIniSettings;         // = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)\n\n    //------------------------------------------------------------------\n    // Platform Identifiers\n    // (the imgui_impl_xxxx backend files are setting those up for you)\n    //------------------------------------------------------------------\n\n    // Nowadays those would be stored in ImGuiPlatformIO but we are leaving them here for legacy reasons.\n    // Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.\n    const char* BackendPlatformName;            // = NULL\n    const char* BackendRendererName;            // = NULL\n    void*       BackendPlatformUserData;        // = NULL           // User data for platform backend\n    void*       BackendRendererUserData;        // = NULL           // User data for renderer backend\n    void*       BackendLanguageUserData;        // = NULL           // User data for non C++ programming language backend\n\n    //------------------------------------------------------------------\n    // Input - Call before calling NewFrame()\n    //------------------------------------------------------------------\n\n    // Input Functions\n    IMGUI_API void  AddKeyEvent(ImGuiKey key, bool down);                   // Queue a new key down/up event. Key should be \"translated\" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)\n    IMGUI_API void  AddKeyAnalogEvent(ImGuiKey key, bool down, float v);    // Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.\n    IMGUI_API void  AddMousePosEvent(float x, float y);                     // Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)\n    IMGUI_API void  AddMouseButtonEvent(int button, bool down);             // Queue a mouse button change\n    IMGUI_API void  AddMouseWheelEvent(float wheel_x, float wheel_y);       // Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.\n    IMGUI_API void  AddMouseSourceEvent(ImGuiMouseSource source);           // Queue a mouse source change (Mouse/TouchScreen/Pen)\n    IMGUI_API void  AddFocusEvent(bool focused);                            // Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)\n    IMGUI_API void  AddInputCharacter(unsigned int c);                      // Queue a new character input\n    IMGUI_API void  AddInputCharacterUTF16(ImWchar16 c);                    // Queue a new character input from a UTF-16 character, it can be a surrogate\n    IMGUI_API void  AddInputCharactersUTF8(const char* str);                // Queue a new characters input from a UTF-8 string\n\n    IMGUI_API void  SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index = -1); // [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.\n    IMGUI_API void  SetAppAcceptingEvents(bool accepting_events);           // Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.\n    IMGUI_API void  ClearEventsQueue();                                     // Clear all incoming events.\n    IMGUI_API void  ClearInputKeys();                                       // Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.\n    IMGUI_API void  ClearInputMouse();                                      // Clear current mouse state.\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    IMGUI_API void  ClearInputCharacters();                                 // [Obsoleted in 1.89.8] Clear the current frame text input buffer. Now included within ClearInputKeys().\n#endif\n\n    //------------------------------------------------------------------\n    // Output - Updated by NewFrame() or EndFrame()/Render()\n    // (when reading from the io.WantCaptureMouse, io.WantCaptureKeyboard flags to dispatch your inputs, it is\n    //  generally easier and more correct to use their state BEFORE calling NewFrame(). See FAQ for details!)\n    //------------------------------------------------------------------\n\n    bool        WantCaptureMouse;                   // Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).\n    bool        WantCaptureKeyboard;                // Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).\n    bool        WantTextInput;                      // Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).\n    bool        WantSetMousePos;                    // MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.\n    bool        WantSaveIniSettings;                // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!\n    bool        NavActive;                          // Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.\n    bool        NavVisible;                         // Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).\n    float       Framerate;                          // Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.\n    int         MetricsRenderVertices;              // Vertices output during last call to Render()\n    int         MetricsRenderIndices;               // Indices output during last call to Render() = number of triangles * 3\n    int         MetricsRenderWindows;               // Number of visible windows\n    int         MetricsActiveWindows;               // Number of active windows\n    ImVec2      MouseDelta;                         // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.\n\n    //------------------------------------------------------------------\n    // [Internal] Dear ImGui will maintain those fields. Forward compatibility not guaranteed!\n    //------------------------------------------------------------------\n\n    ImGuiContext* Ctx;                              // Parent UI context (needs to be set explicitly by parent).\n\n    // Main Input State\n    // (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)\n    // (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)\n    ImVec2      MousePos;                           // Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)\n    bool        MouseDown[5];                       // Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.\n    float       MouseWheel;                         // Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.\n    float       MouseWheelH;                        // Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.\n    ImGuiMouseSource MouseSource;                   // Mouse actual input peripheral (Mouse/TouchScreen/Pen).\n    bool        KeyCtrl;                            // Keyboard modifier down: Control\n    bool        KeyShift;                           // Keyboard modifier down: Shift\n    bool        KeyAlt;                             // Keyboard modifier down: Alt\n    bool        KeySuper;                           // Keyboard modifier down: Cmd/Super/Windows\n\n    // Other state maintained from data above + IO function calls\n    ImGuiKeyChord KeyMods;                          // Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()\n    ImGuiKeyData  KeysData[ImGuiKey_NamedKey_COUNT];// Key state for all known keys. Use IsKeyXXX() functions to access this.\n    bool        WantCaptureMouseUnlessPopupClose;   // Alternative to WantCaptureMouse: (WantCaptureMouse == true && WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.\n    ImVec2      MousePosPrev;                       // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)\n    ImVec2      MouseClickedPos[5];                 // Position at time of clicking\n    double      MouseClickedTime[5];                // Time of last click (used to figure out double-click)\n    bool        MouseClicked[5];                    // Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)\n    bool        MouseDoubleClicked[5];              // Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)\n    ImU16       MouseClickedCount[5];               // == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down\n    ImU16       MouseClickedLastCount[5];           // Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.\n    bool        MouseReleased[5];                   // Mouse button went from Down to !Down\n    bool        MouseDownOwned[5];                  // Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.\n    bool        MouseDownOwnedUnlessPopupClose[5];  // Track if button was clicked inside a dear imgui window.\n    bool        MouseWheelRequestAxisSwap;          // On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.\n    bool        MouseCtrlLeftAsRightClick;          // (OSX) Set to true when the current click was a ctrl-click that spawned a simulated right click\n    float       MouseDownDuration[5];               // Duration the mouse button has been down (0.0f == just clicked)\n    float       MouseDownDurationPrev[5];           // Previous time the mouse button has been down\n    float       MouseDragMaxDistanceSqr[5];         // Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)\n    float       PenPressure;                        // Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.\n    bool        AppFocusLost;                       // Only modify via AddFocusEvent()\n    bool        AppAcceptingEvents;                 // Only modify via SetAppAcceptingEvents()\n    ImWchar16   InputQueueSurrogate;                // For AddInputCharacterUTF16()\n    ImVector<ImWchar> InputQueueCharacters;         // Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.\n\n    // Legacy: before 1.87, we required backend to fill io.KeyMap[] (imgui->native map) during initialization and io.KeysDown[] (native indices) every frame.\n    // This is still temporarily supported as a legacy feature. However the new preferred scheme is for backend to call io.AddKeyEvent().\n    //   Old (<1.87):  ImGui::IsKeyPressed(ImGui::GetIO().KeyMap[ImGuiKey_Space]) --> New (1.87+) ImGui::IsKeyPressed(ImGuiKey_Space)\n    //   Old (<1.87):  ImGui::IsKeyPressed(MYPLATFORM_KEY_SPACE)                  --> New (1.87+) ImGui::IsKeyPressed(ImGuiKey_Space)\n    // Read https://github.com/ocornut/imgui/issues/4921 for details.\n    //int       KeyMap[ImGuiKey_COUNT];             // [LEGACY] Input: map of indices into the KeysDown[512] entries array which represent your \"native\" keyboard state. The first 512 are now unused and should be kept zero. Legacy backend will write into KeyMap[] using ImGuiKey_ indices which are always >512.\n    //bool      KeysDown[ImGuiKey_COUNT];           // [LEGACY] Input: Keyboard keys that are pressed (ideally left in the \"native\" order your engine has access to keyboard keys, so you can use your own defines/enums for keys). This used to be [512] sized. It is now ImGuiKey_COUNT to allow legacy io.KeysDown[GetKeyIndex(...)] to work without an overflow.\n    //float     NavInputs[ImGuiNavInput_COUNT];     // [LEGACY] Since 1.88, NavInputs[] was removed. Backends from 1.60 to 1.86 won't build. Feed gamepad inputs via io.AddKeyEvent() and ImGuiKey_GamepadXXX enums.\n    //void*     ImeWindowHandle;                    // [Obsoleted in 1.87] Set ImGuiViewport::PlatformHandleRaw instead. Set this to your HWND to get automatic IME cursor positioning.\n\n    // Legacy: before 1.91.1, clipboard functions were stored in ImGuiIO instead of ImGuiPlatformIO.\n    // As this is will affect all users of custom engines/backends, we are providing proper legacy redirection (will obsolete).\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    const char* (*GetClipboardTextFn)(void* user_data);\n    void        (*SetClipboardTextFn)(void* user_data, const char* text);\n    void*       ClipboardUserData;\n#endif\n\n    IMGUI_API   ImGuiIO();\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)\n//-----------------------------------------------------------------------------\n\n// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.\n// The callback function should return 0 by default.\n// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)\n// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)\n// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration\n// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB\n// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows\n// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\n// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.\nstruct ImGuiInputTextCallbackData\n{\n    ImGuiContext*       Ctx;            // Parent UI context\n    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only\n    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only\n    void*               UserData;       // What user passed to InputText()      // Read-only\n\n    // Arguments for the different callback events\n    // - During Resize callback, Buf will be same as your input buffer.\n    // - However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.\n    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.\n    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.\n    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;\n    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]\n    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!\n    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()\n    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1\n    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]\n    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]\n    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)\n    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]\n\n    // Helper functions for text manipulation.\n    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.\n    IMGUI_API ImGuiInputTextCallbackData();\n    IMGUI_API void      DeleteChars(int pos, int bytes_count);\n    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);\n    void                SelectAll()             { SelectionStart = 0; SelectionEnd = BufTextLen; }\n    void                ClearSelection()        { SelectionStart = SelectionEnd = BufTextLen; }\n    bool                HasSelection() const    { return SelectionStart != SelectionEnd; }\n};\n\n// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\n// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.\nstruct ImGuiSizeCallbackData\n{\n    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).\n    ImVec2  Pos;            // Read-only.   Window position, for reference.\n    ImVec2  CurrentSize;    // Read-only.   Current window size.\n    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.\n};\n\n// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()\nstruct ImGuiPayload\n{\n    // Members\n    void*           Data;               // Data (copied and owned by dear imgui)\n    int             DataSize;           // Data size\n\n    // [Internal]\n    ImGuiID         SourceId;           // Source item id\n    ImGuiID         SourceParentId;     // Source parent id (if available)\n    int             DataFrameCount;     // Data timestamp\n    char            DataType[32 + 1];   // Data type tag (short user-supplied string, 32 characters max)\n    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)\n    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.\n\n    ImGuiPayload()  { Clear(); }\n    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }\n    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }\n    bool IsPreview() const                  { return Preview; }\n    bool IsDelivery() const                 { return Delivery; }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)\n//-----------------------------------------------------------------------------\n\n// Helper: Unicode defines\n#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).\n#ifdef IMGUI_USE_WCHAR32\n#define IM_UNICODE_CODEPOINT_MAX     0x10FFFF   // Maximum Unicode code point supported by this build.\n#else\n#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.\n#endif\n\n// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.\n// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\");\nstruct ImGuiOnceUponAFrame\n{\n    ImGuiOnceUponAFrame() { RefFrame = -1; }\n    mutable int RefFrame;\n    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }\n};\n\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\nstruct ImGuiTextFilter\n{\n    IMGUI_API           ImGuiTextFilter(const char* default_filter = \"\");\n    IMGUI_API bool      Draw(const char* label = \"Filter (inc,-exc)\", float width = 0.0f);  // Helper calling InputText+Build\n    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;\n    IMGUI_API void      Build();\n    void                Clear()          { InputBuf[0] = 0; Build(); }\n    bool                IsActive() const { return !Filters.empty(); }\n\n    // [Internal]\n    struct ImGuiTextRange\n    {\n        const char*     b;\n        const char*     e;\n\n        ImGuiTextRange()                                { b = e = NULL; }\n        ImGuiTextRange(const char* _b, const char* _e)  { b = _b; e = _e; }\n        bool            empty() const                   { return b == e; }\n        IMGUI_API void  split(char separator, ImVector<ImGuiTextRange>* out) const;\n    };\n    char                    InputBuf[256];\n    ImVector<ImGuiTextRange>Filters;\n    int                     CountGrep;\n};\n\n// Helper: Growable text buffer for logging/accumulating text\n// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')\nstruct ImGuiTextBuffer\n{\n    ImVector<char>      Buf;\n    IMGUI_API static char EmptyString[1];\n\n    ImGuiTextBuffer()   { }\n    inline char         operator[](int i) const { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }\n    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }\n    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator\n    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }\n    bool                empty() const           { return Buf.Size <= 1; }\n    void                clear()                 { Buf.clear(); }\n    void                reserve(int capacity)   { Buf.reserve(capacity); }\n    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }\n    IMGUI_API void      append(const char* str, const char* str_end = NULL);\n    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);\n    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);\n};\n\n// [Internal] Key+Value for ImGuiStorage\nstruct ImGuiStoragePair\n{\n    ImGuiID     key;\n    union       { int val_i; float val_f; void* val_p; };\n    ImGuiStoragePair(ImGuiID _key, int _val)    { key = _key; val_i = _val; }\n    ImGuiStoragePair(ImGuiID _key, float _val)  { key = _key; val_f = _val; }\n    ImGuiStoragePair(ImGuiID _key, void* _val)  { key = _key; val_p = _val; }\n};\n\n// Helper: Key->Value storage\n// Typically you don't have to worry about this since a storage is held within each Window.\n// We use it to e.g. store collapse state for a tree (Int 0/1)\n// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)\n// You can use it as custom user storage for temporary values. Declare your own storage if, for example:\n// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).\n// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)\n// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.\nstruct ImGuiStorage\n{\n    // [Internal]\n    ImVector<ImGuiStoragePair>      Data;\n\n    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)\n    // - Set***() functions find pair, insertion on demand if missing.\n    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.\n    void                Clear() { Data.clear(); }\n    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;\n    IMGUI_API void      SetInt(ImGuiID key, int val);\n    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;\n    IMGUI_API void      SetBool(ImGuiID key, bool val);\n    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;\n    IMGUI_API void      SetFloat(ImGuiID key, float val);\n    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL\n    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);\n\n    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.\n    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\n    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)\n    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat(\"var\", pvar, 0, 100.0f); some_var += *pvar;\n    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);\n    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);\n    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);\n    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);\n\n    // Advanced: for quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\n    IMGUI_API void      BuildSortByKey();\n    // Obsolete: use on your own storage if you know only integer are being stored (open/close all tree nodes)\n    IMGUI_API void      SetAllInt(int val);\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    //typedef ::ImGuiStoragePair ImGuiStoragePair;  // 1.90.8: moved type outside struct\n#endif\n};\n\n// Helper: Manually clip large list of items.\n// If you have lots evenly spaced items and you have random access to the list, you can perform coarse\n// clipping based on visibility to only submit items that are in view.\n// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.\n// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally\n//  fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily\n//  scale using lists with tens of thousands of items without a problem)\n// Usage:\n//   ImGuiListClipper clipper;\n//   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.\n//   while (clipper.Step())\n//       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n//           ImGui::Text(\"line number %d\", i);\n// Generally what happens is:\n// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.\n// - User code submit that one element.\n// - Clipper can measure the height of the first element\n// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.\n// - User code submit visible elements.\n// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.\nstruct ImGuiListClipper\n{\n    ImGuiContext*   Ctx;                // Parent UI context\n    int             DisplayStart;       // First item to display, updated by each call to Step()\n    int             DisplayEnd;         // End of items to display (exclusive)\n    int             ItemsCount;         // [Internal] Number of items\n    float           ItemsHeight;        // [Internal] Height of item after a first step and item submission can calculate it\n    float           StartPosY;          // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed\n    double          StartSeekOffsetY;   // [Internal] Account for frozen rows in a table and initial loss of precision in very large windows.\n    void*           TempData;           // [Internal] Internal data\n\n    // items_count: Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step, and you can call SeekCursorForItem() manually if you need)\n    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().\n    IMGUI_API ImGuiListClipper();\n    IMGUI_API ~ImGuiListClipper();\n    IMGUI_API void  Begin(int items_count, float items_height = -1.0f);\n    IMGUI_API void  End();             // Automatically called on the last call of Step() that returns false.\n    IMGUI_API bool  Step();            // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.\n\n    // Call IncludeItemByIndex() or IncludeItemsByIndex() *BEFORE* first call to Step() if you need a range of items to not be clipped, regardless of their visibility.\n    // (Due to alignment / padding of certain items it is possible that an extra item may be included on either end of the display range).\n    inline void     IncludeItemByIndex(int item_index)                  { IncludeItemsByIndex(item_index, item_index + 1); }\n    IMGUI_API void  IncludeItemsByIndex(int item_begin, int item_end);  // item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.\n\n    // Seek cursor toward given item. This is automatically called while stepping.\n    // - The only reason to call this is: you can use ImGuiListClipper::Begin(INT_MAX) if you don't know item count ahead of time.\n    // - In this case, after all steps are done, you'll want to call SeekCursorForItem(item_count).\n    IMGUI_API void  SeekCursorForItem(int item_index);\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    inline void IncludeRangeByIndices(int item_begin, int item_end)      { IncludeItemsByIndex(item_begin, item_end); } // [renamed in 1.89.9]\n    inline void ForceDisplayRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); } // [renamed in 1.89.6]\n    //inline ImGuiListClipper(int items_count, float items_height = -1.0f) { memset(this, 0, sizeof(*this)); ItemsCount = -1; Begin(items_count, items_height); } // [removed in 1.79]\n#endif\n};\n\n// Helpers: ImVec2/ImVec4 operators\n// - It is important that we are keeping those disabled by default so they don't leak in user space.\n// - This is in order to allow user enabling implicit cast operators between ImVec2/ImVec4 and their own types (using IM_VEC2_CLASS_EXTRA in imconfig.h)\n// - Add '#define IMGUI_DEFINE_MATH_OPERATORS' before including this file (or in imconfig.h) to access courtesy maths operators for ImVec2 and ImVec4.\n// - We intentionally provide ImVec2*float but not float*ImVec2: this is rare enough and we want to reduce the surface for possible user mistake.\n#ifdef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS_IMPLEMENTED\nIM_MSVC_RUNTIME_CHECKS_OFF\nstatic inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }\nstatic inline ImVec2  operator/(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x / rhs, lhs.y / rhs); }\nstatic inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }\nstatic inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }\nstatic inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }\nstatic inline ImVec2  operator/(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x / rhs.x, lhs.y / rhs.y); }\nstatic inline ImVec2  operator-(const ImVec2& lhs)                      { return ImVec2(-lhs.x, -lhs.y); }\nstatic inline ImVec2& operator*=(ImVec2& lhs, const float rhs)          { lhs.x *= rhs; lhs.y *= rhs; return lhs; }\nstatic inline ImVec2& operator/=(ImVec2& lhs, const float rhs)          { lhs.x /= rhs; lhs.y /= rhs; return lhs; }\nstatic inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }\nstatic inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }\nstatic inline ImVec2& operator*=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x *= rhs.x; lhs.y *= rhs.y; return lhs; }\nstatic inline ImVec2& operator/=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x /= rhs.x; lhs.y /= rhs.y; return lhs; }\nstatic inline bool    operator==(const ImVec2& lhs, const ImVec2& rhs)  { return lhs.x == rhs.x && lhs.y == rhs.y; }\nstatic inline bool    operator!=(const ImVec2& lhs, const ImVec2& rhs)  { return lhs.x != rhs.x || lhs.y != rhs.y; }\nstatic inline ImVec4  operator+(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w); }\nstatic inline ImVec4  operator-(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w); }\nstatic inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }\nstatic inline bool    operator==(const ImVec4& lhs, const ImVec4& rhs)  { return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z && lhs.w == rhs.w; }\nstatic inline bool    operator!=(const ImVec4& lhs, const ImVec4& rhs)  { return lhs.x != rhs.x || lhs.y != rhs.y || lhs.z != rhs.z || lhs.w != rhs.w; }\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n#endif\n\n// Helpers macros to generate 32-bit encoded colors\n// - User can declare their own format by #defining the 5 _SHIFT/_MASK macros in their imconfig file.\n// - Any setting other than the default will need custom backend support. The only standard backend that supports anything else than the default is DirectX9.\n#ifndef IM_COL32_R_SHIFT\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\n#define IM_COL32_R_SHIFT    16\n#define IM_COL32_G_SHIFT    8\n#define IM_COL32_B_SHIFT    0\n#define IM_COL32_A_SHIFT    24\n#define IM_COL32_A_MASK     0xFF000000\n#else\n#define IM_COL32_R_SHIFT    0\n#define IM_COL32_G_SHIFT    8\n#define IM_COL32_B_SHIFT    16\n#define IM_COL32_A_SHIFT    24\n#define IM_COL32_A_MASK     0xFF000000\n#endif\n#endif\n#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))\n#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF\n#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black\n#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000\n\n// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)\n// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.\n// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.\n// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.\nstruct ImColor\n{\n    ImVec4          Value;\n\n    constexpr ImColor()                                             { }\n    constexpr ImColor(float r, float g, float b, float a = 1.0f)    : Value(r, g, b, a) { }\n    constexpr ImColor(const ImVec4& col)                            : Value(col) {}\n    constexpr ImColor(int r, int g, int b, int a = 255)             : Value((float)r * (1.0f / 255.0f), (float)g * (1.0f / 255.0f), (float)b * (1.0f / 255.0f), (float)a* (1.0f / 255.0f)) {}\n    constexpr ImColor(ImU32 rgba)                                   : Value((float)((rgba >> IM_COL32_R_SHIFT) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> IM_COL32_G_SHIFT) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> IM_COL32_B_SHIFT) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> IM_COL32_A_SHIFT) & 0xFF) * (1.0f / 255.0f)) {}\n    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }\n    inline operator ImVec4() const                                  { return Value; }\n\n    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.\n    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }\n    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Multi-Select API flags and structures (ImGuiMultiSelectFlags, ImGuiSelectionRequestType, ImGuiSelectionRequest, ImGuiMultiSelectIO, ImGuiSelectionBasicStorage)\n//-----------------------------------------------------------------------------\n\n// Multi-selection system\n// Documentation at: https://github.com/ocornut/imgui/wiki/Multi-Select\n// - Refer to 'Demo->Widgets->Selection State & Multi-Select' for demos using this.\n// - This system implements standard multi-selection idioms (CTRL+Mouse/Keyboard, SHIFT+Mouse/Keyboard, etc)\n//   with support for clipper (skipping non-visible items), box-select and many other details.\n// - Selectable(), Checkbox() are supported but custom widgets may use it as well.\n// - TreeNode() is technically supported but... using this correctly is more complicated: you need some sort of linear/random access to your tree,\n//   which is suited to advanced trees setups also implementing filters and clipper. We will work toward simplifying and demoing it.\n// - In the spirit of Dear ImGui design, your code owns actual selection data.\n//   This is designed to allow all kinds of selection storage you may use in your application e.g. set/map/hash.\n// About ImGuiSelectionBasicStorage:\n// - This is an optional helper to store a selection state and apply selection requests.\n// - It is used by our demos and provided as a convenience to quickly implement multi-selection.\n// Usage:\n// - Identify submitted items with SetNextItemSelectionUserData(), most likely using an index into your current data-set.\n// - Store and maintain actual selection data using persistent object identifiers.\n// - Usage flow:\n//     BEGIN - (1) Call BeginMultiSelect() and retrieve the ImGuiMultiSelectIO* result.\n//           - (2) Honor request list (SetAll/SetRange requests) by updating your selection data. Same code as Step 6.\n//           - (3) [If using clipper] You need to make sure RangeSrcItem is always submitted. Calculate its index and pass to clipper.IncludeItemByIndex(). If storing indices in ImGuiSelectionUserData, a simple clipper.IncludeItemByIndex(ms_io->RangeSrcItem) call will work.\n//     LOOP  - (4) Submit your items with SetNextItemSelectionUserData() + Selectable()/TreeNode() calls.\n//     END   - (5) Call EndMultiSelect() and retrieve the ImGuiMultiSelectIO* result.\n//           - (6) Honor request list (SetAll/SetRange requests) by updating your selection data. Same code as Step 2.\n//     If you submit all items (no clipper), Step 2 and 3 are optional and will be handled by each item themselves. It is fine to always honor those steps.\n// About ImGuiSelectionUserData:\n// - This can store an application-defined identifier (e.g. index or pointer) submitted via SetNextItemSelectionUserData().\n// - In return we store them into RangeSrcItem/RangeFirstItem/RangeLastItem and other fields in ImGuiMultiSelectIO.\n// - Most applications will store an object INDEX, hence the chosen name and type. Storing an index is natural, because\n//   SetRange requests will give you two end-points and you will need to iterate/interpolate between them to update your selection.\n// - However it is perfectly possible to store a POINTER or another IDENTIFIER inside ImGuiSelectionUserData.\n//   Our system never assume that you identify items by indices, it never attempts to interpolate between two values.\n// - If you enable ImGuiMultiSelectFlags_NoRangeSelect then it is guaranteed that you will never have to interpolate\n//   between two ImGuiSelectionUserData, which may be a convenient way to use part of the feature with less code work.\n// - As most users will want to store an index, for convenience and to reduce confusion we use ImS64 instead of void*,\n//   being syntactically easier to downcast. Feel free to reinterpret_cast and store a pointer inside.\n\n// Flags for BeginMultiSelect()\nenum ImGuiMultiSelectFlags_\n{\n    ImGuiMultiSelectFlags_None                  = 0,\n    ImGuiMultiSelectFlags_SingleSelect          = 1 << 0,   // Disable selecting more than one item. This is available to allow single-selection code to share same code/logic if desired. It essentially disables the main purpose of BeginMultiSelect() tho!\n    ImGuiMultiSelectFlags_NoSelectAll           = 1 << 1,   // Disable CTRL+A shortcut to select all.\n    ImGuiMultiSelectFlags_NoRangeSelect         = 1 << 2,   // Disable Shift+selection mouse/keyboard support (useful for unordered 2D selection). With BoxSelect is also ensure contiguous SetRange requests are not combined into one. This allows not handling interpolation in SetRange requests.\n    ImGuiMultiSelectFlags_NoAutoSelect          = 1 << 3,   // Disable selecting items when navigating (useful for e.g. supporting range-select in a list of checkboxes).\n    ImGuiMultiSelectFlags_NoAutoClear           = 1 << 4,   // Disable clearing selection when navigating or selecting another one (generally used with ImGuiMultiSelectFlags_NoAutoSelect. useful for e.g. supporting range-select in a list of checkboxes).\n    ImGuiMultiSelectFlags_NoAutoClearOnReselect = 1 << 5,   // Disable clearing selection when clicking/selecting an already selected item.\n    ImGuiMultiSelectFlags_BoxSelect1d           = 1 << 6,   // Enable box-selection with same width and same x pos items (e.g. full row Selectable()). Box-selection works better with little bit of spacing between items hit-box in order to be able to aim at empty space.\n    ImGuiMultiSelectFlags_BoxSelect2d           = 1 << 7,   // Enable box-selection with varying width or varying x pos items support (e.g. different width labels, or 2D layout/grid). This is slower: alters clipping logic so that e.g. horizontal movements will update selection of normally clipped items.\n    ImGuiMultiSelectFlags_BoxSelectNoScroll     = 1 << 8,   // Disable scrolling when box-selecting near edges of scope.\n    ImGuiMultiSelectFlags_ClearOnEscape         = 1 << 9,   // Clear selection when pressing Escape while scope is focused.\n    ImGuiMultiSelectFlags_ClearOnClickVoid      = 1 << 10,  // Clear selection when clicking on empty location within scope.\n    ImGuiMultiSelectFlags_ScopeWindow           = 1 << 11,  // Scope for _BoxSelect and _ClearOnClickVoid is whole window (Default). Use if BeginMultiSelect() covers a whole window or used a single time in same window.\n    ImGuiMultiSelectFlags_ScopeRect             = 1 << 12,  // Scope for _BoxSelect and _ClearOnClickVoid is rectangle encompassing BeginMultiSelect()/EndMultiSelect(). Use if BeginMultiSelect() is called multiple times in same window.\n    ImGuiMultiSelectFlags_SelectOnClick         = 1 << 13,  // Apply selection on mouse down when clicking on unselected item. (Default)\n    ImGuiMultiSelectFlags_SelectOnClickRelease  = 1 << 14,  // Apply selection on mouse release when clicking an unselected item. Allow dragging an unselected item without altering selection.\n    //ImGuiMultiSelectFlags_RangeSelect2d       = 1 << 15,  // Shift+Selection uses 2d geometry instead of linear sequence, so possible to use Shift+up/down to select vertically in grid. Analogous to what BoxSelect does.\n    ImGuiMultiSelectFlags_NavWrapX              = 1 << 16,  // [Temporary] Enable navigation wrapping on X axis. Provided as a convenience because we don't have a design for the general Nav API for this yet. When the more general feature be public we may obsolete this flag in favor of new one.\n};\n\n// Main IO structure returned by BeginMultiSelect()/EndMultiSelect().\n// This mainly contains a list of selection requests.\n// - Use 'Demo->Tools->Debug Log->Selection' to see requests as they happen.\n// - Some fields are only useful if your list is dynamic and allows deletion (getting post-deletion focus/state right is shown in the demo)\n// - Below: who reads/writes each fields? 'r'=read, 'w'=write, 'ms'=multi-select code, 'app'=application/user code.\nstruct ImGuiMultiSelectIO\n{\n    //------------------------------------------// BeginMultiSelect / EndMultiSelect\n    ImVector<ImGuiSelectionRequest> Requests;   //  ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.\n    ImGuiSelectionUserData      RangeSrcItem;   //  ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.\n    ImGuiSelectionUserData      NavIdItem;      //  ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).\n    bool                        NavIdSelected;  //  ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).\n    bool                        RangeSrcReset;  //        app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).\n    int                         ItemsCount;     //  ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.\n};\n\n// Selection request type\nenum ImGuiSelectionRequestType\n{\n    ImGuiSelectionRequestType_None = 0,\n    ImGuiSelectionRequestType_SetAll,           // Request app to clear selection (if Selected==false) or select all items (if Selected==true). We cannot set RangeFirstItem/RangeLastItem as its contents is entirely up to user (not necessarily an index)\n    ImGuiSelectionRequestType_SetRange,         // Request app to select/unselect [RangeFirstItem..RangeLastItem] items (inclusive) based on value of Selected. Only EndMultiSelect() request this, app code can read after BeginMultiSelect() and it will always be false.\n};\n\n// Selection request item\nstruct ImGuiSelectionRequest\n{\n    //------------------------------------------// BeginMultiSelect / EndMultiSelect\n    ImGuiSelectionRequestType   Type;           //  ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.\n    bool                        Selected;       //  ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (true = select, false = unselect)\n    ImS8                        RangeDirection; //                  /  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.\n    ImGuiSelectionUserData      RangeFirstItem; //                  /  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).\n    ImGuiSelectionUserData      RangeLastItem;  //                  /  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!\n};\n\n// Optional helper to store multi-selection state + apply multi-selection requests.\n// - Used by our demos and provided as a convenience to easily implement basic multi-selection.\n// - Iterate selection with 'void* it = NULL; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'\n//   Or you can check 'if (Contains(id)) { ... }' for each possible object if their number is not too high to iterate.\n// - USING THIS IS NOT MANDATORY. This is only a helper and not a required API.\n// To store a multi-selection, in your application you could:\n// - Use this helper as a convenience. We use our simple key->value ImGuiStorage as a std::set<ImGuiID> replacement.\n// - Use your own external storage: e.g. std::set<MyObjectId>, std::vector<MyObjectId>, interval trees, intrusively stored selection etc.\n// In ImGuiSelectionBasicStorage we:\n// - always use indices in the multi-selection API (passed to SetNextItemSelectionUserData(), retrieved in ImGuiMultiSelectIO)\n// - use the AdapterIndexToStorageId() indirection layer to abstract how persistent selection data is derived from an index.\n// - use decently optimized logic to allow queries and insertion of very large selection sets.\n// - do not preserve selection order.\n// Many combinations are possible depending on how you prefer to store your items and how you prefer to store your selection.\n// Large applications are likely to eventually want to get rid of this indirection layer and do their own thing.\n// See https://github.com/ocornut/imgui/wiki/Multi-Select for details and pseudo-code using this helper.\nstruct ImGuiSelectionBasicStorage\n{\n    // Members\n    int             Size;           //          // Number of selected items, maintained by this helper.\n    bool            PreserveOrder;  // = false  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)\n    void*           UserData;       // = NULL   // User data for use by adapter function        // e.g. selection.UserData = (void*)my_items;\n    ImGuiID         (*AdapterIndexToStorageId)(ImGuiSelectionBasicStorage* self, int idx);      // e.g. selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { return ((MyItems**)self->UserData)[idx]->ID; };\n    int             _SelectionOrder;// [Internal] Increasing counter to store selection order\n    ImGuiStorage    _Storage;       // [Internal] Selection set. Think of this as similar to e.g. std::set<ImGuiID>. Prefer not accessing directly: iterate with GetNextSelectedItem().\n\n    // Methods\n    IMGUI_API ImGuiSelectionBasicStorage();\n    IMGUI_API void  ApplyRequests(ImGuiMultiSelectIO* ms_io);   // Apply selection requests coming from BeginMultiSelect() and EndMultiSelect() functions. It uses 'items_count' passed to BeginMultiSelect()\n    IMGUI_API bool  Contains(ImGuiID id) const;                 // Query if an item id is in selection.\n    IMGUI_API void  Clear();                                    // Clear selection\n    IMGUI_API void  Swap(ImGuiSelectionBasicStorage& r);        // Swap two selections\n    IMGUI_API void  SetItemSelected(ImGuiID id, bool selected); // Add/remove an item from selection (generally done by ApplyRequests() function)\n    IMGUI_API bool  GetNextSelectedItem(void** opaque_it, ImGuiID* out_id); // Iterate selection with 'void* it = NULL; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'\n    inline ImGuiID  GetStorageIdFromIndex(int idx)              { return AdapterIndexToStorageId(this, idx); }  // Convert index to item id based on provided adapter.\n};\n\n// Optional helper to apply multi-selection requests to existing randomly accessible storage.\n// Convenient if you want to quickly wire multi-select API on e.g. an array of bool or items storing their own selection state.\nstruct ImGuiSelectionExternalStorage\n{\n    // Members\n    void*           UserData;       // User data for use by adapter function                                // e.g. selection.UserData = (void*)my_items;\n    void            (*AdapterSetItemSelected)(ImGuiSelectionExternalStorage* self, int idx, bool selected); // e.g. AdapterSetItemSelected = [](ImGuiSelectionExternalStorage* self, int idx, bool selected) { ((MyItems**)self->UserData)[idx]->Selected = selected; }\n\n    // Methods\n    IMGUI_API ImGuiSelectionExternalStorage();\n    IMGUI_API void  ApplyRequests(ImGuiMultiSelectIO* ms_io);   // Apply selection requests by using AdapterSetItemSelected() calls\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Drawing API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)\n// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.\n//-----------------------------------------------------------------------------\n\n// The maximum line width to bake anti-aliased textures for. Build atlas with ImFontAtlasFlags_NoBakedLines to disable baking.\n#ifndef IM_DRAWLIST_TEX_LINES_WIDTH_MAX\n#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)\n#endif\n\n// ImDrawCallback: Draw callbacks for advanced uses [configurable type: override in imconfig.h]\n// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,\n// you can poke into the draw list for that! Draw callback may be useful for example to:\n//  A) Change your GPU render state,\n//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.\n// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'\n// If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering backend accordingly.\n#ifndef ImDrawCallback\ntypedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);\n#endif\n\n// Special Draw callback value to request renderer backend to reset the graphics/render state.\n// The renderer backend needs to handle this special value, otherwise it will crash trying to call a function at this address.\n// This is useful, for example, if you submitted callbacks which you know have altered the render state and you want it to be restored.\n// Render state is not reset by default because they are many perfectly useful way of altering render state (e.g. changing shader/blending settings before an Image call).\n#define ImDrawCallback_ResetRenderState     (ImDrawCallback)(-8)\n\n// Typically, 1 command = 1 GPU draw call (unless command is a callback)\n// - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,\n//   this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.\n//   Backends made for <1.71. will typically ignore the VtxOffset fields.\n// - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).\nstruct ImDrawCmd\n{\n    ImVec4          ClipRect;           // 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in \"viewport\" coordinates\n    ImTextureID     TextureId;          // 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.\n    unsigned int    VtxOffset;          // 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.\n    unsigned int    IdxOffset;          // 4    // Start offset in index buffer.\n    unsigned int    ElemCount;          // 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].\n    ImDrawCallback  UserCallback;       // 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.\n    void*           UserCallbackData;   // 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.\n    int             UserCallbackDataSize;  // 4 // Size of callback user data when using storage, otherwise 0.\n    int             UserCallbackDataOffset;// 4 // [Internal] Offset of callback user data when using storage, otherwise -1.\n\n    ImDrawCmd()     { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed\n\n    // Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)\n    inline ImTextureID GetTexID() const { return TextureId; }\n};\n\n// Vertex layout\n#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT\nstruct ImDrawVert\n{\n    ImVec2  pos;\n    ImVec2  uv;\n    ImU32   col;\n};\n#else\n// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h\n// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.\n// The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared at the time you'd want to set your type up.\n// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.\nIMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;\n#endif\n\n// [Internal] For use by ImDrawList\nstruct ImDrawCmdHeader\n{\n    ImVec4          ClipRect;\n    ImTextureID     TextureId;\n    unsigned int    VtxOffset;\n};\n\n// [Internal] For use by ImDrawListSplitter\nstruct ImDrawChannel\n{\n    ImVector<ImDrawCmd>         _CmdBuffer;\n    ImVector<ImDrawIdx>         _IdxBuffer;\n};\n\n\n// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.\n// This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.\nstruct ImDrawListSplitter\n{\n    int                         _Current;    // Current channel number (0)\n    int                         _Count;      // Number of active channels (1+)\n    ImVector<ImDrawChannel>     _Channels;   // Draw channels (not resized down so _Count might be < Channels.Size)\n\n    inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }\n    inline ~ImDrawListSplitter() { ClearFreeMemory(); }\n    inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame\n    IMGUI_API void              ClearFreeMemory();\n    IMGUI_API void              Split(ImDrawList* draw_list, int count);\n    IMGUI_API void              Merge(ImDrawList* draw_list);\n    IMGUI_API void              SetCurrentChannel(ImDrawList* draw_list, int channel_idx);\n};\n\n// Flags for ImDrawList functions\n// (Legacy: bit 0 must always correspond to ImDrawFlags_Closed to be backward compatible with old API using a bool. Bits 1..3 must be unused)\nenum ImDrawFlags_\n{\n    ImDrawFlags_None                        = 0,\n    ImDrawFlags_Closed                      = 1 << 0, // PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)\n    ImDrawFlags_RoundCornersTopLeft         = 1 << 4, // AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.\n    ImDrawFlags_RoundCornersTopRight        = 1 << 5, // AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.\n    ImDrawFlags_RoundCornersBottomLeft      = 1 << 6, // AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.\n    ImDrawFlags_RoundCornersBottomRight     = 1 << 7, // AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.\n    ImDrawFlags_RoundCornersNone            = 1 << 8, // AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!\n    ImDrawFlags_RoundCornersTop             = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,\n    ImDrawFlags_RoundCornersBottom          = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,\n    ImDrawFlags_RoundCornersLeft            = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,\n    ImDrawFlags_RoundCornersRight           = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,\n    ImDrawFlags_RoundCornersAll             = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,\n    ImDrawFlags_RoundCornersDefault_        = ImDrawFlags_RoundCornersAll, // Default to ALL corners if none of the _RoundCornersXX flags are specified.\n    ImDrawFlags_RoundCornersMask_           = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone,\n};\n\n// Flags for ImDrawList instance. Those are set automatically by ImGui:: functions from ImGuiIO settings, and generally not manipulated directly.\n// It is however possible to temporarily alter flags between calls to ImDrawList:: functions.\nenum ImDrawListFlags_\n{\n    ImDrawListFlags_None                    = 0,\n    ImDrawListFlags_AntiAliasedLines        = 1 << 0,  // Enable anti-aliased lines/borders (*2 the number of triangles for 1.0f wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)\n    ImDrawListFlags_AntiAliasedLinesUseTex  = 1 << 1,  // Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).\n    ImDrawListFlags_AntiAliasedFill         = 1 << 2,  // Enable anti-aliased edge around filled shapes (rounded rectangles, circles).\n    ImDrawListFlags_AllowVtxOffset          = 1 << 3,  // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.\n};\n\n// Draw command list\n// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,\n// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.\n// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to\n// access the current window draw list and draw custom primitives.\n// You can interleave normal ImGui:: calls and adding primitives to the current draw list.\n// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).\n// You are totally free to apply whatever transformation matrix you want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)\n// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.\nstruct ImDrawList\n{\n    // This is what you have to render\n    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.\n    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those\n    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.\n    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.\n\n    // [Internal, used while building lists]\n    unsigned int            _VtxCurrentIdx;     // [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.\n    ImDrawListSharedData*   _Data;              // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)\n    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\n    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\n    ImVector<ImVec2>        _Path;              // [Internal] current path building\n    ImDrawCmdHeader         _CmdHeader;         // [Internal] template of active commands. Fields should match those of CmdBuffer.back().\n    ImDrawListSplitter      _Splitter;          // [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)\n    ImVector<ImVec4>        _ClipRectStack;     // [Internal]\n    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]\n    ImVector<ImU8>          _CallbacksDataBuf;  // [Internal]\n    float                   _FringeScale;       // [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content\n    const char*             _OwnerName;         // Pointer to owner window's name for debugging\n\n    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData().\n    // (advanced: you may create and use your own ImDrawListSharedData so you can use ImDrawList without ImGui, but that's more involved)\n    IMGUI_API ImDrawList(ImDrawListSharedData* shared_data);\n    IMGUI_API ~ImDrawList();\n\n    IMGUI_API void  PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\n    IMGUI_API void  PushClipRectFullScreen();\n    IMGUI_API void  PopClipRect();\n    IMGUI_API void  PushTextureID(ImTextureID texture_id);\n    IMGUI_API void  PopTextureID();\n    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }\n    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }\n\n    // Primitives\n    // - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have \"inward\" anti-aliasing.\n    // - For rectangular primitives, \"p_min\" and \"p_max\" represent the upper-left and lower-right corners.\n    // - For circle primitives, use \"num_segments == 0\" to automatically calculate tessellation (preferred).\n    //   In older versions (until Dear ImGui 1.77) the AddCircle functions defaulted to num_segments == 12.\n    //   In future versions we will use textures to provide cheaper and higher-quality circles.\n    //   Use AddNgon() and AddNgonFilled() functions if you need to guarantee a specific number of sides.\n    IMGUI_API void  AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness = 1.0f);\n    IMGUI_API void  AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0, float thickness = 1.0f);   // a: upper-left, b: lower-right (== upper-left + size)\n    IMGUI_API void  AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0);                     // a: upper-left, b: lower-right (== upper-left + size)\n    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);\n    IMGUI_API void  AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness = 1.0f);\n    IMGUI_API void  AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col);\n    IMGUI_API void  AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness = 1.0f);\n    IMGUI_API void  AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col);\n    IMGUI_API void  AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments = 0, float thickness = 1.0f);\n    IMGUI_API void  AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments = 0);\n    IMGUI_API void  AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);\n    IMGUI_API void  AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);\n    IMGUI_API void  AddEllipse(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f);\n    IMGUI_API void  AddEllipseFilled(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot = 0.0f, int num_segments = 0);\n    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);\n    IMGUI_API void  AddText(ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);\n    IMGUI_API void  AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0); // Cubic Bezier (4 control points)\n    IMGUI_API void  AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);               // Quadratic Bezier (3 control points)\n\n    // General polygon\n    // - Only simple polygons are supported by filling functions (no self-intersections, no holes).\n    // - Concave polygon fill is more expensive than convex one: it has O(N^2) complexity. Provided as a convenience fo user but not used by main library.\n    IMGUI_API void  AddPolyline(const ImVec2* points, int num_points, ImU32 col, ImDrawFlags flags, float thickness);\n    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col);\n    IMGUI_API void  AddConcavePolyFilled(const ImVec2* points, int num_points, ImU32 col);\n\n    // Image primitives\n    // - Read FAQ to understand what ImTextureID is.\n    // - \"p_min\" and \"p_max\" represent the upper-left and lower-right corners of the rectangle.\n    // - \"uv_min\" and \"uv_max\" represent the normalized texture coordinates to use for those corners. Using (0,0)->(1,1) texture coordinates will generally display the entire texture.\n    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2(0, 0), const ImVec2& uv_max = ImVec2(1, 1), ImU32 col = IM_COL32_WHITE);\n    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2(0, 0), const ImVec2& uv2 = ImVec2(1, 0), const ImVec2& uv3 = ImVec2(1, 1), const ImVec2& uv4 = ImVec2(0, 1), ImU32 col = IM_COL32_WHITE);\n    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags = 0);\n\n    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()\n    // - Important: filled shapes must always use clockwise winding order! The anti-aliasing fringe depends on it. Counter-clockwise shapes will have \"inward\" anti-aliasing.\n    //   so e.g. 'PathArcTo(center, radius, PI * -0.5f, PI)' is ok, whereas 'PathArcTo(center, radius, PI, PI * -0.5f)' won't have correct anti-aliasing when followed by PathFillConvex().\n    inline    void  PathClear()                                                 { _Path.Size = 0; }\n    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }\n    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }\n    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }\n    inline    void  PathFillConcave(ImU32 col)                                  { AddConcavePolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }\n    inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }\n    IMGUI_API void  PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 0);\n    IMGUI_API void  PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12);                // Use precomputed angles for a 12 steps circle\n    IMGUI_API void  PathEllipticalArcTo(const ImVec2& center, const ImVec2& radius, float rot, float a_min, float a_max, int num_segments = 0); // Ellipse\n    IMGUI_API void  PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0); // Cubic Bezier (4 control points)\n    IMGUI_API void  PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);               // Quadratic Bezier (3 control points)\n    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawFlags flags = 0);\n\n    // Advanced: Draw Callbacks\n    // - May be used to alter render state (change sampler, blending, current shader). May be used to emit custom rendering commands (difficult to do correctly, but possible).\n    // - Use special ImDrawCallback_ResetRenderState callback to instruct backend to reset its render state to the default.\n    // - Your rendering loop must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles. All standard backends are honoring this.\n    // - For some backends, the callback may access selected render-states exposed by the backend in a ImGui_ImplXXXX_RenderState structure pointed to by platform_io.Renderer_RenderState.\n    // - IMPORTANT: please be mindful of the different level of indirection between using size==0 (copying argument) and using size>0 (copying pointed data into a buffer).\n    //   - If userdata_size == 0: we copy/store the 'userdata' argument as-is. It will be available unmodified in ImDrawCmd::UserCallbackData during render.\n    //   - If userdata_size > 0,  we copy/store 'userdata_size' bytes pointed to by 'userdata'. We store them in a buffer stored inside the drawlist. ImDrawCmd::UserCallbackData will point inside that buffer so you have to retrieve data from there. Your callback may need to use ImDrawCmd::UserCallbackDataSize if you expect dynamically-sized data.\n    //   - Support for userdata_size > 0 was added in v1.91.4, October 2024. So earlier code always only allowed to copy/store a simple void*.\n    IMGUI_API void  AddCallback(ImDrawCallback callback, void* userdata, size_t userdata_size = 0);\n\n    // Advanced: Miscellaneous\n    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible\n    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.\n\n    // Advanced: Channels\n    // - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)\n    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)\n    // - This API shouldn't have been in ImDrawList in the first place!\n    //   Prefer using your own persistent instance of ImDrawListSplitter as you can stack them.\n    //   Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.\n    inline void     ChannelsSplit(int count)    { _Splitter.Split(this, count); }\n    inline void     ChannelsMerge()             { _Splitter.Merge(this); }\n    inline void     ChannelsSetCurrent(int n)   { _Splitter.SetCurrentChannel(this, n); }\n\n    // Advanced: Primitives allocations\n    // - We render triangles (three vertices)\n    // - All primitives needs to be reserved via PrimReserve() beforehand.\n    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);\n    IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);\n    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)\n    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);\n    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);\n    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }\n    inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }\n    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)         { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); } // Write vertex with unique index\n\n    // Obsolete names\n    //inline  void  AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { AddEllipse(center, ImVec2(radius_x, radius_y), col, rot, num_segments, thickness); } // OBSOLETED in 1.90.5 (Mar 2024)\n    //inline  void  AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { AddEllipseFilled(center, ImVec2(radius_x, radius_y), col, rot, num_segments); }                        // OBSOLETED in 1.90.5 (Mar 2024)\n    //inline  void  PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { PathEllipticalArcTo(center, ImVec2(radius_x, radius_y), rot, a_min, a_max, num_segments); } // OBSOLETED in 1.90.5 (Mar 2024)\n    //inline  void  AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); }                         // OBSOLETED in 1.80 (Jan 2021)\n    //inline  void  PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); }                                                                                // OBSOLETED in 1.80 (Jan 2021)\n\n    // [Internal helpers]\n    IMGUI_API void  _ResetForNewFrame();\n    IMGUI_API void  _ClearFreeMemory();\n    IMGUI_API void  _PopUnusedDrawCmd();\n    IMGUI_API void  _TryMergeDrawCmds();\n    IMGUI_API void  _OnChangedClipRect();\n    IMGUI_API void  _OnChangedTextureID();\n    IMGUI_API void  _OnChangedVtxOffset();\n    IMGUI_API void  _SetTextureID(ImTextureID texture_id);\n    IMGUI_API int   _CalcCircleAutoSegmentCount(float radius) const;\n    IMGUI_API void  _PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step);\n    IMGUI_API void  _PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments);\n};\n\n// All draw data to render a Dear ImGui frame\n// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,\n// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)\nstruct ImDrawData\n{\n    bool                Valid;              // Only valid after Render() is called and before the next NewFrame() is called.\n    int                 CmdListsCount;      // Number of ImDrawList* to render (should always be == CmdLists.size)\n    int                 TotalIdxCount;      // For convenience, sum of all ImDrawList's IdxBuffer.Size\n    int                 TotalVtxCount;      // For convenience, sum of all ImDrawList's VtxBuffer.Size\n    ImVector<ImDrawList*> CmdLists;         // Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.\n    ImVec2              DisplayPos;         // Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)\n    ImVec2              DisplaySize;        // Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)\n    ImVec2              FramebufferScale;   // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.\n    ImGuiViewport*      OwnerViewport;      // Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).\n\n    // Functions\n    ImDrawData()    { Clear(); }\n    IMGUI_API void  Clear();\n    IMGUI_API void  AddDrawList(ImDrawList* draw_list);     // Helper to add an external draw list into an existing ImDrawData.\n    IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\n    IMGUI_API void  ScaleClipRects(const ImVec2& fb_scale); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)\n//-----------------------------------------------------------------------------\n\nstruct ImFontConfig\n{\n    void*           FontData;               //          // TTF/OTF data\n    int             FontDataSize;           //          // TTF/OTF data size\n    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).\n    int             FontNo;                 // 0        // Index of font within TTF/OTF file\n    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).\n    int             OversampleH;            // 2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.\n    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.\n    bool            PixelSnapH;             // false    // Align every glyph AdvanceX to pixel boundaries. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.\n    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs when rendered: essentially add to glyph->AdvanceX. Only X axis is supported for now.\n    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.\n    const ImWchar*  GlyphRanges;            // NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).\n    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font\n    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs\n    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.\n    unsigned int    FontBuilderFlags;       // 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.\n    float           RasterizerMultiply;     // 1.0f     // Linearly brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.\n    float           RasterizerDensity;      // 1.0f     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.\n    ImWchar         EllipsisChar;           // 0        // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.\n\n    // [Internal]\n    char            Name[40];               // Name (strictly to ease debugging)\n    ImFont*         DstFont;\n\n    IMGUI_API ImFontConfig();\n};\n\n// Hold rendering data for one glyph.\n// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)\nstruct ImFontGlyph\n{\n    unsigned int    Colored : 1;        // Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)\n    unsigned int    Visible : 1;        // Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.\n    unsigned int    Codepoint : 30;     // 0x0000..0x10FFFF\n    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)\n    float           X0, Y0, X1, Y1;     // Glyph corners\n    float           U0, V0, U1, V1;     // Texture coordinates\n};\n\n// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().\n// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.\nstruct ImFontGlyphRangesBuilder\n{\n    ImVector<ImU32> UsedChars;            // Store 1-bit per Unicode code point (0=unused, 1=used)\n\n    ImFontGlyphRangesBuilder()              { Clear(); }\n    inline void     Clear()                 { int size_in_bytes = (IM_UNICODE_CODEPOINT_MAX + 1) / 8; UsedChars.resize(size_in_bytes / (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }\n    inline bool     GetBit(size_t n) const  { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array\n    inline void     SetBit(size_t n)        { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array\n    inline void     AddChar(ImWchar c)      { SetBit(c); }                      // Add character\n    IMGUI_API void  AddText(const char* text, const char* text_end = NULL);     // Add string (each character of the UTF-8 string are added)\n    IMGUI_API void  AddRanges(const ImWchar* ranges);                           // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext\n    IMGUI_API void  BuildRanges(ImVector<ImWchar>* out_ranges);                 // Output new ranges\n};\n\n// See ImFontAtlas::AddCustomRectXXX functions.\nstruct ImFontAtlasCustomRect\n{\n    unsigned short  X, Y;           // Output   // Packed position in Atlas\n\n    // [Internal]\n    unsigned short  Width, Height;  // Input    // Desired rectangle dimension\n    unsigned int    GlyphID : 31;   // Input    // For custom font glyphs only (ID < 0x110000)\n    unsigned int    GlyphColored : 1; // Input  // For custom font glyphs only: glyph is colored, removed tinting.\n    float           GlyphAdvanceX;  // Input    // For custom font glyphs only: glyph xadvance\n    ImVec2          GlyphOffset;    // Input    // For custom font glyphs only: glyph display offset\n    ImFont*         Font;           // Input    // For custom font glyphs only: target font\n    ImFontAtlasCustomRect()         { X = Y = 0xFFFF; Width = Height = 0; GlyphID = 0; GlyphColored = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }\n    bool IsPacked() const           { return X != 0xFFFF; }\n};\n\n// Flags for ImFontAtlas build\nenum ImFontAtlasFlags_\n{\n    ImFontAtlasFlags_None               = 0,\n    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two\n    ImFontAtlasFlags_NoMouseCursors     = 1 << 1,   // Don't build software mouse cursors into the atlas (save a little texture memory)\n    ImFontAtlasFlags_NoBakedLines       = 1 << 2,   // Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).\n};\n\n// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:\n//  - One or more fonts.\n//  - Custom graphics data needed to render the shapes needed by Dear ImGui.\n//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).\n// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.\n//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.\n//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\n//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)\n//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.\n//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.\n// Common pitfalls:\n// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the\n//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.\n// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.\n//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,\n// - Even though many functions are suffixed with \"TTF\", OTF data is supported just as well.\n// - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!\nstruct ImFontAtlas\n{\n    IMGUI_API ImFontAtlas();\n    IMGUI_API ~ImFontAtlas();\n    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);\n    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);\n    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);\n    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_data_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.\n    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.\n    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.\n    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).\n    IMGUI_API void              Clear();                    // Clear all input and output.\n\n    // Build atlas, retrieve pixel data.\n    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().\n    // The pitch is always = Width * BytesPerPixels (1 or 4)\n    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into\n    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.\n    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.\n    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel\n    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel\n    bool                        IsBuilt() const             { return Fonts.Size > 0 && TexReady; } // Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...\n    void                        SetTexID(ImTextureID id)    { TexID = id; }\n\n    //-------------------------------------------\n    // Glyph Ranges\n    //-------------------------------------------\n\n    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)\n    // NB: Make sure that your string are UTF-8 and NOT in your local code page.\n    // Read https://github.com/ocornut/imgui/blob/master/docs/FONTS.md/#about-utf-8-encoding for details.\n    // NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.\n    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin\n    IMGUI_API const ImWchar*    GetGlyphRangesGreek();                  // Default + Greek and Coptic\n    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters\n    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs\n    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs\n    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese\n    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters\n    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters\n    IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();             // Default + Vietnamese characters\n\n    //-------------------------------------------\n    // [BETA] Custom Rectangles/Glyphs API\n    //-------------------------------------------\n\n    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes.\n    // - After calling Build(), you can query the rectangle position and render your pixels.\n    // - If you render colored output, set 'atlas->TexPixelsUseColors = true' as this may help some backends decide of preferred texture format.\n    // - You can also request your rectangles to be mapped as font glyph (given a font + Unicode point),\n    //   so you can render e.g. custom colorful icons and use them as regular glyphs.\n    // - Read docs/FONTS.md for more details about using colorful icons.\n    // - Note: this API may be redesigned later in order to support multi-monitor varying DPI settings.\n    IMGUI_API int               AddCustomRectRegular(int width, int height);\n    IMGUI_API int               AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0, 0));\n    ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }\n\n    // [Internal]\n    IMGUI_API void              CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const;\n    IMGUI_API bool              GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);\n\n    //-------------------------------------------\n    // Members\n    //-------------------------------------------\n\n    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)\n    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.\n    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.\n    int                         TexGlyphPadding;    // FIXME: Should be called \"TexPackPadding\". Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).\n    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.\n    void*                       UserData;           // Store your own atlas related user-data (if e.g. you have multiple font atlas).\n\n    // [Internal]\n    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.\n    bool                        TexReady;           // Set when texture was built matching current font input\n    bool                        TexPixelsUseColors; // Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.\n    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight\n    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4\n    int                         TexWidth;           // Texture width calculated during Build().\n    int                         TexHeight;          // Texture height calculated during Build().\n    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)\n    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel\n    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.\n    ImVector<ImFontAtlasCustomRect> CustomRects;    // Rectangles for packing custom texture data into the atlas.\n    ImVector<ImFontConfig>      ConfigData;         // Configuration data\n    ImVec4                      TexUvLines[IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1];  // UVs for baked anti-aliased lines\n\n    // [Internal] Font builder\n    const ImFontBuilderIO*      FontBuilderIO;      // Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).\n    unsigned int                FontBuilderFlags;   // Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.\n\n    // [Internal] Packing data\n    int                         PackIdMouseCursors; // Custom texture rectangle ID for white pixel and mouse cursors\n    int                         PackIdLines;        // Custom texture rectangle ID for baked anti-aliased lines\n\n    // [Obsolete]\n    //typedef ImFontAtlasCustomRect    CustomRect;         // OBSOLETED in 1.72+\n    //typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETED in 1.67+\n};\n\n// Font runtime data and rendering\n// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().\nstruct ImFont\n{\n    // [Internal] Members: Hot ~20/24 bytes (for CalcTextSize)\n    ImVector<float>             IndexAdvanceX;      // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).\n    float                       FallbackAdvanceX;   // 4     // out // = FallbackGlyph->AdvanceX\n    float                       FontSize;           // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)\n\n    // [Internal] Members: Hot ~28/40 bytes (for RenderText loop)\n    ImVector<ImWchar>           IndexLookup;        // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.\n    ImVector<ImFontGlyph>       Glyphs;             // 12-16 // out //            // All glyphs.\n    const ImFontGlyph*          FallbackGlyph;      // 4-8   // out // = FindGlyph(FontFallbackChar)\n\n    // [Internal] Members: Cold ~32/40 bytes\n    // Conceptually ConfigData[] is the list of font sources merged to create this font.\n    ImFontAtlas*                ContainerAtlas;     // 4-8   // out //            // What we has been loaded into\n    const ImFontConfig*         ConfigData;         // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData to ConfigDataCount instances\n    short                       ConfigDataCount;    // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.\n    short                       EllipsisCharCount;  // 1     // out // 1 or 3\n    ImWchar                     EllipsisChar;       // 2-4   // out // = '...'/'.'// Character used for ellipsis rendering.\n    ImWchar                     FallbackChar;       // 2-4   // out // = FFFD/'?' // Character used if a glyph isn't found.\n    float                       EllipsisWidth;      // 4     // out               // Width\n    float                       EllipsisCharStep;   // 4     // out               // Step between characters when EllipsisCount > 0\n    bool                        DirtyLookupTables;  // 1     // out //\n    float                       Scale;              // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()\n    float                       Ascent, Descent;    // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)\n    int                         MetricsTotalSurface;// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)\n    ImU8                        Used4kPagesMap[(IM_UNICODE_CODEPOINT_MAX+1)/4096/8]; // 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.\n\n    // Methods\n    IMGUI_API ImFont();\n    IMGUI_API ~ImFont();\n    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c);\n    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c);\n    float                       GetCharAdvance(ImWchar c)           { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }\n    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }\n    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : \"<unknown>\"; }\n\n    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.\n    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.\n    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL); // utf8\n    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width);\n    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c);\n    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false);\n\n    // [Internal] Don't use!\n    IMGUI_API void              BuildLookupTable();\n    IMGUI_API void              ClearOutputData();\n    IMGUI_API void              GrowIndex(int new_size);\n    IMGUI_API void              AddGlyph(const ImFontConfig* src_cfg, ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);\n    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.\n    IMGUI_API void              SetGlyphVisible(ImWchar c, bool visible);\n    IMGUI_API bool              IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Viewports\n//-----------------------------------------------------------------------------\n\n// Flags stored in ImGuiViewport::Flags, giving indications to the platform backends.\nenum ImGuiViewportFlags_\n{\n    ImGuiViewportFlags_None                     = 0,\n    ImGuiViewportFlags_IsPlatformWindow         = 1 << 0,   // Represent a Platform Window\n    ImGuiViewportFlags_IsPlatformMonitor        = 1 << 1,   // Represent a Platform Monitor (unused yet)\n    ImGuiViewportFlags_OwnedByApp               = 1 << 2,   // Platform Window: Is created/managed by the application (rather than a dear imgui backend)\n};\n\n// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.\n// - In 'docking' branch with multi-viewport enabled, we extend this concept to have multiple active viewports.\n// - In the future we will extend this concept further to also represent Platform Monitor and support a \"no main platform window\" operation mode.\n// - About Main Area vs Work Area:\n//   - Main Area = entire viewport.\n//   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).\n//   - Windows are generally trying to stay within the Work Area of their host viewport.\nstruct ImGuiViewport\n{\n    ImGuiID             ID;                     // Unique identifier for the viewport\n    ImGuiViewportFlags  Flags;                  // See ImGuiViewportFlags_\n    ImVec2              Pos;                    // Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)\n    ImVec2              Size;                   // Main Area: Size of the viewport.\n    ImVec2              WorkPos;                // Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)\n    ImVec2              WorkSize;               // Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)\n\n    // Platform/Backend Dependent Data\n    void*               PlatformHandle;         // void* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*)\n    void*               PlatformHandleRaw;      // void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms)\n\n    ImGuiViewport()     { memset(this, 0, sizeof(*this)); }\n\n    // Helpers\n    ImVec2              GetCenter() const       { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }\n    ImVec2              GetWorkCenter() const   { return ImVec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Platform Dependent Interfaces\n//-----------------------------------------------------------------------------\n\n// Access via ImGui::GetPlatformIO()\nstruct ImGuiPlatformIO\n{\n    IMGUI_API ImGuiPlatformIO();\n\n    //------------------------------------------------------------------\n    // Interface with OS and Platform backend\n    //------------------------------------------------------------------\n\n    // Optional: Access OS clipboard\n    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)\n    const char* (*Platform_GetClipboardTextFn)(ImGuiContext* ctx);\n    void        (*Platform_SetClipboardTextFn)(ImGuiContext* ctx, const char* text);\n    void*       Platform_ClipboardUserData;\n\n    // Optional: Open link/folder/file in OS Shell\n    // (default to use ShellExecuteA() on Windows, system() on Linux/Mac)\n    bool        (*Platform_OpenInShellFn)(ImGuiContext* ctx, const char* path);\n    void*       Platform_OpenInShellUserData;\n\n    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)\n    // (default to use native imm32 api on Windows)\n    void        (*Platform_SetImeDataFn)(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);\n    void*       Platform_ImeUserData;\n    //void      (*SetPlatformImeDataFn)(ImGuiViewport* viewport, ImGuiPlatformImeData* data); // [Renamed to platform_io.PlatformSetImeDataFn in 1.91.1]\n\n    // Optional: Platform locale\n    // [Experimental] Configure decimal point e.g. '.' or ',' useful for some languages (e.g. German), generally pulled from *localeconv()->decimal_point\n    ImWchar     Platform_LocaleDecimalPoint;     // '.'\n\n    //------------------------------------------------------------------\n    // Interface with Renderer Backend\n    //------------------------------------------------------------------\n\n    // Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.\n    void*       Renderer_RenderState;\n};\n\n// (Optional) Support for IME (Input Method Editor) via the platform_io.Platform_SetImeDataFn() function.\nstruct ImGuiPlatformImeData\n{\n    bool    WantVisible;        // A widget wants the IME to be visible\n    ImVec2  InputPos;           // Position of the input cursor\n    float   InputLineHeight;    // Line height\n\n    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Obsolete functions and types\n// (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)\n// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.\n//-----------------------------------------------------------------------------\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\nnamespace ImGui\n{\n    // OBSOLETED in 1.91.0 (from July 2024)\n    static inline void  PushButtonRepeat(bool repeat)                           { PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat); }\n    static inline void  PopButtonRepeat()                                       { PopItemFlag(); }\n    static inline void  PushTabStop(bool tab_stop)                              { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }\n    static inline void  PopTabStop()                                            { PopItemFlag(); }\n    IMGUI_API ImVec2    GetContentRegionMax();                                  // Content boundaries max (e.g. window boundaries including scrolling, or current column boundaries). You should never need this. Always use GetCursorScreenPos() and GetContentRegionAvail()!\n    IMGUI_API ImVec2    GetWindowContentRegionMin();                            // Content boundaries min for the window (roughly (0,0)-Scroll), in window-local coordinates. You should never need this. Always use GetCursorScreenPos() and GetContentRegionAvail()!\n    IMGUI_API ImVec2    GetWindowContentRegionMax();                            // Content boundaries max for the window (roughly (0,0)+Size-Scroll), in window-local coordinates. You should never need this. Always use GetCursorScreenPos() and GetContentRegionAvail()!\n    // OBSOLETED in 1.90.0 (from September 2023)\n    static inline bool  BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags window_flags = 0)  { return BeginChild(id, size, ImGuiChildFlags_FrameStyle, window_flags); }\n    static inline void  EndChildFrame()                                                                     { EndChild(); }\n    //static inline bool BeginChild(const char* str_id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags){ return BeginChild(str_id, size_arg, borders ? ImGuiChildFlags_Borders : ImGuiChildFlags_None, window_flags); } // Unnecessary as true == ImGuiChildFlags_Borders\n    //static inline bool BeginChild(ImGuiID id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags)        { return BeginChild(id, size_arg, borders ? ImGuiChildFlags_Borders : ImGuiChildFlags_None, window_flags);     } // Unnecessary as true == ImGuiChildFlags_Borders\n    static inline void  ShowStackToolWindow(bool* p_open = NULL)                { ShowIDStackToolWindow(p_open); }\n    IMGUI_API bool      Combo(const char* label, int* current_item, bool (*old_callback)(void* user_data, int idx, const char** out_text), void* user_data, int items_count, int popup_max_height_in_items = -1);\n    IMGUI_API bool      ListBox(const char* label, int* current_item, bool (*old_callback)(void* user_data, int idx, const char** out_text), void* user_data, int items_count, int height_in_items = -1);\n    // OBSOLETED in 1.89.7 (from June 2023)\n    IMGUI_API void      SetItemAllowOverlap();                                  // Use SetNextItemAllowOverlap() before item.\n    // OBSOLETED in 1.89.4 (from March 2023)\n    static inline void  PushAllowKeyboardFocus(bool tab_stop)                   { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }\n    static inline void  PopAllowKeyboardFocus()                                 { PopItemFlag(); }\n\n    // Some of the older obsolete names along with their replacement (commented out so they are not reported in IDE)\n    //-- OBSOLETED in 1.89 (from August 2022)\n    //IMGUI_API bool      ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1)); // --> Use new ImageButton() signature (explicit item id, regular FramePadding). Refer to code in 1.91 if you want to grab a copy of this version.\n    //-- OBSOLETED in 1.88 (from May 2022)\n    //static inline void  CaptureKeyboardFromApp(bool want_capture_keyboard = true)                   { SetNextFrameWantCaptureKeyboard(want_capture_keyboard); } // Renamed as name was misleading + removed default value.\n    //static inline void  CaptureMouseFromApp(bool want_capture_mouse = true)                         { SetNextFrameWantCaptureMouse(want_capture_mouse); }       // Renamed as name was misleading + removed default value.\n    //-- OBSOLETED in 1.87 (from February 2022, more formally obsoleted April 2024)\n    //IMGUI_API ImGuiKey  GetKeyIndex(ImGuiKey key);                                                  { IM_ASSERT(key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END); const ImGuiKeyData* key_data = GetKeyData(key); return (ImGuiKey)(key_data - g.IO.KeysData); } // Map ImGuiKey_* values into legacy native key index. == io.KeyMap[key]. When using a 1.87+ backend using io.AddKeyEvent(), calling GetKeyIndex() with ANY ImGuiKey_XXXX values will return the same value!\n    //static inline ImGuiKey GetKeyIndex(ImGuiKey key)                                                { IM_ASSERT(key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END); return key; }\n    //-- OBSOLETED in 1.86 (from November 2021)\n    //IMGUI_API void      CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end); // Code removed, see 1.90 for last version of the code. Calculate range of visible items for large list of evenly sized items. Prefer using ImGuiListClipper.\n    //-- OBSOLETED in 1.85 (from August 2021)\n    //static inline float GetWindowContentRegionWidth()                                               { return GetWindowContentRegionMax().x - GetWindowContentRegionMin().x; }\n    //-- OBSOLETED in 1.81 (from February 2021)\n    //static inline bool  ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0, 0))         { return BeginListBox(label, size); }\n    //static inline bool  ListBoxHeader(const char* label, int items_count, int height_in_items = -1) { float height = GetTextLineHeightWithSpacing() * ((height_in_items < 0 ? ImMin(items_count, 7) : height_in_items) + 0.25f) + GetStyle().FramePadding.y * 2.0f; return BeginListBox(label, ImVec2(0.0f, height)); } // Helper to calculate size from items_count and height_in_items\n    //static inline void  ListBoxFooter()                                                             { EndListBox(); }\n    //-- OBSOLETED in 1.79 (from August 2020)\n    //static inline void  OpenPopupContextItem(const char* str_id = NULL, ImGuiMouseButton mb = 1)    { OpenPopupOnItemClick(str_id, mb); } // Bool return value removed. Use IsWindowAppearing() in BeginPopup() instead. Renamed in 1.77, renamed back in 1.79. Sorry!\n    //-- OBSOLETED in 1.78 (from June 2020): Old drag/sliders functions that took a 'float power > 1.0f' argument instead of ImGuiSliderFlags_Logarithmic. See github.com/ocornut/imgui/issues/3361 for details.\n    //IMGUI_API bool      DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, float power = 1.0f)                                                            // OBSOLETED in 1.78 (from June 2020)\n    //IMGUI_API bool      DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, float power = 1.0f);                                          // OBSOLETED in 1.78 (from June 2020)\n    //IMGUI_API bool      SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, float power = 1.0f);                                                                        // OBSOLETED in 1.78 (from June 2020)\n    //IMGUI_API bool      SliderScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format, float power = 1.0f);                                                       // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power = 1.0f)    { return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power); }     // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power); } // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power); } // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power); } // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power = 1.0f)                 { return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power); }            // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power); }        // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power); }        // OBSOLETED in 1.78 (from June 2020)\n    //static inline bool  SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power); }        // OBSOLETED in 1.78 (from June 2020)\n    //-- OBSOLETED in 1.77 and before\n    //static inline bool  BeginPopupContextWindow(const char* str_id, ImGuiMouseButton mb, bool over_items) { return BeginPopupContextWindow(str_id, mb | (over_items ? 0 : ImGuiPopupFlags_NoOpenOverItems)); } // OBSOLETED in 1.77 (from June 2020)\n    //static inline void  TreeAdvanceToLabelPos()               { SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()); }   // OBSOLETED in 1.72 (from July 2019)\n    //static inline void  SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { SetNextItemOpen(open, cond); }                       // OBSOLETED in 1.71 (from June 2019)\n    //static inline float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }                               // OBSOLETED in 1.70 (from May 2019)\n    //static inline ImDrawList* GetOverlayDrawList()            { return GetForegroundDrawList(); }                                 // OBSOLETED in 1.69 (from Mar 2019)\n    //static inline void  SetScrollHere(float ratio = 0.5f)     { SetScrollHereY(ratio); }                                          // OBSOLETED in 1.66 (from Nov 2018)\n    //static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }                            // OBSOLETED in 1.63 (from Aug 2018)\n    //-- OBSOLETED in 1.60 and before\n    //static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }            // OBSOLETED in 1.60 (from Apr 2018)\n    //static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }            // OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)\n    //static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }                                        // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\n    //static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }           // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\n    //static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }  // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\n    //static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }                      // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\n    //static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }                             // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\n    //IMGUI_API bool      Begin(char* name, bool* p_open, ImVec2 size_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags=0); // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017): Equivalent of using SetNextWindowSize(size, ImGuiCond_FirstUseEver) and SetNextWindowBgAlpha().\n    //static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }  // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)\n    //static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }                                      // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)\n    //static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { SetNextWindowPos(GetMainViewport()->GetCenter(), c, ImVec2(0.5f,0.5f)); } // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)\n    //static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }               // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)\n    //static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; }                                     // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017): This was misleading and partly broken. You probably want to use the io.WantCaptureMouse flag instead.\n    //static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }            // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)\n    //static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }       // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)\n    //-- OBSOLETED in 1.50 and before\n    //static inline bool  CollapsingHeader(char* label, const char* str_id, bool framed = true, bool default_open = false) { return CollapsingHeader(label, (default_open ? (1 << 5) : 0)); } // OBSOLETED in 1.49\n    //static inline ImFont*GetWindowFont()                      { return GetFont(); }                                               // OBSOLETED in 1.48\n    //static inline float GetWindowFontSize()                   { return GetFontSize(); }                                           // OBSOLETED in 1.48\n    //static inline void  SetScrollPosHere()                    { SetScrollHere(); }                                                // OBSOLETED in 1.42\n}\n\n//-- OBSOLETED in 1.82 (from Mars 2021): flags for AddRect(), AddRectFilled(), AddImageRounded(), PathRect()\n//typedef ImDrawFlags ImDrawCornerFlags;\n//enum ImDrawCornerFlags_\n//{\n//    ImDrawCornerFlags_None      = ImDrawFlags_RoundCornersNone,         // Was == 0 prior to 1.82, this is now == ImDrawFlags_RoundCornersNone which is != 0 and not implicit\n//    ImDrawCornerFlags_TopLeft   = ImDrawFlags_RoundCornersTopLeft,      // Was == 0x01 (1 << 0) prior to 1.82. Order matches ImDrawFlags_NoRoundCorner* flag (we exploit this internally).\n//    ImDrawCornerFlags_TopRight  = ImDrawFlags_RoundCornersTopRight,     // Was == 0x02 (1 << 1) prior to 1.82.\n//    ImDrawCornerFlags_BotLeft   = ImDrawFlags_RoundCornersBottomLeft,   // Was == 0x04 (1 << 2) prior to 1.82.\n//    ImDrawCornerFlags_BotRight  = ImDrawFlags_RoundCornersBottomRight,  // Was == 0x08 (1 << 3) prior to 1.82.\n//    ImDrawCornerFlags_All       = ImDrawFlags_RoundCornersAll,          // Was == 0x0F prior to 1.82\n//    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,\n//    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,\n//    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,\n//    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,\n//};\n\n// RENAMED and MERGED both ImGuiKey_ModXXX and ImGuiModFlags_XXX into ImGuiMod_XXX (from September 2022)\n// RENAMED ImGuiKeyModFlags -> ImGuiModFlags in 1.88 (from April 2022). Exceptionally commented out ahead of obscolescence schedule to reduce confusion and because they were not meant to be used in the first place.\n//typedef ImGuiKeyChord ImGuiModFlags;      // == int. We generally use ImGuiKeyChord to mean \"a ImGuiKey or-ed with any number of ImGuiMod_XXX value\", so you may store mods in there.\n//enum ImGuiModFlags_ { ImGuiModFlags_None = 0, ImGuiModFlags_Ctrl = ImGuiMod_Ctrl, ImGuiModFlags_Shift = ImGuiMod_Shift, ImGuiModFlags_Alt = ImGuiMod_Alt, ImGuiModFlags_Super = ImGuiMod_Super };\n//typedef ImGuiKeyChord ImGuiKeyModFlags; // == int\n//enum ImGuiKeyModFlags_ { ImGuiKeyModFlags_None = 0, ImGuiKeyModFlags_Ctrl = ImGuiMod_Ctrl, ImGuiKeyModFlags_Shift = ImGuiMod_Shift, ImGuiKeyModFlags_Alt = ImGuiMod_Alt, ImGuiKeyModFlags_Super = ImGuiMod_Super };\n\n#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)    // OBSOLETED IN 1.90 (now using C++11 standard version)\n\n#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n\n// RENAMED IMGUI_DISABLE_METRICS_WINDOW > IMGUI_DISABLE_DEBUG_TOOLS in 1.88 (from June 2022)\n#ifdef IMGUI_DISABLE_METRICS_WINDOW\n#error IMGUI_DISABLE_METRICS_WINDOW was renamed to IMGUI_DISABLE_DEBUG_TOOLS, please use new name.\n#endif\n\n//-----------------------------------------------------------------------------\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#elif defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (pop)\n#endif\n\n// Include imgui_user.h at the end of imgui.h\n// May be convenient for some users to only explicitly include vanilla imgui.h and have extra stuff included.\n#ifdef IMGUI_INCLUDE_IMGUI_USER_H\n#ifdef IMGUI_USER_H_FILENAME\n#include IMGUI_USER_H_FILENAME\n#else\n#include \"imgui_user.h\"\n#endif\n#endif\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "imgui_demo.cpp",
          "type": "blob",
          "size": 533.9,
          "content": "// dear imgui, v1.91.7 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// How to easily locate code?\n// - Use Tools->Item Picker to debug break in code by clicking any widgets: https://github.com/ocornut/imgui/wiki/Debug-Tools\n// - Browse an online version the demo with code linked to hovered widgets: https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html\n// - Find a visible string and search for it in the code!\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n// - You can search/grep for all sections listed in the index to find the section.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Helpers: ExampleTreeNode, ExampleMemberInfo (for use by Property Editor & Multi-Select demos)\n// [SECTION] Demo Window / ShowDemoWindow()\n// [SECTION] ShowDemoWindowMenuBar()\n// [SECTION] ShowDemoWindowWidgets()\n// [SECTION] ShowDemoWindowMultiSelect()\n// [SECTION] ShowDemoWindowLayout()\n// [SECTION] ShowDemoWindowPopups()\n// [SECTION] ShowDemoWindowTables()\n// [SECTION] ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n// [SECTION] Example App: Assets Browser / ShowExampleAppAssetsBrowser()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includes\n#include <ctype.h>          // toupper\n#include <limits.h>         // INT_MIN, INT_MAX\n#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf\n#include <stdio.h>          // vsnprintf, sscanf, printf\n#include <stdlib.h>         // NULL, malloc, free, atoi\n#include <stdint.h>         // intptr_t\n#if !defined(_MSC_VER) || _MSC_VER >= 1800\n#include <inttypes.h>       // PRId64/PRIu64, not avail in some MinGW headers.\n#endif\n#ifdef __EMSCRIPTEN__\n#include <emscripten/version.h>     // __EMSCRIPTEN_major__ etc.\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to an 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                     // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                           // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"        // warning: 'xx' is deprecated: The POSIX name for this..   // for strdup used in demo code (so user can copy & paste the code)\n#pragma clang diagnostic ignored \"-Wint-to-void-pointer-cast\"       // warning: cast to 'void *' from smaller integer type\n#pragma clang diagnostic ignored \"-Wformat-security\"                // warning: format string is not a string literal\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"          // warning: declaration requires an exit-time destructor    // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.\n#pragma clang diagnostic ignored \"-Wunused-macros\"                  // warning: macro is not used                               // we define snprintf/vsnprintf on Windows so they are available, but not always used.\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                   // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wint-to-pointer-cast\"              // warning: cast to pointer from integer of different size\n#pragma GCC diagnostic ignored \"-Wformat\"                           // warning: format '%p' expects argument of type 'int'/'void*', but argument X has type 'unsigned int'/'ImGuiWindow*'\n#pragma GCC diagnostic ignored \"-Wformat-security\"                  // warning: format string is not a string literal (potentially insecure)\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"                       // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wmisleading-indentation\"           // [__GNUC__ >= 6] warning: this 'if' clause does not guard this statement      // GCC 6.0+ only. See #883 on GitHub.\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"                  // warning: assuming signed overflow does not occur when simplifying division / ..when changing X +- C1 cmp C2 to X cmp C2 -+ C1\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                        // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers\n#endif\n\n// Play it nice with Windows users (Update: May 2018, Notepad now supports Unix-style carriage returns!)\n#ifdef _WIN32\n#define IM_NEWLINE  \"\\r\\n\"\n#else\n#define IM_NEWLINE  \"\\n\"\n#endif\n\n// Helpers\n#if defined(_MSC_VER) && !defined(snprintf)\n#define snprintf    _snprintf\n#endif\n#if defined(_MSC_VER) && !defined(vsnprintf)\n#define vsnprintf   _vsnprintf\n#endif\n\n// Format specifiers for 64-bit values (hasn't been decently standardized before VS2013)\n#if !defined(PRId64) && defined(_MSC_VER)\n#define PRId64 \"I64d\"\n#define PRIu64 \"I64u\"\n#elif !defined(PRId64)\n#define PRId64 \"lld\"\n#define PRIu64 \"llu\"\n#endif\n\n// Helpers macros\n// We normally try to not use many helpers in imgui_demo.cpp in order to make code easier to copy and paste,\n// but making an exception here as those are largely simplifying code...\n// In other imgui sources we can use nicer internal functions from imgui_internal.h (ImMin/ImMax) but not in the demo.\n#define IM_MIN(A, B)            (((A) < (B)) ? (A) : (B))\n#define IM_MAX(A, B)            (((A) >= (B)) ? (A) : (B))\n#define IM_CLAMP(V, MN, MX)     ((V) < (MN) ? (MN) : (V) > (MX) ? (MX) : (V))\n\n// Enforce cdecl calling convention for functions called by the standard library,\n// in case compilation settings changed the default to e.g. __vectorcall\n#ifndef IMGUI_CDECL\n#ifdef _MSC_VER\n#define IMGUI_CDECL __cdecl\n#else\n#define IMGUI_CDECL\n#endif\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Forward Declarations\n//-----------------------------------------------------------------------------\n\n#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)\n\n// Forward Declarations\nstruct ImGuiDemoWindowData;\nstatic void ShowExampleAppMainMenuBar();\nstatic void ShowExampleAppAssetsBrowser(bool* p_open);\nstatic void ShowExampleAppConsole(bool* p_open);\nstatic void ShowExampleAppCustomRendering(bool* p_open);\nstatic void ShowExampleAppDocuments(bool* p_open);\nstatic void ShowExampleAppLog(bool* p_open);\nstatic void ShowExampleAppLayout(bool* p_open);\nstatic void ShowExampleAppPropertyEditor(bool* p_open, ImGuiDemoWindowData* demo_data);\nstatic void ShowExampleAppSimpleOverlay(bool* p_open);\nstatic void ShowExampleAppAutoResize(bool* p_open);\nstatic void ShowExampleAppConstrainedResize(bool* p_open);\nstatic void ShowExampleAppFullscreen(bool* p_open);\nstatic void ShowExampleAppLongText(bool* p_open);\nstatic void ShowExampleAppWindowTitles(bool* p_open);\nstatic void ShowExampleMenuFile();\n\n// We split the contents of the big ShowDemoWindow() function into smaller functions\n// (because the link time of very large functions tends to grow non-linearly)\nstatic void ShowDemoWindowMenuBar(ImGuiDemoWindowData* demo_data);\nstatic void ShowDemoWindowWidgets(ImGuiDemoWindowData* demo_data);\nstatic void ShowDemoWindowMultiSelect(ImGuiDemoWindowData* demo_data);\nstatic void ShowDemoWindowLayout();\nstatic void ShowDemoWindowPopups();\nstatic void ShowDemoWindowTables();\nstatic void ShowDemoWindowColumns();\nstatic void ShowDemoWindowInputs();\n\n//-----------------------------------------------------------------------------\n// [SECTION] Helpers\n//-----------------------------------------------------------------------------\n\n// Helper to display a little (?) mark which shows a tooltip when hovered.\n// In your own code you may want to display an actual icon if you are using a merged icon fonts (see docs/FONTS.md)\nstatic void HelpMarker(const char* desc)\n{\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::BeginItemTooltip())\n    {\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n        ImGui::TextUnformatted(desc);\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}\n\n// Helper to wire demo markers located in code to an interactive browser\ntypedef void (*ImGuiDemoMarkerCallback)(const char* file, int line, const char* section, void* user_data);\nextern ImGuiDemoMarkerCallback      GImGuiDemoMarkerCallback;\nextern void*                        GImGuiDemoMarkerCallbackUserData;\nImGuiDemoMarkerCallback             GImGuiDemoMarkerCallback = NULL;\nvoid*                               GImGuiDemoMarkerCallbackUserData = NULL;\n#define IMGUI_DEMO_MARKER(section)  do { if (GImGuiDemoMarkerCallback != NULL) GImGuiDemoMarkerCallback(__FILE__, __LINE__, section, GImGuiDemoMarkerCallbackUserData); } while (0)\n\n//-----------------------------------------------------------------------------\n// [SECTION] Helpers: ExampleTreeNode, ExampleMemberInfo (for use by Property Editor etc.)\n//-----------------------------------------------------------------------------\n\n// Simple representation for a tree\n// (this is designed to be simple to understand for our demos, not to be fancy or efficient etc.)\nstruct ExampleTreeNode\n{\n    // Tree structure\n    char                        Name[28] = \"\";\n    int                         UID = 0;\n    ExampleTreeNode*            Parent = NULL;\n    ImVector<ExampleTreeNode*>  Childs;\n    unsigned short              IndexInParent = 0;  // Maintaining this allows us to implement linear traversal more easily\n\n    // Leaf Data\n    bool                        HasData = false;    // All leaves have data\n    bool                        DataMyBool = true;\n    int                         DataMyInt = 128;\n    ImVec2                      DataMyVec2 = ImVec2(0.0f, 3.141592f);\n};\n\n// Simple representation of struct metadata/serialization data.\n// (this is a minimal version of what a typical advanced application may provide)\nstruct ExampleMemberInfo\n{\n    const char*     Name;       // Member name\n    ImGuiDataType   DataType;   // Member type\n    int             DataCount;  // Member count (1 when scalar)\n    int             Offset;     // Offset inside parent structure\n};\n\n// Metadata description of ExampleTreeNode struct.\nstatic const ExampleMemberInfo ExampleTreeNodeMemberInfos[]\n{\n    { \"MyName\",     ImGuiDataType_String,  1, offsetof(ExampleTreeNode, Name) },\n    { \"MyBool\",     ImGuiDataType_Bool,    1, offsetof(ExampleTreeNode, DataMyBool) },\n    { \"MyInt\",      ImGuiDataType_S32,     1, offsetof(ExampleTreeNode, DataMyInt) },\n    { \"MyVec2\",     ImGuiDataType_Float,   2, offsetof(ExampleTreeNode, DataMyVec2) },\n};\n\nstatic ExampleTreeNode* ExampleTree_CreateNode(const char* name, int uid, ExampleTreeNode* parent)\n{\n    ExampleTreeNode* node = IM_NEW(ExampleTreeNode);\n    snprintf(node->Name, IM_ARRAYSIZE(node->Name), \"%s\", name);\n    node->UID = uid;\n    node->Parent = parent;\n    node->IndexInParent = parent ? (unsigned short)parent->Childs.Size : 0;\n    if (parent)\n        parent->Childs.push_back(node);\n    return node;\n}\n\nstatic void ExampleTree_DestroyNode(ExampleTreeNode* node)\n{\n    for (ExampleTreeNode* child_node : node->Childs)\n        ExampleTree_DestroyNode(child_node);\n    IM_DELETE(node);\n}\n\n// Create example tree data\n// (this allocates _many_ more times than most other code in either Dear ImGui or others demo)\nstatic ExampleTreeNode* ExampleTree_CreateDemoTree()\n{\n    static const char* root_names[] = { \"Apple\", \"Banana\", \"Cherry\", \"Kiwi\", \"Mango\", \"Orange\", \"Pear\", \"Pineapple\", \"Strawberry\", \"Watermelon\" };\n    const size_t NAME_MAX_LEN = sizeof(ExampleTreeNode::Name);\n    char name_buf[NAME_MAX_LEN];\n    int uid = 0;\n    ExampleTreeNode* node_L0 = ExampleTree_CreateNode(\"<ROOT>\", ++uid, NULL);\n    const int root_items_multiplier = 2;\n    for (int idx_L0 = 0; idx_L0 < IM_ARRAYSIZE(root_names) * root_items_multiplier; idx_L0++)\n    {\n        snprintf(name_buf, IM_ARRAYSIZE(name_buf), \"%s %d\", root_names[idx_L0 / root_items_multiplier], idx_L0 % root_items_multiplier);\n        ExampleTreeNode* node_L1 = ExampleTree_CreateNode(name_buf, ++uid, node_L0);\n        const int number_of_childs = (int)strlen(node_L1->Name);\n        for (int idx_L1 = 0; idx_L1 < number_of_childs; idx_L1++)\n        {\n            snprintf(name_buf, IM_ARRAYSIZE(name_buf), \"Child %d\", idx_L1);\n            ExampleTreeNode* node_L2 = ExampleTree_CreateNode(name_buf, ++uid, node_L1);\n            node_L2->HasData = true;\n            if (idx_L1 == 0)\n            {\n                snprintf(name_buf, IM_ARRAYSIZE(name_buf), \"Sub-child %d\", 0);\n                ExampleTreeNode* node_L3 = ExampleTree_CreateNode(name_buf, ++uid, node_L2);\n                node_L3->HasData = true;\n            }\n        }\n    }\n    return node_L0;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Demo Window / ShowDemoWindow()\n//-----------------------------------------------------------------------------\n\n// Data to be shared across different functions of the demo.\nstruct ImGuiDemoWindowData\n{\n    // Examples Apps (accessible from the \"Examples\" menu)\n    bool ShowMainMenuBar = false;\n    bool ShowAppAssetsBrowser = false;\n    bool ShowAppConsole = false;\n    bool ShowAppCustomRendering = false;\n    bool ShowAppDocuments = false;\n    bool ShowAppLog = false;\n    bool ShowAppLayout = false;\n    bool ShowAppPropertyEditor = false;\n    bool ShowAppSimpleOverlay = false;\n    bool ShowAppAutoResize = false;\n    bool ShowAppConstrainedResize = false;\n    bool ShowAppFullscreen = false;\n    bool ShowAppLongText = false;\n    bool ShowAppWindowTitles = false;\n\n    // Dear ImGui Tools (accessible from the \"Tools\" menu)\n    bool ShowMetrics = false;\n    bool ShowDebugLog = false;\n    bool ShowIDStackTool = false;\n    bool ShowStyleEditor = false;\n    bool ShowAbout = false;\n\n    // Other data\n    ExampleTreeNode* DemoTree = NULL;\n\n    ~ImGuiDemoWindowData() { if (DemoTree) ExampleTree_DestroyNode(DemoTree); }\n};\n\n// Demonstrate most Dear ImGui features (this is big function!)\n// You may execute this function to experiment with the UI and understand what it does.\n// You may then search for keywords in the code when you are interested by a specific feature.\nvoid ImGui::ShowDemoWindow(bool* p_open)\n{\n    // Exceptionally add an extra assert here for people confused about initial Dear ImGui setup\n    // Most functions would normally just assert/crash if the context is missing.\n    IM_ASSERT(ImGui::GetCurrentContext() != NULL && \"Missing Dear ImGui context. Refer to examples app!\");\n\n    // Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.\n    IMGUI_CHECKVERSION();\n\n    // Stored data\n    static ImGuiDemoWindowData demo_data;\n\n    // Examples Apps (accessible from the \"Examples\" menu)\n    if (demo_data.ShowMainMenuBar)          { ShowExampleAppMainMenuBar(); }\n    if (demo_data.ShowAppDocuments)         { ShowExampleAppDocuments(&demo_data.ShowAppDocuments); }\n    if (demo_data.ShowAppAssetsBrowser)     { ShowExampleAppAssetsBrowser(&demo_data.ShowAppAssetsBrowser); }\n    if (demo_data.ShowAppConsole)           { ShowExampleAppConsole(&demo_data.ShowAppConsole); }\n    if (demo_data.ShowAppCustomRendering)   { ShowExampleAppCustomRendering(&demo_data.ShowAppCustomRendering); }\n    if (demo_data.ShowAppLog)               { ShowExampleAppLog(&demo_data.ShowAppLog); }\n    if (demo_data.ShowAppLayout)            { ShowExampleAppLayout(&demo_data.ShowAppLayout); }\n    if (demo_data.ShowAppPropertyEditor)    { ShowExampleAppPropertyEditor(&demo_data.ShowAppPropertyEditor, &demo_data); }\n    if (demo_data.ShowAppSimpleOverlay)     { ShowExampleAppSimpleOverlay(&demo_data.ShowAppSimpleOverlay); }\n    if (demo_data.ShowAppAutoResize)        { ShowExampleAppAutoResize(&demo_data.ShowAppAutoResize); }\n    if (demo_data.ShowAppConstrainedResize) { ShowExampleAppConstrainedResize(&demo_data.ShowAppConstrainedResize); }\n    if (demo_data.ShowAppFullscreen)        { ShowExampleAppFullscreen(&demo_data.ShowAppFullscreen); }\n    if (demo_data.ShowAppLongText)          { ShowExampleAppLongText(&demo_data.ShowAppLongText); }\n    if (demo_data.ShowAppWindowTitles)      { ShowExampleAppWindowTitles(&demo_data.ShowAppWindowTitles); }\n\n    // Dear ImGui Tools (accessible from the \"Tools\" menu)\n    if (demo_data.ShowMetrics)              { ImGui::ShowMetricsWindow(&demo_data.ShowMetrics); }\n    if (demo_data.ShowDebugLog)             { ImGui::ShowDebugLogWindow(&demo_data.ShowDebugLog); }\n    if (demo_data.ShowIDStackTool)          { ImGui::ShowIDStackToolWindow(&demo_data.ShowIDStackTool); }\n    if (demo_data.ShowAbout)                { ImGui::ShowAboutWindow(&demo_data.ShowAbout); }\n    if (demo_data.ShowStyleEditor)\n    {\n        ImGui::Begin(\"Dear ImGui Style Editor\", &demo_data.ShowStyleEditor);\n        ImGui::ShowStyleEditor();\n        ImGui::End();\n    }\n\n    // Demonstrate the various window flags. Typically you would just use the default!\n    static bool no_titlebar = false;\n    static bool no_scrollbar = false;\n    static bool no_menu = false;\n    static bool no_move = false;\n    static bool no_resize = false;\n    static bool no_collapse = false;\n    static bool no_close = false;\n    static bool no_nav = false;\n    static bool no_background = false;\n    static bool no_bring_to_front = false;\n    static bool unsaved_document = false;\n\n    ImGuiWindowFlags window_flags = 0;\n    if (no_titlebar)        window_flags |= ImGuiWindowFlags_NoTitleBar;\n    if (no_scrollbar)       window_flags |= ImGuiWindowFlags_NoScrollbar;\n    if (!no_menu)           window_flags |= ImGuiWindowFlags_MenuBar;\n    if (no_move)            window_flags |= ImGuiWindowFlags_NoMove;\n    if (no_resize)          window_flags |= ImGuiWindowFlags_NoResize;\n    if (no_collapse)        window_flags |= ImGuiWindowFlags_NoCollapse;\n    if (no_nav)             window_flags |= ImGuiWindowFlags_NoNav;\n    if (no_background)      window_flags |= ImGuiWindowFlags_NoBackground;\n    if (no_bring_to_front)  window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus;\n    if (unsaved_document)   window_flags |= ImGuiWindowFlags_UnsavedDocument;\n    if (no_close)           p_open = NULL; // Don't pass our bool* to Begin\n\n    // We specify a default position/size in case there's no data in the .ini file.\n    // We only do it to make the demo applications a little more welcoming, but typically this isn't required.\n    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();\n    ImGui::SetNextWindowPos(ImVec2(main_viewport->WorkPos.x + 650, main_viewport->WorkPos.y + 20), ImGuiCond_FirstUseEver);\n    ImGui::SetNextWindowSize(ImVec2(550, 680), ImGuiCond_FirstUseEver);\n\n    // Main body of the Demo window starts here.\n    if (!ImGui::Begin(\"Dear ImGui Demo\", p_open, window_flags))\n    {\n        // Early out if the window is collapsed, as an optimization.\n        ImGui::End();\n        return;\n    }\n\n    // Most \"big\" widgets share a common width settings by default. See 'Demo->Layout->Widgets Width' for details.\n    ImGui::PushItemWidth(ImGui::GetFontSize() * -12);           // e.g. Leave a fixed amount of width for labels (by passing a negative value), the rest goes to widgets.\n    //ImGui::PushItemWidth(-ImGui::GetWindowWidth() * 0.35f);   // e.g. Use 2/3 of the space for widgets and 1/3 for labels (right align)\n\n    // Menu Bar\n    ShowDemoWindowMenuBar(&demo_data);\n\n    ImGui::Text(\"dear imgui says hello! (%s) (%d)\", IMGUI_VERSION, IMGUI_VERSION_NUM);\n    ImGui::Spacing();\n\n    IMGUI_DEMO_MARKER(\"Help\");\n    if (ImGui::CollapsingHeader(\"Help\"))\n    {\n        ImGui::SeparatorText(\"ABOUT THIS DEMO:\");\n        ImGui::BulletText(\"Sections below are demonstrating many aspects of the library.\");\n        ImGui::BulletText(\"The \\\"Examples\\\" menu above leads to more demo contents.\");\n        ImGui::BulletText(\"The \\\"Tools\\\" menu above gives access to: About Box, Style Editor,\\n\"\n                          \"and Metrics/Debugger (general purpose Dear ImGui debugging tool).\");\n\n        ImGui::SeparatorText(\"PROGRAMMER GUIDE:\");\n        ImGui::BulletText(\"See the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!\");\n        ImGui::BulletText(\"See comments in imgui.cpp.\");\n        ImGui::BulletText(\"See example applications in the examples/ folder.\");\n        ImGui::BulletText(\"Read the FAQ at \");\n        ImGui::SameLine(0, 0);\n        ImGui::TextLinkOpenURL(\"https://www.dearimgui.com/faq/\");\n        ImGui::BulletText(\"Set 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.\");\n        ImGui::BulletText(\"Set 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.\");\n\n        ImGui::SeparatorText(\"USER GUIDE:\");\n        ImGui::ShowUserGuide();\n    }\n\n    IMGUI_DEMO_MARKER(\"Configuration\");\n    if (ImGui::CollapsingHeader(\"Configuration\"))\n    {\n        ImGuiIO& io = ImGui::GetIO();\n\n        if (ImGui::TreeNode(\"Configuration##2\"))\n        {\n            ImGui::SeparatorText(\"General\");\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NavEnableKeyboard\",    &io.ConfigFlags, ImGuiConfigFlags_NavEnableKeyboard);\n            ImGui::SameLine(); HelpMarker(\"Enable keyboard controls.\");\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NavEnableGamepad\",     &io.ConfigFlags, ImGuiConfigFlags_NavEnableGamepad);\n            ImGui::SameLine(); HelpMarker(\"Enable gamepad controls. Require backend to set io.BackendFlags |= ImGuiBackendFlags_HasGamepad.\\n\\nRead instructions in imgui.cpp for details.\");\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NoMouse\",              &io.ConfigFlags, ImGuiConfigFlags_NoMouse);\n            ImGui::SameLine(); HelpMarker(\"Instruct dear imgui to disable mouse inputs and interactions.\");\n\n            // The \"NoMouse\" option can get us stuck with a disabled mouse! Let's provide an alternative way to fix it:\n            if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)\n            {\n                if (fmodf((float)ImGui::GetTime(), 0.40f) < 0.20f)\n                {\n                    ImGui::SameLine();\n                    ImGui::Text(\"<<PRESS SPACE TO DISABLE>>\");\n                }\n                // Prevent both being checked\n                if (ImGui::IsKeyPressed(ImGuiKey_Space) || (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard))\n                    io.ConfigFlags &= ~ImGuiConfigFlags_NoMouse;\n            }\n\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NoMouseCursorChange\",  &io.ConfigFlags, ImGuiConfigFlags_NoMouseCursorChange);\n            ImGui::SameLine(); HelpMarker(\"Instruct backend to not alter mouse cursor shape and visibility.\");\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NoKeyboard\", &io.ConfigFlags, ImGuiConfigFlags_NoKeyboard);\n            ImGui::SameLine(); HelpMarker(\"Instruct dear imgui to disable keyboard inputs and interactions.\");\n\n            ImGui::Checkbox(\"io.ConfigInputTrickleEventQueue\", &io.ConfigInputTrickleEventQueue);\n            ImGui::SameLine(); HelpMarker(\"Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.\");\n            ImGui::Checkbox(\"io.MouseDrawCursor\", &io.MouseDrawCursor);\n            ImGui::SameLine(); HelpMarker(\"Instruct Dear ImGui to render a mouse cursor itself. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\\n\\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).\");\n\n            ImGui::SeparatorText(\"Keyboard/Gamepad Navigation\");\n            ImGui::Checkbox(\"io.ConfigNavSwapGamepadButtons\", &io.ConfigNavSwapGamepadButtons);\n            ImGui::Checkbox(\"io.ConfigNavMoveSetMousePos\", &io.ConfigNavMoveSetMousePos);\n            ImGui::SameLine(); HelpMarker(\"Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult\");\n            ImGui::Checkbox(\"io.ConfigNavCaptureKeyboard\", &io.ConfigNavCaptureKeyboard);\n            ImGui::Checkbox(\"io.ConfigNavEscapeClearFocusItem\", &io.ConfigNavEscapeClearFocusItem);\n            ImGui::SameLine(); HelpMarker(\"Pressing Escape clears focused item.\");\n            ImGui::Checkbox(\"io.ConfigNavEscapeClearFocusWindow\", &io.ConfigNavEscapeClearFocusWindow);\n            ImGui::SameLine(); HelpMarker(\"Pressing Escape clears focused window.\");\n            ImGui::Checkbox(\"io.ConfigNavCursorVisibleAuto\", &io.ConfigNavCursorVisibleAuto);\n            ImGui::SameLine(); HelpMarker(\"Using directional navigation key makes the cursor visible. Mouse click hides the cursor.\");\n            ImGui::Checkbox(\"io.ConfigNavCursorVisibleAlways\", &io.ConfigNavCursorVisibleAlways);\n            ImGui::SameLine(); HelpMarker(\"Navigation cursor is always visible.\");\n\n            ImGui::SeparatorText(\"Windows\");\n            ImGui::Checkbox(\"io.ConfigWindowsResizeFromEdges\", &io.ConfigWindowsResizeFromEdges);\n            ImGui::SameLine(); HelpMarker(\"Enable resizing of windows from their edges and from the lower-left corner.\\nThis requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback.\");\n            ImGui::Checkbox(\"io.ConfigWindowsMoveFromTitleBarOnly\", &io.ConfigWindowsMoveFromTitleBarOnly);\n            ImGui::Checkbox(\"io.ConfigWindowsCopyContentsWithCtrlC\", &io.ConfigWindowsCopyContentsWithCtrlC); // [EXPERIMENTAL]\n            ImGui::SameLine(); HelpMarker(\"*EXPERIMENTAL* CTRL+C copy the contents of focused window into the clipboard.\\n\\nExperimental because:\\n- (1) has known issues with nested Begin/End pairs.\\n- (2) text output quality varies.\\n- (3) text output is in submission order rather than spatial order.\");\n            ImGui::Checkbox(\"io.ConfigScrollbarScrollByPage\", &io.ConfigScrollbarScrollByPage);\n            ImGui::SameLine(); HelpMarker(\"Enable scrolling page by page when clicking outside the scrollbar grab.\\nWhen disabled, always scroll to clicked location.\\nWhen enabled, Shift+Click scrolls to clicked location.\");\n\n            ImGui::SeparatorText(\"Widgets\");\n            ImGui::Checkbox(\"io.ConfigInputTextCursorBlink\", &io.ConfigInputTextCursorBlink);\n            ImGui::SameLine(); HelpMarker(\"Enable blinking cursor (optional as some users consider it to be distracting).\");\n            ImGui::Checkbox(\"io.ConfigInputTextEnterKeepActive\", &io.ConfigInputTextEnterKeepActive);\n            ImGui::SameLine(); HelpMarker(\"Pressing Enter will keep item active and select contents (single-line only).\");\n            ImGui::Checkbox(\"io.ConfigDragClickToInputText\", &io.ConfigDragClickToInputText);\n            ImGui::SameLine(); HelpMarker(\"Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving).\");\n            ImGui::Checkbox(\"io.ConfigMacOSXBehaviors\", &io.ConfigMacOSXBehaviors);\n            ImGui::SameLine(); HelpMarker(\"Swap Cmd<>Ctrl keys, enable various MacOS style behaviors.\");\n            ImGui::Text(\"Also see Style->Rendering for rendering options.\");\n\n            // Also read: https://github.com/ocornut/imgui/wiki/Error-Handling\n            ImGui::SeparatorText(\"Error Handling\");\n\n            ImGui::Checkbox(\"io.ConfigErrorRecovery\", &io.ConfigErrorRecovery);\n            ImGui::SameLine(); HelpMarker(\n                \"Options to configure how we handle recoverable errors.\\n\"\n                \"- Error recovery is not perfect nor guaranteed! It is a feature to ease development.\\n\"\n                \"- You not are not supposed to rely on it in the course of a normal application run.\\n\"\n                \"- Possible usage: facilitate recovery from errors triggered from a scripting language or after specific exceptions handlers.\\n\"\n                \"- Always ensure that on programmers seat you have at minimum Asserts or Tooltips enabled when making direct imgui API call!\"\n                \"Otherwise it would severely hinder your ability to catch and correct mistakes!\");\n            ImGui::Checkbox(\"io.ConfigErrorRecoveryEnableAssert\", &io.ConfigErrorRecoveryEnableAssert);\n            ImGui::Checkbox(\"io.ConfigErrorRecoveryEnableDebugLog\", &io.ConfigErrorRecoveryEnableDebugLog);\n            ImGui::Checkbox(\"io.ConfigErrorRecoveryEnableTooltip\", &io.ConfigErrorRecoveryEnableTooltip);\n            if (!io.ConfigErrorRecoveryEnableAssert && !io.ConfigErrorRecoveryEnableDebugLog && !io.ConfigErrorRecoveryEnableTooltip)\n                io.ConfigErrorRecoveryEnableAssert = io.ConfigErrorRecoveryEnableDebugLog = io.ConfigErrorRecoveryEnableTooltip = true;\n\n            // Also read: https://github.com/ocornut/imgui/wiki/Debug-Tools\n            ImGui::SeparatorText(\"Debug\");\n            ImGui::Checkbox(\"io.ConfigDebugIsDebuggerPresent\", &io.ConfigDebugIsDebuggerPresent);\n            ImGui::SameLine(); HelpMarker(\"Enable various tools calling IM_DEBUG_BREAK().\\n\\nRequires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.\");\n            ImGui::Checkbox(\"io.ConfigDebugHighlightIdConflicts\", &io.ConfigDebugHighlightIdConflicts);\n            ImGui::SameLine(); HelpMarker(\"Highlight and show an error message when multiple items have conflicting identifiers.\");\n            ImGui::BeginDisabled();\n            ImGui::Checkbox(\"io.ConfigDebugBeginReturnValueOnce\", &io.ConfigDebugBeginReturnValueOnce);\n            ImGui::EndDisabled();\n            ImGui::SameLine(); HelpMarker(\"First calls to Begin()/BeginChild() will return false.\\n\\nTHIS OPTION IS DISABLED because it needs to be set at application boot-time to make sense. Showing the disabled option is a way to make this feature easier to discover.\");\n            ImGui::Checkbox(\"io.ConfigDebugBeginReturnValueLoop\", &io.ConfigDebugBeginReturnValueLoop);\n            ImGui::SameLine(); HelpMarker(\"Some calls to Begin()/BeginChild() will return false.\\n\\nWill cycle through window depths then repeat. Windows should be flickering while running.\");\n            ImGui::Checkbox(\"io.ConfigDebugIgnoreFocusLoss\", &io.ConfigDebugIgnoreFocusLoss);\n            ImGui::SameLine(); HelpMarker(\"Option to deactivate io.AddFocusEvent(false) handling. May facilitate interactions with a debugger when focus loss leads to clearing inputs data.\");\n            ImGui::Checkbox(\"io.ConfigDebugIniSettings\", &io.ConfigDebugIniSettings);\n            ImGui::SameLine(); HelpMarker(\"Option to save .ini data with extra comments (particularly helpful for Docking, but makes saving slower).\");\n\n            ImGui::TreePop();\n            ImGui::Spacing();\n        }\n\n        IMGUI_DEMO_MARKER(\"Configuration/Backend Flags\");\n        if (ImGui::TreeNode(\"Backend Flags\"))\n        {\n            HelpMarker(\n                \"Those flags are set by the backends (imgui_impl_xxx files) to specify their capabilities.\\n\"\n                \"Here we expose them as read-only fields to avoid breaking interactions with your backend.\");\n\n            // FIXME: Maybe we need a BeginReadonly() equivalent to keep label bright?\n            ImGui::BeginDisabled();\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasGamepad\",           &io.BackendFlags, ImGuiBackendFlags_HasGamepad);\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasMouseCursors\",      &io.BackendFlags, ImGuiBackendFlags_HasMouseCursors);\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasSetMousePos\",       &io.BackendFlags, ImGuiBackendFlags_HasSetMousePos);\n            ImGui::CheckboxFlags(\"io.BackendFlags: RendererHasVtxOffset\", &io.BackendFlags, ImGuiBackendFlags_RendererHasVtxOffset);\n            ImGui::EndDisabled();\n\n            ImGui::TreePop();\n            ImGui::Spacing();\n        }\n\n        IMGUI_DEMO_MARKER(\"Configuration/Style\");\n        if (ImGui::TreeNode(\"Style\"))\n        {\n            ImGui::Checkbox(\"Style Editor\", &demo_data.ShowStyleEditor);\n            ImGui::SameLine();\n            HelpMarker(\"The same contents can be accessed in 'Tools->Style Editor' or by calling the ShowStyleEditor() function.\");\n            ImGui::TreePop();\n            ImGui::Spacing();\n        }\n\n        IMGUI_DEMO_MARKER(\"Configuration/Capture, Logging\");\n        if (ImGui::TreeNode(\"Capture/Logging\"))\n        {\n            HelpMarker(\n                \"The logging API redirects all text output so you can easily capture the content of \"\n                \"a window or a block. Tree nodes can be automatically expanded.\\n\"\n                \"Try opening any of the contents below in this window and then click one of the \\\"Log To\\\" button.\");\n            ImGui::LogButtons();\n\n            HelpMarker(\"You can also call ImGui::LogText() to output directly to the log without a visual output.\");\n            if (ImGui::Button(\"Copy \\\"Hello, world!\\\" to clipboard\"))\n            {\n                ImGui::LogToClipboard();\n                ImGui::LogText(\"Hello, world!\");\n                ImGui::LogFinish();\n            }\n            ImGui::TreePop();\n        }\n    }\n\n    IMGUI_DEMO_MARKER(\"Window options\");\n    if (ImGui::CollapsingHeader(\"Window options\"))\n    {\n        if (ImGui::BeginTable(\"split\", 3))\n        {\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No titlebar\", &no_titlebar);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No scrollbar\", &no_scrollbar);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No menu\", &no_menu);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No move\", &no_move);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No resize\", &no_resize);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No collapse\", &no_collapse);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No close\", &no_close);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No nav\", &no_nav);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No background\", &no_background);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"No bring to front\", &no_bring_to_front);\n            ImGui::TableNextColumn(); ImGui::Checkbox(\"Unsaved document\", &unsaved_document);\n            ImGui::EndTable();\n        }\n    }\n\n    // All demo contents\n    ShowDemoWindowWidgets(&demo_data);\n    ShowDemoWindowLayout();\n    ShowDemoWindowPopups();\n    ShowDemoWindowTables();\n    ShowDemoWindowInputs();\n\n    // End of ShowDemoWindow()\n    ImGui::PopItemWidth();\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowMenuBar()\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowMenuBar(ImGuiDemoWindowData* demo_data)\n{\n    IMGUI_DEMO_MARKER(\"Menu\");\n    if (ImGui::BeginMenuBar())\n    {\n        if (ImGui::BeginMenu(\"Menu\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu/File\");\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        if (ImGui::BeginMenu(\"Examples\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu/Examples\");\n            ImGui::MenuItem(\"Main menu bar\", NULL, &demo_data->ShowMainMenuBar);\n\n            ImGui::SeparatorText(\"Mini apps\");\n            ImGui::MenuItem(\"Assets Browser\", NULL, &demo_data->ShowAppAssetsBrowser);\n            ImGui::MenuItem(\"Console\", NULL, &demo_data->ShowAppConsole);\n            ImGui::MenuItem(\"Custom rendering\", NULL, &demo_data->ShowAppCustomRendering);\n            ImGui::MenuItem(\"Documents\", NULL, &demo_data->ShowAppDocuments);\n            ImGui::MenuItem(\"Log\", NULL, &demo_data->ShowAppLog);\n            ImGui::MenuItem(\"Property editor\", NULL, &demo_data->ShowAppPropertyEditor);\n            ImGui::MenuItem(\"Simple layout\", NULL, &demo_data->ShowAppLayout);\n            ImGui::MenuItem(\"Simple overlay\", NULL, &demo_data->ShowAppSimpleOverlay);\n\n            ImGui::SeparatorText(\"Concepts\");\n            ImGui::MenuItem(\"Auto-resizing window\", NULL, &demo_data->ShowAppAutoResize);\n            ImGui::MenuItem(\"Constrained-resizing window\", NULL, &demo_data->ShowAppConstrainedResize);\n            ImGui::MenuItem(\"Fullscreen window\", NULL, &demo_data->ShowAppFullscreen);\n            ImGui::MenuItem(\"Long text display\", NULL, &demo_data->ShowAppLongText);\n            ImGui::MenuItem(\"Manipulating window titles\", NULL, &demo_data->ShowAppWindowTitles);\n\n            ImGui::EndMenu();\n        }\n        //if (ImGui::MenuItem(\"MenuItem\")) {} // You can also use MenuItem() inside a menu bar!\n        if (ImGui::BeginMenu(\"Tools\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu/Tools\");\n            ImGuiIO& io = ImGui::GetIO();\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n            const bool has_debug_tools = true;\n#else\n            const bool has_debug_tools = false;\n#endif\n            ImGui::MenuItem(\"Metrics/Debugger\", NULL, &demo_data->ShowMetrics, has_debug_tools);\n            ImGui::MenuItem(\"Debug Log\", NULL, &demo_data->ShowDebugLog, has_debug_tools);\n            ImGui::MenuItem(\"ID Stack Tool\", NULL, &demo_data->ShowIDStackTool, has_debug_tools);\n            bool is_debugger_present = io.ConfigDebugIsDebuggerPresent;\n            if (ImGui::MenuItem(\"Item Picker\", NULL, false, has_debug_tools && is_debugger_present))\n                ImGui::DebugStartItemPicker();\n            if (!is_debugger_present)\n                ImGui::SetItemTooltip(\"Requires io.ConfigDebugIsDebuggerPresent=true to be set.\\n\\nWe otherwise disable the menu option to avoid casual users crashing the application.\\n\\nYou can however always access the Item Picker in Metrics->Tools.\");\n            ImGui::MenuItem(\"Style Editor\", NULL, &demo_data->ShowStyleEditor);\n            ImGui::MenuItem(\"About Dear ImGui\", NULL, &demo_data->ShowAbout);\n\n            ImGui::SeparatorText(\"Debug Options\");\n            ImGui::MenuItem(\"Highlight ID Conflicts\", NULL, &io.ConfigDebugHighlightIdConflicts, has_debug_tools);\n            ImGui::EndMenu();\n        }\n        ImGui::EndMenuBar();\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowWidgets()\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowWidgets(ImGuiDemoWindowData* demo_data)\n{\n    IMGUI_DEMO_MARKER(\"Widgets\");\n    //ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n    if (!ImGui::CollapsingHeader(\"Widgets\"))\n        return;\n\n    static bool disable_all = false; // The Checkbox for that is inside the \"Disabled\" section at the bottom\n    if (disable_all)\n        ImGui::BeginDisabled();\n\n    IMGUI_DEMO_MARKER(\"Widgets/Basic\");\n    if (ImGui::TreeNode(\"Basic\"))\n    {\n        ImGui::SeparatorText(\"General\");\n\n        IMGUI_DEMO_MARKER(\"Widgets/Basic/Button\");\n        static int clicked = 0;\n        if (ImGui::Button(\"Button\"))\n            clicked++;\n        if (clicked & 1)\n        {\n            ImGui::SameLine();\n            ImGui::Text(\"Thanks for clicking me!\");\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Basic/Checkbox\");\n        static bool check = true;\n        ImGui::Checkbox(\"checkbox\", &check);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Basic/RadioButton\");\n        static int e = 0;\n        ImGui::RadioButton(\"radio a\", &e, 0); ImGui::SameLine();\n        ImGui::RadioButton(\"radio b\", &e, 1); ImGui::SameLine();\n        ImGui::RadioButton(\"radio c\", &e, 2);\n\n        // Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.\n        IMGUI_DEMO_MARKER(\"Widgets/Basic/Buttons (Colored)\");\n        for (int i = 0; i < 7; i++)\n        {\n            if (i > 0)\n                ImGui::SameLine();\n            ImGui::PushID(i);\n            ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(i / 7.0f, 0.6f, 0.6f));\n            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(i / 7.0f, 0.7f, 0.7f));\n            ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(i / 7.0f, 0.8f, 0.8f));\n            ImGui::Button(\"Click\");\n            ImGui::PopStyleColor(3);\n            ImGui::PopID();\n        }\n\n        // Use AlignTextToFramePadding() to align text baseline to the baseline of framed widgets elements\n        // (otherwise a Text+SameLine+Button sequence will have the text a little too high by default!)\n        // See 'Demo->Layout->Text Baseline Alignment' for details.\n        ImGui::AlignTextToFramePadding();\n        ImGui::Text(\"Hold to repeat:\");\n        ImGui::SameLine();\n\n        // Arrow buttons with Repeater\n        IMGUI_DEMO_MARKER(\"Widgets/Basic/Buttons (Repeating)\");\n        static int counter = 0;\n        float spacing = ImGui::GetStyle().ItemInnerSpacing.x;\n        ImGui::PushItemFlag(ImGuiItemFlags_ButtonRepeat, true);\n        if (ImGui::ArrowButton(\"##left\", ImGuiDir_Left)) { counter--; }\n        ImGui::SameLine(0.0f, spacing);\n        if (ImGui::ArrowButton(\"##right\", ImGuiDir_Right)) { counter++; }\n        ImGui::PopItemFlag();\n        ImGui::SameLine();\n        ImGui::Text(\"%d\", counter);\n\n        ImGui::Button(\"Tooltip\");\n        ImGui::SetItemTooltip(\"I am a tooltip\");\n\n        ImGui::LabelText(\"label\", \"Value\");\n\n        ImGui::SeparatorText(\"Inputs\");\n\n        {\n            // To wire InputText() with std::string or any other custom string type,\n            // see the \"Text Input > Resize Callback\" section of this demo, and the misc/cpp/imgui_stdlib.h file.\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/InputText\");\n            static char str0[128] = \"Hello, world!\";\n            ImGui::InputText(\"input text\", str0, IM_ARRAYSIZE(str0));\n            ImGui::SameLine(); HelpMarker(\n                \"USER:\\n\"\n                \"Hold SHIFT or use mouse to select text.\\n\"\n                \"CTRL+Left/Right to word jump.\\n\"\n                \"CTRL+A or Double-Click to select all.\\n\"\n                \"CTRL+X,CTRL+C,CTRL+V clipboard.\\n\"\n                \"CTRL+Z,CTRL+Y undo/redo.\\n\"\n                \"ESCAPE to revert.\\n\\n\"\n                \"PROGRAMMER:\\n\"\n                \"You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputText() \"\n                \"to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated \"\n                \"in imgui_demo.cpp).\");\n\n            static char str1[128] = \"\";\n            ImGui::InputTextWithHint(\"input text (w/ hint)\", \"enter text here\", str1, IM_ARRAYSIZE(str1));\n\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/InputInt, InputFloat\");\n            static int i0 = 123;\n            ImGui::InputInt(\"input int\", &i0);\n\n            static float f0 = 0.001f;\n            ImGui::InputFloat(\"input float\", &f0, 0.01f, 1.0f, \"%.3f\");\n\n            static double d0 = 999999.00000001;\n            ImGui::InputDouble(\"input double\", &d0, 0.01f, 1.0f, \"%.8f\");\n\n            static float f1 = 1.e10f;\n            ImGui::InputFloat(\"input scientific\", &f1, 0.0f, 0.0f, \"%e\");\n            ImGui::SameLine(); HelpMarker(\n                \"You can input value using the scientific notation,\\n\"\n                \"  e.g. \\\"1e+8\\\" becomes \\\"100000000\\\".\");\n\n            static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };\n            ImGui::InputFloat3(\"input float3\", vec4a);\n        }\n\n        ImGui::SeparatorText(\"Drags\");\n\n        {\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/DragInt, DragFloat\");\n            static int i1 = 50, i2 = 42, i3 = 128;\n            ImGui::DragInt(\"drag int\", &i1, 1);\n            ImGui::SameLine(); HelpMarker(\n                \"Click and drag to edit value.\\n\"\n                \"Hold SHIFT/ALT for faster/slower edit.\\n\"\n                \"Double-click or CTRL+click to input value.\");\n            ImGui::DragInt(\"drag int 0..100\", &i2, 1, 0, 100, \"%d%%\", ImGuiSliderFlags_AlwaysClamp);\n            ImGui::DragInt(\"drag int wrap 100..200\", &i3, 1, 100, 200, \"%d\", ImGuiSliderFlags_WrapAround);\n\n            static float f1 = 1.00f, f2 = 0.0067f;\n            ImGui::DragFloat(\"drag float\", &f1, 0.005f);\n            ImGui::DragFloat(\"drag small float\", &f2, 0.0001f, 0.0f, 0.0f, \"%.06f ns\");\n            //ImGui::DragFloat(\"drag wrap -1..1\", &f3, 0.005f, -1.0f, 1.0f, NULL, ImGuiSliderFlags_WrapAround);\n        }\n\n        ImGui::SeparatorText(\"Sliders\");\n\n        {\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/SliderInt, SliderFloat\");\n            static int i1 = 0;\n            ImGui::SliderInt(\"slider int\", &i1, -1, 3);\n            ImGui::SameLine(); HelpMarker(\"CTRL+click to input value.\");\n\n            static float f1 = 0.123f, f2 = 0.0f;\n            ImGui::SliderFloat(\"slider float\", &f1, 0.0f, 1.0f, \"ratio = %.3f\");\n            ImGui::SliderFloat(\"slider float (log)\", &f2, -10.0f, 10.0f, \"%.4f\", ImGuiSliderFlags_Logarithmic);\n\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/SliderAngle\");\n            static float angle = 0.0f;\n            ImGui::SliderAngle(\"slider angle\", &angle);\n\n            // Using the format string to display a name instead of an integer.\n            // Here we completely omit '%d' from the format string, so it'll only display a name.\n            // This technique can also be used with DragInt().\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/Slider (enum)\");\n            enum Element { Element_Fire, Element_Earth, Element_Air, Element_Water, Element_COUNT };\n            static int elem = Element_Fire;\n            const char* elems_names[Element_COUNT] = { \"Fire\", \"Earth\", \"Air\", \"Water\" };\n            const char* elem_name = (elem >= 0 && elem < Element_COUNT) ? elems_names[elem] : \"Unknown\";\n            ImGui::SliderInt(\"slider enum\", &elem, 0, Element_COUNT - 1, elem_name); // Use ImGuiSliderFlags_NoInput flag to disable CTRL+Click here.\n            ImGui::SameLine(); HelpMarker(\"Using the format string parameter to display a name instead of the underlying integer.\");\n        }\n\n        ImGui::SeparatorText(\"Selectors/Pickers\");\n\n        {\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/ColorEdit3, ColorEdit4\");\n            static float col1[3] = { 1.0f, 0.0f, 0.2f };\n            static float col2[4] = { 0.4f, 0.7f, 0.0f, 0.5f };\n            ImGui::ColorEdit3(\"color 1\", col1);\n            ImGui::SameLine(); HelpMarker(\n                \"Click on the color square to open a color picker.\\n\"\n                \"Click and hold to use drag and drop.\\n\"\n                \"Right-click on the color square to show options.\\n\"\n                \"CTRL+click on individual component to input value.\\n\");\n\n            ImGui::ColorEdit4(\"color 2\", col2);\n        }\n\n        {\n            // Using the _simplified_ one-liner Combo() api here\n            // See \"Combo\" section for examples of how to use the more flexible BeginCombo()/EndCombo() api.\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/Combo\");\n            const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\", \"FFFF\", \"GGGG\", \"HHHH\", \"IIIIIII\", \"JJJJ\", \"KKKKKKK\" };\n            static int item_current = 0;\n            ImGui::Combo(\"combo\", &item_current, items, IM_ARRAYSIZE(items));\n            ImGui::SameLine(); HelpMarker(\n                \"Using the simplified one-liner Combo API here.\\n\"\n                \"Refer to the \\\"Combo\\\" section below for an explanation of how to use the more flexible and general BeginCombo/EndCombo API.\");\n        }\n\n        {\n            // Using the _simplified_ one-liner ListBox() api here\n            // See \"List boxes\" section for examples of how to use the more flexible BeginListBox()/EndListBox() api.\n            IMGUI_DEMO_MARKER(\"Widgets/Basic/ListBox\");\n            const char* items[] = { \"Apple\", \"Banana\", \"Cherry\", \"Kiwi\", \"Mango\", \"Orange\", \"Pineapple\", \"Strawberry\", \"Watermelon\" };\n            static int item_current = 1;\n            ImGui::ListBox(\"listbox\", &item_current, items, IM_ARRAYSIZE(items), 4);\n            ImGui::SameLine(); HelpMarker(\n                \"Using the simplified one-liner ListBox API here.\\n\"\n                \"Refer to the \\\"List boxes\\\" section below for an explanation of how to use the more flexible and general BeginListBox/EndListBox API.\");\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Tooltips\");\n    if (ImGui::TreeNode(\"Tooltips\"))\n    {\n        // Tooltips are windows following the mouse. They do not take focus away.\n        ImGui::SeparatorText(\"General\");\n\n        // Typical use cases:\n        // - Short-form (text only):      SetItemTooltip(\"Hello\");\n        // - Short-form (any contents):   if (BeginItemTooltip()) { Text(\"Hello\"); EndTooltip(); }\n\n        // - Full-form (text only):       if (IsItemHovered(...)) { SetTooltip(\"Hello\"); }\n        // - Full-form (any contents):    if (IsItemHovered(...) && BeginTooltip()) { Text(\"Hello\"); EndTooltip(); }\n\n        HelpMarker(\n            \"Tooltip are typically created by using a IsItemHovered() + SetTooltip() sequence.\\n\\n\"\n            \"We provide a helper SetItemTooltip() function to perform the two with standards flags.\");\n\n        ImVec2 sz = ImVec2(-FLT_MIN, 0.0f);\n\n        ImGui::Button(\"Basic\", sz);\n        ImGui::SetItemTooltip(\"I am a tooltip\");\n\n        ImGui::Button(\"Fancy\", sz);\n        if (ImGui::BeginItemTooltip())\n        {\n            ImGui::Text(\"I am a fancy tooltip\");\n            static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };\n            ImGui::PlotLines(\"Curve\", arr, IM_ARRAYSIZE(arr));\n            ImGui::Text(\"Sin(time) = %f\", sinf((float)ImGui::GetTime()));\n            ImGui::EndTooltip();\n        }\n\n        ImGui::SeparatorText(\"Always On\");\n\n        // Showcase NOT relying on a IsItemHovered() to emit a tooltip.\n        // Here the tooltip is always emitted when 'always_on == true'.\n        static int always_on = 0;\n        ImGui::RadioButton(\"Off\", &always_on, 0);\n        ImGui::SameLine();\n        ImGui::RadioButton(\"Always On (Simple)\", &always_on, 1);\n        ImGui::SameLine();\n        ImGui::RadioButton(\"Always On (Advanced)\", &always_on, 2);\n        if (always_on == 1)\n            ImGui::SetTooltip(\"I am following you around.\");\n        else if (always_on == 2 && ImGui::BeginTooltip())\n        {\n            ImGui::ProgressBar(sinf((float)ImGui::GetTime()) * 0.5f + 0.5f, ImVec2(ImGui::GetFontSize() * 25, 0.0f));\n            ImGui::EndTooltip();\n        }\n\n        ImGui::SeparatorText(\"Custom\");\n\n        HelpMarker(\n            \"Passing ImGuiHoveredFlags_ForTooltip to IsItemHovered() is the preferred way to standardize\"\n            \"tooltip activation details across your application. You may however decide to use custom\"\n            \"flags for a specific tooltip instance.\");\n\n        // The following examples are passed for documentation purpose but may not be useful to most users.\n        // Passing ImGuiHoveredFlags_ForTooltip to IsItemHovered() will pull ImGuiHoveredFlags flags values from\n        // 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' depending on whether mouse or keyboard/gamepad is being used.\n        // With default settings, ImGuiHoveredFlags_ForTooltip is equivalent to ImGuiHoveredFlags_DelayShort + ImGuiHoveredFlags_Stationary.\n        ImGui::Button(\"Manual\", sz);\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip))\n            ImGui::SetTooltip(\"I am a manually emitted tooltip.\");\n\n        ImGui::Button(\"DelayNone\", sz);\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayNone))\n            ImGui::SetTooltip(\"I am a tooltip with no delay.\");\n\n        ImGui::Button(\"DelayShort\", sz);\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_NoSharedDelay))\n            ImGui::SetTooltip(\"I am a tooltip with a short delay (%0.2f sec).\", ImGui::GetStyle().HoverDelayShort);\n\n        ImGui::Button(\"DelayLong\", sz);\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_NoSharedDelay))\n            ImGui::SetTooltip(\"I am a tooltip with a long delay (%0.2f sec).\", ImGui::GetStyle().HoverDelayNormal);\n\n        ImGui::Button(\"Stationary\", sz);\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_Stationary))\n            ImGui::SetTooltip(\"I am a tooltip requiring mouse to be stationary before activating.\");\n\n        // Using ImGuiHoveredFlags_ForTooltip will pull flags from 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav',\n        // which default value include the ImGuiHoveredFlags_AllowWhenDisabled flag.\n        ImGui::BeginDisabled();\n        ImGui::Button(\"Disabled item\", sz);\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip))\n            ImGui::SetTooltip(\"I am a a tooltip for a disabled item.\");\n        ImGui::EndDisabled();\n\n        ImGui::TreePop();\n    }\n\n    // Testing ImGuiOnceUponAFrame helper.\n    //static ImGuiOnceUponAFrame once;\n    //for (int i = 0; i < 5; i++)\n    //    if (once)\n    //        ImGui::Text(\"This will be displayed only once.\");\n\n    IMGUI_DEMO_MARKER(\"Widgets/Tree Nodes\");\n    if (ImGui::TreeNode(\"Tree Nodes\"))\n    {\n        IMGUI_DEMO_MARKER(\"Widgets/Tree Nodes/Basic trees\");\n        if (ImGui::TreeNode(\"Basic trees\"))\n        {\n            for (int i = 0; i < 5; i++)\n            {\n                // Use SetNextItemOpen() so set the default state of a node to be open. We could\n                // also use TreeNodeEx() with the ImGuiTreeNodeFlags_DefaultOpen flag to achieve the same thing!\n                if (i == 0)\n                    ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n\n                // Here we use PushID() to generate a unique base ID, and then the \"\" used as TreeNode id won't conflict.\n                // An alternative to using 'PushID() + TreeNode(\"\", ...)' to generate a unique ID is to use 'TreeNode((void*)(intptr_t)i, ...)',\n                // aka generate a dummy pointer-sized value to be hashed. The demo below uses that technique. Both are fine.\n                ImGui::PushID(i);\n                if (ImGui::TreeNode(\"\", \"Child %d\", i))\n                {\n                    ImGui::Text(\"blah blah\");\n                    ImGui::SameLine();\n                    if (ImGui::SmallButton(\"button\")) {}\n                    ImGui::TreePop();\n                }\n                ImGui::PopID();\n            }\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Tree Nodes/Advanced, with Selectable nodes\");\n        if (ImGui::TreeNode(\"Advanced, with Selectable nodes\"))\n        {\n            HelpMarker(\n                \"This is a more typical looking tree with selectable nodes.\\n\"\n                \"Click to select, CTRL+Click to toggle, click on arrows or double-click to open.\");\n            static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_SpanAvailWidth;\n            static bool align_label_with_current_x_position = false;\n            static bool test_drag_and_drop = false;\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_OpenOnArrow\",       &base_flags, ImGuiTreeNodeFlags_OpenOnArrow);\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_OpenOnDoubleClick\", &base_flags, ImGuiTreeNodeFlags_OpenOnDoubleClick);\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanAvailWidth\",    &base_flags, ImGuiTreeNodeFlags_SpanAvailWidth); ImGui::SameLine(); HelpMarker(\"Extend hit area to all available width instead of allowing more items to be laid out after the node.\");\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanFullWidth\",     &base_flags, ImGuiTreeNodeFlags_SpanFullWidth);\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanTextWidth\",     &base_flags, ImGuiTreeNodeFlags_SpanTextWidth); ImGui::SameLine(); HelpMarker(\"Reduce hit area to the text label and a bit of margin.\");\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanAllColumns\",    &base_flags, ImGuiTreeNodeFlags_SpanAllColumns); ImGui::SameLine(); HelpMarker(\"For use in Tables only.\");\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_AllowOverlap\",      &base_flags, ImGuiTreeNodeFlags_AllowOverlap);\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_Framed\",            &base_flags, ImGuiTreeNodeFlags_Framed); ImGui::SameLine(); HelpMarker(\"Draw frame with background (e.g. for CollapsingHeader)\");\n            ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_NavLeftJumpsBackHere\", &base_flags, ImGuiTreeNodeFlags_NavLeftJumpsBackHere);\n            ImGui::Checkbox(\"Align label with current X position\", &align_label_with_current_x_position);\n            ImGui::Checkbox(\"Test tree node as drag source\", &test_drag_and_drop);\n            ImGui::Text(\"Hello!\");\n            if (align_label_with_current_x_position)\n                ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());\n\n            // 'selection_mask' is dumb representation of what may be user-side selection state.\n            //  You may retain selection state inside or outside your objects in whatever format you see fit.\n            // 'node_clicked' is temporary storage of what node we have clicked to process selection at the end\n            /// of the loop. May be a pointer to your own node type, etc.\n            static int selection_mask = (1 << 2);\n            int node_clicked = -1;\n            for (int i = 0; i < 6; i++)\n            {\n                // Disable the default \"open on single-click behavior\" + set Selected flag according to our selection.\n                // To alter selection we use IsItemClicked() && !IsItemToggledOpen(), so clicking on an arrow doesn't alter selection.\n                ImGuiTreeNodeFlags node_flags = base_flags;\n                const bool is_selected = (selection_mask & (1 << i)) != 0;\n                if (is_selected)\n                    node_flags |= ImGuiTreeNodeFlags_Selected;\n                if (i < 3)\n                {\n                    // Items 0..2 are Tree Node\n                    bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, \"Selectable Node %d\", i);\n                    if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen())\n                        node_clicked = i;\n                    if (test_drag_and_drop && ImGui::BeginDragDropSource())\n                    {\n                        ImGui::SetDragDropPayload(\"_TREENODE\", NULL, 0);\n                        ImGui::Text(\"This is a drag and drop source\");\n                        ImGui::EndDragDropSource();\n                    }\n                    if (i == 2 && (base_flags & ImGuiTreeNodeFlags_SpanTextWidth))\n                    {\n                        // Item 2 has an additional inline button to help demonstrate SpanTextWidth.\n                        ImGui::SameLine();\n                        if (ImGui::SmallButton(\"button\")) {}\n                    }\n                    if (node_open)\n                    {\n                        ImGui::BulletText(\"Blah blah\\nBlah Blah\");\n                        ImGui::SameLine();\n                        ImGui::SmallButton(\"Button\");\n                        ImGui::TreePop();\n                    }\n                }\n                else\n                {\n                    // Items 3..5 are Tree Leaves\n                    // The only reason we use TreeNode at all is to allow selection of the leaf. Otherwise we can\n                    // use BulletText() or advance the cursor by GetTreeNodeToLabelSpacing() and call Text().\n                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet\n                    ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, \"Selectable Leaf %d\", i);\n                    if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen())\n                        node_clicked = i;\n                    if (test_drag_and_drop && ImGui::BeginDragDropSource())\n                    {\n                        ImGui::SetDragDropPayload(\"_TREENODE\", NULL, 0);\n                        ImGui::Text(\"This is a drag and drop source\");\n                        ImGui::EndDragDropSource();\n                    }\n                }\n            }\n            if (node_clicked != -1)\n            {\n                // Update selection state\n                // (process outside of tree loop to avoid visual inconsistencies during the clicking frame)\n                if (ImGui::GetIO().KeyCtrl)\n                    selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle\n                else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, may want to preserve selection when clicking on item that is part of the selection\n                    selection_mask = (1 << node_clicked);           // Click to single-select\n            }\n            if (align_label_with_current_x_position)\n                ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());\n            ImGui::TreePop();\n        }\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Collapsing Headers\");\n    if (ImGui::TreeNode(\"Collapsing Headers\"))\n    {\n        static bool closable_group = true;\n        ImGui::Checkbox(\"Show 2nd header\", &closable_group);\n        if (ImGui::CollapsingHeader(\"Header\", ImGuiTreeNodeFlags_None))\n        {\n            ImGui::Text(\"IsItemHovered: %d\", ImGui::IsItemHovered());\n            for (int i = 0; i < 5; i++)\n                ImGui::Text(\"Some content %d\", i);\n        }\n        if (ImGui::CollapsingHeader(\"Header with a close button\", &closable_group))\n        {\n            ImGui::Text(\"IsItemHovered: %d\", ImGui::IsItemHovered());\n            for (int i = 0; i < 5; i++)\n                ImGui::Text(\"More content %d\", i);\n        }\n        /*\n        if (ImGui::CollapsingHeader(\"Header with a bullet\", ImGuiTreeNodeFlags_Bullet))\n            ImGui::Text(\"IsItemHovered: %d\", ImGui::IsItemHovered());\n        */\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Bullets\");\n    if (ImGui::TreeNode(\"Bullets\"))\n    {\n        ImGui::BulletText(\"Bullet point 1\");\n        ImGui::BulletText(\"Bullet point 2\\nOn multiple lines\");\n        if (ImGui::TreeNode(\"Tree node\"))\n        {\n            ImGui::BulletText(\"Another bullet point\");\n            ImGui::TreePop();\n        }\n        ImGui::Bullet(); ImGui::Text(\"Bullet point 3 (two calls)\");\n        ImGui::Bullet(); ImGui::SmallButton(\"Button\");\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Text\");\n    if (ImGui::TreeNode(\"Text\"))\n    {\n        IMGUI_DEMO_MARKER(\"Widgets/Text/Colored Text\");\n        if (ImGui::TreeNode(\"Colorful Text\"))\n        {\n            // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.\n            ImGui::TextColored(ImVec4(1.0f, 0.0f, 1.0f, 1.0f), \"Pink\");\n            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), \"Yellow\");\n            ImGui::TextDisabled(\"Disabled\");\n            ImGui::SameLine(); HelpMarker(\"The TextDisabled color is stored in ImGuiStyle.\");\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text/Word Wrapping\");\n        if (ImGui::TreeNode(\"Word Wrapping\"))\n        {\n            // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.\n            ImGui::TextWrapped(\n                \"This text should automatically wrap on the edge of the window. The current implementation \"\n                \"for text wrapping follows simple rules suitable for English and possibly other languages.\");\n            ImGui::Spacing();\n\n            static float wrap_width = 200.0f;\n            ImGui::SliderFloat(\"Wrap width\", &wrap_width, -20, 600, \"%.0f\");\n\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            for (int n = 0; n < 2; n++)\n            {\n                ImGui::Text(\"Test paragraph %d:\", n);\n                ImVec2 pos = ImGui::GetCursorScreenPos();\n                ImVec2 marker_min = ImVec2(pos.x + wrap_width, pos.y);\n                ImVec2 marker_max = ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight());\n                ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);\n                if (n == 0)\n                    ImGui::Text(\"The lazy dog is a good dog. This paragraph should fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.\", wrap_width);\n                else\n                    ImGui::Text(\"aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh\");\n\n                // Draw actual text bounding box, following by marker of our expected limit (should not overlap!)\n                draw_list->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255, 255, 0, 255));\n                draw_list->AddRectFilled(marker_min, marker_max, IM_COL32(255, 0, 255, 255));\n                ImGui::PopTextWrapPos();\n            }\n\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text/UTF-8 Text\");\n        if (ImGui::TreeNode(\"UTF-8 Text\"))\n        {\n            // UTF-8 test with Japanese characters\n            // (Needs a suitable font? Try \"Google Noto\" or \"Arial Unicode\". See docs/FONTS.md for details.)\n            // - From C++11 you can use the u8\"my text\" syntax to encode literal strings as UTF-8\n            // - For earlier compiler, you may be able to encode your sources as UTF-8 (e.g. in Visual Studio, you\n            //   can save your source files as 'UTF-8 without signature').\n            // - FOR THIS DEMO FILE ONLY, BECAUSE WE WANT TO SUPPORT OLD COMPILERS, WE ARE *NOT* INCLUDING RAW UTF-8\n            //   CHARACTERS IN THIS SOURCE FILE. Instead we are encoding a few strings with hexadecimal constants.\n            //   Don't do this in your application! Please use u8\"text in any language\" in your application!\n            // Note that characters values are preserved even by InputText() if the font cannot be displayed,\n            // so you can safely copy & paste garbled characters into another application.\n            ImGui::TextWrapped(\n                \"CJK text will only appear if the font was loaded with the appropriate CJK character ranges. \"\n                \"Call io.Fonts->AddFontFromFileTTF() manually to load extra character ranges. \"\n                \"Read docs/FONTS.md for details.\");\n            ImGui::Text(\"Hiragana: \\xe3\\x81\\x8b\\xe3\\x81\\x8d\\xe3\\x81\\x8f\\xe3\\x81\\x91\\xe3\\x81\\x93 (kakikukeko)\");\n            ImGui::Text(\"Kanjis: \\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e (nihongo)\");\n            static char buf[32] = \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\";\n            //static char buf[32] = u8\"NIHONGO\"; // <- this is how you would write it with C++11, using real kanjis\n            ImGui::InputText(\"UTF-8 input\", buf, IM_ARRAYSIZE(buf));\n            ImGui::TreePop();\n        }\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Images\");\n    if (ImGui::TreeNode(\"Images\"))\n    {\n        ImGuiIO& io = ImGui::GetIO();\n        ImGui::TextWrapped(\n            \"Below we are displaying the font texture (which is the only texture we have access to in this demo). \"\n            \"Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. \"\n            \"Hover the texture for a zoomed view!\");\n\n        // Below we are displaying the font texture because it is the only texture we have access to inside the demo!\n        // Remember that ImTextureID is just storage for whatever you want it to be. It is essentially a value that\n        // will be passed to the rendering backend via the ImDrawCmd structure.\n        // If you use one of the default imgui_impl_XXXX.cpp rendering backend, they all have comments at the top\n        // of their respective source file to specify what they expect to be stored in ImTextureID, for example:\n        // - The imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer\n        // - The imgui_impl_opengl3.cpp renderer expect a GLuint OpenGL texture identifier, etc.\n        // More:\n        // - If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers\n        //   to ImGui::Image(), and gather width/height through your own functions, etc.\n        // - You can use ShowMetricsWindow() to inspect the draw data that are being passed to your renderer,\n        //   it will help you debug issues if you are confused about it.\n        // - Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().\n        // - Read https://github.com/ocornut/imgui/blob/master/docs/FAQ.md\n        // - Read https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples\n        ImTextureID my_tex_id = io.Fonts->TexID;\n        float my_tex_w = (float)io.Fonts->TexWidth;\n        float my_tex_h = (float)io.Fonts->TexHeight;\n        {\n            static bool use_text_color_for_tint = false;\n            ImGui::Checkbox(\"Use Text Color for Tint\", &use_text_color_for_tint);\n            ImGui::Text(\"%.0fx%.0f\", my_tex_w, my_tex_h);\n            ImVec2 pos = ImGui::GetCursorScreenPos();\n            ImVec2 uv_min = ImVec2(0.0f, 0.0f);                 // Top-left\n            ImVec2 uv_max = ImVec2(1.0f, 1.0f);                 // Lower-right\n            ImVec4 tint_col = use_text_color_for_tint ? ImGui::GetStyleColorVec4(ImGuiCol_Text) : ImVec4(1.0f, 1.0f, 1.0f, 1.0f); // No tint\n            ImVec4 border_col = ImGui::GetStyleColorVec4(ImGuiCol_Border);\n            ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), uv_min, uv_max, tint_col, border_col);\n            if (ImGui::BeginItemTooltip())\n            {\n                float region_sz = 32.0f;\n                float region_x = io.MousePos.x - pos.x - region_sz * 0.5f;\n                float region_y = io.MousePos.y - pos.y - region_sz * 0.5f;\n                float zoom = 4.0f;\n                if (region_x < 0.0f) { region_x = 0.0f; }\n                else if (region_x > my_tex_w - region_sz) { region_x = my_tex_w - region_sz; }\n                if (region_y < 0.0f) { region_y = 0.0f; }\n                else if (region_y > my_tex_h - region_sz) { region_y = my_tex_h - region_sz; }\n                ImGui::Text(\"Min: (%.2f, %.2f)\", region_x, region_y);\n                ImGui::Text(\"Max: (%.2f, %.2f)\", region_x + region_sz, region_y + region_sz);\n                ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);\n                ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);\n                ImGui::Image(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, tint_col, border_col);\n                ImGui::EndTooltip();\n            }\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Images/Textured buttons\");\n        ImGui::TextWrapped(\"And now some textured buttons..\");\n        static int pressed_count = 0;\n        for (int i = 0; i < 8; i++)\n        {\n            // UV coordinates are often (0.0f, 0.0f) and (1.0f, 1.0f) to display an entire textures.\n            // Here are trying to display only a 32x32 pixels area of the texture, hence the UV computation.\n            // Read about UV coordinates here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples\n            ImGui::PushID(i);\n            if (i > 0)\n                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(i - 1.0f, i - 1.0f));\n            ImVec2 size = ImVec2(32.0f, 32.0f);                         // Size of the image we want to make visible\n            ImVec2 uv0 = ImVec2(0.0f, 0.0f);                            // UV coordinates for lower-left\n            ImVec2 uv1 = ImVec2(32.0f / my_tex_w, 32.0f / my_tex_h);    // UV coordinates for (32,32) in our texture\n            ImVec4 bg_col = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);             // Black background\n            ImVec4 tint_col = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);           // No tint\n            if (ImGui::ImageButton(\"\", my_tex_id, size, uv0, uv1, bg_col, tint_col))\n                pressed_count += 1;\n            if (i > 0)\n                ImGui::PopStyleVar();\n            ImGui::PopID();\n            ImGui::SameLine();\n        }\n        ImGui::NewLine();\n        ImGui::Text(\"Pressed %d times.\", pressed_count);\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Combo\");\n    if (ImGui::TreeNode(\"Combo\"))\n    {\n        // Combo Boxes are also called \"Dropdown\" in other systems\n        // Expose flags as checkbox for the demo\n        static ImGuiComboFlags flags = 0;\n        ImGui::CheckboxFlags(\"ImGuiComboFlags_PopupAlignLeft\", &flags, ImGuiComboFlags_PopupAlignLeft);\n        ImGui::SameLine(); HelpMarker(\"Only makes a difference if the popup is larger than the combo\");\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_NoArrowButton\", &flags, ImGuiComboFlags_NoArrowButton))\n            flags &= ~ImGuiComboFlags_NoPreview;     // Clear incompatible flags\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_NoPreview\", &flags, ImGuiComboFlags_NoPreview))\n            flags &= ~(ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_WidthFitPreview); // Clear incompatible flags\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_WidthFitPreview\", &flags, ImGuiComboFlags_WidthFitPreview))\n            flags &= ~ImGuiComboFlags_NoPreview;\n\n        // Override default popup height\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_HeightSmall\", &flags, ImGuiComboFlags_HeightSmall))\n            flags &= ~(ImGuiComboFlags_HeightMask_ & ~ImGuiComboFlags_HeightSmall);\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_HeightRegular\", &flags, ImGuiComboFlags_HeightRegular))\n            flags &= ~(ImGuiComboFlags_HeightMask_ & ~ImGuiComboFlags_HeightRegular);\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_HeightLargest\", &flags, ImGuiComboFlags_HeightLargest))\n            flags &= ~(ImGuiComboFlags_HeightMask_ & ~ImGuiComboFlags_HeightLargest);\n\n        // Using the generic BeginCombo() API, you have full control over how to display the combo contents.\n        // (your selection data could be an index, a pointer to the object, an id for the object, a flag intrusively\n        // stored in the object itself, etc.)\n        const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\", \"FFFF\", \"GGGG\", \"HHHH\", \"IIII\", \"JJJJ\", \"KKKK\", \"LLLLLLL\", \"MMMM\", \"OOOOOOO\" };\n        static int item_selected_idx = 0; // Here we store our selection data as an index.\n\n        // Pass in the preview value visible before opening the combo (it could technically be different contents or not pulled from items[])\n        const char* combo_preview_value = items[item_selected_idx];\n\n        if (ImGui::BeginCombo(\"combo 1\", combo_preview_value, flags))\n        {\n            for (int n = 0; n < IM_ARRAYSIZE(items); n++)\n            {\n                const bool is_selected = (item_selected_idx == n);\n                if (ImGui::Selectable(items[n], is_selected))\n                    item_selected_idx = n;\n\n                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)\n                if (is_selected)\n                    ImGui::SetItemDefaultFocus();\n            }\n            ImGui::EndCombo();\n        }\n\n        ImGui::Spacing();\n        ImGui::SeparatorText(\"One-liner variants\");\n        HelpMarker(\"Flags above don't apply to this section.\");\n\n        // Simplified one-liner Combo() API, using values packed in a single constant string\n        // This is a convenience for when the selection set is small and known at compile-time.\n        static int item_current_2 = 0;\n        ImGui::Combo(\"combo 2 (one-liner)\", &item_current_2, \"aaaa\\0bbbb\\0cccc\\0dddd\\0eeee\\0\\0\");\n\n        // Simplified one-liner Combo() using an array of const char*\n        // This is not very useful (may obsolete): prefer using BeginCombo()/EndCombo() for full control.\n        static int item_current_3 = -1; // If the selection isn't within 0..count, Combo won't display a preview\n        ImGui::Combo(\"combo 3 (array)\", &item_current_3, items, IM_ARRAYSIZE(items));\n\n        // Simplified one-liner Combo() using an accessor function\n        static int item_current_4 = 0;\n        ImGui::Combo(\"combo 4 (function)\", &item_current_4, [](void* data, int n) { return ((const char**)data)[n]; }, items, IM_ARRAYSIZE(items));\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/List Boxes\");\n    if (ImGui::TreeNode(\"List boxes\"))\n    {\n        // BeginListBox() is essentially a thin wrapper to using BeginChild()/EndChild()\n        // using the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.\n        // You may be tempted to simply use BeginChild() directly. However note that BeginChild() requires EndChild()\n        // to always be called (inconsistent with BeginListBox()/EndListBox()).\n\n        // Using the generic BeginListBox() API, you have full control over how to display the combo contents.\n        // (your selection data could be an index, a pointer to the object, an id for the object, a flag intrusively\n        // stored in the object itself, etc.)\n        const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\", \"FFFF\", \"GGGG\", \"HHHH\", \"IIII\", \"JJJJ\", \"KKKK\", \"LLLLLLL\", \"MMMM\", \"OOOOOOO\" };\n        static int item_selected_idx = 0; // Here we store our selected data as an index.\n\n        static bool item_highlight = false;\n        int item_highlighted_idx = -1; // Here we store our highlighted data as an index.\n        ImGui::Checkbox(\"Highlight hovered item in second listbox\", &item_highlight);\n\n        if (ImGui::BeginListBox(\"listbox 1\"))\n        {\n            for (int n = 0; n < IM_ARRAYSIZE(items); n++)\n            {\n                const bool is_selected = (item_selected_idx == n);\n                if (ImGui::Selectable(items[n], is_selected))\n                    item_selected_idx = n;\n\n                if (item_highlight && ImGui::IsItemHovered())\n                    item_highlighted_idx = n;\n\n                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)\n                if (is_selected)\n                    ImGui::SetItemDefaultFocus();\n            }\n            ImGui::EndListBox();\n        }\n        ImGui::SameLine(); HelpMarker(\"Here we are sharing selection state between both boxes.\");\n\n        // Custom size: use all width, 5 items tall\n        ImGui::Text(\"Full-width:\");\n        if (ImGui::BeginListBox(\"##listbox 2\", ImVec2(-FLT_MIN, 5 * ImGui::GetTextLineHeightWithSpacing())))\n        {\n            for (int n = 0; n < IM_ARRAYSIZE(items); n++)\n            {\n                bool is_selected = (item_selected_idx == n);\n                ImGuiSelectableFlags flags = (item_highlighted_idx == n) ? ImGuiSelectableFlags_Highlight : 0;\n                if (ImGui::Selectable(items[n], is_selected, flags))\n                    item_selected_idx = n;\n\n                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)\n                if (is_selected)\n                    ImGui::SetItemDefaultFocus();\n            }\n            ImGui::EndListBox();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Selectables\");\n    //ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n    if (ImGui::TreeNode(\"Selectables\"))\n    {\n        // Selectable() has 2 overloads:\n        // - The one taking \"bool selected\" as a read-only selection information.\n        //   When Selectable() has been clicked it returns true and you can alter selection state accordingly.\n        // - The one taking \"bool* p_selected\" as a read-write selection information (convenient in some cases)\n        // The earlier is more flexible, as in real application your selection may be stored in many different ways\n        // and not necessarily inside a bool value (e.g. in flags within objects, as an external list, etc).\n        IMGUI_DEMO_MARKER(\"Widgets/Selectables/Basic\");\n        if (ImGui::TreeNode(\"Basic\"))\n        {\n            static bool selection[5] = { false, true, false, false };\n            ImGui::Selectable(\"1. I am selectable\", &selection[0]);\n            ImGui::Selectable(\"2. I am selectable\", &selection[1]);\n            ImGui::Selectable(\"3. I am selectable\", &selection[2]);\n            if (ImGui::Selectable(\"4. I am double clickable\", selection[3], ImGuiSelectableFlags_AllowDoubleClick))\n                if (ImGui::IsMouseDoubleClicked(0))\n                    selection[3] = !selection[3];\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Selectables/Rendering more items on the same line\");\n        if (ImGui::TreeNode(\"Rendering more items on the same line\"))\n        {\n            // (1) Using SetNextItemAllowOverlap()\n            // (2) Using the Selectable() override that takes \"bool* p_selected\" parameter, the bool value is toggled automatically.\n            static bool selected[3] = { false, false, false };\n            ImGui::SetNextItemAllowOverlap(); ImGui::Selectable(\"main.c\",    &selected[0]); ImGui::SameLine(); ImGui::SmallButton(\"Link 1\");\n            ImGui::SetNextItemAllowOverlap(); ImGui::Selectable(\"Hello.cpp\", &selected[1]); ImGui::SameLine(); ImGui::SmallButton(\"Link 2\");\n            ImGui::SetNextItemAllowOverlap(); ImGui::Selectable(\"Hello.h\",   &selected[2]); ImGui::SameLine(); ImGui::SmallButton(\"Link 3\");\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Selectables/In Tables\");\n        if (ImGui::TreeNode(\"In Tables\"))\n        {\n            static bool selected[10] = {};\n\n            if (ImGui::BeginTable(\"split1\", 3, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_Borders))\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    char label[32];\n                    sprintf(label, \"Item %d\", i);\n                    ImGui::TableNextColumn();\n                    ImGui::Selectable(label, &selected[i]); // FIXME-TABLE: Selection overlap\n                }\n                ImGui::EndTable();\n            }\n            ImGui::Spacing();\n            if (ImGui::BeginTable(\"split2\", 3, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_Borders))\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    char label[32];\n                    sprintf(label, \"Item %d\", i);\n                    ImGui::TableNextRow();\n                    ImGui::TableNextColumn();\n                    ImGui::Selectable(label, &selected[i], ImGuiSelectableFlags_SpanAllColumns);\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"Some other contents\");\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"123456\");\n                }\n                ImGui::EndTable();\n            }\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Selectables/Grid\");\n        if (ImGui::TreeNode(\"Grid\"))\n        {\n            static char selected[4][4] = { { 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 1 } };\n\n            // Add in a bit of silly fun...\n            const float time = (float)ImGui::GetTime();\n            const bool winning_state = memchr(selected, 0, sizeof(selected)) == NULL; // If all cells are selected...\n            if (winning_state)\n                ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, ImVec2(0.5f + 0.5f * cosf(time * 2.0f), 0.5f + 0.5f * sinf(time * 3.0f)));\n\n            for (int y = 0; y < 4; y++)\n                for (int x = 0; x < 4; x++)\n                {\n                    if (x > 0)\n                        ImGui::SameLine();\n                    ImGui::PushID(y * 4 + x);\n                    if (ImGui::Selectable(\"Sailor\", selected[y][x] != 0, 0, ImVec2(50, 50)))\n                    {\n                        // Toggle clicked cell + toggle neighbors\n                        selected[y][x] ^= 1;\n                        if (x > 0) { selected[y][x - 1] ^= 1; }\n                        if (x < 3) { selected[y][x + 1] ^= 1; }\n                        if (y > 0) { selected[y - 1][x] ^= 1; }\n                        if (y < 3) { selected[y + 1][x] ^= 1; }\n                    }\n                    ImGui::PopID();\n                }\n\n            if (winning_state)\n                ImGui::PopStyleVar();\n            ImGui::TreePop();\n        }\n        IMGUI_DEMO_MARKER(\"Widgets/Selectables/Alignment\");\n        if (ImGui::TreeNode(\"Alignment\"))\n        {\n            HelpMarker(\n                \"By default, Selectables uses style.SelectableTextAlign but it can be overridden on a per-item \"\n                \"basis using PushStyleVar(). You'll probably want to always keep your default situation to \"\n                \"left-align otherwise it becomes difficult to layout multiple items on a same line\");\n            static bool selected[3 * 3] = { true, false, true, false, true, false, true, false, true };\n            for (int y = 0; y < 3; y++)\n            {\n                for (int x = 0; x < 3; x++)\n                {\n                    ImVec2 alignment = ImVec2((float)x / 2.0f, (float)y / 2.0f);\n                    char name[32];\n                    sprintf(name, \"(%.1f,%.1f)\", alignment.x, alignment.y);\n                    if (x > 0) ImGui::SameLine();\n                    ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, alignment);\n                    ImGui::Selectable(name, &selected[3 * y + x], ImGuiSelectableFlags_None, ImVec2(80, 80));\n                    ImGui::PopStyleVar();\n                }\n            }\n            ImGui::TreePop();\n        }\n        ImGui::TreePop();\n    }\n\n    ShowDemoWindowMultiSelect(demo_data);\n\n    // To wire InputText() with std::string or any other custom string type,\n    // see the \"Text Input > Resize Callback\" section of this demo, and the misc/cpp/imgui_stdlib.h file.\n    IMGUI_DEMO_MARKER(\"Widgets/Text Input\");\n    if (ImGui::TreeNode(\"Text Input\"))\n    {\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Multi-line Text Input\");\n        if (ImGui::TreeNode(\"Multi-line Text Input\"))\n        {\n            // Note: we are using a fixed-sized buffer for simplicity here. See ImGuiInputTextFlags_CallbackResize\n            // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.\n            static char text[1024 * 16] =\n                \"/*\\n\"\n                \" The Pentium F00F bug, shorthand for F0 0F C7 C8,\\n\"\n                \" the hexadecimal encoding of one offending instruction,\\n\"\n                \" more formally, the invalid operand with locked CMPXCHG8B\\n\"\n                \" instruction bug, is a design flaw in the majority of\\n\"\n                \" Intel Pentium, Pentium MMX, and Pentium OverDrive\\n\"\n                \" processors (all in the P5 microarchitecture).\\n\"\n                \"*/\\n\\n\"\n                \"label:\\n\"\n                \"\\tlock cmpxchg8b eax\\n\";\n\n            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput;\n            HelpMarker(\"You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp because we don't want to include <string> in here)\");\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_ReadOnly\", &flags, ImGuiInputTextFlags_ReadOnly);\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_AllowTabInput\", &flags, ImGuiInputTextFlags_AllowTabInput);\n            ImGui::SameLine(); HelpMarker(\"When _AllowTabInput is set, passing through the widget with Tabbing doesn't automatically activate it, in order to also cycling through subsequent widgets.\");\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_CtrlEnterForNewLine\", &flags, ImGuiInputTextFlags_CtrlEnterForNewLine);\n            ImGui::InputTextMultiline(\"##source\", text, IM_ARRAYSIZE(text), ImVec2(-FLT_MIN, ImGui::GetTextLineHeight() * 16), flags);\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Filtered Text Input\");\n        if (ImGui::TreeNode(\"Filtered Text Input\"))\n        {\n            struct TextFilters\n            {\n                // Modify character input by altering 'data->Eventchar' (ImGuiInputTextFlags_CallbackCharFilter callback)\n                static int FilterCasingSwap(ImGuiInputTextCallbackData* data)\n                {\n                    if (data->EventChar >= 'a' && data->EventChar <= 'z')       { data->EventChar -= 'a' - 'A'; } // Lowercase becomes uppercase\n                    else if (data->EventChar >= 'A' && data->EventChar <= 'Z')  { data->EventChar += 'a' - 'A'; } // Uppercase becomes lowercase\n                    return 0;\n                }\n\n                // Return 0 (pass) if the character is 'i' or 'm' or 'g' or 'u' or 'i', otherwise return 1 (filter out)\n                static int FilterImGuiLetters(ImGuiInputTextCallbackData* data)\n                {\n                    if (data->EventChar < 256 && strchr(\"imgui\", (char)data->EventChar))\n                        return 0;\n                    return 1;\n                }\n            };\n\n            static char buf1[32] = \"\"; ImGui::InputText(\"default\",     buf1, 32);\n            static char buf2[32] = \"\"; ImGui::InputText(\"decimal\",     buf2, 32, ImGuiInputTextFlags_CharsDecimal);\n            static char buf3[32] = \"\"; ImGui::InputText(\"hexadecimal\", buf3, 32, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);\n            static char buf4[32] = \"\"; ImGui::InputText(\"uppercase\",   buf4, 32, ImGuiInputTextFlags_CharsUppercase);\n            static char buf5[32] = \"\"; ImGui::InputText(\"no blank\",    buf5, 32, ImGuiInputTextFlags_CharsNoBlank);\n            static char buf6[32] = \"\"; ImGui::InputText(\"casing swap\", buf6, 32, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterCasingSwap); // Use CharFilter callback to replace characters.\n            static char buf7[32] = \"\"; ImGui::InputText(\"\\\"imgui\\\"\",   buf7, 32, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters); // Use CharFilter callback to disable some characters.\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Password input\");\n        if (ImGui::TreeNode(\"Password Input\"))\n        {\n            static char password[64] = \"password123\";\n            ImGui::InputText(\"password\", password, IM_ARRAYSIZE(password), ImGuiInputTextFlags_Password);\n            ImGui::SameLine(); HelpMarker(\"Display all characters as '*'.\\nDisable clipboard cut and copy.\\nDisable logging.\\n\");\n            ImGui::InputTextWithHint(\"password (w/ hint)\", \"<password>\", password, IM_ARRAYSIZE(password), ImGuiInputTextFlags_Password);\n            ImGui::InputText(\"password (clear)\", password, IM_ARRAYSIZE(password));\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Completion, History, Edit Callbacks\");\n        if (ImGui::TreeNode(\"Completion, History, Edit Callbacks\"))\n        {\n            struct Funcs\n            {\n                static int MyCallback(ImGuiInputTextCallbackData* data)\n                {\n                    if (data->EventFlag == ImGuiInputTextFlags_CallbackCompletion)\n                    {\n                        data->InsertChars(data->CursorPos, \"..\");\n                    }\n                    else if (data->EventFlag == ImGuiInputTextFlags_CallbackHistory)\n                    {\n                        if (data->EventKey == ImGuiKey_UpArrow)\n                        {\n                            data->DeleteChars(0, data->BufTextLen);\n                            data->InsertChars(0, \"Pressed Up!\");\n                            data->SelectAll();\n                        }\n                        else if (data->EventKey == ImGuiKey_DownArrow)\n                        {\n                            data->DeleteChars(0, data->BufTextLen);\n                            data->InsertChars(0, \"Pressed Down!\");\n                            data->SelectAll();\n                        }\n                    }\n                    else if (data->EventFlag == ImGuiInputTextFlags_CallbackEdit)\n                    {\n                        // Toggle casing of first character\n                        char c = data->Buf[0];\n                        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) data->Buf[0] ^= 32;\n                        data->BufDirty = true;\n\n                        // Increment a counter\n                        int* p_int = (int*)data->UserData;\n                        *p_int = *p_int + 1;\n                    }\n                    return 0;\n                }\n            };\n            static char buf1[64];\n            ImGui::InputText(\"Completion\", buf1, 64, ImGuiInputTextFlags_CallbackCompletion, Funcs::MyCallback);\n            ImGui::SameLine(); HelpMarker(\n                \"Here we append \\\"..\\\" each time Tab is pressed. \"\n                \"See 'Examples>Console' for a more meaningful demonstration of using this callback.\");\n\n            static char buf2[64];\n            ImGui::InputText(\"History\", buf2, 64, ImGuiInputTextFlags_CallbackHistory, Funcs::MyCallback);\n            ImGui::SameLine(); HelpMarker(\n                \"Here we replace and select text each time Up/Down are pressed. \"\n                \"See 'Examples>Console' for a more meaningful demonstration of using this callback.\");\n\n            static char buf3[64];\n            static int edit_count = 0;\n            ImGui::InputText(\"Edit\", buf3, 64, ImGuiInputTextFlags_CallbackEdit, Funcs::MyCallback, (void*)&edit_count);\n            ImGui::SameLine(); HelpMarker(\n                \"Here we toggle the casing of the first character on every edit + count edits.\");\n            ImGui::SameLine(); ImGui::Text(\"(%d)\", edit_count);\n\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Resize Callback\");\n        if (ImGui::TreeNode(\"Resize Callback\"))\n        {\n            // To wire InputText() with std::string or any other custom string type,\n            // you can use the ImGuiInputTextFlags_CallbackResize flag + create a custom ImGui::InputText() wrapper\n            // using your preferred type. See misc/cpp/imgui_stdlib.h for an implementation of this using std::string.\n            HelpMarker(\n                \"Using ImGuiInputTextFlags_CallbackResize to wire your custom string type to InputText().\\n\\n\"\n                \"See misc/cpp/imgui_stdlib.h for an implementation of this for std::string.\");\n            struct Funcs\n            {\n                static int MyResizeCallback(ImGuiInputTextCallbackData* data)\n                {\n                    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)\n                    {\n                        ImVector<char>* my_str = (ImVector<char>*)data->UserData;\n                        IM_ASSERT(my_str->begin() == data->Buf);\n                        my_str->resize(data->BufSize); // NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1\n                        data->Buf = my_str->begin();\n                    }\n                    return 0;\n                }\n\n                // Note: Because ImGui:: is a namespace you would typically add your own function into the namespace.\n                // For example, you code may declare a function 'ImGui::InputText(const char* label, MyString* my_str)'\n                static bool MyInputTextMultiline(const char* label, ImVector<char>* my_str, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0)\n                {\n                    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n                    return ImGui::InputTextMultiline(label, my_str->begin(), (size_t)my_str->size(), size, flags | ImGuiInputTextFlags_CallbackResize, Funcs::MyResizeCallback, (void*)my_str);\n                }\n            };\n\n            // For this demo we are using ImVector as a string container.\n            // Note that because we need to store a terminating zero character, our size/capacity are 1 more\n            // than usually reported by a typical string class.\n            static ImVector<char> my_str;\n            if (my_str.empty())\n                my_str.push_back(0);\n            Funcs::MyInputTextMultiline(\"##MyStr\", &my_str, ImVec2(-FLT_MIN, ImGui::GetTextLineHeight() * 16));\n            ImGui::Text(\"Data: %p\\nSize: %d\\nCapacity: %d\", (void*)my_str.begin(), my_str.size(), my_str.capacity());\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Eliding, Alignment\");\n        if (ImGui::TreeNode(\"Eliding, Alignment\"))\n        {\n            static char buf1[128] = \"/path/to/some/folder/with/long/filename.cpp\";\n            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_ElideLeft;\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_ElideLeft\", &flags, ImGuiInputTextFlags_ElideLeft);\n            ImGui::InputText(\"Path\", buf1, IM_ARRAYSIZE(buf1), flags);\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Text Input/Miscellaneous\");\n        if (ImGui::TreeNode(\"Miscellaneous\"))\n        {\n            static char buf1[16];\n            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_EscapeClearsAll;\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_EscapeClearsAll\", &flags, ImGuiInputTextFlags_EscapeClearsAll);\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_ReadOnly\", &flags, ImGuiInputTextFlags_ReadOnly);\n            ImGui::CheckboxFlags(\"ImGuiInputTextFlags_NoUndoRedo\", &flags, ImGuiInputTextFlags_NoUndoRedo);\n            ImGui::InputText(\"Hello\", buf1, IM_ARRAYSIZE(buf1), flags);\n            ImGui::TreePop();\n        }\n\n        ImGui::TreePop();\n    }\n\n    // Tabs\n    IMGUI_DEMO_MARKER(\"Widgets/Tabs\");\n    if (ImGui::TreeNode(\"Tabs\"))\n    {\n        IMGUI_DEMO_MARKER(\"Widgets/Tabs/Basic\");\n        if (ImGui::TreeNode(\"Basic\"))\n        {\n            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;\n            if (ImGui::BeginTabBar(\"MyTabBar\", tab_bar_flags))\n            {\n                if (ImGui::BeginTabItem(\"Avocado\"))\n                {\n                    ImGui::Text(\"This is the Avocado tab!\\nblah blah blah blah blah\");\n                    ImGui::EndTabItem();\n                }\n                if (ImGui::BeginTabItem(\"Broccoli\"))\n                {\n                    ImGui::Text(\"This is the Broccoli tab!\\nblah blah blah blah blah\");\n                    ImGui::EndTabItem();\n                }\n                if (ImGui::BeginTabItem(\"Cucumber\"))\n                {\n                    ImGui::Text(\"This is the Cucumber tab!\\nblah blah blah blah blah\");\n                    ImGui::EndTabItem();\n                }\n                ImGui::EndTabBar();\n            }\n            ImGui::Separator();\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Tabs/Advanced & Close Button\");\n        if (ImGui::TreeNode(\"Advanced & Close Button\"))\n        {\n            // Expose a couple of the available flags. In most cases you may just call BeginTabBar() with no flags (0).\n            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable;\n            ImGui::CheckboxFlags(\"ImGuiTabBarFlags_Reorderable\", &tab_bar_flags, ImGuiTabBarFlags_Reorderable);\n            ImGui::CheckboxFlags(\"ImGuiTabBarFlags_AutoSelectNewTabs\", &tab_bar_flags, ImGuiTabBarFlags_AutoSelectNewTabs);\n            ImGui::CheckboxFlags(\"ImGuiTabBarFlags_TabListPopupButton\", &tab_bar_flags, ImGuiTabBarFlags_TabListPopupButton);\n            ImGui::CheckboxFlags(\"ImGuiTabBarFlags_NoCloseWithMiddleMouseButton\", &tab_bar_flags, ImGuiTabBarFlags_NoCloseWithMiddleMouseButton);\n            ImGui::CheckboxFlags(\"ImGuiTabBarFlags_DrawSelectedOverline\", &tab_bar_flags, ImGuiTabBarFlags_DrawSelectedOverline);\n            if ((tab_bar_flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)\n                tab_bar_flags |= ImGuiTabBarFlags_FittingPolicyDefault_;\n            if (ImGui::CheckboxFlags(\"ImGuiTabBarFlags_FittingPolicyResizeDown\", &tab_bar_flags, ImGuiTabBarFlags_FittingPolicyResizeDown))\n                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyResizeDown);\n            if (ImGui::CheckboxFlags(\"ImGuiTabBarFlags_FittingPolicyScroll\", &tab_bar_flags, ImGuiTabBarFlags_FittingPolicyScroll))\n                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyScroll);\n\n            // Tab Bar\n            ImGui::AlignTextToFramePadding();\n            ImGui::Text(\"Opened:\");\n            const char* names[4] = { \"Artichoke\", \"Beetroot\", \"Celery\", \"Daikon\" };\n            static bool opened[4] = { true, true, true, true }; // Persistent user state\n            for (int n = 0; n < IM_ARRAYSIZE(opened); n++)\n            {\n                ImGui::SameLine();\n                ImGui::Checkbox(names[n], &opened[n]);\n            }\n\n            // Passing a bool* to BeginTabItem() is similar to passing one to Begin():\n            // the underlying bool will be set to false when the tab is closed.\n            if (ImGui::BeginTabBar(\"MyTabBar\", tab_bar_flags))\n            {\n                for (int n = 0; n < IM_ARRAYSIZE(opened); n++)\n                    if (opened[n] && ImGui::BeginTabItem(names[n], &opened[n], ImGuiTabItemFlags_None))\n                    {\n                        ImGui::Text(\"This is the %s tab!\", names[n]);\n                        if (n & 1)\n                            ImGui::Text(\"I am an odd tab.\");\n                        ImGui::EndTabItem();\n                    }\n                ImGui::EndTabBar();\n            }\n            ImGui::Separator();\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Tabs/TabItemButton & Leading-Trailing flags\");\n        if (ImGui::TreeNode(\"TabItemButton & Leading/Trailing flags\"))\n        {\n            static ImVector<int> active_tabs;\n            static int next_tab_id = 0;\n            if (next_tab_id == 0) // Initialize with some default tabs\n                for (int i = 0; i < 3; i++)\n                    active_tabs.push_back(next_tab_id++);\n\n            // TabItemButton() and Leading/Trailing flags are distinct features which we will demo together.\n            // (It is possible to submit regular tabs with Leading/Trailing flags, or TabItemButton tabs without Leading/Trailing flags...\n            // but they tend to make more sense together)\n            static bool show_leading_button = true;\n            static bool show_trailing_button = true;\n            ImGui::Checkbox(\"Show Leading TabItemButton()\", &show_leading_button);\n            ImGui::Checkbox(\"Show Trailing TabItemButton()\", &show_trailing_button);\n\n            // Expose some other flags which are useful to showcase how they interact with Leading/Trailing tabs\n            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_AutoSelectNewTabs | ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_FittingPolicyResizeDown;\n            ImGui::CheckboxFlags(\"ImGuiTabBarFlags_TabListPopupButton\", &tab_bar_flags, ImGuiTabBarFlags_TabListPopupButton);\n            if (ImGui::CheckboxFlags(\"ImGuiTabBarFlags_FittingPolicyResizeDown\", &tab_bar_flags, ImGuiTabBarFlags_FittingPolicyResizeDown))\n                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyResizeDown);\n            if (ImGui::CheckboxFlags(\"ImGuiTabBarFlags_FittingPolicyScroll\", &tab_bar_flags, ImGuiTabBarFlags_FittingPolicyScroll))\n                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyScroll);\n\n            if (ImGui::BeginTabBar(\"MyTabBar\", tab_bar_flags))\n            {\n                // Demo a Leading TabItemButton(): click the \"?\" button to open a menu\n                if (show_leading_button)\n                    if (ImGui::TabItemButton(\"?\", ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_NoTooltip))\n                        ImGui::OpenPopup(\"MyHelpMenu\");\n                if (ImGui::BeginPopup(\"MyHelpMenu\"))\n                {\n                    ImGui::Selectable(\"Hello!\");\n                    ImGui::EndPopup();\n                }\n\n                // Demo Trailing Tabs: click the \"+\" button to add a new tab.\n                // (In your app you may want to use a font icon instead of the \"+\")\n                // We submit it before the regular tabs, but thanks to the ImGuiTabItemFlags_Trailing flag it will always appear at the end.\n                if (show_trailing_button)\n                    if (ImGui::TabItemButton(\"+\", ImGuiTabItemFlags_Trailing | ImGuiTabItemFlags_NoTooltip))\n                        active_tabs.push_back(next_tab_id++); // Add new tab\n\n                // Submit our regular tabs\n                for (int n = 0; n < active_tabs.Size; )\n                {\n                    bool open = true;\n                    char name[16];\n                    snprintf(name, IM_ARRAYSIZE(name), \"%04d\", active_tabs[n]);\n                    if (ImGui::BeginTabItem(name, &open, ImGuiTabItemFlags_None))\n                    {\n                        ImGui::Text(\"This is the %s tab!\", name);\n                        ImGui::EndTabItem();\n                    }\n\n                    if (!open)\n                        active_tabs.erase(active_tabs.Data + n);\n                    else\n                        n++;\n                }\n\n                ImGui::EndTabBar();\n            }\n            ImGui::Separator();\n            ImGui::TreePop();\n        }\n        ImGui::TreePop();\n    }\n\n    // Plot/Graph widgets are not very good.\n    // Consider using a third-party library such as ImPlot: https://github.com/epezent/implot\n    // (see others https://github.com/ocornut/imgui/wiki/Useful-Extensions)\n    IMGUI_DEMO_MARKER(\"Widgets/Plotting\");\n    if (ImGui::TreeNode(\"Plotting\"))\n    {\n        static bool animate = true;\n        ImGui::Checkbox(\"Animate\", &animate);\n\n        // Plot as lines and plot as histogram\n        static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };\n        ImGui::PlotLines(\"Frame Times\", arr, IM_ARRAYSIZE(arr));\n        ImGui::PlotHistogram(\"Histogram\", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0, 80.0f));\n        //ImGui::SameLine(); HelpMarker(\"Consider using ImPlot instead!\");\n\n        // Fill an array of contiguous float values to plot\n        // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float\n        // and the sizeof() of your structure in the \"stride\" parameter.\n        static float values[90] = {};\n        static int values_offset = 0;\n        static double refresh_time = 0.0;\n        if (!animate || refresh_time == 0.0)\n            refresh_time = ImGui::GetTime();\n        while (refresh_time < ImGui::GetTime()) // Create data at fixed 60 Hz rate for the demo\n        {\n            static float phase = 0.0f;\n            values[values_offset] = cosf(phase);\n            values_offset = (values_offset + 1) % IM_ARRAYSIZE(values);\n            phase += 0.10f * values_offset;\n            refresh_time += 1.0f / 60.0f;\n        }\n\n        // Plots can display overlay texts\n        // (in this example, we will display an average value)\n        {\n            float average = 0.0f;\n            for (int n = 0; n < IM_ARRAYSIZE(values); n++)\n                average += values[n];\n            average /= (float)IM_ARRAYSIZE(values);\n            char overlay[32];\n            sprintf(overlay, \"avg %f\", average);\n            ImGui::PlotLines(\"Lines\", values, IM_ARRAYSIZE(values), values_offset, overlay, -1.0f, 1.0f, ImVec2(0, 80.0f));\n        }\n\n        // Use functions to generate output\n        // FIXME: This is actually VERY awkward because current plot API only pass in indices.\n        // We probably want an API passing floats and user provide sample rate/count.\n        struct Funcs\n        {\n            static float Sin(void*, int i) { return sinf(i * 0.1f); }\n            static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }\n        };\n        static int func_type = 0, display_count = 70;\n        ImGui::SeparatorText(\"Functions\");\n        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n        ImGui::Combo(\"func\", &func_type, \"Sin\\0Saw\\0\");\n        ImGui::SameLine();\n        ImGui::SliderInt(\"Sample count\", &display_count, 1, 400);\n        float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;\n        ImGui::PlotLines(\"Lines##2\", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0, 80));\n        ImGui::PlotHistogram(\"Histogram##2\", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0, 80));\n        ImGui::Separator();\n\n        ImGui::Text(\"Need better plotting and graphing? Consider using ImPlot:\");\n        ImGui::TextLinkOpenURL(\"https://github.com/epezent/implot\");\n        ImGui::Separator();\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Progress Bars\");\n    if (ImGui::TreeNode(\"Progress Bars\"))\n    {\n        // Animate a simple progress bar\n        static float progress = 0.0f, progress_dir = 1.0f;\n        progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;\n        if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }\n        if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }\n\n        // Typically we would use ImVec2(-1.0f,0.0f) or ImVec2(-FLT_MIN,0.0f) to use all available width,\n        // or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.\n        ImGui::ProgressBar(progress, ImVec2(0.0f, 0.0f));\n        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n        ImGui::Text(\"Progress Bar\");\n\n        float progress_saturated = IM_CLAMP(progress, 0.0f, 1.0f);\n        char buf[32];\n        sprintf(buf, \"%d/%d\", (int)(progress_saturated * 1753), 1753);\n        ImGui::ProgressBar(progress, ImVec2(0.f, 0.f), buf);\n\n        // Pass an animated negative value, e.g. -1.0f * (float)ImGui::GetTime() is the recommended value.\n        // Adjust the factor if you want to adjust the animation speed.\n        ImGui::ProgressBar(-1.0f * (float)ImGui::GetTime(), ImVec2(0.0f, 0.0f), \"Searching..\");\n        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n        ImGui::Text(\"Indeterminate\");\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Color\");\n    if (ImGui::TreeNode(\"Color/Picker Widgets\"))\n    {\n        static ImVec4 color = ImVec4(114.0f / 255.0f, 144.0f / 255.0f, 154.0f / 255.0f, 200.0f / 255.0f);\n\n        static bool alpha_preview = true;\n        static bool alpha_half_preview = false;\n        static bool drag_and_drop = true;\n        static bool options_menu = true;\n        static bool hdr = false;\n        ImGui::SeparatorText(\"Options\");\n        ImGui::Checkbox(\"With Alpha Preview\", &alpha_preview);\n        ImGui::Checkbox(\"With Half Alpha Preview\", &alpha_half_preview);\n        ImGui::Checkbox(\"With Drag and Drop\", &drag_and_drop);\n        ImGui::Checkbox(\"With Options Menu\", &options_menu); ImGui::SameLine(); HelpMarker(\"Right-click on the individual color widget to show options.\");\n        ImGui::Checkbox(\"With HDR\", &hdr); ImGui::SameLine(); HelpMarker(\"Currently all this does is to lift the 0..1 limits on dragging widgets.\");\n        ImGuiColorEditFlags misc_flags = (hdr ? ImGuiColorEditFlags_HDR : 0) | (drag_and_drop ? 0 : ImGuiColorEditFlags_NoDragDrop) | (alpha_half_preview ? ImGuiColorEditFlags_AlphaPreviewHalf : (alpha_preview ? ImGuiColorEditFlags_AlphaPreview : 0)) | (options_menu ? 0 : ImGuiColorEditFlags_NoOptions);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorEdit\");\n        ImGui::SeparatorText(\"Inline color editor\");\n        ImGui::Text(\"Color widget:\");\n        ImGui::SameLine(); HelpMarker(\n            \"Click on the color square to open a color picker.\\n\"\n            \"CTRL+click on individual component to input value.\\n\");\n        ImGui::ColorEdit3(\"MyColor##1\", (float*)&color, misc_flags);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorEdit (HSV, with Alpha)\");\n        ImGui::Text(\"Color widget HSV with Alpha:\");\n        ImGui::ColorEdit4(\"MyColor##2\", (float*)&color, ImGuiColorEditFlags_DisplayHSV | misc_flags);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorEdit (float display)\");\n        ImGui::Text(\"Color widget with Float Display:\");\n        ImGui::ColorEdit4(\"MyColor##2f\", (float*)&color, ImGuiColorEditFlags_Float | misc_flags);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorButton (with Picker)\");\n        ImGui::Text(\"Color button with Picker:\");\n        ImGui::SameLine(); HelpMarker(\n            \"With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\\n\"\n            \"With the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only \"\n            \"be used for the tooltip and picker popup.\");\n        ImGui::ColorEdit4(\"MyColor##3\", (float*)&color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | misc_flags);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorButton (with custom Picker popup)\");\n        ImGui::Text(\"Color button with Custom Picker Popup:\");\n\n        // Generate a default palette. The palette will persist and can be edited.\n        static bool saved_palette_init = true;\n        static ImVec4 saved_palette[32] = {};\n        if (saved_palette_init)\n        {\n            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)\n            {\n                ImGui::ColorConvertHSVtoRGB(n / 31.0f, 0.8f, 0.8f,\n                    saved_palette[n].x, saved_palette[n].y, saved_palette[n].z);\n                saved_palette[n].w = 1.0f; // Alpha\n            }\n            saved_palette_init = false;\n        }\n\n        static ImVec4 backup_color;\n        bool open_popup = ImGui::ColorButton(\"MyColor##3b\", color, misc_flags);\n        ImGui::SameLine(0, ImGui::GetStyle().ItemInnerSpacing.x);\n        open_popup |= ImGui::Button(\"Palette\");\n        if (open_popup)\n        {\n            ImGui::OpenPopup(\"mypicker\");\n            backup_color = color;\n        }\n        if (ImGui::BeginPopup(\"mypicker\"))\n        {\n            ImGui::Text(\"MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!\");\n            ImGui::Separator();\n            ImGui::ColorPicker4(\"##picker\", (float*)&color, misc_flags | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview);\n            ImGui::SameLine();\n\n            ImGui::BeginGroup(); // Lock X position\n            ImGui::Text(\"Current\");\n            ImGui::ColorButton(\"##current\", color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60, 40));\n            ImGui::Text(\"Previous\");\n            if (ImGui::ColorButton(\"##previous\", backup_color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60, 40)))\n                color = backup_color;\n            ImGui::Separator();\n            ImGui::Text(\"Palette\");\n            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)\n            {\n                ImGui::PushID(n);\n                if ((n % 8) != 0)\n                    ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);\n\n                ImGuiColorEditFlags palette_button_flags = ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip;\n                if (ImGui::ColorButton(\"##palette\", saved_palette[n], palette_button_flags, ImVec2(20, 20)))\n                    color = ImVec4(saved_palette[n].x, saved_palette[n].y, saved_palette[n].z, color.w); // Preserve alpha!\n\n                // Allow user to drop colors into each palette entry. Note that ColorButton() is already a\n                // drag source by default, unless specifying the ImGuiColorEditFlags_NoDragDrop flag.\n                if (ImGui::BeginDragDropTarget())\n                {\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))\n                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))\n                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);\n                    ImGui::EndDragDropTarget();\n                }\n\n                ImGui::PopID();\n            }\n            ImGui::EndGroup();\n            ImGui::EndPopup();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorButton (simple)\");\n        ImGui::Text(\"Color button only:\");\n        static bool no_border = false;\n        ImGui::Checkbox(\"ImGuiColorEditFlags_NoBorder\", &no_border);\n        ImGui::ColorButton(\"MyColor##3c\", *(ImVec4*)&color, misc_flags | (no_border ? ImGuiColorEditFlags_NoBorder : 0), ImVec2(80, 80));\n\n        IMGUI_DEMO_MARKER(\"Widgets/Color/ColorPicker\");\n        ImGui::SeparatorText(\"Color picker\");\n        static bool alpha = true;\n        static bool alpha_bar = true;\n        static bool side_preview = true;\n        static bool ref_color = false;\n        static ImVec4 ref_color_v(1.0f, 0.0f, 1.0f, 0.5f);\n        static int display_mode = 0;\n        static int picker_mode = 0;\n        ImGui::Checkbox(\"With Alpha\", &alpha);\n        ImGui::Checkbox(\"With Alpha Bar\", &alpha_bar);\n        ImGui::Checkbox(\"With Side Preview\", &side_preview);\n        if (side_preview)\n        {\n            ImGui::SameLine();\n            ImGui::Checkbox(\"With Ref Color\", &ref_color);\n            if (ref_color)\n            {\n                ImGui::SameLine();\n                ImGui::ColorEdit4(\"##RefColor\", &ref_color_v.x, ImGuiColorEditFlags_NoInputs | misc_flags);\n            }\n        }\n        ImGui::Combo(\"Display Mode\", &display_mode, \"Auto/Current\\0None\\0RGB Only\\0HSV Only\\0Hex Only\\0\");\n        ImGui::SameLine(); HelpMarker(\n            \"ColorEdit defaults to displaying RGB inputs if you don't specify a display mode, \"\n            \"but the user can change it with a right-click on those inputs.\\n\\nColorPicker defaults to displaying RGB+HSV+Hex \"\n            \"if you don't specify a display mode.\\n\\nYou can change the defaults using SetColorEditOptions().\");\n        ImGui::SameLine(); HelpMarker(\"When not specified explicitly (Auto/Current mode), user can right-click the picker to change mode.\");\n        ImGuiColorEditFlags flags = misc_flags;\n        if (!alpha)            flags |= ImGuiColorEditFlags_NoAlpha;        // This is by default if you call ColorPicker3() instead of ColorPicker4()\n        if (alpha_bar)         flags |= ImGuiColorEditFlags_AlphaBar;\n        if (!side_preview)     flags |= ImGuiColorEditFlags_NoSidePreview;\n        if (picker_mode == 1)  flags |= ImGuiColorEditFlags_PickerHueBar;\n        if (picker_mode == 2)  flags |= ImGuiColorEditFlags_PickerHueWheel;\n        if (display_mode == 1) flags |= ImGuiColorEditFlags_NoInputs;       // Disable all RGB/HSV/Hex displays\n        if (display_mode == 2) flags |= ImGuiColorEditFlags_DisplayRGB;     // Override display mode\n        if (display_mode == 3) flags |= ImGuiColorEditFlags_DisplayHSV;\n        if (display_mode == 4) flags |= ImGuiColorEditFlags_DisplayHex;\n        ImGui::ColorPicker4(\"MyColor##4\", (float*)&color, flags, ref_color ? &ref_color_v.x : NULL);\n\n        ImGui::Text(\"Set defaults in code:\");\n        ImGui::SameLine(); HelpMarker(\n            \"SetColorEditOptions() is designed to allow you to set boot-time default.\\n\"\n            \"We don't have Push/Pop functions because you can force options on a per-widget basis if needed,\"\n            \"and the user can change non-forced ones with the options menu.\\nWe don't have a getter to avoid\"\n            \"encouraging you to persistently save values that aren't forward-compatible.\");\n        if (ImGui::Button(\"Default: Uint8 + HSV + Hue Bar\"))\n            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_PickerHueBar);\n        if (ImGui::Button(\"Default: Float + HDR + Hue Wheel\"))\n            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Float | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_PickerHueWheel);\n\n        // Always display a small version of both types of pickers\n        // (that's in order to make it more visible in the demo to people who are skimming quickly through it)\n        ImGui::Text(\"Both types:\");\n        float w = (ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.y) * 0.40f;\n        ImGui::SetNextItemWidth(w);\n        ImGui::ColorPicker3(\"##MyColor##5\", (float*)&color, ImGuiColorEditFlags_PickerHueBar | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);\n        ImGui::SameLine();\n        ImGui::SetNextItemWidth(w);\n        ImGui::ColorPicker3(\"##MyColor##6\", (float*)&color, ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);\n\n        // HSV encoded support (to avoid RGB<>HSV round trips and singularities when S==0 or V==0)\n        static ImVec4 color_hsv(0.23f, 1.0f, 1.0f, 1.0f); // Stored as HSV!\n        ImGui::Spacing();\n        ImGui::Text(\"HSV encoded colors\");\n        ImGui::SameLine(); HelpMarker(\n            \"By default, colors are given to ColorEdit and ColorPicker in RGB, but ImGuiColorEditFlags_InputHSV\"\n            \"allows you to store colors as HSV and pass them to ColorEdit and ColorPicker as HSV. This comes with the\"\n            \"added benefit that you can manipulate hue values with the picker even when saturation or value are zero.\");\n        ImGui::Text(\"Color widget with InputHSV:\");\n        ImGui::ColorEdit4(\"HSV shown as RGB##1\", (float*)&color_hsv, ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);\n        ImGui::ColorEdit4(\"HSV shown as HSV##1\", (float*)&color_hsv, ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);\n        ImGui::DragFloat4(\"Raw HSV values\", (float*)&color_hsv, 0.01f, 0.0f, 1.0f);\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Drag and Slider Flags\");\n    if (ImGui::TreeNode(\"Drag/Slider Flags\"))\n    {\n        // Demonstrate using advanced flags for DragXXX and SliderXXX functions. Note that the flags are the same!\n        static ImGuiSliderFlags flags = ImGuiSliderFlags_None;\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_AlwaysClamp\", &flags, ImGuiSliderFlags_AlwaysClamp);\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_ClampOnInput\", &flags, ImGuiSliderFlags_ClampOnInput);\n        ImGui::SameLine(); HelpMarker(\"Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.\");\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_ClampZeroRange\", &flags, ImGuiSliderFlags_ClampZeroRange);\n        ImGui::SameLine(); HelpMarker(\"Clamp even if min==max==0.0f. Otherwise DragXXX functions don't clamp.\");\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_Logarithmic\", &flags, ImGuiSliderFlags_Logarithmic);\n        ImGui::SameLine(); HelpMarker(\"Enable logarithmic editing (more precision for small values).\");\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_NoRoundToFormat\", &flags, ImGuiSliderFlags_NoRoundToFormat);\n        ImGui::SameLine(); HelpMarker(\"Disable rounding underlying value to match precision of the format string (e.g. %.3f values are rounded to those 3 digits).\");\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_NoInput\", &flags, ImGuiSliderFlags_NoInput);\n        ImGui::SameLine(); HelpMarker(\"Disable CTRL+Click or Enter key allowing to input text directly into the widget.\");\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_NoSpeedTweaks\", &flags, ImGuiSliderFlags_NoSpeedTweaks);\n        ImGui::SameLine(); HelpMarker(\"Disable keyboard modifiers altering tweak speed. Useful if you want to alter tweak speed yourself based on your own logic.\");\n        ImGui::CheckboxFlags(\"ImGuiSliderFlags_WrapAround\", &flags, ImGuiSliderFlags_WrapAround);\n        ImGui::SameLine(); HelpMarker(\"Enable wrapping around from max to min and from min to max (only supported by DragXXX() functions)\");\n\n        // Drags\n        static float drag_f = 0.5f;\n        static int drag_i = 50;\n        ImGui::Text(\"Underlying float value: %f\", drag_f);\n        ImGui::DragFloat(\"DragFloat (0 -> 1)\", &drag_f, 0.005f, 0.0f, 1.0f, \"%.3f\", flags);\n        ImGui::DragFloat(\"DragFloat (0 -> +inf)\", &drag_f, 0.005f, 0.0f, FLT_MAX, \"%.3f\", flags);\n        ImGui::DragFloat(\"DragFloat (-inf -> 1)\", &drag_f, 0.005f, -FLT_MAX, 1.0f, \"%.3f\", flags);\n        ImGui::DragFloat(\"DragFloat (-inf -> +inf)\", &drag_f, 0.005f, -FLT_MAX, +FLT_MAX, \"%.3f\", flags);\n        //ImGui::DragFloat(\"DragFloat (0 -> 0)\", &drag_f, 0.005f, 0.0f, 0.0f, \"%.3f\", flags);           // To test ClampZeroRange\n        //ImGui::DragFloat(\"DragFloat (100 -> 100)\", &drag_f, 0.005f, 100.0f, 100.0f, \"%.3f\", flags);\n        ImGui::DragInt(\"DragInt (0 -> 100)\", &drag_i, 0.5f, 0, 100, \"%d\", flags);\n\n        // Sliders\n        static float slider_f = 0.5f;\n        static int slider_i = 50;\n        const ImGuiSliderFlags flags_for_sliders = flags & ~ImGuiSliderFlags_WrapAround;\n        ImGui::Text(\"Underlying float value: %f\", slider_f);\n        ImGui::SliderFloat(\"SliderFloat (0 -> 1)\", &slider_f, 0.0f, 1.0f, \"%.3f\", flags_for_sliders);\n        ImGui::SliderInt(\"SliderInt (0 -> 100)\", &slider_i, 0, 100, \"%d\", flags_for_sliders);\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Range Widgets\");\n    if (ImGui::TreeNode(\"Range Widgets\"))\n    {\n        static float begin = 10, end = 90;\n        static int begin_i = 100, end_i = 1000;\n        ImGui::DragFloatRange2(\"range float\", &begin, &end, 0.25f, 0.0f, 100.0f, \"Min: %.1f %%\", \"Max: %.1f %%\", ImGuiSliderFlags_AlwaysClamp);\n        ImGui::DragIntRange2(\"range int\", &begin_i, &end_i, 5, 0, 1000, \"Min: %d units\", \"Max: %d units\");\n        ImGui::DragIntRange2(\"range int (no bounds)\", &begin_i, &end_i, 5, 0, 0, \"Min: %d units\", \"Max: %d units\");\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Data Types\");\n    if (ImGui::TreeNode(\"Data Types\"))\n    {\n        // DragScalar/InputScalar/SliderScalar functions allow various data types\n        // - signed/unsigned\n        // - 8/16/32/64-bits\n        // - integer/float/double\n        // To avoid polluting the public API with all possible combinations, we use the ImGuiDataType enum\n        // to pass the type, and passing all arguments by pointer.\n        // This is the reason the test code below creates local variables to hold \"zero\" \"one\" etc. for each type.\n        // In practice, if you frequently use a given type that is not covered by the normal API entry points,\n        // you can wrap it yourself inside a 1 line function which can take typed argument as value instead of void*,\n        // and then pass their address to the generic function. For example:\n        //   bool MySliderU64(const char *label, u64* value, u64 min = 0, u64 max = 0, const char* format = \"%lld\")\n        //   {\n        //      return SliderScalar(label, ImGuiDataType_U64, value, &min, &max, format);\n        //   }\n\n        // Setup limits (as helper variables so we can take their address, as explained above)\n        // Note: SliderScalar() functions have a maximum usable range of half the natural type maximum, hence the /2.\n        #ifndef LLONG_MIN\n        ImS64 LLONG_MIN = -9223372036854775807LL - 1;\n        ImS64 LLONG_MAX = 9223372036854775807LL;\n        ImU64 ULLONG_MAX = (2ULL * 9223372036854775807LL + 1);\n        #endif\n        const char    s8_zero  = 0,   s8_one  = 1,   s8_fifty  = 50, s8_min  = -128,        s8_max = 127;\n        const ImU8    u8_zero  = 0,   u8_one  = 1,   u8_fifty  = 50, u8_min  = 0,           u8_max = 255;\n        const short   s16_zero = 0,   s16_one = 1,   s16_fifty = 50, s16_min = -32768,      s16_max = 32767;\n        const ImU16   u16_zero = 0,   u16_one = 1,   u16_fifty = 50, u16_min = 0,           u16_max = 65535;\n        const ImS32   s32_zero = 0,   s32_one = 1,   s32_fifty = 50, s32_min = INT_MIN/2,   s32_max = INT_MAX/2,    s32_hi_a = INT_MAX/2 - 100,    s32_hi_b = INT_MAX/2;\n        const ImU32   u32_zero = 0,   u32_one = 1,   u32_fifty = 50, u32_min = 0,           u32_max = UINT_MAX/2,   u32_hi_a = UINT_MAX/2 - 100,   u32_hi_b = UINT_MAX/2;\n        const ImS64   s64_zero = 0,   s64_one = 1,   s64_fifty = 50, s64_min = LLONG_MIN/2, s64_max = LLONG_MAX/2,  s64_hi_a = LLONG_MAX/2 - 100,  s64_hi_b = LLONG_MAX/2;\n        const ImU64   u64_zero = 0,   u64_one = 1,   u64_fifty = 50, u64_min = 0,           u64_max = ULLONG_MAX/2, u64_hi_a = ULLONG_MAX/2 - 100, u64_hi_b = ULLONG_MAX/2;\n        const float   f32_zero = 0.f, f32_one = 1.f, f32_lo_a = -10000000000.0f, f32_hi_a = +10000000000.0f;\n        const double  f64_zero = 0.,  f64_one = 1.,  f64_lo_a = -1000000000000000.0, f64_hi_a = +1000000000000000.0;\n\n        // State\n        static char   s8_v  = 127;\n        static ImU8   u8_v  = 255;\n        static short  s16_v = 32767;\n        static ImU16  u16_v = 65535;\n        static ImS32  s32_v = -1;\n        static ImU32  u32_v = (ImU32)-1;\n        static ImS64  s64_v = -1;\n        static ImU64  u64_v = (ImU64)-1;\n        static float  f32_v = 0.123f;\n        static double f64_v = 90000.01234567890123456789;\n\n        const float drag_speed = 0.2f;\n        static bool drag_clamp = false;\n        IMGUI_DEMO_MARKER(\"Widgets/Data Types/Drags\");\n        ImGui::SeparatorText(\"Drags\");\n        ImGui::Checkbox(\"Clamp integers to 0..50\", &drag_clamp);\n        ImGui::SameLine(); HelpMarker(\n            \"As with every widget in dear imgui, we never modify values unless there is a user interaction.\\n\"\n            \"You can override the clamping limits by using CTRL+Click to input a value.\");\n        ImGui::DragScalar(\"drag s8\",        ImGuiDataType_S8,     &s8_v,  drag_speed, drag_clamp ? &s8_zero  : NULL, drag_clamp ? &s8_fifty  : NULL);\n        ImGui::DragScalar(\"drag u8\",        ImGuiDataType_U8,     &u8_v,  drag_speed, drag_clamp ? &u8_zero  : NULL, drag_clamp ? &u8_fifty  : NULL, \"%u ms\");\n        ImGui::DragScalar(\"drag s16\",       ImGuiDataType_S16,    &s16_v, drag_speed, drag_clamp ? &s16_zero : NULL, drag_clamp ? &s16_fifty : NULL);\n        ImGui::DragScalar(\"drag u16\",       ImGuiDataType_U16,    &u16_v, drag_speed, drag_clamp ? &u16_zero : NULL, drag_clamp ? &u16_fifty : NULL, \"%u ms\");\n        ImGui::DragScalar(\"drag s32\",       ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL);\n        ImGui::DragScalar(\"drag s32 hex\",   ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL, \"0x%08X\");\n        ImGui::DragScalar(\"drag u32\",       ImGuiDataType_U32,    &u32_v, drag_speed, drag_clamp ? &u32_zero : NULL, drag_clamp ? &u32_fifty : NULL, \"%u ms\");\n        ImGui::DragScalar(\"drag s64\",       ImGuiDataType_S64,    &s64_v, drag_speed, drag_clamp ? &s64_zero : NULL, drag_clamp ? &s64_fifty : NULL);\n        ImGui::DragScalar(\"drag u64\",       ImGuiDataType_U64,    &u64_v, drag_speed, drag_clamp ? &u64_zero : NULL, drag_clamp ? &u64_fifty : NULL);\n        ImGui::DragScalar(\"drag float\",     ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, \"%f\");\n        ImGui::DragScalar(\"drag float log\", ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, \"%f\", ImGuiSliderFlags_Logarithmic);\n        ImGui::DragScalar(\"drag double\",    ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, NULL,     \"%.10f grams\");\n        ImGui::DragScalar(\"drag double log\",ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, &f64_one, \"0 < %.10f < 1\", ImGuiSliderFlags_Logarithmic);\n\n        IMGUI_DEMO_MARKER(\"Widgets/Data Types/Sliders\");\n        ImGui::SeparatorText(\"Sliders\");\n        ImGui::SliderScalar(\"slider s8 full\",       ImGuiDataType_S8,     &s8_v,  &s8_min,   &s8_max,   \"%d\");\n        ImGui::SliderScalar(\"slider u8 full\",       ImGuiDataType_U8,     &u8_v,  &u8_min,   &u8_max,   \"%u\");\n        ImGui::SliderScalar(\"slider s16 full\",      ImGuiDataType_S16,    &s16_v, &s16_min,  &s16_max,  \"%d\");\n        ImGui::SliderScalar(\"slider u16 full\",      ImGuiDataType_U16,    &u16_v, &u16_min,  &u16_max,  \"%u\");\n        ImGui::SliderScalar(\"slider s32 low\",       ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty,\"%d\");\n        ImGui::SliderScalar(\"slider s32 high\",      ImGuiDataType_S32,    &s32_v, &s32_hi_a, &s32_hi_b, \"%d\");\n        ImGui::SliderScalar(\"slider s32 full\",      ImGuiDataType_S32,    &s32_v, &s32_min,  &s32_max,  \"%d\");\n        ImGui::SliderScalar(\"slider s32 hex\",       ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty, \"0x%04X\");\n        ImGui::SliderScalar(\"slider u32 low\",       ImGuiDataType_U32,    &u32_v, &u32_zero, &u32_fifty,\"%u\");\n        ImGui::SliderScalar(\"slider u32 high\",      ImGuiDataType_U32,    &u32_v, &u32_hi_a, &u32_hi_b, \"%u\");\n        ImGui::SliderScalar(\"slider u32 full\",      ImGuiDataType_U32,    &u32_v, &u32_min,  &u32_max,  \"%u\");\n        ImGui::SliderScalar(\"slider s64 low\",       ImGuiDataType_S64,    &s64_v, &s64_zero, &s64_fifty,\"%\" PRId64);\n        ImGui::SliderScalar(\"slider s64 high\",      ImGuiDataType_S64,    &s64_v, &s64_hi_a, &s64_hi_b, \"%\" PRId64);\n        ImGui::SliderScalar(\"slider s64 full\",      ImGuiDataType_S64,    &s64_v, &s64_min,  &s64_max,  \"%\" PRId64);\n        ImGui::SliderScalar(\"slider u64 low\",       ImGuiDataType_U64,    &u64_v, &u64_zero, &u64_fifty,\"%\" PRIu64 \" ms\");\n        ImGui::SliderScalar(\"slider u64 high\",      ImGuiDataType_U64,    &u64_v, &u64_hi_a, &u64_hi_b, \"%\" PRIu64 \" ms\");\n        ImGui::SliderScalar(\"slider u64 full\",      ImGuiDataType_U64,    &u64_v, &u64_min,  &u64_max,  \"%\" PRIu64 \" ms\");\n        ImGui::SliderScalar(\"slider float low\",     ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one);\n        ImGui::SliderScalar(\"slider float low log\", ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one,  \"%.10f\", ImGuiSliderFlags_Logarithmic);\n        ImGui::SliderScalar(\"slider float high\",    ImGuiDataType_Float,  &f32_v, &f32_lo_a, &f32_hi_a, \"%e\");\n        ImGui::SliderScalar(\"slider double low\",    ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  \"%.10f grams\");\n        ImGui::SliderScalar(\"slider double low log\",ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  \"%.10f\", ImGuiSliderFlags_Logarithmic);\n        ImGui::SliderScalar(\"slider double high\",   ImGuiDataType_Double, &f64_v, &f64_lo_a, &f64_hi_a, \"%e grams\");\n\n        ImGui::SeparatorText(\"Sliders (reverse)\");\n        ImGui::SliderScalar(\"slider s8 reverse\",    ImGuiDataType_S8,   &s8_v,  &s8_max,    &s8_min,   \"%d\");\n        ImGui::SliderScalar(\"slider u8 reverse\",    ImGuiDataType_U8,   &u8_v,  &u8_max,    &u8_min,   \"%u\");\n        ImGui::SliderScalar(\"slider s32 reverse\",   ImGuiDataType_S32,  &s32_v, &s32_fifty, &s32_zero, \"%d\");\n        ImGui::SliderScalar(\"slider u32 reverse\",   ImGuiDataType_U32,  &u32_v, &u32_fifty, &u32_zero, \"%u\");\n        ImGui::SliderScalar(\"slider s64 reverse\",   ImGuiDataType_S64,  &s64_v, &s64_fifty, &s64_zero, \"%\" PRId64);\n        ImGui::SliderScalar(\"slider u64 reverse\",   ImGuiDataType_U64,  &u64_v, &u64_fifty, &u64_zero, \"%\" PRIu64 \" ms\");\n\n        IMGUI_DEMO_MARKER(\"Widgets/Data Types/Inputs\");\n        static bool inputs_step = true;\n        static ImGuiInputTextFlags flags = ImGuiInputTextFlags_None;\n        ImGui::SeparatorText(\"Inputs\");\n        ImGui::Checkbox(\"Show step buttons\", &inputs_step);\n        ImGui::CheckboxFlags(\"ImGuiInputTextFlags_ReadOnly\", &flags, ImGuiInputTextFlags_ReadOnly);\n        ImGui::CheckboxFlags(\"ImGuiInputTextFlags_ParseEmptyRefVal\", &flags, ImGuiInputTextFlags_ParseEmptyRefVal);\n        ImGui::CheckboxFlags(\"ImGuiInputTextFlags_DisplayEmptyRefVal\", &flags, ImGuiInputTextFlags_DisplayEmptyRefVal);\n        ImGui::InputScalar(\"input s8\",      ImGuiDataType_S8,     &s8_v,  inputs_step ? &s8_one  : NULL, NULL, \"%d\", flags);\n        ImGui::InputScalar(\"input u8\",      ImGuiDataType_U8,     &u8_v,  inputs_step ? &u8_one  : NULL, NULL, \"%u\", flags);\n        ImGui::InputScalar(\"input s16\",     ImGuiDataType_S16,    &s16_v, inputs_step ? &s16_one : NULL, NULL, \"%d\", flags);\n        ImGui::InputScalar(\"input u16\",     ImGuiDataType_U16,    &u16_v, inputs_step ? &u16_one : NULL, NULL, \"%u\", flags);\n        ImGui::InputScalar(\"input s32\",     ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, \"%d\", flags);\n        ImGui::InputScalar(\"input s32 hex\", ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, \"%04X\", flags);\n        ImGui::InputScalar(\"input u32\",     ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, \"%u\", flags);\n        ImGui::InputScalar(\"input u32 hex\", ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, \"%08X\", flags);\n        ImGui::InputScalar(\"input s64\",     ImGuiDataType_S64,    &s64_v, inputs_step ? &s64_one : NULL, NULL, NULL, flags);\n        ImGui::InputScalar(\"input u64\",     ImGuiDataType_U64,    &u64_v, inputs_step ? &u64_one : NULL, NULL, NULL, flags);\n        ImGui::InputScalar(\"input float\",   ImGuiDataType_Float,  &f32_v, inputs_step ? &f32_one : NULL, NULL, NULL, flags);\n        ImGui::InputScalar(\"input double\",  ImGuiDataType_Double, &f64_v, inputs_step ? &f64_one : NULL, NULL, NULL, flags);\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Multi-component Widgets\");\n    if (ImGui::TreeNode(\"Multi-component Widgets\"))\n    {\n        static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };\n        static int vec4i[4] = { 1, 5, 100, 255 };\n\n        ImGui::SeparatorText(\"2-wide\");\n        ImGui::InputFloat2(\"input float2\", vec4f);\n        ImGui::DragFloat2(\"drag float2\", vec4f, 0.01f, 0.0f, 1.0f);\n        ImGui::SliderFloat2(\"slider float2\", vec4f, 0.0f, 1.0f);\n        ImGui::InputInt2(\"input int2\", vec4i);\n        ImGui::DragInt2(\"drag int2\", vec4i, 1, 0, 255);\n        ImGui::SliderInt2(\"slider int2\", vec4i, 0, 255);\n\n        ImGui::SeparatorText(\"3-wide\");\n        ImGui::InputFloat3(\"input float3\", vec4f);\n        ImGui::DragFloat3(\"drag float3\", vec4f, 0.01f, 0.0f, 1.0f);\n        ImGui::SliderFloat3(\"slider float3\", vec4f, 0.0f, 1.0f);\n        ImGui::InputInt3(\"input int3\", vec4i);\n        ImGui::DragInt3(\"drag int3\", vec4i, 1, 0, 255);\n        ImGui::SliderInt3(\"slider int3\", vec4i, 0, 255);\n\n        ImGui::SeparatorText(\"4-wide\");\n        ImGui::InputFloat4(\"input float4\", vec4f);\n        ImGui::DragFloat4(\"drag float4\", vec4f, 0.01f, 0.0f, 1.0f);\n        ImGui::SliderFloat4(\"slider float4\", vec4f, 0.0f, 1.0f);\n        ImGui::InputInt4(\"input int4\", vec4i);\n        ImGui::DragInt4(\"drag int4\", vec4i, 1, 0, 255);\n        ImGui::SliderInt4(\"slider int4\", vec4i, 0, 255);\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Vertical Sliders\");\n    if (ImGui::TreeNode(\"Vertical Sliders\"))\n    {\n        const float spacing = 4;\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));\n\n        static int int_value = 0;\n        ImGui::VSliderInt(\"##int\", ImVec2(18, 160), &int_value, 0, 5);\n        ImGui::SameLine();\n\n        static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };\n        ImGui::PushID(\"set1\");\n        for (int i = 0; i < 7; i++)\n        {\n            if (i > 0) ImGui::SameLine();\n            ImGui::PushID(i);\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(i / 7.0f, 0.5f, 0.5f));\n            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(i / 7.0f, 0.6f, 0.5f));\n            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(i / 7.0f, 0.7f, 0.5f));\n            ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(i / 7.0f, 0.9f, 0.9f));\n            ImGui::VSliderFloat(\"##v\", ImVec2(18, 160), &values[i], 0.0f, 1.0f, \"\");\n            if (ImGui::IsItemActive() || ImGui::IsItemHovered())\n                ImGui::SetTooltip(\"%.3f\", values[i]);\n            ImGui::PopStyleColor(4);\n            ImGui::PopID();\n        }\n        ImGui::PopID();\n\n        ImGui::SameLine();\n        ImGui::PushID(\"set2\");\n        static float values2[4] = { 0.20f, 0.80f, 0.40f, 0.25f };\n        const int rows = 3;\n        const ImVec2 small_slider_size(18, (float)(int)((160.0f - (rows - 1) * spacing) / rows));\n        for (int nx = 0; nx < 4; nx++)\n        {\n            if (nx > 0) ImGui::SameLine();\n            ImGui::BeginGroup();\n            for (int ny = 0; ny < rows; ny++)\n            {\n                ImGui::PushID(nx * rows + ny);\n                ImGui::VSliderFloat(\"##v\", small_slider_size, &values2[nx], 0.0f, 1.0f, \"\");\n                if (ImGui::IsItemActive() || ImGui::IsItemHovered())\n                    ImGui::SetTooltip(\"%.3f\", values2[nx]);\n                ImGui::PopID();\n            }\n            ImGui::EndGroup();\n        }\n        ImGui::PopID();\n\n        ImGui::SameLine();\n        ImGui::PushID(\"set3\");\n        for (int i = 0; i < 4; i++)\n        {\n            if (i > 0) ImGui::SameLine();\n            ImGui::PushID(i);\n            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);\n            ImGui::VSliderFloat(\"##v\", ImVec2(40, 160), &values[i], 0.0f, 1.0f, \"%.2f\\nsec\");\n            ImGui::PopStyleVar();\n            ImGui::PopID();\n        }\n        ImGui::PopID();\n        ImGui::PopStyleVar();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Drag and drop\");\n    if (ImGui::TreeNode(\"Drag and Drop\"))\n    {\n        IMGUI_DEMO_MARKER(\"Widgets/Drag and drop/Standard widgets\");\n        if (ImGui::TreeNode(\"Drag and drop in standard widgets\"))\n        {\n            // ColorEdit widgets automatically act as drag source and drag target.\n            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F and IMGUI_PAYLOAD_TYPE_COLOR_4F\n            // to allow your own widgets to use colors in their drag and drop interaction.\n            // Also see 'Demo->Widgets->Color/Picker Widgets->Palette' demo.\n            HelpMarker(\"You can drag from the color squares.\");\n            static float col1[3] = { 1.0f, 0.0f, 0.2f };\n            static float col2[4] = { 0.4f, 0.7f, 0.0f, 0.5f };\n            ImGui::ColorEdit3(\"color 1\", col1);\n            ImGui::ColorEdit4(\"color 2\", col2);\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Drag and drop/Copy-swap items\");\n        if (ImGui::TreeNode(\"Drag and drop to copy/swap items\"))\n        {\n            enum Mode\n            {\n                Mode_Copy,\n                Mode_Move,\n                Mode_Swap\n            };\n            static int mode = 0;\n            if (ImGui::RadioButton(\"Copy\", mode == Mode_Copy)) { mode = Mode_Copy; } ImGui::SameLine();\n            if (ImGui::RadioButton(\"Move\", mode == Mode_Move)) { mode = Mode_Move; } ImGui::SameLine();\n            if (ImGui::RadioButton(\"Swap\", mode == Mode_Swap)) { mode = Mode_Swap; }\n            static const char* names[9] =\n            {\n                \"Bobby\", \"Beatrice\", \"Betty\",\n                \"Brianna\", \"Barry\", \"Bernard\",\n                \"Bibi\", \"Blaine\", \"Bryn\"\n            };\n            for (int n = 0; n < IM_ARRAYSIZE(names); n++)\n            {\n                ImGui::PushID(n);\n                if ((n % 3) != 0)\n                    ImGui::SameLine();\n                ImGui::Button(names[n], ImVec2(60, 60));\n\n                // Our buttons are both drag sources and drag targets here!\n                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))\n                {\n                    // Set payload to carry the index of our item (could be anything)\n                    ImGui::SetDragDropPayload(\"DND_DEMO_CELL\", &n, sizeof(int));\n\n                    // Display preview (could be anything, e.g. when dragging an image we could decide to display\n                    // the filename and a small preview of the image, etc.)\n                    if (mode == Mode_Copy) { ImGui::Text(\"Copy %s\", names[n]); }\n                    if (mode == Mode_Move) { ImGui::Text(\"Move %s\", names[n]); }\n                    if (mode == Mode_Swap) { ImGui::Text(\"Swap %s\", names[n]); }\n                    ImGui::EndDragDropSource();\n                }\n                if (ImGui::BeginDragDropTarget())\n                {\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"DND_DEMO_CELL\"))\n                    {\n                        IM_ASSERT(payload->DataSize == sizeof(int));\n                        int payload_n = *(const int*)payload->Data;\n                        if (mode == Mode_Copy)\n                        {\n                            names[n] = names[payload_n];\n                        }\n                        if (mode == Mode_Move)\n                        {\n                            names[n] = names[payload_n];\n                            names[payload_n] = \"\";\n                        }\n                        if (mode == Mode_Swap)\n                        {\n                            const char* tmp = names[n];\n                            names[n] = names[payload_n];\n                            names[payload_n] = tmp;\n                        }\n                    }\n                    ImGui::EndDragDropTarget();\n                }\n                ImGui::PopID();\n            }\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Drag and Drop/Drag to reorder items (simple)\");\n        if (ImGui::TreeNode(\"Drag to reorder items (simple)\"))\n        {\n            // FIXME: there is temporary (usually single-frame) ID Conflict during reordering as a same item may be submitting twice.\n            // This code was always slightly faulty but in a way which was not easily noticeable.\n            // Until we fix this, enable ImGuiItemFlags_AllowDuplicateId to disable detecting the issue.\n            ImGui::PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true);\n\n            // Simple reordering\n            HelpMarker(\n                \"We don't use the drag and drop api at all here! \"\n                \"Instead we query when the item is held but not hovered, and order items accordingly.\");\n            static const char* item_names[] = { \"Item One\", \"Item Two\", \"Item Three\", \"Item Four\", \"Item Five\" };\n            for (int n = 0; n < IM_ARRAYSIZE(item_names); n++)\n            {\n                const char* item = item_names[n];\n                ImGui::Selectable(item);\n\n                if (ImGui::IsItemActive() && !ImGui::IsItemHovered())\n                {\n                    int n_next = n + (ImGui::GetMouseDragDelta(0).y < 0.f ? -1 : 1);\n                    if (n_next >= 0 && n_next < IM_ARRAYSIZE(item_names))\n                    {\n                        item_names[n] = item_names[n_next];\n                        item_names[n_next] = item;\n                        ImGui::ResetMouseDragDelta();\n                    }\n                }\n            }\n\n            ImGui::PopItemFlag();\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Drag and Drop/Tooltip at target location\");\n        if (ImGui::TreeNode(\"Tooltip at target location\"))\n        {\n            for (int n = 0; n < 2; n++)\n            {\n                // Drop targets\n                ImGui::Button(n ? \"drop here##1\" : \"drop here##0\");\n                if (ImGui::BeginDragDropTarget())\n                {\n                    ImGuiDragDropFlags drop_target_flags = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoPreviewTooltip;\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, drop_target_flags))\n                    {\n                        IM_UNUSED(payload);\n                        ImGui::SetMouseCursor(ImGuiMouseCursor_NotAllowed);\n                        ImGui::SetTooltip(\"Cannot drop here!\");\n                    }\n                    ImGui::EndDragDropTarget();\n                }\n\n                // Drop source\n                static ImVec4 col4 = { 1.0f, 0.0f, 0.2f, 1.0f };\n                if (n == 0)\n                    ImGui::ColorButton(\"drag me\", col4);\n\n            }\n            ImGui::TreePop();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Querying Item Status (Edited,Active,Hovered etc.)\");\n    if (ImGui::TreeNode(\"Querying Item Status (Edited/Active/Hovered etc.)\"))\n    {\n        // Select an item type\n        const char* item_names[] =\n        {\n            \"Text\", \"Button\", \"Button (w/ repeat)\", \"Checkbox\", \"SliderFloat\", \"InputText\", \"InputTextMultiline\", \"InputFloat\",\n            \"InputFloat3\", \"ColorEdit4\", \"Selectable\", \"MenuItem\", \"TreeNode\", \"TreeNode (w/ double-click)\", \"Combo\", \"ListBox\"\n        };\n        static int item_type = 4;\n        static bool item_disabled = false;\n        ImGui::Combo(\"Item Type\", &item_type, item_names, IM_ARRAYSIZE(item_names), IM_ARRAYSIZE(item_names));\n        ImGui::SameLine();\n        HelpMarker(\"Testing how various types of items are interacting with the IsItemXXX functions. Note that the bool return value of most ImGui function is generally equivalent to calling ImGui::IsItemHovered().\");\n        ImGui::Checkbox(\"Item Disabled\",  &item_disabled);\n\n        // Submit selected items so we can query their status in the code following it.\n        bool ret = false;\n        static bool b = false;\n        static float col4f[4] = { 1.0f, 0.5, 0.0f, 1.0f };\n        static char str[16] = {};\n        if (item_disabled)\n            ImGui::BeginDisabled(true);\n        if (item_type == 0) { ImGui::Text(\"ITEM: Text\"); }                                              // Testing text items with no identifier/interaction\n        if (item_type == 1) { ret = ImGui::Button(\"ITEM: Button\"); }                                    // Testing button\n        if (item_type == 2) { ImGui::PushItemFlag(ImGuiItemFlags_ButtonRepeat, true); ret = ImGui::Button(\"ITEM: Button\"); ImGui::PopItemFlag(); } // Testing button (with repeater)\n        if (item_type == 3) { ret = ImGui::Checkbox(\"ITEM: Checkbox\", &b); }                            // Testing checkbox\n        if (item_type == 4) { ret = ImGui::SliderFloat(\"ITEM: SliderFloat\", &col4f[0], 0.0f, 1.0f); }   // Testing basic item\n        if (item_type == 5) { ret = ImGui::InputText(\"ITEM: InputText\", &str[0], IM_ARRAYSIZE(str)); }  // Testing input text (which handles tabbing)\n        if (item_type == 6) { ret = ImGui::InputTextMultiline(\"ITEM: InputTextMultiline\", &str[0], IM_ARRAYSIZE(str)); } // Testing input text (which uses a child window)\n        if (item_type == 7) { ret = ImGui::InputFloat(\"ITEM: InputFloat\", col4f, 1.0f); }               // Testing +/- buttons on scalar input\n        if (item_type == 8) { ret = ImGui::InputFloat3(\"ITEM: InputFloat3\", col4f); }                   // Testing multi-component items (IsItemXXX flags are reported merged)\n        if (item_type == 9) { ret = ImGui::ColorEdit4(\"ITEM: ColorEdit4\", col4f); }                     // Testing multi-component items (IsItemXXX flags are reported merged)\n        if (item_type == 10){ ret = ImGui::Selectable(\"ITEM: Selectable\"); }                            // Testing selectable item\n        if (item_type == 11){ ret = ImGui::MenuItem(\"ITEM: MenuItem\"); }                                // Testing menu item (they use ImGuiButtonFlags_PressedOnRelease button policy)\n        if (item_type == 12){ ret = ImGui::TreeNode(\"ITEM: TreeNode\"); if (ret) ImGui::TreePop(); }     // Testing tree node\n        if (item_type == 13){ ret = ImGui::TreeNodeEx(\"ITEM: TreeNode w/ ImGuiTreeNodeFlags_OpenOnDoubleClick\", ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_NoTreePushOnOpen); } // Testing tree node with ImGuiButtonFlags_PressedOnDoubleClick button policy.\n        if (item_type == 14){ const char* items[] = { \"Apple\", \"Banana\", \"Cherry\", \"Kiwi\" }; static int current = 1; ret = ImGui::Combo(\"ITEM: Combo\", &current, items, IM_ARRAYSIZE(items)); }\n        if (item_type == 15){ const char* items[] = { \"Apple\", \"Banana\", \"Cherry\", \"Kiwi\" }; static int current = 1; ret = ImGui::ListBox(\"ITEM: ListBox\", &current, items, IM_ARRAYSIZE(items), IM_ARRAYSIZE(items)); }\n\n        bool hovered_delay_none = ImGui::IsItemHovered();\n        bool hovered_delay_stationary = ImGui::IsItemHovered(ImGuiHoveredFlags_Stationary);\n        bool hovered_delay_short = ImGui::IsItemHovered(ImGuiHoveredFlags_DelayShort);\n        bool hovered_delay_normal = ImGui::IsItemHovered(ImGuiHoveredFlags_DelayNormal);\n        bool hovered_delay_tooltip = ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip); // = Normal + Stationary\n\n        // Display the values of IsItemHovered() and other common item state functions.\n        // Note that the ImGuiHoveredFlags_XXX flags can be combined.\n        // Because BulletText is an item itself and that would affect the output of IsItemXXX functions,\n        // we query every state in a single call to avoid storing them and to simplify the code.\n        ImGui::BulletText(\n            \"Return value = %d\\n\"\n            \"IsItemFocused() = %d\\n\"\n            \"IsItemHovered() = %d\\n\"\n            \"IsItemHovered(_AllowWhenBlockedByPopup) = %d\\n\"\n            \"IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\\n\"\n            \"IsItemHovered(_AllowWhenOverlappedByItem) = %d\\n\"\n            \"IsItemHovered(_AllowWhenOverlappedByWindow) = %d\\n\"\n            \"IsItemHovered(_AllowWhenDisabled) = %d\\n\"\n            \"IsItemHovered(_RectOnly) = %d\\n\"\n            \"IsItemActive() = %d\\n\"\n            \"IsItemEdited() = %d\\n\"\n            \"IsItemActivated() = %d\\n\"\n            \"IsItemDeactivated() = %d\\n\"\n            \"IsItemDeactivatedAfterEdit() = %d\\n\"\n            \"IsItemVisible() = %d\\n\"\n            \"IsItemClicked() = %d\\n\"\n            \"IsItemToggledOpen() = %d\\n\"\n            \"GetItemRectMin() = (%.1f, %.1f)\\n\"\n            \"GetItemRectMax() = (%.1f, %.1f)\\n\"\n            \"GetItemRectSize() = (%.1f, %.1f)\",\n            ret,\n            ImGui::IsItemFocused(),\n            ImGui::IsItemHovered(),\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlappedByItem),\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlappedByWindow),\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled),\n            ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly),\n            ImGui::IsItemActive(),\n            ImGui::IsItemEdited(),\n            ImGui::IsItemActivated(),\n            ImGui::IsItemDeactivated(),\n            ImGui::IsItemDeactivatedAfterEdit(),\n            ImGui::IsItemVisible(),\n            ImGui::IsItemClicked(),\n            ImGui::IsItemToggledOpen(),\n            ImGui::GetItemRectMin().x, ImGui::GetItemRectMin().y,\n            ImGui::GetItemRectMax().x, ImGui::GetItemRectMax().y,\n            ImGui::GetItemRectSize().x, ImGui::GetItemRectSize().y\n        );\n        ImGui::BulletText(\n            \"with Hovering Delay or Stationary test:\\n\"\n            \"IsItemHovered() = = %d\\n\"\n            \"IsItemHovered(_Stationary) = %d\\n\"\n            \"IsItemHovered(_DelayShort) = %d\\n\"\n            \"IsItemHovered(_DelayNormal) = %d\\n\"\n            \"IsItemHovered(_Tooltip) = %d\",\n            hovered_delay_none, hovered_delay_stationary, hovered_delay_short, hovered_delay_normal, hovered_delay_tooltip);\n\n        if (item_disabled)\n            ImGui::EndDisabled();\n\n        char buf[1] = \"\";\n        ImGui::InputText(\"unused\", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_ReadOnly);\n        ImGui::SameLine();\n        HelpMarker(\"This widget is only here to be able to tab-out of the widgets above and see e.g. Deactivated() status.\");\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Querying Window Status (Focused,Hovered etc.)\");\n    if (ImGui::TreeNode(\"Querying Window Status (Focused/Hovered etc.)\"))\n    {\n        static bool embed_all_inside_a_child_window = false;\n        ImGui::Checkbox(\"Embed everything inside a child window for testing _RootWindow flag.\", &embed_all_inside_a_child_window);\n        if (embed_all_inside_a_child_window)\n            ImGui::BeginChild(\"outer_child\", ImVec2(0, ImGui::GetFontSize() * 20.0f), ImGuiChildFlags_Borders);\n\n        // Testing IsWindowFocused() function with its various flags.\n        ImGui::BulletText(\n            \"IsWindowFocused() = %d\\n\"\n            \"IsWindowFocused(_ChildWindows) = %d\\n\"\n            \"IsWindowFocused(_ChildWindows|_NoPopupHierarchy) = %d\\n\"\n            \"IsWindowFocused(_ChildWindows|_RootWindow) = %d\\n\"\n            \"IsWindowFocused(_ChildWindows|_RootWindow|_NoPopupHierarchy) = %d\\n\"\n            \"IsWindowFocused(_RootWindow) = %d\\n\"\n            \"IsWindowFocused(_RootWindow|_NoPopupHierarchy) = %d\\n\"\n            \"IsWindowFocused(_AnyWindow) = %d\\n\",\n            ImGui::IsWindowFocused(),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_NoPopupHierarchy),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_NoPopupHierarchy),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_NoPopupHierarchy),\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow));\n\n        // Testing IsWindowHovered() function with its various flags.\n        ImGui::BulletText(\n            \"IsWindowHovered() = %d\\n\"\n            \"IsWindowHovered(_AllowWhenBlockedByPopup) = %d\\n\"\n            \"IsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\\n\"\n            \"IsWindowHovered(_ChildWindows) = %d\\n\"\n            \"IsWindowHovered(_ChildWindows|_NoPopupHierarchy) = %d\\n\"\n            \"IsWindowHovered(_ChildWindows|_RootWindow) = %d\\n\"\n            \"IsWindowHovered(_ChildWindows|_RootWindow|_NoPopupHierarchy) = %d\\n\"\n            \"IsWindowHovered(_RootWindow) = %d\\n\"\n            \"IsWindowHovered(_RootWindow|_NoPopupHierarchy) = %d\\n\"\n            \"IsWindowHovered(_ChildWindows|_AllowWhenBlockedByPopup) = %d\\n\"\n            \"IsWindowHovered(_AnyWindow) = %d\\n\"\n            \"IsWindowHovered(_Stationary) = %d\\n\",\n            ImGui::IsWindowHovered(),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_NoPopupHierarchy),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_NoPopupHierarchy),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_NoPopupHierarchy),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_AllowWhenBlockedByPopup),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow),\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_Stationary));\n\n        ImGui::BeginChild(\"child\", ImVec2(0, 50), ImGuiChildFlags_Borders);\n        ImGui::Text(\"This is another child window for testing the _ChildWindows flag.\");\n        ImGui::EndChild();\n        if (embed_all_inside_a_child_window)\n            ImGui::EndChild();\n\n        // Calling IsItemHovered() after begin returns the hovered status of the title bar.\n        // This is useful in particular if you want to create a context menu associated to the title bar of a window.\n        static bool test_window = false;\n        ImGui::Checkbox(\"Hovered/Active tests after Begin() for title bar testing\", &test_window);\n        if (test_window)\n        {\n            ImGui::Begin(\"Title bar Hovered/Active tests\", &test_window);\n            if (ImGui::BeginPopupContextItem()) // <-- This is using IsItemHovered()\n            {\n                if (ImGui::MenuItem(\"Close\")) { test_window = false; }\n                ImGui::EndPopup();\n            }\n            ImGui::Text(\n                \"IsItemHovered() after begin = %d (== is title bar hovered)\\n\"\n                \"IsItemActive() after begin = %d (== is window being clicked/moved)\\n\",\n                ImGui::IsItemHovered(), ImGui::IsItemActive());\n            ImGui::End();\n        }\n\n        ImGui::TreePop();\n    }\n\n    // Demonstrate BeginDisabled/EndDisabled using a checkbox located at the bottom of the section (which is a bit odd:\n    // logically we'd have this checkbox at the top of the section, but we don't want this feature to steal that space)\n    if (disable_all)\n        ImGui::EndDisabled();\n\n    IMGUI_DEMO_MARKER(\"Widgets/Disable Block\");\n    if (ImGui::TreeNode(\"Disable block\"))\n    {\n        ImGui::Checkbox(\"Disable entire section above\", &disable_all);\n        ImGui::SameLine(); HelpMarker(\"Demonstrate using BeginDisabled()/EndDisabled() across this section.\");\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Widgets/Text Filter\");\n    if (ImGui::TreeNode(\"Text Filter\"))\n    {\n        // Helper class to easy setup a text filter.\n        // You may want to implement a more feature-full filtering scheme in your own application.\n        HelpMarker(\"Not a widget per-se, but ImGuiTextFilter is a helper to perform simple filtering on text strings.\");\n        static ImGuiTextFilter filter;\n        ImGui::Text(\"Filter usage:\\n\"\n            \"  \\\"\\\"         display all lines\\n\"\n            \"  \\\"xxx\\\"      display lines containing \\\"xxx\\\"\\n\"\n            \"  \\\"xxx,yyy\\\"  display lines containing \\\"xxx\\\" or \\\"yyy\\\"\\n\"\n            \"  \\\"-xxx\\\"     hide lines containing \\\"xxx\\\"\");\n        filter.Draw();\n        const char* lines[] = { \"aaa1.c\", \"bbb1.c\", \"ccc1.c\", \"aaa2.cpp\", \"bbb2.cpp\", \"ccc2.cpp\", \"abc.h\", \"hello, world\" };\n        for (int i = 0; i < IM_ARRAYSIZE(lines); i++)\n            if (filter.PassFilter(lines[i]))\n                ImGui::BulletText(\"%s\", lines[i]);\n        ImGui::TreePop();\n    }\n}\n\nstatic const char* ExampleNames[] =\n{\n    \"Artichoke\", \"Arugula\", \"Asparagus\", \"Avocado\", \"Bamboo Shoots\", \"Bean Sprouts\", \"Beans\", \"Beet\", \"Belgian Endive\", \"Bell Pepper\",\n    \"Bitter Gourd\", \"Bok Choy\", \"Broccoli\", \"Brussels Sprouts\", \"Burdock Root\", \"Cabbage\", \"Calabash\", \"Capers\", \"Carrot\", \"Cassava\",\n    \"Cauliflower\", \"Celery\", \"Celery Root\", \"Celcuce\", \"Chayote\", \"Chinese Broccoli\", \"Corn\", \"Cucumber\"\n};\n\n// Extra functions to add deletion support to ImGuiSelectionBasicStorage\nstruct ExampleSelectionWithDeletion : ImGuiSelectionBasicStorage\n{\n    // Find which item should be Focused after deletion.\n    // Call _before_ item submission. Retunr an index in the before-deletion item list, your item loop should call SetKeyboardFocusHere() on it.\n    // The subsequent ApplyDeletionPostLoop() code will use it to apply Selection.\n    // - We cannot provide this logic in core Dear ImGui because we don't have access to selection data.\n    // - We don't actually manipulate the ImVector<> here, only in ApplyDeletionPostLoop(), but using similar API for consistency and flexibility.\n    // - Important: Deletion only works if the underlying ImGuiID for your items are stable: aka not depend on their index, but on e.g. item id/ptr.\n    // FIXME-MULTISELECT: Doesn't take account of the possibility focus target will be moved during deletion. Need refocus or scroll offset.\n    int ApplyDeletionPreLoop(ImGuiMultiSelectIO* ms_io, int items_count)\n    {\n        if (Size == 0)\n            return -1;\n\n        // If focused item is not selected...\n        const int focused_idx = (int)ms_io->NavIdItem;  // Index of currently focused item\n        if (ms_io->NavIdSelected == false)  // This is merely a shortcut, == Contains(adapter->IndexToStorage(items, focused_idx))\n        {\n            ms_io->RangeSrcReset = true;    // Request to recover RangeSrc from NavId next frame. Would be ok to reset even when NavIdSelected==true, but it would take an extra frame to recover RangeSrc when deleting a selected item.\n            return focused_idx;             // Request to focus same item after deletion.\n        }\n\n        // If focused item is selected: land on first unselected item after focused item.\n        for (int idx = focused_idx + 1; idx < items_count; idx++)\n            if (!Contains(GetStorageIdFromIndex(idx)))\n                return idx;\n\n        // If focused item is selected: otherwise return last unselected item before focused item.\n        for (int idx = IM_MIN(focused_idx, items_count) - 1; idx >= 0; idx--)\n            if (!Contains(GetStorageIdFromIndex(idx)))\n                return idx;\n\n        return -1;\n    }\n\n    // Rewrite item list (delete items) + update selection.\n    // - Call after EndMultiSelect()\n    // - We cannot provide this logic in core Dear ImGui because we don't have access to your items, nor to selection data.\n    template<typename ITEM_TYPE>\n    void ApplyDeletionPostLoop(ImGuiMultiSelectIO* ms_io, ImVector<ITEM_TYPE>& items, int item_curr_idx_to_select)\n    {\n        // Rewrite item list (delete items) + convert old selection index (before deletion) to new selection index (after selection).\n        // If NavId was not part of selection, we will stay on same item.\n        ImVector<ITEM_TYPE> new_items;\n        new_items.reserve(items.Size - Size);\n        int item_next_idx_to_select = -1;\n        for (int idx = 0; idx < items.Size; idx++)\n        {\n            if (!Contains(GetStorageIdFromIndex(idx)))\n                new_items.push_back(items[idx]);\n            if (item_curr_idx_to_select == idx)\n                item_next_idx_to_select = new_items.Size - 1;\n        }\n        items.swap(new_items);\n\n        // Update selection\n        Clear();\n        if (item_next_idx_to_select != -1 && ms_io->NavIdSelected)\n            SetItemSelected(GetStorageIdFromIndex(item_next_idx_to_select), true);\n    }\n};\n\n// Example: Implement dual list box storage and interface\nstruct ExampleDualListBox\n{\n    ImVector<ImGuiID>           Items[2];               // ID is index into ExampleName[]\n    ImGuiSelectionBasicStorage  Selections[2];          // Store ExampleItemId into selection\n    bool                        OptKeepSorted = true;\n\n    void MoveAll(int src, int dst)\n    {\n        IM_ASSERT((src == 0 && dst == 1) || (src == 1 && dst == 0));\n        for (ImGuiID item_id : Items[src])\n            Items[dst].push_back(item_id);\n        Items[src].clear();\n        SortItems(dst);\n        Selections[src].Swap(Selections[dst]);\n        Selections[src].Clear();\n    }\n    void MoveSelected(int src, int dst)\n    {\n        for (int src_n = 0; src_n < Items[src].Size; src_n++)\n        {\n            ImGuiID item_id = Items[src][src_n];\n            if (!Selections[src].Contains(item_id))\n                continue;\n            Items[src].erase(&Items[src][src_n]); // FIXME-OPT: Could be implemented more optimally (rebuild src items and swap)\n            Items[dst].push_back(item_id);\n            src_n--;\n        }\n        if (OptKeepSorted)\n            SortItems(dst);\n        Selections[src].Swap(Selections[dst]);\n        Selections[src].Clear();\n    }\n    void ApplySelectionRequests(ImGuiMultiSelectIO* ms_io, int side)\n    {\n        // In this example we store item id in selection (instead of item index)\n        Selections[side].UserData = Items[side].Data;\n        Selections[side].AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { ImGuiID* items = (ImGuiID*)self->UserData; return items[idx]; };\n        Selections[side].ApplyRequests(ms_io);\n    }\n    static int IMGUI_CDECL CompareItemsByValue(const void* lhs, const void* rhs)\n    {\n        const int* a = (const int*)lhs;\n        const int* b = (const int*)rhs;\n        return (*a - *b) > 0 ? +1 : -1;\n    }\n    void SortItems(int n)\n    {\n        qsort(Items[n].Data, (size_t)Items[n].Size, sizeof(Items[n][0]), CompareItemsByValue);\n    }\n    void Show()\n    {\n        //ImGui::Checkbox(\"Sorted\", &OptKeepSorted);\n        if (ImGui::BeginTable(\"split\", 3, ImGuiTableFlags_None))\n        {\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthStretch);    // Left side\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthFixed);      // Buttons\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthStretch);    // Right side\n            ImGui::TableNextRow();\n\n            int request_move_selected = -1;\n            int request_move_all = -1;\n            float child_height_0 = 0.0f;\n            for (int side = 0; side < 2; side++)\n            {\n                // FIXME-MULTISELECT: Dual List Box: Add context menus\n                // FIXME-NAV: Using ImGuiWindowFlags_NavFlattened exhibit many issues.\n                ImVector<ImGuiID>& items = Items[side];\n                ImGuiSelectionBasicStorage& selection = Selections[side];\n\n                ImGui::TableSetColumnIndex((side == 0) ? 0 : 2);\n                ImGui::Text(\"%s (%d)\", (side == 0) ? \"Available\" : \"Basket\", items.Size);\n\n                // Submit scrolling range to avoid glitches on moving/deletion\n                const float items_height = ImGui::GetTextLineHeightWithSpacing();\n                ImGui::SetNextWindowContentSize(ImVec2(0.0f, items.Size * items_height));\n\n                bool child_visible;\n                if (side == 0)\n                {\n                    // Left child is resizable\n                    ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, ImGui::GetFrameHeightWithSpacing() * 4), ImVec2(FLT_MAX, FLT_MAX));\n                    child_visible = ImGui::BeginChild(\"0\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY);\n                    child_height_0 = ImGui::GetWindowSize().y;\n                }\n                else\n                {\n                    // Right child use same height as left one\n                    child_visible = ImGui::BeginChild(\"1\", ImVec2(-FLT_MIN, child_height_0), ImGuiChildFlags_FrameStyle);\n                }\n                if (child_visible)\n                {\n                    ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_None;\n                    ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, items.Size);\n                    ApplySelectionRequests(ms_io, side);\n\n                    for (int item_n = 0; item_n < items.Size; item_n++)\n                    {\n                        ImGuiID item_id = items[item_n];\n                        bool item_is_selected = selection.Contains(item_id);\n                        ImGui::SetNextItemSelectionUserData(item_n);\n                        ImGui::Selectable(ExampleNames[item_id], item_is_selected, ImGuiSelectableFlags_AllowDoubleClick);\n                        if (ImGui::IsItemFocused())\n                        {\n                            // FIXME-MULTISELECT: Dual List Box: Transfer focus\n                            if (ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter))\n                                request_move_selected = side;\n                            if (ImGui::IsMouseDoubleClicked(0)) // FIXME-MULTISELECT: Double-click on multi-selection?\n                                request_move_selected = side;\n                        }\n                    }\n\n                    ms_io = ImGui::EndMultiSelect();\n                    ApplySelectionRequests(ms_io, side);\n                }\n                ImGui::EndChild();\n            }\n\n            // Buttons columns\n            ImGui::TableSetColumnIndex(1);\n            ImGui::NewLine();\n            //ImVec2 button_sz = { ImGui::CalcTextSize(\">>\").x + ImGui::GetStyle().FramePadding.x * 2.0f, ImGui::GetFrameHeight() + padding.y * 2.0f };\n            ImVec2 button_sz = { ImGui::GetFrameHeight(), ImGui::GetFrameHeight() };\n\n            // (Using BeginDisabled()/EndDisabled() works but feels distracting given how it is currently visualized)\n            if (ImGui::Button(\">>\", button_sz))\n                request_move_all = 0;\n            if (ImGui::Button(\">\", button_sz))\n                request_move_selected = 0;\n            if (ImGui::Button(\"<\", button_sz))\n                request_move_selected = 1;\n            if (ImGui::Button(\"<<\", button_sz))\n                request_move_all = 1;\n\n            // Process requests\n            if (request_move_all != -1)\n                MoveAll(request_move_all, request_move_all ^ 1);\n            if (request_move_selected != -1)\n                MoveSelected(request_move_selected, request_move_selected ^ 1);\n\n            // FIXME-MULTISELECT: Support action from outside\n            /*\n            if (OptKeepSorted == false)\n            {\n                ImGui::NewLine();\n                if (ImGui::ArrowButton(\"MoveUp\", ImGuiDir_Up)) {}\n                if (ImGui::ArrowButton(\"MoveDown\", ImGuiDir_Down)) {}\n            }\n            */\n\n            ImGui::EndTable();\n        }\n    }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowMultiSelect()\n//-----------------------------------------------------------------------------\n// Multi-selection demos\n// Also read: https://github.com/ocornut/imgui/wiki/Multi-Select\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowMultiSelect(ImGuiDemoWindowData* demo_data)\n{\n    IMGUI_DEMO_MARKER(\"Widgets/Selection State & Multi-Select\");\n    if (ImGui::TreeNode(\"Selection State & Multi-Select\"))\n    {\n        HelpMarker(\"Selections can be built using Selectable(), TreeNode() or other widgets. Selection state is owned by application code/data.\");\n\n        // Without any fancy API: manage single-selection yourself.\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Single-Select\");\n        if (ImGui::TreeNode(\"Single-Select\"))\n        {\n            static int selected = -1;\n            for (int n = 0; n < 5; n++)\n            {\n                char buf[32];\n                sprintf(buf, \"Object %d\", n);\n                if (ImGui::Selectable(buf, selected == n))\n                    selected = n;\n            }\n            ImGui::TreePop();\n        }\n\n        // Demonstrate implementation a most-basic form of multi-selection manually\n        // This doesn't support the SHIFT modifier which requires BeginMultiSelect()!\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (manual/simplified, without BeginMultiSelect)\");\n        if (ImGui::TreeNode(\"Multi-Select (manual/simplified, without BeginMultiSelect)\"))\n        {\n            HelpMarker(\"Hold CTRL and click to select multiple items.\");\n            static bool selection[5] = { false, false, false, false, false };\n            for (int n = 0; n < 5; n++)\n            {\n                char buf[32];\n                sprintf(buf, \"Object %d\", n);\n                if (ImGui::Selectable(buf, selection[n]))\n                {\n                    if (!ImGui::GetIO().KeyCtrl) // Clear selection when CTRL is not held\n                        memset(selection, 0, sizeof(selection));\n                    selection[n] ^= 1; // Toggle current item\n                }\n            }\n            ImGui::TreePop();\n        }\n\n        // Demonstrate handling proper multi-selection using the BeginMultiSelect/EndMultiSelect API.\n        // SHIFT+Click w/ CTRL and other standard features are supported.\n        // We use the ImGuiSelectionBasicStorage helper which you may freely reimplement.\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select\");\n        if (ImGui::TreeNode(\"Multi-Select\"))\n        {\n            ImGui::Text(\"Supported features:\");\n            ImGui::BulletText(\"Keyboard navigation (arrows, page up/down, home/end, space).\");\n            ImGui::BulletText(\"Ctrl modifier to preserve and toggle selection.\");\n            ImGui::BulletText(\"Shift modifier for range selection.\");\n            ImGui::BulletText(\"CTRL+A to select all.\");\n            ImGui::BulletText(\"Escape to clear selection.\");\n            ImGui::BulletText(\"Click and drag to box-select.\");\n            ImGui::Text(\"Tip: Use 'Demo->Tools->Debug Log->Selection' to see selection requests as they happen.\");\n\n            // Use default selection.Adapter: Pass index to SetNextItemSelectionUserData(), store index in Selection\n            const int ITEMS_COUNT = 50;\n            static ImGuiSelectionBasicStorage selection;\n            ImGui::Text(\"Selection: %d/%d\", selection.Size, ITEMS_COUNT);\n\n            // The BeginChild() has no purpose for selection logic, other that offering a scrolling region.\n            if (ImGui::BeginChild(\"##Basket\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))\n            {\n                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, ITEMS_COUNT);\n                selection.ApplyRequests(ms_io);\n\n                for (int n = 0; n < ITEMS_COUNT; n++)\n                {\n                    char label[64];\n                    sprintf(label, \"Object %05d: %s\", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);\n                    bool item_is_selected = selection.Contains((ImGuiID)n);\n                    ImGui::SetNextItemSelectionUserData(n);\n                    ImGui::Selectable(label, item_is_selected);\n                }\n\n                ms_io = ImGui::EndMultiSelect();\n                selection.ApplyRequests(ms_io);\n            }\n            ImGui::EndChild();\n            ImGui::TreePop();\n        }\n\n        // Demonstrate using the clipper with BeginMultiSelect()/EndMultiSelect()\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (with clipper)\");\n        if (ImGui::TreeNode(\"Multi-Select (with clipper)\"))\n        {\n            // Use default selection.Adapter: Pass index to SetNextItemSelectionUserData(), store index in Selection\n            static ImGuiSelectionBasicStorage selection;\n\n            ImGui::Text(\"Added features:\");\n            ImGui::BulletText(\"Using ImGuiListClipper.\");\n\n            const int ITEMS_COUNT = 10000;\n            ImGui::Text(\"Selection: %d/%d\", selection.Size, ITEMS_COUNT);\n            if (ImGui::BeginChild(\"##Basket\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))\n            {\n                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, ITEMS_COUNT);\n                selection.ApplyRequests(ms_io);\n\n                ImGuiListClipper clipper;\n                clipper.Begin(ITEMS_COUNT);\n                if (ms_io->RangeSrcItem != -1)\n                    clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem); // Ensure RangeSrc item is not clipped.\n                while (clipper.Step())\n                {\n                    for (int n = clipper.DisplayStart; n < clipper.DisplayEnd; n++)\n                    {\n                        char label[64];\n                        sprintf(label, \"Object %05d: %s\", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);\n                        bool item_is_selected = selection.Contains((ImGuiID)n);\n                        ImGui::SetNextItemSelectionUserData(n);\n                        ImGui::Selectable(label, item_is_selected);\n                    }\n                }\n\n                ms_io = ImGui::EndMultiSelect();\n                selection.ApplyRequests(ms_io);\n            }\n            ImGui::EndChild();\n            ImGui::TreePop();\n        }\n\n        // Demonstrate dynamic item list + deletion support using the BeginMultiSelect/EndMultiSelect API.\n        // In order to support Deletion without any glitches you need to:\n        // - (1) If items are submitted in their own scrolling area, submit contents size SetNextWindowContentSize() ahead of time to prevent one-frame readjustment of scrolling.\n        // - (2) Items needs to have persistent ID Stack identifier = ID needs to not depends on their index. PushID(index) = KO. PushID(item_id) = OK. This is in order to focus items reliably after a selection.\n        // - (3) BeginXXXX process\n        // - (4) Focus process\n        // - (5) EndXXXX process\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (with deletion)\");\n        if (ImGui::TreeNode(\"Multi-Select (with deletion)\"))\n        {\n            // Storing items data separately from selection data.\n            // (you may decide to store selection data inside your item (aka intrusive storage) if you don't need multiple views over same items)\n            // Use a custom selection.Adapter: store item identifier in Selection (instead of index)\n            static ImVector<ImGuiID> items;\n            static ExampleSelectionWithDeletion selection;\n            selection.UserData = (void*)&items;\n            selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { ImVector<ImGuiID>* p_items = (ImVector<ImGuiID>*)self->UserData; return (*p_items)[idx]; }; // Index -> ID\n\n            ImGui::Text(\"Added features:\");\n            ImGui::BulletText(\"Dynamic list with Delete key support.\");\n            ImGui::Text(\"Selection size: %d/%d\", selection.Size, items.Size);\n\n            // Initialize default list with 50 items + button to add/remove items.\n            static ImGuiID items_next_id = 0;\n            if (items_next_id == 0)\n                for (ImGuiID n = 0; n < 50; n++)\n                    items.push_back(items_next_id++);\n            if (ImGui::SmallButton(\"Add 20 items\"))     { for (int n = 0; n < 20; n++) { items.push_back(items_next_id++); } }\n            ImGui::SameLine();\n            if (ImGui::SmallButton(\"Remove 20 items\"))  { for (int n = IM_MIN(20, items.Size); n > 0; n--) { selection.SetItemSelected(items.back(), false); items.pop_back(); } }\n\n            // (1) Extra to support deletion: Submit scrolling range to avoid glitches on deletion\n            const float items_height = ImGui::GetTextLineHeightWithSpacing();\n            ImGui::SetNextWindowContentSize(ImVec2(0.0f, items.Size * items_height));\n\n            if (ImGui::BeginChild(\"##Basket\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))\n            {\n                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, items.Size);\n                selection.ApplyRequests(ms_io);\n\n                const bool want_delete = ImGui::Shortcut(ImGuiKey_Delete, ImGuiInputFlags_Repeat) && (selection.Size > 0);\n                const int item_curr_idx_to_focus = want_delete ? selection.ApplyDeletionPreLoop(ms_io, items.Size) : -1;\n\n                for (int n = 0; n < items.Size; n++)\n                {\n                    const ImGuiID item_id = items[n];\n                    char label[64];\n                    sprintf(label, \"Object %05u: %s\", item_id, ExampleNames[item_id % IM_ARRAYSIZE(ExampleNames)]);\n\n                    bool item_is_selected = selection.Contains(item_id);\n                    ImGui::SetNextItemSelectionUserData(n);\n                    ImGui::Selectable(label, item_is_selected);\n                    if (item_curr_idx_to_focus == n)\n                        ImGui::SetKeyboardFocusHere(-1);\n                }\n\n                // Apply multi-select requests\n                ms_io = ImGui::EndMultiSelect();\n                selection.ApplyRequests(ms_io);\n                if (want_delete)\n                    selection.ApplyDeletionPostLoop(ms_io, items, item_curr_idx_to_focus);\n            }\n            ImGui::EndChild();\n            ImGui::TreePop();\n        }\n\n        // Implement a Dual List Box (#6648)\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (dual list box)\");\n        if (ImGui::TreeNode(\"Multi-Select (dual list box)\"))\n        {\n            // Init default state\n            static ExampleDualListBox dlb;\n            if (dlb.Items[0].Size == 0 && dlb.Items[1].Size == 0)\n                for (int item_id = 0; item_id < IM_ARRAYSIZE(ExampleNames); item_id++)\n                    dlb.Items[0].push_back((ImGuiID)item_id);\n\n            // Show\n            dlb.Show();\n\n            ImGui::TreePop();\n        }\n\n        // Demonstrate using the clipper with BeginMultiSelect()/EndMultiSelect()\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (in a table)\");\n        if (ImGui::TreeNode(\"Multi-Select (in a table)\"))\n        {\n            static ImGuiSelectionBasicStorage selection;\n\n            const int ITEMS_COUNT = 10000;\n            ImGui::Text(\"Selection: %d/%d\", selection.Size, ITEMS_COUNT);\n            if (ImGui::BeginTable(\"##Basket\", 2, ImGuiTableFlags_ScrollY | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter))\n            {\n                ImGui::TableSetupColumn(\"Object\");\n                ImGui::TableSetupColumn(\"Action\");\n                ImGui::TableSetupScrollFreeze(0, 1);\n                ImGui::TableHeadersRow();\n\n                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, ITEMS_COUNT);\n                selection.ApplyRequests(ms_io);\n\n                ImGuiListClipper clipper;\n                clipper.Begin(ITEMS_COUNT);\n                if (ms_io->RangeSrcItem != -1)\n                    clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem); // Ensure RangeSrc item is not clipped.\n                while (clipper.Step())\n                {\n                    for (int n = clipper.DisplayStart; n < clipper.DisplayEnd; n++)\n                    {\n                        ImGui::TableNextRow();\n                        ImGui::TableNextColumn();\n                        char label[64];\n                        sprintf(label, \"Object %05d: %s\", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);\n                        bool item_is_selected = selection.Contains((ImGuiID)n);\n                        ImGui::SetNextItemSelectionUserData(n);\n                        ImGui::Selectable(label, item_is_selected, ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowOverlap);\n                        ImGui::TableNextColumn();\n                        ImGui::SmallButton(\"hello\");\n                    }\n                }\n\n                ms_io = ImGui::EndMultiSelect();\n                selection.ApplyRequests(ms_io);\n                ImGui::EndTable();\n            }\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (checkboxes)\");\n        if (ImGui::TreeNode(\"Multi-Select (checkboxes)\"))\n        {\n            ImGui::Text(\"In a list of checkboxes (not selectable):\");\n            ImGui::BulletText(\"Using _NoAutoSelect + _NoAutoClear flags.\");\n            ImGui::BulletText(\"Shift+Click to check multiple boxes.\");\n            ImGui::BulletText(\"Shift+Keyboard to copy current value to other boxes.\");\n\n            // If you have an array of checkboxes, you may want to use NoAutoSelect + NoAutoClear and the ImGuiSelectionExternalStorage helper.\n            static bool items[20] = {};\n            static ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_NoAutoSelect | ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_ClearOnEscape;\n            ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoAutoSelect\", &flags, ImGuiMultiSelectFlags_NoAutoSelect);\n            ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoAutoClear\", &flags, ImGuiMultiSelectFlags_NoAutoClear);\n            ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_BoxSelect2d\", &flags, ImGuiMultiSelectFlags_BoxSelect2d); // Cannot use ImGuiMultiSelectFlags_BoxSelect1d as checkboxes are varying width.\n\n            if (ImGui::BeginChild(\"##Basket\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY))\n            {\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, -1, IM_ARRAYSIZE(items));\n                ImGuiSelectionExternalStorage storage_wrapper;\n                storage_wrapper.UserData = (void*)items;\n                storage_wrapper.AdapterSetItemSelected = [](ImGuiSelectionExternalStorage* self, int n, bool selected) { bool* array = (bool*)self->UserData; array[n] = selected; };\n                storage_wrapper.ApplyRequests(ms_io);\n                for (int n = 0; n < 20; n++)\n                {\n                    char label[32];\n                    sprintf(label, \"Item %d\", n);\n                    ImGui::SetNextItemSelectionUserData(n);\n                    ImGui::Checkbox(label, &items[n]);\n                }\n                ms_io = ImGui::EndMultiSelect();\n                storage_wrapper.ApplyRequests(ms_io);\n            }\n            ImGui::EndChild();\n\n            ImGui::TreePop();\n        }\n\n        // Demonstrate individual selection scopes in same window\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (multiple scopes)\");\n        if (ImGui::TreeNode(\"Multi-Select (multiple scopes)\"))\n        {\n            // Use default select: Pass index to SetNextItemSelectionUserData(), store index in Selection\n            const int SCOPES_COUNT = 3;\n            const int ITEMS_COUNT = 8; // Per scope\n            static ImGuiSelectionBasicStorage selections_data[SCOPES_COUNT];\n\n            // Use ImGuiMultiSelectFlags_ScopeRect to not affect other selections in same window.\n            static ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ScopeRect | ImGuiMultiSelectFlags_ClearOnEscape;// | ImGuiMultiSelectFlags_ClearOnClickVoid;\n            if (ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ScopeWindow\", &flags, ImGuiMultiSelectFlags_ScopeWindow) && (flags & ImGuiMultiSelectFlags_ScopeWindow))\n                flags &= ~ImGuiMultiSelectFlags_ScopeRect;\n            if (ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ScopeRect\", &flags, ImGuiMultiSelectFlags_ScopeRect) && (flags & ImGuiMultiSelectFlags_ScopeRect))\n                flags &= ~ImGuiMultiSelectFlags_ScopeWindow;\n            ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ClearOnClickVoid\", &flags, ImGuiMultiSelectFlags_ClearOnClickVoid);\n            ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_BoxSelect1d\", &flags, ImGuiMultiSelectFlags_BoxSelect1d);\n\n            for (int selection_scope_n = 0; selection_scope_n < SCOPES_COUNT; selection_scope_n++)\n            {\n                ImGui::PushID(selection_scope_n);\n                ImGuiSelectionBasicStorage* selection = &selections_data[selection_scope_n];\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection->Size, ITEMS_COUNT);\n                selection->ApplyRequests(ms_io);\n\n                ImGui::SeparatorText(\"Selection scope\");\n                ImGui::Text(\"Selection size: %d/%d\", selection->Size, ITEMS_COUNT);\n\n                for (int n = 0; n < ITEMS_COUNT; n++)\n                {\n                    char label[64];\n                    sprintf(label, \"Object %05d: %s\", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);\n                    bool item_is_selected = selection->Contains((ImGuiID)n);\n                    ImGui::SetNextItemSelectionUserData(n);\n                    ImGui::Selectable(label, item_is_selected);\n                }\n\n                // Apply multi-select requests\n                ms_io = ImGui::EndMultiSelect();\n                selection->ApplyRequests(ms_io);\n                ImGui::PopID();\n            }\n            ImGui::TreePop();\n        }\n\n        // See ShowExampleAppAssetsBrowser()\n        if (ImGui::TreeNode(\"Multi-Select (tiled assets browser)\"))\n        {\n            ImGui::Checkbox(\"Assets Browser\", &demo_data->ShowAppAssetsBrowser);\n            ImGui::Text(\"(also access from 'Examples->Assets Browser' in menu)\");\n            ImGui::TreePop();\n        }\n\n        // Demonstrate supporting multiple-selection in a tree.\n        // - We don't use linear indices for selection user data, but our ExampleTreeNode* pointer directly!\n        //   This showcase how SetNextItemSelectionUserData() never assume indices!\n        // - The difficulty here is to \"interpolate\" from RangeSrcItem to RangeDstItem in the SetAll/SetRange request.\n        //   We want this interpolation to match what the user sees: in visible order, skipping closed nodes.\n        //   This is implemented by our TreeGetNextNodeInVisibleOrder() user-space helper.\n        // - Important: In a real codebase aiming to implement full-featured selectable tree with custom filtering, you\n        //   are more likely to build an array mapping sequential indices to visible tree nodes, since your\n        //   filtering/search + clipping process will benefit from it. Having this will make this interpolation much easier.\n        // - Consider this a prototype: we are working toward simplifying some of it.\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (trees)\");\n        if (ImGui::TreeNode(\"Multi-Select (trees)\"))\n        {\n            HelpMarker(\n                \"This is rather advanced and experimental. If you are getting started with multi-select,\"\n                \"please don't start by looking at how to use it for a tree!\\n\\n\"\n                \"Future versions will try to simplify and formalize some of this.\");\n\n            struct ExampleTreeFuncs\n            {\n                static void DrawNode(ExampleTreeNode* node, ImGuiSelectionBasicStorage* selection)\n                {\n                    ImGuiTreeNodeFlags tree_node_flags = ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;\n                    tree_node_flags |= ImGuiTreeNodeFlags_NavLeftJumpsBackHere; // Enable pressing left to jump to parent\n                    if (node->Childs.Size == 0)\n                        tree_node_flags |= ImGuiTreeNodeFlags_Bullet | ImGuiTreeNodeFlags_Leaf;\n                    if (selection->Contains((ImGuiID)node->UID))\n                        tree_node_flags |= ImGuiTreeNodeFlags_Selected;\n\n                    // Using SetNextItemStorageID() to specify storage id, so we can easily peek into\n                    // the storage holding open/close stage, using our TreeNodeGetOpen/TreeNodeSetOpen() functions.\n                    ImGui::SetNextItemSelectionUserData((ImGuiSelectionUserData)(intptr_t)node);\n                    ImGui::SetNextItemStorageID((ImGuiID)node->UID);\n                    if (ImGui::TreeNodeEx(node->Name, tree_node_flags))\n                    {\n                        for (ExampleTreeNode* child : node->Childs)\n                            DrawNode(child, selection);\n                        ImGui::TreePop();\n                    }\n                    else if (ImGui::IsItemToggledOpen())\n                    {\n                        TreeCloseAndUnselectChildNodes(node, selection);\n                    }\n                }\n\n                static bool TreeNodeGetOpen(ExampleTreeNode* node)\n                {\n                    return ImGui::GetStateStorage()->GetBool((ImGuiID)node->UID);\n                }\n\n                static void TreeNodeSetOpen(ExampleTreeNode* node, bool open)\n                {\n                    ImGui::GetStateStorage()->SetBool((ImGuiID)node->UID, open);\n                }\n\n                // When closing a node: 1) close and unselect all child nodes, 2) select parent if any child was selected.\n                // FIXME: This is currently handled by user logic but I'm hoping to eventually provide tree node\n                // features to do this automatically, e.g. a ImGuiTreeNodeFlags_AutoCloseChildNodes etc.\n                static int TreeCloseAndUnselectChildNodes(ExampleTreeNode* node, ImGuiSelectionBasicStorage* selection, int depth = 0)\n                {\n                    // Recursive close (the test for depth == 0 is because we call this on a node that was just closed!)\n                    int unselected_count = selection->Contains((ImGuiID)node->UID) ? 1 : 0;\n                    if (depth == 0 || TreeNodeGetOpen(node))\n                    {\n                        for (ExampleTreeNode* child : node->Childs)\n                            unselected_count += TreeCloseAndUnselectChildNodes(child, selection, depth + 1);\n                        TreeNodeSetOpen(node, false);\n                    }\n\n                    // Select root node if any of its child was selected, otherwise unselect\n                    selection->SetItemSelected((ImGuiID)node->UID, (depth == 0 && unselected_count > 0));\n                    return unselected_count;\n                }\n\n                // Apply multi-selection requests\n                static void ApplySelectionRequests(ImGuiMultiSelectIO* ms_io, ExampleTreeNode* tree, ImGuiSelectionBasicStorage* selection)\n                {\n                    for (ImGuiSelectionRequest& req : ms_io->Requests)\n                    {\n                        if (req.Type == ImGuiSelectionRequestType_SetAll)\n                        {\n                            if (req.Selected)\n                                TreeSetAllInOpenNodes(tree, selection, req.Selected);\n                            else\n                                selection->Clear();\n                        }\n                        else if (req.Type == ImGuiSelectionRequestType_SetRange)\n                        {\n                            ExampleTreeNode* first_node = (ExampleTreeNode*)(intptr_t)req.RangeFirstItem;\n                            ExampleTreeNode* last_node = (ExampleTreeNode*)(intptr_t)req.RangeLastItem;\n                            for (ExampleTreeNode* node = first_node; node != NULL; node = TreeGetNextNodeInVisibleOrder(node, last_node))\n                                selection->SetItemSelected((ImGuiID)node->UID, req.Selected);\n                        }\n                    }\n                }\n\n                static void TreeSetAllInOpenNodes(ExampleTreeNode* node, ImGuiSelectionBasicStorage* selection, bool selected)\n                {\n                    if (node->Parent != NULL) // Root node isn't visible nor selectable in our scheme\n                        selection->SetItemSelected((ImGuiID)node->UID, selected);\n                    if (node->Parent == NULL || TreeNodeGetOpen(node))\n                        for (ExampleTreeNode* child : node->Childs)\n                            TreeSetAllInOpenNodes(child, selection, selected);\n                }\n\n                // Interpolate in *user-visible order* AND only *over opened nodes*.\n                // If you have a sequential mapping tables (e.g. generated after a filter/search pass) this would be simpler.\n                // Here the tricks are that:\n                // - we store/maintain ExampleTreeNode::IndexInParent which allows implementing a linear iterator easily, without searches, without recursion.\n                //   this could be replaced by a search in parent, aka 'int index_in_parent = curr_node->Parent->Childs.find_index(curr_node)'\n                //   which would only be called when crossing from child to a parent, aka not too much.\n                // - we call SetNextItemStorageID() before our TreeNode() calls with an ID which doesn't relate to UI stack,\n                //   making it easier to call TreeNodeGetOpen()/TreeNodeSetOpen() from any location.\n                static ExampleTreeNode* TreeGetNextNodeInVisibleOrder(ExampleTreeNode* curr_node, ExampleTreeNode* last_node)\n                {\n                    // Reached last node\n                    if (curr_node == last_node)\n                        return NULL;\n\n                    // Recurse into childs. Query storage to tell if the node is open.\n                    if (curr_node->Childs.Size > 0 && TreeNodeGetOpen(curr_node))\n                        return curr_node->Childs[0];\n\n                    // Next sibling, then into our own parent\n                    while (curr_node->Parent != NULL)\n                    {\n                        if (curr_node->IndexInParent + 1 < curr_node->Parent->Childs.Size)\n                            return curr_node->Parent->Childs[curr_node->IndexInParent + 1];\n                        curr_node = curr_node->Parent;\n                    }\n                    return NULL;\n                }\n\n            }; // ExampleTreeFuncs\n\n            static ImGuiSelectionBasicStorage selection;\n            if (demo_data->DemoTree == NULL)\n                demo_data->DemoTree = ExampleTree_CreateDemoTree(); // Create tree once\n            ImGui::Text(\"Selection size: %d\", selection.Size);\n\n            if (ImGui::BeginChild(\"##Tree\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))\n            {\n                ExampleTreeNode* tree = demo_data->DemoTree;\n                ImGuiMultiSelectFlags ms_flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect2d;\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(ms_flags, selection.Size, -1);\n                ExampleTreeFuncs::ApplySelectionRequests(ms_io, tree, &selection);\n                for (ExampleTreeNode* node : tree->Childs)\n                    ExampleTreeFuncs::DrawNode(node, &selection);\n                ms_io = ImGui::EndMultiSelect();\n                ExampleTreeFuncs::ApplySelectionRequests(ms_io, tree, &selection);\n            }\n            ImGui::EndChild();\n\n            ImGui::TreePop();\n        }\n\n        // Advanced demonstration of BeginMultiSelect()\n        // - Showcase clipping.\n        // - Showcase deletion.\n        // - Showcase basic drag and drop.\n        // - Showcase TreeNode variant (note that tree node don't expand in the demo: supporting expanding tree nodes + clipping a separate thing).\n        // - Showcase using inside a table.\n        IMGUI_DEMO_MARKER(\"Widgets/Selection State/Multi-Select (advanced)\");\n        //ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n        if (ImGui::TreeNode(\"Multi-Select (advanced)\"))\n        {\n            // Options\n            enum WidgetType { WidgetType_Selectable, WidgetType_TreeNode };\n            static bool use_clipper = true;\n            static bool use_deletion = true;\n            static bool use_drag_drop = true;\n            static bool show_in_table = false;\n            static bool show_color_button = true;\n            static ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;\n            static WidgetType widget_type = WidgetType_Selectable;\n\n            if (ImGui::TreeNode(\"Options\"))\n            {\n                if (ImGui::RadioButton(\"Selectables\", widget_type == WidgetType_Selectable)) { widget_type = WidgetType_Selectable; }\n                ImGui::SameLine();\n                if (ImGui::RadioButton(\"Tree nodes\", widget_type == WidgetType_TreeNode)) { widget_type = WidgetType_TreeNode; }\n                ImGui::SameLine();\n                HelpMarker(\"TreeNode() is technically supported but... using this correctly is more complicated (you need some sort of linear/random access to your tree, which is suited to advanced trees setups already implementing filters and clipper. We will work toward simplifying and demoing this.\\n\\nFor now the tree demo is actually a little bit meaningless because it is an empty tree with only root nodes.\");\n                ImGui::Checkbox(\"Enable clipper\", &use_clipper);\n                ImGui::Checkbox(\"Enable deletion\", &use_deletion);\n                ImGui::Checkbox(\"Enable drag & drop\", &use_drag_drop);\n                ImGui::Checkbox(\"Show in a table\", &show_in_table);\n                ImGui::Checkbox(\"Show color button\", &show_color_button);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_SingleSelect\", &flags, ImGuiMultiSelectFlags_SingleSelect);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoSelectAll\", &flags, ImGuiMultiSelectFlags_NoSelectAll);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoRangeSelect\", &flags, ImGuiMultiSelectFlags_NoRangeSelect);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoAutoSelect\", &flags, ImGuiMultiSelectFlags_NoAutoSelect);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoAutoClear\", &flags, ImGuiMultiSelectFlags_NoAutoClear);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_NoAutoClearOnReselect\", &flags, ImGuiMultiSelectFlags_NoAutoClearOnReselect);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_BoxSelect1d\", &flags, ImGuiMultiSelectFlags_BoxSelect1d);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_BoxSelect2d\", &flags, ImGuiMultiSelectFlags_BoxSelect2d);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_BoxSelectNoScroll\", &flags, ImGuiMultiSelectFlags_BoxSelectNoScroll);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ClearOnEscape\", &flags, ImGuiMultiSelectFlags_ClearOnEscape);\n                ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ClearOnClickVoid\", &flags, ImGuiMultiSelectFlags_ClearOnClickVoid);\n                if (ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ScopeWindow\", &flags, ImGuiMultiSelectFlags_ScopeWindow) && (flags & ImGuiMultiSelectFlags_ScopeWindow))\n                    flags &= ~ImGuiMultiSelectFlags_ScopeRect;\n                if (ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_ScopeRect\", &flags, ImGuiMultiSelectFlags_ScopeRect) && (flags & ImGuiMultiSelectFlags_ScopeRect))\n                    flags &= ~ImGuiMultiSelectFlags_ScopeWindow;\n                if (ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_SelectOnClick\", &flags, ImGuiMultiSelectFlags_SelectOnClick) && (flags & ImGuiMultiSelectFlags_SelectOnClick))\n                    flags &= ~ImGuiMultiSelectFlags_SelectOnClickRelease;\n                if (ImGui::CheckboxFlags(\"ImGuiMultiSelectFlags_SelectOnClickRelease\", &flags, ImGuiMultiSelectFlags_SelectOnClickRelease) && (flags & ImGuiMultiSelectFlags_SelectOnClickRelease))\n                    flags &= ~ImGuiMultiSelectFlags_SelectOnClick;\n                ImGui::SameLine(); HelpMarker(\"Allow dragging an unselected item without altering selection.\");\n                ImGui::TreePop();\n            }\n\n            // Initialize default list with 1000 items.\n            // Use default selection.Adapter: Pass index to SetNextItemSelectionUserData(), store index in Selection\n            static ImVector<int> items;\n            static int items_next_id = 0;\n            if (items_next_id == 0) { for (int n = 0; n < 1000; n++) { items.push_back(items_next_id++); } }\n            static ExampleSelectionWithDeletion selection;\n            static bool request_deletion_from_menu = false; // Queue deletion triggered from context menu\n\n            ImGui::Text(\"Selection size: %d/%d\", selection.Size, items.Size);\n\n            const float items_height = (widget_type == WidgetType_TreeNode) ? ImGui::GetTextLineHeight() : ImGui::GetTextLineHeightWithSpacing();\n            ImGui::SetNextWindowContentSize(ImVec2(0.0f, items.Size * items_height));\n            if (ImGui::BeginChild(\"##Basket\", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))\n            {\n                ImVec2 color_button_sz(ImGui::GetFontSize(), ImGui::GetFontSize());\n                if (widget_type == WidgetType_TreeNode)\n                    ImGui::PushStyleVarY(ImGuiStyleVar_ItemSpacing, 0.0f);\n\n                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, items.Size);\n                selection.ApplyRequests(ms_io);\n\n                const bool want_delete = (ImGui::Shortcut(ImGuiKey_Delete, ImGuiInputFlags_Repeat) && (selection.Size > 0)) || request_deletion_from_menu;\n                const int item_curr_idx_to_focus = want_delete ? selection.ApplyDeletionPreLoop(ms_io, items.Size) : -1;\n                request_deletion_from_menu = false;\n\n                if (show_in_table)\n                {\n                    if (widget_type == WidgetType_TreeNode)\n                        ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, ImVec2(0.0f, 0.0f));\n                    ImGui::BeginTable(\"##Split\", 2, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_NoPadOuterX);\n                    ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthStretch, 0.70f);\n                    ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthStretch, 0.30f);\n                    //ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacingY, 0.0f);\n                }\n\n                ImGuiListClipper clipper;\n                if (use_clipper)\n                {\n                    clipper.Begin(items.Size);\n                    if (item_curr_idx_to_focus != -1)\n                        clipper.IncludeItemByIndex(item_curr_idx_to_focus); // Ensure focused item is not clipped.\n                    if (ms_io->RangeSrcItem != -1)\n                        clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem); // Ensure RangeSrc item is not clipped.\n                }\n\n                while (!use_clipper || clipper.Step())\n                {\n                    const int item_begin = use_clipper ? clipper.DisplayStart : 0;\n                    const int item_end = use_clipper ? clipper.DisplayEnd : items.Size;\n                    for (int n = item_begin; n < item_end; n++)\n                    {\n                        if (show_in_table)\n                            ImGui::TableNextColumn();\n\n                        const int item_id = items[n];\n                        const char* item_category = ExampleNames[item_id % IM_ARRAYSIZE(ExampleNames)];\n                        char label[64];\n                        sprintf(label, \"Object %05d: %s\", item_id, item_category);\n\n                        // IMPORTANT: for deletion refocus to work we need object ID to be stable,\n                        // aka not depend on their index in the list. Here we use our persistent item_id\n                        // instead of index to build a unique ID that will persist.\n                        // (If we used PushID(index) instead, focus wouldn't be restored correctly after deletion).\n                        ImGui::PushID(item_id);\n\n                        // Emit a color button, to test that Shift+LeftArrow landing on an item that is not part\n                        // of the selection scope doesn't erroneously alter our selection.\n                        if (show_color_button)\n                        {\n                            ImU32 dummy_col = (ImU32)((unsigned int)n * 0xC250B74B) | IM_COL32_A_MASK;\n                            ImGui::ColorButton(\"##\", ImColor(dummy_col), ImGuiColorEditFlags_NoTooltip, color_button_sz);\n                            ImGui::SameLine();\n                        }\n\n                        // Submit item\n                        bool item_is_selected = selection.Contains((ImGuiID)n);\n                        bool item_is_open = false;\n                        ImGui::SetNextItemSelectionUserData(n);\n                        if (widget_type == WidgetType_Selectable)\n                        {\n                            ImGui::Selectable(label, item_is_selected, ImGuiSelectableFlags_None);\n                        }\n                        else if (widget_type == WidgetType_TreeNode)\n                        {\n                            ImGuiTreeNodeFlags tree_node_flags = ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;\n                            if (item_is_selected)\n                                tree_node_flags |= ImGuiTreeNodeFlags_Selected;\n                            item_is_open = ImGui::TreeNodeEx(label, tree_node_flags);\n                        }\n\n                        // Focus (for after deletion)\n                        if (item_curr_idx_to_focus == n)\n                            ImGui::SetKeyboardFocusHere(-1);\n\n                        // Drag and Drop\n                        if (use_drag_drop && ImGui::BeginDragDropSource())\n                        {\n                            // Create payload with full selection OR single unselected item.\n                            // (the later is only possible when using ImGuiMultiSelectFlags_SelectOnClickRelease)\n                            if (ImGui::GetDragDropPayload() == NULL)\n                            {\n                                ImVector<int> payload_items;\n                                void* it = NULL;\n                                ImGuiID id = 0;\n                                if (!item_is_selected)\n                                    payload_items.push_back(item_id);\n                                else\n                                    while (selection.GetNextSelectedItem(&it, &id))\n                                        payload_items.push_back((int)id);\n                                ImGui::SetDragDropPayload(\"MULTISELECT_DEMO_ITEMS\", payload_items.Data, (size_t)payload_items.size_in_bytes());\n                            }\n\n                            // Display payload content in tooltip\n                            const ImGuiPayload* payload = ImGui::GetDragDropPayload();\n                            const int* payload_items = (int*)payload->Data;\n                            const int payload_count = (int)payload->DataSize / (int)sizeof(int);\n                            if (payload_count == 1)\n                                ImGui::Text(\"Object %05d: %s\", payload_items[0], ExampleNames[payload_items[0] % IM_ARRAYSIZE(ExampleNames)]);\n                            else\n                                ImGui::Text(\"Dragging %d objects\", payload_count);\n\n                            ImGui::EndDragDropSource();\n                        }\n\n                        if (widget_type == WidgetType_TreeNode && item_is_open)\n                            ImGui::TreePop();\n\n                        // Right-click: context menu\n                        if (ImGui::BeginPopupContextItem())\n                        {\n                            ImGui::BeginDisabled(!use_deletion || selection.Size == 0);\n                            sprintf(label, \"Delete %d item(s)###DeleteSelected\", selection.Size);\n                            if (ImGui::Selectable(label))\n                                request_deletion_from_menu = true;\n                            ImGui::EndDisabled();\n                            ImGui::Selectable(\"Close\");\n                            ImGui::EndPopup();\n                        }\n\n                        // Demo content within a table\n                        if (show_in_table)\n                        {\n                            ImGui::TableNextColumn();\n                            ImGui::SetNextItemWidth(-FLT_MIN);\n                            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n                            ImGui::InputText(\"###NoLabel\", (char*)(void*)item_category, strlen(item_category), ImGuiInputTextFlags_ReadOnly);\n                            ImGui::PopStyleVar();\n                        }\n\n                        ImGui::PopID();\n                    }\n                    if (!use_clipper)\n                        break;\n                }\n\n                if (show_in_table)\n                {\n                    ImGui::EndTable();\n                    if (widget_type == WidgetType_TreeNode)\n                        ImGui::PopStyleVar();\n                }\n\n                // Apply multi-select requests\n                ms_io = ImGui::EndMultiSelect();\n                selection.ApplyRequests(ms_io);\n                if (want_delete)\n                    selection.ApplyDeletionPostLoop(ms_io, items, item_curr_idx_to_focus);\n\n                if (widget_type == WidgetType_TreeNode)\n                    ImGui::PopStyleVar();\n            }\n            ImGui::EndChild();\n            ImGui::TreePop();\n        }\n        ImGui::TreePop();\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowLayout()\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowLayout()\n{\n    IMGUI_DEMO_MARKER(\"Layout\");\n    if (!ImGui::CollapsingHeader(\"Layout & Scrolling\"))\n        return;\n\n    IMGUI_DEMO_MARKER(\"Layout/Child windows\");\n    if (ImGui::TreeNode(\"Child windows\"))\n    {\n        ImGui::SeparatorText(\"Child windows\");\n\n        HelpMarker(\"Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window.\");\n        static bool disable_mouse_wheel = false;\n        static bool disable_menu = false;\n        ImGui::Checkbox(\"Disable Mouse Wheel\", &disable_mouse_wheel);\n        ImGui::Checkbox(\"Disable Menu\", &disable_menu);\n\n        // Child 1: no border, enable horizontal scrollbar\n        {\n            ImGuiWindowFlags window_flags = ImGuiWindowFlags_HorizontalScrollbar;\n            if (disable_mouse_wheel)\n                window_flags |= ImGuiWindowFlags_NoScrollWithMouse;\n            ImGui::BeginChild(\"ChildL\", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, 260), ImGuiChildFlags_None, window_flags);\n            for (int i = 0; i < 100; i++)\n                ImGui::Text(\"%04d: scrollable region\", i);\n            ImGui::EndChild();\n        }\n\n        ImGui::SameLine();\n\n        // Child 2: rounded border\n        {\n            ImGuiWindowFlags window_flags = ImGuiWindowFlags_None;\n            if (disable_mouse_wheel)\n                window_flags |= ImGuiWindowFlags_NoScrollWithMouse;\n            if (!disable_menu)\n                window_flags |= ImGuiWindowFlags_MenuBar;\n            ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 5.0f);\n            ImGui::BeginChild(\"ChildR\", ImVec2(0, 260), ImGuiChildFlags_Borders, window_flags);\n            if (!disable_menu && ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"Menu\"))\n                {\n                    ShowExampleMenuFile();\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            if (ImGui::BeginTable(\"split\", 2, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings))\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    char buf[32];\n                    sprintf(buf, \"%03d\", i);\n                    ImGui::TableNextColumn();\n                    ImGui::Button(buf, ImVec2(-FLT_MIN, 0.0f));\n                }\n                ImGui::EndTable();\n            }\n            ImGui::EndChild();\n            ImGui::PopStyleVar();\n        }\n\n        // Child 3: manual-resize\n        ImGui::SeparatorText(\"Manual-resize\");\n        {\n            HelpMarker(\"Drag bottom border to resize. Double-click bottom border to auto-fit to vertical contents.\");\n            //if (ImGui::Button(\"Set Height to 200\"))\n            //    ImGui::SetNextWindowSize(ImVec2(-FLT_MIN, 200.0f));\n\n            ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::GetStyleColorVec4(ImGuiCol_FrameBg));\n            if (ImGui::BeginChild(\"ResizableChild\", ImVec2(-FLT_MIN, ImGui::GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY))\n                for (int n = 0; n < 10; n++)\n                    ImGui::Text(\"Line %04d\", n);\n            ImGui::PopStyleColor();\n            ImGui::EndChild();\n        }\n\n        // Child 4: auto-resizing height with a limit\n        ImGui::SeparatorText(\"Auto-resize with constraints\");\n        {\n            static int draw_lines = 3;\n            static int max_height_in_lines = 10;\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n            ImGui::DragInt(\"Lines Count\", &draw_lines, 0.2f);\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n            ImGui::DragInt(\"Max Height (in Lines)\", &max_height_in_lines, 0.2f);\n\n            ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, ImGui::GetTextLineHeightWithSpacing() * 1), ImVec2(FLT_MAX, ImGui::GetTextLineHeightWithSpacing() * max_height_in_lines));\n            if (ImGui::BeginChild(\"ConstrainedChild\", ImVec2(-FLT_MIN, 0.0f), ImGuiChildFlags_Borders | ImGuiChildFlags_AutoResizeY))\n                for (int n = 0; n < draw_lines; n++)\n                    ImGui::Text(\"Line %04d\", n);\n            ImGui::EndChild();\n        }\n\n        ImGui::SeparatorText(\"Misc/Advanced\");\n\n        // Demonstrate a few extra things\n        // - Changing ImGuiCol_ChildBg (which is transparent black in default styles)\n        // - Using SetCursorPos() to position child window (the child window is an item from the POV of parent window)\n        //   You can also call SetNextWindowPos() to position the child window. The parent window will effectively\n        //   layout from this position.\n        // - Using ImGui::GetItemRectMin/Max() to query the \"item\" state (because the child window is an item from\n        //   the POV of the parent window). See 'Demo->Querying Status (Edited/Active/Hovered etc.)' for details.\n        {\n            static int offset_x = 0;\n            static bool override_bg_color = true;\n            static ImGuiChildFlags child_flags = ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY;\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n            ImGui::DragInt(\"Offset X\", &offset_x, 1.0f, -1000, 1000);\n            ImGui::Checkbox(\"Override ChildBg color\", &override_bg_color);\n            ImGui::CheckboxFlags(\"ImGuiChildFlags_Borders\", &child_flags, ImGuiChildFlags_Borders);\n            ImGui::CheckboxFlags(\"ImGuiChildFlags_AlwaysUseWindowPadding\", &child_flags, ImGuiChildFlags_AlwaysUseWindowPadding);\n            ImGui::CheckboxFlags(\"ImGuiChildFlags_ResizeX\", &child_flags, ImGuiChildFlags_ResizeX);\n            ImGui::CheckboxFlags(\"ImGuiChildFlags_ResizeY\", &child_flags, ImGuiChildFlags_ResizeY);\n            ImGui::CheckboxFlags(\"ImGuiChildFlags_FrameStyle\", &child_flags, ImGuiChildFlags_FrameStyle);\n            ImGui::SameLine(); HelpMarker(\"Style the child window like a framed item: use FrameBg, FrameRounding, FrameBorderSize, FramePadding instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.\");\n            if (child_flags & ImGuiChildFlags_FrameStyle)\n                override_bg_color = false;\n\n            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (float)offset_x);\n            if (override_bg_color)\n                ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(255, 0, 0, 100));\n            ImGui::BeginChild(\"Red\", ImVec2(200, 100), child_flags, ImGuiWindowFlags_None);\n            if (override_bg_color)\n                ImGui::PopStyleColor();\n\n            for (int n = 0; n < 50; n++)\n                ImGui::Text(\"Some test %d\", n);\n            ImGui::EndChild();\n            bool child_is_hovered = ImGui::IsItemHovered();\n            ImVec2 child_rect_min = ImGui::GetItemRectMin();\n            ImVec2 child_rect_max = ImGui::GetItemRectMax();\n            ImGui::Text(\"Hovered: %d\", child_is_hovered);\n            ImGui::Text(\"Rect of child window is: (%.0f,%.0f) (%.0f,%.0f)\", child_rect_min.x, child_rect_min.y, child_rect_max.x, child_rect_max.y);\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Widgets Width\");\n    if (ImGui::TreeNode(\"Widgets Width\"))\n    {\n        static float f = 0.0f;\n        static bool show_indented_items = true;\n        ImGui::Checkbox(\"Show indented items\", &show_indented_items);\n\n        // Use SetNextItemWidth() to set the width of a single upcoming item.\n        // Use PushItemWidth()/PopItemWidth() to set the width of a group of items.\n        // In real code use you'll probably want to choose width values that are proportional to your font size\n        // e.g. Using '20.0f * GetFontSize()' as width instead of '200.0f', etc.\n\n        ImGui::Text(\"SetNextItemWidth/PushItemWidth(100)\");\n        ImGui::SameLine(); HelpMarker(\"Fixed width.\");\n        ImGui::PushItemWidth(100);\n        ImGui::DragFloat(\"float##1b\", &f);\n        if (show_indented_items)\n        {\n            ImGui::Indent();\n            ImGui::DragFloat(\"float (indented)##1b\", &f);\n            ImGui::Unindent();\n        }\n        ImGui::PopItemWidth();\n\n        ImGui::Text(\"SetNextItemWidth/PushItemWidth(-100)\");\n        ImGui::SameLine(); HelpMarker(\"Align to right edge minus 100\");\n        ImGui::PushItemWidth(-100);\n        ImGui::DragFloat(\"float##2a\", &f);\n        if (show_indented_items)\n        {\n            ImGui::Indent();\n            ImGui::DragFloat(\"float (indented)##2b\", &f);\n            ImGui::Unindent();\n        }\n        ImGui::PopItemWidth();\n\n        ImGui::Text(\"SetNextItemWidth/PushItemWidth(GetContentRegionAvail().x * 0.5f)\");\n        ImGui::SameLine(); HelpMarker(\"Half of available width.\\n(~ right-cursor_pos)\\n(works within a column set)\");\n        ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x * 0.5f);\n        ImGui::DragFloat(\"float##3a\", &f);\n        if (show_indented_items)\n        {\n            ImGui::Indent();\n            ImGui::DragFloat(\"float (indented)##3b\", &f);\n            ImGui::Unindent();\n        }\n        ImGui::PopItemWidth();\n\n        ImGui::Text(\"SetNextItemWidth/PushItemWidth(-GetContentRegionAvail().x * 0.5f)\");\n        ImGui::SameLine(); HelpMarker(\"Align to right edge minus half\");\n        ImGui::PushItemWidth(-ImGui::GetContentRegionAvail().x * 0.5f);\n        ImGui::DragFloat(\"float##4a\", &f);\n        if (show_indented_items)\n        {\n            ImGui::Indent();\n            ImGui::DragFloat(\"float (indented)##4b\", &f);\n            ImGui::Unindent();\n        }\n        ImGui::PopItemWidth();\n\n        // Demonstrate using PushItemWidth to surround three items.\n        // Calling SetNextItemWidth() before each of them would have the same effect.\n        ImGui::Text(\"SetNextItemWidth/PushItemWidth(-FLT_MIN)\");\n        ImGui::SameLine(); HelpMarker(\"Align to right edge\");\n        ImGui::PushItemWidth(-FLT_MIN);\n        ImGui::DragFloat(\"##float5a\", &f);\n        if (show_indented_items)\n        {\n            ImGui::Indent();\n            ImGui::DragFloat(\"float (indented)##5b\", &f);\n            ImGui::Unindent();\n        }\n        ImGui::PopItemWidth();\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Basic Horizontal Layout\");\n    if (ImGui::TreeNode(\"Basic Horizontal Layout\"))\n    {\n        ImGui::TextWrapped(\"(Use ImGui::SameLine() to keep adding items to the right of the preceding item)\");\n\n        // Text\n        IMGUI_DEMO_MARKER(\"Layout/Basic Horizontal Layout/SameLine\");\n        ImGui::Text(\"Two items: Hello\"); ImGui::SameLine();\n        ImGui::TextColored(ImVec4(1, 1, 0, 1), \"Sailor\");\n\n        // Adjust spacing\n        ImGui::Text(\"More spacing: Hello\"); ImGui::SameLine(0, 20);\n        ImGui::TextColored(ImVec4(1, 1, 0, 1), \"Sailor\");\n\n        // Button\n        ImGui::AlignTextToFramePadding();\n        ImGui::Text(\"Normal buttons\"); ImGui::SameLine();\n        ImGui::Button(\"Banana\"); ImGui::SameLine();\n        ImGui::Button(\"Apple\"); ImGui::SameLine();\n        ImGui::Button(\"Corniflower\");\n\n        // Button\n        ImGui::Text(\"Small buttons\"); ImGui::SameLine();\n        ImGui::SmallButton(\"Like this one\"); ImGui::SameLine();\n        ImGui::Text(\"can fit within a text block.\");\n\n        // Aligned to arbitrary position. Easy/cheap column.\n        IMGUI_DEMO_MARKER(\"Layout/Basic Horizontal Layout/SameLine (with offset)\");\n        ImGui::Text(\"Aligned\");\n        ImGui::SameLine(150); ImGui::Text(\"x=150\");\n        ImGui::SameLine(300); ImGui::Text(\"x=300\");\n        ImGui::Text(\"Aligned\");\n        ImGui::SameLine(150); ImGui::SmallButton(\"x=150\");\n        ImGui::SameLine(300); ImGui::SmallButton(\"x=300\");\n\n        // Checkbox\n        IMGUI_DEMO_MARKER(\"Layout/Basic Horizontal Layout/SameLine (more)\");\n        static bool c1 = false, c2 = false, c3 = false, c4 = false;\n        ImGui::Checkbox(\"My\", &c1); ImGui::SameLine();\n        ImGui::Checkbox(\"Tailor\", &c2); ImGui::SameLine();\n        ImGui::Checkbox(\"Is\", &c3); ImGui::SameLine();\n        ImGui::Checkbox(\"Rich\", &c4);\n\n        // Various\n        static float f0 = 1.0f, f1 = 2.0f, f2 = 3.0f;\n        ImGui::PushItemWidth(80);\n        const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\" };\n        static int item = -1;\n        ImGui::Combo(\"Combo\", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();\n        ImGui::SliderFloat(\"X\", &f0, 0.0f, 5.0f); ImGui::SameLine();\n        ImGui::SliderFloat(\"Y\", &f1, 0.0f, 5.0f); ImGui::SameLine();\n        ImGui::SliderFloat(\"Z\", &f2, 0.0f, 5.0f);\n        ImGui::PopItemWidth();\n\n        ImGui::PushItemWidth(80);\n        ImGui::Text(\"Lists:\");\n        static int selection[4] = { 0, 1, 2, 3 };\n        for (int i = 0; i < 4; i++)\n        {\n            if (i > 0) ImGui::SameLine();\n            ImGui::PushID(i);\n            ImGui::ListBox(\"\", &selection[i], items, IM_ARRAYSIZE(items));\n            ImGui::PopID();\n            //ImGui::SetItemTooltip(\"ListBox %d hovered\", i);\n        }\n        ImGui::PopItemWidth();\n\n        // Dummy\n        IMGUI_DEMO_MARKER(\"Layout/Basic Horizontal Layout/Dummy\");\n        ImVec2 button_sz(40, 40);\n        ImGui::Button(\"A\", button_sz); ImGui::SameLine();\n        ImGui::Dummy(button_sz); ImGui::SameLine();\n        ImGui::Button(\"B\", button_sz);\n\n        // Manually wrapping\n        // (we should eventually provide this as an automatic layout feature, but for now you can do it manually)\n        IMGUI_DEMO_MARKER(\"Layout/Basic Horizontal Layout/Manual wrapping\");\n        ImGui::Text(\"Manual wrapping:\");\n        ImGuiStyle& style = ImGui::GetStyle();\n        int buttons_count = 20;\n        float window_visible_x2 = ImGui::GetCursorScreenPos().x + ImGui::GetContentRegionAvail().x;\n        for (int n = 0; n < buttons_count; n++)\n        {\n            ImGui::PushID(n);\n            ImGui::Button(\"Box\", button_sz);\n            float last_button_x2 = ImGui::GetItemRectMax().x;\n            float next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line\n            if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)\n                ImGui::SameLine();\n            ImGui::PopID();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Groups\");\n    if (ImGui::TreeNode(\"Groups\"))\n    {\n        HelpMarker(\n            \"BeginGroup() basically locks the horizontal position for new line. \"\n            \"EndGroup() bundles the whole group so that you can use \\\"item\\\" functions such as \"\n            \"IsItemHovered()/IsItemActive() or SameLine() etc. on the whole group.\");\n        ImGui::BeginGroup();\n        {\n            ImGui::BeginGroup();\n            ImGui::Button(\"AAA\");\n            ImGui::SameLine();\n            ImGui::Button(\"BBB\");\n            ImGui::SameLine();\n            ImGui::BeginGroup();\n            ImGui::Button(\"CCC\");\n            ImGui::Button(\"DDD\");\n            ImGui::EndGroup();\n            ImGui::SameLine();\n            ImGui::Button(\"EEE\");\n            ImGui::EndGroup();\n            ImGui::SetItemTooltip(\"First group hovered\");\n        }\n        // Capture the group size and create widgets using the same size\n        ImVec2 size = ImGui::GetItemRectSize();\n        const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };\n        ImGui::PlotHistogram(\"##values\", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);\n\n        ImGui::Button(\"ACTION\", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x) * 0.5f, size.y));\n        ImGui::SameLine();\n        ImGui::Button(\"REACTION\", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x) * 0.5f, size.y));\n        ImGui::EndGroup();\n        ImGui::SameLine();\n\n        ImGui::Button(\"LEVERAGE\\nBUZZWORD\", size);\n        ImGui::SameLine();\n\n        if (ImGui::BeginListBox(\"List\", size))\n        {\n            ImGui::Selectable(\"Selected\", true);\n            ImGui::Selectable(\"Not Selected\", false);\n            ImGui::EndListBox();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Text Baseline Alignment\");\n    if (ImGui::TreeNode(\"Text Baseline Alignment\"))\n    {\n        {\n            ImGui::BulletText(\"Text baseline:\");\n            ImGui::SameLine(); HelpMarker(\n                \"This is testing the vertical alignment that gets applied on text to keep it aligned with widgets. \"\n                \"Lines only composed of text or \\\"small\\\" widgets use less vertical space than lines with framed widgets.\");\n            ImGui::Indent();\n\n            ImGui::Text(\"KO Blahblah\"); ImGui::SameLine();\n            ImGui::Button(\"Some framed item\"); ImGui::SameLine();\n            HelpMarker(\"Baseline of button will look misaligned with text..\");\n\n            // If your line starts with text, call AlignTextToFramePadding() to align text to upcoming widgets.\n            // (because we don't know what's coming after the Text() statement, we need to move the text baseline\n            // down by FramePadding.y ahead of time)\n            ImGui::AlignTextToFramePadding();\n            ImGui::Text(\"OK Blahblah\"); ImGui::SameLine();\n            ImGui::Button(\"Some framed item##2\"); ImGui::SameLine();\n            HelpMarker(\"We call AlignTextToFramePadding() to vertically align the text baseline by +FramePadding.y\");\n\n            // SmallButton() uses the same vertical padding as Text\n            ImGui::Button(\"TEST##1\"); ImGui::SameLine();\n            ImGui::Text(\"TEST\"); ImGui::SameLine();\n            ImGui::SmallButton(\"TEST##2\");\n\n            // If your line starts with text, call AlignTextToFramePadding() to align text to upcoming widgets.\n            ImGui::AlignTextToFramePadding();\n            ImGui::Text(\"Text aligned to framed item\"); ImGui::SameLine();\n            ImGui::Button(\"Item##1\"); ImGui::SameLine();\n            ImGui::Text(\"Item\"); ImGui::SameLine();\n            ImGui::SmallButton(\"Item##2\"); ImGui::SameLine();\n            ImGui::Button(\"Item##3\");\n\n            ImGui::Unindent();\n        }\n\n        ImGui::Spacing();\n\n        {\n            ImGui::BulletText(\"Multi-line text:\");\n            ImGui::Indent();\n            ImGui::Text(\"One\\nTwo\\nThree\"); ImGui::SameLine();\n            ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\n            ImGui::Text(\"Banana\");\n\n            ImGui::Text(\"Banana\"); ImGui::SameLine();\n            ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\n            ImGui::Text(\"One\\nTwo\\nThree\");\n\n            ImGui::Button(\"HOP##1\"); ImGui::SameLine();\n            ImGui::Text(\"Banana\"); ImGui::SameLine();\n            ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\n            ImGui::Text(\"Banana\");\n\n            ImGui::Button(\"HOP##2\"); ImGui::SameLine();\n            ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\n            ImGui::Text(\"Banana\");\n            ImGui::Unindent();\n        }\n\n        ImGui::Spacing();\n\n        {\n            ImGui::BulletText(\"Misc items:\");\n            ImGui::Indent();\n\n            // SmallButton() sets FramePadding to zero. Text baseline is aligned to match baseline of previous Button.\n            ImGui::Button(\"80x80\", ImVec2(80, 80));\n            ImGui::SameLine();\n            ImGui::Button(\"50x50\", ImVec2(50, 50));\n            ImGui::SameLine();\n            ImGui::Button(\"Button()\");\n            ImGui::SameLine();\n            ImGui::SmallButton(\"SmallButton()\");\n\n            // Tree\n            const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;\n            ImGui::Button(\"Button##1\");\n            ImGui::SameLine(0.0f, spacing);\n            if (ImGui::TreeNode(\"Node##1\"))\n            {\n                // Placeholder tree data\n                for (int i = 0; i < 6; i++)\n                    ImGui::BulletText(\"Item %d..\", i);\n                ImGui::TreePop();\n            }\n\n            // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget.\n            // Otherwise you can use SmallButton() (smaller fit).\n            ImGui::AlignTextToFramePadding();\n\n            // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add\n            // other contents below the node.\n            bool node_open = ImGui::TreeNode(\"Node##2\");\n            ImGui::SameLine(0.0f, spacing); ImGui::Button(\"Button##2\");\n            if (node_open)\n            {\n                // Placeholder tree data\n                for (int i = 0; i < 6; i++)\n                    ImGui::BulletText(\"Item %d..\", i);\n                ImGui::TreePop();\n            }\n\n            // Bullet\n            ImGui::Button(\"Button##3\");\n            ImGui::SameLine(0.0f, spacing);\n            ImGui::BulletText(\"Bullet text\");\n\n            ImGui::AlignTextToFramePadding();\n            ImGui::BulletText(\"Node\");\n            ImGui::SameLine(0.0f, spacing); ImGui::Button(\"Button##4\");\n            ImGui::Unindent();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Scrolling\");\n    if (ImGui::TreeNode(\"Scrolling\"))\n    {\n        // Vertical scroll functions\n        IMGUI_DEMO_MARKER(\"Layout/Scrolling/Vertical\");\n        HelpMarker(\"Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given vertical position.\");\n\n        static int track_item = 50;\n        static bool enable_track = true;\n        static bool enable_extra_decorations = false;\n        static float scroll_to_off_px = 0.0f;\n        static float scroll_to_pos_px = 200.0f;\n\n        ImGui::Checkbox(\"Decoration\", &enable_extra_decorations);\n\n        ImGui::Checkbox(\"Track\", &enable_track);\n        ImGui::PushItemWidth(100);\n        ImGui::SameLine(140); enable_track |= ImGui::DragInt(\"##item\", &track_item, 0.25f, 0, 99, \"Item = %d\");\n\n        bool scroll_to_off = ImGui::Button(\"Scroll Offset\");\n        ImGui::SameLine(140); scroll_to_off |= ImGui::DragFloat(\"##off\", &scroll_to_off_px, 1.00f, 0, FLT_MAX, \"+%.0f px\");\n\n        bool scroll_to_pos = ImGui::Button(\"Scroll To Pos\");\n        ImGui::SameLine(140); scroll_to_pos |= ImGui::DragFloat(\"##pos\", &scroll_to_pos_px, 1.00f, -10, FLT_MAX, \"X/Y = %.0f px\");\n        ImGui::PopItemWidth();\n\n        if (scroll_to_off || scroll_to_pos)\n            enable_track = false;\n\n        ImGuiStyle& style = ImGui::GetStyle();\n        float child_w = (ImGui::GetContentRegionAvail().x - 4 * style.ItemSpacing.x) / 5;\n        if (child_w < 1.0f)\n            child_w = 1.0f;\n        ImGui::PushID(\"##VerticalScrolling\");\n        for (int i = 0; i < 5; i++)\n        {\n            if (i > 0) ImGui::SameLine();\n            ImGui::BeginGroup();\n            const char* names[] = { \"Top\", \"25%\", \"Center\", \"75%\", \"Bottom\" };\n            ImGui::TextUnformatted(names[i]);\n\n            const ImGuiWindowFlags child_flags = enable_extra_decorations ? ImGuiWindowFlags_MenuBar : 0;\n            const ImGuiID child_id = ImGui::GetID((void*)(intptr_t)i);\n            const bool child_is_visible = ImGui::BeginChild(child_id, ImVec2(child_w, 200.0f), ImGuiChildFlags_Borders, child_flags);\n            if (ImGui::BeginMenuBar())\n            {\n                ImGui::TextUnformatted(\"abc\");\n                ImGui::EndMenuBar();\n            }\n            if (scroll_to_off)\n                ImGui::SetScrollY(scroll_to_off_px);\n            if (scroll_to_pos)\n                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + scroll_to_pos_px, i * 0.25f);\n            if (child_is_visible) // Avoid calling SetScrollHereY when running with culled items\n            {\n                for (int item = 0; item < 100; item++)\n                {\n                    if (enable_track && item == track_item)\n                    {\n                        ImGui::TextColored(ImVec4(1, 1, 0, 1), \"Item %d\", item);\n                        ImGui::SetScrollHereY(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom\n                    }\n                    else\n                    {\n                        ImGui::Text(\"Item %d\", item);\n                    }\n                }\n            }\n            float scroll_y = ImGui::GetScrollY();\n            float scroll_max_y = ImGui::GetScrollMaxY();\n            ImGui::EndChild();\n            ImGui::Text(\"%.0f/%.0f\", scroll_y, scroll_max_y);\n            ImGui::EndGroup();\n        }\n        ImGui::PopID();\n\n        // Horizontal scroll functions\n        IMGUI_DEMO_MARKER(\"Layout/Scrolling/Horizontal\");\n        ImGui::Spacing();\n        HelpMarker(\n            \"Use SetScrollHereX() or SetScrollFromPosX() to scroll to a given horizontal position.\\n\\n\"\n            \"Because the clipping rectangle of most window hides half worth of WindowPadding on the \"\n            \"left/right, using SetScrollFromPosX(+1) will usually result in clipped text whereas the \"\n            \"equivalent SetScrollFromPosY(+1) wouldn't.\");\n        ImGui::PushID(\"##HorizontalScrolling\");\n        for (int i = 0; i < 5; i++)\n        {\n            float child_height = ImGui::GetTextLineHeight() + style.ScrollbarSize + style.WindowPadding.y * 2.0f;\n            ImGuiWindowFlags child_flags = ImGuiWindowFlags_HorizontalScrollbar | (enable_extra_decorations ? ImGuiWindowFlags_AlwaysVerticalScrollbar : 0);\n            ImGuiID child_id = ImGui::GetID((void*)(intptr_t)i);\n            bool child_is_visible = ImGui::BeginChild(child_id, ImVec2(-100, child_height), ImGuiChildFlags_Borders, child_flags);\n            if (scroll_to_off)\n                ImGui::SetScrollX(scroll_to_off_px);\n            if (scroll_to_pos)\n                ImGui::SetScrollFromPosX(ImGui::GetCursorStartPos().x + scroll_to_pos_px, i * 0.25f);\n            if (child_is_visible) // Avoid calling SetScrollHereY when running with culled items\n            {\n                for (int item = 0; item < 100; item++)\n                {\n                    if (item > 0)\n                        ImGui::SameLine();\n                    if (enable_track && item == track_item)\n                    {\n                        ImGui::TextColored(ImVec4(1, 1, 0, 1), \"Item %d\", item);\n                        ImGui::SetScrollHereX(i * 0.25f); // 0.0f:left, 0.5f:center, 1.0f:right\n                    }\n                    else\n                    {\n                        ImGui::Text(\"Item %d\", item);\n                    }\n                }\n            }\n            float scroll_x = ImGui::GetScrollX();\n            float scroll_max_x = ImGui::GetScrollMaxX();\n            ImGui::EndChild();\n            ImGui::SameLine();\n            const char* names[] = { \"Left\", \"25%\", \"Center\", \"75%\", \"Right\" };\n            ImGui::Text(\"%s\\n%.0f/%.0f\", names[i], scroll_x, scroll_max_x);\n            ImGui::Spacing();\n        }\n        ImGui::PopID();\n\n        // Miscellaneous Horizontal Scrolling Demo\n        IMGUI_DEMO_MARKER(\"Layout/Scrolling/Horizontal (more)\");\n        HelpMarker(\n            \"Horizontal scrolling for a window is enabled via the ImGuiWindowFlags_HorizontalScrollbar flag.\\n\\n\"\n            \"You may want to also explicitly specify content width by using SetNextWindowContentWidth() before Begin().\");\n        static int lines = 7;\n        ImGui::SliderInt(\"Lines\", &lines, 1, 15);\n        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);\n        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));\n        ImVec2 scrolling_child_size = ImVec2(0, ImGui::GetFrameHeightWithSpacing() * 7 + 30);\n        ImGui::BeginChild(\"scrolling\", scrolling_child_size, ImGuiChildFlags_Borders, ImGuiWindowFlags_HorizontalScrollbar);\n        for (int line = 0; line < lines; line++)\n        {\n            // Display random stuff. For the sake of this trivial demo we are using basic Button() + SameLine()\n            // If you want to create your own time line for a real application you may be better off manipulating\n            // the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets\n            // yourself. You may also want to use the lower-level ImDrawList API.\n            int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);\n            for (int n = 0; n < num_buttons; n++)\n            {\n                if (n > 0) ImGui::SameLine();\n                ImGui::PushID(n + line * 1000);\n                char num_buf[16];\n                sprintf(num_buf, \"%d\", n);\n                const char* label = (!(n % 15)) ? \"FizzBuzz\" : (!(n % 3)) ? \"Fizz\" : (!(n % 5)) ? \"Buzz\" : num_buf;\n                float hue = n * 0.05f;\n                ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));\n                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));\n                ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(hue, 0.8f, 0.8f));\n                ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));\n                ImGui::PopStyleColor(3);\n                ImGui::PopID();\n            }\n        }\n        float scroll_x = ImGui::GetScrollX();\n        float scroll_max_x = ImGui::GetScrollMaxX();\n        ImGui::EndChild();\n        ImGui::PopStyleVar(2);\n        float scroll_x_delta = 0.0f;\n        ImGui::SmallButton(\"<<\");\n        if (ImGui::IsItemActive())\n            scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f;\n        ImGui::SameLine();\n        ImGui::Text(\"Scroll from code\"); ImGui::SameLine();\n        ImGui::SmallButton(\">>\");\n        if (ImGui::IsItemActive())\n            scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f;\n        ImGui::SameLine();\n        ImGui::Text(\"%.0f/%.0f\", scroll_x, scroll_max_x);\n        if (scroll_x_delta != 0.0f)\n        {\n            // Demonstrate a trick: you can use Begin to set yourself in the context of another window\n            // (here we are already out of your child window)\n            ImGui::BeginChild(\"scrolling\");\n            ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);\n            ImGui::EndChild();\n        }\n        ImGui::Spacing();\n\n        static bool show_horizontal_contents_size_demo_window = false;\n        ImGui::Checkbox(\"Show Horizontal contents size demo window\", &show_horizontal_contents_size_demo_window);\n\n        if (show_horizontal_contents_size_demo_window)\n        {\n            static bool show_h_scrollbar = true;\n            static bool show_button = true;\n            static bool show_tree_nodes = true;\n            static bool show_text_wrapped = false;\n            static bool show_columns = true;\n            static bool show_tab_bar = true;\n            static bool show_child = false;\n            static bool explicit_content_size = false;\n            static float contents_size_x = 300.0f;\n            if (explicit_content_size)\n                ImGui::SetNextWindowContentSize(ImVec2(contents_size_x, 0.0f));\n            ImGui::Begin(\"Horizontal contents size demo window\", &show_horizontal_contents_size_demo_window, show_h_scrollbar ? ImGuiWindowFlags_HorizontalScrollbar : 0);\n            IMGUI_DEMO_MARKER(\"Layout/Scrolling/Horizontal contents size demo window\");\n            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2, 0));\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 0));\n            HelpMarker(\n                \"Test how different widgets react and impact the work rectangle growing when horizontal scrolling is enabled.\\n\\n\"\n                \"Use 'Metrics->Tools->Show windows rectangles' to visualize rectangles.\");\n            ImGui::Checkbox(\"H-scrollbar\", &show_h_scrollbar);\n            ImGui::Checkbox(\"Button\", &show_button);            // Will grow contents size (unless explicitly overwritten)\n            ImGui::Checkbox(\"Tree nodes\", &show_tree_nodes);    // Will grow contents size and display highlight over full width\n            ImGui::Checkbox(\"Text wrapped\", &show_text_wrapped);// Will grow and use contents size\n            ImGui::Checkbox(\"Columns\", &show_columns);          // Will use contents size\n            ImGui::Checkbox(\"Tab bar\", &show_tab_bar);          // Will use contents size\n            ImGui::Checkbox(\"Child\", &show_child);              // Will grow and use contents size\n            ImGui::Checkbox(\"Explicit content size\", &explicit_content_size);\n            ImGui::Text(\"Scroll %.1f/%.1f %.1f/%.1f\", ImGui::GetScrollX(), ImGui::GetScrollMaxX(), ImGui::GetScrollY(), ImGui::GetScrollMaxY());\n            if (explicit_content_size)\n            {\n                ImGui::SameLine();\n                ImGui::SetNextItemWidth(100);\n                ImGui::DragFloat(\"##csx\", &contents_size_x);\n                ImVec2 p = ImGui::GetCursorScreenPos();\n                ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x + 10, p.y + 10), IM_COL32_WHITE);\n                ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(p.x + contents_size_x - 10, p.y), ImVec2(p.x + contents_size_x, p.y + 10), IM_COL32_WHITE);\n                ImGui::Dummy(ImVec2(0, 10));\n            }\n            ImGui::PopStyleVar(2);\n            ImGui::Separator();\n            if (show_button)\n            {\n                ImGui::Button(\"this is a 300-wide button\", ImVec2(300, 0));\n            }\n            if (show_tree_nodes)\n            {\n                bool open = true;\n                if (ImGui::TreeNode(\"this is a tree node\"))\n                {\n                    if (ImGui::TreeNode(\"another one of those tree node...\"))\n                    {\n                        ImGui::Text(\"Some tree contents\");\n                        ImGui::TreePop();\n                    }\n                    ImGui::TreePop();\n                }\n                ImGui::CollapsingHeader(\"CollapsingHeader\", &open);\n            }\n            if (show_text_wrapped)\n            {\n                ImGui::TextWrapped(\"This text should automatically wrap on the edge of the work rectangle.\");\n            }\n            if (show_columns)\n            {\n                ImGui::Text(\"Tables:\");\n                if (ImGui::BeginTable(\"table\", 4, ImGuiTableFlags_Borders))\n                {\n                    for (int n = 0; n < 4; n++)\n                    {\n                        ImGui::TableNextColumn();\n                        ImGui::Text(\"Width %.2f\", ImGui::GetContentRegionAvail().x);\n                    }\n                    ImGui::EndTable();\n                }\n                ImGui::Text(\"Columns:\");\n                ImGui::Columns(4);\n                for (int n = 0; n < 4; n++)\n                {\n                    ImGui::Text(\"Width %.2f\", ImGui::GetColumnWidth());\n                    ImGui::NextColumn();\n                }\n                ImGui::Columns(1);\n            }\n            if (show_tab_bar && ImGui::BeginTabBar(\"Hello\"))\n            {\n                if (ImGui::BeginTabItem(\"OneOneOne\")) { ImGui::EndTabItem(); }\n                if (ImGui::BeginTabItem(\"TwoTwoTwo\")) { ImGui::EndTabItem(); }\n                if (ImGui::BeginTabItem(\"ThreeThreeThree\")) { ImGui::EndTabItem(); }\n                if (ImGui::BeginTabItem(\"FourFourFour\")) { ImGui::EndTabItem(); }\n                ImGui::EndTabBar();\n            }\n            if (show_child)\n            {\n                ImGui::BeginChild(\"child\", ImVec2(0, 0), ImGuiChildFlags_Borders);\n                ImGui::EndChild();\n            }\n            ImGui::End();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Text Clipping\");\n    if (ImGui::TreeNode(\"Text Clipping\"))\n    {\n        static ImVec2 size(100.0f, 100.0f);\n        static ImVec2 offset(30.0f, 30.0f);\n        ImGui::DragFloat2(\"size\", (float*)&size, 0.5f, 1.0f, 200.0f, \"%.0f\");\n        ImGui::TextWrapped(\"(Click and drag to scroll)\");\n\n        HelpMarker(\n            \"(Left) Using ImGui::PushClipRect():\\n\"\n            \"Will alter ImGui hit-testing logic + ImDrawList rendering.\\n\"\n            \"(use this if you want your clipping rectangle to affect interactions)\\n\\n\"\n            \"(Center) Using ImDrawList::PushClipRect():\\n\"\n            \"Will alter ImDrawList rendering only.\\n\"\n            \"(use this as a shortcut if you are only using ImDrawList calls)\\n\\n\"\n            \"(Right) Using ImDrawList::AddText() with a fine ClipRect:\\n\"\n            \"Will alter only this specific ImDrawList::AddText() rendering.\\n\"\n            \"This is often used internally to avoid altering the clipping rectangle and minimize draw calls.\");\n\n        for (int n = 0; n < 3; n++)\n        {\n            if (n > 0)\n                ImGui::SameLine();\n\n            ImGui::PushID(n);\n            ImGui::InvisibleButton(\"##canvas\", size);\n            if (ImGui::IsItemActive() && ImGui::IsMouseDragging(ImGuiMouseButton_Left))\n            {\n                offset.x += ImGui::GetIO().MouseDelta.x;\n                offset.y += ImGui::GetIO().MouseDelta.y;\n            }\n            ImGui::PopID();\n            if (!ImGui::IsItemVisible()) // Skip rendering as ImDrawList elements are not clipped.\n                continue;\n\n            const ImVec2 p0 = ImGui::GetItemRectMin();\n            const ImVec2 p1 = ImGui::GetItemRectMax();\n            const char* text_str = \"Line 1 hello\\nLine 2 clip me!\";\n            const ImVec2 text_pos = ImVec2(p0.x + offset.x, p0.y + offset.y);\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            switch (n)\n            {\n            case 0:\n                ImGui::PushClipRect(p0, p1, true);\n                draw_list->AddRectFilled(p0, p1, IM_COL32(90, 90, 120, 255));\n                draw_list->AddText(text_pos, IM_COL32_WHITE, text_str);\n                ImGui::PopClipRect();\n                break;\n            case 1:\n                draw_list->PushClipRect(p0, p1, true);\n                draw_list->AddRectFilled(p0, p1, IM_COL32(90, 90, 120, 255));\n                draw_list->AddText(text_pos, IM_COL32_WHITE, text_str);\n                draw_list->PopClipRect();\n                break;\n            case 2:\n                ImVec4 clip_rect(p0.x, p0.y, p1.x, p1.y); // AddText() takes a ImVec4* here so let's convert.\n                draw_list->AddRectFilled(p0, p1, IM_COL32(90, 90, 120, 255));\n                draw_list->AddText(ImGui::GetFont(), ImGui::GetFontSize(), text_pos, IM_COL32_WHITE, text_str, NULL, 0.0f, &clip_rect);\n                break;\n            }\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Layout/Overlap Mode\");\n    if (ImGui::TreeNode(\"Overlap Mode\"))\n    {\n        static bool enable_allow_overlap = true;\n\n        HelpMarker(\n            \"Hit-testing is by default performed in item submission order, which generally is perceived as 'back-to-front'.\\n\\n\"\n            \"By using SetNextItemAllowOverlap() you can notify that an item may be overlapped by another. \"\n            \"Doing so alters the hovering logic: items using AllowOverlap mode requires an extra frame to accept hovered state.\");\n        ImGui::Checkbox(\"Enable AllowOverlap\", &enable_allow_overlap);\n\n        ImVec2 button1_pos = ImGui::GetCursorScreenPos();\n        ImVec2 button2_pos = ImVec2(button1_pos.x + 50.0f, button1_pos.y + 50.0f);\n        if (enable_allow_overlap)\n            ImGui::SetNextItemAllowOverlap();\n        ImGui::Button(\"Button 1\", ImVec2(80, 80));\n        ImGui::SetCursorScreenPos(button2_pos);\n        ImGui::Button(\"Button 2\", ImVec2(80, 80));\n\n        // This is typically used with width-spanning items.\n        // (note that Selectable() has a dedicated flag ImGuiSelectableFlags_AllowOverlap, which is a shortcut\n        // for using SetNextItemAllowOverlap(). For demo purpose we use SetNextItemAllowOverlap() here.)\n        if (enable_allow_overlap)\n            ImGui::SetNextItemAllowOverlap();\n        ImGui::Selectable(\"Some Selectable\", false);\n        ImGui::SameLine();\n        ImGui::SmallButton(\"++\");\n\n        ImGui::TreePop();\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowPopups()\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowPopups()\n{\n    IMGUI_DEMO_MARKER(\"Popups\");\n    if (!ImGui::CollapsingHeader(\"Popups & Modal windows\"))\n        return;\n\n    // The properties of popups windows are:\n    // - They block normal mouse hovering detection outside them. (*)\n    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.\n    // - Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as\n    //   we are used to with regular Begin() calls. User can manipulate the visibility state by calling OpenPopup().\n    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even\n    //     when normally blocked by a popup.\n    // Those three properties are connected. The library needs to hold their visibility state BECAUSE it can close\n    // popups at any time.\n\n    // Typical use for regular windows:\n    //   bool my_tool_is_active = false; if (ImGui::Button(\"Open\")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin(\"My Tool\", &my_tool_is_active) { [...] } End();\n    // Typical use for popups:\n    //   if (ImGui::Button(\"Open\")) ImGui::OpenPopup(\"MyPopup\"); if (ImGui::BeginPopup(\"MyPopup\") { [...] EndPopup(); }\n\n    // With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.\n    // This may be a bit confusing at first but it should quickly make sense. Follow on the examples below.\n\n    IMGUI_DEMO_MARKER(\"Popups/Popups\");\n    if (ImGui::TreeNode(\"Popups\"))\n    {\n        ImGui::TextWrapped(\n            \"When a popup is active, it inhibits interacting with windows that are behind the popup. \"\n            \"Clicking outside the popup closes it.\");\n\n        static int selected_fish = -1;\n        const char* names[] = { \"Bream\", \"Haddock\", \"Mackerel\", \"Pollock\", \"Tilefish\" };\n        static bool toggles[] = { true, false, false, false, false };\n\n        // Simple selection popup (if you want to show the current selection inside the Button itself,\n        // you may want to build a string using the \"###\" operator to preserve a constant ID with a variable label)\n        if (ImGui::Button(\"Select..\"))\n            ImGui::OpenPopup(\"my_select_popup\");\n        ImGui::SameLine();\n        ImGui::TextUnformatted(selected_fish == -1 ? \"<None>\" : names[selected_fish]);\n        if (ImGui::BeginPopup(\"my_select_popup\"))\n        {\n            ImGui::SeparatorText(\"Aquarium\");\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                if (ImGui::Selectable(names[i]))\n                    selected_fish = i;\n            ImGui::EndPopup();\n        }\n\n        // Showing a menu with toggles\n        if (ImGui::Button(\"Toggle..\"))\n            ImGui::OpenPopup(\"my_toggle_popup\");\n        if (ImGui::BeginPopup(\"my_toggle_popup\"))\n        {\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                ImGui::MenuItem(names[i], \"\", &toggles[i]);\n            if (ImGui::BeginMenu(\"Sub-menu\"))\n            {\n                ImGui::MenuItem(\"Click me\");\n                ImGui::EndMenu();\n            }\n\n            ImGui::Separator();\n            ImGui::Text(\"Tooltip here\");\n            ImGui::SetItemTooltip(\"I am a tooltip over a popup\");\n\n            if (ImGui::Button(\"Stacked Popup\"))\n                ImGui::OpenPopup(\"another popup\");\n            if (ImGui::BeginPopup(\"another popup\"))\n            {\n                for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                    ImGui::MenuItem(names[i], \"\", &toggles[i]);\n                if (ImGui::BeginMenu(\"Sub-menu\"))\n                {\n                    ImGui::MenuItem(\"Click me\");\n                    if (ImGui::Button(\"Stacked Popup\"))\n                        ImGui::OpenPopup(\"another popup\");\n                    if (ImGui::BeginPopup(\"another popup\"))\n                    {\n                        ImGui::Text(\"I am the last one here.\");\n                        ImGui::EndPopup();\n                    }\n                    ImGui::EndMenu();\n                }\n                ImGui::EndPopup();\n            }\n            ImGui::EndPopup();\n        }\n\n        // Call the more complete ShowExampleMenuFile which we use in various places of this demo\n        if (ImGui::Button(\"With a menu..\"))\n            ImGui::OpenPopup(\"my_file_popup\");\n        if (ImGui::BeginPopup(\"my_file_popup\", ImGuiWindowFlags_MenuBar))\n        {\n            if (ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"File\"))\n                {\n                    ShowExampleMenuFile();\n                    ImGui::EndMenu();\n                }\n                if (ImGui::BeginMenu(\"Edit\"))\n                {\n                    ImGui::MenuItem(\"Dummy\");\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            ImGui::Text(\"Hello from popup!\");\n            ImGui::Button(\"This is a dummy button..\");\n            ImGui::EndPopup();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups/Context menus\");\n    if (ImGui::TreeNode(\"Context menus\"))\n    {\n        HelpMarker(\"\\\"Context\\\" functions are simple helpers to associate a Popup to a given Item or Window identifier.\");\n\n        // BeginPopupContextItem() is a helper to provide common/simple popup behavior of essentially doing:\n        //     if (id == 0)\n        //         id = GetItemID(); // Use last item id\n        //     if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))\n        //         OpenPopup(id);\n        //     return BeginPopup(id);\n        // For advanced uses you may want to replicate and customize this code.\n        // See more details in BeginPopupContextItem().\n\n        // Example 1\n        // When used after an item that has an ID (e.g. Button), we can skip providing an ID to BeginPopupContextItem(),\n        // and BeginPopupContextItem() will use the last item ID as the popup ID.\n        {\n            const char* names[5] = { \"Label1\", \"Label2\", \"Label3\", \"Label4\", \"Label5\" };\n            static int selected = -1;\n            for (int n = 0; n < 5; n++)\n            {\n                if (ImGui::Selectable(names[n], selected == n))\n                    selected = n;\n                if (ImGui::BeginPopupContextItem()) // <-- use last item id as popup id\n                {\n                    selected = n;\n                    ImGui::Text(\"This a popup for \\\"%s\\\"!\", names[n]);\n                    if (ImGui::Button(\"Close\"))\n                        ImGui::CloseCurrentPopup();\n                    ImGui::EndPopup();\n                }\n                ImGui::SetItemTooltip(\"Right-click to open popup\");\n            }\n        }\n\n        // Example 2\n        // Popup on a Text() element which doesn't have an identifier: we need to provide an identifier to BeginPopupContextItem().\n        // Using an explicit identifier is also convenient if you want to activate the popups from different locations.\n        {\n            HelpMarker(\"Text() elements don't have stable identifiers so we need to provide one.\");\n            static float value = 0.5f;\n            ImGui::Text(\"Value = %.3f <-- (1) right-click this text\", value);\n            if (ImGui::BeginPopupContextItem(\"my popup\"))\n            {\n                if (ImGui::Selectable(\"Set to zero\")) value = 0.0f;\n                if (ImGui::Selectable(\"Set to PI\")) value = 3.1415f;\n                ImGui::SetNextItemWidth(-FLT_MIN);\n                ImGui::DragFloat(\"##Value\", &value, 0.1f, 0.0f, 0.0f);\n                ImGui::EndPopup();\n            }\n\n            // We can also use OpenPopupOnItemClick() to toggle the visibility of a given popup.\n            // Here we make it that right-clicking this other text element opens the same popup as above.\n            // The popup itself will be submitted by the code above.\n            ImGui::Text(\"(2) Or right-click this text\");\n            ImGui::OpenPopupOnItemClick(\"my popup\", ImGuiPopupFlags_MouseButtonRight);\n\n            // Back to square one: manually open the same popup.\n            if (ImGui::Button(\"(3) Or click this button\"))\n                ImGui::OpenPopup(\"my popup\");\n        }\n\n        // Example 3\n        // When using BeginPopupContextItem() with an implicit identifier (NULL == use last item ID),\n        // we need to make sure your item identifier is stable.\n        // In this example we showcase altering the item label while preserving its identifier, using the ### operator (see FAQ).\n        {\n            HelpMarker(\"Showcase using a popup ID linked to item ID, with the item having a changing label + stable ID using the ### operator.\");\n            static char name[32] = \"Label1\";\n            char buf[64];\n            sprintf(buf, \"Button: %s###Button\", name); // ### operator override ID ignoring the preceding label\n            ImGui::Button(buf);\n            if (ImGui::BeginPopupContextItem())\n            {\n                ImGui::Text(\"Edit name:\");\n                ImGui::InputText(\"##edit\", name, IM_ARRAYSIZE(name));\n                if (ImGui::Button(\"Close\"))\n                    ImGui::CloseCurrentPopup();\n                ImGui::EndPopup();\n            }\n            ImGui::SameLine(); ImGui::Text(\"(<-- right-click here)\");\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups/Modals\");\n    if (ImGui::TreeNode(\"Modals\"))\n    {\n        ImGui::TextWrapped(\"Modal windows are like popups but the user cannot close them by clicking outside.\");\n\n        if (ImGui::Button(\"Delete..\"))\n            ImGui::OpenPopup(\"Delete?\");\n\n        // Always center this window when appearing\n        ImVec2 center = ImGui::GetMainViewport()->GetCenter();\n        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));\n\n        if (ImGui::BeginPopupModal(\"Delete?\", NULL, ImGuiWindowFlags_AlwaysAutoResize))\n        {\n            ImGui::Text(\"All those beautiful files will be deleted.\\nThis operation cannot be undone!\");\n            ImGui::Separator();\n\n            //static int unused_i = 0;\n            //ImGui::Combo(\"Combo\", &unused_i, \"Delete\\0Delete harder\\0\");\n\n            static bool dont_ask_me_next_time = false;\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n            ImGui::Checkbox(\"Don't ask me next time\", &dont_ask_me_next_time);\n            ImGui::PopStyleVar();\n\n            if (ImGui::Button(\"OK\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\n            ImGui::SetItemDefaultFocus();\n            ImGui::SameLine();\n            if (ImGui::Button(\"Cancel\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\n            ImGui::EndPopup();\n        }\n\n        if (ImGui::Button(\"Stacked modals..\"))\n            ImGui::OpenPopup(\"Stacked 1\");\n        if (ImGui::BeginPopupModal(\"Stacked 1\", NULL, ImGuiWindowFlags_MenuBar))\n        {\n            if (ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"File\"))\n                {\n                    if (ImGui::MenuItem(\"Some menu item\")) {}\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            ImGui::Text(\"Hello from Stacked The First\\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.\");\n\n            // Testing behavior of widgets stacking their own regular popups over the modal.\n            static int item = 1;\n            static float color[4] = { 0.4f, 0.7f, 0.0f, 0.5f };\n            ImGui::Combo(\"Combo\", &item, \"aaaa\\0bbbb\\0cccc\\0dddd\\0eeee\\0\\0\");\n            ImGui::ColorEdit4(\"Color\", color);\n\n            if (ImGui::Button(\"Add another modal..\"))\n                ImGui::OpenPopup(\"Stacked 2\");\n\n            // Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which\n            // will close the popup. Note that the visibility state of popups is owned by imgui, so the input value\n            // of the bool actually doesn't matter here.\n            bool unused_open = true;\n            if (ImGui::BeginPopupModal(\"Stacked 2\", &unused_open))\n            {\n                ImGui::Text(\"Hello from Stacked The Second!\");\n                ImGui::ColorEdit4(\"Color\", color); // Allow opening another nested popup\n                if (ImGui::Button(\"Close\"))\n                    ImGui::CloseCurrentPopup();\n                ImGui::EndPopup();\n            }\n\n            if (ImGui::Button(\"Close\"))\n                ImGui::CloseCurrentPopup();\n            ImGui::EndPopup();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups/Menus inside a regular window\");\n    if (ImGui::TreeNode(\"Menus inside a regular window\"))\n    {\n        ImGui::TextWrapped(\"Below we are testing adding menu items to a regular window. It's rather unusual but should work!\");\n        ImGui::Separator();\n\n        ImGui::MenuItem(\"Menu item\", \"CTRL+M\");\n        if (ImGui::BeginMenu(\"Menu inside a regular window\"))\n        {\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n}\n\n// Dummy data structure that we use for the Table demo.\n// (pre-C++11 doesn't allow us to instantiate ImVector<MyItem> template if this structure is defined inside the demo function)\nnamespace\n{\n// We are passing our own identifier to TableSetupColumn() to facilitate identifying columns in the sorting code.\n// This identifier will be passed down into ImGuiTableSortSpec::ColumnUserID.\n// But it is possible to omit the user id parameter of TableSetupColumn() and just use the column index instead! (ImGuiTableSortSpec::ColumnIndex)\n// If you don't use sorting, you will generally never care about giving column an ID!\nenum MyItemColumnID\n{\n    MyItemColumnID_ID,\n    MyItemColumnID_Name,\n    MyItemColumnID_Action,\n    MyItemColumnID_Quantity,\n    MyItemColumnID_Description\n};\n\nstruct MyItem\n{\n    int         ID;\n    const char* Name;\n    int         Quantity;\n\n    // We have a problem which is affecting _only this demo_ and should not affect your code:\n    // As we don't rely on std:: or other third-party library to compile dear imgui, we only have reliable access to qsort(),\n    // however qsort doesn't allow passing user data to comparing function.\n    // As a workaround, we are storing the sort specs in a static/global for the comparing function to access.\n    // In your own use case you would probably pass the sort specs to your sorting/comparing functions directly and not use a global.\n    // We could technically call ImGui::TableGetSortSpecs() in CompareWithSortSpecs(), but considering that this function is called\n    // very often by the sorting algorithm it would be a little wasteful.\n    static const ImGuiTableSortSpecs* s_current_sort_specs;\n\n    static void SortWithSortSpecs(ImGuiTableSortSpecs* sort_specs, MyItem* items, int items_count)\n    {\n        s_current_sort_specs = sort_specs; // Store in variable accessible by the sort function.\n        if (items_count > 1)\n            qsort(items, (size_t)items_count, sizeof(items[0]), MyItem::CompareWithSortSpecs);\n        s_current_sort_specs = NULL;\n    }\n\n    // Compare function to be used by qsort()\n    static int IMGUI_CDECL CompareWithSortSpecs(const void* lhs, const void* rhs)\n    {\n        const MyItem* a = (const MyItem*)lhs;\n        const MyItem* b = (const MyItem*)rhs;\n        for (int n = 0; n < s_current_sort_specs->SpecsCount; n++)\n        {\n            // Here we identify columns using the ColumnUserID value that we ourselves passed to TableSetupColumn()\n            // We could also choose to identify columns based on their index (sort_spec->ColumnIndex), which is simpler!\n            const ImGuiTableColumnSortSpecs* sort_spec = &s_current_sort_specs->Specs[n];\n            int delta = 0;\n            switch (sort_spec->ColumnUserID)\n            {\n            case MyItemColumnID_ID:             delta = (a->ID - b->ID);                break;\n            case MyItemColumnID_Name:           delta = (strcmp(a->Name, b->Name));     break;\n            case MyItemColumnID_Quantity:       delta = (a->Quantity - b->Quantity);    break;\n            case MyItemColumnID_Description:    delta = (strcmp(a->Name, b->Name));     break;\n            default: IM_ASSERT(0); break;\n            }\n            if (delta > 0)\n                return (sort_spec->SortDirection == ImGuiSortDirection_Ascending) ? +1 : -1;\n            if (delta < 0)\n                return (sort_spec->SortDirection == ImGuiSortDirection_Ascending) ? -1 : +1;\n        }\n\n        // qsort() is instable so always return a way to differenciate items.\n        // Your own compare function may want to avoid fallback on implicit sort specs.\n        // e.g. a Name compare if it wasn't already part of the sort specs.\n        return (a->ID - b->ID);\n    }\n};\nconst ImGuiTableSortSpecs* MyItem::s_current_sort_specs = NULL;\n}\n\n// Make the UI compact because there are so many fields\nstatic void PushStyleCompact()\n{\n    ImGuiStyle& style = ImGui::GetStyle();\n    ImGui::PushStyleVarY(ImGuiStyleVar_FramePadding, (float)(int)(style.FramePadding.y * 0.60f));\n    ImGui::PushStyleVarY(ImGuiStyleVar_ItemSpacing, (float)(int)(style.ItemSpacing.y * 0.60f));\n}\n\nstatic void PopStyleCompact()\n{\n    ImGui::PopStyleVar(2);\n}\n\n// Show a combo box with a choice of sizing policies\nstatic void EditTableSizingFlags(ImGuiTableFlags* p_flags)\n{\n    struct EnumDesc { ImGuiTableFlags Value; const char* Name; const char* Tooltip; };\n    static const EnumDesc policies[] =\n    {\n        { ImGuiTableFlags_None,               \"Default\",                            \"Use default sizing policy:\\n- ImGuiTableFlags_SizingFixedFit if ScrollX is on or if host window has ImGuiWindowFlags_AlwaysAutoResize.\\n- ImGuiTableFlags_SizingStretchSame otherwise.\" },\n        { ImGuiTableFlags_SizingFixedFit,     \"ImGuiTableFlags_SizingFixedFit\",     \"Columns default to _WidthFixed (if resizable) or _WidthAuto (if not resizable), matching contents width.\" },\n        { ImGuiTableFlags_SizingFixedSame,    \"ImGuiTableFlags_SizingFixedSame\",    \"Columns are all the same width, matching the maximum contents width.\\nImplicitly disable ImGuiTableFlags_Resizable and enable ImGuiTableFlags_NoKeepColumnsVisible.\" },\n        { ImGuiTableFlags_SizingStretchProp,  \"ImGuiTableFlags_SizingStretchProp\",  \"Columns default to _WidthStretch with weights proportional to their widths.\" },\n        { ImGuiTableFlags_SizingStretchSame,  \"ImGuiTableFlags_SizingStretchSame\",  \"Columns default to _WidthStretch with same weights.\" }\n    };\n    int idx;\n    for (idx = 0; idx < IM_ARRAYSIZE(policies); idx++)\n        if (policies[idx].Value == (*p_flags & ImGuiTableFlags_SizingMask_))\n            break;\n    const char* preview_text = (idx < IM_ARRAYSIZE(policies)) ? policies[idx].Name + (idx > 0 ? strlen(\"ImGuiTableFlags\") : 0) : \"\";\n    if (ImGui::BeginCombo(\"Sizing Policy\", preview_text))\n    {\n        for (int n = 0; n < IM_ARRAYSIZE(policies); n++)\n            if (ImGui::Selectable(policies[n].Name, idx == n))\n                *p_flags = (*p_flags & ~ImGuiTableFlags_SizingMask_) | policies[n].Value;\n        ImGui::EndCombo();\n    }\n    ImGui::SameLine();\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::BeginItemTooltip())\n    {\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 50.0f);\n        for (int m = 0; m < IM_ARRAYSIZE(policies); m++)\n        {\n            ImGui::Separator();\n            ImGui::Text(\"%s:\", policies[m].Name);\n            ImGui::Separator();\n            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetStyle().IndentSpacing * 0.5f);\n            ImGui::TextUnformatted(policies[m].Tooltip);\n        }\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}\n\nstatic void EditTableColumnsFlags(ImGuiTableColumnFlags* p_flags)\n{\n    ImGui::CheckboxFlags(\"_Disabled\", p_flags, ImGuiTableColumnFlags_Disabled); ImGui::SameLine(); HelpMarker(\"Master disable flag (also hide from context menu)\");\n    ImGui::CheckboxFlags(\"_DefaultHide\", p_flags, ImGuiTableColumnFlags_DefaultHide);\n    ImGui::CheckboxFlags(\"_DefaultSort\", p_flags, ImGuiTableColumnFlags_DefaultSort);\n    if (ImGui::CheckboxFlags(\"_WidthStretch\", p_flags, ImGuiTableColumnFlags_WidthStretch))\n        *p_flags &= ~(ImGuiTableColumnFlags_WidthMask_ ^ ImGuiTableColumnFlags_WidthStretch);\n    if (ImGui::CheckboxFlags(\"_WidthFixed\", p_flags, ImGuiTableColumnFlags_WidthFixed))\n        *p_flags &= ~(ImGuiTableColumnFlags_WidthMask_ ^ ImGuiTableColumnFlags_WidthFixed);\n    ImGui::CheckboxFlags(\"_NoResize\", p_flags, ImGuiTableColumnFlags_NoResize);\n    ImGui::CheckboxFlags(\"_NoReorder\", p_flags, ImGuiTableColumnFlags_NoReorder);\n    ImGui::CheckboxFlags(\"_NoHide\", p_flags, ImGuiTableColumnFlags_NoHide);\n    ImGui::CheckboxFlags(\"_NoClip\", p_flags, ImGuiTableColumnFlags_NoClip);\n    ImGui::CheckboxFlags(\"_NoSort\", p_flags, ImGuiTableColumnFlags_NoSort);\n    ImGui::CheckboxFlags(\"_NoSortAscending\", p_flags, ImGuiTableColumnFlags_NoSortAscending);\n    ImGui::CheckboxFlags(\"_NoSortDescending\", p_flags, ImGuiTableColumnFlags_NoSortDescending);\n    ImGui::CheckboxFlags(\"_NoHeaderLabel\", p_flags, ImGuiTableColumnFlags_NoHeaderLabel);\n    ImGui::CheckboxFlags(\"_NoHeaderWidth\", p_flags, ImGuiTableColumnFlags_NoHeaderWidth);\n    ImGui::CheckboxFlags(\"_PreferSortAscending\", p_flags, ImGuiTableColumnFlags_PreferSortAscending);\n    ImGui::CheckboxFlags(\"_PreferSortDescending\", p_flags, ImGuiTableColumnFlags_PreferSortDescending);\n    ImGui::CheckboxFlags(\"_IndentEnable\", p_flags, ImGuiTableColumnFlags_IndentEnable); ImGui::SameLine(); HelpMarker(\"Default for column 0\");\n    ImGui::CheckboxFlags(\"_IndentDisable\", p_flags, ImGuiTableColumnFlags_IndentDisable); ImGui::SameLine(); HelpMarker(\"Default for column >0\");\n    ImGui::CheckboxFlags(\"_AngledHeader\", p_flags, ImGuiTableColumnFlags_AngledHeader);\n}\n\nstatic void ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags)\n{\n    ImGui::CheckboxFlags(\"_IsEnabled\", &flags, ImGuiTableColumnFlags_IsEnabled);\n    ImGui::CheckboxFlags(\"_IsVisible\", &flags, ImGuiTableColumnFlags_IsVisible);\n    ImGui::CheckboxFlags(\"_IsSorted\", &flags, ImGuiTableColumnFlags_IsSorted);\n    ImGui::CheckboxFlags(\"_IsHovered\", &flags, ImGuiTableColumnFlags_IsHovered);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowTables()\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowTables()\n{\n    //ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n    IMGUI_DEMO_MARKER(\"Tables\");\n    if (!ImGui::CollapsingHeader(\"Tables & Columns\"))\n        return;\n\n    // Using those as a base value to create width/height that are factor of the size of our font\n    const float TEXT_BASE_WIDTH = ImGui::CalcTextSize(\"A\").x;\n    const float TEXT_BASE_HEIGHT = ImGui::GetTextLineHeightWithSpacing();\n\n    ImGui::PushID(\"Tables\");\n\n    int open_action = -1;\n    if (ImGui::Button(\"Expand all\"))\n        open_action = 1;\n    ImGui::SameLine();\n    if (ImGui::Button(\"Collapse all\"))\n        open_action = 0;\n    ImGui::SameLine();\n\n    // Options\n    static bool disable_indent = false;\n    ImGui::Checkbox(\"Disable tree indentation\", &disable_indent);\n    ImGui::SameLine();\n    HelpMarker(\"Disable the indenting of tree nodes so demo tables can use the full window width.\");\n    ImGui::Separator();\n    if (disable_indent)\n        ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 0.0f);\n\n    // About Styling of tables\n    // Most settings are configured on a per-table basis via the flags passed to BeginTable() and TableSetupColumns APIs.\n    // There are however a few settings that a shared and part of the ImGuiStyle structure:\n    //   style.CellPadding                          // Padding within each cell\n    //   style.Colors[ImGuiCol_TableHeaderBg]       // Table header background\n    //   style.Colors[ImGuiCol_TableBorderStrong]   // Table outer and header borders\n    //   style.Colors[ImGuiCol_TableBorderLight]    // Table inner borders\n    //   style.Colors[ImGuiCol_TableRowBg]          // Table row background when ImGuiTableFlags_RowBg is enabled (even rows)\n    //   style.Colors[ImGuiCol_TableRowBgAlt]       // Table row background when ImGuiTableFlags_RowBg is enabled (odds rows)\n\n    // Demos\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Basic\");\n    if (ImGui::TreeNode(\"Basic\"))\n    {\n        // Here we will showcase three different ways to output a table.\n        // They are very simple variations of a same thing!\n\n        // [Method 1] Using TableNextRow() to create a new row, and TableSetColumnIndex() to select the column.\n        // In many situations, this is the most flexible and easy to use pattern.\n        HelpMarker(\"Using TableNextRow() + calling TableSetColumnIndex() _before_ each cell, in a loop.\");\n        if (ImGui::BeginTable(\"table1\", 3))\n        {\n            for (int row = 0; row < 4; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Row %d Column %d\", row, column);\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        // [Method 2] Using TableNextColumn() called multiple times, instead of using a for loop + TableSetColumnIndex().\n        // This is generally more convenient when you have code manually submitting the contents of each column.\n        HelpMarker(\"Using TableNextRow() + calling TableNextColumn() _before_ each cell, manually.\");\n        if (ImGui::BeginTable(\"table2\", 3))\n        {\n            for (int row = 0; row < 4; row++)\n            {\n                ImGui::TableNextRow();\n                ImGui::TableNextColumn();\n                ImGui::Text(\"Row %d\", row);\n                ImGui::TableNextColumn();\n                ImGui::Text(\"Some contents\");\n                ImGui::TableNextColumn();\n                ImGui::Text(\"123.456\");\n            }\n            ImGui::EndTable();\n        }\n\n        // [Method 3] We call TableNextColumn() _before_ each cell. We never call TableNextRow(),\n        // as TableNextColumn() will automatically wrap around and create new rows as needed.\n        // This is generally more convenient when your cells all contains the same type of data.\n        HelpMarker(\n            \"Only using TableNextColumn(), which tends to be convenient for tables where every cell contains \"\n            \"the same type of contents.\\n This is also more similar to the old NextColumn() function of the \"\n            \"Columns API, and provided to facilitate the Columns->Tables API transition.\");\n        if (ImGui::BeginTable(\"table3\", 3))\n        {\n            for (int item = 0; item < 14; item++)\n            {\n                ImGui::TableNextColumn();\n                ImGui::Text(\"Item %d\", item);\n            }\n            ImGui::EndTable();\n        }\n\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Borders, background\");\n    if (ImGui::TreeNode(\"Borders, background\"))\n    {\n        // Expose a few Borders related flags interactively\n        enum ContentsType { CT_Text, CT_FillButton };\n        static ImGuiTableFlags flags = ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg;\n        static bool display_headers = false;\n        static int contents_type = CT_Text;\n\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_RowBg\", &flags, ImGuiTableFlags_RowBg);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Borders\", &flags, ImGuiTableFlags_Borders);\n        ImGui::SameLine(); HelpMarker(\"ImGuiTableFlags_Borders\\n = ImGuiTableFlags_BordersInnerV\\n | ImGuiTableFlags_BordersOuterV\\n | ImGuiTableFlags_BordersInnerH\\n | ImGuiTableFlags_BordersOuterH\");\n        ImGui::Indent();\n\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersH\", &flags, ImGuiTableFlags_BordersH);\n        ImGui::Indent();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuterH\", &flags, ImGuiTableFlags_BordersOuterH);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInnerH\", &flags, ImGuiTableFlags_BordersInnerH);\n        ImGui::Unindent();\n\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersV\", &flags, ImGuiTableFlags_BordersV);\n        ImGui::Indent();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuterV\", &flags, ImGuiTableFlags_BordersOuterV);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInnerV\", &flags, ImGuiTableFlags_BordersInnerV);\n        ImGui::Unindent();\n\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuter\", &flags, ImGuiTableFlags_BordersOuter);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInner\", &flags, ImGuiTableFlags_BordersInner);\n        ImGui::Unindent();\n\n        ImGui::AlignTextToFramePadding(); ImGui::Text(\"Cell contents:\");\n        ImGui::SameLine(); ImGui::RadioButton(\"Text\", &contents_type, CT_Text);\n        ImGui::SameLine(); ImGui::RadioButton(\"FillButton\", &contents_type, CT_FillButton);\n        ImGui::Checkbox(\"Display headers\", &display_headers);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoBordersInBody\", &flags, ImGuiTableFlags_NoBordersInBody); ImGui::SameLine(); HelpMarker(\"Disable vertical borders in columns Body (borders will always appear in Headers\");\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table1\", 3, flags))\n        {\n            // Display headers so we can inspect their interaction with borders\n            // (Headers are not the main purpose of this section of the demo, so we are not elaborating on them now. See other sections for details)\n            if (display_headers)\n            {\n                ImGui::TableSetupColumn(\"One\");\n                ImGui::TableSetupColumn(\"Two\");\n                ImGui::TableSetupColumn(\"Three\");\n                ImGui::TableHeadersRow();\n            }\n\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    char buf[32];\n                    sprintf(buf, \"Hello %d,%d\", column, row);\n                    if (contents_type == CT_Text)\n                        ImGui::TextUnformatted(buf);\n                    else if (contents_type == CT_FillButton)\n                        ImGui::Button(buf, ImVec2(-FLT_MIN, 0.0f));\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Resizable, stretch\");\n    if (ImGui::TreeNode(\"Resizable, stretch\"))\n    {\n        // By default, if we don't enable ScrollX the sizing policy for each column is \"Stretch\"\n        // All columns maintain a sizing weight, and they will occupy all available width.\n        static ImGuiTableFlags flags = ImGuiTableFlags_SizingStretchSame | ImGuiTableFlags_Resizable | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_ContextMenuInBody;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersV\", &flags, ImGuiTableFlags_BordersV);\n        ImGui::SameLine(); HelpMarker(\n            \"Using the _Resizable flag automatically enables the _BordersInnerV flag as well, \"\n            \"this is why the resize borders are still showing when unchecking this.\");\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table1\", 3, flags))\n        {\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Hello %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Resizable, fixed\");\n    if (ImGui::TreeNode(\"Resizable, fixed\"))\n    {\n        // Here we use ImGuiTableFlags_SizingFixedFit (even though _ScrollX is not set)\n        // So columns will adopt the \"Fixed\" policy and will maintain a fixed width regardless of the whole available width (unless table is small)\n        // If there is not enough available width to fit all columns, they will however be resized down.\n        // FIXME-TABLE: Providing a stretch-on-init would make sense especially for tables which don't have saved settings\n        HelpMarker(\n            \"Using _Resizable + _SizingFixedFit flags.\\n\"\n            \"Fixed-width columns generally makes more sense if you want to use horizontal scrolling.\\n\\n\"\n            \"Double-click a column border to auto-fit the column to its contents.\");\n        PushStyleCompact();\n        static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Resizable | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_ContextMenuInBody;\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoHostExtendX\", &flags, ImGuiTableFlags_NoHostExtendX);\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table1\", 3, flags))\n        {\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Hello %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Resizable, mixed\");\n    if (ImGui::TreeNode(\"Resizable, mixed\"))\n    {\n        HelpMarker(\n            \"Using TableSetupColumn() to alter resizing policy on a per-column basis.\\n\\n\"\n            \"When combining Fixed and Stretch columns, generally you only want one, maybe two trailing columns to use _WidthStretch.\");\n        static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;\n\n        if (ImGui::BeginTable(\"table1\", 3, flags))\n        {\n            ImGui::TableSetupColumn(\"AAA\", ImGuiTableColumnFlags_WidthFixed);\n            ImGui::TableSetupColumn(\"BBB\", ImGuiTableColumnFlags_WidthFixed);\n            ImGui::TableSetupColumn(\"CCC\", ImGuiTableColumnFlags_WidthStretch);\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"%s %d,%d\", (column == 2) ? \"Stretch\" : \"Fixed\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        if (ImGui::BeginTable(\"table2\", 6, flags))\n        {\n            ImGui::TableSetupColumn(\"AAA\", ImGuiTableColumnFlags_WidthFixed);\n            ImGui::TableSetupColumn(\"BBB\", ImGuiTableColumnFlags_WidthFixed);\n            ImGui::TableSetupColumn(\"CCC\", ImGuiTableColumnFlags_WidthFixed | ImGuiTableColumnFlags_DefaultHide);\n            ImGui::TableSetupColumn(\"DDD\", ImGuiTableColumnFlags_WidthStretch);\n            ImGui::TableSetupColumn(\"EEE\", ImGuiTableColumnFlags_WidthStretch);\n            ImGui::TableSetupColumn(\"FFF\", ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_DefaultHide);\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 6; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"%s %d,%d\", (column >= 3) ? \"Stretch\" : \"Fixed\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Reorderable, hideable, with headers\");\n    if (ImGui::TreeNode(\"Reorderable, hideable, with headers\"))\n    {\n        HelpMarker(\n            \"Click and drag column headers to reorder columns.\\n\\n\"\n            \"Right-click on a header to open a context menu.\");\n        static ImGuiTableFlags flags = ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Reorderable\", &flags, ImGuiTableFlags_Reorderable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Hideable\", &flags, ImGuiTableFlags_Hideable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoBordersInBody\", &flags, ImGuiTableFlags_NoBordersInBody);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoBordersInBodyUntilResize\", &flags, ImGuiTableFlags_NoBordersInBodyUntilResize); ImGui::SameLine(); HelpMarker(\"Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers)\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_HighlightHoveredColumn\", &flags, ImGuiTableFlags_HighlightHoveredColumn);\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table1\", 3, flags))\n        {\n            // Submit columns name with TableSetupColumn() and call TableHeadersRow() to create a row with a header in each column.\n            // (Later we will show how TableSetupColumn() has other uses, optional flags, sizing weight etc.)\n            ImGui::TableSetupColumn(\"One\");\n            ImGui::TableSetupColumn(\"Two\");\n            ImGui::TableSetupColumn(\"Three\");\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 6; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Hello %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        // Use outer_size.x == 0.0f instead of default to make the table as tight as possible\n        // (only valid when no scrolling and no stretch column)\n        if (ImGui::BeginTable(\"table2\", 3, flags | ImGuiTableFlags_SizingFixedFit, ImVec2(0.0f, 0.0f)))\n        {\n            ImGui::TableSetupColumn(\"One\");\n            ImGui::TableSetupColumn(\"Two\");\n            ImGui::TableSetupColumn(\"Three\");\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 6; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Fixed %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Padding\");\n    if (ImGui::TreeNode(\"Padding\"))\n    {\n        // First example: showcase use of padding flags and effect of BorderOuterV/BorderInnerV on X padding.\n        // We don't expose BorderOuterH/BorderInnerH here because they have no effect on X padding.\n        HelpMarker(\n            \"We often want outer padding activated when any using features which makes the edges of a column visible:\\n\"\n            \"e.g.:\\n\"\n            \"- BorderOuterV\\n\"\n            \"- any form of row selection\\n\"\n            \"Because of this, activating BorderOuterV sets the default to PadOuterX. \"\n            \"Using PadOuterX or NoPadOuterX you can override the default.\\n\\n\"\n            \"Actual padding values are using style.CellPadding.\\n\\n\"\n            \"In this demo we don't show horizontal borders to emphasize how they don't affect default horizontal padding.\");\n\n        static ImGuiTableFlags flags1 = ImGuiTableFlags_BordersV;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_PadOuterX\", &flags1, ImGuiTableFlags_PadOuterX);\n        ImGui::SameLine(); HelpMarker(\"Enable outer-most padding (default if ImGuiTableFlags_BordersOuterV is set)\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoPadOuterX\", &flags1, ImGuiTableFlags_NoPadOuterX);\n        ImGui::SameLine(); HelpMarker(\"Disable outer-most padding (default if ImGuiTableFlags_BordersOuterV is not set)\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoPadInnerX\", &flags1, ImGuiTableFlags_NoPadInnerX);\n        ImGui::SameLine(); HelpMarker(\"Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off)\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuterV\", &flags1, ImGuiTableFlags_BordersOuterV);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInnerV\", &flags1, ImGuiTableFlags_BordersInnerV);\n        static bool show_headers = false;\n        ImGui::Checkbox(\"show_headers\", &show_headers);\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table_padding\", 3, flags1))\n        {\n            if (show_headers)\n            {\n                ImGui::TableSetupColumn(\"One\");\n                ImGui::TableSetupColumn(\"Two\");\n                ImGui::TableSetupColumn(\"Three\");\n                ImGui::TableHeadersRow();\n            }\n\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    if (row == 0)\n                    {\n                        ImGui::Text(\"Avail %.2f\", ImGui::GetContentRegionAvail().x);\n                    }\n                    else\n                    {\n                        char buf[32];\n                        sprintf(buf, \"Hello %d,%d\", column, row);\n                        ImGui::Button(buf, ImVec2(-FLT_MIN, 0.0f));\n                    }\n                    //if (ImGui::TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered)\n                    //    ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, IM_COL32(0, 100, 0, 255));\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        // Second example: set style.CellPadding to (0.0) or a custom value.\n        // FIXME-TABLE: Vertical border effectively not displayed the same way as horizontal one...\n        HelpMarker(\"Setting style.CellPadding to (0,0) or a custom value.\");\n        static ImGuiTableFlags flags2 = ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg;\n        static ImVec2 cell_padding(0.0f, 0.0f);\n        static bool show_widget_frame_bg = true;\n\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Borders\", &flags2, ImGuiTableFlags_Borders);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersH\", &flags2, ImGuiTableFlags_BordersH);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersV\", &flags2, ImGuiTableFlags_BordersV);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInner\", &flags2, ImGuiTableFlags_BordersInner);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuter\", &flags2, ImGuiTableFlags_BordersOuter);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_RowBg\", &flags2, ImGuiTableFlags_RowBg);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags2, ImGuiTableFlags_Resizable);\n        ImGui::Checkbox(\"show_widget_frame_bg\", &show_widget_frame_bg);\n        ImGui::SliderFloat2(\"CellPadding\", &cell_padding.x, 0.0f, 10.0f, \"%.0f\");\n        PopStyleCompact();\n\n        ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, cell_padding);\n        if (ImGui::BeginTable(\"table_padding_2\", 3, flags2))\n        {\n            static char text_bufs[3 * 5][16]; // Mini text storage for 3x5 cells\n            static bool init = true;\n            if (!show_widget_frame_bg)\n                ImGui::PushStyleColor(ImGuiCol_FrameBg, 0);\n            for (int cell = 0; cell < 3 * 5; cell++)\n            {\n                ImGui::TableNextColumn();\n                if (init)\n                    strcpy(text_bufs[cell], \"edit me\");\n                ImGui::SetNextItemWidth(-FLT_MIN);\n                ImGui::PushID(cell);\n                ImGui::InputText(\"##cell\", text_bufs[cell], IM_ARRAYSIZE(text_bufs[cell]));\n                ImGui::PopID();\n            }\n            if (!show_widget_frame_bg)\n                ImGui::PopStyleColor();\n            init = false;\n            ImGui::EndTable();\n        }\n        ImGui::PopStyleVar();\n\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Explicit widths\");\n    if (ImGui::TreeNode(\"Sizing policies\"))\n    {\n        static ImGuiTableFlags flags1 = ImGuiTableFlags_BordersV | ImGuiTableFlags_BordersOuterH | ImGuiTableFlags_RowBg | ImGuiTableFlags_ContextMenuInBody;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags1, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoHostExtendX\", &flags1, ImGuiTableFlags_NoHostExtendX);\n        PopStyleCompact();\n\n        static ImGuiTableFlags sizing_policy_flags[4] = { ImGuiTableFlags_SizingFixedFit, ImGuiTableFlags_SizingFixedSame, ImGuiTableFlags_SizingStretchProp, ImGuiTableFlags_SizingStretchSame };\n        for (int table_n = 0; table_n < 4; table_n++)\n        {\n            ImGui::PushID(table_n);\n            ImGui::SetNextItemWidth(TEXT_BASE_WIDTH * 30);\n            EditTableSizingFlags(&sizing_policy_flags[table_n]);\n\n            // To make it easier to understand the different sizing policy,\n            // For each policy: we display one table where the columns have equal contents width,\n            // and one where the columns have different contents width.\n            if (ImGui::BeginTable(\"table1\", 3, sizing_policy_flags[table_n] | flags1))\n            {\n                for (int row = 0; row < 3; row++)\n                {\n                    ImGui::TableNextRow();\n                    ImGui::TableNextColumn(); ImGui::Text(\"Oh dear\");\n                    ImGui::TableNextColumn(); ImGui::Text(\"Oh dear\");\n                    ImGui::TableNextColumn(); ImGui::Text(\"Oh dear\");\n                }\n                ImGui::EndTable();\n            }\n            if (ImGui::BeginTable(\"table2\", 3, sizing_policy_flags[table_n] | flags1))\n            {\n                for (int row = 0; row < 3; row++)\n                {\n                    ImGui::TableNextRow();\n                    ImGui::TableNextColumn(); ImGui::Text(\"AAAA\");\n                    ImGui::TableNextColumn(); ImGui::Text(\"BBBBBBBB\");\n                    ImGui::TableNextColumn(); ImGui::Text(\"CCCCCCCCCCCC\");\n                }\n                ImGui::EndTable();\n            }\n            ImGui::PopID();\n        }\n\n        ImGui::Spacing();\n        ImGui::TextUnformatted(\"Advanced\");\n        ImGui::SameLine();\n        HelpMarker(\n            \"This section allows you to interact and see the effect of various sizing policies \"\n            \"depending on whether Scroll is enabled and the contents of your columns.\");\n\n        enum ContentsType { CT_ShowWidth, CT_ShortText, CT_LongText, CT_Button, CT_FillButton, CT_InputText };\n        static ImGuiTableFlags flags = ImGuiTableFlags_ScrollY | ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable;\n        static int contents_type = CT_ShowWidth;\n        static int column_count = 3;\n\n        PushStyleCompact();\n        ImGui::PushID(\"Advanced\");\n        ImGui::PushItemWidth(TEXT_BASE_WIDTH * 30);\n        EditTableSizingFlags(&flags);\n        ImGui::Combo(\"Contents\", &contents_type, \"Show width\\0Short Text\\0Long Text\\0Button\\0Fill Button\\0InputText\\0\");\n        if (contents_type == CT_FillButton)\n        {\n            ImGui::SameLine();\n            HelpMarker(\n                \"Be mindful that using right-alignment (e.g. size.x = -FLT_MIN) creates a feedback loop \"\n                \"where contents width can feed into auto-column width can feed into contents width.\");\n        }\n        ImGui::DragInt(\"Columns\", &column_count, 0.1f, 1, 64, \"%d\", ImGuiSliderFlags_AlwaysClamp);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_PreciseWidths\", &flags, ImGuiTableFlags_PreciseWidths);\n        ImGui::SameLine(); HelpMarker(\"Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollX\", &flags, ImGuiTableFlags_ScrollX);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollY\", &flags, ImGuiTableFlags_ScrollY);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoClip\", &flags, ImGuiTableFlags_NoClip);\n        ImGui::PopItemWidth();\n        ImGui::PopID();\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table2\", column_count, flags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 7)))\n        {\n            for (int cell = 0; cell < 10 * column_count; cell++)\n            {\n                ImGui::TableNextColumn();\n                int column = ImGui::TableGetColumnIndex();\n                int row = ImGui::TableGetRowIndex();\n\n                ImGui::PushID(cell);\n                char label[32];\n                static char text_buf[32] = \"\";\n                sprintf(label, \"Hello %d,%d\", column, row);\n                switch (contents_type)\n                {\n                case CT_ShortText:  ImGui::TextUnformatted(label); break;\n                case CT_LongText:   ImGui::Text(\"Some %s text %d,%d\\nOver two lines..\", column == 0 ? \"long\" : \"longeeer\", column, row); break;\n                case CT_ShowWidth:  ImGui::Text(\"W: %.1f\", ImGui::GetContentRegionAvail().x); break;\n                case CT_Button:     ImGui::Button(label); break;\n                case CT_FillButton: ImGui::Button(label, ImVec2(-FLT_MIN, 0.0f)); break;\n                case CT_InputText:  ImGui::SetNextItemWidth(-FLT_MIN); ImGui::InputText(\"##\", text_buf, IM_ARRAYSIZE(text_buf)); break;\n                }\n                ImGui::PopID();\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Vertical scrolling, with clipping\");\n    if (ImGui::TreeNode(\"Vertical scrolling, with clipping\"))\n    {\n        HelpMarker(\n            \"Here we activate ScrollY, which will create a child window container to allow hosting scrollable contents.\\n\\n\"\n            \"We also demonstrate using ImGuiListClipper to virtualize the submission of many items.\");\n        static ImGuiTableFlags flags = ImGuiTableFlags_ScrollY | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;\n\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollY\", &flags, ImGuiTableFlags_ScrollY);\n        PopStyleCompact();\n\n        // When using ScrollX or ScrollY we need to specify a size for our table container!\n        // Otherwise by default the table will fit all available space, like a BeginChild() call.\n        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 8);\n        if (ImGui::BeginTable(\"table_scrolly\", 3, flags, outer_size))\n        {\n            ImGui::TableSetupScrollFreeze(0, 1); // Make top row always visible\n            ImGui::TableSetupColumn(\"One\", ImGuiTableColumnFlags_None);\n            ImGui::TableSetupColumn(\"Two\", ImGuiTableColumnFlags_None);\n            ImGui::TableSetupColumn(\"Three\", ImGuiTableColumnFlags_None);\n            ImGui::TableHeadersRow();\n\n            // Demonstrate using clipper for large vertical lists\n            ImGuiListClipper clipper;\n            clipper.Begin(1000);\n            while (clipper.Step())\n            {\n                for (int row = clipper.DisplayStart; row < clipper.DisplayEnd; row++)\n                {\n                    ImGui::TableNextRow();\n                    for (int column = 0; column < 3; column++)\n                    {\n                        ImGui::TableSetColumnIndex(column);\n                        ImGui::Text(\"Hello %d,%d\", column, row);\n                    }\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Horizontal scrolling\");\n    if (ImGui::TreeNode(\"Horizontal scrolling\"))\n    {\n        HelpMarker(\n            \"When ScrollX is enabled, the default sizing policy becomes ImGuiTableFlags_SizingFixedFit, \"\n            \"as automatically stretching columns doesn't make much sense with horizontal scrolling.\\n\\n\"\n            \"Also note that as of the current version, you will almost always want to enable ScrollY along with ScrollX, \"\n            \"because the container window won't automatically extend vertically to fix contents \"\n            \"(this may be improved in future versions).\");\n        static ImGuiTableFlags flags = ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;\n        static int freeze_cols = 1;\n        static int freeze_rows = 1;\n\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollX\", &flags, ImGuiTableFlags_ScrollX);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollY\", &flags, ImGuiTableFlags_ScrollY);\n        ImGui::SetNextItemWidth(ImGui::GetFrameHeight());\n        ImGui::DragInt(\"freeze_cols\", &freeze_cols, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);\n        ImGui::SetNextItemWidth(ImGui::GetFrameHeight());\n        ImGui::DragInt(\"freeze_rows\", &freeze_rows, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);\n        PopStyleCompact();\n\n        // When using ScrollX or ScrollY we need to specify a size for our table container!\n        // Otherwise by default the table will fit all available space, like a BeginChild() call.\n        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 8);\n        if (ImGui::BeginTable(\"table_scrollx\", 7, flags, outer_size))\n        {\n            ImGui::TableSetupScrollFreeze(freeze_cols, freeze_rows);\n            ImGui::TableSetupColumn(\"Line #\", ImGuiTableColumnFlags_NoHide); // Make the first column not hideable to match our use of TableSetupScrollFreeze()\n            ImGui::TableSetupColumn(\"One\");\n            ImGui::TableSetupColumn(\"Two\");\n            ImGui::TableSetupColumn(\"Three\");\n            ImGui::TableSetupColumn(\"Four\");\n            ImGui::TableSetupColumn(\"Five\");\n            ImGui::TableSetupColumn(\"Six\");\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 20; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 7; column++)\n                {\n                    // Both TableNextColumn() and TableSetColumnIndex() return true when a column is visible or performing width measurement.\n                    // Because here we know that:\n                    // - A) all our columns are contributing the same to row height\n                    // - B) column 0 is always visible,\n                    // We only always submit this one column and can skip others.\n                    // More advanced per-column clipping behaviors may benefit from polling the status flags via TableGetColumnFlags().\n                    if (!ImGui::TableSetColumnIndex(column) && column > 0)\n                        continue;\n                    if (column == 0)\n                        ImGui::Text(\"Line %d\", row);\n                    else\n                        ImGui::Text(\"Hello world %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        ImGui::Spacing();\n        ImGui::TextUnformatted(\"Stretch + ScrollX\");\n        ImGui::SameLine();\n        HelpMarker(\n            \"Showcase using Stretch columns + ScrollX together: \"\n            \"this is rather unusual and only makes sense when specifying an 'inner_width' for the table!\\n\"\n            \"Without an explicit value, inner_width is == outer_size.x and therefore using Stretch columns \"\n            \"along with ScrollX doesn't make sense.\");\n        static ImGuiTableFlags flags2 = ImGuiTableFlags_SizingStretchSame | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_RowBg | ImGuiTableFlags_ContextMenuInBody;\n        static float inner_width = 1000.0f;\n        PushStyleCompact();\n        ImGui::PushID(\"flags3\");\n        ImGui::PushItemWidth(TEXT_BASE_WIDTH * 30);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollX\", &flags2, ImGuiTableFlags_ScrollX);\n        ImGui::DragFloat(\"inner_width\", &inner_width, 1.0f, 0.0f, FLT_MAX, \"%.1f\");\n        ImGui::PopItemWidth();\n        ImGui::PopID();\n        PopStyleCompact();\n        if (ImGui::BeginTable(\"table2\", 7, flags2, outer_size, inner_width))\n        {\n            for (int cell = 0; cell < 20 * 7; cell++)\n            {\n                ImGui::TableNextColumn();\n                ImGui::Text(\"Hello world %d,%d\", ImGui::TableGetColumnIndex(), ImGui::TableGetRowIndex());\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Columns flags\");\n    if (ImGui::TreeNode(\"Columns flags\"))\n    {\n        // Create a first table just to show all the options/flags we want to make visible in our example!\n        const int column_count = 3;\n        const char* column_names[column_count] = { \"One\", \"Two\", \"Three\" };\n        static ImGuiTableColumnFlags column_flags[column_count] = { ImGuiTableColumnFlags_DefaultSort, ImGuiTableColumnFlags_None, ImGuiTableColumnFlags_DefaultHide };\n        static ImGuiTableColumnFlags column_flags_out[column_count] = { 0, 0, 0 }; // Output from TableGetColumnFlags()\n\n        if (ImGui::BeginTable(\"table_columns_flags_checkboxes\", column_count, ImGuiTableFlags_None))\n        {\n            PushStyleCompact();\n            for (int column = 0; column < column_count; column++)\n            {\n                ImGui::TableNextColumn();\n                ImGui::PushID(column);\n                ImGui::AlignTextToFramePadding(); // FIXME-TABLE: Workaround for wrong text baseline propagation across columns\n                ImGui::Text(\"'%s'\", column_names[column]);\n                ImGui::Spacing();\n                ImGui::Text(\"Input flags:\");\n                EditTableColumnsFlags(&column_flags[column]);\n                ImGui::Spacing();\n                ImGui::Text(\"Output flags:\");\n                ImGui::BeginDisabled();\n                ShowTableColumnsStatusFlags(column_flags_out[column]);\n                ImGui::EndDisabled();\n                ImGui::PopID();\n            }\n            PopStyleCompact();\n            ImGui::EndTable();\n        }\n\n        // Create the real table we care about for the example!\n        // We use a scrolling table to be able to showcase the difference between the _IsEnabled and _IsVisible flags above,\n        // otherwise in a non-scrolling table columns are always visible (unless using ImGuiTableFlags_NoKeepColumnsVisible\n        // + resizing the parent window down).\n        const ImGuiTableFlags flags\n            = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY\n            | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV\n            | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Sortable;\n        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 9);\n        if (ImGui::BeginTable(\"table_columns_flags\", column_count, flags, outer_size))\n        {\n            bool has_angled_header = false;\n            for (int column = 0; column < column_count; column++)\n            {\n                has_angled_header |= (column_flags[column] & ImGuiTableColumnFlags_AngledHeader) != 0;\n                ImGui::TableSetupColumn(column_names[column], column_flags[column]);\n            }\n            if (has_angled_header)\n                ImGui::TableAngledHeadersRow();\n            ImGui::TableHeadersRow();\n            for (int column = 0; column < column_count; column++)\n                column_flags_out[column] = ImGui::TableGetColumnFlags(column);\n            float indent_step = (float)((int)TEXT_BASE_WIDTH / 2);\n            for (int row = 0; row < 8; row++)\n            {\n                // Add some indentation to demonstrate usage of per-column IndentEnable/IndentDisable flags.\n                ImGui::Indent(indent_step);\n                ImGui::TableNextRow();\n                for (int column = 0; column < column_count; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"%s %s\", (column == 0) ? \"Indented\" : \"Hello\", ImGui::TableGetColumnName(column));\n                }\n            }\n            ImGui::Unindent(indent_step * 8.0f);\n\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Columns widths\");\n    if (ImGui::TreeNode(\"Columns widths\"))\n    {\n        HelpMarker(\"Using TableSetupColumn() to setup default width.\");\n\n        static ImGuiTableFlags flags1 = ImGuiTableFlags_Borders | ImGuiTableFlags_NoBordersInBodyUntilResize;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags1, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoBordersInBodyUntilResize\", &flags1, ImGuiTableFlags_NoBordersInBodyUntilResize);\n        PopStyleCompact();\n        if (ImGui::BeginTable(\"table1\", 3, flags1))\n        {\n            // We could also set ImGuiTableFlags_SizingFixedFit on the table and all columns will default to ImGuiTableColumnFlags_WidthFixed.\n            ImGui::TableSetupColumn(\"one\", ImGuiTableColumnFlags_WidthFixed, 100.0f); // Default to 100.0f\n            ImGui::TableSetupColumn(\"two\", ImGuiTableColumnFlags_WidthFixed, 200.0f); // Default to 200.0f\n            ImGui::TableSetupColumn(\"three\", ImGuiTableColumnFlags_WidthFixed);       // Default to auto\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 4; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    if (row == 0)\n                        ImGui::Text(\"(w: %5.1f)\", ImGui::GetContentRegionAvail().x);\n                    else\n                        ImGui::Text(\"Hello %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        HelpMarker(\n            \"Using TableSetupColumn() to setup explicit width.\\n\\nUnless _NoKeepColumnsVisible is set, \"\n            \"fixed columns with set width may still be shrunk down if there's not enough space in the host.\");\n\n        static ImGuiTableFlags flags2 = ImGuiTableFlags_None;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoKeepColumnsVisible\", &flags2, ImGuiTableFlags_NoKeepColumnsVisible);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInnerV\", &flags2, ImGuiTableFlags_BordersInnerV);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuterV\", &flags2, ImGuiTableFlags_BordersOuterV);\n        PopStyleCompact();\n        if (ImGui::BeginTable(\"table2\", 4, flags2))\n        {\n            // We could also set ImGuiTableFlags_SizingFixedFit on the table and then all columns\n            // will default to ImGuiTableColumnFlags_WidthFixed.\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthFixed, 100.0f);\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 15.0f);\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 30.0f);\n            ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 15.0f);\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 4; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    if (row == 0)\n                        ImGui::Text(\"(w: %5.1f)\", ImGui::GetContentRegionAvail().x);\n                    else\n                        ImGui::Text(\"Hello %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Nested tables\");\n    if (ImGui::TreeNode(\"Nested tables\"))\n    {\n        HelpMarker(\"This demonstrates embedding a table into another table cell.\");\n\n        if (ImGui::BeginTable(\"table_nested1\", 2, ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))\n        {\n            ImGui::TableSetupColumn(\"A0\");\n            ImGui::TableSetupColumn(\"A1\");\n            ImGui::TableHeadersRow();\n\n            ImGui::TableNextColumn();\n            ImGui::Text(\"A0 Row 0\");\n            {\n                float rows_height = TEXT_BASE_HEIGHT * 2;\n                if (ImGui::BeginTable(\"table_nested2\", 2, ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))\n                {\n                    ImGui::TableSetupColumn(\"B0\");\n                    ImGui::TableSetupColumn(\"B1\");\n                    ImGui::TableHeadersRow();\n\n                    ImGui::TableNextRow(ImGuiTableRowFlags_None, rows_height);\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"B0 Row 0\");\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"B1 Row 0\");\n                    ImGui::TableNextRow(ImGuiTableRowFlags_None, rows_height);\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"B0 Row 1\");\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"B1 Row 1\");\n\n                    ImGui::EndTable();\n                }\n            }\n            ImGui::TableNextColumn(); ImGui::Text(\"A1 Row 0\");\n            ImGui::TableNextColumn(); ImGui::Text(\"A0 Row 1\");\n            ImGui::TableNextColumn(); ImGui::Text(\"A1 Row 1\");\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Row height\");\n    if (ImGui::TreeNode(\"Row height\"))\n    {\n        HelpMarker(\n            \"You can pass a 'min_row_height' to TableNextRow().\\n\\nRows are padded with 'style.CellPadding.y' on top and bottom, \"\n            \"so effectively the minimum row height will always be >= 'style.CellPadding.y * 2.0f'.\\n\\n\"\n            \"We cannot honor a _maximum_ row height as that would require a unique clipping rectangle per row.\");\n        if (ImGui::BeginTable(\"table_row_height\", 1, ImGuiTableFlags_Borders))\n        {\n            for (int row = 0; row < 8; row++)\n            {\n                float min_row_height = (float)(int)(TEXT_BASE_HEIGHT * 0.30f * row);\n                ImGui::TableNextRow(ImGuiTableRowFlags_None, min_row_height);\n                ImGui::TableNextColumn();\n                ImGui::Text(\"min_row_height = %.2f\", min_row_height);\n            }\n            ImGui::EndTable();\n        }\n\n        HelpMarker(\n            \"Showcase using SameLine(0,0) to share Current Line Height between cells.\\n\\n\"\n            \"Please note that Tables Row Height is not the same thing as Current Line Height, \"\n            \"as a table cell may contains multiple lines.\");\n        if (ImGui::BeginTable(\"table_share_lineheight\", 2, ImGuiTableFlags_Borders))\n        {\n            ImGui::TableNextRow();\n            ImGui::TableNextColumn();\n            ImGui::ColorButton(\"##1\", ImVec4(0.13f, 0.26f, 0.40f, 1.0f), ImGuiColorEditFlags_None, ImVec2(40, 40));\n            ImGui::TableNextColumn();\n            ImGui::Text(\"Line 1\");\n            ImGui::Text(\"Line 2\");\n\n            ImGui::TableNextRow();\n            ImGui::TableNextColumn();\n            ImGui::ColorButton(\"##2\", ImVec4(0.13f, 0.26f, 0.40f, 1.0f), ImGuiColorEditFlags_None, ImVec2(40, 40));\n            ImGui::TableNextColumn();\n            ImGui::SameLine(0.0f, 0.0f); // Reuse line height from previous column\n            ImGui::Text(\"Line 1, with SameLine(0,0)\");\n            ImGui::Text(\"Line 2\");\n\n            ImGui::EndTable();\n        }\n\n        HelpMarker(\"Showcase altering CellPadding.y between rows. Note that CellPadding.x is locked for the entire table.\");\n        if (ImGui::BeginTable(\"table_changing_cellpadding_y\", 1, ImGuiTableFlags_Borders))\n        {\n            ImGuiStyle& style = ImGui::GetStyle();\n            for (int row = 0; row < 8; row++)\n            {\n                if ((row % 3) == 2)\n                    ImGui::PushStyleVarY(ImGuiStyleVar_CellPadding, 20.0f);\n                ImGui::TableNextRow(ImGuiTableRowFlags_None);\n                ImGui::TableNextColumn();\n                ImGui::Text(\"CellPadding.y = %.2f\", style.CellPadding.y);\n                if ((row % 3) == 2)\n                    ImGui::PopStyleVar();\n            }\n            ImGui::EndTable();\n        }\n\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Outer size\");\n    if (ImGui::TreeNode(\"Outer size\"))\n    {\n        // Showcasing use of ImGuiTableFlags_NoHostExtendX and ImGuiTableFlags_NoHostExtendY\n        // Important to that note how the two flags have slightly different behaviors!\n        ImGui::Text(\"Using NoHostExtendX and NoHostExtendY:\");\n        PushStyleCompact();\n        static ImGuiTableFlags flags = ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_ContextMenuInBody | ImGuiTableFlags_RowBg | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_NoHostExtendX;\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoHostExtendX\", &flags, ImGuiTableFlags_NoHostExtendX);\n        ImGui::SameLine(); HelpMarker(\"Make outer width auto-fit to columns, overriding outer_size.x value.\\n\\nOnly available when ScrollX/ScrollY are disabled and Stretch columns are not used.\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_NoHostExtendY\", &flags, ImGuiTableFlags_NoHostExtendY);\n        ImGui::SameLine(); HelpMarker(\"Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit).\\n\\nOnly available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.\");\n        PopStyleCompact();\n\n        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 5.5f);\n        if (ImGui::BeginTable(\"table1\", 3, flags, outer_size))\n        {\n            for (int row = 0; row < 10; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"Cell %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::SameLine();\n        ImGui::Text(\"Hello!\");\n\n        ImGui::Spacing();\n\n        ImGui::Text(\"Using explicit size:\");\n        if (ImGui::BeginTable(\"table2\", 3, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg, ImVec2(TEXT_BASE_WIDTH * 30, 0.0f)))\n        {\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"Cell %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::SameLine();\n        if (ImGui::BeginTable(\"table3\", 3, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg, ImVec2(TEXT_BASE_WIDTH * 30, 0.0f)))\n        {\n            for (int row = 0; row < 3; row++)\n            {\n                ImGui::TableNextRow(0, TEXT_BASE_HEIGHT * 1.5f);\n                for (int column = 0; column < 3; column++)\n                {\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"Cell %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Background color\");\n    if (ImGui::TreeNode(\"Background color\"))\n    {\n        static ImGuiTableFlags flags = ImGuiTableFlags_RowBg;\n        static int row_bg_type = 1;\n        static int row_bg_target = 1;\n        static int cell_bg_type = 1;\n\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Borders\", &flags, ImGuiTableFlags_Borders);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_RowBg\", &flags, ImGuiTableFlags_RowBg);\n        ImGui::SameLine(); HelpMarker(\"ImGuiTableFlags_RowBg automatically sets RowBg0 to alternative colors pulled from the Style.\");\n        ImGui::Combo(\"row bg type\", (int*)&row_bg_type, \"None\\0Red\\0Gradient\\0\");\n        ImGui::Combo(\"row bg target\", (int*)&row_bg_target, \"RowBg0\\0RowBg1\\0\"); ImGui::SameLine(); HelpMarker(\"Target RowBg0 to override the alternating odd/even colors,\\nTarget RowBg1 to blend with them.\");\n        ImGui::Combo(\"cell bg type\", (int*)&cell_bg_type, \"None\\0Blue\\0\"); ImGui::SameLine(); HelpMarker(\"We are colorizing cells to B1->C2 here.\");\n        IM_ASSERT(row_bg_type >= 0 && row_bg_type <= 2);\n        IM_ASSERT(row_bg_target >= 0 && row_bg_target <= 1);\n        IM_ASSERT(cell_bg_type >= 0 && cell_bg_type <= 1);\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table1\", 5, flags))\n        {\n            for (int row = 0; row < 6; row++)\n            {\n                ImGui::TableNextRow();\n\n                // Demonstrate setting a row background color with 'ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBgX, ...)'\n                // We use a transparent color so we can see the one behind in case our target is RowBg1 and RowBg0 was already targeted by the ImGuiTableFlags_RowBg flag.\n                if (row_bg_type != 0)\n                {\n                    ImU32 row_bg_color = ImGui::GetColorU32(row_bg_type == 1 ? ImVec4(0.7f, 0.3f, 0.3f, 0.65f) : ImVec4(0.2f + row * 0.1f, 0.2f, 0.2f, 0.65f)); // Flat or Gradient?\n                    ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0 + row_bg_target, row_bg_color);\n                }\n\n                // Fill cells\n                for (int column = 0; column < 5; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"%c%c\", 'A' + row, '0' + column);\n\n                    // Change background of Cells B1->C2\n                    // Demonstrate setting a cell background color with 'ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, ...)'\n                    // (the CellBg color will be blended over the RowBg and ColumnBg colors)\n                    // We can also pass a column number as a third parameter to TableSetBgColor() and do this outside the column loop.\n                    if (row >= 1 && row <= 2 && column >= 1 && column <= 2 && cell_bg_type == 1)\n                    {\n                        ImU32 cell_bg_color = ImGui::GetColorU32(ImVec4(0.3f, 0.3f, 0.7f, 0.65f));\n                        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, cell_bg_color);\n                    }\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Tree view\");\n    if (ImGui::TreeNode(\"Tree view\"))\n    {\n        static ImGuiTableFlags flags = ImGuiTableFlags_BordersV | ImGuiTableFlags_BordersOuterH | ImGuiTableFlags_Resizable | ImGuiTableFlags_RowBg | ImGuiTableFlags_NoBordersInBody;\n\n        static ImGuiTreeNodeFlags tree_node_flags = ImGuiTreeNodeFlags_SpanAllColumns;\n        ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanFullWidth\",  &tree_node_flags, ImGuiTreeNodeFlags_SpanFullWidth);\n        ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanTextWidth\",  &tree_node_flags, ImGuiTreeNodeFlags_SpanTextWidth);\n        ImGui::CheckboxFlags(\"ImGuiTreeNodeFlags_SpanAllColumns\", &tree_node_flags, ImGuiTreeNodeFlags_SpanAllColumns);\n\n        HelpMarker(\"See \\\"Columns flags\\\" section to configure how indentation is applied to individual columns.\");\n        if (ImGui::BeginTable(\"3ways\", 3, flags))\n        {\n            // The first column will use the default _WidthStretch when ScrollX is Off and _WidthFixed when ScrollX is On\n            ImGui::TableSetupColumn(\"Name\", ImGuiTableColumnFlags_NoHide);\n            ImGui::TableSetupColumn(\"Size\", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 12.0f);\n            ImGui::TableSetupColumn(\"Type\", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 18.0f);\n            ImGui::TableHeadersRow();\n\n            // Simple storage to output a dummy file-system.\n            struct MyTreeNode\n            {\n                const char*     Name;\n                const char*     Type;\n                int             Size;\n                int             ChildIdx;\n                int             ChildCount;\n                static void DisplayNode(const MyTreeNode* node, const MyTreeNode* all_nodes)\n                {\n                    ImGui::TableNextRow();\n                    ImGui::TableNextColumn();\n                    const bool is_folder = (node->ChildCount > 0);\n                    if (is_folder)\n                    {\n                        bool open = ImGui::TreeNodeEx(node->Name, tree_node_flags);\n                        ImGui::TableNextColumn();\n                        ImGui::TextDisabled(\"--\");\n                        ImGui::TableNextColumn();\n                        ImGui::TextUnformatted(node->Type);\n                        if (open)\n                        {\n                            for (int child_n = 0; child_n < node->ChildCount; child_n++)\n                                DisplayNode(&all_nodes[node->ChildIdx + child_n], all_nodes);\n                            ImGui::TreePop();\n                        }\n                    }\n                    else\n                    {\n                        ImGui::TreeNodeEx(node->Name, tree_node_flags | ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_Bullet | ImGuiTreeNodeFlags_NoTreePushOnOpen);\n                        ImGui::TableNextColumn();\n                        ImGui::Text(\"%d\", node->Size);\n                        ImGui::TableNextColumn();\n                        ImGui::TextUnformatted(node->Type);\n                    }\n                }\n            };\n            static const MyTreeNode nodes[] =\n            {\n                { \"Root\",                         \"Folder\",       -1,       1, 3    }, // 0\n                { \"Music\",                        \"Folder\",       -1,       4, 2    }, // 1\n                { \"Textures\",                     \"Folder\",       -1,       6, 3    }, // 2\n                { \"desktop.ini\",                  \"System file\",  1024,    -1,-1    }, // 3\n                { \"File1_a.wav\",                  \"Audio file\",   123000,  -1,-1    }, // 4\n                { \"File1_b.wav\",                  \"Audio file\",   456000,  -1,-1    }, // 5\n                { \"Image001.png\",                 \"Image file\",   203128,  -1,-1    }, // 6\n                { \"Copy of Image001.png\",         \"Image file\",   203256,  -1,-1    }, // 7\n                { \"Copy of Image001 (Final2).png\",\"Image file\",   203512,  -1,-1    }, // 8\n            };\n\n            MyTreeNode::DisplayNode(&nodes[0], nodes);\n\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Item width\");\n    if (ImGui::TreeNode(\"Item width\"))\n    {\n        HelpMarker(\n            \"Showcase using PushItemWidth() and how it is preserved on a per-column basis.\\n\\n\"\n            \"Note that on auto-resizing non-resizable fixed columns, querying the content width for \"\n            \"e.g. right-alignment doesn't make sense.\");\n        if (ImGui::BeginTable(\"table_item_width\", 3, ImGuiTableFlags_Borders))\n        {\n            ImGui::TableSetupColumn(\"small\");\n            ImGui::TableSetupColumn(\"half\");\n            ImGui::TableSetupColumn(\"right-align\");\n            ImGui::TableHeadersRow();\n\n            for (int row = 0; row < 3; row++)\n            {\n                ImGui::TableNextRow();\n                if (row == 0)\n                {\n                    // Setup ItemWidth once (instead of setting up every time, which is also possible but less efficient)\n                    ImGui::TableSetColumnIndex(0);\n                    ImGui::PushItemWidth(TEXT_BASE_WIDTH * 3.0f); // Small\n                    ImGui::TableSetColumnIndex(1);\n                    ImGui::PushItemWidth(-ImGui::GetContentRegionAvail().x * 0.5f);\n                    ImGui::TableSetColumnIndex(2);\n                    ImGui::PushItemWidth(-FLT_MIN); // Right-aligned\n                }\n\n                // Draw our contents\n                static float dummy_f = 0.0f;\n                ImGui::PushID(row);\n                ImGui::TableSetColumnIndex(0);\n                ImGui::SliderFloat(\"float0\", &dummy_f, 0.0f, 1.0f);\n                ImGui::TableSetColumnIndex(1);\n                ImGui::SliderFloat(\"float1\", &dummy_f, 0.0f, 1.0f);\n                ImGui::TableSetColumnIndex(2);\n                ImGui::SliderFloat(\"##float2\", &dummy_f, 0.0f, 1.0f); // No visible label since right-aligned\n                ImGui::PopID();\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    // Demonstrate using TableHeader() calls instead of TableHeadersRow()\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Custom headers\");\n    if (ImGui::TreeNode(\"Custom headers\"))\n    {\n        const int COLUMNS_COUNT = 3;\n        if (ImGui::BeginTable(\"table_custom_headers\", COLUMNS_COUNT, ImGuiTableFlags_Borders | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))\n        {\n            ImGui::TableSetupColumn(\"Apricot\");\n            ImGui::TableSetupColumn(\"Banana\");\n            ImGui::TableSetupColumn(\"Cherry\");\n\n            // Dummy entire-column selection storage\n            // FIXME: It would be nice to actually demonstrate full-featured selection using those checkbox.\n            static bool column_selected[3] = {};\n\n            // Instead of calling TableHeadersRow() we'll submit custom headers ourselves.\n            // (A different approach is also possible:\n            //    - Specify ImGuiTableColumnFlags_NoHeaderLabel in some TableSetupColumn() call.\n            //    - Call TableHeadersRow() normally. This will submit TableHeader() with no name.\n            //    - Then call TableSetColumnIndex() to position yourself in the column and submit your stuff e.g. Checkbox().)\n            ImGui::TableNextRow(ImGuiTableRowFlags_Headers);\n            for (int column = 0; column < COLUMNS_COUNT; column++)\n            {\n                ImGui::TableSetColumnIndex(column);\n                const char* column_name = ImGui::TableGetColumnName(column); // Retrieve name passed to TableSetupColumn()\n                ImGui::PushID(column);\n                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n                ImGui::Checkbox(\"##checkall\", &column_selected[column]);\n                ImGui::PopStyleVar();\n                ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n                ImGui::TableHeader(column_name);\n                ImGui::PopID();\n            }\n\n            // Submit table contents\n            for (int row = 0; row < 5; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < 3; column++)\n                {\n                    char buf[32];\n                    sprintf(buf, \"Cell %d,%d\", column, row);\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Selectable(buf, column_selected[column]);\n                }\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    // Demonstrate using ImGuiTableColumnFlags_AngledHeader flag to create angled headers\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Angled headers\");\n    if (ImGui::TreeNode(\"Angled headers\"))\n    {\n        const char* column_names[] = { \"Track\", \"cabasa\", \"ride\", \"smash\", \"tom-hi\", \"tom-mid\", \"tom-low\", \"hihat-o\", \"hihat-c\", \"snare-s\", \"snare-c\", \"clap\", \"rim\", \"kick\" };\n        const int columns_count = IM_ARRAYSIZE(column_names);\n        const int rows_count = 12;\n\n        static ImGuiTableFlags table_flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_Hideable | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_HighlightHoveredColumn;\n        static ImGuiTableColumnFlags column_flags = ImGuiTableColumnFlags_AngledHeader | ImGuiTableColumnFlags_WidthFixed;\n        static bool bools[columns_count * rows_count] = {}; // Dummy storage selection storage\n        static int frozen_cols = 1;\n        static int frozen_rows = 2;\n        ImGui::CheckboxFlags(\"_ScrollX\", &table_flags, ImGuiTableFlags_ScrollX);\n        ImGui::CheckboxFlags(\"_ScrollY\", &table_flags, ImGuiTableFlags_ScrollY);\n        ImGui::CheckboxFlags(\"_Resizable\", &table_flags, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"_Sortable\", &table_flags, ImGuiTableFlags_Sortable);\n        ImGui::CheckboxFlags(\"_NoBordersInBody\", &table_flags, ImGuiTableFlags_NoBordersInBody);\n        ImGui::CheckboxFlags(\"_HighlightHoveredColumn\", &table_flags, ImGuiTableFlags_HighlightHoveredColumn);\n        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n        ImGui::SliderInt(\"Frozen columns\", &frozen_cols, 0, 2);\n        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n        ImGui::SliderInt(\"Frozen rows\", &frozen_rows, 0, 2);\n        ImGui::CheckboxFlags(\"Disable header contributing to column width\", &column_flags, ImGuiTableColumnFlags_NoHeaderWidth);\n\n        if (ImGui::TreeNode(\"Style settings\"))\n        {\n            ImGui::SameLine();\n            HelpMarker(\"Giving access to some ImGuiStyle value in this demo for convenience.\");\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n            ImGui::SliderAngle(\"style.TableAngledHeadersAngle\", &ImGui::GetStyle().TableAngledHeadersAngle, -50.0f, +50.0f);\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n            ImGui::SliderFloat2(\"style.TableAngledHeadersTextAlign\", (float*)&ImGui::GetStyle().TableAngledHeadersTextAlign, 0.0f, 1.0f, \"%.2f\");\n            ImGui::TreePop();\n        }\n\n        if (ImGui::BeginTable(\"table_angled_headers\", columns_count, table_flags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 12)))\n        {\n            ImGui::TableSetupColumn(column_names[0], ImGuiTableColumnFlags_NoHide | ImGuiTableColumnFlags_NoReorder);\n            for (int n = 1; n < columns_count; n++)\n                ImGui::TableSetupColumn(column_names[n], column_flags);\n            ImGui::TableSetupScrollFreeze(frozen_cols, frozen_rows);\n\n            ImGui::TableAngledHeadersRow(); // Draw angled headers for all columns with the ImGuiTableColumnFlags_AngledHeader flag.\n            ImGui::TableHeadersRow();       // Draw remaining headers and allow access to context-menu and other functions.\n            for (int row = 0; row < rows_count; row++)\n            {\n                ImGui::PushID(row);\n                ImGui::TableNextRow();\n                ImGui::TableSetColumnIndex(0);\n                ImGui::AlignTextToFramePadding();\n                ImGui::Text(\"Track %d\", row);\n                for (int column = 1; column < columns_count; column++)\n                    if (ImGui::TableSetColumnIndex(column))\n                    {\n                        ImGui::PushID(column);\n                        ImGui::Checkbox(\"\", &bools[row * columns_count + column]);\n                        ImGui::PopID();\n                    }\n                ImGui::PopID();\n            }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    // Demonstrate creating custom context menus inside columns,\n    // while playing it nice with context menus provided by TableHeadersRow()/TableHeader()\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Context menus\");\n    if (ImGui::TreeNode(\"Context menus\"))\n    {\n        HelpMarker(\n            \"By default, right-clicking over a TableHeadersRow()/TableHeader() line will open the default context-menu.\\n\"\n            \"Using ImGuiTableFlags_ContextMenuInBody we also allow right-clicking over columns body.\");\n        static ImGuiTableFlags flags1 = ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Borders | ImGuiTableFlags_ContextMenuInBody;\n\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ContextMenuInBody\", &flags1, ImGuiTableFlags_ContextMenuInBody);\n        PopStyleCompact();\n\n        // Context Menus: first example\n        // [1.1] Right-click on the TableHeadersRow() line to open the default table context menu.\n        // [1.2] Right-click in columns also open the default table context menu (if ImGuiTableFlags_ContextMenuInBody is set)\n        const int COLUMNS_COUNT = 3;\n        if (ImGui::BeginTable(\"table_context_menu\", COLUMNS_COUNT, flags1))\n        {\n            ImGui::TableSetupColumn(\"One\");\n            ImGui::TableSetupColumn(\"Two\");\n            ImGui::TableSetupColumn(\"Three\");\n\n            // [1.1]] Right-click on the TableHeadersRow() line to open the default table context menu.\n            ImGui::TableHeadersRow();\n\n            // Submit dummy contents\n            for (int row = 0; row < 4; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < COLUMNS_COUNT; column++)\n                {\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Cell %d,%d\", column, row);\n                }\n            }\n            ImGui::EndTable();\n        }\n\n        // Context Menus: second example\n        // [2.1] Right-click on the TableHeadersRow() line to open the default table context menu.\n        // [2.2] Right-click on the \"..\" to open a custom popup\n        // [2.3] Right-click in columns to open another custom popup\n        HelpMarker(\n            \"Demonstrate mixing table context menu (over header), item context button (over button) \"\n            \"and custom per-colunm context menu (over column body).\");\n        ImGuiTableFlags flags2 = ImGuiTableFlags_Resizable | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Borders;\n        if (ImGui::BeginTable(\"table_context_menu_2\", COLUMNS_COUNT, flags2))\n        {\n            ImGui::TableSetupColumn(\"One\");\n            ImGui::TableSetupColumn(\"Two\");\n            ImGui::TableSetupColumn(\"Three\");\n\n            // [2.1] Right-click on the TableHeadersRow() line to open the default table context menu.\n            ImGui::TableHeadersRow();\n            for (int row = 0; row < 4; row++)\n            {\n                ImGui::TableNextRow();\n                for (int column = 0; column < COLUMNS_COUNT; column++)\n                {\n                    // Submit dummy contents\n                    ImGui::TableSetColumnIndex(column);\n                    ImGui::Text(\"Cell %d,%d\", column, row);\n                    ImGui::SameLine();\n\n                    // [2.2] Right-click on the \"..\" to open a custom popup\n                    ImGui::PushID(row * COLUMNS_COUNT + column);\n                    ImGui::SmallButton(\"..\");\n                    if (ImGui::BeginPopupContextItem())\n                    {\n                        ImGui::Text(\"This is the popup for Button(\\\"..\\\") in Cell %d,%d\", column, row);\n                        if (ImGui::Button(\"Close\"))\n                            ImGui::CloseCurrentPopup();\n                        ImGui::EndPopup();\n                    }\n                    ImGui::PopID();\n                }\n            }\n\n            // [2.3] Right-click anywhere in columns to open another custom popup\n            // (instead of testing for !IsAnyItemHovered() we could also call OpenPopup() with ImGuiPopupFlags_NoOpenOverExistingPopup\n            // to manage popup priority as the popups triggers, here \"are we hovering a column\" are overlapping)\n            int hovered_column = -1;\n            for (int column = 0; column < COLUMNS_COUNT + 1; column++)\n            {\n                ImGui::PushID(column);\n                if (ImGui::TableGetColumnFlags(column) & ImGuiTableColumnFlags_IsHovered)\n                    hovered_column = column;\n                if (hovered_column == column && !ImGui::IsAnyItemHovered() && ImGui::IsMouseReleased(1))\n                    ImGui::OpenPopup(\"MyPopup\");\n                if (ImGui::BeginPopup(\"MyPopup\"))\n                {\n                    if (column == COLUMNS_COUNT)\n                        ImGui::Text(\"This is a custom popup for unused space after the last column.\");\n                    else\n                        ImGui::Text(\"This is a custom popup for Column %d\", column);\n                    if (ImGui::Button(\"Close\"))\n                        ImGui::CloseCurrentPopup();\n                    ImGui::EndPopup();\n                }\n                ImGui::PopID();\n            }\n\n            ImGui::EndTable();\n            ImGui::Text(\"Hovered column: %d\", hovered_column);\n        }\n        ImGui::TreePop();\n    }\n\n    // Demonstrate creating multiple tables with the same ID\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Synced instances\");\n    if (ImGui::TreeNode(\"Synced instances\"))\n    {\n        HelpMarker(\"Multiple tables with the same identifier will share their settings, width, visibility, order etc.\");\n\n        static ImGuiTableFlags flags = ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Borders | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_NoSavedSettings;\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags, ImGuiTableFlags_Resizable);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollY\", &flags, ImGuiTableFlags_ScrollY);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_SizingFixedFit\", &flags, ImGuiTableFlags_SizingFixedFit);\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_HighlightHoveredColumn\", &flags, ImGuiTableFlags_HighlightHoveredColumn);\n        for (int n = 0; n < 3; n++)\n        {\n            char buf[32];\n            sprintf(buf, \"Synced Table %d\", n);\n            bool open = ImGui::CollapsingHeader(buf, ImGuiTreeNodeFlags_DefaultOpen);\n            if (open && ImGui::BeginTable(\"Table\", 3, flags, ImVec2(0.0f, ImGui::GetTextLineHeightWithSpacing() * 5)))\n            {\n                ImGui::TableSetupColumn(\"One\");\n                ImGui::TableSetupColumn(\"Two\");\n                ImGui::TableSetupColumn(\"Three\");\n                ImGui::TableHeadersRow();\n                const int cell_count = (n == 1) ? 27 : 9; // Make second table have a scrollbar to verify that additional decoration is not affecting column positions.\n                for (int cell = 0; cell < cell_count; cell++)\n                {\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"this cell %d\", cell);\n                }\n                ImGui::EndTable();\n            }\n        }\n        ImGui::TreePop();\n    }\n\n    // Demonstrate using Sorting facilities\n    // This is a simplified version of the \"Advanced\" example, where we mostly focus on the code necessary to handle sorting.\n    // Note that the \"Advanced\" example also showcase manually triggering a sort (e.g. if item quantities have been modified)\n    static const char* template_items_names[] =\n    {\n        \"Banana\", \"Apple\", \"Cherry\", \"Watermelon\", \"Grapefruit\", \"Strawberry\", \"Mango\",\n        \"Kiwi\", \"Orange\", \"Pineapple\", \"Blueberry\", \"Plum\", \"Coconut\", \"Pear\", \"Apricot\"\n    };\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Sorting\");\n    if (ImGui::TreeNode(\"Sorting\"))\n    {\n        // Create item list\n        static ImVector<MyItem> items;\n        if (items.Size == 0)\n        {\n            items.resize(50, MyItem());\n            for (int n = 0; n < items.Size; n++)\n            {\n                const int template_n = n % IM_ARRAYSIZE(template_items_names);\n                MyItem& item = items[n];\n                item.ID = n;\n                item.Name = template_items_names[template_n];\n                item.Quantity = (n * n - n) % 20; // Assign default quantities\n            }\n        }\n\n        // Options\n        static ImGuiTableFlags flags =\n            ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Sortable | ImGuiTableFlags_SortMulti\n            | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_NoBordersInBody\n            | ImGuiTableFlags_ScrollY;\n        PushStyleCompact();\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_SortMulti\", &flags, ImGuiTableFlags_SortMulti);\n        ImGui::SameLine(); HelpMarker(\"When sorting is enabled: hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).\");\n        ImGui::CheckboxFlags(\"ImGuiTableFlags_SortTristate\", &flags, ImGuiTableFlags_SortTristate);\n        ImGui::SameLine(); HelpMarker(\"When sorting is enabled: allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).\");\n        PopStyleCompact();\n\n        if (ImGui::BeginTable(\"table_sorting\", 4, flags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 15), 0.0f))\n        {\n            // Declare columns\n            // We use the \"user_id\" parameter of TableSetupColumn() to specify a user id that will be stored in the sort specifications.\n            // This is so our sort function can identify a column given our own identifier. We could also identify them based on their index!\n            // Demonstrate using a mixture of flags among available sort-related flags:\n            // - ImGuiTableColumnFlags_DefaultSort\n            // - ImGuiTableColumnFlags_NoSort / ImGuiTableColumnFlags_NoSortAscending / ImGuiTableColumnFlags_NoSortDescending\n            // - ImGuiTableColumnFlags_PreferSortAscending / ImGuiTableColumnFlags_PreferSortDescending\n            ImGui::TableSetupColumn(\"ID\",       ImGuiTableColumnFlags_DefaultSort          | ImGuiTableColumnFlags_WidthFixed,   0.0f, MyItemColumnID_ID);\n            ImGui::TableSetupColumn(\"Name\",                                                  ImGuiTableColumnFlags_WidthFixed,   0.0f, MyItemColumnID_Name);\n            ImGui::TableSetupColumn(\"Action\",   ImGuiTableColumnFlags_NoSort               | ImGuiTableColumnFlags_WidthFixed,   0.0f, MyItemColumnID_Action);\n            ImGui::TableSetupColumn(\"Quantity\", ImGuiTableColumnFlags_PreferSortDescending | ImGuiTableColumnFlags_WidthStretch, 0.0f, MyItemColumnID_Quantity);\n            ImGui::TableSetupScrollFreeze(0, 1); // Make row always visible\n            ImGui::TableHeadersRow();\n\n            // Sort our data if sort specs have been changed!\n            if (ImGuiTableSortSpecs* sort_specs = ImGui::TableGetSortSpecs())\n                if (sort_specs->SpecsDirty)\n                {\n                    MyItem::SortWithSortSpecs(sort_specs, items.Data, items.Size);\n                    sort_specs->SpecsDirty = false;\n                }\n\n            // Demonstrate using clipper for large vertical lists\n            ImGuiListClipper clipper;\n            clipper.Begin(items.Size);\n            while (clipper.Step())\n                for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++)\n                {\n                    // Display a data item\n                    MyItem* item = &items[row_n];\n                    ImGui::PushID(item->ID);\n                    ImGui::TableNextRow();\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"%04d\", item->ID);\n                    ImGui::TableNextColumn();\n                    ImGui::TextUnformatted(item->Name);\n                    ImGui::TableNextColumn();\n                    ImGui::SmallButton(\"None\");\n                    ImGui::TableNextColumn();\n                    ImGui::Text(\"%d\", item->Quantity);\n                    ImGui::PopID();\n                }\n            ImGui::EndTable();\n        }\n        ImGui::TreePop();\n    }\n\n    // In this example we'll expose most table flags and settings.\n    // For specific flags and settings refer to the corresponding section for more detailed explanation.\n    // This section is mostly useful to experiment with combining certain flags or settings with each others.\n    //ImGui::SetNextItemOpen(true, ImGuiCond_Once); // [DEBUG]\n    if (open_action != -1)\n        ImGui::SetNextItemOpen(open_action != 0);\n    IMGUI_DEMO_MARKER(\"Tables/Advanced\");\n    if (ImGui::TreeNode(\"Advanced\"))\n    {\n        static ImGuiTableFlags flags =\n            ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable\n            | ImGuiTableFlags_Sortable | ImGuiTableFlags_SortMulti\n            | ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_NoBordersInBody\n            | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY\n            | ImGuiTableFlags_SizingFixedFit;\n        static ImGuiTableColumnFlags columns_base_flags = ImGuiTableColumnFlags_None;\n\n        enum ContentsType { CT_Text, CT_Button, CT_SmallButton, CT_FillButton, CT_Selectable, CT_SelectableSpanRow };\n        static int contents_type = CT_SelectableSpanRow;\n        const char* contents_type_names[] = { \"Text\", \"Button\", \"SmallButton\", \"FillButton\", \"Selectable\", \"Selectable (span row)\" };\n        static int freeze_cols = 1;\n        static int freeze_rows = 1;\n        static int items_count = IM_ARRAYSIZE(template_items_names) * 2;\n        static ImVec2 outer_size_value = ImVec2(0.0f, TEXT_BASE_HEIGHT * 12);\n        static float row_min_height = 0.0f; // Auto\n        static float inner_width_with_scroll = 0.0f; // Auto-extend\n        static bool outer_size_enabled = true;\n        static bool show_headers = true;\n        static bool show_wrapped_text = false;\n        //static ImGuiTextFilter filter;\n        //ImGui::SetNextItemOpen(true, ImGuiCond_Once); // FIXME-TABLE: Enabling this results in initial clipped first pass on table which tend to affect column sizing\n        if (ImGui::TreeNode(\"Options\"))\n        {\n            // Make the UI compact because there are so many fields\n            PushStyleCompact();\n            ImGui::PushItemWidth(TEXT_BASE_WIDTH * 28.0f);\n\n            if (ImGui::TreeNodeEx(\"Features:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_Resizable\", &flags, ImGuiTableFlags_Resizable);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_Reorderable\", &flags, ImGuiTableFlags_Reorderable);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_Hideable\", &flags, ImGuiTableFlags_Hideable);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_Sortable\", &flags, ImGuiTableFlags_Sortable);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoSavedSettings\", &flags, ImGuiTableFlags_NoSavedSettings);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_ContextMenuInBody\", &flags, ImGuiTableFlags_ContextMenuInBody);\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Decorations:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_RowBg\", &flags, ImGuiTableFlags_RowBg);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersV\", &flags, ImGuiTableFlags_BordersV);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuterV\", &flags, ImGuiTableFlags_BordersOuterV);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInnerV\", &flags, ImGuiTableFlags_BordersInnerV);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersH\", &flags, ImGuiTableFlags_BordersH);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersOuterH\", &flags, ImGuiTableFlags_BordersOuterH);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_BordersInnerH\", &flags, ImGuiTableFlags_BordersInnerH);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoBordersInBody\", &flags, ImGuiTableFlags_NoBordersInBody); ImGui::SameLine(); HelpMarker(\"Disable vertical borders in columns Body (borders will always appear in Headers\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoBordersInBodyUntilResize\", &flags, ImGuiTableFlags_NoBordersInBodyUntilResize); ImGui::SameLine(); HelpMarker(\"Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers)\");\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Sizing:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                EditTableSizingFlags(&flags);\n                ImGui::SameLine(); HelpMarker(\"In the Advanced demo we override the policy of each column so those table-wide settings have less effect that typical.\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoHostExtendX\", &flags, ImGuiTableFlags_NoHostExtendX);\n                ImGui::SameLine(); HelpMarker(\"Make outer width auto-fit to columns, overriding outer_size.x value.\\n\\nOnly available when ScrollX/ScrollY are disabled and Stretch columns are not used.\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoHostExtendY\", &flags, ImGuiTableFlags_NoHostExtendY);\n                ImGui::SameLine(); HelpMarker(\"Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit).\\n\\nOnly available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoKeepColumnsVisible\", &flags, ImGuiTableFlags_NoKeepColumnsVisible);\n                ImGui::SameLine(); HelpMarker(\"Only available if ScrollX is disabled.\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_PreciseWidths\", &flags, ImGuiTableFlags_PreciseWidths);\n                ImGui::SameLine(); HelpMarker(\"Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoClip\", &flags, ImGuiTableFlags_NoClip);\n                ImGui::SameLine(); HelpMarker(\"Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with ScrollFreeze options.\");\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Padding:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_PadOuterX\", &flags, ImGuiTableFlags_PadOuterX);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoPadOuterX\", &flags, ImGuiTableFlags_NoPadOuterX);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_NoPadInnerX\", &flags, ImGuiTableFlags_NoPadInnerX);\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Scrolling:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollX\", &flags, ImGuiTableFlags_ScrollX);\n                ImGui::SameLine();\n                ImGui::SetNextItemWidth(ImGui::GetFrameHeight());\n                ImGui::DragInt(\"freeze_cols\", &freeze_cols, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_ScrollY\", &flags, ImGuiTableFlags_ScrollY);\n                ImGui::SameLine();\n                ImGui::SetNextItemWidth(ImGui::GetFrameHeight());\n                ImGui::DragInt(\"freeze_rows\", &freeze_rows, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Sorting:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_SortMulti\", &flags, ImGuiTableFlags_SortMulti);\n                ImGui::SameLine(); HelpMarker(\"When sorting is enabled: hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).\");\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_SortTristate\", &flags, ImGuiTableFlags_SortTristate);\n                ImGui::SameLine(); HelpMarker(\"When sorting is enabled: allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).\");\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Headers:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::Checkbox(\"show_headers\", &show_headers);\n                ImGui::CheckboxFlags(\"ImGuiTableFlags_HighlightHoveredColumn\", &flags, ImGuiTableFlags_HighlightHoveredColumn);\n                ImGui::CheckboxFlags(\"ImGuiTableColumnFlags_AngledHeader\", &columns_base_flags, ImGuiTableColumnFlags_AngledHeader);\n                ImGui::SameLine(); HelpMarker(\"Enable AngledHeader on all columns. Best enabled on selected narrow columns (see \\\"Angled headers\\\" section of the demo).\");\n                ImGui::TreePop();\n            }\n\n            if (ImGui::TreeNodeEx(\"Other:\", ImGuiTreeNodeFlags_DefaultOpen))\n            {\n                ImGui::Checkbox(\"show_wrapped_text\", &show_wrapped_text);\n\n                ImGui::DragFloat2(\"##OuterSize\", &outer_size_value.x);\n                ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n                ImGui::Checkbox(\"outer_size\", &outer_size_enabled);\n                ImGui::SameLine();\n                HelpMarker(\"If scrolling is disabled (ScrollX and ScrollY not set):\\n\"\n                    \"- The table is output directly in the parent window.\\n\"\n                    \"- OuterSize.x < 0.0f will right-align the table.\\n\"\n                    \"- OuterSize.x = 0.0f will narrow fit the table unless there are any Stretch columns.\\n\"\n                    \"- OuterSize.y then becomes the minimum size for the table, which will extend vertically if there are more rows (unless NoHostExtendY is set).\");\n\n                // From a user point of view we will tend to use 'inner_width' differently depending on whether our table is embedding scrolling.\n                // To facilitate toying with this demo we will actually pass 0.0f to the BeginTable() when ScrollX is disabled.\n                ImGui::DragFloat(\"inner_width (when ScrollX active)\", &inner_width_with_scroll, 1.0f, 0.0f, FLT_MAX);\n\n                ImGui::DragFloat(\"row_min_height\", &row_min_height, 1.0f, 0.0f, FLT_MAX);\n                ImGui::SameLine(); HelpMarker(\"Specify height of the Selectable item.\");\n\n                ImGui::DragInt(\"items_count\", &items_count, 0.1f, 0, 9999);\n                ImGui::Combo(\"items_type (first column)\", &contents_type, contents_type_names, IM_ARRAYSIZE(contents_type_names));\n                //filter.Draw(\"filter\");\n                ImGui::TreePop();\n            }\n\n            ImGui::PopItemWidth();\n            PopStyleCompact();\n            ImGui::Spacing();\n            ImGui::TreePop();\n        }\n\n        // Update item list if we changed the number of items\n        static ImVector<MyItem> items;\n        static ImVector<int> selection;\n        static bool items_need_sort = false;\n        if (items.Size != items_count)\n        {\n            items.resize(items_count, MyItem());\n            for (int n = 0; n < items_count; n++)\n            {\n                const int template_n = n % IM_ARRAYSIZE(template_items_names);\n                MyItem& item = items[n];\n                item.ID = n;\n                item.Name = template_items_names[template_n];\n                item.Quantity = (template_n == 3) ? 10 : (template_n == 4) ? 20 : 0; // Assign default quantities\n            }\n        }\n\n        const ImDrawList* parent_draw_list = ImGui::GetWindowDrawList();\n        const int parent_draw_list_draw_cmd_count = parent_draw_list->CmdBuffer.Size;\n        ImVec2 table_scroll_cur, table_scroll_max; // For debug display\n        const ImDrawList* table_draw_list = NULL;  // \"\n\n        // Submit table\n        const float inner_width_to_use = (flags & ImGuiTableFlags_ScrollX) ? inner_width_with_scroll : 0.0f;\n        if (ImGui::BeginTable(\"table_advanced\", 6, flags, outer_size_enabled ? outer_size_value : ImVec2(0, 0), inner_width_to_use))\n        {\n            // Declare columns\n            // We use the \"user_id\" parameter of TableSetupColumn() to specify a user id that will be stored in the sort specifications.\n            // This is so our sort function can identify a column given our own identifier. We could also identify them based on their index!\n            ImGui::TableSetupColumn(\"ID\",           columns_base_flags | ImGuiTableColumnFlags_DefaultSort | ImGuiTableColumnFlags_WidthFixed | ImGuiTableColumnFlags_NoHide, 0.0f, MyItemColumnID_ID);\n            ImGui::TableSetupColumn(\"Name\",         columns_base_flags | ImGuiTableColumnFlags_WidthFixed, 0.0f, MyItemColumnID_Name);\n            ImGui::TableSetupColumn(\"Action\",       columns_base_flags | ImGuiTableColumnFlags_NoSort | ImGuiTableColumnFlags_WidthFixed, 0.0f, MyItemColumnID_Action);\n            ImGui::TableSetupColumn(\"Quantity\",     columns_base_flags | ImGuiTableColumnFlags_PreferSortDescending, 0.0f, MyItemColumnID_Quantity);\n            ImGui::TableSetupColumn(\"Description\",  columns_base_flags | ((flags & ImGuiTableFlags_NoHostExtendX) ? 0 : ImGuiTableColumnFlags_WidthStretch), 0.0f, MyItemColumnID_Description);\n            ImGui::TableSetupColumn(\"Hidden\",       columns_base_flags |  ImGuiTableColumnFlags_DefaultHide | ImGuiTableColumnFlags_NoSort);\n            ImGui::TableSetupScrollFreeze(freeze_cols, freeze_rows);\n\n            // Sort our data if sort specs have been changed!\n            ImGuiTableSortSpecs* sort_specs = ImGui::TableGetSortSpecs();\n            if (sort_specs && sort_specs->SpecsDirty)\n                items_need_sort = true;\n            if (sort_specs && items_need_sort && items.Size > 1)\n            {\n                MyItem::SortWithSortSpecs(sort_specs, items.Data, items.Size);\n                sort_specs->SpecsDirty = false;\n            }\n            items_need_sort = false;\n\n            // Take note of whether we are currently sorting based on the Quantity field,\n            // we will use this to trigger sorting when we know the data of this column has been modified.\n            const bool sorts_specs_using_quantity = (ImGui::TableGetColumnFlags(3) & ImGuiTableColumnFlags_IsSorted) != 0;\n\n            // Show headers\n            if (show_headers && (columns_base_flags & ImGuiTableColumnFlags_AngledHeader) != 0)\n                ImGui::TableAngledHeadersRow();\n            if (show_headers)\n                ImGui::TableHeadersRow();\n\n            // Show data\n            // FIXME-TABLE FIXME-NAV: How we can get decent up/down even though we have the buttons here?\n#if 1\n            // Demonstrate using clipper for large vertical lists\n            ImGuiListClipper clipper;\n            clipper.Begin(items.Size);\n            while (clipper.Step())\n            {\n                for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++)\n#else\n            // Without clipper\n            {\n                for (int row_n = 0; row_n < items.Size; row_n++)\n#endif\n                {\n                    MyItem* item = &items[row_n];\n                    //if (!filter.PassFilter(item->Name))\n                    //    continue;\n\n                    const bool item_is_selected = selection.contains(item->ID);\n                    ImGui::PushID(item->ID);\n                    ImGui::TableNextRow(ImGuiTableRowFlags_None, row_min_height);\n\n                    // For the demo purpose we can select among different type of items submitted in the first column\n                    ImGui::TableSetColumnIndex(0);\n                    char label[32];\n                    sprintf(label, \"%04d\", item->ID);\n                    if (contents_type == CT_Text)\n                        ImGui::TextUnformatted(label);\n                    else if (contents_type == CT_Button)\n                        ImGui::Button(label);\n                    else if (contents_type == CT_SmallButton)\n                        ImGui::SmallButton(label);\n                    else if (contents_type == CT_FillButton)\n                        ImGui::Button(label, ImVec2(-FLT_MIN, 0.0f));\n                    else if (contents_type == CT_Selectable || contents_type == CT_SelectableSpanRow)\n                    {\n                        ImGuiSelectableFlags selectable_flags = (contents_type == CT_SelectableSpanRow) ? ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowOverlap : ImGuiSelectableFlags_None;\n                        if (ImGui::Selectable(label, item_is_selected, selectable_flags, ImVec2(0, row_min_height)))\n                        {\n                            if (ImGui::GetIO().KeyCtrl)\n                            {\n                                if (item_is_selected)\n                                    selection.find_erase_unsorted(item->ID);\n                                else\n                                    selection.push_back(item->ID);\n                            }\n                            else\n                            {\n                                selection.clear();\n                                selection.push_back(item->ID);\n                            }\n                        }\n                    }\n\n                    if (ImGui::TableSetColumnIndex(1))\n                        ImGui::TextUnformatted(item->Name);\n\n                    // Here we demonstrate marking our data set as needing to be sorted again if we modified a quantity,\n                    // and we are currently sorting on the column showing the Quantity.\n                    // To avoid triggering a sort while holding the button, we only trigger it when the button has been released.\n                    // You will probably need some extra logic if you want to automatically sort when a specific entry changes.\n                    if (ImGui::TableSetColumnIndex(2))\n                    {\n                        if (ImGui::SmallButton(\"Chop\")) { item->Quantity += 1; }\n                        if (sorts_specs_using_quantity && ImGui::IsItemDeactivated()) { items_need_sort = true; }\n                        ImGui::SameLine();\n                        if (ImGui::SmallButton(\"Eat\")) { item->Quantity -= 1; }\n                        if (sorts_specs_using_quantity && ImGui::IsItemDeactivated()) { items_need_sort = true; }\n                    }\n\n                    if (ImGui::TableSetColumnIndex(3))\n                        ImGui::Text(\"%d\", item->Quantity);\n\n                    ImGui::TableSetColumnIndex(4);\n                    if (show_wrapped_text)\n                        ImGui::TextWrapped(\"Lorem ipsum dolor sit amet\");\n                    else\n                        ImGui::Text(\"Lorem ipsum dolor sit amet\");\n\n                    if (ImGui::TableSetColumnIndex(5))\n                        ImGui::Text(\"1234\");\n\n                    ImGui::PopID();\n                }\n            }\n\n            // Store some info to display debug details below\n            table_scroll_cur = ImVec2(ImGui::GetScrollX(), ImGui::GetScrollY());\n            table_scroll_max = ImVec2(ImGui::GetScrollMaxX(), ImGui::GetScrollMaxY());\n            table_draw_list = ImGui::GetWindowDrawList();\n            ImGui::EndTable();\n        }\n        static bool show_debug_details = false;\n        ImGui::Checkbox(\"Debug details\", &show_debug_details);\n        if (show_debug_details && table_draw_list)\n        {\n            ImGui::SameLine(0.0f, 0.0f);\n            const int table_draw_list_draw_cmd_count = table_draw_list->CmdBuffer.Size;\n            if (table_draw_list == parent_draw_list)\n                ImGui::Text(\": DrawCmd: +%d (in same window)\",\n                    table_draw_list_draw_cmd_count - parent_draw_list_draw_cmd_count);\n            else\n                ImGui::Text(\": DrawCmd: +%d (in child window), Scroll: (%.f/%.f) (%.f/%.f)\",\n                    table_draw_list_draw_cmd_count - 1, table_scroll_cur.x, table_scroll_max.x, table_scroll_cur.y, table_scroll_max.y);\n        }\n        ImGui::TreePop();\n    }\n\n    ImGui::PopID();\n\n    ShowDemoWindowColumns();\n\n    if (disable_indent)\n        ImGui::PopStyleVar();\n}\n\n// Demonstrate old/legacy Columns API!\n// [2020: Columns are under-featured and not maintained. Prefer using the more flexible and powerful BeginTable() API!]\nstatic void ShowDemoWindowColumns()\n{\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\");\n    bool open = ImGui::TreeNode(\"Legacy Columns API\");\n    ImGui::SameLine();\n    HelpMarker(\"Columns() is an old API! Prefer using the more flexible and powerful BeginTable() API!\");\n    if (!open)\n        return;\n\n    // Basic columns\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)/Basic\");\n    if (ImGui::TreeNode(\"Basic\"))\n    {\n        ImGui::Text(\"Without border:\");\n        ImGui::Columns(3, \"mycolumns3\", false);  // 3-ways, no border\n        ImGui::Separator();\n        for (int n = 0; n < 14; n++)\n        {\n            char label[32];\n            sprintf(label, \"Item %d\", n);\n            if (ImGui::Selectable(label)) {}\n            //if (ImGui::Button(label, ImVec2(-FLT_MIN,0.0f))) {}\n            ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        ImGui::Separator();\n\n        ImGui::Text(\"With border:\");\n        ImGui::Columns(4, \"mycolumns\"); // 4-ways, with border\n        ImGui::Separator();\n        ImGui::Text(\"ID\"); ImGui::NextColumn();\n        ImGui::Text(\"Name\"); ImGui::NextColumn();\n        ImGui::Text(\"Path\"); ImGui::NextColumn();\n        ImGui::Text(\"Hovered\"); ImGui::NextColumn();\n        ImGui::Separator();\n        const char* names[3] = { \"One\", \"Two\", \"Three\" };\n        const char* paths[3] = { \"/path/one\", \"/path/two\", \"/path/three\" };\n        static int selected = -1;\n        for (int i = 0; i < 3; i++)\n        {\n            char label[32];\n            sprintf(label, \"%04d\", i);\n            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))\n                selected = i;\n            bool hovered = ImGui::IsItemHovered();\n            ImGui::NextColumn();\n            ImGui::Text(names[i]); ImGui::NextColumn();\n            ImGui::Text(paths[i]); ImGui::NextColumn();\n            ImGui::Text(\"%d\", hovered); ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)/Borders\");\n    if (ImGui::TreeNode(\"Borders\"))\n    {\n        // NB: Future columns API should allow automatic horizontal borders.\n        static bool h_borders = true;\n        static bool v_borders = true;\n        static int columns_count = 4;\n        const int lines_count = 3;\n        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n        ImGui::DragInt(\"##columns_count\", &columns_count, 0.1f, 2, 10, \"%d columns\");\n        if (columns_count < 2)\n            columns_count = 2;\n        ImGui::SameLine();\n        ImGui::Checkbox(\"horizontal\", &h_borders);\n        ImGui::SameLine();\n        ImGui::Checkbox(\"vertical\", &v_borders);\n        ImGui::Columns(columns_count, NULL, v_borders);\n        for (int i = 0; i < columns_count * lines_count; i++)\n        {\n            if (h_borders && ImGui::GetColumnIndex() == 0)\n                ImGui::Separator();\n            ImGui::PushID(i);\n            ImGui::Text(\"%c%c%c\", 'a' + i, 'a' + i, 'a' + i);\n            ImGui::Text(\"Width %.2f\", ImGui::GetColumnWidth());\n            ImGui::Text(\"Avail %.2f\", ImGui::GetContentRegionAvail().x);\n            ImGui::Text(\"Offset %.2f\", ImGui::GetColumnOffset());\n            ImGui::Text(\"Long text that is likely to clip\");\n            ImGui::Button(\"Button\", ImVec2(-FLT_MIN, 0.0f));\n            ImGui::PopID();\n            ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        if (h_borders)\n            ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    // Create multiple items in a same cell before switching to next column\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)/Mixed items\");\n    if (ImGui::TreeNode(\"Mixed items\"))\n    {\n        ImGui::Columns(3, \"mixed\");\n        ImGui::Separator();\n\n        ImGui::Text(\"Hello\");\n        ImGui::Button(\"Banana\");\n        ImGui::NextColumn();\n\n        ImGui::Text(\"ImGui\");\n        ImGui::Button(\"Apple\");\n        static float foo = 1.0f;\n        ImGui::InputFloat(\"red\", &foo, 0.05f, 0, \"%.3f\");\n        ImGui::Text(\"An extra line here.\");\n        ImGui::NextColumn();\n\n        ImGui::Text(\"Sailor\");\n        ImGui::Button(\"Corniflower\");\n        static float bar = 1.0f;\n        ImGui::InputFloat(\"blue\", &bar, 0.05f, 0, \"%.3f\");\n        ImGui::NextColumn();\n\n        if (ImGui::CollapsingHeader(\"Category A\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        if (ImGui::CollapsingHeader(\"Category B\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        if (ImGui::CollapsingHeader(\"Category C\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    // Word wrapping\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)/Word-wrapping\");\n    if (ImGui::TreeNode(\"Word-wrapping\"))\n    {\n        ImGui::Columns(2, \"word-wrapping\");\n        ImGui::Separator();\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\n        ImGui::TextWrapped(\"Hello Left\");\n        ImGui::NextColumn();\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\n        ImGui::TextWrapped(\"Hello Right\");\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)/Horizontal Scrolling\");\n    if (ImGui::TreeNode(\"Horizontal Scrolling\"))\n    {\n        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));\n        ImVec2 child_size = ImVec2(0, ImGui::GetFontSize() * 20.0f);\n        ImGui::BeginChild(\"##ScrollingRegion\", child_size, ImGuiChildFlags_None, ImGuiWindowFlags_HorizontalScrollbar);\n        ImGui::Columns(10);\n\n        // Also demonstrate using clipper for large vertical lists\n        int ITEMS_COUNT = 2000;\n        ImGuiListClipper clipper;\n        clipper.Begin(ITEMS_COUNT);\n        while (clipper.Step())\n        {\n            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n                for (int j = 0; j < 10; j++)\n                {\n                    ImGui::Text(\"Line %d Column %d...\", i, j);\n                    ImGui::NextColumn();\n                }\n        }\n        ImGui::Columns(1);\n        ImGui::EndChild();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)/Tree\");\n    if (ImGui::TreeNode(\"Tree\"))\n    {\n        ImGui::Columns(2, \"tree\", true);\n        for (int x = 0; x < 3; x++)\n        {\n            bool open1 = ImGui::TreeNode((void*)(intptr_t)x, \"Node%d\", x);\n            ImGui::NextColumn();\n            ImGui::Text(\"Node contents\");\n            ImGui::NextColumn();\n            if (open1)\n            {\n                for (int y = 0; y < 3; y++)\n                {\n                    bool open2 = ImGui::TreeNode((void*)(intptr_t)y, \"Node%d.%d\", x, y);\n                    ImGui::NextColumn();\n                    ImGui::Text(\"Node contents\");\n                    if (open2)\n                    {\n                        ImGui::Text(\"Even more contents\");\n                        if (ImGui::TreeNode(\"Tree in column\"))\n                        {\n                            ImGui::Text(\"The quick brown fox jumps over the lazy dog\");\n                            ImGui::TreePop();\n                        }\n                    }\n                    ImGui::NextColumn();\n                    if (open2)\n                        ImGui::TreePop();\n                }\n                ImGui::TreePop();\n            }\n        }\n        ImGui::Columns(1);\n        ImGui::TreePop();\n    }\n\n    ImGui::TreePop();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ShowDemoWindowInputs()\n//-----------------------------------------------------------------------------\n\nstatic void ShowDemoWindowInputs()\n{\n    IMGUI_DEMO_MARKER(\"Inputs & Focus\");\n    if (ImGui::CollapsingHeader(\"Inputs & Focus\"))\n    {\n        ImGuiIO& io = ImGui::GetIO();\n\n        // Display inputs submitted to ImGuiIO\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Inputs\");\n        ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n        bool inputs_opened = ImGui::TreeNode(\"Inputs\");\n        ImGui::SameLine();\n        HelpMarker(\n            \"This is a simplified view. See more detailed input state:\\n\"\n            \"- in 'Tools->Metrics/Debugger->Inputs'.\\n\"\n            \"- in 'Tools->Debug Log->IO'.\");\n        if (inputs_opened)\n        {\n            if (ImGui::IsMousePosValid())\n                ImGui::Text(\"Mouse pos: (%g, %g)\", io.MousePos.x, io.MousePos.y);\n            else\n                ImGui::Text(\"Mouse pos: <INVALID>\");\n            ImGui::Text(\"Mouse delta: (%g, %g)\", io.MouseDelta.x, io.MouseDelta.y);\n            ImGui::Text(\"Mouse down:\");\n            for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDown(i)) { ImGui::SameLine(); ImGui::Text(\"b%d (%.02f secs)\", i, io.MouseDownDuration[i]); }\n            ImGui::Text(\"Mouse wheel: %.1f\", io.MouseWheel);\n\n            // We iterate both legacy native range and named ImGuiKey ranges. This is a little unusual/odd but this allows\n            // displaying the data for old/new backends.\n            // User code should never have to go through such hoops!\n            // You can generally iterate between ImGuiKey_NamedKey_BEGIN and ImGuiKey_NamedKey_END.\n            struct funcs { static bool IsLegacyNativeDupe(ImGuiKey) { return false; } };\n            ImGuiKey start_key = ImGuiKey_NamedKey_BEGIN;\n            ImGui::Text(\"Keys down:\");         for (ImGuiKey key = start_key; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1)) { if (funcs::IsLegacyNativeDupe(key) || !ImGui::IsKeyDown(key)) continue; ImGui::SameLine(); ImGui::Text((key < ImGuiKey_NamedKey_BEGIN) ? \"\\\"%s\\\"\" : \"\\\"%s\\\" %d\", ImGui::GetKeyName(key), key); }\n            ImGui::Text(\"Keys mods: %s%s%s%s\", io.KeyCtrl ? \"CTRL \" : \"\", io.KeyShift ? \"SHIFT \" : \"\", io.KeyAlt ? \"ALT \" : \"\", io.KeySuper ? \"SUPER \" : \"\");\n            ImGui::Text(\"Chars queue:\");       for (int i = 0; i < io.InputQueueCharacters.Size; i++) { ImWchar c = io.InputQueueCharacters[i]; ImGui::SameLine();  ImGui::Text(\"\\'%c\\' (0x%04X)\", (c > ' ' && c <= 255) ? (char)c : '?', c); } // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.\n\n            ImGui::TreePop();\n        }\n\n        // Display ImGuiIO output flags\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Outputs\");\n        ImGui::SetNextItemOpen(true, ImGuiCond_Once);\n        bool outputs_opened = ImGui::TreeNode(\"Outputs\");\n        ImGui::SameLine();\n        HelpMarker(\n            \"The value of io.WantCaptureMouse and io.WantCaptureKeyboard are normally set by Dear ImGui \"\n            \"to instruct your application of how to route inputs. Typically, when a value is true, it means \"\n            \"Dear ImGui wants the corresponding inputs and we expect the underlying application to ignore them.\\n\\n\"\n            \"The most typical case is: when hovering a window, Dear ImGui set io.WantCaptureMouse to true, \"\n            \"and underlying application should ignore mouse inputs (in practice there are many and more subtle \"\n            \"rules leading to how those flags are set).\");\n        if (outputs_opened)\n        {\n            ImGui::Text(\"io.WantCaptureMouse: %d\", io.WantCaptureMouse);\n            ImGui::Text(\"io.WantCaptureMouseUnlessPopupClose: %d\", io.WantCaptureMouseUnlessPopupClose);\n            ImGui::Text(\"io.WantCaptureKeyboard: %d\", io.WantCaptureKeyboard);\n            ImGui::Text(\"io.WantTextInput: %d\", io.WantTextInput);\n            ImGui::Text(\"io.WantSetMousePos: %d\", io.WantSetMousePos);\n            ImGui::Text(\"io.NavActive: %d, io.NavVisible: %d\", io.NavActive, io.NavVisible);\n\n            IMGUI_DEMO_MARKER(\"Inputs & Focus/Outputs/WantCapture override\");\n            if (ImGui::TreeNode(\"WantCapture override\"))\n            {\n                HelpMarker(\n                    \"Hovering the colored canvas will override io.WantCaptureXXX fields.\\n\"\n                    \"Notice how normally (when set to none), the value of io.WantCaptureKeyboard would be false when hovering \"\n                    \"and true when clicking.\");\n                static int capture_override_mouse = -1;\n                static int capture_override_keyboard = -1;\n                const char* capture_override_desc[] = { \"None\", \"Set to false\", \"Set to true\" };\n                ImGui::SetNextItemWidth(ImGui::GetFontSize() * 15);\n                ImGui::SliderInt(\"SetNextFrameWantCaptureMouse() on hover\", &capture_override_mouse, -1, +1, capture_override_desc[capture_override_mouse + 1], ImGuiSliderFlags_AlwaysClamp);\n                ImGui::SetNextItemWidth(ImGui::GetFontSize() * 15);\n                ImGui::SliderInt(\"SetNextFrameWantCaptureKeyboard() on hover\", &capture_override_keyboard, -1, +1, capture_override_desc[capture_override_keyboard + 1], ImGuiSliderFlags_AlwaysClamp);\n\n                ImGui::ColorButton(\"##panel\", ImVec4(0.7f, 0.1f, 0.7f, 1.0f), ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoDragDrop, ImVec2(128.0f, 96.0f)); // Dummy item\n                if (ImGui::IsItemHovered() && capture_override_mouse != -1)\n                    ImGui::SetNextFrameWantCaptureMouse(capture_override_mouse == 1);\n                if (ImGui::IsItemHovered() && capture_override_keyboard != -1)\n                    ImGui::SetNextFrameWantCaptureKeyboard(capture_override_keyboard == 1);\n\n                ImGui::TreePop();\n            }\n            ImGui::TreePop();\n        }\n\n        // Demonstrate using Shortcut() and Routing Policies.\n        // The general flow is:\n        // - Code interested in a chord (e.g. \"Ctrl+A\") declares their intent.\n        // - Multiple locations may be interested in same chord! Routing helps find a winner.\n        // - Every frame, we resolve all claims and assign one owner if the modifiers are matching.\n        // - The lower-level function is 'bool SetShortcutRouting()', returns true when caller got the route.\n        // - Most of the times, SetShortcutRouting() is not called directly. User mostly calls Shortcut() with routing flags.\n        // - If you call Shortcut() WITHOUT any routing option, it uses ImGuiInputFlags_RouteFocused.\n        // TL;DR: Most uses will simply be:\n        // - Shortcut(ImGuiMod_Ctrl | ImGuiKey_A); // Use ImGuiInputFlags_RouteFocused policy.\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Shortcuts\");\n        if (ImGui::TreeNode(\"Shortcuts\"))\n        {\n            static ImGuiInputFlags route_options = ImGuiInputFlags_Repeat;\n            static ImGuiInputFlags route_type = ImGuiInputFlags_RouteFocused;\n            ImGui::CheckboxFlags(\"ImGuiInputFlags_Repeat\", &route_options, ImGuiInputFlags_Repeat);\n            ImGui::RadioButton(\"ImGuiInputFlags_RouteActive\", &route_type, ImGuiInputFlags_RouteActive);\n            ImGui::RadioButton(\"ImGuiInputFlags_RouteFocused (default)\", &route_type, ImGuiInputFlags_RouteFocused);\n            ImGui::RadioButton(\"ImGuiInputFlags_RouteGlobal\", &route_type, ImGuiInputFlags_RouteGlobal);\n            ImGui::Indent();\n            ImGui::BeginDisabled(route_type != ImGuiInputFlags_RouteGlobal);\n            ImGui::CheckboxFlags(\"ImGuiInputFlags_RouteOverFocused\", &route_options, ImGuiInputFlags_RouteOverFocused);\n            ImGui::CheckboxFlags(\"ImGuiInputFlags_RouteOverActive\", &route_options, ImGuiInputFlags_RouteOverActive);\n            ImGui::CheckboxFlags(\"ImGuiInputFlags_RouteUnlessBgFocused\", &route_options, ImGuiInputFlags_RouteUnlessBgFocused);\n            ImGui::EndDisabled();\n            ImGui::Unindent();\n            ImGui::RadioButton(\"ImGuiInputFlags_RouteAlways\", &route_type, ImGuiInputFlags_RouteAlways);\n            ImGuiInputFlags flags = route_type | route_options; // Merged flags\n            if (route_type != ImGuiInputFlags_RouteGlobal)\n                flags &= ~(ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused);\n\n            ImGui::SeparatorText(\"Using SetNextItemShortcut()\");\n            ImGui::Text(\"Ctrl+S\");\n            ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_S, flags | ImGuiInputFlags_Tooltip);\n            ImGui::Button(\"Save\");\n            ImGui::Text(\"Alt+F\");\n            ImGui::SetNextItemShortcut(ImGuiMod_Alt | ImGuiKey_F, flags | ImGuiInputFlags_Tooltip);\n            static float f = 0.5f;\n            ImGui::SliderFloat(\"Factor\", &f, 0.0f, 1.0f);\n\n            ImGui::SeparatorText(\"Using Shortcut()\");\n            const float line_height = ImGui::GetTextLineHeightWithSpacing();\n            const ImGuiKeyChord key_chord = ImGuiMod_Ctrl | ImGuiKey_A;\n\n            ImGui::Text(\"Ctrl+A\");\n            ImGui::Text(\"IsWindowFocused: %d, Shortcut: %s\", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? \"PRESSED\" : \"...\");\n\n            ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(1.0f, 0.0f, 1.0f, 0.1f));\n\n            ImGui::BeginChild(\"WindowA\", ImVec2(-FLT_MIN, line_height * 14), true);\n            ImGui::Text(\"Press CTRL+A and see who receives it!\");\n            ImGui::Separator();\n\n            // 1: Window polling for CTRL+A\n            ImGui::Text(\"(in WindowA)\");\n            ImGui::Text(\"IsWindowFocused: %d, Shortcut: %s\", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? \"PRESSED\" : \"...\");\n\n            // 2: InputText also polling for CTRL+A: it always uses _RouteFocused internally (gets priority when active)\n            // (Commmented because the owner-aware version of Shortcut() is still in imgui_internal.h)\n            //char str[16] = \"Press CTRL+A\";\n            //ImGui::Spacing();\n            //ImGui::InputText(\"InputTextB\", str, IM_ARRAYSIZE(str), ImGuiInputTextFlags_ReadOnly);\n            //ImGuiID item_id = ImGui::GetItemID();\n            //ImGui::SameLine(); HelpMarker(\"Internal widgets always use _RouteFocused\");\n            //ImGui::Text(\"IsWindowFocused: %d, Shortcut: %s\", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags, item_id) ? \"PRESSED\" : \"...\");\n\n            // 3: Dummy child is not claiming the route: focusing them shouldn't steal route away from WindowA\n            ImGui::BeginChild(\"ChildD\", ImVec2(-FLT_MIN, line_height * 4), true);\n            ImGui::Text(\"(in ChildD: not using same Shortcut)\");\n            ImGui::Text(\"IsWindowFocused: %d\", ImGui::IsWindowFocused());\n            ImGui::EndChild();\n\n            // 4: Child window polling for CTRL+A. It is deeper than WindowA and gets priority when focused.\n            ImGui::BeginChild(\"ChildE\", ImVec2(-FLT_MIN, line_height * 4), true);\n            ImGui::Text(\"(in ChildE: using same Shortcut)\");\n            ImGui::Text(\"IsWindowFocused: %d, Shortcut: %s\", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? \"PRESSED\" : \"...\");\n            ImGui::EndChild();\n\n            // 5: In a popup\n            if (ImGui::Button(\"Open Popup\"))\n                ImGui::OpenPopup(\"PopupF\");\n            if (ImGui::BeginPopup(\"PopupF\"))\n            {\n                ImGui::Text(\"(in PopupF)\");\n                ImGui::Text(\"IsWindowFocused: %d, Shortcut: %s\", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? \"PRESSED\" : \"...\");\n                // (Commmented because the owner-aware version of Shortcut() is still in imgui_internal.h)\n                //ImGui::InputText(\"InputTextG\", str, IM_ARRAYSIZE(str), ImGuiInputTextFlags_ReadOnly);\n                //ImGui::Text(\"IsWindowFocused: %d, Shortcut: %s\", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags, ImGui::GetItemID()) ? \"PRESSED\" : \"...\");\n                ImGui::EndPopup();\n            }\n            ImGui::EndChild();\n            ImGui::PopStyleColor();\n\n            ImGui::TreePop();\n        }\n\n        // Display mouse cursors\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Mouse Cursors\");\n        if (ImGui::TreeNode(\"Mouse Cursors\"))\n        {\n            const char* mouse_cursors_names[] = { \"Arrow\", \"TextInput\", \"ResizeAll\", \"ResizeNS\", \"ResizeEW\", \"ResizeNESW\", \"ResizeNWSE\", \"Hand\", \"NotAllowed\" };\n            IM_ASSERT(IM_ARRAYSIZE(mouse_cursors_names) == ImGuiMouseCursor_COUNT);\n\n            ImGuiMouseCursor current = ImGui::GetMouseCursor();\n            const char* cursor_name = (current >= ImGuiMouseCursor_Arrow) && (current < ImGuiMouseCursor_COUNT) ? mouse_cursors_names[current] : \"N/A\";\n            ImGui::Text(\"Current mouse cursor = %d: %s\", current, cursor_name);\n            ImGui::BeginDisabled(true);\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasMouseCursors\", &io.BackendFlags, ImGuiBackendFlags_HasMouseCursors);\n            ImGui::EndDisabled();\n\n            ImGui::Text(\"Hover to see mouse cursors:\");\n            ImGui::SameLine(); HelpMarker(\n                \"Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. \"\n                \"If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, \"\n                \"otherwise your backend needs to handle it.\");\n            for (int i = 0; i < ImGuiMouseCursor_COUNT; i++)\n            {\n                char label[32];\n                sprintf(label, \"Mouse cursor %d: %s\", i, mouse_cursors_names[i]);\n                ImGui::Bullet(); ImGui::Selectable(label, false);\n                if (ImGui::IsItemHovered())\n                    ImGui::SetMouseCursor(i);\n            }\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Tabbing\");\n        if (ImGui::TreeNode(\"Tabbing\"))\n        {\n            ImGui::Text(\"Use TAB/SHIFT+TAB to cycle through keyboard editable fields.\");\n            static char buf[32] = \"hello\";\n            ImGui::InputText(\"1\", buf, IM_ARRAYSIZE(buf));\n            ImGui::InputText(\"2\", buf, IM_ARRAYSIZE(buf));\n            ImGui::InputText(\"3\", buf, IM_ARRAYSIZE(buf));\n            ImGui::PushItemFlag(ImGuiItemFlags_NoTabStop, true);\n            ImGui::InputText(\"4 (tab skip)\", buf, IM_ARRAYSIZE(buf));\n            ImGui::SameLine(); HelpMarker(\"Item won't be cycled through when using TAB or Shift+Tab.\");\n            ImGui::PopItemFlag();\n            ImGui::InputText(\"5\", buf, IM_ARRAYSIZE(buf));\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Focus from code\");\n        if (ImGui::TreeNode(\"Focus from code\"))\n        {\n            bool focus_1 = ImGui::Button(\"Focus on 1\"); ImGui::SameLine();\n            bool focus_2 = ImGui::Button(\"Focus on 2\"); ImGui::SameLine();\n            bool focus_3 = ImGui::Button(\"Focus on 3\");\n            int has_focus = 0;\n            static char buf[128] = \"click on a button to set focus\";\n\n            if (focus_1) ImGui::SetKeyboardFocusHere();\n            ImGui::InputText(\"1\", buf, IM_ARRAYSIZE(buf));\n            if (ImGui::IsItemActive()) has_focus = 1;\n\n            if (focus_2) ImGui::SetKeyboardFocusHere();\n            ImGui::InputText(\"2\", buf, IM_ARRAYSIZE(buf));\n            if (ImGui::IsItemActive()) has_focus = 2;\n\n            ImGui::PushItemFlag(ImGuiItemFlags_NoTabStop, true);\n            if (focus_3) ImGui::SetKeyboardFocusHere();\n            ImGui::InputText(\"3 (tab skip)\", buf, IM_ARRAYSIZE(buf));\n            if (ImGui::IsItemActive()) has_focus = 3;\n            ImGui::SameLine(); HelpMarker(\"Item won't be cycled through when using TAB or Shift+Tab.\");\n            ImGui::PopItemFlag();\n\n            if (has_focus)\n                ImGui::Text(\"Item with focus: %d\", has_focus);\n            else\n                ImGui::Text(\"Item with focus: <none>\");\n\n            // Use >= 0 parameter to SetKeyboardFocusHere() to focus an upcoming item\n            static float f3[3] = { 0.0f, 0.0f, 0.0f };\n            int focus_ahead = -1;\n            if (ImGui::Button(\"Focus on X\")) { focus_ahead = 0; } ImGui::SameLine();\n            if (ImGui::Button(\"Focus on Y\")) { focus_ahead = 1; } ImGui::SameLine();\n            if (ImGui::Button(\"Focus on Z\")) { focus_ahead = 2; }\n            if (focus_ahead != -1) ImGui::SetKeyboardFocusHere(focus_ahead);\n            ImGui::SliderFloat3(\"Float3\", &f3[0], 0.0f, 1.0f);\n\n            ImGui::TextWrapped(\"NB: Cursor & selection are preserved when refocusing last used item in code.\");\n            ImGui::TreePop();\n        }\n\n        IMGUI_DEMO_MARKER(\"Inputs & Focus/Dragging\");\n        if (ImGui::TreeNode(\"Dragging\"))\n        {\n            ImGui::TextWrapped(\"You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.\");\n            for (int button = 0; button < 3; button++)\n            {\n                ImGui::Text(\"IsMouseDragging(%d):\", button);\n                ImGui::Text(\"  w/ default threshold: %d,\", ImGui::IsMouseDragging(button));\n                ImGui::Text(\"  w/ zero threshold: %d,\", ImGui::IsMouseDragging(button, 0.0f));\n                ImGui::Text(\"  w/ large threshold: %d,\", ImGui::IsMouseDragging(button, 20.0f));\n            }\n\n            ImGui::Button(\"Drag Me\");\n            if (ImGui::IsItemActive())\n                ImGui::GetForegroundDrawList()->AddLine(io.MouseClickedPos[0], io.MousePos, ImGui::GetColorU32(ImGuiCol_Button), 4.0f); // Draw a line between the button and the mouse cursor\n\n            // Drag operations gets \"unlocked\" when the mouse has moved past a certain threshold\n            // (the default threshold is stored in io.MouseDragThreshold). You can request a lower or higher\n            // threshold using the second parameter of IsMouseDragging() and GetMouseDragDelta().\n            ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);\n            ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);\n            ImVec2 mouse_delta = io.MouseDelta;\n            ImGui::Text(\"GetMouseDragDelta(0):\");\n            ImGui::Text(\"  w/ default threshold: (%.1f, %.1f)\", value_with_lock_threshold.x, value_with_lock_threshold.y);\n            ImGui::Text(\"  w/ zero threshold: (%.1f, %.1f)\", value_raw.x, value_raw.y);\n            ImGui::Text(\"io.MouseDelta: (%.1f, %.1f)\", mouse_delta.x, mouse_delta.y);\n            ImGui::TreePop();\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] About Window / ShowAboutWindow()\n// Access from Dear ImGui Demo -> Tools -> About\n//-----------------------------------------------------------------------------\n\nvoid ImGui::ShowAboutWindow(bool* p_open)\n{\n    if (!ImGui::Begin(\"About Dear ImGui\", p_open, ImGuiWindowFlags_AlwaysAutoResize))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Tools/About Dear ImGui\");\n    ImGui::Text(\"Dear ImGui %s (%d)\", IMGUI_VERSION, IMGUI_VERSION_NUM);\n\n    ImGui::TextLinkOpenURL(\"Homepage\", \"https://github.com/ocornut/imgui\");\n    ImGui::SameLine();\n    ImGui::TextLinkOpenURL(\"FAQ\", \"https://github.com/ocornut/imgui/blob/master/docs/FAQ.md\");\n    ImGui::SameLine();\n    ImGui::TextLinkOpenURL(\"Wiki\", \"https://github.com/ocornut/imgui/wiki\");\n    ImGui::SameLine();\n    ImGui::TextLinkOpenURL(\"Releases\", \"https://github.com/ocornut/imgui/releases\");\n    ImGui::SameLine();\n    ImGui::TextLinkOpenURL(\"Funding\", \"https://github.com/ocornut/imgui/wiki/Funding\");\n\n    ImGui::Separator();\n    ImGui::Text(\"(c) 2014-2025 Omar Cornut\");\n    ImGui::Text(\"Developed by Omar Cornut and all Dear ImGui contributors.\");\n    ImGui::Text(\"Dear ImGui is licensed under the MIT License, see LICENSE for more information.\");\n    ImGui::Text(\"If your company uses this, please consider funding the project.\");\n\n    static bool show_config_info = false;\n    ImGui::Checkbox(\"Config/Build Information\", &show_config_info);\n    if (show_config_info)\n    {\n        ImGuiIO& io = ImGui::GetIO();\n        ImGuiStyle& style = ImGui::GetStyle();\n\n        bool copy_to_clipboard = ImGui::Button(\"Copy to clipboard\");\n        ImVec2 child_size = ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18);\n        ImGui::BeginChild(ImGui::GetID(\"cfg_infos\"), child_size, ImGuiChildFlags_FrameStyle);\n        if (copy_to_clipboard)\n        {\n            ImGui::LogToClipboard();\n            ImGui::LogText(\"```\\n\"); // Back quotes will make text appears without formatting when pasting on GitHub\n        }\n\n        ImGui::Text(\"Dear ImGui %s (%d)\", IMGUI_VERSION, IMGUI_VERSION_NUM);\n        ImGui::Separator();\n        ImGui::Text(\"sizeof(size_t): %d, sizeof(ImDrawIdx): %d, sizeof(ImDrawVert): %d\", (int)sizeof(size_t), (int)sizeof(ImDrawIdx), (int)sizeof(ImDrawVert));\n        ImGui::Text(\"define: __cplusplus=%d\", (int)__cplusplus);\n#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_OBSOLETE_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_WIN32_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_WIN32_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_FILE_FUNCTIONS\n        ImGui::Text(\"define: IMGUI_DISABLE_FILE_FUNCTIONS\");\n#endif\n#ifdef IMGUI_DISABLE_DEFAULT_ALLOCATORS\n        ImGui::Text(\"define: IMGUI_DISABLE_DEFAULT_ALLOCATORS\");\n#endif\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\n        ImGui::Text(\"define: IMGUI_USE_BGRA_PACKED_COLOR\");\n#endif\n#ifdef _WIN32\n        ImGui::Text(\"define: _WIN32\");\n#endif\n#ifdef _WIN64\n        ImGui::Text(\"define: _WIN64\");\n#endif\n#ifdef __linux__\n        ImGui::Text(\"define: __linux__\");\n#endif\n#ifdef __APPLE__\n        ImGui::Text(\"define: __APPLE__\");\n#endif\n#ifdef _MSC_VER\n        ImGui::Text(\"define: _MSC_VER=%d\", _MSC_VER);\n#endif\n#ifdef _MSVC_LANG\n        ImGui::Text(\"define: _MSVC_LANG=%d\", (int)_MSVC_LANG);\n#endif\n#ifdef __MINGW32__\n        ImGui::Text(\"define: __MINGW32__\");\n#endif\n#ifdef __MINGW64__\n        ImGui::Text(\"define: __MINGW64__\");\n#endif\n#ifdef __GNUC__\n        ImGui::Text(\"define: __GNUC__=%d\", (int)__GNUC__);\n#endif\n#ifdef __clang_version__\n        ImGui::Text(\"define: __clang_version__=%s\", __clang_version__);\n#endif\n#ifdef __EMSCRIPTEN__\n        ImGui::Text(\"define: __EMSCRIPTEN__\");\n        ImGui::Text(\"Emscripten: %d.%d.%d\", __EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__);\n#endif\n        ImGui::Separator();\n        ImGui::Text(\"io.BackendPlatformName: %s\", io.BackendPlatformName ? io.BackendPlatformName : \"NULL\");\n        ImGui::Text(\"io.BackendRendererName: %s\", io.BackendRendererName ? io.BackendRendererName : \"NULL\");\n        ImGui::Text(\"io.ConfigFlags: 0x%08X\", io.ConfigFlags);\n        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)        ImGui::Text(\" NavEnableKeyboard\");\n        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad)         ImGui::Text(\" NavEnableGamepad\");\n        if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)                  ImGui::Text(\" NoMouse\");\n        if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)      ImGui::Text(\" NoMouseCursorChange\");\n        if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)               ImGui::Text(\" NoKeyboard\");\n        if (io.MouseDrawCursor)                                         ImGui::Text(\"io.MouseDrawCursor\");\n        if (io.ConfigMacOSXBehaviors)                                   ImGui::Text(\"io.ConfigMacOSXBehaviors\");\n        if (io.ConfigNavMoveSetMousePos)                                ImGui::Text(\"io.ConfigNavMoveSetMousePos\");\n        if (io.ConfigNavCaptureKeyboard)                                ImGui::Text(\"io.ConfigNavCaptureKeyboard\");\n        if (io.ConfigInputTextCursorBlink)                              ImGui::Text(\"io.ConfigInputTextCursorBlink\");\n        if (io.ConfigWindowsResizeFromEdges)                            ImGui::Text(\"io.ConfigWindowsResizeFromEdges\");\n        if (io.ConfigWindowsMoveFromTitleBarOnly)                       ImGui::Text(\"io.ConfigWindowsMoveFromTitleBarOnly\");\n        if (io.ConfigMemoryCompactTimer >= 0.0f)                        ImGui::Text(\"io.ConfigMemoryCompactTimer = %.1f\", io.ConfigMemoryCompactTimer);\n        ImGui::Text(\"io.BackendFlags: 0x%08X\", io.BackendFlags);\n        if (io.BackendFlags & ImGuiBackendFlags_HasGamepad)             ImGui::Text(\" HasGamepad\");\n        if (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)        ImGui::Text(\" HasMouseCursors\");\n        if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos)         ImGui::Text(\" HasSetMousePos\");\n        if (io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)   ImGui::Text(\" RendererHasVtxOffset\");\n        ImGui::Separator();\n        ImGui::Text(\"io.Fonts: %d fonts, Flags: 0x%08X, TexSize: %d,%d\", io.Fonts->Fonts.Size, io.Fonts->Flags, io.Fonts->TexWidth, io.Fonts->TexHeight);\n        ImGui::Text(\"io.DisplaySize: %.2f,%.2f\", io.DisplaySize.x, io.DisplaySize.y);\n        ImGui::Text(\"io.DisplayFramebufferScale: %.2f,%.2f\", io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);\n        ImGui::Separator();\n        ImGui::Text(\"style.WindowPadding: %.2f,%.2f\", style.WindowPadding.x, style.WindowPadding.y);\n        ImGui::Text(\"style.WindowBorderSize: %.2f\", style.WindowBorderSize);\n        ImGui::Text(\"style.FramePadding: %.2f,%.2f\", style.FramePadding.x, style.FramePadding.y);\n        ImGui::Text(\"style.FrameRounding: %.2f\", style.FrameRounding);\n        ImGui::Text(\"style.FrameBorderSize: %.2f\", style.FrameBorderSize);\n        ImGui::Text(\"style.ItemSpacing: %.2f,%.2f\", style.ItemSpacing.x, style.ItemSpacing.y);\n        ImGui::Text(\"style.ItemInnerSpacing: %.2f,%.2f\", style.ItemInnerSpacing.x, style.ItemInnerSpacing.y);\n\n        if (copy_to_clipboard)\n        {\n            ImGui::LogText(\"\\n```\\n\");\n            ImGui::LogFinish();\n        }\n        ImGui::EndChild();\n    }\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Style Editor / ShowStyleEditor()\n//-----------------------------------------------------------------------------\n// - ShowFontSelector()\n// - ShowStyleSelector()\n// - ShowStyleEditor()\n//-----------------------------------------------------------------------------\n\n// Forward declare ShowFontAtlas() which isn't worth putting in public API yet\nnamespace ImGui { IMGUI_API void ShowFontAtlas(ImFontAtlas* atlas); }\n\n// Demo helper function to select among loaded fonts.\n// Here we use the regular BeginCombo()/EndCombo() api which is the more flexible one.\nvoid ImGui::ShowFontSelector(const char* label)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    ImFont* font_current = ImGui::GetFont();\n    if (ImGui::BeginCombo(label, font_current->GetDebugName()))\n    {\n        for (ImFont* font : io.Fonts->Fonts)\n        {\n            ImGui::PushID((void*)font);\n            if (ImGui::Selectable(font->GetDebugName(), font == font_current))\n                io.FontDefault = font;\n            if (font == font_current)\n                ImGui::SetItemDefaultFocus();\n            ImGui::PopID();\n        }\n        ImGui::EndCombo();\n    }\n    ImGui::SameLine();\n    HelpMarker(\n        \"- Load additional fonts with io.Fonts->AddFontFromFileTTF().\\n\"\n        \"- The font atlas is built when calling io.Fonts->GetTexDataAsXXXX() or io.Fonts->Build().\\n\"\n        \"- Read FAQ and docs/FONTS.md for more details.\\n\"\n        \"- If you need to add/remove fonts at runtime (e.g. for DPI change), do it before calling NewFrame().\");\n}\n\n// Demo helper function to select among default colors. See ShowStyleEditor() for more advanced options.\n// Here we use the simplified Combo() api that packs items into a single literal string.\n// Useful for quick combo boxes where the choices are known locally.\nbool ImGui::ShowStyleSelector(const char* label)\n{\n    static int style_idx = -1;\n    if (ImGui::Combo(label, &style_idx, \"Dark\\0Light\\0Classic\\0\"))\n    {\n        switch (style_idx)\n        {\n        case 0: ImGui::StyleColorsDark(); break;\n        case 1: ImGui::StyleColorsLight(); break;\n        case 2: ImGui::StyleColorsClassic(); break;\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid ImGui::ShowStyleEditor(ImGuiStyle* ref)\n{\n    IMGUI_DEMO_MARKER(\"Tools/Style Editor\");\n    // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to\n    // (without a reference style pointer, we will use one compared locally as a reference)\n    ImGuiStyle& style = ImGui::GetStyle();\n    static ImGuiStyle ref_saved_style;\n\n    // Default to using internal storage as reference\n    static bool init = true;\n    if (init && ref == NULL)\n        ref_saved_style = style;\n    init = false;\n    if (ref == NULL)\n        ref = &ref_saved_style;\n\n    ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);\n\n    if (ImGui::ShowStyleSelector(\"Colors##Selector\"))\n        ref_saved_style = style;\n    ImGui::ShowFontSelector(\"Fonts##Selector\");\n\n    // Simplified Settings (expose floating-pointer border sizes as boolean representing 0.0f or 1.0f)\n    if (ImGui::SliderFloat(\"FrameRounding\", &style.FrameRounding, 0.0f, 12.0f, \"%.0f\"))\n        style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding\n    { bool border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox(\"WindowBorder\", &border)) { style.WindowBorderSize = border ? 1.0f : 0.0f; } }\n    ImGui::SameLine();\n    { bool border = (style.FrameBorderSize > 0.0f);  if (ImGui::Checkbox(\"FrameBorder\",  &border)) { style.FrameBorderSize  = border ? 1.0f : 0.0f; } }\n    ImGui::SameLine();\n    { bool border = (style.PopupBorderSize > 0.0f);  if (ImGui::Checkbox(\"PopupBorder\",  &border)) { style.PopupBorderSize  = border ? 1.0f : 0.0f; } }\n\n    // Save/Revert button\n    if (ImGui::Button(\"Save Ref\"))\n        *ref = ref_saved_style = style;\n    ImGui::SameLine();\n    if (ImGui::Button(\"Revert Ref\"))\n        style = *ref;\n    ImGui::SameLine();\n    HelpMarker(\n        \"Save/Revert in local non-persistent storage. Default Colors definition are not affected. \"\n        \"Use \\\"Export\\\" below to save them somewhere.\");\n\n    ImGui::Separator();\n\n    if (ImGui::BeginTabBar(\"##tabs\", ImGuiTabBarFlags_None))\n    {\n        if (ImGui::BeginTabItem(\"Sizes\"))\n        {\n            ImGui::SeparatorText(\"Main\");\n            ImGui::SliderFloat2(\"WindowPadding\", (float*)&style.WindowPadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"FramePadding\", (float*)&style.FramePadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"ItemSpacing\", (float*)&style.ItemSpacing, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"ItemInnerSpacing\", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"TouchExtraPadding\", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, \"%.0f\");\n            ImGui::SliderFloat(\"IndentSpacing\", &style.IndentSpacing, 0.0f, 30.0f, \"%.0f\");\n            ImGui::SliderFloat(\"ScrollbarSize\", &style.ScrollbarSize, 1.0f, 20.0f, \"%.0f\");\n            ImGui::SliderFloat(\"GrabMinSize\", &style.GrabMinSize, 1.0f, 20.0f, \"%.0f\");\n\n            ImGui::SeparatorText(\"Borders\");\n            ImGui::SliderFloat(\"WindowBorderSize\", &style.WindowBorderSize, 0.0f, 1.0f, \"%.0f\");\n            ImGui::SliderFloat(\"ChildBorderSize\", &style.ChildBorderSize, 0.0f, 1.0f, \"%.0f\");\n            ImGui::SliderFloat(\"PopupBorderSize\", &style.PopupBorderSize, 0.0f, 1.0f, \"%.0f\");\n            ImGui::SliderFloat(\"FrameBorderSize\", &style.FrameBorderSize, 0.0f, 1.0f, \"%.0f\");\n            ImGui::SliderFloat(\"TabBorderSize\", &style.TabBorderSize, 0.0f, 1.0f, \"%.0f\");\n            ImGui::SliderFloat(\"TabBarBorderSize\", &style.TabBarBorderSize, 0.0f, 2.0f, \"%.0f\");\n            ImGui::SliderFloat(\"TabBarOverlineSize\", &style.TabBarOverlineSize, 0.0f, 2.0f, \"%.0f\");\n            ImGui::SameLine(); HelpMarker(\"Overline is only drawn over the selected tab when ImGuiTabBarFlags_DrawSelectedOverline is set.\");\n\n            ImGui::SeparatorText(\"Rounding\");\n            ImGui::SliderFloat(\"WindowRounding\", &style.WindowRounding, 0.0f, 12.0f, \"%.0f\");\n            ImGui::SliderFloat(\"ChildRounding\", &style.ChildRounding, 0.0f, 12.0f, \"%.0f\");\n            ImGui::SliderFloat(\"FrameRounding\", &style.FrameRounding, 0.0f, 12.0f, \"%.0f\");\n            ImGui::SliderFloat(\"PopupRounding\", &style.PopupRounding, 0.0f, 12.0f, \"%.0f\");\n            ImGui::SliderFloat(\"ScrollbarRounding\", &style.ScrollbarRounding, 0.0f, 12.0f, \"%.0f\");\n            ImGui::SliderFloat(\"GrabRounding\", &style.GrabRounding, 0.0f, 12.0f, \"%.0f\");\n            ImGui::SliderFloat(\"TabRounding\", &style.TabRounding, 0.0f, 12.0f, \"%.0f\");\n\n            ImGui::SeparatorText(\"Tables\");\n            ImGui::SliderFloat2(\"CellPadding\", (float*)&style.CellPadding, 0.0f, 20.0f, \"%.0f\");\n            ImGui::SliderAngle(\"TableAngledHeadersAngle\", &style.TableAngledHeadersAngle, -50.0f, +50.0f);\n            ImGui::SliderFloat2(\"TableAngledHeadersTextAlign\", (float*)&style.TableAngledHeadersTextAlign, 0.0f, 1.0f, \"%.2f\");\n\n            ImGui::SeparatorText(\"Widgets\");\n            ImGui::SliderFloat2(\"WindowTitleAlign\", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, \"%.2f\");\n            int window_menu_button_position = style.WindowMenuButtonPosition + 1;\n            if (ImGui::Combo(\"WindowMenuButtonPosition\", (int*)&window_menu_button_position, \"None\\0Left\\0Right\\0\"))\n                style.WindowMenuButtonPosition = (ImGuiDir)(window_menu_button_position - 1);\n            ImGui::Combo(\"ColorButtonPosition\", (int*)&style.ColorButtonPosition, \"Left\\0Right\\0\");\n            ImGui::SliderFloat2(\"ButtonTextAlign\", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, \"%.2f\");\n            ImGui::SameLine(); HelpMarker(\"Alignment applies when a button is larger than its text content.\");\n            ImGui::SliderFloat2(\"SelectableTextAlign\", (float*)&style.SelectableTextAlign, 0.0f, 1.0f, \"%.2f\");\n            ImGui::SameLine(); HelpMarker(\"Alignment applies when a selectable is larger than its text content.\");\n            ImGui::SliderFloat(\"SeparatorTextBorderSize\", &style.SeparatorTextBorderSize, 0.0f, 10.0f, \"%.0f\");\n            ImGui::SliderFloat2(\"SeparatorTextAlign\", (float*)&style.SeparatorTextAlign, 0.0f, 1.0f, \"%.2f\");\n            ImGui::SliderFloat2(\"SeparatorTextPadding\", (float*)&style.SeparatorTextPadding, 0.0f, 40.0f, \"%.0f\");\n            ImGui::SliderFloat(\"LogSliderDeadzone\", &style.LogSliderDeadzone, 0.0f, 12.0f, \"%.0f\");\n\n            ImGui::SeparatorText(\"Tooltips\");\n            for (int n = 0; n < 2; n++)\n                if (ImGui::TreeNodeEx(n == 0 ? \"HoverFlagsForTooltipMouse\" : \"HoverFlagsForTooltipNav\"))\n                {\n                    ImGuiHoveredFlags* p = (n == 0) ? &style.HoverFlagsForTooltipMouse : &style.HoverFlagsForTooltipNav;\n                    ImGui::CheckboxFlags(\"ImGuiHoveredFlags_DelayNone\", p, ImGuiHoveredFlags_DelayNone);\n                    ImGui::CheckboxFlags(\"ImGuiHoveredFlags_DelayShort\", p, ImGuiHoveredFlags_DelayShort);\n                    ImGui::CheckboxFlags(\"ImGuiHoveredFlags_DelayNormal\", p, ImGuiHoveredFlags_DelayNormal);\n                    ImGui::CheckboxFlags(\"ImGuiHoveredFlags_Stationary\", p, ImGuiHoveredFlags_Stationary);\n                    ImGui::CheckboxFlags(\"ImGuiHoveredFlags_NoSharedDelay\", p, ImGuiHoveredFlags_NoSharedDelay);\n                    ImGui::TreePop();\n                }\n\n            ImGui::SeparatorText(\"Misc\");\n            ImGui::SliderFloat2(\"DisplayWindowPadding\", (float*)&style.DisplayWindowPadding, 0.0f, 30.0f, \"%.0f\"); ImGui::SameLine(); HelpMarker(\"Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.\");\n            ImGui::SliderFloat2(\"DisplaySafeAreaPadding\", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, \"%.0f\"); ImGui::SameLine(); HelpMarker(\"Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).\");\n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Colors\"))\n        {\n            static int output_dest = 0;\n            static bool output_only_modified = true;\n            if (ImGui::Button(\"Export\"))\n            {\n                if (output_dest == 0)\n                    ImGui::LogToClipboard();\n                else\n                    ImGui::LogToTTY();\n                ImGui::LogText(\"ImVec4* colors = ImGui::GetStyle().Colors;\" IM_NEWLINE);\n                for (int i = 0; i < ImGuiCol_COUNT; i++)\n                {\n                    const ImVec4& col = style.Colors[i];\n                    const char* name = ImGui::GetStyleColorName(i);\n                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)\n                        ImGui::LogText(\"colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);\" IM_NEWLINE,\n                            name, 23 - (int)strlen(name), \"\", col.x, col.y, col.z, col.w);\n                }\n                ImGui::LogFinish();\n            }\n            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo(\"##output_type\", &output_dest, \"To Clipboard\\0To TTY\\0\");\n            ImGui::SameLine(); ImGui::Checkbox(\"Only Modified Colors\", &output_only_modified);\n\n            static ImGuiTextFilter filter;\n            filter.Draw(\"Filter colors\", ImGui::GetFontSize() * 16);\n\n            static ImGuiColorEditFlags alpha_flags = 0;\n            if (ImGui::RadioButton(\"Opaque\", alpha_flags == ImGuiColorEditFlags_None))             { alpha_flags = ImGuiColorEditFlags_None; } ImGui::SameLine();\n            if (ImGui::RadioButton(\"Alpha\",  alpha_flags == ImGuiColorEditFlags_AlphaPreview))     { alpha_flags = ImGuiColorEditFlags_AlphaPreview; } ImGui::SameLine();\n            if (ImGui::RadioButton(\"Both\",   alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf)) { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } ImGui::SameLine();\n            HelpMarker(\n                \"In the color list:\\n\"\n                \"Left-click on color square to open color picker,\\n\"\n                \"Right-click to open edit options menu.\");\n\n            ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, ImGui::GetTextLineHeightWithSpacing() * 10), ImVec2(FLT_MAX, FLT_MAX));\n            ImGui::BeginChild(\"##colors\", ImVec2(0, 0), ImGuiChildFlags_Borders | ImGuiChildFlags_NavFlattened, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);\n            ImGui::PushItemWidth(ImGui::GetFontSize() * -12);\n            for (int i = 0; i < ImGuiCol_COUNT; i++)\n            {\n                const char* name = ImGui::GetStyleColorName(i);\n                if (!filter.PassFilter(name))\n                    continue;\n                ImGui::PushID(i);\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n                if (ImGui::Button(\"?\"))\n                    ImGui::DebugFlashStyleColor((ImGuiCol)i);\n                ImGui::SetItemTooltip(\"Flash given color to identify places where it is used.\");\n                ImGui::SameLine();\n#endif\n                ImGui::ColorEdit4(\"##color\", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);\n                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)\n                {\n                    // Tips: in a real user application, you may want to merge and use an icon font into the main font,\n                    // so instead of \"Save\"/\"Revert\" you'd use icons!\n                    // Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!\n                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button(\"Save\")) { ref->Colors[i] = style.Colors[i]; }\n                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button(\"Revert\")) { style.Colors[i] = ref->Colors[i]; }\n                }\n                ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);\n                ImGui::TextUnformatted(name);\n                ImGui::PopID();\n            }\n            ImGui::PopItemWidth();\n            ImGui::EndChild();\n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Fonts\"))\n        {\n            ImGuiIO& io = ImGui::GetIO();\n            ImFontAtlas* atlas = io.Fonts;\n            HelpMarker(\"Read FAQ and docs/FONTS.md for details on font loading.\");\n            ImGui::ShowFontAtlas(atlas);\n\n            // Post-baking font scaling. Note that this is NOT the nice way of scaling fonts, read below.\n            // (we enforce hard clamping manually as by default DragFloat/SliderFloat allows CTRL+Click text to get out of bounds).\n            const float MIN_SCALE = 0.3f;\n            const float MAX_SCALE = 2.0f;\n            HelpMarker(\n                \"Those are old settings provided for convenience.\\n\"\n                \"However, the _correct_ way of scaling your UI is currently to reload your font at the designed size, \"\n                \"rebuild the font atlas, and call style.ScaleAllSizes() on a reference ImGuiStyle structure.\\n\"\n                \"Using those settings here will give you poor quality results.\");\n            static float window_scale = 1.0f;\n            ImGui::PushItemWidth(ImGui::GetFontSize() * 8);\n            if (ImGui::DragFloat(\"window scale\", &window_scale, 0.005f, MIN_SCALE, MAX_SCALE, \"%.2f\", ImGuiSliderFlags_AlwaysClamp)) // Scale only this window\n                ImGui::SetWindowFontScale(window_scale);\n            ImGui::DragFloat(\"global scale\", &io.FontGlobalScale, 0.005f, MIN_SCALE, MAX_SCALE, \"%.2f\", ImGuiSliderFlags_AlwaysClamp); // Scale everything\n            ImGui::PopItemWidth();\n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Rendering\"))\n        {\n            ImGui::Checkbox(\"Anti-aliased lines\", &style.AntiAliasedLines);\n            ImGui::SameLine();\n            HelpMarker(\"When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.\");\n\n            ImGui::Checkbox(\"Anti-aliased lines use texture\", &style.AntiAliasedLinesUseTex);\n            ImGui::SameLine();\n            HelpMarker(\"Faster lines using texture data. Require backend to render with bilinear filtering (not point/nearest filtering).\");\n\n            ImGui::Checkbox(\"Anti-aliased fill\", &style.AntiAliasedFill);\n            ImGui::PushItemWidth(ImGui::GetFontSize() * 8);\n            ImGui::DragFloat(\"Curve Tessellation Tolerance\", &style.CurveTessellationTol, 0.02f, 0.10f, 10.0f, \"%.2f\");\n            if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;\n\n            // When editing the \"Circle Segment Max Error\" value, draw a preview of its effect on auto-tessellated circles.\n            ImGui::DragFloat(\"Circle Tessellation Max Error\", &style.CircleTessellationMaxError , 0.005f, 0.10f, 5.0f, \"%.2f\", ImGuiSliderFlags_AlwaysClamp);\n            const bool show_samples = ImGui::IsItemActive();\n            if (show_samples)\n                ImGui::SetNextWindowPos(ImGui::GetCursorScreenPos());\n            if (show_samples && ImGui::BeginTooltip())\n            {\n                ImGui::TextUnformatted(\"(R = radius, N = approx number of segments)\");\n                ImGui::Spacing();\n                ImDrawList* draw_list = ImGui::GetWindowDrawList();\n                const float min_widget_width = ImGui::CalcTextSize(\"R: MMM\\nN: MMM\").x;\n                for (int n = 0; n < 8; n++)\n                {\n                    const float RAD_MIN = 5.0f;\n                    const float RAD_MAX = 70.0f;\n                    const float rad = RAD_MIN + (RAD_MAX - RAD_MIN) * (float)n / (8.0f - 1.0f);\n\n                    ImGui::BeginGroup();\n\n                    // N is not always exact here due to how PathArcTo() function work internally\n                    ImGui::Text(\"R: %.f\\nN: %d\", rad, draw_list->_CalcCircleAutoSegmentCount(rad));\n\n                    const float canvas_width = IM_MAX(min_widget_width, rad * 2.0f);\n                    const float offset_x     = floorf(canvas_width * 0.5f);\n                    const float offset_y     = floorf(RAD_MAX);\n\n                    const ImVec2 p1 = ImGui::GetCursorScreenPos();\n                    draw_list->AddCircle(ImVec2(p1.x + offset_x, p1.y + offset_y), rad, ImGui::GetColorU32(ImGuiCol_Text));\n                    ImGui::Dummy(ImVec2(canvas_width, RAD_MAX * 2));\n\n                    /*\n                    const ImVec2 p2 = ImGui::GetCursorScreenPos();\n                    draw_list->AddCircleFilled(ImVec2(p2.x + offset_x, p2.y + offset_y), rad, ImGui::GetColorU32(ImGuiCol_Text));\n                    ImGui::Dummy(ImVec2(canvas_width, RAD_MAX * 2));\n                    */\n\n                    ImGui::EndGroup();\n                    ImGui::SameLine();\n                }\n                ImGui::EndTooltip();\n            }\n            ImGui::SameLine();\n            HelpMarker(\"When drawing circle primitives with \\\"num_segments == 0\\\" tesselation will be calculated automatically.\");\n\n            ImGui::DragFloat(\"Global Alpha\", &style.Alpha, 0.005f, 0.20f, 1.0f, \"%.2f\"); // Not exposing zero here so user doesn't \"lose\" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.\n            ImGui::DragFloat(\"Disabled Alpha\", &style.DisabledAlpha, 0.005f, 0.0f, 1.0f, \"%.2f\"); ImGui::SameLine(); HelpMarker(\"Additional alpha multiplier for disabled items (multiply over current value of Alpha).\");\n            ImGui::PopItemWidth();\n\n            ImGui::EndTabItem();\n        }\n\n        ImGui::EndTabBar();\n    }\n\n    ImGui::PopItemWidth();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] User Guide / ShowUserGuide()\n//-----------------------------------------------------------------------------\n\nvoid ImGui::ShowUserGuide()\n{\n    ImGuiIO& io = ImGui::GetIO();\n    ImGui::BulletText(\"Double-click on title bar to collapse window.\");\n    ImGui::BulletText(\n        \"Click and drag on lower corner to resize window\\n\"\n        \"(double-click to auto fit window to its contents).\");\n    ImGui::BulletText(\"CTRL+Click on a slider or drag box to input value as text.\");\n    ImGui::BulletText(\"TAB/SHIFT+TAB to cycle through keyboard editable fields.\");\n    ImGui::BulletText(\"CTRL+Tab to select a window.\");\n    if (io.FontAllowUserScaling)\n        ImGui::BulletText(\"CTRL+Mouse Wheel to zoom window contents.\");\n    ImGui::BulletText(\"While inputing text:\\n\");\n    ImGui::Indent();\n    ImGui::BulletText(\"CTRL+Left/Right to word jump.\");\n    ImGui::BulletText(\"CTRL+A or double-click to select all.\");\n    ImGui::BulletText(\"CTRL+X/C/V to use clipboard cut/copy/paste.\");\n    ImGui::BulletText(\"CTRL+Z,CTRL+Y to undo/redo.\");\n    ImGui::BulletText(\"ESCAPE to revert.\");\n    ImGui::Unindent();\n    ImGui::BulletText(\"With keyboard navigation enabled:\");\n    ImGui::Indent();\n    ImGui::BulletText(\"Arrow keys to navigate.\");\n    ImGui::BulletText(\"Space to activate a widget.\");\n    ImGui::BulletText(\"Return to input text into a widget.\");\n    ImGui::BulletText(\"Escape to deactivate a widget, close popup, exit child window.\");\n    ImGui::BulletText(\"Alt to jump to the menu layer of a window.\");\n    ImGui::Unindent();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n//-----------------------------------------------------------------------------\n// - ShowExampleAppMainMenuBar()\n// - ShowExampleMenuFile()\n//-----------------------------------------------------------------------------\n\n// Demonstrate creating a \"main\" fullscreen menu bar and populating it.\n// Note the difference between BeginMainMenuBar() and BeginMenuBar():\n// - BeginMenuBar() = menu-bar inside current window (which needs the ImGuiWindowFlags_MenuBar flag!)\n// - BeginMainMenuBar() = helper to create menu-bar-sized window at the top of the main viewport + call BeginMenuBar() into it.\nstatic void ShowExampleAppMainMenuBar()\n{\n    if (ImGui::BeginMainMenuBar())\n    {\n        if (ImGui::BeginMenu(\"File\"))\n        {\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        if (ImGui::BeginMenu(\"Edit\"))\n        {\n            if (ImGui::MenuItem(\"Undo\", \"CTRL+Z\")) {}\n            if (ImGui::MenuItem(\"Redo\", \"CTRL+Y\", false, false)) {}  // Disabled item\n            ImGui::Separator();\n            if (ImGui::MenuItem(\"Cut\", \"CTRL+X\")) {}\n            if (ImGui::MenuItem(\"Copy\", \"CTRL+C\")) {}\n            if (ImGui::MenuItem(\"Paste\", \"CTRL+V\")) {}\n            ImGui::EndMenu();\n        }\n        ImGui::EndMainMenuBar();\n    }\n}\n\n// Note that shortcuts are currently provided for display only\n// (future version will add explicit flags to BeginMenu() to request processing shortcuts)\nstatic void ShowExampleMenuFile()\n{\n    IMGUI_DEMO_MARKER(\"Examples/Menu\");\n    ImGui::MenuItem(\"(demo menu)\", NULL, false, false);\n    if (ImGui::MenuItem(\"New\")) {}\n    if (ImGui::MenuItem(\"Open\", \"Ctrl+O\")) {}\n    if (ImGui::BeginMenu(\"Open Recent\"))\n    {\n        ImGui::MenuItem(\"fish_hat.c\");\n        ImGui::MenuItem(\"fish_hat.inl\");\n        ImGui::MenuItem(\"fish_hat.h\");\n        if (ImGui::BeginMenu(\"More..\"))\n        {\n            ImGui::MenuItem(\"Hello\");\n            ImGui::MenuItem(\"Sailor\");\n            if (ImGui::BeginMenu(\"Recurse..\"))\n            {\n                ShowExampleMenuFile();\n                ImGui::EndMenu();\n            }\n            ImGui::EndMenu();\n        }\n        ImGui::EndMenu();\n    }\n    if (ImGui::MenuItem(\"Save\", \"Ctrl+S\")) {}\n    if (ImGui::MenuItem(\"Save As..\")) {}\n\n    ImGui::Separator();\n    IMGUI_DEMO_MARKER(\"Examples/Menu/Options\");\n    if (ImGui::BeginMenu(\"Options\"))\n    {\n        static bool enabled = true;\n        ImGui::MenuItem(\"Enabled\", \"\", &enabled);\n        ImGui::BeginChild(\"child\", ImVec2(0, 60), ImGuiChildFlags_Borders);\n        for (int i = 0; i < 10; i++)\n            ImGui::Text(\"Scrolling Text %d\", i);\n        ImGui::EndChild();\n        static float f = 0.5f;\n        static int n = 0;\n        ImGui::SliderFloat(\"Value\", &f, 0.0f, 1.0f);\n        ImGui::InputFloat(\"Input\", &f, 0.1f);\n        ImGui::Combo(\"Combo\", &n, \"Yes\\0No\\0Maybe\\0\\0\");\n        ImGui::EndMenu();\n    }\n\n    IMGUI_DEMO_MARKER(\"Examples/Menu/Colors\");\n    if (ImGui::BeginMenu(\"Colors\"))\n    {\n        float sz = ImGui::GetTextLineHeight();\n        for (int i = 0; i < ImGuiCol_COUNT; i++)\n        {\n            const char* name = ImGui::GetStyleColorName((ImGuiCol)i);\n            ImVec2 p = ImGui::GetCursorScreenPos();\n            ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x + sz, p.y + sz), ImGui::GetColorU32((ImGuiCol)i));\n            ImGui::Dummy(ImVec2(sz, sz));\n            ImGui::SameLine();\n            ImGui::MenuItem(name);\n        }\n        ImGui::EndMenu();\n    }\n\n    // Here we demonstrate appending again to the \"Options\" menu (which we already created above)\n    // Of course in this demo it is a little bit silly that this function calls BeginMenu(\"Options\") twice.\n    // In a real code-base using it would make senses to use this feature from very different code locations.\n    if (ImGui::BeginMenu(\"Options\")) // <-- Append!\n    {\n        IMGUI_DEMO_MARKER(\"Examples/Menu/Append to an existing menu\");\n        static bool b = true;\n        ImGui::Checkbox(\"SomeOption\", &b);\n        ImGui::EndMenu();\n    }\n\n    if (ImGui::BeginMenu(\"Disabled\", false)) // Disabled\n    {\n        IM_ASSERT(0);\n    }\n    if (ImGui::MenuItem(\"Checked\", NULL, true)) {}\n    ImGui::Separator();\n    if (ImGui::MenuItem(\"Quit\", \"Alt+F4\")) {}\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n//-----------------------------------------------------------------------------\n\n// Demonstrate creating a simple console window, with scrolling, filtering, completion and history.\n// For the console example, we are using a more C++ like approach of declaring a class to hold both data and functions.\nstruct ExampleAppConsole\n{\n    char                  InputBuf[256];\n    ImVector<char*>       Items;\n    ImVector<const char*> Commands;\n    ImVector<char*>       History;\n    int                   HistoryPos;    // -1: new line, 0..History.Size-1 browsing history.\n    ImGuiTextFilter       Filter;\n    bool                  AutoScroll;\n    bool                  ScrollToBottom;\n\n    ExampleAppConsole()\n    {\n        IMGUI_DEMO_MARKER(\"Examples/Console\");\n        ClearLog();\n        memset(InputBuf, 0, sizeof(InputBuf));\n        HistoryPos = -1;\n\n        // \"CLASSIFY\" is here to provide the test case where \"C\"+[tab] completes to \"CL\" and display multiple matches.\n        Commands.push_back(\"HELP\");\n        Commands.push_back(\"HISTORY\");\n        Commands.push_back(\"CLEAR\");\n        Commands.push_back(\"CLASSIFY\");\n        AutoScroll = true;\n        ScrollToBottom = false;\n        AddLog(\"Welcome to Dear ImGui!\");\n    }\n    ~ExampleAppConsole()\n    {\n        ClearLog();\n        for (int i = 0; i < History.Size; i++)\n            ImGui::MemFree(History[i]);\n    }\n\n    // Portable helpers\n    static int   Stricmp(const char* s1, const char* s2)         { int d; while ((d = toupper(*s2) - toupper(*s1)) == 0 && *s1) { s1++; s2++; } return d; }\n    static int   Strnicmp(const char* s1, const char* s2, int n) { int d = 0; while (n > 0 && (d = toupper(*s2) - toupper(*s1)) == 0 && *s1) { s1++; s2++; n--; } return d; }\n    static char* Strdup(const char* s)                           { IM_ASSERT(s); size_t len = strlen(s) + 1; void* buf = ImGui::MemAlloc(len); IM_ASSERT(buf); return (char*)memcpy(buf, (const void*)s, len); }\n    static void  Strtrim(char* s)                                { char* str_end = s + strlen(s); while (str_end > s && str_end[-1] == ' ') str_end--; *str_end = 0; }\n\n    void    ClearLog()\n    {\n        for (int i = 0; i < Items.Size; i++)\n            ImGui::MemFree(Items[i]);\n        Items.clear();\n    }\n\n    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)\n    {\n        // FIXME-OPT\n        char buf[1024];\n        va_list args;\n        va_start(args, fmt);\n        vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);\n        buf[IM_ARRAYSIZE(buf)-1] = 0;\n        va_end(args);\n        Items.push_back(Strdup(buf));\n    }\n\n    void    Draw(const char* title, bool* p_open)\n    {\n        ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);\n        if (!ImGui::Begin(title, p_open))\n        {\n            ImGui::End();\n            return;\n        }\n\n        // As a specific feature guaranteed by the library, after calling Begin() the last Item represent the title bar.\n        // So e.g. IsItemHovered() will return true when hovering the title bar.\n        // Here we create a context menu only available from the title bar.\n        if (ImGui::BeginPopupContextItem())\n        {\n            if (ImGui::MenuItem(\"Close Console\"))\n                *p_open = false;\n            ImGui::EndPopup();\n        }\n\n        ImGui::TextWrapped(\n            \"This example implements a console with basic coloring, completion (TAB key) and history (Up/Down keys). A more elaborate \"\n            \"implementation may want to store entries along with extra data such as timestamp, emitter, etc.\");\n        ImGui::TextWrapped(\"Enter 'HELP' for help.\");\n\n        // TODO: display items starting from the bottom\n\n        if (ImGui::SmallButton(\"Add Debug Text\"))  { AddLog(\"%d some text\", Items.Size); AddLog(\"some more text\"); AddLog(\"display very important message here!\"); }\n        ImGui::SameLine();\n        if (ImGui::SmallButton(\"Add Debug Error\")) { AddLog(\"[error] something went wrong\"); }\n        ImGui::SameLine();\n        if (ImGui::SmallButton(\"Clear\"))           { ClearLog(); }\n        ImGui::SameLine();\n        bool copy_to_clipboard = ImGui::SmallButton(\"Copy\");\n        //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog(\"Spam %f\", t); }\n\n        ImGui::Separator();\n\n        // Options menu\n        if (ImGui::BeginPopup(\"Options\"))\n        {\n            ImGui::Checkbox(\"Auto-scroll\", &AutoScroll);\n            ImGui::EndPopup();\n        }\n\n        // Options, Filter\n        ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_O, ImGuiInputFlags_Tooltip);\n        if (ImGui::Button(\"Options\"))\n            ImGui::OpenPopup(\"Options\");\n        ImGui::SameLine();\n        Filter.Draw(\"Filter (\\\"incl,-excl\\\") (\\\"error\\\")\", 180);\n        ImGui::Separator();\n\n        // Reserve enough left-over height for 1 separator + 1 input text\n        const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing();\n        if (ImGui::BeginChild(\"ScrollingRegion\", ImVec2(0, -footer_height_to_reserve), ImGuiChildFlags_NavFlattened, ImGuiWindowFlags_HorizontalScrollbar))\n        {\n            if (ImGui::BeginPopupContextWindow())\n            {\n                if (ImGui::Selectable(\"Clear\")) ClearLog();\n                ImGui::EndPopup();\n            }\n\n            // Display every line as a separate entry so we can change their color or add custom widgets.\n            // If you only want raw text you can use ImGui::TextUnformatted(log.begin(), log.end());\n            // NB- if you have thousands of entries this approach may be too inefficient and may require user-side clipping\n            // to only process visible items. The clipper will automatically measure the height of your first item and then\n            // \"seek\" to display only items in the visible area.\n            // To use the clipper we can replace your standard loop:\n            //      for (int i = 0; i < Items.Size; i++)\n            //   With:\n            //      ImGuiListClipper clipper;\n            //      clipper.Begin(Items.Size);\n            //      while (clipper.Step())\n            //         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n            // - That your items are evenly spaced (same height)\n            // - That you have cheap random access to your elements (you can access them given their index,\n            //   without processing all the ones before)\n            // You cannot this code as-is if a filter is active because it breaks the 'cheap random-access' property.\n            // We would need random-access on the post-filtered list.\n            // A typical application wanting coarse clipping and filtering may want to pre-compute an array of indices\n            // or offsets of items that passed the filtering test, recomputing this array when user changes the filter,\n            // and appending newly elements as they are inserted. This is left as a task to the user until we can manage\n            // to improve this example code!\n            // If your items are of variable height:\n            // - Split them into same height items would be simpler and facilitate random-seeking into your list.\n            // - Consider using manual call to IsRectVisible() and skipping extraneous decoration from your items.\n            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 1)); // Tighten spacing\n            if (copy_to_clipboard)\n                ImGui::LogToClipboard();\n            for (const char* item : Items)\n            {\n                if (!Filter.PassFilter(item))\n                    continue;\n\n                // Normally you would store more information in your item than just a string.\n                // (e.g. make Items[] an array of structure, store color/type etc.)\n                ImVec4 color;\n                bool has_color = false;\n                if (strstr(item, \"[error]\")) { color = ImVec4(1.0f, 0.4f, 0.4f, 1.0f); has_color = true; }\n                else if (strncmp(item, \"# \", 2) == 0) { color = ImVec4(1.0f, 0.8f, 0.6f, 1.0f); has_color = true; }\n                if (has_color)\n                    ImGui::PushStyleColor(ImGuiCol_Text, color);\n                ImGui::TextUnformatted(item);\n                if (has_color)\n                    ImGui::PopStyleColor();\n            }\n            if (copy_to_clipboard)\n                ImGui::LogFinish();\n\n            // Keep up at the bottom of the scroll region if we were already at the bottom at the beginning of the frame.\n            // Using a scrollbar or mouse-wheel will take away from the bottom edge.\n            if (ScrollToBottom || (AutoScroll && ImGui::GetScrollY() >= ImGui::GetScrollMaxY()))\n                ImGui::SetScrollHereY(1.0f);\n            ScrollToBottom = false;\n\n            ImGui::PopStyleVar();\n        }\n        ImGui::EndChild();\n        ImGui::Separator();\n\n        // Command-line\n        bool reclaim_focus = false;\n        ImGuiInputTextFlags input_text_flags = ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_EscapeClearsAll | ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory;\n        if (ImGui::InputText(\"Input\", InputBuf, IM_ARRAYSIZE(InputBuf), input_text_flags, &TextEditCallbackStub, (void*)this))\n        {\n            char* s = InputBuf;\n            Strtrim(s);\n            if (s[0])\n                ExecCommand(s);\n            strcpy(s, \"\");\n            reclaim_focus = true;\n        }\n\n        // Auto-focus on window apparition\n        ImGui::SetItemDefaultFocus();\n        if (reclaim_focus)\n            ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget\n\n        ImGui::End();\n    }\n\n    void    ExecCommand(const char* command_line)\n    {\n        AddLog(\"# %s\\n\", command_line);\n\n        // Insert into history. First find match and delete it so it can be pushed to the back.\n        // This isn't trying to be smart or optimal.\n        HistoryPos = -1;\n        for (int i = History.Size - 1; i >= 0; i--)\n            if (Stricmp(History[i], command_line) == 0)\n            {\n                ImGui::MemFree(History[i]);\n                History.erase(History.begin() + i);\n                break;\n            }\n        History.push_back(Strdup(command_line));\n\n        // Process command\n        if (Stricmp(command_line, \"CLEAR\") == 0)\n        {\n            ClearLog();\n        }\n        else if (Stricmp(command_line, \"HELP\") == 0)\n        {\n            AddLog(\"Commands:\");\n            for (int i = 0; i < Commands.Size; i++)\n                AddLog(\"- %s\", Commands[i]);\n        }\n        else if (Stricmp(command_line, \"HISTORY\") == 0)\n        {\n            int first = History.Size - 10;\n            for (int i = first > 0 ? first : 0; i < History.Size; i++)\n                AddLog(\"%3d: %s\\n\", i, History[i]);\n        }\n        else\n        {\n            AddLog(\"Unknown command: '%s'\\n\", command_line);\n        }\n\n        // On command input, we scroll to bottom even if AutoScroll==false\n        ScrollToBottom = true;\n    }\n\n    // In C++11 you'd be better off using lambdas for this sort of forwarding callbacks\n    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data)\n    {\n        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;\n        return console->TextEditCallback(data);\n    }\n\n    int     TextEditCallback(ImGuiInputTextCallbackData* data)\n    {\n        //AddLog(\"cursor: %d, selection: %d-%d\", data->CursorPos, data->SelectionStart, data->SelectionEnd);\n        switch (data->EventFlag)\n        {\n        case ImGuiInputTextFlags_CallbackCompletion:\n            {\n                // Example of TEXT COMPLETION\n\n                // Locate beginning of current word\n                const char* word_end = data->Buf + data->CursorPos;\n                const char* word_start = word_end;\n                while (word_start > data->Buf)\n                {\n                    const char c = word_start[-1];\n                    if (c == ' ' || c == '\\t' || c == ',' || c == ';')\n                        break;\n                    word_start--;\n                }\n\n                // Build a list of candidates\n                ImVector<const char*> candidates;\n                for (int i = 0; i < Commands.Size; i++)\n                    if (Strnicmp(Commands[i], word_start, (int)(word_end - word_start)) == 0)\n                        candidates.push_back(Commands[i]);\n\n                if (candidates.Size == 0)\n                {\n                    // No match\n                    AddLog(\"No match for \\\"%.*s\\\"!\\n\", (int)(word_end - word_start), word_start);\n                }\n                else if (candidates.Size == 1)\n                {\n                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing.\n                    data->DeleteChars((int)(word_start - data->Buf), (int)(word_end - word_start));\n                    data->InsertChars(data->CursorPos, candidates[0]);\n                    data->InsertChars(data->CursorPos, \" \");\n                }\n                else\n                {\n                    // Multiple matches. Complete as much as we can..\n                    // So inputing \"C\"+Tab will complete to \"CL\" then display \"CLEAR\" and \"CLASSIFY\" as matches.\n                    int match_len = (int)(word_end - word_start);\n                    for (;;)\n                    {\n                        int c = 0;\n                        bool all_candidates_matches = true;\n                        for (int i = 0; i < candidates.Size && all_candidates_matches; i++)\n                            if (i == 0)\n                                c = toupper(candidates[i][match_len]);\n                            else if (c == 0 || c != toupper(candidates[i][match_len]))\n                                all_candidates_matches = false;\n                        if (!all_candidates_matches)\n                            break;\n                        match_len++;\n                    }\n\n                    if (match_len > 0)\n                    {\n                        data->DeleteChars((int)(word_start - data->Buf), (int)(word_end - word_start));\n                        data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);\n                    }\n\n                    // List matches\n                    AddLog(\"Possible matches:\\n\");\n                    for (int i = 0; i < candidates.Size; i++)\n                        AddLog(\"- %s\\n\", candidates[i]);\n                }\n\n                break;\n            }\n        case ImGuiInputTextFlags_CallbackHistory:\n            {\n                // Example of HISTORY\n                const int prev_history_pos = HistoryPos;\n                if (data->EventKey == ImGuiKey_UpArrow)\n                {\n                    if (HistoryPos == -1)\n                        HistoryPos = History.Size - 1;\n                    else if (HistoryPos > 0)\n                        HistoryPos--;\n                }\n                else if (data->EventKey == ImGuiKey_DownArrow)\n                {\n                    if (HistoryPos != -1)\n                        if (++HistoryPos >= History.Size)\n                            HistoryPos = -1;\n                }\n\n                // A better implementation would preserve the data on the current input line along with cursor position.\n                if (prev_history_pos != HistoryPos)\n                {\n                    const char* history_str = (HistoryPos >= 0) ? History[HistoryPos] : \"\";\n                    data->DeleteChars(0, data->BufTextLen);\n                    data->InsertChars(0, history_str);\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nstatic void ShowExampleAppConsole(bool* p_open)\n{\n    static ExampleAppConsole console;\n    console.Draw(\"Example: Console\", p_open);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n//-----------------------------------------------------------------------------\n\n// Usage:\n//  static ExampleAppLog my_log;\n//  my_log.AddLog(\"Hello %d world\\n\", 123);\n//  my_log.Draw(\"title\");\nstruct ExampleAppLog\n{\n    ImGuiTextBuffer     Buf;\n    ImGuiTextFilter     Filter;\n    ImVector<int>       LineOffsets; // Index to lines offset. We maintain this with AddLog() calls.\n    bool                AutoScroll;  // Keep scrolling if already at the bottom.\n\n    ExampleAppLog()\n    {\n        AutoScroll = true;\n        Clear();\n    }\n\n    void    Clear()\n    {\n        Buf.clear();\n        LineOffsets.clear();\n        LineOffsets.push_back(0);\n    }\n\n    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)\n    {\n        int old_size = Buf.size();\n        va_list args;\n        va_start(args, fmt);\n        Buf.appendfv(fmt, args);\n        va_end(args);\n        for (int new_size = Buf.size(); old_size < new_size; old_size++)\n            if (Buf[old_size] == '\\n')\n                LineOffsets.push_back(old_size + 1);\n    }\n\n    void    Draw(const char* title, bool* p_open = NULL)\n    {\n        if (!ImGui::Begin(title, p_open))\n        {\n            ImGui::End();\n            return;\n        }\n\n        // Options menu\n        if (ImGui::BeginPopup(\"Options\"))\n        {\n            ImGui::Checkbox(\"Auto-scroll\", &AutoScroll);\n            ImGui::EndPopup();\n        }\n\n        // Main window\n        if (ImGui::Button(\"Options\"))\n            ImGui::OpenPopup(\"Options\");\n        ImGui::SameLine();\n        bool clear = ImGui::Button(\"Clear\");\n        ImGui::SameLine();\n        bool copy = ImGui::Button(\"Copy\");\n        ImGui::SameLine();\n        Filter.Draw(\"Filter\", -100.0f);\n\n        ImGui::Separator();\n\n        if (ImGui::BeginChild(\"scrolling\", ImVec2(0, 0), ImGuiChildFlags_None, ImGuiWindowFlags_HorizontalScrollbar))\n        {\n            if (clear)\n                Clear();\n            if (copy)\n                ImGui::LogToClipboard();\n\n            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));\n            const char* buf = Buf.begin();\n            const char* buf_end = Buf.end();\n            if (Filter.IsActive())\n            {\n                // In this example we don't use the clipper when Filter is enabled.\n                // This is because we don't have random access to the result of our filter.\n                // A real application processing logs with ten of thousands of entries may want to store the result of\n                // search/filter.. especially if the filtering function is not trivial (e.g. reg-exp).\n                for (int line_no = 0; line_no < LineOffsets.Size; line_no++)\n                {\n                    const char* line_start = buf + LineOffsets[line_no];\n                    const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;\n                    if (Filter.PassFilter(line_start, line_end))\n                        ImGui::TextUnformatted(line_start, line_end);\n                }\n            }\n            else\n            {\n                // The simplest and easy way to display the entire buffer:\n                //   ImGui::TextUnformatted(buf_begin, buf_end);\n                // And it'll just work. TextUnformatted() has specialization for large blob of text and will fast-forward\n                // to skip non-visible lines. Here we instead demonstrate using the clipper to only process lines that are\n                // within the visible area.\n                // If you have tens of thousands of items and their processing cost is non-negligible, coarse clipping them\n                // on your side is recommended. Using ImGuiListClipper requires\n                // - A) random access into your data\n                // - B) items all being the  same height,\n                // both of which we can handle since we have an array pointing to the beginning of each line of text.\n                // When using the filter (in the block of code above) we don't have random access into the data to display\n                // anymore, which is why we don't use the clipper. Storing or skimming through the search result would make\n                // it possible (and would be recommended if you want to search through tens of thousands of entries).\n                ImGuiListClipper clipper;\n                clipper.Begin(LineOffsets.Size);\n                while (clipper.Step())\n                {\n                    for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)\n                    {\n                        const char* line_start = buf + LineOffsets[line_no];\n                        const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;\n                        ImGui::TextUnformatted(line_start, line_end);\n                    }\n                }\n                clipper.End();\n            }\n            ImGui::PopStyleVar();\n\n            // Keep up at the bottom of the scroll region if we were already at the bottom at the beginning of the frame.\n            // Using a scrollbar or mouse-wheel will take away from the bottom edge.\n            if (AutoScroll && ImGui::GetScrollY() >= ImGui::GetScrollMaxY())\n                ImGui::SetScrollHereY(1.0f);\n        }\n        ImGui::EndChild();\n        ImGui::End();\n    }\n};\n\n// Demonstrate creating a simple log window with basic filtering.\nstatic void ShowExampleAppLog(bool* p_open)\n{\n    static ExampleAppLog log;\n\n    // For the demo: add a debug button _BEFORE_ the normal log window contents\n    // We take advantage of a rarely used feature: multiple calls to Begin()/End() are appending to the _same_ window.\n    // Most of the contents of the window will be added by the log.Draw() call.\n    ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);\n    ImGui::Begin(\"Example: Log\", p_open);\n    IMGUI_DEMO_MARKER(\"Examples/Log\");\n    if (ImGui::SmallButton(\"[Debug] Add 5 entries\"))\n    {\n        static int counter = 0;\n        const char* categories[3] = { \"info\", \"warn\", \"error\" };\n        const char* words[] = { \"Bumfuzzled\", \"Cattywampus\", \"Snickersnee\", \"Abibliophobia\", \"Absquatulate\", \"Nincompoop\", \"Pauciloquent\" };\n        for (int n = 0; n < 5; n++)\n        {\n            const char* category = categories[counter % IM_ARRAYSIZE(categories)];\n            const char* word = words[counter % IM_ARRAYSIZE(words)];\n            log.AddLog(\"[%05d] [%s] Hello, current time is %.1f, here's a word: '%s'\\n\",\n                ImGui::GetFrameCount(), category, ImGui::GetTime(), word);\n            counter++;\n        }\n    }\n    ImGui::End();\n\n    // Actually call in the regular Log helper (which will Begin() into the same window as we just did)\n    log.Draw(\"Example: Log\", p_open);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n//-----------------------------------------------------------------------------\n\n// Demonstrate create a window with multiple child windows.\nstatic void ShowExampleAppLayout(bool* p_open)\n{\n    ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);\n    if (ImGui::Begin(\"Example: Simple layout\", p_open, ImGuiWindowFlags_MenuBar))\n    {\n        IMGUI_DEMO_MARKER(\"Examples/Simple layout\");\n        if (ImGui::BeginMenuBar())\n        {\n            if (ImGui::BeginMenu(\"File\"))\n            {\n                if (ImGui::MenuItem(\"Close\", \"Ctrl+W\")) { *p_open = false; }\n                ImGui::EndMenu();\n            }\n            ImGui::EndMenuBar();\n        }\n\n        // Left\n        static int selected = 0;\n        {\n            ImGui::BeginChild(\"left pane\", ImVec2(150, 0), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeX);\n            for (int i = 0; i < 100; i++)\n            {\n                // FIXME: Good candidate to use ImGuiSelectableFlags_SelectOnNav\n                char label[128];\n                sprintf(label, \"MyObject %d\", i);\n                if (ImGui::Selectable(label, selected == i))\n                    selected = i;\n            }\n            ImGui::EndChild();\n        }\n        ImGui::SameLine();\n\n        // Right\n        {\n            ImGui::BeginGroup();\n            ImGui::BeginChild(\"item view\", ImVec2(0, -ImGui::GetFrameHeightWithSpacing())); // Leave room for 1 line below us\n            ImGui::Text(\"MyObject: %d\", selected);\n            ImGui::Separator();\n            if (ImGui::BeginTabBar(\"##Tabs\", ImGuiTabBarFlags_None))\n            {\n                if (ImGui::BeginTabItem(\"Description\"))\n                {\n                    ImGui::TextWrapped(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \");\n                    ImGui::EndTabItem();\n                }\n                if (ImGui::BeginTabItem(\"Details\"))\n                {\n                    ImGui::Text(\"ID: 0123456789\");\n                    ImGui::EndTabItem();\n                }\n                ImGui::EndTabBar();\n            }\n            ImGui::EndChild();\n            if (ImGui::Button(\"Revert\")) {}\n            ImGui::SameLine();\n            if (ImGui::Button(\"Save\")) {}\n            ImGui::EndGroup();\n        }\n    }\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n//-----------------------------------------------------------------------------\n// Some of the interactions are a bit lack-luster:\n// - We would want pressing validating or leaving the filter to somehow restore focus.\n// - We may want more advanced filtering (child nodes) and clipper support: both will need extra work.\n// - We would want to customize some keyboard interactions to easily keyboard navigate between the tree and the properties.\n//-----------------------------------------------------------------------------\n\nstruct ExampleAppPropertyEditor\n{\n    ImGuiTextFilter     Filter;\n    ExampleTreeNode*    VisibleNode = NULL;\n\n    void Draw(ExampleTreeNode* root_node)\n    {\n        // Left side: draw tree\n        // - Currently using a table to benefit from RowBg feature\n        if (ImGui::BeginChild(\"##tree\", ImVec2(300, 0), ImGuiChildFlags_ResizeX | ImGuiChildFlags_Borders | ImGuiChildFlags_NavFlattened))\n        {\n            ImGui::SetNextItemWidth(-FLT_MIN);\n            ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_F, ImGuiInputFlags_Tooltip);\n            ImGui::PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);\n            if (ImGui::InputTextWithHint(\"##Filter\", \"incl,-excl\", Filter.InputBuf, IM_ARRAYSIZE(Filter.InputBuf), ImGuiInputTextFlags_EscapeClearsAll))\n                Filter.Build();\n            ImGui::PopItemFlag();\n\n            if (ImGui::BeginTable(\"##bg\", 1, ImGuiTableFlags_RowBg))\n            {\n                for (ExampleTreeNode* node : root_node->Childs)\n                    if (Filter.PassFilter(node->Name)) // Filter root node\n                        DrawTreeNode(node);\n                ImGui::EndTable();\n            }\n        }\n        ImGui::EndChild();\n\n        // Right side: draw properties\n        ImGui::SameLine();\n\n        ImGui::BeginGroup(); // Lock X position\n        if (ExampleTreeNode* node = VisibleNode)\n        {\n            ImGui::Text(\"%s\", node->Name);\n            ImGui::TextDisabled(\"UID: 0x%08X\", node->UID);\n            ImGui::Separator();\n            if (ImGui::BeginTable(\"##properties\", 2, ImGuiTableFlags_Resizable | ImGuiTableFlags_ScrollY))\n            {\n                // Push object ID after we entered the table, so table is shared for all objects\n                ImGui::PushID((int)node->UID);\n                ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthFixed);\n                ImGui::TableSetupColumn(\"\", ImGuiTableColumnFlags_WidthStretch, 2.0f); // Default twice larger\n                if (node->HasData)\n                {\n                    // In a typical application, the structure description would be derived from a data-driven system.\n                    // - We try to mimic this with our ExampleMemberInfo structure and the ExampleTreeNodeMemberInfos[] array.\n                    // - Limits and some details are hard-coded to simplify the demo.\n                    for (const ExampleMemberInfo& field_desc : ExampleTreeNodeMemberInfos)\n                    {\n                        ImGui::TableNextRow();\n                        ImGui::PushID(field_desc.Name);\n                        ImGui::TableNextColumn();\n                        ImGui::AlignTextToFramePadding();\n                        ImGui::TextUnformatted(field_desc.Name);\n                        ImGui::TableNextColumn();\n                        void* field_ptr = (void*)(((unsigned char*)node) + field_desc.Offset);\n                        switch (field_desc.DataType)\n                        {\n                        case ImGuiDataType_Bool:\n                        {\n                            IM_ASSERT(field_desc.DataCount == 1);\n                            ImGui::Checkbox(\"##Editor\", (bool*)field_ptr);\n                            break;\n                        }\n                        case ImGuiDataType_S32:\n                        {\n                            int v_min = INT_MIN, v_max = INT_MAX;\n                            ImGui::SetNextItemWidth(-FLT_MIN);\n                            ImGui::DragScalarN(\"##Editor\", field_desc.DataType, field_ptr, field_desc.DataCount, 1.0f, &v_min, &v_max);\n                            break;\n                        }\n                        case ImGuiDataType_Float:\n                        {\n                            float v_min = 0.0f, v_max = 1.0f;\n                            ImGui::SetNextItemWidth(-FLT_MIN);\n                            ImGui::SliderScalarN(\"##Editor\", field_desc.DataType, field_ptr, field_desc.DataCount, &v_min, &v_max);\n                            break;\n                        }\n                        case ImGuiDataType_String:\n                        {\n                            ImGui::InputText(\"##Editor\", reinterpret_cast<char*>(field_ptr), 28);\n                            break;\n                        }\n                        }\n                        ImGui::PopID();\n                    }\n                }\n                ImGui::PopID();\n                ImGui::EndTable();\n            }\n        }\n        ImGui::EndGroup();\n    }\n\n    void DrawTreeNode(ExampleTreeNode* node)\n    {\n        ImGui::TableNextRow();\n        ImGui::TableNextColumn();\n        ImGui::PushID(node->UID);\n        ImGuiTreeNodeFlags tree_flags = ImGuiTreeNodeFlags_None;\n        tree_flags |= ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;    // Standard opening mode as we are likely to want to add selection afterwards\n        tree_flags |= ImGuiTreeNodeFlags_NavLeftJumpsBackHere;                                  // Left arrow support\n        if (node == VisibleNode)\n            tree_flags |= ImGuiTreeNodeFlags_Selected;\n        if (node->Childs.Size == 0)\n            tree_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_Bullet;\n        if (node->DataMyBool == false)\n            ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_TextDisabled]);\n        bool node_open = ImGui::TreeNodeEx(\"\", tree_flags, \"%s\", node->Name);\n        if (node->DataMyBool == false)\n            ImGui::PopStyleColor();\n        if (ImGui::IsItemFocused())\n            VisibleNode = node;\n        if (node_open)\n        {\n            for (ExampleTreeNode* child : node->Childs)\n                DrawTreeNode(child);\n            ImGui::TreePop();\n        }\n        ImGui::PopID();\n    }\n};\n\n// Demonstrate creating a simple property editor.\nstatic void ShowExampleAppPropertyEditor(bool* p_open, ImGuiDemoWindowData* demo_data)\n{\n    ImGui::SetNextWindowSize(ImVec2(430, 450), ImGuiCond_FirstUseEver);\n    if (!ImGui::Begin(\"Example: Property editor\", p_open))\n    {\n        ImGui::End();\n        return;\n    }\n\n    IMGUI_DEMO_MARKER(\"Examples/Property Editor\");\n    static ExampleAppPropertyEditor property_editor;\n    if (demo_data->DemoTree == NULL)\n        demo_data->DemoTree = ExampleTree_CreateDemoTree();\n    property_editor.Draw(demo_data->DemoTree);\n\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n//-----------------------------------------------------------------------------\n\n// Demonstrate/test rendering huge amount of text, and the incidence of clipping.\nstatic void ShowExampleAppLongText(bool* p_open)\n{\n    ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);\n    if (!ImGui::Begin(\"Example: Long text display\", p_open))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples/Long text display\");\n\n    static int test_type = 0;\n    static ImGuiTextBuffer log;\n    static int lines = 0;\n    ImGui::Text(\"Printing unusually long amount of text.\");\n    ImGui::Combo(\"Test type\", &test_type,\n        \"Single call to TextUnformatted()\\0\"\n        \"Multiple calls to Text(), clipped\\0\"\n        \"Multiple calls to Text(), not clipped (slow)\\0\");\n    ImGui::Text(\"Buffer contents: %d lines, %d bytes\", lines, log.size());\n    if (ImGui::Button(\"Clear\")) { log.clear(); lines = 0; }\n    ImGui::SameLine();\n    if (ImGui::Button(\"Add 1000 lines\"))\n    {\n        for (int i = 0; i < 1000; i++)\n            log.appendf(\"%i The quick brown fox jumps over the lazy dog\\n\", lines + i);\n        lines += 1000;\n    }\n    ImGui::BeginChild(\"Log\");\n    switch (test_type)\n    {\n    case 0:\n        // Single call to TextUnformatted() with a big buffer\n        ImGui::TextUnformatted(log.begin(), log.end());\n        break;\n    case 1:\n        {\n            // Multiple calls to Text(), manually coarsely clipped - demonstrate how to use the ImGuiListClipper helper.\n            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));\n            ImGuiListClipper clipper;\n            clipper.Begin(lines);\n            while (clipper.Step())\n                for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n                    ImGui::Text(\"%i The quick brown fox jumps over the lazy dog\", i);\n            ImGui::PopStyleVar();\n            break;\n        }\n    case 2:\n        // Multiple calls to Text(), not clipped (slow)\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));\n        for (int i = 0; i < lines; i++)\n            ImGui::Text(\"%i The quick brown fox jumps over the lazy dog\", i);\n        ImGui::PopStyleVar();\n        break;\n    }\n    ImGui::EndChild();\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n//-----------------------------------------------------------------------------\n\n// Demonstrate creating a window which gets auto-resized according to its content.\nstatic void ShowExampleAppAutoResize(bool* p_open)\n{\n    if (!ImGui::Begin(\"Example: Auto-resizing window\", p_open, ImGuiWindowFlags_AlwaysAutoResize))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples/Auto-resizing window\");\n\n    static int lines = 10;\n    ImGui::TextUnformatted(\n        \"Window will resize every-frame to the size of its content.\\n\"\n        \"Note that you probably don't want to query the window size to\\n\"\n        \"output your content because that would create a feedback loop.\");\n    ImGui::SliderInt(\"Number of lines\", &lines, 1, 20);\n    for (int i = 0; i < lines; i++)\n        ImGui::Text(\"%*sThis is line %d\", i * 4, \"\", i); // Pad with space to extend size horizontally\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n//-----------------------------------------------------------------------------\n\n// Demonstrate creating a window with custom resize constraints.\n// Note that size constraints currently don't work on a docked window (when in 'docking' branch)\nstatic void ShowExampleAppConstrainedResize(bool* p_open)\n{\n    struct CustomConstraints\n    {\n        // Helper functions to demonstrate programmatic constraints\n        // FIXME: This doesn't take account of decoration size (e.g. title bar), library should make this easier.\n        // FIXME: None of the three demos works consistently when resizing from borders.\n        static void AspectRatio(ImGuiSizeCallbackData* data)\n        {\n            float aspect_ratio = *(float*)data->UserData;\n            data->DesiredSize.y = (float)(int)(data->DesiredSize.x / aspect_ratio);\n        }\n        static void Square(ImGuiSizeCallbackData* data)\n        {\n            data->DesiredSize.x = data->DesiredSize.y = IM_MAX(data->DesiredSize.x, data->DesiredSize.y);\n        }\n        static void Step(ImGuiSizeCallbackData* data)\n        {\n            float step = *(float*)data->UserData;\n            data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step);\n        }\n    };\n\n    const char* test_desc[] =\n    {\n        \"Between 100x100 and 500x500\",\n        \"At least 100x100\",\n        \"Resize vertical + lock current width\",\n        \"Resize horizontal + lock current height\",\n        \"Width Between 400 and 500\",\n        \"Height at least 400\",\n        \"Custom: Aspect Ratio 16:9\",\n        \"Custom: Always Square\",\n        \"Custom: Fixed Steps (100)\",\n    };\n\n    // Options\n    static bool auto_resize = false;\n    static bool window_padding = true;\n    static int type = 6; // Aspect Ratio\n    static int display_lines = 10;\n\n    // Submit constraint\n    float aspect_ratio = 16.0f / 9.0f;\n    float fixed_step = 100.0f;\n    if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(500, 500));         // Between 100x100 and 500x500\n    if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100\n    if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Resize vertical + lock current width\n    if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Resize horizontal + lock current height\n    if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(400, -1),  ImVec2(500, -1));          // Width Between and 400 and 500\n    if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 400),  ImVec2(-1, FLT_MAX));      // Height at least 400\n    if (type == 6) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::AspectRatio, (void*)&aspect_ratio);   // Aspect ratio\n    if (type == 7) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);                              // Always Square\n    if (type == 8) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)&fixed_step);            // Fixed Step\n\n    // Submit window\n    if (!window_padding)\n        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));\n    const ImGuiWindowFlags window_flags = auto_resize ? ImGuiWindowFlags_AlwaysAutoResize : 0;\n    const bool window_open = ImGui::Begin(\"Example: Constrained Resize\", p_open, window_flags);\n    if (!window_padding)\n        ImGui::PopStyleVar();\n    if (window_open)\n    {\n        IMGUI_DEMO_MARKER(\"Examples/Constrained Resizing window\");\n        if (ImGui::GetIO().KeyShift)\n        {\n            // Display a dummy viewport (in your real app you would likely use ImageButton() to display a texture.\n            ImVec2 avail_size = ImGui::GetContentRegionAvail();\n            ImVec2 pos = ImGui::GetCursorScreenPos();\n            ImGui::ColorButton(\"viewport\", ImVec4(0.5f, 0.2f, 0.5f, 1.0f), ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoDragDrop, avail_size);\n            ImGui::SetCursorScreenPos(ImVec2(pos.x + 10, pos.y + 10));\n            ImGui::Text(\"%.2f x %.2f\", avail_size.x, avail_size.y);\n        }\n        else\n        {\n            ImGui::Text(\"(Hold SHIFT to display a dummy viewport)\");\n            if (ImGui::Button(\"Set 200x200\")) { ImGui::SetWindowSize(ImVec2(200, 200)); } ImGui::SameLine();\n            if (ImGui::Button(\"Set 500x500\")) { ImGui::SetWindowSize(ImVec2(500, 500)); } ImGui::SameLine();\n            if (ImGui::Button(\"Set 800x200\")) { ImGui::SetWindowSize(ImVec2(800, 200)); }\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 20);\n            ImGui::Combo(\"Constraint\", &type, test_desc, IM_ARRAYSIZE(test_desc));\n            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 20);\n            ImGui::DragInt(\"Lines\", &display_lines, 0.2f, 1, 100);\n            ImGui::Checkbox(\"Auto-resize\", &auto_resize);\n            ImGui::Checkbox(\"Window padding\", &window_padding);\n            for (int i = 0; i < display_lines; i++)\n                ImGui::Text(\"%*sHello, sailor! Making this line long enough for the example.\", i * 4, \"\");\n        }\n    }\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n//-----------------------------------------------------------------------------\n\n// Demonstrate creating a simple static window with no decoration\n// + a context-menu to choose which corner of the screen to use.\nstatic void ShowExampleAppSimpleOverlay(bool* p_open)\n{\n    static int location = 0;\n    ImGuiIO& io = ImGui::GetIO();\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav;\n    if (location >= 0)\n    {\n        const float PAD = 10.0f;\n        const ImGuiViewport* viewport = ImGui::GetMainViewport();\n        ImVec2 work_pos = viewport->WorkPos; // Use work area to avoid menu-bar/task-bar, if any!\n        ImVec2 work_size = viewport->WorkSize;\n        ImVec2 window_pos, window_pos_pivot;\n        window_pos.x = (location & 1) ? (work_pos.x + work_size.x - PAD) : (work_pos.x + PAD);\n        window_pos.y = (location & 2) ? (work_pos.y + work_size.y - PAD) : (work_pos.y + PAD);\n        window_pos_pivot.x = (location & 1) ? 1.0f : 0.0f;\n        window_pos_pivot.y = (location & 2) ? 1.0f : 0.0f;\n        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);\n        window_flags |= ImGuiWindowFlags_NoMove;\n    }\n    else if (location == -2)\n    {\n        // Center window\n        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));\n        window_flags |= ImGuiWindowFlags_NoMove;\n    }\n    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background\n    if (ImGui::Begin(\"Example: Simple overlay\", p_open, window_flags))\n    {\n        IMGUI_DEMO_MARKER(\"Examples/Simple Overlay\");\n        ImGui::Text(\"Simple overlay\\n\" \"(right-click to change position)\");\n        ImGui::Separator();\n        if (ImGui::IsMousePosValid())\n            ImGui::Text(\"Mouse Position: (%.1f,%.1f)\", io.MousePos.x, io.MousePos.y);\n        else\n            ImGui::Text(\"Mouse Position: <invalid>\");\n        if (ImGui::BeginPopupContextWindow())\n        {\n            if (ImGui::MenuItem(\"Custom\",       NULL, location == -1)) location = -1;\n            if (ImGui::MenuItem(\"Center\",       NULL, location == -2)) location = -2;\n            if (ImGui::MenuItem(\"Top-left\",     NULL, location == 0)) location = 0;\n            if (ImGui::MenuItem(\"Top-right\",    NULL, location == 1)) location = 1;\n            if (ImGui::MenuItem(\"Bottom-left\",  NULL, location == 2)) location = 2;\n            if (ImGui::MenuItem(\"Bottom-right\", NULL, location == 3)) location = 3;\n            if (p_open && ImGui::MenuItem(\"Close\")) *p_open = false;\n            ImGui::EndPopup();\n        }\n    }\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n//-----------------------------------------------------------------------------\n\n// Demonstrate creating a window covering the entire screen/viewport\nstatic void ShowExampleAppFullscreen(bool* p_open)\n{\n    static bool use_work_area = true;\n    static ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings;\n\n    // We demonstrate using the full viewport area or the work area (without menu-bars, task-bars etc.)\n    // Based on your use case you may want one or the other.\n    const ImGuiViewport* viewport = ImGui::GetMainViewport();\n    ImGui::SetNextWindowPos(use_work_area ? viewport->WorkPos : viewport->Pos);\n    ImGui::SetNextWindowSize(use_work_area ? viewport->WorkSize : viewport->Size);\n\n    if (ImGui::Begin(\"Example: Fullscreen window\", p_open, flags))\n    {\n        ImGui::Checkbox(\"Use work area instead of main area\", &use_work_area);\n        ImGui::SameLine();\n        HelpMarker(\"Main Area = entire viewport,\\nWork Area = entire viewport minus sections used by the main menu bars, task bars etc.\\n\\nEnable the main-menu bar in Examples menu to see the difference.\");\n\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoBackground\", &flags, ImGuiWindowFlags_NoBackground);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoDecoration\", &flags, ImGuiWindowFlags_NoDecoration);\n        ImGui::Indent();\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoTitleBar\", &flags, ImGuiWindowFlags_NoTitleBar);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoCollapse\", &flags, ImGuiWindowFlags_NoCollapse);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoScrollbar\", &flags, ImGuiWindowFlags_NoScrollbar);\n        ImGui::Unindent();\n\n        if (p_open && ImGui::Button(\"Close this window\"))\n            *p_open = false;\n    }\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()\n//-----------------------------------------------------------------------------\n\n// Demonstrate the use of \"##\" and \"###\" in identifiers to manipulate ID generation.\n// This applies to all regular items as well.\n// Read FAQ section \"How can I have multiple widgets with the same label?\" for details.\nstatic void ShowExampleAppWindowTitles(bool*)\n{\n    const ImGuiViewport* viewport = ImGui::GetMainViewport();\n    const ImVec2 base_pos = viewport->Pos;\n\n    // By default, Windows are uniquely identified by their title.\n    // You can use the \"##\" and \"###\" markers to manipulate the display/ID.\n\n    // Using \"##\" to display same title but have unique identifier.\n    ImGui::SetNextWindowPos(ImVec2(base_pos.x + 100, base_pos.y + 100), ImGuiCond_FirstUseEver);\n    ImGui::Begin(\"Same title as another window##1\");\n    IMGUI_DEMO_MARKER(\"Examples/Manipulating window titles\");\n    ImGui::Text(\"This is window 1.\\nMy title is the same as window 2, but my identifier is unique.\");\n    ImGui::End();\n\n    ImGui::SetNextWindowPos(ImVec2(base_pos.x + 100, base_pos.y + 200), ImGuiCond_FirstUseEver);\n    ImGui::Begin(\"Same title as another window##2\");\n    ImGui::Text(\"This is window 2.\\nMy title is the same as window 1, but my identifier is unique.\");\n    ImGui::End();\n\n    // Using \"###\" to display a changing title but keep a static identifier \"AnimatedTitle\"\n    char buf[128];\n    sprintf(buf, \"Animated title %c %d###AnimatedTitle\", \"|/-\\\\\"[(int)(ImGui::GetTime() / 0.25f) & 3], ImGui::GetFrameCount());\n    ImGui::SetNextWindowPos(ImVec2(base_pos.x + 100, base_pos.y + 300), ImGuiCond_FirstUseEver);\n    ImGui::Begin(buf);\n    ImGui::Text(\"This window has a changing title.\");\n    ImGui::End();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n//-----------------------------------------------------------------------------\n\n// Add a |_| looking shape\nstatic void PathConcaveShape(ImDrawList* draw_list, float x, float y, float sz)\n{\n    const ImVec2 pos_norms[] = { { 0.0f, 0.0f }, { 0.3f, 0.0f }, { 0.3f, 0.7f }, { 0.7f, 0.7f }, { 0.7f, 0.0f }, { 1.0f, 0.0f }, { 1.0f, 1.0f }, { 0.0f, 1.0f } };\n    for (const ImVec2& p : pos_norms)\n        draw_list->PathLineTo(ImVec2(x + 0.5f + (int)(sz * p.x), y + 0.5f + (int)(sz * p.y)));\n}\n\n// Demonstrate using the low-level ImDrawList to draw custom shapes.\nstatic void ShowExampleAppCustomRendering(bool* p_open)\n{\n    if (!ImGui::Begin(\"Example: Custom rendering\", p_open))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples/Custom Rendering\");\n\n    // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of\n    // overloaded operators, etc. Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your\n    // types and ImVec2/ImVec4. Dear ImGui defines overloaded operators but they are internal to imgui.cpp and not\n    // exposed outside (to avoid messing with your types) In this example we are not using the maths operators!\n\n    if (ImGui::BeginTabBar(\"##TabBar\"))\n    {\n        if (ImGui::BeginTabItem(\"Primitives\"))\n        {\n            ImGui::PushItemWidth(-ImGui::GetFontSize() * 15);\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n\n            // Draw gradients\n            // (note that those are currently exacerbating our sRGB/Linear issues)\n            // Calling ImGui::GetColorU32() multiplies the given colors by the current Style Alpha, but you may pass the IM_COL32() directly as well..\n            ImGui::Text(\"Gradients\");\n            ImVec2 gradient_size = ImVec2(ImGui::CalcItemWidth(), ImGui::GetFrameHeight());\n            {\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);\n                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 0, 0, 255));\n                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 255, 255, 255));\n                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);\n                ImGui::InvisibleButton(\"##gradient1\", gradient_size);\n            }\n            {\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);\n                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 255, 0, 255));\n                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 0, 0, 255));\n                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);\n                ImGui::InvisibleButton(\"##gradient2\", gradient_size);\n            }\n\n            // Draw a bunch of primitives\n            ImGui::Text(\"All primitives\");\n            static float sz = 36.0f;\n            static float thickness = 3.0f;\n            static int ngon_sides = 6;\n            static bool circle_segments_override = false;\n            static int circle_segments_override_v = 12;\n            static bool curve_segments_override = false;\n            static int curve_segments_override_v = 8;\n            static ImVec4 colf = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);\n            ImGui::DragFloat(\"Size\", &sz, 0.2f, 2.0f, 100.0f, \"%.0f\");\n            ImGui::DragFloat(\"Thickness\", &thickness, 0.05f, 1.0f, 8.0f, \"%.02f\");\n            ImGui::SliderInt(\"N-gon sides\", &ngon_sides, 3, 12);\n            ImGui::Checkbox(\"##circlesegmentoverride\", &circle_segments_override);\n            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n            circle_segments_override |= ImGui::SliderInt(\"Circle segments override\", &circle_segments_override_v, 3, 40);\n            ImGui::Checkbox(\"##curvessegmentoverride\", &curve_segments_override);\n            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n            curve_segments_override |= ImGui::SliderInt(\"Curves segments override\", &curve_segments_override_v, 3, 40);\n            ImGui::ColorEdit4(\"Color\", &colf.x);\n\n            const ImVec2 p = ImGui::GetCursorScreenPos();\n            const ImU32 col = ImColor(colf);\n            const float spacing = 10.0f;\n            const ImDrawFlags corners_tl_br = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBottomRight;\n            const float rounding = sz / 5.0f;\n            const int circle_segments = circle_segments_override ? circle_segments_override_v : 0;\n            const int curve_segments = curve_segments_override ? curve_segments_override_v : 0;\n            const ImVec2 cp3[3] = { ImVec2(0.0f, sz * 0.6f), ImVec2(sz * 0.5f, -sz * 0.4f), ImVec2(sz, sz) }; // Control points for curves\n            const ImVec2 cp4[4] = { ImVec2(0.0f, 0.0f), ImVec2(sz * 1.3f, sz * 0.3f), ImVec2(sz - sz * 1.3f, sz - sz * 0.3f), ImVec2(sz, sz) };\n\n            float x = p.x + 4.0f;\n            float y = p.y + 4.0f;\n            for (int n = 0; n < 2; n++)\n            {\n                // First line uses a thickness of 1.0f, second line uses the configurable thickness\n                float th = (n == 0) ? 1.0f : thickness;\n                draw_list->AddNgon(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, ngon_sides, th);                 x += sz + spacing;  // N-gon\n                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, circle_segments, th);          x += sz + spacing;  // Circle\n                draw_list->AddEllipse(ImVec2(x + sz*0.5f, y + sz*0.5f), ImVec2(sz*0.5f, sz*0.3f), col, -0.3f, circle_segments, th); x += sz + spacing;\t// Ellipse\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 0.0f, ImDrawFlags_None, th);          x += sz + spacing;  // Square\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, ImDrawFlags_None, th);      x += sz + spacing;  // Square with all rounded corners\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, corners_tl_br, th);         x += sz + spacing;  // Square with two rounded corners\n                draw_list->AddTriangle(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col, th);x += sz + spacing;  // Triangle\n                //draw_list->AddTriangle(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col, th);x+= sz*0.4f + spacing; // Thin triangle\n                PathConcaveShape(draw_list, x, y, sz); draw_list->PathStroke(col, ImDrawFlags_Closed, th);          x += sz + spacing;  // Concave Shape\n                //draw_list->AddPolyline(concave_shape, IM_ARRAYSIZE(concave_shape), col, ImDrawFlags_Closed, th);\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y), col, th);                                       x += sz + spacing;  // Horizontal line (note: drawing a filled rectangle will be faster!)\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x, y + sz), col, th);                                       x += spacing;       // Vertical line (note: drawing a filled rectangle will be faster!)\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y + sz), col, th);                                  x += sz + spacing;  // Diagonal line\n\n                // Path\n                draw_list->PathArcTo(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, 3.141592f, 3.141592f * -0.5f);\n                draw_list->PathStroke(col, ImDrawFlags_None, th);\n                x += sz + spacing;\n\n                // Quadratic Bezier Curve (3 control points)\n                draw_list->AddBezierQuadratic(ImVec2(x + cp3[0].x, y + cp3[0].y), ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), col, th, curve_segments);\n                x += sz + spacing;\n\n                // Cubic Bezier Curve (4 control points)\n                draw_list->AddBezierCubic(ImVec2(x + cp4[0].x, y + cp4[0].y), ImVec2(x + cp4[1].x, y + cp4[1].y), ImVec2(x + cp4[2].x, y + cp4[2].y), ImVec2(x + cp4[3].x, y + cp4[3].y), col, th, curve_segments);\n\n                x = p.x + 4;\n                y += sz + spacing;\n            }\n\n            // Filled shapes\n            draw_list->AddNgonFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, ngon_sides);             x += sz + spacing;  // N-gon\n            draw_list->AddCircleFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, circle_segments);      x += sz + spacing;  // Circle\n            draw_list->AddEllipseFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), ImVec2(sz * 0.5f, sz * 0.3f), col, -0.3f, circle_segments); x += sz + spacing;// Ellipse\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col);                                    x += sz + spacing;  // Square\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f);                             x += sz + spacing;  // Square with all rounded corners\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br);              x += sz + spacing;  // Square with two rounded corners\n            draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col);  x += sz + spacing;  // Triangle\n            //draw_list->AddTriangleFilled(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col); x += sz*0.4f + spacing; // Thin triangle\n            PathConcaveShape(draw_list, x, y, sz); draw_list->PathFillConcave(col);                                 x += sz + spacing;  // Concave shape\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + thickness), col);                             x += sz + spacing;  // Horizontal line (faster than AddLine, but only handle integer thickness)\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + thickness, y + sz), col);                             x += spacing * 2.0f;// Vertical line (faster than AddLine, but only handle integer thickness)\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + 1, y + 1), col);                                      x += sz;            // Pixel (faster than AddLine)\n\n            // Path\n            draw_list->PathArcTo(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, 3.141592f * -0.5f, 3.141592f);\n            draw_list->PathFillConvex(col);\n            x += sz + spacing;\n\n            // Quadratic Bezier Curve (3 control points)\n            draw_list->PathLineTo(ImVec2(x + cp3[0].x, y + cp3[0].y));\n            draw_list->PathBezierQuadraticCurveTo(ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), curve_segments);\n            draw_list->PathFillConvex(col);\n            x += sz + spacing;\n\n            draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + sz, y + sz), IM_COL32(0, 0, 0, 255), IM_COL32(255, 0, 0, 255), IM_COL32(255, 255, 0, 255), IM_COL32(0, 255, 0, 255));\n            x += sz + spacing;\n\n            ImGui::Dummy(ImVec2((sz + spacing) * 13.2f, (sz + spacing) * 3.0f));\n            ImGui::PopItemWidth();\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Canvas\"))\n        {\n            static ImVector<ImVec2> points;\n            static ImVec2 scrolling(0.0f, 0.0f);\n            static bool opt_enable_grid = true;\n            static bool opt_enable_context_menu = true;\n            static bool adding_line = false;\n\n            ImGui::Checkbox(\"Enable grid\", &opt_enable_grid);\n            ImGui::Checkbox(\"Enable context menu\", &opt_enable_context_menu);\n            ImGui::Text(\"Mouse Left: drag to add lines,\\nMouse Right: drag to scroll, click for context menu.\");\n\n            // Typically you would use a BeginChild()/EndChild() pair to benefit from a clipping region + own scrolling.\n            // Here we demonstrate that this can be replaced by simple offsetting + custom drawing + PushClipRect/PopClipRect() calls.\n            // To use a child window instead we could use, e.g:\n            //      ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));      // Disable padding\n            //      ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(50, 50, 50, 255));  // Set a background color\n            //      ImGui::BeginChild(\"canvas\", ImVec2(0.0f, 0.0f), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);\n            //      ImGui::PopStyleColor();\n            //      ImGui::PopStyleVar();\n            //      [...]\n            //      ImGui::EndChild();\n\n            // Using InvisibleButton() as a convenience 1) it will advance the layout cursor and 2) allows us to use IsItemHovered()/IsItemActive()\n            ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();      // ImDrawList API uses screen coordinates!\n            ImVec2 canvas_sz = ImGui::GetContentRegionAvail();   // Resize canvas to what's available\n            if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;\n            if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;\n            ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);\n\n            // Draw border and background color\n            ImGuiIO& io = ImGui::GetIO();\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            draw_list->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(50, 50, 50, 255));\n            draw_list->AddRect(canvas_p0, canvas_p1, IM_COL32(255, 255, 255, 255));\n\n            // This will catch our interactions\n            ImGui::InvisibleButton(\"canvas\", canvas_sz, ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight);\n            const bool is_hovered = ImGui::IsItemHovered(); // Hovered\n            const bool is_active = ImGui::IsItemActive();   // Held\n            const ImVec2 origin(canvas_p0.x + scrolling.x, canvas_p0.y + scrolling.y); // Lock scrolled origin\n            const ImVec2 mouse_pos_in_canvas(io.MousePos.x - origin.x, io.MousePos.y - origin.y);\n\n            // Add first and second point\n            if (is_hovered && !adding_line && ImGui::IsMouseClicked(ImGuiMouseButton_Left))\n            {\n                points.push_back(mouse_pos_in_canvas);\n                points.push_back(mouse_pos_in_canvas);\n                adding_line = true;\n            }\n            if (adding_line)\n            {\n                points.back() = mouse_pos_in_canvas;\n                if (!ImGui::IsMouseDown(ImGuiMouseButton_Left))\n                    adding_line = false;\n            }\n\n            // Pan (we use a zero mouse threshold when there's no context menu)\n            // You may decide to make that threshold dynamic based on whether the mouse is hovering something etc.\n            const float mouse_threshold_for_pan = opt_enable_context_menu ? -1.0f : 0.0f;\n            if (is_active && ImGui::IsMouseDragging(ImGuiMouseButton_Right, mouse_threshold_for_pan))\n            {\n                scrolling.x += io.MouseDelta.x;\n                scrolling.y += io.MouseDelta.y;\n            }\n\n            // Context menu (under default mouse threshold)\n            ImVec2 drag_delta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Right);\n            if (opt_enable_context_menu && drag_delta.x == 0.0f && drag_delta.y == 0.0f)\n                ImGui::OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n            if (ImGui::BeginPopup(\"context\"))\n            {\n                if (adding_line)\n                    points.resize(points.size() - 2);\n                adding_line = false;\n                if (ImGui::MenuItem(\"Remove one\", NULL, false, points.Size > 0)) { points.resize(points.size() - 2); }\n                if (ImGui::MenuItem(\"Remove all\", NULL, false, points.Size > 0)) { points.clear(); }\n                ImGui::EndPopup();\n            }\n\n            // Draw grid + all lines in the canvas\n            draw_list->PushClipRect(canvas_p0, canvas_p1, true);\n            if (opt_enable_grid)\n            {\n                const float GRID_STEP = 64.0f;\n                for (float x = fmodf(scrolling.x, GRID_STEP); x < canvas_sz.x; x += GRID_STEP)\n                    draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p1.y), IM_COL32(200, 200, 200, 40));\n                for (float y = fmodf(scrolling.y, GRID_STEP); y < canvas_sz.y; y += GRID_STEP)\n                    draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p1.x, canvas_p0.y + y), IM_COL32(200, 200, 200, 40));\n            }\n            for (int n = 0; n < points.Size; n += 2)\n                draw_list->AddLine(ImVec2(origin.x + points[n].x, origin.y + points[n].y), ImVec2(origin.x + points[n + 1].x, origin.y + points[n + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);\n            draw_list->PopClipRect();\n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"BG/FG draw lists\"))\n        {\n            static bool draw_bg = true;\n            static bool draw_fg = true;\n            ImGui::Checkbox(\"Draw in Background draw list\", &draw_bg);\n            ImGui::SameLine(); HelpMarker(\"The Background draw list will be rendered below every Dear ImGui windows.\");\n            ImGui::Checkbox(\"Draw in Foreground draw list\", &draw_fg);\n            ImGui::SameLine(); HelpMarker(\"The Foreground draw list will be rendered over every Dear ImGui windows.\");\n            ImVec2 window_pos = ImGui::GetWindowPos();\n            ImVec2 window_size = ImGui::GetWindowSize();\n            ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);\n            if (draw_bg)\n                ImGui::GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 0, 10 + 4);\n            if (draw_fg)\n                ImGui::GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 0, 10);\n            ImGui::EndTabItem();\n        }\n\n        // Demonstrate out-of-order rendering via channels splitting\n        // We use functions in ImDrawList as each draw list contains a convenience splitter,\n        // but you can also instantiate your own ImDrawListSplitter if you need to nest them.\n        if (ImGui::BeginTabItem(\"Draw Channels\"))\n        {\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            {\n                ImGui::Text(\"Blue shape is drawn first: appears in back\");\n                ImGui::Text(\"Red shape is drawn after: appears in front\");\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                draw_list->AddRectFilled(ImVec2(p0.x, p0.y), ImVec2(p0.x + 50, p0.y + 50), IM_COL32(0, 0, 255, 255)); // Blue\n                draw_list->AddRectFilled(ImVec2(p0.x + 25, p0.y + 25), ImVec2(p0.x + 75, p0.y + 75), IM_COL32(255, 0, 0, 255)); // Red\n                ImGui::Dummy(ImVec2(75, 75));\n            }\n            ImGui::Separator();\n            {\n                ImGui::Text(\"Blue shape is drawn first, into channel 1: appears in front\");\n                ImGui::Text(\"Red shape is drawn after, into channel 0: appears in back\");\n                ImVec2 p1 = ImGui::GetCursorScreenPos();\n\n                // Create 2 channels and draw a Blue shape THEN a Red shape.\n                // You can create any number of channels. Tables API use 1 channel per column in order to better batch draw calls.\n                draw_list->ChannelsSplit(2);\n                draw_list->ChannelsSetCurrent(1);\n                draw_list->AddRectFilled(ImVec2(p1.x, p1.y), ImVec2(p1.x + 50, p1.y + 50), IM_COL32(0, 0, 255, 255)); // Blue\n                draw_list->ChannelsSetCurrent(0);\n                d"
        },
        {
          "name": "imgui_draw.cpp",
          "type": "blob",
          "size": 252.06,
          "content": "// dear imgui, v1.91.7 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas: glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#pragma clang diagnostic ignored \"-Wcast-qual\"                      // warning: cast from 'const xxxx *' to 'xxx *' drops const qualifier\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"                  // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"                       // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"                  // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"                  // warning: assuming signed overflow does not occur when simplifying division / ..when changing X +- C1 cmp C2 to X cmp C2 -+ C1\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                        // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)\n//-------------------------------------------------------------------------\n\n// Compile time options:\n//#define IMGUI_STB_NAMESPACE           ImStb\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack.h\"\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\n\n#ifdef IMGUI_STB_NAMESPACE\nnamespace IMGUI_STB_NAMESPACE\n{\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration\n#pragma warning (disable: 6011)                             // (stb_rectpack) Dereferencing NULL pointer 'cur->next'.\n#pragma warning (disable: 6385)                             // (stb_truetype) Reading invalid data from 'buffer':  the readable size is '_Old_3`kernel_width' bytes, but '3' bytes may be read.\n#pragma warning (disable: 28182)                            // (stb_rectpack) Dereferencing NULL pointer. 'cur' contains the same NULL value as 'cur->next' did.\n#endif\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"        // warning: 'xxxx' defined but not used\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n#pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\n#endif\n\n#if defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]\n#pragma GCC diagnostic ignored \"-Wimplicit-fallthrough\"     // warning: this statement may fall through\n#endif\n\n#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)\n#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION          // in case the user already have an implementation in another compilation unit\n#define STBRP_STATIC\n#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)\n#define STBRP_SORT          ImQsort\n#define STB_RECT_PACK_IMPLEMENTATION\n#endif\n#ifdef IMGUI_STB_RECT_PACK_FILENAME\n#include IMGUI_STB_RECT_PACK_FILENAME\n#else\n#include \"imstb_rectpack.h\"\n#endif\n#endif\n\n#ifdef  IMGUI_ENABLE_STB_TRUETYPE\n#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)\n#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION           // in case the user already have an implementation in another compilation unit\n#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))\n#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))\n#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)\n#define STBTT_fmod(x,y)     ImFmod(x,y)\n#define STBTT_sqrt(x)       ImSqrt(x)\n#define STBTT_pow(x,y)      ImPow(x,y)\n#define STBTT_fabs(x)       ImFabs(x)\n#define STBTT_ifloor(x)     ((int)ImFloor(x))\n#define STBTT_iceil(x)      ((int)ImCeil(x))\n#define STBTT_STATIC\n#define STB_TRUETYPE_IMPLEMENTATION\n#else\n#define STBTT_DEF extern\n#endif\n#ifdef IMGUI_STB_TRUETYPE_FILENAME\n#include IMGUI_STB_TRUETYPE_FILENAME\n#else\n#include \"imstb_truetype.h\"\n#endif\n#endif\n#endif // IMGUI_ENABLE_STB_TRUETYPE\n\n#if defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#if defined(_MSC_VER)\n#pragma warning (pop)\n#endif\n\n#ifdef IMGUI_STB_NAMESPACE\n} // namespace ImStb\nusing namespace IMGUI_STB_NAMESPACE;\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Style functions\n//-----------------------------------------------------------------------------\n\nvoid ImGui::StyleColorsDark(ImGuiStyle* dst)\n{\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\n    ImVec4* colors = style->Colors;\n\n    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);\n    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);\n    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\n    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];\n    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);\n    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);\n    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];\n    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);\n    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);\n    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.50f, 0.50f, 0.50f, 0.00f);\n    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\n    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);\n    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here\n    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here\n    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);\n    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);\n    colors[ImGuiCol_NavCursor]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);\n    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);\n    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);\n}\n\nvoid ImGui::StyleColorsClassic(ImGuiStyle* dst)\n{\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\n    ImVec4* colors = style->Colors;\n\n    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.85f);\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);\n    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);\n    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);\n    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);\n    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);\n    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 0.60f);\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.10f);\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);\n    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];\n    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);\n    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);\n    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];\n    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);\n    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);\n    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.53f, 0.53f, 0.87f, 0.00f);\n    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\n    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.27f, 0.27f, 0.38f, 1.00f);\n    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.45f, 1.00f);   // Prefer using Alpha=1.0 here\n    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.26f, 0.26f, 0.28f, 1.00f);   // Prefer using Alpha=1.0 here\n    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.07f);\n    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);\n    colors[ImGuiCol_NavCursor]              = colors[ImGuiCol_HeaderHovered];\n    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);\n    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);\n    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);\n}\n\n// Those light colors are better suited with a thicker font than the default one + FrameBorder\nvoid ImGui::StyleColorsLight(ImGuiStyle* dst)\n{\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\n    ImVec4* colors = style->Colors;\n\n    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);\n    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);\n    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);\n    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\n    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 0.62f);\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.35f, 0.35f, 0.35f, 0.17f);\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\n    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];\n    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);\n    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);\n    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];\n    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);\n    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);\n    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.26f, 0.59f, 1.00f, 0.00f);\n    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);\n    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.78f, 0.87f, 0.98f, 1.00f);\n    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.57f, 0.57f, 0.64f, 1.00f);   // Prefer using Alpha=1.0 here\n    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.68f, 0.68f, 0.74f, 1.00f);   // Prefer using Alpha=1.0 here\n    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(0.30f, 0.30f, 0.30f, 0.09f);\n    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\n    colors[ImGuiCol_NavCursor]              = colors[ImGuiCol_HeaderHovered];\n    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);\n    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);\n    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImDrawList\n//-----------------------------------------------------------------------------\n\nImDrawListSharedData::ImDrawListSharedData()\n{\n    memset(this, 0, sizeof(*this));\n    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)\n    {\n        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);\n        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));\n    }\n    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);\n}\n\nvoid ImDrawListSharedData::SetCircleTessellationMaxError(float max_error)\n{\n    if (CircleSegmentMaxError == max_error)\n        return;\n\n    IM_ASSERT(max_error > 0.0f);\n    CircleSegmentMaxError = max_error;\n    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)\n    {\n        const float radius = (float)i;\n        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);\n    }\n    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);\n}\n\nImDrawList::ImDrawList(ImDrawListSharedData* shared_data)\n{\n    memset(this, 0, sizeof(*this));\n    _Data = shared_data;\n}\n\nImDrawList::~ImDrawList()\n{\n    _ClearFreeMemory();\n}\n\n// Initialize before use in a new frame. We always have a command ready in the buffer.\n// In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.\nvoid ImDrawList::_ResetForNewFrame()\n{\n    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.\n    IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);\n    IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));\n    IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));\n    if (_Splitter._Count > 1)\n        _Splitter.Merge(this);\n\n    CmdBuffer.resize(0);\n    IdxBuffer.resize(0);\n    VtxBuffer.resize(0);\n    Flags = _Data->InitialFlags;\n    memset(&_CmdHeader, 0, sizeof(_CmdHeader));\n    _VtxCurrentIdx = 0;\n    _VtxWritePtr = NULL;\n    _IdxWritePtr = NULL;\n    _ClipRectStack.resize(0);\n    _TextureIdStack.resize(0);\n    _CallbacksDataBuf.resize(0);\n    _Path.resize(0);\n    _Splitter.Clear();\n    CmdBuffer.push_back(ImDrawCmd());\n    _FringeScale = 1.0f;\n}\n\nvoid ImDrawList::_ClearFreeMemory()\n{\n    CmdBuffer.clear();\n    IdxBuffer.clear();\n    VtxBuffer.clear();\n    Flags = ImDrawListFlags_None;\n    _VtxCurrentIdx = 0;\n    _VtxWritePtr = NULL;\n    _IdxWritePtr = NULL;\n    _ClipRectStack.clear();\n    _TextureIdStack.clear();\n    _CallbacksDataBuf.clear();\n    _Path.clear();\n    _Splitter.ClearFreeMemory();\n}\n\nImDrawList* ImDrawList::CloneOutput() const\n{\n    ImDrawList* dst = IM_NEW(ImDrawList(_Data));\n    dst->CmdBuffer = CmdBuffer;\n    dst->IdxBuffer = IdxBuffer;\n    dst->VtxBuffer = VtxBuffer;\n    dst->Flags = Flags;\n    return dst;\n}\n\nvoid ImDrawList::AddDrawCmd()\n{\n    ImDrawCmd draw_cmd;\n    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()\n    draw_cmd.TextureId = _CmdHeader.TextureId;\n    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;\n    draw_cmd.IdxOffset = IdxBuffer.Size;\n\n    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);\n    CmdBuffer.push_back(draw_cmd);\n}\n\n// Pop trailing draw command (used before merging or presenting to user)\n// Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL\nvoid ImDrawList::_PopUnusedDrawCmd()\n{\n    while (CmdBuffer.Size > 0)\n    {\n        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)\n            return;// break;\n        CmdBuffer.pop_back();\n    }\n}\n\nvoid ImDrawList::AddCallback(ImDrawCallback callback, void* userdata, size_t userdata_size)\n{\n    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);\n    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    IM_ASSERT(curr_cmd->UserCallback == NULL);\n    if (curr_cmd->ElemCount != 0)\n    {\n        AddDrawCmd();\n        curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    }\n\n    curr_cmd->UserCallback = callback;\n    if (userdata_size == 0)\n    {\n        // Store user data directly in command (no indirection)\n        curr_cmd->UserCallbackData = userdata;\n        curr_cmd->UserCallbackDataSize = 0;\n        curr_cmd->UserCallbackDataOffset = -1;\n    }\n    else\n    {\n        // Copy and store user data in a buffer\n        IM_ASSERT(userdata != NULL);\n        IM_ASSERT(userdata_size < (1u << 31));\n        curr_cmd->UserCallbackData = NULL; // Will be resolved during Render()\n        curr_cmd->UserCallbackDataSize = (int)userdata_size;\n        curr_cmd->UserCallbackDataOffset = _CallbacksDataBuf.Size;\n        _CallbacksDataBuf.resize(_CallbacksDataBuf.Size + (int)userdata_size);\n        memcpy(_CallbacksDataBuf.Data + (size_t)curr_cmd->UserCallbackDataOffset, userdata, userdata_size);\n    }\n\n    AddDrawCmd(); // Force a new command after us (see comment below)\n}\n\n// Compare ClipRect, TextureId and VtxOffset with a single memcmp()\n#define ImDrawCmd_HeaderSize                            (offsetof(ImDrawCmd, VtxOffset) + sizeof(unsigned int))\n#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset\n#define ImDrawCmd_HeaderCopy(CMD_DST, CMD_SRC)          (memcpy(CMD_DST, CMD_SRC, ImDrawCmd_HeaderSize))    // Copy ClipRect, TextureId, VtxOffset\n#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)\n\n// Try to merge two last draw commands\nvoid ImDrawList::_TryMergeDrawCmds()\n{\n    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);\n    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    ImDrawCmd* prev_cmd = curr_cmd - 1;\n    if (ImDrawCmd_HeaderCompare(curr_cmd, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && curr_cmd->UserCallback == NULL && prev_cmd->UserCallback == NULL)\n    {\n        prev_cmd->ElemCount += curr_cmd->ElemCount;\n        CmdBuffer.pop_back();\n    }\n}\n\n// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.\n// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.\nvoid ImDrawList::_OnChangedClipRect()\n{\n    // If current command is used with different settings we need to add a new command\n    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);\n    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)\n    {\n        AddDrawCmd();\n        return;\n    }\n    IM_ASSERT(curr_cmd->UserCallback == NULL);\n\n    // Try to merge with previous command if it matches, else use current command\n    ImDrawCmd* prev_cmd = curr_cmd - 1;\n    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)\n    {\n        CmdBuffer.pop_back();\n        return;\n    }\n    curr_cmd->ClipRect = _CmdHeader.ClipRect;\n}\n\nvoid ImDrawList::_OnChangedTextureID()\n{\n    // If current command is used with different settings we need to add a new command\n    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);\n    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)\n    {\n        AddDrawCmd();\n        return;\n    }\n    IM_ASSERT(curr_cmd->UserCallback == NULL);\n\n    // Try to merge with previous command if it matches, else use current command\n    ImDrawCmd* prev_cmd = curr_cmd - 1;\n    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)\n    {\n        CmdBuffer.pop_back();\n        return;\n    }\n    curr_cmd->TextureId = _CmdHeader.TextureId;\n}\n\nvoid ImDrawList::_OnChangedVtxOffset()\n{\n    // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.\n    _VtxCurrentIdx = 0;\n    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);\n    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349\n    if (curr_cmd->ElemCount != 0)\n    {\n        AddDrawCmd();\n        return;\n    }\n    IM_ASSERT(curr_cmd->UserCallback == NULL);\n    curr_cmd->VtxOffset = _CmdHeader.VtxOffset;\n}\n\nint ImDrawList::_CalcCircleAutoSegmentCount(float radius) const\n{\n    // Automatic segment count\n    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy\n    if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))\n        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value\n    else\n        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);\n}\n\n// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\nvoid ImDrawList::PushClipRect(const ImVec2& cr_min, const ImVec2& cr_max, bool intersect_with_current_clip_rect)\n{\n    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);\n    if (intersect_with_current_clip_rect)\n    {\n        ImVec4 current = _CmdHeader.ClipRect;\n        if (cr.x < current.x) cr.x = current.x;\n        if (cr.y < current.y) cr.y = current.y;\n        if (cr.z > current.z) cr.z = current.z;\n        if (cr.w > current.w) cr.w = current.w;\n    }\n    cr.z = ImMax(cr.x, cr.z);\n    cr.w = ImMax(cr.y, cr.w);\n\n    _ClipRectStack.push_back(cr);\n    _CmdHeader.ClipRect = cr;\n    _OnChangedClipRect();\n}\n\nvoid ImDrawList::PushClipRectFullScreen()\n{\n    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));\n}\n\nvoid ImDrawList::PopClipRect()\n{\n    _ClipRectStack.pop_back();\n    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];\n    _OnChangedClipRect();\n}\n\nvoid ImDrawList::PushTextureID(ImTextureID texture_id)\n{\n    _TextureIdStack.push_back(texture_id);\n    _CmdHeader.TextureId = texture_id;\n    _OnChangedTextureID();\n}\n\nvoid ImDrawList::PopTextureID()\n{\n    _TextureIdStack.pop_back();\n    _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];\n    _OnChangedTextureID();\n}\n\n// This is used by ImGui::PushFont()/PopFont(). It works because we never use _TextureIdStack[] elsewhere than in PushTextureID()/PopTextureID().\nvoid ImDrawList::_SetTextureID(ImTextureID texture_id)\n{\n    if (_CmdHeader.TextureId == texture_id)\n        return;\n    _CmdHeader.TextureId = texture_id;\n    _OnChangedTextureID();\n}\n\n// Reserve space for a number of vertices and indices.\n// You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or\n// submit the intermediate results. PrimUnreserve() can be used to release unused allocations.\nvoid ImDrawList::PrimReserve(int idx_count, int vtx_count)\n{\n    // Large mesh support (when enabled)\n    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);\n    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))\n    {\n        // FIXME: In theory we should be testing that vtx_count <64k here.\n        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us\n        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.\n        _CmdHeader.VtxOffset = VtxBuffer.Size;\n        _OnChangedVtxOffset();\n    }\n\n    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    draw_cmd->ElemCount += idx_count;\n\n    int vtx_buffer_old_size = VtxBuffer.Size;\n    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);\n    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;\n\n    int idx_buffer_old_size = IdxBuffer.Size;\n    IdxBuffer.resize(idx_buffer_old_size + idx_count);\n    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;\n}\n\n// Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().\nvoid ImDrawList::PrimUnreserve(int idx_count, int vtx_count)\n{\n    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);\n\n    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];\n    draw_cmd->ElemCount -= idx_count;\n    VtxBuffer.shrink(VtxBuffer.Size - vtx_count);\n    IdxBuffer.shrink(IdxBuffer.Size - idx_count);\n}\n\n// Fully unrolled with inline call to keep our debug builds decently fast.\nvoid ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)\n{\n    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;\n    _VtxWritePtr += 4;\n    _VtxCurrentIdx += 4;\n    _IdxWritePtr += 6;\n}\n\nvoid ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)\n{\n    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;\n    _VtxWritePtr += 4;\n    _VtxCurrentIdx += 4;\n    _IdxWritePtr += 6;\n}\n\nvoid ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)\n{\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;\n    _VtxWritePtr += 4;\n    _VtxCurrentIdx += 4;\n    _IdxWritePtr += 6;\n}\n\n// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superfluous function calls to optimize debug/non-inlined builds.\n// - Those macros expects l-values and need to be used as their own statement.\n// - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.\n#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0\n#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)\n#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0\n\n// TODO: Thickness anti-aliased lines cap are missing their AA fringe.\n// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.\nvoid ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness)\n{\n    if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)\n        return;\n\n    const bool closed = (flags & ImDrawFlags_Closed) != 0;\n    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;\n    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw\n    const bool thick_line = (thickness > _FringeScale);\n\n    if (Flags & ImDrawListFlags_AntiAliasedLines)\n    {\n        // Anti-aliased stroke\n        const float AA_SIZE = _FringeScale;\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\n\n        // Thicknesses <1.0 should behave like thickness 1.0\n        thickness = ImMax(thickness, 1.0f);\n        const int integer_thickness = (int)thickness;\n        const float fractional_thickness = thickness - integer_thickness;\n\n        // Do we want to draw this line using a texture?\n        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.\n        // - If AA_SIZE is not 1.0f we cannot use the texture path.\n        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);\n\n        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off\n        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));\n\n        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);\n        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);\n        PrimReserve(idx_count, vtx_count);\n\n        // Temporary buffer\n        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point\n        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));\n        ImVec2* temp_normals = _Data->TempBuffer.Data;\n        ImVec2* temp_points = temp_normals + points_count;\n\n        // Calculate normals (tangents) for each line segment\n        for (int i1 = 0; i1 < count; i1++)\n        {\n            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;\n            float dx = points[i2].x - points[i1].x;\n            float dy = points[i2].y - points[i1].y;\n            IM_NORMALIZE2F_OVER_ZERO(dx, dy);\n            temp_normals[i1].x = dy;\n            temp_normals[i1].y = -dx;\n        }\n        if (!closed)\n            temp_normals[points_count - 1] = temp_normals[points_count - 2];\n\n        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point\n        if (use_texture || !thick_line)\n        {\n            // [PATH 1] Texture-based lines (thick or non-thick)\n            // [PATH 2] Non texture-based lines (non-thick)\n\n            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus \"one pixel\" for AA.\n            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture\n            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.\n            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to\n            //   allow scaling geometry while preserving one-screen-pixel AA fringe).\n            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;\n\n            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend\n            if (!closed)\n            {\n                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;\n                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;\n                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;\n                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;\n            }\n\n            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges\n            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)\n            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.\n            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment\n            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment\n            {\n                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment\n                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment\n\n                // Average normals\n                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;\n                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;\n                IM_FIXNORMAL2F(dm_x, dm_y);\n                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area\n                dm_y *= half_draw_size;\n\n                // Add temporary vertexes for the outer edges\n                ImVec2* out_vtx = &temp_points[i2 * 2];\n                out_vtx[0].x = points[i2].x + dm_x;\n                out_vtx[0].y = points[i2].y + dm_y;\n                out_vtx[1].x = points[i2].x - dm_x;\n                out_vtx[1].y = points[i2].y - dm_y;\n\n                if (use_texture)\n                {\n                    // Add indices for two triangles\n                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri\n                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri\n                    _IdxWritePtr += 6;\n                }\n                else\n                {\n                    // Add indexes for four triangles\n                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1\n                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2\n                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1\n                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2\n                    _IdxWritePtr += 12;\n                }\n\n                idx1 = idx2;\n            }\n\n            // Add vertexes for each point on the line\n            if (use_texture)\n            {\n                // If we're using textures we only need to emit the left/right edge vertices\n                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];\n                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!\n                {\n                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];\n                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()\n                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;\n                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;\n                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;\n                }*/\n                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);\n                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);\n                for (int i = 0; i < points_count; i++)\n                {\n                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge\n                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge\n                    _VtxWritePtr += 2;\n                }\n            }\n            else\n            {\n                // If we're not using a texture, we need the center vertex as well\n                for (int i = 0; i < points_count; i++)\n                {\n                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line\n                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge\n                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge\n                    _VtxWritePtr += 3;\n                }\n            }\n        }\n        else\n        {\n            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point\n            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;\n\n            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend\n            if (!closed)\n            {\n                const int points_last = points_count - 1;\n                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);\n                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);\n                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);\n                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);\n                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);\n                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);\n                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);\n                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);\n            }\n\n            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges\n            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)\n            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.\n            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment\n            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment\n            {\n                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment\n                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment\n\n                // Average normals\n                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;\n                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;\n                IM_FIXNORMAL2F(dm_x, dm_y);\n                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);\n                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);\n                float dm_in_x = dm_x * half_inner_thickness;\n                float dm_in_y = dm_y * half_inner_thickness;\n\n                // Add temporary vertices\n                ImVec2* out_vtx = &temp_points[i2 * 4];\n                out_vtx[0].x = points[i2].x + dm_out_x;\n                out_vtx[0].y = points[i2].y + dm_out_y;\n                out_vtx[1].x = points[i2].x + dm_in_x;\n                out_vtx[1].y = points[i2].y + dm_in_y;\n                out_vtx[2].x = points[i2].x - dm_in_x;\n                out_vtx[2].y = points[i2].y - dm_in_y;\n                out_vtx[3].x = points[i2].x - dm_out_x;\n                out_vtx[3].y = points[i2].y - dm_out_y;\n\n                // Add indexes\n                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);\n                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);\n                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);\n                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);\n                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);\n                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);\n                _IdxWritePtr += 18;\n\n                idx1 = idx2;\n            }\n\n            // Add vertices\n            for (int i = 0; i < points_count; i++)\n            {\n                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;\n                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;\n                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;\n                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;\n                _VtxWritePtr += 4;\n            }\n        }\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\n    }\n    else\n    {\n        // [PATH 4] Non texture-based, Non anti-aliased lines\n        const int idx_count = count * 6;\n        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges\n        PrimReserve(idx_count, vtx_count);\n\n        for (int i1 = 0; i1 < count; i1++)\n        {\n            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;\n            const ImVec2& p1 = points[i1];\n            const ImVec2& p2 = points[i2];\n\n            float dx = p2.x - p1.x;\n            float dy = p2.y - p1.y;\n            IM_NORMALIZE2F_OVER_ZERO(dx, dy);\n            dx *= (thickness * 0.5f);\n            dy *= (thickness * 0.5f);\n\n            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;\n            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;\n            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;\n            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;\n            _VtxWritePtr += 4;\n\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);\n            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);\n            _IdxWritePtr += 6;\n            _VtxCurrentIdx += 4;\n        }\n    }\n}\n\n// - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.\n// - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have \"inward\" anti-aliasing.\nvoid ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)\n{\n    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)\n        return;\n\n    const ImVec2 uv = _Data->TexUvWhitePixel;\n\n    if (Flags & ImDrawListFlags_AntiAliasedFill)\n    {\n        // Anti-aliased Fill\n        const float AA_SIZE = _FringeScale;\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\n        const int idx_count = (points_count - 2)*3 + points_count * 6;\n        const int vtx_count = (points_count * 2);\n        PrimReserve(idx_count, vtx_count);\n\n        // Add indexes for fill\n        unsigned int vtx_inner_idx = _VtxCurrentIdx;\n        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;\n        for (int i = 2; i < points_count; i++)\n        {\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));\n            _IdxWritePtr += 3;\n        }\n\n        // Compute normals\n        _Data->TempBuffer.reserve_discard(points_count);\n        ImVec2* temp_normals = _Data->TempBuffer.Data;\n        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)\n        {\n            const ImVec2& p0 = points[i0];\n            const ImVec2& p1 = points[i1];\n            float dx = p1.x - p0.x;\n            float dy = p1.y - p0.y;\n            IM_NORMALIZE2F_OVER_ZERO(dx, dy);\n            temp_normals[i0].x = dy;\n            temp_normals[i0].y = -dx;\n        }\n\n        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)\n        {\n            // Average normals\n            const ImVec2& n0 = temp_normals[i0];\n            const ImVec2& n1 = temp_normals[i1];\n            float dm_x = (n0.x + n1.x) * 0.5f;\n            float dm_y = (n0.y + n1.y) * 0.5f;\n            IM_FIXNORMAL2F(dm_x, dm_y);\n            dm_x *= AA_SIZE * 0.5f;\n            dm_y *= AA_SIZE * 0.5f;\n\n            // Add vertices\n            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner\n            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer\n            _VtxWritePtr += 2;\n\n            // Add indexes for fringes\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));\n            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));\n            _IdxWritePtr += 6;\n        }\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\n    }\n    else\n    {\n        // Non Anti-aliased Fill\n        const int idx_count = (points_count - 2)*3;\n        const int vtx_count = points_count;\n        PrimReserve(idx_count, vtx_count);\n        for (int i = 0; i < vtx_count; i++)\n        {\n            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\n            _VtxWritePtr++;\n        }\n        for (int i = 2; i < points_count; i++)\n        {\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);\n            _IdxWritePtr += 3;\n        }\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\n    }\n}\n\nvoid ImDrawList::_PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step)\n{\n    if (radius < 0.5f)\n    {\n        _Path.push_back(center);\n        return;\n    }\n\n    // Calculate arc auto segment step size\n    if (a_step <= 0)\n        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);\n\n    // Make sure we never do steps larger than one quarter of the circle\n    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);\n\n    const int sample_range = ImAbs(a_max_sample - a_min_sample);\n    const int a_next_step = a_step;\n\n    int samples = sample_range + 1;\n    bool extra_max_sample = false;\n    if (a_step > 1)\n    {\n        samples            = sample_range / a_step + 1;\n        const int overstep = sample_range % a_step;\n\n        if (overstep > 0)\n        {\n            extra_max_sample = true;\n            samples++;\n\n            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,\n            // distribute first step range evenly between them by reducing first step size.\n            if (sample_range > 0)\n                a_step -= (a_step - overstep) / 2;\n        }\n    }\n\n    _Path.resize(_Path.Size + samples);\n    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);\n\n    int sample_index = a_min_sample;\n    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)\n    {\n        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n        if (sample_index < 0)\n            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n    }\n\n    if (a_max_sample >= a_min_sample)\n    {\n        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)\n        {\n            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more\n            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)\n                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n\n            const ImVec2 s = _Data->ArcFastVtx[sample_index];\n            out_ptr->x = center.x + s.x * radius;\n            out_ptr->y = center.y + s.y * radius;\n            out_ptr++;\n        }\n    }\n    else\n    {\n        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)\n        {\n            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more\n            if (sample_index < 0)\n                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n\n            const ImVec2 s = _Data->ArcFastVtx[sample_index];\n            out_ptr->x = center.x + s.x * radius;\n            out_ptr->y = center.y + s.y * radius;\n            out_ptr++;\n        }\n    }\n\n    if (extra_max_sample)\n    {\n        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n        if (normalized_max_sample < 0)\n            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n\n        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];\n        out_ptr->x = center.x + s.x * radius;\n        out_ptr->y = center.y + s.y * radius;\n        out_ptr++;\n    }\n\n    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);\n}\n\nvoid ImDrawList::_PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)\n{\n    if (radius < 0.5f)\n    {\n        _Path.push_back(center);\n        return;\n    }\n\n    // Note that we are adding a point at both a_min and a_max.\n    // If you are trying to draw a full closed circle you don't want the overlapping points!\n    _Path.reserve(_Path.Size + (num_segments + 1));\n    for (int i = 0; i <= num_segments; i++)\n    {\n        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);\n        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));\n    }\n}\n\n// 0: East, 3: South, 6: West, 9: North, 12: East\nvoid ImDrawList::PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12)\n{\n    if (radius < 0.5f)\n    {\n        _Path.push_back(center);\n        return;\n    }\n    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);\n}\n\nvoid ImDrawList::PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)\n{\n    if (radius < 0.5f)\n    {\n        _Path.push_back(center);\n        return;\n    }\n\n    if (num_segments > 0)\n    {\n        _PathArcToN(center, radius, a_min, a_max, num_segments);\n        return;\n    }\n\n    // Automatic segment count\n    if (radius <= _Data->ArcFastRadiusCutoff)\n    {\n        const bool a_is_reverse = a_max < a_min;\n\n        // We are going to use precomputed values for mid samples.\n        // Determine first and last sample in lookup table that belong to the arc.\n        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);\n        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);\n\n        const int a_min_sample = a_is_reverse ? (int)ImFloor(a_min_sample_f) : (int)ImCeil(a_min_sample_f);\n        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloor(a_max_sample_f);\n        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);\n\n        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;\n        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;\n        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;\n\n        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));\n        if (a_emit_start)\n            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));\n        if (a_mid_samples > 0)\n            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);\n        if (a_emit_end)\n            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));\n    }\n    else\n    {\n        const float arc_length = ImAbs(a_max - a_min);\n        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);\n        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));\n        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);\n    }\n}\n\nvoid ImDrawList::PathEllipticalArcTo(const ImVec2& center, const ImVec2& radius, float rot, float a_min, float a_max, int num_segments)\n{\n    if (num_segments <= 0)\n        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.\n\n    _Path.reserve(_Path.Size + (num_segments + 1));\n\n    const float cos_rot = ImCos(rot);\n    const float sin_rot = ImSin(rot);\n    for (int i = 0; i <= num_segments; i++)\n    {\n        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);\n        ImVec2 point(ImCos(a) * radius.x, ImSin(a) * radius.y);\n        const ImVec2 rel((point.x * cos_rot) - (point.y * sin_rot), (point.x * sin_rot) + (point.y * cos_rot));\n        point.x = rel.x + center.x;\n        point.y = rel.y + center.y;\n        _Path.push_back(point);\n    }\n}\n\nImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t)\n{\n    float u = 1.0f - t;\n    float w1 = u * u * u;\n    float w2 = 3 * u * u * t;\n    float w3 = 3 * u * t * t;\n    float w4 = t * t * t;\n    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);\n}\n\nImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t)\n{\n    float u = 1.0f - t;\n    float w1 = u * u;\n    float w2 = 2 * u * t;\n    float w3 = t * t;\n    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y);\n}\n\n// Closely mimics ImBezierCubicClosestPointCasteljau() in imgui.cpp\nstatic void PathBezierCubicCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)\n{\n    float dx = x4 - x1;\n    float dy = y4 - y1;\n    float d2 = (x2 - x4) * dy - (y2 - y4) * dx;\n    float d3 = (x3 - x4) * dy - (y3 - y4) * dx;\n    d2 = (d2 >= 0) ? d2 : -d2;\n    d3 = (d3 >= 0) ? d3 : -d3;\n    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))\n    {\n        path->push_back(ImVec2(x4, y4));\n    }\n    else if (level < 10)\n    {\n        float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;\n        float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;\n        float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;\n        float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;\n        float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;\n        float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;\n        PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);\n        PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);\n    }\n}\n\nstatic void PathBezierQuadraticCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float tess_tol, int level)\n{\n    float dx = x3 - x1, dy = y3 - y1;\n    float det = (x2 - x3) * dy - (y2 - y3) * dx;\n    if (det * det * 4.0f < tess_tol * (dx * dx + dy * dy))\n    {\n        path->push_back(ImVec2(x3, y3));\n    }\n    else if (level < 10)\n    {\n        float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;\n        float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;\n        float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;\n        PathBezierQuadraticCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, tess_tol, level + 1);\n        PathBezierQuadraticCurveToCasteljau(path, x123, y123, x23, y23, x3, y3, tess_tol, level + 1);\n    }\n}\n\nvoid ImDrawList::PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)\n{\n    ImVec2 p1 = _Path.back();\n    if (num_segments == 0)\n    {\n        IM_ASSERT(_Data->CurveTessellationTol > 0.0f);\n        PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated\n    }\n    else\n    {\n        float t_step = 1.0f / (float)num_segments;\n        for (int i_step = 1; i_step <= num_segments; i_step++)\n            _Path.push_back(ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step));\n    }\n}\n\nvoid ImDrawList::PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments)\n{\n    ImVec2 p1 = _Path.back();\n    if (num_segments == 0)\n    {\n        IM_ASSERT(_Data->CurveTessellationTol > 0.0f);\n        PathBezierQuadraticCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, _Data->CurveTessellationTol, 0);// Auto-tessellated\n    }\n    else\n    {\n        float t_step = 1.0f / (float)num_segments;\n        for (int i_step = 1; i_step <= num_segments; i_step++)\n            _Path.push_back(ImBezierQuadraticCalc(p1, p2, p3, t_step * i_step));\n    }\n}\n\nstatic inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags)\n{\n    /*\n    IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)\n    // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)\n    if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }\n    // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.\n    if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }\n    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'\n#endif\n    */\n    // If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.\n    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.\n    // See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in \"API BREAKING CHANGES\" section.\n    IM_ASSERT((flags & 0x0F) == 0 && \"Misuse of legacy hardcoded ImDrawCornerFlags values!\");\n\n    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)\n        flags |= ImDrawFlags_RoundCornersAll;\n\n    return flags;\n}\n\nvoid ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawFlags flags)\n{\n    if (rounding >= 0.5f)\n    {\n        flags = FixRectCornerFlags(flags);\n        rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);\n        rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);\n    }\n    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)\n    {\n        PathLineTo(a);\n        PathLineTo(ImVec2(b.x, a.y));\n        PathLineTo(b);\n        PathLineTo(ImVec2(a.x, b.y));\n    }\n    else\n    {\n        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;\n        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;\n        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;\n        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;\n        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);\n        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);\n        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);\n        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);\n    }\n}\n\nvoid ImDrawList::AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n    PathLineTo(p1 + ImVec2(0.5f, 0.5f));\n    PathLineTo(p2 + ImVec2(0.5f, 0.5f));\n    PathStroke(col, 0, thickness);\n}\n\n// p_min = upper-left, p_max = lower-right\n// Note we don't render 1 pixels sized rectangles properly.\nvoid ImDrawList::AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n    if (Flags & ImDrawListFlags_AntiAliasedLines)\n        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);\n    else\n        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.\n    PathStroke(col, ImDrawFlags_Closed, thickness);\n}\n\nvoid ImDrawList::AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)\n    {\n        PrimReserve(6, 4);\n        PrimRect(p_min, p_max, col);\n    }\n    else\n    {\n        PathRect(p_min, p_max, rounding, flags);\n        PathFillConvex(col);\n    }\n}\n\n// p_min = upper-left, p_max = lower-right\nvoid ImDrawList::AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)\n{\n    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)\n        return;\n\n    const ImVec2 uv = _Data->TexUvWhitePixel;\n    PrimReserve(6, 4);\n    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));\n    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));\n    PrimWriteVtx(p_min, uv, col_upr_left);\n    PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);\n    PrimWriteVtx(p_max, uv, col_bot_right);\n    PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);\n}\n\nvoid ImDrawList::AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    PathLineTo(p1);\n    PathLineTo(p2);\n    PathLineTo(p3);\n    PathLineTo(p4);\n    PathStroke(col, ImDrawFlags_Closed, thickness);\n}\n\nvoid ImDrawList::AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    PathLineTo(p1);\n    PathLineTo(p2);\n    PathLineTo(p3);\n    PathLineTo(p4);\n    PathFillConvex(col);\n}\n\nvoid ImDrawList::AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    PathLineTo(p1);\n    PathLineTo(p2);\n    PathLineTo(p3);\n    PathStroke(col, ImDrawFlags_Closed, thickness);\n}\n\nvoid ImDrawList::AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    PathLineTo(p1);\n    PathLineTo(p2);\n    PathLineTo(p3);\n    PathFillConvex(col);\n}\n\nvoid ImDrawList::AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)\n        return;\n\n    if (num_segments <= 0)\n    {\n        // Use arc with automatic segment count\n        _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);\n        _Path.Size--;\n    }\n    else\n    {\n        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)\n        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);\n\n        // Because we are filling a closed shape we remove 1 from the count of segments/points\n        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;\n        PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);\n    }\n\n    PathStroke(col, ImDrawFlags_Closed, thickness);\n}\n\nvoid ImDrawList::AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)\n{\n    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)\n        return;\n\n    if (num_segments <= 0)\n    {\n        // Use arc with automatic segment count\n        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);\n        _Path.Size--;\n    }\n    else\n    {\n        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)\n        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);\n\n        // Because we are filling a closed shape we remove 1 from the count of segments/points\n        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;\n        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);\n    }\n\n    PathFillConvex(col);\n}\n\n// Guaranteed to honor 'num_segments'\nvoid ImDrawList::AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)\n        return;\n\n    // Because we are filling a closed shape we remove 1 from the count of segments/points\n    const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;\n    PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);\n    PathStroke(col, ImDrawFlags_Closed, thickness);\n}\n\n// Guaranteed to honor 'num_segments'\nvoid ImDrawList::AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)\n{\n    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)\n        return;\n\n    // Because we are filling a closed shape we remove 1 from the count of segments/points\n    const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;\n    PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);\n    PathFillConvex(col);\n}\n\n// Ellipse\nvoid ImDrawList::AddEllipse(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot, int num_segments, float thickness)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    if (num_segments <= 0)\n        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.\n\n    // Because we are filling a closed shape we remove 1 from the count of segments/points\n    const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;\n    PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);\n    PathStroke(col, true, thickness);\n}\n\nvoid ImDrawList::AddEllipseFilled(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot, int num_segments)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    if (num_segments <= 0)\n        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.\n\n    // Because we are filling a closed shape we remove 1 from the count of segments/points\n    const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;\n    PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);\n    PathFillConvex(col);\n}\n\n// Cubic Bezier takes 4 controls points\nvoid ImDrawList::AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    PathLineTo(p1);\n    PathBezierCubicCurveTo(p2, p3, p4, num_segments);\n    PathStroke(col, 0, thickness);\n}\n\n// Quadratic Bezier takes 3 controls points\nvoid ImDrawList::AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    PathLineTo(p1);\n    PathBezierQuadraticCurveTo(p2, p3, num_segments);\n    PathStroke(col, 0, thickness);\n}\n\nvoid ImDrawList::AddText(ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    // Accept null ranges\n    if (text_begin == text_end || text_begin[0] == 0)\n        return;\n    if (text_end == NULL)\n        text_end = text_begin + strlen(text_begin);\n\n    // Pull default font/size from the shared ImDrawListSharedData instance\n    if (font == NULL)\n        font = _Data->Font;\n    if (font_size == 0.0f)\n        font_size = _Data->FontSize;\n\n    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.\n\n    ImVec4 clip_rect = _CmdHeader.ClipRect;\n    if (cpu_fine_clip_rect)\n    {\n        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);\n        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);\n        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);\n        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);\n    }\n    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);\n}\n\nvoid ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)\n{\n    AddText(NULL, 0.0f, pos, col, text_begin, text_end);\n}\n\nvoid ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;\n    if (push_texture_id)\n        PushTextureID(user_texture_id);\n\n    PrimReserve(6, 4);\n    PrimRectUV(p_min, p_max, uv_min, uv_max, col);\n\n    if (push_texture_id)\n        PopTextureID();\n}\n\nvoid ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1, const ImVec2& uv2, const ImVec2& uv3, const ImVec2& uv4, ImU32 col)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;\n    if (push_texture_id)\n        PushTextureID(user_texture_id);\n\n    PrimReserve(6, 4);\n    PrimQuadUV(p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);\n\n    if (push_texture_id)\n        PopTextureID();\n}\n\nvoid ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags)\n{\n    if ((col & IM_COL32_A_MASK) == 0)\n        return;\n\n    flags = FixRectCornerFlags(flags);\n    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)\n    {\n        AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);\n        return;\n    }\n\n    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;\n    if (push_texture_id)\n        PushTextureID(user_texture_id);\n\n    int vert_start_idx = VtxBuffer.Size;\n    PathRect(p_min, p_max, rounding, flags);\n    PathFillConvex(col);\n    int vert_end_idx = VtxBuffer.Size;\n    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);\n\n    if (push_texture_id)\n        PopTextureID();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n//-----------------------------------------------------------------------------\n// Triangulate concave polygons. Based on \"Triangulation by Ear Clipping\" paper, O(N^2) complexity.\n// Reference: https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n// Provided as a convenience for user but not used by main library.\n//-----------------------------------------------------------------------------\n// - ImTriangulator [Internal]\n// - AddConcavePolyFilled()\n//-----------------------------------------------------------------------------\n\nenum ImTriangulatorNodeType\n{\n    ImTriangulatorNodeType_Convex,\n    ImTriangulatorNodeType_Ear,\n    ImTriangulatorNodeType_Reflex\n};\n\nstruct ImTriangulatorNode\n{\n    ImTriangulatorNodeType  Type;\n    int                     Index;\n    ImVec2                  Pos;\n    ImTriangulatorNode*     Next;\n    ImTriangulatorNode*     Prev;\n\n    void    Unlink()        { Next->Prev = Prev; Prev->Next = Next; }\n};\n\nstruct ImTriangulatorNodeSpan\n{\n    ImTriangulatorNode**    Data = NULL;\n    int                     Size = 0;\n\n    void    push_back(ImTriangulatorNode* node) { Data[Size++] = node; }\n    void    find_erase_unsorted(int idx)        { for (int i = Size - 1; i >= 0; i--) if (Data[i]->Index == idx) { Data[i] = Data[Size - 1]; Size--; return; } }\n};\n\nstruct ImTriangulator\n{\n    static int EstimateTriangleCount(int points_count)      { return (points_count < 3) ? 0 : points_count - 2; }\n    static int EstimateScratchBufferSize(int points_count)  { return sizeof(ImTriangulatorNode) * points_count + sizeof(ImTriangulatorNode*) * points_count * 2; }\n\n    void    Init(const ImVec2* points, int points_count, void* scratch_buffer);\n    void    GetNextTriangle(unsigned int out_triangle[3]);     // Return relative indexes for next triangle\n\n    // Internal functions\n    void    BuildNodes(const ImVec2* points, int points_count);\n    void    BuildReflexes();\n    void    BuildEars();\n    void    FlipNodeList();\n    bool    IsEar(int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2) const;\n    void    ReclassifyNode(ImTriangulatorNode* node);\n\n    // Internal members\n    int                     _TrianglesLeft = 0;\n    ImTriangulatorNode*     _Nodes = NULL;\n    ImTriangulatorNodeSpan  _Ears;\n    ImTriangulatorNodeSpan  _Reflexes;\n};\n\n// Distribute storage for nodes, ears and reflexes.\n// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer\n// (this would require first building reflexes to bail to convex if empty, without even building nodes)\nvoid ImTriangulator::Init(const ImVec2* points, int points_count, void* scratch_buffer)\n{\n    IM_ASSERT(scratch_buffer != NULL && points_count >= 3);\n    _TrianglesLeft = EstimateTriangleCount(points_count);\n    _Nodes         = (ImTriangulatorNode*)scratch_buffer;                          // points_count x Node\n    _Ears.Data     = (ImTriangulatorNode**)(_Nodes + points_count);                // points_count x Node*\n    _Reflexes.Data = (ImTriangulatorNode**)(_Nodes + points_count) + points_count; // points_count x Node*\n    BuildNodes(points, points_count);\n    BuildReflexes();\n    BuildEars();\n}\n\nvoid ImTriangulator::BuildNodes(const ImVec2* points, int points_count)\n{\n    for (int i = 0; i < points_count; i++)\n    {\n        _Nodes[i].Type = ImTriangulatorNodeType_Convex;\n        _Nodes[i].Index = i;\n        _Nodes[i].Pos = points[i];\n        _Nodes[i].Next = _Nodes + i + 1;\n        _Nodes[i].Prev = _Nodes + i - 1;\n    }\n    _Nodes[0].Prev = _Nodes + points_count - 1;\n    _Nodes[points_count - 1].Next = _Nodes;\n}\n\nvoid ImTriangulator::BuildReflexes()\n{\n    ImTriangulatorNode* n1 = _Nodes;\n    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)\n    {\n        if (ImTriangleIsClockwise(n1->Prev->Pos, n1->Pos, n1->Next->Pos))\n            continue;\n        n1->Type = ImTriangulatorNodeType_Reflex;\n        _Reflexes.push_back(n1);\n    }\n}\n\nvoid ImTriangulator::BuildEars()\n{\n    ImTriangulatorNode* n1 = _Nodes;\n    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)\n    {\n        if (n1->Type != ImTriangulatorNodeType_Convex)\n            continue;\n        if (!IsEar(n1->Prev->Index, n1->Index, n1->Next->Index, n1->Prev->Pos, n1->Pos, n1->Next->Pos))\n            continue;\n        n1->Type = ImTriangulatorNodeType_Ear;\n        _Ears.push_back(n1);\n    }\n}\n\nvoid ImTriangulator::GetNextTriangle(unsigned int out_triangle[3])\n{\n    if (_Ears.Size == 0)\n    {\n        FlipNodeList();\n\n        ImTriangulatorNode* node = _Nodes;\n        for (int i = _TrianglesLeft; i >= 0; i--, node = node->Next)\n            node->Type = ImTriangulatorNodeType_Convex;\n        _Reflexes.Size = 0;\n        BuildReflexes();\n        BuildEars();\n\n        // If we still don't have ears, it means geometry is degenerated.\n        if (_Ears.Size == 0)\n        {\n            // Return first triangle available, mimicking the behavior of convex fill.\n            IM_ASSERT(_TrianglesLeft > 0); // Geometry is degenerated\n            _Ears.Data[0] = _Nodes;\n            _Ears.Size    = 1;\n        }\n    }\n\n    ImTriangulatorNode* ear = _Ears.Data[--_Ears.Size];\n    out_triangle[0] = ear->Prev->Index;\n    out_triangle[1] = ear->Index;\n    out_triangle[2] = ear->Next->Index;\n\n    ear->Unlink();\n    if (ear == _Nodes)\n        _Nodes = ear->Next;\n\n    ReclassifyNode(ear->Prev);\n    ReclassifyNode(ear->Next);\n    _TrianglesLeft--;\n}\n\nvoid ImTriangulator::FlipNodeList()\n{\n    ImTriangulatorNode* prev = _Nodes;\n    ImTriangulatorNode* temp = _Nodes;\n    ImTriangulatorNode* current = _Nodes->Next;\n    prev->Next = prev;\n    prev->Prev = prev;\n    while (current != _Nodes)\n    {\n        temp = current->Next;\n\n        current->Next = prev;\n        prev->Prev = current;\n        _Nodes->Next = current;\n        current->Prev = _Nodes;\n\n        prev = current;\n        current = temp;\n    }\n    _Nodes = prev;\n}\n\n// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)\nbool ImTriangulator::IsEar(int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2) const\n{\n    ImTriangulatorNode** p_end = _Reflexes.Data + _Reflexes.Size;\n    for (ImTriangulatorNode** p = _Reflexes.Data; p < p_end; p++)\n    {\n        ImTriangulatorNode* reflex = *p;\n        if (reflex->Index != i0 && reflex->Index != i1 && reflex->Index != i2)\n            if (ImTriangleContainsPoint(v0, v1, v2, reflex->Pos))\n                return false;\n    }\n    return true;\n}\n\nvoid ImTriangulator::ReclassifyNode(ImTriangulatorNode* n1)\n{\n    // Classify node\n    ImTriangulatorNodeType type;\n    const ImTriangulatorNode* n0 = n1->Prev;\n    const ImTriangulatorNode* n2 = n1->Next;\n    if (!ImTriangleIsClockwise(n0->Pos, n1->Pos, n2->Pos))\n        type = ImTriangulatorNodeType_Reflex;\n    else if (IsEar(n0->Index, n1->Index, n2->Index, n0->Pos, n1->Pos, n2->Pos))\n        type = ImTriangulatorNodeType_Ear;\n    else\n        type = ImTriangulatorNodeType_Convex;\n\n    // Update lists when a type changes\n    if (type == n1->Type)\n        return;\n    if (n1->Type == ImTriangulatorNodeType_Reflex)\n        _Reflexes.find_erase_unsorted(n1->Index);\n    else if (n1->Type == ImTriangulatorNodeType_Ear)\n        _Ears.find_erase_unsorted(n1->Index);\n    if (type == ImTriangulatorNodeType_Reflex)\n        _Reflexes.push_back(n1);\n    else if (type == ImTriangulatorNodeType_Ear)\n        _Ears.push_back(n1);\n    n1->Type = type;\n}\n\n// Use ear-clipping algorithm to triangulate a simple polygon (no self-interaction, no holes).\n// (Reminder: we don't perform any coarse clipping/culling in ImDrawList layer!\n// It is up to caller to ensure not making costly calls that will be outside of visible area.\n// As concave fill is noticeably more expensive than other primitives, be mindful of this...\n// Caller can build AABB of points, and avoid filling if 'draw_list->_CmdHeader.ClipRect.Overlays(points_bb) == false')\nvoid ImDrawList::AddConcavePolyFilled(const ImVec2* points, const int points_count, ImU32 col)\n{\n    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)\n        return;\n\n    const ImVec2 uv = _Data->TexUvWhitePixel;\n    ImTriangulator triangulator;\n    unsigned int triangle[3];\n    if (Flags & ImDrawListFlags_AntiAliasedFill)\n    {\n        // Anti-aliased Fill\n        const float AA_SIZE = _FringeScale;\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\n        const int idx_count = (points_count - 2) * 3 + points_count * 6;\n        const int vtx_count = (points_count * 2);\n        PrimReserve(idx_count, vtx_count);\n\n        // Add indexes for fill\n        unsigned int vtx_inner_idx = _VtxCurrentIdx;\n        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;\n\n        _Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));\n        triangulator.Init(points, points_count, _Data->TempBuffer.Data);\n        while (triangulator._TrianglesLeft > 0)\n        {\n            triangulator.GetNextTriangle(triangle);\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (triangle[0] << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (triangle[1] << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (triangle[2] << 1));\n            _IdxWritePtr += 3;\n        }\n\n        // Compute normals\n        _Data->TempBuffer.reserve_discard(points_count);\n        ImVec2* temp_normals = _Data->TempBuffer.Data;\n        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)\n        {\n            const ImVec2& p0 = points[i0];\n            const ImVec2& p1 = points[i1];\n            float dx = p1.x - p0.x;\n            float dy = p1.y - p0.y;\n            IM_NORMALIZE2F_OVER_ZERO(dx, dy);\n            temp_normals[i0].x = dy;\n            temp_normals[i0].y = -dx;\n        }\n\n        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)\n        {\n            // Average normals\n            const ImVec2& n0 = temp_normals[i0];\n            const ImVec2& n1 = temp_normals[i1];\n            float dm_x = (n0.x + n1.x) * 0.5f;\n            float dm_y = (n0.y + n1.y) * 0.5f;\n            IM_FIXNORMAL2F(dm_x, dm_y);\n            dm_x *= AA_SIZE * 0.5f;\n            dm_y *= AA_SIZE * 0.5f;\n\n            // Add vertices\n            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner\n            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer\n            _VtxWritePtr += 2;\n\n            // Add indexes for fringes\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));\n            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));\n            _IdxWritePtr += 6;\n        }\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\n    }\n    else\n    {\n        // Non Anti-aliased Fill\n        const int idx_count = (points_count - 2) * 3;\n        const int vtx_count = points_count;\n        PrimReserve(idx_count, vtx_count);\n        for (int i = 0; i < vtx_count; i++)\n        {\n            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\n            _VtxWritePtr++;\n        }\n        _Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));\n        triangulator.Init(points, points_count, _Data->TempBuffer.Data);\n        while (triangulator._TrianglesLeft > 0)\n        {\n            triangulator.GetNextTriangle(triangle);\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx + triangle[0]); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + triangle[1]); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + triangle[2]);\n            _IdxWritePtr += 3;\n        }\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImDrawListSplitter\n//-----------------------------------------------------------------------------\n// FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..\n//-----------------------------------------------------------------------------\n\nvoid ImDrawListSplitter::ClearFreeMemory()\n{\n    for (int i = 0; i < _Channels.Size; i++)\n    {\n        if (i == _Current)\n            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again\n        _Channels[i]._CmdBuffer.clear();\n        _Channels[i]._IdxBuffer.clear();\n    }\n    _Current = 0;\n    _Count = 1;\n    _Channels.clear();\n}\n\nvoid ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)\n{\n    IM_UNUSED(draw_list);\n    IM_ASSERT(_Current == 0 && _Count <= 1 && \"Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.\");\n    int old_channels_count = _Channels.Size;\n    if (old_channels_count < channels_count)\n    {\n        _Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable\n        _Channels.resize(channels_count);\n    }\n    _Count = channels_count;\n\n    // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer\n    // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.\n    // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer\n    memset(&_Channels[0], 0, sizeof(ImDrawChannel));\n    for (int i = 1; i < channels_count; i++)\n    {\n        if (i >= old_channels_count)\n        {\n            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();\n        }\n        else\n        {\n            _Channels[i]._CmdBuffer.resize(0);\n            _Channels[i]._IdxBuffer.resize(0);\n        }\n    }\n}\n\nvoid ImDrawListSplitter::Merge(ImDrawList* draw_list)\n{\n    // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.\n    if (_Count <= 1)\n        return;\n\n    SetCurrentChannel(draw_list, 0);\n    draw_list->_PopUnusedDrawCmd();\n\n    // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.\n    int new_cmd_buffer_count = 0;\n    int new_idx_buffer_count = 0;\n    ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;\n    int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;\n    for (int i = 1; i < _Count; i++)\n    {\n        ImDrawChannel& ch = _Channels[i];\n        if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()\n            ch._CmdBuffer.pop_back();\n\n        if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)\n        {\n            // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.\n            // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.\n            ImDrawCmd* next_cmd = &ch._CmdBuffer[0];\n            if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)\n            {\n                // Merge previous channel last draw command with current channel first draw command if matching.\n                last_cmd->ElemCount += next_cmd->ElemCount;\n                idx_offset += next_cmd->ElemCount;\n                ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.\n            }\n        }\n        if (ch._CmdBuffer.Size > 0)\n            last_cmd = &ch._CmdBuffer.back();\n        new_cmd_buffer_count += ch._CmdBuffer.Size;\n        new_idx_buffer_count += ch._IdxBuffer.Size;\n        for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)\n        {\n            ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;\n            idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;\n        }\n    }\n    draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);\n    draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);\n\n    // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)\n    ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;\n    ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;\n    for (int i = 1; i < _Count; i++)\n    {\n        ImDrawChannel& ch = _Channels[i];\n        if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }\n        if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }\n    }\n    draw_list->_IdxWritePtr = idx_write;\n\n    // Ensure there's always a non-callback draw command trailing the command-buffer\n    if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)\n        draw_list->AddDrawCmd();\n\n    // If current command is used with different settings we need to add a new command\n    ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];\n    if (curr_cmd->ElemCount == 0)\n        ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset\n    else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)\n        draw_list->AddDrawCmd();\n\n    _Count = 1;\n}\n\nvoid ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)\n{\n    IM_ASSERT(idx >= 0 && idx < _Count);\n    if (_Current == idx)\n        return;\n\n    // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()\n    memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));\n    memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));\n    _Current = idx;\n    memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));\n    memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));\n    draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;\n\n    // If current command is used with different settings we need to add a new command\n    ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];\n    if (curr_cmd == NULL)\n        draw_list->AddDrawCmd();\n    else if (curr_cmd->ElemCount == 0)\n        ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset\n    else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)\n        draw_list->AddDrawCmd();\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImDrawData\n//-----------------------------------------------------------------------------\n\nvoid ImDrawData::Clear()\n{\n    Valid = false;\n    CmdListsCount = TotalIdxCount = TotalVtxCount = 0;\n    CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.\n    DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);\n    OwnerViewport = NULL;\n}\n\n// Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list\n// as long at it is expected that the result will be later merged into draw_data->CmdLists[].\nvoid ImGui::AddDrawListToDrawDataEx(ImDrawData* draw_data, ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)\n{\n    if (draw_list->CmdBuffer.Size == 0)\n        return;\n    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)\n        return;\n\n    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.\n    // May trigger for you if you are using PrimXXX functions incorrectly.\n    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);\n    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);\n    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))\n        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);\n\n    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)\n    // If this assert triggers because you are drawing lots of stuff manually:\n    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.\n    //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.\n    // - If you want large meshes with more than 64K vertices, you can either:\n    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.\n    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.\n    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.\n    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.\n    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:\n    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);\n    //       Your own engine or render API may use different parameters or function calls to specify index sizes.\n    //       2 and 4 bytes indices are generally supported by most graphics API.\n    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching\n    //   the 64K limit to split your draw commands in multiple draw lists.\n    if (sizeof(ImDrawIdx) == 2)\n        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && \"Too many vertices in ImDrawList using 16-bit indices. Read comment above\");\n\n    // Resolve callback data pointers\n    if (draw_list->_CallbacksDataBuf.Size > 0)\n        for (ImDrawCmd& cmd : draw_list->CmdBuffer)\n            if (cmd.UserCallback != NULL && cmd.UserCallbackDataOffset != -1 && cmd.UserCallbackDataSize > 0)\n                cmd.UserCallbackData = draw_list->_CallbacksDataBuf.Data + cmd.UserCallbackDataOffset;\n\n    // Add to output list + records state in ImDrawData\n    out_list->push_back(draw_list);\n    draw_data->CmdListsCount++;\n    draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;\n    draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;\n}\n\nvoid ImDrawData::AddDrawList(ImDrawList* draw_list)\n{\n    IM_ASSERT(CmdLists.Size == CmdListsCount);\n    draw_list->_PopUnusedDrawCmd();\n    ImGui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);\n}\n\n// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\nvoid ImDrawData::DeIndexAllBuffers()\n{\n    ImVector<ImDrawVert> new_vtx_buffer;\n    TotalVtxCount = TotalIdxCount = 0;\n    for (int i = 0; i < CmdListsCount; i++)\n    {\n        ImDrawList* cmd_list = CmdLists[i];\n        if (cmd_list->IdxBuffer.empty())\n            continue;\n        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);\n        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)\n            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];\n        cmd_list->VtxBuffer.swap(new_vtx_buffer);\n        cmd_list->IdxBuffer.resize(0);\n        TotalVtxCount += cmd_list->VtxBuffer.Size;\n    }\n}\n\n// Helper to scale the ClipRect field of each ImDrawCmd.\n// Use if your final output buffer is at a different scale than draw_data->DisplaySize,\n// or if there is a difference between your window resolution and framebuffer resolution.\nvoid ImDrawData::ScaleClipRects(const ImVec2& fb_scale)\n{\n    for (ImDrawList* draw_list : CmdLists)\n        for (ImDrawCmd& cmd : draw_list->CmdBuffer)\n            cmd.ClipRect = ImVec4(cmd.ClipRect.x * fb_scale.x, cmd.ClipRect.y * fb_scale.y, cmd.ClipRect.z * fb_scale.x, cmd.ClipRect.w * fb_scale.y);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Helpers ShadeVertsXXX functions\n//-----------------------------------------------------------------------------\n\n// Generic linear color gradient, write to RGB fields, leave A untouched.\nvoid ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)\n{\n    ImVec2 gradient_extent = gradient_p1 - gradient_p0;\n    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);\n    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;\n    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;\n    const int col0_r = (int)(col0 >> IM_COL32_R_SHIFT) & 0xFF;\n    const int col0_g = (int)(col0 >> IM_COL32_G_SHIFT) & 0xFF;\n    const int col0_b = (int)(col0 >> IM_COL32_B_SHIFT) & 0xFF;\n    const int col_delta_r = ((int)(col1 >> IM_COL32_R_SHIFT) & 0xFF) - col0_r;\n    const int col_delta_g = ((int)(col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g;\n    const int col_delta_b = ((int)(col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b;\n    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)\n    {\n        float d = ImDot(vert->pos - gradient_p0, gradient_extent);\n        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);\n        int r = (int)(col0_r + col_delta_r * t);\n        int g = (int)(col0_g + col_delta_g * t);\n        int b = (int)(col0_b + col_delta_b * t);\n        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);\n    }\n}\n\n// Distribute UV over (a, b) rectangle\nvoid ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)\n{\n    const ImVec2 size = b - a;\n    const ImVec2 uv_size = uv_b - uv_a;\n    const ImVec2 scale = ImVec2(\n        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,\n        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);\n\n    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;\n    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;\n    if (clamp)\n    {\n        const ImVec2 min = ImMin(uv_a, uv_b);\n        const ImVec2 max = ImMax(uv_a, uv_b);\n        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\n            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);\n    }\n    else\n    {\n        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\n            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);\n    }\n}\n\nvoid ImGui::ShadeVertsTransformPos(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& pivot_in, float cos_a, float sin_a, const ImVec2& pivot_out)\n{\n    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;\n    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;\n    for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\n        vertex->pos = ImRotate(vertex->pos- pivot_in, cos_a, sin_a) + pivot_out;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImFontConfig\n//-----------------------------------------------------------------------------\n\nImFontConfig::ImFontConfig()\n{\n    memset(this, 0, sizeof(*this));\n    FontDataOwnedByAtlas = true;\n    OversampleH = 2;\n    OversampleV = 1;\n    GlyphMaxAdvanceX = FLT_MAX;\n    RasterizerMultiply = 1.0f;\n    RasterizerDensity = 1.0f;\n    EllipsisChar = 0;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImFontAtlas\n//-----------------------------------------------------------------------------\n// - Default texture data encoded in ASCII\n// - ImFontAtlas::ClearInputData()\n// - ImFontAtlas::ClearTexData()\n// - ImFontAtlas::ClearFonts()\n// - ImFontAtlas::Clear()\n// - ImFontAtlas::GetTexDataAsAlpha8()\n// - ImFontAtlas::GetTexDataAsRGBA32()\n// - ImFontAtlas::AddFont()\n// - ImFontAtlas::AddFontDefault()\n// - ImFontAtlas::AddFontFromFileTTF()\n// - ImFontAtlas::AddFontFromMemoryTTF()\n// - ImFontAtlas::AddFontFromMemoryCompressedTTF()\n// - ImFontAtlas::AddFontFromMemoryCompressedBase85TTF()\n// - ImFontAtlas::AddCustomRectRegular()\n// - ImFontAtlas::AddCustomRectFontGlyph()\n// - ImFontAtlas::CalcCustomRectUV()\n// - ImFontAtlas::GetMouseCursorTexData()\n// - ImFontAtlas::Build()\n// - ImFontAtlasBuildMultiplyCalcLookupTable()\n// - ImFontAtlasBuildMultiplyRectAlpha8()\n// - ImFontAtlasBuildWithStbTruetype()\n// - ImFontAtlasGetBuilderForStbTruetype()\n// - ImFontAtlasUpdateConfigDataPointers()\n// - ImFontAtlasBuildSetupFont()\n// - ImFontAtlasBuildPackCustomRects()\n// - ImFontAtlasBuildRender8bppRectFromString()\n// - ImFontAtlasBuildRender32bppRectFromString()\n// - ImFontAtlasBuildRenderDefaultTexData()\n// - ImFontAtlasBuildRenderLinesTexData()\n// - ImFontAtlasBuildInit()\n// - ImFontAtlasBuildFinish()\n//-----------------------------------------------------------------------------\n\n// A work of art lies ahead! (. = white layer, X = black layer, others are blank)\n// The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.\n// (This is used when io.MouseDrawCursor = true)\nconst int FONT_ATLAS_DEFAULT_TEX_DATA_W = 122; // Actual texture will be 2 times that + 1 spacing.\nconst int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;\nstatic const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =\n{\n    \"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          - XX       XX \"\n    \"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         -X..X     X..X\"\n    \"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         -X...X   X...X\"\n    \"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         - X...X X...X \"\n    \"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         -  X...X...X  \"\n    \"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       -   X.....X   \"\n    \"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    -    X...X    \"\n    \"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  -     X.X     \"\n    \"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X -    X...X    \"\n    \"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X-   X.....X   \"\n    \"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X-  X...X...X  \"\n    \"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X- X...X X...X \"\n    \"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X-X...X   X...X\"\n    \"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X-X..X     X..X\"\n    \"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X- XX       XX \"\n    \"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X--------------\"\n    \"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X -             \"\n    \"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X -             \"\n    \"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X -             \"\n    \"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  -             \"\n    \"      X..X  -       -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  -             \"\n    \"       XX   -       -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             \"\n    \"-------------       -    X    -           X           -X.....................X-           -------------------             \"\n    \"                    ----------------------------------- X...XXXXXXXXXXXXX...X -                                           \"\n    \"                                                      -  X..X           X..X  -                                           \"\n    \"                                                      -   X.X           X.X   -                                           \"\n    \"                                                      -    XX           XX    -                                           \"\n};\n\nstatic const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =\n{\n    // Pos ........ Size ......... Offset ......\n    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow\n    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput\n    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll\n    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS\n    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW\n    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW\n    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE\n    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand\n    { ImVec2(109,0),ImVec2(13,15), ImVec2( 6, 7) }, // ImGuiMouseCursor_NotAllowed\n};\n\nImFontAtlas::ImFontAtlas()\n{\n    memset(this, 0, sizeof(*this));\n    TexGlyphPadding = 1;\n    PackIdMouseCursors = PackIdLines = -1;\n}\n\nImFontAtlas::~ImFontAtlas()\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    Clear();\n}\n\nvoid    ImFontAtlas::ClearInputData()\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    for (ImFontConfig& font_cfg : ConfigData)\n        if (font_cfg.FontData && font_cfg.FontDataOwnedByAtlas)\n        {\n            IM_FREE(font_cfg.FontData);\n            font_cfg.FontData = NULL;\n        }\n\n    // When clearing this we lose access to the font name and other information used to build the font.\n    for (ImFont* font : Fonts)\n        if (font->ConfigData >= ConfigData.Data && font->ConfigData < ConfigData.Data + ConfigData.Size)\n        {\n            font->ConfigData = NULL;\n            font->ConfigDataCount = 0;\n        }\n    ConfigData.clear();\n    CustomRects.clear();\n    PackIdMouseCursors = PackIdLines = -1;\n    // Important: we leave TexReady untouched\n}\n\nvoid    ImFontAtlas::ClearTexData()\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    if (TexPixelsAlpha8)\n        IM_FREE(TexPixelsAlpha8);\n    if (TexPixelsRGBA32)\n        IM_FREE(TexPixelsRGBA32);\n    TexPixelsAlpha8 = NULL;\n    TexPixelsRGBA32 = NULL;\n    TexPixelsUseColors = false;\n    // Important: we leave TexReady untouched\n}\n\nvoid    ImFontAtlas::ClearFonts()\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    Fonts.clear_delete();\n    TexReady = false;\n}\n\nvoid    ImFontAtlas::Clear()\n{\n    ClearInputData();\n    ClearTexData();\n    ClearFonts();\n}\n\nvoid    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)\n{\n    // Build atlas on demand\n    if (TexPixelsAlpha8 == NULL)\n        Build();\n\n    *out_pixels = TexPixelsAlpha8;\n    if (out_width) *out_width = TexWidth;\n    if (out_height) *out_height = TexHeight;\n    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;\n}\n\nvoid    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)\n{\n    // Convert to RGBA32 format on demand\n    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp\n    if (!TexPixelsRGBA32)\n    {\n        unsigned char* pixels = NULL;\n        GetTexDataAsAlpha8(&pixels, NULL, NULL);\n        if (pixels)\n        {\n            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);\n            const unsigned char* src = pixels;\n            unsigned int* dst = TexPixelsRGBA32;\n            for (int n = TexWidth * TexHeight; n > 0; n--)\n                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));\n        }\n    }\n\n    *out_pixels = (unsigned char*)TexPixelsRGBA32;\n    if (out_width) *out_width = TexWidth;\n    if (out_height) *out_height = TexHeight;\n    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;\n}\n\nImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);\n    IM_ASSERT(font_cfg->SizePixels > 0.0f && \"Is ImFontConfig struct correctly initialized?\");\n    IM_ASSERT(font_cfg->OversampleH > 0 && font_cfg->OversampleV > 0 && \"Is ImFontConfig struct correctly initialized?\");\n    IM_ASSERT(font_cfg->RasterizerDensity > 0.0f);\n\n    // Create new font\n    if (!font_cfg->MergeMode)\n        Fonts.push_back(IM_NEW(ImFont));\n    else\n        IM_ASSERT(Fonts.Size > 0 && \"Cannot use MergeMode for the first font\"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.\n\n    ConfigData.push_back(*font_cfg);\n    ImFontConfig& new_font_cfg = ConfigData.back();\n    if (new_font_cfg.DstFont == NULL)\n        new_font_cfg.DstFont = Fonts.back();\n    if (!new_font_cfg.FontDataOwnedByAtlas)\n    {\n        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);\n        new_font_cfg.FontDataOwnedByAtlas = true;\n        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);\n    }\n\n    // Round font size\n    // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.\n    // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.\n    // - We may support it better later and remove this rounding.\n    new_font_cfg.SizePixels = ImTrunc(new_font_cfg.SizePixels);\n\n    // Pointers to ConfigData and BuilderData are otherwise dangling\n    ImFontAtlasUpdateConfigDataPointers(this);\n\n    // Invalidate texture\n    TexReady = false;\n    ClearTexData();\n    return new_font_cfg.DstFont;\n}\n\n// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)\nstatic unsigned int stb_decompress_length(const unsigned char* input);\nstatic unsigned int stb_decompress(unsigned char* output, const unsigned char* input, unsigned int length);\nstatic unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }\nstatic void         Decode85(const unsigned char* src, unsigned char* dst)\n{\n    while (*src)\n    {\n        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));\n        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.\n        src += 5;\n        dst += 4;\n    }\n}\n#ifndef IMGUI_DISABLE_DEFAULT_FONT\nstatic const char* GetDefaultCompressedFontDataTTF(int* out_size);\n#endif\n\n// Load embedded ProggyClean.ttf at size 13, disable oversampling\nImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)\n{\n#ifndef IMGUI_DISABLE_DEFAULT_FONT\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\n    if (!font_cfg_template)\n    {\n        font_cfg.OversampleH = font_cfg.OversampleV = 1;\n        font_cfg.PixelSnapH = true;\n    }\n    if (font_cfg.SizePixels <= 0.0f)\n        font_cfg.SizePixels = 13.0f * 1.0f;\n    if (font_cfg.Name[0] == '\\0')\n        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), \"ProggyClean.ttf, %dpx\", (int)font_cfg.SizePixels);\n    font_cfg.EllipsisChar = (ImWchar)0x0085;\n    font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units\n\n    int ttf_compressed_size = 0;\n    const char* ttf_compressed = GetDefaultCompressedFontDataTTF(&ttf_compressed_size);\n    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();\n    ImFont* font = AddFontFromMemoryCompressedTTF(ttf_compressed, ttf_compressed_size, font_cfg.SizePixels, &font_cfg, glyph_ranges);\n    return font;\n#else\n    IM_ASSERT(0 && \"AddFontDefault() disabled in this build.\");\n    IM_UNUSED(font_cfg_template);\n    return NULL;\n#endif // #ifndef IMGUI_DISABLE_DEFAULT_FONT\n}\n\nImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    size_t data_size = 0;\n    void* data = ImFileLoadToMemory(filename, \"rb\", &data_size, 0);\n    if (!data)\n    {\n        IM_ASSERT_USER_ERROR(0, \"Could not load font file!\");\n        return NULL;\n    }\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\n    if (font_cfg.Name[0] == '\\0')\n    {\n        // Store a short copy of filename into into the font name for convenience\n        const char* p;\n        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\\\'; p--) {}\n        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), \"%s, %.0fpx\", p, size_pixels);\n    }\n    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);\n}\n\n// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().\nImFont* ImFontAtlas::AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\n    IM_ASSERT(font_cfg.FontData == NULL);\n    IM_ASSERT(font_data_size > 100 && \"Incorrect value for font_data_size!\"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.\n    font_cfg.FontData = font_data;\n    font_cfg.FontDataSize = font_data_size;\n    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;\n    if (glyph_ranges)\n        font_cfg.GlyphRanges = glyph_ranges;\n    return AddFont(&font_cfg);\n}\n\nImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\n{\n    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);\n    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);\n    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);\n\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\n    IM_ASSERT(font_cfg.FontData == NULL);\n    font_cfg.FontDataOwnedByAtlas = true;\n    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);\n}\n\nImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)\n{\n    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;\n    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);\n    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);\n    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);\n    IM_FREE(compressed_ttf);\n    return font;\n}\n\nint ImFontAtlas::AddCustomRectRegular(int width, int height)\n{\n    IM_ASSERT(width > 0 && width <= 0xFFFF);\n    IM_ASSERT(height > 0 && height <= 0xFFFF);\n    ImFontAtlasCustomRect r;\n    r.Width = (unsigned short)width;\n    r.Height = (unsigned short)height;\n    CustomRects.push_back(r);\n    return CustomRects.Size - 1; // Return index\n}\n\nint ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)\n{\n#ifdef IMGUI_USE_WCHAR32\n    IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);\n#endif\n    IM_ASSERT(font != NULL);\n    IM_ASSERT(width > 0 && width <= 0xFFFF);\n    IM_ASSERT(height > 0 && height <= 0xFFFF);\n    ImFontAtlasCustomRect r;\n    r.Width = (unsigned short)width;\n    r.Height = (unsigned short)height;\n    r.GlyphID = id;\n    r.GlyphColored = 0; // Set to 1 manually to mark glyph as colored // FIXME: No official API for that (#8133)\n    r.GlyphAdvanceX = advance_x;\n    r.GlyphOffset = offset;\n    r.Font = font;\n    CustomRects.push_back(r);\n    return CustomRects.Size - 1; // Return index\n}\n\nvoid ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const\n{\n    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates\n    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed\n    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);\n    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);\n}\n\nbool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])\n{\n    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)\n        return false;\n    if (Flags & ImFontAtlasFlags_NoMouseCursors)\n        return false;\n\n    IM_ASSERT(PackIdMouseCursors != -1);\n    ImFontAtlasCustomRect* r = GetCustomRectByIndex(PackIdMouseCursors);\n    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);\n    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];\n    *out_size = size;\n    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];\n    out_uv_border[0] = (pos) * TexUvScale;\n    out_uv_border[1] = (pos + size) * TexUvScale;\n    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;\n    out_uv_fill[0] = (pos) * TexUvScale;\n    out_uv_fill[1] = (pos + size) * TexUvScale;\n    return true;\n}\n\nbool    ImFontAtlas::Build()\n{\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\n\n    // Default font is none are specified\n    if (ConfigData.Size == 0)\n        AddFontDefault();\n\n    // Select builder\n    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which\n    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are\n    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere\n    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.\n    const ImFontBuilderIO* builder_io = FontBuilderIO;\n    if (builder_io == NULL)\n    {\n#ifdef IMGUI_ENABLE_FREETYPE\n        builder_io = ImGuiFreeType::GetBuilderForFreeType();\n#elif defined(IMGUI_ENABLE_STB_TRUETYPE)\n        builder_io = ImFontAtlasGetBuilderForStbTruetype();\n#else\n        IM_ASSERT(0); // Invalid Build function\n#endif\n    }\n\n    // Build\n    return builder_io->FontBuilder_Build(this);\n}\n\nvoid    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)\n{\n    for (unsigned int i = 0; i < 256; i++)\n    {\n        unsigned int value = (unsigned int)(i * in_brighten_factor);\n        out_table[i] = value > 255 ? 255 : (value & 0xFF);\n    }\n}\n\nvoid    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)\n{\n    IM_ASSERT_PARANOID(w <= stride);\n    unsigned char* data = pixels + x + y * stride;\n    for (int j = h; j > 0; j--, data += stride - w)\n        for (int i = w; i > 0; i--, data++)\n            *data = table[*data];\n}\n\n#ifdef IMGUI_ENABLE_STB_TRUETYPE\n// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)\n// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)\nstruct ImFontBuildSrcData\n{\n    stbtt_fontinfo      FontInfo;\n    stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)\n    stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.\n    stbtt_packedchar*   PackedChars;        // Output glyphs\n    const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)\n    int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]\n    int                 GlyphsHighest;      // Highest requested codepoint\n    int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)\n    ImBitVector         GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)\n    ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsSet)\n};\n\n// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)\nstruct ImFontBuildDstData\n{\n    int                 SrcCount;           // Number of source fonts targeting this destination font.\n    int                 GlyphsHighest;\n    int                 GlyphsCount;\n    ImBitVector         GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.\n};\n\nstatic void UnpackBitVectorToFlatIndexList(const ImBitVector* in, ImVector<int>* out)\n{\n    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));\n    const ImU32* it_begin = in->Storage.begin();\n    const ImU32* it_end = in->Storage.end();\n    for (const ImU32* it = it_begin; it < it_end; it++)\n        if (ImU32 entries_32 = *it)\n            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)\n                if (entries_32 & ((ImU32)1 << bit_n))\n                    out->push_back((int)(((it - it_begin) << 5) + bit_n));\n}\n\nstatic bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)\n{\n    IM_ASSERT(atlas->ConfigData.Size > 0);\n\n    ImFontAtlasBuildInit(atlas);\n\n    // Clear atlas\n    atlas->TexID = (ImTextureID)NULL;\n    atlas->TexWidth = atlas->TexHeight = 0;\n    atlas->TexUvScale = ImVec2(0.0f, 0.0f);\n    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);\n    atlas->ClearTexData();\n\n    // Temporary storage for building\n    ImVector<ImFontBuildSrcData> src_tmp_array;\n    ImVector<ImFontBuildDstData> dst_tmp_array;\n    src_tmp_array.resize(atlas->ConfigData.Size);\n    dst_tmp_array.resize(atlas->Fonts.Size);\n    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());\n    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());\n\n    // 1. Initialize font loading structure, check font data validity\n    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)\n    {\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        ImFontConfig& cfg = atlas->ConfigData[src_i];\n        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));\n\n        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)\n        src_tmp.DstIndex = -1;\n        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)\n            if (cfg.DstFont == atlas->Fonts[output_i])\n                src_tmp.DstIndex = output_i;\n        if (src_tmp.DstIndex == -1)\n        {\n            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?\n            return false;\n        }\n        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct\n        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);\n        IM_ASSERT(font_offset >= 0 && \"FontData is incorrect, or FontNo cannot be found.\");\n        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))\n        {\n            IM_ASSERT(0 && \"stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.\");\n            return false;\n        }\n\n        // Measure highest codepoints\n        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];\n        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();\n        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)\n        {\n            // Check for valid range. This may also help detect *some* dangling pointers, because a common\n            // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent,\n            // or to forget to zero-terminate the glyph range array.\n            IM_ASSERT(src_range[0] <= src_range[1] && \"Invalid range: is your glyph range array persistent? it is zero-terminated?\");\n            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);\n        }\n        dst_tmp.SrcCount++;\n        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);\n    }\n\n    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.\n    int total_glyphs_count = 0;\n    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)\n    {\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];\n        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);\n        if (dst_tmp.GlyphsSet.Storage.empty())\n            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);\n\n        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)\n            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)\n            {\n                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)\n                    continue;\n                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?\n                    continue;\n\n                // Add to avail set/counters\n                src_tmp.GlyphsCount++;\n                dst_tmp.GlyphsCount++;\n                src_tmp.GlyphsSet.SetBit(codepoint);\n                dst_tmp.GlyphsSet.SetBit(codepoint);\n                total_glyphs_count++;\n            }\n    }\n\n    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)\n    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)\n    {\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);\n        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);\n        src_tmp.GlyphsSet.Clear();\n        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);\n    }\n    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)\n        dst_tmp_array[dst_i].GlyphsSet.Clear();\n    dst_tmp_array.clear();\n\n    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)\n    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)\n    ImVector<stbrp_rect> buf_rects;\n    ImVector<stbtt_packedchar> buf_packedchars;\n    buf_rects.resize(total_glyphs_count);\n    buf_packedchars.resize(total_glyphs_count);\n    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());\n    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());\n\n    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.\n    int total_surface = 0;\n    int buf_rects_out_n = 0;\n    int buf_packedchars_out_n = 0;\n    const int pack_padding = atlas->TexGlyphPadding;\n    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)\n    {\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        if (src_tmp.GlyphsCount == 0)\n            continue;\n\n        src_tmp.Rects = &buf_rects[buf_rects_out_n];\n        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];\n        buf_rects_out_n += src_tmp.GlyphsCount;\n        buf_packedchars_out_n += src_tmp.GlyphsCount;\n\n        // Convert our ranges in the format stb_truetype wants\n        ImFontConfig& cfg = atlas->ConfigData[src_i];\n        src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;\n        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;\n        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;\n        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;\n        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;\n        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;\n        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;\n\n        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)\n        const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);\n        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)\n        {\n            int x0, y0, x1, y1;\n            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);\n            IM_ASSERT(glyph_index_in_font != 0);\n            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);\n            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + pack_padding + cfg.OversampleH - 1);\n            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + pack_padding + cfg.OversampleV - 1);\n            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;\n        }\n    }\n    for (int i = 0; i < atlas->CustomRects.Size; i++)\n        total_surface += (atlas->CustomRects[i].Width + pack_padding) * (atlas->CustomRects[i].Height + pack_padding);\n\n    // We need a width for the skyline algorithm, any width!\n    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.\n    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.\n    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;\n    atlas->TexHeight = 0;\n    if (atlas->TexDesiredWidth > 0)\n        atlas->TexWidth = atlas->TexDesiredWidth;\n    else\n        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;\n\n    // 5. Start packing\n    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).\n    const int TEX_HEIGHT_MAX = 1024 * 32;\n    stbtt_pack_context spc = {};\n    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, 0, NULL);\n    spc.padding = atlas->TexGlyphPadding; // Because we mixup stbtt_PackXXX and stbrp_PackXXX there's a bit of a hack here, not passing the value to stbtt_PackBegin() allows us to still pack a TexWidth-1 wide item. (#8107)\n    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);\n\n    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.\n    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)\n    {\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        if (src_tmp.GlyphsCount == 0)\n            continue;\n\n        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);\n\n        // Extend texture height and mark missing glyphs as non-packed so we won't render them.\n        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)\n        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)\n            if (src_tmp.Rects[glyph_i].was_packed)\n                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);\n    }\n\n    // 7. Allocate texture\n    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);\n    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);\n    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);\n    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);\n    spc.pixels = atlas->TexPixelsAlpha8;\n    spc.height = atlas->TexHeight;\n\n    // 8. Render/rasterize font characters into the texture\n    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)\n    {\n        ImFontConfig& cfg = atlas->ConfigData[src_i];\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        if (src_tmp.GlyphsCount == 0)\n            continue;\n\n        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);\n\n        // Apply multiply operator\n        if (cfg.RasterizerMultiply != 1.0f)\n        {\n            unsigned char multiply_table[256];\n            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);\n            stbrp_rect* r = &src_tmp.Rects[0];\n            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)\n                if (r->was_packed)\n                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);\n        }\n        src_tmp.Rects = NULL;\n    }\n\n    // End packing\n    stbtt_PackEnd(&spc);\n    buf_rects.clear();\n\n    // 9. Setup ImFont and glyphs for runtime\n    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)\n    {\n        // When merging fonts with MergeMode=true:\n        // - We can have multiple input fonts writing into a same destination font.\n        // - dst_font->ConfigData is != from cfg which is our source configuration.\n        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];\n        ImFontConfig& cfg = atlas->ConfigData[src_i];\n        ImFont* dst_font = cfg.DstFont;\n\n        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);\n        int unscaled_ascent, unscaled_descent, unscaled_line_gap;\n        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);\n\n        const float ascent = ImCeil(unscaled_ascent * font_scale);\n        const float descent = ImFloor(unscaled_descent * font_scale);\n        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);\n        const float font_off_x = cfg.GlyphOffset.x;\n        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);\n\n        const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;\n\n        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)\n        {\n            // Register glyph\n            const int codepoint = src_tmp.GlyphsList[glyph_i];\n            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];\n            stbtt_aligned_quad q;\n            float unused_x = 0.0f, unused_y = 0.0f;\n            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);\n            float x0 = q.x0 * inv_rasterization_scale + font_off_x;\n            float y0 = q.y0 * inv_rasterization_scale + font_off_y;\n            float x1 = q.x1 * inv_rasterization_scale + font_off_x;\n            float y1 = q.y1 * inv_rasterization_scale + font_off_y;\n            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);\n        }\n    }\n\n    // Cleanup\n    src_tmp_array.clear_destruct();\n\n    ImFontAtlasBuildFinish(atlas);\n    return true;\n}\n\nconst ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype()\n{\n    static ImFontBuilderIO io;\n    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;\n    return &io;\n}\n\n#endif // IMGUI_ENABLE_STB_TRUETYPE\n\nvoid ImFontAtlasUpdateConfigDataPointers(ImFontAtlas* atlas)\n{\n    for (ImFontConfig& font_cfg : atlas->ConfigData)\n    {\n        ImFont* font = font_cfg.DstFont;\n        if (!font_cfg.MergeMode)\n        {\n            font->ConfigData = &font_cfg;\n            font->ConfigDataCount = 0;\n        }\n        font->ConfigDataCount++;\n    }\n}\n\nvoid ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)\n{\n    if (!font_config->MergeMode)\n    {\n        font->ClearOutputData();\n        font->FontSize = font_config->SizePixels;\n        IM_ASSERT(font->ConfigData == font_config);\n        font->ContainerAtlas = atlas;\n        font->Ascent = ascent;\n        font->Descent = descent;\n    }\n}\n\nvoid ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)\n{\n    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;\n    IM_ASSERT(pack_context != NULL);\n\n    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;\n    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.\n#ifdef __GNUC__\n    if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)\n#endif\n\n    const int pack_padding = atlas->TexGlyphPadding;\n    ImVector<stbrp_rect> pack_rects;\n    pack_rects.resize(user_rects.Size);\n    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());\n    for (int i = 0; i < user_rects.Size; i++)\n    {\n        pack_rects[i].w = user_rects[i].Width + pack_padding;\n        pack_rects[i].h = user_rects[i].Height + pack_padding;\n    }\n    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);\n    for (int i = 0; i < pack_rects.Size; i++)\n        if (pack_rects[i].was_packed)\n        {\n            user_rects[i].X = (unsigned short)pack_rects[i].x;\n            user_rects[i].Y = (unsigned short)pack_rects[i].y;\n            IM_ASSERT(pack_rects[i].w == user_rects[i].Width + pack_padding && pack_rects[i].h == user_rects[i].Height + pack_padding);\n            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);\n        }\n}\n\nvoid ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value)\n{\n    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);\n    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);\n    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);\n    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)\n        for (int off_x = 0; off_x < w; off_x++)\n            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;\n}\n\nvoid ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value)\n{\n    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);\n    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);\n    unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);\n    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)\n        for (int off_x = 0; off_x < w; off_x++)\n            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;\n}\n\nstatic void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)\n{\n    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);\n    IM_ASSERT(r->IsPacked());\n\n    const int w = atlas->TexWidth;\n    if (atlas->Flags & ImFontAtlasFlags_NoMouseCursors)\n    {\n        // White pixels only\n        IM_ASSERT(r->Width == 2 && r->Height == 2);\n        const int offset = (int)r->X + (int)r->Y * w;\n        if (atlas->TexPixelsAlpha8 != NULL)\n        {\n            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;\n        }\n        else\n        {\n            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;\n        }\n    }\n    else\n    {\n        // White pixels and mouse cursor\n        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);\n        const int x_for_white = r->X;\n        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;\n        if (atlas->TexPixelsAlpha8 != NULL)\n        {\n            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);\n            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);\n        }\n        else\n        {\n            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);\n            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);\n        }\n    }\n    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);\n}\n\nstatic void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas* atlas)\n{\n    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)\n        return;\n\n    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them\n    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);\n    IM_ASSERT(r->IsPacked());\n    for (int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row\n    {\n        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle\n        int y = n;\n        int line_width = n;\n        int pad_left = (r->Width - line_width) / 2;\n        int pad_right = r->Width - (pad_left + line_width);\n\n        // Write each slice\n        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels\n        if (atlas->TexPixelsAlpha8 != NULL)\n        {\n            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];\n            for (int i = 0; i < pad_left; i++)\n                *(write_ptr + i) = 0x00;\n\n            for (int i = 0; i < line_width; i++)\n                *(write_ptr + pad_left + i) = 0xFF;\n\n            for (int i = 0; i < pad_right; i++)\n                *(write_ptr + pad_left + line_width + i) = 0x00;\n        }\n        else\n        {\n            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];\n            for (int i = 0; i < pad_left; i++)\n                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);\n\n            for (int i = 0; i < line_width; i++)\n                *(write_ptr + pad_left + i) = IM_COL32_WHITE;\n\n            for (int i = 0; i < pad_right; i++)\n                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);\n        }\n\n        // Calculate UVs for this line\n        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;\n        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;\n        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts\n        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);\n    }\n}\n\n// Note: this is called / shared by both the stb_truetype and the FreeType builder\nvoid ImFontAtlasBuildInit(ImFontAtlas* atlas)\n{\n    // Register texture region for mouse cursors or standard white pixels\n    if (atlas->PackIdMouseCursors < 0)\n    {\n        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))\n            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);\n        else\n            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);\n    }\n\n    // Register texture region for thick lines\n    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row\n    if (atlas->PackIdLines < 0)\n    {\n        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))\n            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);\n    }\n}\n\n// This is called/shared by both the stb_truetype and the FreeType builder.\nvoid ImFontAtlasBuildFinish(ImFontAtlas* atlas)\n{\n    // Render into our custom data blocks\n    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);\n    ImFontAtlasBuildRenderDefaultTexData(atlas);\n    ImFontAtlasBuildRenderLinesTexData(atlas);\n\n    // Register custom rectangle glyphs\n    for (int i = 0; i < atlas->CustomRects.Size; i++)\n    {\n        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];\n        if (r->Font == NULL || r->GlyphID == 0)\n            continue;\n\n        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH\n        IM_ASSERT(r->Font->ContainerAtlas == atlas);\n        ImVec2 uv0, uv1;\n        atlas->CalcCustomRectUV(r, &uv0, &uv1);\n        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);\n        if (r->GlyphColored)\n            r->Font->Glyphs.back().Colored = 1;\n    }\n\n    // Build all fonts lookup tables\n    for (ImFont* font : atlas->Fonts)\n        if (font->DirtyLookupTables)\n            font->BuildLookupTable();\n\n    atlas->TexReady = true;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] ImFontAtlas: glyph ranges helpers\n//-------------------------------------------------------------------------\n// - GetGlyphRangesDefault()\n// - GetGlyphRangesGreek()\n// - GetGlyphRangesKorean()\n// - GetGlyphRangesChineseFull()\n// - GetGlyphRangesChineseSimplifiedCommon()\n// - GetGlyphRangesJapanese()\n// - GetGlyphRangesCyrillic()\n// - GetGlyphRangesThai()\n// - GetGlyphRangesVietnamese()\n//-----------------------------------------------------------------------------\n\n// Retrieve list of range (2 int per range, values are inclusive)\nconst ImWchar*   ImFontAtlas::GetGlyphRangesDefault()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0,\n    };\n    return &ranges[0];\n}\n\nconst ImWchar*   ImFontAtlas::GetGlyphRangesGreek()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x0370, 0x03FF, // Greek and Coptic\n        0,\n    };\n    return &ranges[0];\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesKorean()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x3131, 0x3163, // Korean alphabets\n        0xAC00, 0xD7A3, // Korean characters\n        0xFFFD, 0xFFFD, // Invalid\n        0,\n    };\n    return &ranges[0];\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x2000, 0x206F, // General Punctuation\n        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\n        0xFF00, 0xFFEF, // Half-width characters\n        0xFFFD, 0xFFFD, // Invalid\n        0x4e00, 0x9FAF, // CJK Ideograms\n        0,\n    };\n    return &ranges[0];\n}\n\nstatic void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)\n{\n    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)\n    {\n        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);\n        base_codepoint += accumulative_offsets[n];\n    }\n    out_ranges[0] = 0;\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()\n{\n    // Store 2500 regularly used characters for Simplified Chinese.\n    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8\n    // This table covers 97.97% of all characters used during the month in July, 1987.\n    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.\n    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)\n    static const short accumulative_offsets_from_0x4E00[] =\n    {\n        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,\n        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,\n        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,\n        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,\n        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,\n        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,\n        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,\n        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,\n        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,\n        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,\n        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,\n        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,\n        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,\n        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,\n        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,\n        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,\n        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,\n        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,\n        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,\n        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,\n        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,\n        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,\n        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,\n        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,\n        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,\n        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,\n        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,\n        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,\n        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,\n        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,\n        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,\n        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,\n        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,\n        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,\n        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,\n        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,\n        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,\n        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,\n        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,\n        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6\n    };\n    static ImWchar base_ranges[] = // not zero-terminated\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x2000, 0x206F, // General Punctuation\n        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\n        0xFF00, 0xFFEF, // Half-width characters\n        0xFFFD, 0xFFFD  // Invalid\n    };\n    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };\n    if (!full_ranges[0])\n    {\n        memcpy(full_ranges, base_ranges, sizeof(base_ranges));\n        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));\n    }\n    return &full_ranges[0];\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()\n{\n    // 2999 ideograms code points for Japanese\n    // - 2136 Joyo (meaning \"for regular use\" or \"for common use\") Kanji code points\n    // - 863 Jinmeiyo (meaning \"for personal name\") Kanji code points\n    // - Sourced from official information provided by the government agencies of Japan:\n    //   - List of Joyo Kanji by the Agency for Cultural Affairs\n    //     - https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/\n    //   - List of Jinmeiyo Kanji by the Ministry of Justice\n    //     - http://www.moj.go.jp/MINJI/minji86.html\n    //   - Available under the terms of the Creative Commons Attribution 4.0 International (CC BY 4.0).\n    //     - https://creativecommons.org/licenses/by/4.0/legalcode\n    // - You can generate this code by the script at:\n    //   - https://github.com/vaiorabbit/everyday_use_kanji\n    // - References:\n    //   - List of Joyo Kanji\n    //     - (Wikipedia) https://en.wikipedia.org/wiki/List_of_j%C5%8Dy%C5%8D_kanji\n    //   - List of Jinmeiyo Kanji\n    //     - (Wikipedia) https://en.wikipedia.org/wiki/Jinmeiy%C5%8D_kanji\n    // - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi: Shitsu,shichi), see https://github.com/ocornut/imgui/pull/3627 for details.\n    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.\n    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)\n    static const short accumulative_offsets_from_0x4E00[] =\n    {\n        0,1,2,4,1,1,1,1,2,1,3,3,2,2,1,5,3,5,7,5,6,1,2,1,7,2,6,3,1,8,1,1,4,1,1,18,2,11,2,6,2,1,2,1,5,1,2,1,3,1,2,1,2,3,3,1,1,2,3,1,1,1,12,7,9,1,4,5,1,\n        1,2,1,10,1,1,9,2,2,4,5,6,9,3,1,1,1,1,9,3,18,5,2,2,2,2,1,6,3,7,1,1,1,1,2,2,4,2,1,23,2,10,4,3,5,2,4,10,2,4,13,1,6,1,9,3,1,1,6,6,7,6,3,1,2,11,3,\n        2,2,3,2,15,2,2,5,4,3,6,4,1,2,5,2,12,16,6,13,9,13,2,1,1,7,16,4,7,1,19,1,5,1,2,2,7,7,8,2,6,5,4,9,18,7,4,5,9,13,11,8,15,2,1,1,1,2,1,2,2,1,2,2,8,\n        2,9,3,3,1,1,4,4,1,1,1,4,9,1,4,3,5,5,2,7,5,3,4,8,2,1,13,2,3,3,1,14,1,1,4,5,1,3,6,1,5,2,1,1,3,3,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,1,1,1,12,3,3,9,5,\n        2,6,1,5,6,1,2,3,18,2,4,14,4,1,3,6,1,1,6,3,5,5,3,2,2,2,2,12,3,1,4,2,3,2,3,11,1,7,4,1,2,1,3,17,1,9,1,24,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,2,4,15,1,\n        1,2,1,1,2,1,5,2,5,20,2,5,9,1,10,8,7,6,1,1,1,1,1,1,6,2,1,2,8,1,1,1,1,5,1,1,3,1,1,1,1,3,1,1,12,4,1,3,1,1,1,1,1,10,3,1,7,5,13,1,2,3,4,6,1,1,30,\n        2,9,9,1,15,38,11,3,1,8,24,7,1,9,8,10,2,1,9,31,2,13,6,2,9,4,49,5,2,15,2,1,10,2,1,1,1,2,2,6,15,30,35,3,14,18,8,1,16,10,28,12,19,45,38,1,3,2,3,\n        13,2,1,7,3,6,5,3,4,3,1,5,7,8,1,5,3,18,5,3,6,1,21,4,24,9,24,40,3,14,3,21,3,2,1,2,4,2,3,1,15,15,6,5,1,1,3,1,5,6,1,9,7,3,3,2,1,4,3,8,21,5,16,4,\n        5,2,10,11,11,3,6,3,2,9,3,6,13,1,2,1,1,1,1,11,12,6,6,1,4,2,6,5,2,1,1,3,3,6,13,3,1,1,5,1,2,3,3,14,2,1,2,2,2,5,1,9,5,1,1,6,12,3,12,3,4,13,2,14,\n        2,8,1,17,5,1,16,4,2,2,21,8,9,6,23,20,12,25,19,9,38,8,3,21,40,25,33,13,4,3,1,4,1,2,4,1,2,5,26,2,1,1,2,1,3,6,2,1,1,1,1,1,1,2,3,1,1,1,9,2,3,1,1,\n        1,3,6,3,2,1,1,6,6,1,8,2,2,2,1,4,1,2,3,2,7,3,2,4,1,2,1,2,2,1,1,1,1,1,3,1,2,5,4,10,9,4,9,1,1,1,1,1,1,5,3,2,1,6,4,9,6,1,10,2,31,17,8,3,7,5,40,1,\n        7,7,1,6,5,2,10,7,8,4,15,39,25,6,28,47,18,10,7,1,3,1,1,2,1,1,1,3,3,3,1,1,1,3,4,2,1,4,1,3,6,10,7,8,6,2,2,1,3,3,2,5,8,7,9,12,2,15,1,1,4,1,2,1,1,\n        1,3,2,1,3,3,5,6,2,3,2,10,1,4,2,8,1,1,1,11,6,1,21,4,16,3,1,3,1,4,2,3,6,5,1,3,1,1,3,3,4,6,1,1,10,4,2,7,10,4,7,4,2,9,4,3,1,1,1,4,1,8,3,4,1,3,1,\n        6,1,4,2,1,4,7,2,1,8,1,4,5,1,1,2,2,4,6,2,7,1,10,1,1,3,4,11,10,8,21,4,6,1,3,5,2,1,2,28,5,5,2,3,13,1,2,3,1,4,2,1,5,20,3,8,11,1,3,3,3,1,8,10,9,2,\n        10,9,2,3,1,1,2,4,1,8,3,6,1,7,8,6,11,1,4,29,8,4,3,1,2,7,13,1,4,1,6,2,6,12,12,2,20,3,2,3,6,4,8,9,2,7,34,5,1,18,6,1,1,4,4,5,7,9,1,2,2,4,3,4,1,7,\n        2,2,2,6,2,3,25,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,5,3,4,4,3,2,1,1,4,1,2,1,1,3,1,11,1,6,3,1,7,3,6,2,8,8,6,9,3,4,11,3,2,10,12,2,5,11,1,6,4,5,\n        3,1,8,5,4,6,6,3,5,1,1,3,2,1,2,2,6,17,12,1,10,1,6,12,1,6,6,19,9,6,16,1,13,4,4,15,7,17,6,11,9,15,12,6,7,2,1,2,2,15,9,3,21,4,6,49,18,7,3,2,3,1,\n        6,8,2,2,6,2,9,1,3,6,4,4,1,2,16,2,5,2,1,6,2,3,5,3,1,2,5,1,2,1,9,3,1,8,6,4,8,11,3,1,1,1,1,3,1,13,8,4,1,3,2,2,1,4,1,11,1,5,2,1,5,2,5,8,6,1,1,7,\n        4,3,8,3,2,7,2,1,5,1,5,2,4,7,6,2,8,5,1,11,4,5,3,6,18,1,2,13,3,3,1,21,1,1,4,1,4,1,1,1,8,1,2,2,7,1,2,4,2,2,9,2,1,1,1,4,3,6,3,12,5,1,1,1,5,6,3,2,\n        4,8,2,2,4,2,7,1,8,9,5,2,3,2,1,3,2,13,7,14,6,5,1,1,2,1,4,2,23,2,1,1,6,3,1,4,1,15,3,1,7,3,9,14,1,3,1,4,1,1,5,8,1,3,8,3,8,15,11,4,14,4,4,2,5,5,\n        1,7,1,6,14,7,7,8,5,15,4,8,6,5,6,2,1,13,1,20,15,11,9,2,5,6,2,11,2,6,2,5,1,5,8,4,13,19,25,4,1,1,11,1,34,2,5,9,14,6,2,2,6,1,1,14,1,3,14,13,1,6,\n        12,21,14,14,6,32,17,8,32,9,28,1,2,4,11,8,3,1,14,2,5,15,1,1,1,1,3,6,4,1,3,4,11,3,1,1,11,30,1,5,1,4,1,5,8,1,1,3,2,4,3,17,35,2,6,12,17,3,1,6,2,\n        1,1,12,2,7,3,3,2,1,16,2,8,3,6,5,4,7,3,3,8,1,9,8,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,4,3,7,5,8,3,3,3,3,3,3,1,23,10,3,1,2,2,6,3,1,16,1,16,\n        22,3,10,4,11,6,9,7,7,3,6,2,2,2,4,10,2,1,1,2,8,7,1,6,4,1,3,3,3,5,10,12,12,2,3,12,8,15,1,1,16,6,6,1,5,9,11,4,11,4,2,6,12,1,17,5,13,1,4,9,5,1,11,\n        2,1,8,1,5,7,28,8,3,5,10,2,17,3,38,22,1,2,18,12,10,4,38,18,1,4,44,19,4,1,8,4,1,12,1,4,31,12,1,14,7,75,7,5,10,6,6,13,3,2,11,11,3,2,5,28,15,6,18,\n        18,5,6,4,3,16,1,7,18,7,36,3,5,3,1,7,1,9,1,10,7,2,4,2,6,2,9,7,4,3,32,12,3,7,10,2,23,16,3,1,12,3,31,4,11,1,3,8,9,5,1,30,15,6,12,3,2,2,11,19,9,\n        14,2,6,2,3,19,13,17,5,3,3,25,3,14,1,1,1,36,1,3,2,19,3,13,36,9,13,31,6,4,16,34,2,5,4,2,3,3,5,1,1,1,4,3,1,17,3,2,3,5,3,1,3,2,3,5,6,3,12,11,1,3,\n        1,2,26,7,12,7,2,14,3,3,7,7,11,25,25,28,16,4,36,1,2,1,6,2,1,9,3,27,17,4,3,4,13,4,1,3,2,2,1,10,4,2,4,6,3,8,2,1,18,1,1,24,2,2,4,33,2,3,63,7,1,6,\n        40,7,3,4,4,2,4,15,18,1,16,1,1,11,2,41,14,1,3,18,13,3,2,4,16,2,17,7,15,24,7,18,13,44,2,2,3,6,1,1,7,5,1,7,1,4,3,3,5,10,8,2,3,1,8,1,1,27,4,2,1,\n        12,1,2,1,10,6,1,6,7,5,2,3,7,11,5,11,3,6,6,2,3,15,4,9,1,1,2,1,2,11,2,8,12,8,5,4,2,3,1,5,2,2,1,14,1,12,11,4,1,11,17,17,4,3,2,5,5,7,3,1,5,9,9,8,\n        2,5,6,6,13,13,2,1,2,6,1,2,2,49,4,9,1,2,10,16,7,8,4,3,2,23,4,58,3,29,1,14,19,19,11,11,2,7,5,1,3,4,6,2,18,5,12,12,17,17,3,3,2,4,1,6,2,3,4,3,1,\n        1,1,1,5,1,1,9,1,3,1,3,6,1,8,1,1,2,6,4,14,3,1,4,11,4,1,3,32,1,2,4,13,4,1,2,4,2,1,3,1,11,1,4,2,1,4,4,6,3,5,1,6,5,7,6,3,23,3,5,3,5,3,3,13,3,9,10,\n        1,12,10,2,3,18,13,7,160,52,4,2,2,3,2,14,5,4,12,4,6,4,1,20,4,11,6,2,12,27,1,4,1,2,2,7,4,5,2,28,3,7,25,8,3,19,3,6,10,2,2,1,10,2,5,4,1,3,4,1,5,\n        3,2,6,9,3,6,2,16,3,3,16,4,5,5,3,2,1,2,16,15,8,2,6,21,2,4,1,22,5,8,1,1,21,11,2,1,11,11,19,13,12,4,2,3,2,3,6,1,8,11,1,4,2,9,5,2,1,11,2,9,1,1,2,\n        14,31,9,3,4,21,14,4,8,1,7,2,2,2,5,1,4,20,3,3,4,10,1,11,9,8,2,1,4,5,14,12,14,2,17,9,6,31,4,14,1,20,13,26,5,2,7,3,6,13,2,4,2,19,6,2,2,18,9,3,5,\n        12,12,14,4,6,2,3,6,9,5,22,4,5,25,6,4,8,5,2,6,27,2,35,2,16,3,7,8,8,6,6,5,9,17,2,20,6,19,2,13,3,1,1,1,4,17,12,2,14,7,1,4,18,12,38,33,2,10,1,1,\n        2,13,14,17,11,50,6,33,20,26,74,16,23,45,50,13,38,33,6,6,7,4,4,2,1,3,2,5,8,7,8,9,3,11,21,9,13,1,3,10,6,7,1,2,2,18,5,5,1,9,9,2,68,9,19,13,2,5,\n        1,4,4,7,4,13,3,9,10,21,17,3,26,2,1,5,2,4,5,4,1,7,4,7,3,4,2,1,6,1,1,20,4,1,9,2,2,1,3,3,2,3,2,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,3,2,10,3,5,3,4,4,\n        3,4,16,1,6,1,10,2,4,2,1,1,2,10,11,2,2,3,1,24,31,4,10,10,2,5,12,16,164,15,4,16,7,9,15,19,17,1,2,1,1,5,1,1,1,1,1,3,1,4,3,1,3,1,3,1,2,1,1,3,3,7,\n        2,8,1,2,2,2,1,3,4,3,7,8,12,92,2,10,3,1,3,14,5,25,16,42,4,7,7,4,2,21,5,27,26,27,21,25,30,31,2,1,5,13,3,22,5,6,6,11,9,12,1,5,9,7,5,5,22,60,3,5,\n        13,1,1,8,1,1,3,3,2,1,9,3,3,18,4,1,2,3,7,6,3,1,2,3,9,1,3,1,3,2,1,3,1,1,1,2,1,11,3,1,6,9,1,3,2,3,1,2,1,5,1,1,4,3,4,1,2,2,4,4,1,7,2,1,2,2,3,5,13,\n        18,3,4,14,9,9,4,16,3,7,5,8,2,6,48,28,3,1,1,4,2,14,8,2,9,2,1,15,2,4,3,2,10,16,12,8,7,1,1,3,1,1,1,2,7,4,1,6,4,38,39,16,23,7,15,15,3,2,12,7,21,\n        37,27,6,5,4,8,2,10,8,8,6,5,1,2,1,3,24,1,16,17,9,23,10,17,6,1,51,55,44,13,294,9,3,6,2,4,2,2,15,1,1,1,13,21,17,68,14,8,9,4,1,4,9,3,11,7,1,1,1,\n        5,6,3,2,1,1,1,2,3,8,1,2,2,4,1,5,5,2,1,4,3,7,13,4,1,4,1,3,1,1,1,5,5,10,1,6,1,5,2,1,5,2,4,1,4,5,7,3,18,2,9,11,32,4,3,3,2,4,7,11,16,9,11,8,13,38,\n        32,8,4,2,1,1,2,1,2,4,4,1,1,1,4,1,21,3,11,1,16,1,1,6,1,3,2,4,9,8,57,7,44,1,3,3,13,3,10,1,1,7,5,2,7,21,47,63,3,15,4,7,1,16,1,1,2,8,2,3,42,15,4,\n        1,29,7,22,10,3,78,16,12,20,18,4,67,11,5,1,3,15,6,21,31,32,27,18,13,71,35,5,142,4,10,1,2,50,19,33,16,35,37,16,19,27,7,1,133,19,1,4,8,7,20,1,4,\n        4,1,10,3,1,6,1,2,51,5,40,15,24,43,22928,11,1,13,154,70,3,1,1,7,4,10,1,2,1,1,2,1,2,1,2,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,\n        3,2,1,1,1,1,2,1,1,\n    };\n    static ImWchar base_ranges[] = // not zero-terminated\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\n        0xFF00, 0xFFEF, // Half-width characters\n        0xFFFD, 0xFFFD  // Invalid\n    };\n    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };\n    if (!full_ranges[0])\n    {\n        memcpy(full_ranges, base_ranges, sizeof(base_ranges));\n        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));\n    }\n    return &full_ranges[0];\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement\n        0x2DE0, 0x2DFF, // Cyrillic Extended-A\n        0xA640, 0xA69F, // Cyrillic Extended-B\n        0,\n    };\n    return &ranges[0];\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesThai()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin\n        0x2010, 0x205E, // Punctuations\n        0x0E00, 0x0E7F, // Thai\n        0,\n    };\n    return &ranges[0];\n}\n\nconst ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()\n{\n    static const ImWchar ranges[] =\n    {\n        0x0020, 0x00FF, // Basic Latin\n        0x0102, 0x0103,\n        0x0110, 0x0111,\n        0x0128, 0x0129,\n        0x0168, 0x0169,\n        0x01A0, 0x01A1,\n        0x01AF, 0x01B0,\n        0x1EA0, 0x1EF9,\n        0,\n    };\n    return &ranges[0];\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImFontGlyphRangesBuilder\n//-----------------------------------------------------------------------------\n\nvoid ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)\n{\n    while (text_end ? (text < text_end) : *text)\n    {\n        unsigned int c = 0;\n        int c_len = ImTextCharFromUtf8(&c, text, text_end);\n        text += c_len;\n        if (c_len == 0)\n            break;\n        AddChar((ImWchar)c);\n    }\n}\n\nvoid ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)\n{\n    for (; ranges[0]; ranges += 2)\n        for (unsigned int c = ranges[0]; c <= ranges[1] && c <= IM_UNICODE_CODEPOINT_MAX; c++) //-V560\n            AddChar((ImWchar)c);\n}\n\nvoid ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)\n{\n    const int max_codepoint = IM_UNICODE_CODEPOINT_MAX;\n    for (int n = 0; n <= max_codepoint; n++)\n        if (GetBit(n))\n        {\n            out_ranges->push_back((ImWchar)n);\n            while (n < max_codepoint && GetBit(n + 1))\n                n++;\n            out_ranges->push_back((ImWchar)n);\n        }\n    out_ranges->push_back(0);\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImFont\n//-----------------------------------------------------------------------------\n\nImFont::ImFont()\n{\n    FontSize = 0.0f;\n    FallbackAdvanceX = 0.0f;\n    FallbackChar = 0;\n    EllipsisChar = 0;\n    EllipsisWidth = EllipsisCharStep = 0.0f;\n    EllipsisCharCount = 0;\n    FallbackGlyph = NULL;\n    ContainerAtlas = NULL;\n    ConfigData = NULL;\n    ConfigDataCount = 0;\n    DirtyLookupTables = false;\n    Scale = 1.0f;\n    Ascent = Descent = 0.0f;\n    MetricsTotalSurface = 0;\n    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));\n}\n\nImFont::~ImFont()\n{\n    ClearOutputData();\n}\n\nvoid    ImFont::ClearOutputData()\n{\n    FontSize = 0.0f;\n    FallbackAdvanceX = 0.0f;\n    Glyphs.clear();\n    IndexAdvanceX.clear();\n    IndexLookup.clear();\n    FallbackGlyph = NULL;\n    ContainerAtlas = NULL;\n    DirtyLookupTables = true;\n    Ascent = Descent = 0.0f;\n    MetricsTotalSurface = 0;\n    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));\n}\n\nstatic ImWchar FindFirstExistingGlyph(ImFont* font, const ImWchar* candidate_chars, int candidate_chars_count)\n{\n    for (int n = 0; n < candidate_chars_count; n++)\n        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)\n            return candidate_chars[n];\n    return 0;\n}\n\nvoid ImFont::BuildLookupTable()\n{\n    int max_codepoint = 0;\n    for (int i = 0; i != Glyphs.Size; i++)\n        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);\n\n    // Build lookup table\n    IM_ASSERT(Glyphs.Size > 0 && \"Font has not loaded glyph!\");\n    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved\n    IndexAdvanceX.clear();\n    IndexLookup.clear();\n    DirtyLookupTables = false;\n    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));\n    GrowIndex(max_codepoint + 1);\n    for (int i = 0; i < Glyphs.Size; i++)\n    {\n        int codepoint = (int)Glyphs[i].Codepoint;\n        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;\n        IndexLookup[codepoint] = (ImWchar)i;\n\n        // Mark 4K page as used\n        const int page_n = codepoint / 4096;\n        Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);\n    }\n\n    // Create a glyph to handle TAB\n    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at \"column 0\" ?)\n    if (FindGlyph((ImWchar)' '))\n    {\n        if (Glyphs.back().Codepoint != '\\t')   // So we can call this function multiple times (FIXME: Flaky)\n            Glyphs.resize(Glyphs.Size + 1);\n        ImFontGlyph& tab_glyph = Glyphs.back();\n        tab_glyph = *FindGlyph((ImWchar)' ');\n        tab_glyph.Codepoint = '\\t';\n        tab_glyph.AdvanceX *= IM_TABSIZE;\n        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;\n        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);\n    }\n\n    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)\n    SetGlyphVisible((ImWchar)' ', false);\n    SetGlyphVisible((ImWchar)'\\t', false);\n\n    // Setup Fallback character\n    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };\n    FallbackGlyph = FindGlyphNoFallback(FallbackChar);\n    if (FallbackGlyph == NULL)\n    {\n        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));\n        FallbackGlyph = FindGlyphNoFallback(FallbackChar);\n        if (FallbackGlyph == NULL)\n        {\n            FallbackGlyph = &Glyphs.back();\n            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;\n        }\n    }\n    FallbackAdvanceX = FallbackGlyph->AdvanceX;\n    for (int i = 0; i < max_codepoint + 1; i++)\n        if (IndexAdvanceX[i] < 0.0f)\n            IndexAdvanceX[i] = FallbackAdvanceX;\n\n    // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).\n    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.\n    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.\n    const ImWchar ellipsis_chars[] = { ConfigData->EllipsisChar, (ImWchar)0x2026, (ImWchar)0x0085 };\n    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };\n    if (EllipsisChar == 0)\n        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));\n    const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));\n    if (EllipsisChar != 0)\n    {\n        EllipsisCharCount = 1;\n        EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;\n    }\n    else if (dot_char != 0)\n    {\n        const ImFontGlyph* dot_glyph = FindGlyph(dot_char);\n        EllipsisChar = dot_char;\n        EllipsisCharCount = 3;\n        EllipsisCharStep = (float)(int)(dot_glyph->X1 - dot_glyph->X0) + 1.0f;\n        EllipsisWidth = ImMax(dot_glyph->AdvanceX, dot_glyph->X0 + EllipsisCharStep * 3.0f - 1.0f); // FIXME: Slightly odd for normally mono-space fonts but since this is used for trailing contents.\n    }\n}\n\n// API is designed this way to avoid exposing the 4K page size\n// e.g. use with IsGlyphRangeUnused(0, 255)\nbool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last)\n{\n    unsigned int page_begin = (c_begin / 4096);\n    unsigned int page_last = (c_last / 4096);\n    for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)\n        if ((page_n >> 3) < sizeof(Used4kPagesMap))\n            if (Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7)))\n                return false;\n    return true;\n}\n\nvoid ImFont::SetGlyphVisible(ImWchar c, bool visible)\n{\n    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))\n        glyph->Visible = visible ? 1 : 0;\n}\n\nvoid ImFont::GrowIndex(int new_size)\n{\n    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);\n    if (new_size <= IndexLookup.Size)\n        return;\n    IndexAdvanceX.resize(new_size, -1.0f);\n    IndexLookup.resize(new_size, (ImWchar)-1);\n}\n\n// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.\n// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).\n// 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.\nvoid ImFont::AddGlyph(const ImFontConfig* cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)\n{\n    if (cfg != NULL)\n    {\n        // Clamp & recenter if needed\n        const float advance_x_original = advance_x;\n        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);\n        if (advance_x != advance_x_original)\n        {\n            float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;\n            x0 += char_off_x;\n            x1 += char_off_x;\n        }\n\n        // Snap to pixel\n        if (cfg->PixelSnapH)\n            advance_x = IM_ROUND(advance_x);\n\n        // Bake spacing\n        advance_x += cfg->GlyphExtraSpacing.x;\n    }\n\n    int glyph_idx = Glyphs.Size;\n    Glyphs.resize(Glyphs.Size + 1);\n    ImFontGlyph& glyph = Glyphs[glyph_idx];\n    glyph.Codepoint = (unsigned int)codepoint;\n    glyph.Visible = (x0 != x1) && (y0 != y1);\n    glyph.Colored = false;\n    glyph.X0 = x0;\n    glyph.Y0 = y0;\n    glyph.X1 = x1;\n    glyph.Y1 = y1;\n    glyph.U0 = u0;\n    glyph.V0 = v0;\n    glyph.U1 = u1;\n    glyph.V1 = v1;\n    glyph.AdvanceX = advance_x;\n\n    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)\n    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.\n    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;\n    DirtyLookupTables = true;\n    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);\n}\n\nvoid ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)\n{\n    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.\n    unsigned int index_size = (unsigned int)IndexLookup.Size;\n\n    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists\n        return;\n    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op\n        return;\n\n    GrowIndex(dst + 1);\n    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;\n    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;\n}\n\n// Find glyph, return fallback if missing\nconst ImFontGlyph* ImFont::FindGlyph(ImWchar c)\n{\n    if (c >= (size_t)IndexLookup.Size)\n        return FallbackGlyph;\n    const ImWchar i = IndexLookup.Data[c];\n    if (i == (ImWchar)-1)\n        return FallbackGlyph;\n    return &Glyphs.Data[i];\n}\n\nconst ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c)\n{\n    if (c >= (size_t)IndexLookup.Size)\n        return NULL;\n    const ImWchar i = IndexLookup.Data[c];\n    if (i == (ImWchar)-1)\n        return NULL;\n    return &Glyphs.Data[i];\n}\n\n// Trim trailing space and find beginning of next line\nstatic inline const char* CalcWordWrapNextLineStartA(const char* text, const char* text_end)\n{\n    while (text < text_end && ImCharIsBlankA(*text))\n        text++;\n    if (*text == '\\n')\n        text++;\n    return text;\n}\n\n#define ImFontGetCharAdvanceX(_FONT, _CH)  ((int)(_CH) < (_FONT)->IndexAdvanceX.Size ? (_FONT)->IndexAdvanceX.Data[_CH] : (_FONT)->FallbackAdvanceX)\n\n// Simple word-wrapping for English, not full-featured. Please submit failing cases!\n// This will return the next location to wrap from. If no wrapping if necessary, this will fast-forward to e.g. text_end.\n// FIXME: Much possible improvements (don't cut things like \"word !\", \"word!!!\" but cut within \"word,,,,\", more sensible support for punctuations, support for Unicode punctuations, etc.)\nconst char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width)\n{\n    // For references, possible wrap point marked with ^\n    //  \"aaa bbb, ccc,ddd. eee   fff. ggg!\"\n    //      ^    ^    ^   ^   ^__    ^    ^\n\n    // List of hardcoded separators: .,;!?'\"\n\n    // Skip extra blanks after a line returns (that includes not counting them in width computation)\n    // e.g. \"Hello    world\" --> \"Hello\" \"World\"\n\n    // Cut words that cannot possibly fit within one line.\n    // e.g.: \"The tropical fish\" with ~5 characters worth of width --> \"The tr\" \"opical\" \"fish\"\n    float line_width = 0.0f;\n    float word_width = 0.0f;\n    float blank_width = 0.0f;\n    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters\n\n    const char* word_end = text;\n    const char* prev_word_end = NULL;\n    bool inside_word = true;\n\n    const char* s = text;\n    IM_ASSERT(text_end != NULL);\n    while (s < text_end)\n    {\n        unsigned int c = (unsigned int)*s;\n        const char* next_s;\n        if (c < 0x80)\n            next_s = s + 1;\n        else\n            next_s = s + ImTextCharFromUtf8(&c, s, text_end);\n\n        if (c < 32)\n        {\n            if (c == '\\n')\n            {\n                line_width = word_width = blank_width = 0.0f;\n                inside_word = true;\n                s = next_s;\n                continue;\n            }\n            if (c == '\\r')\n            {\n                s = next_s;\n                continue;\n            }\n        }\n\n        const float char_width = ImFontGetCharAdvanceX(this, c);\n        if (ImCharIsBlankW(c))\n        {\n            if (inside_word)\n            {\n                line_width += blank_width;\n                blank_width = 0.0f;\n                word_end = s;\n            }\n            blank_width += char_width;\n            inside_word = false;\n        }\n        else\n        {\n            word_width += char_width;\n            if (inside_word)\n            {\n                word_end = next_s;\n            }\n            else\n            {\n                prev_word_end = word_end;\n                line_width += word_width + blank_width;\n                word_width = blank_width = 0.0f;\n            }\n\n            // Allow wrapping after punctuation.\n            inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\\\"');\n        }\n\n        // We ignore blank width at the end of the line (they can be skipped)\n        if (line_width + word_width > wrap_width)\n        {\n            // Words that cannot possibly fit within an entire line will be cut anywhere.\n            if (word_width < wrap_width)\n                s = prev_word_end ? prev_word_end : word_end;\n            break;\n        }\n\n        s = next_s;\n    }\n\n    // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.\n    // +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).\n    if (s == text && text < text_end)\n        return s + 1;\n    return s;\n}\n\nImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining)\n{\n    if (!text_end)\n        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.\n\n    const float line_height = size;\n    const float scale = size / FontSize;\n\n    ImVec2 text_size = ImVec2(0, 0);\n    float line_width = 0.0f;\n\n    const bool word_wrap_enabled = (wrap_width > 0.0f);\n    const char* word_wrap_eol = NULL;\n\n    const char* s = text_begin;\n    while (s < text_end)\n    {\n        if (word_wrap_enabled)\n        {\n            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.\n            if (!word_wrap_eol)\n                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);\n\n            if (s >= word_wrap_eol)\n            {\n                if (text_size.x < line_width)\n                    text_size.x = line_width;\n                text_size.y += line_height;\n                line_width = 0.0f;\n                word_wrap_eol = NULL;\n                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks\n                continue;\n            }\n        }\n\n        // Decode and advance source\n        const char* prev_s = s;\n        unsigned int c = (unsigned int)*s;\n        if (c < 0x80)\n            s += 1;\n        else\n            s += ImTextCharFromUtf8(&c, s, text_end);\n\n        if (c < 32)\n        {\n            if (c == '\\n')\n            {\n                text_size.x = ImMax(text_size.x, line_width);\n                text_size.y += line_height;\n                line_width = 0.0f;\n                continue;\n            }\n            if (c == '\\r')\n                continue;\n        }\n\n        const float char_width = ImFontGetCharAdvanceX(this, c) * scale;\n        if (line_width + char_width >= max_width)\n        {\n            s = prev_s;\n            break;\n        }\n\n        line_width += char_width;\n    }\n\n    if (text_size.x < line_width)\n        text_size.x = line_width;\n\n    if (line_width > 0 || text_size.y == 0.0f)\n        text_size.y += line_height;\n\n    if (remaining)\n        *remaining = s;\n\n    return text_size;\n}\n\n// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.\nvoid ImFont::RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c)\n{\n    const ImFontGlyph* glyph = FindGlyph(c);\n    if (!glyph || !glyph->Visible)\n        return;\n    if (glyph->Colored)\n        col |= ~IM_COL32_A_MASK;\n    float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;\n    float x = IM_TRUNC(pos.x);\n    float y = IM_TRUNC(pos.y);\n    draw_list->PrimReserve(6, 4);\n    draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);\n}\n\n// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.\nvoid ImFont::RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip)\n{\n    if (!text_end)\n        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.\n\n    // Align to be pixel perfect\n    float x = IM_TRUNC(pos.x);\n    float y = IM_TRUNC(pos.y);\n    if (y > clip_rect.w)\n        return;\n\n    const float scale = size / FontSize;\n    const float line_height = FontSize * scale;\n    const float origin_x = x;\n    const bool word_wrap_enabled = (wrap_width > 0.0f);\n\n    // Fast-forward to first visible line\n    const char* s = text_begin;\n    if (y + line_height < clip_rect.y)\n        while (y + line_height < clip_rect.y && s < text_end)\n        {\n            const char* line_end = (const char*)memchr(s, '\\n', text_end - s);\n            if (word_wrap_enabled)\n            {\n                // FIXME-OPT: This is not optimal as do first do a search for \\n before calling CalcWordWrapPositionA().\n                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \\n we could combine both.\n                // However it is still better than nothing performing the fast-forward!\n                s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);\n                s = CalcWordWrapNextLineStartA(s, text_end);\n            }\n            else\n            {\n                s = line_end ? line_end + 1 : text_end;\n            }\n            y += line_height;\n        }\n\n    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()\n    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)\n    if (text_end - s > 10000 && !word_wrap_enabled)\n    {\n        const char* s_end = s;\n        float y_end = y;\n        while (y_end < clip_rect.w && s_end < text_end)\n        {\n            s_end = (const char*)memchr(s_end, '\\n', text_end - s_end);\n            s_end = s_end ? s_end + 1 : text_end;\n            y_end += line_height;\n        }\n        text_end = s_end;\n    }\n    if (s == text_end)\n        return;\n\n    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)\n    const int vtx_count_max = (int)(text_end - s) * 4;\n    const int idx_count_max = (int)(text_end - s) * 6;\n    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;\n    draw_list->PrimReserve(idx_count_max, vtx_count_max);\n    ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;\n    ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;\n    unsigned int vtx_index = draw_list->_VtxCurrentIdx;\n\n    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;\n    const char* word_wrap_eol = NULL;\n\n    while (s < text_end)\n    {\n        if (word_wrap_enabled)\n        {\n            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.\n            if (!word_wrap_eol)\n                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - origin_x));\n\n            if (s >= word_wrap_eol)\n            {\n                x = origin_x;\n                y += line_height;\n                if (y > clip_rect.w)\n                    break; // break out of main loop\n                word_wrap_eol = NULL;\n                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks\n                continue;\n            }\n        }\n\n        // Decode and advance source\n        unsigned int c = (unsigned int)*s;\n        if (c < 0x80)\n            s += 1;\n        else\n            s += ImTextCharFromUtf8(&c, s, text_end);\n\n        if (c < 32)\n        {\n            if (c == '\\n')\n            {\n                x = origin_x;\n                y += line_height;\n                if (y > clip_rect.w)\n                    break; // break out of main loop\n                continue;\n            }\n            if (c == '\\r')\n                continue;\n        }\n\n        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);\n        if (glyph == NULL)\n            continue;\n\n        float char_width = glyph->AdvanceX * scale;\n        if (glyph->Visible)\n        {\n            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w\n            float x1 = x + glyph->X0 * scale;\n            float x2 = x + glyph->X1 * scale;\n            float y1 = y + glyph->Y0 * scale;\n            float y2 = y + glyph->Y1 * scale;\n            if (x1 <= clip_rect.z && x2 >= clip_rect.x)\n            {\n                // Render a character\n                float u1 = glyph->U0;\n                float v1 = glyph->V0;\n                float u2 = glyph->U1;\n                float v2 = glyph->V1;\n\n                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.\n                if (cpu_fine_clip)\n                {\n                    if (x1 < clip_rect.x)\n                    {\n                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);\n                        x1 = clip_rect.x;\n                    }\n                    if (y1 < clip_rect.y)\n                    {\n                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);\n                        y1 = clip_rect.y;\n                    }\n                    if (x2 > clip_rect.z)\n                    {\n                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);\n                        x2 = clip_rect.z;\n                    }\n                    if (y2 > clip_rect.w)\n                    {\n                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);\n                        y2 = clip_rect.w;\n                    }\n                    if (y1 >= y2)\n                    {\n                        x += char_width;\n                        continue;\n                    }\n                }\n\n                // Support for untinted glyphs\n                ImU32 glyph_col = glyph->Colored ? col_untinted : col;\n\n                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:\n                {\n                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;\n                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;\n                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;\n                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;\n                    idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);\n                    idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);\n                    vtx_write += 4;\n                    vtx_index += 4;\n                    idx_write += 6;\n                }\n            }\n        }\n        x += char_width;\n    }\n\n    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.\n    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()\n    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);\n    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);\n    draw_list->_VtxWritePtr = vtx_write;\n    draw_list->_IdxWritePtr = idx_write;\n    draw_list->_VtxCurrentIdx = vtx_index;\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGui Internal Render Helpers\n//-----------------------------------------------------------------------------\n// Vaguely redesigned to stop accessing ImGui global state:\n// - RenderArrow()\n// - RenderBullet()\n// - RenderCheckMark()\n// - RenderArrowPointingAt()\n// - RenderRectFilledRangeH()\n// - RenderRectFilledWithHole()\n//-----------------------------------------------------------------------------\n// Function in need of a redesign (legacy mess)\n// - RenderColorRectWithAlphaCheckerboard()\n//-----------------------------------------------------------------------------\n\n// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state\nvoid ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)\n{\n    const float h = draw_list->_Data->FontSize * 1.00f;\n    float r = h * 0.40f * scale;\n    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);\n\n    ImVec2 a, b, c;\n    switch (dir)\n    {\n    case ImGuiDir_Up:\n    case ImGuiDir_Down:\n        if (dir == ImGuiDir_Up) r = -r;\n        a = ImVec2(+0.000f, +0.750f) * r;\n        b = ImVec2(-0.866f, -0.750f) * r;\n        c = ImVec2(+0.866f, -0.750f) * r;\n        break;\n    case ImGuiDir_Left:\n    case ImGuiDir_Right:\n        if (dir == ImGuiDir_Left) r = -r;\n        a = ImVec2(+0.750f, +0.000f) * r;\n        b = ImVec2(-0.750f, +0.866f) * r;\n        c = ImVec2(-0.750f, -0.866f) * r;\n        break;\n    case ImGuiDir_None:\n    case ImGuiDir_COUNT:\n        IM_ASSERT(0);\n        break;\n    }\n    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);\n}\n\nvoid ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)\n{\n    // FIXME-OPT: This should be baked in font.\n    draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);\n}\n\nvoid ImGui::RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz)\n{\n    float thickness = ImMax(sz / 5.0f, 1.0f);\n    sz -= thickness * 0.5f;\n    pos += ImVec2(thickness * 0.25f, thickness * 0.25f);\n\n    float third = sz / 3.0f;\n    float bx = pos.x + third;\n    float by = pos.y + sz - third * 0.5f;\n    draw_list->PathLineTo(ImVec2(bx - third, by - third));\n    draw_list->PathLineTo(ImVec2(bx, by));\n    draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));\n    draw_list->PathStroke(col, 0, thickness);\n}\n\n// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.\nvoid ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)\n{\n    switch (direction)\n    {\n    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;\n    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;\n    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;\n    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;\n    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings\n    }\n}\n\nstatic inline float ImAcos01(float x)\n{\n    if (x <= 0.0f) return IM_PI * 0.5f;\n    if (x >= 1.0f) return 0.0f;\n    return ImAcos(x);\n    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.\n}\n\n// FIXME: Cleanup and move code to ImDrawList.\nvoid ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)\n{\n    if (x_end_norm == x_start_norm)\n        return;\n    if (x_start_norm > x_end_norm)\n        ImSwap(x_start_norm, x_end_norm);\n\n    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);\n    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);\n    if (rounding == 0.0f)\n    {\n        draw_list->AddRectFilled(p0, p1, col, 0.0f);\n        return;\n    }\n\n    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);\n    const float inv_rounding = 1.0f / rounding;\n    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);\n    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);\n    const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.\n    const float x0 = ImMax(p0.x, rect.Min.x + rounding);\n    if (arc0_b == arc0_e)\n    {\n        draw_list->PathLineTo(ImVec2(x0, p1.y));\n        draw_list->PathLineTo(ImVec2(x0, p0.y));\n    }\n    else if (arc0_b == 0.0f && arc0_e == half_pi)\n    {\n        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL\n        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR\n    }\n    else\n    {\n        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b); // BL\n        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e); // TR\n    }\n    if (p1.x > rect.Min.x + rounding)\n    {\n        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);\n        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);\n        const float x1 = ImMin(p1.x, rect.Max.x - rounding);\n        if (arc1_b == arc1_e)\n        {\n            draw_list->PathLineTo(ImVec2(x1, p0.y));\n            draw_list->PathLineTo(ImVec2(x1, p1.y));\n        }\n        else if (arc1_b == 0.0f && arc1_e == half_pi)\n        {\n            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR\n            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR\n        }\n        else\n        {\n            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b); // TR\n            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e); // BR\n        }\n    }\n    draw_list->PathFillConvex(col);\n}\n\nvoid ImGui::RenderRectFilledWithHole(ImDrawList* draw_list, const ImRect& outer, const ImRect& inner, ImU32 col, float rounding)\n{\n    const bool fill_L = (inner.Min.x > outer.Min.x);\n    const bool fill_R = (inner.Max.x < outer.Max.x);\n    const bool fill_U = (inner.Min.y > outer.Min.y);\n    const bool fill_D = (inner.Max.y < outer.Max.y);\n    if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));\n    if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));\n    if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));\n    if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));\n    if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);\n    if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);\n    if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);\n    if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);\n}\n\n// Helper for ColorPicker4()\n// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.\n// Spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding altogether.\n// FIXME: uses ImGui::GetColorU32\nvoid ImGui::RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, ImDrawFlags flags)\n{\n    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)\n        flags = ImDrawFlags_RoundCornersDefault_;\n    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)\n    {\n        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col));\n        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col));\n        draw_list->AddRectFilled(p_min, p_max, col_bg1, rounding, flags);\n\n        int yi = 0;\n        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)\n        {\n            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);\n            if (y2 <= y1)\n                continue;\n            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)\n            {\n                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);\n                if (x2 <= x1)\n                    continue;\n                ImDrawFlags cell_flags = ImDrawFlags_RoundCornersNone;\n                if (y1 <= p_min.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersTopLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersTopRight; }\n                if (y2 >= p_max.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersBottomLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersBottomRight; }\n\n                // Combine flags\n                cell_flags = (flags == ImDrawFlags_RoundCornersNone || cell_flags == ImDrawFlags_RoundCornersNone) ? ImDrawFlags_RoundCornersNone : (cell_flags & flags);\n                draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);\n            }\n        }\n    }\n    else\n    {\n        draw_list->AddRectFilled(p_min, p_max, col, rounding, flags);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Decompression code\n//-----------------------------------------------------------------------------\n// Compressed with stb_compress() then converted to a C array and encoded as base85.\n// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.\n// The purpose of encoding as base85 instead of \"0x00,0x01,...\" style is only save on _source code_ size.\n// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h\n//-----------------------------------------------------------------------------\n\nstatic unsigned int stb_decompress_length(const unsigned char *input)\n{\n    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];\n}\n\nstatic unsigned char *stb__barrier_out_e, *stb__barrier_out_b;\nstatic const unsigned char *stb__barrier_in_b;\nstatic unsigned char *stb__dout;\nstatic void stb__match(const unsigned char *data, unsigned int length)\n{\n    // INVERSE of memmove... write each byte before copying the next...\n    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);\n    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }\n    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }\n    while (length--) *stb__dout++ = *data++;\n}\n\nstatic void stb__lit(const unsigned char *data, unsigned int length)\n{\n    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);\n    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }\n    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }\n    memcpy(stb__dout, data, length);\n    stb__dout += length;\n}\n\n#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])\n#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))\n#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))\n\nstatic const unsigned char *stb_decompress_token(const unsigned char *i)\n{\n    if (*i >= 0x20) { // use fewer if's for cases that expand small\n        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;\n        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;\n        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);\n    } else { // more ifs for cases that expand large, since overhead is amortized\n        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;\n        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;\n        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);\n        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);\n        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;\n        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;\n    }\n    return i;\n}\n\nstatic unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)\n{\n    const unsigned long ADLER_MOD = 65521;\n    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;\n    unsigned long blocklen = buflen % 5552;\n\n    unsigned long i;\n    while (buflen) {\n        for (i=0; i + 7 < blocklen; i += 8) {\n            s1 += buffer[0], s2 += s1;\n            s1 += buffer[1], s2 += s1;\n            s1 += buffer[2], s2 += s1;\n            s1 += buffer[3], s2 += s1;\n            s1 += buffer[4], s2 += s1;\n            s1 += buffer[5], s2 += s1;\n            s1 += buffer[6], s2 += s1;\n            s1 += buffer[7], s2 += s1;\n\n            buffer += 8;\n        }\n\n        for (; i < blocklen; ++i)\n            s1 += *buffer++, s2 += s1;\n\n        s1 %= ADLER_MOD, s2 %= ADLER_MOD;\n        buflen -= blocklen;\n        blocklen = 5552;\n    }\n    return (unsigned int)(s2 << 16) + (unsigned int)s1;\n}\n\nstatic unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)\n{\n    if (stb__in4(0) != 0x57bC0000) return 0;\n    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB\n    const unsigned int olen = stb_decompress_length(i);\n    stb__barrier_in_b = i;\n    stb__barrier_out_e = output + olen;\n    stb__barrier_out_b = output;\n    i += 16;\n\n    stb__dout = output;\n    for (;;) {\n        const unsigned char *old_i = i;\n        i = stb_decompress_token(i);\n        if (i == old_i) {\n            if (*i == 0x05 && i[1] == 0xfa) {\n                IM_ASSERT(stb__dout == output + olen);\n                if (stb__dout != output + olen) return 0;\n                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))\n                    return 0;\n                return olen;\n            } else {\n                IM_ASSERT(0); /* NOTREACHED */\n                return 0;\n            }\n        }\n        IM_ASSERT(stb__dout <= output + olen);\n        if (stb__dout > output + olen)\n            return 0;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Default font data (ProggyClean.ttf)\n//-----------------------------------------------------------------------------\n// ProggyClean.ttf\n// Copyright (c) 2004, 2005 Tristan Grimmer\n// MIT license (see License.txt in http://www.proggyfonts.net/index.php?menu=download)\n// Download and more information at http://www.proggyfonts.net or http://upperboundsinteractive.com/fonts.php\n//-----------------------------------------------------------------------------\n\n#ifndef IMGUI_DISABLE_DEFAULT_FONT\n\n// File: 'ProggyClean.ttf' (41208 bytes)\n// Exported using binary_to_compressed_c.exe -u8 \"ProggyClean.ttf\" proggy_clean_ttf\nstatic const unsigned int proggy_clean_ttf_compressed_size = 9583;\nstatic const unsigned char proggy_clean_ttf_compressed_data[9583] =\n{\n    87,188,0,0,0,0,0,0,0,0,160,248,0,4,0,0,55,0,1,0,0,0,12,0,128,0,3,0,64,79,83,47,50,136,235,116,144,0,0,1,72,130,21,44,78,99,109,97,112,2,18,35,117,0,0,3,160,130,19,36,82,99,118,116,\n    32,130,23,130,2,33,4,252,130,4,56,2,103,108,121,102,18,175,137,86,0,0,7,4,0,0,146,128,104,101,97,100,215,145,102,211,130,27,32,204,130,3,33,54,104,130,16,39,8,66,1,195,0,0,1,4,130,\n    15,59,36,104,109,116,120,138,0,126,128,0,0,1,152,0,0,2,6,108,111,99,97,140,115,176,216,0,0,5,130,30,41,2,4,109,97,120,112,1,174,0,218,130,31,32,40,130,16,44,32,110,97,109,101,37,89,\n    187,150,0,0,153,132,130,19,44,158,112,111,115,116,166,172,131,239,0,0,155,36,130,51,44,210,112,114,101,112,105,2,1,18,0,0,4,244,130,47,32,8,132,203,46,1,0,0,60,85,233,213,95,15,60,\n    245,0,3,8,0,131,0,34,183,103,119,130,63,43,0,0,189,146,166,215,0,0,254,128,3,128,131,111,130,241,33,2,0,133,0,32,1,130,65,38,192,254,64,0,0,3,128,131,16,130,5,32,1,131,7,138,3,33,2,\n    0,130,17,36,1,1,0,144,0,130,121,130,23,38,2,0,8,0,64,0,10,130,9,32,118,130,9,130,6,32,0,130,59,33,1,144,131,200,35,2,188,2,138,130,16,32,143,133,7,37,1,197,0,50,2,0,131,0,33,4,9,131,\n    5,145,3,43,65,108,116,115,0,64,0,0,32,172,8,0,131,0,35,5,0,1,128,131,77,131,3,33,3,128,191,1,33,1,128,130,184,35,0,0,128,0,130,3,131,11,32,1,130,7,33,0,128,131,1,32,1,136,9,32,0,132,\n    15,135,5,32,1,131,13,135,27,144,35,32,1,149,25,131,21,32,0,130,0,32,128,132,103,130,35,132,39,32,0,136,45,136,97,133,17,130,5,33,0,0,136,19,34,0,128,1,133,13,133,5,32,128,130,15,132,\n    131,32,3,130,5,32,3,132,27,144,71,32,0,133,27,130,29,130,31,136,29,131,63,131,3,65,63,5,132,5,132,205,130,9,33,0,0,131,9,137,119,32,3,132,19,138,243,130,55,32,1,132,35,135,19,131,201,\n    136,11,132,143,137,13,130,41,32,0,131,3,144,35,33,128,0,135,1,131,223,131,3,141,17,134,13,136,63,134,15,136,53,143,15,130,96,33,0,3,131,4,130,3,34,28,0,1,130,5,34,0,0,76,130,17,131,\n    9,36,28,0,4,0,48,130,17,46,8,0,8,0,2,0,0,0,127,0,255,32,172,255,255,130,9,34,0,0,129,132,9,130,102,33,223,213,134,53,132,22,33,1,6,132,6,64,4,215,32,129,165,216,39,177,0,1,141,184,\n    1,255,133,134,45,33,198,0,193,1,8,190,244,1,28,1,158,2,20,2,136,2,252,3,20,3,88,3,156,3,222,4,20,4,50,4,80,4,98,4,162,5,22,5,102,5,188,6,18,6,116,6,214,7,56,7,126,7,236,8,78,8,108,\n    8,150,8,208,9,16,9,74,9,136,10,22,10,128,11,4,11,86,11,200,12,46,12,130,12,234,13,94,13,164,13,234,14,80,14,150,15,40,15,176,16,18,16,116,16,224,17,82,17,182,18,4,18,110,18,196,19,\n    76,19,172,19,246,20,88,20,174,20,234,21,64,21,128,21,166,21,184,22,18,22,126,22,198,23,52,23,142,23,224,24,86,24,186,24,238,25,54,25,150,25,212,26,72,26,156,26,240,27,92,27,200,28,\n    4,28,76,28,150,28,234,29,42,29,146,29,210,30,64,30,142,30,224,31,36,31,118,31,166,31,166,32,16,130,1,52,46,32,138,32,178,32,200,33,20,33,116,33,152,33,238,34,98,34,134,35,12,130,1,\n    33,128,35,131,1,60,152,35,176,35,216,36,0,36,74,36,104,36,144,36,174,37,6,37,96,37,130,37,248,37,248,38,88,38,170,130,1,8,190,216,39,64,39,154,40,10,40,104,40,168,41,14,41,32,41,184,\n    41,248,42,54,42,96,42,96,43,2,43,42,43,94,43,172,43,230,44,32,44,52,44,154,45,40,45,92,45,120,45,170,45,232,46,38,46,166,47,38,47,182,47,244,48,94,48,200,49,62,49,180,50,30,50,158,\n    51,30,51,130,51,238,52,92,52,206,53,58,53,134,53,212,54,38,54,114,54,230,55,118,55,216,56,58,56,166,57,18,57,116,57,174,58,46,58,154,59,6,59,124,59,232,60,58,60,150,61,34,61,134,61,\n    236,62,86,62,198,63,42,63,154,64,18,64,106,64,208,65,54,65,162,66,8,66,64,66,122,66,184,66,240,67,98,67,204,68,42,68,138,68,238,69,88,69,182,69,226,70,84,70,180,71,20,71,122,71,218,\n    72,84,72,198,73,64,0,36,70,21,8,8,77,3,0,7,0,11,0,15,0,19,0,23,0,27,0,31,0,35,0,39,0,43,0,47,0,51,0,55,0,59,0,63,0,67,0,71,0,75,0,79,0,83,0,87,0,91,0,95,0,99,0,103,0,107,0,111,0,115,\n    0,119,0,123,0,127,0,131,0,135,0,139,0,143,0,0,17,53,51,21,49,150,3,32,5,130,23,32,33,130,3,211,7,151,115,32,128,133,0,37,252,128,128,2,128,128,190,5,133,74,32,4,133,6,206,5,42,0,7,\n    1,128,0,0,2,0,4,0,0,65,139,13,37,0,1,53,51,21,7,146,3,32,3,130,19,32,1,141,133,32,3,141,14,131,13,38,255,0,128,128,0,6,1,130,84,35,2,128,4,128,140,91,132,89,32,51,65,143,6,139,7,33,\n    1,0,130,57,32,254,130,3,32,128,132,4,32,4,131,14,138,89,35,0,0,24,0,130,0,33,3,128,144,171,66,55,33,148,115,65,187,19,32,5,130,151,143,155,163,39,32,1,136,182,32,253,134,178,132,7,\n    132,200,145,17,32,3,65,48,17,165,17,39,0,0,21,0,128,255,128,3,65,175,17,65,3,27,132,253,131,217,139,201,155,233,155,27,131,67,131,31,130,241,33,255,0,131,181,137,232,132,15,132,4,138,\n    247,34,255,0,128,179,238,32,0,130,0,32,20,65,239,48,33,0,19,67,235,10,32,51,65,203,14,65,215,11,32,7,154,27,135,39,32,33,130,35,33,128,128,130,231,32,253,132,231,32,128,132,232,34,\n    128,128,254,133,13,136,8,32,253,65,186,5,130,36,130,42,176,234,133,231,34,128,0,0,66,215,44,33,0,1,68,235,6,68,211,19,32,49,68,239,14,139,207,139,47,66,13,7,32,51,130,47,33,1,0,130,\n    207,35,128,128,1,0,131,222,131,5,130,212,130,6,131,212,32,0,130,10,133,220,130,233,130,226,32,254,133,255,178,233,39,3,1,128,3,0,2,0,4,68,15,7,68,99,12,130,89,130,104,33,128,4,133,\n    93,130,10,38,0,0,11,1,0,255,0,68,63,16,70,39,9,66,215,8,32,7,68,77,6,68,175,14,32,29,68,195,6,132,7,35,2,0,128,255,131,91,132,4,65,178,5,141,111,67,129,23,165,135,140,107,142,135,33,\n    21,5,69,71,6,131,7,33,1,0,140,104,132,142,130,4,137,247,140,30,68,255,12,39,11,0,128,0,128,3,0,3,69,171,15,67,251,7,65,15,8,66,249,11,65,229,7,67,211,7,66,13,7,35,1,128,128,254,133,\n    93,32,254,131,145,132,4,132,18,32,2,151,128,130,23,34,0,0,9,154,131,65,207,8,68,107,15,68,51,7,32,7,70,59,7,135,121,130,82,32,128,151,111,41,0,0,4,0,128,255,0,1,128,1,137,239,33,0,\n    37,70,145,10,65,77,10,65,212,14,37,0,0,0,5,0,128,66,109,5,70,123,10,33,0,19,72,33,18,133,237,70,209,11,33,0,2,130,113,137,119,136,115,33,1,0,133,43,130,5,34,0,0,10,69,135,6,70,219,\n    13,66,155,7,65,9,12,66,157,11,66,9,11,32,7,130,141,132,252,66,151,9,137,9,66,15,30,36,0,20,0,128,0,130,218,71,11,42,68,51,8,65,141,7,73,19,15,69,47,23,143,39,66,81,7,32,1,66,55,6,34,\n    1,128,128,68,25,5,69,32,6,137,6,136,25,32,254,131,42,32,3,66,88,26,148,26,32,0,130,0,32,14,164,231,70,225,12,66,233,7,67,133,19,71,203,15,130,161,32,255,130,155,32,254,139,127,134,\n    12,164,174,33,0,15,164,159,33,59,0,65,125,20,66,25,7,32,5,68,191,6,66,29,7,144,165,65,105,9,35,128,128,255,0,137,2,133,182,164,169,33,128,128,197,171,130,155,68,235,7,32,21,70,77,19,\n    66,21,10,68,97,8,66,30,5,66,4,43,34,0,17,0,71,19,41,65,253,20,71,25,23,65,91,15,65,115,7,34,2,128,128,66,9,8,130,169,33,1,0,66,212,13,132,28,72,201,43,35,0,0,0,18,66,27,38,76,231,5,\n    68,157,20,135,157,32,7,68,185,13,65,129,28,66,20,5,32,253,66,210,11,65,128,49,133,61,32,0,65,135,6,74,111,37,72,149,12,66,203,19,65,147,19,68,93,7,68,85,8,76,4,5,33,255,0,133,129,34,\n    254,0,128,68,69,8,181,197,34,0,0,12,65,135,32,65,123,20,69,183,27,133,156,66,50,5,72,87,10,67,137,32,33,0,19,160,139,78,251,13,68,55,20,67,119,19,65,91,36,69,177,15,32,254,143,16,65,\n    98,53,32,128,130,0,32,0,66,43,54,70,141,23,66,23,15,131,39,69,47,11,131,15,70,129,19,74,161,9,36,128,255,0,128,254,130,153,65,148,32,67,41,9,34,0,0,4,79,15,5,73,99,10,71,203,8,32,3,\n    72,123,6,72,43,8,32,2,133,56,131,99,130,9,34,0,0,6,72,175,5,73,159,14,144,63,135,197,132,189,133,66,33,255,0,73,6,7,70,137,12,35,0,0,0,10,130,3,73,243,25,67,113,12,65,73,7,69,161,7,\n    138,7,37,21,2,0,128,128,254,134,3,73,116,27,33,128,128,130,111,39,12,0,128,1,0,3,128,2,72,219,21,35,43,0,47,0,67,47,20,130,111,33,21,1,68,167,13,81,147,8,133,230,32,128,77,73,6,32,\n    128,131,142,134,18,130,6,32,255,75,18,12,131,243,37,128,0,128,3,128,3,74,231,21,135,123,32,29,134,107,135,7,32,21,74,117,7,135,7,134,96,135,246,74,103,23,132,242,33,0,10,67,151,28,\n    67,133,20,66,141,11,131,11,32,3,77,71,6,32,128,130,113,32,1,81,4,6,134,218,66,130,24,131,31,34,0,26,0,130,0,77,255,44,83,15,11,148,155,68,13,7,32,49,78,231,18,79,7,11,73,243,11,32,\n    33,65,187,10,130,63,65,87,8,73,239,19,35,0,128,1,0,131,226,32,252,65,100,6,32,128,139,8,33,1,0,130,21,32,253,72,155,44,73,255,20,32,128,71,67,8,81,243,39,67,15,20,74,191,23,68,121,\n    27,32,1,66,150,6,32,254,79,19,11,131,214,32,128,130,215,37,2,0,128,253,0,128,136,5,65,220,24,147,212,130,210,33,0,24,72,219,42,84,255,13,67,119,16,69,245,19,72,225,19,65,3,15,69,93,\n    19,131,55,132,178,71,115,14,81,228,6,142,245,33,253,0,132,43,172,252,65,16,11,75,219,8,65,219,31,66,223,24,75,223,10,33,29,1,80,243,10,66,175,8,131,110,134,203,133,172,130,16,70,30,\n    7,164,183,130,163,32,20,65,171,48,65,163,36,65,143,23,65,151,19,65,147,13,65,134,17,133,17,130,216,67,114,5,164,217,65,137,12,72,147,48,79,71,19,74,169,22,80,251,8,65,173,7,66,157,\n    15,74,173,15,32,254,65,170,8,71,186,45,72,131,6,77,143,40,187,195,152,179,65,123,38,68,215,57,68,179,15,65,85,7,69,187,14,32,21,66,95,15,67,19,25,32,1,83,223,6,32,2,76,240,7,77,166,\n    43,65,8,5,130,206,32,0,67,39,54,143,167,66,255,19,82,193,11,151,47,85,171,5,67,27,17,132,160,69,172,11,69,184,56,66,95,6,33,12,1,130,237,32,2,68,179,27,68,175,16,80,135,15,72,55,7,\n    71,87,12,73,3,12,132,12,66,75,32,76,215,5,169,139,147,135,148,139,81,12,12,81,185,36,75,251,7,65,23,27,76,215,9,87,165,12,65,209,15,72,157,7,65,245,31,32,128,71,128,6,32,1,82,125,5,\n    34,0,128,254,131,169,32,254,131,187,71,180,9,132,27,32,2,88,129,44,32,0,78,47,40,65,79,23,79,171,14,32,21,71,87,8,72,15,14,65,224,33,130,139,74,27,62,93,23,7,68,31,7,75,27,7,139,15,\n    74,3,7,74,23,27,65,165,11,65,177,15,67,123,5,32,1,130,221,32,252,71,96,5,74,12,12,133,244,130,25,34,1,0,128,130,2,139,8,93,26,8,65,9,32,65,57,14,140,14,32,0,73,79,67,68,119,11,135,\n    11,32,51,90,75,14,139,247,65,43,7,131,19,139,11,69,159,11,65,247,6,36,1,128,128,253,0,90,71,9,33,1,0,132,14,32,128,89,93,14,69,133,6,130,44,131,30,131,6,65,20,56,33,0,16,72,179,40,\n    75,47,12,65,215,19,74,95,19,65,43,11,131,168,67,110,5,75,23,17,69,106,6,75,65,5,71,204,43,32,0,80,75,47,71,203,15,159,181,68,91,11,67,197,7,73,101,13,68,85,6,33,128,128,130,214,130,\n    25,32,254,74,236,48,130,194,37,0,18,0,128,255,128,77,215,40,65,139,64,32,51,80,159,10,65,147,39,130,219,84,212,43,130,46,75,19,97,74,33,11,65,201,23,65,173,31,33,1,0,79,133,6,66,150,\n    5,67,75,48,85,187,6,70,207,37,32,71,87,221,13,73,163,14,80,167,15,132,15,83,193,19,82,209,8,78,99,9,72,190,11,77,110,49,89,63,5,80,91,35,99,63,32,70,235,23,81,99,10,69,148,10,65,110,\n    36,32,0,65,99,47,95,219,11,68,171,51,66,87,7,72,57,7,74,45,17,143,17,65,114,50,33,14,0,65,111,40,159,195,98,135,15,35,7,53,51,21,100,78,9,95,146,16,32,254,82,114,6,32,128,67,208,37,\n    130,166,99,79,58,32,17,96,99,14,72,31,19,72,87,31,82,155,7,67,47,14,32,21,131,75,134,231,72,51,17,72,78,8,133,8,80,133,6,33,253,128,88,37,9,66,124,36,72,65,12,134,12,71,55,43,66,139,\n    27,85,135,10,91,33,12,65,35,11,66,131,11,71,32,8,90,127,6,130,244,71,76,11,168,207,33,0,12,66,123,32,32,0,65,183,15,68,135,11,66,111,7,67,235,11,66,111,15,32,254,97,66,12,160,154,67,\n    227,52,80,33,15,87,249,15,93,45,31,75,111,12,93,45,11,77,99,9,160,184,81,31,12,32,15,98,135,30,104,175,7,77,249,36,69,73,15,78,5,12,32,254,66,151,19,34,128,128,4,87,32,12,149,35,133,\n    21,96,151,31,32,19,72,35,5,98,173,15,143,15,32,21,143,99,158,129,33,0,0,65,35,52,65,11,15,147,15,98,75,11,33,1,0,143,151,132,15,32,254,99,200,37,132,43,130,4,39,0,10,0,128,1,128,3,\n    0,104,151,14,97,187,20,69,131,15,67,195,11,87,227,7,33,128,128,132,128,33,254,0,68,131,9,65,46,26,42,0,0,0,7,0,0,255,128,3,128,0,88,223,15,33,0,21,89,61,22,66,209,12,65,2,12,37,0,2,\n    1,0,3,128,101,83,8,36,0,1,53,51,29,130,3,34,21,1,0,66,53,8,32,0,68,215,6,100,55,25,107,111,9,66,193,11,72,167,8,73,143,31,139,31,33,1,0,131,158,32,254,132,5,33,253,128,65,16,9,133,\n    17,89,130,25,141,212,33,0,0,93,39,8,90,131,25,93,39,14,66,217,6,106,179,8,159,181,71,125,15,139,47,138,141,87,11,14,76,23,14,65,231,26,140,209,66,122,8,81,179,5,101,195,26,32,47,74,\n    75,13,69,159,11,83,235,11,67,21,16,136,167,131,106,130,165,130,15,32,128,101,90,24,134,142,32,0,65,103,51,108,23,11,101,231,15,75,173,23,74,237,23,66,15,6,66,46,17,66,58,17,65,105,\n    49,66,247,55,71,179,12,70,139,15,86,229,7,84,167,15,32,1,95,72,12,89,49,6,33,128,128,65,136,38,66,30,9,32,0,100,239,7,66,247,29,70,105,20,65,141,19,69,81,15,130,144,32,128,83,41,5,\n    32,255,131,177,68,185,5,133,126,65,97,37,32,0,130,0,33,21,0,130,55,66,195,28,67,155,13,34,79,0,83,66,213,13,73,241,19,66,59,19,65,125,11,135,201,66,249,16,32,128,66,44,11,66,56,17,\n    68,143,8,68,124,38,67,183,12,96,211,9,65,143,29,112,171,5,32,0,68,131,63,34,33,53,51,71,121,11,32,254,98,251,16,32,253,74,231,10,65,175,37,133,206,37,0,0,8,1,0,0,107,123,11,113,115,\n    9,33,0,1,130,117,131,3,73,103,7,66,51,18,66,44,5,133,75,70,88,5,32,254,65,39,12,68,80,9,34,12,0,128,107,179,28,68,223,6,155,111,86,147,15,32,2,131,82,141,110,33,254,0,130,15,32,4,103,\n    184,15,141,35,87,176,5,83,11,5,71,235,23,114,107,11,65,189,16,70,33,15,86,153,31,135,126,86,145,30,65,183,41,32,0,130,0,32,10,65,183,24,34,35,0,39,67,85,9,65,179,15,143,15,33,1,0,65,\n    28,17,157,136,130,123,32,20,130,3,32,0,97,135,24,115,167,19,80,71,12,32,51,110,163,14,78,35,19,131,19,155,23,77,229,8,78,9,17,151,17,67,231,46,94,135,8,73,31,31,93,215,56,82,171,25,\n    72,77,8,162,179,169,167,99,131,11,69,85,19,66,215,15,76,129,13,68,115,22,72,79,35,67,113,5,34,0,0,19,70,31,46,65,89,52,73,223,15,85,199,33,95,33,8,132,203,73,29,32,67,48,16,177,215,\n    101,13,15,65,141,43,69,141,15,75,89,5,70,0,11,70,235,21,178,215,36,10,0,128,0,0,71,207,24,33,0,19,100,67,6,80,215,11,66,67,7,80,43,12,71,106,7,80,192,5,65,63,5,66,217,26,33,0,13,156,\n    119,68,95,5,72,233,12,134,129,85,81,11,76,165,20,65,43,8,73,136,8,75,10,31,38,128,128,0,0,0,13,1,130,4,32,3,106,235,29,114,179,12,66,131,23,32,7,77,133,6,67,89,12,131,139,116,60,9,\n    89,15,37,32,0,74,15,7,103,11,22,65,35,5,33,55,0,93,81,28,67,239,23,78,85,5,107,93,14,66,84,17,65,193,26,74,183,10,66,67,34,143,135,79,91,15,32,7,117,111,8,75,56,9,84,212,9,154,134,\n    32,0,130,0,32,18,130,3,70,171,41,83,7,16,70,131,19,84,191,15,84,175,19,84,167,30,84,158,12,154,193,68,107,15,33,0,0,65,79,42,65,71,7,73,55,7,118,191,16,83,180,9,32,255,76,166,9,154,\n    141,32,0,130,0,69,195,52,65,225,15,151,15,75,215,31,80,56,10,68,240,17,100,32,9,70,147,39,65,93,12,71,71,41,92,85,15,84,135,23,78,35,15,110,27,10,84,125,8,107,115,29,136,160,38,0,0,\n    14,0,128,255,0,82,155,24,67,239,8,119,255,11,69,131,11,77,29,6,112,31,8,134,27,105,203,8,32,2,75,51,11,75,195,12,74,13,29,136,161,37,128,0,0,0,11,1,130,163,82,115,8,125,191,17,69,35,\n    12,74,137,15,143,15,32,1,65,157,12,136,12,161,142,65,43,40,65,199,6,65,19,24,102,185,11,76,123,11,99,6,12,135,12,32,254,130,8,161,155,101,23,9,39,8,0,0,1,128,3,128,2,78,63,17,72,245,\n    12,67,41,11,90,167,9,32,128,97,49,9,32,128,109,51,14,132,97,81,191,8,130,97,125,99,12,121,35,9,127,75,15,71,79,12,81,151,23,87,97,7,70,223,15,80,245,16,105,97,15,32,254,113,17,6,32,\n    128,130,8,105,105,8,76,122,18,65,243,21,74,63,7,38,4,1,0,255,0,2,0,119,247,28,133,65,32,255,141,91,35,0,0,0,16,67,63,36,34,59,0,63,77,59,9,119,147,11,143,241,66,173,15,66,31,11,67,\n    75,8,81,74,16,32,128,131,255,87,181,42,127,43,5,34,255,128,2,120,235,11,37,19,0,23,0,0,37,109,191,14,118,219,7,127,43,14,65,79,14,35,0,0,0,3,73,91,5,130,5,38,3,0,7,0,11,0,0,70,205,\n    11,88,221,12,32,0,73,135,7,87,15,22,73,135,10,79,153,15,97,71,19,65,49,11,32,1,131,104,121,235,11,80,65,11,142,179,144,14,81,123,46,32,1,88,217,5,112,5,8,65,201,15,83,29,15,122,147,\n    11,135,179,142,175,143,185,67,247,39,66,199,7,35,5,0,128,3,69,203,15,123,163,12,67,127,7,130,119,71,153,10,141,102,70,175,8,32,128,121,235,30,136,89,100,191,11,116,195,11,111,235,15,\n    72,39,7,32,2,97,43,5,132,5,94,67,8,131,8,125,253,10,32,3,65,158,16,146,16,130,170,40,0,21,0,128,0,0,3,128,5,88,219,15,24,64,159,32,135,141,65,167,15,68,163,10,97,73,49,32,255,82,58,\n    7,93,80,8,97,81,16,24,67,87,52,34,0,0,5,130,231,33,128,2,80,51,13,65,129,8,113,61,6,132,175,65,219,5,130,136,77,152,17,32,0,95,131,61,70,215,6,33,21,51,90,53,10,78,97,23,105,77,31,\n    65,117,7,139,75,24,68,195,9,24,64,22,9,33,0,128,130,11,33,128,128,66,25,5,121,38,5,134,5,134,45,66,40,36,66,59,18,34,128,0,0,66,59,81,135,245,123,103,19,120,159,19,77,175,12,33,255,\n    0,87,29,10,94,70,21,66,59,54,39,3,1,128,3,0,2,128,4,24,65,7,15,66,47,7,72,98,12,37,0,0,0,3,1,0,24,65,55,21,131,195,32,1,67,178,6,33,4,0,77,141,8,32,6,131,47,74,67,16,24,69,3,20,24,\n    65,251,7,133,234,130,229,94,108,17,35,0,0,6,0,141,175,86,59,5,162,79,85,166,8,70,112,13,32,13,24,64,67,26,24,71,255,7,123,211,12,80,121,11,69,215,15,66,217,11,69,71,10,131,113,132,\n    126,119,90,9,66,117,19,132,19,32,0,130,0,24,64,47,59,33,7,0,73,227,5,68,243,15,85,13,12,76,37,22,74,254,15,130,138,33,0,4,65,111,6,137,79,65,107,16,32,1,77,200,6,34,128,128,3,75,154,\n    12,37,0,16,0,0,2,0,104,115,36,140,157,68,67,19,68,51,15,106,243,15,134,120,70,37,10,68,27,10,140,152,65,121,24,32,128,94,155,7,67,11,8,24,74,11,25,65,3,12,83,89,18,82,21,37,67,200,\n    5,130,144,24,64,172,12,33,4,0,134,162,74,80,14,145,184,32,0,130,0,69,251,20,32,19,81,243,5,82,143,8,33,5,53,89,203,5,133,112,79,109,15,33,0,21,130,71,80,175,41,36,75,0,79,0,83,121,\n    117,9,87,89,27,66,103,11,70,13,15,75,191,11,135,67,87,97,20,109,203,5,69,246,8,108,171,5,78,195,38,65,51,13,107,203,11,77,3,17,24,75,239,17,65,229,28,79,129,39,130,175,32,128,123,253,\n    7,132,142,24,65,51,15,65,239,41,36,128,128,0,0,13,65,171,5,66,163,28,136,183,118,137,11,80,255,15,67,65,7,74,111,8,32,0,130,157,32,253,24,76,35,10,103,212,5,81,175,9,69,141,7,66,150,\n    29,131,158,24,75,199,28,124,185,7,76,205,15,68,124,14,32,3,123,139,16,130,16,33,128,128,108,199,6,33,0,3,65,191,35,107,11,6,73,197,11,24,70,121,15,83,247,15,24,70,173,23,69,205,14,\n    32,253,131,140,32,254,136,4,94,198,9,32,3,78,4,13,66,127,13,143,13,32,0,130,0,33,16,0,24,69,59,39,109,147,12,76,253,19,24,69,207,15,69,229,15,130,195,71,90,10,139,10,130,152,73,43,\n    40,91,139,10,65,131,37,35,75,0,79,0,84,227,12,143,151,68,25,15,80,9,23,95,169,11,34,128,2,128,112,186,5,130,6,83,161,19,76,50,6,130,37,65,145,44,110,83,5,32,16,67,99,6,71,67,15,76,\n    55,17,140,215,67,97,23,76,69,15,77,237,11,104,211,23,77,238,11,65,154,43,33,0,10,83,15,28,83,13,20,67,145,19,67,141,14,97,149,21,68,9,15,86,251,5,66,207,5,66,27,37,82,1,23,127,71,12,\n    94,235,10,110,175,24,98,243,15,132,154,132,4,24,66,69,10,32,4,67,156,43,130,198,35,2,1,0,4,75,27,9,69,85,9,95,240,7,32,128,130,35,32,28,66,43,40,24,82,63,23,83,123,12,72,231,15,127,\n    59,23,116,23,19,117,71,7,24,77,99,15,67,111,15,71,101,8,36,2,128,128,252,128,127,60,11,32,1,132,16,130,18,141,24,67,107,9,32,3,68,194,15,175,15,38,0,11,0,128,1,128,2,80,63,25,32,0,\n    24,65,73,11,69,185,15,83,243,16,32,0,24,81,165,8,130,86,77,35,6,155,163,88,203,5,24,66,195,30,70,19,19,24,80,133,15,32,1,75,211,8,32,254,108,133,8,79,87,20,65,32,9,41,0,0,7,0,128,0,\n    0,2,128,2,68,87,15,66,1,16,92,201,16,24,76,24,17,133,17,34,128,0,30,66,127,64,34,115,0,119,73,205,9,66,43,11,109,143,15,24,79,203,11,90,143,15,131,15,155,31,65,185,15,86,87,11,35,128,\n    128,253,0,69,7,6,130,213,33,1,0,119,178,15,142,17,66,141,74,83,28,6,36,7,0,0,4,128,82,39,18,76,149,12,67,69,21,32,128,79,118,15,32,0,130,0,32,8,131,206,32,2,79,83,9,100,223,14,102,\n    113,23,115,115,7,24,65,231,12,130,162,32,4,68,182,19,130,102,93,143,8,69,107,29,24,77,255,12,143,197,72,51,7,76,195,15,132,139,85,49,15,130,152,131,18,71,81,23,70,14,11,36,0,10,0,128,\n    2,69,59,9,89,151,15,66,241,11,76,165,12,71,43,15,75,49,13,65,12,23,132,37,32,0,179,115,130,231,95,181,16,132,77,32,254,67,224,8,65,126,20,79,171,8,32,2,89,81,5,75,143,6,80,41,8,34,\n    2,0,128,24,81,72,9,32,0,130,0,35,17,0,0,255,77,99,39,95,65,36,67,109,15,24,69,93,11,77,239,5,95,77,23,35,128,1,0,128,24,86,7,8,132,167,32,2,69,198,41,130,202,33,0,26,120,75,44,24,89,\n    51,15,71,243,12,70,239,11,24,84,3,11,66,7,11,71,255,10,32,21,69,155,35,88,151,12,32,128,74,38,10,65,210,8,74,251,5,65,226,5,75,201,13,32,3,65,9,41,146,41,40,0,0,0,9,1,0,1,0,2,91,99,\n    19,32,35,106,119,13,70,219,15,83,239,12,137,154,32,2,67,252,19,36,128,0,0,4,1,130,196,32,2,130,8,91,107,8,32,0,135,81,24,73,211,8,132,161,73,164,13,36,0,8,0,128,2,105,123,26,139,67,\n    76,99,15,34,1,0,128,135,76,83,156,20,92,104,8,67,251,30,24,86,47,27,123,207,12,24,86,7,15,71,227,8,32,4,65,20,20,131,127,32,0,130,123,32,0,71,223,26,32,19,90,195,22,71,223,15,84,200,\n    6,32,128,133,241,24,84,149,9,67,41,25,36,0,0,0,22,0,88,111,49,32,87,66,21,5,77,3,27,123,75,7,71,143,19,135,183,71,183,19,130,171,74,252,5,131,5,89,87,17,32,1,132,18,130,232,68,11,10,\n    33,1,128,70,208,16,66,230,18,147,18,130,254,223,255,75,27,23,65,59,15,135,39,155,255,34,128,128,254,104,92,8,33,0,128,65,32,11,65,1,58,33,26,0,130,0,72,71,18,78,55,17,76,11,19,86,101,\n    12,75,223,11,89,15,11,24,76,87,15,75,235,15,131,15,72,95,7,85,71,11,72,115,11,73,64,6,34,1,128,128,66,215,9,34,128,254,128,134,14,33,128,255,67,102,5,32,0,130,16,70,38,11,66,26,57,\n    88,11,8,24,76,215,34,78,139,7,95,245,7,32,7,24,73,75,23,32,128,131,167,130,170,101,158,9,82,49,22,118,139,6,32,18,67,155,44,116,187,9,108,55,14,80,155,23,66,131,15,93,77,10,131,168,\n    32,128,73,211,12,24,75,187,22,32,4,96,71,20,67,108,19,132,19,120,207,8,32,5,76,79,15,66,111,21,66,95,8,32,3,190,211,111,3,8,211,212,32,20,65,167,44,34,75,0,79,97,59,13,32,33,112,63,\n    10,65,147,19,69,39,19,143,39,24,66,71,9,130,224,65,185,43,94,176,12,65,183,24,71,38,8,24,72,167,7,65,191,38,136,235,24,96,167,12,65,203,62,115,131,13,65,208,42,175,235,67,127,6,32,\n    4,76,171,29,114,187,5,32,71,65,211,5,65,203,68,72,51,8,164,219,32,0,172,214,71,239,58,78,3,27,66,143,15,77,19,15,147,31,35,33,53,51,21,66,183,10,173,245,66,170,30,150,30,34,0,0,23,\n    80,123,54,76,1,16,73,125,15,82,245,11,167,253,24,76,85,12,70,184,5,32,254,131,185,37,254,0,128,1,0,128,133,16,117,158,18,92,27,38,65,3,17,130,251,35,17,0,128,254,24,69,83,39,140,243,\n    121,73,19,109,167,7,81,41,15,24,95,175,12,102,227,15,121,96,11,24,95,189,7,32,3,145,171,154,17,24,77,47,9,33,0,5,70,71,37,68,135,7,32,29,117,171,11,69,87,15,24,79,97,19,24,79,149,23,\n    131,59,32,1,75,235,5,72,115,11,72,143,7,132,188,71,27,46,131,51,32,0,69,95,6,175,215,32,21,131,167,81,15,19,151,191,151,23,131,215,71,43,5,32,254,24,79,164,24,74,109,8,77,166,13,65,\n    176,26,88,162,5,98,159,6,171,219,120,247,6,79,29,8,99,169,10,103,59,19,65,209,35,131,35,91,25,19,112,94,15,83,36,8,173,229,33,20,0,88,75,43,71,31,12,65,191,71,33,1,0,130,203,32,254,\n    131,4,68,66,7,67,130,6,104,61,13,173,215,38,13,1,0,0,0,2,128,67,111,28,74,129,16,104,35,19,79,161,16,87,14,7,138,143,132,10,67,62,36,114,115,5,162,151,67,33,16,108,181,15,143,151,67,\n    5,5,24,100,242,15,170,153,34,0,0,14,65,51,34,32,55,79,75,9,32,51,74,7,10,65,57,38,132,142,32,254,72,0,14,139,163,32,128,80,254,8,67,158,21,65,63,7,32,4,72,227,27,95,155,12,67,119,19,\n    124,91,24,149,154,72,177,34,97,223,8,155,151,24,108,227,15,88,147,16,72,117,19,68,35,11,92,253,15,70,199,15,24,87,209,17,32,2,87,233,7,32,1,24,88,195,10,119,24,8,32,3,81,227,24,65,\n    125,21,35,128,128,0,25,76,59,48,24,90,187,9,97,235,12,66,61,11,91,105,19,24,79,141,11,24,79,117,15,24,79,129,27,90,53,13,130,13,32,253,131,228,24,79,133,40,69,70,8,66,137,31,65,33,\n    19,96,107,8,68,119,29,66,7,5,68,125,16,65,253,19,65,241,27,24,90,179,13,24,79,143,18,33,128,128,130,246,32,254,130,168,68,154,36,77,51,9,97,47,5,167,195,32,21,131,183,78,239,27,155,\n    195,78,231,14,201,196,77,11,6,32,5,73,111,37,97,247,12,77,19,31,155,207,78,215,19,162,212,69,17,14,66,91,19,80,143,57,78,203,39,159,215,32,128,93,134,8,24,80,109,24,66,113,15,169,215,\n    66,115,6,32,4,69,63,33,32,0,101,113,7,86,227,35,143,211,36,49,53,51,21,1,77,185,14,65,159,28,69,251,34,67,56,8,33,9,0,24,107,175,25,90,111,12,110,251,11,119,189,24,119,187,34,87,15,\n    9,32,4,66,231,37,90,39,7,66,239,8,84,219,15,69,105,23,24,85,27,27,87,31,11,33,1,128,76,94,6,32,1,85,241,7,33,128,128,106,48,10,33,128,128,69,136,11,133,13,24,79,116,49,84,236,8,24,\n    91,87,9,32,5,165,255,69,115,12,66,27,15,159,15,24,72,247,12,74,178,5,24,80,64,15,33,0,128,143,17,77,89,51,130,214,24,81,43,7,170,215,74,49,8,159,199,143,31,139,215,69,143,5,32,254,\n    24,81,50,35,181,217,84,123,70,143,195,159,15,65,187,16,66,123,7,65,175,15,65,193,29,68,207,39,79,27,5,70,131,6,32,4,68,211,33,33,67,0,83,143,14,159,207,143,31,140,223,33,0,128,24,80,\n    82,14,24,93,16,23,32,253,65,195,5,68,227,40,133,214,107,31,7,32,5,67,115,27,87,9,8,107,31,43,66,125,6,32,0,103,177,23,131,127,72,203,36,32,0,110,103,8,155,163,73,135,6,32,19,24,112,\n    99,10,65,71,11,73,143,19,143,31,126,195,5,24,85,21,9,24,76,47,14,32,254,24,93,77,36,68,207,11,39,25,0,0,255,128,3,128,4,66,51,37,95,247,13,82,255,24,76,39,19,147,221,66,85,27,24,118,\n    7,8,24,74,249,12,76,74,8,91,234,8,67,80,17,131,222,33,253,0,121,30,44,73,0,16,69,15,6,32,0,65,23,38,69,231,12,65,179,6,98,131,16,86,31,27,24,108,157,14,80,160,8,24,65,46,17,33,4,0,\n    96,2,18,144,191,65,226,8,68,19,5,171,199,80,9,15,180,199,67,89,5,32,255,24,79,173,28,174,201,24,79,179,50,32,1,24,122,5,10,82,61,10,180,209,83,19,8,32,128,24,80,129,27,111,248,43,131,\n    71,24,115,103,8,67,127,41,78,213,24,100,247,19,66,115,39,75,107,5,32,254,165,219,78,170,40,24,112,163,49,32,1,97,203,6,65,173,64,32,0,83,54,7,133,217,88,37,12,32,254,131,28,33,128,\n    3,67,71,44,84,183,6,32,5,69,223,33,96,7,7,123,137,16,192,211,24,112,14,9,32,255,67,88,29,68,14,10,84,197,38,33,0,22,116,47,50,32,87,106,99,9,116,49,15,89,225,15,97,231,23,70,41,19,\n    82,85,8,93,167,6,32,253,132,236,108,190,7,89,251,5,116,49,58,33,128,128,131,234,32,15,24,74,67,38,70,227,24,24,83,45,23,89,219,12,70,187,12,89,216,19,32,2,69,185,24,141,24,70,143,66,\n    24,82,119,56,78,24,10,32,253,133,149,132,6,24,106,233,7,69,198,48,178,203,81,243,12,68,211,15,106,255,23,66,91,15,69,193,7,100,39,10,24,83,72,16,176,204,33,19,0,88,207,45,68,21,12,\n    68,17,10,65,157,53,68,17,6,32,254,92,67,10,65,161,25,69,182,43,24,118,91,47,69,183,18,181,209,111,253,12,89,159,8,66,112,12,69,184,45,35,0,0,0,9,24,80,227,26,73,185,16,118,195,15,131,\n    15,33,1,0,65,59,15,66,39,27,160,111,66,205,12,148,111,143,110,33,128,128,156,112,24,81,199,8,75,199,23,66,117,20,155,121,32,254,68,126,12,72,213,29,134,239,149,123,89,27,16,148,117,\n    65,245,8,24,71,159,14,141,134,134,28,73,51,55,109,77,15,105,131,11,68,67,11,76,169,27,107,209,12,102,174,8,32,128,72,100,18,116,163,56,79,203,11,75,183,44,85,119,19,71,119,23,151,227,\n    32,1,93,27,8,65,122,5,77,102,8,110,120,20,66,23,8,66,175,17,66,63,12,133,12,79,35,8,74,235,33,67,149,16,69,243,15,78,57,15,69,235,16,67,177,7,151,192,130,23,67,84,29,141,192,174,187,\n    77,67,15,69,11,12,159,187,77,59,10,199,189,24,70,235,50,96,83,19,66,53,23,105,65,19,77,47,12,163,199,66,67,37,78,207,50,67,23,23,174,205,67,228,6,71,107,13,67,22,14,66,85,11,83,187,\n    38,124,47,49,95,7,19,66,83,23,67,23,19,24,96,78,17,80,101,16,71,98,40,33,0,7,88,131,22,24,89,245,12,84,45,12,102,213,5,123,12,9,32,2,126,21,14,43,255,0,128,128,0,0,20,0,128,255,128,\n    3,126,19,39,32,75,106,51,7,113,129,15,24,110,135,19,126,47,15,115,117,11,69,47,11,32,2,109,76,9,102,109,9,32,128,75,2,10,130,21,32,254,69,47,6,32,3,94,217,47,32,0,65,247,10,69,15,46,\n    65,235,31,65,243,15,101,139,10,66,174,14,65,247,16,72,102,28,69,17,14,84,243,9,165,191,88,47,48,66,53,12,32,128,71,108,6,203,193,32,17,75,187,42,73,65,16,65,133,52,114,123,9,167,199,\n    69,21,37,86,127,44,75,171,11,180,197,78,213,12,148,200,81,97,46,24,95,243,9,32,4,66,75,33,113,103,9,87,243,36,143,225,24,84,27,31,90,145,8,148,216,67,49,5,24,84,34,14,75,155,27,67,\n    52,13,140,13,36,0,20,0,128,255,24,135,99,46,88,59,43,155,249,80,165,7,136,144,71,161,23,32,253,132,33,32,254,88,87,44,136,84,35,128,0,0,21,81,103,5,94,47,44,76,51,12,143,197,151,15,\n    65,215,31,24,64,77,13,65,220,20,65,214,14,71,4,40,65,213,13,32,0,130,0,35,21,1,2,0,135,0,34,36,0,72,134,10,36,1,0,26,0,130,134,11,36,2,0,14,0,108,134,11,32,3,138,23,32,4,138,11,34,\n    5,0,20,134,33,34,0,0,6,132,23,32,1,134,15,32,18,130,25,133,11,37,1,0,13,0,49,0,133,11,36,2,0,7,0,38,134,11,36,3,0,17,0,45,134,11,32,4,138,35,36,5,0,10,0,62,134,23,32,6,132,23,36,3,\n    0,1,4,9,130,87,131,167,133,11,133,167,133,11,133,167,133,11,37,3,0,34,0,122,0,133,11,133,167,133,11,133,167,133,11,133,167,34,50,0,48,130,1,34,52,0,47,134,5,8,49,49,0,53,98,121,32,\n    84,114,105,115,116,97,110,32,71,114,105,109,109,101,114,82,101,103,117,108,97,114,84,84,88,32,80,114,111,103,103,121,67,108,101,97,110,84,84,50,48,48,52,47,130,2,53,49,53,0,98,0,121,\n    0,32,0,84,0,114,0,105,0,115,0,116,0,97,0,110,130,15,32,71,132,15,36,109,0,109,0,101,130,9,32,82,130,5,36,103,0,117,0,108,130,29,32,114,130,43,34,84,0,88,130,35,32,80,130,25,34,111,\n    0,103,130,1,34,121,0,67,130,27,32,101,132,59,32,84,130,31,33,0,0,65,155,9,34,20,0,0,65,11,6,130,8,135,2,33,1,1,130,9,8,120,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,\n    1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,\n    22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,130,187,8,66,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,\n    57,0,58,0,59,0,60,0,61,0,62,0,63,0,64,0,65,0,66,130,243,9,75,68,0,69,0,70,0,71,0,72,0,73,0,74,0,75,0,76,0,77,0,78,0,79,0,80,0,81,0,82,0,83,0,84,0,85,0,86,0,87,0,88,0,89,0,90,0,91,0,\n    92,0,93,0,94,0,95,0,96,0,97,1,33,1,34,1,35,1,36,1,37,1,38,1,39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1,54,1,55,1,56,1,57,1,58,1,59,1,60,1,61,1,62,1,\n    63,1,64,1,65,0,172,0,163,0,132,0,133,0,189,0,150,0,232,0,134,0,142,0,139,0,157,0,169,0,164,0,239,0,138,0,218,0,131,0,147,0,242,0,243,0,141,0,151,0,136,0,195,0,222,0,241,0,158,0,170,\n    0,245,0,244,0,246,0,162,0,173,0,201,0,199,0,174,0,98,0,99,0,144,0,100,0,203,0,101,0,200,0,202,0,207,0,204,0,205,0,206,0,233,0,102,0,211,0,208,0,209,0,175,0,103,0,240,0,145,0,214,0,\n    212,0,213,0,104,0,235,0,237,0,137,0,106,0,105,0,107,0,109,0,108,0,110,0,160,0,111,0,113,0,112,0,114,0,115,0,117,0,116,0,118,0,119,0,234,0,120,0,122,0,121,0,123,0,125,0,124,0,184,0,\n    161,0,127,0,126,0,128,0,129,0,236,0,238,0,186,14,117,110,105,99,111,100,101,35,48,120,48,48,48,49,141,14,32,50,141,14,32,51,141,14,32,52,141,14,32,53,141,14,32,54,141,14,32,55,141,\n    14,32,56,141,14,32,57,141,14,32,97,141,14,32,98,141,14,32,99,141,14,32,100,141,14,32,101,141,14,32,102,140,14,33,49,48,141,14,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,\n    141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,45,49,102,6,100,101,108,101,116,101,4,69,117,114,\n    111,140,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,\n    32,56,141,236,32,56,141,236,32,56,65,220,13,32,57,65,220,13,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,\n    239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,35,57,102,0,0,5,250,72,249,98,247,\n};\n\nstatic const char* GetDefaultCompressedFontDataTTF(int* out_size)\n{\n    *out_size = proggy_clean_ttf_compressed_size;\n    return (const char*)proggy_clean_ttf_compressed_data;\n}\n#endif // #ifndef IMGUI_DISABLE_DEFAULT_FONT\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "imgui_internal.h",
          "type": "blob",
          "size": 263.29,
          "content": "// dear imgui, v1.91.7 WIP\n// (internal structures/api)\n\n// You may use this file to debug, understand or extend Dear ImGui features but we don't provide any guarantee of forward compatibility.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Header mess\n// [SECTION] Forward declarations\n// [SECTION] Context pointer\n// [SECTION] STB libraries includes\n// [SECTION] Macros\n// [SECTION] Generic helpers\n// [SECTION] ImDrawList support\n// [SECTION] Data types support\n// [SECTION] Widgets support: flags, enums, data structures\n// [SECTION] Popup support\n// [SECTION] Inputs support\n// [SECTION] Clipper support\n// [SECTION] Navigation support\n// [SECTION] Typing-select support\n// [SECTION] Columns support\n// [SECTION] Box-select support\n// [SECTION] Multi-select support\n// [SECTION] Docking support\n// [SECTION] Viewport support\n// [SECTION] Settings support\n// [SECTION] Localization support\n// [SECTION] Error handling, State recovery support\n// [SECTION] Metrics, Debug tools\n// [SECTION] Generic context hooks\n// [SECTION] ImGuiContext (main imgui context)\n// [SECTION] ImGuiWindowTempData, ImGuiWindow\n// [SECTION] Tab bar, Tab item support\n// [SECTION] Table support\n// [SECTION] ImGui internal API\n// [SECTION] ImFontAtlas internal API\n// [SECTION] Test Engine specific hooks (imgui_test_engine)\n\n*/\n\n#pragma once\n#ifndef IMGUI_DISABLE\n\n//-----------------------------------------------------------------------------\n// [SECTION] Header mess\n//-----------------------------------------------------------------------------\n\n#ifndef IMGUI_VERSION\n#include \"imgui.h\"\n#endif\n\n#include <stdio.h>      // FILE*, sscanf\n#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof\n#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf\n#include <limits.h>     // INT_MIN, INT_MAX\n\n// Enable SSE intrinsics if available\n#if (defined __SSE__ || defined __x86_64__ || defined _M_X64 || (defined(_M_IX86_FP) && (_M_IX86_FP >= 1))) && !defined(IMGUI_DISABLE_SSE)\n#define IMGUI_ENABLE_SSE\n#include <immintrin.h>\n#if (defined __AVX__ || defined __SSE4_2__)\n#define IMGUI_ENABLE_SSE4_2\n#include <nmmintrin.h>\n#endif\n#endif\n// Emscripten has partial SSE 4.2 support where _mm_crc32_u32 is not available. See https://emscripten.org/docs/porting/simd.html#id11 and #8213\n#if defined(IMGUI_ENABLE_SSE4_2) && !defined(IMGUI_USE_LEGACY_CRC32_ADLER) && !defined(__EMSCRIPTEN__)\n#define IMGUI_ENABLE_SSE4_2_CRC\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4251)     // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)\n#pragma warning (disable: 26812)    // The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#pragma warning (disable: 26495)    // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok, for ImFloor()\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wmissing-noreturn\"               // warning: function 'xxx' could be declared with attribute 'noreturn'\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#elif defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#pragma GCC diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"  // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#endif\n\n// In 1.89.4, we moved the implementation of \"courtesy maths operators\" from imgui_internal.h in imgui.h\n// As they are frequently requested, we do not want to encourage to many people using imgui_internal.h\n#if defined(IMGUI_DEFINE_MATH_OPERATORS) && !defined(IMGUI_DEFINE_MATH_OPERATORS_IMPLEMENTED)\n#error Please '#define IMGUI_DEFINE_MATH_OPERATORS' _BEFORE_ including imgui.h!\n#endif\n\n// Legacy defines\n#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS            // Renamed in 1.74\n#error Use IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\n#endif\n#ifdef IMGUI_DISABLE_MATH_FUNCTIONS                     // Renamed in 1.74\n#error Use IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS\n#endif\n\n// Enable stb_truetype by default unless FreeType is enabled.\n// You can compile with both by defining both IMGUI_ENABLE_FREETYPE and IMGUI_ENABLE_STB_TRUETYPE together.\n#ifndef IMGUI_ENABLE_FREETYPE\n#define IMGUI_ENABLE_STB_TRUETYPE\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Forward declarations\n//-----------------------------------------------------------------------------\n\nstruct ImBitVector;                 // Store 1-bit per value\nstruct ImRect;                      // An axis-aligned rectangle (2 points)\nstruct ImDrawDataBuilder;           // Helper to build a ImDrawData instance\nstruct ImDrawListSharedData;        // Data shared between all ImDrawList instances\nstruct ImGuiBoxSelectState;         // Box-selection state (currently used by multi-selection, could potentially be used by others)\nstruct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it\nstruct ImGuiContext;                // Main Dear ImGui context\nstruct ImGuiContextHook;            // Hook for extensions like ImGuiTestEngine\nstruct ImGuiDataVarInfo;            // Variable information (e.g. to access style variables from an enum)\nstruct ImGuiDataTypeInfo;           // Type information associated to a ImGuiDataType enum\nstruct ImGuiErrorRecoveryState;     // Storage of stack sizes for error handling and recovery\nstruct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()\nstruct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box\nstruct ImGuiInputTextDeactivateData;// Short term storage to backup text of a deactivating InputText() while another is stealing active id\nstruct ImGuiLastItemData;           // Status storage for last submitted items\nstruct ImGuiLocEntry;               // A localization entry.\nstruct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only\nstruct ImGuiMultiSelectState;       // Multi-selection persistent state (for focused selection).\nstruct ImGuiMultiSelectTempData;    // Multi-selection temporary state (while traversing).\nstruct ImGuiNavItemData;            // Result of a keyboard/gamepad directional navigation move query result\nstruct ImGuiMetricsConfig;          // Storage for ShowMetricsWindow() and DebugNodeXXX() functions\nstruct ImGuiNextWindowData;         // Storage for SetNextWindow** functions\nstruct ImGuiNextItemData;           // Storage for SetNextItem** functions\nstruct ImGuiOldColumnData;          // Storage data for a single column for legacy Columns() api\nstruct ImGuiOldColumns;             // Storage data for a columns set for legacy Columns() api\nstruct ImGuiPopupData;              // Storage for current popup stack\nstruct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file\nstruct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it\nstruct ImGuiTabBar;                 // Storage for a tab bar\nstruct ImGuiTabItem;                // Storage for a tab item (within a tab bar)\nstruct ImGuiTable;                  // Storage for a table\nstruct ImGuiTableHeaderData;        // Storage for TableAngledHeadersRow()\nstruct ImGuiTableColumn;            // Storage for one column of a table\nstruct ImGuiTableInstanceData;      // Storage for one instance of a same table\nstruct ImGuiTableTempData;          // Temporary storage for one table (one per table in the stack), shared between tables.\nstruct ImGuiTableSettings;          // Storage for a table .ini settings\nstruct ImGuiTableColumnsSettings;   // Storage for a column .ini settings\nstruct ImGuiTreeNodeStackData;      // Temporary storage for TreeNode().\nstruct ImGuiTypingSelectState;      // Storage for GetTypingSelectRequest()\nstruct ImGuiTypingSelectRequest;    // Storage for GetTypingSelectRequest() (aimed to be public)\nstruct ImGuiWindow;                 // Storage for one window\nstruct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame, in practice we currently keep it for each window)\nstruct ImGuiWindowSettings;         // Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)\n\n// Enumerations\n// Use your programming IDE \"Go to definition\" facility on the names of the center columns to find the actual flags/enum lists.\nenum ImGuiLocKey : int;                 // -> enum ImGuiLocKey              // Enum: a localization entry for translation.\ntypedef int ImGuiLayoutType;            // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical\n\n// Flags\ntypedef int ImGuiActivateFlags;         // -> enum ImGuiActivateFlags_      // Flags: for navigation/focus function (will be for ActivateItem() later)\ntypedef int ImGuiDebugLogFlags;         // -> enum ImGuiDebugLogFlags_      // Flags: for ShowDebugLogWindow(), g.DebugLogFlags\ntypedef int ImGuiFocusRequestFlags;     // -> enum ImGuiFocusRequestFlags_  // Flags: for FocusWindow()\ntypedef int ImGuiItemStatusFlags;       // -> enum ImGuiItemStatusFlags_    // Flags: for g.LastItemData.StatusFlags\ntypedef int ImGuiOldColumnFlags;        // -> enum ImGuiOldColumnFlags_     // Flags: for BeginColumns()\ntypedef int ImGuiLogFlags;              // -> enum ImGuiLogFlags_           // Flags: for LogBegin() text capturing function\ntypedef int ImGuiNavRenderCursorFlags;  // -> enum ImGuiNavRenderCursorFlags_//Flags: for RenderNavCursor()\ntypedef int ImGuiNavMoveFlags;          // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests\ntypedef int ImGuiNextItemDataFlags;     // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions\ntypedef int ImGuiNextWindowDataFlags;   // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions\ntypedef int ImGuiScrollFlags;           // -> enum ImGuiScrollFlags_        // Flags: for ScrollToItem() and navigation requests\ntypedef int ImGuiSeparatorFlags;        // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()\ntypedef int ImGuiTextFlags;             // -> enum ImGuiTextFlags_          // Flags: for TextEx()\ntypedef int ImGuiTooltipFlags;          // -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()\ntypedef int ImGuiTypingSelectFlags;     // -> enum ImGuiTypingSelectFlags_  // Flags: for GetTypingSelectRequest()\ntypedef int ImGuiWindowRefreshFlags;    // -> enum ImGuiWindowRefreshFlags_ // Flags: for SetNextWindowRefreshPolicy()\n\n//-----------------------------------------------------------------------------\n// [SECTION] Context pointer\n// See implementation of this variable in imgui.cpp for comments and details.\n//-----------------------------------------------------------------------------\n\n#ifndef GImGui\nextern IMGUI_API ImGuiContext* GImGui;  // Current implicit context pointer\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Macros\n//-----------------------------------------------------------------------------\n\n// Debug Printing Into TTY\n// (since IMGUI_VERSION_NUM >= 18729: IMGUI_DEBUG_LOG was reworked into IMGUI_DEBUG_PRINTF (and removed framecount from it). If you were using a #define IMGUI_DEBUG_LOG please rename)\n#ifndef IMGUI_DEBUG_PRINTF\n#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS\n#define IMGUI_DEBUG_PRINTF(_FMT,...)    printf(_FMT, __VA_ARGS__)\n#else\n#define IMGUI_DEBUG_PRINTF(_FMT,...)    ((void)0)\n#endif\n#endif\n\n// Debug Logging for ShowDebugLogWindow(). This is designed for relatively rare events so please don't spam.\n#define IMGUI_DEBUG_LOG_ERROR(...)      do { ImGuiContext& g2 = *GImGui; if (g2.DebugLogFlags & ImGuiDebugLogFlags_EventError) IMGUI_DEBUG_LOG(__VA_ARGS__); else g2.DebugLogSkippedErrors++; } while (0)\n#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_POPUP(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_SELECTION(...)  do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)   IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_CLIPPER(...)    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper)     IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)          IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_FONT(...)       do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFont)        IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n#define IMGUI_DEBUG_LOG_INPUTROUTING(...) do{if (g.DebugLogFlags & ImGuiDebugLogFlags_EventInputRouting)IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)\n\n// Static Asserts\n#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, \"\")\n\n// \"Paranoid\" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.\n// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.\n//#define IMGUI_DEBUG_PARANOID\n#ifdef IMGUI_DEBUG_PARANOID\n#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)\n#else\n#define IM_ASSERT_PARANOID(_EXPR)\n#endif\n\n// Misc Macros\n#define IM_PI                           3.14159265358979323846f\n#ifdef _WIN32\n#define IM_NEWLINE                      \"\\r\\n\"   // Play it nice with Windows users (Update: since 2018-05, Notepad finally appears to support Unix-style carriage returns!)\n#else\n#define IM_NEWLINE                      \"\\n\"\n#endif\n#ifndef IM_TABSIZE                      // Until we move this to runtime and/or add proper tab support, at least allow users to compile-time override\n#define IM_TABSIZE                      (4)\n#endif\n#define IM_MEMALIGN(_OFF,_ALIGN)        (((_OFF) + ((_ALIGN) - 1)) & ~((_ALIGN) - 1))           // Memory align e.g. IM_ALIGN(0,4)=0, IM_ALIGN(1,4)=4, IM_ALIGN(4,4)=4, IM_ALIGN(5,4)=8\n#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose\n#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255\n#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds\n#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //\n#define IM_STRINGIFY_HELPER(_X)         #_X\n#define IM_STRINGIFY(_X)                IM_STRINGIFY_HELPER(_X)                                 // Preprocessor idiom to stringify e.g. an integer.\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n#define IM_FLOOR IM_TRUNC\n#endif\n\n// Hint for branch prediction\n#if (defined(__cplusplus) && (__cplusplus >= 202002L)) || (defined(_MSVC_LANG) && (_MSVC_LANG >= 202002L))\n#define IM_LIKELY   [[likely]]\n#define IM_UNLIKELY [[unlikely]]\n#else\n#define IM_LIKELY\n#define IM_UNLIKELY\n#endif\n\n// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall\n#ifdef _MSC_VER\n#define IMGUI_CDECL __cdecl\n#else\n#define IMGUI_CDECL\n#endif\n\n// Warnings\n#if defined(_MSC_VER) && !defined(__clang__)\n#define IM_MSVC_WARNING_SUPPRESS(XXXX)  __pragma(warning(suppress: XXXX))\n#else\n#define IM_MSVC_WARNING_SUPPRESS(XXXX)\n#endif\n\n// Debug Tools\n// Use 'Metrics/Debugger->Tools->Item Picker' to break into the call-stack of a specific item.\n// This will call IM_DEBUG_BREAK() which you may redefine yourself. See https://github.com/scottt/debugbreak for more reference.\n#ifndef IM_DEBUG_BREAK\n#if defined (_MSC_VER)\n#define IM_DEBUG_BREAK()    __debugbreak()\n#elif defined(__clang__)\n#define IM_DEBUG_BREAK()    __builtin_debugtrap()\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n#define IM_DEBUG_BREAK()    __asm__ volatile(\"int3;nop\")\n#elif defined(__GNUC__) && defined(__thumb__)\n#define IM_DEBUG_BREAK()    __asm__ volatile(\".inst 0xde01\")\n#elif defined(__GNUC__) && defined(__arm__) && !defined(__thumb__)\n#define IM_DEBUG_BREAK()    __asm__ volatile(\".inst 0xe7f001f0\")\n#else\n#define IM_DEBUG_BREAK()    IM_ASSERT(0)    // It is expected that you define IM_DEBUG_BREAK() into something that will break nicely in a debugger!\n#endif\n#endif // #ifndef IM_DEBUG_BREAK\n\n// Format specifiers, printing 64-bit hasn't been decently standardized...\n// In a real application you should be using PRId64 and PRIu64 from <inttypes.h> (non-windows) and on Windows define them yourself.\n#if defined(_MSC_VER) && !defined(__clang__)\n#define IM_PRId64   \"I64d\"\n#define IM_PRIu64   \"I64u\"\n#define IM_PRIX64   \"I64X\"\n#else\n#define IM_PRId64   \"lld\"\n#define IM_PRIu64   \"llu\"\n#define IM_PRIX64   \"llX\"\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Generic helpers\n// Note that the ImXXX helpers functions are lower-level than ImGui functions.\n// ImGui functions or the ImGui context are never called/used from other ImXXX functions.\n//-----------------------------------------------------------------------------\n// - Helpers: Hashing\n// - Helpers: Sorting\n// - Helpers: Bit manipulation\n// - Helpers: String\n// - Helpers: Formatting\n// - Helpers: UTF-8 <> wchar conversions\n// - Helpers: ImVec2/ImVec4 operators\n// - Helpers: Maths\n// - Helpers: Geometry\n// - Helper: ImVec1\n// - Helper: ImVec2ih\n// - Helper: ImRect\n// - Helper: ImBitArray\n// - Helper: ImBitVector\n// - Helper: ImSpan<>, ImSpanAllocator<>\n// - Helper: ImPool<>\n// - Helper: ImChunkStream<>\n// - Helper: ImGuiTextIndex\n// - Helper: ImGuiStorage\n//-----------------------------------------------------------------------------\n\n// Helpers: Hashing\nIMGUI_API ImGuiID       ImHashData(const void* data, size_t data_size, ImGuiID seed = 0);\nIMGUI_API ImGuiID       ImHashStr(const char* data, size_t data_size = 0, ImGuiID seed = 0);\n\n// Helpers: Sorting\n#ifndef ImQsort\nstatic inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }\n#endif\n\n// Helpers: Color Blending\nIMGUI_API ImU32         ImAlphaBlendColors(ImU32 col_a, ImU32 col_b);\n\n// Helpers: Bit manipulation\nstatic inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }\nstatic inline bool      ImIsPowerOfTwo(ImU64 v)         { return v != 0 && (v & (v - 1)) == 0; }\nstatic inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }\n\n// Helpers: String\nIMGUI_API int           ImStricmp(const char* str1, const char* str2);                      // Case insensitive compare.\nIMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);       // Case insensitive compare to a certain count.\nIMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);                // Copy to a certain count and always zero terminate (strncpy doesn't).\nIMGUI_API char*         ImStrdup(const char* str);                                          // Duplicate a string.\nIMGUI_API char*         ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);        // Copy in provided buffer, recreate buffer if needed.\nIMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);  // Find first occurrence of 'c' in string range.\nIMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line\nIMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);  // Find a substring in a string range.\nIMGUI_API void          ImStrTrimBlanks(char* str);                                         // Remove leading and trailing blanks from a buffer.\nIMGUI_API const char*   ImStrSkipBlank(const char* str);                                    // Find first non-blank character.\nIMGUI_API int           ImStrlenW(const ImWchar* str);                                      // Computer string length (ImWchar string)\nIMGUI_API const char*   ImStrbol(const char* buf_mid_line, const char* buf_begin);          // Find beginning-of-line\nIM_MSVC_RUNTIME_CHECKS_OFF\nstatic inline char      ImToUpper(char c)               { return (c >= 'a' && c <= 'z') ? c &= ~32 : c; }\nstatic inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\\t'; }\nstatic inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\\t' || c == 0x3000; }\nstatic inline bool      ImCharIsXdigitA(char c)         { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'); }\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n// Helpers: Formatting\nIMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);\nIMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);\nIMGUI_API void          ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...) IM_FMTARGS(3);\nIMGUI_API void          ImFormatStringToTempBufferV(const char** out_buf, const char** out_buf_end, const char* fmt, va_list args) IM_FMTLIST(3);\nIMGUI_API const char*   ImParseFormatFindStart(const char* format);\nIMGUI_API const char*   ImParseFormatFindEnd(const char* format);\nIMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);\nIMGUI_API void          ImParseFormatSanitizeForPrinting(const char* fmt_in, char* fmt_out, size_t fmt_out_size);\nIMGUI_API const char*   ImParseFormatSanitizeForScanning(const char* fmt_in, char* fmt_out, size_t fmt_out_size);\nIMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);\n\n// Helpers: UTF-8 <> wchar conversions\nIMGUI_API const char*   ImTextCharToUtf8(char out_buf[5], unsigned int c);                                                      // return out_buf\nIMGUI_API int           ImTextStrToUtf8(char* out_buf, int out_buf_size, const ImWchar* in_text, const ImWchar* in_text_end);   // return output UTF-8 bytes count\nIMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);               // read one character. return input UTF-8 bytes count\nIMGUI_API int           ImTextStrFromUtf8(ImWchar* out_buf, int out_buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count\nIMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                                 // return number of UTF-8 code-points (NOT bytes count)\nIMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                             // return number of bytes to express one char in UTF-8\nIMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                        // return number of bytes to express string in UTF-8\nIMGUI_API const char*   ImTextFindPreviousUtf8Codepoint(const char* in_text_start, const char* in_text_curr);                   // return previous UTF-8 code-point.\nIMGUI_API int           ImTextCountLines(const char* in_text, const char* in_text_end);                                         // return number of lines taken by text. trailing carriage return doesn't count as an extra line.\n\n// Helpers: File System\n#ifdef IMGUI_DISABLE_FILE_FUNCTIONS\n#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS\ntypedef void* ImFileHandle;\nstatic inline ImFileHandle  ImFileOpen(const char*, const char*)                    { return NULL; }\nstatic inline bool          ImFileClose(ImFileHandle)                               { return false; }\nstatic inline ImU64         ImFileGetSize(ImFileHandle)                             { return (ImU64)-1; }\nstatic inline ImU64         ImFileRead(void*, ImU64, ImU64, ImFileHandle)           { return 0; }\nstatic inline ImU64         ImFileWrite(const void*, ImU64, ImU64, ImFileHandle)    { return 0; }\n#endif\n#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS\ntypedef FILE* ImFileHandle;\nIMGUI_API ImFileHandle      ImFileOpen(const char* filename, const char* mode);\nIMGUI_API bool              ImFileClose(ImFileHandle file);\nIMGUI_API ImU64             ImFileGetSize(ImFileHandle file);\nIMGUI_API ImU64             ImFileRead(void* data, ImU64 size, ImU64 count, ImFileHandle file);\nIMGUI_API ImU64             ImFileWrite(const void* data, ImU64 size, ImU64 count, ImFileHandle file);\n#else\n#define IMGUI_DISABLE_TTY_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions\n#endif\nIMGUI_API void*             ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size = NULL, int padding_bytes = 0);\n\n// Helpers: Maths\nIM_MSVC_RUNTIME_CHECKS_OFF\n// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)\n#ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS\n#define ImFabs(X)           fabsf(X)\n#define ImSqrt(X)           sqrtf(X)\n#define ImFmod(X, Y)        fmodf((X), (Y))\n#define ImCos(X)            cosf(X)\n#define ImSin(X)            sinf(X)\n#define ImAcos(X)           acosf(X)\n#define ImAtan2(Y, X)       atan2f((Y), (X))\n#define ImAtof(STR)         atof(STR)\n#define ImCeil(X)           ceilf(X)\nstatic inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision\nstatic inline double ImPow(double x, double y)  { return pow(x, y); }\nstatic inline float  ImLog(float x)             { return logf(x); }             // DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision\nstatic inline double ImLog(double x)            { return log(x); }\nstatic inline int    ImAbs(int x)               { return x < 0 ? -x : x; }\nstatic inline float  ImAbs(float x)             { return fabsf(x); }\nstatic inline double ImAbs(double x)            { return fabs(x); }\nstatic inline float  ImSign(float x)            { return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f : 0.0f; } // Sign operator - returns -1, 0 or 1 based on sign of argument\nstatic inline double ImSign(double x)           { return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0 : 0.0; }\n#ifdef IMGUI_ENABLE_SSE\nstatic inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }\n#else\nstatic inline float  ImRsqrt(float x)           { return 1.0f / sqrtf(x); }\n#endif\nstatic inline double ImRsqrt(double x)          { return 1.0 / sqrt(x); }\n#endif\n// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double\n// (Exceptionally using templates here but we could also redefine them for those types)\ntemplate<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }\ntemplate<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }\ntemplate<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }\ntemplate<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * (T)t); }\ntemplate<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }\ntemplate<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }\ntemplate<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }\n// - Misc maths helpers\nstatic inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }\nstatic inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }\nstatic inline ImVec2 ImClamp(const ImVec2& v, const ImVec2&mn, const ImVec2&mx) { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }\nstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }\nstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }\nstatic inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }\nstatic inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }\nstatic inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }\nstatic inline float  ImLengthSqr(const ImVec4& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w); }\nstatic inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = (lhs.x * lhs.x) + (lhs.y * lhs.y); if (d > 0.0f) return ImRsqrt(d); return fail_value; }\nstatic inline float  ImTrunc(float f)                                           { return (float)(int)(f); }\nstatic inline ImVec2 ImTrunc(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }\nstatic inline float  ImFloor(float f)                                           { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()\nstatic inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2(ImFloor(v.x), ImFloor(v.y)); }\nstatic inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }\nstatic inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }\nstatic inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }\nstatic inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }\nstatic inline float  ImLinearRemapClamp(float s0, float s1, float d0, float d1, float x) { return ImSaturate((x - s0) / (s1 - s0)) * (d1 - d0) + d0; }\nstatic inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }\nstatic inline bool   ImIsFloatAboveGuaranteedIntegerPrecision(float f)          { return f <= -16777216 || f >= 16777216; }\nstatic inline float  ImExponentialMovingAverage(float avg, float sample, int n) { avg -= avg / n; avg += sample / n; return avg; }\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n// Helpers: Geometry\nIMGUI_API ImVec2     ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t);\nIMGUI_API ImVec2     ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments);       // For curves with explicit number of segments\nIMGUI_API ImVec2     ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol);// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol\nIMGUI_API ImVec2     ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t);\nIMGUI_API ImVec2     ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);\nIMGUI_API bool       ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);\nIMGUI_API ImVec2     ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);\nIMGUI_API void       ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);\ninline float         ImTriangleArea(const ImVec2& a, const ImVec2& b, const ImVec2& c)          { return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5f; }\ninline bool          ImTriangleIsClockwise(const ImVec2& a, const ImVec2& b, const ImVec2& c)   { return ((b.x - a.x) * (c.y - b.y)) - ((c.x - b.x) * (b.y - a.y)) > 0.0f; }\n\n// Helper: ImVec1 (1D vector)\n// (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)\nIM_MSVC_RUNTIME_CHECKS_OFF\nstruct ImVec1\n{\n    float   x;\n    constexpr ImVec1()         : x(0.0f) { }\n    constexpr ImVec1(float _x) : x(_x) { }\n};\n\n// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)\nstruct ImVec2ih\n{\n    short   x, y;\n    constexpr ImVec2ih()                           : x(0), y(0) {}\n    constexpr ImVec2ih(short _x, short _y)         : x(_x), y(_y) {}\n    constexpr explicit ImVec2ih(const ImVec2& rhs) : x((short)rhs.x), y((short)rhs.y) {}\n};\n\n// Helper: ImRect (2D axis aligned bounding-box)\n// NB: we can't rely on ImVec2 math operators being available here!\nstruct IMGUI_API ImRect\n{\n    ImVec2      Min;    // Upper-left\n    ImVec2      Max;    // Lower-right\n\n    constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}\n    constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}\n    constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}\n    constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}\n\n    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }\n    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }\n    float       GetWidth() const                    { return Max.x - Min.x; }\n    float       GetHeight() const                   { return Max.y - Min.y; }\n    float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }\n    ImVec2      GetTL() const                       { return Min; }                   // Top-left\n    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right\n    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left\n    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right\n    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }\n    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }\n    bool        ContainsWithPad(const ImVec2& p, const ImVec2& pad) const { return p.x >= Min.x - pad.x && p.y >= Min.y - pad.y && p.x < Max.x + pad.x && p.y < Max.y + pad.y; }\n    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }\n    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }\n    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }\n    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }\n    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }\n    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }\n    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }\n    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }\n    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.\n    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.\n    void        Floor()                             { Min.x = IM_TRUNC(Min.x); Min.y = IM_TRUNC(Min.y); Max.x = IM_TRUNC(Max.x); Max.y = IM_TRUNC(Max.y); }\n    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }\n    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }\n};\n\n// Helper: ImBitArray\n#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!\n#define         IM_BITARRAY_CLEARBIT(_ARRAY, _N)                ((_ARRAY[(_N) >> 5] &= ~((ImU32)1 << ((_N) & 31))))    // Macro version of ImBitArrayClearBit(): ensure args have side-effect or are costly!\ninline size_t   ImBitArrayGetStorageSizeInBytes(int bitcount)   { return (size_t)((bitcount + 31) >> 5) << 2; }\ninline void     ImBitArrayClearAllBits(ImU32* arr, int bitcount){ memset(arr, 0, ImBitArrayGetStorageSizeInBytes(bitcount)); }\ninline bool     ImBitArrayTestBit(const ImU32* arr, int n)      { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }\ninline void     ImBitArrayClearBit(ImU32* arr, int n)           { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] &= ~mask; }\ninline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }\ninline void     ImBitArraySetBitRange(ImU32* arr, int n, int n2) // Works on range [n..n2)\n{\n    n2--;\n    while (n <= n2)\n    {\n        int a_mod = (n & 31);\n        int b_mod = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1;\n        ImU32 mask = (ImU32)(((ImU64)1 << b_mod) - 1) & ~(ImU32)(((ImU64)1 << a_mod) - 1);\n        arr[n >> 5] |= mask;\n        n = (n + 32) & ~31;\n    }\n}\n\ntypedef ImU32* ImBitArrayPtr; // Name for use in structs\n\n// Helper: ImBitArray class (wrapper over ImBitArray functions)\n// Store 1-bit per value.\ntemplate<int BITCOUNT, int OFFSET = 0>\nstruct ImBitArray\n{\n    ImU32           Storage[(BITCOUNT + 31) >> 5];\n    ImBitArray()                                { ClearAllBits(); }\n    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }\n    void            SetAllBits()                { memset(Storage, 255, sizeof(Storage)); }\n    bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }\n    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }\n    void            ClearBit(int n)             { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArrayClearBit(Storage, n); }\n    void            SetBitRange(int n, int n2)  { n += OFFSET; n2 += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT); ImBitArraySetBitRange(Storage, n, n2); } // Works on range [n..n2)\n    bool            operator[](int n) const     { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }\n};\n\n// Helper: ImBitVector\n// Store 1-bit per value.\nstruct IMGUI_API ImBitVector\n{\n    ImVector<ImU32> Storage;\n    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }\n    void            Clear()                     { Storage.clear(); }\n    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }\n    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }\n    void            ClearBit(int n)             { IM_ASSERT(n < (Storage.Size << 5)); ImBitArrayClearBit(Storage.Data, n); }\n};\nIM_MSVC_RUNTIME_CHECKS_RESTORE\n\n// Helper: ImSpan<>\n// Pointing to a span of data we don't own.\ntemplate<typename T>\nstruct ImSpan\n{\n    T*                  Data;\n    T*                  DataEnd;\n\n    // Constructors, destructor\n    inline ImSpan()                                 { Data = DataEnd = NULL; }\n    inline ImSpan(T* data, int size)                { Data = data; DataEnd = data + size; }\n    inline ImSpan(T* data, T* data_end)             { Data = data; DataEnd = data_end; }\n\n    inline void         set(T* data, int size)      { Data = data; DataEnd = data + size; }\n    inline void         set(T* data, T* data_end)   { Data = data; DataEnd = data_end; }\n    inline int          size() const                { return (int)(ptrdiff_t)(DataEnd - Data); }\n    inline int          size_in_bytes() const       { return (int)(ptrdiff_t)(DataEnd - Data) * (int)sizeof(T); }\n    inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }\n    inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }\n\n    inline T*           begin()                     { return Data; }\n    inline const T*     begin() const               { return Data; }\n    inline T*           end()                       { return DataEnd; }\n    inline const T*     end() const                 { return DataEnd; }\n\n    // Utilities\n    inline int  index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < DataEnd); const ptrdiff_t off = it - Data; return (int)off; }\n};\n\n// Helper: ImSpanAllocator<>\n// Facilitate storing multiple chunks into a single large block (the \"arena\")\n// - Usage: call Reserve() N times, allocate GetArenaSizeInBytes() worth, pass it to SetArenaBasePtr(), call GetSpan() N times to retrieve the aligned ranges.\ntemplate<int CHUNKS>\nstruct ImSpanAllocator\n{\n    char*   BasePtr;\n    int     CurrOff;\n    int     CurrIdx;\n    int     Offsets[CHUNKS];\n    int     Sizes[CHUNKS];\n\n    ImSpanAllocator()                               { memset(this, 0, sizeof(*this)); }\n    inline void  Reserve(int n, size_t sz, int a=4) { IM_ASSERT(n == CurrIdx && n < CHUNKS); CurrOff = IM_MEMALIGN(CurrOff, a); Offsets[n] = CurrOff; Sizes[n] = (int)sz; CurrIdx++; CurrOff += (int)sz; }\n    inline int   GetArenaSizeInBytes()              { return CurrOff; }\n    inline void  SetArenaBasePtr(void* base_ptr)    { BasePtr = (char*)base_ptr; }\n    inline void* GetSpanPtrBegin(int n)             { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n]); }\n    inline void* GetSpanPtrEnd(int n)               { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n] + Sizes[n]); }\n    template<typename T>\n    inline void  GetSpan(int n, ImSpan<T>* span)    { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }\n};\n\n// Helper: ImPool<>\n// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,\n// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.\ntypedef int ImPoolIdx;\ntemplate<typename T>\nstruct ImPool\n{\n    ImVector<T>     Buf;        // Contiguous data\n    ImGuiStorage    Map;        // ID->Index\n    ImPoolIdx       FreeIdx;    // Next free idx to use\n    ImPoolIdx       AliveCount; // Number of active/alive items (for display purpose)\n\n    ImPool()    { FreeIdx = AliveCount = 0; }\n    ~ImPool()   { Clear(); }\n    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Buf[idx] : NULL; }\n    T*          GetByIndex(ImPoolIdx n)             { return &Buf[n]; }\n    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }\n    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }\n    bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }\n    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Buf[idx].~T(); } Map.Clear(); Buf.clear(); FreeIdx = AliveCount = 0; }\n    T*          Add()                               { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } IM_PLACEMENT_NEW(&Buf[idx]) T(); AliveCount++; return &Buf[idx]; }\n    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }\n    void        Remove(ImGuiID key, ImPoolIdx idx)  { Buf[idx].~T(); *(int*)&Buf[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); AliveCount--; }\n    void        Reserve(int capacity)               { Buf.reserve(capacity); Map.Data.reserve(capacity); }\n\n    // To iterate a ImPool: for (int n = 0; n < pool.GetMapSize(); n++) if (T* t = pool.TryGetMapData(n)) { ... }\n    // Can be avoided if you know .Remove() has never been called on the pool, or AliveCount == GetMapSize()\n    int         GetAliveCount() const               { return AliveCount; }      // Number of active/alive items in the pool (for display purpose)\n    int         GetBufSize() const                  { return Buf.Size; }\n    int         GetMapSize() const                  { return Map.Data.Size; }   // It is the map we need iterate to find valid items, since we don't have \"alive\" storage anywhere\n    T*          TryGetMapData(ImPoolIdx n)          { int idx = Map.Data[n].val_i; if (idx == -1) return NULL; return GetByIndex(idx); }\n};\n\n// Helper: ImChunkStream<>\n// Build and iterate a contiguous stream of variable-sized structures.\n// This is used by Settings to store persistent data while reducing allocation count.\n// We store the chunk size first, and align the final size on 4 bytes boundaries.\n// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.\ntemplate<typename T>\nstruct ImChunkStream\n{\n    ImVector<char>  Buf;\n\n    void    clear()                     { Buf.clear(); }\n    bool    empty() const               { return Buf.Size == 0; }\n    int     size() const                { return Buf.Size; }\n    T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }\n    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }\n    T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }\n    int     chunk_size(const T* p)      { return ((const int*)p)[-1]; }\n    T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }\n    int     offset_from_ptr(const T* p) { IM_ASSERT(p >= begin() && p < end()); const ptrdiff_t off = (const char*)p - Buf.Data; return (int)off; }\n    T*      ptr_from_offset(int off)    { IM_ASSERT(off >= 4 && off < Buf.Size); return (T*)(void*)(Buf.Data + off); }\n    void    swap(ImChunkStream<T>& rhs) { rhs.Buf.swap(Buf); }\n};\n\n// Helper: ImGuiTextIndex\n// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.\nstruct ImGuiTextIndex\n{\n    ImVector<int>   LineOffsets;\n    int             EndOffset = 0;                          // Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)\n\n    void            clear()                                 { LineOffsets.clear(); EndOffset = 0; }\n    int             size()                                  { return LineOffsets.Size; }\n    const char*     get_line_begin(const char* base, int n) { return base + LineOffsets[n]; }\n    const char*     get_line_end(const char* base, int n)   { return base + (n + 1 < LineOffsets.Size ? (LineOffsets[n + 1] - 1) : EndOffset); }\n    void            append(const char* base, int old_size, int new_size);\n};\n\n// Helper: ImGuiStorage\nIMGUI_API ImGuiStoragePair* ImLowerBound(ImGuiStoragePair* in_begin, ImGuiStoragePair* in_end, ImGuiID key);\n//-----------------------------------------------------------------------------\n// [SECTION] ImDrawList support\n//-----------------------------------------------------------------------------\n\n// ImDrawList: Helper function to calculate a circle's segment count given its radius and a \"maximum error\" value.\n// Estimation of number of circle segment based on error is derived using method described in https://stackoverflow.com/a/2244088/15194693\n// Number of segments (N) is calculated using equation:\n//   N = ceil ( pi / acos(1 - error / r) )     where r > 0, error <= r\n// Our equation is significantly simpler that one in the post thanks for choosing segment that is\n// perpendicular to X axis. Follow steps in the article from this starting condition and you will\n// will get this result.\n//\n// Rendering circles with an odd number of segments, while mathematically correct will produce\n// asymmetrical results on the raster grid. Therefore we're rounding N to next even number (7->8, 8->8, 9->10 etc.)\n#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)\n#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4\n#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512\n#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)\n\n// Raw equation from IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC rewritten for 'r' and 'error'.\n#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))\n#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR(_N,_RAD)     ((1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))) / (_RAD))\n\n// ImDrawList: Lookup table size for adaptive arc drawing, cover full circle.\n#ifndef IM_DRAWLIST_ARCFAST_TABLE_SIZE\n#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.\n#endif\n#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.\n\n// Data shared between all ImDrawList instances\n// Conceptually this could have been called e.g. ImDrawListSharedContext\n// Typically one ImGui context would create and maintain one of this.\n// You may want to create your own instance of you try to ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.\nstruct IMGUI_API ImDrawListSharedData\n{\n    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas\n    const ImVec4*   TexUvLines;                 // UV of anti-aliased lines in the atlas\n    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)\n    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)\n    float           FontScale;                  // Current/default font scale (== FontSize / Font->FontSize)\n    float           CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo()\n    float           CircleSegmentMaxError;      // Number of circle segments to use per pixel of radius for AddCircle() etc\n    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()\n    ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)\n    ImVector<ImVec2> TempBuffer;                // Temporary write buffer\n\n    // Lookup tables\n    ImVec2          ArcFastVtx[IM_DRAWLIST_ARCFAST_TABLE_SIZE]; // Sample points on the quarter of the circle.\n    float           ArcFastRadiusCutoff;                        // Cutoff radius after which arc drawing will fallback to slower PathArcTo()\n    ImU8            CircleSegmentCounts[64];    // Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)\n\n    ImDrawListSharedData();\n    void SetCircleTessellationMaxError(float max_error);\n};\n\nstruct ImDrawDataBuilder\n{\n    ImVector<ImDrawList*>*  Layers[2];      // Pointers to global layers for: regular, tooltip. LayersP[0] is owned by DrawData.\n    ImVector<ImDrawList*>   LayerData1;\n\n    ImDrawDataBuilder()                     { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Data types support\n//-----------------------------------------------------------------------------\n\nstruct ImGuiDataVarInfo\n{\n    ImGuiDataType   Type;\n    ImU32           Count;      // 1+\n    ImU32           Offset;     // Offset in parent structure\n    void* GetVarPtr(void* parent) const { return (void*)((unsigned char*)parent + Offset); }\n};\n\nstruct ImGuiDataTypeStorage\n{\n    ImU8        Data[8];        // Opaque storage to fit any data up to ImGuiDataType_COUNT\n};\n\n// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().\nstruct ImGuiDataTypeInfo\n{\n    size_t      Size;           // Size in bytes\n    const char* Name;           // Short descriptive name for the type, for debugging\n    const char* PrintFmt;       // Default printf format for the type\n    const char* ScanFmt;        // Default scanf format for the type\n};\n\n// Extend ImGuiDataType_\nenum ImGuiDataTypePrivate_\n{\n    ImGuiDataType_Pointer = ImGuiDataType_COUNT + 1,\n    ImGuiDataType_ID,\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Widgets support: flags, enums, data structures\n//-----------------------------------------------------------------------------\n\n// Extend ImGuiItemFlags\n// - input: PushItemFlag() manipulates g.CurrentItemFlags, g.NextItemData.ItemFlags, ItemAdd() calls may add extra flags too.\n// - output: stored in g.LastItemData.ItemFlags\nenum ImGuiItemFlagsPrivate_\n{\n    // Controlled by user\n    ImGuiItemFlags_Disabled                 = 1 << 10, // false     // Disable interactions (DOES NOT affect visuals. DO NOT mix direct use of this with BeginDisabled(). See BeginDisabled()/EndDisabled() for full disable feature, and github #211).\n    ImGuiItemFlags_ReadOnly                 = 1 << 11, // false     // [ALPHA] Allow hovering interactions but underlying value is not changed.\n    ImGuiItemFlags_MixedValue               = 1 << 12, // false     // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)\n    ImGuiItemFlags_NoWindowHoverableCheck   = 1 << 13, // false     // Disable hoverable check in ItemHoverable()\n    ImGuiItemFlags_AllowOverlap             = 1 << 14, // false     // Allow being overlapped by another widget. Not-hovered to Hovered transition deferred by a frame.\n    ImGuiItemFlags_NoNavDisableMouseHover   = 1 << 15, // false     // Nav keyboard/gamepad mode doesn't disable hover highlight (behave as if NavHighlightItemUnderNav==false).\n    ImGuiItemFlags_NoMarkEdited             = 1 << 16, // false     // Skip calling MarkItemEdited()\n\n    // Controlled by widget code\n    ImGuiItemFlags_Inputable                = 1 << 20, // false     // [WIP] Auto-activate input mode when tab focused. Currently only used and supported by a few items before it becomes a generic feature.\n    ImGuiItemFlags_HasSelectionUserData     = 1 << 21, // false     // Set by SetNextItemSelectionUserData()\n    ImGuiItemFlags_IsMultiSelect            = 1 << 22, // false     // Set by SetNextItemSelectionUserData()\n\n    ImGuiItemFlags_Default_                 = ImGuiItemFlags_AutoClosePopups,    // Please don't change, use PushItemFlag() instead.\n\n    // Obsolete\n    //ImGuiItemFlags_SelectableDontClosePopup = !ImGuiItemFlags_AutoClosePopups, // Can't have a redirect as we inverted the behavior\n};\n\n// Status flags for an already submitted item\n// - output: stored in g.LastItemData.StatusFlags\nenum ImGuiItemStatusFlags_\n{\n    ImGuiItemStatusFlags_None               = 0,\n    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,   // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)\n    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,   // g.LastItemData.DisplayRect is valid\n    ImGuiItemStatusFlags_Edited             = 1 << 2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)\n    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3,   // Set when Selectable(), TreeNode() reports toggling a selection. We can't report \"Selected\", only state changes, in order to easily handle clipping with less issues.\n    ImGuiItemStatusFlags_ToggledOpen        = 1 << 4,   // Set when TreeNode() reports toggling their open state.\n    ImGuiItemStatusFlags_HasDeactivated     = 1 << 5,   // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.\n    ImGuiItemStatusFlags_Deactivated        = 1 << 6,   // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.\n    ImGuiItemStatusFlags_HoveredWindow      = 1 << 7,   // Override the HoveredWindow test to allow cross-window hover testing.\n    ImGuiItemStatusFlags_Visible            = 1 << 8,   // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).\n    ImGuiItemStatusFlags_HasClipRect        = 1 << 9,   // g.LastItemData.ClipRect is valid.\n    ImGuiItemStatusFlags_HasShortcut        = 1 << 10,  // g.LastItemData.Shortcut valid. Set by SetNextItemShortcut() -> ItemAdd().\n\n    // Additional status + semantic for ImGuiTestEngine\n#ifdef IMGUI_ENABLE_TEST_ENGINE\n    ImGuiItemStatusFlags_Openable           = 1 << 20,  // Item is an openable (e.g. TreeNode)\n    ImGuiItemStatusFlags_Opened             = 1 << 21,  // Opened status\n    ImGuiItemStatusFlags_Checkable          = 1 << 22,  // Item is a checkable (e.g. CheckBox, MenuItem)\n    ImGuiItemStatusFlags_Checked            = 1 << 23,  // Checked status\n    ImGuiItemStatusFlags_Inputable          = 1 << 24,  // Item is a text-inputable (e.g. InputText, SliderXXX, DragXXX)\n#endif\n};\n\n// Extend ImGuiHoveredFlags_\nenum ImGuiHoveredFlagsPrivate_\n{\n    ImGuiHoveredFlags_DelayMask_                    = ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_NoSharedDelay,\n    ImGuiHoveredFlags_AllowedMaskForIsWindowHovered = ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_NoPopupHierarchy | ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_Stationary,\n    ImGuiHoveredFlags_AllowedMaskForIsItemHovered   = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_AllowWhenDisabled | ImGuiHoveredFlags_NoNavOverride | ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayMask_,\n};\n\n// Extend ImGuiInputTextFlags_\nenum ImGuiInputTextFlagsPrivate_\n{\n    // [Internal]\n    ImGuiInputTextFlags_Multiline           = 1 << 26,  // For internal use by InputTextMultiline()\n    ImGuiInputTextFlags_MergedItem          = 1 << 27,  // For internal use by TempInputText(), will skip calling ItemAdd(). Require bounding-box to strictly match.\n    ImGuiInputTextFlags_LocalizeDecimalPoint= 1 << 28,  // For internal use by InputScalar() and TempInputScalar()\n};\n\n// Extend ImGuiButtonFlags_\nenum ImGuiButtonFlagsPrivate_\n{\n    ImGuiButtonFlags_PressedOnClick         = 1 << 4,   // return true on click (mouse down event)\n    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 5,   // [Default] return true on click + release on same item <-- this is what the majority of Button are using\n    ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6, // return true on click + release even if the release event is not done while hovering the item\n    ImGuiButtonFlags_PressedOnRelease       = 1 << 7,   // return true on release (default requires click+release)\n    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 8,   // return true on double-click (default requires click+release)\n    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 9,   // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)\n    //ImGuiButtonFlags_Repeat               = 1 << 10,  // hold to repeat -> use ImGuiItemFlags_ButtonRepeat instead.\n    ImGuiButtonFlags_FlattenChildren        = 1 << 11,  // allow interactions even if a child window is overlapping\n    ImGuiButtonFlags_AllowOverlap           = 1 << 12,  // require previous frame HoveredId to either match id or be null before being usable.\n    //ImGuiButtonFlags_DontClosePopups      = 1 << 13,  // disable automatically closing parent popup on press\n    //ImGuiButtonFlags_Disabled             = 1 << 14,  // disable interactions -> use BeginDisabled() or ImGuiItemFlags_Disabled\n    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 15,  // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine\n    ImGuiButtonFlags_NoKeyModsAllowed       = 1 << 16,  // disable mouse interaction if a key modifier is held\n    ImGuiButtonFlags_NoHoldingActiveId      = 1 << 17,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)\n    ImGuiButtonFlags_NoNavFocus             = 1 << 18,  // don't override navigation focus when activated (FIXME: this is essentially used every time an item uses ImGuiItemFlags_NoNav, but because legacy specs don't requires LastItemData to be set ButtonBehavior(), we can't poll g.LastItemData.ItemFlags)\n    ImGuiButtonFlags_NoHoveredOnFocus       = 1 << 19,  // don't report as hovered when nav focus is on this item\n    ImGuiButtonFlags_NoSetKeyOwner          = 1 << 20,  // don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)\n    ImGuiButtonFlags_NoTestKeyOwner         = 1 << 21,  // don't test key/input owner when polling the key (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)\n    ImGuiButtonFlags_PressedOnMask_         = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,\n    ImGuiButtonFlags_PressedOnDefault_      = ImGuiButtonFlags_PressedOnClickRelease,\n};\n\n// Extend ImGuiComboFlags_\nenum ImGuiComboFlagsPrivate_\n{\n    ImGuiComboFlags_CustomPreview           = 1 << 20,  // enable BeginComboPreview()\n};\n\n// Extend ImGuiSliderFlags_\nenum ImGuiSliderFlagsPrivate_\n{\n    ImGuiSliderFlags_Vertical               = 1 << 20,  // Should this slider be orientated vertically?\n    ImGuiSliderFlags_ReadOnly               = 1 << 21,  // Consider using g.NextItemData.ItemFlags |= ImGuiItemFlags_ReadOnly instead.\n};\n\n// Extend ImGuiSelectableFlags_\nenum ImGuiSelectableFlagsPrivate_\n{\n    // NB: need to be in sync with last value of ImGuiSelectableFlags_\n    ImGuiSelectableFlags_NoHoldingActiveID      = 1 << 20,\n    ImGuiSelectableFlags_SelectOnNav            = 1 << 21,  // (WIP) Auto-select when moved into. This is not exposed in public API as to handle multi-select and modifiers we will need user to explicitly control focus scope. May be replaced with a BeginSelection() API.\n    ImGuiSelectableFlags_SelectOnClick          = 1 << 22,  // Override button behavior to react on Click (default is Click+Release)\n    ImGuiSelectableFlags_SelectOnRelease        = 1 << 23,  // Override button behavior to react on Release (default is Click+Release)\n    ImGuiSelectableFlags_SpanAvailWidth         = 1 << 24,  // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)\n    ImGuiSelectableFlags_SetNavIdOnHover        = 1 << 25,  // Set Nav/Focus ID on mouse hover (used by MenuItem)\n    ImGuiSelectableFlags_NoPadWithHalfSpacing   = 1 << 26,  // Disable padding each side with ItemSpacing * 0.5f\n    ImGuiSelectableFlags_NoSetKeyOwner          = 1 << 27,  // Don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)\n};\n\n// Extend ImGuiTreeNodeFlags_\nenum ImGuiTreeNodeFlagsPrivate_\n{\n    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 28,// FIXME-WIP: Hard-coded for CollapsingHeader()\n    ImGuiTreeNodeFlags_UpsideDownArrow            = 1 << 29,// FIXME-WIP: Turn Down arrow into an Up arrow, for reversed trees (#6517)\n    ImGuiTreeNodeFlags_OpenOnMask_                = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow,\n};\n\nenum ImGuiSeparatorFlags_\n{\n    ImGuiSeparatorFlags_None                    = 0,\n    ImGuiSeparatorFlags_Horizontal              = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar\n    ImGuiSeparatorFlags_Vertical                = 1 << 1,\n    ImGuiSeparatorFlags_SpanAllColumns          = 1 << 2,   // Make separator cover all columns of a legacy Columns() set.\n};\n\n// Flags for FocusWindow(). This is not called ImGuiFocusFlags to avoid confusion with public-facing ImGuiFocusedFlags.\n// FIXME: Once we finishing replacing more uses of GetTopMostPopupModal()+IsWindowWithinBeginStackOf()\n// and FindBlockingModal() with this, we may want to change the flag to be opt-out instead of opt-in.\nenum ImGuiFocusRequestFlags_\n{\n    ImGuiFocusRequestFlags_None                 = 0,\n    ImGuiFocusRequestFlags_RestoreFocusedChild  = 1 << 0,   // Find last focused child (if any) and focus it instead.\n    ImGuiFocusRequestFlags_UnlessBelowModal     = 1 << 1,   // Do not set focus if the window is below a modal.\n};\n\nenum ImGuiTextFlags_\n{\n    ImGuiTextFlags_None                         = 0,\n    ImGuiTextFlags_NoWidthForLargeClippedText   = 1 << 0,\n};\n\nenum ImGuiTooltipFlags_\n{\n    ImGuiTooltipFlags_None                      = 0,\n    ImGuiTooltipFlags_OverridePrevious          = 1 << 1,   // Clear/ignore previously submitted tooltip (defaults to append)\n};\n\n// FIXME: this is in development, not exposed/functional as a generic feature yet.\n// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2\nenum ImGuiLayoutType_\n{\n    ImGuiLayoutType_Horizontal = 0,\n    ImGuiLayoutType_Vertical = 1\n};\n\n// Flags for LogBegin() text capturing function\nenum ImGuiLogFlags_\n{\n    ImGuiLogFlags_None = 0,\n\n    ImGuiLogFlags_OutputTTY         = 1 << 0,\n    ImGuiLogFlags_OutputFile        = 1 << 1,\n    ImGuiLogFlags_OutputBuffer      = 1 << 2,\n    ImGuiLogFlags_OutputClipboard   = 1 << 3,\n    ImGuiLogFlags_OutputMask_       = ImGuiLogFlags_OutputTTY | ImGuiLogFlags_OutputFile | ImGuiLogFlags_OutputBuffer | ImGuiLogFlags_OutputClipboard,\n};\n\n// X/Y enums are fixed to 0/1 so they may be used to index ImVec2\nenum ImGuiAxis\n{\n    ImGuiAxis_None = -1,\n    ImGuiAxis_X = 0,\n    ImGuiAxis_Y = 1\n};\n\nenum ImGuiPlotType\n{\n    ImGuiPlotType_Lines,\n    ImGuiPlotType_Histogram,\n};\n\n// Stacked color modifier, backup of modified data so we can restore it\nstruct ImGuiColorMod\n{\n    ImGuiCol        Col;\n    ImVec4          BackupValue;\n};\n\n// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.\nstruct ImGuiStyleMod\n{\n    ImGuiStyleVar   VarIdx;\n    union           { int BackupInt[2]; float BackupFloat[2]; };\n    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }\n    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }\n    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }\n};\n\n// Storage data for BeginComboPreview()/EndComboPreview()\nstruct IMGUI_API ImGuiComboPreviewData\n{\n    ImRect          PreviewRect;\n    ImVec2          BackupCursorPos;\n    ImVec2          BackupCursorMaxPos;\n    ImVec2          BackupCursorPosPrevLine;\n    float           BackupPrevLineTextBaseOffset;\n    ImGuiLayoutType BackupLayout;\n\n    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }\n};\n\n// Stacked storage data for BeginGroup()/EndGroup()\nstruct IMGUI_API ImGuiGroupData\n{\n    ImGuiID     WindowID;\n    ImVec2      BackupCursorPos;\n    ImVec2      BackupCursorMaxPos;\n    ImVec2      BackupCursorPosPrevLine;\n    ImVec1      BackupIndent;\n    ImVec1      BackupGroupOffset;\n    ImVec2      BackupCurrLineSize;\n    float       BackupCurrLineTextBaseOffset;\n    ImGuiID     BackupActiveIdIsAlive;\n    bool        BackupActiveIdPreviousFrameIsAlive;\n    bool        BackupHoveredIdIsAlive;\n    bool        BackupIsSameLine;\n    bool        EmitItem;\n};\n\n// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.\nstruct IMGUI_API ImGuiMenuColumns\n{\n    ImU32       TotalWidth;\n    ImU32       NextTotalWidth;\n    ImU16       Spacing;\n    ImU16       OffsetIcon;         // Always zero for now\n    ImU16       OffsetLabel;        // Offsets are locked in Update()\n    ImU16       OffsetShortcut;\n    ImU16       OffsetMark;\n    ImU16       Widths[4];          // Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)\n\n    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }\n    void        Update(float spacing, bool window_reappearing);\n    float       DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark);\n    void        CalcNextTotalWidth(bool update_offsets);\n};\n\n// Internal temporary state for deactivating InputText() instances.\nstruct IMGUI_API ImGuiInputTextDeactivatedState\n{\n    ImGuiID            ID;              // widget id owning the text state (which just got deactivated)\n    ImVector<char>     TextA;           // text buffer\n\n    ImGuiInputTextDeactivatedState()    { memset(this, 0, sizeof(*this)); }\n    void    ClearFreeMemory()           { ID = 0; TextA.clear(); }\n};\n\n// Forward declare imstb_textedit.h structure + make its main configuration define accessible\n#undef IMSTB_TEXTEDIT_STRING\n#undef IMSTB_TEXTEDIT_CHARTYPE\n#define IMSTB_TEXTEDIT_STRING             ImGuiInputTextState\n#define IMSTB_TEXTEDIT_CHARTYPE           char\n#define IMSTB_TEXTEDIT_GETWIDTH_NEWLINE   (-1.0f)\n#define IMSTB_TEXTEDIT_UNDOSTATECOUNT     99\n#define IMSTB_TEXTEDIT_UNDOCHARCOUNT      999\nnamespace ImStb { struct STB_TexteditState; }\ntypedef ImStb::STB_TexteditState ImStbTexteditState;\n\n// Internal state of the currently focused/edited text input box\n// For a given item ID, access with ImGui::GetInputTextState()\nstruct IMGUI_API ImGuiInputTextState\n{\n    ImGuiContext*           Ctx;                    // parent UI context (needs to be set explicitly by parent).\n    ImStbTexteditState*     Stb;                    // State for stb_textedit.h\n    ImGuiInputTextFlags     Flags;                  // copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.\n    ImGuiID                 ID;                     // widget id owning the text state\n    int                     TextLen;                // UTF-8 length of the string in TextA (in bytes)\n    const char*             TextSrc;                // == TextA.Data unless read-only, in which case == buf passed to InputText(). Field only set and valid _inside_ the call InputText() call.\n    ImVector<char>          TextA;                  // main UTF8 buffer. TextA.Size is a buffer size! Should always be >= buf_size passed by user (and of course >= CurLenA + 1).\n    ImVector<char>          TextToRevertTo;         // value to revert to when pressing Escape = backup of end-user buffer at the time of focus (in UTF-8, unaltered)\n    ImVector<char>          CallbackTextBackup;     // temporary storage for callback to support automatic reconcile of undo-stack\n    int                     BufCapacity;            // end-user buffer capacity (include zero terminator)\n    ImVec2                  Scroll;                 // horizontal offset (managed manually) + vertical scrolling (pulled from child window's own Scroll.y)\n    float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately\n    bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)\n    bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection\n    bool                    Edited;                 // edited this frame\n    bool                    WantReloadUserBuf;      // force a reload of user buf so it may be modified externally. may be automatic in future version.\n    int                     ReloadSelectionStart;\n    int                     ReloadSelectionEnd;\n\n    ImGuiInputTextState();\n    ~ImGuiInputTextState();\n    void        ClearText()                 { TextLen = 0; TextA[0] = 0; CursorClamp(); }\n    void        ClearFreeMemory()           { TextA.clear(); TextToRevertTo.clear(); }\n    void        OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation\n    void        OnCharPressed(unsigned int c);\n\n    // Cursor & Selection\n    void        CursorAnimReset();\n    void        CursorClamp();\n    bool        HasSelection() const;\n    void        ClearSelection();\n    int         GetCursorPos() const;\n    int         GetSelectionStart() const;\n    int         GetSelectionEnd() const;\n    void        SelectAll();\n\n    // Reload user buf (WIP #2890)\n    // If you modify underlying user-passed const char* while active you need to call this (InputText V2 may lift this)\n    //   strcpy(my_buf, \"hello\");\n    //   if (ImGuiInputTextState* state = ImGui::GetInputTextState(id)) // id may be ImGui::GetItemID() is last item\n    //       state->ReloadUserBufAndSelectAll();\n    void        ReloadUserBufAndSelectAll();\n    void        ReloadUserBufAndKeepSelection();\n    void        ReloadUserBufAndMoveToEnd();\n};\n\nenum ImGuiWindowRefreshFlags_\n{\n    ImGuiWindowRefreshFlags_None                = 0,\n    ImGuiWindowRefreshFlags_TryToAvoidRefresh   = 1 << 0,   // [EXPERIMENTAL] Try to keep existing contents, USER MUST NOT HONOR BEGIN() RETURNING FALSE AND NOT APPEND.\n    ImGuiWindowRefreshFlags_RefreshOnHover      = 1 << 1,   // [EXPERIMENTAL] Always refresh on hover\n    ImGuiWindowRefreshFlags_RefreshOnFocus      = 1 << 2,   // [EXPERIMENTAL] Always refresh on focus\n    // Refresh policy/frequency, Load Balancing etc.\n};\n\nenum ImGuiNextWindowDataFlags_\n{\n    ImGuiNextWindowDataFlags_None               = 0,\n    ImGuiNextWindowDataFlags_HasPos             = 1 << 0,\n    ImGuiNextWindowDataFlags_HasSize            = 1 << 1,\n    ImGuiNextWindowDataFlags_HasContentSize     = 1 << 2,\n    ImGuiNextWindowDataFlags_HasCollapsed       = 1 << 3,\n    ImGuiNextWindowDataFlags_HasSizeConstraint  = 1 << 4,\n    ImGuiNextWindowDataFlags_HasFocus           = 1 << 5,\n    ImGuiNextWindowDataFlags_HasBgAlpha         = 1 << 6,\n    ImGuiNextWindowDataFlags_HasScroll          = 1 << 7,\n    ImGuiNextWindowDataFlags_HasChildFlags      = 1 << 8,\n    ImGuiNextWindowDataFlags_HasRefreshPolicy   = 1 << 9,\n};\n\n// Storage for SetNexWindow** functions\nstruct ImGuiNextWindowData\n{\n    ImGuiNextWindowDataFlags    Flags;\n    ImGuiCond                   PosCond;\n    ImGuiCond                   SizeCond;\n    ImGuiCond                   CollapsedCond;\n    ImVec2                      PosVal;\n    ImVec2                      PosPivotVal;\n    ImVec2                      SizeVal;\n    ImVec2                      ContentSizeVal;\n    ImVec2                      ScrollVal;\n    ImGuiChildFlags             ChildFlags;\n    bool                        CollapsedVal;\n    ImRect                      SizeConstraintRect;\n    ImGuiSizeCallback           SizeCallback;\n    void*                       SizeCallbackUserData;\n    float                       BgAlphaVal;             // Override background alpha\n    ImVec2                      MenuBarOffsetMinVal;    // (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)\n    ImGuiWindowRefreshFlags     RefreshFlagsVal;\n\n    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }\n    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }\n};\n\nenum ImGuiNextItemDataFlags_\n{\n    ImGuiNextItemDataFlags_None         = 0,\n    ImGuiNextItemDataFlags_HasWidth     = 1 << 0,\n    ImGuiNextItemDataFlags_HasOpen      = 1 << 1,\n    ImGuiNextItemDataFlags_HasShortcut  = 1 << 2,\n    ImGuiNextItemDataFlags_HasRefVal    = 1 << 3,\n    ImGuiNextItemDataFlags_HasStorageID = 1 << 4,\n};\n\nstruct ImGuiNextItemData\n{\n    ImGuiNextItemDataFlags      HasFlags;           // Called HasFlags instead of Flags to avoid mistaking this\n    ImGuiItemFlags              ItemFlags;          // Currently only tested/used for ImGuiItemFlags_AllowOverlap and ImGuiItemFlags_HasSelectionUserData.\n    // Non-flags members are NOT cleared by ItemAdd() meaning they are still valid during NavProcessItem()\n    ImGuiID                     FocusScopeId;       // Set by SetNextItemSelectionUserData()\n    ImGuiSelectionUserData      SelectionUserData;  // Set by SetNextItemSelectionUserData() (note that NULL/0 is a valid value, we use -1 == ImGuiSelectionUserData_Invalid to mark invalid values)\n    float                       Width;              // Set by SetNextItemWidth()\n    ImGuiKeyChord               Shortcut;           // Set by SetNextItemShortcut()\n    ImGuiInputFlags             ShortcutFlags;      // Set by SetNextItemShortcut()\n    bool                        OpenVal;            // Set by SetNextItemOpen()\n    ImU8                        OpenCond;           // Set by SetNextItemOpen()\n    ImGuiDataTypeStorage        RefVal;             // Not exposed yet, for ImGuiInputTextFlags_ParseEmptyAsRefVal\n    ImGuiID                     StorageId;          // Set by SetNextItemStorageID()\n\n    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); SelectionUserData = -1; }\n    inline void ClearFlags()    { HasFlags = ImGuiNextItemDataFlags_None; ItemFlags = ImGuiItemFlags_None; } // Also cleared manually by ItemAdd()!\n};\n\n// Status storage for the last submitted item\nstruct ImGuiLastItemData\n{\n    ImGuiID                 ID;\n    ImGuiItemFlags          ItemFlags;          // See ImGuiItemFlags_\n    ImGuiItemStatusFlags    StatusFlags;        // See ImGuiItemStatusFlags_\n    ImRect                  Rect;               // Full rectangle\n    ImRect                  NavRect;            // Navigation scoring rectangle (not displayed)\n    // Rarely used fields are not explicitly cleared, only valid when the corresponding ImGuiItemStatusFlags ar set.\n    ImRect                  DisplayRect;        // Display rectangle. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) is set.\n    ImRect                  ClipRect;           // Clip rectangle at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasClipRect) is set..\n    ImGuiKeyChord           Shortcut;           // Shortcut at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasShortcut) is set..\n\n    ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }\n};\n\n// Store data emitted by TreeNode() for usage by TreePop()\n// - To implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere: store the minimum amount of data\n//   which we can't infer in TreePop(), to perform the equivalent of NavApplyItemToResult().\n//   Only stored when the node is a potential candidate for landing on a Left arrow jump.\nstruct ImGuiTreeNodeStackData\n{\n    ImGuiID                 ID;\n    ImGuiTreeNodeFlags      TreeFlags;\n    ImGuiItemFlags          ItemFlags;  // Used for nav landing\n    ImRect                  NavRect;    // Used for nav landing\n};\n\n// sizeof() = 20\nstruct IMGUI_API ImGuiErrorRecoveryState\n{\n    short   SizeOfWindowStack;\n    short   SizeOfIDStack;\n    short   SizeOfTreeStack;\n    short   SizeOfColorStack;\n    short   SizeOfStyleVarStack;\n    short   SizeOfFontStack;\n    short   SizeOfFocusScopeStack;\n    short   SizeOfGroupStack;\n    short   SizeOfItemFlagsStack;\n    short   SizeOfBeginPopupStack;\n    short   SizeOfDisabledStack;\n\n    ImGuiErrorRecoveryState() { memset(this, 0, sizeof(*this)); }\n};\n\n// Data saved for each window pushed into the stack\nstruct ImGuiWindowStackData\n{\n    ImGuiWindow*            Window;\n    ImGuiLastItemData       ParentLastItemDataBackup;\n    ImGuiErrorRecoveryState StackSizesInBegin;          // Store size of various stacks for asserting\n    bool                    DisabledOverrideReenable;   // Non-child window override disabled flag\n};\n\nstruct ImGuiShrinkWidthItem\n{\n    int         Index;\n    float       Width;\n    float       InitialWidth;\n};\n\nstruct ImGuiPtrOrIndex\n{\n    void*       Ptr;            // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.\n    int         Index;          // Usually index in a main pool.\n\n    ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }\n    ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Popup support\n//-----------------------------------------------------------------------------\n\nenum ImGuiPopupPositionPolicy\n{\n    ImGuiPopupPositionPolicy_Default,\n    ImGuiPopupPositionPolicy_ComboBox,\n    ImGuiPopupPositionPolicy_Tooltip,\n};\n\n// Storage for popup stacks (g.OpenPopupStack and g.BeginPopupStack)\nstruct ImGuiPopupData\n{\n    ImGuiID             PopupId;        // Set on OpenPopup()\n    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()\n    ImGuiWindow*        RestoreNavWindow;// Set on OpenPopup(), a NavWindow that will be restored on popup close\n    int                 ParentNavLayer; // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as \"not any of layers\" value\n    int                 OpenFrameCount; // Set on OpenPopup()\n    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)\n    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)\n    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup\n\n    ImGuiPopupData()    { memset(this, 0, sizeof(*this)); ParentNavLayer = OpenFrameCount = -1; }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Inputs support\n//-----------------------------------------------------------------------------\n\n// Bit array for named keys\ntypedef ImBitArray<ImGuiKey_NamedKey_COUNT, -ImGuiKey_NamedKey_BEGIN>    ImBitArrayForNamedKeys;\n\n// [Internal] Key ranges\n#define ImGuiKey_LegacyNativeKey_BEGIN  0\n#define ImGuiKey_LegacyNativeKey_END    512\n#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)\n#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)\n#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)\n#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)\n#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)\n#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)\n#define ImGuiKey_Aliases_BEGIN          (ImGuiKey_Mouse_BEGIN)\n#define ImGuiKey_Aliases_END            (ImGuiKey_Mouse_END)\n\n// [Internal] Named shortcuts for Navigation\n#define ImGuiKey_NavKeyboardTweakSlow   ImGuiMod_Ctrl\n#define ImGuiKey_NavKeyboardTweakFast   ImGuiMod_Shift\n#define ImGuiKey_NavGamepadTweakSlow    ImGuiKey_GamepadL1\n#define ImGuiKey_NavGamepadTweakFast    ImGuiKey_GamepadR1\n#define ImGuiKey_NavGamepadActivate     (g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey_GamepadFaceRight : ImGuiKey_GamepadFaceDown)\n#define ImGuiKey_NavGamepadCancel       (g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey_GamepadFaceDown : ImGuiKey_GamepadFaceRight)\n#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft\n#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp\n\nenum ImGuiInputEventType\n{\n    ImGuiInputEventType_None = 0,\n    ImGuiInputEventType_MousePos,\n    ImGuiInputEventType_MouseWheel,\n    ImGuiInputEventType_MouseButton,\n    ImGuiInputEventType_Key,\n    ImGuiInputEventType_Text,\n    ImGuiInputEventType_Focus,\n    ImGuiInputEventType_COUNT\n};\n\nenum ImGuiInputSource\n{\n    ImGuiInputSource_None = 0,\n    ImGuiInputSource_Mouse,         // Note: may be Mouse or TouchScreen or Pen. See io.MouseSource to distinguish them.\n    ImGuiInputSource_Keyboard,\n    ImGuiInputSource_Gamepad,\n    ImGuiInputSource_COUNT\n};\n\n// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?\n// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'\nstruct ImGuiInputEventMousePos      { float PosX, PosY; ImGuiMouseSource MouseSource; };\nstruct ImGuiInputEventMouseWheel    { float WheelX, WheelY; ImGuiMouseSource MouseSource; };\nstruct ImGuiInputEventMouseButton   { int Button; bool Down; ImGuiMouseSource MouseSource; };\nstruct ImGuiInputEventKey           { ImGuiKey Key; bool Down; float AnalogValue; };\nstruct ImGuiInputEventText          { unsigned int Char; };\nstruct ImGuiInputEventAppFocused    { bool Focused; };\n\nstruct ImGuiInputEvent\n{\n    ImGuiInputEventType             Type;\n    ImGuiInputSource                Source;\n    ImU32                           EventId;        // Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).\n    union\n    {\n        ImGuiInputEventMousePos     MousePos;       // if Type == ImGuiInputEventType_MousePos\n        ImGuiInputEventMouseWheel   MouseWheel;     // if Type == ImGuiInputEventType_MouseWheel\n        ImGuiInputEventMouseButton  MouseButton;    // if Type == ImGuiInputEventType_MouseButton\n        ImGuiInputEventKey          Key;            // if Type == ImGuiInputEventType_Key\n        ImGuiInputEventText         Text;           // if Type == ImGuiInputEventType_Text\n        ImGuiInputEventAppFocused   AppFocused;     // if Type == ImGuiInputEventType_Focus\n    };\n    bool                            AddedByTestEngine;\n\n    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }\n};\n\n// Input function taking an 'ImGuiID owner_id' argument defaults to (ImGuiKeyOwner_Any == 0) aka don't test ownership, which matches legacy behavior.\n#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.\n#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.\n//#define ImGuiKeyOwner_None ImGuiKeyOwner_NoOwner  // We previously called this 'ImGuiKeyOwner_None' but it was inconsistent with our pattern that _None values == 0 and quite dangerous. Also using _NoOwner makes the IsKeyPressed() calls more explicit.\n\ntypedef ImS16 ImGuiKeyRoutingIndex;\n\n// Routing table entry (sizeof() == 16 bytes)\nstruct ImGuiKeyRoutingData\n{\n    ImGuiKeyRoutingIndex            NextEntryIndex;\n    ImU16                           Mods;               // Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits.\n    ImU8                            RoutingCurrScore;   // [DEBUG] For debug display\n    ImU8                            RoutingNextScore;   // Lower is better (0: perfect score)\n    ImGuiID                         RoutingCurr;\n    ImGuiID                         RoutingNext;\n\n    ImGuiKeyRoutingData()           { NextEntryIndex = -1; Mods = 0; RoutingCurrScore = RoutingNextScore = 255; RoutingCurr = RoutingNext = ImGuiKeyOwner_NoOwner; }\n};\n\n// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.\n// Stored in main context (1 instance)\nstruct ImGuiKeyRoutingTable\n{\n    ImGuiKeyRoutingIndex            Index[ImGuiKey_NamedKey_COUNT]; // Index of first entry in Entries[]\n    ImVector<ImGuiKeyRoutingData>   Entries;\n    ImVector<ImGuiKeyRoutingData>   EntriesNext;                    // Double-buffer to avoid reallocation (could use a shared buffer)\n\n    ImGuiKeyRoutingTable()          { Clear(); }\n    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Index); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }\n};\n\n// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)\n// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.\nstruct ImGuiKeyOwnerData\n{\n    ImGuiID     OwnerCurr;\n    ImGuiID     OwnerNext;\n    bool        LockThisFrame;      // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.\n    bool        LockUntilRelease;   // Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.\n\n    ImGuiKeyOwnerData()             { OwnerCurr = OwnerNext = ImGuiKeyOwner_NoOwner; LockThisFrame = LockUntilRelease = false; }\n};\n\n// Extend ImGuiInputFlags_\n// Flags for extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner()\n// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)\nenum ImGuiInputFlagsPrivate_\n{\n    // Flags for IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(), Shortcut()\n    // - Repeat mode: Repeat rate selection\n    ImGuiInputFlags_RepeatRateDefault           = 1 << 1,   // Repeat rate: Regular (default)\n    ImGuiInputFlags_RepeatRateNavMove           = 1 << 2,   // Repeat rate: Fast\n    ImGuiInputFlags_RepeatRateNavTweak          = 1 << 3,   // Repeat rate: Faster\n    // - Repeat mode: Specify when repeating key pressed can be interrupted.\n    // - In theory ImGuiInputFlags_RepeatUntilOtherKeyPress may be a desirable default, but it would break too many behavior so everything is opt-in.\n    ImGuiInputFlags_RepeatUntilRelease          = 1 << 4,   // Stop repeating when released (default for all functions except Shortcut). This only exists to allow overriding Shortcut() default behavior.\n    ImGuiInputFlags_RepeatUntilKeyModsChange    = 1 << 5,   // Stop repeating when released OR if keyboard mods are changed (default for Shortcut)\n    ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone = 1 << 6,  // Stop repeating when released OR if keyboard mods are leaving the None state. Allows going from Mod+Key to Key by releasing Mod.\n    ImGuiInputFlags_RepeatUntilOtherKeyPress    = 1 << 7,   // Stop repeating when released OR if any other keyboard key is pressed during the repeat\n\n    // Flags for SetKeyOwner(), SetItemKeyOwner()\n    // - Locking key away from non-input aware code. Locking is useful to make input-owner-aware code steal keys from non-input-owner-aware code. If all code is input-owner-aware locking would never be necessary.\n    ImGuiInputFlags_LockThisFrame               = 1 << 20,  // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared at end of frame.\n    ImGuiInputFlags_LockUntilRelease            = 1 << 21,  // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared when the key is released or at end of each frame if key is released.\n\n    // - Condition for SetItemKeyOwner()\n    ImGuiInputFlags_CondHovered                 = 1 << 22,  // Only set if item is hovered (default to both)\n    ImGuiInputFlags_CondActive                  = 1 << 23,  // Only set if item is active (default to both)\n    ImGuiInputFlags_CondDefault_                = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,\n\n    // [Internal] Mask of which function support which flags\n    ImGuiInputFlags_RepeatRateMask_             = ImGuiInputFlags_RepeatRateDefault | ImGuiInputFlags_RepeatRateNavMove | ImGuiInputFlags_RepeatRateNavTweak,\n    ImGuiInputFlags_RepeatUntilMask_            = ImGuiInputFlags_RepeatUntilRelease | ImGuiInputFlags_RepeatUntilKeyModsChange | ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone | ImGuiInputFlags_RepeatUntilOtherKeyPress,\n    ImGuiInputFlags_RepeatMask_                 = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_,\n    ImGuiInputFlags_CondMask_                   = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,\n    ImGuiInputFlags_RouteTypeMask_              = ImGuiInputFlags_RouteActive | ImGuiInputFlags_RouteFocused | ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteAlways,\n    ImGuiInputFlags_RouteOptionsMask_           = ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused | ImGuiInputFlags_RouteFromRootWindow,\n    ImGuiInputFlags_SupportedByIsKeyPressed     = ImGuiInputFlags_RepeatMask_,\n    ImGuiInputFlags_SupportedByIsMouseClicked   = ImGuiInputFlags_Repeat,\n    ImGuiInputFlags_SupportedByShortcut         = ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_,\n    ImGuiInputFlags_SupportedBySetNextItemShortcut = ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_ | ImGuiInputFlags_Tooltip,\n    ImGuiInputFlags_SupportedBySetKeyOwner      = ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease,\n    ImGuiInputFlags_SupportedBySetItemKeyOwner  = ImGuiInputFlags_SupportedBySetKeyOwner | ImGuiInputFlags_CondMask_,\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Clipper support\n//-----------------------------------------------------------------------------\n\n// Note that Max is exclusive, so perhaps should be using a Begin/End convention.\nstruct ImGuiListClipperRange\n{\n    int     Min;\n    int     Max;\n    bool    PosToIndexConvert;      // Begin/End are absolute position (will be converted to indices later)\n    ImS8    PosToIndexOffsetMin;    // Add to Min after converting to indices\n    ImS8    PosToIndexOffsetMax;    // Add to Min after converting to indices\n\n    static ImGuiListClipperRange    FromIndices(int min, int max)                               { ImGuiListClipperRange r = { min, max, false, 0, 0 }; return r; }\n    static ImGuiListClipperRange    FromPositions(float y1, float y2, int off_min, int off_max) { ImGuiListClipperRange r = { (int)y1, (int)y2, true, (ImS8)off_min, (ImS8)off_max }; return r; }\n};\n\n// Temporary clipper data, buffers shared/reused between instances\nstruct ImGuiListClipperData\n{\n    ImGuiListClipper*               ListClipper;\n    float                           LossynessOffset;\n    int                             StepNo;\n    int                             ItemsFrozen;\n    ImVector<ImGuiListClipperRange> Ranges;\n\n    ImGuiListClipperData()          { memset(this, 0, sizeof(*this)); }\n    void                            Reset(ImGuiListClipper* clipper) { ListClipper = clipper; StepNo = ItemsFrozen = 0; Ranges.resize(0); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Navigation support\n//-----------------------------------------------------------------------------\n\nenum ImGuiActivateFlags_\n{\n    ImGuiActivateFlags_None                 = 0,\n    ImGuiActivateFlags_PreferInput          = 1 << 0,       // Favor activation that requires keyboard text input (e.g. for Slider/Drag). Default for Enter key.\n    ImGuiActivateFlags_PreferTweak          = 1 << 1,       // Favor activation for tweaking with arrows or gamepad (e.g. for Slider/Drag). Default for Space key and if keyboard is not used.\n    ImGuiActivateFlags_TryToPreserveState   = 1 << 2,       // Request widget to preserve state if it can (e.g. InputText will try to preserve cursor/selection)\n    ImGuiActivateFlags_FromTabbing          = 1 << 3,       // Activation requested by a tabbing request\n    ImGuiActivateFlags_FromShortcut         = 1 << 4,       // Activation requested by an item shortcut via SetNextItemShortcut() function.\n};\n\n// Early work-in-progress API for ScrollToItem()\nenum ImGuiScrollFlags_\n{\n    ImGuiScrollFlags_None                   = 0,\n    ImGuiScrollFlags_KeepVisibleEdgeX       = 1 << 0,       // If item is not visible: scroll as little as possible on X axis to bring item back into view [default for X axis]\n    ImGuiScrollFlags_KeepVisibleEdgeY       = 1 << 1,       // If item is not visible: scroll as little as possible on Y axis to bring item back into view [default for Y axis for windows that are already visible]\n    ImGuiScrollFlags_KeepVisibleCenterX     = 1 << 2,       // If item is not visible: scroll to make the item centered on X axis [rarely used]\n    ImGuiScrollFlags_KeepVisibleCenterY     = 1 << 3,       // If item is not visible: scroll to make the item centered on Y axis\n    ImGuiScrollFlags_AlwaysCenterX          = 1 << 4,       // Always center the result item on X axis [rarely used]\n    ImGuiScrollFlags_AlwaysCenterY          = 1 << 5,       // Always center the result item on Y axis [default for Y axis for appearing window)\n    ImGuiScrollFlags_NoScrollParent         = 1 << 6,       // Disable forwarding scrolling to parent window if required to keep item/rect visible (only scroll window the function was applied to).\n    ImGuiScrollFlags_MaskX_                 = ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleCenterX | ImGuiScrollFlags_AlwaysCenterX,\n    ImGuiScrollFlags_MaskY_                 = ImGuiScrollFlags_KeepVisibleEdgeY | ImGuiScrollFlags_KeepVisibleCenterY | ImGuiScrollFlags_AlwaysCenterY,\n};\n\nenum ImGuiNavRenderCursorFlags_\n{\n    ImGuiNavRenderCursorFlags_None          = 0,\n    ImGuiNavRenderCursorFlags_Compact       = 1 << 1,       // Compact highlight, no padding/distance from focused item\n    ImGuiNavRenderCursorFlags_AlwaysDraw    = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) even when g.NavCursorVisible == false, aka even when using the mouse.\n    ImGuiNavRenderCursorFlags_NoRounding    = 1 << 3,\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    ImGuiNavHighlightFlags_None             = ImGuiNavRenderCursorFlags_None,       // Renamed in 1.91.4\n    ImGuiNavHighlightFlags_Compact          = ImGuiNavRenderCursorFlags_Compact,    // Renamed in 1.91.4\n    ImGuiNavHighlightFlags_AlwaysDraw       = ImGuiNavRenderCursorFlags_AlwaysDraw, // Renamed in 1.91.4\n    ImGuiNavHighlightFlags_NoRounding       = ImGuiNavRenderCursorFlags_NoRounding, // Renamed in 1.91.4\n#endif\n};\n\nenum ImGuiNavMoveFlags_\n{\n    ImGuiNavMoveFlags_None                  = 0,\n    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side\n    ImGuiNavMoveFlags_LoopY                 = 1 << 1,\n    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)\n    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful but provided for completeness\n    ImGuiNavMoveFlags_WrapMask_             = ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_WrapY,\n    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)\n    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5,   // Store alternate result in NavMoveResultLocalVisible that only comprise elements that are already fully visible (used by PageUp/PageDown)\n    ImGuiNavMoveFlags_ScrollToEdgeY         = 1 << 6,   // Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim to remove or reword, probably unnecessary\n    ImGuiNavMoveFlags_Forwarded             = 1 << 7,\n    ImGuiNavMoveFlags_DebugNoResult         = 1 << 8,   // Dummy scoring for debug purpose, don't apply result\n    ImGuiNavMoveFlags_FocusApi              = 1 << 9,   // Requests from focus API can land/focus/activate items even if they are marked with _NoTabStop (see NavProcessItemForTabbingRequest() for details)\n    ImGuiNavMoveFlags_IsTabbing             = 1 << 10,  // == Focus + Activate if item is Inputable + DontChangeNavHighlight\n    ImGuiNavMoveFlags_IsPageMove            = 1 << 11,  // Identify a PageDown/PageUp request.\n    ImGuiNavMoveFlags_Activate              = 1 << 12,  // Activate/select target item.\n    ImGuiNavMoveFlags_NoSelect              = 1 << 13,  // Don't trigger selection by not setting g.NavJustMovedTo\n    ImGuiNavMoveFlags_NoSetNavCursorVisible = 1 << 14,  // Do not alter the nav cursor visible state\n    ImGuiNavMoveFlags_NoClearActiveId       = 1 << 15,  // (Experimental) Do not clear active id when applying move result\n};\n\nenum ImGuiNavLayer\n{\n    ImGuiNavLayer_Main  = 0,    // Main scrolling layer\n    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt)\n    ImGuiNavLayer_COUNT\n};\n\n// Storage for navigation query/results\nstruct ImGuiNavItemData\n{\n    ImGuiWindow*        Window;         // Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)\n    ImGuiID             ID;             // Init,Move    // Best candidate item ID\n    ImGuiID             FocusScopeId;   // Init,Move    // Best candidate focus scope ID\n    ImRect              RectRel;        // Init,Move    // Best candidate bounding box in window relative space\n    ImGuiItemFlags      ItemFlags;      // ????,Move    // Best candidate item flags\n    float               DistBox;        //      Move    // Best candidate box distance to current NavId\n    float               DistCenter;     //      Move    // Best candidate center distance to current NavId\n    float               DistAxial;      //      Move    // Best candidate axial distance to current NavId\n    ImGuiSelectionUserData SelectionUserData;//I+Mov    // Best candidate SetNextItemSelectionUserData() value. Valid if (ItemFlags & ImGuiItemFlags_HasSelectionUserData)\n\n    ImGuiNavItemData()  { Clear(); }\n    void Clear()        { Window = NULL; ID = FocusScopeId = 0; ItemFlags = 0; SelectionUserData = -1; DistBox = DistCenter = DistAxial = FLT_MAX; }\n};\n\n// Storage for PushFocusScope(), g.FocusScopeStack[], g.NavFocusRoute[]\nstruct ImGuiFocusScopeData\n{\n    ImGuiID             ID;\n    ImGuiID             WindowID;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Typing-select support\n//-----------------------------------------------------------------------------\n\n// Flags for GetTypingSelectRequest()\nenum ImGuiTypingSelectFlags_\n{\n    ImGuiTypingSelectFlags_None                 = 0,\n    ImGuiTypingSelectFlags_AllowBackspace       = 1 << 0,   // Backspace to delete character inputs. If using: ensure GetTypingSelectRequest() is not called more than once per frame (filter by e.g. focus state)\n    ImGuiTypingSelectFlags_AllowSingleCharMode  = 1 << 1,   // Allow \"single char\" search mode which is activated when pressing the same character multiple times.\n};\n\n// Returned by GetTypingSelectRequest(), designed to eventually be public.\nstruct IMGUI_API ImGuiTypingSelectRequest\n{\n    ImGuiTypingSelectFlags  Flags;              // Flags passed to GetTypingSelectRequest()\n    int                     SearchBufferLen;\n    const char*             SearchBuffer;       // Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).\n    bool                    SelectRequest;      // Set when buffer was modified this frame, requesting a selection.\n    bool                    SingleCharMode;     // Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.\n    ImS8                    SingleCharSize;     // Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.\n};\n\n// Storage for GetTypingSelectRequest()\nstruct IMGUI_API ImGuiTypingSelectState\n{\n    ImGuiTypingSelectRequest Request;           // User-facing data\n    char            SearchBuffer[64];           // Search buffer: no need to make dynamic as this search is very transient.\n    ImGuiID         FocusScope;\n    int             LastRequestFrame = 0;\n    float           LastRequestTime = 0.0f;\n    bool            SingleCharModeLock = false; // After a certain single char repeat count we lock into SingleCharMode. Two benefits: 1) buffer never fill, 2) we can provide an immediate SingleChar mode without timer elapsing.\n\n    ImGuiTypingSelectState() { memset(this, 0, sizeof(*this)); }\n    void            Clear()  { SearchBuffer[0] = 0; SingleCharModeLock = false; } // We preserve remaining data for easier debugging\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Columns support\n//-----------------------------------------------------------------------------\n\n// Flags for internal's BeginColumns(). This is an obsolete API. Prefer using BeginTable() nowadays!\nenum ImGuiOldColumnFlags_\n{\n    ImGuiOldColumnFlags_None                    = 0,\n    ImGuiOldColumnFlags_NoBorder                = 1 << 0,   // Disable column dividers\n    ImGuiOldColumnFlags_NoResize                = 1 << 1,   // Disable resizing columns when clicking on the dividers\n    ImGuiOldColumnFlags_NoPreserveWidths        = 1 << 2,   // Disable column width preservation when adjusting columns\n    ImGuiOldColumnFlags_NoForceWithinWindow     = 1 << 3,   // Disable forcing columns to fit within window\n    ImGuiOldColumnFlags_GrowParentContentsSize  = 1 << 4,   // Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.\n\n    // Obsolete names (will be removed)\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    //ImGuiColumnsFlags_None                    = ImGuiOldColumnFlags_None,\n    //ImGuiColumnsFlags_NoBorder                = ImGuiOldColumnFlags_NoBorder,\n    //ImGuiColumnsFlags_NoResize                = ImGuiOldColumnFlags_NoResize,\n    //ImGuiColumnsFlags_NoPreserveWidths        = ImGuiOldColumnFlags_NoPreserveWidths,\n    //ImGuiColumnsFlags_NoForceWithinWindow     = ImGuiOldColumnFlags_NoForceWithinWindow,\n    //ImGuiColumnsFlags_GrowParentContentsSize  = ImGuiOldColumnFlags_GrowParentContentsSize,\n#endif\n};\n\nstruct ImGuiOldColumnData\n{\n    float               OffsetNorm;             // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)\n    float               OffsetNormBeforeResize;\n    ImGuiOldColumnFlags Flags;                  // Not exposed\n    ImRect              ClipRect;\n\n    ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }\n};\n\nstruct ImGuiOldColumns\n{\n    ImGuiID             ID;\n    ImGuiOldColumnFlags Flags;\n    bool                IsFirstFrame;\n    bool                IsBeingResized;\n    int                 Current;\n    int                 Count;\n    float               OffMinX, OffMaxX;       // Offsets from HostWorkRect.Min.x\n    float               LineMinY, LineMaxY;\n    float               HostCursorPosY;         // Backup of CursorPos at the time of BeginColumns()\n    float               HostCursorMaxPosX;      // Backup of CursorMaxPos at the time of BeginColumns()\n    ImRect              HostInitialClipRect;    // Backup of ClipRect at the time of BeginColumns()\n    ImRect              HostBackupClipRect;     // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()\n    ImRect              HostBackupParentWorkRect;//Backup of WorkRect at the time of BeginColumns()\n    ImVector<ImGuiOldColumnData> Columns;\n    ImDrawListSplitter  Splitter;\n\n    ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Box-select support\n//-----------------------------------------------------------------------------\n\nstruct ImGuiBoxSelectState\n{\n    // Active box-selection data (persistent, 1 active at a time)\n    ImGuiID                 ID;\n    bool                    IsActive;\n    bool                    IsStarting;\n    bool                    IsStartedFromVoid;  // Starting click was not from an item.\n    bool                    IsStartedSetNavIdOnce;\n    bool                    RequestClear;\n    ImGuiKeyChord           KeyMods : 16;       // Latched key-mods for box-select logic.\n    ImVec2                  StartPosRel;        // Start position in window-contents relative space (to support scrolling)\n    ImVec2                  EndPosRel;          // End position in window-contents relative space\n    ImVec2                  ScrollAccum;        // Scrolling accumulator (to behave at high-frame spaces)\n    ImGuiWindow*            Window;\n\n    // Temporary/Transient data\n    bool                    UnclipMode;         // (Temp/Transient, here in hot area). Set/cleared by the BeginMultiSelect()/EndMultiSelect() owning active box-select.\n    ImRect                  UnclipRect;         // Rectangle where ItemAdd() clipping may be temporarily disabled. Need support by multi-select supporting widgets.\n    ImRect                  BoxSelectRectPrev;  // Selection rectangle in absolute coordinates (derived every frame from BoxSelectStartPosRel and MousePos)\n    ImRect                  BoxSelectRectCurr;\n\n    ImGuiBoxSelectState()   { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Multi-select support\n//-----------------------------------------------------------------------------\n\n// We always assume that -1 is an invalid value (which works for indices and pointers)\n#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)\n\n// Temporary storage for multi-select\nstruct IMGUI_API ImGuiMultiSelectTempData\n{\n    ImGuiMultiSelectIO      IO;                 // MUST BE FIRST FIELD. Requests are set and returned by BeginMultiSelect()/EndMultiSelect() + written to by user during the loop.\n    ImGuiMultiSelectState*  Storage;\n    ImGuiID                 FocusScopeId;       // Copied from g.CurrentFocusScopeId (unless another selection scope was pushed manually)\n    ImGuiMultiSelectFlags   Flags;\n    ImVec2                  ScopeRectMin;\n    ImVec2                  BackupCursorMaxPos;\n    ImGuiSelectionUserData  LastSubmittedItem;  // Copy of last submitted item data, used to merge output ranges.\n    ImGuiID                 BoxSelectId;\n    ImGuiKeyChord           KeyMods;\n    ImS8                    LoopRequestSetAll;  // -1: no operation, 0: clear all, 1: select all.\n    bool                    IsEndIO;            // Set when switching IO from BeginMultiSelect() to EndMultiSelect() state.\n    bool                    IsFocused;          // Set if currently focusing the selection scope (any item of the selection). May be used if you have custom shortcut associated to selection.\n    bool                    IsKeyboardSetRange; // Set by BeginMultiSelect() when using Shift+Navigation. Because scrolling may be affected we can't afford a frame of lag with Shift+Navigation.\n    bool                    NavIdPassedBy;\n    bool                    RangeSrcPassedBy;   // Set by the item that matches RangeSrcItem.\n    bool                    RangeDstPassedBy;   // Set by the item that matches NavJustMovedToId when IsSetRange is set.\n\n    ImGuiMultiSelectTempData()  { Clear(); }\n    void Clear()            { size_t io_sz = sizeof(IO); ClearIO(); memset((void*)(&IO + 1), 0, sizeof(*this) - io_sz); } // Zero-clear except IO as we preserve IO.Requests[] buffer allocation.\n    void ClearIO()          { IO.Requests.resize(0); IO.RangeSrcItem = IO.NavIdItem = ImGuiSelectionUserData_Invalid; IO.NavIdSelected = IO.RangeSrcReset = false; }\n};\n\n// Persistent storage for multi-select (as long as selection is alive)\nstruct IMGUI_API ImGuiMultiSelectState\n{\n    ImGuiWindow*            Window;\n    ImGuiID                 ID;\n    int                     LastFrameActive;    // Last used frame-count, for GC.\n    int                     LastSelectionSize;  // Set by BeginMultiSelect() based on optional info provided by user. May be -1 if unknown.\n    ImS8                    RangeSelected;      // -1 (don't have) or true/false\n    ImS8                    NavIdSelected;      // -1 (don't have) or true/false\n    ImGuiSelectionUserData  RangeSrcItem;       //\n    ImGuiSelectionUserData  NavIdItem;          // SetNextItemSelectionUserData() value for NavId (if part of submitted items)\n\n    ImGuiMultiSelectState() { Window = NULL; ID = 0; LastFrameActive = LastSelectionSize = 0; RangeSelected = NavIdSelected = -1; RangeSrcItem = NavIdItem = ImGuiSelectionUserData_Invalid; }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Docking support\n//-----------------------------------------------------------------------------\n\n#ifdef IMGUI_HAS_DOCK\n// <this is filled in 'docking' branch>\n#endif // #ifdef IMGUI_HAS_DOCK\n\n//-----------------------------------------------------------------------------\n// [SECTION] Viewport support\n//-----------------------------------------------------------------------------\n\n// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)\n// Every instance of ImGuiViewport is in fact a ImGuiViewportP.\nstruct ImGuiViewportP : public ImGuiViewport\n{\n    int                 BgFgDrawListsLastFrame[2]; // Last frame number the background (0) and foreground (1) draw lists were used\n    ImDrawList*         BgFgDrawLists[2];       // Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.\n    ImDrawData          DrawDataP;\n    ImDrawDataBuilder   DrawDataBuilder;        // Temporary data while building final ImDrawData\n\n    // Per-viewport work area\n    // - Insets are >= 0.0f values, distance from viewport corners to work area.\n    // - BeginMainMenuBar() and DockspaceOverViewport() tend to use work area to avoid stepping over existing contents.\n    // - Generally 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.\n    ImVec2              WorkInsetMin;           // Work Area inset locked for the frame. GetWorkRect() always fits within GetMainRect().\n    ImVec2              WorkInsetMax;           // \"\n    ImVec2              BuildWorkInsetMin;      // Work Area inset accumulator for current frame, to become next frame's WorkInset\n    ImVec2              BuildWorkInsetMax;      // \"\n\n    ImGuiViewportP()    { BgFgDrawListsLastFrame[0] = BgFgDrawListsLastFrame[1] = -1; BgFgDrawLists[0] = BgFgDrawLists[1] = NULL; }\n    ~ImGuiViewportP()   { if (BgFgDrawLists[0]) IM_DELETE(BgFgDrawLists[0]); if (BgFgDrawLists[1]) IM_DELETE(BgFgDrawLists[1]); }\n\n    // Calculate work rect pos/size given a set of offset (we have 1 pair of offset for rect locked from last frame data, and 1 pair for currently building rect)\n    ImVec2  CalcWorkRectPos(const ImVec2& inset_min) const                           { return ImVec2(Pos.x + inset_min.x, Pos.y + inset_min.y); }\n    ImVec2  CalcWorkRectSize(const ImVec2& inset_min, const ImVec2& inset_max) const { return ImVec2(ImMax(0.0f, Size.x - inset_min.x - inset_max.x), ImMax(0.0f, Size.y - inset_min.y - inset_max.y)); }\n    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkInsetMin); WorkSize = CalcWorkRectSize(WorkInsetMin, WorkInsetMax); } // Update public fields\n\n    // Helpers to retrieve ImRect (we don't need to store BuildWorkRect as every access tend to change it, hence the code asymmetry)\n    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }\n    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }\n    ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkInsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkInsetMin, BuildWorkInsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Settings support\n//-----------------------------------------------------------------------------\n\n// Windows data saved in imgui.ini file\n// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.\n// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)\nstruct ImGuiWindowSettings\n{\n    ImGuiID     ID;\n    ImVec2ih    Pos;\n    ImVec2ih    Size;\n    bool        Collapsed;\n    bool        IsChild;\n    bool        WantApply;      // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)\n    bool        WantDelete;     // Set to invalidate/delete the settings entry\n\n    ImGuiWindowSettings()       { memset(this, 0, sizeof(*this)); }\n    char* GetName()             { return (char*)(this + 1); }\n};\n\nstruct ImGuiSettingsHandler\n{\n    const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'\n    ImGuiID     TypeHash;       // == ImHashStr(TypeName)\n    void        (*ClearAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                // Clear all settings data\n    void        (*ReadInitFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                // Read: Called before reading (in registration order)\n    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. \"[Window][Name]\"\n    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry\n    void        (*ApplyAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                // Read: Called after reading (in registration order)\n    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'\n    void*       UserData;\n\n    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Localization support\n//-----------------------------------------------------------------------------\n\n// This is experimental and not officially supported, it'll probably fall short of features, if/when it does we may backtrack.\nenum ImGuiLocKey : int\n{\n    ImGuiLocKey_VersionStr,\n    ImGuiLocKey_TableSizeOne,\n    ImGuiLocKey_TableSizeAllFit,\n    ImGuiLocKey_TableSizeAllDefault,\n    ImGuiLocKey_TableResetOrder,\n    ImGuiLocKey_WindowingMainMenuBar,\n    ImGuiLocKey_WindowingPopup,\n    ImGuiLocKey_WindowingUntitled,\n    ImGuiLocKey_OpenLink_s,\n    ImGuiLocKey_CopyLink,\n    ImGuiLocKey_COUNT\n};\n\nstruct ImGuiLocEntry\n{\n    ImGuiLocKey     Key;\n    const char*     Text;\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Error handling, State recovery support\n//-----------------------------------------------------------------------------\n\n// Macros used by Recoverable Error handling\n// - Only dispatch error if _EXPR: evaluate as assert (similar to an assert macro).\n// - The message will always be a string literal, in order to increase likelihood of being display by an assert handler.\n// - See 'Demo->Configuration->Error Handling' and ImGuiIO definitions for details on error handling.\n// - Read https://github.com/ocornut/imgui/wiki/Error-Handling for details on error handling.\n#ifndef IM_ASSERT_USER_ERROR\n#define IM_ASSERT_USER_ERROR(_EXPR,_MSG)    do { if (!(_EXPR) && ImGui::ErrorLog(_MSG)) { IM_ASSERT((_EXPR) && _MSG); } } while (0)    // Recoverable User Error\n#endif\n\n// The error callback is currently not public, as it is expected that only advanced users will rely on it.\ntypedef void (*ImGuiErrorCallback)(ImGuiContext* ctx, void* user_data, const char* msg); // Function signature for g.ErrorCallback\n\n//-----------------------------------------------------------------------------\n// [SECTION] Metrics, Debug Tools\n//-----------------------------------------------------------------------------\n\n// See IMGUI_DEBUG_LOG() and IMGUI_DEBUG_LOG_XXX() macros.\nenum ImGuiDebugLogFlags_\n{\n    // Event types\n    ImGuiDebugLogFlags_None                 = 0,\n    ImGuiDebugLogFlags_EventError           = 1 << 0,   // Error submitted by IM_ASSERT_USER_ERROR()\n    ImGuiDebugLogFlags_EventActiveId        = 1 << 1,\n    ImGuiDebugLogFlags_EventFocus           = 1 << 2,\n    ImGuiDebugLogFlags_EventPopup           = 1 << 3,\n    ImGuiDebugLogFlags_EventNav             = 1 << 4,\n    ImGuiDebugLogFlags_EventClipper         = 1 << 5,\n    ImGuiDebugLogFlags_EventSelection       = 1 << 6,\n    ImGuiDebugLogFlags_EventIO              = 1 << 7,\n    ImGuiDebugLogFlags_EventFont            = 1 << 8,\n    ImGuiDebugLogFlags_EventInputRouting    = 1 << 9,\n    ImGuiDebugLogFlags_EventDocking         = 1 << 10,  // Unused in this branch\n    ImGuiDebugLogFlags_EventViewport        = 1 << 11,  // Unused in this branch\n\n    ImGuiDebugLogFlags_EventMask_           = ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_EventActiveId | ImGuiDebugLogFlags_EventFocus | ImGuiDebugLogFlags_EventPopup | ImGuiDebugLogFlags_EventNav | ImGuiDebugLogFlags_EventClipper | ImGuiDebugLogFlags_EventSelection | ImGuiDebugLogFlags_EventIO | ImGuiDebugLogFlags_EventFont | ImGuiDebugLogFlags_EventInputRouting | ImGuiDebugLogFlags_EventDocking | ImGuiDebugLogFlags_EventViewport,\n    ImGuiDebugLogFlags_OutputToTTY          = 1 << 20,  // Also send output to TTY\n    ImGuiDebugLogFlags_OutputToTestEngine   = 1 << 21,  // Also send output to Test Engine\n};\n\nstruct ImGuiDebugAllocEntry\n{\n    int         FrameCount;\n    ImS16       AllocCount;\n    ImS16       FreeCount;\n};\n\nstruct ImGuiDebugAllocInfo\n{\n    int         TotalAllocCount;            // Number of call to MemAlloc().\n    int         TotalFreeCount;\n    ImS16       LastEntriesIdx;             // Current index in buffer\n    ImGuiDebugAllocEntry LastEntriesBuf[6]; // Track last 6 frames that had allocations\n\n    ImGuiDebugAllocInfo() { memset(this, 0, sizeof(*this)); }\n};\n\nstruct ImGuiMetricsConfig\n{\n    bool        ShowDebugLog = false;\n    bool        ShowIDStackTool = false;\n    bool        ShowWindowsRects = false;\n    bool        ShowWindowsBeginOrder = false;\n    bool        ShowTablesRects = false;\n    bool        ShowDrawCmdMesh = true;\n    bool        ShowDrawCmdBoundingBoxes = true;\n    bool        ShowTextEncodingViewer = false;\n    bool        ShowAtlasTintedWithTextColor = false;\n    int         ShowWindowsRectsType = -1;\n    int         ShowTablesRectsType = -1;\n    int         HighlightMonitorIdx = -1;\n    ImGuiID     HighlightViewportID = 0;\n};\n\nstruct ImGuiStackLevelInfo\n{\n    ImGuiID                 ID;\n    ImS8                    QueryFrameCount;            // >= 1: Query in progress\n    bool                    QuerySuccess;               // Obtained result from DebugHookIdInfo()\n    ImGuiDataType           DataType : 8;\n    char                    Desc[57];                   // Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.\n\n    ImGuiStackLevelInfo()   { memset(this, 0, sizeof(*this)); }\n};\n\n// State for ID Stack tool queries\nstruct ImGuiIDStackTool\n{\n    int                     LastActiveFrame;\n    int                     StackLevel;                 // -1: query stack and resize Results, >= 0: individual stack level\n    ImGuiID                 QueryId;                    // ID to query details for\n    ImVector<ImGuiStackLevelInfo> Results;\n    bool                    CopyToClipboardOnCtrlC;\n    float                   CopyToClipboardLastTime;\n\n    ImGuiIDStackTool()      { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -FLT_MAX; }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Generic context hooks\n//-----------------------------------------------------------------------------\n\ntypedef void (*ImGuiContextHookCallback)(ImGuiContext* ctx, ImGuiContextHook* hook);\nenum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };\n\nstruct ImGuiContextHook\n{\n    ImGuiID                     HookId;     // A unique ID assigned by AddContextHook()\n    ImGuiContextHookType        Type;\n    ImGuiID                     Owner;\n    ImGuiContextHookCallback    Callback;\n    void*                       UserData;\n\n    ImGuiContextHook()          { memset(this, 0, sizeof(*this)); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiContext (main Dear ImGui context)\n//-----------------------------------------------------------------------------\n\nstruct ImGuiContext\n{\n    bool                    Initialized;\n    bool                    FontAtlasOwnedByContext;            // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.\n    ImGuiIO                 IO;\n    ImGuiPlatformIO         PlatformIO;\n    ImGuiStyle              Style;\n    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()\n    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.\n    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.\n    float                   FontScale;                          // == FontSize / Font->FontSize\n    float                   CurrentDpiScale;                    // Current window/viewport DpiScale\n    ImDrawListSharedData    DrawListSharedData;\n    double                  Time;\n    int                     FrameCount;\n    int                     FrameCountEnded;\n    int                     FrameCountRendered;\n    ImGuiID                 WithinEndChildID;                   // Set within EndChild()\n    bool                    WithinFrameScope;                   // Set by NewFrame(), cleared by EndFrame()\n    bool                    WithinFrameScopeWithImplicitWindow; // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed\n    bool                    GcCompactAll;                       // Request full GC\n    bool                    TestEngineHookItems;                // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()\n    void*                   TestEngine;                         // Test engine user data\n    char                    ContextName[16];                    // Storage for a context name (to facilitate debugging multi-context setups)\n\n    // Inputs\n    ImVector<ImGuiInputEvent> InputEventsQueue;                 // Input events which will be trickled/written into IO structure.\n    ImVector<ImGuiInputEvent> InputEventsTrail;                 // Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.\n    ImGuiMouseSource        InputEventsNextMouseSource;\n    ImU32                   InputEventsNextEventId;\n\n    // Windows state\n    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front\n    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Root windows, sorted in focus order, back to front.\n    ImVector<ImGuiWindow*>  WindowsTempSortBuffer;              // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child\n    ImVector<ImGuiWindowStackData> CurrentWindowStack;\n    ImGuiStorage            WindowsById;                        // Map window's ImGuiID to ImGuiWindow*\n    int                     WindowsActiveCount;                 // Number of unique windows submitted by frame\n    ImVec2                  WindowsHoverPadding;                // Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING).\n    ImGuiID                 DebugBreakInWindow;                 // Set to break in Begin() call.\n    ImGuiWindow*            CurrentWindow;                      // Window being drawn into\n    ImGuiWindow*            HoveredWindow;                      // Window the mouse is hovering. Will typically catch mouse inputs.\n    ImGuiWindow*            HoveredWindowUnderMovingWindow;     // Hovered window ignoring MovingWindow. Only set if MovingWindow is set.\n    ImGuiWindow*            HoveredWindowBeforeClear;           // Window the mouse is hovering. Filled even with _NoMouse. This is currently useful for multi-context compositors.\n    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindow.\n    ImGuiWindow*            WheelingWindow;                     // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.\n    ImVec2                  WheelingWindowRefMousePos;\n    int                     WheelingWindowStartFrame;           // This may be set one frame before WheelingWindow is != NULL\n    int                     WheelingWindowScrolledFrame;\n    float                   WheelingWindowReleaseTimer;\n    ImVec2                  WheelingWindowWheelRemainder;\n    ImVec2                  WheelingAxisAvg;\n\n    // Item/widgets state and tracking information\n    ImGuiID                 DebugDrawIdConflicts;               // Set when we detect multiple items with the same identifier\n    ImGuiID                 DebugHookIdInfo;                    // Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]\n    ImGuiID                 HoveredId;                          // Hovered widget, filled during the frame\n    ImGuiID                 HoveredIdPreviousFrame;\n    int                     HoveredIdPreviousFrameItemCount;    // Count numbers of items using the same ID as last frame's hovered id\n    float                   HoveredIdTimer;                     // Measure contiguous hovering time\n    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active\n    bool                    HoveredIdAllowOverlap;\n    bool                    HoveredIdIsDisabled;                // At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.\n    bool                    ItemUnclipByLog;                    // Disable ItemAdd() clipping, essentially a memory-locality friendly copy of LogEnabled\n    ImGuiID                 ActiveId;                           // Active widget\n    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)\n    float                   ActiveIdTimer;\n    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame\n    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)\n    bool                    ActiveIdNoClearOnFocusLoss;         // Disable losing active id if the active id window gets unfocused.\n    bool                    ActiveIdHasBeenPressedBefore;       // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.\n    bool                    ActiveIdHasBeenEditedBefore;        // Was the value associated to the widget Edited over the course of the Active state.\n    bool                    ActiveIdHasBeenEditedThisFrame;\n    bool                    ActiveIdFromShortcut;\n    int                     ActiveIdMouseButton : 8;\n    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)\n    ImGuiWindow*            ActiveIdWindow;\n    ImGuiInputSource        ActiveIdSource;                     // Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad\n    ImGuiID                 ActiveIdPreviousFrame;\n    bool                    ActiveIdPreviousFrameIsAlive;\n    bool                    ActiveIdPreviousFrameHasBeenEditedBefore;\n    ImGuiWindow*            ActiveIdPreviousFrameWindow;\n    ImGuiDataTypeStorage    ActiveIdValueOnActivation;          // Backup of initial value at the time of activation. ONLY SET BY SPECIFIC WIDGETS: DragXXX and SliderXXX.\n    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.\n    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.\n\n    // Key/Input Ownership + Shortcut Routing system\n    // - The idea is that instead of \"eating\" a given key, we can link to an owner.\n    // - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.\n    // - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().\n    double                  LastKeyModsChangeTime;              // Record the last time key mods changed (affect repeat delay when using shortcut logic)\n    double                  LastKeyModsChangeFromNoneTime;      // Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)\n    double                  LastKeyboardKeyPressTime;           // Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.\n    ImBitArrayForNamedKeys  KeysMayBeCharInput;                 // Lookup to tell if a key can emit char input, see IsKeyChordPotentiallyCharInput(). sizeof() = 20 bytes\n    ImGuiKeyOwnerData       KeysOwnerData[ImGuiKey_NamedKey_COUNT];\n    ImGuiKeyRoutingTable    KeysRoutingTable;\n    ImU32                   ActiveIdUsingNavDirMask;            // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)\n    bool                    ActiveIdUsingAllKeyboardKeys;       // Active widget will want to read all keyboard keys inputs. (this is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations)\n    ImGuiKeyChord           DebugBreakInShortcutRouting;        // Set to break in SetShortcutRouting()/Shortcut() calls.\n    //ImU32                 ActiveIdUsingNavInputMask;          // [OBSOLETE] Since (IMGUI_VERSION_NUM >= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel);' becomes --> 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) and/or SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'\n\n    // Next window/item data\n    ImGuiID                 CurrentFocusScopeId;                // Value for currently appending items == g.FocusScopeStack.back(). Not to be mistaken with g.NavFocusScopeId.\n    ImGuiItemFlags          CurrentItemFlags;                   // Value for currently appending items == g.ItemFlagsStack.back()\n    ImGuiID                 DebugLocateId;                      // Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location\n    ImGuiNextItemData       NextItemData;                       // Storage for SetNextItem** functions\n    ImGuiLastItemData       LastItemData;                       // Storage for last submitted item (setup by ItemAdd)\n    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions\n    bool                    DebugShowGroupRects;\n\n    // Shared stacks\n    ImGuiCol                        DebugFlashStyleColorIdx;    // (Keep close to ColorStack to share cache line)\n    ImVector<ImGuiColorMod>         ColorStack;                 // Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()\n    ImVector<ImGuiStyleMod>         StyleVarStack;              // Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()\n    ImVector<ImFont*>               FontStack;                  // Stack for PushFont()/PopFont() - inherited by Begin()\n    ImVector<ImGuiFocusScopeData>   FocusScopeStack;            // Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()\n    ImVector<ImGuiItemFlags>        ItemFlagsStack;             // Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()\n    ImVector<ImGuiGroupData>        GroupStack;                 // Stack for BeginGroup()/EndGroup() - not inherited by Begin()\n    ImVector<ImGuiPopupData>        OpenPopupStack;             // Which popups are open (persistent)\n    ImVector<ImGuiPopupData>        BeginPopupStack;            // Which level of BeginPopup() we are in (reset every frame)\n    ImVector<ImGuiTreeNodeStackData>TreeNodeStack;              // Stack for TreeNode()\n\n    // Viewports\n    ImVector<ImGuiViewportP*> Viewports;                        // Active viewports (Size==1 in 'master' branch). Each viewports hold their copy of ImDrawData.\n\n    // Keyboard/Gamepad Navigation\n    bool                    NavCursorVisible;                   // Nav focus cursor/rectangle is visible? We hide it after a mouse click. We show it after a nav move.\n    bool                    NavHighlightItemUnderNav;           // Disable mouse hovering highlight. Highlight navigation focused item instead of mouse hovered item.\n    //bool                  NavDisableHighlight;                // Old name for !g.NavCursorVisible before 1.91.4 (2024/10/18). OPPOSITE VALUE (g.NavDisableHighlight == !g.NavCursorVisible)\n    //bool                  NavDisableMouseHover;               // Old name for g.NavHighlightItemUnderNav before 1.91.1 (2024/10/18) this was called When user starts using keyboard/gamepad, we hide mouse hovering highlight until mouse is touched again.\n    bool                    NavMousePosDirty;                   // When set we will update mouse position if io.ConfigNavMoveSetMousePos is set (not enabled by default)\n    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRectRel is valid\n    ImGuiID                 NavId;                              // Focused item for navigation\n    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusedWindow'\n    ImGuiID                 NavFocusScopeId;                    // Focused focus scope (e.g. selection code often wants to \"clear other items\" when landing on an item of the same scope)\n    ImGuiNavLayer           NavLayer;                           // Focused layer (main scrolling layer, or menu/title bar layer)\n    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()\n    ImGuiID                 NavActivateDownId;                  // ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0\n    ImGuiID                 NavActivatePressedId;               // ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)\n    ImGuiActivateFlags      NavActivateFlags;\n    ImVector<ImGuiFocusScopeData> NavFocusRoute;                // Reversed copy focus scope stack for NavId (should contains NavFocusScopeId). This essentially follow the window->ParentWindowForFocusRoute chain.\n    ImGuiID                 NavHighlightActivatedId;\n    float                   NavHighlightActivatedTimer;\n    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.\n    ImGuiActivateFlags      NavNextActivateFlags;\n    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse\n    ImGuiSelectionUserData  NavLastValidSelectionUserData;      // Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.\n    ImS8                    NavCursorHideFrames;\n\n    // Navigation: Init & Move Requests\n    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()\n    bool                    NavInitRequest;                     // Init request for appearing window to select first item\n    bool                    NavInitRequestFromMove;\n    ImGuiNavItemData        NavInitResult;                      // Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)\n    bool                    NavMoveSubmitted;                   // Move request submitted, will process result on next NewFrame()\n    bool                    NavMoveScoringItems;                // Move request submitted, still scoring incoming items\n    bool                    NavMoveForwardToNextFrame;\n    ImGuiNavMoveFlags       NavMoveFlags;\n    ImGuiScrollFlags        NavMoveScrollFlags;\n    ImGuiKeyChord           NavMoveKeyMods;\n    ImGuiDir                NavMoveDir;                         // Direction of the move request (left/right/up/down)\n    ImGuiDir                NavMoveDirForDebug;\n    ImGuiDir                NavMoveClipDir;                     // FIXME-NAV: Describe the purpose of this better. Might want to rename?\n    ImRect                  NavScoringRect;                     // Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.\n    ImRect                  NavScoringNoClipRect;               // Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted\n    int                     NavScoringDebugCount;               // Metrics for debugging\n    int                     NavTabbingDir;                      // Generally -1 or +1, 0 when tabbing without a nav id\n    int                     NavTabbingCounter;                  // >0 when counting items for tabbing\n    ImGuiNavItemData        NavMoveResultLocal;                 // Best move request candidate within NavWindow\n    ImGuiNavItemData        NavMoveResultLocalVisible;          // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)\n    ImGuiNavItemData        NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)\n    ImGuiNavItemData        NavTabbingResultFirst;              // First tabbing request candidate within NavWindow and flattened hierarchy\n\n    // Navigation: record of last move request\n    ImGuiID                 NavJustMovedFromFocusScopeId;       // Just navigated from this focus scope id (result of a successfully MoveRequest).\n    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).\n    ImGuiID                 NavJustMovedToFocusScopeId;         // Just navigated to this focus scope id (result of a successfully MoveRequest).\n    ImGuiKeyChord           NavJustMovedToKeyMods;\n    bool                    NavJustMovedToIsTabbing;            // Copy of ImGuiNavMoveFlags_IsTabbing. Maybe we should store whole flags.\n    bool                    NavJustMovedToHasSelectionData;     // Copy of move result's ItemFlags & ImGuiItemFlags_HasSelectionUserData). Maybe we should just store ImGuiNavItemData.\n\n    // Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)\n    ImGuiKeyChord           ConfigNavWindowingKeyNext;          // = ImGuiMod_Ctrl | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiKey_Tab on OS X). For reconfiguration (see #4828)\n    ImGuiKeyChord           ConfigNavWindowingKeyPrev;          // = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab on OS X)\n    ImGuiWindow*            NavWindowingTarget;                 // Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!\n    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.\n    ImGuiWindow*            NavWindowingListWindow;             // Internal window actually listing the CTRL+Tab contents\n    float                   NavWindowingTimer;\n    float                   NavWindowingHighlightAlpha;\n    bool                    NavWindowingToggleLayer;\n    ImGuiKey                NavWindowingToggleKey;\n    ImVec2                  NavWindowingAccumDeltaPos;\n    ImVec2                  NavWindowingAccumDeltaSize;\n\n    // Render\n    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)\n\n    // Drag and Drop\n    bool                    DragDropActive;\n    bool                    DragDropWithinSource;               // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.\n    bool                    DragDropWithinTarget;               // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.\n    ImGuiDragDropFlags      DragDropSourceFlags;\n    int                     DragDropSourceFrameCount;\n    int                     DragDropMouseButton;\n    ImGuiPayload            DragDropPayload;\n    ImRect                  DragDropTargetRect;                 // Store rectangle of current target candidate (we favor small targets when overlapping)\n    ImRect                  DragDropTargetClipRect;             // Store ClipRect at the time of item's drawing\n    ImGuiID                 DragDropTargetId;\n    ImGuiDragDropFlags      DragDropAcceptFlags;\n    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)\n    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)\n    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)\n    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source\n    ImGuiID                 DragDropHoldJustPressedId;          // Set when holding a payload just made ButtonBehavior() return a press.\n    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size\n    unsigned char           DragDropPayloadBufLocal[16];        // Local buffer for small payloads\n\n    // Clipper\n    int                             ClipperTempDataStacked;\n    ImVector<ImGuiListClipperData>  ClipperTempData;\n\n    // Tables\n    ImGuiTable*                     CurrentTable;\n    ImGuiID                         DebugBreakInTable;          // Set to break in BeginTable() call.\n    int                             TablesTempDataStacked;      // Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)\n    ImVector<ImGuiTableTempData>    TablesTempData;             // Temporary table data (buffers reused/shared across instances, support nesting)\n    ImPool<ImGuiTable>              Tables;                     // Persistent table data\n    ImVector<float>                 TablesLastTimeActive;       // Last used timestamp of each tables (SOA, for efficient GC)\n    ImVector<ImDrawChannel>         DrawChannelsTempMergeBuffer;\n\n    // Tab bars\n    ImGuiTabBar*                    CurrentTabBar;\n    ImPool<ImGuiTabBar>             TabBars;\n    ImVector<ImGuiPtrOrIndex>       CurrentTabBarStack;\n    ImVector<ImGuiShrinkWidthItem>  ShrinkWidthBuffer;\n\n    // Multi-Select state\n    ImGuiBoxSelectState             BoxSelectState;\n    ImGuiMultiSelectTempData*       CurrentMultiSelect;\n    int                             MultiSelectTempDataStacked; // Temporary multi-select data size (because we leave previous instances undestructed, we generally don't use MultiSelectTempData.Size)\n    ImVector<ImGuiMultiSelectTempData> MultiSelectTempData;\n    ImPool<ImGuiMultiSelectState>   MultiSelectStorage;\n\n    // Hover Delay system\n    ImGuiID                 HoverItemDelayId;\n    ImGuiID                 HoverItemDelayIdPreviousFrame;\n    float                   HoverItemDelayTimer;                // Currently used by IsItemHovered()\n    float                   HoverItemDelayClearTimer;           // Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.\n    ImGuiID                 HoverItemUnlockedStationaryId;      // Mouse has once been stationary on this item. Only reset after departing the item.\n    ImGuiID                 HoverWindowUnlockedStationaryId;    // Mouse has once been stationary on this window. Only reset after departing the window.\n\n    // Mouse state\n    ImGuiMouseCursor        MouseCursor;\n    float                   MouseStationaryTimer;               // Time the mouse has been stationary (with some loose heuristic)\n    ImVec2                  MouseLastValidPos;\n\n    // Widget state\n    ImGuiInputTextState     InputTextState;\n    ImGuiInputTextDeactivatedState InputTextDeactivatedState;\n    ImFont                  InputTextPasswordFont;\n    ImGuiID                 TempInputId;                        // Temporary text input when CTRL+clicking on a slider, etc.\n    ImGuiDataTypeStorage    DataTypeZeroValue;                  // 0 for all data types\n    int                     BeginMenuDepth;\n    int                     BeginComboDepth;\n    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets\n    ImGuiID                 ColorEditCurrentID;                 // Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).\n    ImGuiID                 ColorEditSavedID;                   // ID we are saving/restoring HS for\n    float                   ColorEditSavedHue;                  // Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips\n    float                   ColorEditSavedSat;                  // Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips\n    ImU32                   ColorEditSavedColor;                // RGB value with alpha set to 0.\n    ImVec4                  ColorPickerRef;                     // Initial/reference color at the time of opening the color picker.\n    ImGuiComboPreviewData   ComboPreviewData;\n    ImRect                  WindowResizeBorderExpectedRect;     // Expected border rect, switch to relative edit if moving\n    bool                    WindowResizeRelativeMode;\n    short                   ScrollbarSeekMode;                  // 0: scroll to clicked location, -1/+1: prev/next page.\n    float                   ScrollbarClickDeltaToGrabCenter;    // When scrolling to mouse location: distance between mouse and center of grab box, normalized in parent space.\n    float                   SliderGrabClickOffset;\n    float                   SliderCurrentAccum;                 // Accumulated slider delta when using navigation controls.\n    bool                    SliderCurrentAccumDirty;            // Has the accumulated slider delta changed since last time we tried to apply it?\n    bool                    DragCurrentAccumDirty;\n    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings\n    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio\n    float                   DisabledAlphaBackup;                // Backup for style.Alpha for BeginDisabled()\n    short                   DisabledStackSize;\n    short                   TooltipOverrideCount;\n    ImGuiWindow*            TooltipPreviousWindow;              // Window of last tooltip submitted during the frame\n    ImVector<char>          ClipboardHandlerData;               // If no custom clipboard handler is defined\n    ImVector<ImGuiID>       MenusIdSubmittedThisFrame;          // A list of menu IDs that were rendered at least once\n    ImGuiTypingSelectState  TypingSelectState;                  // State for GetTypingSelectRequest()\n\n    // Platform support\n    ImGuiPlatformImeData    PlatformImeData;                    // Data updated by current frame\n    ImGuiPlatformImeData    PlatformImeDataPrev;                // Previous frame data. When changed we call the platform_io.Platform_SetImeDataFn() handler.\n\n    // Settings\n    bool                    SettingsLoaded;\n    float                   SettingsDirtyTimer;                 // Save .ini Settings to memory when time reaches zero\n    ImGuiTextBuffer         SettingsIniData;                    // In memory .ini settings\n    ImVector<ImGuiSettingsHandler>      SettingsHandlers;       // List of .ini settings handlers\n    ImChunkStream<ImGuiWindowSettings>  SettingsWindows;        // ImGuiWindow .ini settings entries\n    ImChunkStream<ImGuiTableSettings>   SettingsTables;         // ImGuiTable .ini settings entries\n    ImVector<ImGuiContextHook>          Hooks;                  // Hooks for extensions (e.g. test engine)\n    ImGuiID                             HookIdNext;             // Next available HookId\n\n    // Localization\n    const char*             LocalizationTable[ImGuiLocKey_COUNT];\n\n    // Capture/Logging\n    bool                    LogEnabled;                         // Currently capturing\n    ImGuiLogFlags           LogFlags;                           // Capture flags/type\n    ImGuiWindow*            LogWindow;\n    ImFileHandle            LogFile;                            // If != NULL log to stdout/ file\n    ImGuiTextBuffer         LogBuffer;                          // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.\n    const char*             LogNextPrefix;\n    const char*             LogNextSuffix;\n    float                   LogLinePosY;\n    bool                    LogLineFirstItem;\n    int                     LogDepthRef;\n    int                     LogDepthToExpand;\n    int                     LogDepthToExpandDefault;            // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.\n\n    // Error Handling\n    ImGuiErrorCallback      ErrorCallback;                      // = NULL. May be exposed in public API eventually.\n    void*                   ErrorCallbackUserData;              // = NULL\n    ImVec2                  ErrorTooltipLockedPos;\n    bool                    ErrorFirst;\n    int                     ErrorCountCurrentFrame;             // [Internal] Number of errors submitted this frame.\n    ImGuiErrorRecoveryState StackSizesInNewFrame;               // [Internal]\n    ImGuiErrorRecoveryState*StackSizesInBeginForCurrentWindow;  // [Internal]\n\n    // Debug Tools\n    // (some of the highly frequently used data are interleaved in other structures above: DebugBreakXXX fields, DebugHookIdInfo, DebugLocateId etc.)\n    int                     DebugDrawIdConflictsCount;          // Locked count (preserved when holding CTRL)\n    ImGuiDebugLogFlags      DebugLogFlags;\n    ImGuiTextBuffer         DebugLogBuf;\n    ImGuiTextIndex          DebugLogIndex;\n    int                     DebugLogSkippedErrors;\n    ImGuiDebugLogFlags      DebugLogAutoDisableFlags;\n    ImU8                    DebugLogAutoDisableFrames;\n    ImU8                    DebugLocateFrames;                  // For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.\n    bool                    DebugBreakInLocateId;               // Debug break in ItemAdd() call for g.DebugLocateId.\n    ImGuiKeyChord           DebugBreakKeyChord;                 // = ImGuiKey_Pause\n    ImS8                    DebugBeginReturnValueCullDepth;     // Cycle between 0..9 then wrap around.\n    bool                    DebugItemPickerActive;              // Item picker is active (started with DebugStartItemPicker())\n    ImU8                    DebugItemPickerMouseButton;\n    ImGuiID                 DebugItemPickerBreakId;             // Will call IM_DEBUG_BREAK() when encountering this ID\n    float                   DebugFlashStyleColorTime;\n    ImVec4                  DebugFlashStyleColorBackup;\n    ImGuiMetricsConfig      DebugMetricsConfig;\n    ImGuiIDStackTool        DebugIDStackTool;\n    ImGuiDebugAllocInfo     DebugAllocInfo;\n\n    // Misc\n    float                   FramerateSecPerFrame[60];           // Calculate estimate of framerate for user over the last 60 frames..\n    int                     FramerateSecPerFrameIdx;\n    int                     FramerateSecPerFrameCount;\n    float                   FramerateSecPerFrameAccum;\n    int                     WantCaptureMouseNextFrame;          // Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.\n    int                     WantCaptureKeyboardNextFrame;       // \"\n    int                     WantTextInputNextFrame;\n    ImVector<char>          TempBuffer;                         // Temporary text buffer\n    char                    TempKeychordName[64];\n\n    ImGuiContext(ImFontAtlas* shared_font_atlas);\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGuiWindowTempData, ImGuiWindow\n//-----------------------------------------------------------------------------\n\n// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.\n// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)\n// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)\nstruct IMGUI_API ImGuiWindowTempData\n{\n    // Layout\n    ImVec2                  CursorPos;              // Current emitting position, in absolute coordinates.\n    ImVec2                  CursorPosPrevLine;\n    ImVec2                  CursorStartPos;         // Initial position after Begin(), generally ~ window position + WindowPadding.\n    ImVec2                  CursorMaxPos;           // Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.\n    ImVec2                  IdealMaxPos;            // Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.\n    ImVec2                  CurrLineSize;\n    ImVec2                  PrevLineSize;\n    float                   CurrLineTextBaseOffset; // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).\n    float                   PrevLineTextBaseOffset;\n    bool                    IsSameLine;\n    bool                    IsSetPos;\n    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)\n    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.\n    ImVec1                  GroupOffset;\n    ImVec2                  CursorStartPosLossyness;// Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.\n\n    // Keyboard/Gamepad navigation\n    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)\n    short                   NavLayersActiveMask;    // Which layers have been written to (result from previous frame)\n    short                   NavLayersActiveMaskNext;// Which layers have been written to (accumulator for current frame)\n    bool                    NavIsScrollPushableX;   // Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.\n    bool                    NavHideHighlightOneFrame;\n    bool                    NavWindowHasScrollY;    // Set per window when scrolling can be used (== ScrollMax.y > 0.0f)\n\n    // Miscellaneous\n    bool                    MenuBarAppending;       // FIXME: Remove this\n    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.\n    ImGuiMenuColumns        MenuColumns;            // Simplified columns storage for menu items measurement\n    int                     TreeDepth;              // Current tree depth.\n    ImU32                   TreeHasStackDataDepthMask; // Store whether given depth has ImGuiTreeNodeStackData data. Could be turned into a ImU64 if necessary.\n    ImVector<ImGuiWindow*>  ChildWindows;\n    ImGuiStorage*           StateStorage;           // Current persistent per-window storage (store e.g. tree node open/close state)\n    ImGuiOldColumns*        CurrentColumns;         // Current columns set\n    int                     CurrentTableIdx;        // Current table index (into g.Tables)\n    ImGuiLayoutType         LayoutType;\n    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()\n    ImU32                   ModalDimBgColor;\n\n    // Local parameters stacks\n    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.\n    float                   ItemWidth;              // Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).\n    float                   TextWrapPos;            // Current text wrap pos.\n    ImVector<float>         ItemWidthStack;         // Store item widths to restore (attention: .back() is not == ItemWidth)\n    ImVector<float>         TextWrapPosStack;       // Store text wrap pos to restore (attention: .back() is not == TextWrapPos)\n};\n\n// Storage for one window\nstruct IMGUI_API ImGuiWindow\n{\n    ImGuiContext*           Ctx;                                // Parent UI context (needs to be set explicitly by parent).\n    char*                   Name;                               // Window name, owned by the window.\n    ImGuiID                 ID;                                 // == ImHashStr(Name)\n    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_\n    ImGuiChildFlags         ChildFlags;                         // Set when window is a child window. See enum ImGuiChildFlags_\n    ImGuiViewportP*         Viewport;                           // Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.\n    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)\n    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)\n    ImVec2                  SizeFull;                           // Size when non collapsed\n    ImVec2                  ContentSize;                        // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.\n    ImVec2                  ContentSizeIdeal;\n    ImVec2                  ContentSizeExplicit;                // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().\n    ImVec2                  WindowPadding;                      // Window padding at the time of Begin().\n    float                   WindowRounding;                     // Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.\n    float                   WindowBorderSize;                   // Window border size at the time of Begin().\n    float                   TitleBarHeight, MenuBarHeight;      // Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.\n    float                   DecoOuterSizeX1, DecoOuterSizeY1;   // Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().\n    float                   DecoOuterSizeX2, DecoOuterSizeY2;   // Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).\n    float                   DecoInnerSizeX1, DecoInnerSizeY1;   // Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).\n    int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)!\n    ImGuiID                 MoveId;                             // == window->GetID(\"#MOVE\")\n    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)\n    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)\n    ImVec2                  Scroll;\n    ImVec2                  ScrollMax;\n    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)\n    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered\n    ImVec2                  ScrollTargetEdgeSnapDist;           // 0.0f = no snapping, >0.0f snapping threshold\n    ImVec2                  ScrollbarSizes;                     // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.\n    bool                    ScrollbarX, ScrollbarY;             // Are scrollbars visible?\n    bool                    Active;                             // Set to true on Begin(), unless Collapsed\n    bool                    WasActive;\n    bool                    WriteAccessed;                      // Set to true when any widget access the current window\n    bool                    Collapsed;                          // Set when collapsing window to become only title-bar\n    bool                    WantCollapseToggle;\n    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)\n    bool                    SkipRefresh;                        // [EXPERIMENTAL] Reuse previous frame drawn contents, Begin() returns false.\n    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)\n    bool                    Hidden;                             // Do not display (== HiddenFrames*** > 0)\n    bool                    IsFallbackWindow;                   // Set on the \"Debug##Default\" window.\n    bool                    IsExplicitChild;                    // Set when passed _ChildWindow, left to false by BeginDocked()\n    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)\n    signed char             ResizeBorderHovered;                // Current border being hovered for resize (-1: none, otherwise 0-3)\n    signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)\n    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)\n    short                   BeginCountPreviousFrame;            // Number of Begin() during the previous frame\n    short                   BeginOrderWithinParent;             // Begin() order within immediate parent window, if we are a child window. Otherwise 0.\n    short                   BeginOrderWithinContext;            // Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.\n    short                   FocusOrder;                         // Order within WindowsFocusOrder[], altered when windows are focused.\n    ImS8                    AutoFitFramesX, AutoFitFramesY;\n    bool                    AutoFitOnlyGrows;\n    ImGuiDir                AutoPosLastDirection;\n    ImS8                    HiddenFramesCanSkipItems;           // Hide the window for N frames\n    ImS8                    HiddenFramesCannotSkipItems;        // Hide the window for N frames while allowing items to be submitted so we can measure their size\n    ImS8                    HiddenFramesForRenderOnly;          // Hide the window until frame N at Render() time only\n    ImS8                    DisableInputsFrames;                // Disable window interactions for N frames\n    ImGuiCond               SetWindowPosAllowFlags : 8;         // store acceptable condition flags for SetNextWindowPos() use.\n    ImGuiCond               SetWindowSizeAllowFlags : 8;        // store acceptable condition flags for SetNextWindowSize() use.\n    ImGuiCond               SetWindowCollapsedAllowFlags : 8;   // store acceptable condition flags for SetNextWindowCollapsed() use.\n    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)\n    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.\n\n    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)\n    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the \"DC\" variable name.\n\n    // The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.\n    // The main 'OuterRect', omitted as a field, is window->Rect().\n    ImRect                  OuterRectClipped;                   // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.\n    ImRect                  InnerRect;                          // Inner rectangle (omit title bar, menu bar, scroll bar)\n    ImRect                  InnerClipRect;                      // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.\n    ImRect                  WorkRect;                           // Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).\n    ImRect                  ParentWorkRect;                     // Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?\n    ImRect                  ClipRect;                           // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().\n    ImRect                  ContentRegionRect;                  // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.\n    ImVec2ih                HitTestHoleSize;                    // Define an optional rectangular hole where mouse will pass-through the window.\n    ImVec2ih                HitTestHoleOffset;\n\n    int                     LastFrameActive;                    // Last frame number the window was Active.\n    float                   LastTimeActive;                     // Last timestamp the window was Active (using float as we don't need high precision there)\n    float                   ItemWidthDefault;\n    ImGuiStorage            StateStorage;\n    ImVector<ImGuiOldColumns> ColumnsStorage;\n    float                   FontWindowScale;                    // User scale multiplier per-window, via SetWindowFontScale()\n    int                     SettingsOffset;                     // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)\n\n    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)\n    ImDrawList              DrawListInst;\n    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.\n    ImGuiWindow*            ParentWindowInBeginStack;\n    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.\n    ImGuiWindow*            RootWindowPopupTree;                // Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.\n    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.\n    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.\n    ImGuiWindow*            ParentWindowForFocusRoute;          // Set to manual link a window to its logical parent so that Shortcut() chain are honoerd (e.g. Tool linked to Document)\n\n    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)\n    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)\n    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space\n    ImVec2                  NavPreferredScoringPosRel[ImGuiNavLayer_COUNT]; // Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.\n    ImGuiID                 NavRootFocusScopeId;                // Focus Scope ID at the time of Begin()\n\n    int                     MemoryDrawListIdxCapacity;          // Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy\n    int                     MemoryDrawListVtxCapacity;\n    bool                    MemoryCompacted;                    // Set when window extraneous data have been garbage collected\n\npublic:\n    ImGuiWindow(ImGuiContext* context, const char* name);\n    ~ImGuiWindow();\n\n    ImGuiID     GetID(const char* str, const char* str_end = NULL);\n    ImGuiID     GetID(const void* ptr);\n    ImGuiID     GetID(int n);\n    ImGuiID     GetIDFromPos(const ImVec2& p_abs);\n    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);\n\n    // We don't use g.FontSize because the window may be != g.CurrentWindow.\n    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }\n    float       CalcFontSize() const    { ImGuiContext& g = *Ctx; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }\n    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight)); }\n    ImRect      MenuBarRect() const     { float y1 = Pos.y + TitleBarHeight; return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Tab bar, Tab item support\n//-----------------------------------------------------------------------------\n\n// Extend ImGuiTabBarFlags_\nenum ImGuiTabBarFlagsPrivate_\n{\n    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]\n    ImGuiTabBarFlags_IsFocused                  = 1 << 21,\n    ImGuiTabBarFlags_SaveSettings               = 1 << 22,  // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs\n};\n\n// Extend ImGuiTabItemFlags_\nenum ImGuiTabItemFlagsPrivate_\n{\n    ImGuiTabItemFlags_SectionMask_              = ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing,\n    ImGuiTabItemFlags_NoCloseButton             = 1 << 20,  // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)\n    ImGuiTabItemFlags_Button                    = 1 << 21,  // Used by TabItemButton, change the tab item behavior to mimic a button\n};\n\n// Storage for one active tab item (sizeof() 40 bytes)\nstruct ImGuiTabItem\n{\n    ImGuiID             ID;\n    ImGuiTabItemFlags   Flags;\n    int                 LastFrameVisible;\n    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance\n    float               Offset;                 // Position relative to beginning of tab\n    float               Width;                  // Width currently displayed\n    float               ContentWidth;           // Width of label, stored during BeginTabItem() call\n    float               RequestedWidth;         // Width optionally requested by caller, -1.0f is unused\n    ImS32               NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames\n    ImS16               BeginOrder;             // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable\n    ImS16               IndexDuringLayout;      // Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.\n    bool                WantClose;              // Marked as closed by SetTabItemClosed()\n\n    ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }\n};\n\n// Storage for a tab bar (sizeof() 160 bytes)\nstruct IMGUI_API ImGuiTabBar\n{\n    ImGuiWindow*        Window;\n    ImVector<ImGuiTabItem> Tabs;\n    ImGuiTabBarFlags    Flags;\n    ImGuiID             ID;                     // Zero for tab-bars used by docking\n    ImGuiID             SelectedTabId;          // Selected tab/window\n    ImGuiID             NextSelectedTabId;      // Next selected tab/window. Will also trigger a scrolling animation\n    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)\n    int                 CurrFrameVisible;\n    int                 PrevFrameVisible;\n    ImRect              BarRect;\n    float               CurrTabsContentsHeight;\n    float               PrevTabsContentsHeight; // Record the height of contents submitted below the tab bar\n    float               WidthAllTabs;           // Actual width of all tabs (locked during layout)\n    float               WidthAllTabsIdeal;      // Ideal width if all tabs were visible and not clipped\n    float               ScrollingAnim;\n    float               ScrollingTarget;\n    float               ScrollingTargetDistToVisibility;\n    float               ScrollingSpeed;\n    float               ScrollingRectMinX;\n    float               ScrollingRectMaxX;\n    float               SeparatorMinX;\n    float               SeparatorMaxX;\n    ImGuiID             ReorderRequestTabId;\n    ImS16               ReorderRequestOffset;\n    ImS8                BeginCount;\n    bool                WantLayout;\n    bool                VisibleTabWasSubmitted;\n    bool                TabsAddedNew;           // Set to true when a new tab item or button has been added to the tab bar during last frame\n    ImS16               TabsActiveCount;        // Number of tabs submitted this frame.\n    ImS16               LastTabItemIdx;         // Index of last BeginTabItem() tab for use by EndTabItem()\n    float               ItemSpacingY;\n    ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()\n    ImVec2              BackupCursorPos;\n    ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer.\n\n    ImGuiTabBar();\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] Table support\n//-----------------------------------------------------------------------------\n\n#define IM_COL32_DISABLE                IM_COL32(0,0,0,1)   // Special sentinel code which cannot be used as a regular color.\n#define IMGUI_TABLE_MAX_COLUMNS         512                 // May be further lifted\n\n// Our current column maximum is 64 but we may raise that in the future.\ntypedef ImS16 ImGuiTableColumnIdx;\ntypedef ImU16 ImGuiTableDrawChannelIdx;\n\n// [Internal] sizeof() ~ 112\n// We use the terminology \"Enabled\" to refer to a column that is not Hidden by user/api.\n// We use the terminology \"Clipped\" to refer to a column that is out of sight because of scrolling/clipping.\n// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use \"Visible\" to mean \"not clipped\".\nstruct ImGuiTableColumn\n{\n    ImGuiTableColumnFlags   Flags;                          // Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_\n    float                   WidthGiven;                     // Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.\n    float                   MinX;                           // Absolute positions\n    float                   MaxX;\n    float                   WidthRequest;                   // Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()\n    float                   WidthAuto;                      // Automatic width\n    float                   WidthMax;                       // Maximum width (FIXME: overwritten by each instance)\n    float                   StretchWeight;                  // Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.\n    float                   InitStretchWeightOrWidth;       // Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).\n    ImRect                  ClipRect;                       // Clipping rectangle for the column\n    ImGuiID                 UserID;                         // Optional, value passed to TableSetupColumn()\n    float                   WorkMinX;                       // Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column\n    float                   WorkMaxX;                       // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)\n    float                   ItemWidth;                      // Current item width for the column, preserved across rows\n    float                   ContentMaxXFrozen;              // Contents maximum position for frozen rows (apart from headers), from which we can infer content width.\n    float                   ContentMaxXUnfrozen;\n    float                   ContentMaxXHeadersUsed;         // Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls\n    float                   ContentMaxXHeadersIdeal;\n    ImS16                   NameOffset;                     // Offset into parent ColumnsNames[]\n    ImGuiTableColumnIdx     DisplayOrder;                   // Index within Table's IndexToDisplayOrder[] (column may be reordered by users)\n    ImGuiTableColumnIdx     IndexWithinEnabledSet;          // Index within enabled/visible set (<= IndexToDisplayOrder)\n    ImGuiTableColumnIdx     PrevEnabledColumn;              // Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column\n    ImGuiTableColumnIdx     NextEnabledColumn;              // Index of next enabled/visible column within Columns[], -1 if last enabled/visible column\n    ImGuiTableColumnIdx     SortOrder;                      // Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort\n    ImGuiTableDrawChannelIdx DrawChannelCurrent;            // Index within DrawSplitter.Channels[]\n    ImGuiTableDrawChannelIdx DrawChannelFrozen;             // Draw channels for frozen rows (often headers)\n    ImGuiTableDrawChannelIdx DrawChannelUnfrozen;           // Draw channels for unfrozen rows\n    bool                    IsEnabled;                      // IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0\n    bool                    IsUserEnabled;                  // Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).\n    bool                    IsUserEnabledNextFrame;\n    bool                    IsVisibleX;                     // Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).\n    bool                    IsVisibleY;\n    bool                    IsRequestOutput;                // Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.\n    bool                    IsSkipItems;                    // Do we want item submissions to this column to be completely ignored (no layout will happen).\n    bool                    IsPreserveWidthAuto;\n    ImS8                    NavLayerCurrent;                // ImGuiNavLayer in 1 byte\n    ImU8                    AutoFitQueue;                   // Queue of 8 values for the next 8 frames to request auto-fit\n    ImU8                    CannotSkipItemsQueue;           // Queue of 8 values for the next 8 frames to disable Clipped/SkipItem\n    ImU8                    SortDirection : 2;              // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending\n    ImU8                    SortDirectionsAvailCount : 2;   // Number of available sort directions (0 to 3)\n    ImU8                    SortDirectionsAvailMask : 4;    // Mask of available sort directions (1-bit each)\n    ImU8                    SortDirectionsAvailList;        // Ordered list of available sort directions (2-bits each, total 8-bits)\n\n    ImGuiTableColumn()\n    {\n        memset(this, 0, sizeof(*this));\n        StretchWeight = WidthRequest = -1.0f;\n        NameOffset = -1;\n        DisplayOrder = IndexWithinEnabledSet = -1;\n        PrevEnabledColumn = NextEnabledColumn = -1;\n        SortOrder = -1;\n        SortDirection = ImGuiSortDirection_None;\n        DrawChannelCurrent = DrawChannelFrozen = DrawChannelUnfrozen = (ImU8)-1;\n    }\n};\n\n// Transient cell data stored per row.\n// sizeof() ~ 6 bytes\nstruct ImGuiTableCellData\n{\n    ImU32                       BgColor;    // Actual color\n    ImGuiTableColumnIdx         Column;     // Column number\n};\n\n// Parameters for TableAngledHeadersRowEx()\n// This may end up being refactored for more general purpose.\n// sizeof() ~ 12 bytes\nstruct ImGuiTableHeaderData\n{\n    ImGuiTableColumnIdx         Index;      // Column index\n    ImU32                       TextColor;\n    ImU32                       BgColor0;\n    ImU32                       BgColor1;\n};\n\n// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)\n// sizeof() ~ 24 bytes\nstruct ImGuiTableInstanceData\n{\n    ImGuiID                     TableInstanceID;\n    float                       LastOuterHeight;            // Outer height from last frame\n    float                       LastTopHeadersRowHeight;    // Height of first consecutive header rows from last frame (FIXME: this is used assuming consecutive headers are in same frozen set)\n    float                       LastFrozenHeight;           // Height of frozen section from last frame\n    int                         HoveredRowLast;             // Index of row which was hovered last frame.\n    int                         HoveredRowNext;             // Index of row hovered this frame, set after encountering it.\n\n    ImGuiTableInstanceData()    { TableInstanceID = 0; LastOuterHeight = LastTopHeadersRowHeight = LastFrozenHeight = 0.0f; HoveredRowLast = HoveredRowNext = -1; }\n};\n\n// sizeof() ~ 592 bytes + heap allocs described in TableBeginInitMemory()\nstruct IMGUI_API ImGuiTable\n{\n    ImGuiID                     ID;\n    ImGuiTableFlags             Flags;\n    void*                       RawData;                    // Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]\n    ImGuiTableTempData*         TempData;                   // Transient data while table is active. Point within g.CurrentTableStack[]\n    ImSpan<ImGuiTableColumn>    Columns;                    // Point within RawData[]\n    ImSpan<ImGuiTableColumnIdx> DisplayOrderToIndex;        // Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)\n    ImSpan<ImGuiTableCellData>  RowCellData;                // Point within RawData[]. Store cells background requests for current row.\n    ImBitArrayPtr               EnabledMaskByDisplayOrder;  // Column DisplayOrder -> IsEnabled map\n    ImBitArrayPtr               EnabledMaskByIndex;         // Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data\n    ImBitArrayPtr               VisibleMaskByIndex;         // Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)\n    ImGuiTableFlags             SettingsLoadedFlags;        // Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)\n    int                         SettingsOffset;             // Offset in g.SettingsTables\n    int                         LastFrameActive;\n    int                         ColumnsCount;               // Number of columns declared in BeginTable()\n    int                         CurrentRow;\n    int                         CurrentColumn;\n    ImS16                       InstanceCurrent;            // Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.\n    ImS16                       InstanceInteracted;         // Mark which instance (generally 0) of the same ID is being interacted with\n    float                       RowPosY1;\n    float                       RowPosY2;\n    float                       RowMinHeight;               // Height submitted to TableNextRow()\n    float                       RowCellPaddingY;            // Top and bottom padding. Reloaded during row change.\n    float                       RowTextBaseline;\n    float                       RowIndentOffsetX;\n    ImGuiTableRowFlags          RowFlags : 16;              // Current row flags, see ImGuiTableRowFlags_\n    ImGuiTableRowFlags          LastRowFlags : 16;\n    int                         RowBgColorCounter;          // Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.\n    ImU32                       RowBgColor[2];              // Background color override for current row.\n    ImU32                       BorderColorStrong;\n    ImU32                       BorderColorLight;\n    float                       BorderX1;\n    float                       BorderX2;\n    float                       HostIndentX;\n    float                       MinColumnWidth;\n    float                       OuterPaddingX;\n    float                       CellPaddingX;               // Padding from each borders. Locked in BeginTable()/Layout.\n    float                       CellSpacingX1;              // Spacing between non-bordered cells. Locked in BeginTable()/Layout.\n    float                       CellSpacingX2;\n    float                       InnerWidth;                 // User value passed to BeginTable(), see comments at the top of BeginTable() for details.\n    float                       ColumnsGivenWidth;          // Sum of current column width\n    float                       ColumnsAutoFitWidth;        // Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window\n    float                       ColumnsStretchSumWeights;   // Sum of weight of all enabled stretching columns\n    float                       ResizedColumnNextWidth;\n    float                       ResizeLockMinContentsX2;    // Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.\n    float                       RefScale;                   // Reference scale to be able to rescale columns on font/dpi changes.\n    float                       AngledHeadersHeight;        // Set by TableAngledHeadersRow(), used in TableUpdateLayout()\n    float                       AngledHeadersSlope;         // Set by TableAngledHeadersRow(), used in TableUpdateLayout()\n    ImRect                      OuterRect;                  // Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().\n    ImRect                      InnerRect;                  // InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is\n    ImRect                      WorkRect;\n    ImRect                      InnerClipRect;\n    ImRect                      BgClipRect;                 // We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries\n    ImRect                      Bg0ClipRectForDrawCmd;      // Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped\n    ImRect                      Bg2ClipRectForDrawCmd;      // Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.\n    ImRect                      HostClipRect;               // This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.\n    ImRect                      HostBackupInnerClipRect;    // Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()\n    ImGuiWindow*                OuterWindow;                // Parent window for the table\n    ImGuiWindow*                InnerWindow;                // Window holding the table data (== OuterWindow or a child window)\n    ImGuiTextBuffer             ColumnsNames;               // Contiguous buffer holding columns names\n    ImDrawListSplitter*         DrawSplitter;               // Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly\n    ImGuiTableInstanceData      InstanceDataFirst;\n    ImVector<ImGuiTableInstanceData>    InstanceDataExtra;  // FIXME-OPT: Using a small-vector pattern would be good.\n    ImGuiTableColumnSortSpecs   SortSpecsSingle;\n    ImVector<ImGuiTableColumnSortSpecs> SortSpecsMulti;     // FIXME-OPT: Using a small-vector pattern would be good.\n    ImGuiTableSortSpecs         SortSpecs;                  // Public facing sorts specs, this is what we return in TableGetSortSpecs()\n    ImGuiTableColumnIdx         SortSpecsCount;\n    ImGuiTableColumnIdx         ColumnsEnabledCount;        // Number of enabled columns (<= ColumnsCount)\n    ImGuiTableColumnIdx         ColumnsEnabledFixedCount;   // Number of enabled columns using fixed width (<= ColumnsCount)\n    ImGuiTableColumnIdx         DeclColumnsCount;           // Count calls to TableSetupColumn()\n    ImGuiTableColumnIdx         AngledHeadersCount;         // Count columns with angled headers\n    ImGuiTableColumnIdx         HoveredColumnBody;          // Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!\n    ImGuiTableColumnIdx         HoveredColumnBorder;        // Index of column whose right-border is being hovered (for resizing).\n    ImGuiTableColumnIdx         HighlightColumnHeader;      // Index of column which should be highlighted.\n    ImGuiTableColumnIdx         AutoFitSingleColumn;        // Index of single column requesting auto-fit.\n    ImGuiTableColumnIdx         ResizedColumn;              // Index of column being resized. Reset when InstanceCurrent==0.\n    ImGuiTableColumnIdx         LastResizedColumn;          // Index of column being resized from previous frame.\n    ImGuiTableColumnIdx         HeldHeaderColumn;           // Index of column header being held.\n    ImGuiTableColumnIdx         ReorderColumn;              // Index of column being reordered. (not cleared)\n    ImGuiTableColumnIdx         ReorderColumnDir;           // -1 or +1\n    ImGuiTableColumnIdx         LeftMostEnabledColumn;      // Index of left-most non-hidden column.\n    ImGuiTableColumnIdx         RightMostEnabledColumn;     // Index of right-most non-hidden column.\n    ImGuiTableColumnIdx         LeftMostStretchedColumn;    // Index of left-most stretched column.\n    ImGuiTableColumnIdx         RightMostStretchedColumn;   // Index of right-most stretched column.\n    ImGuiTableColumnIdx         ContextPopupColumn;         // Column right-clicked on, of -1 if opening context menu from a neutral/empty spot\n    ImGuiTableColumnIdx         FreezeRowsRequest;          // Requested frozen rows count\n    ImGuiTableColumnIdx         FreezeRowsCount;            // Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)\n    ImGuiTableColumnIdx         FreezeColumnsRequest;       // Requested frozen columns count\n    ImGuiTableColumnIdx         FreezeColumnsCount;         // Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)\n    ImGuiTableColumnIdx         RowCellDataCurrent;         // Index of current RowCellData[] entry in current row\n    ImGuiTableDrawChannelIdx    DummyDrawChannel;           // Redirect non-visible columns here.\n    ImGuiTableDrawChannelIdx    Bg2DrawChannelCurrent;      // For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]\n    ImGuiTableDrawChannelIdx    Bg2DrawChannelUnfrozen;\n    bool                        IsLayoutLocked;             // Set by TableUpdateLayout() which is called when beginning the first row.\n    bool                        IsInsideRow;                // Set when inside TableBeginRow()/TableEndRow().\n    bool                        IsInitializing;\n    bool                        IsSortSpecsDirty;\n    bool                        IsUsingHeaders;             // Set when the first row had the ImGuiTableRowFlags_Headers flag.\n    bool                        IsContextPopupOpen;         // Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).\n    bool                        DisableDefaultContextMenu;  // Disable default context menu contents. You may submit your own using TableBeginContextMenuPopup()/EndPopup()\n    bool                        IsSettingsRequestLoad;\n    bool                        IsSettingsDirty;            // Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.\n    bool                        IsDefaultDisplayOrder;      // Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)\n    bool                        IsResetAllRequest;\n    bool                        IsResetDisplayOrderRequest;\n    bool                        IsUnfrozenRows;             // Set when we got past the frozen row.\n    bool                        IsDefaultSizingPolicy;      // Set if user didn't explicitly set a sizing policy in BeginTable()\n    bool                        IsActiveIdAliveBeforeTable;\n    bool                        IsActiveIdInTable;\n    bool                        HasScrollbarYCurr;          // Whether ANY instance of this table had a vertical scrollbar during the current frame.\n    bool                        HasScrollbarYPrev;          // Whether ANY instance of this table had a vertical scrollbar during the previous.\n    bool                        MemoryCompacted;\n    bool                        HostSkipItems;              // Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis\n\n    ImGuiTable()                { memset(this, 0, sizeof(*this)); LastFrameActive = -1; }\n    ~ImGuiTable()               { IM_FREE(RawData); }\n};\n\n// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).\n// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.\n// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.\n// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs.\n// sizeof() ~ 136 bytes.\nstruct IMGUI_API ImGuiTableTempData\n{\n    int                         TableIndex;                 // Index in g.Tables.Buf[] pool\n    float                       LastTimeActive;             // Last timestamp this structure was used\n    float                       AngledHeadersExtraWidth;    // Used in EndTable()\n    ImVector<ImGuiTableHeaderData> AngledHeadersRequests;   // Used in TableAngledHeadersRow()\n\n    ImVec2                      UserOuterSize;              // outer_size.x passed to BeginTable()\n    ImDrawListSplitter          DrawSplitter;\n\n    ImRect                      HostBackupWorkRect;         // Backup of InnerWindow->WorkRect at the end of BeginTable()\n    ImRect                      HostBackupParentWorkRect;   // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()\n    ImVec2                      HostBackupPrevLineSize;     // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()\n    ImVec2                      HostBackupCurrLineSize;     // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()\n    ImVec2                      HostBackupCursorMaxPos;     // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()\n    ImVec1                      HostBackupColumnsOffset;    // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()\n    float                       HostBackupItemWidth;        // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()\n    int                         HostBackupItemWidthStackSize;//Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()\n\n    ImGuiTableTempData()        { memset(this, 0, sizeof(*this)); LastTimeActive = -1.0f; }\n};\n\n// sizeof() ~ 12\nstruct ImGuiTableColumnSettings\n{\n    float                   WidthOrWeight;\n    ImGuiID                 UserID;\n    ImGuiTableColumnIdx     Index;\n    ImGuiTableColumnIdx     DisplayOrder;\n    ImGuiTableColumnIdx     SortOrder;\n    ImU8                    SortDirection : 2;\n    ImU8                    IsEnabled : 1; // \"Visible\" in ini file\n    ImU8                    IsStretch : 1;\n\n    ImGuiTableColumnSettings()\n    {\n        WidthOrWeight = 0.0f;\n        UserID = 0;\n        Index = -1;\n        DisplayOrder = SortOrder = -1;\n        SortDirection = ImGuiSortDirection_None;\n        IsEnabled = 1;\n        IsStretch = 0;\n    }\n};\n\n// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)\nstruct ImGuiTableSettings\n{\n    ImGuiID                     ID;                     // Set to 0 to invalidate/delete the setting\n    ImGuiTableFlags             SaveFlags;              // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)\n    float                       RefScale;               // Reference scale to be able to rescale columns on font/dpi changes.\n    ImGuiTableColumnIdx         ColumnsCount;\n    ImGuiTableColumnIdx         ColumnsCountMax;        // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher\n    bool                        WantApply;              // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)\n\n    ImGuiTableSettings()        { memset(this, 0, sizeof(*this)); }\n    ImGuiTableColumnSettings*   GetColumnSettings()     { return (ImGuiTableColumnSettings*)(this + 1); }\n};\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImGui internal API\n// No guarantee of forward compatibility here!\n//-----------------------------------------------------------------------------\n\nnamespace ImGui\n{\n    // Windows\n    // We should always have a CurrentWindow in the stack (there is an implicit \"Debug\" window)\n    // If this ever crashes because g.CurrentWindow is NULL, it means that either:\n    // - ImGui::NewFrame() has never been called, which is illegal.\n    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.\n    IMGUI_API ImGuiIO&      GetIOEx(ImGuiContext* ctx);\n    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }\n    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }\n    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);\n    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);\n    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);\n    IMGUI_API void          UpdateWindowSkipRefresh(ImGuiWindow* window);\n    IMGUI_API ImVec2        CalcWindowNextAutoFitSize(ImGuiWindow* window);\n    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy);\n    IMGUI_API bool          IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent);\n    IMGUI_API bool          IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below);\n    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);\n    IMGUI_API void          SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond = 0);\n    IMGUI_API void          SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond = 0);\n    IMGUI_API void          SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond = 0);\n    IMGUI_API void          SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size);\n    IMGUI_API void          SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindow* window);\n    inline void             SetWindowParentWindowForFocusRoute(ImGuiWindow* window, ImGuiWindow* parent_window) { window->ParentWindowForFocusRoute = parent_window; }\n    inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }\n    inline ImRect           WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }\n    inline ImVec2           WindowPosAbsToRel(ImGuiWindow* window, const ImVec2& p)  { ImVec2 off = window->DC.CursorStartPos; return ImVec2(p.x - off.x, p.y - off.y); }\n    inline ImVec2           WindowPosRelToAbs(ImGuiWindow* window, const ImVec2& p)  { ImVec2 off = window->DC.CursorStartPos; return ImVec2(p.x + off.x, p.y + off.y); }\n\n    // Windows: Display Order and Focus Order\n    IMGUI_API void          FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags = 0);\n    IMGUI_API void          FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window, ImGuiViewport* filter_viewport, ImGuiFocusRequestFlags flags);\n    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);\n    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);\n    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);\n    IMGUI_API void          BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* above_window);\n    IMGUI_API int           FindWindowDisplayIndex(ImGuiWindow* window);\n    IMGUI_API ImGuiWindow*  FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* window);\n\n    // Windows: Idle, Refresh Policies [EXPERIMENTAL]\n    IMGUI_API void          SetNextWindowRefreshPolicy(ImGuiWindowRefreshFlags flags);\n\n    // Fonts, drawing\n    IMGUI_API void          SetCurrentFont(ImFont* font);\n    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }\n    inline ImDrawList*      GetForegroundDrawList(ImGuiWindow* window) { IM_UNUSED(window); return GetForegroundDrawList(); } // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.\n    IMGUI_API ImDrawList*   GetBackgroundDrawList(ImGuiViewport* viewport);                     // get background draw list for the given viewport. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.\n    IMGUI_API ImDrawList*   GetForegroundDrawList(ImGuiViewport* viewport);                     // get foreground draw list for the given viewport. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.\n    IMGUI_API void          AddDrawListToDrawDataEx(ImDrawData* draw_data, ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);\n\n    // Init\n    IMGUI_API void          Initialize();\n    IMGUI_API void          Shutdown();    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().\n\n    // NewFrame\n    IMGUI_API void          UpdateInputEvents(bool trickle_fast_inputs);\n    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();\n    IMGUI_API void          FindHoveredWindowEx(const ImVec2& pos, bool find_first_and_in_any_viewport, ImGuiWindow** out_hovered_window, ImGuiWindow** out_hovered_window_under_moving_window);\n    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);\n    IMGUI_API void          UpdateMouseMovingWindowNewFrame();\n    IMGUI_API void          UpdateMouseMovingWindowEndFrame();\n\n    // Generic context hooks\n    IMGUI_API ImGuiID       AddContextHook(ImGuiContext* context, const ImGuiContextHook* hook);\n    IMGUI_API void          RemoveContextHook(ImGuiContext* context, ImGuiID hook_to_remove);\n    IMGUI_API void          CallContextHooks(ImGuiContext* context, ImGuiContextHookType type);\n\n    // Viewports\n    IMGUI_API void          ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale);\n    IMGUI_API void          SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport);\n\n    // Settings\n    IMGUI_API void                  MarkIniSettingsDirty();\n    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);\n    IMGUI_API void                  ClearIniSettings();\n    IMGUI_API void                  AddSettingsHandler(const ImGuiSettingsHandler* handler);\n    IMGUI_API void                  RemoveSettingsHandler(const char* type_name);\n    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);\n\n    // Settings - Windows\n    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);\n    IMGUI_API ImGuiWindowSettings*  FindWindowSettingsByID(ImGuiID id);\n    IMGUI_API ImGuiWindowSettings*  FindWindowSettingsByWindow(ImGuiWindow* window);\n    IMGUI_API void                  ClearWindowSettings(const char* name);\n\n    // Localization\n    IMGUI_API void          LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count);\n    inline const char*      LocalizeGetMsg(ImGuiLocKey key) { ImGuiContext& g = *GImGui; const char* msg = g.LocalizationTable[key]; return msg ? msg : \"*Missing Text*\"; }\n\n    // Scrolling\n    IMGUI_API void          SetScrollX(ImGuiWindow* window, float scroll_x);\n    IMGUI_API void          SetScrollY(ImGuiWindow* window, float scroll_y);\n    IMGUI_API void          SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio);\n    IMGUI_API void          SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio);\n\n    // Early work-in-progress API (ScrollToItem() will become public)\n    IMGUI_API void          ScrollToItem(ImGuiScrollFlags flags = 0);\n    IMGUI_API void          ScrollToRect(ImGuiWindow* window, const ImRect& rect, ImGuiScrollFlags flags = 0);\n    IMGUI_API ImVec2        ScrollToRectEx(ImGuiWindow* window, const ImRect& rect, ImGuiScrollFlags flags = 0);\n//#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    inline void             ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect) { ScrollToRect(window, rect, ImGuiScrollFlags_KeepVisibleEdgeY); }\n//#endif\n\n    // Basic Accessors\n    inline ImGuiItemStatusFlags GetItemStatusFlags() { ImGuiContext& g = *GImGui; return g.LastItemData.StatusFlags; }\n    inline ImGuiItemFlags   GetItemFlags()  { ImGuiContext& g = *GImGui; return g.LastItemData.ItemFlags; }\n    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }\n    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }\n    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);\n    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);\n    IMGUI_API void          ClearActiveID();\n    IMGUI_API ImGuiID       GetHoveredID();\n    IMGUI_API void          SetHoveredID(ImGuiID id);\n    IMGUI_API void          KeepAliveID(ImGuiID id);\n    IMGUI_API void          MarkItemEdited(ImGuiID id);     // Mark data associated to given item as \"edited\", used by IsItemDeactivatedAfterEdit() function.\n    IMGUI_API void          PushOverrideID(ImGuiID id);     // Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)\n    IMGUI_API ImGuiID       GetIDWithSeed(const char* str_id_begin, const char* str_id_end, ImGuiID seed);\n    IMGUI_API ImGuiID       GetIDWithSeed(int n, ImGuiID seed);\n\n    // Basic Helpers for widget code\n    IMGUI_API void          ItemSize(const ImVec2& size, float text_baseline_y = -1.0f);\n    inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.\n    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL, ImGuiItemFlags extra_flags = 0);\n    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id, ImGuiItemFlags item_flags);\n    IMGUI_API bool          IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags = 0);\n    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id);\n    IMGUI_API void          SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags status_flags, const ImRect& item_rect);\n    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_w, float default_h);\n    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);\n    IMGUI_API void          PushMultiItemsWidths(int components, float width_full);\n    IMGUI_API void          ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess);\n\n    // Parameter stacks (shared)\n    IMGUI_API const ImGuiDataVarInfo* GetStyleVarInfo(ImGuiStyleVar idx);\n    IMGUI_API void          BeginDisabledOverrideReenable();\n    IMGUI_API void          EndDisabledOverrideReenable();\n\n    // Logging/Capture\n    IMGUI_API void          LogBegin(ImGuiLogFlags flags, int auto_open_depth);         // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.\n    IMGUI_API void          LogToBuffer(int auto_open_depth = -1);                      // Start logging/capturing to internal buffer\n    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);\n    IMGUI_API void          LogSetNextTextDecoration(const char* prefix, const char* suffix);\n\n    // Childs\n    IMGUI_API bool          BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags);\n\n    // Popups, Modals\n    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_window_flags);\n    IMGUI_API void          OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags_None);\n    IMGUI_API void          ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);\n    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);\n    IMGUI_API void          ClosePopupsExceptModals();\n    IMGUI_API bool          IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags);\n    IMGUI_API ImRect        GetPopupAllowedExtentRect(ImGuiWindow* window);\n    IMGUI_API ImGuiWindow*  GetTopMostPopupModal();\n    IMGUI_API ImGuiWindow*  GetTopMostAndVisiblePopupModal();\n    IMGUI_API ImGuiWindow*  FindBlockingModal(ImGuiWindow* window);\n    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);\n    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy);\n\n    // Tooltips\n    IMGUI_API bool          BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags);\n    IMGUI_API bool          BeginTooltipHidden();\n\n    // Menus\n    IMGUI_API bool          BeginViewportSideBar(const char* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags);\n    IMGUI_API bool          BeginMenuEx(const char* label, const char* icon, bool enabled = true);\n    IMGUI_API bool          MenuItemEx(const char* label, const char* icon, const char* shortcut = NULL, bool selected = false, bool enabled = true);\n\n    // Combos\n    IMGUI_API bool          BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags);\n    IMGUI_API bool          BeginComboPreview();\n    IMGUI_API void          EndComboPreview();\n\n    // Keyboard/Gamepad Navigation\n    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);\n    IMGUI_API void          NavInitRequestApplyResult();\n    IMGUI_API bool          NavMoveRequestButNoResultYet();\n    IMGUI_API void          NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);\n    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);\n    IMGUI_API void          NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result);\n    IMGUI_API void          NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemData* result, ImGuiTreeNodeStackData* tree_node_data);\n    IMGUI_API void          NavMoveRequestCancel();\n    IMGUI_API void          NavMoveRequestApplyResult();\n    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);\n    IMGUI_API void          NavHighlightActivated(ImGuiID id);\n    IMGUI_API void          NavClearPreferredPosForAxis(ImGuiAxis axis);\n    IMGUI_API void          SetNavCursorVisibleAfterMove();\n    IMGUI_API void          NavUpdateCurrentWindowIsScrollPushableX();\n    IMGUI_API void          SetNavWindow(ImGuiWindow* window);\n    IMGUI_API void          SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel);\n    IMGUI_API void          SetNavFocusScope(ImGuiID focus_scope_id);\n\n    // Focus/Activation\n    // This should be part of a larger set of API: FocusItem(offset = -1), FocusItemByID(id), ActivateItem(offset = -1), ActivateItemByID(id) etc. which are\n    // much harder to design and implement than expected. I have a couple of private branches on this matter but it's not simple. For now implementing the easy ones.\n    IMGUI_API void          FocusItem();                    // Focus last item (no selection/activation).\n    IMGUI_API void          ActivateItemByID(ImGuiID id);   // Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.\n\n    // Inputs\n    // FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.\n    inline bool             IsNamedKey(ImGuiKey key)                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }\n    inline bool             IsNamedKeyOrMod(ImGuiKey key)               { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super; }\n    inline bool             IsLegacyKey(ImGuiKey key)                   { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END; }\n    inline bool             IsKeyboardKey(ImGuiKey key)                 { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; }\n    inline bool             IsGamepadKey(ImGuiKey key)                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }\n    inline bool             IsMouseKey(ImGuiKey key)                    { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END; }\n    inline bool             IsAliasKey(ImGuiKey key)                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }\n    inline bool             IsLRModKey(ImGuiKey key)                    { return key >= ImGuiKey_LeftCtrl && key <= ImGuiKey_RightSuper; }\n    ImGuiKeyChord           FixupKeyChord(ImGuiKeyChord key_chord);\n    inline ImGuiKey         ConvertSingleModFlagToKey(ImGuiKey key)\n    {\n        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;\n        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;\n        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;\n        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;\n        return key;\n    }\n\n    IMGUI_API ImGuiKeyData* GetKeyData(ImGuiContext* ctx, ImGuiKey key);\n    inline ImGuiKeyData*    GetKeyData(ImGuiKey key)                                    { ImGuiContext& g = *GImGui; return GetKeyData(&g, key); }\n    IMGUI_API const char*   GetKeyChordName(ImGuiKeyChord key_chord);\n    inline ImGuiKey         MouseButtonToKey(ImGuiMouseButton button)                   { IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT); return (ImGuiKey)(ImGuiKey_MouseLeft + button); }\n    IMGUI_API bool          IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold = -1.0f);\n    IMGUI_API ImVec2        GetKeyMagnitude2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down);\n    IMGUI_API float         GetNavTweakPressedAmount(ImGuiAxis axis);\n    IMGUI_API int           CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);\n    IMGUI_API void          GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeat_delay, float* repeat_rate);\n    IMGUI_API void          TeleportMousePos(const ImVec2& pos);\n    IMGUI_API void          SetActiveIdUsingAllKeyboardKeys();\n    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }\n\n    // [EXPERIMENTAL] Low-Level: Key/Input Ownership\n    // - The idea is that instead of \"eating\" a given input, we can link to an owner id.\n    // - Ownership is most often claimed as a result of reacting to a press/down event (but occasionally may be claimed ahead).\n    // - Input queries can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.\n    // - Legacy input queries (without specifying an owner or _Any or _None) are equivalent to using ImGuiKeyOwner_Any (== 0).\n    // - Input ownership is automatically released on the frame after a key is released. Therefore:\n    //   - for ownership registration happening as a result of a down/press event, the SetKeyOwner() call may be done once (common case).\n    //   - for ownership registration happening ahead of a down/press event, the SetKeyOwner() call needs to be made every frame (happens if e.g. claiming ownership on hover).\n    // - SetItemKeyOwner() is a shortcut for common simple case. A custom widget will probably want to call SetKeyOwner() multiple times directly based on its interaction state.\n    // - This is marked experimental because not all widgets are fully honoring the Set/Test idioms. We will need to move forward step by step.\n    //   Please open a GitHub Issue to submit your usage scenario or if there's a use case you need solved.\n    IMGUI_API ImGuiID       GetKeyOwner(ImGuiKey key);\n    IMGUI_API void          SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);\n    IMGUI_API void          SetKeyOwnersForKeyChord(ImGuiKeyChord key, ImGuiID owner_id, ImGuiInputFlags flags = 0);\n    IMGUI_API void          SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags);       // Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.\n    IMGUI_API bool          TestKeyOwner(ImGuiKey key, ImGuiID owner_id);               // Test that key is either not owned, either owned by 'owner_id'\n    inline ImGuiKeyOwnerData* GetKeyOwnerData(ImGuiContext* ctx, ImGuiKey key)          { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(key); IM_ASSERT(IsNamedKey(key)); return &ctx->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }\n\n    // [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input Ownership\n    // - Important: legacy IsKeyPressed(ImGuiKey, bool repeat=true) _DEFAULTS_ to repeat, new IsKeyPressed() requires _EXPLICIT_ ImGuiInputFlags_Repeat flag.\n    // - Expected to be later promoted to public API, the prototypes are designed to replace existing ones (since owner_id can default to Any == 0)\n    // - Specifying a value for 'ImGuiID owner' will test that EITHER the key is NOT owned (UNLESS locked), EITHER the key is owned by 'owner'.\n    //   Legacy functions use ImGuiKeyOwner_Any meaning that they typically ignore ownership, unless a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.\n    // - Binding generators may want to ignore those for now, or suffix them with Ex() until we decide if this gets moved into public API.\n    IMGUI_API bool          IsKeyDown(ImGuiKey key, ImGuiID owner_id);\n    IMGUI_API bool          IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);    // Important: when transitioning from old to new IsKeyPressed(): old API has \"bool repeat = true\", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.\n    IMGUI_API bool          IsKeyReleased(ImGuiKey key, ImGuiID owner_id);\n    IMGUI_API bool          IsKeyChordPressed(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id = 0);\n    IMGUI_API bool          IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id);\n    IMGUI_API bool          IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);\n    IMGUI_API bool          IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id);\n    IMGUI_API bool          IsMouseDoubleClicked(ImGuiMouseButton button, ImGuiID owner_id);\n\n    // Shortcut Testing & Routing\n    // - Set Shortcut() and SetNextItemShortcut() in imgui.h\n    // - When a policy (except for ImGuiInputFlags_RouteAlways *) is set, Shortcut() will register itself with SetShortcutRouting(),\n    //   allowing the system to decide where to route the input among other route-aware calls.\n    //   (* using ImGuiInputFlags_RouteAlways is roughly equivalent to calling IsKeyChordPressed(key) and bypassing route registration and check)\n    // - When using one of the routing option:\n    //   - The default route is ImGuiInputFlags_RouteFocused (accept inputs if window is in focus stack. Deep-most focused window takes inputs. ActiveId takes inputs over deep-most focused window.)\n    //   - Routes are requested given a chord (key + modifiers) and a routing policy.\n    //   - Routes are resolved during NewFrame(): if keyboard modifiers are matching current ones: SetKeyOwner() is called + route is granted for the frame.\n    //   - Each route may be granted to a single owner. When multiple requests are made we have policies to select the winning route (e.g. deep most window).\n    //   - Multiple read sites may use the same owner id can all access the granted route.\n    //   - When owner_id is 0 we use the current Focus Scope ID as a owner ID in order to identify our location.\n    // - You can chain two unrelated windows in the focus stack using SetWindowParentWindowForFocusRoute()\n    //   e.g. if you have a tool window associated to a document, and you want document shortcuts to run when the tool is focused.\n    IMGUI_API bool          Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id);\n    IMGUI_API bool          SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id); // owner_id needs to be explicit and cannot be 0\n    IMGUI_API bool          TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id);\n    IMGUI_API ImGuiKeyRoutingData* GetShortcutRoutingData(ImGuiKeyChord key_chord);\n\n    // [EXPERIMENTAL] Focus Scope\n    // This is generally used to identify a unique input location (for e.g. a selection set)\n    // There is one per window (automatically set in Begin), but:\n    // - Selection patterns generally need to react (e.g. clear a selection) when landing on one item of the set.\n    //   So in order to identify a set multiple lists in same window may each need a focus scope.\n    //   If you imagine an hypothetical BeginSelectionGroup()/EndSelectionGroup() api, it would likely call PushFocusScope()/EndFocusScope()\n    // - Shortcut routing also use focus scope as a default location identifier if an owner is not provided.\n    // We don't use the ID Stack for this as it is common to want them separate.\n    IMGUI_API void          PushFocusScope(ImGuiID id);\n    IMGUI_API void          PopFocusScope();\n    inline ImGuiID          GetCurrentFocusScope() { ImGuiContext& g = *GImGui; return g.CurrentFocusScopeId; }   // Focus scope we are outputting into, set by PushFocusScope()\n\n    // Drag and Drop\n    IMGUI_API bool          IsDragDropActive();\n    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);\n    IMGUI_API void          ClearDragDrop();\n    IMGUI_API bool          IsDragDropPayloadBeingAccepted();\n    IMGUI_API void          RenderDragDropTargetRect(const ImRect& bb, const ImRect& item_clip_rect);\n\n    // Typing-Select API\n    // (provide Windows Explorer style \"select items by typing partial name\" + \"cycle through items by typing same letter\" feature)\n    // (this is currently not documented nor used by main library, but should work. See \"widgets_typingselect\" in imgui_test_suite for usage code. Please let us know if you use this!)\n    IMGUI_API ImGuiTypingSelectRequest* GetTypingSelectRequest(ImGuiTypingSelectFlags flags = ImGuiTypingSelectFlags_None);\n    IMGUI_API int           TypingSelectFindMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data, int nav_item_idx);\n    IMGUI_API int           TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data, int nav_item_idx);\n    IMGUI_API int           TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data);\n\n    // Box-Select API\n    IMGUI_API bool          BeginBoxSelect(const ImRect& scope_rect, ImGuiWindow* window, ImGuiID box_select_id, ImGuiMultiSelectFlags ms_flags);\n    IMGUI_API void          EndBoxSelect(const ImRect& scope_rect, ImGuiMultiSelectFlags ms_flags);\n\n    // Multi-Select API\n    IMGUI_API void          MultiSelectItemHeader(ImGuiID id, bool* p_selected, ImGuiButtonFlags* p_button_flags);\n    IMGUI_API void          MultiSelectItemFooter(ImGuiID id, bool* p_selected, bool* p_pressed);\n    IMGUI_API void          MultiSelectAddSetAll(ImGuiMultiSelectTempData* ms, bool selected);\n    IMGUI_API void          MultiSelectAddSetRange(ImGuiMultiSelectTempData* ms, bool selected, int range_dir, ImGuiSelectionUserData first_item, ImGuiSelectionUserData last_item);\n    inline ImGuiBoxSelectState*     GetBoxSelectState(ImGuiID id)   { ImGuiContext& g = *GImGui; return (id != 0 && g.BoxSelectState.ID == id && g.BoxSelectState.IsActive) ? &g.BoxSelectState : NULL; }\n    inline ImGuiMultiSelectState*   GetMultiSelectState(ImGuiID id) { ImGuiContext& g = *GImGui; return g.MultiSelectStorage.GetByKey(id); }\n\n    // Internal Columns API (this is not exposed because we will encourage transitioning to the Tables API)\n    IMGUI_API void          SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect);\n    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiOldColumnFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().\n    IMGUI_API void          EndColumns();                                                               // close columns\n    IMGUI_API void          PushColumnClipRect(int column_index);\n    IMGUI_API void          PushColumnsBackground();\n    IMGUI_API void          PopColumnsBackground();\n    IMGUI_API ImGuiID       GetColumnsID(const char* str_id, int count);\n    IMGUI_API ImGuiOldColumns* FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);\n    IMGUI_API float         GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm);\n    IMGUI_API float         GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset);\n\n    // Tables: Candidates for public API\n    IMGUI_API void          TableOpenContextMenu(int column_n = -1);\n    IMGUI_API void          TableSetColumnWidth(int column_n, float width);\n    IMGUI_API void          TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs);\n    IMGUI_API int           TableGetHoveredRow();       // Retrieve *PREVIOUS FRAME* hovered row. This difference with TableGetHoveredColumn() is the reason why this is not public yet.\n    IMGUI_API float         TableGetHeaderRowHeight();\n    IMGUI_API float         TableGetHeaderAngledMaxLabelWidth();\n    IMGUI_API void          TablePushBackgroundChannel();\n    IMGUI_API void          TablePopBackgroundChannel();\n    IMGUI_API void          TableAngledHeadersRowEx(ImGuiID row_id, float angle, float max_label_width, const ImGuiTableHeaderData* data, int data_count);\n\n    // Tables: Internals\n    inline    ImGuiTable*   GetCurrentTable() { ImGuiContext& g = *GImGui; return g.CurrentTable; }\n    IMGUI_API ImGuiTable*   TableFindByID(ImGuiID id);\n    IMGUI_API bool          BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0, 0), float inner_width = 0.0f);\n    IMGUI_API void          TableBeginInitMemory(ImGuiTable* table, int columns_count);\n    IMGUI_API void          TableBeginApplyRequests(ImGuiTable* table);\n    IMGUI_API void          TableSetupDrawChannels(ImGuiTable* table);\n    IMGUI_API void          TableUpdateLayout(ImGuiTable* table);\n    IMGUI_API void          TableUpdateBorders(ImGuiTable* table);\n    IMGUI_API void          TableUpdateColumnsWeightFromWidth(ImGuiTable* table);\n    IMGUI_API void          TableDrawBorders(ImGuiTable* table);\n    IMGUI_API void          TableDrawDefaultContextMenu(ImGuiTable* table, ImGuiTableFlags flags_for_section_to_display);\n    IMGUI_API bool          TableBeginContextMenuPopup(ImGuiTable* table);\n    IMGUI_API void          TableMergeDrawChannels(ImGuiTable* table);\n    inline ImGuiTableInstanceData*  TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }\n    inline ImGuiID                  TableGetInstanceID(ImGuiTable* table, int instance_no)   { return TableGetInstanceData(table, instance_no)->TableInstanceID; }\n    IMGUI_API void          TableSortSpecsSanitize(ImGuiTable* table);\n    IMGUI_API void          TableSortSpecsBuild(ImGuiTable* table);\n    IMGUI_API ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn* column);\n    IMGUI_API void          TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column);\n    IMGUI_API float         TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column);\n    IMGUI_API void          TableBeginRow(ImGuiTable* table);\n    IMGUI_API void          TableEndRow(ImGuiTable* table);\n    IMGUI_API void          TableBeginCell(ImGuiTable* table, int column_n);\n    IMGUI_API void          TableEndCell(ImGuiTable* table);\n    IMGUI_API ImRect        TableGetCellBgRect(const ImGuiTable* table, int column_n);\n    IMGUI_API const char*   TableGetColumnName(const ImGuiTable* table, int column_n);\n    IMGUI_API ImGuiID       TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no = 0);\n    IMGUI_API float         TableCalcMaxColumnWidth(const ImGuiTable* table, int column_n);\n    IMGUI_API void          TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n);\n    IMGUI_API void          TableSetColumnWidthAutoAll(ImGuiTable* table);\n    IMGUI_API void          TableRemove(ImGuiTable* table);\n    IMGUI_API void          TableGcCompactTransientBuffers(ImGuiTable* table);\n    IMGUI_API void          TableGcCompactTransientBuffers(ImGuiTableTempData* table);\n    IMGUI_API void          TableGcCompactSettings();\n\n    // Tables: Settings\n    IMGUI_API void                  TableLoadSettings(ImGuiTable* table);\n    IMGUI_API void                  TableSaveSettings(ImGuiTable* table);\n    IMGUI_API void                  TableResetSettings(ImGuiTable* table);\n    IMGUI_API ImGuiTableSettings*   TableGetBoundSettings(ImGuiTable* table);\n    IMGUI_API void                  TableSettingsAddSettingsHandler();\n    IMGUI_API ImGuiTableSettings*   TableSettingsCreate(ImGuiID id, int columns_count);\n    IMGUI_API ImGuiTableSettings*   TableSettingsFindByID(ImGuiID id);\n\n    // Tab Bars\n    inline    ImGuiTabBar*  GetCurrentTabBar() { ImGuiContext& g = *GImGui; return g.CurrentTabBar; }\n    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);\n    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);\n    IMGUI_API ImGuiTabItem* TabBarFindTabByOrder(ImGuiTabBar* tab_bar, int order);\n    IMGUI_API ImGuiTabItem* TabBarGetCurrentTab(ImGuiTabBar* tab_bar);\n    inline int              TabBarGetTabOrder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab) { return tab_bar->Tabs.index_from_ptr(tab); }\n    IMGUI_API const char*   TabBarGetTabName(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);\n    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);\n    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);\n    IMGUI_API void          TabBarQueueFocus(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);\n    IMGUI_API void          TabBarQueueFocus(ImGuiTabBar* tab_bar, const char* tab_name);\n    IMGUI_API void          TabBarQueueReorder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, int offset);\n    IMGUI_API void          TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, ImVec2 mouse_pos);\n    IMGUI_API bool          TabBarProcessReorder(ImGuiTabBar* tab_bar);\n    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window);\n    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button_or_unsaved_marker);\n    IMGUI_API ImVec2        TabItemCalcSize(ImGuiWindow* window);\n    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);\n    IMGUI_API void          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped);\n\n    // Render helpers\n    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.\n    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)\n    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);\n    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);\n    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);\n    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);\n    IMGUI_API void          RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end, const ImVec2* text_size_if_known);\n    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool borders = true, float rounding = 0.0f);\n    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);\n    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, ImDrawFlags flags = 0);\n    IMGUI_API void          RenderNavCursor(const ImRect& bb, ImGuiID id, ImGuiNavRenderCursorFlags flags = ImGuiNavRenderCursorFlags_None); // Navigation highlight\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    inline    void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavRenderCursorFlags flags = ImGuiNavRenderCursorFlags_None) { RenderNavCursor(bb, id, flags); } // Renamed in 1.91.4\n#endif\n    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.\n    IMGUI_API void          RenderMouseCursor(ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow);\n\n    // Render helpers (those functions don't access any ImGui state!)\n    IMGUI_API void          RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale = 1.0f);\n    IMGUI_API void          RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col);\n    IMGUI_API void          RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz);\n    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);\n    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);\n    IMGUI_API void          RenderRectFilledWithHole(ImDrawList* draw_list, const ImRect& outer, const ImRect& inner, ImU32 col, float rounding);\n\n    // Widgets\n    IMGUI_API void          TextEx(const char* text, const char* text_end = NULL, ImGuiTextFlags flags = 0);\n    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0, 0), ImGuiButtonFlags flags = 0);\n    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags = 0);\n    IMGUI_API bool          ImageButtonEx(ImGuiID id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col, ImGuiButtonFlags flags = 0);\n    IMGUI_API void          SeparatorEx(ImGuiSeparatorFlags flags, float thickness = 1.0f);\n    IMGUI_API void          SeparatorTextEx(ImGuiID id, const char* label, const char* label_end, float extra_width);\n    IMGUI_API bool          CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value);\n    IMGUI_API bool          CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value);\n\n    // Widgets: Window Decorations\n    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos);\n    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);\n    IMGUI_API void          Scrollbar(ImGuiAxis axis);\n    IMGUI_API bool          ScrollbarEx(const ImRect& bb, ImGuiID id, ImGuiAxis axis, ImS64* p_scroll_v, ImS64 avail_v, ImS64 contents_v, ImDrawFlags draw_rounding_flags = 0);\n    IMGUI_API ImRect        GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis);\n    IMGUI_API ImGuiID       GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);\n    IMGUI_API ImGuiID       GetWindowResizeCornerID(ImGuiWindow* window, int n); // 0..3: corners\n    IMGUI_API ImGuiID       GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir);\n\n    // Widgets low-level behaviors\n    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);\n    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags);\n    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);\n    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f, ImU32 bg_col = 0);\n\n    // Widgets: Tree Nodes\n    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);\n    IMGUI_API void          TreePushOverrideID(ImGuiID id);\n    IMGUI_API bool          TreeNodeGetOpen(ImGuiID storage_id);\n    IMGUI_API void          TreeNodeSetOpen(ImGuiID storage_id, bool open);\n    IMGUI_API bool          TreeNodeUpdateNextOpen(ImGuiID storage_id, ImGuiTreeNodeFlags flags);   // Return open state. Consume previous SetNextItemOpen() data, if any. May return true when logging.\n\n    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types.\n    // To use them externally (for custom widget) you may need an \"extern template\" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).\n    // e.g. \" extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); \"\n    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API float ScaleRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);\n    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API T     ScaleValueFromRatioT(ImGuiDataType data_type, float t, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);\n    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, ImGuiSliderFlags flags);\n    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);\n    template<typename T>                                        IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);\n    template<typename T>                                        IMGUI_API bool  CheckboxFlagsT(const char* label, T* flags, T flags_value);\n\n    // Data type helpers\n    IMGUI_API const ImGuiDataTypeInfo*  DataTypeGetInfo(ImGuiDataType data_type);\n    IMGUI_API int           DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format);\n    IMGUI_API void          DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg_1, const void* arg_2);\n    IMGUI_API bool          DataTypeApplyFromText(const char* buf, ImGuiDataType data_type, void* p_data, const char* format, void* p_data_when_empty = NULL);\n    IMGUI_API int           DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2);\n    IMGUI_API bool          DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max);\n    IMGUI_API bool          DataTypeIsZero(ImGuiDataType data_type, const void* p_data);\n\n    // InputText\n    IMGUI_API bool          InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\n    IMGUI_API void          InputTextDeactivateHook(ImGuiID id);\n    IMGUI_API bool          TempInputText(const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags);\n    IMGUI_API bool          TempInputScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min = NULL, const void* p_clamp_max = NULL);\n    inline bool             TempInputIsActive(ImGuiID id)       { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }\n    inline ImGuiInputTextState* GetInputTextState(ImGuiID id)   { ImGuiContext& g = *GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : NULL; } // Get input text state if active\n    IMGUI_API void          SetNextItemRefVal(ImGuiDataType data_type, void* p_data);\n\n    // Color\n    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);\n    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);\n    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);\n\n    // Plot\n    IMGUI_API int           PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, const ImVec2& size_arg);\n\n    // Shade functions (write over already created vertices)\n    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);\n    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);\n    IMGUI_API void          ShadeVertsTransformPos(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& pivot_in, float cos_a, float sin_a, const ImVec2& pivot_out);\n\n    // Garbage collection\n    IMGUI_API void          GcCompactTransientMiscBuffers();\n    IMGUI_API void          GcCompactTransientWindowBuffers(ImGuiWindow* window);\n    IMGUI_API void          GcAwakeTransientWindowBuffers(ImGuiWindow* window);\n\n    // Error handling, State Recovery\n    IMGUI_API bool          ErrorLog(const char* msg);\n    IMGUI_API void          ErrorRecoveryStoreState(ImGuiErrorRecoveryState* state_out);\n    IMGUI_API void          ErrorRecoveryTryToRecoverState(const ImGuiErrorRecoveryState* state_in);\n    IMGUI_API void          ErrorRecoveryTryToRecoverWindowState(const ImGuiErrorRecoveryState* state_in);\n    IMGUI_API void          ErrorCheckUsingSetCursorPosToExtendParentBoundaries();\n    IMGUI_API void          ErrorCheckEndFrameFinalizeErrorTooltip();\n    IMGUI_API bool          BeginErrorTooltip();\n    IMGUI_API void          EndErrorTooltip();\n\n    // Debug Tools\n    IMGUI_API void          DebugAllocHook(ImGuiDebugAllocInfo* info, int frame_count, void* ptr, size_t size); // size >= 0 : alloc, size = -1 : free\n    IMGUI_API void          DebugDrawCursorPos(ImU32 col = IM_COL32(255, 0, 0, 255));\n    IMGUI_API void          DebugDrawLineExtents(ImU32 col = IM_COL32(255, 0, 0, 255));\n    IMGUI_API void          DebugDrawItemRect(ImU32 col = IM_COL32(255, 0, 0, 255));\n    IMGUI_API void          DebugTextUnformattedWithLocateItem(const char* line_begin, const char* line_end);\n    IMGUI_API void          DebugLocateItem(ImGuiID target_id);                     // Call sparingly: only 1 at the same time!\n    IMGUI_API void          DebugLocateItemOnHover(ImGuiID target_id);              // Only call on reaction to a mouse Hover: because only 1 at the same time!\n    IMGUI_API void          DebugLocateItemResolveWithLastItem();\n    IMGUI_API void          DebugBreakClearData();\n    IMGUI_API bool          DebugBreakButton(const char* label, const char* description_of_location);\n    IMGUI_API void          DebugBreakButtonTooltip(bool keyboard_only, const char* description_of_location);\n    IMGUI_API void          ShowFontAtlas(ImFontAtlas* atlas);\n    IMGUI_API void          DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void* data_id, const void* data_id_end);\n    IMGUI_API void          DebugNodeColumns(ImGuiOldColumns* columns);\n    IMGUI_API void          DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, const ImDrawList* draw_list, const char* label);\n    IMGUI_API void          DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb);\n    IMGUI_API void          DebugNodeFont(ImFont* font);\n    IMGUI_API void          DebugNodeFontGlyph(ImFont* font, const ImFontGlyph* glyph);\n    IMGUI_API void          DebugNodeStorage(ImGuiStorage* storage, const char* label);\n    IMGUI_API void          DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label);\n    IMGUI_API void          DebugNodeTable(ImGuiTable* table);\n    IMGUI_API void          DebugNodeTableSettings(ImGuiTableSettings* settings);\n    IMGUI_API void          DebugNodeInputTextState(ImGuiInputTextState* state);\n    IMGUI_API void          DebugNodeTypingSelectState(ImGuiTypingSelectState* state);\n    IMGUI_API void          DebugNodeMultiSelectState(ImGuiMultiSelectState* state);\n    IMGUI_API void          DebugNodeWindow(ImGuiWindow* window, const char* label);\n    IMGUI_API void          DebugNodeWindowSettings(ImGuiWindowSettings* settings);\n    IMGUI_API void          DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label);\n    IMGUI_API void          DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windows_size, ImGuiWindow* parent_in_begin_stack);\n    IMGUI_API void          DebugNodeViewport(ImGuiViewportP* viewport);\n    IMGUI_API void          DebugRenderKeyboardPreview(ImDrawList* draw_list);\n    IMGUI_API void          DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb);\n\n    // Obsolete functions\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    //inline void   SetItemUsingMouseWheel()                                            { SetItemKeyOwner(ImGuiKey_MouseWheelY); }      // Changed in 1.89\n    //inline bool   TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0)    { return TreeNodeUpdateNextOpen(id, flags); }   // Renamed in 1.89\n    //inline bool   IsKeyPressedMap(ImGuiKey key, bool repeat = true)                   { IM_ASSERT(IsNamedKey(key)); return IsKeyPressed(key, repeat); } // Removed in 1.87: Mapping from named key is always identity!\n\n    // Refactored focus/nav/tabbing system in 1.82 and 1.84. If you have old/custom copy-and-pasted widgets which used FocusableItemRegister():\n    //  (Old) IMGUI_VERSION_NUM  < 18209: using 'ItemAdd(....)'                              and 'bool tab_focused = FocusableItemRegister(...)'\n    //  (Old) IMGUI_VERSION_NUM >= 18209: using 'ItemAdd(..., ImGuiItemAddFlags_Focusable)'  and 'bool tab_focused = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Focused) != 0'\n    //  (New) IMGUI_VERSION_NUM >= 18413: using 'ItemAdd(..., ImGuiItemFlags_Inputable)'     and 'bool tab_focused = (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput))'\n    //inline bool   FocusableItemRegister(ImGuiWindow* window, ImGuiID id)              // -> pass ImGuiItemAddFlags_Inputable flag to ItemAdd()\n    //inline void   FocusableItemUnregister(ImGuiWindow* window)                        // -> unnecessary: TempInputText() uses ImGuiInputTextFlags_MergedItem\n#endif\n\n} // namespace ImGui\n\n\n//-----------------------------------------------------------------------------\n// [SECTION] ImFontAtlas internal API\n//-----------------------------------------------------------------------------\n\n// This structure is likely to evolve as we add support for incremental atlas updates.\n// Conceptually this could be in ImGuiPlatformIO, but we are far from ready to make this public.\nstruct ImFontBuilderIO\n{\n    bool    (*FontBuilder_Build)(ImFontAtlas* atlas);\n};\n\n// Helper for font builder\n#ifdef IMGUI_ENABLE_STB_TRUETYPE\nIMGUI_API const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype();\n#endif\nIMGUI_API void      ImFontAtlasUpdateConfigDataPointers(ImFontAtlas* atlas);\nIMGUI_API void      ImFontAtlasBuildInit(ImFontAtlas* atlas);\nIMGUI_API void      ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);\nIMGUI_API void      ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);\nIMGUI_API void      ImFontAtlasBuildFinish(ImFontAtlas* atlas);\nIMGUI_API void      ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value);\nIMGUI_API void      ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value);\nIMGUI_API void      ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);\nIMGUI_API void      ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);\n\n//-----------------------------------------------------------------------------\n// [SECTION] Test Engine specific hooks (imgui_test_engine)\n//-----------------------------------------------------------------------------\n\n#ifdef IMGUI_ENABLE_TEST_ENGINE\nextern void         ImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, ImGuiID id, const ImRect& bb, const ImGuiLastItemData* item_data);           // item_data may be NULL\nextern void         ImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);\nextern void         ImGuiTestEngineHook_Log(ImGuiContext* ctx, const char* fmt, ...);\nextern const char*  ImGuiTestEngine_FindItemDebugLabel(ImGuiContext* ctx, ImGuiID id);\n\n// In IMGUI_VERSION_NUM >= 18934: changed IMGUI_TEST_ENGINE_ITEM_ADD(bb,id) to IMGUI_TEST_ENGINE_ITEM_ADD(id,bb,item_data);\n#define IMGUI_TEST_ENGINE_ITEM_ADD(_ID,_BB,_ITEM_DATA)      if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemAdd(&g, _ID, _BB, _ITEM_DATA)    // Register item bounding box\n#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)    // Register item label and status flags (optional)\n#define IMGUI_TEST_ENGINE_LOG(_FMT,...)                     ImGuiTestEngineHook_Log(&g, _FMT, __VA_ARGS__)                                      // Custom log entry from user land into test log\n#else\n#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB,_ID)                 ((void)0)\n#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      ((void)g)\n#endif\n\n//-----------------------------------------------------------------------------\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#elif defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (pop)\n#endif\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "imgui_tables.cpp",
          "type": "blob",
          "size": 239.38,
          "content": "// dear imgui, v1.91.7 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.\n//   Y with ScrollX/ScrollY disabled: we output table directly in current window\n//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful if parent window can vertically scroll.\n//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)\n//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtendY is set)\n//   Y with ScrollX/ScrollY enabled: using a child window for scrolling\n//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window can vertically scroll.\n//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.\n//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.\n//-----------------------------------------------------------------------------\n// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.\n// Important to note how the two flags have slightly different behaviors!\n//   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.\n//   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.\n// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.\n// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not useful and not easily noticeable).\n//-----------------------------------------------------------------------------\n// About 'inner_width':\n//   With ScrollX disabled:\n//   - inner_width          ->  *ignored*\n//   With ScrollX enabled:\n//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird\n//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.\n//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!\n//-----------------------------------------------------------------------------\n// Details:\n// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept\n//   of \"available space\" doesn't make sense.\n// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding\n//   of what the value does.\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// COLUMNS SIZING POLICIES\n// (Reference: ImGuiTableFlags_SizingXXX flags and ImGuiTableColumnFlags_WidthXXX flags)\n//-----------------------------------------------------------------------------\n// About overriding column sizing policy and width/weight with TableSetupColumn():\n// We use a default parameter of -1 for 'init_width'/'init_weight'.\n//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic\n//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom\n//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f\n//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom\n// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)\n// and you can fit a 100.0f wide item in it without clipping and with padding honored.\n//-----------------------------------------------------------------------------\n// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)\n//   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width\n//   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width\n//   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f\n//   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents\n// Default Width and default Weight can be overridden when calling TableSetupColumn().\n//-----------------------------------------------------------------------------\n// About mixing Fixed/Auto and Stretch columns together:\n//   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.\n//   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!\n//     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.\n//   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.\n//   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weights/widths.\n//-----------------------------------------------------------------------------\n// About using column width:\n// If a column is manually resizable or has a width specified with TableSetupColumn():\n//   - you may use GetContentRegionAvail().x to query the width available in a given column.\n//   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.\n// If the column is not resizable and has no width specified with TableSetupColumn():\n//   - its width will be automatic and be set to the max of items submitted.\n//   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).\n//   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).\n//-----------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// TABLES CLIPPING/CULLING\n//-----------------------------------------------------------------------------\n// About clipping/culling of Rows in Tables:\n// - For large numbers of rows, it is recommended you use ImGuiListClipper to submit only visible rows.\n//   ImGuiListClipper is reliant on the fact that rows are of equal height.\n//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.\n// - Note that auto-resizing columns don't play well with using the clipper.\n//   By default a table with _ScrollX but without _Resizable will have column auto-resize.\n//   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.\n//-----------------------------------------------------------------------------\n// About clipping/culling of Columns in Tables:\n// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing\n//   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know\n//   it is not going to contribute to row height.\n//   In many situations, you may skip submitting contents for every column but one (e.g. the first one).\n// - Case A: column is not hidden by user, and at least partially in sight (most common case).\n// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.\n// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).\n//\n//                        [A]         [B]          [C]\n//  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() returns false, user can skip submitting items but only if the column doesn't contribute to row height.\n//          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.\n//           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.\n//  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).\n//\n// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.\n//   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.\n//-----------------------------------------------------------------------------\n// About clipping/culling of whole Tables:\n// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// [SECTION] Header mess\n//-----------------------------------------------------------------------------\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wformat\"                           // warning: format '%p' expects argument of type 'int'/'void*', but argument X has type 'unsigned int'/'ImGuiWindow*'\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-----------------------------------------------------------------------------\n// [SECTION] Tables: Main code\n//-----------------------------------------------------------------------------\n// - TableFixFlags() [Internal]\n// - TableFindByID() [Internal]\n// - BeginTable()\n// - BeginTableEx() [Internal]\n// - TableBeginInitMemory() [Internal]\n// - TableBeginApplyRequests() [Internal]\n// - TableSetupColumnFlags() [Internal]\n// - TableUpdateLayout() [Internal]\n// - TableUpdateBorders() [Internal]\n// - EndTable()\n// - TableSetupColumn()\n// - TableSetupScrollFreeze()\n//-----------------------------------------------------------------------------\n\n// Configuration\nstatic const int TABLE_DRAW_CHANNEL_BG0 = 0;\nstatic const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;\nstatic const int TABLE_DRAW_CHANNEL_NOCLIP = 2;                     // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)\nstatic const float TABLE_BORDER_SIZE                     = 1.0f;    // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.\nstatic const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f;    // Extend outside inner borders.\nstatic const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f;   // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.\n\n// Helper\ninline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)\n{\n    // Adjust flags: set default sizing policy\n    if ((flags & ImGuiTableFlags_SizingMask_) == 0)\n        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;\n\n    // Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame\n    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)\n        flags |= ImGuiTableFlags_NoKeepColumnsVisible;\n\n    // Adjust flags: enforce borders when resizable\n    if (flags & ImGuiTableFlags_Resizable)\n        flags |= ImGuiTableFlags_BordersInnerV;\n\n    // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on\n    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))\n        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);\n\n    // Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody\n    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)\n        flags &= ~ImGuiTableFlags_NoBordersInBody;\n\n    // Adjust flags: disable saved settings if there's nothing to save\n    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)\n        flags |= ImGuiTableFlags_NoSavedSettings;\n\n    // Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)\n    if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)\n        flags |= ImGuiTableFlags_NoSavedSettings;\n\n    return flags;\n}\n\nImGuiTable* ImGui::TableFindByID(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    return g.Tables.GetByKey(id);\n}\n\n// Read about \"TABLE SIZING\" at the top of this file.\nbool    ImGui::BeginTable(const char* str_id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)\n{\n    ImGuiID id = GetID(str_id);\n    return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);\n}\n\nbool    ImGui::BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* outer_window = GetCurrentWindow();\n    if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.\n        return false;\n\n    // Sanity checks\n    IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS);\n    if (flags & ImGuiTableFlags_ScrollX)\n        IM_ASSERT(inner_width >= 0.0f);\n\n    // If an outer size is specified ahead we will be able to early out when not visible. Exact clipping criteria may evolve.\n    // FIXME: coarse clipping because access to table data causes two issues:\n    // - instance numbers varying/unstable. may not be a direct problem for users, but could make outside access broken or confusing, e.g. TestEngine.\n    // - can't implement support for ImGuiChildFlags_ResizeY as we need to somehow pull the height data from somewhere. this also needs stable instance numbers.\n    // The side-effects of accessing table data on coarse clip would be:\n    // - always reserving the pooled ImGuiTable data ahead for a fully clipped table (minor IMHO). Also the 'outer_window_is_measuring_size' criteria may already be defeating this in some situations.\n    // - always performing the GetOrAddByKey() O(log N) query in g.Tables.Map[].\n    const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;\n    const ImVec2 avail_size = GetContentRegionAvail();\n    const ImVec2 actual_outer_size = ImTrunc(CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f));\n    const ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);\n    const bool outer_window_is_measuring_size = (outer_window->AutoFitFramesX > 0) || (outer_window->AutoFitFramesY > 0); // Doesn't apply to AlwaysAutoResize windows!\n    if (use_child_window && IsClippedEx(outer_rect, 0) && !outer_window_is_measuring_size)\n    {\n        ItemSize(outer_rect);\n        ItemAdd(outer_rect, id);\n        return false;\n    }\n\n    // [DEBUG] Debug break requested by user\n    if (g.DebugBreakInTable == id)\n        IM_DEBUG_BREAK();\n\n    // Acquire storage for the table\n    ImGuiTable* table = g.Tables.GetOrAddByKey(id);\n\n    // Acquire temporary buffers\n    const int table_idx = g.Tables.GetIndex(table);\n    if (++g.TablesTempDataStacked > g.TablesTempData.Size)\n        g.TablesTempData.resize(g.TablesTempDataStacked, ImGuiTableTempData());\n    ImGuiTableTempData* temp_data = table->TempData = &g.TablesTempData[g.TablesTempDataStacked - 1];\n    temp_data->TableIndex = table_idx;\n    table->DrawSplitter = &table->TempData->DrawSplitter;\n    table->DrawSplitter->Clear();\n\n    // Fix flags\n    table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;\n    flags = TableFixFlags(flags, outer_window);\n\n    // Initialize\n    const int previous_frame_active = table->LastFrameActive;\n    const int instance_no = (previous_frame_active != g.FrameCount) ? 0 : table->InstanceCurrent + 1;\n    const ImGuiTableFlags previous_flags = table->Flags;\n    table->ID = id;\n    table->Flags = flags;\n    table->LastFrameActive = g.FrameCount;\n    table->OuterWindow = table->InnerWindow = outer_window;\n    table->ColumnsCount = columns_count;\n    table->IsLayoutLocked = false;\n    table->InnerWidth = inner_width;\n    temp_data->UserOuterSize = outer_size;\n\n    // Instance data (for instance 0, TableID == TableInstanceID)\n    ImGuiID instance_id;\n    table->InstanceCurrent = (ImS16)instance_no;\n    if (instance_no > 0)\n    {\n        IM_ASSERT(table->ColumnsCount == columns_count && \"BeginTable(): Cannot change columns count mid-frame while preserving same ID\");\n        if (table->InstanceDataExtra.Size < instance_no)\n            table->InstanceDataExtra.push_back(ImGuiTableInstanceData());\n        instance_id = GetIDWithSeed(instance_no, GetIDWithSeed(\"##Instances\", NULL, id)); // Push \"##Instances\" followed by (int)instance_no in ID stack.\n    }\n    else\n    {\n        instance_id = id;\n    }\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    table_instance->TableInstanceID = instance_id;\n\n    // When not using a child window, WorkRect.Max will grow as we append contents.\n    if (use_child_window)\n    {\n        // Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent\n        // (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)\n        ImVec2 override_content_size(FLT_MAX, FLT_MAX);\n        if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))\n            override_content_size.y = FLT_MIN;\n\n        // Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and\n        // never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align\n        // based on the right side of the child window work rect, which would require knowing ahead if we are going to\n        // have decoration taking horizontal spaces (typically a vertical scrollbar).\n        if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)\n            override_content_size.x = inner_width;\n\n        if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)\n            SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));\n\n        // Reset scroll if we are reactivating it\n        if ((previous_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)\n            if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll) == 0)\n                SetNextWindowScroll(ImVec2(0.0f, 0.0f));\n\n        // Create scrolling region (without border and zero window padding)\n        ImGuiWindowFlags child_window_flags = (flags & ImGuiTableFlags_ScrollX) ? ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_None;\n        BeginChildEx(name, instance_id, outer_rect.GetSize(), ImGuiChildFlags_None, child_window_flags);\n        table->InnerWindow = g.CurrentWindow;\n        table->WorkRect = table->InnerWindow->WorkRect;\n        table->OuterRect = table->InnerWindow->Rect();\n        table->InnerRect = table->InnerWindow->InnerRect;\n        IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);\n\n        // Allow submitting when host is measuring\n        if (table->InnerWindow->SkipItems && outer_window_is_measuring_size)\n            table->InnerWindow->SkipItems = false;\n\n        // When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)\n        if (instance_no == 0)\n        {\n            table->HasScrollbarYPrev = table->HasScrollbarYCurr;\n            table->HasScrollbarYCurr = false;\n        }\n        table->HasScrollbarYCurr |= table->InnerWindow->ScrollbarY;\n    }\n    else\n    {\n        // For non-scrolling tables, WorkRect == OuterRect == InnerRect.\n        // But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().\n        table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;\n        table->HasScrollbarYPrev = table->HasScrollbarYCurr = false;\n    }\n\n    // Push a standardized ID for both child-using and not-child-using tables\n    PushOverrideID(id);\n    if (instance_no > 0)\n        PushOverrideID(instance_id); // FIXME: Somehow this is not resolved by stack-tool, even tho GetIDWithSeed() submitted the symbol.\n\n    // Backup a copy of host window members we will modify\n    ImGuiWindow* inner_window = table->InnerWindow;\n    table->HostIndentX = inner_window->DC.Indent.x;\n    table->HostClipRect = inner_window->ClipRect;\n    table->HostSkipItems = inner_window->SkipItems;\n    temp_data->HostBackupWorkRect = inner_window->WorkRect;\n    temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;\n    temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;\n    temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;\n    temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;\n    temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;\n    temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;\n    temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;\n    inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);\n\n    // Make borders not overlap our contents by offsetting HostClipRect (#6765, #7428, #3752)\n    // (we normally shouldn't alter HostClipRect as we rely on TableMergeDrawChannels() expanding non-clipped column toward the\n    // limits of that rectangle, in order for ImDrawListSplitter::Merge() to merge the draw commands. However since the overlap\n    // problem only affect scrolling tables in this case we can get away with doing it without extra cost).\n    if (inner_window != outer_window)\n    {\n        // FIXME: Because inner_window's Scrollbar doesn't know about border size, since it's not encoded in window->WindowBorderSize,\n        // it already overlaps it and doesn't need an extra offset. Ideally we should be able to pass custom border size with\n        // different x/y values to BeginChild().\n        if (flags & ImGuiTableFlags_BordersOuterV)\n        {\n            table->HostClipRect.Min.x = ImMin(table->HostClipRect.Min.x + TABLE_BORDER_SIZE, table->HostClipRect.Max.x);\n            if (inner_window->DecoOuterSizeX2 == 0.0f)\n                table->HostClipRect.Max.x = ImMax(table->HostClipRect.Max.x - TABLE_BORDER_SIZE, table->HostClipRect.Min.x);\n        }\n        if (flags & ImGuiTableFlags_BordersOuterH)\n        {\n            table->HostClipRect.Min.y = ImMin(table->HostClipRect.Min.y + TABLE_BORDER_SIZE, table->HostClipRect.Max.y);\n            if (inner_window->DecoOuterSizeY2 == 0.0f)\n                table->HostClipRect.Max.y = ImMax(table->HostClipRect.Max.y - TABLE_BORDER_SIZE, table->HostClipRect.Min.y);\n        }\n    }\n\n    // Padding and Spacing\n    // - None               ........Content..... Pad .....Content........\n    // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |\n    // - PadInner           ........Content.. Pad | Pad ..Content........\n    // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |\n    const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true : (flags & ImGuiTableFlags_BordersOuterV) != 0;\n    const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;\n    const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;\n    const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;\n    const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;\n    table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;\n    table->CellSpacingX2 = inner_spacing_explicit;\n    table->CellPaddingX = inner_padding_explicit;\n\n    const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;\n    const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;\n    table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;\n\n    table->CurrentColumn = -1;\n    table->CurrentRow = -1;\n    table->RowBgColorCounter = 0;\n    table->LastRowFlags = ImGuiTableRowFlags_None;\n    table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;\n    table->InnerClipRect.ClipWith(table->WorkRect);     // We need this to honor inner_width\n    table->InnerClipRect.ClipWithFull(table->HostClipRect);\n    table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : table->HostClipRect.Max.y;\n\n    table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow\n    table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()\n    table->RowCellPaddingY = 0.0f;\n    table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any\n    table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;\n    table->IsUnfrozenRows = true;\n    table->DeclColumnsCount = table->AngledHeadersCount = 0;\n    if (previous_frame_active + 1 < g.FrameCount)\n        table->IsActiveIdInTable = false;\n    table->AngledHeadersHeight = 0.0f;\n    temp_data->AngledHeadersExtraWidth = 0.0f;\n\n    // Using opaque colors facilitate overlapping lines of the grid, otherwise we'd need to improve TableDrawBorders()\n    table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);\n    table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);\n\n    // Make table current\n    g.CurrentTable = table;\n    outer_window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();\n    outer_window->DC.CurrentTableIdx = table_idx;\n    if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.\n        inner_window->DC.CurrentTableIdx = table_idx;\n\n    if ((previous_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)\n        table->IsResetDisplayOrderRequest = true;\n\n    // Mark as used to avoid GC\n    if (table_idx >= g.TablesLastTimeActive.Size)\n        g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);\n    g.TablesLastTimeActive[table_idx] = (float)g.Time;\n    temp_data->LastTimeActive = (float)g.Time;\n    table->MemoryCompacted = false;\n\n    // Setup memory buffer (clear data if columns count changed)\n    ImGuiTableColumn* old_columns_to_preserve = NULL;\n    void* old_columns_raw_data = NULL;\n    const int old_columns_count = table->Columns.size();\n    if (old_columns_count != 0 && old_columns_count != columns_count)\n    {\n        // Attempt to preserve width on column count change (#4046)\n        old_columns_to_preserve = table->Columns.Data;\n        old_columns_raw_data = table->RawData;\n        table->RawData = NULL;\n    }\n    if (table->RawData == NULL)\n    {\n        TableBeginInitMemory(table, columns_count);\n        table->IsInitializing = table->IsSettingsRequestLoad = true;\n    }\n    if (table->IsResetAllRequest)\n        TableResetSettings(table);\n    if (table->IsInitializing)\n    {\n        // Initialize\n        table->SettingsOffset = -1;\n        table->IsSortSpecsDirty = true;\n        table->InstanceInteracted = -1;\n        table->ContextPopupColumn = -1;\n        table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;\n        table->AutoFitSingleColumn = -1;\n        table->HoveredColumnBody = table->HoveredColumnBorder = -1;\n        for (int n = 0; n < columns_count; n++)\n        {\n            ImGuiTableColumn* column = &table->Columns[n];\n            if (old_columns_to_preserve && n < old_columns_count)\n            {\n                // FIXME: We don't attempt to preserve column order in this path.\n                *column = old_columns_to_preserve[n];\n            }\n            else\n            {\n                float width_auto = column->WidthAuto;\n                *column = ImGuiTableColumn();\n                column->WidthAuto = width_auto;\n                column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker\n                column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;\n            }\n            column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;\n        }\n    }\n    if (old_columns_raw_data)\n        IM_FREE(old_columns_raw_data);\n\n    // Load settings\n    if (table->IsSettingsRequestLoad)\n        TableLoadSettings(table);\n\n    // Handle DPI/font resize\n    // This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.\n    // It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.\n    // FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.\n    // This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.\n    const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?\n    if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit)\n    {\n        const float scale_factor = new_ref_scale_unit / table->RefScale;\n        //IMGUI_DEBUG_PRINT(\"[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\\n\", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);\n        for (int n = 0; n < columns_count; n++)\n            table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;\n    }\n    table->RefScale = new_ref_scale_unit;\n\n    // Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..\n    // This is not strictly necessary but will reduce cases were \"out of table\" output will be misleading to the user.\n    // Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.\n    inner_window->SkipItems = true;\n\n    // Clear names\n    // At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()\n    if (table->ColumnsNames.Buf.Size > 0)\n        table->ColumnsNames.Buf.resize(0);\n\n    // Apply queued resizing/reordering/hiding requests\n    TableBeginApplyRequests(table);\n\n    return true;\n}\n\n// For reference, the average total _allocation count_ for a table is:\n// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables[])\n// + 1 (for table->RawData allocated below)\n// + 1 (for table->ColumnsNames, if names are used)\n// Shared allocations for the maximum number of simultaneously nested tables (generally a very small number)\n// + 1 (for table->Splitter._Channels)\n// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)\n// Where active_channels_count is variable but often == columns_count or == columns_count + 1, see TableSetupDrawChannels() for details.\n// Unused channels don't perform their +2 allocations.\nvoid ImGui::TableBeginInitMemory(ImGuiTable* table, int columns_count)\n{\n    // Allocate single buffer for our arrays\n    const int columns_bit_array_size = (int)ImBitArrayGetStorageSizeInBytes(columns_count);\n    ImSpanAllocator<6> span_allocator;\n    span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));\n    span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));\n    span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);\n    for (int n = 3; n < 6; n++)\n        span_allocator.Reserve(n, columns_bit_array_size);\n    table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());\n    memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());\n    span_allocator.SetArenaBasePtr(table->RawData);\n    span_allocator.GetSpan(0, &table->Columns);\n    span_allocator.GetSpan(1, &table->DisplayOrderToIndex);\n    span_allocator.GetSpan(2, &table->RowCellData);\n    table->EnabledMaskByDisplayOrder = (ImU32*)span_allocator.GetSpanPtrBegin(3);\n    table->EnabledMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(4);\n    table->VisibleMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(5);\n}\n\n// Apply queued resizing/reordering/hiding requests\nvoid ImGui::TableBeginApplyRequests(ImGuiTable* table)\n{\n    // Handle resizing request\n    // (We process this in the TableBegin() of the first instance of each table)\n    // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?\n    if (table->InstanceCurrent == 0)\n    {\n        if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)\n            TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);\n        table->LastResizedColumn = table->ResizedColumn;\n        table->ResizedColumnNextWidth = FLT_MAX;\n        table->ResizedColumn = -1;\n\n        // Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.\n        // FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.\n        if (table->AutoFitSingleColumn != -1)\n        {\n            TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);\n            table->AutoFitSingleColumn = -1;\n        }\n    }\n\n    // Handle reordering request\n    // Note: we don't clear ReorderColumn after handling the request.\n    if (table->InstanceCurrent == 0)\n    {\n        if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)\n            table->ReorderColumn = -1;\n        table->HeldHeaderColumn = -1;\n        if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0)\n        {\n            // We need to handle reordering across hidden columns.\n            // In the configuration below, moving C to the right of E will lead to:\n            //    ... C [D] E  --->  ... [D] E  C   (Column name/index)\n            //    ... 2  3  4        ...  2  3  4   (Display order)\n            const int reorder_dir = table->ReorderColumnDir;\n            IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);\n            IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);\n            ImGuiTableColumn* src_column = &table->Columns[table->ReorderColumn];\n            ImGuiTableColumn* dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];\n            IM_UNUSED(dst_column);\n            const int src_order = src_column->DisplayOrder;\n            const int dst_order = dst_column->DisplayOrder;\n            src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;\n            for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)\n                table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;\n            IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);\n\n            // Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[]. Rebuild later from the former.\n            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n                table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;\n            table->ReorderColumnDir = 0;\n            table->IsSettingsDirty = true;\n        }\n    }\n\n    // Handle display order reset request\n    if (table->IsResetDisplayOrderRequest)\n    {\n        for (int n = 0; n < table->ColumnsCount; n++)\n            table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;\n        table->IsResetDisplayOrderRequest = false;\n        table->IsSettingsDirty = true;\n    }\n}\n\n// Adjust flags: default width mode + stretch columns are not allowed when auto extending\nstatic void TableSetupColumnFlags(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags flags_in)\n{\n    ImGuiTableColumnFlags flags = flags_in;\n\n    // Sizing Policy\n    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0)\n    {\n        const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);\n        if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)\n            flags |= ImGuiTableColumnFlags_WidthFixed;\n        else\n            flags |= ImGuiTableColumnFlags_WidthStretch;\n    }\n    else\n    {\n        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.\n    }\n\n    // Resize\n    if ((table->Flags & ImGuiTableFlags_Resizable) == 0)\n        flags |= ImGuiTableColumnFlags_NoResize;\n\n    // Sorting\n    if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))\n        flags |= ImGuiTableColumnFlags_NoSort;\n\n    // Indentation\n    if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)\n        flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;\n\n    // Alignment\n    //if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)\n    //    flags |= ImGuiTableColumnFlags_AlignCenter;\n    //IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.\n\n    // Preserve status flags\n    column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);\n\n    // Build an ordered list of available sort directions\n    column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;\n    if (table->Flags & ImGuiTableFlags_Sortable)\n    {\n        int count = 0, mask = 0, list = 0;\n        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }\n        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }\n        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }\n        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }\n        if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) { mask |= 1 << ImGuiSortDirection_None; count++; }\n        column->SortDirectionsAvailList = (ImU8)list;\n        column->SortDirectionsAvailMask = (ImU8)mask;\n        column->SortDirectionsAvailCount = (ImU8)count;\n        ImGui::TableFixColumnSortDirection(table, column);\n    }\n}\n\n// Layout columns for the frame. This is in essence the followup to BeginTable() and this is our largest function.\n// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions to be called first.\n// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.\n// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?\nvoid ImGui::TableUpdateLayout(ImGuiTable* table)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(table->IsLayoutLocked == false);\n\n    const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);\n    table->IsDefaultDisplayOrder = true;\n    table->ColumnsEnabledCount = 0;\n    ImBitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);\n    ImBitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);\n    table->LeftMostEnabledColumn = -1;\n    table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE\n\n    // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.\n    // Process columns in their visible orders as we are building the Prev/Next indices.\n    int count_fixed = 0;                // Number of columns that have fixed sizing policies\n    int count_stretch = 0;              // Number of columns that have stretch sizing policies\n    int prev_visible_column_idx = -1;\n    bool has_auto_fit_request = false;\n    bool has_resizable = false;\n    float stretch_sum_width_auto = 0.0f;\n    float fixed_max_width_auto = 0.0f;\n    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)\n    {\n        const int column_n = table->DisplayOrderToIndex[order_n];\n        if (column_n != order_n)\n            table->IsDefaultDisplayOrder = false;\n        ImGuiTableColumn* column = &table->Columns[column_n];\n\n        // Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.\n        // It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.\n        // We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.\n        if (table->DeclColumnsCount <= column_n)\n        {\n            TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);\n            column->NameOffset = -1;\n            column->UserID = 0;\n            column->InitStretchWeightOrWidth = -1.0f;\n        }\n\n        // Update Enabled state, mark settings and sort specs dirty\n        if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))\n            column->IsUserEnabledNextFrame = true;\n        if (column->IsUserEnabled != column->IsUserEnabledNextFrame)\n        {\n            column->IsUserEnabled = column->IsUserEnabledNextFrame;\n            table->IsSettingsDirty = true;\n        }\n        column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;\n\n        if (column->SortOrder != -1 && !column->IsEnabled)\n            table->IsSortSpecsDirty = true;\n        if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))\n            table->IsSortSpecsDirty = true;\n\n        // Auto-fit unsized columns\n        const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);\n        if (start_auto_fit)\n            column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames\n\n        if (!column->IsEnabled)\n        {\n            column->IndexWithinEnabledSet = -1;\n            continue;\n        }\n\n        // Mark as enabled and link to previous/next enabled column\n        column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;\n        column->NextEnabledColumn = -1;\n        if (prev_visible_column_idx != -1)\n            table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;\n        else\n            table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;\n        column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;\n        ImBitArraySetBit(table->EnabledMaskByIndex, column_n);\n        ImBitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);\n        prev_visible_column_idx = column_n;\n        IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);\n\n        // Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)\n        // Combine width from regular rows + width from headers unless requested not to.\n        if (!column->IsPreserveWidthAuto && table->InstanceCurrent == 0)\n            column->WidthAuto = TableGetColumnWidthAuto(table, column);\n\n        // Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)\n        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;\n        if (column_is_resizable)\n            has_resizable = true;\n        if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)\n            column->WidthAuto = column->InitStretchWeightOrWidth;\n\n        if (column->AutoFitQueue != 0x00)\n            has_auto_fit_request = true;\n        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)\n        {\n            stretch_sum_width_auto += column->WidthAuto;\n            count_stretch++;\n        }\n        else\n        {\n            fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);\n            count_fixed++;\n        }\n    }\n    if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))\n        table->IsSortSpecsDirty = true;\n    table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;\n    IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);\n\n    // [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible to avoid\n    // the column fitting having to wait until the first visible frame of the child container (may or not be a good thing). Also see #6510.\n    // FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.\n    if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)\n        table->InnerWindow->SkipItems = false;\n    if (has_auto_fit_request)\n        table->IsSettingsDirty = true;\n\n    // [Part 3] Fix column flags and record a few extra information.\n    float sum_width_requests = 0.0f;    // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.\n    float stretch_sum_weights = 0.0f;   // Sum of all weights for stretch columns.\n    table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))\n            continue;\n        ImGuiTableColumn* column = &table->Columns[column_n];\n\n        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;\n        if (column->Flags & ImGuiTableColumnFlags_WidthFixed)\n        {\n            // Apply same widths policy\n            float width_auto = column->WidthAuto;\n            if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))\n                width_auto = fixed_max_width_auto;\n\n            // Apply automatic width\n            // Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)\n            if (column->AutoFitQueue != 0x00)\n                column->WidthRequest = width_auto;\n            else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && column->IsRequestOutput)\n                column->WidthRequest = width_auto;\n\n            // FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets\n            // (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very\n            // large height (= first frame scrollbar display very off + clipper would skip lots of items).\n            // This is merely making the side-effect less extreme, but doesn't properly fixes it.\n            // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?\n            // FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.\n            if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)\n                column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?\n            sum_width_requests += column->WidthRequest;\n        }\n        else\n        {\n            // Initialize stretch weight\n            if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable)\n            {\n                if (column->InitStretchWeightOrWidth > 0.0f)\n                    column->StretchWeight = column->InitStretchWeightOrWidth;\n                else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)\n                    column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;\n                else\n                    column->StretchWeight = 1.0f;\n            }\n\n            stretch_sum_weights += column->StretchWeight;\n            if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)\n                table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;\n            if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)\n                table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;\n        }\n        column->IsPreserveWidthAuto = false;\n        sum_width_requests += table->CellPaddingX * 2.0f;\n    }\n    table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;\n    table->ColumnsStretchSumWeights = stretch_sum_weights;\n\n    // [Part 4] Apply final widths based on requested widths\n    const ImRect work_rect = table->WorkRect;\n    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);\n    const float width_removed = (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY) ? g.Style.ScrollbarSize : 0.0f; // To synchronize decoration width of synched tables with mismatching scrollbar state (#5920)\n    const float width_avail = ImMax(1.0f, (((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth()) - width_removed);\n    const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;\n    float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;\n    table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))\n            continue;\n        ImGuiTableColumn* column = &table->Columns[column_n];\n\n        // Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)\n        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)\n        {\n            float weight_ratio = column->StretchWeight / stretch_sum_weights;\n            column->WidthRequest = IM_TRUNC(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);\n            width_remaining_for_stretched_columns -= column->WidthRequest;\n        }\n\n        // [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column\n        // See additional comments in TableSetColumnWidth().\n        if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)\n            column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;\n\n        // Assign final width, record width in case we will need to shrink\n        column->WidthGiven = ImTrunc(ImMax(column->WidthRequest, table->MinColumnWidth));\n        table->ColumnsGivenWidth += column->WidthGiven;\n    }\n\n    // [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).\n    // Using right-to-left distribution (more likely to match resizing cursor).\n    if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))\n        for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--)\n        {\n            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))\n                continue;\n            ImGuiTableColumn* column = &table->Columns[table->DisplayOrderToIndex[order_n]];\n            if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))\n                continue;\n            column->WidthRequest += 1.0f;\n            column->WidthGiven += 1.0f;\n            width_remaining_for_stretched_columns -= 1.0f;\n        }\n\n    // Determine if table is hovered which will be used to flag columns as hovered.\n    // - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),\n    //   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily\n    //   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).\n    // - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    table_instance->HoveredRowLast = table_instance->HoveredRowNext;\n    table_instance->HoveredRowNext = -1;\n    table->HoveredColumnBody = table->HoveredColumnBorder = -1;\n    const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table_instance->LastOuterHeight));\n    const ImGuiID backup_active_id = g.ActiveId;\n    g.ActiveId = 0;\n    const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0, ImGuiItemFlags_None);\n    g.ActiveId = backup_active_id;\n\n    // Determine skewed MousePos.x to support angled headers.\n    float mouse_skewed_x = g.IO.MousePos.x;\n    if (table->AngledHeadersHeight > 0.0f)\n        if (g.IO.MousePos.y >= table->OuterRect.Min.y && g.IO.MousePos.y <= table->OuterRect.Min.y + table->AngledHeadersHeight)\n            mouse_skewed_x += ImTrunc((table->OuterRect.Min.y + table->AngledHeadersHeight - g.IO.MousePos.y) * table->AngledHeadersSlope);\n\n    // [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column\n    // Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.\n    int visible_n = 0;\n    bool has_at_least_one_column_requesting_output = false;\n    bool offset_x_frozen = (table->FreezeColumnsCount > 0);\n    float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;\n    ImRect host_clip_rect = table->InnerClipRect;\n    //host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;\n    ImBitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);\n    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)\n    {\n        const int column_n = table->DisplayOrderToIndex[order_n];\n        ImGuiTableColumn* column = &table->Columns[column_n];\n\n        column->NavLayerCurrent = (ImS8)(table->FreezeRowsCount > 0 ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main); // Use Count NOT request so Header line changes layer when frozen\n\n        if (offset_x_frozen && table->FreezeColumnsCount == visible_n)\n        {\n            offset_x += work_rect.Min.x - table->OuterRect.Min.x;\n            offset_x_frozen = false;\n        }\n\n        // Clear status flags\n        column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;\n\n        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))\n        {\n            // Hidden column: clear a few fields and we are done with it for the remainder of the function.\n            // We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.\n            column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;\n            column->WidthGiven = 0.0f;\n            column->ClipRect.Min.y = work_rect.Min.y;\n            column->ClipRect.Max.y = FLT_MAX;\n            column->ClipRect.ClipWithFull(host_clip_rect);\n            column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;\n            column->IsSkipItems = true;\n            column->ItemWidth = 1.0f;\n            continue;\n        }\n\n        // Lock start position\n        column->MinX = offset_x;\n\n        // Lock width based on start position and minimum/maximum width for this position\n        column->WidthMax = TableCalcMaxColumnWidth(table, column_n);\n        column->WidthGiven = ImMin(column->WidthGiven, column->WidthMax);\n        column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));\n        column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;\n\n        // Lock other positions\n        // - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.\n        // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.\n        // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.\n        // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.\n        const float previous_instance_work_min_x = column->WorkMinX;\n        column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;\n        column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max\n        column->ItemWidth = ImTrunc(column->WidthGiven * 0.65f);\n        column->ClipRect.Min.x = column->MinX;\n        column->ClipRect.Min.y = work_rect.Min.y;\n        column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;\n        column->ClipRect.Max.y = FLT_MAX;\n        column->ClipRect.ClipWithFull(host_clip_rect);\n\n        // Mark column as Clipped (not in sight)\n        // Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.\n        // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.\n        // Taking advantage of LastOuterHeight would yield good results there...\n        // FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,\n        // and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).\n        // Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.\n        column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);\n        column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);\n        const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;\n        if (is_visible)\n            ImBitArraySetBit(table->VisibleMaskByIndex, column_n);\n\n        // Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.\n        column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;\n\n        // Mark column as SkipItems (ignoring all items/layout)\n        // (table->HostSkipItems is a copy of inner_window->SkipItems before we cleared it above in Part 2)\n        column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;\n        if (column->IsSkipItems)\n            IM_ASSERT(!is_visible);\n        if (column->IsRequestOutput && !column->IsSkipItems)\n            has_at_least_one_column_requesting_output = true;\n\n        // Update status flags\n        column->Flags |= ImGuiTableColumnFlags_IsEnabled;\n        if (is_visible)\n            column->Flags |= ImGuiTableColumnFlags_IsVisible;\n        if (column->SortOrder != -1)\n            column->Flags |= ImGuiTableColumnFlags_IsSorted;\n\n        // Detect hovered column\n        if (is_hovering_table && mouse_skewed_x >= column->ClipRect.Min.x && mouse_skewed_x < column->ClipRect.Max.x)\n        {\n            column->Flags |= ImGuiTableColumnFlags_IsHovered;\n            table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;\n        }\n\n        // Alignment\n        // FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in\n        // many cases (to be able to honor this we might be able to store a log of cells width, per row, for\n        // visible rows, but nav/programmatic scroll would have visible artifacts.)\n        //if (column->Flags & ImGuiTableColumnFlags_AlignRight)\n        //    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);\n        //else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)\n        //    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);\n\n        // Reset content width variables\n        if (table->InstanceCurrent == 0)\n        {\n            column->ContentMaxXFrozen = column->WorkMinX;\n            column->ContentMaxXUnfrozen = column->WorkMinX;\n            column->ContentMaxXHeadersUsed = column->WorkMinX;\n            column->ContentMaxXHeadersIdeal = column->WorkMinX;\n        }\n        else\n        {\n            // As we store an absolute value to make per-cell updates faster, we need to offset values used for width computation.\n            const float offset_from_previous_instance = column->WorkMinX - previous_instance_work_min_x;\n            column->ContentMaxXFrozen += offset_from_previous_instance;\n            column->ContentMaxXUnfrozen += offset_from_previous_instance;\n            column->ContentMaxXHeadersUsed += offset_from_previous_instance;\n            column->ContentMaxXHeadersIdeal += offset_from_previous_instance;\n        }\n\n        // Don't decrement auto-fit counters until container window got a chance to submit its items\n        if (table->HostSkipItems == false && table->InstanceCurrent == 0)\n        {\n            column->AutoFitQueue >>= 1;\n            column->CannotSkipItemsQueue >>= 1;\n        }\n\n        if (visible_n < table->FreezeColumnsCount)\n            host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);\n\n        offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;\n        visible_n++;\n    }\n\n    // In case the table is visible (e.g. decorations) but all columns clipped, we keep a column visible.\n    // Else if give no chance to a clipper-savy user to submit rows and therefore total contents height used by scrollbar.\n    if (has_at_least_one_column_requesting_output == false)\n    {\n        table->Columns[table->LeftMostEnabledColumn].IsRequestOutput = true;\n        table->Columns[table->LeftMostEnabledColumn].IsSkipItems = false;\n    }\n\n    // [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)\n    // Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either\n    // because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.\n    const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);\n    if (is_hovering_table && table->HoveredColumnBody == -1)\n        if (mouse_skewed_x >= unused_x1)\n            table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;\n    if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))\n        table->Flags &= ~ImGuiTableFlags_Resizable;\n\n    table->IsActiveIdAliveBeforeTable = (g.ActiveIdIsAlive != 0);\n\n    // [Part 8] Lock actual OuterRect/WorkRect right-most position.\n    // This is done late to handle the case of fixed-columns tables not claiming more widths that they need.\n    // Because of this we are careful with uses of WorkRect and InnerClipRect before this point.\n    if (table->RightMostStretchedColumn != -1)\n        table->Flags &= ~ImGuiTableFlags_NoHostExtendX;\n    if (table->Flags & ImGuiTableFlags_NoHostExtendX)\n    {\n        table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;\n        table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);\n    }\n    table->InnerWindow->ParentWorkRect = table->WorkRect;\n    table->BorderX1 = table->InnerClipRect.Min.x;\n    table->BorderX2 = table->InnerClipRect.Max.x;\n\n    // Setup window's WorkRect.Max.y for GetContentRegionAvail(). Other values will be updated in each TableBeginCell() call.\n    float window_content_max_y;\n    if (table->Flags & ImGuiTableFlags_NoHostExtendY)\n        window_content_max_y = table->OuterRect.Max.y;\n    else\n        window_content_max_y = ImMax(table->InnerWindow->ContentRegionRect.Max.y, (table->Flags & ImGuiTableFlags_ScrollY) ? 0.0f : table->OuterRect.Max.y);\n    table->InnerWindow->WorkRect.Max.y = ImClamp(window_content_max_y - g.Style.CellPadding.y, table->InnerWindow->WorkRect.Min.y, table->InnerWindow->WorkRect.Max.y);\n\n    // [Part 9] Allocate draw channels and setup background cliprect\n    TableSetupDrawChannels(table);\n\n    // [Part 10] Hit testing on borders\n    if (table->Flags & ImGuiTableFlags_Resizable)\n        TableUpdateBorders(table);\n    table_instance->LastTopHeadersRowHeight = 0.0f;\n    table->IsLayoutLocked = true;\n    table->IsUsingHeaders = false;\n\n    // Highlight header\n    table->HighlightColumnHeader = -1;\n    if (table->IsContextPopupOpen && table->ContextPopupColumn != -1 && table->InstanceInteracted == table->InstanceCurrent)\n        table->HighlightColumnHeader = table->ContextPopupColumn;\n    else if ((table->Flags & ImGuiTableFlags_HighlightHoveredColumn) && table->HoveredColumnBody != -1 && table->HoveredColumnBody != table->ColumnsCount && table->HoveredColumnBorder == -1)\n        if (g.ActiveId == 0 || (table->IsActiveIdInTable || g.DragDropActive))\n            table->HighlightColumnHeader = table->HoveredColumnBody;\n\n    // [Part 11] Default context menu\n    // - To append to this menu: you can call TableBeginContextMenuPopup()/.../EndPopup().\n    // - To modify or replace this: set table->IsContextPopupNoDefaultContents = true, then call TableBeginContextMenuPopup()/.../EndPopup().\n    // - You may call TableDrawDefaultContextMenu() with selected flags to display specific sections of the default menu,\n    //   e.g. TableDrawDefaultContextMenu(table, table->Flags & ~ImGuiTableFlags_Hideable) will display everything EXCEPT columns visibility options.\n    if (table->DisableDefaultContextMenu == false && TableBeginContextMenuPopup(table))\n    {\n        TableDrawDefaultContextMenu(table, table->Flags);\n        EndPopup();\n    }\n\n    // [Part 12] Sanitize and build sort specs before we have a chance to use them for display.\n    // This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)\n    if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))\n        TableSortSpecsBuild(table);\n\n    // [Part 13] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)\n    if (table->FreezeColumnsRequest > 0)\n        table->InnerWindow->DecoInnerSizeX1 = table->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest - 1]].MaxX - table->OuterRect.Min.x;\n    if (table->FreezeRowsRequest > 0)\n        table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;\n    table_instance->LastFrozenHeight = 0.0f;\n\n    // Initial state\n    ImGuiWindow* inner_window = table->InnerWindow;\n    if (table->Flags & ImGuiTableFlags_NoClip)\n        table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);\n    else\n        inner_window->DrawList->PushClipRect(inner_window->InnerClipRect.Min, inner_window->InnerClipRect.Max, false); // FIXME: use table->InnerClipRect?\n}\n\n// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()\n// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual feedback noise.\nvoid ImGui::TableUpdateBorders(ImGuiTable* table)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);\n\n    // At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and\n    // use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not\n    // really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).\n    // Actual columns highlight/render will be performed in EndTable() and not be affected.\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    const float hit_half_width = ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale);\n    const float hit_y1 = (table->FreezeRowsCount >= 1 ? table->OuterRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight;\n    const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight - table->AngledHeadersHeight);\n    const float hit_y2_head = hit_y1 + table_instance->LastTopHeadersRowHeight;\n\n    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)\n    {\n        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))\n            continue;\n\n        const int column_n = table->DisplayOrderToIndex[order_n];\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))\n            continue;\n\n        // ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()\n        const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;\n        if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)\n            continue;\n\n        if (!column->IsVisibleX && table->LastResizedColumn != column_n)\n            continue;\n\n        ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);\n        ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);\n        ItemAdd(hit_rect, column_id, NULL, ImGuiItemFlags_NoNav);\n        //GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));\n\n        bool hovered = false, held = false;\n        bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_NoNavFocus);\n        if (pressed && IsMouseDoubleClicked(0))\n        {\n            TableSetColumnWidthAutoSingle(table, column_n);\n            ClearActiveID();\n            held = false;\n        }\n        if (held)\n        {\n            if (table->LastResizedColumn == -1)\n                table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;\n            table->ResizedColumn = (ImGuiTableColumnIdx)column_n;\n            table->InstanceInteracted = table->InstanceCurrent;\n        }\n        if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held)\n        {\n            table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;\n            SetMouseCursor(ImGuiMouseCursor_ResizeEW);\n        }\n    }\n}\n\nvoid    ImGui::EndTable()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL && \"Only call EndTable() if BeginTable() returns true!\");\n\n    // This assert would be very useful to catch a common error... unfortunately it would probably trigger in some\n    // cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)\n    //IM_ASSERT(table->IsLayoutLocked && \"Table unused: never called TableNextRow(), is that the intent?\");\n\n    // If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our\n    // code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.\n    if (!table->IsLayoutLocked)\n        TableUpdateLayout(table);\n\n    const ImGuiTableFlags flags = table->Flags;\n    ImGuiWindow* inner_window = table->InnerWindow;\n    ImGuiWindow* outer_window = table->OuterWindow;\n    ImGuiTableTempData* temp_data = table->TempData;\n    IM_ASSERT(inner_window == g.CurrentWindow);\n    IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);\n\n    if (table->IsInsideRow)\n        TableEndRow(table);\n\n    // Context menu in columns body\n    if (flags & ImGuiTableFlags_ContextMenuInBody)\n        if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))\n            TableOpenContextMenu((int)table->HoveredColumnBody);\n\n    // Finalize table height\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;\n    inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;\n    inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;\n    const float inner_content_max_y = table->RowPosY2;\n    IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);\n    if (inner_window != outer_window)\n        inner_window->DC.CursorMaxPos.y = inner_content_max_y;\n    else if (!(flags & ImGuiTableFlags_NoHostExtendY))\n        table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height\n    table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);\n    table_instance->LastOuterHeight = table->OuterRect.GetHeight();\n\n    // Setup inner scrolling range\n    // FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,\n    // but since the later is likely to be impossible to do we'd rather update both axises together.\n    if (table->Flags & ImGuiTableFlags_ScrollX)\n    {\n        const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;\n        float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;\n        if (table->RightMostEnabledColumn != -1)\n            max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);\n        if (table->ResizedColumn != -1)\n            max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);\n        table->InnerWindow->DC.CursorMaxPos.x = max_pos_x + table->TempData->AngledHeadersExtraWidth;\n    }\n\n    // Pop clipping rect\n    if (!(flags & ImGuiTableFlags_NoClip))\n        inner_window->DrawList->PopClipRect();\n    inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();\n\n    // Draw borders\n    if ((flags & ImGuiTableFlags_Borders) != 0)\n        TableDrawBorders(table);\n\n#if 0\n    // Strip out dummy channel draw calls\n    // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)\n    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.\n    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.\n    if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)\n    {\n        ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];\n        dummy_channel->_CmdBuffer.resize(0);\n        dummy_channel->_IdxBuffer.resize(0);\n    }\n#endif\n\n    // Flatten channels and merge draw calls\n    ImDrawListSplitter* splitter = table->DrawSplitter;\n    splitter->SetCurrentChannel(inner_window->DrawList, 0);\n    if ((table->Flags & ImGuiTableFlags_NoClip) == 0)\n        TableMergeDrawChannels(table);\n    splitter->Merge(inner_window->DrawList);\n\n    // Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()\n    float auto_fit_width_for_fixed = 0.0f;\n    float auto_fit_width_for_stretched = 0.0f;\n    float auto_fit_width_for_stretched_min = 0.0f;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))\n        {\n            ImGuiTableColumn* column = &table->Columns[column_n];\n            float column_width_request = ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize)) ? column->WidthRequest : TableGetColumnWidthAuto(table, column);\n            if (column->Flags & ImGuiTableColumnFlags_WidthFixed)\n                auto_fit_width_for_fixed += column_width_request;\n            else\n                auto_fit_width_for_stretched += column_width_request;\n            if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) && (column->Flags & ImGuiTableColumnFlags_NoResize) != 0)\n                auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column->StretchWeight / table->ColumnsStretchSumWeights));\n        }\n    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);\n    table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);\n\n    // Update scroll\n    if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window)\n    {\n        inner_window->Scroll.x = 0.0f;\n    }\n    else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent)\n    {\n        // When releasing a column being resized, scroll to keep the resulting column in sight\n        const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;\n        ImGuiTableColumn* column = &table->Columns[table->LastResizedColumn];\n        if (column->MaxX < table->InnerClipRect.Min.x)\n            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);\n        else if (column->MaxX > table->InnerClipRect.Max.x)\n            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);\n    }\n\n    // Apply resizing/dragging at the end of the frame\n    if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted)\n    {\n        ImGuiTableColumn* column = &table->Columns[table->ResizedColumn];\n        const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale));\n        const float new_width = ImTrunc(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);\n        table->ResizedColumnNextWidth = new_width;\n    }\n\n    table->IsActiveIdInTable = (g.ActiveIdIsAlive != 0 && table->IsActiveIdAliveBeforeTable == false);\n\n    // Pop from id stack\n    IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table_instance->TableInstanceID, \"Mismatching PushID/PopID!\");\n    IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, \"Too many PopItemWidth!\");\n    if (table->InstanceCurrent > 0)\n        PopID();\n    PopID();\n\n    // Restore window data that we modified\n    const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;\n    inner_window->WorkRect = temp_data->HostBackupWorkRect;\n    inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;\n    inner_window->SkipItems = table->HostSkipItems;\n    outer_window->DC.CursorPos = table->OuterRect.Min;\n    outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;\n    outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;\n    outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;\n\n    // Layout in outer window\n    // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding\n    // CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)\n    if (inner_window != outer_window)\n    {\n        short backup_nav_layers_active_mask = inner_window->DC.NavLayersActiveMask;\n        inner_window->DC.NavLayersActiveMask |= 1 << ImGuiNavLayer_Main; // So empty table don't appear to navigate differently.\n        g.CurrentTable = NULL; // To avoid error recovery recursing\n        EndChild();\n        g.CurrentTable = table;\n        inner_window->DC.NavLayersActiveMask = backup_nav_layers_active_mask;\n    }\n    else\n    {\n        ItemSize(table->OuterRect.GetSize());\n        ItemAdd(table->OuterRect, 0);\n    }\n\n    // Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar\n    if (table->Flags & ImGuiTableFlags_NoHostExtendX)\n    {\n        // FIXME-TABLE: Could we remove this section?\n        // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents\n        IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);\n        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);\n    }\n    else if (temp_data->UserOuterSize.x <= 0.0f)\n    {\n        // Some references for this: #7651 + tests \"table_reported_size\", \"table_reported_size_outer\" equivalent Y block\n        // - Checking for ImGuiTableFlags_ScrollX/ScrollY flag makes us a frame ahead when disabling those flags.\n        // - FIXME-TABLE: Would make sense to pre-compute expected scrollbar visibility/sizes to generally save a frame of feedback.\n        const float inner_content_max_x = table->OuterRect.Min.x + table->ColumnsAutoFitWidth; // Slightly misleading name but used for code symmetry with inner_content_max_y\n        const float decoration_size = table->TempData->AngledHeadersExtraWidth + ((table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.x : 0.0f);\n        outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, inner_content_max_x + decoration_size - temp_data->UserOuterSize.x);\n        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, inner_content_max_x + decoration_size));\n    }\n    else\n    {\n        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);\n    }\n    if (temp_data->UserOuterSize.y <= 0.0f)\n    {\n        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.y : 0.0f;\n        outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);\n        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y + decoration_size));\n    }\n    else\n    {\n        // OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)\n        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);\n    }\n\n    // Save settings\n    if (table->IsSettingsDirty)\n        TableSaveSettings(table);\n    table->IsInitializing = false;\n\n    // Clear or restore current table, if any\n    IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);\n    IM_ASSERT(g.TablesTempDataStacked > 0);\n    temp_data = (--g.TablesTempDataStacked > 0) ? &g.TablesTempData[g.TablesTempDataStacked - 1] : NULL;\n    g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;\n    if (g.CurrentTable)\n    {\n        g.CurrentTable->TempData = temp_data;\n        g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;\n    }\n    outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;\n    NavUpdateCurrentWindowIsScrollPushableX();\n}\n\n// See \"COLUMNS SIZING POLICIES\" comments at the top of this file\n// If (init_width_or_weight <= 0.0f) it is ignored\nvoid ImGui::TableSetupColumn(const char* label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL && \"Need to call TableSetupColumn() after BeginTable()!\");\n    IM_ASSERT(table->IsLayoutLocked == false && \"Need to call call TableSetupColumn() before first row!\");\n    IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && \"Illegal to pass StatusMask values to TableSetupColumn()\");\n    if (table->DeclColumnsCount >= table->ColumnsCount)\n    {\n        IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, \"Called TableSetupColumn() too many times!\");\n        return;\n    }\n\n    ImGuiTableColumn* column = &table->Columns[table->DeclColumnsCount];\n    table->DeclColumnsCount++;\n\n    // Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.\n    // Give a grace to users of ImGuiTableFlags_ScrollX.\n    if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)\n        IM_ASSERT(init_width_or_weight <= 0.0f && \"Can only specify width/weight if sizing policy is set explicitly in either Table or Column.\");\n\n    // When passing a width automatically enforce WidthFixed policy\n    // (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)\n    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)\n        if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)\n            flags |= ImGuiTableColumnFlags_WidthFixed;\n    if (flags & ImGuiTableColumnFlags_AngledHeader)\n    {\n        flags |= ImGuiTableColumnFlags_NoHeaderLabel;\n        table->AngledHeadersCount++;\n    }\n\n    TableSetupColumnFlags(table, column, flags);\n    column->UserID = user_id;\n    flags = column->Flags;\n\n    // Initialize defaults\n    column->InitStretchWeightOrWidth = init_width_or_weight;\n    if (table->IsInitializing)\n    {\n        // Init width or weight\n        if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f)\n        {\n            if ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)\n                column->WidthRequest = init_width_or_weight;\n            if (flags & ImGuiTableColumnFlags_WidthStretch)\n                column->StretchWeight = (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;\n\n            // Disable auto-fit if an explicit width/weight has been specified\n            if (init_width_or_weight > 0.0f)\n                column->AutoFitQueue = 0x00;\n        }\n\n        // Init default visibility/sort state\n        if ((flags & ImGuiTableColumnFlags_DefaultHide) && (table->SettingsLoadedFlags & ImGuiTableFlags_Hideable) == 0)\n            column->IsUserEnabled = column->IsUserEnabledNextFrame = false;\n        if (flags & ImGuiTableColumnFlags_DefaultSort && (table->SettingsLoadedFlags & ImGuiTableFlags_Sortable) == 0)\n        {\n            column->SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.\n            column->SortDirection = (column->Flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending);\n        }\n    }\n\n    // Store name (append with zero-terminator in contiguous buffer)\n    // FIXME: If we recorded the number of \\n in names we could compute header row height\n    column->NameOffset = -1;\n    if (label != NULL && label[0] != 0)\n    {\n        column->NameOffset = (ImS16)table->ColumnsNames.size();\n        table->ColumnsNames.append(label, label + strlen(label) + 1);\n    }\n}\n\n// [Public]\nvoid ImGui::TableSetupScrollFreeze(int columns, int rows)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL && \"Need to call TableSetupColumn() after BeginTable()!\");\n    IM_ASSERT(table->IsLayoutLocked == false && \"Need to call TableSetupColumn() before first row!\");\n    IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);\n    IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit\n\n    table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;\n    table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;\n    table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;\n    table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;\n    table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b\n\n    // Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.\n    // FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)\n    for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++)\n    {\n        int order_n = table->DisplayOrderToIndex[column_n];\n        if (order_n != column_n && order_n >= table->FreezeColumnsRequest)\n        {\n            ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);\n            ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// [SECTION] Tables: Simple accessors\n//-----------------------------------------------------------------------------\n// - TableGetColumnCount()\n// - TableGetColumnName()\n// - TableGetColumnName() [Internal]\n// - TableSetColumnEnabled()\n// - TableGetColumnFlags()\n// - TableGetCellBgRect() [Internal]\n// - TableGetColumnResizeID() [Internal]\n// - TableGetHoveredColumn() [Internal]\n// - TableGetHoveredRow() [Internal]\n// - TableSetBgColor()\n//-----------------------------------------------------------------------------\n\nint ImGui::TableGetColumnCount()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    return table ? table->ColumnsCount : 0;\n}\n\nconst char* ImGui::TableGetColumnName(int column_n)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return NULL;\n    if (column_n < 0)\n        column_n = table->CurrentColumn;\n    return TableGetColumnName(table, column_n);\n}\n\nconst char* ImGui::TableGetColumnName(const ImGuiTable* table, int column_n)\n{\n    if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)\n        return \"\"; // NameOffset is invalid at this point\n    const ImGuiTableColumn* column = &table->Columns[column_n];\n    if (column->NameOffset == -1)\n        return \"\";\n    return &table->ColumnsNames.Buf[column->NameOffset];\n}\n\n// Change user accessible enabled/disabled state of a column (often perceived as \"showing/hiding\" from users point of view)\n// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)\n// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.\n// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().\n// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.\n// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.\nvoid ImGui::TableSetColumnEnabled(int column_n, bool enabled)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL);\n    if (!table)\n        return;\n    IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above\n    if (column_n < 0)\n        column_n = table->CurrentColumn;\n    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);\n    ImGuiTableColumn* column = &table->Columns[column_n];\n    column->IsUserEnabledNextFrame = enabled;\n}\n\n// We allow querying for an extra column in order to poll the IsHovered state of the right-most section\nImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return ImGuiTableColumnFlags_None;\n    if (column_n < 0)\n        column_n = table->CurrentColumn;\n    if (column_n == table->ColumnsCount)\n        return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;\n    return table->Columns[column_n].Flags;\n}\n\n// Return the cell rectangle based on currently known height.\n// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.\n//   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it, or in TableEndRow() when we locked that height.\n// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right\n//   columns report a small offset so their CellBgRect can extend up to the outer border.\n//   FIXME: But the rendering code in TableEndRow() nullifies that with clamping required for scrolling.\nImRect ImGui::TableGetCellBgRect(const ImGuiTable* table, int column_n)\n{\n    const ImGuiTableColumn* column = &table->Columns[column_n];\n    float x1 = column->MinX;\n    float x2 = column->MaxX;\n    //if (column->PrevEnabledColumn == -1)\n    //    x1 -= table->OuterPaddingX;\n    //if (column->NextEnabledColumn == -1)\n    //    x2 += table->OuterPaddingX;\n    x1 = ImMax(x1, table->WorkRect.Min.x);\n    x2 = ImMin(x2, table->WorkRect.Max.x);\n    return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);\n}\n\n// Return the resizing ID for the right-side of the given column.\nImGuiID ImGui::TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no)\n{\n    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);\n    ImGuiID instance_id = TableGetInstanceID(table, instance_no);\n    return instance_id + 1 + column_n; // FIXME: #6140: still not ideal\n}\n\n// Return -1 when table is not hovered. return columns_count if hovering the unused space at the right of the right-most visible column.\nint ImGui::TableGetHoveredColumn()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return -1;\n    return (int)table->HoveredColumnBody;\n}\n\n// Return -1 when table is not hovered. Return maxrow+1 if in table but below last submitted row.\n// *IMPORTANT* Unlike TableGetHoveredColumn(), this has a one frame latency in updating the value.\n// This difference with is the reason why this is not public yet.\nint ImGui::TableGetHoveredRow()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return -1;\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    return (int)table_instance->HoveredRowLast;\n}\n\nvoid ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(target != ImGuiTableBgTarget_None);\n\n    if (color == IM_COL32_DISABLE)\n        color = 0;\n\n    // We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.\n    switch (target)\n    {\n    case ImGuiTableBgTarget_CellBg:\n    {\n        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard\n            return;\n        if (column_n == -1)\n            column_n = table->CurrentColumn;\n        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))\n            return;\n        if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)\n            table->RowCellDataCurrent++;\n        ImGuiTableCellData* cell_data = &table->RowCellData[table->RowCellDataCurrent];\n        cell_data->BgColor = color;\n        cell_data->Column = (ImGuiTableColumnIdx)column_n;\n        break;\n    }\n    case ImGuiTableBgTarget_RowBg0:\n    case ImGuiTableBgTarget_RowBg1:\n    {\n        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard\n            return;\n        IM_ASSERT(column_n == -1);\n        int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;\n        table->RowBgColor[bg_idx] = color;\n        break;\n    }\n    default:\n        IM_ASSERT(0);\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Row changes\n//-------------------------------------------------------------------------\n// - TableGetRowIndex()\n// - TableNextRow()\n// - TableBeginRow() [Internal]\n// - TableEndRow() [Internal]\n//-------------------------------------------------------------------------\n\n// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows\nint ImGui::TableGetRowIndex()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return 0;\n    return table->CurrentRow;\n}\n\n// [Public] Starts into the first cell of a new row\nvoid ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n\n    if (!table->IsLayoutLocked)\n        TableUpdateLayout(table);\n    if (table->IsInsideRow)\n        TableEndRow(table);\n\n    table->LastRowFlags = table->RowFlags;\n    table->RowFlags = row_flags;\n    table->RowCellPaddingY = g.Style.CellPadding.y;\n    table->RowMinHeight = row_min_height;\n    TableBeginRow(table);\n\n    // We honor min_row_height requested by user, but cannot guarantee per-row maximum height,\n    // because that would essentially require a unique clipping rectangle per-cell.\n    table->RowPosY2 += table->RowCellPaddingY * 2.0f;\n    table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);\n\n    // Disable output until user calls TableNextColumn()\n    table->InnerWindow->SkipItems = true;\n}\n\n// [Internal] Only called by TableNextRow()\nvoid ImGui::TableBeginRow(ImGuiTable* table)\n{\n    ImGuiWindow* window = table->InnerWindow;\n    IM_ASSERT(!table->IsInsideRow);\n\n    // New row\n    table->CurrentRow++;\n    table->CurrentColumn = -1;\n    table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;\n    table->RowCellDataCurrent = -1;\n    table->IsInsideRow = true;\n\n    // Begin frozen rows\n    float next_y1 = table->RowPosY2;\n    if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)\n        next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;\n\n    table->RowPosY1 = table->RowPosY2 = next_y1;\n    table->RowTextBaseline = 0.0f;\n    table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent\n\n    window->DC.PrevLineTextBaseOffset = 0.0f;\n    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + table->RowCellPaddingY); // This allows users to call SameLine() to share LineSize between columns.\n    window->DC.PrevLineSize = window->DC.CurrLineSize = ImVec2(0.0f, 0.0f); // This allows users to call SameLine() to share LineSize between columns, and to call it from first column too.\n    window->DC.IsSameLine = window->DC.IsSetPos = false;\n    window->DC.CursorMaxPos.y = next_y1;\n\n    // Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.\n    if (table->RowFlags & ImGuiTableRowFlags_Headers)\n    {\n        TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));\n        if (table->CurrentRow == 0)\n            table->IsUsingHeaders = true;\n    }\n}\n\n// [Internal] Called by TableNextRow()\nvoid ImGui::TableEndRow(ImGuiTable* table)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT(window == table->InnerWindow);\n    IM_ASSERT(table->IsInsideRow);\n\n    if (table->CurrentColumn != -1)\n        TableEndCell(table);\n\n    // Logging\n    if (g.LogEnabled)\n        LogRenderedText(NULL, \"|\");\n\n    // Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is\n    // likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.\n    window->DC.CursorPos.y = table->RowPosY2;\n\n    // Row background fill\n    const float bg_y1 = table->RowPosY1;\n    const float bg_y2 = table->RowPosY2;\n    const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);\n    const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    if ((table->RowFlags & ImGuiTableRowFlags_Headers) && (table->CurrentRow == 0 || (table->LastRowFlags & ImGuiTableRowFlags_Headers)))\n        table_instance->LastTopHeadersRowHeight += bg_y2 - bg_y1;\n\n    const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);\n    if (is_visible)\n    {\n        // Update data for TableGetHoveredRow()\n        if (table->HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 && g.IO.MousePos.y < bg_y2 && table_instance->HoveredRowNext < 0)\n            table_instance->HoveredRowNext = table->CurrentRow;\n\n        // Decide of background color for the row\n        ImU32 bg_col0 = 0;\n        ImU32 bg_col1 = 0;\n        if (table->RowBgColor[0] != IM_COL32_DISABLE)\n            bg_col0 = table->RowBgColor[0];\n        else if (table->Flags & ImGuiTableFlags_RowBg)\n            bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);\n        if (table->RowBgColor[1] != IM_COL32_DISABLE)\n            bg_col1 = table->RowBgColor[1];\n\n        // Decide of top border color\n        ImU32 top_border_col = 0;\n        const float border_size = TABLE_BORDER_SIZE;\n        if (table->CurrentRow > 0 && (table->Flags & ImGuiTableFlags_BordersInnerH))\n            top_border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;\n\n        const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;\n        const bool draw_strong_bottom_border = unfreeze_rows_actual;\n        if ((bg_col0 | bg_col1 | top_border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)\n        {\n            // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is\n            // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.\n            if ((table->Flags & ImGuiTableFlags_NoClip) == 0)\n                window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();\n            table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);\n        }\n\n        // Draw row background\n        // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle\n        if (bg_col0 || bg_col1)\n        {\n            ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);\n            row_rect.ClipWith(table->BgClipRect);\n            if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)\n                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);\n            if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)\n                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);\n        }\n\n        // Draw cell background color\n        if (draw_cell_bg_color)\n        {\n            ImGuiTableCellData* cell_data_end = &table->RowCellData[table->RowCellDataCurrent];\n            for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)\n            {\n                // As we render the BG here we need to clip things (for layout we would not)\n                // FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.\n                const ImGuiTableColumn* column = &table->Columns[cell_data->Column];\n                ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);\n                cell_bg_rect.ClipWith(table->BgClipRect);\n                cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped when scrolling\n                cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);\n                if (cell_bg_rect.Min.y < cell_bg_rect.Max.y)\n                    window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);\n            }\n        }\n\n        // Draw top border\n        if (top_border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)\n            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), top_border_col, border_size);\n\n        // Draw bottom border at the row unfreezing mark (always strong)\n        if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)\n            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);\n    }\n\n    // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)\n    // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and\n    // get the new cursor position.\n    if (unfreeze_rows_request)\n    {\n        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n            table->Columns[column_n].NavLayerCurrent = ImGuiNavLayer_Main;\n        const float y0 = ImMax(table->RowPosY2 + 1, table->InnerClipRect.Min.y);\n        table_instance->LastFrozenHeight = y0 - table->OuterRect.Min.y;\n\n        if (unfreeze_rows_actual)\n        {\n            IM_ASSERT(table->IsUnfrozenRows == false);\n            table->IsUnfrozenRows = true;\n\n            // BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect\n            table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, table->InnerClipRect.Max.y);\n            table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = table->InnerClipRect.Max.y;\n            table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;\n            IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);\n\n            float row_height = table->RowPosY2 - table->RowPosY1;\n            table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;\n            table->RowPosY1 = table->RowPosY2 - row_height;\n            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n            {\n                ImGuiTableColumn* column = &table->Columns[column_n];\n                column->DrawChannelCurrent = column->DrawChannelUnfrozen;\n                column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;\n            }\n\n            // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y\n            SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);\n            table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);\n        }\n    }\n\n    if (!(table->RowFlags & ImGuiTableRowFlags_Headers))\n        table->RowBgColorCounter++;\n    table->IsInsideRow = false;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Columns changes\n//-------------------------------------------------------------------------\n// - TableGetColumnIndex()\n// - TableSetColumnIndex()\n// - TableNextColumn()\n// - TableBeginCell() [Internal]\n// - TableEndCell() [Internal]\n//-------------------------------------------------------------------------\n\nint ImGui::TableGetColumnIndex()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return 0;\n    return table->CurrentColumn;\n}\n\n// [Public] Append into a specific column\nbool ImGui::TableSetColumnIndex(int column_n)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return false;\n\n    if (table->CurrentColumn != column_n)\n    {\n        if (table->CurrentColumn != -1)\n            TableEndCell(table);\n        IM_ASSERT(column_n >= 0 && table->ColumnsCount);\n        TableBeginCell(table, column_n);\n    }\n\n    // Return whether the column is visible. User may choose to skip submitting items based on this return value,\n    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.\n    return table->Columns[column_n].IsRequestOutput;\n}\n\n// [Public] Append into the next column, wrap and create a new row when already on last column\nbool ImGui::TableNextColumn()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (!table)\n        return false;\n\n    if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount)\n    {\n        if (table->CurrentColumn != -1)\n            TableEndCell(table);\n        TableBeginCell(table, table->CurrentColumn + 1);\n    }\n    else\n    {\n        TableNextRow();\n        TableBeginCell(table, 0);\n    }\n\n    // Return whether the column is visible. User may choose to skip submitting items based on this return value,\n    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.\n    return table->Columns[table->CurrentColumn].IsRequestOutput;\n}\n\n\n// [Internal] Called by TableSetColumnIndex()/TableNextColumn()\n// This is called very frequently, so we need to be mindful of unnecessary overhead.\n// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.\nvoid ImGui::TableBeginCell(ImGuiTable* table, int column_n)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTableColumn* column = &table->Columns[column_n];\n    ImGuiWindow* window = table->InnerWindow;\n    table->CurrentColumn = column_n;\n\n    // Start position is roughly ~~ CellRect.Min + CellPadding + Indent\n    float start_x = column->WorkMinX;\n    if (column->Flags & ImGuiTableColumnFlags_IndentEnable)\n        start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.\n\n    window->DC.CursorPos.x = start_x;\n    window->DC.CursorPos.y = table->RowPosY1 + table->RowCellPaddingY;\n    window->DC.CursorMaxPos.x = window->DC.CursorPos.x;\n    window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT\n    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x; // PrevLine.y is preserved. This allows users to call SameLine() to share LineSize between columns.\n    window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;\n    window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;\n\n    // Note how WorkRect.Max.y is only set once during layout\n    window->WorkRect.Min.y = window->DC.CursorPos.y;\n    window->WorkRect.Min.x = column->WorkMinX;\n    window->WorkRect.Max.x = column->WorkMaxX;\n    window->DC.ItemWidth = column->ItemWidth;\n\n    window->SkipItems = column->IsSkipItems;\n    if (column->IsSkipItems)\n    {\n        g.LastItemData.ID = 0;\n        g.LastItemData.StatusFlags = 0;\n    }\n\n    if (table->Flags & ImGuiTableFlags_NoClip)\n    {\n        // FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.\n        table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);\n        //IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);\n    }\n    else\n    {\n        // FIXME-TABLE: Could avoid this if draw channel is dummy channel?\n        SetWindowClipRectBeforeSetChannel(window, column->ClipRect);\n        table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);\n    }\n\n    // Logging\n    if (g.LogEnabled && !column->IsSkipItems)\n    {\n        LogRenderedText(&window->DC.CursorPos, \"|\");\n        g.LogLinePosY = FLT_MAX;\n    }\n}\n\n// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()\nvoid ImGui::TableEndCell(ImGuiTable* table)\n{\n    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];\n    ImGuiWindow* window = table->InnerWindow;\n\n    if (window->DC.IsSetPos)\n        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();\n\n    // Report maximum position so we can infer content size per column.\n    float* p_max_pos_x;\n    if (table->RowFlags & ImGuiTableRowFlags_Headers)\n        p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call\n    else\n        p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;\n    *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);\n    if (column->IsEnabled)\n        table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->RowCellPaddingY);\n    column->ItemWidth = window->DC.ItemWidth;\n\n    // Propagate text baseline for the entire row\n    // FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.\n    table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Columns width management\n//-------------------------------------------------------------------------\n// - TableGetMaxColumnWidth() [Internal]\n// - TableGetColumnWidthAuto() [Internal]\n// - TableSetColumnWidth()\n// - TableSetColumnWidthAutoSingle() [Internal]\n// - TableSetColumnWidthAutoAll() [Internal]\n// - TableUpdateColumnsWeightFromWidth() [Internal]\n//-------------------------------------------------------------------------\n// Note that actual columns widths are computed in TableUpdateLayout().\n//-------------------------------------------------------------------------\n\n// Maximum column content width given current layout. Use column->MinX so this value differs on a per-column basis.\nfloat ImGui::TableCalcMaxColumnWidth(const ImGuiTable* table, int column_n)\n{\n    const ImGuiTableColumn* column = &table->Columns[column_n];\n    float max_width = FLT_MAX;\n    const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;\n    if (table->Flags & ImGuiTableFlags_ScrollX)\n    {\n        // Frozen columns can't reach beyond visible width else scrolling will naturally break.\n        // (we use DisplayOrder as within a set of multiple frozen column reordering is possible)\n        if (column->DisplayOrder < table->FreezeColumnsRequest)\n        {\n            max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;\n            max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;\n        }\n    }\n    else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0)\n    {\n        // If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make\n        // sure they are all visible. Because of this we also know that all of the columns will always fit in\n        // table->WorkRect and therefore in table->InnerRect (because ScrollX is off)\n        // FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.\n        // See \"table_width_distrib\" and \"table_width_keep_visible\" tests\n        max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;\n        //max_width -= table->CellSpacingX1;\n        max_width -= table->CellSpacingX2;\n        max_width -= table->CellPaddingX * 2.0f;\n        max_width -= table->OuterPaddingX;\n    }\n    return max_width;\n}\n\n// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field\nfloat ImGui::TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)\n{\n    const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;\n    const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;\n    float width_auto = content_width_body;\n    if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))\n        width_auto = ImMax(width_auto, content_width_headers);\n\n    // Non-resizable fixed columns preserve their requested width\n    if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)\n        if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))\n            width_auto = column->InitStretchWeightOrWidth;\n\n    return ImMax(width_auto, table->MinColumnWidth);\n}\n\n// 'width' = inner column width, without padding\nvoid ImGui::TableSetColumnWidth(int column_n, float width)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL && table->IsLayoutLocked == false);\n    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);\n    ImGuiTableColumn* column_0 = &table->Columns[column_n];\n    float column_0_width = width;\n\n    // Apply constraints early\n    // Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)\n    IM_ASSERT(table->MinColumnWidth > 0.0f);\n    const float min_width = table->MinColumnWidth;\n    const float max_width = ImMax(min_width, column_0->WidthMax); // Don't use TableCalcMaxColumnWidth() here as it would rely on MinX from last instance (#7933)\n    column_0_width = ImClamp(column_0_width, min_width, max_width);\n    if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)\n        return;\n\n    //IMGUI_DEBUG_PRINT(\"TableSetColumnWidth(%d, %.1f->%.1f)\\n\", column_0_idx, column_0->WidthGiven, column_0_width);\n    ImGuiTableColumn* column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;\n\n    // In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.\n    // - All fixed: easy.\n    // - All stretch: easy.\n    // - One or more fixed + one stretch: easy.\n    // - One or more fixed + more than one stretch: tricky.\n    // Qt when manual resize is enabled only supports a single _trailing_ stretch column, we support more cases here.\n\n    // When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.\n    // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.\n    // Scenarios:\n    // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.\n    // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.\n    // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.\n    // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)\n    // - W1 W2 W3  resize from W1| or W2|   --> ok\n    // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)\n    // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)\n    // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)\n    // - W1 W2 F3  resize from W1| or W2|   --> ok\n    // - W1 F2 W3  resize from W1| or F2|   --> ok\n    // - F1 W2 F3  resize from W2|          --> ok\n    // - F1 W3 F2  resize from W3|          --> ok\n    // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.\n    // - W1 F2 F3  resize from F2|          --> ok\n    // All resizes from a Wx columns are locking other columns.\n\n    // Possible improvements:\n    // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.\n    // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.\n\n    // [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().\n\n    // If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.\n    // This is the preferred resize path\n    if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)\n        if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder)\n        {\n            column_0->WidthRequest = column_0_width;\n            table->IsSettingsDirty = true;\n            return;\n        }\n\n    // We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)\n    if (column_1 == NULL)\n        column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;\n    if (column_1 == NULL)\n        return;\n\n    // Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.\n    // (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)\n    float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);\n    column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;\n    IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);\n    column_0->WidthRequest = column_0_width;\n    column_1->WidthRequest = column_1_width;\n    if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)\n        TableUpdateColumnsWeightFromWidth(table);\n    table->IsSettingsDirty = true;\n}\n\n// Disable clipping then auto-fit, will take 2 frames\n// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)\nvoid ImGui::TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n)\n{\n    // Single auto width uses auto-fit\n    ImGuiTableColumn* column = &table->Columns[column_n];\n    if (!column->IsEnabled)\n        return;\n    column->CannotSkipItemsQueue = (1 << 0);\n    table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;\n}\n\nvoid ImGui::TableSetColumnWidthAutoAll(ImGuiTable* table)\n{\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column\n            continue;\n        column->CannotSkipItemsQueue = (1 << 0);\n        column->AutoFitQueue = (1 << 1);\n    }\n}\n\nvoid ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable* table)\n{\n    IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);\n\n    // Measure existing quantities\n    float visible_weight = 0.0f;\n    float visible_width = 0.0f;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))\n            continue;\n        IM_ASSERT(column->StretchWeight > 0.0f);\n        visible_weight += column->StretchWeight;\n        visible_width += column->WidthRequest;\n    }\n    IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);\n\n    // Apply new weights\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))\n            continue;\n        column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;\n        IM_ASSERT(column->StretchWeight > 0.0f);\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Drawing\n//-------------------------------------------------------------------------\n// - TablePushBackgroundChannel() [Internal]\n// - TablePopBackgroundChannel() [Internal]\n// - TableSetupDrawChannels() [Internal]\n// - TableMergeDrawChannels() [Internal]\n// - TableGetColumnBorderCol() [Internal]\n// - TableDrawBorders() [Internal]\n//-------------------------------------------------------------------------\n\n// Bg2 is used by Selectable (and possibly other widgets) to render to the background.\n// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.\nvoid ImGui::TablePushBackgroundChannel()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiTable* table = g.CurrentTable;\n\n    // Optimization: avoid SetCurrentChannel() + PushClipRect()\n    table->HostBackupInnerClipRect = window->ClipRect;\n    SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);\n    table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);\n}\n\nvoid ImGui::TablePopBackgroundChannel()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiTable* table = g.CurrentTable;\n    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];\n\n    // Optimization: avoid PopClipRect() + SetCurrentChannel()\n    SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);\n    table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);\n}\n\n// Allocate draw channels. Called by TableUpdateLayout()\n// - We allocate them following storage order instead of display order so reordering columns won't needlessly\n//   increase overall dormant memory cost.\n// - We isolate headers draw commands in their own channels instead of just altering clip rects.\n//   This is in order to facilitate merging of draw commands.\n// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.\n// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other\n//   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.\n// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for\n//   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).\n// Draw channel allocation (before merging):\n// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)\n// - Clip                         --> 2+D+N channels\n// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)\n// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)\n// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.\nvoid ImGui::TableSetupDrawChannels(ImGuiTable* table)\n{\n    const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;\n    const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;\n    const int channels_for_bg = 1 + 1 * freeze_row_multiplier;\n    const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0)) ? +1 : 0;\n    const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;\n    table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);\n    table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);\n    table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;\n    table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);\n\n    int draw_channel_current = 2;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (column->IsVisibleX && column->IsVisibleY)\n        {\n            column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);\n            column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));\n            if (!(table->Flags & ImGuiTableFlags_NoClip))\n                draw_channel_current++;\n        }\n        else\n        {\n            column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;\n        }\n        column->DrawChannelCurrent = column->DrawChannelFrozen;\n    }\n\n    // Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.\n    // All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.\n    // (This technically isn't part of setting up draw channels, but is reasonably related to be done here)\n    table->BgClipRect = table->InnerClipRect;\n    table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;\n    table->Bg2ClipRectForDrawCmd = table->HostClipRect;\n    IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);\n}\n\n// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().\n// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,\n// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().\n//\n// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve\n// this we merge their clip rect and make them contiguous in the channel list, so they can be merged\n// by the call to DrawSplitter.Merge() following to the call to this function.\n// We reorder draw commands by arranging them into a maximum of 4 distinct groups:\n//\n//   1 group:               2 groups:              2 groups:              4 groups:\n//   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze\n//   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll\n//\n// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).\n// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group\n// based on its position (within frozen rows/columns groups or not).\n// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.\n// This function assume that each column are pointing to a distinct draw channel,\n// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.\n//\n// Column channels will not be merged into one of the 1-4 groups in the following cases:\n// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).\n//   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds\n//   matches, by e.g. calling SetCursorScreenPos().\n// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..\n//   we could do better but it's going to be rare and probably not worth the hassle.\n// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.\n//\n// This function is particularly tricky to understand.. take a breath.\nvoid ImGui::TableMergeDrawChannels(ImGuiTable* table)\n{\n    ImGuiContext& g = *GImGui;\n    ImDrawListSplitter* splitter = table->DrawSplitter;\n    const bool has_freeze_v = (table->FreezeRowsCount > 0);\n    const bool has_freeze_h = (table->FreezeColumnsCount > 0);\n    IM_ASSERT(splitter->_Current == 0);\n\n    // Track which groups we are going to attempt to merge, and which channels goes into each group.\n    struct MergeGroup\n    {\n        ImRect          ClipRect;\n        int             ChannelsCount = 0;\n        ImBitArrayPtr   ChannelsMask = NULL;\n    };\n    int merge_group_mask = 0x00;\n    MergeGroup merge_groups[4];\n\n    // Use a reusable temp buffer for the merge masks as they are dynamically sized.\n    const int max_draw_channels = (4 + table->ColumnsCount * 2);\n    const int size_for_masks_bitarrays_one = (int)ImBitArrayGetStorageSizeInBytes(max_draw_channels);\n    g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);\n    memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);\n    for (int n = 0; n < IM_ARRAYSIZE(merge_groups); n++)\n        merge_groups[n].ChannelsMask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * n));\n    ImBitArrayPtr remaining_mask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * 4));\n\n    // 1. Scan channels and take note of those which can be merged\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))\n            continue;\n        ImGuiTableColumn* column = &table->Columns[column_n];\n\n        const int merge_group_sub_count = has_freeze_v ? 2 : 1;\n        for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++)\n        {\n            const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;\n\n            // Don't attempt to merge if there are multiple draw calls within the column\n            ImDrawChannel* src_channel = &splitter->_Channels[channel_no];\n            if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0 && src_channel->_CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()\n                src_channel->_CmdBuffer.pop_back();\n            if (src_channel->_CmdBuffer.Size != 1)\n                continue;\n\n            // Find out the width of this merge group and check if it will fit in our column\n            // (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)\n            if (!(column->Flags & ImGuiTableColumnFlags_NoClip))\n            {\n                float content_max_x;\n                if (!has_freeze_v)\n                    content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze\n                else if (merge_group_sub_n == 0)\n                    content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed);   // Row freeze: use width before freeze\n                else\n                    content_max_x = column->ContentMaxXUnfrozen;                                        // Row freeze: use width after freeze\n                if (content_max_x > column->ClipRect.Max.x)\n                    continue;\n            }\n\n            const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);\n            IM_ASSERT(channel_no < max_draw_channels);\n            MergeGroup* merge_group = &merge_groups[merge_group_n];\n            if (merge_group->ChannelsCount == 0)\n                merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);\n            ImBitArraySetBit(merge_group->ChannelsMask, channel_no);\n            merge_group->ChannelsCount++;\n            merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);\n            merge_group_mask |= (1 << merge_group_n);\n        }\n\n        // Invalidate current draw channel\n        // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)\n        column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;\n    }\n\n    // [DEBUG] Display merge groups\n#if 0\n    if (g.IO.KeyShift)\n        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)\n        {\n            MergeGroup* merge_group = &merge_groups[merge_group_n];\n            if (merge_group->ChannelsCount == 0)\n                continue;\n            char buf[32];\n            ImFormatString(buf, 32, \"MG%d:%d\", merge_group_n, merge_group->ChannelsCount);\n            ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);\n            ImVec2 text_size = CalcTextSize(buf, NULL);\n            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));\n            GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);\n            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));\n        }\n#endif\n\n    // 2. Rewrite channel list in our preferred order\n    if (merge_group_mask != 0)\n    {\n        // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().\n        const int LEADING_DRAW_CHANNELS = 2;\n        g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized\n        ImDrawChannel* dst_tmp = g.DrawChannelsTempMergeBuffer.Data;\n        ImBitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS, splitter->_Count);\n        ImBitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);\n        IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);\n        int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);\n        //ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;\n        ImRect host_rect = table->HostClipRect;\n        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)\n        {\n            if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount)\n            {\n                MergeGroup* merge_group = &merge_groups[merge_group_n];\n                ImRect merge_clip_rect = merge_group->ClipRect;\n\n                // Extend outer-most clip limits to match those of host, so draw calls can be merged even if\n                // outer-most columns have some outer padding offsetting them from their parent ClipRect.\n                // The principal cases this is dealing with are:\n                // - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge\n                // - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge\n                // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit\n                // within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.\n                if ((merge_group_n & 1) == 0 || !has_freeze_h)\n                    merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);\n                if ((merge_group_n & 2) == 0 || !has_freeze_v)\n                    merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);\n                if ((merge_group_n & 1) != 0)\n                    merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);\n                if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)\n                    merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);\n                //GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f); // [DEBUG]\n                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));\n                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));\n                remaining_count -= merge_group->ChannelsCount;\n                for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)\n                    remaining_mask[n] &= ~merge_group->ChannelsMask[n];\n                for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++)\n                {\n                    // Copy + overwrite new clip rect\n                    if (!IM_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))\n                        continue;\n                    IM_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);\n                    merge_channels_count--;\n\n                    ImDrawChannel* channel = &splitter->_Channels[n];\n                    IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));\n                    channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();\n                    memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));\n                }\n            }\n\n            // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)\n            if (merge_group_n == 1 && has_freeze_v)\n                memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));\n        }\n\n        // Append unmergeable channels that we didn't reorder at the end of the list\n        for (int n = 0; n < splitter->_Count && remaining_count != 0; n++)\n        {\n            if (!IM_BITARRAY_TESTBIT(remaining_mask, n))\n                continue;\n            ImDrawChannel* channel = &splitter->_Channels[n];\n            memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));\n            remaining_count--;\n        }\n        IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);\n        memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));\n    }\n}\n\nstatic ImU32 TableGetColumnBorderCol(ImGuiTable* table, int order_n, int column_n)\n{\n    const bool is_hovered = (table->HoveredColumnBorder == column_n);\n    const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);\n    const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);\n    if (is_resized || is_hovered)\n        return ImGui::GetColorU32(is_resized ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);\n    if (is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)))\n        return table->BorderColorStrong;\n    return table->BorderColorLight;\n}\n\n// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)\nvoid ImGui::TableDrawBorders(ImGuiTable* table)\n{\n    ImGuiWindow* inner_window = table->InnerWindow;\n    if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))\n        return;\n\n    ImDrawList* inner_drawlist = inner_window->DrawList;\n    table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);\n    inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);\n\n    // Draw inner border and resizing feedback\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    const float border_size = TABLE_BORDER_SIZE;\n    const float draw_y1 = ImMax(table->InnerRect.Min.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight) + ((table->Flags & ImGuiTableFlags_BordersOuterH) ? 1.0f : 0.0f);\n    const float draw_y2_body = table->InnerRect.Max.y;\n    const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table_instance->LastTopHeadersRowHeight) : draw_y1;\n    if (table->Flags & ImGuiTableFlags_BordersInnerV)\n    {\n        for (int order_n = 0; order_n < table->ColumnsCount; order_n++)\n        {\n            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))\n                continue;\n\n            const int column_n = table->DisplayOrderToIndex[order_n];\n            ImGuiTableColumn* column = &table->Columns[column_n];\n            const bool is_hovered = (table->HoveredColumnBorder == column_n);\n            const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);\n            const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;\n            const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);\n            if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)\n                continue;\n\n            // Decide whether right-most column is visible\n            if (column->NextEnabledColumn == -1 && !is_resizable)\n                if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))\n                    continue;\n            if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..\n                continue;\n\n            // Draw in outer window so right-most column won't be clipped\n            // Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.\n            float draw_y2 = (is_hovered || is_resized || is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) == 0) ? draw_y2_body : draw_y2_head;\n            if (draw_y2 > draw_y1)\n                inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), TableGetColumnBorderCol(table, order_n, column_n), border_size);\n        }\n    }\n\n    // Draw outer border\n    // FIXME: could use AddRect or explicit VLine/HLine helper?\n    if (table->Flags & ImGuiTableFlags_BordersOuter)\n    {\n        // Display outer border offset by 1 which is a simple way to display it without adding an extra draw call\n        // (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their\n        // parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part\n        // of it in inner window, and the part that's over scrollbars in the outer window..)\n        // Either solution currently won't allow us to use a larger border size: the border would clipped.\n        const ImRect outer_border = table->OuterRect;\n        const ImU32 outer_col = table->BorderColorStrong;\n        if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter)\n        {\n            inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);\n        }\n        else if (table->Flags & ImGuiTableFlags_BordersOuterV)\n        {\n            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);\n            inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);\n        }\n        else if (table->Flags & ImGuiTableFlags_BordersOuterH)\n        {\n            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);\n            inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);\n        }\n    }\n    if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y)\n    {\n        // Draw bottom-most row border between it is above outer border.\n        const float border_y = table->RowPosY2;\n        if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)\n            inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);\n    }\n\n    inner_drawlist->PopClipRect();\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Sorting\n//-------------------------------------------------------------------------\n// - TableGetSortSpecs()\n// - TableFixColumnSortDirection() [Internal]\n// - TableGetColumnNextSortDirection() [Internal]\n// - TableSetColumnSortDirection() [Internal]\n// - TableSortSpecsSanitize() [Internal]\n// - TableSortSpecsBuild() [Internal]\n//-------------------------------------------------------------------------\n\n// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)\n// When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have\n// changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,\n// else you may wastefully sort your data every frame!\n// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!\nImGuiTableSortSpecs* ImGui::TableGetSortSpecs()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL);\n\n    if (!(table->Flags & ImGuiTableFlags_Sortable))\n        return NULL;\n\n    // Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.\n    if (!table->IsLayoutLocked)\n        TableUpdateLayout(table);\n\n    TableSortSpecsBuild(table);\n    return &table->SortSpecs;\n}\n\nstatic inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn* column, int n)\n{\n    IM_ASSERT(n < column->SortDirectionsAvailCount);\n    return (ImGuiSortDirection)((column->SortDirectionsAvailList >> (n << 1)) & 0x03);\n}\n\n// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)\nvoid ImGui::TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)\n{\n    if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)\n        return;\n    column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);\n    table->IsSortSpecsDirty = true;\n}\n\n// Calculate next sort direction that would be set after clicking the column\n// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.\n// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.\nIM_STATIC_ASSERT(ImGuiSortDirection_None == 0 && ImGuiSortDirection_Ascending == 1 && ImGuiSortDirection_Descending == 2);\nImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn* column)\n{\n    IM_ASSERT(column->SortDirectionsAvailCount > 0);\n    if (column->SortOrder == -1)\n        return TableGetColumnAvailSortDirection(column, 0);\n    for (int n = 0; n < 3; n++)\n        if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))\n            return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);\n    IM_ASSERT(0);\n    return ImGuiSortDirection_None;\n}\n\n// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert\n// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.\nvoid ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n\n    if (!(table->Flags & ImGuiTableFlags_SortMulti))\n        append_to_sort_specs = false;\n    if (!(table->Flags & ImGuiTableFlags_SortTristate))\n        IM_ASSERT(sort_direction != ImGuiSortDirection_None);\n\n    ImGuiTableColumnIdx sort_order_max = 0;\n    if (append_to_sort_specs)\n        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)\n            sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);\n\n    ImGuiTableColumn* column = &table->Columns[column_n];\n    column->SortDirection = (ImU8)sort_direction;\n    if (column->SortDirection == ImGuiSortDirection_None)\n        column->SortOrder = -1;\n    else if (column->SortOrder == -1 || !append_to_sort_specs)\n        column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;\n\n    for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)\n    {\n        ImGuiTableColumn* other_column = &table->Columns[other_column_n];\n        if (other_column != column && !append_to_sort_specs)\n            other_column->SortOrder = -1;\n        TableFixColumnSortDirection(table, other_column);\n    }\n    table->IsSettingsDirty = true;\n    table->IsSortSpecsDirty = true;\n}\n\nvoid ImGui::TableSortSpecsSanitize(ImGuiTable* table)\n{\n    IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);\n\n    // Clear SortOrder from hidden column and verify that there's no gap or duplicate.\n    int sort_order_count = 0;\n    ImU64 sort_order_mask = 0x00;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n    {\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (column->SortOrder != -1 && !column->IsEnabled)\n            column->SortOrder = -1;\n        if (column->SortOrder == -1)\n            continue;\n        sort_order_count++;\n        sort_order_mask |= ((ImU64)1 << column->SortOrder);\n        IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);\n    }\n\n    const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);\n    const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);\n    if (need_fix_linearize || need_fix_single_sort_order)\n    {\n        ImU64 fixed_mask = 0x00;\n        for (int sort_n = 0; sort_n < sort_order_count; sort_n++)\n        {\n            // Fix: Rewrite sort order fields if needed so they have no gap or duplicate.\n            // (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)\n            int column_with_smallest_sort_order = -1;\n            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n                if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)\n                    if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)\n                        column_with_smallest_sort_order = column_n;\n            IM_ASSERT(column_with_smallest_sort_order != -1);\n            fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);\n            table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;\n\n            // Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.\n            if (need_fix_single_sort_order)\n            {\n                sort_order_count = 1;\n                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n                    if (column_n != column_with_smallest_sort_order)\n                        table->Columns[column_n].SortOrder = -1;\n                break;\n            }\n        }\n    }\n\n    // Fallback default sort order (if no column with the ImGuiTableColumnFlags_DefaultSort flag)\n    if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))\n        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n        {\n            ImGuiTableColumn* column = &table->Columns[column_n];\n            if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort))\n            {\n                sort_order_count = 1;\n                column->SortOrder = 0;\n                column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);\n                break;\n            }\n        }\n\n    table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;\n}\n\nvoid ImGui::TableSortSpecsBuild(ImGuiTable* table)\n{\n    bool dirty = table->IsSortSpecsDirty;\n    if (dirty)\n    {\n        TableSortSpecsSanitize(table);\n        table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);\n        table->SortSpecs.SpecsDirty = true; // Mark as dirty for user\n        table->IsSortSpecsDirty = false; // Mark as not dirty for us\n    }\n\n    // Write output\n    // May be able to move all SortSpecs data from table (48 bytes) to ImGuiTableTempData if we decide to write it back on every BeginTable()\n    ImGuiTableColumnSortSpecs* sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle : table->SortSpecsMulti.Data;\n    if (dirty && sort_specs != NULL)\n        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n        {\n            ImGuiTableColumn* column = &table->Columns[column_n];\n            if (column->SortOrder == -1)\n                continue;\n            IM_ASSERT(column->SortOrder < table->SortSpecsCount);\n            ImGuiTableColumnSortSpecs* sort_spec = &sort_specs[column->SortOrder];\n            sort_spec->ColumnUserID = column->UserID;\n            sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;\n            sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;\n            sort_spec->SortDirection = (ImGuiSortDirection)column->SortDirection;\n        }\n\n    table->SortSpecs.Specs = sort_specs;\n    table->SortSpecs.SpecsCount = table->SortSpecsCount;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Headers\n//-------------------------------------------------------------------------\n// - TableGetHeaderRowHeight() [Internal]\n// - TableGetHeaderAngledMaxLabelWidth() [Internal]\n// - TableHeadersRow()\n// - TableHeader()\n// - TableAngledHeadersRow()\n// - TableAngledHeadersRowEx() [Internal]\n//-------------------------------------------------------------------------\n\nfloat ImGui::TableGetHeaderRowHeight()\n{\n    // Caring for a minor edge case:\n    // Calculate row height, for the unlikely case that some labels may be taller than others.\n    // If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.\n    // In your custom header row you may omit this all together and just call TableNextRow() without a height...\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    float row_height = g.FontSize;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))\n            if ((table->Columns[column_n].Flags & ImGuiTableColumnFlags_NoHeaderLabel) == 0)\n                row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(table, column_n)).y);\n    return row_height + g.Style.CellPadding.y * 2.0f;\n}\n\nfloat ImGui::TableGetHeaderAngledMaxLabelWidth()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    float width = 0.0f;\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))\n            if (table->Columns[column_n].Flags & ImGuiTableColumnFlags_AngledHeader)\n                width = ImMax(width, CalcTextSize(TableGetColumnName(table, column_n), NULL, true).x);\n    return width + g.Style.CellPadding.y * 2.0f; // Swap padding\n}\n\n// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().\n// The intent is that advanced users willing to create customized headers would not need to use this helper\n// and can create their own! For example: TableHeader() may be preceded by Checkbox() or other custom widgets.\n// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.\n// This code is intentionally written to not make much use of internal functions, to give you better direction\n// if you need to write your own.\n// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.\nvoid ImGui::TableHeadersRow()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL && \"Need to call TableHeadersRow() after BeginTable()!\");\n\n    // Call layout if not already done. This is automatically done by TableNextRow: we do it here _only_ to make\n    // it easier to debug-step in TableUpdateLayout(). Your own version of this function doesn't need this.\n    if (!table->IsLayoutLocked)\n        TableUpdateLayout(table);\n\n    // Open row\n    const float row_height = TableGetHeaderRowHeight();\n    TableNextRow(ImGuiTableRowFlags_Headers, row_height);\n    const float row_y1 = GetCursorScreenPos().y;\n    if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.\n        return;\n\n    const int columns_count = TableGetColumnCount();\n    for (int column_n = 0; column_n < columns_count; column_n++)\n    {\n        if (!TableSetColumnIndex(column_n))\n            continue;\n\n        // Push an id to allow empty/unnamed headers. This is also idiomatic as it ensure there is a consistent ID path to access columns (for e.g. automation)\n        const char* name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? \"\" : TableGetColumnName(column_n);\n        PushID(column_n);\n        TableHeader(name);\n        PopID();\n    }\n\n    // Allow opening popup from the right-most section after the last column.\n    ImVec2 mouse_pos = ImGui::GetMousePos();\n    if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)\n        if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)\n            TableOpenContextMenu(columns_count); // Will open a non-column-specific popup.\n}\n\n// Emit a column header (text + optional sort order)\n// We cpu-clip text here so that all columns headers can be merged into a same draw call.\n// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()\nvoid ImGui::TableHeader(const char* label)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return;\n\n    ImGuiTable* table = g.CurrentTable;\n    IM_ASSERT(table != NULL && \"Need to call TableHeader() after BeginTable()!\");\n    IM_ASSERT(table->CurrentColumn != -1);\n    const int column_n = table->CurrentColumn;\n    ImGuiTableColumn* column = &table->Columns[column_n];\n\n    // Label\n    if (label == NULL)\n        label = \"\";\n    const char* label_end = FindRenderedTextEnd(label);\n    ImVec2 label_size = CalcTextSize(label, label_end, true);\n    ImVec2 label_pos = window->DC.CursorPos;\n\n    // If we already got a row height, there's use that.\n    // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?\n    ImRect cell_r = TableGetCellBgRect(table, column_n);\n    float label_height = ImMax(label_size.y, table->RowMinHeight - table->RowCellPaddingY * 2.0f);\n\n    // Calculate ideal size for sort order arrow\n    float w_arrow = 0.0f;\n    float w_sort_text = 0.0f;\n    bool sort_arrow = false;\n    char sort_order_suf[4] = \"\";\n    const float ARROW_SCALE = 0.65f;\n    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))\n    {\n        w_arrow = ImTrunc(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);\n        if (column->SortOrder != -1)\n            sort_arrow = true;\n        if (column->SortOrder > 0)\n        {\n            ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), \"%d\", column->SortOrder + 1);\n            w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;\n        }\n    }\n\n    // We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considered for merging.\n    float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;\n    column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, sort_arrow ? cell_r.Max.x : ImMin(max_pos_x, cell_r.Max.x));\n    column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);\n\n    // Keep header highlighted when context menu is open.\n    ImGuiID id = window->GetID(label);\n    ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));\n    ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal\n    if (!ItemAdd(bb, id))\n        return;\n\n    //GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]\n    //GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]\n\n    // Using AllowOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.\n    const bool highlight = (table->HighlightColumnHeader == column_n);\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowOverlap);\n    if (held || hovered || highlight)\n    {\n        const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\n        //RenderFrame(bb.Min, bb.Max, col, false, 0.0f);\n        TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);\n    }\n    else\n    {\n        // Submit single cell bg color in the case we didn't submit a full header row\n        if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)\n            TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);\n    }\n    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_NoRounding);\n    if (held)\n        table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;\n    window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;\n\n    // Drag and drop to re-order columns.\n    // FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.\n    if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive)\n    {\n        // While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x\n        table->ReorderColumn = (ImGuiTableColumnIdx)column_n;\n        table->InstanceInteracted = table->InstanceCurrent;\n\n        // We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.\n        if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)\n            if (ImGuiTableColumn* prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)\n                if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))\n                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))\n                        table->ReorderColumnDir = -1;\n        if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)\n            if (ImGuiTableColumn* next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)\n                if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))\n                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))\n                        table->ReorderColumnDir = +1;\n    }\n\n    // Sort order arrow\n    const float ellipsis_max = ImMax(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x);\n    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))\n    {\n        if (column->SortOrder != -1)\n        {\n            float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);\n            float y = label_pos.y;\n            if (column->SortOrder > 0)\n            {\n                PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));\n                RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);\n                PopStyleColor();\n                x += w_sort_text;\n            }\n            RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);\n        }\n\n        // Handle clicking on column header to adjust Sort Order\n        if (pressed && table->ReorderColumn != column_n)\n        {\n            ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);\n            TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);\n        }\n    }\n\n    // Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will\n    // be merged into a single draw call.\n    //window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);\n    RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);\n\n    const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);\n    if (text_clipped && hovered && g.ActiveId == 0)\n        SetItemTooltip(\"%.*s\", (int)(label_end - label), label);\n\n    // We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden\n    if (IsMouseReleased(1) && IsItemHovered())\n        TableOpenContextMenu(column_n);\n}\n\n// Unlike TableHeadersRow() it is not expected that you can reimplement or customize this with custom widgets.\n// FIXME: No hit-testing/button on the angled header.\nvoid ImGui::TableAngledHeadersRow()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    ImGuiTableTempData* temp_data = table->TempData;\n    temp_data->AngledHeadersRequests.resize(0);\n    temp_data->AngledHeadersRequests.reserve(table->ColumnsEnabledCount);\n\n    // Which column needs highlight?\n    const ImGuiID row_id = GetID(\"##AngledHeaders\");\n    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);\n    int highlight_column_n = table->HighlightColumnHeader;\n    if (highlight_column_n == -1 && table->HoveredColumnBody != -1)\n        if (table_instance->HoveredRowLast == 0 && table->HoveredColumnBorder == -1 && (g.ActiveId == 0 || g.ActiveId == row_id || (table->IsActiveIdInTable || g.DragDropActive)))\n            highlight_column_n = table->HoveredColumnBody;\n\n    // Build up request\n    ImU32 col_header_bg = GetColorU32(ImGuiCol_TableHeaderBg);\n    ImU32 col_text = GetColorU32(ImGuiCol_Text);\n    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)\n        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))\n        {\n            const int column_n = table->DisplayOrderToIndex[order_n];\n            ImGuiTableColumn* column = &table->Columns[column_n];\n            if ((column->Flags & ImGuiTableColumnFlags_AngledHeader) == 0) // Note: can't rely on ImGuiTableColumnFlags_IsVisible test here.\n                continue;\n            ImGuiTableHeaderData request = { (ImGuiTableColumnIdx)column_n, col_text, col_header_bg, (column_n == highlight_column_n) ? GetColorU32(ImGuiCol_Header) : 0 };\n            temp_data->AngledHeadersRequests.push_back(request);\n        }\n\n    // Render row\n    TableAngledHeadersRowEx(row_id, g.Style.TableAngledHeadersAngle, 0.0f, temp_data->AngledHeadersRequests.Data, temp_data->AngledHeadersRequests.Size);\n}\n\n// Important: data must be fed left to right\nvoid ImGui::TableAngledHeadersRowEx(ImGuiID row_id, float angle, float max_label_width, const ImGuiTableHeaderData* data, int data_count)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImDrawList* draw_list = window->DrawList;\n    IM_ASSERT(table != NULL && \"Need to call TableHeadersRow() after BeginTable()!\");\n    IM_ASSERT(table->CurrentRow == -1 && \"Must be first row\");\n\n    if (max_label_width == 0.0f)\n        max_label_width = TableGetHeaderAngledMaxLabelWidth();\n\n    // Angle argument expressed in (-IM_PI/2 .. +IM_PI/2) as it is easier to think about for user.\n    const bool flip_label = (angle < 0.0f);\n    angle -= IM_PI * 0.5f;\n    const float cos_a = ImCos(angle);\n    const float sin_a = ImSin(angle);\n    const float label_cos_a = flip_label ? ImCos(angle + IM_PI) : cos_a;\n    const float label_sin_a = flip_label ? ImSin(angle + IM_PI) : sin_a;\n    const ImVec2 unit_right = ImVec2(cos_a, sin_a);\n\n    // Calculate our base metrics and set angled headers data _before_ the first call to TableNextRow()\n    // FIXME-STYLE: Would it be better for user to submit 'max_label_width' or 'row_height' ? One can be derived from the other.\n    const float header_height = g.FontSize + g.Style.CellPadding.x * 2.0f;\n    const float row_height = ImTrunc(ImFabs(ImRotate(ImVec2(max_label_width, flip_label ? +header_height : -header_height), cos_a, sin_a).y));\n    table->AngledHeadersHeight = row_height;\n    table->AngledHeadersSlope = (sin_a != 0.0f) ? (cos_a / sin_a) : 0.0f;\n    const ImVec2 header_angled_vector = unit_right * (row_height / -sin_a); // vector from bottom-left to top-left, and from bottom-right to top-right\n\n    // Declare row, override and draw our own background\n    TableNextRow(ImGuiTableRowFlags_Headers, row_height);\n    TableNextColumn();\n    const ImRect row_r(table->WorkRect.Min.x, table->BgClipRect.Min.y, table->WorkRect.Max.x, table->RowPosY2);\n    table->DrawSplitter->SetCurrentChannel(draw_list, TABLE_DRAW_CHANNEL_BG0);\n    float clip_rect_min_x = table->BgClipRect.Min.x;\n    if (table->FreezeColumnsCount > 0)\n        clip_rect_min_x = ImMax(clip_rect_min_x, table->Columns[table->FreezeColumnsCount - 1].MaxX);\n    TableSetBgColor(ImGuiTableBgTarget_RowBg0, 0); // Cancel\n    PushClipRect(table->BgClipRect.Min, table->BgClipRect.Max, false); // Span all columns\n    draw_list->AddRectFilled(ImVec2(table->BgClipRect.Min.x, row_r.Min.y), ImVec2(table->BgClipRect.Max.x, row_r.Max.y), GetColorU32(ImGuiCol_TableHeaderBg, 0.25f)); // FIXME-STYLE: Change row background with an arbitrary color.\n    PushClipRect(ImVec2(clip_rect_min_x, table->BgClipRect.Min.y), table->BgClipRect.Max, true); // Span all columns\n\n    ButtonBehavior(row_r, row_id, NULL, NULL);\n    KeepAliveID(row_id);\n\n    const float ascent_scaled = g.Font->Ascent * g.FontScale; // FIXME: Standardize those scaling factors better\n    const float line_off_for_ascent_x = (ImMax((g.FontSize - ascent_scaled) * 0.5f, 0.0f) / -sin_a) * (flip_label ? -1.0f : 1.0f);\n    const ImVec2 padding = g.Style.CellPadding; // We will always use swapped component\n    const ImVec2 align = g.Style.TableAngledHeadersTextAlign;\n\n    // Draw background and labels in first pass, then all borders.\n    float max_x = -FLT_MAX;\n    for (int pass = 0; pass < 2; pass++)\n        for (int order_n = 0; order_n < data_count; order_n++)\n        {\n            const ImGuiTableHeaderData* request = &data[order_n];\n            const int column_n = request->Index;\n            ImGuiTableColumn* column = &table->Columns[column_n];\n\n            ImVec2 bg_shape[4];\n            bg_shape[0] = ImVec2(column->MaxX, row_r.Max.y);\n            bg_shape[1] = ImVec2(column->MinX, row_r.Max.y);\n            bg_shape[2] = bg_shape[1] + header_angled_vector;\n            bg_shape[3] = bg_shape[0] + header_angled_vector;\n            if (pass == 0)\n            {\n                // Draw shape\n                draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor0);\n                draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor1); // Optional highlight\n                max_x = ImMax(max_x, bg_shape[3].x);\n\n                // Draw label\n                // - First draw at an offset where RenderTextXXX() function won't meddle with applying current ClipRect, then transform to final offset.\n                // - Handle multiple lines manually, as we want each lines to follow on the horizontal border, rather than see a whole block rotated.\n                const char* label_name = TableGetColumnName(table, column_n);\n                const char* label_name_end = FindRenderedTextEnd(label_name);\n                const float line_off_step_x = (g.FontSize / -sin_a);\n                const int label_lines = ImTextCountLines(label_name, label_name_end);\n\n                // Left<>Right alignment\n                float line_off_curr_x = flip_label ? (label_lines - 1) * line_off_step_x : 0.0f;\n                float line_off_for_align_x = ImMax((((column->MaxX - column->MinX) - padding.x * 2.0f) - (label_lines * line_off_step_x)), 0.0f) * align.x;\n                line_off_curr_x += line_off_for_align_x - line_off_for_ascent_x;\n\n                // Register header width\n                column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX + ImCeil(label_lines * line_off_step_x - line_off_for_align_x);\n\n                while (label_name < label_name_end)\n                {\n                    const char* label_name_eol = strchr(label_name, '\\n');\n                    if (label_name_eol == NULL)\n                        label_name_eol = label_name_end;\n\n                    // FIXME: Individual line clipping for right-most column is broken for negative angles.\n                    ImVec2 label_size = CalcTextSize(label_name, label_name_eol);\n                    float clip_width = max_label_width - padding.y; // Using padding.y*2.0f would be symmetrical but hide more text.\n                    float clip_height = ImMin(label_size.y, column->ClipRect.Max.x - column->WorkMinX - line_off_curr_x);\n                    ImRect clip_r(window->ClipRect.Min, window->ClipRect.Min + ImVec2(clip_width, clip_height));\n                    int vtx_idx_begin = draw_list->_VtxCurrentIdx;\n                    PushStyleColor(ImGuiCol_Text, request->TextColor);\n                    RenderTextEllipsis(draw_list, clip_r.Min, clip_r.Max, clip_r.Max.x, clip_r.Max.x, label_name, label_name_eol, &label_size);\n                    PopStyleColor();\n                    int vtx_idx_end = draw_list->_VtxCurrentIdx;\n\n                    // Up<>Down alignment\n                    const float available_space = ImMax(clip_width - label_size.x + ImAbs(padding.x * cos_a) * 2.0f - ImAbs(padding.y * sin_a) * 2.0f, 0.0f);\n                    const float vertical_offset = available_space * align.y * (flip_label ? -1.0f : 1.0f);\n\n                    // Rotate and offset label\n                    ImVec2 pivot_in = ImVec2(window->ClipRect.Min.x - vertical_offset, window->ClipRect.Min.y + label_size.y);\n                    ImVec2 pivot_out = ImVec2(column->WorkMinX, row_r.Max.y);\n                    line_off_curr_x += flip_label ? -line_off_step_x : line_off_step_x;\n                    pivot_out += unit_right * padding.y;\n                    if (flip_label)\n                        pivot_out += unit_right * (clip_width - ImMax(0.0f, clip_width - label_size.x));\n                    pivot_out.x += flip_label ? line_off_curr_x + line_off_step_x : line_off_curr_x;\n                    ShadeVertsTransformPos(draw_list, vtx_idx_begin, vtx_idx_end, pivot_in, label_cos_a, label_sin_a, pivot_out); // Rotate and offset\n                    //if (g.IO.KeyShift) { ImDrawList* fg_dl = GetForegroundDrawList(); vtx_idx_begin = fg_dl->_VtxCurrentIdx; fg_dl->AddRect(clip_r.Min, clip_r.Max, IM_COL32(0, 255, 0, 255), 0.0f, 0, 1.0f); ShadeVertsTransformPos(fg_dl, vtx_idx_begin, fg_dl->_VtxCurrentIdx, pivot_in, label_cos_a, label_sin_a, pivot_out); }\n\n                    label_name = label_name_eol + 1;\n                }\n            }\n            if (pass == 1)\n            {\n                // Draw border\n                draw_list->AddLine(bg_shape[0], bg_shape[3], TableGetColumnBorderCol(table, order_n, column_n));\n            }\n        }\n    PopClipRect();\n    PopClipRect();\n    table->TempData->AngledHeadersExtraWidth = ImMax(0.0f, max_x - table->Columns[table->RightMostEnabledColumn].MaxX);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Context Menu\n//-------------------------------------------------------------------------\n// - TableOpenContextMenu() [Internal]\n// - TableBeginContextMenuPopup() [Internal]\n// - TableDrawDefaultContextMenu() [Internal]\n//-------------------------------------------------------------------------\n\n// Use -1 to open menu not specific to a given column.\nvoid ImGui::TableOpenContextMenu(int column_n)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTable* table = g.CurrentTable;\n    if (column_n == -1 && table->CurrentColumn != -1)   // When called within a column automatically use this one (for consistency)\n        column_n = table->CurrentColumn;\n    if (column_n == table->ColumnsCount)                // To facilitate using with TableGetHoveredColumn()\n        column_n = -1;\n    IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);\n    if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))\n    {\n        table->IsContextPopupOpen = true;\n        table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;\n        table->InstanceInteracted = table->InstanceCurrent;\n        const ImGuiID context_menu_id = ImHashStr(\"##ContextMenu\", 0, table->ID);\n        OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);\n    }\n}\n\nbool ImGui::TableBeginContextMenuPopup(ImGuiTable* table)\n{\n    if (!table->IsContextPopupOpen || table->InstanceCurrent != table->InstanceInteracted)\n        return false;\n    const ImGuiID context_menu_id = ImHashStr(\"##ContextMenu\", 0, table->ID);\n    if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))\n        return true;\n    table->IsContextPopupOpen = false;\n    return false;\n}\n\n// Output context menu into current window (generally a popup)\n// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?\n// Sections to display are pulled from 'flags_for_section_to_display', which is typically == table->Flags.\n// - ImGuiTableFlags_Resizable   -> display Sizing menu items\n// - ImGuiTableFlags_Reorderable -> display \"Reset Order\"\n////- ImGuiTableFlags_Sortable   -> display sorting options (disabled)\n// - ImGuiTableFlags_Hideable    -> display columns visibility menu items\n// It means if you have a custom context menus you can call this section and omit some sections, and add your own.\nvoid ImGui::TableDrawDefaultContextMenu(ImGuiTable* table, ImGuiTableFlags flags_for_section_to_display)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return;\n\n    bool want_separator = false;\n    const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;\n    ImGuiTableColumn* column = (column_n != -1) ? &table->Columns[column_n] : NULL;\n\n    // Sizing\n    if (flags_for_section_to_display & ImGuiTableFlags_Resizable)\n    {\n        if (column != NULL)\n        {\n            const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;\n            if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableSizeOne), NULL, false, can_resize)) // \"###SizeOne\"\n                TableSetColumnWidthAutoSingle(table, column_n);\n        }\n\n        const char* size_all_desc;\n        if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)\n            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllFit);        // \"###SizeAll\" All fixed\n        else\n            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllDefault);    // \"###SizeAll\" All stretch or mixed\n        if (MenuItem(size_all_desc, NULL))\n            TableSetColumnWidthAutoAll(table);\n        want_separator = true;\n    }\n\n    // Ordering\n    if (flags_for_section_to_display & ImGuiTableFlags_Reorderable)\n    {\n        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableResetOrder), NULL, false, !table->IsDefaultDisplayOrder))\n            table->IsResetDisplayOrderRequest = true;\n        want_separator = true;\n    }\n\n    // Reset all (should work but seems unnecessary/noisy to expose?)\n    //if (MenuItem(\"Reset all\"))\n    //    table->IsResetAllRequest = true;\n\n    // Sorting\n    // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)\n#if 0\n    if ((flags_for_section_to_display & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)\n    {\n        if (want_separator)\n            Separator();\n        want_separator = true;\n\n        bool append_to_sort_specs = g.IO.KeyShift;\n        if (MenuItem(\"Sort in Ascending Order\", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))\n            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);\n        if (MenuItem(\"Sort in Descending Order\", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))\n            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);\n    }\n#endif\n\n    // Hiding / Visibility\n    if (flags_for_section_to_display & ImGuiTableFlags_Hideable)\n    {\n        if (want_separator)\n            Separator();\n        want_separator = true;\n\n        PushItemFlag(ImGuiItemFlags_AutoClosePopups, false);\n        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)\n        {\n            ImGuiTableColumn* other_column = &table->Columns[other_column_n];\n            if (other_column->Flags & ImGuiTableColumnFlags_Disabled)\n                continue;\n\n            const char* name = TableGetColumnName(table, other_column_n);\n            if (name == NULL || name[0] == 0)\n                name = \"<Unknown>\";\n\n            // Make sure we can't hide the last active column\n            bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;\n            if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)\n                menu_item_active = false;\n            if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))\n                other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;\n        }\n        PopItemFlag();\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Settings (.ini data)\n//-------------------------------------------------------------------------\n// FIXME: The binding/finding/creating flow are too confusing.\n//-------------------------------------------------------------------------\n// - TableSettingsInit() [Internal]\n// - TableSettingsCalcChunkSize() [Internal]\n// - TableSettingsCreate() [Internal]\n// - TableSettingsFindByID() [Internal]\n// - TableGetBoundSettings() [Internal]\n// - TableResetSettings()\n// - TableSaveSettings() [Internal]\n// - TableLoadSettings() [Internal]\n// - TableSettingsHandler_ClearAll() [Internal]\n// - TableSettingsHandler_ApplyAll() [Internal]\n// - TableSettingsHandler_ReadOpen() [Internal]\n// - TableSettingsHandler_ReadLine() [Internal]\n// - TableSettingsHandler_WriteAll() [Internal]\n// - TableSettingsInstallHandler() [Internal]\n//-------------------------------------------------------------------------\n// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.\n// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.\n// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.\n// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.\n//-------------------------------------------------------------------------\n\n// Clear and initialize empty settings instance\nstatic void TableSettingsInit(ImGuiTableSettings* settings, ImGuiID id, int columns_count, int columns_count_max)\n{\n    IM_PLACEMENT_NEW(settings) ImGuiTableSettings();\n    ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();\n    for (int n = 0; n < columns_count_max; n++, settings_column++)\n        IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();\n    settings->ID = id;\n    settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;\n    settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;\n    settings->WantApply = true;\n}\n\nstatic size_t TableSettingsCalcChunkSize(int columns_count)\n{\n    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);\n}\n\nImGuiTableSettings* ImGui::TableSettingsCreate(ImGuiID id, int columns_count)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));\n    TableSettingsInit(settings, id, columns_count, columns_count);\n    return settings;\n}\n\n// Find existing settings\nImGuiTableSettings* ImGui::TableSettingsFindByID(ImGuiID id)\n{\n    // FIXME-OPT: Might want to store a lookup map for this?\n    ImGuiContext& g = *GImGui;\n    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))\n        if (settings->ID == id)\n            return settings;\n    return NULL;\n}\n\n// Get settings for a given table, NULL if none\nImGuiTableSettings* ImGui::TableGetBoundSettings(ImGuiTable* table)\n{\n    if (table->SettingsOffset != -1)\n    {\n        ImGuiContext& g = *GImGui;\n        ImGuiTableSettings* settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);\n        IM_ASSERT(settings->ID == table->ID);\n        if (settings->ColumnsCountMax >= table->ColumnsCount)\n            return settings; // OK\n        settings->ID = 0; // Invalidate storage, we won't fit because of a count change\n    }\n    return NULL;\n}\n\n// Restore initial state of table (with or without saved settings)\nvoid ImGui::TableResetSettings(ImGuiTable* table)\n{\n    table->IsInitializing = table->IsSettingsDirty = true;\n    table->IsResetAllRequest = false;\n    table->IsSettingsRequestLoad = false;                   // Don't reload from ini\n    table->SettingsLoadedFlags = ImGuiTableFlags_None;      // Mark as nothing loaded so our initialized data becomes authoritative\n}\n\nvoid ImGui::TableSaveSettings(ImGuiTable* table)\n{\n    table->IsSettingsDirty = false;\n    if (table->Flags & ImGuiTableFlags_NoSavedSettings)\n        return;\n\n    // Bind or create settings data\n    ImGuiContext& g = *GImGui;\n    ImGuiTableSettings* settings = TableGetBoundSettings(table);\n    if (settings == NULL)\n    {\n        settings = TableSettingsCreate(table->ID, table->ColumnsCount);\n        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);\n    }\n    settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;\n\n    // Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings\n    IM_ASSERT(settings->ID == table->ID);\n    IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);\n    ImGuiTableColumn* column = table->Columns.Data;\n    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();\n\n    bool save_ref_scale = false;\n    settings->SaveFlags = ImGuiTableFlags_None;\n    for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++)\n    {\n        const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;\n        column_settings->WidthOrWeight = width_or_weight;\n        column_settings->Index = (ImGuiTableColumnIdx)n;\n        column_settings->DisplayOrder = column->DisplayOrder;\n        column_settings->SortOrder = column->SortOrder;\n        column_settings->SortDirection = column->SortDirection;\n        column_settings->IsEnabled = column->IsUserEnabled;\n        column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;\n        if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)\n            save_ref_scale = true;\n\n        // We skip saving some data in the .ini file when they are unnecessary to restore our state.\n        // Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.\n        // FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.\n        if (width_or_weight != column->InitStretchWeightOrWidth)\n            settings->SaveFlags |= ImGuiTableFlags_Resizable;\n        if (column->DisplayOrder != n)\n            settings->SaveFlags |= ImGuiTableFlags_Reorderable;\n        if (column->SortOrder != -1)\n            settings->SaveFlags |= ImGuiTableFlags_Sortable;\n        if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))\n            settings->SaveFlags |= ImGuiTableFlags_Hideable;\n    }\n    settings->SaveFlags &= table->Flags;\n    settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;\n\n    MarkIniSettingsDirty();\n}\n\nvoid ImGui::TableLoadSettings(ImGuiTable* table)\n{\n    ImGuiContext& g = *GImGui;\n    table->IsSettingsRequestLoad = false;\n    if (table->Flags & ImGuiTableFlags_NoSavedSettings)\n        return;\n\n    // Bind settings\n    ImGuiTableSettings* settings;\n    if (table->SettingsOffset == -1)\n    {\n        settings = TableSettingsFindByID(table->ID);\n        if (settings == NULL)\n            return;\n        if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...\n            table->IsSettingsDirty = true;\n        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);\n    }\n    else\n    {\n        settings = TableGetBoundSettings(table);\n    }\n\n    table->SettingsLoadedFlags = settings->SaveFlags;\n    table->RefScale = settings->RefScale;\n\n    // Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn\n    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();\n    ImU64 display_order_mask = 0;\n    for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++)\n    {\n        int column_n = column_settings->Index;\n        if (column_n < 0 || column_n >= table->ColumnsCount)\n            continue;\n\n        ImGuiTableColumn* column = &table->Columns[column_n];\n        if (settings->SaveFlags & ImGuiTableFlags_Resizable)\n        {\n            if (column_settings->IsStretch)\n                column->StretchWeight = column_settings->WidthOrWeight;\n            else\n                column->WidthRequest = column_settings->WidthOrWeight;\n            column->AutoFitQueue = 0x00;\n        }\n        if (settings->SaveFlags & ImGuiTableFlags_Reorderable)\n            column->DisplayOrder = column_settings->DisplayOrder;\n        else\n            column->DisplayOrder = (ImGuiTableColumnIdx)column_n;\n        display_order_mask |= (ImU64)1 << column->DisplayOrder;\n        column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled;\n        column->SortOrder = column_settings->SortOrder;\n        column->SortDirection = column_settings->SortDirection;\n    }\n\n    // Validate and fix invalid display order data\n    const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;\n    if (display_order_mask != expected_display_order_mask)\n        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n            table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;\n\n    // Rebuild index\n    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)\n        table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;\n}\n\nstatic void TableSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)\n{\n    ImGuiContext& g = *ctx;\n    for (int i = 0; i != g.Tables.GetMapSize(); i++)\n        if (ImGuiTable* table = g.Tables.TryGetMapData(i))\n            table->SettingsOffset = -1;\n    g.SettingsTables.clear();\n}\n\n// Apply to existing windows (if any)\nstatic void TableSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)\n{\n    ImGuiContext& g = *ctx;\n    for (int i = 0; i != g.Tables.GetMapSize(); i++)\n        if (ImGuiTable* table = g.Tables.TryGetMapData(i))\n        {\n            table->IsSettingsRequestLoad = true;\n            table->SettingsOffset = -1;\n        }\n}\n\nstatic void* TableSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)\n{\n    ImGuiID id = 0;\n    int columns_count = 0;\n    if (sscanf(name, \"0x%08X,%d\", &id, &columns_count) < 2)\n        return NULL;\n\n    if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))\n    {\n        if (settings->ColumnsCountMax >= columns_count)\n        {\n            TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle\n            return settings;\n        }\n        settings->ID = 0; // Invalidate storage, we won't fit because of a count change\n    }\n    return ImGui::TableSettingsCreate(id, columns_count);\n}\n\nstatic void TableSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)\n{\n    // \"Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v\"\n    ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;\n    float f = 0.0f;\n    int column_n = 0, r = 0, n = 0;\n\n    if (sscanf(line, \"RefScale=%f\", &f) == 1) { settings->RefScale = f; return; }\n\n    if (sscanf(line, \"Column %d%n\", &column_n, &r) == 1)\n    {\n        if (column_n < 0 || column_n >= settings->ColumnsCount)\n            return;\n        line = ImStrSkipBlank(line + r);\n        char c = 0;\n        ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;\n        column->Index = (ImGuiTableColumnIdx)column_n;\n        if (sscanf(line, \"UserID=0x%08X%n\", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }\n        if (sscanf(line, \"Width=%d%n\", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }\n        if (sscanf(line, \"Weight=%f%n\", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }\n        if (sscanf(line, \"Visible=%d%n\", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }\n        if (sscanf(line, \"Order=%d%n\", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }\n        if (sscanf(line, \"Sort=%d%c%n\", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }\n    }\n}\n\nstatic void TableSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)\n{\n    ImGuiContext& g = *ctx;\n    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))\n    {\n        if (settings->ID == 0) // Skip ditched settings\n            continue;\n\n        // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped\n        // (e.g. Order was unchanged)\n        const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;\n        const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;\n        const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;\n        const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;\n        if (!save_size && !save_visible && !save_order && !save_sort)\n            continue;\n\n        buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve\n        buf->appendf(\"[%s][0x%08X,%d]\\n\", handler->TypeName, settings->ID, settings->ColumnsCount);\n        if (settings->RefScale != 0.0f)\n            buf->appendf(\"RefScale=%g\\n\", settings->RefScale);\n        ImGuiTableColumnSettings* column = settings->GetColumnSettings();\n        for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)\n        {\n            // \"Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v\"\n            bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);\n            if (!save_column)\n                continue;\n            buf->appendf(\"Column %-2d\", column_n);\n            if (column->UserID != 0)                    { buf->appendf(\" UserID=%08X\", column->UserID); }\n            if (save_size && column->IsStretch)         { buf->appendf(\" Weight=%.4f\", column->WidthOrWeight); }\n            if (save_size && !column->IsStretch)        { buf->appendf(\" Width=%d\", (int)column->WidthOrWeight); }\n            if (save_visible)                           { buf->appendf(\" Visible=%d\", column->IsEnabled); }\n            if (save_order)                             { buf->appendf(\" Order=%d\", column->DisplayOrder); }\n            if (save_sort && column->SortOrder != -1)   { buf->appendf(\" Sort=%d%c\", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^'); }\n            buf->append(\"\\n\");\n        }\n        buf->append(\"\\n\");\n    }\n}\n\nvoid ImGui::TableSettingsAddSettingsHandler()\n{\n    ImGuiSettingsHandler ini_handler;\n    ini_handler.TypeName = \"Table\";\n    ini_handler.TypeHash = ImHashStr(\"Table\");\n    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;\n    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;\n    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;\n    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;\n    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;\n    AddSettingsHandler(&ini_handler);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Garbage Collection\n//-------------------------------------------------------------------------\n// - TableRemove() [Internal]\n// - TableGcCompactTransientBuffers() [Internal]\n// - TableGcCompactSettings() [Internal]\n//-------------------------------------------------------------------------\n\n// Remove Table (currently only used by TestEngine)\nvoid ImGui::TableRemove(ImGuiTable* table)\n{\n    //IMGUI_DEBUG_PRINT(\"TableRemove() id=0x%08X\\n\", table->ID);\n    ImGuiContext& g = *GImGui;\n    int table_idx = g.Tables.GetIndex(table);\n    //memset(table->RawData.Data, 0, table->RawData.size_in_bytes());\n    //memset(table, 0, sizeof(ImGuiTable));\n    g.Tables.Remove(table->ID, table);\n    g.TablesLastTimeActive[table_idx] = -1.0f;\n}\n\n// Free up/compact internal Table buffers for when it gets unused\nvoid ImGui::TableGcCompactTransientBuffers(ImGuiTable* table)\n{\n    //IMGUI_DEBUG_PRINT(\"TableGcCompactTransientBuffers() id=0x%08X\\n\", table->ID);\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(table->MemoryCompacted == false);\n    table->SortSpecs.Specs = NULL;\n    table->SortSpecsMulti.clear();\n    table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.\n    table->ColumnsNames.clear();\n    table->MemoryCompacted = true;\n    for (int n = 0; n < table->ColumnsCount; n++)\n        table->Columns[n].NameOffset = -1;\n    g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;\n}\n\nvoid ImGui::TableGcCompactTransientBuffers(ImGuiTableTempData* temp_data)\n{\n    temp_data->DrawSplitter.ClearFreeMemory();\n    temp_data->LastTimeActive = -1.0f;\n}\n\n// Compact and remove unused settings data (currently only used by TestEngine)\nvoid ImGui::TableGcCompactSettings()\n{\n    ImGuiContext& g = *GImGui;\n    int required_memory = 0;\n    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))\n        if (settings->ID != 0)\n            required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);\n    if (required_memory == g.SettingsTables.Buf.Size)\n        return;\n    ImChunkStream<ImGuiTableSettings> new_chunk_stream;\n    new_chunk_stream.Buf.reserve(required_memory);\n    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))\n        if (settings->ID != 0)\n            memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));\n    g.SettingsTables.swap(new_chunk_stream);\n}\n\n\n//-------------------------------------------------------------------------\n// [SECTION] Tables: Debugging\n//-------------------------------------------------------------------------\n// - DebugNodeTable() [Internal]\n//-------------------------------------------------------------------------\n\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n\nstatic const char* DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy)\n{\n    sizing_policy &= ImGuiTableFlags_SizingMask_;\n    if (sizing_policy == ImGuiTableFlags_SizingFixedFit)    { return \"FixedFit\"; }\n    if (sizing_policy == ImGuiTableFlags_SizingFixedSame)   { return \"FixedSame\"; }\n    if (sizing_policy == ImGuiTableFlags_SizingStretchProp) { return \"StretchProp\"; }\n    if (sizing_policy == ImGuiTableFlags_SizingStretchSame) { return \"StretchSame\"; }\n    return \"N/A\";\n}\n\nvoid ImGui::DebugNodeTable(ImGuiTable* table)\n{\n    ImGuiContext& g = *GImGui;\n    const bool is_active = (table->LastFrameActive >= g.FrameCount - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.\n    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }\n    bool open = TreeNode(table, \"Table 0x%08X (%d columns, in '%s')%s\", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? \"\" : \" *Inactive*\");\n    if (!is_active) { PopStyleColor(); }\n    if (IsItemHovered())\n        GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));\n    if (IsItemVisible() && table->HoveredColumnBody != -1)\n        GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));\n    if (!open)\n        return;\n    if (table->InstanceCurrent > 0)\n        Text(\"** %d instances of same table! Some data below will refer to last instance.\", table->InstanceCurrent + 1);\n    if (g.IO.ConfigDebugIsDebuggerPresent)\n    {\n        if (DebugBreakButton(\"**DebugBreak**\", \"in BeginTable()\"))\n            g.DebugBreakInTable = table->ID;\n        SameLine();\n    }\n\n    bool clear_settings = SmallButton(\"Clear settings\");\n    BulletText(\"OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'\", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));\n    BulletText(\"ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s\", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? \" (auto)\" : \"\");\n    BulletText(\"CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f\", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);\n    BulletText(\"HoveredColumnBody: %d, HoveredColumnBorder: %d\", table->HoveredColumnBody, table->HoveredColumnBorder);\n    BulletText(\"ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d\", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);\n    for (int n = 0; n < table->InstanceCurrent + 1; n++)\n    {\n        ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, n);\n        BulletText(\"Instance %d: HoveredRow: %d, LastOuterHeight: %.2f\", n, table_instance->HoveredRowLast, table_instance->LastOuterHeight);\n    }\n    //BulletText(\"BgDrawChannels: %d/%d\", 0, table->BgDrawChannelUnfrozen);\n    float sum_weights = 0.0f;\n    for (int n = 0; n < table->ColumnsCount; n++)\n        if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)\n            sum_weights += table->Columns[n].StretchWeight;\n    for (int n = 0; n < table->ColumnsCount; n++)\n    {\n        ImGuiTableColumn* column = &table->Columns[n];\n        const char* name = TableGetColumnName(table, n);\n        char buf[512];\n        ImFormatString(buf, IM_ARRAYSIZE(buf),\n            \"Column %d order %d '%s': offset %+.2f to %+.2f%s\\n\"\n            \"Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\\n\"\n            \"WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\\n\"\n            \"MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\\n\"\n            \"ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\\n\"\n            \"Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..\",\n            n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? \" (Frozen)\" : \"\",\n            column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,\n            column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,\n            column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,\n            column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,\n            column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? \" (Asc)\" : (column->SortDirection == ImGuiSortDirection_Descending) ? \" (Des)\" : \"\", column->UserID, column->Flags,\n            (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? \"WidthStretch \" : \"\",\n            (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? \"WidthFixed \" : \"\",\n            (column->Flags & ImGuiTableColumnFlags_NoResize) ? \"NoResize \" : \"\");\n        Bullet();\n        Selectable(buf);\n        if (IsItemHovered())\n        {\n            ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);\n            GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));\n        }\n    }\n    if (ImGuiTableSettings* settings = TableGetBoundSettings(table))\n        DebugNodeTableSettings(settings);\n    if (clear_settings)\n        table->IsResetAllRequest = true;\n    TreePop();\n}\n\nvoid ImGui::DebugNodeTableSettings(ImGuiTableSettings* settings)\n{\n    if (!TreeNode((void*)(intptr_t)settings->ID, \"Settings 0x%08X (%d columns)\", settings->ID, settings->ColumnsCount))\n        return;\n    BulletText(\"SaveFlags: 0x%08X\", settings->SaveFlags);\n    BulletText(\"ColumnsCount: %d (max %d)\", settings->ColumnsCount, settings->ColumnsCountMax);\n    for (int n = 0; n < settings->ColumnsCount; n++)\n    {\n        ImGuiTableColumnSettings* column_settings = &settings->GetColumnSettings()[n];\n        ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;\n        BulletText(\"Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X\",\n            n, column_settings->DisplayOrder, column_settings->SortOrder,\n            (sort_dir == ImGuiSortDirection_Ascending) ? \"Asc\" : (sort_dir == ImGuiSortDirection_Descending) ? \"Des\" : \"---\",\n            column_settings->IsEnabled, column_settings->IsStretch ? \"Weight\" : \"Width \", column_settings->WidthOrWeight, column_settings->UserID);\n    }\n    TreePop();\n}\n\n#else // #ifndef IMGUI_DISABLE_DEBUG_TOOLS\n\nvoid ImGui::DebugNodeTable(ImGuiTable*) {}\nvoid ImGui::DebugNodeTableSettings(ImGuiTableSettings*) {}\n\n#endif\n\n\n//-------------------------------------------------------------------------\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n// (This is a legacy API, prefer using BeginTable/EndTable!)\n//-------------------------------------------------------------------------\n// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)\n//-------------------------------------------------------------------------\n// - SetWindowClipRectBeforeSetChannel() [Internal]\n// - GetColumnIndex()\n// - GetColumnsCount()\n// - GetColumnOffset()\n// - GetColumnWidth()\n// - SetColumnOffset()\n// - SetColumnWidth()\n// - PushColumnClipRect() [Internal]\n// - PushColumnsBackground() [Internal]\n// - PopColumnsBackground() [Internal]\n// - FindOrCreateColumns() [Internal]\n// - GetColumnsID() [Internal]\n// - BeginColumns()\n// - NextColumn()\n// - EndColumns()\n// - Columns()\n//-------------------------------------------------------------------------\n\n// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,\n// they would meddle many times with the underlying ImDrawCmd.\n// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let\n// the subsequent single call to SetCurrentChannel() does it things once.\nvoid ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect)\n{\n    ImVec4 clip_rect_vec4 = clip_rect.ToVec4();\n    window->ClipRect = clip_rect;\n    window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;\n    window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;\n}\n\nint ImGui::GetColumnIndex()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;\n}\n\nint ImGui::GetColumnsCount()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;\n}\n\nfloat ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm)\n{\n    return offset_norm * (columns->OffMaxX - columns->OffMinX);\n}\n\nfloat ImGui::GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset)\n{\n    return offset / (columns->OffMaxX - columns->OffMinX);\n}\n\nstatic const float COLUMNS_HIT_RECT_HALF_THICKNESS = 4.0f;\n\nstatic float GetDraggedColumnOffset(ImGuiOldColumns* columns, int column_index)\n{\n    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing\n    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.\n    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));\n\n    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale) - window->Pos.x;\n    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);\n    if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))\n        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);\n\n    return x;\n}\n\nfloat ImGui::GetColumnOffset(int column_index)\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    if (columns == NULL)\n        return 0.0f;\n\n    if (column_index < 0)\n        column_index = columns->Current;\n    IM_ASSERT(column_index < columns->Columns.Size);\n\n    const float t = columns->Columns[column_index].OffsetNorm;\n    const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);\n    return x_offset;\n}\n\nstatic float GetColumnWidthEx(ImGuiOldColumns* columns, int column_index, bool before_resize = false)\n{\n    if (column_index < 0)\n        column_index = columns->Current;\n\n    float offset_norm;\n    if (before_resize)\n        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;\n    else\n        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;\n    return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);\n}\n\nfloat ImGui::GetColumnWidth(int column_index)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    if (columns == NULL)\n        return GetContentRegionAvail().x;\n\n    if (column_index < 0)\n        column_index = columns->Current;\n    return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);\n}\n\nvoid ImGui::SetColumnOffset(int column_index, float offset)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    IM_ASSERT(columns != NULL);\n\n    if (column_index < 0)\n        column_index = columns->Current;\n    IM_ASSERT(column_index < columns->Columns.Size);\n\n    const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);\n    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;\n\n    if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))\n        offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));\n    columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);\n\n    if (preserve_width)\n        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));\n}\n\nvoid ImGui::SetColumnWidth(int column_index, float width)\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    IM_ASSERT(columns != NULL);\n\n    if (column_index < 0)\n        column_index = columns->Current;\n    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);\n}\n\nvoid ImGui::PushColumnClipRect(int column_index)\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    if (column_index < 0)\n        column_index = columns->Current;\n\n    ImGuiOldColumnData* column = &columns->Columns[column_index];\n    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);\n}\n\n// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)\nvoid ImGui::PushColumnsBackground()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    if (columns->Count == 1)\n        return;\n\n    // Optimization: avoid SetCurrentChannel() + PushClipRect()\n    columns->HostBackupClipRect = window->ClipRect;\n    SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);\n    columns->Splitter.SetCurrentChannel(window->DrawList, 0);\n}\n\nvoid ImGui::PopColumnsBackground()\n{\n    ImGuiWindow* window = GetCurrentWindowRead();\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    if (columns->Count == 1)\n        return;\n\n    // Optimization: avoid PopClipRect() + SetCurrentChannel()\n    SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);\n    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);\n}\n\nImGuiOldColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)\n{\n    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.\n    for (int n = 0; n < window->ColumnsStorage.Size; n++)\n        if (window->ColumnsStorage[n].ID == id)\n            return &window->ColumnsStorage[n];\n\n    window->ColumnsStorage.push_back(ImGuiOldColumns());\n    ImGuiOldColumns* columns = &window->ColumnsStorage.back();\n    columns->ID = id;\n    return columns;\n}\n\nImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n\n    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.\n    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.\n    PushID(0x11223347 + (str_id ? 0 : columns_count));\n    ImGuiID id = window->GetID(str_id ? str_id : \"columns\");\n    PopID();\n\n    return id;\n}\n\nvoid ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiOldColumnFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n\n    IM_ASSERT(columns_count >= 1);\n    IM_ASSERT(window->DC.CurrentColumns == NULL);   // Nested columns are currently not supported\n\n    // Acquire storage for the columns set\n    ImGuiID id = GetColumnsID(str_id, columns_count);\n    ImGuiOldColumns* columns = FindOrCreateColumns(window, id);\n    IM_ASSERT(columns->ID == id);\n    columns->Current = 0;\n    columns->Count = columns_count;\n    columns->Flags = flags;\n    window->DC.CurrentColumns = columns;\n    window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();\n\n    columns->HostCursorPosY = window->DC.CursorPos.y;\n    columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;\n    columns->HostInitialClipRect = window->ClipRect;\n    columns->HostBackupParentWorkRect = window->ParentWorkRect;\n    window->ParentWorkRect = window->WorkRect;\n\n    // Set state for first column\n    // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect\n    const float column_padding = g.Style.ItemSpacing.x;\n    const float half_clip_extend_x = ImTrunc(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));\n    const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);\n    const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;\n    columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);\n    columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);\n    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;\n\n    // Clear data if columns count changed\n    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)\n        columns->Columns.resize(0);\n\n    // Initialize default widths\n    columns->IsFirstFrame = (columns->Columns.Size == 0);\n    if (columns->Columns.Size == 0)\n    {\n        columns->Columns.reserve(columns_count + 1);\n        for (int n = 0; n < columns_count + 1; n++)\n        {\n            ImGuiOldColumnData column;\n            column.OffsetNorm = n / (float)columns_count;\n            columns->Columns.push_back(column);\n        }\n    }\n\n    for (int n = 0; n < columns_count; n++)\n    {\n        // Compute clipping rectangle\n        ImGuiOldColumnData* column = &columns->Columns[n];\n        float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));\n        float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);\n        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);\n        column->ClipRect.ClipWithFull(window->ClipRect);\n    }\n\n    if (columns->Count > 1)\n    {\n        columns->Splitter.Split(window->DrawList, 1 + columns->Count);\n        columns->Splitter.SetCurrentChannel(window->DrawList, 1);\n        PushColumnClipRect(0);\n    }\n\n    // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.\n    float offset_0 = GetColumnOffset(columns->Current);\n    float offset_1 = GetColumnOffset(columns->Current + 1);\n    float width = offset_1 - offset_0;\n    PushItemWidth(width * 0.65f);\n    window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);\n    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\n    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;\n    window->WorkRect.Max.y = window->ContentRegionRect.Max.y;\n}\n\nvoid ImGui::NextColumn()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems || window->DC.CurrentColumns == NULL)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n\n    if (columns->Count == 1)\n    {\n        window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\n        IM_ASSERT(columns->Current == 0);\n        return;\n    }\n\n    // Next column\n    if (++columns->Current == columns->Count)\n        columns->Current = 0;\n\n    PopItemWidth();\n\n    // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()\n    // (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),\n    ImGuiOldColumnData* column = &columns->Columns[columns->Current];\n    SetWindowClipRectBeforeSetChannel(window, column->ClipRect);\n    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);\n\n    const float column_padding = g.Style.ItemSpacing.x;\n    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);\n    if (columns->Current > 0)\n    {\n        // Columns 1+ ignore IndentX (by canceling it out)\n        // FIXME-COLUMNS: Unnecessary, could be locked?\n        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;\n    }\n    else\n    {\n        // New row/line: column 0 honor IndentX.\n        window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);\n        window->DC.IsSameLine = false;\n        columns->LineMinY = columns->LineMaxY;\n    }\n    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\n    window->DC.CursorPos.y = columns->LineMinY;\n    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);\n    window->DC.CurrLineTextBaseOffset = 0.0f;\n\n    // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.\n    float offset_0 = GetColumnOffset(columns->Current);\n    float offset_1 = GetColumnOffset(columns->Current + 1);\n    float width = offset_1 - offset_0;\n    PushItemWidth(width * 0.65f);\n    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;\n}\n\nvoid ImGui::EndColumns()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    IM_ASSERT(columns != NULL);\n\n    PopItemWidth();\n    if (columns->Count > 1)\n    {\n        PopClipRect();\n        columns->Splitter.Merge(window->DrawList);\n    }\n\n    const ImGuiOldColumnFlags flags = columns->Flags;\n    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);\n    window->DC.CursorPos.y = columns->LineMaxY;\n    if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))\n        window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent\n\n    // Draw columns borders and handle resize\n    // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy\n    bool is_being_resized = false;\n    if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)\n    {\n        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.\n        const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);\n        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);\n        int dragging_column = -1;\n        for (int n = 1; n < columns->Count; n++)\n        {\n            ImGuiOldColumnData* column = &columns->Columns[n];\n            float x = window->Pos.x + GetColumnOffset(n);\n            const ImGuiID column_id = columns->ID + ImGuiID(n);\n            const float column_hit_hw = ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale);\n            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));\n            if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))\n                continue;\n\n            bool hovered = false, held = false;\n            if (!(flags & ImGuiOldColumnFlags_NoResize))\n            {\n                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);\n                if (hovered || held)\n                    SetMouseCursor(ImGuiMouseCursor_ResizeEW);\n                if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))\n                    dragging_column = n;\n            }\n\n            // Draw column\n            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);\n            const float xi = IM_TRUNC(x);\n            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);\n        }\n\n        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.\n        if (dragging_column != -1)\n        {\n            if (!columns->IsBeingResized)\n                for (int n = 0; n < columns->Count + 1; n++)\n                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;\n            columns->IsBeingResized = is_being_resized = true;\n            float x = GetDraggedColumnOffset(columns, dragging_column);\n            SetColumnOffset(dragging_column, x);\n        }\n    }\n    columns->IsBeingResized = is_being_resized;\n\n    window->WorkRect = window->ParentWorkRect;\n    window->ParentWorkRect = columns->HostBackupParentWorkRect;\n    window->DC.CurrentColumns = NULL;\n    window->DC.ColumnsOffset.x = 0.0f;\n    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\n    NavUpdateCurrentWindowIsScrollPushableX();\n}\n\nvoid ImGui::Columns(int columns_count, const char* id, bool borders)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    IM_ASSERT(columns_count >= 1);\n\n    ImGuiOldColumnFlags flags = (borders ? 0 : ImGuiOldColumnFlags_NoBorder);\n    //flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior\n    ImGuiOldColumns* columns = window->DC.CurrentColumns;\n    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)\n        return;\n\n    if (columns != NULL)\n        EndColumns();\n\n    if (columns_count != 1)\n        BeginColumns(id, columns_count, flags);\n}\n\n//-------------------------------------------------------------------------\n\n#endif // #ifndef IMGUI_DISABLE\n"
        },
        {
          "name": "imgui_widgets.cpp",
          "type": "blob",
          "size": 500.49,
          "content": "// dear imgui, v1.91.7 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Box-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: Multi-Select helpers\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wunused-macros\"                  // warning: macro is not used                                // we define snprintf/vsnprintf on Windows so they are available, but not always used.\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#pragma clang diagnostic ignored \"-Wnontrivial-memaccess\"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"                      // warning: comparing floating-point with '==' or '!=' is unsafe\n#pragma GCC diagnostic ignored \"-Wformat\"                           // warning: format '%p' expects argument of type 'int'/'void*', but argument X has type 'unsigned int'/'ImGuiWindow*'\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"  // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"                  // warning: assuming signed overflow does not occur when simplifying division / ..when changing X +- C1 cmp C2 to X cmp C2 -+ C1\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                        // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers\n#endif\n\n//-------------------------------------------------------------------------\n// Data\n//-------------------------------------------------------------------------\n\n// Widgets\nstatic const float          DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f;    // Time for drag-hold to activate items accepting the ImGuiButtonFlags_PressedOnDragDropHold button behavior.\nstatic const float          DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f;    // Multiplier for the default value of io.MouseDragThreshold to make DragFloat/DragInt react faster to mouse drags.\n\n// Those MIN/MAX values are not define because we need to point to them\nstatic const signed char    IM_S8_MIN  = -128;\nstatic const signed char    IM_S8_MAX  = 127;\nstatic const unsigned char  IM_U8_MIN  = 0;\nstatic const unsigned char  IM_U8_MAX  = 0xFF;\nstatic const signed short   IM_S16_MIN = -32768;\nstatic const signed short   IM_S16_MAX = 32767;\nstatic const unsigned short IM_U16_MIN = 0;\nstatic const unsigned short IM_U16_MAX = 0xFFFF;\nstatic const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);\nstatic const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)\nstatic const ImU32          IM_U32_MIN = 0;\nstatic const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)\n#ifdef LLONG_MIN\nstatic const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);\nstatic const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);\n#else\nstatic const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;\nstatic const ImS64          IM_S64_MAX = 9223372036854775807LL;\n#endif\nstatic const ImU64          IM_U64_MIN = 0;\n#ifdef ULLONG_MAX\nstatic const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);\n#else\nstatic const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] Forward Declarations\n//-------------------------------------------------------------------------\n\n// For InputTextEx()\nstatic bool     InputTextFilterCharacter(ImGuiContext* ctx, unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, bool input_source_is_clipboard = false);\nstatic int      InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);\nstatic ImVec2   InputTextCalcTextSize(ImGuiContext* ctx, const char* text_begin, const char* text_end, const char** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Text, etc.\n//-------------------------------------------------------------------------\n// - TextEx() [Internal]\n// - TextUnformatted()\n// - Text()\n// - TextV()\n// - TextColored()\n// - TextColoredV()\n// - TextDisabled()\n// - TextDisabledV()\n// - TextWrapped()\n// - TextWrappedV()\n// - LabelText()\n// - LabelTextV()\n// - BulletText()\n// - BulletTextV()\n//-------------------------------------------------------------------------\n\nvoid ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n    ImGuiContext& g = *GImGui;\n\n    // Accept null ranges\n    if (text == text_end)\n        text = text_end = \"\";\n\n    // Calculate length\n    const char* text_begin = text;\n    if (text_end == NULL)\n        text_end = text + strlen(text); // FIXME-OPT\n\n    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);\n    const float wrap_pos_x = window->DC.TextWrapPos;\n    const bool wrap_enabled = (wrap_pos_x >= 0.0f);\n    if (text_end - text <= 2000 || wrap_enabled)\n    {\n        // Common case\n        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;\n        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);\n\n        ImRect bb(text_pos, text_pos + text_size);\n        ItemSize(text_size, 0.0f);\n        if (!ItemAdd(bb, 0))\n            return;\n\n        // Render (we don't hide text after ## in this end-user function)\n        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);\n    }\n    else\n    {\n        // Long text!\n        // Perform manual coarse clipping to optimize for long multi-line text\n        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.\n        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.\n        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.\n        const char* line = text;\n        const float line_height = GetTextLineHeight();\n        ImVec2 text_size(0, 0);\n\n        // Lines to skip (can't skip when logging text)\n        ImVec2 pos = text_pos;\n        if (!g.LogEnabled)\n        {\n            int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);\n            if (lines_skippable > 0)\n            {\n                int lines_skipped = 0;\n                while (line < text_end && lines_skipped < lines_skippable)\n                {\n                    const char* line_end = (const char*)memchr(line, '\\n', text_end - line);\n                    if (!line_end)\n                        line_end = text_end;\n                    if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)\n                        text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);\n                    line = line_end + 1;\n                    lines_skipped++;\n                }\n                pos.y += lines_skipped * line_height;\n            }\n        }\n\n        // Lines to render\n        if (line < text_end)\n        {\n            ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));\n            while (line < text_end)\n            {\n                if (IsClippedEx(line_rect, 0))\n                    break;\n\n                const char* line_end = (const char*)memchr(line, '\\n', text_end - line);\n                if (!line_end)\n                    line_end = text_end;\n                text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);\n                RenderText(pos, line, line_end, false);\n                line = line_end + 1;\n                line_rect.Min.y += line_height;\n                line_rect.Max.y += line_height;\n                pos.y += line_height;\n            }\n\n            // Count remaining lines\n            int lines_skipped = 0;\n            while (line < text_end)\n            {\n                const char* line_end = (const char*)memchr(line, '\\n', text_end - line);\n                if (!line_end)\n                    line_end = text_end;\n                if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)\n                    text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);\n                line = line_end + 1;\n                lines_skipped++;\n            }\n            pos.y += lines_skipped * line_height;\n        }\n        text_size.y = (pos - text_pos).y;\n\n        ImRect bb(text_pos, text_pos + text_size);\n        ItemSize(text_size, 0.0f);\n        ItemAdd(bb, 0);\n    }\n}\n\nvoid ImGui::TextUnformatted(const char* text, const char* text_end)\n{\n    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);\n}\n\nvoid ImGui::Text(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    TextV(fmt, args);\n    va_end(args);\n}\n\nvoid ImGui::TextV(const char* fmt, va_list args)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    const char* text, *text_end;\n    ImFormatStringToTempBufferV(&text, &text_end, fmt, args);\n    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);\n}\n\nvoid ImGui::TextColored(const ImVec4& col, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    TextColoredV(col, fmt, args);\n    va_end(args);\n}\n\nvoid ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)\n{\n    PushStyleColor(ImGuiCol_Text, col);\n    TextV(fmt, args);\n    PopStyleColor();\n}\n\nvoid ImGui::TextDisabled(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    TextDisabledV(fmt, args);\n    va_end(args);\n}\n\nvoid ImGui::TextDisabledV(const char* fmt, va_list args)\n{\n    ImGuiContext& g = *GImGui;\n    PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\n    TextV(fmt, args);\n    PopStyleColor();\n}\n\nvoid ImGui::TextWrapped(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    TextWrappedV(fmt, args);\n    va_end(args);\n}\n\nvoid ImGui::TextWrappedV(const char* fmt, va_list args)\n{\n    ImGuiContext& g = *GImGui;\n    const bool need_backup = (g.CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set\n    if (need_backup)\n        PushTextWrapPos(0.0f);\n    TextV(fmt, args);\n    if (need_backup)\n        PopTextWrapPos();\n}\n\nvoid ImGui::LabelText(const char* label, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    LabelTextV(label, fmt, args);\n    va_end(args);\n}\n\n// Add a label+text combo aligned to other label+value widgets\nvoid ImGui::LabelTextV(const char* label, const char* fmt, va_list args)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const float w = CalcItemWidth();\n\n    const char* value_text_begin, *value_text_end;\n    ImFormatStringToTempBufferV(&value_text_begin, &value_text_end, fmt, args);\n    const ImVec2 value_size = CalcTextSize(value_text_begin, value_text_end, false);\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    const ImVec2 pos = window->DC.CursorPos;\n    const ImRect value_bb(pos, pos + ImVec2(w, value_size.y + style.FramePadding.y * 2));\n    const ImRect total_bb(pos, pos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), ImMax(value_size.y, label_size.y) + style.FramePadding.y * 2));\n    ItemSize(total_bb, style.FramePadding.y);\n    if (!ItemAdd(total_bb, 0))\n        return;\n\n    // Render\n    RenderTextClipped(value_bb.Min + style.FramePadding, value_bb.Max, value_text_begin, value_text_end, &value_size, ImVec2(0.0f, 0.0f));\n    if (label_size.x > 0.0f)\n        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);\n}\n\nvoid ImGui::BulletText(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    BulletTextV(fmt, args);\n    va_end(args);\n}\n\n// Text with a little bullet aligned to the typical tree node.\nvoid ImGui::BulletTextV(const char* fmt, va_list args)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n\n    const char* text_begin, *text_end;\n    ImFormatStringToTempBufferV(&text_begin, &text_end, fmt, args);\n    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);\n    const ImVec2 total_size = ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), label_size.y);  // Empty text doesn't add padding\n    ImVec2 pos = window->DC.CursorPos;\n    pos.y += window->DC.CurrLineTextBaseOffset;\n    ItemSize(total_size, 0.0f);\n    const ImRect bb(pos, pos + total_size);\n    if (!ItemAdd(bb, 0))\n        return;\n\n    // Render\n    ImU32 text_col = GetColorU32(ImGuiCol_Text);\n    RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, g.FontSize * 0.5f), text_col);\n    RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, 0.0f), text_begin, text_end, false);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Main\n//-------------------------------------------------------------------------\n// - ButtonBehavior() [Internal]\n// - Button()\n// - SmallButton()\n// - InvisibleButton()\n// - ArrowButton()\n// - CloseButton() [Internal]\n// - CollapseButton() [Internal]\n// - GetWindowScrollbarID() [Internal]\n// - GetWindowScrollbarRect() [Internal]\n// - Scrollbar() [Internal]\n// - ScrollbarEx() [Internal]\n// - Image()\n// - ImageButton()\n// - Checkbox()\n// - CheckboxFlagsT() [Internal]\n// - CheckboxFlags()\n// - RadioButton()\n// - ProgressBar()\n// - Bullet()\n// - Hyperlink()\n//-------------------------------------------------------------------------\n\n// The ButtonBehavior() function is key to many interactions and used by many/most widgets.\n// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),\n// this code is a little complex.\n// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.\n// See the series of events below and the corresponding state reported by dear imgui:\n//------------------------------------------------------------------------------------------------------------------------------------------------\n// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()\n//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -\n//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -\n//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true\n//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -\n//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -\n//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -\n//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -\n//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -\n//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -\n//------------------------------------------------------------------------------------------------------------------------------------------------\n// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()\n//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true\n//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -\n//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -\n//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -\n//------------------------------------------------------------------------------------------------------------------------------------------------\n// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()\n//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true\n//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -\n//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -\n//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -\n//------------------------------------------------------------------------------------------------------------------------------------------------\n// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()\n//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true\n//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -\n//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -\n//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -\n//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true\n//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -\n//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -\n//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -\n//------------------------------------------------------------------------------------------------------------------------------------------------\n// Note that some combinations are supported,\n// - PressedOnDragDropHold can generally be associated with any flag.\n// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.\n//------------------------------------------------------------------------------------------------------------------------------------------------\n// The behavior of the return-value changes when ImGuiItemFlags_ButtonRepeat is set:\n//                                         Repeat+                  Repeat+           Repeat+             Repeat+\n//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick\n//-------------------------------------------------------------------------------------------------------------------------------------------------\n//   Frame N+0 (mouse button is down)       -                        true              -                   true\n//   ...                                    -                        -                 -                   -\n//   Frame N + RepeatDelay                  true                     true              -                   true\n//   ...                                    -                        -                 -                   -\n//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true\n//-------------------------------------------------------------------------------------------------------------------------------------------------\n\n// - FIXME: For refactor we could output flags, incl mouse hovered vs nav keyboard vs nav triggered etc.\n//   And better standardize how widgets use 'GetColor32((held && hovered) ? ... : hovered ? ...)' vs 'GetColor32(held ? ... : hovered ? ...);'\n//   For mouse feedback we typically prefer the 'held && hovered' test, but for nav feedback not always. Outputting hovered=true on Activation may be misleading.\n// - Since v1.91.2 (Sept 2024) we included io.ConfigDebugHighlightIdConflicts feature.\n//   One idiom which was previously valid which will now emit a warning is when using multiple overlayed ButtonBehavior()\n//   with same ID and different MouseButton (see #8030). You can fix it by:\n//       (1) switching to use a single ButtonBehavior() with multiple _MouseButton flags.\n//    or (2) surrounding those calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()\nbool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n\n    // Default behavior inherited from item flags\n    // Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.\n    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.ItemFlags : g.CurrentItemFlags);\n    if (flags & ImGuiButtonFlags_AllowOverlap)\n        item_flags |= ImGuiItemFlags_AllowOverlap;\n\n    // Default only reacts to left mouse button\n    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)\n        flags |= ImGuiButtonFlags_MouseButtonLeft;\n\n    // Default behavior requires click + release inside bounding box\n    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)\n        flags |= (item_flags & ImGuiItemFlags_ButtonRepeat) ? ImGuiButtonFlags_PressedOnClick : ImGuiButtonFlags_PressedOnDefault_;\n\n    ImGuiWindow* backup_hovered_window = g.HoveredWindow;\n    const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindow == window;\n    if (flatten_hovered_children)\n        g.HoveredWindow = window;\n\n#ifdef IMGUI_ENABLE_TEST_ENGINE\n    // Alternate registration spot, for when caller didn't use ItemAdd()\n    if (g.LastItemData.ID != id)\n        IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);\n#endif\n\n    bool pressed = false;\n    bool hovered = ItemHoverable(bb, id, item_flags);\n\n    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button\n    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))\n        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\n        {\n            hovered = true;\n            SetHoveredID(id);\n            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)\n            {\n                pressed = true;\n                g.DragDropHoldJustPressedId = id;\n                FocusWindow(window);\n            }\n        }\n\n    if (flatten_hovered_children)\n        g.HoveredWindow = backup_hovered_window;\n\n    // Mouse handling\n    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;\n    if (hovered)\n    {\n        IM_ASSERT(id != 0); // Lazily check inside rare path.\n\n        // Poll mouse buttons\n        // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.\n        // - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.\n        int mouse_button_clicked = -1;\n        int mouse_button_released = -1;\n        for (int button = 0; button < 3; button++)\n            if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.\n            {\n                if (IsMouseClicked(button, ImGuiInputFlags_None, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }\n                if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }\n            }\n\n        // Process initial action\n        const bool mods_ok = !(flags & ImGuiButtonFlags_NoKeyModsAllowed) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt);\n        if (mods_ok)\n        {\n            if (mouse_button_clicked != -1 && g.ActiveId != id)\n            {\n                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))\n                    SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);\n                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))\n                {\n                    SetActiveID(id, window);\n                    g.ActiveIdMouseButton = mouse_button_clicked;\n                    if (!(flags & ImGuiButtonFlags_NoNavFocus))\n                    {\n                        SetFocusID(id, window);\n                        FocusWindow(window);\n                    }\n                    else\n                    {\n                        FocusWindow(window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child\n                    }\n                }\n                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))\n                {\n                    pressed = true;\n                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)\n                        ClearActiveID();\n                    else\n                        SetActiveID(id, window); // Hold on ID\n                    g.ActiveIdMouseButton = mouse_button_clicked;\n                    if (!(flags & ImGuiButtonFlags_NoNavFocus))\n                    {\n                        SetFocusID(id, window);\n                        FocusWindow(window);\n                    }\n                    else\n                    {\n                        FocusWindow(window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child\n                    }\n                }\n            }\n            if (flags & ImGuiButtonFlags_PressedOnRelease)\n            {\n                if (mouse_button_released != -1)\n                {\n                    const bool has_repeated_at_least_once = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior\n                    if (!has_repeated_at_least_once)\n                        pressed = true;\n                    if (!(flags & ImGuiButtonFlags_NoNavFocus))\n                        SetFocusID(id, window); // FIXME: Lack of FocusWindow() call here is inconsistent with other paths. Research why.\n                    ClearActiveID();\n                }\n            }\n\n            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).\n            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.\n            if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))\n                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, ImGuiInputFlags_Repeat, test_owner_id))\n                    pressed = true;\n        }\n\n        if (pressed && g.IO.ConfigNavCursorVisibleAuto)\n            g.NavCursorVisible = false;\n    }\n\n    // Keyboard/Gamepad navigation handling\n    // We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with mouse.\n    if (g.NavId == id && g.NavCursorVisible && g.NavHighlightItemUnderNav)\n        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))\n            hovered = true;\n    if (g.NavActivateDownId == id)\n    {\n        bool nav_activated_by_code = (g.NavActivateId == id);\n        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);\n        if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat))\n        {\n            // Avoid pressing multiple keys from triggering excessive amount of repeat events\n            const ImGuiKeyData* key1 = GetKeyData(ImGuiKey_Space);\n            const ImGuiKeyData* key2 = GetKeyData(ImGuiKey_Enter);\n            const ImGuiKeyData* key3 = GetKeyData(ImGuiKey_NavGamepadActivate);\n            const float t1 = ImMax(ImMax(key1->DownDuration, key2->DownDuration), key3->DownDuration);\n            nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;\n        }\n        if (nav_activated_by_code || nav_activated_by_inputs)\n        {\n            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.\n            pressed = true;\n            SetActiveID(id, window);\n            g.ActiveIdSource = g.NavInputSource;\n            if (!(flags & ImGuiButtonFlags_NoNavFocus) && !(g.NavActivateFlags & ImGuiActivateFlags_FromShortcut))\n                SetFocusID(id, window);\n            if (g.NavActivateFlags & ImGuiActivateFlags_FromShortcut)\n                g.ActiveIdFromShortcut = true;\n        }\n    }\n\n    // Process while held\n    bool held = false;\n    if (g.ActiveId == id)\n    {\n        if (g.ActiveIdSource == ImGuiInputSource_Mouse)\n        {\n            if (g.ActiveIdIsJustActivated)\n                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;\n\n            const int mouse_button = g.ActiveIdMouseButton;\n            if (mouse_button == -1)\n            {\n                // Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).\n                ClearActiveID();\n            }\n            else if (IsMouseDown(mouse_button, test_owner_id))\n            {\n                held = true;\n            }\n            else\n            {\n                bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;\n                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;\n                if ((release_in || release_anywhere) && !g.DragDropActive)\n                {\n                    // Report as pressed when releasing the mouse (this is the most common path)\n                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;\n                    bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>\n                    bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);\n                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)\n                        pressed = true;\n                }\n                ClearActiveID();\n            }\n            if (!(flags & ImGuiButtonFlags_NoNavFocus) && g.IO.ConfigNavCursorVisibleAuto)\n                g.NavCursorVisible = false;\n        }\n        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)\n        {\n            // When activated using Nav, we hold on the ActiveID until activation button is released\n            if (g.NavActivateDownId == id)\n                held = true; // hovered == true not true as we are already likely hovered on direct activation.\n            else\n                ClearActiveID();\n        }\n        if (pressed)\n            g.ActiveIdHasBeenPressedBefore = true;\n    }\n\n    // Activation highlight (this may be a remote activation)\n    if (g.NavHighlightActivatedId == id)\n        hovered = true;\n\n    if (out_hovered) *out_hovered = hovered;\n    if (out_held) *out_held = held;\n\n    return pressed;\n}\n\nbool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    ImVec2 pos = window->DC.CursorPos;\n    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)\n        pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;\n    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);\n\n    const ImRect bb(pos, pos + size);\n    ItemSize(size, style.FramePadding.y);\n    if (!ItemAdd(bb, id))\n        return false;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\n\n    // Render\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\n    RenderNavCursor(bb, id);\n    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);\n\n    if (g.LogEnabled)\n        LogSetNextTextDecoration(\"[\", \"]\");\n    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);\n\n    // Automatically close popups\n    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))\n    //    CloseCurrentPopup();\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);\n    return pressed;\n}\n\nbool ImGui::Button(const char* label, const ImVec2& size_arg)\n{\n    return ButtonEx(label, size_arg, ImGuiButtonFlags_None);\n}\n\n// Small buttons fits within text without additional vertical spacing.\nbool ImGui::SmallButton(const char* label)\n{\n    ImGuiContext& g = *GImGui;\n    float backup_padding_y = g.Style.FramePadding.y;\n    g.Style.FramePadding.y = 0.0f;\n    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);\n    g.Style.FramePadding.y = backup_padding_y;\n    return pressed;\n}\n\n// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.\n// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)\nbool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg, ImGuiButtonFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.\n    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);\n\n    const ImGuiID id = window->GetID(str_id);\n    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\n    ItemSize(size);\n    if (!ItemAdd(bb, id, NULL, (flags & ImGuiButtonFlags_EnableNav) ? ImGuiItemFlags_None : ImGuiItemFlags_NoNav))\n        return false;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\n    RenderNavCursor(bb, id);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);\n    return pressed;\n}\n\nbool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    const ImGuiID id = window->GetID(str_id);\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\n    const float default_size = GetFrameHeight();\n    ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0f);\n    if (!ItemAdd(bb, id))\n        return false;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\n\n    // Render\n    const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\n    const ImU32 text_col = GetColorU32(ImGuiCol_Text);\n    RenderNavCursor(bb, id);\n    RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);\n    RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);\n    return pressed;\n}\n\nbool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)\n{\n    float sz = GetFrameHeight();\n    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), ImGuiButtonFlags_None);\n}\n\n// Button to close a window\nbool ImGui::CloseButton(ImGuiID id, const ImVec2& pos)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    // Tweak 1: Shrink hit-testing area if button covers an abnormally large proportion of the visible region. That's in order to facilitate moving the window away. (#3825)\n    // This may better be applied as a general hit-rect reduction mechanism for all widgets to ensure the area to move window is always accessible?\n    const ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));\n    ImRect bb_interact = bb;\n    const float area_to_visible_ratio = window->OuterRectClipped.GetArea() / bb.GetArea();\n    if (area_to_visible_ratio < 1.5f)\n        bb_interact.Expand(ImTrunc(bb_interact.GetSize() * -0.25f));\n\n    // Tweak 2: We intentionally allow interaction when clipped so that a mechanical Alt,Right,Activate sequence can always close a window.\n    // (this isn't the common behavior of buttons, but it doesn't affect the user because navigation tends to keep items visible in scrolling layer).\n    bool is_clipped = !ItemAdd(bb_interact, id);\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb_interact, id, &hovered, &held);\n    if (is_clipped)\n        return pressed;\n\n    // Render\n    ImU32 bg_col = GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered);\n    if (hovered)\n        window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);\n    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact);\n    ImU32 cross_col = GetColorU32(ImGuiCol_Text);\n    ImVec2 cross_center = bb.GetCenter() - ImVec2(0.5f, 0.5f);\n    float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;\n    window->DrawList->AddLine(cross_center + ImVec2(+cross_extent, +cross_extent), cross_center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);\n    window->DrawList->AddLine(cross_center + ImVec2(+cross_extent, -cross_extent), cross_center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);\n\n    return pressed;\n}\n\nbool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));\n    bool is_clipped = !ItemAdd(bb, id);\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);\n    if (is_clipped)\n        return pressed;\n\n    // Render\n    ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\n    ImU32 text_col = GetColorU32(ImGuiCol_Text);\n    if (hovered || held)\n        window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);\n    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact);\n    RenderArrow(window->DrawList, bb.Min, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);\n\n    // Switch to moving the window after mouse is moved beyond the initial drag threshold\n    if (IsItemActive() && IsMouseDragging(0))\n        StartMouseMovingWindow(window);\n\n    return pressed;\n}\n\nImGuiID ImGui::GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis)\n{\n    return window->GetID(axis == ImGuiAxis_X ? \"#SCROLLX\" : \"#SCROLLY\");\n}\n\n// Return scrollbar rectangle, must only be called for corresponding axis if window->ScrollbarX/Y is set.\nImRect ImGui::GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis)\n{\n    const ImRect outer_rect = window->Rect();\n    const ImRect inner_rect = window->InnerRect;\n    const float border_size = window->WindowBorderSize;\n    const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)\n    IM_ASSERT(scrollbar_size > 0.0f);\n    if (axis == ImGuiAxis_X)\n        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);\n    else\n        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);\n}\n\nvoid ImGui::Scrollbar(ImGuiAxis axis)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    const ImGuiID id = GetWindowScrollbarID(window, axis);\n\n    // Calculate scrollbar bounding box\n    ImRect bb = GetWindowScrollbarRect(window, axis);\n    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;\n    if (axis == ImGuiAxis_X)\n    {\n        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;\n        if (!window->ScrollbarY)\n            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;\n    }\n    else\n    {\n        if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))\n            rounding_corners |= ImDrawFlags_RoundCornersTopRight;\n        if (!window->ScrollbarX)\n            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;\n    }\n    float size_visible = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];\n    float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;\n    ImS64 scroll = (ImS64)window->Scroll[axis];\n    ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_visible, (ImS64)size_contents, rounding_corners);\n    window->Scroll[axis] = (float)scroll;\n}\n\n// Vertical/Horizontal scrollbar\n// The entire piece of code below is rather confusing because:\n// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)\n// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar\n// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.\n// Still, the code should probably be made simpler..\nbool ImGui::ScrollbarEx(const ImRect& bb_frame, ImGuiID id, ImGuiAxis axis, ImS64* p_scroll_v, ImS64 size_visible_v, ImS64 size_contents_v, ImDrawFlags draw_rounding_flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    const float bb_frame_width = bb_frame.GetWidth();\n    const float bb_frame_height = bb_frame.GetHeight();\n    if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)\n        return false;\n\n    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)\n    float alpha = 1.0f;\n    if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)\n        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));\n    if (alpha <= 0.0f)\n        return false;\n\n    const ImGuiStyle& style = g.Style;\n    const bool allow_interaction = (alpha >= 1.0f);\n\n    ImRect bb = bb_frame;\n    bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));\n\n    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)\n    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();\n\n    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)\n    // But we maintain a minimum size in pixel to allow for the user to still aim inside.\n    IM_ASSERT(ImMax(size_contents_v, size_visible_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.\n    const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_visible_v), (ImS64)1);\n    const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_visible_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);\n    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;\n\n    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().\n    bool held = false;\n    bool hovered = false;\n    ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);\n    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);\n\n    const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_visible_v);\n    float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);\n    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space\n    if (held && allow_interaction && grab_h_norm < 1.0f)\n    {\n        const float scrollbar_pos_v = bb.Min[axis];\n        const float mouse_pos_v = g.IO.MousePos[axis];\n\n        // Click position in scrollbar normalized space (0.0f->1.0f)\n        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);\n\n        const int held_dir = (clicked_v_norm < grab_v_norm) ? -1 : (clicked_v_norm > grab_v_norm + grab_h_norm) ? +1 : 0;\n        if (g.ActiveIdIsJustActivated)\n        {\n            // On initial click when held_dir == 0 (clicked over grab): calculate the distance between mouse and the center of the grab\n            const bool scroll_to_clicked_location = (g.IO.ConfigScrollbarScrollByPage == false || g.IO.KeyShift || held_dir == 0);\n            g.ScrollbarSeekMode = scroll_to_clicked_location ? 0 : (short)held_dir;\n            g.ScrollbarClickDeltaToGrabCenter = (held_dir == 0 && !g.IO.KeyShift) ? clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f : 0.0f;\n        }\n\n        // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)\n        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position\n        if (g.ScrollbarSeekMode == 0)\n        {\n            // Absolute seeking\n            const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));\n            *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);\n        }\n        else\n        {\n            // Page by page\n            if (IsMouseClicked(ImGuiMouseButton_Left, ImGuiInputFlags_Repeat) && held_dir == g.ScrollbarSeekMode)\n            {\n                float page_dir = (g.ScrollbarSeekMode > 0.0f) ? +1.0f : -1.0f;\n                *p_scroll_v = ImClamp(*p_scroll_v + (ImS64)(page_dir * size_visible_v), (ImS64)0, scroll_max);\n            }\n        }\n\n        // Update values for rendering\n        scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);\n        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;\n\n        // Update distance to grab now that we have seek'ed and saturated\n        //if (seek_absolute)\n        //    g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;\n    }\n\n    // Render\n    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);\n    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);\n    window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, draw_rounding_flags);\n    ImRect grab_rect;\n    if (axis == ImGuiAxis_X)\n        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);\n    else\n        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);\n    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);\n\n    return held;\n}\n\n// - Read about ImTextureID here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples\n// - 'uv0' and 'uv1' are texture coordinates. Read about them from the same link above.\nvoid ImGui::Image(ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    const float border_size = (border_col.w > 0.0f) ? 1.0f : 0.0f;\n    const ImVec2 padding(border_size, border_size);\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + image_size + padding * 2.0f);\n    ItemSize(bb);\n    if (!ItemAdd(bb, 0))\n        return;\n\n    // Render\n    if (border_size > 0.0f)\n        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f, ImDrawFlags_None, border_size);\n    window->DrawList->AddImage(user_texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));\n}\n\nbool ImGui::ImageButtonEx(ImGuiID id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col, ImGuiButtonFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    const ImVec2 padding = g.Style.FramePadding;\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + image_size + padding * 2.0f);\n    ItemSize(bb);\n    if (!ItemAdd(bb, id))\n        return false;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\n\n    // Render\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\n    RenderNavCursor(bb, id);\n    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, g.Style.FrameRounding));\n    if (bg_col.w > 0.0f)\n        window->DrawList->AddRectFilled(bb.Min + padding, bb.Max - padding, GetColorU32(bg_col));\n    window->DrawList->AddImage(user_texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));\n\n    return pressed;\n}\n\n// - ImageButton() adds style.FramePadding*2.0f to provided size. This is in order to facilitate fitting an image in a button.\n// - ImageButton() draws a background based on regular Button() color + optionally an inner background if specified. (#8165) // FIXME: Maybe that's not the best design?\nbool ImGui::ImageButton(const char* str_id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    return ImageButtonEx(window->GetID(str_id), user_texture_id, image_size, uv0, uv1, bg_col, tint_col);\n}\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n// Legacy API obsoleted in 1.89. Two differences with new ImageButton()\n// - old ImageButton() used ImTextureID as item id (created issue with multiple buttons with same image, transient texture id values, opaque computation of ID)\n// - new ImageButton() requires an explicit 'const char* str_id'\n// - old ImageButton() had frame_padding' override argument.\n// - new ImageButton() always use style.FramePadding.\n/*\nbool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)\n{\n    // Default to using texture ID as ID. User can still push string/integer prefixes.\n    PushID((ImTextureID)(intptr_t)user_texture_id);\n    if (frame_padding >= 0)\n        PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2((float)frame_padding, (float)frame_padding));\n    bool ret = ImageButton(\"\", user_texture_id, size, uv0, uv1, bg_col, tint_col);\n    if (frame_padding >= 0)\n        PopStyleVar();\n    PopID();\n    return ret;\n}\n*/\n#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n\nbool ImGui::Checkbox(const char* label, bool* v)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    const float square_sz = GetFrameHeight();\n    const ImVec2 pos = window->DC.CursorPos;\n    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));\n    ItemSize(total_bb, style.FramePadding.y);\n    const bool is_visible = ItemAdd(total_bb, id);\n    const bool is_multi_select = (g.LastItemData.ItemFlags & ImGuiItemFlags_IsMultiSelect) != 0;\n    if (!is_visible)\n        if (!is_multi_select || !g.BoxSelectState.UnclipMode || !g.BoxSelectState.UnclipRect.Overlaps(total_bb)) // Extra layer of \"no logic clip\" for box-select support\n        {\n            IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));\n            return false;\n        }\n\n    // Range-Selection/Multi-selection support (header)\n    bool checked = *v;\n    if (is_multi_select)\n        MultiSelectItemHeader(id, &checked, NULL);\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);\n\n    // Range-Selection/Multi-selection support (footer)\n    if (is_multi_select)\n        MultiSelectItemFooter(id, &checked, &pressed);\n    else if (pressed)\n        checked = !checked;\n\n    if (*v != checked)\n    {\n        *v = checked;\n        pressed = true; // return value\n        MarkItemEdited(id);\n    }\n\n    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));\n    const bool mixed_value = (g.LastItemData.ItemFlags & ImGuiItemFlags_MixedValue) != 0;\n    if (is_visible)\n    {\n        RenderNavCursor(total_bb, id);\n        RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);\n        ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);\n        if (mixed_value)\n        {\n            // Undocumented tristate/mixed/indeterminate checkbox (#2644)\n            // This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)\n            ImVec2 pad(ImMax(1.0f, IM_TRUNC(square_sz / 3.6f)), ImMax(1.0f, IM_TRUNC(square_sz / 3.6f)));\n            window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);\n        }\n        else if (*v)\n        {\n            const float pad = ImMax(1.0f, IM_TRUNC(square_sz / 6.0f));\n            RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);\n        }\n    }\n    const ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);\n    if (g.LogEnabled)\n        LogRenderedText(&label_pos, mixed_value ? \"[~]\" : *v ? \"[x]\" : \"[ ]\");\n    if (is_visible && label_size.x > 0.0f)\n        RenderText(label_pos, label);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));\n    return pressed;\n}\n\ntemplate<typename T>\nbool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)\n{\n    bool all_on = (*flags & flags_value) == flags_value;\n    bool any_on = (*flags & flags_value) != 0;\n    bool pressed;\n    if (!all_on && any_on)\n    {\n        ImGuiContext& g = *GImGui;\n        g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;\n        pressed = Checkbox(label, &all_on);\n    }\n    else\n    {\n        pressed = Checkbox(label, &all_on);\n\n    }\n    if (pressed)\n    {\n        if (all_on)\n            *flags |= flags_value;\n        else\n            *flags &= ~flags_value;\n    }\n    return pressed;\n}\n\nbool ImGui::CheckboxFlags(const char* label, int* flags, int flags_value)\n{\n    return CheckboxFlagsT(label, flags, flags_value);\n}\n\nbool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)\n{\n    return CheckboxFlagsT(label, flags, flags_value);\n}\n\nbool ImGui::CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value)\n{\n    return CheckboxFlagsT(label, flags, flags_value);\n}\n\nbool ImGui::CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value)\n{\n    return CheckboxFlagsT(label, flags, flags_value);\n}\n\nbool ImGui::RadioButton(const char* label, bool active)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    const float square_sz = GetFrameHeight();\n    const ImVec2 pos = window->DC.CursorPos;\n    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));\n    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));\n    ItemSize(total_bb, style.FramePadding.y);\n    if (!ItemAdd(total_bb, id))\n        return false;\n\n    ImVec2 center = check_bb.GetCenter();\n    center.x = IM_ROUND(center.x);\n    center.y = IM_ROUND(center.y);\n    const float radius = (square_sz - 1.0f) * 0.5f;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);\n    if (pressed)\n        MarkItemEdited(id);\n\n    RenderNavCursor(total_bb, id);\n    const int num_segment = window->DrawList->_CalcCircleAutoSegmentCount(radius);\n    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), num_segment);\n    if (active)\n    {\n        const float pad = ImMax(1.0f, IM_TRUNC(square_sz / 6.0f));\n        window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark));\n    }\n\n    if (style.FrameBorderSize > 0.0f)\n    {\n        window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), num_segment, style.FrameBorderSize);\n        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), num_segment, style.FrameBorderSize);\n    }\n\n    ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);\n    if (g.LogEnabled)\n        LogRenderedText(&label_pos, active ? \"(x)\" : \"( )\");\n    if (label_size.x > 0.0f)\n        RenderText(label_pos, label);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);\n    return pressed;\n}\n\n// FIXME: This would work nicely if it was a public template, e.g. 'template<T> RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we would expose it..\nbool ImGui::RadioButton(const char* label, int* v, int v_button)\n{\n    const bool pressed = RadioButton(label, *v == v_button);\n    if (pressed)\n        *v = v_button;\n    return pressed;\n}\n\n// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size\nvoid ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n\n    ImVec2 pos = window->DC.CursorPos;\n    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f);\n    ImRect bb(pos, pos + size);\n    ItemSize(size, style.FramePadding.y);\n    if (!ItemAdd(bb, 0))\n        return;\n\n    // Fraction < 0.0f will display an indeterminate progress bar animation\n    // The value must be animated along with time, so e.g. passing '-1.0f * ImGui::GetTime()' as fraction works.\n    const bool is_indeterminate = (fraction < 0.0f);\n    if (!is_indeterminate)\n        fraction = ImSaturate(fraction);\n\n    // Out of courtesy we accept a NaN fraction without crashing\n    float fill_n0 = 0.0f;\n    float fill_n1 = (fraction == fraction) ? fraction : 0.0f;\n\n    if (is_indeterminate)\n    {\n        const float fill_width_n = 0.2f;\n        fill_n0 = ImFmod(-fraction, 1.0f) * (1.0f + fill_width_n) - fill_width_n;\n        fill_n1 = ImSaturate(fill_n0 + fill_width_n);\n        fill_n0 = ImSaturate(fill_n0);\n    }\n\n    // Render\n    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\n    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));\n    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), fill_n0, fill_n1, style.FrameRounding);\n\n    // Default displaying the fraction as percentage string, but user can override it\n    // Don't display text for indeterminate bars by default\n    char overlay_buf[32];\n    if (!is_indeterminate || overlay != NULL)\n    {\n        if (!overlay)\n        {\n            ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), \"%.0f%%\", fraction * 100 + 0.01f);\n            overlay = overlay_buf;\n        }\n\n        ImVec2 overlay_size = CalcTextSize(overlay, NULL);\n        if (overlay_size.x > 0.0f)\n        {\n            float text_x = is_indeterminate ? (bb.Min.x + bb.Max.x - overlay_size.x) * 0.5f : ImLerp(bb.Min.x, bb.Max.x, fill_n1) + style.ItemSpacing.x;\n            RenderTextClipped(ImVec2(ImClamp(text_x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f, 0.5f), &bb);\n        }\n    }\n}\n\nvoid ImGui::Bullet()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const float line_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), g.FontSize);\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));\n    ItemSize(bb);\n    if (!ItemAdd(bb, 0))\n    {\n        SameLine(0, style.FramePadding.x * 2);\n        return;\n    }\n\n    // Render and stay on same line\n    ImU32 text_col = GetColorU32(ImGuiCol_Text);\n    RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f), text_col);\n    SameLine(0, style.FramePadding.x * 2.0f);\n}\n\n// This is provided as a convenience for being an often requested feature.\n// FIXME-STYLE: we delayed adding as there is a larger plan to revamp the styling system.\n// Because of this we currently don't provide many styling options for this widget\n// (e.g. hovered/active colors are automatically inferred from a single color).\nbool ImGui::TextLink(const char* label)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiID id = window->GetID(label);\n    const char* label_end = FindRenderedTextEnd(label);\n\n    ImVec2 pos = window->DC.CursorPos;\n    ImVec2 size = CalcTextSize(label, label_end, true);\n    ImRect bb(pos, pos + size);\n    ItemSize(size, 0.0f);\n    if (!ItemAdd(bb, id))\n        return false;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\n    RenderNavCursor(bb, id);\n\n    if (hovered)\n        SetMouseCursor(ImGuiMouseCursor_Hand);\n\n    ImVec4 text_colf = g.Style.Colors[ImGuiCol_TextLink];\n    ImVec4 line_colf = text_colf;\n    {\n        // FIXME-STYLE: Read comments above. This widget is NOT written in the same style as some earlier widgets,\n        // as we are currently experimenting/planning a different styling system.\n        float h, s, v;\n        ColorConvertRGBtoHSV(text_colf.x, text_colf.y, text_colf.z, h, s, v);\n        if (held || hovered)\n        {\n            v = ImSaturate(v + (held ? 0.4f : 0.3f));\n            h = ImFmod(h + 0.02f, 1.0f);\n        }\n        ColorConvertHSVtoRGB(h, s, v, text_colf.x, text_colf.y, text_colf.z);\n        v = ImSaturate(v - 0.20f);\n        ColorConvertHSVtoRGB(h, s, v, line_colf.x, line_colf.y, line_colf.z);\n    }\n\n    float line_y = bb.Max.y + ImFloor(g.Font->Descent * g.FontScale * 0.20f);\n    window->DrawList->AddLine(ImVec2(bb.Min.x, line_y), ImVec2(bb.Max.x, line_y), GetColorU32(line_colf)); // FIXME-TEXT: Underline mode.\n\n    PushStyleColor(ImGuiCol_Text, GetColorU32(text_colf));\n    RenderText(bb.Min, label, label_end);\n    PopStyleColor();\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);\n    return pressed;\n}\n\nvoid ImGui::TextLinkOpenURL(const char* label, const char* url)\n{\n    ImGuiContext& g = *GImGui;\n    if (url == NULL)\n        url = label;\n    if (TextLink(label))\n        if (g.PlatformIO.Platform_OpenInShellFn != NULL)\n            g.PlatformIO.Platform_OpenInShellFn(&g, url);\n    SetItemTooltip(LocalizeGetMsg(ImGuiLocKey_OpenLink_s), url); // It is more reassuring for user to _always_ display URL when we same as label\n    if (BeginPopupContextItem())\n    {\n        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_CopyLink)))\n            SetClipboardText(url);\n        EndPopup();\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Low-level Layout helpers\n//-------------------------------------------------------------------------\n// - Spacing()\n// - Dummy()\n// - NewLine()\n// - AlignTextToFramePadding()\n// - SeparatorEx() [Internal]\n// - Separator()\n// - SplitterBehavior() [Internal]\n// - ShrinkWidths() [Internal]\n//-------------------------------------------------------------------------\n\nvoid ImGui::Spacing()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n    ItemSize(ImVec2(0, 0));\n}\n\nvoid ImGui::Dummy(const ImVec2& size)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\n    ItemSize(size);\n    ItemAdd(bb, 0);\n}\n\nvoid ImGui::NewLine()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;\n    window->DC.LayoutType = ImGuiLayoutType_Vertical;\n    window->DC.IsSameLine = false;\n    if (window->DC.CurrLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.\n        ItemSize(ImVec2(0, 0));\n    else\n        ItemSize(ImVec2(0.0f, g.FontSize));\n    window->DC.LayoutType = backup_layout_type;\n}\n\nvoid ImGui::AlignTextToFramePadding()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);\n    window->DC.CurrLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);\n}\n\n// Horizontal/vertical separating line\n// FIXME: Surprisingly, this seemingly trivial widget is a victim of many different legacy/tricky layout issues.\n// Note how thickness == 1.0f is handled specifically as not moving CursorPos by 'thickness', but other values are.\nvoid ImGui::SeparatorEx(ImGuiSeparatorFlags flags, float thickness)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected\n    IM_ASSERT(thickness > 0.0f);\n\n    if (flags & ImGuiSeparatorFlags_Vertical)\n    {\n        // Vertical separator, for menu bars (use current line height).\n        float y1 = window->DC.CursorPos.y;\n        float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;\n        const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + thickness, y2));\n        ItemSize(ImVec2(thickness, 0.0f));\n        if (!ItemAdd(bb, 0))\n            return;\n\n        // Draw\n        window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));\n        if (g.LogEnabled)\n            LogText(\" |\");\n    }\n    else if (flags & ImGuiSeparatorFlags_Horizontal)\n    {\n        // Horizontal Separator\n        float x1 = window->DC.CursorPos.x;\n        float x2 = window->WorkRect.Max.x;\n\n        // Preserve legacy behavior inside Columns()\n        // Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.\n        // We currently don't need to provide the same feature for tables because tables naturally have border features.\n        ImGuiOldColumns* columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;\n        if (columns)\n        {\n            x1 = window->Pos.x + window->DC.Indent.x; // Used to be Pos.x before 2023/10/03\n            x2 = window->Pos.x + window->Size.x;\n            PushColumnsBackground();\n        }\n\n        // We don't provide our width to the layout so that it doesn't get feed back into AutoFit\n        // FIXME: This prevents ->CursorMaxPos based bounding box evaluation from working (e.g. TableEndCell)\n        const float thickness_for_layout = (thickness == 1.0f) ? 0.0f : thickness; // FIXME: See 1.70/1.71 Separator() change: makes legacy 1-px separator not affect layout yet. Should change.\n        const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness));\n        ItemSize(ImVec2(0.0f, thickness_for_layout));\n\n        if (ItemAdd(bb, 0))\n        {\n            // Draw\n            window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));\n            if (g.LogEnabled)\n                LogRenderedText(&bb.Min, \"--------------------------------\\n\");\n\n        }\n        if (columns)\n        {\n            PopColumnsBackground();\n            columns->LineMinY = window->DC.CursorPos.y;\n        }\n    }\n}\n\nvoid ImGui::Separator()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return;\n\n    // Those flags should eventually be configurable by the user\n    // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.\n    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;\n\n    // Only applies to legacy Columns() api as they relied on Separator() a lot.\n    if (window->DC.CurrentColumns)\n        flags |= ImGuiSeparatorFlags_SpanAllColumns;\n\n    SeparatorEx(flags, 1.0f);\n}\n\nvoid ImGui::SeparatorTextEx(ImGuiID id, const char* label, const char* label_end, float extra_w)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiStyle& style = g.Style;\n\n    const ImVec2 label_size = CalcTextSize(label, label_end, false);\n    const ImVec2 pos = window->DC.CursorPos;\n    const ImVec2 padding = style.SeparatorTextPadding;\n\n    const float separator_thickness = style.SeparatorTextBorderSize;\n    const ImVec2 min_size(label_size.x + extra_w + padding.x * 2.0f, ImMax(label_size.y + padding.y * 2.0f, separator_thickness));\n    const ImRect bb(pos, ImVec2(window->WorkRect.Max.x, pos.y + min_size.y));\n    const float text_baseline_y = ImTrunc((bb.GetHeight() - label_size.y) * style.SeparatorTextAlign.y + 0.99999f); //ImMax(padding.y, ImFloor((style.SeparatorTextSize - label_size.y) * 0.5f));\n    ItemSize(min_size, text_baseline_y);\n    if (!ItemAdd(bb, id))\n        return;\n\n    const float sep1_x1 = pos.x;\n    const float sep2_x2 = bb.Max.x;\n    const float seps_y = ImTrunc((bb.Min.y + bb.Max.y) * 0.5f + 0.99999f);\n\n    const float label_avail_w = ImMax(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);\n    const ImVec2 label_pos(pos.x + padding.x + ImMax(0.0f, (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y); // FIXME-ALIGN\n\n    // This allows using SameLine() to position something in the 'extra_w'\n    window->DC.CursorPosPrevLine.x = label_pos.x + label_size.x;\n\n    const ImU32 separator_col = GetColorU32(ImGuiCol_Separator);\n    if (label_size.x > 0.0f)\n    {\n        const float sep1_x2 = label_pos.x - style.ItemSpacing.x;\n        const float sep2_x1 = label_pos.x + label_size.x + extra_w + style.ItemSpacing.x;\n        if (sep1_x2 > sep1_x1 && separator_thickness > 0.0f)\n            window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep1_x2, seps_y), separator_col, separator_thickness);\n        if (sep2_x2 > sep2_x1 && separator_thickness > 0.0f)\n            window->DrawList->AddLine(ImVec2(sep2_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);\n        if (g.LogEnabled)\n            LogSetNextTextDecoration(\"---\", NULL);\n        RenderTextEllipsis(window->DrawList, label_pos, ImVec2(bb.Max.x, bb.Max.y + style.ItemSpacing.y), bb.Max.x, bb.Max.x, label, label_end, &label_size);\n    }\n    else\n    {\n        if (g.LogEnabled)\n            LogText(\"---\");\n        if (separator_thickness > 0.0f)\n            window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);\n    }\n}\n\nvoid ImGui::SeparatorText(const char* label)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n\n    // The SeparatorText() vs SeparatorTextEx() distinction is designed to be considerate that we may want:\n    // - allow separator-text to be draggable items (would require a stable ID + a noticeable highlight)\n    // - this high-level entry point to allow formatting? (which in turns may require ID separate from formatted string)\n    // - because of this we probably can't turn 'const char* label' into 'const char* fmt, ...'\n    // Otherwise, we can decide that users wanting to drag this would layout a dedicated drag-item,\n    // and then we can turn this into a format function.\n    SeparatorTextEx(0, label, FindRenderedTextEnd(label), 0.0f);\n}\n\n// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.\nbool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay, ImU32 bg_col)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    if (!ItemAdd(bb, id, NULL, ImGuiItemFlags_NoNav))\n        return false;\n\n    // FIXME: AFAIK the only leftover reason for passing ImGuiButtonFlags_AllowOverlap here is\n    // to allow caller of SplitterBehavior() to call SetItemAllowOverlap() after the item.\n    // Nowadays we would instead want to use SetNextItemAllowOverlap() before the item.\n    ImGuiButtonFlags button_flags = ImGuiButtonFlags_FlattenChildren;\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n    button_flags |= ImGuiButtonFlags_AllowOverlap;\n#endif\n\n    bool hovered, held;\n    ImRect bb_interact = bb;\n    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));\n    ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);\n    if (hovered)\n        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect; // for IsItemHovered(), because bb_interact is larger than bb\n\n    if (held || (hovered && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))\n        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);\n\n    ImRect bb_render = bb;\n    if (held)\n    {\n        float mouse_delta = (g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min)[axis];\n\n        // Minimum pane size\n        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);\n        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);\n        if (mouse_delta < -size_1_maximum_delta)\n            mouse_delta = -size_1_maximum_delta;\n        if (mouse_delta > size_2_maximum_delta)\n            mouse_delta = size_2_maximum_delta;\n\n        // Apply resize\n        if (mouse_delta != 0.0f)\n        {\n            *size1 = ImMax(*size1 + mouse_delta, min_size1);\n            *size2 = ImMax(*size2 - mouse_delta, min_size2);\n            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));\n            MarkItemEdited(id);\n        }\n    }\n\n    // Render at new position\n    if (bg_col & IM_COL32_A_MASK)\n        window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, bg_col, 0.0f);\n    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);\n    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);\n\n    return held;\n}\n\nstatic int IMGUI_CDECL ShrinkWidthItemComparer(const void* lhs, const void* rhs)\n{\n    const ImGuiShrinkWidthItem* a = (const ImGuiShrinkWidthItem*)lhs;\n    const ImGuiShrinkWidthItem* b = (const ImGuiShrinkWidthItem*)rhs;\n    if (int d = (int)(b->Width - a->Width))\n        return d;\n    return (b->Index - a->Index);\n}\n\n// Shrink excess width from a set of item, by removing width from the larger items first.\n// Set items Width to -1.0f to disable shrinking this item.\nvoid ImGui::ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess)\n{\n    if (count == 1)\n    {\n        if (items[0].Width >= 0.0f)\n            items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);\n        return;\n    }\n    ImQsort(items, (size_t)count, sizeof(ImGuiShrinkWidthItem), ShrinkWidthItemComparer);\n    int count_same_width = 1;\n    while (width_excess > 0.0f && count_same_width < count)\n    {\n        while (count_same_width < count && items[0].Width <= items[count_same_width].Width)\n            count_same_width++;\n        float max_width_to_remove_per_item = (count_same_width < count && items[count_same_width].Width >= 0.0f) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0f);\n        if (max_width_to_remove_per_item <= 0.0f)\n            break;\n        float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);\n        for (int item_n = 0; item_n < count_same_width; item_n++)\n            items[item_n].Width -= width_to_remove_per_item;\n        width_excess -= width_to_remove_per_item * count_same_width;\n    }\n\n    // Round width and redistribute remainder\n    // Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.\n    width_excess = 0.0f;\n    for (int n = 0; n < count; n++)\n    {\n        float width_rounded = ImTrunc(items[n].Width);\n        width_excess += items[n].Width - width_rounded;\n        items[n].Width = width_rounded;\n    }\n    while (width_excess > 0.0f)\n        for (int n = 0; n < count && width_excess > 0.0f; n++)\n        {\n            float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);\n            items[n].Width += width_to_add;\n            width_excess -= width_to_add;\n        }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: ComboBox\n//-------------------------------------------------------------------------\n// - CalcMaxPopupHeightFromItemCount() [Internal]\n// - BeginCombo()\n// - BeginComboPopup() [Internal]\n// - EndCombo()\n// - BeginComboPreview() [Internal]\n// - EndComboPreview() [Internal]\n// - Combo()\n//-------------------------------------------------------------------------\n\nstatic float CalcMaxPopupHeightFromItemCount(int items_count)\n{\n    ImGuiContext& g = *GImGui;\n    if (items_count <= 0)\n        return FLT_MAX;\n    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);\n}\n\nbool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n\n    ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;\n    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values\n    if (window->SkipItems)\n        return false;\n\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together\n    if (flags & ImGuiComboFlags_WidthFitPreview)\n        IM_ASSERT((flags & (ImGuiComboFlags_NoPreview | (ImGuiComboFlags)ImGuiComboFlags_CustomPreview)) == 0);\n\n    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n    const float preview_width = ((flags & ImGuiComboFlags_WidthFitPreview) && (preview_value != NULL)) ? CalcTextSize(preview_value, NULL, true).x : 0.0f;\n    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : ((flags & ImGuiComboFlags_WidthFitPreview) ? (arrow_size + preview_width + style.FramePadding.x * 2.0f) : CalcItemWidth());\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));\n    const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\n    ItemSize(total_bb, style.FramePadding.y);\n    if (!ItemAdd(total_bb, id, &bb))\n        return false;\n\n    // Open on click\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\n    const ImGuiID popup_id = ImHashStr(\"##ComboPopup\", 0, id);\n    bool popup_open = IsPopupOpen(popup_id, ImGuiPopupFlags_None);\n    if (pressed && !popup_open)\n    {\n        OpenPopupEx(popup_id, ImGuiPopupFlags_None);\n        popup_open = true;\n    }\n\n    // Render shape\n    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\n    const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);\n    RenderNavCursor(bb, id);\n    if (!(flags & ImGuiComboFlags_NoPreview))\n        window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);\n    if (!(flags & ImGuiComboFlags_NoArrowButton))\n    {\n        ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\n        ImU32 text_col = GetColorU32(ImGuiCol_Text);\n        window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);\n        if (value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x)\n            RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f);\n    }\n    RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding);\n\n    // Custom preview\n    if (flags & ImGuiComboFlags_CustomPreview)\n    {\n        g.ComboPreviewData.PreviewRect = ImRect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);\n        IM_ASSERT(preview_value == NULL || preview_value[0] == 0);\n        preview_value = NULL;\n    }\n\n    // Render preview and label\n    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))\n    {\n        if (g.LogEnabled)\n            LogSetNextTextDecoration(\"{\", \"}\");\n        RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);\n    }\n    if (label_size.x > 0)\n        RenderText(ImVec2(bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y), label);\n\n    if (!popup_open)\n        return false;\n\n    g.NextWindowData.Flags = backup_next_window_data_flags;\n    return BeginComboPopup(popup_id, bb, flags);\n}\n\nbool ImGui::BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    if (!IsPopupOpen(popup_id, ImGuiPopupFlags_None))\n    {\n        g.NextWindowData.ClearFlags();\n        return false;\n    }\n\n    // Set popup size\n    float w = bb.GetWidth();\n    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)\n    {\n        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);\n    }\n    else\n    {\n        if ((flags & ImGuiComboFlags_HeightMask_) == 0)\n            flags |= ImGuiComboFlags_HeightRegular;\n        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_)); // Only one\n        int popup_max_height_in_items = -1;\n        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;\n        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;\n        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;\n        ImVec2 constraint_min(0.0f, 0.0f), constraint_max(FLT_MAX, FLT_MAX);\n        if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.x <= 0.0f) // Don't apply constraints if user specified a size\n            constraint_min.x = w;\n        if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.y <= 0.0f)\n            constraint_max.y = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);\n        SetNextWindowSizeConstraints(constraint_min, constraint_max);\n    }\n\n    // This is essentially a specialized version of BeginPopupEx()\n    char name[16];\n    ImFormatString(name, IM_ARRAYSIZE(name), \"##Combo_%02d\", g.BeginComboDepth); // Recycle windows based on depth\n\n    // Set position given a custom constraint (peak into expected window size so we can position it)\n    // FIXME: This might be easier to express with an hypothetical SetNextWindowPosConstraints() function?\n    // FIXME: This might be moved to Begin() or at least around the same spot where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?\n    if (ImGuiWindow* popup_window = FindWindowByName(name))\n        if (popup_window->WasActive)\n        {\n            // Always override 'AutoPosLastDirection' to not leave a chance for a past value to affect us.\n            ImVec2 size_expected = CalcWindowNextAutoFitSize(popup_window);\n            popup_window->AutoPosLastDirection = (flags & ImGuiComboFlags_PopupAlignLeft) ? ImGuiDir_Left : ImGuiDir_Down; // Left = \"Below, Toward Left\", Down = \"Below, Toward Right (default)\"\n            ImRect r_outer = GetPopupAllowedExtentRect(popup_window);\n            ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);\n            SetNextWindowPos(pos);\n        }\n\n    // We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;\n    PushStyleVarX(ImGuiStyleVar_WindowPadding, g.Style.FramePadding.x); // Horizontally align ourselves with the framed text\n    bool ret = Begin(name, NULL, window_flags);\n    PopStyleVar();\n    if (!ret)\n    {\n        EndPopup();\n        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above\n        return false;\n    }\n    g.BeginComboDepth++;\n    return true;\n}\n\nvoid ImGui::EndCombo()\n{\n    ImGuiContext& g = *GImGui;\n    EndPopup();\n    g.BeginComboDepth--;\n}\n\n// Call directly after the BeginCombo/EndCombo block. The preview is designed to only host non-interactive elements\n// (Experimental, see GitHub issues: #1658, #4168)\nbool ImGui::BeginComboPreview()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiComboPreviewData* preview_data = &g.ComboPreviewData;\n\n    if (window->SkipItems || !(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible))\n        return false;\n    IM_ASSERT(g.LastItemData.Rect.Min.x == preview_data->PreviewRect.Min.x && g.LastItemData.Rect.Min.y == preview_data->PreviewRect.Min.y); // Didn't call after BeginCombo/EndCombo block or forgot to pass ImGuiComboFlags_CustomPreview flag?\n    if (!window->ClipRect.Overlaps(preview_data->PreviewRect)) // Narrower test (optional)\n        return false;\n\n    // FIXME: This could be contained in a PushWorkRect() api\n    preview_data->BackupCursorPos = window->DC.CursorPos;\n    preview_data->BackupCursorMaxPos = window->DC.CursorMaxPos;\n    preview_data->BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;\n    preview_data->BackupPrevLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;\n    preview_data->BackupLayout = window->DC.LayoutType;\n    window->DC.CursorPos = preview_data->PreviewRect.Min + g.Style.FramePadding;\n    window->DC.CursorMaxPos = window->DC.CursorPos;\n    window->DC.LayoutType = ImGuiLayoutType_Horizontal;\n    window->DC.IsSameLine = false;\n    PushClipRect(preview_data->PreviewRect.Min, preview_data->PreviewRect.Max, true);\n\n    return true;\n}\n\nvoid ImGui::EndComboPreview()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiComboPreviewData* preview_data = &g.ComboPreviewData;\n\n    // FIXME: Using CursorMaxPos approximation instead of correct AABB which we will store in ImDrawCmd in the future\n    ImDrawList* draw_list = window->DrawList;\n    if (window->DC.CursorMaxPos.x < preview_data->PreviewRect.Max.x && window->DC.CursorMaxPos.y < preview_data->PreviewRect.Max.y)\n        if (draw_list->CmdBuffer.Size > 1) // Unlikely case that the PushClipRect() didn't create a command\n        {\n            draw_list->_CmdHeader.ClipRect = draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ClipRect = draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 2].ClipRect;\n            draw_list->_TryMergeDrawCmds();\n        }\n    PopClipRect();\n    window->DC.CursorPos = preview_data->BackupCursorPos;\n    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, preview_data->BackupCursorMaxPos);\n    window->DC.CursorPosPrevLine = preview_data->BackupCursorPosPrevLine;\n    window->DC.PrevLineTextBaseOffset = preview_data->BackupPrevLineTextBaseOffset;\n    window->DC.LayoutType = preview_data->BackupLayout;\n    window->DC.IsSameLine = false;\n    preview_data->PreviewRect = ImRect();\n}\n\n// Getter for the old Combo() API: const char*[]\nstatic const char* Items_ArrayGetter(void* data, int idx)\n{\n    const char* const* items = (const char* const*)data;\n    return items[idx];\n}\n\n// Getter for the old Combo() API: \"item1\\0item2\\0item3\\0\"\nstatic const char* Items_SingleStringGetter(void* data, int idx)\n{\n    const char* items_separated_by_zeros = (const char*)data;\n    int items_count = 0;\n    const char* p = items_separated_by_zeros;\n    while (*p)\n    {\n        if (idx == items_count)\n            break;\n        p += strlen(p) + 1;\n        items_count++;\n    }\n    return *p ? p : NULL;\n}\n\n// Old API, prefer using BeginCombo() nowadays if you can.\nbool ImGui::Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int popup_max_height_in_items)\n{\n    ImGuiContext& g = *GImGui;\n\n    // Call the getter to obtain the preview string which is a parameter to BeginCombo()\n    const char* preview_value = NULL;\n    if (*current_item >= 0 && *current_item < items_count)\n        preview_value = getter(user_data, *current_item);\n\n    // The old Combo() API exposed \"popup_max_height_in_items\". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.\n    if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))\n        SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));\n\n    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))\n        return false;\n\n    // Display items\n    bool value_changed = false;\n    ImGuiListClipper clipper;\n    clipper.Begin(items_count);\n    clipper.IncludeItemByIndex(*current_item);\n    while (clipper.Step())\n        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n        {\n            const char* item_text = getter(user_data, i);\n            if (item_text == NULL)\n                item_text = \"*Unknown item*\";\n\n            PushID(i);\n            const bool item_selected = (i == *current_item);\n            if (Selectable(item_text, item_selected) && *current_item != i)\n            {\n                value_changed = true;\n                *current_item = i;\n            }\n            if (item_selected)\n                SetItemDefaultFocus();\n            PopID();\n        }\n\n    EndCombo();\n    if (value_changed)\n        MarkItemEdited(g.LastItemData.ID);\n\n    return value_changed;\n}\n\n// Combo box helper allowing to pass an array of strings.\nbool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)\n{\n    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);\n    return value_changed;\n}\n\n// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items \"item1\\0item2\\0\"\nbool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)\n{\n    int items_count = 0;\n    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open\n    while (*p)\n    {\n        p += strlen(p) + 1;\n        items_count++;\n    }\n    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);\n    return value_changed;\n}\n\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\n\nstruct ImGuiGetNameFromIndexOldToNewCallbackData { void* UserData; bool (*OldCallback)(void*, int, const char**); };\nstatic const char* ImGuiGetNameFromIndexOldToNewCallback(void* user_data, int idx)\n{\n    ImGuiGetNameFromIndexOldToNewCallbackData* data = (ImGuiGetNameFromIndexOldToNewCallbackData*)user_data;\n    const char* s = NULL;\n    data->OldCallback(data->UserData, idx, &s);\n    return s;\n}\n\nbool ImGui::ListBox(const char* label, int* current_item, bool (*old_getter)(void*, int, const char**), void* user_data, int items_count, int height_in_items)\n{\n    ImGuiGetNameFromIndexOldToNewCallbackData old_to_new_data = { user_data, old_getter };\n    return ListBox(label, current_item, ImGuiGetNameFromIndexOldToNewCallback, &old_to_new_data, items_count, height_in_items);\n}\nbool ImGui::Combo(const char* label, int* current_item, bool (*old_getter)(void*, int, const char**), void* user_data, int items_count, int popup_max_height_in_items)\n{\n    ImGuiGetNameFromIndexOldToNewCallbackData old_to_new_data = { user_data, old_getter };\n    return Combo(label, current_item, ImGuiGetNameFromIndexOldToNewCallback, &old_to_new_data, items_count, popup_max_height_in_items);\n}\n\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] Data Type and Data Formatting Helpers [Internal]\n//-------------------------------------------------------------------------\n// - DataTypeGetInfo()\n// - DataTypeFormatString()\n// - DataTypeApplyOp()\n// - DataTypeApplyFromText()\n// - DataTypeCompare()\n// - DataTypeClamp()\n// - GetMinimumStepAtDecimalPrecision\n// - RoundScalarWithFormat<>()\n//-------------------------------------------------------------------------\n\nstatic const ImGuiDataTypeInfo GDataTypeInfo[] =\n{\n    { sizeof(char),             \"S8\",   \"%d\",   \"%d\"    },  // ImGuiDataType_S8\n    { sizeof(unsigned char),    \"U8\",   \"%u\",   \"%u\"    },\n    { sizeof(short),            \"S16\",  \"%d\",   \"%d\"    },  // ImGuiDataType_S16\n    { sizeof(unsigned short),   \"U16\",  \"%u\",   \"%u\"    },\n    { sizeof(int),              \"S32\",  \"%d\",   \"%d\"    },  // ImGuiDataType_S32\n    { sizeof(unsigned int),     \"U32\",  \"%u\",   \"%u\"    },\n#ifdef _MSC_VER\n    { sizeof(ImS64),            \"S64\",  \"%I64d\",\"%I64d\" },  // ImGuiDataType_S64\n    { sizeof(ImU64),            \"U64\",  \"%I64u\",\"%I64u\" },\n#else\n    { sizeof(ImS64),            \"S64\",  \"%lld\", \"%lld\"  },  // ImGuiDataType_S64\n    { sizeof(ImU64),            \"U64\",  \"%llu\", \"%llu\"  },\n#endif\n    { sizeof(float),            \"float\", \"%.3f\",\"%f\"    },  // ImGuiDataType_Float (float are promoted to double in va_arg)\n    { sizeof(double),           \"double\",\"%f\",  \"%lf\"   },  // ImGuiDataType_Double\n    { sizeof(bool),             \"bool\", \"%d\",   \"%d\"    },  // ImGuiDataType_Bool\n    { 0,                        \"char*\",\"%s\",   \"%s\"    },  // ImGuiDataType_String\n};\nIM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);\n\nconst ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)\n{\n    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);\n    return &GDataTypeInfo[data_type];\n}\n\nint ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format)\n{\n    // Signedness doesn't matter when pushing integer arguments\n    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)\n        return ImFormatString(buf, buf_size, format, *(const ImU32*)p_data);\n    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)\n        return ImFormatString(buf, buf_size, format, *(const ImU64*)p_data);\n    if (data_type == ImGuiDataType_Float)\n        return ImFormatString(buf, buf_size, format, *(const float*)p_data);\n    if (data_type == ImGuiDataType_Double)\n        return ImFormatString(buf, buf_size, format, *(const double*)p_data);\n    if (data_type == ImGuiDataType_S8)\n        return ImFormatString(buf, buf_size, format, *(const ImS8*)p_data);\n    if (data_type == ImGuiDataType_U8)\n        return ImFormatString(buf, buf_size, format, *(const ImU8*)p_data);\n    if (data_type == ImGuiDataType_S16)\n        return ImFormatString(buf, buf_size, format, *(const ImS16*)p_data);\n    if (data_type == ImGuiDataType_U16)\n        return ImFormatString(buf, buf_size, format, *(const ImU16*)p_data);\n    IM_ASSERT(0);\n    return 0;\n}\n\nvoid ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg1, const void* arg2)\n{\n    IM_ASSERT(op == '+' || op == '-');\n    switch (data_type)\n    {\n        case ImGuiDataType_S8:\n            if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }\n            if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }\n            return;\n        case ImGuiDataType_U8:\n            if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }\n            if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }\n            return;\n        case ImGuiDataType_S16:\n            if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }\n            if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }\n            return;\n        case ImGuiDataType_U16:\n            if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }\n            if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }\n            return;\n        case ImGuiDataType_S32:\n            if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }\n            if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }\n            return;\n        case ImGuiDataType_U32:\n            if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }\n            if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }\n            return;\n        case ImGuiDataType_S64:\n            if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }\n            if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }\n            return;\n        case ImGuiDataType_U64:\n            if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }\n            if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }\n            return;\n        case ImGuiDataType_Float:\n            if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }\n            if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }\n            return;\n        case ImGuiDataType_Double:\n            if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }\n            if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }\n            return;\n        case ImGuiDataType_COUNT: break;\n    }\n    IM_ASSERT(0);\n}\n\n// User can input math operators (e.g. +100) to edit a numerical values.\n// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..\nbool ImGui::DataTypeApplyFromText(const char* buf, ImGuiDataType data_type, void* p_data, const char* format, void* p_data_when_empty)\n{\n    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.\n    const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);\n    ImGuiDataTypeStorage data_backup;\n    memcpy(&data_backup, p_data, type_info->Size);\n\n    while (ImCharIsBlankA(*buf))\n        buf++;\n    if (!buf[0])\n    {\n        if (p_data_when_empty != NULL)\n        {\n            memcpy(p_data, p_data_when_empty, type_info->Size);\n            return memcmp(&data_backup, p_data, type_info->Size) != 0;\n        }\n        return false;\n    }\n\n    // Sanitize format\n    // - For float/double we have to ignore format with precision (e.g. \"%.2f\") because sscanf doesn't take them in, so force them into %f and %lf\n    // - In theory could treat empty format as using default, but this would only cover rare/bizarre case of using InputScalar() + integer + format string without %.\n    char format_sanitized[32];\n    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)\n        format = type_info->ScanFmt;\n    else\n        format = ImParseFormatSanitizeForScanning(format, format_sanitized, IM_ARRAYSIZE(format_sanitized));\n\n    // Small types need a 32-bit buffer to receive the result from scanf()\n    int v32 = 0;\n    if (sscanf(buf, format, type_info->Size >= 4 ? p_data : &v32) < 1)\n        return false;\n    if (type_info->Size < 4)\n    {\n        if (data_type == ImGuiDataType_S8)\n            *(ImS8*)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);\n        else if (data_type == ImGuiDataType_U8)\n            *(ImU8*)p_data = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);\n        else if (data_type == ImGuiDataType_S16)\n            *(ImS16*)p_data = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);\n        else if (data_type == ImGuiDataType_U16)\n            *(ImU16*)p_data = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);\n        else\n            IM_ASSERT(0);\n    }\n\n    return memcmp(&data_backup, p_data, type_info->Size) != 0;\n}\n\ntemplate<typename T>\nstatic int DataTypeCompareT(const T* lhs, const T* rhs)\n{\n    if (*lhs < *rhs) return -1;\n    if (*lhs > *rhs) return +1;\n    return 0;\n}\n\nint ImGui::DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2)\n{\n    switch (data_type)\n    {\n    case ImGuiDataType_S8:     return DataTypeCompareT<ImS8  >((const ImS8*  )arg_1, (const ImS8*  )arg_2);\n    case ImGuiDataType_U8:     return DataTypeCompareT<ImU8  >((const ImU8*  )arg_1, (const ImU8*  )arg_2);\n    case ImGuiDataType_S16:    return DataTypeCompareT<ImS16 >((const ImS16* )arg_1, (const ImS16* )arg_2);\n    case ImGuiDataType_U16:    return DataTypeCompareT<ImU16 >((const ImU16* )arg_1, (const ImU16* )arg_2);\n    case ImGuiDataType_S32:    return DataTypeCompareT<ImS32 >((const ImS32* )arg_1, (const ImS32* )arg_2);\n    case ImGuiDataType_U32:    return DataTypeCompareT<ImU32 >((const ImU32* )arg_1, (const ImU32* )arg_2);\n    case ImGuiDataType_S64:    return DataTypeCompareT<ImS64 >((const ImS64* )arg_1, (const ImS64* )arg_2);\n    case ImGuiDataType_U64:    return DataTypeCompareT<ImU64 >((const ImU64* )arg_1, (const ImU64* )arg_2);\n    case ImGuiDataType_Float:  return DataTypeCompareT<float >((const float* )arg_1, (const float* )arg_2);\n    case ImGuiDataType_Double: return DataTypeCompareT<double>((const double*)arg_1, (const double*)arg_2);\n    case ImGuiDataType_COUNT:  break;\n    }\n    IM_ASSERT(0);\n    return 0;\n}\n\ntemplate<typename T>\nstatic bool DataTypeClampT(T* v, const T* v_min, const T* v_max)\n{\n    // Clamp, both sides are optional, return true if modified\n    if (v_min && *v < *v_min) { *v = *v_min; return true; }\n    if (v_max && *v > *v_max) { *v = *v_max; return true; }\n    return false;\n}\n\nbool ImGui::DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max)\n{\n    switch (data_type)\n    {\n    case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);\n    case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);\n    case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);\n    case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);\n    case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);\n    case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);\n    case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);\n    case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);\n    case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);\n    case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);\n    case ImGuiDataType_COUNT:  break;\n    }\n    IM_ASSERT(0);\n    return false;\n}\n\nbool ImGui::DataTypeIsZero(ImGuiDataType data_type, const void* p_data)\n{\n    ImGuiContext& g = *GImGui;\n    return DataTypeCompare(data_type, p_data, &g.DataTypeZeroValue) == 0;\n}\n\nstatic float GetMinimumStepAtDecimalPrecision(int decimal_precision)\n{\n    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };\n    if (decimal_precision < 0)\n        return FLT_MIN;\n    return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);\n}\n\ntemplate<typename TYPE>\nTYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)\n{\n    IM_UNUSED(data_type);\n    IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);\n    const char* fmt_start = ImParseFormatFindStart(format);\n    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string\n        return v;\n\n    // Sanitize format\n    char fmt_sanitized[32];\n    ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));\n    fmt_start = fmt_sanitized;\n\n    // Format value with our rounding, and read back\n    char v_str[64];\n    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);\n    const char* p = v_str;\n    while (*p == ' ')\n        p++;\n    v = (TYPE)ImAtof(p);\n\n    return v;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n//-------------------------------------------------------------------------\n// - DragBehaviorT<>() [Internal]\n// - DragBehavior() [Internal]\n// - DragScalar()\n// - DragScalarN()\n// - DragFloat()\n// - DragFloat2()\n// - DragFloat3()\n// - DragFloat4()\n// - DragFloatRange2()\n// - DragInt()\n// - DragInt2()\n// - DragInt3()\n// - DragInt4()\n// - DragIntRange2()\n//-------------------------------------------------------------------------\n\n// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)\ntemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>\nbool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;\n    const bool is_bounded = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0f || (flags & ImGuiSliderFlags_ClampZeroRange)));\n    const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);\n    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;\n    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);\n\n    // Default tweak speed\n    if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))\n        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);\n\n    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings\n    float adjust_delta = 0.0f;\n    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))\n    {\n        adjust_delta = g.IO.MouseDelta[axis];\n        if (g.IO.KeyAlt && !(flags & ImGuiSliderFlags_NoSpeedTweaks))\n            adjust_delta *= 1.0f / 100.0f;\n        if (g.IO.KeyShift && !(flags & ImGuiSliderFlags_NoSpeedTweaks))\n            adjust_delta *= 10.0f;\n    }\n    else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)\n    {\n        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;\n        const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);\n        const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);\n        const float tweak_factor = (flags & ImGuiSliderFlags_NoSpeedTweaks) ? 1.0f : tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f : 1.0f;\n        adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;\n        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));\n    }\n    adjust_delta *= v_speed;\n\n    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.\n    if (axis == ImGuiAxis_Y)\n        adjust_delta = -adjust_delta;\n\n    // For logarithmic use our range is effectively 0..1 so scale the delta into that range\n    if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0\n        adjust_delta /= (float)(v_max - v_min);\n\n    // Clear current value on activation\n    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.\n    const bool is_just_activated = g.ActiveIdIsJustActivated;\n    const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));\n    if (is_just_activated || is_already_past_limits_and_pushing_outward)\n    {\n        g.DragCurrentAccum = 0.0f;\n        g.DragCurrentAccumDirty = false;\n    }\n    else if (adjust_delta != 0.0f)\n    {\n        g.DragCurrentAccum += adjust_delta;\n        g.DragCurrentAccumDirty = true;\n    }\n\n    if (!g.DragCurrentAccumDirty)\n        return false;\n\n    TYPE v_cur = *v;\n    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;\n\n    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true\n    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)\n    if (is_logarithmic)\n    {\n        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.\n        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;\n        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);\n\n        // Convert to parametric space, apply delta, convert back\n        float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;\n        v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n        v_old_ref_for_accum_remainder = v_old_parametric;\n    }\n    else\n    {\n        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;\n    }\n\n    // Round to user desired precision based on format string\n    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))\n        v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);\n\n    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.\n    g.DragCurrentAccumDirty = false;\n    if (is_logarithmic)\n    {\n        // Convert to parametric space, apply delta, convert back\n        float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);\n    }\n    else\n    {\n        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);\n    }\n\n    // Lose zero sign for float/double\n    if (v_cur == (TYPE)-0)\n        v_cur = (TYPE)0;\n\n    if (*v != v_cur && is_bounded)\n    {\n        if (is_wrapped)\n        {\n            // Wrap values\n            if (v_cur < v_min)\n                v_cur += v_max - v_min + (is_floating_point ? 0 : 1);\n            if (v_cur > v_max)\n                v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);\n        }\n        else\n        {\n            // Clamp values + handle overflow/wrap-around for integer types.\n            if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))\n                v_cur = v_min;\n            if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))\n                v_cur = v_max;\n        }\n    }\n\n    // Apply result\n    if (*v == v_cur)\n        return false;\n    *v = v_cur;\n    return true;\n}\n\nbool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)\n{\n    // Read imgui.cpp \"API BREAKING CHANGES\" section for 1.78 if you hit this assert.\n    IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && \"Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.\");\n\n    ImGuiContext& g = *GImGui;\n    if (g.ActiveId == id)\n    {\n        // Those are the things we can do easily outside the DragBehaviorT<> template, saves code generation.\n        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])\n            ClearActiveID();\n        else if ((g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)\n            ClearActiveID();\n    }\n    if (g.ActiveId != id)\n        return false;\n    if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))\n        return false;\n\n    switch (data_type)\n    {\n    case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS8*) p_min : IM_S8_MIN,  p_max ? *(const ImS8*)p_max  : IM_S8_MAX,  format, flags); if (r) *(ImS8*)p_v = (ImS8)v32; return r; }\n    case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU8*) p_min : IM_U8_MIN,  p_max ? *(const ImU8*)p_max  : IM_U8_MAX,  format, flags); if (r) *(ImU8*)p_v = (ImU8)v32; return r; }\n    case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS16*)p_min : IM_S16_MIN, p_max ? *(const ImS16*)p_max : IM_S16_MAX, format, flags); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }\n    case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU16*)p_min : IM_U16_MIN, p_max ? *(const ImU16*)p_max : IM_U16_MAX, format, flags); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }\n    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)p_v,  v_speed, p_min ? *(const ImS32* )p_min : IM_S32_MIN, p_max ? *(const ImS32* )p_max : IM_S32_MAX, format, flags);\n    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)p_v,  v_speed, p_min ? *(const ImU32* )p_min : IM_U32_MIN, p_max ? *(const ImU32* )p_max : IM_U32_MAX, format, flags);\n    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)p_v,  v_speed, p_min ? *(const ImS64* )p_min : IM_S64_MIN, p_max ? *(const ImS64* )p_max : IM_S64_MAX, format, flags);\n    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)p_v,  v_speed, p_min ? *(const ImU64* )p_min : IM_U64_MIN, p_max ? *(const ImU64* )p_max : IM_U64_MAX, format, flags);\n    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)p_v,  v_speed, p_min ? *(const float* )p_min : -FLT_MAX,   p_max ? *(const float* )p_max : FLT_MAX,    format, flags);\n    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)p_v, v_speed, p_min ? *(const double*)p_min : -DBL_MAX,   p_max ? *(const double*)p_max : DBL_MAX,    format, flags);\n    case ImGuiDataType_COUNT:  break;\n    }\n    IM_ASSERT(0);\n    return false;\n}\n\n// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a Drag widget, p_min and p_max are optional.\n// Read code of e.g. DragFloat(), DragInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.\nbool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    const float w = CalcItemWidth();\n\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\n\n    const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;\n    ItemSize(total_bb, style.FramePadding.y);\n    if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))\n        return false;\n\n    // Default format string when passing NULL\n    if (format == NULL)\n        format = DataTypeGetInfo(data_type)->PrintFmt;\n\n    const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags);\n    bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);\n    if (!temp_input_is_active)\n    {\n        // Tabbing or CTRL-clicking on Drag turns it into an InputText\n        const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);\n        const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey_MouseLeft, id));\n        const bool make_active = (clicked || double_clicked || g.NavActivateId == id);\n        if (make_active && (clicked || double_clicked))\n            SetKeyOwner(ImGuiKey_MouseLeft, id);\n        if (make_active && temp_input_allowed)\n            if ((clicked && g.IO.KeyCtrl) || double_clicked || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))\n                temp_input_is_active = true;\n\n        // (Optional) simple click (without moving) turns Drag into an InputText\n        if (g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active)\n            if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))\n            {\n                g.NavActivateId = id;\n                g.NavActivateFlags = ImGuiActivateFlags_PreferInput;\n                temp_input_is_active = true;\n            }\n\n        // Store initial value (not used by main lib but available as a convenience but some mods e.g. to revert)\n        if (make_active)\n            memcpy(&g.ActiveIdValueOnActivation, p_data, DataTypeGetInfo(data_type)->Size);\n\n        if (make_active && !temp_input_is_active)\n        {\n            SetActiveID(id, window);\n            SetFocusID(id, window);\n            FocusWindow(window);\n            g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);\n        }\n    }\n\n    if (temp_input_is_active)\n    {\n        // Only clamp CTRL+Click input when ImGuiSliderFlags_ClampOnInput is set (generally via ImGuiSliderFlags_AlwaysClamp)\n        bool clamp_enabled = false;\n        if ((flags & ImGuiSliderFlags_ClampOnInput) && (p_min != NULL || p_max != NULL))\n        {\n            const int clamp_range_dir = (p_min != NULL && p_max != NULL) ? DataTypeCompare(data_type, p_min, p_max) : 0; // -1 when *p_min < *p_max, == 0 when *p_min == *p_max\n            if (p_min == NULL || p_max == NULL || clamp_range_dir < 0)\n                clamp_enabled = true;\n            else if (clamp_range_dir == 0)\n                clamp_enabled = DataTypeIsZero(data_type, p_min) ? ((flags & ImGuiSliderFlags_ClampZeroRange) != 0) : true;\n        }\n        return TempInputScalar(frame_bb, id, label, data_type, p_data, format, clamp_enabled ? p_min : NULL, clamp_enabled ? p_max : NULL);\n    }\n\n    // Draw frame\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\n    RenderNavCursor(frame_bb, id);\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);\n\n    // Drag behavior\n    const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);\n    if (value_changed)\n        MarkItemEdited(id);\n\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\n    char value_buf[64];\n    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);\n    if (g.LogEnabled)\n        LogSetNextTextDecoration(\"{\", \"}\");\n    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));\n\n    if (label_size.x > 0.0f)\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));\n    return value_changed;\n}\n\nbool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    bool value_changed = false;\n    BeginGroup();\n    PushID(label);\n    PushMultiItemsWidths(components, CalcItemWidth());\n    size_t type_size = GDataTypeInfo[data_type].Size;\n    for (int i = 0; i < components; i++)\n    {\n        PushID(i);\n        if (i > 0)\n            SameLine(0, g.Style.ItemInnerSpacing.x);\n        value_changed |= DragScalar(\"\", data_type, p_data, v_speed, p_min, p_max, format, flags);\n        PopID();\n        PopItemWidth();\n        p_data = (void*)((char*)p_data + type_size);\n    }\n    PopID();\n\n    const char* label_end = FindRenderedTextEnd(label);\n    if (label != label_end)\n    {\n        SameLine(0, g.Style.ItemInnerSpacing.x);\n        TextEx(label, label_end);\n    }\n\n    EndGroup();\n    return value_changed;\n}\n\nbool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, flags);\n}\n\n// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.\nbool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    PushID(label);\n    BeginGroup();\n    PushMultiItemsWidths(2, CalcItemWidth());\n\n    float min_min = (v_min >= v_max) ? -FLT_MAX : v_min;\n    float min_max = (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);\n    ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);\n    bool value_changed = DragScalar(\"##min\", ImGuiDataType_Float, v_current_min, v_speed, &min_min, &min_max, format, min_flags);\n    PopItemWidth();\n    SameLine(0, g.Style.ItemInnerSpacing.x);\n\n    float max_min = (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);\n    float max_max = (v_min >= v_max) ? FLT_MAX : v_max;\n    ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);\n    value_changed |= DragScalar(\"##max\", ImGuiDataType_Float, v_current_max, v_speed, &max_min, &max_max, format_max ? format_max : format, max_flags);\n    PopItemWidth();\n    SameLine(0, g.Style.ItemInnerSpacing.x);\n\n    TextEx(label, FindRenderedTextEnd(label));\n    EndGroup();\n    PopID();\n\n    return value_changed;\n}\n\n// NB: v_speed is float to allow adjusting the drag speed with more precision\nbool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format, flags);\n}\n\n// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.\nbool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    PushID(label);\n    BeginGroup();\n    PushMultiItemsWidths(2, CalcItemWidth());\n\n    int min_min = (v_min >= v_max) ? INT_MIN : v_min;\n    int min_max = (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);\n    ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);\n    bool value_changed = DragInt(\"##min\", v_current_min, v_speed, min_min, min_max, format, min_flags);\n    PopItemWidth();\n    SameLine(0, g.Style.ItemInnerSpacing.x);\n\n    int max_min = (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);\n    int max_max = (v_min >= v_max) ? INT_MAX : v_max;\n    ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);\n    value_changed |= DragInt(\"##max\", v_current_max, v_speed, max_min, max_max, format_max ? format_max : format, max_flags);\n    PopItemWidth();\n    SameLine(0, g.Style.ItemInnerSpacing.x);\n\n    TextEx(label, FindRenderedTextEnd(label));\n    EndGroup();\n    PopID();\n\n    return value_changed;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n//-------------------------------------------------------------------------\n// - ScaleRatioFromValueT<> [Internal]\n// - ScaleValueFromRatioT<> [Internal]\n// - SliderBehaviorT<>() [Internal]\n// - SliderBehavior() [Internal]\n// - SliderScalar()\n// - SliderScalarN()\n// - SliderFloat()\n// - SliderFloat2()\n// - SliderFloat3()\n// - SliderFloat4()\n// - SliderAngle()\n// - SliderInt()\n// - SliderInt2()\n// - SliderInt3()\n// - SliderInt4()\n// - VSliderScalar()\n// - VSliderFloat()\n// - VSliderInt()\n//-------------------------------------------------------------------------\n\n// Convert a value v in the output space of a slider into a parametric position on the slider itself (the logical opposite of ScaleValueFromRatioT)\ntemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>\nfloat ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)\n{\n    if (v_min == v_max)\n        return 0.0f;\n    IM_UNUSED(data_type);\n\n    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);\n    if (is_logarithmic)\n    {\n        bool flipped = v_max < v_min;\n\n        if (flipped) // Handle the case where the range is backwards\n            ImSwap(v_min, v_max);\n\n        // Fudge min/max to avoid getting close to log(0)\n        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;\n        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;\n\n        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)\n        if ((v_min == 0.0f) && (v_max < 0.0f))\n            v_min_fudged = -logarithmic_zero_epsilon;\n        else if ((v_max == 0.0f) && (v_min < 0.0f))\n            v_max_fudged = -logarithmic_zero_epsilon;\n\n        float result;\n        if (v_clamped <= v_min_fudged)\n            result = 0.0f; // Workaround for values that are in-range but below our fudge\n        else if (v_clamped >= v_max_fudged)\n            result = 1.0f; // Workaround for values that are in-range but above our fudge\n        else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions\n        {\n            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)\n            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;\n            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;\n            if (v == 0.0f)\n                result = zero_point_center; // Special case for exactly zero\n            else if (v < 0.0f)\n                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;\n            else\n                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));\n        }\n        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider\n            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));\n        else\n            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));\n\n        return flipped ? (1.0f - result) : result;\n    }\n    else\n    {\n        // Linear slider\n        return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));\n    }\n}\n\n// Convert a parametric position on a slider into a value v in the output space (the logical opposite of ScaleRatioFromValueT)\ntemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>\nTYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)\n{\n    // We special-case the extents because otherwise our logarithmic fudging can lead to \"mathematically correct\"\n    // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.\n    if (t <= 0.0f || v_min == v_max)\n        return v_min;\n    if (t >= 1.0f)\n        return v_max;\n\n    TYPE result = (TYPE)0;\n    if (is_logarithmic)\n    {\n        // Fudge min/max to avoid getting silly results close to zero\n        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;\n        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;\n\n        const bool flipped = v_max < v_min; // Check if range is \"backwards\"\n        if (flipped)\n            ImSwap(v_min_fudged, v_max_fudged);\n\n        // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)\n        if ((v_max == 0.0f) && (v_min < 0.0f))\n            v_max_fudged = -logarithmic_zero_epsilon;\n\n        float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range\n\n        if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts\n        {\n            float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space\n            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;\n            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;\n            if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)\n                result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)\n            else if (t_with_flip < zero_point_center)\n                result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));\n            else\n                result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));\n        }\n        else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider\n            result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));\n        else\n            result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));\n    }\n    else\n    {\n        // Linear slider\n        const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);\n        if (is_floating_point)\n        {\n            result = ImLerp(v_min, v_max, t);\n        }\n        else if (t < 1.0)\n        {\n            // - For integer values we want the clicking position to match the grab box so we round above\n            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..\n            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64\n            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.\n            FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;\n            result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));\n        }\n    }\n\n    return result;\n}\n\n// FIXME: Try to move more of the code into shared SliderBehavior()\ntemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>\nbool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)\n{\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n\n    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;\n    const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;\n    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);\n    const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.\n\n    // Calculate bounds\n    const float grab_padding = 2.0f; // FIXME: Should be part of style.\n    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;\n    float grab_sz = style.GrabMinSize;\n    if (!is_floating_point && v_range_f >= 0.0f)                         // v_range_f < 0 may happen on integer overflows\n        grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit\n    grab_sz = ImMin(grab_sz, slider_sz);\n    const float slider_usable_sz = slider_sz - grab_sz;\n    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;\n    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;\n\n    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true\n    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true\n    if (is_logarithmic)\n    {\n        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.\n        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;\n        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);\n        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);\n    }\n\n    // Process interacting with the slider\n    bool value_changed = false;\n    if (g.ActiveId == id)\n    {\n        bool set_new_value = false;\n        float clicked_t = 0.0f;\n        if (g.ActiveIdSource == ImGuiInputSource_Mouse)\n        {\n            if (!g.IO.MouseDown[0])\n            {\n                ClearActiveID();\n            }\n            else\n            {\n                const float mouse_abs_pos = g.IO.MousePos[axis];\n                if (g.ActiveIdIsJustActivated)\n                {\n                    float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n                    if (axis == ImGuiAxis_Y)\n                        grab_t = 1.0f - grab_t;\n                    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);\n                    const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.\n                    g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;\n                }\n                if (slider_usable_sz > 0.0f)\n                    clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);\n                if (axis == ImGuiAxis_Y)\n                    clicked_t = 1.0f - clicked_t;\n                set_new_value = true;\n            }\n        }\n        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)\n        {\n            if (g.ActiveIdIsJustActivated)\n            {\n                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation\n                g.SliderCurrentAccumDirty = false;\n            }\n\n            float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);\n            if (input_delta != 0.0f)\n            {\n                const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);\n                const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);\n                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;\n                if (decimal_precision > 0)\n                {\n                    input_delta /= 100.0f; // Keyboard/Gamepad tweak speeds in % of slider bounds\n                    if (tweak_slow)\n                        input_delta /= 10.0f;\n                }\n                else\n                {\n                    if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)\n                        input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Keyboard/Gamepad tweak speeds in integer steps\n                    else\n                        input_delta /= 100.0f;\n                }\n                if (tweak_fast)\n                    input_delta *= 10.0f;\n\n                g.SliderCurrentAccum += input_delta;\n                g.SliderCurrentAccumDirty = true;\n            }\n\n            float delta = g.SliderCurrentAccum;\n            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)\n            {\n                ClearActiveID();\n            }\n            else if (g.SliderCurrentAccumDirty)\n            {\n                clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n\n                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits\n                {\n                    set_new_value = false;\n                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate\n                }\n                else\n                {\n                    set_new_value = true;\n                    float old_clicked_t = clicked_t;\n                    clicked_t = ImSaturate(clicked_t + delta);\n\n                    // Calculate what our \"new\" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator\n                    TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n                    if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))\n                        v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);\n                    float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n\n                    if (delta > 0)\n                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);\n                    else\n                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);\n                }\n\n                g.SliderCurrentAccumDirty = false;\n            }\n        }\n\n        if (set_new_value)\n            if ((g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))\n                set_new_value = false;\n\n        if (set_new_value)\n        {\n            TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n\n            // Round to user desired precision based on format string\n            if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))\n                v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);\n\n            // Apply result\n            if (*v != v_new)\n            {\n                *v = v_new;\n                value_changed = true;\n            }\n        }\n    }\n\n    if (slider_sz < 1.0f)\n    {\n        *out_grab_bb = ImRect(bb.Min, bb.Min);\n    }\n    else\n    {\n        // Output grab position so it can be displayed by the caller\n        float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);\n        if (axis == ImGuiAxis_Y)\n            grab_t = 1.0f - grab_t;\n        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);\n        if (axis == ImGuiAxis_X)\n            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);\n        else\n            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);\n    }\n\n    return value_changed;\n}\n\n// For 32-bit and larger types, slider bounds are limited to half the natural type range.\n// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.\n// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.\nbool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)\n{\n    // Read imgui.cpp \"API BREAKING CHANGES\" section for 1.78 if you hit this assert.\n    IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && \"Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.\");\n    IM_ASSERT((flags & ImGuiSliderFlags_WrapAround) == 0); // Not supported by SliderXXX(), only by DragXXX()\n\n    switch (data_type)\n    {\n    case ImGuiDataType_S8:  { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS8*)p_min,  *(const ImS8*)p_max,  format, flags, out_grab_bb); if (r) *(ImS8*)p_v  = (ImS8)v32;  return r; }\n    case ImGuiDataType_U8:  { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU8*)p_min,  *(const ImU8*)p_max,  format, flags, out_grab_bb); if (r) *(ImU8*)p_v  = (ImU8)v32;  return r; }\n    case ImGuiDataType_S16: { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS16*)p_min, *(const ImS16*)p_max, format, flags, out_grab_bb); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }\n    case ImGuiDataType_U16: { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU16*)p_min, *(const ImU16*)p_max, format, flags, out_grab_bb); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }\n    case ImGuiDataType_S32:\n        IM_ASSERT(*(const ImS32*)p_min >= IM_S32_MIN / 2 && *(const ImS32*)p_max <= IM_S32_MAX / 2);\n        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)p_v,  *(const ImS32*)p_min,  *(const ImS32*)p_max,  format, flags, out_grab_bb);\n    case ImGuiDataType_U32:\n        IM_ASSERT(*(const ImU32*)p_max <= IM_U32_MAX / 2);\n        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)p_v,  *(const ImU32*)p_min,  *(const ImU32*)p_max,  format, flags, out_grab_bb);\n    case ImGuiDataType_S64:\n        IM_ASSERT(*(const ImS64*)p_min >= IM_S64_MIN / 2 && *(const ImS64*)p_max <= IM_S64_MAX / 2);\n        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)p_v,  *(const ImS64*)p_min,  *(const ImS64*)p_max,  format, flags, out_grab_bb);\n    case ImGuiDataType_U64:\n        IM_ASSERT(*(const ImU64*)p_max <= IM_U64_MAX / 2);\n        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)p_v,  *(const ImU64*)p_min,  *(const ImU64*)p_max,  format, flags, out_grab_bb);\n    case ImGuiDataType_Float:\n        IM_ASSERT(*(const float*)p_min >= -FLT_MAX / 2.0f && *(const float*)p_max <= FLT_MAX / 2.0f);\n        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)p_v,  *(const float*)p_min,  *(const float*)p_max,  format, flags, out_grab_bb);\n    case ImGuiDataType_Double:\n        IM_ASSERT(*(const double*)p_min >= -DBL_MAX / 2.0f && *(const double*)p_max <= DBL_MAX / 2.0f);\n        return SliderBehaviorT<double, double, double>(bb, id, data_type, (double*)p_v, *(const double*)p_min, *(const double*)p_max, format, flags, out_grab_bb);\n    case ImGuiDataType_COUNT: break;\n    }\n    IM_ASSERT(0);\n    return false;\n}\n\n// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required.\n// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.\nbool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    const float w = CalcItemWidth();\n\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\n\n    const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;\n    ItemSize(total_bb, style.FramePadding.y);\n    if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))\n        return false;\n\n    // Default format string when passing NULL\n    if (format == NULL)\n        format = DataTypeGetInfo(data_type)->PrintFmt;\n\n    const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags);\n    bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);\n    if (!temp_input_is_active)\n    {\n        // Tabbing or CTRL-clicking on Slider turns it into an input box\n        const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);\n        const bool make_active = (clicked || g.NavActivateId == id);\n        if (make_active && clicked)\n            SetKeyOwner(ImGuiKey_MouseLeft, id);\n        if (make_active && temp_input_allowed)\n            if ((clicked && g.IO.KeyCtrl) || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))\n                temp_input_is_active = true;\n\n        // Store initial value (not used by main lib but available as a convenience but some mods e.g. to revert)\n        if (make_active)\n            memcpy(&g.ActiveIdValueOnActivation, p_data, DataTypeGetInfo(data_type)->Size);\n\n        if (make_active && !temp_input_is_active)\n        {\n            SetActiveID(id, window);\n            SetFocusID(id, window);\n            FocusWindow(window);\n            g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);\n        }\n    }\n\n    if (temp_input_is_active)\n    {\n        // Only clamp CTRL+Click input when ImGuiSliderFlags_ClampOnInput is set (generally via ImGuiSliderFlags_AlwaysClamp)\n        const bool clamp_enabled = (flags & ImGuiSliderFlags_ClampOnInput) != 0;\n        return TempInputScalar(frame_bb, id, label, data_type, p_data, format, clamp_enabled ? p_min : NULL, clamp_enabled ? p_max : NULL);\n    }\n\n    // Draw frame\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\n    RenderNavCursor(frame_bb, id);\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);\n\n    // Slider behavior\n    ImRect grab_bb;\n    const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &grab_bb);\n    if (value_changed)\n        MarkItemEdited(id);\n\n    // Render grab\n    if (grab_bb.Max.x > grab_bb.Min.x)\n        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);\n\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\n    char value_buf[64];\n    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);\n    if (g.LogEnabled)\n        LogSetNextTextDecoration(\"{\", \"}\");\n    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));\n\n    if (label_size.x > 0.0f)\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));\n    return value_changed;\n}\n\n// Add multiple sliders on 1 line for compact edition of multiple components\nbool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    bool value_changed = false;\n    BeginGroup();\n    PushID(label);\n    PushMultiItemsWidths(components, CalcItemWidth());\n    size_t type_size = GDataTypeInfo[data_type].Size;\n    for (int i = 0; i < components; i++)\n    {\n        PushID(i);\n        if (i > 0)\n            SameLine(0, g.Style.ItemInnerSpacing.x);\n        value_changed |= SliderScalar(\"\", data_type, v, v_min, v_max, format, flags);\n        PopID();\n        PopItemWidth();\n        v = (void*)((char*)v + type_size);\n    }\n    PopID();\n\n    const char* label_end = FindRenderedTextEnd(label);\n    if (label != label_end)\n    {\n        SameLine(0, g.Style.ItemInnerSpacing.x);\n        TextEx(label, label_end);\n    }\n\n    EndGroup();\n    return value_changed;\n}\n\nbool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format, ImGuiSliderFlags flags)\n{\n    if (format == NULL)\n        format = \"%.0f deg\";\n    float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);\n    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, flags);\n    if (value_changed)\n        *v_rad = v_deg * (2 * IM_PI) / 360.0f;\n    return value_changed;\n}\n\nbool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);\n    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\n\n    ItemSize(bb, style.FramePadding.y);\n    if (!ItemAdd(frame_bb, id))\n        return false;\n\n    // Default format string when passing NULL\n    if (format == NULL)\n        format = DataTypeGetInfo(data_type)->PrintFmt;\n\n    const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags);\n    const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);\n    if (clicked || g.NavActivateId == id)\n    {\n        if (clicked)\n            SetKeyOwner(ImGuiKey_MouseLeft, id);\n        SetActiveID(id, window);\n        SetFocusID(id, window);\n        FocusWindow(window);\n        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);\n    }\n\n    // Draw frame\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\n    RenderNavCursor(frame_bb, id);\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);\n\n    // Slider behavior\n    ImRect grab_bb;\n    const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags | ImGuiSliderFlags_Vertical, &grab_bb);\n    if (value_changed)\n        MarkItemEdited(id);\n\n    // Render grab\n    if (grab_bb.Max.y > grab_bb.Min.y)\n        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);\n\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\n    // For the vertical slider we allow centered text to overlap the frame padding\n    char value_buf[64];\n    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);\n    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f));\n    if (label_size.x > 0.0f)\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\n\n    return value_changed;\n}\n\nbool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);\n}\n\nbool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)\n{\n    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n//-------------------------------------------------------------------------\n// - ImParseFormatFindStart() [Internal]\n// - ImParseFormatFindEnd() [Internal]\n// - ImParseFormatTrimDecorations() [Internal]\n// - ImParseFormatSanitizeForPrinting() [Internal]\n// - ImParseFormatSanitizeForScanning() [Internal]\n// - ImParseFormatPrecision() [Internal]\n// - TempInputTextScalar() [Internal]\n// - InputScalar()\n// - InputScalarN()\n// - InputFloat()\n// - InputFloat2()\n// - InputFloat3()\n// - InputFloat4()\n// - InputInt()\n// - InputInt2()\n// - InputInt3()\n// - InputInt4()\n// - InputDouble()\n//-------------------------------------------------------------------------\n\n// We don't use strchr() because our strings are usually very short and often start with '%'\nconst char* ImParseFormatFindStart(const char* fmt)\n{\n    while (char c = fmt[0])\n    {\n        if (c == '%' && fmt[1] != '%')\n            return fmt;\n        else if (c == '%')\n            fmt++;\n        fmt++;\n    }\n    return fmt;\n}\n\nconst char* ImParseFormatFindEnd(const char* fmt)\n{\n    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.\n    if (fmt[0] != '%')\n        return fmt;\n    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));\n    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));\n    for (char c; (c = *fmt) != 0; fmt++)\n    {\n        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)\n            return fmt + 1;\n        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)\n            return fmt + 1;\n    }\n    return fmt;\n}\n\n// Extract the format out of a format string with leading or trailing decorations\n//  fmt = \"blah blah\"  -> return \"\"\n//  fmt = \"%.3f\"       -> return fmt\n//  fmt = \"hello %.3f\" -> return fmt + 6\n//  fmt = \"%.3f hello\" -> return buf written with \"%.3f\"\nconst char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)\n{\n    const char* fmt_start = ImParseFormatFindStart(fmt);\n    if (fmt_start[0] != '%')\n        return \"\";\n    const char* fmt_end = ImParseFormatFindEnd(fmt_start);\n    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.\n        return fmt_start;\n    ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));\n    return buf;\n}\n\n// Sanitize format\n// - Zero terminate so extra characters after format (e.g. \"%f123\") don't confuse atof/atoi\n// - stb_sprintf.h supports several new modifiers which format numbers in a way that also makes them incompatible atof/atoi.\nvoid ImParseFormatSanitizeForPrinting(const char* fmt_in, char* fmt_out, size_t fmt_out_size)\n{\n    const char* fmt_end = ImParseFormatFindEnd(fmt_in);\n    IM_UNUSED(fmt_out_size);\n    IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!\n    while (fmt_in < fmt_end)\n    {\n        char c = *fmt_in++;\n        if (c != '\\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.\n            *(fmt_out++) = c;\n    }\n    *fmt_out = 0; // Zero-terminate\n}\n\n// - For scanning we need to remove all width and precision fields and flags \"%+3.7f\" -> \"%f\". BUT don't strip types like \"%I64d\" which includes digits. ! \"%07I64d\" -> \"%I64d\"\nconst char* ImParseFormatSanitizeForScanning(const char* fmt_in, char* fmt_out, size_t fmt_out_size)\n{\n    const char* fmt_end = ImParseFormatFindEnd(fmt_in);\n    const char* fmt_out_begin = fmt_out;\n    IM_UNUSED(fmt_out_size);\n    IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!\n    bool has_type = false;\n    while (fmt_in < fmt_end)\n    {\n        char c = *fmt_in++;\n        if (!has_type && ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#'))\n            continue;\n        has_type |= ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); // Stop skipping digits\n        if (c != '\\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.\n            *(fmt_out++) = c;\n    }\n    *fmt_out = 0; // Zero-terminate\n    return fmt_out_begin;\n}\n\ntemplate<typename TYPE>\nstatic const char* ImAtoi(const char* src, TYPE* output)\n{\n    int negative = 0;\n    if (*src == '-') { negative = 1; src++; }\n    if (*src == '+') { src++; }\n    TYPE v = 0;\n    while (*src >= '0' && *src <= '9')\n        v = (v * 10) + (*src++ - '0');\n    *output = negative ? -v : v;\n    return src;\n}\n\n// Parse display precision back from the display format string\n// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.\nint ImParseFormatPrecision(const char* fmt, int default_precision)\n{\n    fmt = ImParseFormatFindStart(fmt);\n    if (fmt[0] != '%')\n        return default_precision;\n    fmt++;\n    while (*fmt >= '0' && *fmt <= '9')\n        fmt++;\n    int precision = INT_MAX;\n    if (*fmt == '.')\n    {\n        fmt = ImAtoi<int>(fmt + 1, &precision);\n        if (precision < 0 || precision > 99)\n            precision = default_precision;\n    }\n    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation\n        precision = -1;\n    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)\n        precision = -1;\n    return (precision == INT_MAX) ? default_precision : precision;\n}\n\n// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)\n// FIXME: Facilitate using this in variety of other situations.\n// FIXME: Among other things, setting ImGuiItemFlags_AllowDuplicateId in LastItemData is currently correct but\n// the expected relationship between TempInputXXX functions and LastItemData is a little fishy.\nbool ImGui::TempInputText(const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags)\n{\n    // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.\n    // We clear ActiveID on the first frame to allow the InputText() taking it back.\n    ImGuiContext& g = *GImGui;\n    const bool init = (g.TempInputId != id);\n    if (init)\n        ClearActiveID();\n\n    g.CurrentWindow->DC.CursorPos = bb.Min;\n    g.LastItemData.ItemFlags |= ImGuiItemFlags_AllowDuplicateId;\n    bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);\n    if (init)\n    {\n        // First frame we started displaying the InputText widget, we expect it to take the active id.\n        IM_ASSERT(g.ActiveId == id);\n        g.TempInputId = g.ActiveId;\n    }\n    return value_changed;\n}\n\n// Note that Drag/Slider functions are only forwarding the min/max values clamping values if the ImGuiSliderFlags_AlwaysClamp flag is set!\n// This is intended: this way we allow CTRL+Click manual input to set a value out of bounds, for maximum flexibility.\n// However this may not be ideal for all uses, as some user code may break on out of bound values.\nbool ImGui::TempInputScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min, const void* p_clamp_max)\n{\n    // FIXME: May need to clarify display behavior if format doesn't contain %.\n    // \"%d\" -> \"%d\" / \"There are %d items\" -> \"%d\" / \"items\" -> \"%d\" (fallback). Also see #6405\n    ImGuiContext& g = *GImGui;\n    const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);\n    char fmt_buf[32];\n    char data_buf[32];\n    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));\n    if (format[0] == 0)\n        format = type_info->PrintFmt;\n    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, p_data, format);\n    ImStrTrimBlanks(data_buf);\n\n    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint;\n    g.LastItemData.ItemFlags |= ImGuiItemFlags_NoMarkEdited; // Because TempInputText() uses ImGuiInputTextFlags_MergedItem it doesn't submit a new item, so we poke LastItemData.\n    bool value_changed = false;\n    if (TempInputText(bb, id, label, data_buf, IM_ARRAYSIZE(data_buf), flags))\n    {\n        // Backup old value\n        size_t data_type_size = type_info->Size;\n        ImGuiDataTypeStorage data_backup;\n        memcpy(&data_backup, p_data, data_type_size);\n\n        // Apply new value (or operations) then clamp\n        DataTypeApplyFromText(data_buf, data_type, p_data, format, NULL);\n        if (p_clamp_min || p_clamp_max)\n        {\n            if (p_clamp_min && p_clamp_max && DataTypeCompare(data_type, p_clamp_min, p_clamp_max) > 0)\n                ImSwap(p_clamp_min, p_clamp_max);\n            DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max);\n        }\n\n        // Only mark as edited if new value is different\n        g.LastItemData.ItemFlags &= ~ImGuiItemFlags_NoMarkEdited;\n        value_changed = memcmp(&data_backup, p_data, data_type_size) != 0;\n        if (value_changed)\n            MarkItemEdited(id);\n    }\n    return value_changed;\n}\n\nvoid ImGui::SetNextItemRefVal(ImGuiDataType data_type, void* p_data)\n{\n    ImGuiContext& g = *GImGui;\n    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasRefVal;\n    memcpy(&g.NextItemData.RefVal, p_data, DataTypeGetInfo(data_type)->Size);\n}\n\n// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding the data. For an Input widget, p_step and p_step_fast are optional.\n// Read code of e.g. InputFloat(), InputInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.\nbool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    ImGuiStyle& style = g.Style;\n    IM_ASSERT((flags & ImGuiInputTextFlags_EnterReturnsTrue) == 0); // Not supported by InputScalar(). Please open an issue if you this would be useful to you. Otherwise use IsItemDeactivatedAfterEdit()!\n\n    if (format == NULL)\n        format = DataTypeGetInfo(data_type)->PrintFmt;\n\n    void* p_data_default = (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasRefVal) ? &g.NextItemData.RefVal : &g.DataTypeZeroValue;\n\n    char buf[64];\n    if ((flags & ImGuiInputTextFlags_DisplayEmptyRefVal) && DataTypeCompare(data_type, p_data, p_data_default) == 0)\n        buf[0] = 0;\n    else\n        DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, p_data, format);\n\n    // Disable the MarkItemEdited() call in InputText but keep ImGuiItemStatusFlags_Edited.\n    // We call MarkItemEdited() ourselves by comparing the actual data rather than the string.\n    g.NextItemData.ItemFlags |= ImGuiItemFlags_NoMarkEdited;\n    flags |= ImGuiInputTextFlags_AutoSelectAll | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint;\n\n    bool value_changed = false;\n    if (p_step == NULL)\n    {\n        if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))\n            value_changed = DataTypeApplyFromText(buf, data_type, p_data, format, (flags & ImGuiInputTextFlags_ParseEmptyRefVal) ? p_data_default : NULL);\n    }\n    else\n    {\n        const float button_size = GetFrameHeight();\n\n        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()\n        PushID(label);\n        SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));\n        if (InputText(\"\", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + \"\" gives us the expected ID from outside point of view\n            value_changed = DataTypeApplyFromText(buf, data_type, p_data, format, (flags & ImGuiInputTextFlags_ParseEmptyRefVal) ? p_data_default : NULL);\n        IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);\n\n        // Step buttons\n        const ImVec2 backup_frame_padding = style.FramePadding;\n        style.FramePadding.x = style.FramePadding.y;\n        if (flags & ImGuiInputTextFlags_ReadOnly)\n            BeginDisabled();\n        PushItemFlag(ImGuiItemFlags_ButtonRepeat, true);\n        SameLine(0, style.ItemInnerSpacing.x);\n        if (ButtonEx(\"-\", ImVec2(button_size, button_size)))\n        {\n            DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);\n            value_changed = true;\n        }\n        SameLine(0, style.ItemInnerSpacing.x);\n        if (ButtonEx(\"+\", ImVec2(button_size, button_size)))\n        {\n            DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);\n            value_changed = true;\n        }\n        PopItemFlag();\n        if (flags & ImGuiInputTextFlags_ReadOnly)\n            EndDisabled();\n\n        const char* label_end = FindRenderedTextEnd(label);\n        if (label != label_end)\n        {\n            SameLine(0, style.ItemInnerSpacing.x);\n            TextEx(label, label_end);\n        }\n        style.FramePadding = backup_frame_padding;\n\n        PopID();\n        EndGroup();\n    }\n\n    g.LastItemData.ItemFlags &= ~ImGuiItemFlags_NoMarkEdited;\n    if (value_changed)\n        MarkItemEdited(g.LastItemData.ID);\n\n    return value_changed;\n}\n\nbool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    bool value_changed = false;\n    BeginGroup();\n    PushID(label);\n    PushMultiItemsWidths(components, CalcItemWidth());\n    size_t type_size = GDataTypeInfo[data_type].Size;\n    for (int i = 0; i < components; i++)\n    {\n        PushID(i);\n        if (i > 0)\n            SameLine(0, g.Style.ItemInnerSpacing.x);\n        value_changed |= InputScalar(\"\", data_type, p_data, p_step, p_step_fast, format, flags);\n        PopID();\n        PopItemWidth();\n        p_data = (void*)((char*)p_data + type_size);\n    }\n    PopID();\n\n    const char* label_end = FindRenderedTextEnd(label);\n    if (label != label_end)\n    {\n        SameLine(0.0f, g.Style.ItemInnerSpacing.x);\n        TextEx(label, label_end);\n    }\n\n    EndGroup();\n    return value_changed;\n}\n\nbool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)\n{\n    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step > 0.0f ? &step : NULL), (void*)(step_fast > 0.0f ? &step_fast : NULL), format, flags);\n}\n\nbool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)\n{\n    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);\n}\n\nbool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)\n{\n    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);\n}\n\nbool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)\n{\n    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);\n}\n\nbool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)\n{\n    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.\n    const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? \"%08X\" : \"%d\";\n    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step > 0 ? &step : NULL), (void*)(step_fast > 0 ? &step_fast : NULL), format, flags);\n}\n\nbool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)\n{\n    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, \"%d\", flags);\n}\n\nbool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)\n{\n    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, \"%d\", flags);\n}\n\nbool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)\n{\n    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, \"%d\", flags);\n}\n\nbool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)\n{\n    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step > 0.0 ? &step : NULL), (void*)(step_fast > 0.0 ? &step_fast : NULL), format, flags);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint\n//-------------------------------------------------------------------------\n// - imstb_textedit.h include\n// - InputText()\n// - InputTextWithHint()\n// - InputTextMultiline()\n// - InputTextGetCharInfo() [Internal]\n// - InputTextReindexLines() [Internal]\n// - InputTextReindexLinesRange() [Internal]\n// - InputTextEx() [Internal]\n// - DebugNodeInputTextState() [Internal]\n//-------------------------------------------------------------------------\n\nnamespace ImStb\n{\n#include \"imstb_textedit.h\"\n}\n\nbool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()\n    return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);\n}\n\nbool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);\n}\n\nbool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline() or  InputTextEx() manually if you need multi-line + hint.\n    return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);\n}\n\n// This is only used in the path where the multiline widget is inactivate.\nstatic int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)\n{\n    int line_count = 0;\n    const char* s = text_begin;\n    while (true)\n    {\n        const char* s_eol = strchr(s, '\\n');\n        line_count++;\n        if (s_eol == NULL)\n        {\n            s = s + strlen(s);\n            break;\n        }\n        s = s_eol + 1;\n    }\n    *out_text_end = s;\n    return line_count;\n}\n\n// FIXME: Ideally we'd share code with ImFont::CalcTextSizeA()\nstatic ImVec2 InputTextCalcTextSize(ImGuiContext* ctx, const char* text_begin, const char* text_end, const char** remaining, ImVec2* out_offset, bool stop_on_new_line)\n{\n    ImGuiContext& g = *ctx;\n    ImFont* font = g.Font;\n    const float line_height = g.FontSize;\n    const float scale = line_height / font->FontSize;\n\n    ImVec2 text_size = ImVec2(0, 0);\n    float line_width = 0.0f;\n\n    const char* s = text_begin;\n    while (s < text_end)\n    {\n        unsigned int c = (unsigned int)*s;\n        if (c < 0x80)\n            s += 1;\n        else\n            s += ImTextCharFromUtf8(&c, s, text_end);\n\n        if (c == '\\n')\n        {\n            text_size.x = ImMax(text_size.x, line_width);\n            text_size.y += line_height;\n            line_width = 0.0f;\n            if (stop_on_new_line)\n                break;\n            continue;\n        }\n        if (c == '\\r')\n            continue;\n\n        const float char_width = ((int)c < font->IndexAdvanceX.Size ? font->IndexAdvanceX.Data[c] : font->FallbackAdvanceX) * scale;\n        line_width += char_width;\n    }\n\n    if (text_size.x < line_width)\n        text_size.x = line_width;\n\n    if (out_offset)\n        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \\n\n\n    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \\n\n        text_size.y += line_height;\n\n    if (remaining)\n        *remaining = s;\n\n    return text_size;\n}\n\n// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)\n// With our UTF-8 use of stb_textedit:\n// - STB_TEXTEDIT_GETCHAR is nothing more than a a \"GETBYTE\". It's only used to compare to ascii or to copy blocks of text so we are fine.\n// - One exception is the STB_TEXTEDIT_IS_SPACE feature which would expect a full char in order to handle full-width space such as 0x3000 (see ImCharIsBlankW).\n// - ...but we don't use that feature.\nnamespace ImStb\n{\nstatic int     STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj)                             { return obj->TextLen; }\nstatic char    STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { IM_ASSERT(idx <= obj->TextLen); return obj->TextSrc[idx]; }\nstatic float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { unsigned int c; ImTextCharFromUtf8(&c, obj->TextSrc + line_start_idx + char_idx, obj->TextSrc + obj->TextLen); if ((ImWchar)c == '\\n') return IMSTB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance((ImWchar)c) * g.FontScale; }\nstatic char    STB_TEXTEDIT_NEWLINE = '\\n';\nstatic void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, ImGuiInputTextState* obj, int line_start_idx)\n{\n    const char* text = obj->TextSrc;\n    const char* text_remaining = NULL;\n    const ImVec2 size = InputTextCalcTextSize(obj->Ctx, text + line_start_idx, text + obj->TextLen, &text_remaining, NULL, true);\n    r->x0 = 0.0f;\n    r->x1 = size.x;\n    r->baseline_y_delta = size.y;\n    r->ymin = 0.0f;\n    r->ymax = size.y;\n    r->num_chars = (int)(text_remaining - (text + line_start_idx));\n}\n\n#define IMSTB_TEXTEDIT_GETNEXTCHARINDEX  IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPL\n#define IMSTB_TEXTEDIT_GETPREVCHARINDEX  IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL\n\nstatic int IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx)\n{\n    if (idx >= obj->TextLen)\n        return obj->TextLen + 1;\n    unsigned int c;\n    return idx + ImTextCharFromUtf8(&c, obj->TextSrc + idx, obj->TextSrc + obj->TextLen);\n}\n\nstatic int IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx)\n{\n    if (idx <= 0)\n        return -1;\n    const char* p = ImTextFindPreviousUtf8Codepoint(obj->TextSrc, obj->TextSrc + idx);\n    return (int)(p - obj->TextSrc);\n}\n\nstatic bool ImCharIsSeparatorW(unsigned int c)\n{\n    static const unsigned int separator_list[] =\n    {\n        ',', 0x3001, '.', 0x3002, ';', 0xFF1B, '(', 0xFF08, ')', 0xFF09, '{', 0xFF5B, '}', 0xFF5D,\n        '[', 0x300C, ']', 0x300D, '|', 0xFF5C, '!', 0xFF01, '\\\\', 0xFFE5, '/', 0x30FB, 0xFF0F,\n        '\\n', '\\r',\n    };\n    for (unsigned int separator : separator_list)\n        if (c == separator)\n            return true;\n    return false;\n}\n\nstatic int is_word_boundary_from_right(ImGuiInputTextState* obj, int idx)\n{\n    // When ImGuiInputTextFlags_Password is set, we don't want actions such as CTRL+Arrow to leak the fact that underlying data are blanks or separators.\n    if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)\n        return 0;\n\n    const char* curr_p = obj->TextSrc + idx;\n    const char* prev_p = ImTextFindPreviousUtf8Codepoint(obj->TextSrc, curr_p);\n    unsigned int curr_c; ImTextCharFromUtf8(&curr_c, curr_p, obj->TextSrc + obj->TextLen);\n    unsigned int prev_c; ImTextCharFromUtf8(&prev_c, prev_p, obj->TextSrc + obj->TextLen);\n\n    bool prev_white = ImCharIsBlankW(prev_c);\n    bool prev_separ = ImCharIsSeparatorW(prev_c);\n    bool curr_white = ImCharIsBlankW(curr_c);\n    bool curr_separ = ImCharIsSeparatorW(curr_c);\n    return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);\n}\nstatic int is_word_boundary_from_left(ImGuiInputTextState* obj, int idx)\n{\n    if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)\n        return 0;\n\n    const char* curr_p = obj->TextSrc + idx;\n    const char* prev_p = ImTextFindPreviousUtf8Codepoint(obj->TextSrc, curr_p);\n    unsigned int prev_c; ImTextCharFromUtf8(&prev_c, curr_p, obj->TextSrc + obj->TextLen);\n    unsigned int curr_c; ImTextCharFromUtf8(&curr_c, prev_p, obj->TextSrc + obj->TextLen);\n\n    bool prev_white = ImCharIsBlankW(prev_c);\n    bool prev_separ = ImCharIsSeparatorW(prev_c);\n    bool curr_white = ImCharIsBlankW(curr_c);\n    bool curr_separ = ImCharIsSeparatorW(curr_c);\n    return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);\n}\nstatic int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState* obj, int idx)\n{\n    idx = IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx);\n    while (idx >= 0 && !is_word_boundary_from_right(obj, idx))\n        idx = IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx);\n    return idx < 0 ? 0 : idx;\n}\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_MAC(ImGuiInputTextState* obj, int idx)\n{\n    int len = obj->TextLen;\n    idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);\n    while (idx < len && !is_word_boundary_from_left(obj, idx))\n        idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);\n    return idx > len ? len : idx;\n}\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState* obj, int idx)\n{\n    idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);\n    int len = obj->TextLen;\n    while (idx < len && !is_word_boundary_from_right(obj, idx))\n        idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx);\n    return idx > len ? len : idx;\n}\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiInputTextState* obj, int idx)  { ImGuiContext& g = *obj->Ctx; if (g.IO.ConfigMacOSXBehaviors) return STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx); else return STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx); }\n#define STB_TEXTEDIT_MOVEWORDLEFT       STB_TEXTEDIT_MOVEWORDLEFT_IMPL  // They need to be #define for stb_textedit.h\n#define STB_TEXTEDIT_MOVEWORDRIGHT      STB_TEXTEDIT_MOVEWORDRIGHT_IMPL\n\nstatic void STB_TEXTEDIT_DELETECHARS(ImGuiInputTextState* obj, int pos, int n)\n{\n    // Offset remaining text (+ copy zero terminator)\n    IM_ASSERT(obj->TextSrc == obj->TextA.Data);\n    char* dst = obj->TextA.Data + pos;\n    char* src = obj->TextA.Data + pos + n;\n    memmove(dst, src, obj->TextLen - n - pos + 1);\n    obj->Edited = true;\n    obj->TextLen -= n;\n}\n\nstatic bool STB_TEXTEDIT_INSERTCHARS(ImGuiInputTextState* obj, int pos, const char* new_text, int new_text_len)\n{\n    const bool is_resizable = (obj->Flags & ImGuiInputTextFlags_CallbackResize) != 0;\n    const int text_len = obj->TextLen;\n    IM_ASSERT(pos <= text_len);\n\n    if (!is_resizable && (new_text_len + obj->TextLen + 1 > obj->BufCapacity))\n        return false;\n\n    // Grow internal buffer if needed\n    IM_ASSERT(obj->TextSrc == obj->TextA.Data);\n    if (new_text_len + text_len + 1 > obj->TextA.Size)\n    {\n        if (!is_resizable)\n            return false;\n        obj->TextA.resize(text_len + ImClamp(new_text_len, 32, ImMax(256, new_text_len)) + 1);\n        obj->TextSrc = obj->TextA.Data;\n    }\n\n    char* text = obj->TextA.Data;\n    if (pos != text_len)\n        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos));\n    memcpy(text + pos, new_text, (size_t)new_text_len);\n\n    obj->Edited = true;\n    obj->TextLen += new_text_len;\n    obj->TextA[obj->TextLen] = '\\0';\n\n    return true;\n}\n\n// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)\n#define STB_TEXTEDIT_K_LEFT         0x200000 // keyboard input to move cursor left\n#define STB_TEXTEDIT_K_RIGHT        0x200001 // keyboard input to move cursor right\n#define STB_TEXTEDIT_K_UP           0x200002 // keyboard input to move cursor up\n#define STB_TEXTEDIT_K_DOWN         0x200003 // keyboard input to move cursor down\n#define STB_TEXTEDIT_K_LINESTART    0x200004 // keyboard input to move cursor to start of line\n#define STB_TEXTEDIT_K_LINEEND      0x200005 // keyboard input to move cursor to end of line\n#define STB_TEXTEDIT_K_TEXTSTART    0x200006 // keyboard input to move cursor to start of text\n#define STB_TEXTEDIT_K_TEXTEND      0x200007 // keyboard input to move cursor to end of text\n#define STB_TEXTEDIT_K_DELETE       0x200008 // keyboard input to delete selection or character under cursor\n#define STB_TEXTEDIT_K_BACKSPACE    0x200009 // keyboard input to delete selection or character left of cursor\n#define STB_TEXTEDIT_K_UNDO         0x20000A // keyboard input to perform undo\n#define STB_TEXTEDIT_K_REDO         0x20000B // keyboard input to perform redo\n#define STB_TEXTEDIT_K_WORDLEFT     0x20000C // keyboard input to move cursor left one word\n#define STB_TEXTEDIT_K_WORDRIGHT    0x20000D // keyboard input to move cursor right one word\n#define STB_TEXTEDIT_K_PGUP         0x20000E // keyboard input to move cursor up a page\n#define STB_TEXTEDIT_K_PGDOWN       0x20000F // keyboard input to move cursor down a page\n#define STB_TEXTEDIT_K_SHIFT        0x400000\n\n#define IMSTB_TEXTEDIT_IMPLEMENTATION\n#define IMSTB_TEXTEDIT_memmove memmove\n#include \"imstb_textedit.h\"\n\n// stb_textedit internally allows for a single undo record to do addition and deletion, but somehow, calling\n// the stb_textedit_paste() function creates two separate records, so we perform it manually. (FIXME: Report to nothings/stb?)\nstatic void stb_textedit_replace(ImGuiInputTextState* str, STB_TexteditState* state, const IMSTB_TEXTEDIT_CHARTYPE* text, int text_len)\n{\n    stb_text_makeundo_replace(str, state, 0, str->TextLen, text_len);\n    ImStb::STB_TEXTEDIT_DELETECHARS(str, 0, str->TextLen);\n    state->cursor = state->select_start = state->select_end = 0;\n    if (text_len <= 0)\n        return;\n    if (ImStb::STB_TEXTEDIT_INSERTCHARS(str, 0, text, text_len))\n    {\n        state->cursor = state->select_start = state->select_end = text_len;\n        state->has_preferred_x = 0;\n        return;\n    }\n    IM_ASSERT(0); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()\n}\n\n} // namespace ImStb\n\n// We added an extra indirection where 'Stb' is heap-allocated, in order facilitate the work of bindings generators.\nImGuiInputTextState::ImGuiInputTextState()\n{\n    memset(this, 0, sizeof(*this));\n    Stb = IM_NEW(ImStbTexteditState);\n    memset(Stb, 0, sizeof(*Stb));\n}\n\nImGuiInputTextState::~ImGuiInputTextState()\n{\n    IM_DELETE(Stb);\n}\n\nvoid ImGuiInputTextState::OnKeyPressed(int key)\n{\n    stb_textedit_key(this, Stb, key);\n    CursorFollow = true;\n    CursorAnimReset();\n}\n\nvoid ImGuiInputTextState::OnCharPressed(unsigned int c)\n{\n    // Convert the key to a UTF8 byte sequence.\n    // The changes we had to make to stb_textedit_key made it very much UTF-8 specific which is not too great.\n    char utf8[5];\n    ImTextCharToUtf8(utf8, c);\n    stb_textedit_text(this, Stb, utf8, (int)strlen(utf8));\n    CursorFollow = true;\n    CursorAnimReset();\n}\n\n// Those functions are not inlined in imgui_internal.h, allowing us to hide ImStbTexteditState from that header.\nvoid ImGuiInputTextState::CursorAnimReset()                 { CursorAnim = -0.30f; } // After a user-input the cursor stays on for a while without blinking\nvoid ImGuiInputTextState::CursorClamp()                     { Stb->cursor = ImMin(Stb->cursor, TextLen); Stb->select_start = ImMin(Stb->select_start, TextLen); Stb->select_end = ImMin(Stb->select_end, TextLen); }\nbool ImGuiInputTextState::HasSelection() const              { return Stb->select_start != Stb->select_end; }\nvoid ImGuiInputTextState::ClearSelection()                  { Stb->select_start = Stb->select_end = Stb->cursor; }\nint  ImGuiInputTextState::GetCursorPos() const              { return Stb->cursor; }\nint  ImGuiInputTextState::GetSelectionStart() const         { return Stb->select_start; }\nint  ImGuiInputTextState::GetSelectionEnd() const           { return Stb->select_end; }\nvoid ImGuiInputTextState::SelectAll()                       { Stb->select_start = 0; Stb->cursor = Stb->select_end = TextLen; Stb->has_preferred_x = 0; }\nvoid ImGuiInputTextState::ReloadUserBufAndSelectAll()       { WantReloadUserBuf = true; ReloadSelectionStart = 0; ReloadSelectionEnd = INT_MAX; }\nvoid ImGuiInputTextState::ReloadUserBufAndKeepSelection()   { WantReloadUserBuf = true; ReloadSelectionStart = Stb->select_start; ReloadSelectionEnd = Stb->select_end; }\nvoid ImGuiInputTextState::ReloadUserBufAndMoveToEnd()       { WantReloadUserBuf = true; ReloadSelectionStart = ReloadSelectionEnd = INT_MAX; }\n\nImGuiInputTextCallbackData::ImGuiInputTextCallbackData()\n{\n    memset(this, 0, sizeof(*this));\n}\n\n// Public API to manipulate UTF-8 text from within a callback.\n// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.\n// Historically they existed because STB_TEXTEDIT_INSERTCHARS() etc. worked on our ImWchar\n// buffer, but nowadays they both work on UTF-8 data. Should aim to merge both.\nvoid ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)\n{\n    IM_ASSERT(pos + bytes_count <= BufTextLen);\n    char* dst = Buf + pos;\n    const char* src = Buf + pos + bytes_count;\n    memmove(dst, src, BufTextLen - bytes_count - pos + 1);\n\n    if (CursorPos >= pos + bytes_count)\n        CursorPos -= bytes_count;\n    else if (CursorPos >= pos)\n        CursorPos = pos;\n    SelectionStart = SelectionEnd = CursorPos;\n    BufDirty = true;\n    BufTextLen -= bytes_count;\n}\n\nvoid ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)\n{\n    // Accept null ranges\n    if (new_text == new_text_end)\n        return;\n\n    // Grow internal buffer if needed\n    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;\n    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);\n    if (new_text_len + BufTextLen >= BufSize)\n    {\n        if (!is_resizable)\n            return;\n\n        ImGuiContext& g = *Ctx;\n        ImGuiInputTextState* edit_state = &g.InputTextState;\n        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);\n        IM_ASSERT(Buf == edit_state->TextA.Data);\n        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;\n        edit_state->TextA.resize(new_buf_size + 1);\n        edit_state->TextSrc = edit_state->TextA.Data;\n        Buf = edit_state->TextA.Data;\n        BufSize = edit_state->BufCapacity = new_buf_size;\n    }\n\n    if (BufTextLen != pos)\n        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));\n    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));\n    Buf[BufTextLen + new_text_len] = '\\0';\n\n    if (CursorPos >= pos)\n        CursorPos += new_text_len;\n    SelectionStart = SelectionEnd = CursorPos;\n    BufDirty = true;\n    BufTextLen += new_text_len;\n}\n\n// Return false to discard a character.\nstatic bool InputTextFilterCharacter(ImGuiContext* ctx, unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, bool input_source_is_clipboard)\n{\n    unsigned int c = *p_char;\n\n    // Filter non-printable (NB: isprint is unreliable! see #2467)\n    bool apply_named_filters = true;\n    if (c < 0x20)\n    {\n        bool pass = false;\n        pass |= (c == '\\n') && (flags & ImGuiInputTextFlags_Multiline) != 0; // Note that an Enter KEY will emit \\r and be ignored (we poll for KEY in InputText() code)\n        pass |= (c == '\\t') && (flags & ImGuiInputTextFlags_AllowTabInput) != 0;\n        if (!pass)\n            return false;\n        apply_named_filters = false; // Override named filters below so newline and tabs can still be inserted.\n    }\n\n    if (input_source_is_clipboard == false)\n    {\n        // We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)\n        if (c == 127)\n            return false;\n\n        // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)\n        if (c >= 0xE000 && c <= 0xF8FF)\n            return false;\n    }\n\n    // Filter Unicode ranges we are not handling in this build\n    if (c > IM_UNICODE_CODEPOINT_MAX)\n        return false;\n\n    // Generic named filters\n    if (apply_named_filters && (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint)))\n    {\n        // The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC, \"de_DE.UTF-8\");' which affect the output/input of printf/scanf to use e.g. ',' instead of '.'.\n        // The standard mandate that programs starts in the \"C\" locale where the decimal point is '.'.\n        // We don't really intend to provide widespread support for it, but out of empathy for people stuck with using odd API, we support the bare minimum aka overriding the decimal point.\n        // Change the default decimal_point with:\n        //   ImGui::GetPlatformIO()->Platform_LocaleDecimalPoint = *localeconv()->decimal_point;\n        // Users of non-default decimal point (in particular ',') may be affected by word-selection logic (is_word_boundary_from_right/is_word_boundary_from_left) functions.\n        ImGuiContext& g = *ctx;\n        const unsigned c_decimal_point = (unsigned int)g.PlatformIO.Platform_LocaleDecimalPoint;\n        if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint))\n            if (c == '.' || c == ',')\n                c = c_decimal_point;\n\n        // Full-width -> half-width conversion for numeric fields (https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\n        // While this is mostly convenient, this has the side-effect for uninformed users accidentally inputting full-width characters that they may\n        // scratch their head as to why it works in numerical fields vs in generic text fields it would require support in the font.\n        if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | ImGuiInputTextFlags_CharsHexadecimal))\n            if (c >= 0xFF01 && c <= 0xFF5E)\n                c = c - 0xFF01 + 0x21;\n\n        // Allow 0-9 . - + * /\n        if (flags & ImGuiInputTextFlags_CharsDecimal)\n            if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/'))\n                return false;\n\n        // Allow 0-9 . - + * / e E\n        if (flags & ImGuiInputTextFlags_CharsScientific)\n            if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))\n                return false;\n\n        // Allow 0-9 a-F A-F\n        if (flags & ImGuiInputTextFlags_CharsHexadecimal)\n            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))\n                return false;\n\n        // Turn a-z into A-Z\n        if (flags & ImGuiInputTextFlags_CharsUppercase)\n            if (c >= 'a' && c <= 'z')\n                c += (unsigned int)('A' - 'a');\n\n        if (flags & ImGuiInputTextFlags_CharsNoBlank)\n            if (ImCharIsBlankW(c))\n                return false;\n\n        *p_char = c;\n    }\n\n    // Custom callback filter\n    if (flags & ImGuiInputTextFlags_CallbackCharFilter)\n    {\n        ImGuiContext& g = *GImGui;\n        ImGuiInputTextCallbackData callback_data;\n        callback_data.Ctx = &g;\n        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;\n        callback_data.EventChar = (ImWchar)c;\n        callback_data.Flags = flags;\n        callback_data.UserData = user_data;\n        if (callback(&callback_data) != 0)\n            return false;\n        *p_char = callback_data.EventChar;\n        if (!callback_data.EventChar)\n            return false;\n    }\n\n    return true;\n}\n\n// Find the shortest single replacement we can make to get from old_buf to new_buf\n// Note that this doesn't directly alter state->TextA, state->TextLen. They are expected to be made valid separately.\n// FIXME: Ideally we should transition toward (1) making InsertChars()/DeleteChars() update undo-stack (2) discourage (and keep reconcile) or obsolete (and remove reconcile) accessing buffer directly.\nstatic void InputTextReconcileUndoState(ImGuiInputTextState* state, const char* old_buf, int old_length, const char* new_buf, int new_length)\n{\n    const int shorter_length = ImMin(old_length, new_length);\n    int first_diff;\n    for (first_diff = 0; first_diff < shorter_length; first_diff++)\n        if (old_buf[first_diff] != new_buf[first_diff])\n            break;\n    if (first_diff == old_length && first_diff == new_length)\n        return;\n\n    int old_last_diff = old_length   - 1;\n    int new_last_diff = new_length - 1;\n    for (; old_last_diff >= first_diff && new_last_diff >= first_diff; old_last_diff--, new_last_diff--)\n        if (old_buf[old_last_diff] != new_buf[new_last_diff])\n            break;\n\n    const int insert_len = new_last_diff - first_diff + 1;\n    const int delete_len = old_last_diff - first_diff + 1;\n    if (insert_len > 0 || delete_len > 0)\n        if (IMSTB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->Stb->undostate, first_diff, delete_len, insert_len))\n            for (int i = 0; i < delete_len; i++)\n                p[i] = old_buf[first_diff + i];\n}\n\n// As InputText() retain textual data and we currently provide a path for user to not retain it (via local variables)\n// we need some form of hook to reapply data back to user buffer on deactivation frame. (#4714)\n// It would be more desirable that we discourage users from taking advantage of the \"user not retaining data\" trick,\n// but that more likely be attractive when we do have _NoLiveEdit flag available.\nvoid ImGui::InputTextDeactivateHook(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiInputTextState* state = &g.InputTextState;\n    if (id == 0 || state->ID != id)\n        return;\n    g.InputTextDeactivatedState.ID = state->ID;\n    if (state->Flags & ImGuiInputTextFlags_ReadOnly)\n    {\n        g.InputTextDeactivatedState.TextA.resize(0); // In theory this data won't be used, but clear to be neat.\n    }\n    else\n    {\n        IM_ASSERT(state->TextA.Data != 0);\n        IM_ASSERT(state->TextA[state->TextLen] == 0);\n        g.InputTextDeactivatedState.TextA.resize(state->TextLen + 1);\n        memcpy(g.InputTextDeactivatedState.TextA.Data, state->TextA.Data, state->TextLen + 1);\n    }\n}\n\n// Edit a string of text\n// - buf_size account for the zero-terminator, so a buf_size of 6 can hold \"Hello\" but not \"Hello!\".\n//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match\n//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.\n// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.\n// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h\n// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are\n//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)\nbool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    IM_ASSERT(buf != NULL && buf_size >= 0);\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_ElideLeft) && (flags & ImGuiInputTextFlags_Multiline)));               // Multiline will not work with left-trimming\n\n    ImGuiContext& g = *GImGui;\n    ImGuiIO& io = g.IO;\n    const ImGuiStyle& style = g.Style;\n\n    const bool RENDER_SELECTION_WHEN_INACTIVE = false;\n    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;\n\n    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope (including the scrollbar)\n        BeginGroup();\n    const ImGuiID id = window->GetID(label);\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n    const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line\n    const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);\n\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);\n    const ImRect total_bb(frame_bb.Min, frame_bb.Min + total_size);\n\n    ImGuiWindow* draw_window = window;\n    ImVec2 inner_size = frame_size;\n    ImGuiLastItemData item_data_backup;\n    if (is_multiline)\n    {\n        ImVec2 backup_pos = window->DC.CursorPos;\n        ItemSize(total_bb, style.FramePadding.y);\n        if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))\n        {\n            EndGroup();\n            return false;\n        }\n        item_data_backup = g.LastItemData;\n        window->DC.CursorPos = backup_pos;\n\n        // Prevent NavActivation from Tabbing when our widget accepts Tab inputs: this allows cycling through widgets without stopping.\n        if (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_FromTabbing) && (flags & ImGuiInputTextFlags_AllowTabInput))\n            g.NavActivateId = 0;\n\n        // Prevent NavActivate reactivating in BeginChild() when we are already active.\n        const ImGuiID backup_activate_id = g.NavActivateId;\n        if (g.ActiveId == id) // Prevent reactivation\n            g.NavActivateId = 0;\n\n        // We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.\n        PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);\n        PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);\n        PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);\n        PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0)); // Ensure no clip rect so mouse hover can reach FramePadding edges\n        bool child_visible = BeginChildEx(label, id, frame_bb.GetSize(), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);\n        g.NavActivateId = backup_activate_id;\n        PopStyleVar(3);\n        PopStyleColor();\n        if (!child_visible)\n        {\n            EndChild();\n            EndGroup();\n            return false;\n        }\n        draw_window = g.CurrentWindow; // Child window\n        draw_window->DC.NavLayersActiveMaskNext |= (1 << draw_window->DC.NavLayerCurrent); // This is to ensure that EndChild() will display a navigation highlight so we can \"enter\" into it.\n        draw_window->DC.CursorPos += style.FramePadding;\n        inner_size.x -= draw_window->ScrollbarSizes.x;\n    }\n    else\n    {\n        // Support for internal ImGuiInputTextFlags_MergedItem flag, which could be redesigned as an ItemFlags if needed (with test performed in ItemAdd)\n        ItemSize(total_bb, style.FramePadding.y);\n        if (!(flags & ImGuiInputTextFlags_MergedItem))\n            if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))\n                return false;\n    }\n\n    // Ensure mouse cursor is set even after switching to keyboard/gamepad mode. May generalize further? (#6417)\n    bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags | ImGuiItemFlags_NoNavDisableMouseHover);\n    if (hovered)\n        SetMouseCursor(ImGuiMouseCursor_TextInput);\n    if (hovered && g.NavHighlightItemUnderNav)\n        hovered = false;\n\n    // We are only allowed to access the state if we are already the active widget.\n    ImGuiInputTextState* state = GetInputTextState(id);\n\n    if (g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly)\n        flags |= ImGuiInputTextFlags_ReadOnly;\n    const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;\n    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;\n    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;\n    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;\n    if (is_resizable)\n        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!\n\n    const bool input_requested_by_nav = (g.ActiveId != id) && ((g.NavActivateId == id) && ((g.NavActivateFlags & ImGuiActivateFlags_PreferInput) || (g.NavInputSource == ImGuiInputSource_Keyboard)));\n\n    const bool user_clicked = hovered && io.MouseClicked[0];\n    const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);\n    const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);\n    bool clear_active_id = false;\n    bool select_all = false;\n\n    float scroll_y = is_multiline ? draw_window->Scroll.y : FLT_MAX;\n\n    const bool init_reload_from_user_buf = (state != NULL && state->WantReloadUserBuf);\n    const bool init_changed_specs = (state != NULL && state->Stb->single_line != !is_multiline); // state != NULL means its our state.\n    const bool init_make_active = (user_clicked || user_scroll_finish || input_requested_by_nav);\n    const bool init_state = (init_make_active || user_scroll_active);\n    if (init_reload_from_user_buf)\n    {\n        int new_len = (int)strlen(buf);\n        IM_ASSERT(new_len + 1 <= buf_size && \"Is your input buffer properly zero-terminated?\");\n        state->WantReloadUserBuf = false;\n        InputTextReconcileUndoState(state, state->TextA.Data, state->TextLen, buf, new_len);\n        state->TextA.resize(buf_size + 1); // we use +1 to make sure that .Data is always pointing to at least an empty string.\n        state->TextLen = new_len;\n        memcpy(state->TextA.Data, buf, state->TextLen + 1);\n        state->Stb->select_start = state->ReloadSelectionStart;\n        state->Stb->cursor = state->Stb->select_end = state->ReloadSelectionEnd;\n        state->CursorClamp();\n    }\n    else if ((init_state && g.ActiveId != id) || init_changed_specs)\n    {\n        // Access state even if we don't own it yet.\n        state = &g.InputTextState;\n        state->CursorAnimReset();\n\n        // Backup state of deactivating item so they'll have a chance to do a write to output buffer on the same frame they report IsItemDeactivatedAfterEdit (#4714)\n        InputTextDeactivateHook(state->ID);\n\n        // Take a copy of the initial buffer value.\n        // From the moment we focused we are normally ignoring the content of 'buf' (unless we are in read-only mode)\n        const int buf_len = (int)strlen(buf);\n        IM_ASSERT(buf_len + 1 <= buf_size && \"Is your input buffer properly zero-terminated?\");\n        state->TextToRevertTo.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.\n        memcpy(state->TextToRevertTo.Data, buf, buf_len + 1);\n\n        // Preserve cursor position and undo/redo stack if we come back to same widget\n        // FIXME: Since we reworked this on 2022/06, may want to differentiate recycle_cursor vs recycle_undostate?\n        bool recycle_state = (state->ID == id && !init_changed_specs);\n        if (recycle_state && (state->TextLen != buf_len || (state->TextA.Data == NULL || strncmp(state->TextA.Data, buf, buf_len) != 0)))\n            recycle_state = false;\n\n        // Start edition\n        state->ID = id;\n        state->TextLen = buf_len;\n        if (!is_readonly)\n        {\n            state->TextA.resize(buf_size + 1); // we use +1 to make sure that .Data is always pointing to at least an empty string.\n            memcpy(state->TextA.Data, buf, state->TextLen + 1);\n        }\n\n        // Find initial scroll position for right alignment\n        state->Scroll = ImVec2(0.0f, 0.0f);\n        if (flags & ImGuiInputTextFlags_ElideLeft)\n            state->Scroll.x += ImMax(0.0f, CalcTextSize(buf).x - frame_size.x + style.FramePadding.x * 2.0f);\n\n        // Recycle existing cursor/selection/undo stack but clamp position\n        // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.\n        if (recycle_state)\n            state->CursorClamp();\n        else\n            stb_textedit_initialize_state(state->Stb, !is_multiline);\n\n        if (!is_multiline)\n        {\n            if (flags & ImGuiInputTextFlags_AutoSelectAll)\n                select_all = true;\n            if (input_requested_by_nav && (!recycle_state || !(g.NavActivateFlags & ImGuiActivateFlags_TryToPreserveState)))\n                select_all = true;\n            if (user_clicked && io.KeyCtrl)\n                select_all = true;\n        }\n\n        if (flags & ImGuiInputTextFlags_AlwaysOverwrite)\n            state->Stb->insert_mode = 1; // stb field name is indeed incorrect (see #2863)\n    }\n\n    const bool is_osx = io.ConfigMacOSXBehaviors;\n    if (g.ActiveId != id && init_make_active)\n    {\n        IM_ASSERT(state && state->ID == id);\n        SetActiveID(id, window);\n        SetFocusID(id, window);\n        FocusWindow(window);\n    }\n    if (g.ActiveId == id)\n    {\n        // Declare some inputs, the other are registered and polled via Shortcut() routing system.\n        // FIXME: The reason we don't use Shortcut() is we would need a routing flag to specify multiple mods, or to all mods combinaison into individual shortcuts.\n        const ImGuiKey always_owned_keys[] = { ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_Enter, ImGuiKey_KeypadEnter, ImGuiKey_Delete, ImGuiKey_Backspace, ImGuiKey_Home, ImGuiKey_End };\n        for (ImGuiKey key : always_owned_keys)\n            SetKeyOwner(key, id);\n        if (user_clicked)\n            SetKeyOwner(ImGuiKey_MouseLeft, id);\n        g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);\n        if (is_multiline || (flags & ImGuiInputTextFlags_CallbackHistory))\n        {\n            g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);\n            SetKeyOwner(ImGuiKey_UpArrow, id);\n            SetKeyOwner(ImGuiKey_DownArrow, id);\n        }\n        if (is_multiline)\n        {\n            SetKeyOwner(ImGuiKey_PageUp, id);\n            SetKeyOwner(ImGuiKey_PageDown, id);\n        }\n        // FIXME: May be a problem to always steal Alt on OSX, would ideally still allow an uninterrupted Alt down-up to toggle menu\n        if (is_osx)\n            SetKeyOwner(ImGuiMod_Alt, id);\n\n        // Expose scroll in a manner that is agnostic to us using a child window\n        if (is_multiline && state != NULL)\n            state->Scroll.y = draw_window->Scroll.y;\n\n        // Read-only mode always ever read from source buffer. Refresh TextLen when active.\n        if (is_readonly && state != NULL)\n            state->TextLen = (int)strlen(buf);\n        //if (is_readonly && state != NULL)\n        //    state->TextA.clear(); // Uncomment to facilitate debugging, but we otherwise prefer to keep/amortize th allocation.\n    }\n    if (state != NULL)\n        state->TextSrc = is_readonly ? buf : state->TextA.Data;\n\n    // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)\n    if (g.ActiveId == id && state == NULL)\n        ClearActiveID();\n\n    // Release focus when we click outside\n    if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560\n        clear_active_id = true;\n\n    // Lock the decision of whether we are going to take the path displaying the cursor or selection\n    bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);\n    bool render_selection = state && (state->HasSelection() || select_all) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);\n    bool value_changed = false;\n    bool validated = false;\n\n    // Select the buffer to render.\n    const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state;\n    const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);\n\n    // Password pushes a temporary font with only a fallback glyph\n    if (is_password && !is_displaying_hint)\n    {\n        const ImFontGlyph* glyph = g.Font->FindGlyph('*');\n        ImFont* password_font = &g.InputTextPasswordFont;\n        password_font->FontSize = g.Font->FontSize;\n        password_font->Scale = g.Font->Scale;\n        password_font->Ascent = g.Font->Ascent;\n        password_font->Descent = g.Font->Descent;\n        password_font->ContainerAtlas = g.Font->ContainerAtlas;\n        password_font->FallbackGlyph = glyph;\n        password_font->FallbackAdvanceX = glyph->AdvanceX;\n        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());\n        PushFont(password_font);\n    }\n\n    // Process mouse inputs and character inputs\n    if (g.ActiveId == id)\n    {\n        IM_ASSERT(state != NULL);\n        state->Edited = false;\n        state->BufCapacity = buf_size;\n        state->Flags = flags;\n\n        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.\n        // Down the line we should have a cleaner library-wide concept of Selected vs Active.\n        g.ActiveIdAllowOverlap = !io.MouseDown[0];\n\n        // Edit in progress\n        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->Scroll.x;\n        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y) : (g.FontSize * 0.5f));\n\n        if (select_all)\n        {\n            state->SelectAll();\n            state->SelectedAllMouseLock = true;\n        }\n        else if (hovered && io.MouseClickedCount[0] >= 2 && !io.KeyShift)\n        {\n            stb_textedit_click(state, state->Stb, mouse_x, mouse_y);\n            const int multiclick_count = (io.MouseClickedCount[0] - 2);\n            if ((multiclick_count % 2) == 0)\n            {\n                // Double-click: Select word\n                // We always use the \"Mac\" word advance for double-click select vs CTRL+Right which use the platform dependent variant:\n                // FIXME: There are likely many ways to improve this behavior, but there's no \"right\" behavior (depends on use-case, software, OS)\n                const bool is_bol = (state->Stb->cursor == 0) || ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb->cursor - 1) == '\\n';\n                if (STB_TEXT_HAS_SELECTION(state->Stb) || !is_bol)\n                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);\n                //state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);\n                if (!STB_TEXT_HAS_SELECTION(state->Stb))\n                    ImStb::stb_textedit_prep_selection_at_cursor(state->Stb);\n                state->Stb->cursor = ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state->Stb->cursor);\n                state->Stb->select_end = state->Stb->cursor;\n                ImStb::stb_textedit_clamp(state, state->Stb);\n            }\n            else\n            {\n                // Triple-click: Select line\n                const bool is_eol = ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb->cursor) == '\\n';\n                state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART);\n                state->OnKeyPressed(STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT);\n                state->OnKeyPressed(STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT);\n                if (!is_eol && is_multiline)\n                {\n                    ImSwap(state->Stb->select_start, state->Stb->select_end);\n                    state->Stb->cursor = state->Stb->select_end;\n                }\n                state->CursorFollow = false;\n            }\n            state->CursorAnimReset();\n        }\n        else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)\n        {\n            if (hovered)\n            {\n                if (io.KeyShift)\n                    stb_textedit_drag(state, state->Stb, mouse_x, mouse_y);\n                else\n                    stb_textedit_click(state, state->Stb, mouse_x, mouse_y);\n                state->CursorAnimReset();\n            }\n        }\n        else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))\n        {\n            stb_textedit_drag(state, state->Stb, mouse_x, mouse_y);\n            state->CursorAnimReset();\n            state->CursorFollow = true;\n        }\n        if (state->SelectedAllMouseLock && !io.MouseDown[0])\n            state->SelectedAllMouseLock = false;\n\n        // We expect backends to emit a Tab key but some also emit a Tab character which we ignore (#2467, #1336)\n        // (For Tab and Enter: Win32/SFML/Allegro are sending both keys and chars, GLFW and SDL are only sending keys. For Space they all send all threes)\n        if ((flags & ImGuiInputTextFlags_AllowTabInput) && !is_readonly)\n        {\n            if (Shortcut(ImGuiKey_Tab, ImGuiInputFlags_Repeat, id))\n            {\n                unsigned int c = '\\t'; // Insert TAB\n                if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))\n                    state->OnCharPressed(c);\n            }\n            // FIXME: Implement Shift+Tab\n            /*\n            if (Shortcut(ImGuiKey_Tab | ImGuiMod_Shift, ImGuiInputFlags_Repeat, id))\n            {\n            }\n            */\n        }\n\n        // Process regular text input (before we check for Return because using some IME will effectively send a Return?)\n        // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.\n        const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeyCtrl);\n        if (io.InputQueueCharacters.Size > 0)\n        {\n            if (!ignore_char_inputs && !is_readonly && !input_requested_by_nav)\n                for (int n = 0; n < io.InputQueueCharacters.Size; n++)\n                {\n                    // Insert character if they pass filtering\n                    unsigned int c = (unsigned int)io.InputQueueCharacters[n];\n                    if (c == '\\t') // Skip Tab, see above.\n                        continue;\n                    if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))\n                        state->OnCharPressed(c);\n                }\n\n            // Consume characters\n            io.InputQueueCharacters.resize(0);\n        }\n    }\n\n    // Process other shortcuts/key-presses\n    bool revert_edit = false;\n    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)\n    {\n        IM_ASSERT(state != NULL);\n\n        const int row_count_per_page = ImMax((int)((inner_size.y - style.FramePadding.y) / g.FontSize), 1);\n        state->Stb->row_count_per_page = row_count_per_page;\n\n        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);\n        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl\n        const bool is_startend_key_down = is_osx && io.KeyCtrl && !io.KeySuper && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End\n\n        // Using Shortcut() with ImGuiInputFlags_RouteFocused (default policy) to allow routing operations for other code (e.g. calling window trying to use CTRL+A and CTRL+B: formet would be handled by InputText)\n        // Otherwise we could simply assume that we own the keys as we are active.\n        const ImGuiInputFlags f_repeat = ImGuiInputFlags_Repeat;\n        const bool is_cut   = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_X, f_repeat, id) || Shortcut(ImGuiMod_Shift | ImGuiKey_Delete, f_repeat, id)) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());\n        const bool is_copy  = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_C, 0,        id) || Shortcut(ImGuiMod_Ctrl  | ImGuiKey_Insert, 0,        id)) && !is_password && (!is_multiline || state->HasSelection());\n        const bool is_paste = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_V, f_repeat, id) || Shortcut(ImGuiMod_Shift | ImGuiKey_Insert, f_repeat, id)) && !is_readonly;\n        const bool is_undo  = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_Z, f_repeat, id)) && !is_readonly && is_undoable;\n        const bool is_redo =  (Shortcut(ImGuiMod_Ctrl | ImGuiKey_Y, f_repeat, id) || (is_osx && Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Z, f_repeat, id))) && !is_readonly && is_undoable;\n        const bool is_select_all = Shortcut(ImGuiMod_Ctrl | ImGuiKey_A, 0, id);\n\n        // We allow validate/cancel with Nav source (gamepad) to makes it easier to undo an accidental NavInput press with no keyboard wired, but otherwise it isn't very useful.\n        const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;\n        const bool is_enter_pressed = IsKeyPressed(ImGuiKey_Enter, true) || IsKeyPressed(ImGuiKey_KeypadEnter, true);\n        const bool is_gamepad_validate = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate, false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false));\n        const bool is_cancel = Shortcut(ImGuiKey_Escape, f_repeat, id) || (nav_gamepad_active && Shortcut(ImGuiKey_NavGamepadCancel, f_repeat, id));\n\n        // FIXME: Should use more Shortcut() and reduce IsKeyPressed()+SetKeyOwner(), but requires modifiers combination to be taken account of.\n        // FIXME-OSX: Missing support for Alt(option)+Right/Left = go to end of line, or next line if already in end of line.\n        if (IsKeyPressed(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }\n        else if (IsKeyPressed(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }\n        else if (IsKeyPressed(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }\n        else if (IsKeyPressed(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }\n        else if (IsKeyPressed(ImGuiKey_PageUp) && is_multiline)      { state->OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask); scroll_y -= row_count_per_page * g.FontSize; }\n        else if (IsKeyPressed(ImGuiKey_PageDown) && is_multiline)    { state->OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask); scroll_y += row_count_per_page * g.FontSize; }\n        else if (IsKeyPressed(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }\n        else if (IsKeyPressed(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }\n        else if (IsKeyPressed(ImGuiKey_Delete) && !is_readonly && !is_cut)\n        {\n            if (!state->HasSelection())\n            {\n                // OSX doesn't seem to have Super+Delete to delete until end-of-line, so we don't emulate that (as opposed to Super+Backspace)\n                if (is_wordmove_key_down)\n                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);\n            }\n            state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask);\n        }\n        else if (IsKeyPressed(ImGuiKey_Backspace) && !is_readonly)\n        {\n            if (!state->HasSelection())\n            {\n                if (is_wordmove_key_down)\n                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);\n                else if (is_osx && io.KeyCtrl && !io.KeyAlt && !io.KeySuper)\n                    state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);\n            }\n            state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);\n        }\n        else if (is_enter_pressed || is_gamepad_validate)\n        {\n            // Determine if we turn Enter into a \\n character\n            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;\n            if (!is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))\n            {\n                validated = true;\n                if (io.ConfigInputTextEnterKeepActive && !is_multiline)\n                    state->SelectAll(); // No need to scroll\n                else\n                    clear_active_id = true;\n            }\n            else if (!is_readonly)\n            {\n                unsigned int c = '\\n'; // Insert new line\n                if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))\n                    state->OnCharPressed(c);\n            }\n        }\n        else if (is_cancel)\n        {\n            if (flags & ImGuiInputTextFlags_EscapeClearsAll)\n            {\n                if (buf[0] != 0)\n                {\n                    revert_edit = true;\n                }\n                else\n                {\n                    render_cursor = render_selection = false;\n                    clear_active_id = true;\n                }\n            }\n            else\n            {\n                clear_active_id = revert_edit = true;\n                render_cursor = render_selection = false;\n            }\n        }\n        else if (is_undo || is_redo)\n        {\n            state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);\n            state->ClearSelection();\n        }\n        else if (is_select_all)\n        {\n            state->SelectAll();\n            state->CursorFollow = true;\n        }\n        else if (is_cut || is_copy)\n        {\n            // Cut, Copy\n            if (g.PlatformIO.Platform_SetClipboardTextFn != NULL)\n            {\n                // SetClipboardText() only takes null terminated strings + state->TextSrc may point to read-only user buffer, so we need to make a copy.\n                const int ib = state->HasSelection() ? ImMin(state->Stb->select_start, state->Stb->select_end) : 0;\n                const int ie = state->HasSelection() ? ImMax(state->Stb->select_start, state->Stb->select_end) : state->TextLen;\n                g.TempBuffer.reserve(ie - ib + 1);\n                memcpy(g.TempBuffer.Data, state->TextSrc + ib, ie - ib);\n                g.TempBuffer.Data[ie - ib] = 0;\n                SetClipboardText(g.TempBuffer.Data);\n            }\n            if (is_cut)\n            {\n                if (!state->HasSelection())\n                    state->SelectAll();\n                state->CursorFollow = true;\n                stb_textedit_cut(state, state->Stb);\n            }\n        }\n        else if (is_paste)\n        {\n            if (const char* clipboard = GetClipboardText())\n            {\n                // Filter pasted buffer\n                const int clipboard_len = (int)strlen(clipboard);\n                ImVector<char> clipboard_filtered;\n                clipboard_filtered.reserve(clipboard_len + 1);\n                for (const char* s = clipboard; *s != 0; )\n                {\n                    unsigned int c;\n                    int in_len = ImTextCharFromUtf8(&c, s, NULL);\n                    s += in_len;\n                    if (!InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data, true))\n                        continue;\n                    char c_utf8[5];\n                    ImTextCharToUtf8(c_utf8, c);\n                    int out_len = (int)strlen(c_utf8);\n                    clipboard_filtered.resize(clipboard_filtered.Size + out_len);\n                    memcpy(clipboard_filtered.Data + clipboard_filtered.Size - out_len, c_utf8, out_len);\n                }\n                if (clipboard_filtered.Size > 0) // If everything was filtered, ignore the pasting operation\n                {\n                    clipboard_filtered.push_back(0);\n                    stb_textedit_paste(state, state->Stb, clipboard_filtered.Data, clipboard_filtered.Size - 1);\n                    state->CursorFollow = true;\n                }\n            }\n        }\n\n        // Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.\n        render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);\n    }\n\n    // Process callbacks and apply result back to user's buffer.\n    const char* apply_new_text = NULL;\n    int apply_new_text_length = 0;\n    if (g.ActiveId == id)\n    {\n        IM_ASSERT(state != NULL);\n        if (revert_edit && !is_readonly)\n        {\n            if (flags & ImGuiInputTextFlags_EscapeClearsAll)\n            {\n                // Clear input\n                IM_ASSERT(buf[0] != 0);\n                apply_new_text = \"\";\n                apply_new_text_length = 0;\n                value_changed = true;\n                IMSTB_TEXTEDIT_CHARTYPE empty_string;\n                stb_textedit_replace(state, state->Stb, &empty_string, 0);\n            }\n            else if (strcmp(buf, state->TextToRevertTo.Data) != 0)\n            {\n                apply_new_text = state->TextToRevertTo.Data;\n                apply_new_text_length = state->TextToRevertTo.Size - 1;\n\n                // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.\n                // Push records into the undo stack so we can CTRL+Z the revert operation itself\n                value_changed = true;\n                stb_textedit_replace(state, state->Stb, state->TextToRevertTo.Data, state->TextToRevertTo.Size - 1);\n            }\n        }\n\n        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer\n        // before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.\n        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.\n        // This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage\n        // (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object\n        // unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).\n        const bool apply_edit_back_to_user_buffer = !revert_edit || (validated && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);\n        if (apply_edit_back_to_user_buffer)\n        {\n            // Apply new value immediately - copy modified buffer back\n            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer\n            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.\n            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.\n\n            // User callback\n            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_CallbackAlways)) != 0)\n            {\n                IM_ASSERT(callback != NULL);\n\n                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.\n                ImGuiInputTextFlags event_flag = 0;\n                ImGuiKey event_key = ImGuiKey_None;\n                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && Shortcut(ImGuiKey_Tab, 0, id))\n                {\n                    event_flag = ImGuiInputTextFlags_CallbackCompletion;\n                    event_key = ImGuiKey_Tab;\n                }\n                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_UpArrow))\n                {\n                    event_flag = ImGuiInputTextFlags_CallbackHistory;\n                    event_key = ImGuiKey_UpArrow;\n                }\n                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_DownArrow))\n                {\n                    event_flag = ImGuiInputTextFlags_CallbackHistory;\n                    event_key = ImGuiKey_DownArrow;\n                }\n                else if ((flags & ImGuiInputTextFlags_CallbackEdit) && state->Edited)\n                {\n                    event_flag = ImGuiInputTextFlags_CallbackEdit;\n                }\n                else if (flags & ImGuiInputTextFlags_CallbackAlways)\n                {\n                    event_flag = ImGuiInputTextFlags_CallbackAlways;\n                }\n\n                if (event_flag)\n                {\n                    ImGuiInputTextCallbackData callback_data;\n                    callback_data.Ctx = &g;\n                    callback_data.EventFlag = event_flag;\n                    callback_data.Flags = flags;\n                    callback_data.UserData = callback_user_data;\n\n                    // FIXME-OPT: Undo stack reconcile needs a backup of the data until we rework API, see #7925\n                    char* callback_buf = is_readonly ? buf : state->TextA.Data;\n                    IM_ASSERT(callback_buf == state->TextSrc);\n                    state->CallbackTextBackup.resize(state->TextLen + 1);\n                    memcpy(state->CallbackTextBackup.Data, callback_buf, state->TextLen + 1);\n\n                    callback_data.EventKey = event_key;\n                    callback_data.Buf = callback_buf;\n                    callback_data.BufTextLen = state->TextLen;\n                    callback_data.BufSize = state->BufCapacity;\n                    callback_data.BufDirty = false;\n\n                    const int utf8_cursor_pos = callback_data.CursorPos = state->Stb->cursor;\n                    const int utf8_selection_start = callback_data.SelectionStart = state->Stb->select_start;\n                    const int utf8_selection_end = callback_data.SelectionEnd = state->Stb->select_end;\n\n                    // Call user code\n                    callback(&callback_data);\n\n                    // Read back what user may have modified\n                    callback_buf = is_readonly ? buf : state->TextA.Data; // Pointer may have been invalidated by a resize callback\n                    IM_ASSERT(callback_data.Buf == callback_buf);         // Invalid to modify those fields\n                    IM_ASSERT(callback_data.BufSize == state->BufCapacity);\n                    IM_ASSERT(callback_data.Flags == flags);\n                    const bool buf_dirty = callback_data.BufDirty;\n                    if (callback_data.CursorPos != utf8_cursor_pos || buf_dirty)            { state->Stb->cursor = callback_data.CursorPos; state->CursorFollow = true; }\n                    if (callback_data.SelectionStart != utf8_selection_start || buf_dirty)  { state->Stb->select_start = (callback_data.SelectionStart == callback_data.CursorPos) ? state->Stb->cursor : callback_data.SelectionStart; }\n                    if (callback_data.SelectionEnd != utf8_selection_end || buf_dirty)      { state->Stb->select_end = (callback_data.SelectionEnd == callback_data.SelectionStart) ? state->Stb->select_start : callback_data.SelectionEnd; }\n                    if (buf_dirty)\n                    {\n                        // Callback may update buffer and thus set buf_dirty even in read-only mode.\n                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!\n                        InputTextReconcileUndoState(state, state->CallbackTextBackup.Data, state->CallbackTextBackup.Size - 1, callback_data.Buf, callback_data.BufTextLen);\n                        state->TextLen = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()\n                        state->CursorAnimReset();\n                    }\n                }\n            }\n\n            // Will copy result string if modified\n            if (!is_readonly && strcmp(state->TextSrc, buf) != 0)\n            {\n                apply_new_text = state->TextSrc;\n                apply_new_text_length = state->TextLen;\n                value_changed = true;\n            }\n        }\n    }\n\n    // Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)\n    if (g.InputTextDeactivatedState.ID == id)\n    {\n        if (g.ActiveId != id && IsItemDeactivatedAfterEdit() && !is_readonly && strcmp(g.InputTextDeactivatedState.TextA.Data, buf) != 0)\n        {\n            apply_new_text = g.InputTextDeactivatedState.TextA.Data;\n            apply_new_text_length = g.InputTextDeactivatedState.TextA.Size - 1;\n            value_changed = true;\n            //IMGUI_DEBUG_LOG(\"InputText(): apply Deactivated data for 0x%08X: \\\"%.*s\\\".\\n\", id, apply_new_text_length, apply_new_text);\n        }\n        g.InputTextDeactivatedState.ID = 0;\n    }\n\n    // Copy result to user buffer. This can currently only happen when (g.ActiveId == id)\n    if (apply_new_text != NULL)\n    {\n        //// We cannot test for 'backup_current_text_length != apply_new_text_length' here because we have no guarantee that the size\n        //// of our owned buffer matches the size of the string object held by the user, and by design we allow InputText() to be used\n        //// without any storage on user's side.\n        IM_ASSERT(apply_new_text_length >= 0);\n        if (is_resizable)\n        {\n            ImGuiInputTextCallbackData callback_data;\n            callback_data.Ctx = &g;\n            callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;\n            callback_data.Flags = flags;\n            callback_data.Buf = buf;\n            callback_data.BufTextLen = apply_new_text_length;\n            callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);\n            callback_data.UserData = callback_user_data;\n            callback(&callback_data);\n            buf = callback_data.Buf;\n            buf_size = callback_data.BufSize;\n            apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);\n            IM_ASSERT(apply_new_text_length <= buf_size);\n        }\n        //IMGUI_DEBUG_PRINT(\"InputText(\\\"%s\\\"): apply_new_text length %d\\n\", label, apply_new_text_length);\n\n        // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.\n        ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));\n    }\n\n    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)\n    // Otherwise request text input ahead for next frame.\n    if (g.ActiveId == id && clear_active_id)\n        ClearActiveID();\n    else if (g.ActiveId == id)\n        g.WantTextInputNextFrame = 1;\n\n    // Render frame\n    if (!is_multiline)\n    {\n        RenderNavCursor(frame_bb, id);\n        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\n    }\n\n    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size\n    ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;\n    ImVec2 text_size(0.0f, 0.0f);\n\n    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line\n    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.\n    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.\n    const int buf_display_max_length = 2 * 1024 * 1024;\n    const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595\n    const char* buf_display_end = NULL; // We have specialized paths below for setting the length\n    if (is_displaying_hint)\n    {\n        buf_display = hint;\n        buf_display_end = hint + strlen(hint);\n    }\n\n    // Render text. We currently only render selection when the widget is active or while scrolling.\n    // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.\n    if (render_cursor || render_selection)\n    {\n        IM_ASSERT(state != NULL);\n        if (!is_displaying_hint)\n            buf_display_end = buf_display + state->TextLen;\n\n        // Render text (with cursor and selection)\n        // This is going to be messy. We need to:\n        // - Display the text (this alone can be more easily clipped)\n        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)\n        // - Measure text height (for scrollbar)\n        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)\n        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.\n        const char* text_begin = buf_display;\n        const char* text_end = text_begin + state->TextLen;\n        ImVec2 cursor_offset, select_start_offset;\n\n        {\n            // Find lines numbers straddling cursor and selection min position\n            int cursor_line_no = render_cursor ? -1 : -1000;\n            int selmin_line_no = render_selection ? -1 : -1000;\n            const char* cursor_ptr = render_cursor ? text_begin + state->Stb->cursor : NULL;\n            const char* selmin_ptr = render_selection ? text_begin + ImMin(state->Stb->select_start, state->Stb->select_end) : NULL;\n\n            // Count lines and find line number for cursor and selection ends\n            int line_count = 1;\n            if (is_multiline)\n            {\n                for (const char* s = text_begin; (s = (const char*)memchr(s, '\\n', (size_t)(text_end - s))) != NULL; s++)\n                {\n                    if (cursor_line_no == -1 && s >= cursor_ptr) { cursor_line_no = line_count; }\n                    if (selmin_line_no == -1 && s >= selmin_ptr) { selmin_line_no = line_count; }\n                    line_count++;\n                }\n            }\n            if (cursor_line_no == -1)\n                cursor_line_no = line_count;\n            if (selmin_line_no == -1)\n                selmin_line_no = line_count;\n\n            // Calculate 2d position by finding the beginning of the line and measuring distance\n            cursor_offset.x = InputTextCalcTextSize(&g, ImStrbol(cursor_ptr, text_begin), cursor_ptr).x;\n            cursor_offset.y = cursor_line_no * g.FontSize;\n            if (selmin_line_no >= 0)\n            {\n                select_start_offset.x = InputTextCalcTextSize(&g, ImStrbol(selmin_ptr, text_begin), selmin_ptr).x;\n                select_start_offset.y = selmin_line_no * g.FontSize;\n            }\n\n            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)\n            if (is_multiline)\n                text_size = ImVec2(inner_size.x, line_count * g.FontSize);\n        }\n\n        // Scroll\n        if (render_cursor && state->CursorFollow)\n        {\n            // Horizontal scroll in chunks of quarter width\n            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))\n            {\n                const float scroll_increment_x = inner_size.x * 0.25f;\n                const float visible_width = inner_size.x - style.FramePadding.x;\n                if (cursor_offset.x < state->Scroll.x)\n                    state->Scroll.x = IM_TRUNC(ImMax(0.0f, cursor_offset.x - scroll_increment_x));\n                else if (cursor_offset.x - visible_width >= state->Scroll.x)\n                    state->Scroll.x = IM_TRUNC(cursor_offset.x - visible_width + scroll_increment_x);\n            }\n            else\n            {\n                state->Scroll.y = 0.0f;\n            }\n\n            // Vertical scroll\n            if (is_multiline)\n            {\n                // Test if cursor is vertically visible\n                if (cursor_offset.y - g.FontSize < scroll_y)\n                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);\n                else if (cursor_offset.y - (inner_size.y - style.FramePadding.y * 2.0f) >= scroll_y)\n                    scroll_y = cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0f;\n                const float scroll_max_y = ImMax((text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);\n                scroll_y = ImClamp(scroll_y, 0.0f, scroll_max_y);\n                draw_pos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag\n                draw_window->Scroll.y = scroll_y;\n            }\n\n            state->CursorFollow = false;\n        }\n\n        // Draw selection\n        const ImVec2 draw_scroll = ImVec2(state->Scroll.x, 0.0f);\n        if (render_selection)\n        {\n            const char* text_selected_begin = text_begin + ImMin(state->Stb->select_start, state->Stb->select_end);\n            const char* text_selected_end = text_begin + ImMax(state->Stb->select_start, state->Stb->select_end);\n\n            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.\n            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.\n            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;\n            ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;\n            for (const char* p = text_selected_begin; p < text_selected_end; )\n            {\n                if (rect_pos.y > clip_rect.w + g.FontSize)\n                    break;\n                if (rect_pos.y < clip_rect.y)\n                {\n                    p = (const char*)memchr((void*)p, '\\n', text_selected_end - p);\n                    p = p ? p + 1 : text_selected_end;\n                }\n                else\n                {\n                    ImVec2 rect_size = InputTextCalcTextSize(&g, p, text_selected_end, &p, NULL, true);\n                    if (rect_size.x <= 0.0f) rect_size.x = IM_TRUNC(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines\n                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));\n                    rect.ClipWith(clip_rect);\n                    if (rect.Overlaps(clip_rect))\n                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);\n                    rect_pos.x = draw_pos.x - draw_scroll.x;\n                }\n                rect_pos.y += g.FontSize;\n            }\n        }\n\n        // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.\n        // FIXME-OPT: Multiline could submit a smaller amount of contents to AddText() since we already iterated through it.\n        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)\n        {\n            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);\n            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);\n        }\n\n        // Draw blinking cursor\n        if (render_cursor)\n        {\n            state->CursorAnim += io.DeltaTime;\n            bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;\n            ImVec2 cursor_screen_pos = ImTrunc(draw_pos + cursor_offset - draw_scroll);\n            ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);\n            if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))\n                draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));\n\n            // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)\n            if (!is_readonly)\n            {\n                g.PlatformImeData.WantVisible = true;\n                g.PlatformImeData.InputPos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);\n                g.PlatformImeData.InputLineHeight = g.FontSize;\n            }\n        }\n    }\n    else\n    {\n        // Render text only (no selection, no cursor)\n        if (is_multiline)\n            text_size = ImVec2(inner_size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width\n        else if (!is_displaying_hint && g.ActiveId == id)\n            buf_display_end = buf_display + state->TextLen;\n        else if (!is_displaying_hint)\n            buf_display_end = buf_display + strlen(buf_display);\n\n        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)\n        {\n            // Find render position for right alignment\n            if (flags & ImGuiInputTextFlags_ElideLeft)\n                draw_pos.x = ImMin(draw_pos.x, frame_bb.Max.x - CalcTextSize(buf_display, NULL).x - style.FramePadding.x);\n\n            const ImVec2 draw_scroll = /*state ? ImVec2(state->Scroll.x, 0.0f) :*/ ImVec2(0.0f, 0.0f); // Preserve scroll when inactive?\n            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);\n            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);\n        }\n    }\n\n    if (is_password && !is_displaying_hint)\n        PopFont();\n\n    if (is_multiline)\n    {\n        // For focus requests to work on our multiline we need to ensure our child ItemAdd() call specifies the ImGuiItemFlags_Inputable (see #4761, #7870)...\n        Dummy(ImVec2(text_size.x, text_size.y + style.FramePadding.y));\n        g.NextItemData.ItemFlags |= (ImGuiItemFlags)ImGuiItemFlags_Inputable | ImGuiItemFlags_NoTabStop;\n        EndChild();\n        item_data_backup.StatusFlags |= (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredWindow);\n\n        // ...and then we need to undo the group overriding last item data, which gets a bit messy as EndGroup() tries to forward scrollbar being active...\n        // FIXME: This quite messy/tricky, should attempt to get rid of the child window.\n        EndGroup();\n        if (g.LastItemData.ID == 0 || g.LastItemData.ID != GetWindowScrollbarID(draw_window, ImGuiAxis_Y))\n        {\n            g.LastItemData.ID = id;\n            g.LastItemData.ItemFlags = item_data_backup.ItemFlags;\n            g.LastItemData.StatusFlags = item_data_backup.StatusFlags;\n        }\n    }\n    if (state)\n        state->TextSrc = NULL;\n\n    // Log as text\n    if (g.LogEnabled && (!is_password || is_displaying_hint))\n    {\n        LogSetNextTextDecoration(\"{\", \"}\");\n        LogRenderedText(&draw_pos, buf_display, buf_display_end);\n    }\n\n    if (label_size.x > 0)\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\n\n    if (value_changed)\n        MarkItemEdited(id);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);\n    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)\n        return validated;\n    else\n        return value_changed;\n}\n\nvoid ImGui::DebugNodeInputTextState(ImGuiInputTextState* state)\n{\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    ImGuiContext& g = *GImGui;\n    ImStb::STB_TexteditState* stb_state = state->Stb;\n    ImStb::StbUndoState* undo_state = &stb_state->undostate;\n    Text(\"ID: 0x%08X, ActiveID: 0x%08X\", state->ID, g.ActiveId);\n    DebugLocateItemOnHover(state->ID);\n    Text(\"CurLenA: %d, Cursor: %d, Selection: %d..%d\", state->TextLen, stb_state->cursor, stb_state->select_start, stb_state->select_end);\n    Text(\"BufCapacityA: %d\", state->BufCapacity);\n    Text(\"(Internal Buffer: TextA Size: %d, Capacity: %d)\", state->TextA.Size, state->TextA.Capacity);\n    Text(\"has_preferred_x: %d (%.2f)\", stb_state->has_preferred_x, stb_state->preferred_x);\n    Text(\"undo_point: %d, redo_point: %d, undo_char_point: %d, redo_char_point: %d\", undo_state->undo_point, undo_state->redo_point, undo_state->undo_char_point, undo_state->redo_char_point);\n    if (BeginChild(\"undopoints\", ImVec2(0.0f, GetTextLineHeight() * 10), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY)) // Visualize undo state\n    {\n        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));\n        for (int n = 0; n < IMSTB_TEXTEDIT_UNDOSTATECOUNT; n++)\n        {\n            ImStb::StbUndoRecord* undo_rec = &undo_state->undo_rec[n];\n            const char undo_rec_type = (n < undo_state->undo_point) ? 'u' : (n >= undo_state->redo_point) ? 'r' : ' ';\n            if (undo_rec_type == ' ')\n                BeginDisabled();\n            const int buf_preview_len = (undo_rec_type != ' ' && undo_rec->char_storage != -1) ? undo_rec->insert_length : 0;\n            const char* buf_preview_str = undo_state->undo_char + undo_rec->char_storage;\n            Text(\"%c [%02d] where %03d, insert %03d, delete %03d, char_storage %03d \\\"%.*s\\\"\",\n                undo_rec_type, n, undo_rec->where, undo_rec->insert_length, undo_rec->delete_length, undo_rec->char_storage, buf_preview_len, buf_preview_str);\n            if (undo_rec_type == ' ')\n                EndDisabled();\n        }\n        PopStyleVar();\n    }\n    EndChild();\n#else\n    IM_UNUSED(state);\n#endif\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n//-------------------------------------------------------------------------\n// - ColorEdit3()\n// - ColorEdit4()\n// - ColorPicker3()\n// - RenderColorRectWithAlphaCheckerboard() [Internal]\n// - ColorPicker4()\n// - ColorButton()\n// - SetColorEditOptions()\n// - ColorTooltip() [Internal]\n// - ColorEditOptionsPopup() [Internal]\n// - ColorPickerOptionsPopup() [Internal]\n//-------------------------------------------------------------------------\n\nbool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)\n{\n    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);\n}\n\nstatic void ColorEditRestoreH(const float* col, float* H)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.ColorEditCurrentID != 0);\n    if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))\n        return;\n    *H = g.ColorEditSavedHue;\n}\n\n// ColorEdit supports RGB and HSV inputs. In case of RGB input resulting color may have undefined hue and/or saturation.\n// Since widget displays both RGB and HSV values we must preserve hue and saturation to prevent these values resetting.\nstatic void ColorEditRestoreHS(const float* col, float* H, float* S, float* V)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(g.ColorEditCurrentID != 0);\n    if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))\n        return;\n\n    // When S == 0, H is undefined.\n    // When H == 1 it wraps around to 0.\n    if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))\n        *H = g.ColorEditSavedHue;\n\n    // When V == 0, S is undefined.\n    if (*V == 0.0f)\n        *S = g.ColorEditSavedSat;\n}\n\n// Edit colors components (each component in 0.0f..1.0f range).\n// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\n// With typical options: Left-click on color square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.\nbool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const float square_sz = GetFrameHeight();\n    const char* label_display_end = FindRenderedTextEnd(label);\n    float w_full = CalcItemWidth();\n    g.NextItemData.ClearFlags();\n\n    BeginGroup();\n    PushID(label);\n    const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);\n    if (set_current_color_edit_id)\n        g.ColorEditCurrentID = window->IDStack.back();\n\n    // If we're not showing any slider there's no point in doing any HSV conversions\n    const ImGuiColorEditFlags flags_untouched = flags;\n    if (flags & ImGuiColorEditFlags_NoInputs)\n        flags = (flags & (~ImGuiColorEditFlags_DisplayMask_)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;\n\n    // Context menu: display and modify options (before defaults are applied)\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\n        ColorEditOptionsPopup(col, flags);\n\n    // Read stored options\n    if (!(flags & ImGuiColorEditFlags_DisplayMask_))\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DisplayMask_);\n    if (!(flags & ImGuiColorEditFlags_DataTypeMask_))\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DataTypeMask_);\n    if (!(flags & ImGuiColorEditFlags_PickerMask_))\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_);\n    if (!(flags & ImGuiColorEditFlags_InputMask_))\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_InputMask_);\n    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_));\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_)); // Check that only 1 is selected\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));   // Check that only 1 is selected\n\n    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;\n    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;\n    const int components = alpha ? 4 : 3;\n    const float w_button = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);\n    const float w_inputs = ImMax(w_full - w_button, 1.0f);\n    w_full = w_inputs + w_button;\n\n    // Convert to the formats we need\n    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };\n    if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))\n        ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);\n    else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV))\n    {\n        // Hue is lost when converting from grayscale rgb (saturation=0). Restore it.\n        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);\n        ColorEditRestoreHS(col, &f[0], &f[1], &f[2]);\n    }\n    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };\n\n    bool value_changed = false;\n    bool value_changed_as_float = false;\n\n    const ImVec2 pos = window->DC.CursorPos;\n    const float inputs_offset_x = (style.ColorButtonPosition == ImGuiDir_Left) ? w_button : 0.0f;\n    window->DC.CursorPos.x = pos.x + inputs_offset_x;\n\n    if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)\n    {\n        // RGB/HSV 0..255 Sliders\n        const float w_items = w_inputs - style.ItemInnerSpacing.x * (components - 1);\n\n        const bool hide_prefix = (IM_TRUNC(w_items / components) <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? \"M:0.000\" : \"M:000\").x);\n        static const char* ids[4] = { \"##X\", \"##Y\", \"##Z\", \"##W\" };\n        static const char* fmt_table_int[3][4] =\n        {\n            {   \"%3d\",   \"%3d\",   \"%3d\",   \"%3d\" }, // Short display\n            { \"R:%3d\", \"G:%3d\", \"B:%3d\", \"A:%3d\" }, // Long display for RGBA\n            { \"H:%3d\", \"S:%3d\", \"V:%3d\", \"A:%3d\" }  // Long display for HSVA\n        };\n        static const char* fmt_table_float[3][4] =\n        {\n            {   \"%0.3f\",   \"%0.3f\",   \"%0.3f\",   \"%0.3f\" }, // Short display\n            { \"R:%0.3f\", \"G:%0.3f\", \"B:%0.3f\", \"A:%0.3f\" }, // Long display for RGBA\n            { \"H:%0.3f\", \"S:%0.3f\", \"V:%0.3f\", \"A:%0.3f\" }  // Long display for HSVA\n        };\n        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;\n\n        float prev_split = 0.0f;\n        for (int n = 0; n < components; n++)\n        {\n            if (n > 0)\n                SameLine(0, style.ItemInnerSpacing.x);\n            float next_split = IM_TRUNC(w_items * (n + 1) / components);\n            SetNextItemWidth(ImMax(next_split - prev_split, 1.0f));\n            prev_split = next_split;\n\n            // FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.\n            if (flags & ImGuiColorEditFlags_Float)\n            {\n                value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);\n                value_changed_as_float |= value_changed;\n            }\n            else\n            {\n                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);\n            }\n            if (!(flags & ImGuiColorEditFlags_NoOptions))\n                OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n        }\n    }\n    else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)\n    {\n        // RGB Hexadecimal Input\n        char buf[64];\n        if (alpha)\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X%02X\", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));\n        else\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X\", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));\n        SetNextItemWidth(w_inputs);\n        if (InputText(\"##Text\", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsUppercase))\n        {\n            value_changed = true;\n            char* p = buf;\n            while (*p == '#' || ImCharIsBlankA(*p))\n                p++;\n            i[0] = i[1] = i[2] = 0;\n            i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g. inputting #FFFFFF omitting alpha)\n            int r;\n            if (alpha)\n                r = sscanf(p, \"%02X%02X%02X%02X\", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)\n            else\n                r = sscanf(p, \"%02X%02X%02X\", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);\n            IM_UNUSED(r); // Fixes C6031: Return value ignored: 'sscanf'.\n        }\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\n            OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n    }\n\n    ImGuiWindow* picker_active_window = NULL;\n    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))\n    {\n        const float button_offset_x = ((flags & ImGuiColorEditFlags_NoInputs) || (style.ColorButtonPosition == ImGuiDir_Left)) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;\n        window->DC.CursorPos = ImVec2(pos.x + button_offset_x, pos.y);\n\n        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);\n        if (ColorButton(\"##ColorButton\", col_v4, flags))\n        {\n            if (!(flags & ImGuiColorEditFlags_NoPicker))\n            {\n                // Store current color and open a picker\n                g.ColorPickerRef = col_v4;\n                OpenPopup(\"picker\");\n                SetNextWindowPos(g.LastItemData.Rect.GetBL() + ImVec2(0.0f, style.ItemSpacing.y));\n            }\n        }\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\n            OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n\n        if (BeginPopup(\"picker\"))\n        {\n            if (g.CurrentWindow->BeginCount == 1)\n            {\n                picker_active_window = g.CurrentWindow;\n                if (label != label_display_end)\n                {\n                    TextEx(label, label_display_end);\n                    Spacing();\n                }\n                ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;\n                ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;\n                SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?\n                value_changed |= ColorPicker4(\"##picker\", col, picker_flags, &g.ColorPickerRef.x);\n            }\n            EndPopup();\n        }\n    }\n\n    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))\n    {\n        // Position not necessarily next to last submitted button (e.g. if style.ColorButtonPosition == ImGuiDir_Left),\n        // but we need to use SameLine() to setup baseline correctly. Might want to refactor SameLine() to simplify this.\n        SameLine(0.0f, style.ItemInnerSpacing.x);\n        window->DC.CursorPos.x = pos.x + ((flags & ImGuiColorEditFlags_NoInputs) ? w_button : w_full + style.ItemInnerSpacing.x);\n        TextEx(label, label_display_end);\n    }\n\n    // Convert back\n    if (value_changed && picker_active_window == NULL)\n    {\n        if (!value_changed_as_float)\n            for (int n = 0; n < 4; n++)\n                f[n] = i[n] / 255.0f;\n        if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))\n        {\n            g.ColorEditSavedHue = f[0];\n            g.ColorEditSavedSat = f[1];\n            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);\n            g.ColorEditSavedID = g.ColorEditCurrentID;\n            g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(f[0], f[1], f[2], 0));\n        }\n        if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))\n            ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);\n\n        col[0] = f[0];\n        col[1] = f[1];\n        col[2] = f[2];\n        if (alpha)\n            col[3] = f[3];\n    }\n\n    if (set_current_color_edit_id)\n        g.ColorEditCurrentID = 0;\n    PopID();\n    EndGroup();\n\n    // Drag and Drop Target\n    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.\n    if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(g.LastItemData.ItemFlags & ImGuiItemFlags_ReadOnly) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())\n    {\n        bool accepted_drag_drop = false;\n        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))\n        {\n            memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512 //-V1086\n            value_changed = accepted_drag_drop = true;\n        }\n        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))\n        {\n            memcpy((float*)col, payload->Data, sizeof(float) * components);\n            value_changed = accepted_drag_drop = true;\n        }\n\n        // Drag-drop payloads are always RGB\n        if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))\n            ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);\n        EndDragDropTarget();\n    }\n\n    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().\n    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)\n        g.LastItemData.ID = g.ActiveId;\n\n    if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId\n        MarkItemEdited(g.LastItemData.ID);\n\n    return value_changed;\n}\n\nbool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)\n{\n    float col4[4] = { col[0], col[1], col[2], 1.0f };\n    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))\n        return false;\n    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];\n    return true;\n}\n\n// Helper for ColorPicker4()\nstatic void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w, float alpha)\n{\n    ImU32 alpha8 = IM_F32_TO_INT8_SAT(alpha);\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32(0,0,0,alpha8));\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32(255,255,255,alpha8));\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));\n}\n\n// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\n// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)\n// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)\n// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also, the color wheel will have overlapping glitches with (style.Alpha < 1.0)\nbool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImDrawList* draw_list = window->DrawList;\n    ImGuiStyle& style = g.Style;\n    ImGuiIO& io = g.IO;\n\n    const float width = CalcItemWidth();\n    const bool is_readonly = ((g.NextItemData.ItemFlags | g.CurrentItemFlags) & ImGuiItemFlags_ReadOnly) != 0;\n    g.NextItemData.ClearFlags();\n\n    PushID(label);\n    const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);\n    if (set_current_color_edit_id)\n        g.ColorEditCurrentID = window->IDStack.back();\n    BeginGroup();\n\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\n        flags |= ImGuiColorEditFlags_NoSmallPreview;\n\n    // Context menu: display and store options.\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\n        ColorPickerOptionsPopup(col, flags);\n\n    // Read stored options\n    if (!(flags & ImGuiColorEditFlags_PickerMask_))\n        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_PickerMask_;\n    if (!(flags & ImGuiColorEditFlags_InputMask_))\n        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_InputMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_InputMask_;\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_)); // Check that only 1 is selected\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));  // Check that only 1 is selected\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);\n\n    // Setup\n    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;\n    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);\n    ImVec2 picker_pos = window->DC.CursorPos;\n    float square_sz = GetFrameHeight();\n    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars\n    float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box\n    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;\n    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;\n    float bars_triangles_half_sz = IM_TRUNC(bars_width * 0.20f);\n\n    float backup_initial_col[4];\n    memcpy(backup_initial_col, col, components * sizeof(float));\n\n    float wheel_thickness = sv_picker_size * 0.08f;\n    float wheel_r_outer = sv_picker_size * 0.50f;\n    float wheel_r_inner = wheel_r_outer - wheel_thickness;\n    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size * 0.5f);\n\n    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.\n    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);\n    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.\n    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.\n    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.\n\n    float H = col[0], S = col[1], V = col[2];\n    float R = col[0], G = col[1], B = col[2];\n    if (flags & ImGuiColorEditFlags_InputRGB)\n    {\n        // Hue is lost when converting from grayscale rgb (saturation=0). Restore it.\n        ColorConvertRGBtoHSV(R, G, B, H, S, V);\n        ColorEditRestoreHS(col, &H, &S, &V);\n    }\n    else if (flags & ImGuiColorEditFlags_InputHSV)\n    {\n        ColorConvertHSVtoRGB(H, S, V, R, G, B);\n    }\n\n    bool value_changed = false, value_changed_h = false, value_changed_sv = false;\n\n    PushItemFlag(ImGuiItemFlags_NoNav, true);\n    if (flags & ImGuiColorEditFlags_PickerHueWheel)\n    {\n        // Hue wheel + SV triangle logic\n        InvisibleButton(\"hsv\", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));\n        if (IsItemActive() && !is_readonly)\n        {\n            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;\n            ImVec2 current_off = g.IO.MousePos - wheel_center;\n            float initial_dist2 = ImLengthSqr(initial_off);\n            if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))\n            {\n                // Interactive with Hue wheel\n                H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5f;\n                if (H < 0.0f)\n                    H += 1.0f;\n                value_changed = value_changed_h = true;\n            }\n            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);\n            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);\n            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))\n            {\n                // Interacting with SV triangle\n                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);\n                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))\n                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);\n                float uu, vv, ww;\n                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);\n                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);\n                S = ImClamp(uu / V, 0.0001f, 1.0f);\n                value_changed = value_changed_sv = true;\n            }\n        }\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\n            OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n    }\n    else if (flags & ImGuiColorEditFlags_PickerHueBar)\n    {\n        // SV rectangle logic\n        InvisibleButton(\"sv\", ImVec2(sv_picker_size, sv_picker_size));\n        if (IsItemActive() && !is_readonly)\n        {\n            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));\n            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));\n            ColorEditRestoreH(col, &H); // Greatly reduces hue jitter and reset to 0 when hue == 255 and color is rapidly modified using SV square.\n            value_changed = value_changed_sv = true;\n        }\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\n            OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n\n        // Hue bar logic\n        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));\n        InvisibleButton(\"hue\", ImVec2(bars_width, sv_picker_size));\n        if (IsItemActive() && !is_readonly)\n        {\n            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));\n            value_changed = value_changed_h = true;\n        }\n    }\n\n    // Alpha bar logic\n    if (alpha_bar)\n    {\n        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));\n        InvisibleButton(\"alpha\", ImVec2(bars_width, sv_picker_size));\n        if (IsItemActive())\n        {\n            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));\n            value_changed = true;\n        }\n    }\n    PopItemFlag(); // ImGuiItemFlags_NoNav\n\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\n    {\n        SameLine(0, style.ItemInnerSpacing.x);\n        BeginGroup();\n    }\n\n    if (!(flags & ImGuiColorEditFlags_NoLabel))\n    {\n        const char* label_display_end = FindRenderedTextEnd(label);\n        if (label != label_display_end)\n        {\n            if ((flags & ImGuiColorEditFlags_NoSidePreview))\n                SameLine(0, style.ItemInnerSpacing.x);\n            TextEx(label, label_display_end);\n        }\n    }\n\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\n    {\n        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);\n        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\n        if ((flags & ImGuiColorEditFlags_NoLabel))\n            Text(\"Current\");\n\n        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;\n        ColorButton(\"##current\", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));\n        if (ref_col != NULL)\n        {\n            Text(\"Original\");\n            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);\n            if (ColorButton(\"##original\", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))\n            {\n                memcpy(col, ref_col, components * sizeof(float));\n                value_changed = true;\n            }\n        }\n        PopItemFlag();\n        EndGroup();\n    }\n\n    // Convert back color to RGB\n    if (value_changed_h || value_changed_sv)\n    {\n        if (flags & ImGuiColorEditFlags_InputRGB)\n        {\n            ColorConvertHSVtoRGB(H, S, V, col[0], col[1], col[2]);\n            g.ColorEditSavedHue = H;\n            g.ColorEditSavedSat = S;\n            g.ColorEditSavedID = g.ColorEditCurrentID;\n            g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0));\n        }\n        else if (flags & ImGuiColorEditFlags_InputHSV)\n        {\n            col[0] = H;\n            col[1] = S;\n            col[2] = V;\n        }\n    }\n\n    // R,G,B and H,S,V slider color editor\n    bool value_changed_fix_hue_wrap = false;\n    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)\n    {\n        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);\n        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;\n        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;\n        if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)\n            if (ColorEdit4(\"##rgb\", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))\n            {\n                // FIXME: Hackily differentiating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.\n                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)\n                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);\n                value_changed = true;\n            }\n        if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)\n            value_changed |= ColorEdit4(\"##hsv\", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);\n        if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)\n            value_changed |= ColorEdit4(\"##hex\", col, sub_flags | ImGuiColorEditFlags_DisplayHex);\n        PopItemWidth();\n    }\n\n    // Try to cancel hue wrap (after ColorEdit4 call), if any\n    if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))\n    {\n        float new_H, new_S, new_V;\n        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);\n        if (new_H <= 0 && H > 0)\n        {\n            if (new_V <= 0 && V != new_V)\n                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);\n            else if (new_S <= 0)\n                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);\n        }\n    }\n\n    if (value_changed)\n    {\n        if (flags & ImGuiColorEditFlags_InputRGB)\n        {\n            R = col[0];\n            G = col[1];\n            B = col[2];\n            ColorConvertRGBtoHSV(R, G, B, H, S, V);\n            ColorEditRestoreHS(col, &H, &S, &V);   // Fix local Hue as display below will use it immediately.\n        }\n        else if (flags & ImGuiColorEditFlags_InputHSV)\n        {\n            H = col[0];\n            S = col[1];\n            V = col[2];\n            ColorConvertHSVtoRGB(H, S, V, R, G, B);\n        }\n    }\n\n    const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);\n    const ImU32 col_black = IM_COL32(0,0,0,style_alpha8);\n    const ImU32 col_white = IM_COL32(255,255,255,style_alpha8);\n    const ImU32 col_midgrey = IM_COL32(128,128,128,style_alpha8);\n    const ImU32 col_hues[6 + 1] = { IM_COL32(255,0,0,style_alpha8), IM_COL32(255,255,0,style_alpha8), IM_COL32(0,255,0,style_alpha8), IM_COL32(0,255,255,style_alpha8), IM_COL32(0,0,255,style_alpha8), IM_COL32(255,0,255,style_alpha8), IM_COL32(255,0,0,style_alpha8) };\n\n    ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);\n    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);\n    ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!\n\n    ImVec2 sv_cursor_pos;\n\n    if (flags & ImGuiColorEditFlags_PickerHueWheel)\n    {\n        // Render Hue Wheel\n        const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).\n        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);\n        for (int n = 0; n < 6; n++)\n        {\n            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;\n            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;\n            const int vert_start_idx = draw_list->VtxBuffer.Size;\n            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);\n            draw_list->PathStroke(col_white, 0, wheel_thickness);\n            const int vert_end_idx = draw_list->VtxBuffer.Size;\n\n            // Paint colors over existing vertices\n            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);\n            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);\n            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n + 1]);\n        }\n\n        // Render Cursor + preview on Hue Wheel\n        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);\n        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);\n        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);\n        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;\n        int hue_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(hue_cursor_rad); // Lock segment count so the +1 one matches others.\n        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);\n        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments);\n        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments);\n\n        // Render SV triangle (rotated according to hue)\n        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);\n        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);\n        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);\n        ImVec2 uv_white = GetFontTexUvWhitePixel();\n        draw_list->PrimReserve(3, 3);\n        draw_list->PrimVtx(tra, uv_white, hue_color32);\n        draw_list->PrimVtx(trb, uv_white, col_black);\n        draw_list->PrimVtx(trc, uv_white, col_white);\n        draw_list->AddTriangle(tra, trb, trc, col_midgrey, 1.5f);\n        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));\n    }\n    else if (flags & ImGuiColorEditFlags_PickerHueBar)\n    {\n        // Render SV Square\n        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);\n        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);\n        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);\n        sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S)     * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much\n        sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);\n\n        // Render Hue Bar\n        for (int i = 0; i < 6; ++i)\n            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);\n        float bar0_line_y = IM_ROUND(picker_pos.y + H * sv_picker_size);\n        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);\n        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);\n    }\n\n    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)\n    float sv_cursor_rad = value_changed_sv ? wheel_thickness * 0.55f : wheel_thickness * 0.40f;\n    int sv_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(sv_cursor_rad); // Lock segment count so the +1 one matches others.\n    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, sv_cursor_segments);\n    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, sv_cursor_segments);\n    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, sv_cursor_segments);\n\n    // Render alpha bar\n    if (alpha_bar)\n    {\n        float alpha = ImSaturate(col[3]);\n        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);\n        RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));\n        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK);\n        float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);\n        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);\n        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);\n    }\n\n    EndGroup();\n\n    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)\n        value_changed = false;\n    if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId\n        MarkItemEdited(g.LastItemData.ID);\n\n    if (set_current_color_edit_id)\n        g.ColorEditCurrentID = 0;\n    PopID();\n\n    return value_changed;\n}\n\n// A little color square. Return true when clicked.\n// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.\n// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.\n// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.\nbool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, const ImVec2& size_arg)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiID id = window->GetID(desc_id);\n    const float default_size = GetFrameHeight();\n    const ImVec2 size(size_arg.x == 0.0f ? default_size : size_arg.x, size_arg.y == 0.0f ? default_size : size_arg.y);\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\n    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);\n    if (!ItemAdd(bb, id))\n        return false;\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\n\n    if (flags & ImGuiColorEditFlags_NoAlpha)\n        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);\n\n    ImVec4 col_rgb = col;\n    if (flags & ImGuiColorEditFlags_InputHSV)\n        ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);\n\n    ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);\n    float grid_step = ImMin(size.x, size.y) / 2.99f;\n    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);\n    ImRect bb_inner = bb;\n    float off = 0.0f;\n    if ((flags & ImGuiColorEditFlags_NoBorder) == 0)\n    {\n        off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.\n        bb_inner.Expand(off);\n    }\n    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)\n    {\n        float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);\n        RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);\n        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_RoundCornersLeft);\n    }\n    else\n    {\n        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha\n        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;\n        if (col_source.w < 1.0f)\n            RenderColorRectWithAlphaCheckerboard(window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);\n        else\n            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding);\n    }\n    RenderNavCursor(bb, id);\n    if ((flags & ImGuiColorEditFlags_NoBorder) == 0)\n    {\n        if (g.Style.FrameBorderSize > 0.0f)\n            RenderFrameBorder(bb.Min, bb.Max, rounding);\n        else\n            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border\n    }\n\n    // Drag and Drop Source\n    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.\n    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())\n    {\n        if (flags & ImGuiColorEditFlags_NoAlpha)\n            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);\n        else\n            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);\n        ColorButton(desc_id, col, flags);\n        SameLine();\n        TextEx(\"Color\");\n        EndDragDropSource();\n    }\n\n    // Tooltip\n    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered && IsItemHovered(ImGuiHoveredFlags_ForTooltip))\n        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));\n\n    return pressed;\n}\n\n// Initialize/override default color options\nvoid ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    if ((flags & ImGuiColorEditFlags_DisplayMask_) == 0)\n        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_DisplayMask_;\n    if ((flags & ImGuiColorEditFlags_DataTypeMask_) == 0)\n        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_DataTypeMask_;\n    if ((flags & ImGuiColorEditFlags_PickerMask_) == 0)\n        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_PickerMask_;\n    if ((flags & ImGuiColorEditFlags_InputMask_) == 0)\n        flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_InputMask_;\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_));    // Check only 1 option is selected\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DataTypeMask_));   // Check only 1 option is selected\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_));     // Check only 1 option is selected\n    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));      // Check only 1 option is selected\n    g.ColorEditOptions = flags;\n}\n\n// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\nvoid ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n\n    if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))\n        return;\n    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;\n    if (text_end > text)\n    {\n        TextEx(text, text_end);\n        Separator();\n    }\n\n    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);\n    ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\n    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);\n    ColorButton(\"##preview\", cf, (flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);\n    SameLine();\n    if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags_InputMask_))\n    {\n        if (flags & ImGuiColorEditFlags_NoAlpha)\n            Text(\"#%02X%02X%02X\\nR: %d, G: %d, B: %d\\n(%.3f, %.3f, %.3f)\", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);\n        else\n            Text(\"#%02X%02X%02X%02X\\nR:%d, G:%d, B:%d, A:%d\\n(%.3f, %.3f, %.3f, %.3f)\", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);\n    }\n    else if (flags & ImGuiColorEditFlags_InputHSV)\n    {\n        if (flags & ImGuiColorEditFlags_NoAlpha)\n            Text(\"H: %.3f, S: %.3f, V: %.3f\", col[0], col[1], col[2]);\n        else\n            Text(\"H: %.3f, S: %.3f, V: %.3f, A: %.3f\", col[0], col[1], col[2], col[3]);\n    }\n    EndTooltip();\n}\n\nvoid ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)\n{\n    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags_DisplayMask_);\n    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags_DataTypeMask_);\n    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup(\"context\"))\n        return;\n\n    ImGuiContext& g = *GImGui;\n    PushItemFlag(ImGuiItemFlags_NoMarkEdited, true);\n    ImGuiColorEditFlags opts = g.ColorEditOptions;\n    if (allow_opt_inputs)\n    {\n        if (RadioButton(\"RGB\", (opts & ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayRGB;\n        if (RadioButton(\"HSV\", (opts & ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHSV;\n        if (RadioButton(\"Hex\", (opts & ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHex;\n    }\n    if (allow_opt_datatype)\n    {\n        if (allow_opt_inputs) Separator();\n        if (RadioButton(\"0..255\",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Uint8;\n        if (RadioButton(\"0.00..1.00\", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Float;\n    }\n\n    if (allow_opt_inputs || allow_opt_datatype)\n        Separator();\n    if (Button(\"Copy as..\", ImVec2(-1, 0)))\n        OpenPopup(\"Copy\");\n    if (BeginPopup(\"Copy\"))\n    {\n        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);\n        char buf[64];\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"(%.3ff, %.3ff, %.3ff, %.3ff)\", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\n        if (Selectable(buf))\n            SetClipboardText(buf);\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"(%d,%d,%d,%d)\", cr, cg, cb, ca);\n        if (Selectable(buf))\n            SetClipboardText(buf);\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X\", cr, cg, cb);\n        if (Selectable(buf))\n            SetClipboardText(buf);\n        if (!(flags & ImGuiColorEditFlags_NoAlpha))\n        {\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X%02X\", cr, cg, cb, ca);\n            if (Selectable(buf))\n                SetClipboardText(buf);\n        }\n        EndPopup();\n    }\n\n    g.ColorEditOptions = opts;\n    PopItemFlag();\n    EndPopup();\n}\n\nvoid ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)\n{\n    bool allow_opt_picker = !(flags & ImGuiColorEditFlags_PickerMask_);\n    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);\n    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup(\"context\"))\n        return;\n\n    ImGuiContext& g = *GImGui;\n    PushItemFlag(ImGuiItemFlags_NoMarkEdited, true);\n    if (allow_opt_picker)\n    {\n        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function\n        PushItemWidth(picker_size.x);\n        for (int picker_type = 0; picker_type < 2; picker_type++)\n        {\n            // Draw small/thumbnail version of each picker type (over an invisible button for selection)\n            if (picker_type > 0) Separator();\n            PushID(picker_type);\n            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_NoAlpha);\n            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;\n            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;\n            ImVec2 backup_pos = GetCursorScreenPos();\n            if (Selectable(\"##selectable\", false, 0, picker_size)) // By default, Selectable() is closing popup\n                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags_PickerMask_) | (picker_flags & ImGuiColorEditFlags_PickerMask_);\n            SetCursorScreenPos(backup_pos);\n            ImVec4 previewing_ref_col;\n            memcpy(&previewing_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));\n            ColorPicker4(\"##previewing_picker\", &previewing_ref_col.x, picker_flags);\n            PopID();\n        }\n        PopItemWidth();\n    }\n    if (allow_opt_alpha_bar)\n    {\n        if (allow_opt_picker) Separator();\n        CheckboxFlags(\"Alpha Bar\", &g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);\n    }\n    PopItemFlag();\n    EndPopup();\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n//-------------------------------------------------------------------------\n// - TreeNode()\n// - TreeNodeV()\n// - TreeNodeEx()\n// - TreeNodeExV()\n// - TreeNodeBehavior() [Internal]\n// - TreePush()\n// - TreePop()\n// - GetTreeNodeToLabelSpacing()\n// - SetNextItemOpen()\n// - CollapsingHeader()\n//-------------------------------------------------------------------------\n\nbool ImGui::TreeNode(const char* str_id, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    bool is_open = TreeNodeExV(str_id, 0, fmt, args);\n    va_end(args);\n    return is_open;\n}\n\nbool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);\n    va_end(args);\n    return is_open;\n}\n\nbool ImGui::TreeNode(const char* label)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n    ImGuiID id = window->GetID(label);\n    return TreeNodeBehavior(id, ImGuiTreeNodeFlags_None, label, NULL);\n}\n\nbool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)\n{\n    return TreeNodeExV(str_id, 0, fmt, args);\n}\n\nbool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)\n{\n    return TreeNodeExV(ptr_id, 0, fmt, args);\n}\n\nbool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n    ImGuiID id = window->GetID(label);\n    return TreeNodeBehavior(id, flags, label, NULL);\n}\n\nbool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    bool is_open = TreeNodeExV(str_id, flags, fmt, args);\n    va_end(args);\n    return is_open;\n}\n\nbool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);\n    va_end(args);\n    return is_open;\n}\n\nbool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiID id = window->GetID(str_id);\n    const char* label, *label_end;\n    ImFormatStringToTempBufferV(&label, &label_end, fmt, args);\n    return TreeNodeBehavior(id, flags, label, label_end);\n}\n\nbool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiID id = window->GetID(ptr_id);\n    const char* label, *label_end;\n    ImFormatStringToTempBufferV(&label, &label_end, fmt, args);\n    return TreeNodeBehavior(id, flags, label, label_end);\n}\n\nbool ImGui::TreeNodeGetOpen(ImGuiID storage_id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiStorage* storage = g.CurrentWindow->DC.StateStorage;\n    return storage->GetInt(storage_id, 0) != 0;\n}\n\nvoid ImGui::TreeNodeSetOpen(ImGuiID storage_id, bool open)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiStorage* storage = g.CurrentWindow->DC.StateStorage;\n    storage->SetInt(storage_id, open ? 1 : 0);\n}\n\nbool ImGui::TreeNodeUpdateNextOpen(ImGuiID storage_id, ImGuiTreeNodeFlags flags)\n{\n    if (flags & ImGuiTreeNodeFlags_Leaf)\n        return true;\n\n    // We only write to the tree storage if the user clicks, or explicitly use the SetNextItemOpen function\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiStorage* storage = window->DC.StateStorage;\n\n    bool is_open;\n    if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasOpen)\n    {\n        if (g.NextItemData.OpenCond & ImGuiCond_Always)\n        {\n            is_open = g.NextItemData.OpenVal;\n            TreeNodeSetOpen(storage_id, is_open);\n        }\n        else\n        {\n            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.\n            const int stored_value = storage->GetInt(storage_id, -1);\n            if (stored_value == -1)\n            {\n                is_open = g.NextItemData.OpenVal;\n                TreeNodeSetOpen(storage_id, is_open);\n            }\n            else\n            {\n                is_open = stored_value != 0;\n            }\n        }\n    }\n    else\n    {\n        is_open = storage->GetInt(storage_id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;\n    }\n\n    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).\n    // NB- If we are above max depth we still allow manually opened nodes to be logged.\n    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)\n        is_open = true;\n\n    return is_open;\n}\n\n// Store ImGuiTreeNodeStackData for just submitted node.\n// Currently only supports 32 level deep and we are fine with (1 << Depth) overflowing into a zero, easy to increase.\nstatic void TreeNodeStoreStackData(ImGuiTreeNodeFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    g.TreeNodeStack.resize(g.TreeNodeStack.Size + 1);\n    ImGuiTreeNodeStackData* tree_node_data = &g.TreeNodeStack.back();\n    tree_node_data->ID = g.LastItemData.ID;\n    tree_node_data->TreeFlags = flags;\n    tree_node_data->ItemFlags = g.LastItemData.ItemFlags;\n    tree_node_data->NavRect = g.LastItemData.NavRect;\n    window->DC.TreeHasStackDataDepthMask |= (1 << window->DC.TreeDepth);\n}\n\n// When using public API, currently 'id == storage_id' is always true, but we separate the values to facilitate advanced user code doing storage queries outside of UI loop.\nbool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;\n    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));\n\n    if (!label_end)\n        label_end = FindRenderedTextEnd(label);\n    const ImVec2 label_size = CalcTextSize(label, label_end, false);\n\n    const float text_offset_x = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2);   // Collapsing arrow width + Spacing\n    const float text_offset_y = ImMax(padding.y, window->DC.CurrLineTextBaseOffset);            // Latch before ItemSize changes it\n    const float text_width = g.FontSize + label_size.x + padding.x * 2;                         // Include collapsing arrow\n\n    // We vertically grow up to current line height up the typical widget height.\n    const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);\n    const bool span_all_columns = (flags & ImGuiTreeNodeFlags_SpanAllColumns) != 0 && (g.CurrentTable != NULL);\n    ImRect frame_bb;\n    frame_bb.Min.x = span_all_columns ? window->ParentWorkRect.Min.x : (flags & ImGuiTreeNodeFlags_SpanFullWidth) ? window->WorkRect.Min.x : window->DC.CursorPos.x;\n    frame_bb.Min.y = window->DC.CursorPos.y;\n    frame_bb.Max.x = span_all_columns ? window->ParentWorkRect.Max.x : (flags & ImGuiTreeNodeFlags_SpanTextWidth) ? window->DC.CursorPos.x + text_width + padding.x : window->WorkRect.Max.x;\n    frame_bb.Max.y = window->DC.CursorPos.y + frame_height;\n    if (display_frame)\n    {\n        const float outer_extend = IM_TRUNC(window->WindowPadding.x * 0.5f); // Framed header expand a little outside of current limits\n        frame_bb.Min.x -= outer_extend;\n        frame_bb.Max.x += outer_extend;\n    }\n\n    ImVec2 text_pos(window->DC.CursorPos.x + text_offset_x, window->DC.CursorPos.y + text_offset_y);\n    ItemSize(ImVec2(text_width, frame_height), padding.y);\n\n    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing\n    ImRect interact_bb = frame_bb;\n    if ((flags & (ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_SpanTextWidth | ImGuiTreeNodeFlags_SpanAllColumns)) == 0)\n        interact_bb.Max.x = frame_bb.Min.x + text_width + (label_size.x > 0.0f ? style.ItemSpacing.x * 2.0f : 0.0f);\n\n    // Compute open and multi-select states before ItemAdd() as it clear NextItem data.\n    ImGuiID storage_id = (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasStorageID) ? g.NextItemData.StorageId : id;\n    bool is_open = TreeNodeUpdateNextOpen(storage_id, flags);\n\n    bool is_visible;\n    if (span_all_columns)\n    {\n        // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..\n        const float backup_clip_rect_min_x = window->ClipRect.Min.x;\n        const float backup_clip_rect_max_x = window->ClipRect.Max.x;\n        window->ClipRect.Min.x = window->ParentWorkRect.Min.x;\n        window->ClipRect.Max.x = window->ParentWorkRect.Max.x;\n        is_visible = ItemAdd(interact_bb, id);\n        window->ClipRect.Min.x = backup_clip_rect_min_x;\n        window->ClipRect.Max.x = backup_clip_rect_max_x;\n    }\n    else\n    {\n        is_visible = ItemAdd(interact_bb, id);\n    }\n    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;\n    g.LastItemData.DisplayRect = frame_bb;\n\n    // If a NavLeft request is happening and ImGuiTreeNodeFlags_NavLeftJumpsBackHere enabled:\n    // Store data for the current depth to allow returning to this node from any child item.\n    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().\n    // It will become tempting to enable ImGuiTreeNodeFlags_NavLeftJumpsBackHere by default or move it to ImGuiStyle.\n    bool store_tree_node_stack_data = false;\n    if (!(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\n    {\n        if ((flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && is_open && !g.NavIdIsAlive)\n            if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())\n                store_tree_node_stack_data = true;\n    }\n\n    const bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;\n    if (!is_visible)\n    {\n        if (store_tree_node_stack_data && is_open)\n            TreeNodeStoreStackData(flags); // Call before TreePushOverrideID()\n        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\n            TreePushOverrideID(id);\n        IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));\n        return is_open;\n    }\n\n    if (span_all_columns)\n    {\n        TablePushBackgroundChannel();\n        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasClipRect;\n        g.LastItemData.ClipRect = window->ClipRect;\n    }\n\n    ImGuiButtonFlags button_flags = ImGuiTreeNodeFlags_None;\n    if ((flags & ImGuiTreeNodeFlags_AllowOverlap) || (g.LastItemData.ItemFlags & ImGuiItemFlags_AllowOverlap))\n        button_flags |= ImGuiButtonFlags_AllowOverlap;\n    if (!is_leaf)\n        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;\n\n    // We allow clicking on the arrow section with keyboard modifiers held, in order to easily\n    // allow browsing a tree while preserving selection with code implementing multi-selection patterns.\n    // When clicking on the rest of the tree node we always disallow keyboard modifiers.\n    const float arrow_hit_x1 = (text_pos.x - text_offset_x) - style.TouchExtraPadding.x;\n    const float arrow_hit_x2 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0f) + style.TouchExtraPadding.x;\n    const bool is_mouse_x_over_arrow = (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2);\n\n    const bool is_multi_select = (g.LastItemData.ItemFlags & ImGuiItemFlags_IsMultiSelect) != 0;\n    if (is_multi_select) // We absolutely need to distinguish open vs select so _OpenOnArrow comes by default\n        flags |= (flags & ImGuiTreeNodeFlags_OpenOnMask_) == 0 ? ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick : ImGuiTreeNodeFlags_OpenOnArrow;\n\n    // Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.\n    // Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.\n    // - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)\n    // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)\n    // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)\n    // - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)\n    // - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)\n    // It is rather standard that arrow click react on Down rather than Up.\n    // We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.\n    if (is_mouse_x_over_arrow)\n        button_flags |= ImGuiButtonFlags_PressedOnClick;\n    else if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)\n        button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;\n    else\n        button_flags |= ImGuiButtonFlags_PressedOnClickRelease;\n\n    bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;\n    const bool was_selected = selected;\n\n    // Multi-selection support (header)\n    if (is_multi_select)\n    {\n        // Handle multi-select + alter button flags for it\n        MultiSelectItemHeader(id, &selected, &button_flags);\n        if (is_mouse_x_over_arrow)\n            button_flags = (button_flags | ImGuiButtonFlags_PressedOnClick) & ~ImGuiButtonFlags_PressedOnClickRelease;\n    }\n    else\n    {\n        if (window != g.HoveredWindow || !is_mouse_x_over_arrow)\n            button_flags |= ImGuiButtonFlags_NoKeyModsAllowed;\n    }\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);\n    bool toggled = false;\n    if (!is_leaf)\n    {\n        if (pressed && g.DragDropHoldJustPressedId != id)\n        {\n            if ((flags & ImGuiTreeNodeFlags_OpenOnMask_) == 0 || (g.NavActivateId == id && !is_multi_select))\n                toggled = true; // Single click\n            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)\n                toggled |= is_mouse_x_over_arrow && !g.NavHighlightItemUnderNav; // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job\n            if ((flags & ImGuiTreeNodeFlags_OpenOnDoubleClick) && g.IO.MouseClickedCount[0] == 2)\n                toggled = true; // Double click\n        }\n        else if (pressed && g.DragDropHoldJustPressedId == id)\n        {\n            IM_ASSERT(button_flags & ImGuiButtonFlags_PressedOnDragDropHold);\n            if (!is_open) // When using Drag and Drop \"hold to open\" we keep the node highlighted after opening, but never close it again.\n                toggled = true;\n            else\n                pressed = false; // Cancel press so it doesn't trigger selection.\n        }\n\n        if (g.NavId == id && g.NavMoveDir == ImGuiDir_Left && is_open)\n        {\n            toggled = true;\n            NavClearPreferredPosForAxis(ImGuiAxis_X);\n            NavMoveRequestCancel();\n        }\n        if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?\n        {\n            toggled = true;\n            NavClearPreferredPosForAxis(ImGuiAxis_X);\n            NavMoveRequestCancel();\n        }\n\n        if (toggled)\n        {\n            is_open = !is_open;\n            window->DC.StateStorage->SetInt(storage_id, is_open);\n            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledOpen;\n        }\n    }\n\n    // Multi-selection support (footer)\n    if (is_multi_select)\n    {\n        bool pressed_copy = pressed && !toggled;\n        MultiSelectItemFooter(id, &selected, &pressed_copy);\n        if (pressed)\n            SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, interact_bb);\n    }\n\n    if (selected != was_selected)\n        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;\n\n    // Render\n    {\n        const ImU32 text_col = GetColorU32(ImGuiCol_Text);\n        ImGuiNavRenderCursorFlags nav_render_cursor_flags = ImGuiNavRenderCursorFlags_Compact;\n        if (is_multi_select)\n            nav_render_cursor_flags |= ImGuiNavRenderCursorFlags_AlwaysDraw; // Always show the nav rectangle\n        if (display_frame)\n        {\n            // Framed type\n            const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\n            RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);\n            RenderNavCursor(frame_bb, id, nav_render_cursor_flags);\n            if (flags & ImGuiTreeNodeFlags_Bullet)\n                RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f), text_col);\n            else if (!is_leaf)\n                RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 1.0f);\n            else // Leaf without bullet, left-adjusted text\n                text_pos.x -= text_offset_x - padding.x;\n            if (flags & ImGuiTreeNodeFlags_ClipLabelForTrailingButton)\n                frame_bb.Max.x -= g.FontSize + style.FramePadding.x;\n            if (g.LogEnabled)\n                LogSetNextTextDecoration(\"###\", \"###\");\n        }\n        else\n        {\n            // Unframed typed for tree nodes\n            if (hovered || selected)\n            {\n                const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\n                RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);\n            }\n            RenderNavCursor(frame_bb, id, nav_render_cursor_flags);\n            if (flags & ImGuiTreeNodeFlags_Bullet)\n                RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f), text_col);\n            else if (!is_leaf)\n                RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 0.70f);\n            if (g.LogEnabled)\n                LogSetNextTextDecoration(\">\", NULL);\n        }\n\n        if (span_all_columns)\n            TablePopBackgroundChannel();\n\n        // Label\n        if (display_frame)\n            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);\n        else\n            RenderText(text_pos, label, label_end, false);\n    }\n\n    if (store_tree_node_stack_data && is_open)\n        TreeNodeStoreStackData(flags); // Call before TreePushOverrideID()\n    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\n        TreePushOverrideID(id); // Could use TreePush(label) but this avoid computing twice\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));\n    return is_open;\n}\n\nvoid ImGui::TreePush(const char* str_id)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    Indent();\n    window->DC.TreeDepth++;\n    PushID(str_id);\n}\n\nvoid ImGui::TreePush(const void* ptr_id)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    Indent();\n    window->DC.TreeDepth++;\n    PushID(ptr_id);\n}\n\nvoid ImGui::TreePushOverrideID(ImGuiID id)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    Indent();\n    window->DC.TreeDepth++;\n    PushOverrideID(id);\n}\n\nvoid ImGui::TreePop()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    Unindent();\n\n    window->DC.TreeDepth--;\n    ImU32 tree_depth_mask = (1 << window->DC.TreeDepth);\n\n    if (window->DC.TreeHasStackDataDepthMask & tree_depth_mask) // Only set during request\n    {\n        ImGuiTreeNodeStackData* data = &g.TreeNodeStack.back();\n        IM_ASSERT(data->ID == window->IDStack.back());\n        if (data->TreeFlags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere)\n        {\n            // Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)\n            if (g.NavIdIsAlive && g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())\n                NavMoveRequestResolveWithPastTreeNode(&g.NavMoveResultLocal, data);\n        }\n        g.TreeNodeStack.pop_back();\n        window->DC.TreeHasStackDataDepthMask &= ~tree_depth_mask;\n    }\n\n    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.\n    PopID();\n}\n\n// Horizontal distance preceding label when using TreeNode() or Bullet()\nfloat ImGui::GetTreeNodeToLabelSpacing()\n{\n    ImGuiContext& g = *GImGui;\n    return g.FontSize + (g.Style.FramePadding.x * 2.0f);\n}\n\n// Set next TreeNode/CollapsingHeader open state.\nvoid ImGui::SetNextItemOpen(bool is_open, ImGuiCond cond)\n{\n    ImGuiContext& g = *GImGui;\n    if (g.CurrentWindow->SkipItems)\n        return;\n    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasOpen;\n    g.NextItemData.OpenVal = is_open;\n    g.NextItemData.OpenCond = (ImU8)(cond ? cond : ImGuiCond_Always);\n}\n\n// Set next TreeNode/CollapsingHeader storage id.\nvoid ImGui::SetNextItemStorageID(ImGuiID storage_id)\n{\n    ImGuiContext& g = *GImGui;\n    if (g.CurrentWindow->SkipItems)\n        return;\n    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasStorageID;\n    g.NextItemData.StorageId = storage_id;\n}\n\n// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).\n// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().\nbool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n    ImGuiID id = window->GetID(label);\n    return TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader, label);\n}\n\n// p_visible == NULL                        : regular collapsing header\n// p_visible != NULL && *p_visible == true  : show a small close button on the corner of the header, clicking the button will set *p_visible = false\n// p_visible != NULL && *p_visible == false : do not show the header at all\n// Do not mistake this with the Open state of the header itself, which you can adjust with SetNextItemOpen() or ImGuiTreeNodeFlags_DefaultOpen.\nbool ImGui::CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    if (p_visible && !*p_visible)\n        return false;\n\n    ImGuiID id = window->GetID(label);\n    flags |= ImGuiTreeNodeFlags_CollapsingHeader;\n    if (p_visible)\n        flags |= ImGuiTreeNodeFlags_AllowOverlap | (ImGuiTreeNodeFlags)ImGuiTreeNodeFlags_ClipLabelForTrailingButton;\n    bool is_open = TreeNodeBehavior(id, flags, label);\n    if (p_visible != NULL)\n    {\n        // Create a small overlapping close button\n        // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.\n        // FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.\n        ImGuiContext& g = *GImGui;\n        ImGuiLastItemData last_item_backup = g.LastItemData;\n        float button_size = g.FontSize;\n        float button_x = ImMax(g.LastItemData.Rect.Min.x, g.LastItemData.Rect.Max.x - g.Style.FramePadding.x - button_size);\n        float button_y = g.LastItemData.Rect.Min.y + g.Style.FramePadding.y;\n        ImGuiID close_button_id = GetIDWithSeed(\"#CLOSE\", NULL, id);\n        if (CloseButton(close_button_id, ImVec2(button_x, button_y)))\n            *p_visible = false;\n        g.LastItemData = last_item_backup;\n    }\n\n    return is_open;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Selectable\n//-------------------------------------------------------------------------\n// - Selectable()\n//-------------------------------------------------------------------------\n\n// Tip: pass a non-visible label (e.g. \"##hello\") then you can use the space to draw other text or image.\n// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.\n// With this scheme, ImGuiSelectableFlags_SpanAllColumns and ImGuiSelectableFlags_AllowOverlap are also frequently used flags.\n// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f) followed by SameLine() is currently not supported.\nbool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n\n    // Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.\n    ImGuiID id = window->GetID(label);\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\n    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);\n    ImVec2 pos = window->DC.CursorPos;\n    pos.y += window->DC.CurrLineTextBaseOffset;\n    ItemSize(size, 0.0f);\n\n    // Fill horizontal space\n    // We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.\n    const bool span_all_columns = (flags & ImGuiSelectableFlags_SpanAllColumns) != 0;\n    const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;\n    const float max_x = span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;\n    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_SpanAvailWidth))\n        size.x = ImMax(label_size.x, max_x - min_x);\n\n    // Text stays at the submission position, but bounding box may be extended on both sides\n    const ImVec2 text_min = pos;\n    const ImVec2 text_max(min_x + size.x, pos.y + size.y);\n\n    // Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.\n    // FIXME: Not part of layout so not included in clipper calculation, but ItemSize currently doesn't allow offsetting CursorPos.\n    ImRect bb(min_x, pos.y, text_max.x, text_max.y);\n    if ((flags & ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)\n    {\n        const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;\n        const float spacing_y = style.ItemSpacing.y;\n        const float spacing_L = IM_TRUNC(spacing_x * 0.50f);\n        const float spacing_U = IM_TRUNC(spacing_y * 0.50f);\n        bb.Min.x -= spacing_L;\n        bb.Min.y -= spacing_U;\n        bb.Max.x += (spacing_x - spacing_L);\n        bb.Max.y += (spacing_y - spacing_U);\n    }\n    //if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }\n\n    const bool disabled_item = (flags & ImGuiSelectableFlags_Disabled) != 0;\n    const ImGuiItemFlags extra_item_flags = disabled_item ? (ImGuiItemFlags)ImGuiItemFlags_Disabled : ImGuiItemFlags_None;\n    bool is_visible;\n    if (span_all_columns)\n    {\n        // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..\n        const float backup_clip_rect_min_x = window->ClipRect.Min.x;\n        const float backup_clip_rect_max_x = window->ClipRect.Max.x;\n        window->ClipRect.Min.x = window->ParentWorkRect.Min.x;\n        window->ClipRect.Max.x = window->ParentWorkRect.Max.x;\n        is_visible = ItemAdd(bb, id, NULL, extra_item_flags);\n        window->ClipRect.Min.x = backup_clip_rect_min_x;\n        window->ClipRect.Max.x = backup_clip_rect_max_x;\n    }\n    else\n    {\n        is_visible = ItemAdd(bb, id, NULL, extra_item_flags);\n    }\n\n    const bool is_multi_select = (g.LastItemData.ItemFlags & ImGuiItemFlags_IsMultiSelect) != 0;\n    if (!is_visible)\n        if (!is_multi_select || !g.BoxSelectState.UnclipMode || !g.BoxSelectState.UnclipRect.Overlaps(bb)) // Extra layer of \"no logic clip\" for box-select support (would be more overhead to add to ItemAdd)\n            return false;\n\n    const bool disabled_global = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;\n    if (disabled_item && !disabled_global) // Only testing this as an optimization\n        BeginDisabled();\n\n    // FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,\n    // which would be advantageous since most selectable are not selected.\n    if (span_all_columns)\n    {\n        if (g.CurrentTable)\n            TablePushBackgroundChannel();\n        else if (window->DC.CurrentColumns)\n            PushColumnsBackground();\n        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasClipRect;\n        g.LastItemData.ClipRect = window->ClipRect;\n    }\n\n    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries\n    ImGuiButtonFlags button_flags = 0;\n    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }\n    if (flags & ImGuiSelectableFlags_NoSetKeyOwner)     { button_flags |= ImGuiButtonFlags_NoSetKeyOwner; }\n    if (flags & ImGuiSelectableFlags_SelectOnClick)     { button_flags |= ImGuiButtonFlags_PressedOnClick; }\n    if (flags & ImGuiSelectableFlags_SelectOnRelease)   { button_flags |= ImGuiButtonFlags_PressedOnRelease; }\n    if (flags & ImGuiSelectableFlags_AllowDoubleClick)  { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }\n    if ((flags & ImGuiSelectableFlags_AllowOverlap) || (g.LastItemData.ItemFlags & ImGuiItemFlags_AllowOverlap)) { button_flags |= ImGuiButtonFlags_AllowOverlap; }\n\n    // Multi-selection support (header)\n    const bool was_selected = selected;\n    if (is_multi_select)\n    {\n        // Handle multi-select + alter button flags for it\n        MultiSelectItemHeader(id, &selected, &button_flags);\n    }\n\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);\n\n    // Multi-selection support (footer)\n    if (is_multi_select)\n    {\n        MultiSelectItemFooter(id, &selected, &pressed);\n    }\n    else\n    {\n        // Auto-select when moved into\n        // - This will be more fully fleshed in the range-select branch\n        // - This is not exposed as it won't nicely work with some user side handling of shift/control\n        // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons\n        //   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())\n        //   - (2) usage will fail with clipped items\n        //   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.\n        if ((flags & ImGuiSelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)\n            if (g.NavJustMovedToId == id)\n                selected = pressed = true;\n    }\n\n    // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with keyboard/gamepad\n    if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover)))\n    {\n        if (!g.NavHighlightItemUnderNav && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)\n        {\n            SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)\n            if (g.IO.ConfigNavCursorVisibleAuto)\n                g.NavCursorVisible = false;\n        }\n    }\n    if (pressed)\n        MarkItemEdited(id);\n\n    if (selected != was_selected)\n        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;\n\n    // Render\n    if (is_visible)\n    {\n        const bool highlighted = hovered || (flags & ImGuiSelectableFlags_Highlight);\n        if (highlighted || selected)\n        {\n            // Between 1.91.0 and 1.91.4 we made selected Selectable use an arbitrary lerp between _Header and _HeaderHovered. Removed that now. (#8106)\n            ImU32 col = GetColorU32((held && highlighted) ? ImGuiCol_HeaderActive : highlighted ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\n            RenderFrame(bb.Min, bb.Max, col, false, 0.0f);\n        }\n        if (g.NavId == id)\n        {\n            ImGuiNavRenderCursorFlags nav_render_cursor_flags = ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_NoRounding;\n            if (is_multi_select)\n                nav_render_cursor_flags |= ImGuiNavRenderCursorFlags_AlwaysDraw; // Always show the nav rectangle\n            RenderNavCursor(bb, id, nav_render_cursor_flags);\n        }\n    }\n\n    if (span_all_columns)\n    {\n        if (g.CurrentTable)\n            TablePopBackgroundChannel();\n        else if (window->DC.CurrentColumns)\n            PopColumnsBackground();\n    }\n\n    if (is_visible)\n        RenderTextClipped(text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb);\n\n    // Automatically close popups\n    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_NoAutoClosePopups) && (g.LastItemData.ItemFlags & ImGuiItemFlags_AutoClosePopups))\n        CloseCurrentPopup();\n\n    if (disabled_item && !disabled_global)\n        EndDisabled();\n\n    // Selectable() always returns a pressed state!\n    // Users of BeginMultiSelect()/EndMultiSelect() scope: you may call ImGui::IsItemToggledSelection() to retrieve\n    // selection toggle, only useful if you need that state updated (e.g. for rendering purpose) before reaching EndMultiSelect().\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);\n    return pressed; //-V1020\n}\n\nbool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)\n{\n    if (Selectable(label, *p_selected, flags, size_arg))\n    {\n        *p_selected = !*p_selected;\n        return true;\n    }\n    return false;\n}\n\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Typing-Select support\n//-------------------------------------------------------------------------\n\n// [Experimental] Currently not exposed in public API.\n// Consume character inputs and return search request, if any.\n// This would typically only be called on the focused window or location you want to grab inputs for, e.g.\n//   if (ImGui::IsWindowFocused(...))\n//       if (ImGuiTypingSelectRequest* req = ImGui::GetTypingSelectRequest())\n//           focus_idx = ImGui::TypingSelectFindMatch(req, my_items.size(), [](void*, int n) { return my_items[n]->Name; }, &my_items, -1);\n// However the code is written in a way where calling it from multiple locations is safe (e.g. to obtain buffer).\nImGuiTypingSelectRequest* ImGui::GetTypingSelectRequest(ImGuiTypingSelectFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiTypingSelectState* data = &g.TypingSelectState;\n    ImGuiTypingSelectRequest* out_request = &data->Request;\n\n    // Clear buffer\n    const float TYPING_SELECT_RESET_TIMER = 1.80f;          // FIXME: Potentially move to IO config.\n    const int TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK = 4; // Lock single char matching when repeating same char 4 times\n    if (data->SearchBuffer[0] != 0)\n    {\n        bool clear_buffer = false;\n        clear_buffer |= (g.NavFocusScopeId != data->FocusScope);\n        clear_buffer |= (data->LastRequestTime + TYPING_SELECT_RESET_TIMER < g.Time);\n        clear_buffer |= g.NavAnyRequest;\n        clear_buffer |= g.ActiveId != 0 && g.NavActivateId == 0; // Allow temporary SPACE activation to not interfere\n        clear_buffer |= IsKeyPressed(ImGuiKey_Escape) || IsKeyPressed(ImGuiKey_Enter);\n        clear_buffer |= IsKeyPressed(ImGuiKey_Backspace) && (flags & ImGuiTypingSelectFlags_AllowBackspace) == 0;\n        //if (clear_buffer) { IMGUI_DEBUG_LOG(\"GetTypingSelectRequest(): Clear SearchBuffer.\\n\"); }\n        if (clear_buffer)\n            data->Clear();\n    }\n\n    // Append to buffer\n    const int buffer_max_len = IM_ARRAYSIZE(data->SearchBuffer) - 1;\n    int buffer_len = (int)strlen(data->SearchBuffer);\n    bool select_request = false;\n    for (ImWchar w : g.IO.InputQueueCharacters)\n    {\n        const int w_len = ImTextCountUtf8BytesFromStr(&w, &w + 1);\n        if (w < 32 || (buffer_len == 0 && ImCharIsBlankW(w)) || (buffer_len + w_len > buffer_max_len)) // Ignore leading blanks\n            continue;\n        char w_buf[5];\n        ImTextCharToUtf8(w_buf, (unsigned int)w);\n        if (data->SingleCharModeLock && w_len == out_request->SingleCharSize && memcmp(w_buf, data->SearchBuffer, w_len) == 0)\n        {\n            select_request = true; // Same character: don't need to append to buffer.\n            continue;\n        }\n        if (data->SingleCharModeLock)\n        {\n            data->Clear(); // Different character: clear\n            buffer_len = 0;\n        }\n        memcpy(data->SearchBuffer + buffer_len, w_buf, w_len + 1); // Append\n        buffer_len += w_len;\n        select_request = true;\n    }\n    g.IO.InputQueueCharacters.resize(0);\n\n    // Handle backspace\n    if ((flags & ImGuiTypingSelectFlags_AllowBackspace) && IsKeyPressed(ImGuiKey_Backspace, ImGuiInputFlags_Repeat))\n    {\n        char* p = (char*)(void*)ImTextFindPreviousUtf8Codepoint(data->SearchBuffer, data->SearchBuffer + buffer_len);\n        *p = 0;\n        buffer_len = (int)(p - data->SearchBuffer);\n    }\n\n    // Return request if any\n    if (buffer_len == 0)\n        return NULL;\n    if (select_request)\n    {\n        data->FocusScope = g.NavFocusScopeId;\n        data->LastRequestFrame = g.FrameCount;\n        data->LastRequestTime = (float)g.Time;\n    }\n    out_request->Flags = flags;\n    out_request->SearchBufferLen = buffer_len;\n    out_request->SearchBuffer = data->SearchBuffer;\n    out_request->SelectRequest = (data->LastRequestFrame == g.FrameCount);\n    out_request->SingleCharMode = false;\n    out_request->SingleCharSize = 0;\n\n    // Calculate if buffer contains the same character repeated.\n    // - This can be used to implement a special search mode on first character.\n    // - Performed on UTF-8 codepoint for correctness.\n    // - SingleCharMode is always set for first input character, because it usually leads to a \"next\".\n    if (flags & ImGuiTypingSelectFlags_AllowSingleCharMode)\n    {\n        const char* buf_begin = out_request->SearchBuffer;\n        const char* buf_end = out_request->SearchBuffer + out_request->SearchBufferLen;\n        const int c0_len = ImTextCountUtf8BytesFromChar(buf_begin, buf_end);\n        const char* p = buf_begin + c0_len;\n        for (; p < buf_end; p += c0_len)\n            if (memcmp(buf_begin, p, (size_t)c0_len) != 0)\n                break;\n        const int single_char_count = (p == buf_end) ? (out_request->SearchBufferLen / c0_len) : 0;\n        out_request->SingleCharMode = (single_char_count > 0 || data->SingleCharModeLock);\n        out_request->SingleCharSize = (ImS8)c0_len;\n        data->SingleCharModeLock |= (single_char_count >= TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK); // From now on we stop search matching to lock to single char mode.\n    }\n\n    return out_request;\n}\n\nstatic int ImStrimatchlen(const char* s1, const char* s1_end, const char* s2)\n{\n    int match_len = 0;\n    while (s1 < s1_end && ImToUpper(*s1++) == ImToUpper(*s2++))\n        match_len++;\n    return match_len;\n}\n\n// Default handler for finding a result for typing-select. You may implement your own.\n// You might want to display a tooltip to visualize the current request SearchBuffer\n// When SingleCharMode is set:\n// - it is better to NOT display a tooltip of other on-screen display indicator.\n// - the index of the currently focused item is required.\n//   if your SetNextItemSelectionUserData() values are indices, you can obtain it from ImGuiMultiSelectIO::NavIdItem, otherwise from g.NavLastValidSelectionUserData.\nint ImGui::TypingSelectFindMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data, int nav_item_idx)\n{\n    if (req == NULL || req->SelectRequest == false) // Support NULL parameter so both calls can be done from same spot.\n        return -1;\n    int idx = -1;\n    if (req->SingleCharMode && (req->Flags & ImGuiTypingSelectFlags_AllowSingleCharMode))\n        idx = TypingSelectFindNextSingleCharMatch(req, items_count, get_item_name_func, user_data, nav_item_idx);\n    else\n        idx = TypingSelectFindBestLeadingMatch(req, items_count, get_item_name_func, user_data);\n    if (idx != -1)\n        SetNavCursorVisibleAfterMove();\n    return idx;\n}\n\n// Special handling when a single character is repeated: perform search on a single letter and goes to next.\nint ImGui::TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data, int nav_item_idx)\n{\n    // FIXME: Assume selection user data is index. Would be extremely practical.\n    //if (nav_item_idx == -1)\n    //    nav_item_idx = (int)g.NavLastValidSelectionUserData;\n\n    int first_match_idx = -1;\n    bool return_next_match = false;\n    for (int idx = 0; idx < items_count; idx++)\n    {\n        const char* item_name = get_item_name_func(user_data, idx);\n        if (ImStrimatchlen(req->SearchBuffer, req->SearchBuffer + req->SingleCharSize, item_name) < req->SingleCharSize)\n            continue;\n        if (return_next_match)                           // Return next matching item after current item.\n            return idx;\n        if (first_match_idx == -1 && nav_item_idx == -1) // Return first match immediately if we don't have a nav_item_idx value.\n            return idx;\n        if (first_match_idx == -1)                       // Record first match for wrapping.\n            first_match_idx = idx;\n        if (nav_item_idx == idx)                         // Record that we encountering nav_item so we can return next match.\n            return_next_match = true;\n    }\n    return first_match_idx; // First result\n}\n\nint ImGui::TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequest* req, int items_count, const char* (*get_item_name_func)(void*, int), void* user_data)\n{\n    int longest_match_idx = -1;\n    int longest_match_len = 0;\n    for (int idx = 0; idx < items_count; idx++)\n    {\n        const char* item_name = get_item_name_func(user_data, idx);\n        const int match_len = ImStrimatchlen(req->SearchBuffer, req->SearchBuffer + req->SearchBufferLen, item_name);\n        if (match_len <= longest_match_len)\n            continue;\n        longest_match_idx = idx;\n        longest_match_len = match_len;\n        if (match_len == req->SearchBufferLen)\n            break;\n    }\n    return longest_match_idx;\n}\n\nvoid ImGui::DebugNodeTypingSelectState(ImGuiTypingSelectState* data)\n{\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    Text(\"SearchBuffer = \\\"%s\\\"\", data->SearchBuffer);\n    Text(\"SingleCharMode = %d, Size = %d, Lock = %d\", data->Request.SingleCharMode, data->Request.SingleCharSize, data->SingleCharModeLock);\n    Text(\"LastRequest = time: %.2f, frame: %d\", data->LastRequestTime, data->LastRequestFrame);\n#else\n    IM_UNUSED(data);\n#endif\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Box-Select support\n// This has been extracted away from Multi-Select logic in the hope that it could eventually be used elsewhere, but hasn't been yet.\n//-------------------------------------------------------------------------\n// Extra logic in MultiSelectItemFooter() and ImGuiListClipper::Step()\n//-------------------------------------------------------------------------\n// - BoxSelectPreStartDrag() [Internal]\n// - BoxSelectActivateDrag() [Internal]\n// - BoxSelectDeactivateDrag() [Internal]\n// - BoxSelectScrollWithMouseDrag() [Internal]\n// - BeginBoxSelect() [Internal]\n// - EndBoxSelect() [Internal]\n//-------------------------------------------------------------------------\n\n// Call on the initial click.\nstatic void BoxSelectPreStartDrag(ImGuiID id, ImGuiSelectionUserData clicked_item)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiBoxSelectState* bs = &g.BoxSelectState;\n    bs->ID = id;\n    bs->IsStarting = true; // Consider starting box-select.\n    bs->IsStartedFromVoid = (clicked_item == ImGuiSelectionUserData_Invalid);\n    bs->IsStartedSetNavIdOnce = bs->IsStartedFromVoid;\n    bs->KeyMods = g.IO.KeyMods;\n    bs->StartPosRel = bs->EndPosRel = ImGui::WindowPosAbsToRel(g.CurrentWindow, g.IO.MousePos);\n    bs->ScrollAccum = ImVec2(0.0f, 0.0f);\n}\n\nstatic void BoxSelectActivateDrag(ImGuiBoxSelectState* bs, ImGuiWindow* window)\n{\n    ImGuiContext& g = *GImGui;\n    IMGUI_DEBUG_LOG_SELECTION(\"[selection] BeginBoxSelect() 0X%08X: Activate\\n\", bs->ID);\n    bs->IsActive = true;\n    bs->Window = window;\n    bs->IsStarting = false;\n    ImGui::SetActiveID(bs->ID, window);\n    ImGui::SetActiveIdUsingAllKeyboardKeys();\n    if (bs->IsStartedFromVoid && (bs->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0)\n        bs->RequestClear = true;\n}\n\nstatic void BoxSelectDeactivateDrag(ImGuiBoxSelectState* bs)\n{\n    ImGuiContext& g = *GImGui;\n    bs->IsActive = bs->IsStarting = false;\n    if (g.ActiveId == bs->ID)\n    {\n        IMGUI_DEBUG_LOG_SELECTION(\"[selection] BeginBoxSelect() 0X%08X: Deactivate\\n\", bs->ID);\n        ImGui::ClearActiveID();\n    }\n    bs->ID = 0;\n}\n\nstatic void BoxSelectScrollWithMouseDrag(ImGuiBoxSelectState* bs, ImGuiWindow* window, const ImRect& inner_r)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(bs->Window == window);\n    for (int n = 0; n < 2; n++) // each axis\n    {\n        const float mouse_pos = g.IO.MousePos[n];\n        const float dist = (mouse_pos > inner_r.Max[n]) ? mouse_pos - inner_r.Max[n] : (mouse_pos < inner_r.Min[n]) ? mouse_pos - inner_r.Min[n] : 0.0f;\n        const float scroll_curr = window->Scroll[n];\n        if (dist == 0.0f || (dist < 0.0f && scroll_curr < 0.0f) || (dist > 0.0f && scroll_curr >= window->ScrollMax[n]))\n            continue;\n\n        const float speed_multiplier = ImLinearRemapClamp(g.FontSize, g.FontSize * 5.0f, 1.0f, 4.0f, ImAbs(dist)); // x1 to x4 depending on distance\n        const float scroll_step = g.FontSize * 35.0f * speed_multiplier * ImSign(dist) * g.IO.DeltaTime;\n        bs->ScrollAccum[n] += scroll_step;\n\n        // Accumulate into a stored value so we can handle high-framerate\n        const float scroll_step_i = ImFloor(bs->ScrollAccum[n]);\n        if (scroll_step_i == 0.0f)\n            continue;\n        if (n == 0)\n            ImGui::SetScrollX(window, scroll_curr + scroll_step_i);\n        else\n            ImGui::SetScrollY(window, scroll_curr + scroll_step_i);\n        bs->ScrollAccum[n] -= scroll_step_i;\n    }\n}\n\nbool ImGui::BeginBoxSelect(const ImRect& scope_rect, ImGuiWindow* window, ImGuiID box_select_id, ImGuiMultiSelectFlags ms_flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiBoxSelectState* bs = &g.BoxSelectState;\n    KeepAliveID(box_select_id);\n    if (bs->ID != box_select_id)\n        return false;\n\n    // IsStarting is set by MultiSelectItemFooter() when considering a possible box-select. We validate it here and lock geometry.\n    bs->UnclipMode = false;\n    bs->RequestClear = false;\n    if (bs->IsStarting && IsMouseDragPastThreshold(0))\n        BoxSelectActivateDrag(bs, window);\n    else if ((bs->IsStarting || bs->IsActive) && g.IO.MouseDown[0] == false)\n        BoxSelectDeactivateDrag(bs);\n    if (!bs->IsActive)\n        return false;\n\n    // Current frame absolute prev/current rectangles are used to toggle selection.\n    // They are derived from positions relative to scrolling space.\n    ImVec2 start_pos_abs = WindowPosRelToAbs(window, bs->StartPosRel);\n    ImVec2 prev_end_pos_abs = WindowPosRelToAbs(window, bs->EndPosRel); // Clamped already\n    ImVec2 curr_end_pos_abs = g.IO.MousePos;\n    if (ms_flags & ImGuiMultiSelectFlags_ScopeWindow) // Box-select scrolling only happens with ScopeWindow\n        curr_end_pos_abs = ImClamp(curr_end_pos_abs, scope_rect.Min, scope_rect.Max);\n    bs->BoxSelectRectPrev.Min = ImMin(start_pos_abs, prev_end_pos_abs);\n    bs->BoxSelectRectPrev.Max = ImMax(start_pos_abs, prev_end_pos_abs);\n    bs->BoxSelectRectCurr.Min = ImMin(start_pos_abs, curr_end_pos_abs);\n    bs->BoxSelectRectCurr.Max = ImMax(start_pos_abs, curr_end_pos_abs);\n\n    // Box-select 2D mode detects horizontal changes (vertical ones are already picked by Clipper)\n    // Storing an extra rect used by widgets supporting box-select.\n    if (ms_flags & ImGuiMultiSelectFlags_BoxSelect2d)\n        if (bs->BoxSelectRectPrev.Min.x != bs->BoxSelectRectCurr.Min.x || bs->BoxSelectRectPrev.Max.x != bs->BoxSelectRectCurr.Max.x)\n        {\n            bs->UnclipMode = true;\n            bs->UnclipRect = bs->BoxSelectRectPrev; // FIXME-OPT: UnclipRect x coordinates could be intersection of Prev and Curr rect on X axis.\n            bs->UnclipRect.Add(bs->BoxSelectRectCurr);\n        }\n\n    //GetForegroundDrawList()->AddRect(bs->UnclipRect.Min, bs->UnclipRect.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);\n    //GetForegroundDrawList()->AddRect(bs->BoxSelectRectPrev.Min, bs->BoxSelectRectPrev.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);\n    //GetForegroundDrawList()->AddRect(bs->BoxSelectRectCurr.Min, bs->BoxSelectRectCurr.Max, IM_COL32(0,255,0,200), 0.0f, 0, 1.0f);\n    return true;\n}\n\nvoid ImGui::EndBoxSelect(const ImRect& scope_rect, ImGuiMultiSelectFlags ms_flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    ImGuiBoxSelectState* bs = &g.BoxSelectState;\n    IM_ASSERT(bs->IsActive);\n    bs->UnclipMode = false;\n\n    // Render selection rectangle\n    bs->EndPosRel = WindowPosAbsToRel(window, ImClamp(g.IO.MousePos, scope_rect.Min, scope_rect.Max)); // Clamp stored position according to current scrolling view\n    ImRect box_select_r = bs->BoxSelectRectCurr;\n    box_select_r.ClipWith(scope_rect);\n    window->DrawList->AddRectFilled(box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_SeparatorHovered, 0.30f)); // FIXME-MULTISELECT: Styling\n    window->DrawList->AddRect(box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_NavCursor)); // FIXME-MULTISELECT: Styling\n\n    // Scroll\n    const bool enable_scroll = (ms_flags & ImGuiMultiSelectFlags_ScopeWindow) && (ms_flags & ImGuiMultiSelectFlags_BoxSelectNoScroll) == 0;\n    if (enable_scroll)\n    {\n        ImRect scroll_r = scope_rect;\n        scroll_r.Expand(-g.FontSize);\n        //GetForegroundDrawList()->AddRect(scroll_r.Min, scroll_r.Max, IM_COL32(0, 255, 0, 255));\n        if (!scroll_r.Contains(g.IO.MousePos))\n            BoxSelectScrollWithMouseDrag(bs, window, scroll_r);\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Multi-Select support\n//-------------------------------------------------------------------------\n// - DebugLogMultiSelectRequests() [Internal]\n// - CalcScopeRect() [Internal]\n// - BeginMultiSelect()\n// - EndMultiSelect()\n// - SetNextItemSelectionUserData()\n// - MultiSelectItemHeader() [Internal]\n// - MultiSelectItemFooter() [Internal]\n// - DebugNodeMultiSelectState() [Internal]\n//-------------------------------------------------------------------------\n\nstatic void DebugLogMultiSelectRequests(const char* function, const ImGuiMultiSelectIO* io)\n{\n    ImGuiContext& g = *GImGui;\n    IM_UNUSED(function);\n    for (const ImGuiSelectionRequest& req : io->Requests)\n    {\n        if (req.Type == ImGuiSelectionRequestType_SetAll)    IMGUI_DEBUG_LOG_SELECTION(\"[selection] %s: Request: SetAll %d (= %s)\\n\", function, req.Selected, req.Selected ? \"SelectAll\" : \"Clear\");\n        if (req.Type == ImGuiSelectionRequestType_SetRange)  IMGUI_DEBUG_LOG_SELECTION(\"[selection] %s: Request: SetRange %\" IM_PRId64 \"..%\" IM_PRId64 \" (0x%\" IM_PRIX64 \"..0x%\" IM_PRIX64 \") = %d (dir %d)\\n\", function, req.RangeFirstItem, req.RangeLastItem, req.RangeFirstItem, req.RangeLastItem, req.Selected, req.RangeDirection);\n    }\n}\n\nstatic ImRect CalcScopeRect(ImGuiMultiSelectTempData* ms, ImGuiWindow* window)\n{\n    ImGuiContext& g = *GImGui;\n    if (ms->Flags & ImGuiMultiSelectFlags_ScopeRect)\n    {\n        // Warning: this depends on CursorMaxPos so it means to be called by EndMultiSelect() only\n        return ImRect(ms->ScopeRectMin, ImMax(window->DC.CursorMaxPos, ms->ScopeRectMin));\n    }\n    else\n    {\n        // When a table, pull HostClipRect, which allows us to predict ClipRect before first row/layout is performed. (#7970)\n        ImRect scope_rect = window->InnerClipRect;\n        if (g.CurrentTable != NULL)\n            scope_rect = g.CurrentTable->HostClipRect;\n\n        // Add inner table decoration (#7821) // FIXME: Why not baking in InnerClipRect?\n        scope_rect.Min = ImMin(scope_rect.Min + ImVec2(window->DecoInnerSizeX1, window->DecoInnerSizeY1), scope_rect.Max);\n        return scope_rect;\n    }\n}\n\n// Return ImGuiMultiSelectIO structure.\n// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().\n// Passing 'selection_size' and 'items_count' parameters is currently optional.\n// - 'selection_size' is useful to disable some shortcut routing: e.g. ImGuiMultiSelectFlags_ClearOnEscape won't claim Escape key when selection_size 0,\n//    allowing a first press to clear selection THEN the second press to leave child window and return to parent.\n// - 'items_count' is stored in ImGuiMultiSelectIO which makes it a convenient way to pass the information to your ApplyRequest() handler (but you may pass it differently).\n// - If they are costly for you to compute (e.g. external intrusive selection without maintaining size), you may avoid them and pass -1.\n//   - If you can easily tell if your selection is empty or not, you may pass 0/1, or you may enable ImGuiMultiSelectFlags_ClearOnEscape flag dynamically.\nImGuiMultiSelectIO* ImGui::BeginMultiSelect(ImGuiMultiSelectFlags flags, int selection_size, int items_count)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    if (++g.MultiSelectTempDataStacked > g.MultiSelectTempData.Size)\n        g.MultiSelectTempData.resize(g.MultiSelectTempDataStacked, ImGuiMultiSelectTempData());\n    ImGuiMultiSelectTempData* ms = &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1];\n    IM_STATIC_ASSERT(offsetof(ImGuiMultiSelectTempData, IO) == 0); // Clear() relies on that.\n    g.CurrentMultiSelect = ms;\n    if ((flags & (ImGuiMultiSelectFlags_ScopeWindow | ImGuiMultiSelectFlags_ScopeRect)) == 0)\n        flags |= ImGuiMultiSelectFlags_ScopeWindow;\n    if (flags & ImGuiMultiSelectFlags_SingleSelect)\n        flags &= ~(ImGuiMultiSelectFlags_BoxSelect2d | ImGuiMultiSelectFlags_BoxSelect1d);\n    if (flags & ImGuiMultiSelectFlags_BoxSelect2d)\n        flags &= ~ImGuiMultiSelectFlags_BoxSelect1d;\n\n    // FIXME: Workaround to the fact we override CursorMaxPos, meaning size measurement are lost. (#8250)\n    // They should perhaps be stacked properly?\n    if (ImGuiTable* table = g.CurrentTable)\n        if (table->CurrentColumn != -1)\n            TableEndCell(table); // This is currently safe to call multiple time. If that properly is lost we can extract the \"save measurement\" part of it.\n\n    // FIXME: BeginFocusScope()\n    const ImGuiID id = window->IDStack.back();\n    ms->Clear();\n    ms->FocusScopeId = id;\n    ms->Flags = flags;\n    ms->IsFocused = (ms->FocusScopeId == g.NavFocusScopeId);\n    ms->BackupCursorMaxPos = window->DC.CursorMaxPos;\n    ms->ScopeRectMin = window->DC.CursorMaxPos = window->DC.CursorPos;\n    PushFocusScope(ms->FocusScopeId);\n    if (flags & ImGuiMultiSelectFlags_ScopeWindow) // Mark parent child window as navigable into, with highlight. Assume user will always submit interactive items.\n        window->DC.NavLayersActiveMask |= 1 << ImGuiNavLayer_Main;\n\n    // Use copy of keyboard mods at the time of the request, otherwise we would requires mods to be held for an extra frame.\n    ms->KeyMods = g.NavJustMovedToId ? (g.NavJustMovedToIsTabbing ? 0 : g.NavJustMovedToKeyMods) : g.IO.KeyMods;\n    if (flags & ImGuiMultiSelectFlags_NoRangeSelect)\n        ms->KeyMods &= ~ImGuiMod_Shift;\n\n    // Bind storage\n    ImGuiMultiSelectState* storage = g.MultiSelectStorage.GetOrAddByKey(id);\n    storage->ID = id;\n    storage->LastFrameActive = g.FrameCount;\n    storage->LastSelectionSize = selection_size;\n    storage->Window = window;\n    ms->Storage = storage;\n\n    // Output to user\n    ms->IO.Requests.resize(0);\n    ms->IO.RangeSrcItem = storage->RangeSrcItem;\n    ms->IO.NavIdItem = storage->NavIdItem;\n    ms->IO.NavIdSelected = (storage->NavIdSelected == 1) ? true : false;\n    ms->IO.ItemsCount = items_count;\n\n    // Clear when using Navigation to move within the scope\n    // (we compare FocusScopeId so it possible to use multiple selections inside a same window)\n    bool request_clear = false;\n    bool request_select_all = false;\n    if (g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == ms->FocusScopeId && g.NavJustMovedToHasSelectionData)\n    {\n        if (ms->KeyMods & ImGuiMod_Shift)\n            ms->IsKeyboardSetRange = true;\n        if (ms->IsKeyboardSetRange)\n            IM_ASSERT(storage->RangeSrcItem != ImGuiSelectionUserData_Invalid); // Not ready -> could clear?\n        if ((ms->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0 && (flags & (ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_NoAutoSelect)) == 0)\n            request_clear = true;\n    }\n    else if (g.NavJustMovedFromFocusScopeId == ms->FocusScopeId)\n    {\n        // Also clear on leaving scope (may be optional?)\n        if ((ms->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0 && (flags & (ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_NoAutoSelect)) == 0)\n            request_clear = true;\n    }\n\n    // Box-select handling: update active state.\n    ImGuiBoxSelectState* bs = &g.BoxSelectState;\n    if (flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))\n    {\n        ms->BoxSelectId = GetID(\"##BoxSelect\");\n        if (BeginBoxSelect(CalcScopeRect(ms, window), window, ms->BoxSelectId, flags))\n            request_clear |= bs->RequestClear;\n    }\n\n    if (ms->IsFocused)\n    {\n        // Shortcut: Clear selection (Escape)\n        // - Only claim shortcut if selection is not empty, allowing further presses on Escape to e.g. leave current child window.\n        // - Box select also handle Escape and needs to pass an id to bypass ActiveIdUsingAllKeyboardKeys lock.\n        if (flags & ImGuiMultiSelectFlags_ClearOnEscape)\n        {\n            if (selection_size != 0 || bs->IsActive)\n                if (Shortcut(ImGuiKey_Escape, ImGuiInputFlags_None, bs->IsActive ? bs->ID : 0))\n                {\n                    request_clear = true;\n                    if (bs->IsActive)\n                        BoxSelectDeactivateDrag(bs);\n                }\n        }\n\n        // Shortcut: Select all (CTRL+A)\n        if (!(flags & ImGuiMultiSelectFlags_SingleSelect) && !(flags & ImGuiMultiSelectFlags_NoSelectAll))\n            if (Shortcut(ImGuiMod_Ctrl | ImGuiKey_A))\n                request_select_all = true;\n    }\n\n    if (request_clear || request_select_all)\n    {\n        MultiSelectAddSetAll(ms, request_select_all);\n        if (!request_select_all)\n            storage->LastSelectionSize = 0;\n    }\n    ms->LoopRequestSetAll = request_select_all ? 1 : request_clear ? 0 : -1;\n    ms->LastSubmittedItem = ImGuiSelectionUserData_Invalid;\n\n    if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)\n        DebugLogMultiSelectRequests(\"BeginMultiSelect\", &ms->IO);\n\n    return &ms->IO;\n}\n\n// Return updated ImGuiMultiSelectIO structure.\n// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().\nImGuiMultiSelectIO* ImGui::EndMultiSelect()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect;\n    ImGuiMultiSelectState* storage = ms->Storage;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT_USER_ERROR(ms->FocusScopeId == g.CurrentFocusScopeId, \"EndMultiSelect() FocusScope mismatch!\");\n    IM_ASSERT(g.CurrentMultiSelect != NULL && storage->Window == g.CurrentWindow);\n    IM_ASSERT(g.MultiSelectTempDataStacked > 0 && &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1] == g.CurrentMultiSelect);\n\n    ImRect scope_rect = CalcScopeRect(ms, window);\n    if (ms->IsFocused)\n    {\n        // We currently don't allow user code to modify RangeSrcItem by writing to BeginIO's version, but that would be an easy change here.\n        if (ms->IO.RangeSrcReset || (ms->RangeSrcPassedBy == false && ms->IO.RangeSrcItem != ImGuiSelectionUserData_Invalid)) // Can't read storage->RangeSrcItem here -> we want the state at begining of the scope (see tests for easy failure)\n        {\n            IMGUI_DEBUG_LOG_SELECTION(\"[selection] EndMultiSelect: Reset RangeSrcItem.\\n\"); // Will set be to NavId.\n            storage->RangeSrcItem = ImGuiSelectionUserData_Invalid;\n        }\n        if (ms->NavIdPassedBy == false && storage->NavIdItem != ImGuiSelectionUserData_Invalid)\n        {\n            IMGUI_DEBUG_LOG_SELECTION(\"[selection] EndMultiSelect: Reset NavIdItem.\\n\");\n            storage->NavIdItem = ImGuiSelectionUserData_Invalid;\n            storage->NavIdSelected = -1;\n        }\n\n        if ((ms->Flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d)) && GetBoxSelectState(ms->BoxSelectId))\n            EndBoxSelect(scope_rect, ms->Flags);\n    }\n\n    if (ms->IsEndIO == false)\n        ms->IO.Requests.resize(0);\n\n    // Clear selection when clicking void?\n    // We specifically test for IsMouseDragPastThreshold(0) == false to allow box-selection!\n    // The InnerRect test is necessary for non-child/decorated windows.\n    bool scope_hovered = IsWindowHovered() && window->InnerRect.Contains(g.IO.MousePos);\n    if (scope_hovered && (ms->Flags & ImGuiMultiSelectFlags_ScopeRect))\n        scope_hovered &= scope_rect.Contains(g.IO.MousePos);\n    if (scope_hovered && g.HoveredId == 0 && g.ActiveId == 0)\n    {\n        if (ms->Flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))\n        {\n            if (!g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && g.IO.MouseClickedCount[0] == 1)\n            {\n                BoxSelectPreStartDrag(ms->BoxSelectId, ImGuiSelectionUserData_Invalid);\n                FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);\n                SetHoveredID(ms->BoxSelectId);\n                if (ms->Flags & ImGuiMultiSelectFlags_ScopeRect)\n                    SetNavID(0, ImGuiNavLayer_Main, ms->FocusScopeId, ImRect(g.IO.MousePos, g.IO.MousePos)); // Automatically switch FocusScope for initial click from void to box-select.\n            }\n        }\n\n        if (ms->Flags & ImGuiMultiSelectFlags_ClearOnClickVoid)\n            if (IsMouseReleased(0) && IsMouseDragPastThreshold(0) == false && g.IO.KeyMods == ImGuiMod_None)\n                MultiSelectAddSetAll(ms, false);\n    }\n\n    // Courtesy nav wrapping helper flag\n    if (ms->Flags & ImGuiMultiSelectFlags_NavWrapX)\n    {\n        IM_ASSERT(ms->Flags & ImGuiMultiSelectFlags_ScopeWindow); // Only supported at window scope\n        ImGui::NavMoveRequestTryWrapping(ImGui::GetCurrentWindow(), ImGuiNavMoveFlags_WrapX);\n    }\n\n    // Unwind\n    window->DC.CursorMaxPos = ImMax(ms->BackupCursorMaxPos, window->DC.CursorMaxPos);\n    PopFocusScope();\n\n    if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)\n        DebugLogMultiSelectRequests(\"EndMultiSelect\", &ms->IO);\n\n    ms->FocusScopeId = 0;\n    ms->Flags = ImGuiMultiSelectFlags_None;\n    g.CurrentMultiSelect = (--g.MultiSelectTempDataStacked > 0) ? &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1] : NULL;\n\n    return &ms->IO;\n}\n\nvoid ImGui::SetNextItemSelectionUserData(ImGuiSelectionUserData selection_user_data)\n{\n    // Note that flags will be cleared by ItemAdd(), so it's only useful for Navigation code!\n    // This designed so widgets can also cheaply set this before calling ItemAdd(), so we are not tied to MultiSelect api.\n    ImGuiContext& g = *GImGui;\n    g.NextItemData.SelectionUserData = selection_user_data;\n    g.NextItemData.FocusScopeId = g.CurrentFocusScopeId;\n\n    if (ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect)\n    {\n        // Auto updating RangeSrcPassedBy for cases were clipper is not used (done before ItemAdd() clipping)\n        g.NextItemData.ItemFlags |= ImGuiItemFlags_HasSelectionUserData | ImGuiItemFlags_IsMultiSelect;\n        if (ms->IO.RangeSrcItem == selection_user_data)\n            ms->RangeSrcPassedBy = true;\n    }\n    else\n    {\n        g.NextItemData.ItemFlags |= ImGuiItemFlags_HasSelectionUserData;\n    }\n}\n\n// In charge of:\n// - Applying SetAll for submitted items.\n// - Applying SetRange for submitted items and record end points.\n// - Altering button behavior flags to facilitate use with drag and drop.\nvoid ImGui::MultiSelectItemHeader(ImGuiID id, bool* p_selected, ImGuiButtonFlags* p_button_flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect;\n\n    bool selected = *p_selected;\n    if (ms->IsFocused)\n    {\n        ImGuiMultiSelectState* storage = ms->Storage;\n        ImGuiSelectionUserData item_data = g.NextItemData.SelectionUserData;\n        IM_ASSERT(g.NextItemData.FocusScopeId == g.CurrentFocusScopeId && \"Forgot to call SetNextItemSelectionUserData() prior to item, required in BeginMultiSelect()/EndMultiSelect() scope\");\n\n        // Apply SetAll (Clear/SelectAll) requests requested by BeginMultiSelect().\n        // This is only useful if the user hasn't processed them already, and this only works if the user isn't using the clipper.\n        // If you are using a clipper you need to process the SetAll request after calling BeginMultiSelect()\n        if (ms->LoopRequestSetAll != -1)\n            selected = (ms->LoopRequestSetAll == 1);\n\n        // When using SHIFT+Nav: because it can incur scrolling we cannot afford a frame of lag with the selection highlight (otherwise scrolling would happen before selection)\n        // For this to work, we need someone to set 'RangeSrcPassedBy = true' at some point (either clipper either SetNextItemSelectionUserData() function)\n        if (ms->IsKeyboardSetRange)\n        {\n            IM_ASSERT(id != 0 && (ms->KeyMods & ImGuiMod_Shift) != 0);\n            const bool is_range_dst = (ms->RangeDstPassedBy == false) && g.NavJustMovedToId == id;     // Assume that g.NavJustMovedToId is not clipped.\n            if (is_range_dst)\n                ms->RangeDstPassedBy = true;\n            if (is_range_dst && storage->RangeSrcItem == ImGuiSelectionUserData_Invalid) // If we don't have RangeSrc, assign RangeSrc = RangeDst\n            {\n                storage->RangeSrcItem = item_data;\n                storage->RangeSelected = selected ? 1 : 0;\n            }\n            const bool is_range_src = storage->RangeSrcItem == item_data;\n            if (is_range_src || is_range_dst || ms->RangeSrcPassedBy != ms->RangeDstPassedBy)\n            {\n                // Apply range-select value to visible items\n                IM_ASSERT(storage->RangeSrcItem != ImGuiSelectionUserData_Invalid && storage->RangeSelected != -1);\n                selected = (storage->RangeSelected != 0);\n            }\n            else if ((ms->KeyMods & ImGuiMod_Ctrl) == 0 && (ms->Flags & ImGuiMultiSelectFlags_NoAutoClear) == 0)\n            {\n                // Clear other items\n                selected = false;\n            }\n        }\n        *p_selected = selected;\n    }\n\n    // Alter button behavior flags\n    // To handle drag and drop of multiple items we need to avoid clearing selection on click.\n    // Enabling this test makes actions using CTRL+SHIFT delay their effect on MouseUp which is annoying, but it allows drag and drop of multiple items.\n    if (p_button_flags != NULL)\n    {\n        ImGuiButtonFlags button_flags = *p_button_flags;\n        button_flags |= ImGuiButtonFlags_NoHoveredOnFocus;\n        if ((!selected || (g.ActiveId == id && g.ActiveIdHasBeenPressedBefore)) && !(ms->Flags & ImGuiMultiSelectFlags_SelectOnClickRelease))\n            button_flags = (button_flags | ImGuiButtonFlags_PressedOnClick) & ~ImGuiButtonFlags_PressedOnClickRelease;\n        else\n            button_flags |= ImGuiButtonFlags_PressedOnClickRelease;\n        *p_button_flags = button_flags;\n    }\n}\n\n// In charge of:\n// - Auto-select on navigation.\n// - Box-select toggle handling.\n// - Right-click handling.\n// - Altering selection based on Ctrl/Shift modifiers, both for keyboard and mouse.\n// - Record current selection state for RangeSrc\n// This is all rather complex, best to run and refer to \"widgets_multiselect_xxx\" tests in imgui_test_suite.\nvoid ImGui::MultiSelectItemFooter(ImGuiID id, bool* p_selected, bool* p_pressed)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    bool selected = *p_selected;\n    bool pressed = *p_pressed;\n    ImGuiMultiSelectTempData* ms = g.CurrentMultiSelect;\n    ImGuiMultiSelectState* storage = ms->Storage;\n    if (pressed)\n        ms->IsFocused = true;\n\n    bool hovered = false;\n    if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect)\n        hovered = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);\n    if (!ms->IsFocused && !hovered)\n        return;\n\n    ImGuiSelectionUserData item_data = g.NextItemData.SelectionUserData;\n\n    ImGuiMultiSelectFlags flags = ms->Flags;\n    const bool is_singleselect = (flags & ImGuiMultiSelectFlags_SingleSelect) != 0;\n    bool is_ctrl = (ms->KeyMods & ImGuiMod_Ctrl) != 0;\n    bool is_shift = (ms->KeyMods & ImGuiMod_Shift) != 0;\n\n    bool apply_to_range_src = false;\n\n    if (g.NavId == id && storage->RangeSrcItem == ImGuiSelectionUserData_Invalid)\n        apply_to_range_src = true;\n    if (ms->IsEndIO == false)\n    {\n        ms->IO.Requests.resize(0);\n        ms->IsEndIO = true;\n    }\n\n    // Auto-select as you navigate a list\n    if (g.NavJustMovedToId == id)\n    {\n        if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)\n        {\n            if (is_ctrl && is_shift)\n                pressed = true;\n            else if (!is_ctrl)\n                selected = pressed = true;\n        }\n        else\n        {\n            // With NoAutoSelect, using Shift+keyboard performs a write/copy\n            if (is_shift)\n                pressed = true;\n            else if (!is_ctrl)\n                apply_to_range_src = true; // Since if (pressed) {} main block is not running we update this\n        }\n    }\n\n    if (apply_to_range_src)\n    {\n        storage->RangeSrcItem = item_data;\n        storage->RangeSelected = selected; // Will be updated at the end of this function anyway.\n    }\n\n    // Box-select toggle handling\n    if (ms->BoxSelectId != 0)\n        if (ImGuiBoxSelectState* bs = GetBoxSelectState(ms->BoxSelectId))\n        {\n            const bool rect_overlap_curr = bs->BoxSelectRectCurr.Overlaps(g.LastItemData.Rect);\n            const bool rect_overlap_prev = bs->BoxSelectRectPrev.Overlaps(g.LastItemData.Rect);\n            if ((rect_overlap_curr && !rect_overlap_prev && !selected) || (rect_overlap_prev && !rect_overlap_curr))\n            {\n                if (storage->LastSelectionSize <= 0 && bs->IsStartedSetNavIdOnce)\n                {\n                    pressed = true; // First item act as a pressed: code below will emit selection request and set NavId (whatever we emit here will be overridden anyway)\n                    bs->IsStartedSetNavIdOnce = false;\n                }\n                else\n                {\n                    selected = !selected;\n                    MultiSelectAddSetRange(ms, selected, +1, item_data, item_data);\n                }\n                storage->LastSelectionSize = ImMax(storage->LastSelectionSize + 1, 1);\n            }\n        }\n\n    // Right-click handling.\n    // FIXME-MULTISELECT: Currently filtered out by ImGuiMultiSelectFlags_NoAutoSelect but maybe should be moved to Selectable(). See https://github.com/ocornut/imgui/pull/5816\n    if (hovered && IsMouseClicked(1) && (flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)\n    {\n        if (g.ActiveId != 0 && g.ActiveId != id)\n            ClearActiveID();\n        SetFocusID(id, window);\n        if (!pressed && !selected)\n        {\n            pressed = true;\n            is_ctrl = is_shift = false;\n        }\n    }\n\n    // Unlike Space, Enter doesn't alter selection (but can still return a press) unless current item is not selected.\n    // The later, \"unless current item is not select\", may become optional? It seems like a better default if Enter doesn't necessarily open something\n    // (unlike e.g. Windows explorer). For use case where Enter always open something, we might decide to make this optional?\n    const bool enter_pressed = pressed && (g.NavActivateId == id) && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput);\n\n    // Alter selection\n    if (pressed && (!enter_pressed || !selected))\n    {\n        // Box-select\n        ImGuiInputSource input_source = (g.NavJustMovedToId == id || g.NavActivateId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;\n        if (flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))\n            if (selected == false && !g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && input_source == ImGuiInputSource_Mouse && g.IO.MouseClickedCount[0] == 1)\n                BoxSelectPreStartDrag(ms->BoxSelectId, item_data);\n\n        //----------------------------------------------------------------------------------------\n        // ACTION                      | Begin  | Pressed/Activated  | End\n        //----------------------------------------------------------------------------------------\n        // Keys Navigated:             | Clear  | Src=item, Sel=1               SetRange 1\n        // Keys Navigated: Ctrl        | n/a    | n/a\n        // Keys Navigated:      Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1\n        // Keys Navigated: Ctrl+Shift  | n/a    | Dst=item, Sel=Src  => Clear + SetRange Src-Dst\n        // Keys Activated:             | n/a    | Src=item, Sel=1    => Clear + SetRange 1\n        // Keys Activated: Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetSange 1\n        // Keys Activated:      Shift  | n/a    | Dst=item, Sel=1    => Clear + SetSange 1\n        //----------------------------------------------------------------------------------------\n        // Mouse Pressed:              | n/a    | Src=item, Sel=1,   => Clear + SetRange 1\n        // Mouse Pressed:  Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetRange 1\n        // Mouse Pressed:       Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1\n        // Mouse Pressed:  Ctrl+Shift  | n/a    | Dst=item, Sel=!Sel =>         SetRange Src-Dst\n        //----------------------------------------------------------------------------------------\n\n        if ((flags & ImGuiMultiSelectFlags_NoAutoClear) == 0)\n        {\n            bool request_clear = false;\n            if (is_singleselect)\n                request_clear = true;\n            else if ((input_source == ImGuiInputSource_Mouse || g.NavActivateId == id) && !is_ctrl)\n                request_clear = (flags & ImGuiMultiSelectFlags_NoAutoClearOnReselect) ? !selected : true;\n            else if ((input_source == ImGuiInputSource_Keyboard || input_source == ImGuiInputSource_Gamepad) && is_shift && !is_ctrl)\n                request_clear = true; // With is_shift==false the RequestClear was done in BeginIO, not necessary to do again.\n            if (request_clear)\n                MultiSelectAddSetAll(ms, false);\n        }\n\n        int range_direction;\n        bool range_selected;\n        if (is_shift && !is_singleselect)\n        {\n            //IM_ASSERT(storage->HasRangeSrc && storage->HasRangeValue);\n            if (storage->RangeSrcItem == ImGuiSelectionUserData_Invalid)\n                storage->RangeSrcItem = item_data;\n            if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)\n            {\n                // Shift+Arrow always select\n                // Ctrl+Shift+Arrow copy source selection state (already stored by BeginMultiSelect() in storage->RangeSelected)\n                range_selected = (is_ctrl && storage->RangeSelected != -1) ? (storage->RangeSelected != 0) : true;\n            }\n            else\n            {\n                // Shift+Arrow copy source selection state\n                // Shift+Click always copy from target selection state\n                if (ms->IsKeyboardSetRange)\n                    range_selected = (storage->RangeSelected != -1) ? (storage->RangeSelected != 0) : true;\n                else\n                    range_selected = !selected;\n            }\n            range_direction = ms->RangeSrcPassedBy ? +1 : -1;\n        }\n        else\n        {\n            // Ctrl inverts selection, otherwise always select\n            if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)\n                selected = is_ctrl ? !selected : true;\n            else\n                selected = !selected;\n            storage->RangeSrcItem = item_data;\n            range_selected = selected;\n            range_direction = +1;\n        }\n        MultiSelectAddSetRange(ms, range_selected, range_direction, storage->RangeSrcItem, item_data);\n    }\n\n    // Update/store the selection state of the Source item (used by CTRL+SHIFT, when Source is unselected we perform a range unselect)\n    if (storage->RangeSrcItem == item_data)\n        storage->RangeSelected = selected ? 1 : 0;\n\n    // Update/store the selection state of focused item\n    if (g.NavId == id)\n    {\n        storage->NavIdItem = item_data;\n        storage->NavIdSelected = selected ? 1 : 0;\n    }\n    if (storage->NavIdItem == item_data)\n        ms->NavIdPassedBy = true;\n    ms->LastSubmittedItem = item_data;\n\n    *p_selected = selected;\n    *p_pressed = pressed;\n}\n\nvoid ImGui::MultiSelectAddSetAll(ImGuiMultiSelectTempData* ms, bool selected)\n{\n    ImGuiSelectionRequest req = { ImGuiSelectionRequestType_SetAll, selected, 0, ImGuiSelectionUserData_Invalid, ImGuiSelectionUserData_Invalid };\n    ms->IO.Requests.resize(0);      // Can always clear previous requests\n    ms->IO.Requests.push_back(req); // Add new request\n}\n\nvoid ImGui::MultiSelectAddSetRange(ImGuiMultiSelectTempData* ms, bool selected, int range_dir, ImGuiSelectionUserData first_item, ImGuiSelectionUserData last_item)\n{\n    // Merge contiguous spans into same request (unless NoRangeSelect is set which guarantees single-item ranges)\n    if (ms->IO.Requests.Size > 0 && first_item == last_item && (ms->Flags & ImGuiMultiSelectFlags_NoRangeSelect) == 0)\n    {\n        ImGuiSelectionRequest* prev = &ms->IO.Requests.Data[ms->IO.Requests.Size - 1];\n        if (prev->Type == ImGuiSelectionRequestType_SetRange && prev->RangeLastItem == ms->LastSubmittedItem && prev->Selected == selected)\n        {\n            prev->RangeLastItem = last_item;\n            return;\n        }\n    }\n\n    ImGuiSelectionRequest req = { ImGuiSelectionRequestType_SetRange, selected, (ImS8)range_dir, (range_dir > 0) ? first_item : last_item, (range_dir > 0) ? last_item : first_item };\n    ms->IO.Requests.push_back(req); // Add new request\n}\n\nvoid ImGui::DebugNodeMultiSelectState(ImGuiMultiSelectState* storage)\n{\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n    const bool is_active = (storage->LastFrameActive >= GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.\n    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }\n    bool open = TreeNode((void*)(intptr_t)storage->ID, \"MultiSelect 0x%08X in '%s'%s\", storage->ID, storage->Window ? storage->Window->Name : \"N/A\", is_active ? \"\" : \" *Inactive*\");\n    if (!is_active) { PopStyleColor(); }\n    if (!open)\n        return;\n    Text(\"RangeSrcItem = %\" IM_PRId64 \" (0x%\" IM_PRIX64 \"), RangeSelected = %d\", storage->RangeSrcItem, storage->RangeSrcItem, storage->RangeSelected);\n    Text(\"NavIdItem = %\" IM_PRId64 \" (0x%\" IM_PRIX64 \"), NavIdSelected = %d\", storage->NavIdItem, storage->NavIdItem, storage->NavIdSelected);\n    Text(\"LastSelectionSize = %d\", storage->LastSelectionSize); // Provided by user\n    TreePop();\n#else\n    IM_UNUSED(storage);\n#endif\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Multi-Select helpers\n//-------------------------------------------------------------------------\n// - ImGuiSelectionBasicStorage\n// - ImGuiSelectionExternalStorage\n//-------------------------------------------------------------------------\n\nImGuiSelectionBasicStorage::ImGuiSelectionBasicStorage()\n{\n    Size = 0;\n    PreserveOrder = false;\n    UserData = NULL;\n    AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage*, int idx) { return (ImGuiID)idx; };\n    _SelectionOrder = 1; // Always >0\n}\n\nvoid ImGuiSelectionBasicStorage::Clear()\n{\n    Size = 0;\n    _SelectionOrder = 1; // Always >0\n    _Storage.Data.resize(0);\n}\n\nvoid ImGuiSelectionBasicStorage::Swap(ImGuiSelectionBasicStorage& r)\n{\n    ImSwap(Size, r.Size);\n    ImSwap(_SelectionOrder, r._SelectionOrder);\n    _Storage.Data.swap(r._Storage.Data);\n}\n\nbool ImGuiSelectionBasicStorage::Contains(ImGuiID id) const\n{\n    return _Storage.GetInt(id, 0) != 0;\n}\n\nstatic int IMGUI_CDECL PairComparerByValueInt(const void* lhs, const void* rhs)\n{\n    int lhs_v = ((const ImGuiStoragePair*)lhs)->val_i;\n    int rhs_v = ((const ImGuiStoragePair*)rhs)->val_i;\n    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);\n}\n\n// GetNextSelectedItem() is an abstraction allowing us to change our underlying actual storage system without impacting user.\n// (e.g. store unselected vs compact down, compact down on demand, use raw ImVector<ImGuiID> instead of ImGuiStorage...)\nbool ImGuiSelectionBasicStorage::GetNextSelectedItem(void** opaque_it, ImGuiID* out_id)\n{\n    ImGuiStoragePair* it = (ImGuiStoragePair*)*opaque_it;\n    ImGuiStoragePair* it_end = _Storage.Data.Data + _Storage.Data.Size;\n    if (PreserveOrder && it == NULL && it_end != NULL)\n        ImQsort(_Storage.Data.Data, (size_t)_Storage.Data.Size, sizeof(ImGuiStoragePair), PairComparerByValueInt); // ~ImGuiStorage::BuildSortByValueInt()\n    if (it == NULL)\n        it = _Storage.Data.Data;\n    IM_ASSERT(it >= _Storage.Data.Data && it <= it_end);\n    if (it != it_end)\n        while (it->val_i == 0 && it < it_end)\n            it++;\n    const bool has_more = (it != it_end);\n    *opaque_it = has_more ? (void**)(it + 1) : (void**)(it);\n    *out_id = has_more ? it->key : 0;\n    if (PreserveOrder && !has_more)\n        _Storage.BuildSortByKey();\n    return has_more;\n}\n\nvoid ImGuiSelectionBasicStorage::SetItemSelected(ImGuiID id, bool selected)\n{\n    int* p_int = _Storage.GetIntRef(id, 0);\n    if (selected && *p_int == 0) { *p_int = _SelectionOrder++; Size++; }\n    else if (!selected && *p_int != 0) { *p_int = 0; Size--; }\n}\n\n// Optimized for batch edits (with same value of 'selected')\nstatic void ImGuiSelectionBasicStorage_BatchSetItemSelected(ImGuiSelectionBasicStorage* selection, ImGuiID id, bool selected, int size_before_amends, int selection_order)\n{\n    ImGuiStorage* storage = &selection->_Storage;\n    ImGuiStoragePair* it = ImLowerBound(storage->Data.Data, storage->Data.Data + size_before_amends, id);\n    const bool is_contained = (it != storage->Data.Data + size_before_amends) && (it->key == id);\n    if (selected == (is_contained && it->val_i != 0))\n        return;\n    if (selected && !is_contained)\n        storage->Data.push_back(ImGuiStoragePair(id, selection_order)); // Push unsorted at end of vector, will be sorted in SelectionMultiAmendsFinish()\n    else if (is_contained)\n        it->val_i = selected ? selection_order : 0; // Modify in-place.\n    selection->Size += selected ? +1 : -1;\n}\n\nstatic void ImGuiSelectionBasicStorage_BatchFinish(ImGuiSelectionBasicStorage* selection, bool selected, int size_before_amends)\n{\n    ImGuiStorage* storage = &selection->_Storage;\n    if (selected && selection->Size != size_before_amends)\n        storage->BuildSortByKey(); // When done selecting: sort everything\n}\n\n// Apply requests coming from BeginMultiSelect() and EndMultiSelect().\n// - Enable 'Demo->Tools->Debug Log->Selection' to see selection requests as they happen.\n// - Honoring SetRange requests requires that you can iterate/interpolate between RangeFirstItem and RangeLastItem.\n//   - In this demo we often submit indices to SetNextItemSelectionUserData() + store the same indices in persistent selection.\n//   - Your code may do differently. If you store pointers or objects ID in ImGuiSelectionUserData you may need to perform\n//     a lookup in order to have some way to iterate/interpolate between two items.\n// - A full-featured application is likely to allow search/filtering which is likely to lead to using indices\n//   and constructing a view index <> object id/ptr data structure anyway.\n// WHEN YOUR APPLICATION SETTLES ON A CHOICE, YOU WILL PROBABLY PREFER TO GET RID OF THIS UNNECESSARY 'ImGuiSelectionBasicStorage' INDIRECTION LOGIC.\n// Notice that with the simplest adapter (using indices everywhere), all functions return their parameters.\n// The most simple implementation (using indices everywhere) would look like:\n//   for (ImGuiSelectionRequest& req : ms_io->Requests)\n//   {\n//      if (req.Type == ImGuiSelectionRequestType_SetAll)    { Clear(); if (req.Selected) { for (int n = 0; n < items_count; n++) { SetItemSelected(n, true); } }\n//      if (req.Type == ImGuiSelectionRequestType_SetRange)  { for (int n = (int)ms_io->RangeFirstItem; n <= (int)ms_io->RangeLastItem; n++) { SetItemSelected(n, ms_io->Selected); } }\n//   }\nvoid ImGuiSelectionBasicStorage::ApplyRequests(ImGuiMultiSelectIO* ms_io)\n{\n    // For convenience we obtain ItemsCount as passed to BeginMultiSelect(), which is optional.\n    // It makes sense when using ImGuiSelectionBasicStorage to simply pass your items count to BeginMultiSelect().\n    // Other scheme may handle SetAll differently.\n    IM_ASSERT(ms_io->ItemsCount != -1 && \"Missing value for items_count in BeginMultiSelect() call!\");\n    IM_ASSERT(AdapterIndexToStorageId != NULL);\n\n    // This is optimized/specialized to cope with very large selections (e.g. 100k+ items)\n    // - A simpler version could call SetItemSelected() directly instead of ImGuiSelectionBasicStorage_BatchSetItemSelected() + ImGuiSelectionBasicStorage_BatchFinish().\n    // - Optimized select can append unsorted, then sort in a second pass. Optimized unselect can clear in-place then compact in a second pass.\n    // - A more optimal version wouldn't even use ImGuiStorage but directly a ImVector<ImGuiID> to reduce bandwidth, but this is a reasonable trade off to reuse code.\n    // - There are many ways this could be better optimized. The worse case scenario being: using BoxSelect2d in a grid, box-select scrolling down while wiggling\n    //   left and right: it affects coarse clipping + can emit multiple SetRange with 1 item each.)\n    // FIXME-OPT: For each block of consecutive SetRange request:\n    // - add all requests to a sorted list, store ID, selected, offset in ImGuiStorage.\n    // - rewrite sorted storage a single time.\n    for (ImGuiSelectionRequest& req : ms_io->Requests)\n    {\n        if (req.Type == ImGuiSelectionRequestType_SetAll)\n        {\n            Clear();\n            if (req.Selected)\n            {\n                _Storage.Data.reserve(ms_io->ItemsCount);\n                const int size_before_amends = _Storage.Data.Size;\n                for (int idx = 0; idx < ms_io->ItemsCount; idx++, _SelectionOrder++)\n                    ImGuiSelectionBasicStorage_BatchSetItemSelected(this, GetStorageIdFromIndex(idx), req.Selected, size_before_amends, _SelectionOrder);\n                ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends);\n            }\n        }\n        else if (req.Type == ImGuiSelectionRequestType_SetRange)\n        {\n            const int selection_changes = (int)req.RangeLastItem - (int)req.RangeFirstItem + 1;\n            //ImGuiContext& g = *GImGui; IMGUI_DEBUG_LOG_SELECTION(\"Req %d/%d: set %d to %d\\n\", ms_io->Requests.index_from_ptr(&req), ms_io->Requests.Size, selection_changes, req.Selected);\n            if (selection_changes == 1 || (selection_changes < Size / 100))\n            {\n                // Multiple sorted insertion + copy likely to be faster.\n                // Technically we could do a single copy with a little more work (sort sequential SetRange requests)\n                for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++)\n                    SetItemSelected(GetStorageIdFromIndex(idx), req.Selected);\n            }\n            else\n            {\n                // Append insertion + single sort likely be faster.\n                // Use req.RangeDirection to set order field so that shift+clicking from 1 to 5 is different than shift+clicking from 5 to 1\n                const int size_before_amends = _Storage.Data.Size;\n                int selection_order = _SelectionOrder + ((req.RangeDirection < 0) ? selection_changes - 1 : 0);\n                for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++, selection_order += req.RangeDirection)\n                    ImGuiSelectionBasicStorage_BatchSetItemSelected(this, GetStorageIdFromIndex(idx), req.Selected, size_before_amends, selection_order);\n                if (req.Selected)\n                    _SelectionOrder += selection_changes;\n                ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends);\n            }\n        }\n    }\n}\n\n//-------------------------------------------------------------------------\n\nImGuiSelectionExternalStorage::ImGuiSelectionExternalStorage()\n{\n    UserData = NULL;\n    AdapterSetItemSelected = NULL;\n}\n\n// Apply requests coming from BeginMultiSelect() and EndMultiSelect().\n// We also pull 'ms_io->ItemsCount' as passed for BeginMultiSelect() for consistency with ImGuiSelectionBasicStorage\n// This makes no assumption about underlying storage.\nvoid ImGuiSelectionExternalStorage::ApplyRequests(ImGuiMultiSelectIO* ms_io)\n{\n    IM_ASSERT(AdapterSetItemSelected);\n    for (ImGuiSelectionRequest& req : ms_io->Requests)\n    {\n        if (req.Type == ImGuiSelectionRequestType_SetAll)\n            for (int idx = 0; idx < ms_io->ItemsCount; idx++)\n                AdapterSetItemSelected(this, idx, req.Selected);\n        if (req.Type == ImGuiSelectionRequestType_SetRange)\n            for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++)\n                AdapterSetItemSelected(this, idx, req.Selected);\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: ListBox\n//-------------------------------------------------------------------------\n// - BeginListBox()\n// - EndListBox()\n// - ListBox()\n//-------------------------------------------------------------------------\n\n// This is essentially a thin wrapper to using BeginChild/EndChild with the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.\n// This handle some subtleties with capturing info from the label.\n// If you don't need a label you can pretty much directly use ImGui::BeginChild() with ImGuiChildFlags_FrameStyle.\n// Tip: To have a list filling the entire window width, use size.x = -FLT_MIN and pass an non-visible label e.g. \"##empty\"\n// Tip: If your vertical size is calculated from an item count (e.g. 10 * item_height) consider adding a fractional part to facilitate seeing scrolling boundaries (e.g. 10.5f * item_height).\nbool ImGui::BeginListBox(const char* label, const ImVec2& size_arg)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = GetID(label);\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    // Size default to hold ~7.25 items.\n    // Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.\n    ImVec2 size = ImTrunc(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));\n    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));\n    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);\n    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\n    g.NextItemData.ClearFlags();\n\n    if (!IsRectVisible(bb.Min, bb.Max))\n    {\n        ItemSize(bb.GetSize(), style.FramePadding.y);\n        ItemAdd(bb, 0, &frame_bb);\n        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values\n        return false;\n    }\n\n    // FIXME-OPT: We could omit the BeginGroup() if label_size.x == 0.0f but would need to omit the EndGroup() as well.\n    BeginGroup();\n    if (label_size.x > 0.0f)\n    {\n        ImVec2 label_pos = ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y);\n        RenderText(label_pos, label);\n        window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, label_pos + label_size);\n        AlignTextToFramePadding();\n    }\n\n    BeginChild(id, frame_bb.GetSize(), ImGuiChildFlags_FrameStyle);\n    return true;\n}\n\nvoid ImGui::EndListBox()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) && \"Mismatched BeginListBox/EndListBox calls. Did you test the return value of BeginListBox?\");\n    IM_UNUSED(window);\n\n    EndChild();\n    EndGroup(); // This is only required to be able to do IsItemXXX query on the whole ListBox including label\n}\n\nbool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)\n{\n    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);\n    return value_changed;\n}\n\n// This is merely a helper around BeginListBox(), EndListBox().\n// Considering using those directly to submit custom data or store selection differently.\nbool ImGui::ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int height_in_items)\n{\n    ImGuiContext& g = *GImGui;\n\n    // Calculate size from \"height_in_items\"\n    if (height_in_items < 0)\n        height_in_items = ImMin(items_count, 7);\n    float height_in_items_f = height_in_items + 0.25f;\n    ImVec2 size(0.0f, ImTrunc(GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0f));\n\n    if (!BeginListBox(label, size))\n        return false;\n\n    // Assume all items have even height (= 1 line of text). If you need items of different height,\n    // you can create a custom version of ListBox() in your code without using the clipper.\n    bool value_changed = false;\n    ImGuiListClipper clipper;\n    clipper.Begin(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.\n    clipper.IncludeItemByIndex(*current_item);\n    while (clipper.Step())\n        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n        {\n            const char* item_text = getter(user_data, i);\n            if (item_text == NULL)\n                item_text = \"*Unknown item*\";\n\n            PushID(i);\n            const bool item_selected = (i == *current_item);\n            if (Selectable(item_text, item_selected))\n            {\n                *current_item = i;\n                value_changed = true;\n            }\n            if (item_selected)\n                SetItemDefaultFocus();\n            PopID();\n        }\n    EndListBox();\n\n    if (value_changed)\n        MarkItemEdited(g.LastItemData.ID);\n\n    return value_changed;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: PlotLines, PlotHistogram\n//-------------------------------------------------------------------------\n// - PlotEx() [Internal]\n// - PlotLines()\n// - PlotHistogram()\n//-------------------------------------------------------------------------\n// Plot/Graph widgets are not very good.\n// Consider writing your own, or using a third-party one, see:\n// - ImPlot https://github.com/epezent/implot\n// - others https://github.com/ocornut/imgui/wiki/Useful-Extensions\n//-------------------------------------------------------------------------\n\nint ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, const ImVec2& size_arg)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return -1;\n\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\n    const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), label_size.y + style.FramePadding.y * 2.0f);\n\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);\n    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));\n    ItemSize(total_bb, style.FramePadding.y);\n    if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_NoNav))\n        return -1;\n    bool hovered;\n    ButtonBehavior(frame_bb, id, &hovered, NULL);\n\n    // Determine scale from values if not specified\n    if (scale_min == FLT_MAX || scale_max == FLT_MAX)\n    {\n        float v_min = FLT_MAX;\n        float v_max = -FLT_MAX;\n        for (int i = 0; i < values_count; i++)\n        {\n            const float v = values_getter(data, i);\n            if (v != v) // Ignore NaN values\n                continue;\n            v_min = ImMin(v_min, v);\n            v_max = ImMax(v_max, v);\n        }\n        if (scale_min == FLT_MAX)\n            scale_min = v_min;\n        if (scale_max == FLT_MAX)\n            scale_max = v_max;\n    }\n\n    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\n\n    const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;\n    int idx_hovered = -1;\n    if (values_count >= values_count_min)\n    {\n        int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);\n        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);\n\n        // Tooltip on hover\n        if (hovered && inner_bb.Contains(g.IO.MousePos))\n        {\n            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);\n            const int v_idx = (int)(t * item_count);\n            IM_ASSERT(v_idx >= 0 && v_idx < values_count);\n\n            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);\n            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);\n            if (plot_type == ImGuiPlotType_Lines)\n                SetTooltip(\"%d: %8.4g\\n%d: %8.4g\", v_idx, v0, v_idx + 1, v1);\n            else if (plot_type == ImGuiPlotType_Histogram)\n                SetTooltip(\"%d: %8.4g\", v_idx, v0);\n            idx_hovered = v_idx;\n        }\n\n        const float t_step = 1.0f / (float)res_w;\n        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));\n\n        float v0 = values_getter(data, (0 + values_offset) % values_count);\n        float t0 = 0.0f;\n        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle\n        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (1 + scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands\n\n        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);\n        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);\n\n        for (int n = 0; n < res_w; n++)\n        {\n            const float t1 = t0 + t_step;\n            const int v1_idx = (int)(t0 * item_count + 0.5f);\n            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);\n            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);\n            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );\n\n            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.\n            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);\n            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));\n            if (plot_type == ImGuiPlotType_Lines)\n            {\n                window->DrawList->AddLine(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);\n            }\n            else if (plot_type == ImGuiPlotType_Histogram)\n            {\n                if (pos1.x >= pos0.x + 2.0f)\n                    pos1.x -= 1.0f;\n                window->DrawList->AddRectFilled(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);\n            }\n\n            t0 = t1;\n            tp0 = tp1;\n        }\n    }\n\n    // Text overlay\n    if (overlay_text)\n        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f, 0.0f));\n\n    if (label_size.x > 0.0f)\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);\n\n    // Return hovered index or -1 if none are hovered.\n    // This is currently not exposed in the public API because we need a larger redesign of the whole thing, but in the short-term we are making it available in PlotEx().\n    return idx_hovered;\n}\n\nstruct ImGuiPlotArrayGetterData\n{\n    const float* Values;\n    int Stride;\n\n    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }\n};\n\nstatic float Plot_ArrayGetter(void* data, int idx)\n{\n    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;\n    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);\n    return v;\n}\n\nvoid ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)\n{\n    ImGuiPlotArrayGetterData data(values, stride);\n    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\n}\n\nvoid ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\n{\n    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\n}\n\nvoid ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)\n{\n    ImGuiPlotArrayGetterData data(values, stride);\n    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\n}\n\nvoid ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\n{\n    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: Value helpers\n// Those is not very useful, legacy API.\n//-------------------------------------------------------------------------\n// - Value()\n//-------------------------------------------------------------------------\n\nvoid ImGui::Value(const char* prefix, bool b)\n{\n    Text(\"%s: %s\", prefix, (b ? \"true\" : \"false\"));\n}\n\nvoid ImGui::Value(const char* prefix, int v)\n{\n    Text(\"%s: %d\", prefix, v);\n}\n\nvoid ImGui::Value(const char* prefix, unsigned int v)\n{\n    Text(\"%s: %d\", prefix, v);\n}\n\nvoid ImGui::Value(const char* prefix, float v, const char* float_format)\n{\n    if (float_format)\n    {\n        char fmt[64];\n        ImFormatString(fmt, IM_ARRAYSIZE(fmt), \"%%s: %s\", float_format);\n        Text(fmt, prefix, v);\n    }\n    else\n    {\n        Text(\"%s: %.3f\", prefix, v);\n    }\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] MenuItem, BeginMenu, EndMenu, etc.\n//-------------------------------------------------------------------------\n// - ImGuiMenuColumns [Internal]\n// - BeginMenuBar()\n// - EndMenuBar()\n// - BeginMainMenuBar()\n// - EndMainMenuBar()\n// - BeginMenu()\n// - EndMenu()\n// - MenuItemEx() [Internal]\n// - MenuItem()\n//-------------------------------------------------------------------------\n\n// Helpers for internal use\nvoid ImGuiMenuColumns::Update(float spacing, bool window_reappearing)\n{\n    if (window_reappearing)\n        memset(Widths, 0, sizeof(Widths));\n    Spacing = (ImU16)spacing;\n    CalcNextTotalWidth(true);\n    memset(Widths, 0, sizeof(Widths));\n    TotalWidth = NextTotalWidth;\n    NextTotalWidth = 0;\n}\n\nvoid ImGuiMenuColumns::CalcNextTotalWidth(bool update_offsets)\n{\n    ImU16 offset = 0;\n    bool want_spacing = false;\n    for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)\n    {\n        ImU16 width = Widths[i];\n        if (want_spacing && width > 0)\n            offset += Spacing;\n        want_spacing |= (width > 0);\n        if (update_offsets)\n        {\n            if (i == 1) { OffsetLabel = offset; }\n            if (i == 2) { OffsetShortcut = offset; }\n            if (i == 3) { OffsetMark = offset; }\n        }\n        offset += width;\n    }\n    NextTotalWidth = offset;\n}\n\nfloat ImGuiMenuColumns::DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark)\n{\n    Widths[0] = ImMax(Widths[0], (ImU16)w_icon);\n    Widths[1] = ImMax(Widths[1], (ImU16)w_label);\n    Widths[2] = ImMax(Widths[2], (ImU16)w_shortcut);\n    Widths[3] = ImMax(Widths[3], (ImU16)w_mark);\n    CalcNextTotalWidth(false);\n    return (float)ImMax(TotalWidth, NextTotalWidth);\n}\n\n// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used anywhere..\n// Currently the main responsibility of this function being to setup clip-rect + horizontal layout + menu navigation layer.\n// Ideally we also want this to be responsible for claiming space out of the main window scrolling rectangle, in which case ImGuiWindowFlags_MenuBar will become unnecessary.\n// Then later the same system could be used for multiple menu-bars, scrollbars, side-bars.\nbool ImGui::BeginMenuBar()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n    if (!(window->Flags & ImGuiWindowFlags_MenuBar))\n        return false;\n\n    IM_ASSERT(!window->DC.MenuBarAppending);\n    BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore\n    PushID(\"##menubar\");\n\n    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.\n    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.\n    ImRect bar_rect = window->MenuBarRect();\n    ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));\n    clip_rect.ClipWith(window->OuterRectClipped);\n    PushClipRect(clip_rect.Min, clip_rect.Max, false);\n\n    // We overwrite CursorMaxPos because BeginGroup sets it to CursorPos (essentially the .EmitItem hack in EndMenuBar() would need something analogous here, maybe a BeginGroupEx() with flags).\n    window->DC.CursorPos = window->DC.CursorMaxPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);\n    window->DC.LayoutType = ImGuiLayoutType_Horizontal;\n    window->DC.IsSameLine = false;\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;\n    window->DC.MenuBarAppending = true;\n    AlignTextToFramePadding();\n    return true;\n}\n\nvoid ImGui::EndMenuBar()\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return;\n    ImGuiContext& g = *GImGui;\n\n    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.\n    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))\n    {\n        // Try to find out if the request is for one of our child menu\n        ImGuiWindow* nav_earliest_child = g.NavWindow;\n        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))\n            nav_earliest_child = nav_earliest_child->ParentWindow;\n        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)\n        {\n            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.\n            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth bothering)\n            const ImGuiNavLayer layer = ImGuiNavLayer_Menu;\n            IM_ASSERT(window->DC.NavLayersActiveMaskNext & (1 << layer)); // Sanity check (FIXME: Seems unnecessary)\n            FocusWindow(window);\n            SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);\n            // FIXME-NAV: How to deal with this when not using g.IO.ConfigNavCursorVisibleAuto?\n            if (g.NavCursorVisible)\n            {\n                g.NavCursorVisible = false; // Hide nav cursor for the current frame so we don't see the intermediary selection. Will be set again\n                g.NavCursorHideFrames = 2;\n            }\n            g.NavHighlightItemUnderNav = g.NavMousePosDirty = true;\n            NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags); // Repeat\n        }\n    }\n\n    IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive \"warning C6011: Dereferencing NULL pointer 'window'\"\n    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);\n    IM_ASSERT(window->DC.MenuBarAppending);\n    PopClipRect();\n    PopID();\n    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->Pos.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.\n\n    // FIXME: Extremely confusing, cleanup by (a) working on WorkRect stack system (b) not using a Group confusingly here.\n    ImGuiGroupData& group_data = g.GroupStack.back();\n    group_data.EmitItem = false;\n    ImVec2 restore_cursor_max_pos = group_data.BackupCursorMaxPos;\n    window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, window->DC.CursorMaxPos.x - window->Scroll.x); // Convert ideal extents for scrolling layer equivalent.\n    EndGroup(); // Restore position on layer 0 // FIXME: Misleading to use a group for that backup/restore\n    window->DC.LayoutType = ImGuiLayoutType_Vertical;\n    window->DC.IsSameLine = false;\n    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;\n    window->DC.MenuBarAppending = false;\n    window->DC.CursorMaxPos = restore_cursor_max_pos;\n}\n\n// Important: calling order matters!\n// FIXME: Somehow overlapping with docking tech.\n// FIXME: The \"rect-cut\" aspect of this could be formalized into a lower-level helper (rect-cut: https://halt.software/dead-simple-layouts)\nbool ImGui::BeginViewportSideBar(const char* name, ImGuiViewport* viewport_p, ImGuiDir dir, float axis_size, ImGuiWindowFlags window_flags)\n{\n    IM_ASSERT(dir != ImGuiDir_None);\n\n    ImGuiWindow* bar_window = FindWindowByName(name);\n    if (bar_window == NULL || bar_window->BeginCount == 0)\n    {\n        // Calculate and set window size/position\n        ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)(viewport_p ? viewport_p : GetMainViewport());\n        ImRect avail_rect = viewport->GetBuildWorkRect();\n        ImGuiAxis axis = (dir == ImGuiDir_Up || dir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;\n        ImVec2 pos = avail_rect.Min;\n        if (dir == ImGuiDir_Right || dir == ImGuiDir_Down)\n            pos[axis] = avail_rect.Max[axis] - axis_size;\n        ImVec2 size = avail_rect.GetSize();\n        size[axis] = axis_size;\n        SetNextWindowPos(pos);\n        SetNextWindowSize(size);\n\n        // Report our size into work area (for next frame) using actual window size\n        if (dir == ImGuiDir_Up || dir == ImGuiDir_Left)\n            viewport->BuildWorkInsetMin[axis] += axis_size;\n        else if (dir == ImGuiDir_Down || dir == ImGuiDir_Right)\n            viewport->BuildWorkInsetMax[axis] += axis_size;\n    }\n\n    window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;\n    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);\n    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0)); // Lift normal size constraint\n    bool is_open = Begin(name, NULL, window_flags);\n    PopStyleVar(2);\n\n    return is_open;\n}\n\nbool ImGui::BeginMainMenuBar()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)GetMainViewport();\n\n    // For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.\n    // FIXME: This could be generalized as an opt-in way to clamp window->DC.CursorStartPos to avoid SafeArea?\n    // FIXME: Consider removing support for safe area down the line... it's messy. Nowadays consoles have support for TV calibration in OS settings.\n    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;\n    float height = GetFrameHeight();\n    bool is_open = BeginViewportSideBar(\"##MainMenuBar\", viewport, ImGuiDir_Up, height, window_flags);\n    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);\n\n    if (is_open)\n        BeginMenuBar();\n    else\n        End();\n    return is_open;\n}\n\nvoid ImGui::EndMainMenuBar()\n{\n    EndMenuBar();\n\n    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window\n    // FIXME: With this strategy we won't be able to restore a NULL focus.\n    ImGuiContext& g = *GImGui;\n    if (g.CurrentWindow == g.NavWindow && g.NavLayer == ImGuiNavLayer_Main && !g.NavAnyRequest)\n        FocusTopMostWindowUnderOne(g.NavWindow, NULL, NULL, ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild);\n\n    End();\n}\n\nstatic bool IsRootOfOpenMenuSet()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if ((g.OpenPopupStack.Size <= g.BeginPopupStack.Size) || (window->Flags & ImGuiWindowFlags_ChildMenu))\n        return false;\n\n    // Initially we used 'upper_popup->OpenParentId == window->IDStack.back()' to differentiate multiple menu sets from each others\n    // (e.g. inside menu bar vs loose menu items) based on parent ID.\n    // This would however prevent the use of e.g. PushID() user code submitting menus.\n    // Previously this worked between popup and a first child menu because the first child menu always had the _ChildWindow flag,\n    // making hovering on parent popup possible while first child menu was focused - but this was generally a bug with other side effects.\n    // Instead we don't treat Popup specifically (in order to consistently support menu features in them), maybe the first child menu of a Popup\n    // doesn't have the _ChildWindow flag, and we rely on this IsRootOfOpenMenuSet() check to allow hovering between root window/popup and first child menu.\n    // In the end, lack of ID check made it so we could no longer differentiate between separate menu sets. To compensate for that, we at least check parent window nav layer.\n    // This fixes the most common case of menu opening on hover when moving between window content and menu bar. Multiple different menu sets in same nav layer would still\n    // open on hover, but that should be a lesser problem, because if such menus are close in proximity in window content then it won't feel weird and if they are far apart\n    // it likely won't be a problem anyone runs into.\n    const ImGuiPopupData* upper_popup = &g.OpenPopupStack[g.BeginPopupStack.Size];\n    if (window->DC.NavLayerCurrent != upper_popup->ParentNavLayer)\n        return false;\n    return upper_popup->Window && (upper_popup->Window->Flags & ImGuiWindowFlags_ChildMenu) && ImGui::IsWindowChildOf(upper_popup->Window, window, true);\n}\n\nbool ImGui::BeginMenuEx(const char* label, const char* icon, bool enabled)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = window->GetID(label);\n    bool menu_is_open = IsPopupOpen(id, ImGuiPopupFlags_None);\n\n    // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)\n    // The first menu in a hierarchy isn't so hovering doesn't get across (otherwise e.g. resizing borders with ImGuiButtonFlags_FlattenChildren would react), but top-most BeginMenu() will bypass that limitation.\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;\n    if (window->Flags & ImGuiWindowFlags_ChildMenu)\n        window_flags |= ImGuiWindowFlags_ChildWindow;\n\n    // If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().\n    // We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.\n    // If somehow this is ever becoming a problem we can switch to use e.g. ImGuiStorage mapping key to last frame used.\n    if (g.MenusIdSubmittedThisFrame.contains(id))\n    {\n        if (menu_is_open)\n            menu_is_open = BeginPopupEx(id, window_flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)\n        else\n            g.NextWindowData.ClearFlags();          // we behave like Begin() and need to consume those values\n        return menu_is_open;\n    }\n\n    // Tag menu as used. Next time BeginMenu() with same ID is called it will append to existing menu\n    g.MenusIdSubmittedThisFrame.push_back(id);\n\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent without always being a Child window)\n    // This is only done for items for the menu set and not the full parent window.\n    const bool menuset_is_open = IsRootOfOpenMenuSet();\n    if (menuset_is_open)\n        PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);\n\n    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,\n    // However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().\n    // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.\n    ImVec2 popup_pos, pos = window->DC.CursorPos;\n    PushID(label);\n    if (!enabled)\n        BeginDisabled();\n    const ImGuiMenuColumns* offsets = &window->DC.MenuColumns;\n    bool pressed;\n\n    // We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.\n    const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_NoAutoClosePopups;\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\n    {\n        // Menu inside an horizontal menu bar\n        // Selectable extend their highlight by half ItemSpacing in each direction.\n        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()\n        popup_pos = ImVec2(pos.x - 1.0f - IM_TRUNC(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight);\n        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5f);\n        PushStyleVarX(ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0f);\n        float w = label_size.x;\n        ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);\n        pressed = Selectable(\"\", menu_is_open, selectable_flags, ImVec2(w, label_size.y));\n        LogSetNextTextDecoration(\"[\", \"]\");\n        RenderText(text_pos, label);\n        PopStyleVar();\n        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().\n    }\n    else\n    {\n        // Menu inside a regular/vertical menu\n        // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.\n        //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.\n        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);\n        float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;\n        float checkmark_w = IM_TRUNC(g.FontSize * 1.20f);\n        float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame\n        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);\n        ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);\n        pressed = Selectable(\"\", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));\n        LogSetNextTextDecoration(\"\", \">\");\n        RenderText(text_pos, label);\n        if (icon_w > 0.0f)\n            RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);\n        RenderArrow(window->DrawList, pos + ImVec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);\n    }\n    if (!enabled)\n        EndDisabled();\n\n    const bool hovered = (g.HoveredId == id) && enabled && !g.NavHighlightItemUnderNav;\n    if (menuset_is_open)\n        PopItemFlag();\n\n    bool want_open = false;\n    bool want_open_nav_init = false;\n    bool want_close = false;\n    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))\n    {\n        // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu\n        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.\n        bool moving_toward_child_menu = false;\n        ImGuiPopupData* child_popup = (g.BeginPopupStack.Size < g.OpenPopupStack.Size) ? &g.OpenPopupStack[g.BeginPopupStack.Size] : NULL; // Popup candidate (testing below)\n        ImGuiWindow* child_menu_window = (child_popup && child_popup->Window && child_popup->Window->ParentWindow == window) ? child_popup->Window : NULL;\n        if (g.HoveredWindow == window && child_menu_window != NULL)\n        {\n            const float ref_unit = g.FontSize; // FIXME-DPI\n            const float child_dir = (window->Pos.x < child_menu_window->Pos.x) ? 1.0f : -1.0f;\n            const ImRect next_window_rect = child_menu_window->Rect();\n            ImVec2 ta = (g.IO.MousePos - g.IO.MouseDelta);\n            ImVec2 tb = (child_dir > 0.0f) ? next_window_rect.GetTL() : next_window_rect.GetTR();\n            ImVec2 tc = (child_dir > 0.0f) ? next_window_rect.GetBL() : next_window_rect.GetBR();\n            const float pad_farmost_h = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f); // Add a bit of extra slack.\n            ta.x += child_dir * -0.5f;\n            tb.x += child_dir * ref_unit;\n            tc.x += child_dir * ref_unit;\n            tb.y = ta.y + ImMax((tb.y - pad_farmost_h) - ta.y, -ref_unit * 8.0f); // Triangle has maximum height to limit the slope and the bias toward large sub-menus\n            tc.y = ta.y + ImMin((tc.y + pad_farmost_h) - ta.y, +ref_unit * 8.0f);\n            moving_toward_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);\n            //GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_toward_child_menu ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]\n        }\n\n        // The 'HovereWindow == window' check creates an inconsistency (e.g. moving away from menu slowly tends to hit same window, whereas moving away fast does not)\n        // But we also need to not close the top-menu menu when moving over void. Perhaps we should extend the triangle check to a larger polygon.\n        // (Remember to test this on BeginPopup(\"A\")->BeginMenu(\"B\") sequence which behaves slightly differently as B isn't a Child of A and hovering isn't shared.)\n        if (menu_is_open && !hovered && g.HoveredWindow == window && !moving_toward_child_menu && !g.NavHighlightItemUnderNav && g.ActiveId == 0)\n            want_close = true;\n\n        // Open\n        // (note: at this point 'hovered' actually includes the NavDisableMouseHover == false test)\n        if (!menu_is_open && pressed) // Click/activate to open\n            want_open = true;\n        else if (!menu_is_open && hovered && !moving_toward_child_menu) // Hover to open\n            want_open = true;\n        else if (!menu_is_open && hovered && g.HoveredIdTimer >= 0.30f && g.MouseStationaryTimer >= 0.30f) // Hover to open (timer fallback)\n            want_open = true;\n        if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open\n        {\n            want_open = want_open_nav_init = true;\n            NavMoveRequestCancel();\n            SetNavCursorVisibleAfterMove();\n        }\n    }\n    else\n    {\n        // Menu bar\n        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it\n        {\n            want_close = true;\n            want_open = menu_is_open = false;\n        }\n        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others\n        {\n            want_open = true;\n        }\n        else if (g.NavId == id && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open\n        {\n            want_open = true;\n            NavMoveRequestCancel();\n        }\n    }\n\n    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu(\"options\", has_object)) { ..use object.. }'\n        want_close = true;\n    if (want_close && IsPopupOpen(id, ImGuiPopupFlags_None))\n        ClosePopupToLevel(g.BeginPopupStack.Size, true);\n\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));\n    PopID();\n\n    if (want_open && !menu_is_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)\n    {\n        // Don't reopen/recycle same menu level in the same frame if it is a different menu ID, first close the other menu and yield for a frame.\n        OpenPopup(label);\n    }\n    else if (want_open)\n    {\n        menu_is_open = true;\n        OpenPopup(label, ImGuiPopupFlags_NoReopen);// | (want_open_nav_init ? ImGuiPopupFlags_NoReopenAlwaysNavInit : 0));\n    }\n\n    if (menu_is_open)\n    {\n        ImGuiLastItemData last_item_in_parent = g.LastItemData;\n        SetNextWindowPos(popup_pos, ImGuiCond_Always);                  // Note: misleading: the value will serve as reference for FindBestWindowPosForPopup(), not actual pos.\n        PushStyleVar(ImGuiStyleVar_ChildRounding, style.PopupRounding); // First level will use _PopupRounding, subsequent will use _ChildRounding\n        menu_is_open = BeginPopupEx(id, window_flags);                  // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)\n        PopStyleVar();\n        if (menu_is_open)\n        {\n            // Implement what ImGuiPopupFlags_NoReopenAlwaysNavInit would do:\n            // Perform an init request in the case the popup was already open (via a previous mouse hover)\n            if (want_open && want_open_nav_init && !g.NavInitRequest)\n            {\n                FocusWindow(g.CurrentWindow, ImGuiFocusRequestFlags_UnlessBelowModal);\n                NavInitWindow(g.CurrentWindow, false);\n            }\n\n            // Restore LastItemData so IsItemXXXX functions can work after BeginMenu()/EndMenu()\n            // (This fixes using IsItemClicked() and IsItemHovered(), but IsItemHovered() also relies on its support for ImGuiItemFlags_NoWindowHoverableCheck)\n            g.LastItemData = last_item_in_parent;\n            if (g.HoveredWindow == window)\n                g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;\n        }\n    }\n    else\n    {\n        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values\n    }\n\n    return menu_is_open;\n}\n\nbool ImGui::BeginMenu(const char* label, bool enabled)\n{\n    return BeginMenuEx(label, NULL, enabled);\n}\n\nvoid ImGui::EndMenu()\n{\n    // Nav: When a left move request our menu failed, close ourselves.\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginMenu()/EndMenu() calls\n    ImGuiWindow* parent_window = window->ParentWindow;  // Should always be != NULL is we passed assert.\n    if (window->BeginCount == window->BeginCountPreviousFrame)\n        if (g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet())\n            if (g.NavWindow && (g.NavWindow->RootWindowForNav == window) && parent_window->DC.LayoutType == ImGuiLayoutType_Vertical)\n            {\n                ClosePopupToLevel(g.BeginPopupStack.Size - 1, true);\n                NavMoveRequestCancel();\n            }\n\n    EndPopup();\n}\n\nbool ImGui::MenuItemEx(const char* label, const char* icon, const char* shortcut, bool selected, bool enabled)\n{\n    ImGuiWindow* window = GetCurrentWindow();\n    if (window->SkipItems)\n        return false;\n\n    ImGuiContext& g = *GImGui;\n    ImGuiStyle& style = g.Style;\n    ImVec2 pos = window->DC.CursorPos;\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    // See BeginMenuEx() for comments about this.\n    const bool menuset_is_open = IsRootOfOpenMenuSet();\n    if (menuset_is_open)\n        PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);\n\n    // We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),\n    // but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.\n    bool pressed;\n    PushID(label);\n    if (!enabled)\n        BeginDisabled();\n\n    // We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.\n    const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SetNavIdOnHover;\n    const ImGuiMenuColumns* offsets = &window->DC.MenuColumns;\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\n    {\n        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful\n        // Note that in this situation: we don't render the shortcut, we render a highlight instead of the selected tick mark.\n        float w = label_size.x;\n        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5f);\n        ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);\n        PushStyleVarX(ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0f);\n        pressed = Selectable(\"\", selected, selectable_flags, ImVec2(w, 0.0f));\n        PopStyleVar();\n        if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)\n            RenderText(text_pos, label);\n        window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().\n    }\n    else\n    {\n        // Menu item inside a vertical menu\n        // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.\n        //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.\n        float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;\n        float shortcut_w = (shortcut && shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;\n        float checkmark_w = IM_TRUNC(g.FontSize * 1.20f);\n        float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame\n        float stretch_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);\n        pressed = Selectable(\"\", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));\n        if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)\n        {\n            RenderText(pos + ImVec2(offsets->OffsetLabel, 0.0f), label);\n            if (icon_w > 0.0f)\n                RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);\n            if (shortcut_w > 0.0f)\n            {\n                PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);\n                LogSetNextTextDecoration(\"(\", \")\");\n                RenderText(pos + ImVec2(offsets->OffsetShortcut + stretch_w, 0.0f), shortcut, NULL, false);\n                PopStyleColor();\n            }\n            if (selected)\n                RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);\n        }\n    }\n    IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));\n    if (!enabled)\n        EndDisabled();\n    PopID();\n    if (menuset_is_open)\n        PopItemFlag();\n\n    return pressed;\n}\n\nbool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)\n{\n    return MenuItemEx(label, NULL, shortcut, selected, enabled);\n}\n\nbool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)\n{\n    if (MenuItemEx(label, NULL, shortcut, p_selected ? *p_selected : false, enabled))\n    {\n        if (p_selected)\n            *p_selected = !*p_selected;\n        return true;\n    }\n    return false;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n//-------------------------------------------------------------------------\n// - BeginTabBar()\n// - BeginTabBarEx() [Internal]\n// - EndTabBar()\n// - TabBarLayout() [Internal]\n// - TabBarCalcTabID() [Internal]\n// - TabBarCalcMaxTabWidth() [Internal]\n// - TabBarFindTabById() [Internal]\n// - TabBarFindTabByOrder() [Internal]\n// - TabBarGetCurrentTab() [Internal]\n// - TabBarGetTabName() [Internal]\n// - TabBarRemoveTab() [Internal]\n// - TabBarCloseTab() [Internal]\n// - TabBarScrollClamp() [Internal]\n// - TabBarScrollToTab() [Internal]\n// - TabBarQueueFocus() [Internal]\n// - TabBarQueueReorder() [Internal]\n// - TabBarProcessReorderFromMousePos() [Internal]\n// - TabBarProcessReorder() [Internal]\n// - TabBarScrollingButtons() [Internal]\n// - TabBarTabListPopupButton() [Internal]\n//-------------------------------------------------------------------------\n\nstruct ImGuiTabBarSection\n{\n    int                 TabCount;               // Number of tabs in this section.\n    float               Width;                  // Sum of width of tabs in this section (after shrinking down)\n    float               Spacing;                // Horizontal spacing at the end of the section.\n\n    ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }\n};\n\nnamespace ImGui\n{\n    static void             TabBarLayout(ImGuiTabBar* tab_bar);\n    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label, ImGuiWindow* docked_window);\n    static float            TabBarCalcMaxTabWidth();\n    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);\n    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections);\n    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);\n    static ImGuiTabItem*    TabBarTabListPopupButton(ImGuiTabBar* tab_bar);\n}\n\nImGuiTabBar::ImGuiTabBar()\n{\n    memset(this, 0, sizeof(*this));\n    CurrFrameVisible = PrevFrameVisible = -1;\n    LastTabItemIdx = -1;\n}\n\nstatic inline int TabItemGetSectionIdx(const ImGuiTabItem* tab)\n{\n    return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;\n}\n\nstatic int IMGUI_CDECL TabItemComparerBySection(const void* lhs, const void* rhs)\n{\n    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;\n    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;\n    const int a_section = TabItemGetSectionIdx(a);\n    const int b_section = TabItemGetSectionIdx(b);\n    if (a_section != b_section)\n        return a_section - b_section;\n    return (int)(a->IndexDuringLayout - b->IndexDuringLayout);\n}\n\nstatic int IMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs)\n{\n    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;\n    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;\n    return (int)(a->BeginOrder - b->BeginOrder);\n}\n\nstatic ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiPtrOrIndex& ref)\n{\n    ImGuiContext& g = *GImGui;\n    return ref.Ptr ? (ImGuiTabBar*)ref.Ptr : g.TabBars.GetByIndex(ref.Index);\n}\n\nstatic ImGuiPtrOrIndex GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)\n{\n    ImGuiContext& g = *GImGui;\n    if (g.TabBars.Contains(tab_bar))\n        return ImGuiPtrOrIndex(g.TabBars.GetIndex(tab_bar));\n    return ImGuiPtrOrIndex(tab_bar);\n}\n\nbool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    ImGuiID id = window->GetID(str_id);\n    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);\n    ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->WorkRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);\n    tab_bar->ID = id;\n    tab_bar->SeparatorMinX = tab_bar->BarRect.Min.x - IM_TRUNC(window->WindowPadding.x * 0.5f);\n    tab_bar->SeparatorMaxX = tab_bar->BarRect.Max.x + IM_TRUNC(window->WindowPadding.x * 0.5f);\n    //if (g.NavWindow && IsWindowChildOf(g.NavWindow, window, false, false))\n    flags |= ImGuiTabBarFlags_IsFocused;\n    return BeginTabBarEx(tab_bar, tab_bar_bb, flags);\n}\n\nbool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    IM_ASSERT(tab_bar->ID != 0);\n    if ((flags & ImGuiTabBarFlags_DockNode) == 0)\n        PushOverrideID(tab_bar->ID);\n\n    // Add to stack\n    g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));\n    g.CurrentTabBar = tab_bar;\n    tab_bar->Window = window;\n\n    // Append with multiple BeginTabBar()/EndTabBar() pairs.\n    tab_bar->BackupCursorPos = window->DC.CursorPos;\n    if (tab_bar->CurrFrameVisible == g.FrameCount)\n    {\n        window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);\n        tab_bar->BeginCount++;\n        return true;\n    }\n\n    // Ensure correct ordering when toggling ImGuiTabBarFlags_Reorderable flag, or when a new tab was added while being not reorderable\n    if ((flags & ImGuiTabBarFlags_Reorderable) != (tab_bar->Flags & ImGuiTabBarFlags_Reorderable) || (tab_bar->TabsAddedNew && !(flags & ImGuiTabBarFlags_Reorderable)))\n        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByBeginOrder);\n    tab_bar->TabsAddedNew = false;\n\n    // Flags\n    if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)\n        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;\n\n    tab_bar->Flags = flags;\n    tab_bar->BarRect = tab_bar_bb;\n    tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()\n    tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;\n    tab_bar->CurrFrameVisible = g.FrameCount;\n    tab_bar->PrevTabsContentsHeight = tab_bar->CurrTabsContentsHeight;\n    tab_bar->CurrTabsContentsHeight = 0.0f;\n    tab_bar->ItemSpacingY = g.Style.ItemSpacing.y;\n    tab_bar->FramePadding = g.Style.FramePadding;\n    tab_bar->TabsActiveCount = 0;\n    tab_bar->LastTabItemIdx = -1;\n    tab_bar->BeginCount = 1;\n\n    // Set cursor pos in a way which only be used in the off-chance the user erroneously submits item before BeginTabItem(): items will overlap\n    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);\n\n    // Draw separator\n    // (it would be misleading to draw this in EndTabBar() suggesting that it may be drawn over tabs, as tab bar are appendable)\n    const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabSelected : ImGuiCol_TabDimmedSelected);\n    if (g.Style.TabBarBorderSize > 0.0f)\n    {\n        const float y = tab_bar->BarRect.Max.y;\n        window->DrawList->AddRectFilled(ImVec2(tab_bar->SeparatorMinX, y - g.Style.TabBarBorderSize), ImVec2(tab_bar->SeparatorMaxX, y), col);\n    }\n    return true;\n}\n\nvoid    ImGui::EndTabBar()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return;\n\n    ImGuiTabBar* tab_bar = g.CurrentTabBar;\n    if (tab_bar == NULL)\n    {\n        IM_ASSERT_USER_ERROR(tab_bar != NULL, \"Mismatched BeginTabBar()/EndTabBar()!\");\n        return;\n    }\n\n    // Fallback in case no TabItem have been submitted\n    if (tab_bar->WantLayout)\n        TabBarLayout(tab_bar);\n\n    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().\n    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);\n    if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)\n    {\n        tab_bar->CurrTabsContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, tab_bar->CurrTabsContentsHeight);\n        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->CurrTabsContentsHeight;\n    }\n    else\n    {\n        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->PrevTabsContentsHeight;\n    }\n    if (tab_bar->BeginCount > 1)\n        window->DC.CursorPos = tab_bar->BackupCursorPos;\n\n    tab_bar->LastTabItemIdx = -1;\n    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)\n        PopID();\n\n    g.CurrentTabBarStack.pop_back();\n    g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());\n}\n\n// Scrolling happens only in the central section (leading/trailing sections are not scrolling)\nstatic float TabBarCalcScrollableWidth(ImGuiTabBar* tab_bar, ImGuiTabBarSection* sections)\n{\n    return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;\n}\n\n// This is called only once a frame before by the first call to ItemTab()\n// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.\nstatic void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)\n{\n    ImGuiContext& g = *GImGui;\n    tab_bar->WantLayout = false;\n\n    // Garbage collect by compacting list\n    // Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)\n    int tab_dst_n = 0;\n    bool need_sort_by_section = false;\n    ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing\n    for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)\n    {\n        ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];\n        if (tab->LastFrameVisible < tab_bar->PrevFrameVisible || tab->WantClose)\n        {\n            // Remove tab\n            if (tab_bar->VisibleTabId == tab->ID) { tab_bar->VisibleTabId = 0; }\n            if (tab_bar->SelectedTabId == tab->ID) { tab_bar->SelectedTabId = 0; }\n            if (tab_bar->NextSelectedTabId == tab->ID) { tab_bar->NextSelectedTabId = 0; }\n            continue;\n        }\n        if (tab_dst_n != tab_src_n)\n            tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];\n\n        tab = &tab_bar->Tabs[tab_dst_n];\n        tab->IndexDuringLayout = (ImS16)tab_dst_n;\n\n        // We will need sorting if tabs have changed section (e.g. moved from one of Leading/Central/Trailing to another)\n        int curr_tab_section_n = TabItemGetSectionIdx(tab);\n        if (tab_dst_n > 0)\n        {\n            ImGuiTabItem* prev_tab = &tab_bar->Tabs[tab_dst_n - 1];\n            int prev_tab_section_n = TabItemGetSectionIdx(prev_tab);\n            if (curr_tab_section_n == 0 && prev_tab_section_n != 0)\n                need_sort_by_section = true;\n            if (prev_tab_section_n == 2 && curr_tab_section_n != 2)\n                need_sort_by_section = true;\n        }\n\n        sections[curr_tab_section_n].TabCount++;\n        tab_dst_n++;\n    }\n    if (tab_bar->Tabs.Size != tab_dst_n)\n        tab_bar->Tabs.resize(tab_dst_n);\n\n    if (need_sort_by_section)\n        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerBySection);\n\n    // Calculate spacing between sections\n    sections[0].Spacing = sections[0].TabCount > 0 && (sections[1].TabCount + sections[2].TabCount) > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;\n    sections[1].Spacing = sections[1].TabCount > 0 && sections[2].TabCount > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;\n\n    // Setup next selected tab\n    ImGuiID scroll_to_tab_id = 0;\n    if (tab_bar->NextSelectedTabId)\n    {\n        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;\n        tab_bar->NextSelectedTabId = 0;\n        scroll_to_tab_id = tab_bar->SelectedTabId;\n    }\n\n    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).\n    if (tab_bar->ReorderRequestTabId != 0)\n    {\n        if (TabBarProcessReorder(tab_bar))\n            if (tab_bar->ReorderRequestTabId == tab_bar->SelectedTabId)\n                scroll_to_tab_id = tab_bar->ReorderRequestTabId;\n        tab_bar->ReorderRequestTabId = 0;\n    }\n\n    // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)\n    const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;\n    if (tab_list_popup_button)\n        if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Min.x!\n            scroll_to_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;\n\n    // Leading/Trailing tabs will be shrink only if central one aren't visible anymore, so layout the shrink data as: leading, trailing, central\n    // (whereas our tabs are stored as: leading, central, trailing)\n    int shrink_buffer_indexes[3] = { 0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount };\n    g.ShrinkWidthBuffer.resize(tab_bar->Tabs.Size);\n\n    // Compute ideal tabs widths + store them into shrink buffer\n    ImGuiTabItem* most_recently_selected_tab = NULL;\n    int curr_section_n = -1;\n    bool found_selected_tab_id = false;\n    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)\n    {\n        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];\n        IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);\n\n        if ((most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected) && !(tab->Flags & ImGuiTabItemFlags_Button))\n            most_recently_selected_tab = tab;\n        if (tab->ID == tab_bar->SelectedTabId)\n            found_selected_tab_id = true;\n        if (scroll_to_tab_id == 0 && g.NavJustMovedToId == tab->ID)\n            scroll_to_tab_id = tab->ID;\n\n        // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.\n        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,\n        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.\n        const char* tab_name = TabBarGetTabName(tab_bar, tab);\n        const bool has_close_button_or_unsaved_marker = (tab->Flags & ImGuiTabItemFlags_NoCloseButton) == 0 || (tab->Flags & ImGuiTabItemFlags_UnsavedDocument);\n        tab->ContentWidth = (tab->RequestedWidth >= 0.0f) ? tab->RequestedWidth : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x;\n\n        int section_n = TabItemGetSectionIdx(tab);\n        ImGuiTabBarSection* section = &sections[section_n];\n        section->Width += tab->ContentWidth + (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0f);\n        curr_section_n = section_n;\n\n        // Store data so we can build an array sorted by width if we need to shrink tabs down\n        IM_MSVC_WARNING_SUPPRESS(6385);\n        ImGuiShrinkWidthItem* shrink_width_item = &g.ShrinkWidthBuffer[shrink_buffer_indexes[section_n]++];\n        shrink_width_item->Index = tab_n;\n        shrink_width_item->Width = shrink_width_item->InitialWidth = tab->ContentWidth;\n        tab->Width = ImMax(tab->ContentWidth, 1.0f);\n    }\n\n    // Compute total ideal width (used for e.g. auto-resizing a window)\n    tab_bar->WidthAllTabsIdeal = 0.0f;\n    for (int section_n = 0; section_n < 3; section_n++)\n        tab_bar->WidthAllTabsIdeal += sections[section_n].Width + sections[section_n].Spacing;\n\n    // Horizontal scrolling buttons\n    // (note that TabBarScrollButtons() will alter BarRect.Max.x)\n    if ((tab_bar->WidthAllTabsIdeal > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll))\n        if (ImGuiTabItem* scroll_and_select_tab = TabBarScrollingButtons(tab_bar))\n        {\n            scroll_to_tab_id = scroll_and_select_tab->ID;\n            if ((scroll_and_select_tab->Flags & ImGuiTabItemFlags_Button) == 0)\n                tab_bar->SelectedTabId = scroll_to_tab_id;\n        }\n\n    // Shrink widths if full tabs don't fit in their allocated space\n    float section_0_w = sections[0].Width + sections[0].Spacing;\n    float section_1_w = sections[1].Width + sections[1].Spacing;\n    float section_2_w = sections[2].Width + sections[2].Spacing;\n    bool central_section_is_visible = (section_0_w + section_2_w) < tab_bar->BarRect.GetWidth();\n    float width_excess;\n    if (central_section_is_visible)\n        width_excess = ImMax(section_1_w - (tab_bar->BarRect.GetWidth() - section_0_w - section_2_w), 0.0f); // Excess used to shrink central section\n    else\n        width_excess = (section_0_w + section_2_w) - tab_bar->BarRect.GetWidth(); // Excess used to shrink leading/trailing section\n\n    // With ImGuiTabBarFlags_FittingPolicyScroll policy, we will only shrink leading/trailing if the central section is not visible anymore\n    if (width_excess >= 1.0f && ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown) || !central_section_is_visible))\n    {\n        int shrink_data_count = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount);\n        int shrink_data_offset = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0);\n        ShrinkWidths(g.ShrinkWidthBuffer.Data + shrink_data_offset, shrink_data_count, width_excess);\n\n        // Apply shrunk values into tabs and sections\n        for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++)\n        {\n            ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];\n            float shrinked_width = IM_TRUNC(g.ShrinkWidthBuffer[tab_n].Width);\n            if (shrinked_width < 0.0f)\n                continue;\n\n            shrinked_width = ImMax(1.0f, shrinked_width);\n            int section_n = TabItemGetSectionIdx(tab);\n            sections[section_n].Width -= (tab->Width - shrinked_width);\n            tab->Width = shrinked_width;\n        }\n    }\n\n    // Layout all active tabs\n    int section_tab_index = 0;\n    float tab_offset = 0.0f;\n    tab_bar->WidthAllTabs = 0.0f;\n    for (int section_n = 0; section_n < 3; section_n++)\n    {\n        ImGuiTabBarSection* section = &sections[section_n];\n        if (section_n == 2)\n            tab_offset = ImMin(ImMax(0.0f, tab_bar->BarRect.GetWidth() - section->Width), tab_offset);\n\n        for (int tab_n = 0; tab_n < section->TabCount; tab_n++)\n        {\n            ImGuiTabItem* tab = &tab_bar->Tabs[section_tab_index + tab_n];\n            tab->Offset = tab_offset;\n            tab->NameOffset = -1;\n            tab_offset += tab->Width + (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);\n        }\n        tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);\n        tab_offset += section->Spacing;\n        section_tab_index += section->TabCount;\n    }\n\n    // Clear name buffers\n    tab_bar->TabsNames.Buf.resize(0);\n\n    // If we have lost the selected tab, select the next most recently active one\n    if (found_selected_tab_id == false)\n        tab_bar->SelectedTabId = 0;\n    if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)\n        scroll_to_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;\n\n    // Lock in visible tab\n    tab_bar->VisibleTabId = tab_bar->SelectedTabId;\n    tab_bar->VisibleTabWasSubmitted = false;\n\n    // Apply request requests\n    if (scroll_to_tab_id != 0)\n        TabBarScrollToTab(tab_bar, scroll_to_tab_id, sections);\n    else if ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll) && IsMouseHoveringRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, true) && IsWindowContentHoverable(g.CurrentWindow))\n    {\n        const float wheel = g.IO.MouseWheelRequestAxisSwap ? g.IO.MouseWheel : g.IO.MouseWheelH;\n        const ImGuiKey wheel_key = g.IO.MouseWheelRequestAxisSwap ? ImGuiKey_MouseWheelY : ImGuiKey_MouseWheelX;\n        if (TestKeyOwner(wheel_key, tab_bar->ID) && wheel != 0.0f)\n        {\n            const float scroll_step = wheel * TabBarCalcScrollableWidth(tab_bar, sections) / 3.0f;\n            tab_bar->ScrollingTargetDistToVisibility = 0.0f;\n            tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget - scroll_step);\n        }\n        SetKeyOwner(wheel_key, tab_bar->ID);\n    }\n\n    // Update scrolling\n    tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);\n    tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);\n    if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)\n    {\n        // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.\n        // Teleport if we are aiming far off the visible line\n        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);\n        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);\n        const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);\n        tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);\n    }\n    else\n    {\n        tab_bar->ScrollingSpeed = 0.0f;\n    }\n    tab_bar->ScrollingRectMinX = tab_bar->BarRect.Min.x + sections[0].Width + sections[0].Spacing;\n    tab_bar->ScrollingRectMaxX = tab_bar->BarRect.Max.x - sections[2].Width - sections[1].Spacing;\n\n    // Actual layout in host window (we don't do it in BeginTabBar() so as not to waste an extra frame)\n    ImGuiWindow* window = g.CurrentWindow;\n    window->DC.CursorPos = tab_bar->BarRect.Min;\n    ItemSize(ImVec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);\n    window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, tab_bar->BarRect.Min.x + tab_bar->WidthAllTabsIdeal);\n}\n\n// Dockable windows uses Name/ID in the global namespace. Non-dockable items use the ID stack.\nstatic ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label, ImGuiWindow* docked_window)\n{\n    IM_ASSERT(docked_window == NULL); // master branch only\n    IM_UNUSED(docked_window);\n    if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)\n    {\n        ImGuiID id = ImHashStr(label);\n        KeepAliveID(id);\n        return id;\n    }\n    else\n    {\n        ImGuiWindow* window = GImGui->CurrentWindow;\n        return window->GetID(label);\n    }\n}\n\nstatic float ImGui::TabBarCalcMaxTabWidth()\n{\n    ImGuiContext& g = *GImGui;\n    return g.FontSize * 20.0f;\n}\n\nImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)\n{\n    if (tab_id != 0)\n        for (int n = 0; n < tab_bar->Tabs.Size; n++)\n            if (tab_bar->Tabs[n].ID == tab_id)\n                return &tab_bar->Tabs[n];\n    return NULL;\n}\n\n// Order = visible order, not submission order! (which is tab->BeginOrder)\nImGuiTabItem* ImGui::TabBarFindTabByOrder(ImGuiTabBar* tab_bar, int order)\n{\n    if (order < 0 || order >= tab_bar->Tabs.Size)\n        return NULL;\n    return &tab_bar->Tabs[order];\n}\n\nImGuiTabItem* ImGui::TabBarGetCurrentTab(ImGuiTabBar* tab_bar)\n{\n    if (tab_bar->LastTabItemIdx < 0 || tab_bar->LastTabItemIdx >= tab_bar->Tabs.Size)\n        return NULL;\n    return &tab_bar->Tabs[tab_bar->LastTabItemIdx];\n}\n\nconst char* ImGui::TabBarGetTabName(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)\n{\n    if (tab->NameOffset == -1)\n        return \"N/A\";\n    IM_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);\n    return tab_bar->TabsNames.Buf.Data + tab->NameOffset;\n}\n\n// The *TabId fields are already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.\nvoid ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)\n{\n    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))\n        tab_bar->Tabs.erase(tab);\n    if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }\n    if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }\n    if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }\n}\n\n// Called on manual closure attempt\nvoid ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)\n{\n    if (tab->Flags & ImGuiTabItemFlags_Button)\n        return; // A button appended with TabItemButton().\n\n    if ((tab->Flags & (ImGuiTabItemFlags_UnsavedDocument | ImGuiTabItemFlags_NoAssumedClosure)) == 0)\n    {\n        // This will remove a frame of lag for selecting another tab on closure.\n        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure\n        tab->WantClose = true;\n        if (tab_bar->VisibleTabId == tab->ID)\n        {\n            tab->LastFrameVisible = -1;\n            tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;\n        }\n    }\n    else\n    {\n        // Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)\n        if (tab_bar->VisibleTabId != tab->ID)\n            TabBarQueueFocus(tab_bar, tab);\n    }\n}\n\nstatic float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)\n{\n    scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());\n    return ImMax(scrolling, 0.0f);\n}\n\n// Note: we may scroll to tab that are not selected! e.g. using keyboard arrow keys\nstatic void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections)\n{\n    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id);\n    if (tab == NULL)\n        return;\n    if (tab->Flags & ImGuiTabItemFlags_SectionMask_)\n        return;\n\n    ImGuiContext& g = *GImGui;\n    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)\n    int order = TabBarGetTabOrder(tab_bar, tab);\n\n    // Scrolling happens only in the central section (leading/trailing sections are not scrolling)\n    float scrollable_width = TabBarCalcScrollableWidth(tab_bar, sections);\n\n    // We make all tabs positions all relative Sections[0].Width to make code simpler\n    float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);\n    float tab_x2 = tab->Offset - sections[0].Width + tab->Width + (order + 1 < tab_bar->Tabs.Size - sections[2].TabCount ? margin : 1.0f);\n    tab_bar->ScrollingTargetDistToVisibility = 0.0f;\n    if (tab_bar->ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= scrollable_width))\n    {\n        // Scroll to the left\n        tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);\n        tab_bar->ScrollingTarget = tab_x1;\n    }\n    else if (tab_bar->ScrollingTarget < tab_x2 - scrollable_width)\n    {\n        // Scroll to the right\n        tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);\n        tab_bar->ScrollingTarget = tab_x2 - scrollable_width;\n    }\n}\n\nvoid ImGui::TabBarQueueFocus(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)\n{\n    tab_bar->NextSelectedTabId = tab->ID;\n}\n\nvoid ImGui::TabBarQueueFocus(ImGuiTabBar* tab_bar, const char* tab_name)\n{\n    IM_ASSERT((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0); // Only supported for manual/explicit tab bars\n    ImGuiID tab_id = TabBarCalcTabID(tab_bar, tab_name, NULL);\n    tab_bar->NextSelectedTabId = tab_id;\n}\n\nvoid ImGui::TabBarQueueReorder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, int offset)\n{\n    IM_ASSERT(offset != 0);\n    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);\n    tab_bar->ReorderRequestTabId = tab->ID;\n    tab_bar->ReorderRequestOffset = (ImS16)offset;\n}\n\nvoid ImGui::TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, ImGuiTabItem* src_tab, ImVec2 mouse_pos)\n{\n    ImGuiContext& g = *GImGui;\n    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);\n    if ((tab_bar->Flags & ImGuiTabBarFlags_Reorderable) == 0)\n        return;\n\n    const bool is_central_section = (src_tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;\n    const float bar_offset = tab_bar->BarRect.Min.x - (is_central_section ? tab_bar->ScrollingTarget : 0);\n\n    // Count number of contiguous tabs we are crossing over\n    const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;\n    const int src_idx = tab_bar->Tabs.index_from_ptr(src_tab);\n    int dst_idx = src_idx;\n    for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir)\n    {\n        // Reordered tabs must share the same section\n        const ImGuiTabItem* dst_tab = &tab_bar->Tabs[i];\n        if (dst_tab->Flags & ImGuiTabItemFlags_NoReorder)\n            break;\n        if ((dst_tab->Flags & ImGuiTabItemFlags_SectionMask_) != (src_tab->Flags & ImGuiTabItemFlags_SectionMask_))\n            break;\n        dst_idx = i;\n\n        // Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.\n        const float x1 = bar_offset + dst_tab->Offset - g.Style.ItemInnerSpacing.x;\n        const float x2 = bar_offset + dst_tab->Offset + dst_tab->Width + g.Style.ItemInnerSpacing.x;\n        //GetForegroundDrawList()->AddRect(ImVec2(x1, tab_bar->BarRect.Min.y), ImVec2(x2, tab_bar->BarRect.Max.y), IM_COL32(255, 0, 0, 255));\n        if ((dir < 0 && mouse_pos.x > x1) || (dir > 0 && mouse_pos.x < x2))\n            break;\n    }\n\n    if (dst_idx != src_idx)\n        TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx);\n}\n\nbool ImGui::TabBarProcessReorder(ImGuiTabBar* tab_bar)\n{\n    ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId);\n    if (tab1 == NULL || (tab1->Flags & ImGuiTabItemFlags_NoReorder))\n        return false;\n\n    //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools\n    int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;\n    if (tab2_order < 0 || tab2_order >= tab_bar->Tabs.Size)\n        return false;\n\n    // Reordered tabs must share the same section\n    // (Note: TabBarQueueReorderFromMousePos() also has a similar test but since we allow direct calls to TabBarQueueReorder() we do it here too)\n    ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];\n    if (tab2->Flags & ImGuiTabItemFlags_NoReorder)\n        return false;\n    if ((tab1->Flags & ImGuiTabItemFlags_SectionMask_) != (tab2->Flags & ImGuiTabItemFlags_SectionMask_))\n        return false;\n\n    ImGuiTabItem item_tmp = *tab1;\n    ImGuiTabItem* src_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 + 1 : tab2;\n    ImGuiTabItem* dst_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 : tab2 + 1;\n    const int move_count = (tab_bar->ReorderRequestOffset > 0) ? tab_bar->ReorderRequestOffset : -tab_bar->ReorderRequestOffset;\n    memmove(dst_tab, src_tab, move_count * sizeof(ImGuiTabItem));\n    *tab2 = item_tmp;\n\n    if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)\n        MarkIniSettingsDirty();\n    return true;\n}\n\nstatic ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);\n    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;\n\n    const ImVec2 backup_cursor_pos = window->DC.CursorPos;\n    //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));\n\n    int select_dir = 0;\n    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];\n    arrow_col.w *= 0.5f;\n\n    PushStyleColor(ImGuiCol_Text, arrow_col);\n    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));\n    PushItemFlag(ImGuiItemFlags_ButtonRepeat, true);\n    const float backup_repeat_delay = g.IO.KeyRepeatDelay;\n    const float backup_repeat_rate = g.IO.KeyRepeatRate;\n    g.IO.KeyRepeatDelay = 0.250f;\n    g.IO.KeyRepeatRate = 0.200f;\n    float x = ImMax(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.x - scrolling_buttons_width);\n    window->DC.CursorPos = ImVec2(x, tab_bar->BarRect.Min.y);\n    if (ArrowButtonEx(\"##<\", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick))\n        select_dir = -1;\n    window->DC.CursorPos = ImVec2(x + arrow_button_size.x, tab_bar->BarRect.Min.y);\n    if (ArrowButtonEx(\"##>\", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick))\n        select_dir = +1;\n    PopItemFlag();\n    PopStyleColor(2);\n    g.IO.KeyRepeatRate = backup_repeat_rate;\n    g.IO.KeyRepeatDelay = backup_repeat_delay;\n\n    ImGuiTabItem* tab_to_scroll_to = NULL;\n    if (select_dir != 0)\n        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))\n        {\n            int selected_order = TabBarGetTabOrder(tab_bar, tab_item);\n            int target_order = selected_order + select_dir;\n\n            // Skip tab item buttons until another tab item is found or end is reached\n            while (tab_to_scroll_to == NULL)\n            {\n                // If we are at the end of the list, still scroll to make our tab visible\n                tab_to_scroll_to = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order];\n\n                // Cross through buttons\n                // (even if first/last item is a button, return it so we can update the scroll)\n                if (tab_to_scroll_to->Flags & ImGuiTabItemFlags_Button)\n                {\n                    target_order += select_dir;\n                    selected_order += select_dir;\n                    tab_to_scroll_to = (target_order < 0 || target_order >= tab_bar->Tabs.Size) ? tab_to_scroll_to : NULL;\n                }\n            }\n        }\n    window->DC.CursorPos = backup_cursor_pos;\n    tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;\n\n    return tab_to_scroll_to;\n}\n\nstatic ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n\n    // We use g.Style.FramePadding.y to match the square ArrowButton size\n    const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;\n    const ImVec2 backup_cursor_pos = window->DC.CursorPos;\n    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);\n    tab_bar->BarRect.Min.x += tab_list_popup_button_width;\n\n    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];\n    arrow_col.w *= 0.5f;\n    PushStyleColor(ImGuiCol_Text, arrow_col);\n    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));\n    bool open = BeginCombo(\"##v\", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);\n    PopStyleColor(2);\n\n    ImGuiTabItem* tab_to_select = NULL;\n    if (open)\n    {\n        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)\n        {\n            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];\n            if (tab->Flags & ImGuiTabItemFlags_Button)\n                continue;\n\n            const char* tab_name = TabBarGetTabName(tab_bar, tab);\n            if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))\n                tab_to_select = tab;\n        }\n        EndCombo();\n    }\n\n    window->DC.CursorPos = backup_cursor_pos;\n    return tab_to_select;\n}\n\n//-------------------------------------------------------------------------\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n//-------------------------------------------------------------------------\n// - BeginTabItem()\n// - EndTabItem()\n// - TabItemButton()\n// - TabItemEx() [Internal]\n// - SetTabItemClosed()\n// - TabItemCalcSize() [Internal]\n// - TabItemBackground() [Internal]\n// - TabItemLabelAndCloseButton() [Internal]\n//-------------------------------------------------------------------------\n\nbool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    ImGuiTabBar* tab_bar = g.CurrentTabBar;\n    if (tab_bar == NULL)\n    {\n        IM_ASSERT_USER_ERROR(tab_bar, \"Needs to be called between BeginTabBar() and EndTabBar()!\");\n        return false;\n    }\n    IM_ASSERT(!(flags & ImGuiTabItemFlags_Button)); // BeginTabItem() Can't be used with button flags, use TabItemButton() instead!\n\n    bool ret = TabItemEx(tab_bar, label, p_open, flags, NULL);\n    if (ret && !(flags & ImGuiTabItemFlags_NoPushId))\n    {\n        ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];\n        PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)\n    }\n    return ret;\n}\n\nvoid    ImGui::EndTabItem()\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return;\n\n    ImGuiTabBar* tab_bar = g.CurrentTabBar;\n    if (tab_bar == NULL)\n    {\n        IM_ASSERT_USER_ERROR(tab_bar != NULL, \"Needs to be called between BeginTabBar() and EndTabBar()!\");\n        return;\n    }\n    IM_ASSERT(tab_bar->LastTabItemIdx >= 0);\n    ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];\n    if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))\n        PopID();\n}\n\nbool    ImGui::TabItemButton(const char* label, ImGuiTabItemFlags flags)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    ImGuiTabBar* tab_bar = g.CurrentTabBar;\n    if (tab_bar == NULL)\n    {\n        IM_ASSERT_USER_ERROR(tab_bar != NULL, \"Needs to be called between BeginTabBar() and EndTabBar()!\");\n        return false;\n    }\n    return TabItemEx(tab_bar, label, NULL, flags | ImGuiTabItemFlags_Button | ImGuiTabItemFlags_NoReorder, NULL);\n}\n\nbool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window)\n{\n    // Layout whole tab bar if not already done\n    ImGuiContext& g = *GImGui;\n    if (tab_bar->WantLayout)\n    {\n        ImGuiNextItemData backup_next_item_data = g.NextItemData;\n        TabBarLayout(tab_bar);\n        g.NextItemData = backup_next_item_data;\n    }\n    ImGuiWindow* window = g.CurrentWindow;\n    if (window->SkipItems)\n        return false;\n\n    const ImGuiStyle& style = g.Style;\n    const ImGuiID id = TabBarCalcTabID(tab_bar, label, docked_window);\n\n    // If the user called us with *p_open == false, we early out and don't render.\n    // We make a call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.\n    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);\n    if (p_open && !*p_open)\n    {\n        ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);\n        return false;\n    }\n\n    IM_ASSERT(!p_open || !(flags & ImGuiTabItemFlags_Button));\n    IM_ASSERT((flags & (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)) != (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)); // Can't use both Leading and Trailing\n\n    // Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)\n    if (flags & ImGuiTabItemFlags_NoCloseButton)\n        p_open = NULL;\n    else if (p_open == NULL)\n        flags |= ImGuiTabItemFlags_NoCloseButton;\n\n    // Acquire tab data\n    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);\n    bool tab_is_new = false;\n    if (tab == NULL)\n    {\n        tab_bar->Tabs.push_back(ImGuiTabItem());\n        tab = &tab_bar->Tabs.back();\n        tab->ID = id;\n        tab_bar->TabsAddedNew = tab_is_new = true;\n    }\n    tab_bar->LastTabItemIdx = (ImS16)tab_bar->Tabs.index_from_ptr(tab);\n\n    // Calculate tab contents size\n    ImVec2 size = TabItemCalcSize(label, (p_open != NULL) || (flags & ImGuiTabItemFlags_UnsavedDocument));\n    tab->RequestedWidth = -1.0f;\n    if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_HasWidth)\n        size.x = tab->RequestedWidth = g.NextItemData.Width;\n    if (tab_is_new)\n        tab->Width = ImMax(1.0f, size.x);\n    tab->ContentWidth = size.x;\n    tab->BeginOrder = tab_bar->TabsActiveCount++;\n\n    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);\n    const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;\n    const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);\n    const bool tab_just_unsaved = (flags & ImGuiTabItemFlags_UnsavedDocument) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument);\n    const bool is_tab_button = (flags & ImGuiTabItemFlags_Button) != 0;\n    tab->LastFrameVisible = g.FrameCount;\n    tab->Flags = flags;\n\n    // Append name _WITH_ the zero-terminator\n    if (docked_window != NULL)\n    {\n        IM_ASSERT(docked_window == NULL); // master branch only\n    }\n    else\n    {\n        tab->NameOffset = (ImS32)tab_bar->TabsNames.size();\n        tab_bar->TabsNames.append(label, label + strlen(label) + 1);\n    }\n\n    // Update selected tab\n    if (!is_tab_button)\n    {\n        if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)\n            if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)\n                TabBarQueueFocus(tab_bar, tab); // New tabs gets activated\n        if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // _SetSelected can only be passed on explicit tab bar\n            TabBarQueueFocus(tab_bar, tab);\n    }\n\n    // Lock visibility\n    // (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations may preview some tabs without selecting them!)\n    bool tab_contents_visible = (tab_bar->VisibleTabId == id);\n    if (tab_contents_visible)\n        tab_bar->VisibleTabWasSubmitted = true;\n\n    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches\n    if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)\n        if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))\n            tab_contents_visible = true;\n\n    // Note that tab_is_new is not necessarily the same as tab_appearing! When a tab bar stops being submitted\n    // and then gets submitted again, the tabs will have 'tab_appearing=true' but 'tab_is_new=false'.\n    if (tab_appearing && (!tab_bar_appearing || tab_is_new))\n    {\n        ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);\n        if (is_tab_button)\n            return false;\n        return tab_contents_visible;\n    }\n\n    if (tab_bar->SelectedTabId == id)\n        tab->LastFrameSelected = g.FrameCount;\n\n    // Backup current layout position\n    const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;\n\n    // Layout\n    const bool is_central_section = (tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;\n    size.x = tab->Width;\n    if (is_central_section)\n        window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(IM_TRUNC(tab->Offset - tab_bar->ScrollingAnim), 0.0f);\n    else\n        window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(tab->Offset, 0.0f);\n    ImVec2 pos = window->DC.CursorPos;\n    ImRect bb(pos, pos + size);\n\n    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)\n    const bool want_clip_rect = is_central_section && (bb.Min.x < tab_bar->ScrollingRectMinX || bb.Max.x > tab_bar->ScrollingRectMaxX);\n    if (want_clip_rect)\n        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);\n\n    ImVec2 backup_cursor_max_pos = window->DC.CursorMaxPos;\n    ItemSize(bb.GetSize(), style.FramePadding.y);\n    window->DC.CursorMaxPos = backup_cursor_max_pos;\n\n    if (!ItemAdd(bb, id))\n    {\n        if (want_clip_rect)\n            PopClipRect();\n        window->DC.CursorPos = backup_main_cursor_pos;\n        return tab_contents_visible;\n    }\n\n    // Click to Select a tab\n    // Allow the close button to overlap\n    ImGuiButtonFlags button_flags = ((is_tab_button ? ImGuiButtonFlags_PressedOnClickRelease : ImGuiButtonFlags_PressedOnClick) | ImGuiButtonFlags_AllowOverlap);\n    if (g.DragDropActive)\n        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;\n    bool hovered, held;\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);\n    if (pressed && !is_tab_button)\n        TabBarQueueFocus(tab_bar, tab);\n\n    // Drag and drop: re-order tabs\n    if (held && !tab_appearing && IsMouseDragging(0))\n    {\n        if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))\n        {\n            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x\n            if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)\n            {\n                TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);\n            }\n            else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)\n            {\n                TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);\n            }\n        }\n    }\n\n#if 0\n    if (hovered && g.HoveredIdNotActiveTimer > TOOLTIP_DELAY && bb.GetWidth() < tab->ContentWidth)\n    {\n        // Enlarge tab display when hovering\n        bb.Max.x = bb.Min.x + IM_TRUNC(ImLerp(bb.GetWidth(), tab->ContentWidth, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f)));\n        display_draw_list = GetForegroundDrawList(window);\n        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));\n    }\n#endif\n\n    // Render tab shape\n    ImDrawList* display_draw_list = window->DrawList;\n    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabSelected : ImGuiCol_TabDimmedSelected) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabDimmed));\n    TabItemBackground(display_draw_list, bb, flags, tab_col);\n    if (tab_contents_visible && (tab_bar->Flags & ImGuiTabBarFlags_DrawSelectedOverline) && style.TabBarOverlineSize > 0.0f)\n    {\n        float x_offset = IM_TRUNC(0.4f * style.TabRounding);\n        if (x_offset < 2.0f * g.CurrentDpiScale)\n            x_offset = 0.0f;\n        float y_offset = 1.0f * g.CurrentDpiScale;\n        display_draw_list->AddLine(bb.GetTL() + ImVec2(x_offset, y_offset), bb.GetTR() + ImVec2(-x_offset, y_offset), GetColorU32(tab_bar_focused ? ImGuiCol_TabSelectedOverline : ImGuiCol_TabDimmedSelectedOverline), style.TabBarOverlineSize);\n    }\n    RenderNavCursor(bb, id);\n\n    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.\n    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);\n    if (tab_bar->SelectedTabId != tab->ID && hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)) && !is_tab_button)\n        TabBarQueueFocus(tab_bar, tab);\n\n    if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)\n        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;\n\n    // Render tab label, process close button\n    const ImGuiID close_button_id = p_open ? GetIDWithSeed(\"#CLOSE\", NULL, id) : 0;\n    bool just_closed;\n    bool text_clipped;\n    TabItemLabelAndCloseButton(display_draw_list, bb, tab_just_unsaved ? (flags & ~ImGuiTabItemFlags_UnsavedDocument) : flags, tab_bar->FramePadding, label, id, close_button_id, tab_contents_visible, &just_closed, &text_clipped);\n    if (just_closed && p_open != NULL)\n    {\n        *p_open = false;\n        TabBarCloseTab(tab_bar, tab);\n    }\n\n    // Restore main window position so user can draw there\n    if (want_clip_rect)\n        PopClipRect();\n    window->DC.CursorPos = backup_main_cursor_pos;\n\n    // Tooltip\n    // (Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer-> seems ok)\n    // (We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar, which g.HoveredId ignores)\n    // FIXME: This is a mess.\n    // FIXME: We may want disabled tab to still display the tooltip?\n    if (text_clipped && g.HoveredId == id && !held)\n        if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip) && !(tab->Flags & ImGuiTabItemFlags_NoTooltip))\n            SetItemTooltip(\"%.*s\", (int)(FindRenderedTextEnd(label) - label), label);\n\n    IM_ASSERT(!is_tab_button || !(tab_bar->SelectedTabId == tab->ID && is_tab_button)); // TabItemButton should not be selected\n    if (is_tab_button)\n        return pressed;\n    return tab_contents_visible;\n}\n\n// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.\n// To use it to need to call the function SetTabItemClosed() between BeginTabBar() and EndTabBar().\n// Tabs closed by the close button will automatically be flagged to avoid this issue.\nvoid    ImGui::SetTabItemClosed(const char* label)\n{\n    ImGuiContext& g = *GImGui;\n    bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);\n    if (is_within_manual_tab_bar)\n    {\n        ImGuiTabBar* tab_bar = g.CurrentTabBar;\n        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label, NULL);\n        if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))\n            tab->WantClose = true; // Will be processed by next call to TabBarLayout()\n    }\n}\n\nImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button_or_unsaved_marker)\n{\n    ImGuiContext& g = *GImGui;\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\n    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);\n    if (has_close_button_or_unsaved_marker)\n        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.\n    else\n        size.x += g.Style.FramePadding.x + 1.0f;\n    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);\n}\n\nImVec2 ImGui::TabItemCalcSize(ImGuiWindow*)\n{\n    IM_ASSERT(0); // This function exists to facilitate merge with 'docking' branch.\n    return ImVec2(0.0f, 0.0f);\n}\n\nvoid ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)\n{\n    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking \"detached\" from it.\n    ImGuiContext& g = *GImGui;\n    const float width = bb.GetWidth();\n    IM_UNUSED(flags);\n    IM_ASSERT(width > 0.0f);\n    const float rounding = ImMax(0.0f, ImMin((flags & ImGuiTabItemFlags_Button) ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5f - 1.0f));\n    const float y1 = bb.Min.y + 1.0f;\n    const float y2 = bb.Max.y - g.Style.TabBarBorderSize;\n    draw_list->PathLineTo(ImVec2(bb.Min.x, y2));\n    draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);\n    draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);\n    draw_list->PathLineTo(ImVec2(bb.Max.x, y2));\n    draw_list->PathFillConvex(col);\n    if (g.Style.TabBorderSize > 0.0f)\n    {\n        draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));\n        draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);\n        draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);\n        draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));\n        draw_list->PathStroke(GetColorU32(ImGuiCol_Border), 0, g.Style.TabBorderSize);\n    }\n}\n\n// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic\n// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.\nvoid ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped)\n{\n    ImGuiContext& g = *GImGui;\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\n\n    if (out_just_closed)\n        *out_just_closed = false;\n    if (out_text_clipped)\n        *out_text_clipped = false;\n\n    if (bb.GetWidth() <= 1.0f)\n        return;\n\n    // In Style V2 we'll have full override of all colors per state (e.g. focused, selected)\n    // But right now if you want to alter text color of tabs this is what you need to do.\n#if 0\n    const float backup_alpha = g.Style.Alpha;\n    if (!is_contents_visible)\n        g.Style.Alpha *= 0.7f;\n#endif\n\n    // Render text label (with clipping + alpha gradient) + unsaved marker\n    ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);\n    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;\n\n    // Return clipped state ignoring the close button\n    if (out_text_clipped)\n    {\n        *out_text_clipped = (text_ellipsis_clip_bb.Min.x + label_size.x) > text_pixel_clip_bb.Max.x;\n        //draw_list->AddCircle(text_ellipsis_clip_bb.Min, 3.0f, *out_text_clipped ? IM_COL32(255, 0, 0, 255) : IM_COL32(0, 255, 0, 255));\n    }\n\n    const float button_sz = g.FontSize;\n    const ImVec2 button_pos(ImMax(bb.Min.x, bb.Max.x - frame_padding.x - button_sz), bb.Min.y + frame_padding.y);\n\n    // Close Button & Unsaved Marker\n    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()\n    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button\n    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button\n    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false\n    bool close_button_pressed = false;\n    bool close_button_visible = false;\n    if (close_button_id != 0)\n        if (is_contents_visible || bb.GetWidth() >= ImMax(button_sz, g.Style.TabMinWidthForCloseButton))\n            if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == tab_id || g.ActiveId == close_button_id)\n                close_button_visible = true;\n    bool unsaved_marker_visible = (flags & ImGuiTabItemFlags_UnsavedDocument) != 0 && (button_pos.x + button_sz <= bb.Max.x);\n\n    if (close_button_visible)\n    {\n        ImGuiLastItemData last_item_backup = g.LastItemData;\n        if (CloseButton(close_button_id, button_pos))\n            close_button_pressed = true;\n        g.LastItemData = last_item_backup;\n\n        // Close with middle mouse button\n        if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))\n            close_button_pressed = true;\n    }\n    else if (unsaved_marker_visible)\n    {\n        const ImRect bullet_bb(button_pos, button_pos + ImVec2(button_sz, button_sz));\n        RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(ImGuiCol_Text));\n    }\n\n    // This is all rather complicated\n    // (the main idea is that because the close button only appears on hover, we don't want it to alter the ellipsis position)\n    // FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong here (e.g. #3497), maybe for consistency that parameter of RenderTextEllipsis() shouldn't exist..\n    float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;\n    if (close_button_visible || unsaved_marker_visible)\n    {\n        text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80f);\n        text_ellipsis_clip_bb.Max.x -= uns"
        },
        {
          "name": "imstb_rectpack.h",
          "type": "blob",
          "size": 19.87,
          "content": "// [DEAR IMGUI]\n// This is a slightly modified version of stb_rect_pack.h 1.01.\n// Grep for [DEAR IMGUI] to find the changes.\n// \n// stb_rect_pack.h - v1.01 - public domain - rectangle packing\n// Sean Barrett 2014\n//\n// Useful for e.g. packing rectangular textures into an atlas.\n// Does not do rotation.\n//\n// Before #including,\n//\n//    #define STB_RECT_PACK_IMPLEMENTATION\n//\n// in the file that you want to have the implementation.\n//\n// Not necessarily the awesomest packing method, but better than\n// the totally naive one in stb_truetype (which is primarily what\n// this is meant to replace).\n//\n// Has only had a few tests run, may have issues.\n//\n// More docs to come.\n//\n// No memory allocations; uses qsort() and assert() from stdlib.\n// Can override those by defining STBRP_SORT and STBRP_ASSERT.\n//\n// This library currently uses the Skyline Bottom-Left algorithm.\n//\n// Please note: better rectangle packers are welcome! Please\n// implement them to the same API, but with a different init\n// function.\n//\n// Credits\n//\n//  Library\n//    Sean Barrett\n//  Minor features\n//    Martins Mozeiko\n//    github:IntellectualKitty\n//\n//  Bugfixes / warning fixes\n//    Jeremy Jaussaud\n//    Fabian Giesen\n//\n// Version history:\n//\n//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section\n//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles\n//     0.99  (2019-02-07)  warning fixes\n//     0.11  (2017-03-03)  return packing success/fail result\n//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings\n//     0.09  (2016-08-27)  fix compiler warnings\n//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)\n//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)\n//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort\n//     0.05:  added STBRP_ASSERT to allow replacing assert\n//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support\n//     0.01:  initial release\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//       INCLUDE SECTION\n//\n\n#ifndef STB_INCLUDE_STB_RECT_PACK_H\n#define STB_INCLUDE_STB_RECT_PACK_H\n\n#define STB_RECT_PACK_VERSION  1\n\n#ifdef STBRP_STATIC\n#define STBRP_DEF static\n#else\n#define STBRP_DEF extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct stbrp_context stbrp_context;\ntypedef struct stbrp_node    stbrp_node;\ntypedef struct stbrp_rect    stbrp_rect;\n\ntypedef int            stbrp_coord;\n\n#define STBRP__MAXVAL  0x7fffffff\n// Mostly for internal use, but this is the maximum supported coordinate value.\n\nSTBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);\n// Assign packed locations to rectangles. The rectangles are of type\n// 'stbrp_rect' defined below, stored in the array 'rects', and there\n// are 'num_rects' many of them.\n//\n// Rectangles which are successfully packed have the 'was_packed' flag\n// set to a non-zero value and 'x' and 'y' store the minimum location\n// on each axis (i.e. bottom-left in cartesian coordinates, top-left\n// if you imagine y increasing downwards). Rectangles which do not fit\n// have the 'was_packed' flag set to 0.\n//\n// You should not try to access the 'rects' array from another thread\n// while this function is running, as the function temporarily reorders\n// the array while it executes.\n//\n// To pack into another rectangle, you need to call stbrp_init_target\n// again. To continue packing into the same rectangle, you can call\n// this function again. Calling this multiple times with multiple rect\n// arrays will probably produce worse packing results than calling it\n// a single time with the full rectangle array, but the option is\n// available.\n//\n// The function returns 1 if all of the rectangles were successfully\n// packed and 0 otherwise.\n\nstruct stbrp_rect\n{\n   // reserved for your use:\n   int            id;\n\n   // input:\n   stbrp_coord    w, h;\n\n   // output:\n   stbrp_coord    x, y;\n   int            was_packed;  // non-zero if valid packing\n\n}; // 16 bytes, nominally\n\n\nSTBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);\n// Initialize a rectangle packer to:\n//    pack a rectangle that is 'width' by 'height' in dimensions\n//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long\n//\n// You must call this function every time you start packing into a new target.\n//\n// There is no \"shutdown\" function. The 'nodes' memory must stay valid for\n// the following stbrp_pack_rects() call (or calls), but can be freed after\n// the call (or calls) finish.\n//\n// Note: to guarantee best results, either:\n//       1. make sure 'num_nodes' >= 'width'\n//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'\n//\n// If you don't do either of the above things, widths will be quantized to multiples\n// of small integers to guarantee the algorithm doesn't run out of temporary storage.\n//\n// If you do #2, then the non-quantized algorithm will be used, but the algorithm\n// may run out of temporary storage and be unable to pack some rectangles.\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);\n// Optionally call this function after init but before doing any packing to\n// change the handling of the out-of-temp-memory scenario, described above.\n// If you call init again, this will be reset to the default (false).\n\n\nSTBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);\n// Optionally select which packing heuristic the library should use. Different\n// heuristics will produce better/worse results for different data sets.\n// If you call init again, this will be reset to the default.\n\nenum\n{\n   STBRP_HEURISTIC_Skyline_default=0,\n   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,\n   STBRP_HEURISTIC_Skyline_BF_sortHeight\n};\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// the details of the following structures don't matter to you, but they must\n// be visible so you can handle the memory allocations for them\n\nstruct stbrp_node\n{\n   stbrp_coord  x,y;\n   stbrp_node  *next;\n};\n\nstruct stbrp_context\n{\n   int width;\n   int height;\n   int align;\n   int init_mode;\n   int heuristic;\n   int num_nodes;\n   stbrp_node *active_head;\n   stbrp_node *free_head;\n   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//     IMPLEMENTATION SECTION\n//\n\n#ifdef STB_RECT_PACK_IMPLEMENTATION\n#ifndef STBRP_SORT\n#include <stdlib.h>\n#define STBRP_SORT qsort\n#endif\n\n#ifndef STBRP_ASSERT\n#include <assert.h>\n#define STBRP_ASSERT assert\n#endif\n\n#ifdef _MSC_VER\n#define STBRP__NOTUSED(v)  (void)(v)\n#define STBRP__CDECL       __cdecl\n#else\n#define STBRP__NOTUSED(v)  (void)sizeof(v)\n#define STBRP__CDECL\n#endif\n\nenum\n{\n   STBRP__INIT_skyline = 1\n};\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)\n{\n   switch (context->init_mode) {\n      case STBRP__INIT_skyline:\n         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);\n         context->heuristic = heuristic;\n         break;\n      default:\n         STBRP_ASSERT(0);\n   }\n}\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)\n{\n   if (allow_out_of_mem)\n      // if it's ok to run out of memory, then don't bother aligning them;\n      // this gives better packing, but may fail due to OOM (even though\n      // the rectangles easily fit). @TODO a smarter approach would be to only\n      // quantize once we've hit OOM, then we could get rid of this parameter.\n      context->align = 1;\n   else {\n      // if it's not ok to run out of memory, then quantize the widths\n      // so that num_nodes is always enough nodes.\n      //\n      // I.e. num_nodes * align >= width\n      //                  align >= width / num_nodes\n      //                  align = ceil(width/num_nodes)\n\n      context->align = (context->width + context->num_nodes-1) / context->num_nodes;\n   }\n}\n\nSTBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)\n{\n   int i;\n\n   for (i=0; i < num_nodes-1; ++i)\n      nodes[i].next = &nodes[i+1];\n   nodes[i].next = NULL;\n   context->init_mode = STBRP__INIT_skyline;\n   context->heuristic = STBRP_HEURISTIC_Skyline_default;\n   context->free_head = &nodes[0];\n   context->active_head = &context->extra[0];\n   context->width = width;\n   context->height = height;\n   context->num_nodes = num_nodes;\n   stbrp_setup_allow_out_of_mem(context, 0);\n\n   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)\n   context->extra[0].x = 0;\n   context->extra[0].y = 0;\n   context->extra[0].next = &context->extra[1];\n   context->extra[1].x = (stbrp_coord) width;\n   context->extra[1].y = (1<<30);\n   context->extra[1].next = NULL;\n}\n\n// find minimum y position if it starts at x1\nstatic int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)\n{\n   stbrp_node *node = first;\n   int x1 = x0 + width;\n   int min_y, visited_width, waste_area;\n\n   STBRP__NOTUSED(c);\n\n   STBRP_ASSERT(first->x <= x0);\n\n   #if 0\n   // skip in case we're past the node\n   while (node->next->x <= x0)\n      ++node;\n   #else\n   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency\n   #endif\n\n   STBRP_ASSERT(node->x <= x0);\n\n   min_y = 0;\n   waste_area = 0;\n   visited_width = 0;\n   while (node->x < x1) {\n      if (node->y > min_y) {\n         // raise min_y higher.\n         // we've accounted for all waste up to min_y,\n         // but we'll now add more waste for everything we've visted\n         waste_area += visited_width * (node->y - min_y);\n         min_y = node->y;\n         // the first time through, visited_width might be reduced\n         if (node->x < x0)\n            visited_width += node->next->x - x0;\n         else\n            visited_width += node->next->x - node->x;\n      } else {\n         // add waste area\n         int under_width = node->next->x - node->x;\n         if (under_width + visited_width > width)\n            under_width = width - visited_width;\n         waste_area += under_width * (min_y - node->y);\n         visited_width += under_width;\n      }\n      node = node->next;\n   }\n\n   *pwaste = waste_area;\n   return min_y;\n}\n\ntypedef struct\n{\n   int x,y;\n   stbrp_node **prev_link;\n} stbrp__findresult;\n\nstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)\n{\n   int best_waste = (1<<30), best_x, best_y = (1 << 30);\n   stbrp__findresult fr;\n   stbrp_node **prev, *node, *tail, **best = NULL;\n\n   // align to multiple of c->align\n   width = (width + c->align - 1);\n   width -= width % c->align;\n   STBRP_ASSERT(width % c->align == 0);\n\n   // if it can't possibly fit, bail immediately\n   if (width > c->width || height > c->height) {\n      fr.prev_link = NULL;\n      fr.x = fr.y = 0;\n      return fr;\n   }\n\n   node = c->active_head;\n   prev = &c->active_head;\n   while (node->x + width <= c->width) {\n      int y,waste;\n      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);\n      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL\n         // bottom left\n         if (y < best_y) {\n            best_y = y;\n            best = prev;\n         }\n      } else {\n         // best-fit\n         if (y + height <= c->height) {\n            // can only use it if it first vertically\n            if (y < best_y || (y == best_y && waste < best_waste)) {\n               best_y = y;\n               best_waste = waste;\n               best = prev;\n            }\n         }\n      }\n      prev = &node->next;\n      node = node->next;\n   }\n\n   best_x = (best == NULL) ? 0 : (*best)->x;\n\n   // if doing best-fit (BF), we also have to try aligning right edge to each node position\n   //\n   // e.g, if fitting\n   //\n   //     ____________________\n   //    |____________________|\n   //\n   //            into\n   //\n   //   |                         |\n   //   |             ____________|\n   //   |____________|\n   //\n   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned\n   //\n   // This makes BF take about 2x the time\n\n   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {\n      tail = c->active_head;\n      node = c->active_head;\n      prev = &c->active_head;\n      // find first node that's admissible\n      while (tail->x < width)\n         tail = tail->next;\n      while (tail) {\n         int xpos = tail->x - width;\n         int y,waste;\n         STBRP_ASSERT(xpos >= 0);\n         // find the left position that matches this\n         while (node->next->x <= xpos) {\n            prev = &node->next;\n            node = node->next;\n         }\n         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);\n         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);\n         if (y + height <= c->height) {\n            if (y <= best_y) {\n               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {\n                  best_x = xpos;\n                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]\n                  best_y = y;\n                  best_waste = waste;\n                  best = prev;\n               }\n            }\n         }\n         tail = tail->next;\n      }\n   }\n\n   fr.prev_link = best;\n   fr.x = best_x;\n   fr.y = best_y;\n   return fr;\n}\n\nstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)\n{\n   // find best position according to heuristic\n   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);\n   stbrp_node *node, *cur;\n\n   // bail if:\n   //    1. it failed\n   //    2. the best node doesn't fit (we don't always check this)\n   //    3. we're out of memory\n   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {\n      res.prev_link = NULL;\n      return res;\n   }\n\n   // on success, create new node\n   node = context->free_head;\n   node->x = (stbrp_coord) res.x;\n   node->y = (stbrp_coord) (res.y + height);\n\n   context->free_head = node->next;\n\n   // insert the new node into the right starting point, and\n   // let 'cur' point to the remaining nodes needing to be\n   // stiched back in\n\n   cur = *res.prev_link;\n   if (cur->x < res.x) {\n      // preserve the existing one, so start testing with the next one\n      stbrp_node *next = cur->next;\n      cur->next = node;\n      cur = next;\n   } else {\n      *res.prev_link = node;\n   }\n\n   // from here, traverse cur and free the nodes, until we get to one\n   // that shouldn't be freed\n   while (cur->next && cur->next->x <= res.x + width) {\n      stbrp_node *next = cur->next;\n      // move the current node to the free list\n      cur->next = context->free_head;\n      context->free_head = cur;\n      cur = next;\n   }\n\n   // stitch the list back in\n   node->next = cur;\n\n   if (cur->x < res.x + width)\n      cur->x = (stbrp_coord) (res.x + width);\n\n#ifdef _DEBUG\n   cur = context->active_head;\n   while (cur->x < context->width) {\n      STBRP_ASSERT(cur->x < cur->next->x);\n      cur = cur->next;\n   }\n   STBRP_ASSERT(cur->next == NULL);\n\n   {\n      int count=0;\n      cur = context->active_head;\n      while (cur) {\n         cur = cur->next;\n         ++count;\n      }\n      cur = context->free_head;\n      while (cur) {\n         cur = cur->next;\n         ++count;\n      }\n      STBRP_ASSERT(count == context->num_nodes+2);\n   }\n#endif\n\n   return res;\n}\n\nstatic int STBRP__CDECL rect_height_compare(const void *a, const void *b)\n{\n   const stbrp_rect *p = (const stbrp_rect *) a;\n   const stbrp_rect *q = (const stbrp_rect *) b;\n   if (p->h > q->h)\n      return -1;\n   if (p->h < q->h)\n      return  1;\n   return (p->w > q->w) ? -1 : (p->w < q->w);\n}\n\nstatic int STBRP__CDECL rect_original_order(const void *a, const void *b)\n{\n   const stbrp_rect *p = (const stbrp_rect *) a;\n   const stbrp_rect *q = (const stbrp_rect *) b;\n   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);\n}\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)\n{\n   int i, all_rects_packed = 1;\n\n   // we use the 'was_packed' field internally to allow sorting/unsorting\n   for (i=0; i < num_rects; ++i) {\n      rects[i].was_packed = i;\n   }\n\n   // sort according to heuristic\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);\n\n   for (i=0; i < num_rects; ++i) {\n      if (rects[i].w == 0 || rects[i].h == 0) {\n         rects[i].x = rects[i].y = 0;  // empty rect needs no space\n      } else {\n         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);\n         if (fr.prev_link) {\n            rects[i].x = (stbrp_coord) fr.x;\n            rects[i].y = (stbrp_coord) fr.y;\n         } else {\n            rects[i].x = rects[i].y = STBRP__MAXVAL;\n         }\n      }\n   }\n\n   // unsort\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);\n\n   // set was_packed flags and all_rects_packed status\n   for (i=0; i < num_rects; ++i) {\n      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);\n      if (!rects[i].was_packed)\n         all_rects_packed = 0;\n   }\n\n   // return the all_rects_packed status\n   return all_rects_packed;\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "imstb_textedit.h",
          "type": "blob",
          "size": 55.79,
          "content": "// [DEAR IMGUI]\n// This is a slightly modified version of stb_textedit.h 1.14.\n// Those changes would need to be pushed into nothings/stb:\n// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)\n// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000 + #6783)\n// - Added name to struct or it may be forward declared in our code.\n// - Added UTF-8 support (see https://github.com/nothings/stb/issues/188 + https://github.com/ocornut/imgui/pull/7925)\n// Grep for [DEAR IMGUI] to find the changes.\n// - Also renamed macros used or defined outside of IMSTB_TEXTEDIT_IMPLEMENTATION block from STB_TEXTEDIT_* to IMSTB_TEXTEDIT_*\n\n// stb_textedit.h - v1.14  - public domain - Sean Barrett\n// Development of this library was sponsored by RAD Game Tools\n//\n// This C header file implements the guts of a multi-line text-editing\n// widget; you implement display, word-wrapping, and low-level string\n// insertion/deletion, and stb_textedit will map user inputs into\n// insertions & deletions, plus updates to the cursor position,\n// selection state, and undo state.\n//\n// It is intended for use in games and other systems that need to build\n// their own custom widgets and which do not have heavy text-editing\n// requirements (this library is not recommended for use for editing large\n// texts, as its performance does not scale and it has limited undo).\n//\n// Non-trivial behaviors are modelled after Windows text controls.\n//\n//\n// LICENSE\n//\n// See end of file for license information.\n//\n//\n// DEPENDENCIES\n//\n// Uses the C runtime function 'memmove', which you can override\n// by defining IMSTB_TEXTEDIT_memmove before the implementation.\n// Uses no other functions. Performs no runtime allocations.\n//\n//\n// VERSION HISTORY\n//\n//   1.14 (2021-07-11) page up/down, various fixes\n//   1.13 (2019-02-07) fix bug in undo size management\n//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash\n//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield\n//   1.10 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.9  (2016-08-27) customizable move-by-word\n//   1.8  (2016-04-02) better keyboard handling when mouse button is down\n//   1.7  (2015-09-13) change y range handling in case baseline is non-0\n//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove\n//   1.5  (2014-09-10) add support for secondary keys for OS X\n//   1.4  (2014-08-17) fix signed/unsigned warnings\n//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary\n//   1.2  (2014-05-27) fix some RAD types that had crept into the new code\n//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )\n//   1.0  (2012-07-26) improve documentation, initial public release\n//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode\n//   0.2  (2011-11-28) fixes to undo/redo\n//   0.1  (2010-07-08) initial version\n//\n// ADDITIONAL CONTRIBUTORS\n//\n//   Ulf Winklemann: move-by-word in 1.1\n//   Fabian Giesen: secondary key inputs in 1.5\n//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6\n//   Louis Schnellbach: page up/down in 1.14\n//\n//   Bugfixes:\n//      Scott Graham\n//      Daniel Keller\n//      Omar Cornut\n//      Dan Thompson\n//\n// USAGE\n//\n// This file behaves differently depending on what symbols you define\n// before including it.\n//\n//\n// Header-file mode:\n//\n//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,\n//   it will operate in \"header file\" mode. In this mode, it declares a\n//   single public symbol, STB_TexteditState, which encapsulates the current\n//   state of a text widget (except for the string, which you will store\n//   separately).\n//\n//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a\n//   primitive type that defines a single character (e.g. char, wchar_t, etc).\n//\n//   To save space or increase undo-ability, you can optionally define the\n//   following things that are used by the undo system:\n//\n//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position\n//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow\n//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer\n//\n//   If you don't define these, they are set to permissive types and\n//   moderate sizes. The undo system does no memory allocations, so\n//   it grows STB_TexteditState by the worst-case storage which is (in bytes):\n//\n//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT\n//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT\n//\n//\n// Implementation mode:\n//\n//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it\n//   will compile the implementation of the text edit widget, depending\n//   on a large number of symbols which must be defined before the include.\n//\n//   The implementation is defined only as static functions. You will then\n//   need to provide your own APIs in the same file which will access the\n//   static functions.\n//\n//   The basic concept is that you provide a \"string\" object which\n//   behaves like an array of characters. stb_textedit uses indices to\n//   refer to positions in the string, implicitly representing positions\n//   in the displayed textedit. This is true for both plain text and\n//   rich text; even with rich text stb_truetype interacts with your\n//   code as if there was an array of all the displayed characters.\n//\n// Symbols that must be the same in header-file and implementation mode:\n//\n//     STB_TEXTEDIT_CHARTYPE             the character type\n//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position\n//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow\n//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer\n//\n// Symbols you must define for implementation mode:\n//\n//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,\n//                                      typically this is a wrapper object with other data you need\n//\n//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))\n//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters\n//                                        starting from character #n (see discussion below)\n//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character\n//                                        to the xpos of the i+1'th char for a line of characters\n//                                        starting at character #n (i.e. accounts for kerning\n//                                        with previous char)\n//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character\n//                                        (return type is int, -1 means not valid to insert)\n//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based\n//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize\n//                                        as manually wordwrapping for end-of-line positioning\n//\n//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i\n//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)\n//\n//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key\n//\n//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left\n//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right\n//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up\n//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down\n//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page\n//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page\n//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME\n//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END\n//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME\n//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END\n//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor\n//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor\n//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo\n//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo\n//\n// Optional:\n//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode\n//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),\n//                                          required for default WORDLEFT/WORDRIGHT handlers\n//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to\n//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to\n//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT\n//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT\n//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line\n//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line\n//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text\n//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text\n//\n// Keyboard input must be encoded as a single integer value; e.g. a character code\n// and some bitflags that represent shift states. to simplify the interface, SHIFT must\n// be a bitflag, so we can test the shifted state of cursor movements to allow selection,\n// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.\n//\n// You can encode other things, such as CONTROL or ALT, in additional bits, and\n// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,\n// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN\n// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,\n// and I pass both WM_KEYDOWN and WM_CHAR events to the \"key\" function in the\n// API below. The control keys will only match WM_KEYDOWN events because of the\n// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN\n// bit so it only decodes WM_CHAR events.\n//\n// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed\n// row of characters assuming they start on the i'th character--the width and\n// the height and the number of characters consumed. This allows this library\n// to traverse the entire layout incrementally. You need to compute word-wrapping\n// here.\n//\n// Each textfield keeps its own insert mode state, which is not how normal\n// applications work. To keep an app-wide insert mode, update/copy the\n// \"insert_mode\" field of STB_TexteditState before/after calling API functions.\n//\n// API\n//\n//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)\n//\n//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)\n//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)\n//    void stb_textedit_text(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int text_len)\n//\n//    Each of these functions potentially updates the string and updates the\n//    state.\n//\n//      initialize_state:\n//          set the textedit state to a known good default state when initially\n//          constructing the textedit.\n//\n//      click:\n//          call this with the mouse x,y on a mouse down; it will update the cursor\n//          and reset the selection start/end to the cursor point. the x,y must\n//          be relative to the text widget, with (0,0) being the top left.\n//\n//      drag:\n//          call this with the mouse x,y on a mouse drag/up; it will update the\n//          cursor and the selection end point\n//\n//      cut:\n//          call this to delete the current selection; returns true if there was\n//          one. you should FIRST copy the current selection to the system paste buffer.\n//          (To copy, just copy the current selection out of the string yourself.)\n//\n//      paste:\n//          call this to paste text at the current cursor point or over the current\n//          selection if there is one.\n//\n//      key:\n//          call this for keyboard inputs sent to the textfield. you can use it\n//          for \"key down\" events or for \"translated\" key events. if you need to\n//          do both (as in Win32), or distinguish Unicode characters from control\n//          inputs, set a high bit to distinguish the two; then you can define the\n//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit\n//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is\n//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to\n//          anything other type you want before including.\n//          if the STB_TEXTEDIT_KEYTOTEXT function is defined, selected keys are\n//          transformed into text and stb_textedit_text() is automatically called.\n//\n//      text: [DEAR IMGUI] added 2024-09\n//          call this to text inputs sent to the textfield.\n//\n//\n//   When rendering, you can read the cursor position and selection state from\n//   the STB_TexteditState.\n//\n//\n// Notes:\n//\n// This is designed to be usable in IMGUI, so it allows for the possibility of\n// running in an IMGUI that has NOT cached the multi-line layout. For this\n// reason, it provides an interface that is compatible with computing the\n// layout incrementally--we try to make sure we make as few passes through\n// as possible. (For example, to locate the mouse pointer in the text, we\n// could define functions that return the X and Y positions of characters\n// and binary search Y and then X, but if we're doing dynamic layout this\n// will run the layout algorithm many times, so instead we manually search\n// forward in one pass. Similar logic applies to e.g. up-arrow and\n// down-arrow movement.)\n//\n// If it's run in a widget that *has* cached the layout, then this is less\n// efficient, but it's not horrible on modern computers. But you wouldn't\n// want to edit million-line files with it.\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////\n////   Header-file mode\n////\n////\n\n#ifndef INCLUDE_IMSTB_TEXTEDIT_H\n#define INCLUDE_IMSTB_TEXTEDIT_H\n\n////////////////////////////////////////////////////////////////////////\n//\n//     STB_TexteditState\n//\n// Definition of STB_TexteditState which you should store\n// per-textfield; it includes cursor position, selection state,\n// and undo state.\n//\n\n#ifndef IMSTB_TEXTEDIT_UNDOSTATECOUNT\n#define IMSTB_TEXTEDIT_UNDOSTATECOUNT   99\n#endif\n#ifndef IMSTB_TEXTEDIT_UNDOCHARCOUNT\n#define IMSTB_TEXTEDIT_UNDOCHARCOUNT   999\n#endif\n#ifndef IMSTB_TEXTEDIT_CHARTYPE\n#define IMSTB_TEXTEDIT_CHARTYPE        int\n#endif\n#ifndef IMSTB_TEXTEDIT_POSITIONTYPE\n#define IMSTB_TEXTEDIT_POSITIONTYPE    int\n#endif\n\ntypedef struct\n{\n   // private data\n   IMSTB_TEXTEDIT_POSITIONTYPE  where;\n   IMSTB_TEXTEDIT_POSITIONTYPE  insert_length;\n   IMSTB_TEXTEDIT_POSITIONTYPE  delete_length;\n   int                        char_storage;\n} StbUndoRecord;\n\ntypedef struct\n{\n   // private data\n   StbUndoRecord          undo_rec [IMSTB_TEXTEDIT_UNDOSTATECOUNT];\n   IMSTB_TEXTEDIT_CHARTYPE  undo_char[IMSTB_TEXTEDIT_UNDOCHARCOUNT];\n   short undo_point, redo_point;\n   int undo_char_point, redo_char_point;\n} StbUndoState;\n\ntypedef struct STB_TexteditState\n{\n   /////////////////////\n   //\n   // public data\n   //\n\n   int cursor;\n   // position of the text cursor within the string\n\n   int select_start;          // selection start point\n   int select_end;\n   // selection start and end point in characters; if equal, no selection.\n   // note that start may be less than or greater than end (e.g. when\n   // dragging the mouse, start is where the initial click was, and you\n   // can drag in either direction)\n\n   unsigned char insert_mode;\n   // each textfield keeps its own insert mode state. to keep an app-wide\n   // insert mode, copy this value in/out of the app state\n\n   int row_count_per_page;\n   // page size in number of row.\n   // this value MUST be set to >0 for pageup or pagedown in multilines documents.\n\n   /////////////////////\n   //\n   // private data\n   //\n   unsigned char cursor_at_end_of_line; // not implemented yet\n   unsigned char initialized;\n   unsigned char has_preferred_x;\n   unsigned char single_line;\n   unsigned char padding1, padding2, padding3;\n   float preferred_x; // this determines where the cursor up/down tries to seek to along x\n   StbUndoState undostate;\n} STB_TexteditState;\n\n\n////////////////////////////////////////////////////////////////////////\n//\n//     StbTexteditRow\n//\n// Result of layout query, used by stb_textedit to determine where\n// the text in each row is.\n\n// result of layout query\ntypedef struct\n{\n   float x0,x1;             // starting x location, end x location (allows for align=right, etc)\n   float baseline_y_delta;  // position of baseline relative to previous row's baseline\n   float ymin,ymax;         // height of row above and below baseline\n   int num_chars;\n} StbTexteditRow;\n#endif //INCLUDE_IMSTB_TEXTEDIT_H\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////\n////   Implementation mode\n////\n////\n\n\n// implementation isn't include-guarded, since it might have indirectly\n// included just the \"header\" portion\n#ifdef IMSTB_TEXTEDIT_IMPLEMENTATION\n\n#ifndef IMSTB_TEXTEDIT_memmove\n#include <string.h>\n#define IMSTB_TEXTEDIT_memmove memmove\n#endif\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//      Mouse input handling\n//\n\n// traverse the layout to locate the nearest character to a display position\nstatic int stb_text_locate_coord(IMSTB_TEXTEDIT_STRING *str, float x, float y)\n{\n   StbTexteditRow r;\n   int n = STB_TEXTEDIT_STRINGLEN(str);\n   float base_y = 0, prev_x;\n   int i=0, k;\n\n   r.x0 = r.x1 = 0;\n   r.ymin = r.ymax = 0;\n   r.num_chars = 0;\n\n   // search rows to find one that straddles 'y'\n   while (i < n) {\n      STB_TEXTEDIT_LAYOUTROW(&r, str, i);\n      if (r.num_chars <= 0)\n         return n;\n\n      if (i==0 && y < base_y + r.ymin)\n         return 0;\n\n      if (y < base_y + r.ymax)\n         break;\n\n      i += r.num_chars;\n      base_y += r.baseline_y_delta;\n   }\n\n   // below all text, return 'after' last character\n   if (i >= n)\n      return n;\n\n   // check if it's before the beginning of the line\n   if (x < r.x0)\n      return i;\n\n   // check if it's before the end of the line\n   if (x < r.x1) {\n      // search characters in row for one that straddles 'x'\n      prev_x = r.x0;\n      for (k=0; k < r.num_chars; k = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, i + k) - i) {\n         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);\n         if (x < prev_x+w) {\n            if (x < prev_x+w/2)\n               return k+i;\n            else\n               return IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, i + k);\n         }\n         prev_x += w;\n      }\n      // shouldn't happen, but if it does, fall through to end-of-line case\n   }\n\n   // if the last character is a newline, return that. otherwise return 'after' the last character\n   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)\n      return i+r.num_chars-1;\n   else\n      return i+r.num_chars;\n}\n\n// API click: on mouse down, move the cursor to the clicked location, and reset the selection\nstatic void stb_textedit_click(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n{\n   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse\n   // goes off the top or bottom of the text\n   if( state->single_line )\n   {\n      StbTexteditRow r;\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\n      y = r.ymin;\n   }\n\n   state->cursor = stb_text_locate_coord(str, x, y);\n   state->select_start = state->cursor;\n   state->select_end = state->cursor;\n   state->has_preferred_x = 0;\n}\n\n// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location\nstatic void stb_textedit_drag(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n{\n   int p = 0;\n\n   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse\n   // goes off the top or bottom of the text\n   if( state->single_line )\n   {\n      StbTexteditRow r;\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\n      y = r.ymin;\n   }\n\n   if (state->select_start == state->select_end)\n      state->select_start = state->cursor;\n\n   p = stb_text_locate_coord(str, x, y);\n   state->cursor = state->select_end = p;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//      Keyboard input handling\n//\n\n// forward declarations\nstatic void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);\nstatic void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);\nstatic void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);\nstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);\nstatic void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);\n\ntypedef struct\n{\n   float x,y;    // position of n'th character\n   float height; // height of line\n   int first_char, length; // first char of row, and length\n   int prev_first;  // first char of previous row\n} StbFindState;\n\n// find the x/y location of a character, and remember info about the previous row in\n// case we get a move-up event (for page up, we'll have to rescan)\nstatic void stb_textedit_find_charpos(StbFindState *find, IMSTB_TEXTEDIT_STRING *str, int n, int single_line)\n{\n   StbTexteditRow r;\n   int prev_start = 0;\n   int z = STB_TEXTEDIT_STRINGLEN(str);\n   int i=0, first;\n\n   if (n == z && single_line) {\n      // special case if it's at the end (may not be needed?)\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\n      find->y = 0;\n      find->first_char = 0;\n      find->length = z;\n      find->height = r.ymax - r.ymin;\n      find->x = r.x1;\n      return;\n   }\n\n   // search rows to find the one that straddles character n\n   find->y = 0;\n\n   for(;;) {\n      STB_TEXTEDIT_LAYOUTROW(&r, str, i);\n      if (n < i + r.num_chars)\n         break;\n      if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE)  // [DEAR IMGUI] special handling for last line\n         break;   // [DEAR IMGUI]\n      prev_start = i;\n      i += r.num_chars;\n      find->y += r.baseline_y_delta;\n      if (i == z) // [DEAR IMGUI]\n      {\n         r.num_chars = 0; // [DEAR IMGUI]\n         break;   // [DEAR IMGUI]\n      }\n   }\n\n   find->first_char = first = i;\n   find->length = r.num_chars;\n   find->height = r.ymax - r.ymin;\n   find->prev_first = prev_start;\n\n   // now scan to find xpos\n   find->x = r.x0;\n   for (i=0; first+i < n; i = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, first + i) - first)\n      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);\n}\n\n#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)\n\n// make the selection/cursor state valid if client altered the string\nstatic void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   int n = STB_TEXTEDIT_STRINGLEN(str);\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      if (state->select_start > n) state->select_start = n;\n      if (state->select_end   > n) state->select_end = n;\n      // if clamping forced them to be equal, move the cursor to match\n      if (state->select_start == state->select_end)\n         state->cursor = state->select_start;\n   }\n   if (state->cursor > n) state->cursor = n;\n}\n\n// delete characters while updating undo\nstatic void stb_textedit_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)\n{\n   stb_text_makeundo_delete(str, state, where, len);\n   STB_TEXTEDIT_DELETECHARS(str, where, len);\n   state->has_preferred_x = 0;\n}\n\n// delete the section\nstatic void stb_textedit_delete_selection(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   stb_textedit_clamp(str, state);\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      if (state->select_start < state->select_end) {\n         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);\n         state->select_end = state->cursor = state->select_start;\n      } else {\n         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);\n         state->select_start = state->cursor = state->select_end;\n      }\n      state->has_preferred_x = 0;\n   }\n}\n\n// canoncialize the selection so start <= end\nstatic void stb_textedit_sortselection(STB_TexteditState *state)\n{\n   if (state->select_end < state->select_start) {\n      int temp = state->select_end;\n      state->select_end = state->select_start;\n      state->select_start = temp;\n   }\n}\n\n// move cursor to first character of selection\nstatic void stb_textedit_move_to_first(STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_sortselection(state);\n      state->cursor = state->select_start;\n      state->select_end = state->select_start;\n      state->has_preferred_x = 0;\n   }\n}\n\n// move cursor to last character of selection\nstatic void stb_textedit_move_to_last(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_sortselection(state);\n      stb_textedit_clamp(str, state);\n      state->cursor = state->select_end;\n      state->select_start = state->select_end;\n      state->has_preferred_x = 0;\n   }\n}\n\n// [DEAR IMGUI]\n// Functions must be implemented for UTF8 support\n// Code in this file that uses those functions is modified for [DEAR IMGUI] and deviates from the original stb_textedit.\n// There is not necessarily a '[DEAR IMGUI]' at the usage sites.\n#ifndef IMSTB_TEXTEDIT_GETPREVCHARINDEX\n#define IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx) (idx - 1)\n#endif\n#ifndef IMSTB_TEXTEDIT_GETNEXTCHARINDEX\n#define IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx) (idx + 1)\n#endif\n\n#ifdef STB_TEXTEDIT_IS_SPACE\nstatic int is_word_boundary( IMSTB_TEXTEDIT_STRING *str, int idx )\n{\n   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;\n}\n\n#ifndef STB_TEXTEDIT_MOVEWORDLEFT\nstatic int stb_textedit_move_to_word_previous( IMSTB_TEXTEDIT_STRING *str, int c )\n{\n   --c; // always move at least one character\n   while( c >= 0 && !is_word_boundary( str, c ) )\n      --c;\n\n   if( c < 0 )\n      c = 0;\n\n   return c;\n}\n#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous\n#endif\n\n#ifndef STB_TEXTEDIT_MOVEWORDRIGHT\nstatic int stb_textedit_move_to_word_next( IMSTB_TEXTEDIT_STRING *str, int c )\n{\n   const int len = STB_TEXTEDIT_STRINGLEN(str);\n   ++c; // always move at least one character\n   while( c < len && !is_word_boundary( str, c ) )\n      ++c;\n\n   if( c > len )\n      c = len;\n\n   return c;\n}\n#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next\n#endif\n\n#endif\n\n// update selection and cursor to match each other\nstatic void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)\n{\n   if (!STB_TEXT_HAS_SELECTION(state))\n      state->select_start = state->select_end = state->cursor;\n   else\n      state->cursor = state->select_end;\n}\n\n// API cut: delete selection\nstatic int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_delete_selection(str,state); // implicitly clamps\n      state->has_preferred_x = 0;\n      return 1;\n   }\n   return 0;\n}\n\n// API paste: replace existing selection with passed-in text\nstatic int stb_textedit_paste_internal(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE *text, int len)\n{\n   // if there's a selection, the paste should delete it\n   stb_textedit_clamp(str, state);\n   stb_textedit_delete_selection(str,state);\n   // try to insert the characters\n   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {\n      stb_text_makeundo_insert(state, state->cursor, len);\n      state->cursor += len;\n      state->has_preferred_x = 0;\n      return 1;\n   }\n   // note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)\n   return 0;\n}\n\n#ifndef STB_TEXTEDIT_KEYTYPE\n#define STB_TEXTEDIT_KEYTYPE int\n#endif\n\n// [DEAR IMGUI] Added stb_textedit_text(), extracted out and called by stb_textedit_key() for backward compatibility.\nstatic void stb_textedit_text(IMSTB_TEXTEDIT_STRING* str, STB_TexteditState* state, const IMSTB_TEXTEDIT_CHARTYPE* text, int text_len)\n{\n   // can't add newline in single-line mode\n   if (text[0] == '\\n' && state->single_line)\n      return;\n\n   if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {\n      stb_text_makeundo_replace(str, state, state->cursor, 1, 1);\n      STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);\n      if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, text_len)) {\n         state->cursor += text_len;\n         state->has_preferred_x = 0;\n      }\n   }\n   else {\n      stb_textedit_delete_selection(str, state); // implicitly clamps\n      if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, text_len)) {\n         stb_text_makeundo_insert(state, state->cursor, text_len);\n         state->cursor += text_len;\n         state->has_preferred_x = 0;\n      }\n   }\n}\n\n// API key: process a keyboard input\nstatic void stb_textedit_key(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)\n{\nretry:\n   switch (key) {\n      default: {\n#ifdef STB_TEXTEDIT_KEYTOTEXT\n         int c = STB_TEXTEDIT_KEYTOTEXT(key);\n         if (c > 0) {\n            IMSTB_TEXTEDIT_CHARTYPE ch = (IMSTB_TEXTEDIT_CHARTYPE)c;\n            stb_textedit_text(str, state, &ch, 1);\n         }\n#endif\n         break;\n      }\n\n#ifdef STB_TEXTEDIT_K_INSERT\n      case STB_TEXTEDIT_K_INSERT:\n         state->insert_mode = !state->insert_mode;\n         break;\n#endif\n\n      case STB_TEXTEDIT_K_UNDO:\n         stb_text_undo(str, state);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_REDO:\n         stb_text_redo(str, state);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_LEFT:\n         // if currently there's a selection, move cursor to start of selection\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_first(state);\n         else\n            if (state->cursor > 0)\n               state->cursor = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state->cursor);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_RIGHT:\n         // if currently there's a selection, move cursor to end of selection\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_last(str, state);\n         else\n            state->cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor);\n         stb_textedit_clamp(str, state);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_clamp(str, state);\n         stb_textedit_prep_selection_at_cursor(state);\n         // move selection left\n         if (state->select_end > 0)\n            state->select_end = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state->select_end);\n         state->cursor = state->select_end;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_MOVEWORDLEFT\n      case STB_TEXTEDIT_K_WORDLEFT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_first(state);\n         else {\n            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);\n            stb_textedit_clamp( str, state );\n         }\n         break;\n\n      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:\n         if( !STB_TEXT_HAS_SELECTION( state ) )\n            stb_textedit_prep_selection_at_cursor(state);\n\n         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);\n         state->select_end = state->cursor;\n\n         stb_textedit_clamp( str, state );\n         break;\n#endif\n\n#ifdef STB_TEXTEDIT_MOVEWORDRIGHT\n      case STB_TEXTEDIT_K_WORDRIGHT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_last(str, state);\n         else {\n            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);\n            stb_textedit_clamp( str, state );\n         }\n         break;\n\n      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:\n         if( !STB_TEXT_HAS_SELECTION( state ) )\n            stb_textedit_prep_selection_at_cursor(state);\n\n         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);\n         state->select_end = state->cursor;\n\n         stb_textedit_clamp( str, state );\n         break;\n#endif\n\n      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_prep_selection_at_cursor(state);\n         // move selection right\n         state->select_end = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->select_end);\n         stb_textedit_clamp(str, state);\n         state->cursor = state->select_end;\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_DOWN:\n      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:\n      case STB_TEXTEDIT_K_PGDOWN:\n      case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {\n         StbFindState find;\n         StbTexteditRow row;\n         int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;\n         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;\n         int row_count = is_page ? state->row_count_per_page : 1;\n\n         if (!is_page && state->single_line) {\n            // on windows, up&down in single-line behave like left&right\n            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);\n            goto retry;\n         }\n\n         if (sel)\n            stb_textedit_prep_selection_at_cursor(state);\n         else if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_last(str, state);\n\n         // compute current position of cursor point\n         stb_textedit_clamp(str, state);\n         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);\n\n         for (j = 0; j < row_count; ++j) {\n            float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;\n            int start = find.first_char + find.length;\n\n            if (find.length == 0)\n               break;\n\n            // [DEAR IMGUI]\n            // going down while being on the last line shouldn't bring us to that line end\n            if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)\n               break;\n\n            // now find character position down a row\n            state->cursor = start;\n            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);\n            x = row.x0;\n            for (i=0; i < row.num_chars; ++i) {\n               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);\n               #ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE\n               if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)\n                  break;\n               #endif\n               x += dx;\n               if (x > goal_x)\n                  break;\n               state->cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor);\n            }\n            stb_textedit_clamp(str, state);\n\n            state->has_preferred_x = 1;\n            state->preferred_x = goal_x;\n\n            if (sel)\n               state->select_end = state->cursor;\n\n            // go to next line\n            find.first_char = find.first_char + find.length;\n            find.length = row.num_chars;\n         }\n         break;\n      }\n\n      case STB_TEXTEDIT_K_UP:\n      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:\n      case STB_TEXTEDIT_K_PGUP:\n      case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {\n         StbFindState find;\n         StbTexteditRow row;\n         int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;\n         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;\n         int row_count = is_page ? state->row_count_per_page : 1;\n\n         if (!is_page && state->single_line) {\n            // on windows, up&down become left&right\n            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);\n            goto retry;\n         }\n\n         if (sel)\n            stb_textedit_prep_selection_at_cursor(state);\n         else if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_first(state);\n\n         // compute current position of cursor point\n         stb_textedit_clamp(str, state);\n         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);\n\n         for (j = 0; j < row_count; ++j) {\n            float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;\n\n            // can only go up if there's a previous row\n            if (find.prev_first == find.first_char)\n               break;\n\n            // now find character position up a row\n            state->cursor = find.prev_first;\n            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);\n            x = row.x0;\n            for (i=0; i < row.num_chars; ++i) {\n               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);\n               #ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE\n               if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)\n                  break;\n               #endif\n               x += dx;\n               if (x > goal_x)\n                  break;\n               state->cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor);\n            }\n            stb_textedit_clamp(str, state);\n\n            state->has_preferred_x = 1;\n            state->preferred_x = goal_x;\n\n            if (sel)\n               state->select_end = state->cursor;\n\n            // go to previous line\n            // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)\n            prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;\n            while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)\n               --prev_scan;\n            find.first_char = find.prev_first;\n            find.prev_first = prev_scan;\n         }\n         break;\n      }\n\n      case STB_TEXTEDIT_K_DELETE:\n      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_delete_selection(str, state);\n         else {\n            int n = STB_TEXTEDIT_STRINGLEN(str);\n            if (state->cursor < n)\n               stb_textedit_delete(str, state, state->cursor, IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor) - state->cursor);\n         }\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_BACKSPACE:\n      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_delete_selection(str, state);\n         else {\n            stb_textedit_clamp(str, state);\n            if (state->cursor > 0) {\n               int prev = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state->cursor);\n               stb_textedit_delete(str, state, prev, state->cursor - prev);\n               state->cursor = prev;\n            }\n         }\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTSTART2\n      case STB_TEXTEDIT_K_TEXTSTART2:\n#endif\n      case STB_TEXTEDIT_K_TEXTSTART:\n         state->cursor = state->select_start = state->select_end = 0;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTEND2\n      case STB_TEXTEDIT_K_TEXTEND2:\n#endif\n      case STB_TEXTEDIT_K_TEXTEND:\n         state->cursor = STB_TEXTEDIT_STRINGLEN(str);\n         state->select_start = state->select_end = 0;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTSTART2\n      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_prep_selection_at_cursor(state);\n         state->cursor = state->select_end = 0;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTEND2\n      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_prep_selection_at_cursor(state);\n         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);\n         state->has_preferred_x = 0;\n         break;\n\n\n#ifdef STB_TEXTEDIT_K_LINESTART2\n      case STB_TEXTEDIT_K_LINESTART2:\n#endif\n      case STB_TEXTEDIT_K_LINESTART:\n         stb_textedit_clamp(str, state);\n         stb_textedit_move_to_first(state);\n         if (state->single_line)\n            state->cursor = 0;\n         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)\n            --state->cursor;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_LINEEND2\n      case STB_TEXTEDIT_K_LINEEND2:\n#endif\n      case STB_TEXTEDIT_K_LINEEND: {\n         int n = STB_TEXTEDIT_STRINGLEN(str);\n         stb_textedit_clamp(str, state);\n         stb_textedit_move_to_first(state);\n         if (state->single_line)\n             state->cursor = n;\n         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)\n             ++state->cursor;\n         state->has_preferred_x = 0;\n         break;\n      }\n\n#ifdef STB_TEXTEDIT_K_LINESTART2\n      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_clamp(str, state);\n         stb_textedit_prep_selection_at_cursor(state);\n         if (state->single_line)\n            state->cursor = 0;\n         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)\n            --state->cursor;\n         state->select_end = state->cursor;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_LINEEND2\n      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {\n         int n = STB_TEXTEDIT_STRINGLEN(str);\n         stb_textedit_clamp(str, state);\n         stb_textedit_prep_selection_at_cursor(state);\n         if (state->single_line)\n             state->cursor = n;\n         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)\n            ++state->cursor;\n         state->select_end = state->cursor;\n         state->has_preferred_x = 0;\n         break;\n      }\n   }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//      Undo processing\n//\n// @OPTIMIZE: the undo/redo buffer should be circular\n\nstatic void stb_textedit_flush_redo(StbUndoState *state)\n{\n   state->redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;\n   state->redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;\n}\n\n// discard the oldest entry in the undo list\nstatic void stb_textedit_discard_undo(StbUndoState *state)\n{\n   if (state->undo_point > 0) {\n      // if the 0th undo state has characters, clean those up\n      if (state->undo_rec[0].char_storage >= 0) {\n         int n = state->undo_rec[0].insert_length, i;\n         // delete n characters from all other records\n         state->undo_char_point -= n;\n         IMSTB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(IMSTB_TEXTEDIT_CHARTYPE)));\n         for (i=0; i < state->undo_point; ++i)\n            if (state->undo_rec[i].char_storage >= 0)\n               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it\n      }\n      --state->undo_point;\n      IMSTB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));\n   }\n}\n\n// discard the oldest entry in the redo list--it's bad if this\n// ever happens, but because undo & redo have to store the actual\n// characters in different cases, the redo character buffer can\n// fill up even though the undo buffer didn't\nstatic void stb_textedit_discard_redo(StbUndoState *state)\n{\n   int k = IMSTB_TEXTEDIT_UNDOSTATECOUNT-1;\n\n   if (state->redo_point <= k) {\n      // if the k'th undo state has characters, clean those up\n      if (state->undo_rec[k].char_storage >= 0) {\n         int n = state->undo_rec[k].insert_length, i;\n         // move the remaining redo character data to the end of the buffer\n         state->redo_char_point += n;\n         IMSTB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((IMSTB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(IMSTB_TEXTEDIT_CHARTYPE)));\n         // adjust the position of all the other records to account for above memmove\n         for (i=state->redo_point; i < k; ++i)\n            if (state->undo_rec[i].char_storage >= 0)\n               state->undo_rec[i].char_storage += n;\n      }\n      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'\n      // [DEAR IMGUI]\n      size_t move_size = (size_t)((IMSTB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));\n      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;\n      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;\n      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);\n      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);\n      IMSTB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);\n\n      // now move redo_point to point to the new one\n      ++state->redo_point;\n   }\n}\n\nstatic StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)\n{\n   // any time we create a new undo record, we discard redo\n   stb_textedit_flush_redo(state);\n\n   // if we have no free records, we have to make room, by sliding the\n   // existing records down\n   if (state->undo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)\n      stb_textedit_discard_undo(state);\n\n   // if the characters to store won't possibly fit in the buffer, we can't undo\n   if (numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT) {\n      state->undo_point = 0;\n      state->undo_char_point = 0;\n      return NULL;\n   }\n\n   // if we don't have enough free characters in the buffer, we have to make room\n   while (state->undo_char_point + numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT)\n      stb_textedit_discard_undo(state);\n\n   return &state->undo_rec[state->undo_point++];\n}\n\nstatic IMSTB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)\n{\n   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);\n   if (r == NULL)\n      return NULL;\n\n   r->where = pos;\n   r->insert_length = (IMSTB_TEXTEDIT_POSITIONTYPE) insert_len;\n   r->delete_length = (IMSTB_TEXTEDIT_POSITIONTYPE) delete_len;\n\n   if (insert_len == 0) {\n      r->char_storage = -1;\n      return NULL;\n   } else {\n      r->char_storage = state->undo_char_point;\n      state->undo_char_point += insert_len;\n      return &state->undo_char[r->char_storage];\n   }\n}\n\nstatic void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   StbUndoState *s = &state->undostate;\n   StbUndoRecord u, *r;\n   if (s->undo_point == 0)\n      return;\n\n   // we need to do two things: apply the undo record, and create a redo record\n   u = s->undo_rec[s->undo_point-1];\n   r = &s->undo_rec[s->redo_point-1];\n   r->char_storage = -1;\n\n   r->insert_length = u.delete_length;\n   r->delete_length = u.insert_length;\n   r->where = u.where;\n\n   if (u.delete_length) {\n      // if the undo record says to delete characters, then the redo record will\n      // need to re-insert the characters that get deleted, so we need to store\n      // them.\n\n      // there are three cases:\n      //    there's enough room to store the characters\n      //    characters stored for *redoing* don't leave room for redo\n      //    characters stored for *undoing* don't leave room for redo\n      // if the last is true, we have to bail\n\n      if (s->undo_char_point + u.delete_length >= IMSTB_TEXTEDIT_UNDOCHARCOUNT) {\n         // the undo records take up too much character space; there's no space to store the redo characters\n         r->insert_length = 0;\n      } else {\n         int i;\n\n         // there's definitely room to store the characters eventually\n         while (s->undo_char_point + u.delete_length > s->redo_char_point) {\n            // should never happen:\n            if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)\n               return;\n            // there's currently not enough room, so discard a redo record\n            stb_textedit_discard_redo(s);\n         }\n         r = &s->undo_rec[s->redo_point-1];\n\n         r->char_storage = s->redo_char_point - u.delete_length;\n         s->redo_char_point = s->redo_char_point - u.delete_length;\n\n         // now save the characters\n         for (i=0; i < u.delete_length; ++i)\n            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);\n      }\n\n      // now we can carry out the deletion\n      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);\n   }\n\n   // check type of recorded action:\n   if (u.insert_length) {\n      // easy case: was a deletion, so we need to insert n characters\n      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);\n      s->undo_char_point -= u.insert_length;\n   }\n\n   state->cursor = u.where + u.insert_length;\n\n   s->undo_point--;\n   s->redo_point--;\n}\n\nstatic void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   StbUndoState *s = &state->undostate;\n   StbUndoRecord *u, r;\n   if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)\n      return;\n\n   // we need to do two things: apply the redo record, and create an undo record\n   u = &s->undo_rec[s->undo_point];\n   r = s->undo_rec[s->redo_point];\n\n   // we KNOW there must be room for the undo record, because the redo record\n   // was derived from an undo record\n\n   u->delete_length = r.insert_length;\n   u->insert_length = r.delete_length;\n   u->where = r.where;\n   u->char_storage = -1;\n\n   if (r.delete_length) {\n      // the redo record requires us to delete characters, so the undo record\n      // needs to store the characters\n\n      if (s->undo_char_point + u->insert_length > s->redo_char_point) {\n         u->insert_length = 0;\n         u->delete_length = 0;\n      } else {\n         int i;\n         u->char_storage = s->undo_char_point;\n         s->undo_char_point = s->undo_char_point + u->insert_length;\n\n         // now save the characters\n         for (i=0; i < u->insert_length; ++i)\n            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);\n      }\n\n      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);\n   }\n\n   if (r.insert_length) {\n      // easy case: need to insert n characters\n      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);\n      s->redo_char_point += r.insert_length;\n   }\n\n   state->cursor = r.where + r.insert_length;\n\n   s->undo_point++;\n   s->redo_point++;\n}\n\nstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)\n{\n   stb_text_createundo(&state->undostate, where, 0, length);\n}\n\nstatic void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)\n{\n   int i;\n   IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);\n   if (p) {\n      for (i=0; i < length; ++i)\n         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);\n   }\n}\n\nstatic void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)\n{\n   int i;\n   IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);\n   if (p) {\n      for (i=0; i < old_length; ++i)\n         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);\n   }\n}\n\n// reset the state to default\nstatic void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)\n{\n   state->undostate.undo_point = 0;\n   state->undostate.undo_char_point = 0;\n   state->undostate.redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;\n   state->undostate.redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;\n   state->select_end = state->select_start = 0;\n   state->cursor = 0;\n   state->has_preferred_x = 0;\n   state->preferred_x = 0;\n   state->cursor_at_end_of_line = 0;\n   state->initialized = 1;\n   state->single_line = (unsigned char) is_single_line;\n   state->insert_mode = 0;\n   state->row_count_per_page = 0;\n}\n\n// API initialize\nstatic void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)\n{\n   stb_textedit_clear_state(state, is_single_line);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\nstatic int stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len)\n{\n   return stb_textedit_paste_internal(str, state, (IMSTB_TEXTEDIT_CHARTYPE *) ctext, len);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif//IMSTB_TEXTEDIT_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "imstb_truetype.h",
          "type": "blob",
          "size": 194.81,
          "content": "// [DEAR IMGUI]\n// This is a slightly modified version of stb_truetype.h 1.26.\n// Mostly fixing for compiler and static analyzer warnings.\n// Grep for [DEAR IMGUI] to find the changes.\n\n// stb_truetype.h - v1.26 - public domain\n// authored from 2009-2021 by Sean Barrett / RAD Game Tools\n//\n// =======================================================================\n//\n//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES\n//\n// This library does no range checking of the offsets found in the file,\n// meaning an attacker can use it to read arbitrary memory.\n//\n// =======================================================================\n//\n//   This library processes TrueType files:\n//        parse files\n//        extract glyph metrics\n//        extract glyph shapes\n//        render glyphs to one-channel bitmaps with antialiasing (box filter)\n//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)\n//\n//   Todo:\n//        non-MS cmaps\n//        crashproof on bad data\n//        hinting? (no longer patented)\n//        cleartype-style AA?\n//        optimize: use simple memory allocator for intermediates\n//        optimize: build edge-list directly from curves\n//        optimize: rasterize directly from curves?\n//\n// ADDITIONAL CONTRIBUTORS\n//\n//   Mikko Mononen: compound shape support, more cmap formats\n//   Tor Andersson: kerning, subpixel rendering\n//   Dougall Johnson: OpenType / Type 2 font handling\n//   Daniel Ribeiro Maciel: basic GPOS-based kerning\n//\n//   Misc other:\n//       Ryan Gordon\n//       Simon Glass\n//       github:IntellectualKitty\n//       Imanol Celaya\n//       Daniel Ribeiro Maciel\n//\n//   Bug/warning reports/fixes:\n//       \"Zer\" on mollyrocket       Fabian \"ryg\" Giesen   github:NiLuJe\n//       Cass Everitt               Martins Mozeiko       github:aloucks\n//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam\n//       Brian Hook                 Omar Cornut           github:vassvik\n//       Walter van Niftrik         Ryan Griege\n//       David Gow                  Peter LaValle\n//       David Given                Sergey Popov\n//       Ivan-Assen Ivanov          Giumo X. Clanjor\n//       Anthony Pesch              Higor Euripedes\n//       Johan Duparc               Thomas Fields\n//       Hou Qiming                 Derek Vinyard\n//       Rob Loach                  Cort Stratton\n//       Kenney Phillis Jr.         Brian Costabile\n//       Ken Voskuil (kaesve)\n//\n// VERSION HISTORY\n//\n//   1.26 (2021-08-28) fix broken rasterizer\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     variant PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//\n//   Full history can be found at the end of this file.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// USAGE\n//\n//   Include this file in whatever places need to refer to it. In ONE C/C++\n//   file, write:\n//      #define STB_TRUETYPE_IMPLEMENTATION\n//   before the #include of this file. This expands out the actual\n//   implementation into that C/C++ file.\n//\n//   To make the implementation private to the file that generates the implementation,\n//      #define STBTT_STATIC\n//\n//   Simple 3D API (don't ship this, but it's fine for tools and quick start)\n//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture\n//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char\n//\n//   Improved 3D API (more shippable):\n//           #include \"stb_rect_pack.h\"           -- optional, but you really want it\n//           stbtt_PackBegin()\n//           stbtt_PackSetOversampling()          -- for improved quality on small fonts\n//           stbtt_PackFontRanges()               -- pack and renders\n//           stbtt_PackEnd()\n//           stbtt_GetPackedQuad()\n//\n//   \"Load\" a font file from a memory buffer (you have to keep the buffer loaded)\n//           stbtt_InitFont()\n//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections\n//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections\n//\n//   Render a unicode codepoint to a bitmap\n//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap\n//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide\n//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be\n//\n//   Character advance/positioning\n//           stbtt_GetCodepointHMetrics()\n//           stbtt_GetFontVMetrics()\n//           stbtt_GetFontVMetricsOS2()\n//           stbtt_GetCodepointKernAdvance()\n//\n//   Starting with version 1.06, the rasterizer was replaced with a new,\n//   faster and generally-more-precise rasterizer. The new rasterizer more\n//   accurately measures pixel coverage for anti-aliasing, except in the case\n//   where multiple shapes overlap, in which case it overestimates the AA pixel\n//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If\n//   this turns out to be a problem, you can re-enable the old rasterizer with\n//        #define STBTT_RASTERIZER_VERSION 1\n//   which will incur about a 15% speed hit.\n//\n// ADDITIONAL DOCUMENTATION\n//\n//   Immediately after this block comment are a series of sample programs.\n//\n//   After the sample programs is the \"header file\" section. This section\n//   includes documentation for each API function.\n//\n//   Some important concepts to understand to use this library:\n//\n//      Codepoint\n//         Characters are defined by unicode codepoints, e.g. 65 is\n//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is\n//         the hiragana for \"ma\".\n//\n//      Glyph\n//         A visual character shape (every codepoint is rendered as\n//         some glyph)\n//\n//      Glyph index\n//         A font-specific integer ID representing a glyph\n//\n//      Baseline\n//         Glyph shapes are defined relative to a baseline, which is the\n//         bottom of uppercase characters. Characters extend both above\n//         and below the baseline.\n//\n//      Current Point\n//         As you draw text to the screen, you keep track of a \"current point\"\n//         which is the origin of each character. The current point's vertical\n//         position is the baseline. Even \"baked fonts\" use this model.\n//\n//      Vertical Font Metrics\n//         The vertical qualities of the font, used to vertically position\n//         and space the characters. See docs for stbtt_GetFontVMetrics.\n//\n//      Font Size in Pixels or Points\n//         The preferred interface for specifying font sizes in stb_truetype\n//         is to specify how tall the font's vertical extent should be in pixels.\n//         If that sounds good enough, skip the next paragraph.\n//\n//         Most font APIs instead use \"points\", which are a common typographic\n//         measurement for describing font size, defined as 72 points per inch.\n//         stb_truetype provides a point API for compatibility. However, true\n//         \"per inch\" conventions don't make much sense on computer displays\n//         since different monitors have different number of pixels per\n//         inch. For example, Windows traditionally uses a convention that\n//         there are 96 pixels per inch, thus making 'inch' measurements have\n//         nothing to do with inches, and thus effectively defining a point to\n//         be 1.333 pixels. Additionally, the TrueType font data provides\n//         an explicit scale factor to scale a given font's glyphs to points,\n//         but the author has observed that this scale factor is often wrong\n//         for non-commercial fonts, thus making fonts scaled in points\n//         according to the TrueType spec incoherently sized in practice.\n//\n// DETAILED USAGE:\n//\n//  Scale:\n//    Select how high you want the font to be, in points or pixels.\n//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute\n//    a scale factor SF that will be used by all other functions.\n//\n//  Baseline:\n//    You need to select a y-coordinate that is the baseline of where\n//    your text will appear. Call GetFontBoundingBox to get the baseline-relative\n//    bounding box for all characters. SF*-y0 will be the distance in pixels\n//    that the worst-case character could extend above the baseline, so if\n//    you want the top edge of characters to appear at the top of the\n//    screen where y=0, then you would set the baseline to SF*-y0.\n//\n//  Current point:\n//    Set the current point where the first character will appear. The\n//    first character could extend left of the current point; this is font\n//    dependent. You can either choose a current point that is the leftmost\n//    point and hope, or add some padding, or check the bounding box or\n//    left-side-bearing of the first character to be displayed and set\n//    the current point based on that.\n//\n//  Displaying a character:\n//    Compute the bounding box of the character. It will contain signed values\n//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,\n//    then the character should be displayed in the rectangle from\n//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).\n//\n//  Advancing for the next character:\n//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.\n//\n//\n// ADVANCED USAGE\n//\n//   Quality:\n//\n//    - Use the functions with Subpixel at the end to allow your characters\n//      to have subpixel positioning. Since the font is anti-aliased, not\n//      hinted, this is very import for quality. (This is not possible with\n//      baked fonts.)\n//\n//    - Kerning is now supported, and if you're supporting subpixel rendering\n//      then kerning is worth using to give your text a polished look.\n//\n//   Performance:\n//\n//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;\n//      if you don't do this, stb_truetype is forced to do the conversion on\n//      every call.\n//\n//    - There are a lot of memory allocations. We should modify it to take\n//      a temp buffer and allocate from the temp buffer (without freeing),\n//      should help performance a lot.\n//\n// NOTES\n//\n//   The system uses the raw data found in the .ttf file without changing it\n//   and without building auxiliary data structures. This is a bit inefficient\n//   on little-endian systems (the data is big-endian), but assuming you're\n//   caching the bitmaps or glyph shapes this shouldn't be a big deal.\n//\n//   It appears to be very hard to programmatically determine what font a\n//   given file is in a general way. I provide an API for this, but I don't\n//   recommend it.\n//\n//\n// PERFORMANCE MEASUREMENTS FOR 1.06:\n//\n//                      32-bit     64-bit\n//   Previous release:  8.83 s     7.68 s\n//   Pool allocations:  7.72 s     6.34 s\n//   Inline sort     :  6.54 s     5.65 s\n//   New rasterizer  :  5.63 s     5.00 s\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////  SAMPLE PROGRAMS\n////\n//\n//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.\n//  See \"tests/truetype_demo_win32.c\" for a complete version.\n#if 0\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\n#include \"stb_truetype.h\"\n\nunsigned char ttf_buffer[1<<20];\nunsigned char temp_bitmap[512*512];\n\nstbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs\nGLuint ftex;\n\nvoid my_stbtt_initfont(void)\n{\n   fread(ttf_buffer, 1, 1<<20, fopen(\"c:/windows/fonts/times.ttf\", \"rb\"));\n   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!\n   // can free ttf_buffer at this point\n   glGenTextures(1, &ftex);\n   glBindTexture(GL_TEXTURE_2D, ftex);\n   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);\n   // can free temp_bitmap at this point\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n}\n\nvoid my_stbtt_print(float x, float y, char *text)\n{\n   // assume orthographic projection with units = screen pixels, origin at top left\n   glEnable(GL_BLEND);\n   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n   glEnable(GL_TEXTURE_2D);\n   glBindTexture(GL_TEXTURE_2D, ftex);\n   glBegin(GL_QUADS);\n   while (*text) {\n      if (*text >= 32 && *text < 128) {\n         stbtt_aligned_quad q;\n         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9\n         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);\n         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);\n         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);\n         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);\n      }\n      ++text;\n   }\n   glEnd();\n}\n#endif\n//\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program (this compiles): get a single bitmap, print as ASCII art\n//\n#if 0\n#include <stdio.h>\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\n#include \"stb_truetype.h\"\n\nchar ttf_buffer[1<<25];\n\nint main(int argc, char **argv)\n{\n   stbtt_fontinfo font;\n   unsigned char *bitmap;\n   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);\n\n   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : \"c:/windows/fonts/arialbd.ttf\", \"rb\"));\n\n   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));\n   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);\n\n   for (j=0; j < h; ++j) {\n      for (i=0; i < w; ++i)\n         putchar(\" .:ioVM@\"[bitmap[j*w+i]>>5]);\n      putchar('\\n');\n   }\n   return 0;\n}\n#endif\n//\n// Output:\n//\n//     .ii.\n//    @@@@@@.\n//   V@Mio@@o\n//   :i.  V@V\n//     :oM@@M\n//   :@@@MM@M\n//   @@o  o@M\n//  :@@.  M@M\n//   @@@o@@@@\n//   :M@@V:@@.\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program: print \"Hello World!\" banner, with bugs\n//\n#if 0\nchar buffer[24<<20];\nunsigned char screen[20][79];\n\nint main(int arg, char **argv)\n{\n   stbtt_fontinfo font;\n   int i,j,ascent,baseline,ch=0;\n   float scale, xpos=2; // leave a little padding in case the character extends left\n   char *text = \"Heljo World!\"; // intentionally misspelled to show 'lj' brokenness\n\n   fread(buffer, 1, 1000000, fopen(\"c:/windows/fonts/arialbd.ttf\", \"rb\"));\n   stbtt_InitFont(&font, buffer, 0);\n\n   scale = stbtt_ScaleForPixelHeight(&font, 15);\n   stbtt_GetFontVMetrics(&font, &ascent,0,0);\n   baseline = (int) (ascent*scale);\n\n   while (text[ch]) {\n      int advance,lsb,x0,y0,x1,y1;\n      float x_shift = xpos - (float) floor(xpos);\n      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);\n      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);\n      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);\n      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong\n      // because this API is really for baking character bitmaps into textures. if you want to render\n      // a sequence of characters, you really need to render each bitmap to a temp buffer, then\n      // \"alpha blend\" that into the working buffer\n      xpos += (advance * scale);\n      if (text[ch+1])\n         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);\n      ++ch;\n   }\n\n   for (j=0; j < 20; ++j) {\n      for (i=0; i < 78; ++i)\n         putchar(\" .:ioVM@\"[screen[j][i]>>5]);\n      putchar('\\n');\n   }\n\n   return 0;\n}\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////   INTEGRATION WITH YOUR CODEBASE\n////\n////   The following sections allow you to supply alternate definitions\n////   of C library functions used by stb_truetype, e.g. if you don't\n////   link with the C runtime library.\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n   // #define your own (u)stbtt_int8/16/32 before including to override this\n   #ifndef stbtt_uint8\n   typedef unsigned char   stbtt_uint8;\n   typedef signed   char   stbtt_int8;\n   typedef unsigned short  stbtt_uint16;\n   typedef signed   short  stbtt_int16;\n   typedef unsigned int    stbtt_uint32;\n   typedef signed   int    stbtt_int32;\n   #endif\n\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\n\n   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h\n   #ifndef STBTT_ifloor\n   #include <math.h>\n   #define STBTT_ifloor(x)   ((int) floor(x))\n   #define STBTT_iceil(x)    ((int) ceil(x))\n   #endif\n\n   #ifndef STBTT_sqrt\n   #include <math.h>\n   #define STBTT_sqrt(x)      sqrt(x)\n   #define STBTT_pow(x,y)     pow(x,y)\n   #endif\n\n   #ifndef STBTT_fmod\n   #include <math.h>\n   #define STBTT_fmod(x,y)    fmod(x,y)\n   #endif\n\n   #ifndef STBTT_cos\n   #include <math.h>\n   #define STBTT_cos(x)       cos(x)\n   #define STBTT_acos(x)      acos(x)\n   #endif\n\n   #ifndef STBTT_fabs\n   #include <math.h>\n   #define STBTT_fabs(x)      fabs(x)\n   #endif\n\n   // #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h\n   #ifndef STBTT_malloc\n   #include <stdlib.h>\n   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))\n   #define STBTT_free(x,u)    ((void)(u),free(x))\n   #endif\n\n   #ifndef STBTT_assert\n   #include <assert.h>\n   #define STBTT_assert(x)    assert(x)\n   #endif\n\n   #ifndef STBTT_strlen\n   #include <string.h>\n   #define STBTT_strlen(x)    strlen(x)\n   #endif\n\n   #ifndef STBTT_memcpy\n   #include <string.h>\n   #define STBTT_memcpy       memcpy\n   #define STBTT_memset       memset\n   #endif\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   INTERFACE\n////\n////\n\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\n#define __STB_INCLUDE_STB_TRUETYPE_H__\n\n#ifdef STBTT_STATIC\n#define STBTT_DEF static\n#else\n#define STBTT_DEF extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// private structure\ntypedef struct\n{\n   unsigned char *data;\n   int cursor;\n   int size;\n} stbtt__buf;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// TEXTURE BAKING API\n//\n// If you use this API, you only have to call two functions ever.\n//\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n} stbtt_bakedchar;\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long\n// if return is positive, the first unused row of the bitmap\n// if return is negative, returns the negative of the number of characters that fit\n// if return is 0, no characters fit and no rows were used\n// This uses a very crappy packing.\n\ntypedef struct\n{\n   float x0,y0,s0,t0; // top-left\n   float x1,y1,s1,t1; // bottom-right\n} stbtt_aligned_quad;\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier\n// Call GetBakedQuad with char_index = 'character - first_char', and it\n// creates the quad you need to draw and advances the current position.\n//\n// The coordinate system used assumes y increases downwards.\n//\n// Characters will extend both above and below the current position;\n// see discussion of \"BASELINE\" above.\n//\n// It's inefficient; you might want to c&p it and optimize it.\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);\n// Query the font vertical metrics without having to create a font first.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// NEW TEXTURE BAKING API\n//\n// This provides options for packing multiple fonts into one atlas, not\n// perfectly but better than nothing.\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n   float xoff2,yoff2;\n} stbtt_packedchar;\n\ntypedef struct stbtt_pack_context stbtt_pack_context;\ntypedef struct stbtt_fontinfo stbtt_fontinfo;\n#ifndef STB_RECT_PACK_VERSION\ntypedef struct stbrp_rect stbrp_rect;\n#endif\n\nSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);\n// Initializes a packing context stored in the passed-in stbtt_pack_context.\n// Future calls using this context will pack characters into the bitmap passed\n// in here: a 1-channel bitmap that is width * height. stride_in_bytes is\n// the distance from one row to the next (or 0 to mean they are packed tightly\n// together). \"padding\" is the amount of padding to leave between each\n// character (normally you want '1' for bitmaps you'll use as textures with\n// bilinear filtering).\n//\n// Returns 0 on failure, 1 on success.\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);\n// Cleans up the packing context and frees all memory.\n\n#define STBTT_POINT_SIZE(x)   (-(x))\n\nSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);\n// Creates character bitmaps from the font_index'th font found in fontdata (use\n// font_index=0 if you don't know what that is). It creates num_chars_in_range\n// bitmaps for characters with unicode values starting at first_unicode_char_in_range\n// and increasing. Data for how to render them is stored in chardata_for_range;\n// pass these to stbtt_GetPackedQuad to get back renderable quads.\n//\n// font_size is the full height of the character from ascender to descender,\n// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed\n// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()\n// and pass that result as 'font_size':\n//       ...,                  20 , ... // font max minus min y is 20 pixels tall\n//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall\n\ntypedef struct\n{\n   float font_size;\n   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint\n   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints\n   int num_chars;\n   stbtt_packedchar *chardata_for_range; // output\n   unsigned char h_oversample, v_oversample; // don't set these, they're used internally\n} stbtt_pack_range;\n\nSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);\n// Creates character bitmaps from multiple ranges of characters stored in\n// ranges. This will usually create a better-packed bitmap than multiple\n// calls to stbtt_PackFontRange. Note that you can call this multiple\n// times within a single PackBegin/PackEnd.\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);\n// Oversampling a font increases the quality by allowing higher-quality subpixel\n// positioning, and is especially valuable at smaller text sizes.\n//\n// This function sets the amount of oversampling for all following calls to\n// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given\n// pack context. The default (no oversampling) is achieved by h_oversample=1\n// and v_oversample=1. The total number of pixels required is\n// h_oversample*v_oversample larger than the default; for example, 2x2\n// oversampling requires 4x the storage of 1x1. For best results, render\n// oversampled textures with bilinear filtering. Look at the readme in\n// stb/tests/oversample for information about oversampled fonts\n//\n// To use with PackFontRangesGather etc., you must set it before calls\n// call to PackFontRangesGatherRects.\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);\n// If skip != 0, this tells stb_truetype to skip any codepoints for which\n// there is no corresponding glyph. If skip=0, which is the default, then\n// codepoints without a glyph received the font's \"missing character\" glyph,\n// typically an empty box by convention.\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int align_to_integer);\n\nSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);\nSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\n// Calling these functions in sequence is roughly equivalent to calling\n// stbtt_PackFontRanges(). If you more control over the packing of multiple\n// fonts, or if you want to pack custom data into a font texture, take a look\n// at the source to of stbtt_PackFontRanges() and create a custom version\n// using these functions, e.g. call GatherRects multiple times,\n// building up a single array of rects, then call PackRects once,\n// then call RenderIntoRects repeatedly. This may result in a\n// better packing than calling PackFontRanges multiple times\n// (or it may not).\n\n// this is an opaque structure that you shouldn't mess with which holds\n// all the context needed from PackBegin to PackEnd.\nstruct stbtt_pack_context {\n   void *user_allocator_context;\n   void *pack_info;\n   int   width;\n   int   height;\n   int   stride_in_bytes;\n   int   padding;\n   int   skip_missing;\n   unsigned int   h_oversample, v_oversample;\n   unsigned char *pixels;\n   void  *nodes;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// FONT LOADING\n//\n//\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);\n// This function will determine the number of fonts in a font file.  TrueType\n// collection (.ttc) files may contain multiple fonts, while TrueType font\n// (.ttf) files only contain one font. The number of fonts can be used for\n// indexing with the previous function where the index is between zero and one\n// less than the total fonts. If an error occurs, -1 is returned.\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\n// Each .ttf/.ttc file may have more than one font. Each font has a sequential\n// index number starting from 0. Call this function to get the font offset for\n// a given index; it returns -1 if the index is out of range. A regular .ttf\n// file will only define one font and it always be at offset 0, so it will\n// return '0' for index 0, and -1 for all other indices.\n\n// The following structure is defined publicly so you can declare one on\n// the stack or as a global or etc, but you should treat it as opaque.\nstruct stbtt_fontinfo\n{\n   void           * userdata;\n   unsigned char  * data;              // pointer to .ttf file\n   int              fontstart;         // offset of start of font\n\n   int numGlyphs;                     // number of glyphs, needed for range checking\n\n   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf\n   int index_map;                     // a cmap mapping for our chosen character encoding\n   int indexToLocFormat;              // format needed to map from glyph index to glyph\n\n   stbtt__buf cff;                    // cff font data\n   stbtt__buf charstrings;            // the charstring index\n   stbtt__buf gsubrs;                 // global charstring subroutines index\n   stbtt__buf subrs;                  // private charstring subroutines index\n   stbtt__buf fontdicts;              // array of font dicts\n   stbtt__buf fdselect;               // map from glyph to fontdict\n};\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\n// Given an offset into the file that defines a font, this function builds\n// the necessary cached info for the rest of the system. You must allocate\n// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't\n// need to do anything special to free it, because the contents are pure\n// value data with no additional data structures. Returns 0 on failure.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER TO GLYPH-INDEX CONVERSIOn\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\n// If you're going to perform multiple operations on the same character\n// and you want a speed-up, call this function with the character you're\n// going to process, then use glyph-based functions instead of the\n// codepoint-based functions.\n// Returns 0 if the character codepoint is not defined in the font.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER PROPERTIES\n//\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose \"height\" is 'pixels' tall.\n// Height is measured as the distance from the highest ascender to the lowest\n// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics\n// and computing:\n//       scale = pixels / (ascent - descent)\n// so if you prefer to measure height by the ascent only, use a similar calculation.\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose EM size is mapped to\n// 'pixels' tall. This is probably what traditional APIs compute, but\n// I'm not positive.\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\n// ascent is the coordinate above the baseline the font extends; descent\n// is the coordinate below the baseline the font extends (i.e. it is typically negative)\n// lineGap is the spacing between one row's descent and the next row's ascent...\n// so you should advance the vertical position by \"*ascent - *descent + *lineGap\"\n//   these are expressed in unscaled coordinates, so you must multiply by\n//   the scale factor for a given size\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);\n// analogous to GetFontVMetrics, but returns the \"typographic\" values from the OS/2\n// table (specific to MS/Windows TTF files).\n//\n// Returns 1 on success (table present), 0 on failure.\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\n// the bounding box around all possible characters\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\n// leftSideBearing is the offset from the current horizontal position to the left edge of the character\n// advanceWidth is the offset from the current horizontal position to the next horizontal position\n//   these are expressed in unscaled coordinates\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\n// an additional amount to add to the 'advance' value between ch1 and ch2\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\n// Gets the bounding box of the visible part of the glyph, in unscaled coordinates\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\nSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n// as above, but takes one or more glyph indices for greater efficiency\n\ntypedef struct stbtt_kerningentry\n{\n   int glyph1; // use stbtt_FindGlyphIndex\n   int glyph2;\n   int advance;\n} stbtt_kerningentry;\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);\nSTBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);\n// Retrieves a complete list of all of the kerning pairs provided by the font\n// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.\n// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// GLYPH SHAPES (you probably don't need these, but they have to go before\n// the bitmaps for C declaration-order reasons)\n//\n\n#ifndef STBTT_vmove // you can predefine these to use different values (but why?)\n   enum {\n      STBTT_vmove=1,\n      STBTT_vline,\n      STBTT_vcurve,\n      STBTT_vcubic\n   };\n#endif\n\n#ifndef stbtt_vertex // you can predefine this to use different values\n                   // (we share this with other code at RAD)\n   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file\n   typedef struct\n   {\n      stbtt_vertex_type x,y,cx,cy,cx1,cy1;\n      unsigned char type,padding;\n   } stbtt_vertex;\n#endif\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\n// returns non-zero if nothing is drawn for this glyph\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\n// returns # of vertices and fills *vertices with the pointer to them\n//   these are expressed in \"unscaled\" coordinates\n//\n// The shape is a series of contours. Each one starts with\n// a STBTT_moveto, then consists of a series of mixed\n// STBTT_lineto and STBTT_curveto segments. A lineto\n// draws a line from previous endpoint to its x,y; a curveto\n// draws a quadratic bezier from previous endpoint to\n// its x,y, using cx,cy as the bezier control point.\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\n// frees the data allocated above\n\nSTBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);\n// fills svg with the character's SVG data.\n// returns data size or 0 if SVG not found.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// BITMAP RENDERING\n//\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\n// frees the bitmap allocated below\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// allocates a large-enough single-channel 8bpp bitmap and renders the\n// specified character/glyph at the specified scale into it, with\n// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).\n// *width & *height are filled out with the width & height of the bitmap,\n// which is stored left-to-right, top-to-bottom.\n//\n// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\n// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap\n// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap\n// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the\n// width and height and positioning info for it first.\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\n// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);\n// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering\n// is performed (see stbtt_PackSetOversampling)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// get the bbox of the bitmap centered around the glyph origin; so the\n// bitmap width is ix1-ix0, height is iy1-iy0, and location to place\n// the bitmap top left is (leftSideBearing*scale,iy0).\n// (Note that the bitmap uses y-increases-down, but the shape uses\n// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel\n// shift for the character\n\n// the following functions are equivalent to the above functions, but operate\n// on glyph indices instead of Unicode codepoints (for efficiency)\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n\n\n// @TODO: don't expose this structure\ntypedef struct\n{\n   int w,h,stride;\n   unsigned char *pixels;\n} stbtt__bitmap;\n\n// rasterize a shape with quadratic beziers into a bitmap\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into\n                               float flatness_in_pixels,     // allowable error of curve in pixels\n                               stbtt_vertex *vertices,       // array of vertices defining shape\n                               int num_verts,                // number of vertices in above array\n                               float scale_x, float scale_y, // scale applied to input vertices\n                               float shift_x, float shift_y, // translation applied to input vertices\n                               int x_off, int y_off,         // another translation applied to input\n                               int invert,                   // if non-zero, vertically flip shape\n                               void *userdata);              // context for to STBTT_MALLOC\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Signed Distance Function (or Field) rendering\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);\n// frees the SDF bitmap allocated below\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\n// These functions compute a discretized SDF field for a single character, suitable for storing\n// in a single-channel texture, sampling with bilinear filtering, and testing against\n// larger than some threshold to produce scalable fonts.\n//        info              --  the font\n//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap\n//        glyph/codepoint   --  the character to generate the SDF for\n//        padding           --  extra \"pixels\" around the character which are filled with the distance to the character (not 0),\n//                                 which allows effects like bit outlines\n//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)\n//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF \"pixel\" away from the edge (on the 0..255 scale)\n//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside\n//        width,height      --  output height & width of the SDF bitmap (including padding)\n//        xoff,yoff         --  output origin of the character\n//        return value      --  a 2D array of bytes 0..255, width*height in size\n//\n// pixel_dist_scale & onedge_value are a scale & bias that allows you to make\n// optimal use of the limited 0..255 for your application, trading off precision\n// and special effects. SDF values outside the range 0..255 are clamped to 0..255.\n//\n// Example:\n//      scale = stbtt_ScaleForPixelHeight(22)\n//      padding = 5\n//      onedge_value = 180\n//      pixel_dist_scale = 180/5.0 = 36.0\n//\n//      This will create an SDF bitmap in which the character is about 22 pixels\n//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled\n//      shape, sample the SDF at each pixel and fill the pixel if the SDF value\n//      is greater than or equal to 180/255. (You'll actually want to antialias,\n//      which is beyond the scope of this example.) Additionally, you can compute\n//      offset outlines (e.g. to stroke the character border inside & outside,\n//      or only outside). For example, to fill outside the character up to 3 SDF\n//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above\n//      choice of variables maps a range from 5 pixels outside the shape to\n//      2 pixels inside the shape to 0..255; this is intended primarily for apply\n//      outside effects only (the interior range is needed to allow proper\n//      antialiasing of the font at *smaller* sizes)\n//\n// The function computes the SDF analytically at each SDF pixel, not by e.g.\n// building a higher-res bitmap and approximating it. In theory the quality\n// should be as high as possible for an SDF of this size & representation, but\n// unclear if this is true in practice (perhaps building a higher-res bitmap\n// and computing from that can allow drop-out prevention).\n//\n// The algorithm has not been optimized at all, so expect it to be slow\n// if computing lots of characters or very large sizes.\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Finding the right font...\n//\n// You should really just solve this offline, keep your own tables\n// of what font is what, and don't try to get it out of the .ttf file.\n// That's because getting it out of the .ttf file is really hard, because\n// the names in the file can appear in many possible encodings, in many\n// possible languages, and e.g. if you need a case-insensitive comparison,\n// the details of that depend on the encoding & language in a complex way\n// (actually underspecified in truetype, but also gigantic).\n//\n// But you can use the provided functions in two possible ways:\n//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on\n//             unicode-encoded names to try to find the font you want;\n//             you can run this before calling stbtt_InitFont()\n//\n//     stbtt_GetFontNameString() lets you get any of the various strings\n//             from the file yourself and do your own comparisons on them.\n//             You have to have called stbtt_InitFont() first.\n\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\n// returns the offset (not index) of the font that matches, or -1 if none\n//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\".\n//   if you use any other flag, use a font name like \"Arial\"; this checks\n//     the 'macStyle' header field; i don't know if fonts set this consistently\n#define STBTT_MACSTYLE_DONTCARE     0\n#define STBTT_MACSTYLE_BOLD         1\n#define STBTT_MACSTYLE_ITALIC       2\n#define STBTT_MACSTYLE_UNDERSCORE   4\n#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\n// returns 1/0 whether the first string interpreted as utf8 is identical to\n// the second string interpreted as big-endian utf16... useful for strings from next func\n\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\n// returns the string (which may be big-endian double byte, e.g. for unicode)\n// and puts the length in bytes in *length.\n//\n// some of the values for the IDs are below; for more see the truetype spec:\n//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html\n//     http://www.microsoft.com/typography/otspec/name.htm\n\nenum { // platformID\n   STBTT_PLATFORM_ID_UNICODE   =0,\n   STBTT_PLATFORM_ID_MAC       =1,\n   STBTT_PLATFORM_ID_ISO       =2,\n   STBTT_PLATFORM_ID_MICROSOFT =3\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_UNICODE\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\n   STBTT_UNICODE_EID_ISO_10646      =2,\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT\n   STBTT_MS_EID_SYMBOL        =0,\n   STBTT_MS_EID_UNICODE_BMP   =1,\n   STBTT_MS_EID_SHIFTJIS      =2,\n   STBTT_MS_EID_UNICODE_FULL  =10\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...\n       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MAC\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // __STB_INCLUDE_STB_TRUETYPE_H__\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   IMPLEMENTATION\n////\n////\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n\n#ifndef STBTT_MAX_OVERSAMPLE\n#define STBTT_MAX_OVERSAMPLE   8\n#endif\n\n#if STBTT_MAX_OVERSAMPLE > 255\n#error \"STBTT_MAX_OVERSAMPLE cannot be > 255\"\n#endif\n\ntypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];\n\n#ifndef STBTT_RASTERIZER_VERSION\n#define STBTT_RASTERIZER_VERSION 2\n#endif\n\n#ifdef _MSC_VER\n#define STBTT__NOTUSED(v)  (void)(v)\n#else\n#define STBTT__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n//////////////////////////////////////////////////////////////////////////\n//\n// stbtt__buf helpers to parse data from file\n//\n\nstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}\n\nstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}\n\nstatic void stbtt__buf_seek(stbtt__buf *b, int o)\n{\n   STBTT_assert(!(o > b->size || o < 0));\n   b->cursor = (o > b->size || o < 0) ? b->size : o;\n}\n\nstatic void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}\n\nstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}\n\nstatic stbtt__buf stbtt__new_buf(const void *p, size_t size)\n{\n   stbtt__buf r;\n   STBTT_assert(size < 0x40000000);\n   r.data = (stbtt_uint8*) p;\n   r.size = (int) size;\n   r.cursor = 0;\n   return r;\n}\n\n#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)\n#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)\n\nstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(NULL, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}\n\nstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)\n{\n   int count, start, offsize;\n   start = b->cursor;\n   count = stbtt__buf_get16(b);\n   if (count) {\n      offsize = stbtt__buf_get8(b);\n      STBTT_assert(offsize >= 1 && offsize <= 4);\n      stbtt__buf_skip(b, offsize * count);\n      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);\n   }\n   return stbtt__buf_range(b, start, b->cursor - start);\n}\n\nstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)\n{\n   int b0 = stbtt__buf_get8(b);\n   if (b0 >= 32 && b0 <= 246)       return b0 - 139;\n   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;\n   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;\n   else if (b0 == 28)               return stbtt__buf_get16(b);\n   else if (b0 == 29)               return stbtt__buf_get32(b);\n   STBTT_assert(0);\n   return 0;\n}\n\nstatic void stbtt__cff_skip_operand(stbtt__buf *b) {\n   int v, b0 = stbtt__buf_peek8(b);\n   STBTT_assert(b0 >= 28);\n   if (b0 == 30) {\n      stbtt__buf_skip(b, 1);\n      while (b->cursor < b->size) {\n         v = stbtt__buf_get8(b);\n         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)\n            break;\n      }\n   } else {\n      stbtt__cff_int(b);\n   }\n}\n\nstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)\n{\n   stbtt__buf_seek(b, 0);\n   while (b->cursor < b->size) {\n      int start = b->cursor, end, op;\n      while (stbtt__buf_peek8(b) >= 28)\n         stbtt__cff_skip_operand(b);\n      end = b->cursor;\n      op = stbtt__buf_get8(b);\n      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;\n      if (op == key) return stbtt__buf_range(b, start, end-start);\n   }\n   return stbtt__buf_range(b, 0, 0);\n}\n\nstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)\n{\n   int i;\n   stbtt__buf operands = stbtt__dict_get(b, key);\n   for (i = 0; i < outcount && operands.cursor < operands.size; i++)\n      out[i] = stbtt__cff_int(&operands);\n}\n\nstatic int stbtt__cff_index_count(stbtt__buf *b)\n{\n   stbtt__buf_seek(b, 0);\n   return stbtt__buf_get16(b);\n}\n\nstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)\n{\n   int count, offsize, start, end;\n   stbtt__buf_seek(&b, 0);\n   count = stbtt__buf_get16(&b);\n   offsize = stbtt__buf_get8(&b);\n   STBTT_assert(i >= 0 && i < count);\n   STBTT_assert(offsize >= 1 && offsize <= 4);\n   stbtt__buf_skip(&b, i*offsize);\n   start = stbtt__buf_get(&b, offsize);\n   end = stbtt__buf_get(&b, offsize);\n   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);\n}\n\n//////////////////////////////////////////////////////////////////////////\n//\n// accessors to parse data from file\n//\n\n// on platforms that don't allow misaligned reads, if we want to allow\n// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE\n\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\n#define ttFixed(p)    ttLONG(p)\n\nstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }\nstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\nstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\nstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\n\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\n\nstatic int stbtt__isfont(stbtt_uint8 *font)\n{\n   // check the version number\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1\n   if (stbtt_tag(font, \"typ1\"))   return 1; // TrueType with type 1 font -- we don't support this!\n   if (stbtt_tag(font, \"OTTO\"))   return 1; // OpenType with CFF\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0\n   if (stbtt_tag(font, \"true\"))   return 1; // Apple specification for TrueType fonts\n   return 0;\n}\n\n// @OPTIMIZE: binary search\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\n{\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\n   stbtt_uint32 tabledir = fontstart + 12;\n   stbtt_int32 i;\n   for (i=0; i < num_tables; ++i) {\n      stbtt_uint32 loc = tabledir + 16*i;\n      if (stbtt_tag(data+loc+0, tag))\n         return ttULONG(data+loc+8);\n   }\n   return 0;\n}\n\nstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)\n{\n   // if it's just a font, there's only one valid index\n   if (stbtt__isfont(font_collection))\n      return index == 0 ? 0 : -1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         stbtt_int32 n = ttLONG(font_collection+8);\n         if (index >= n)\n            return -1;\n         return ttULONG(font_collection+12+index*4);\n      }\n   }\n   return -1;\n}\n\nstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)\n{\n   // if it's just a font, there's only one valid font\n   if (stbtt__isfont(font_collection))\n      return 1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         return ttLONG(font_collection+8);\n      }\n   }\n   return 0;\n}\n\nstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)\n{\n   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };\n   stbtt__buf pdict;\n   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);\n   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);\n   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);\n   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);\n   if (!subrsoff) return stbtt__new_buf(NULL, 0);\n   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);\n   return stbtt__cff_get_index(&cff);\n}\n\n// since most people won't use this, find this table the first time it's needed\nstatic int stbtt__get_svg(stbtt_fontinfo *info)\n{\n   stbtt_uint32 t;\n   if (info->svg < 0) {\n      t = stbtt__find_table(info->data, info->fontstart, \"SVG \");\n      if (t) {\n         stbtt_uint32 offset = ttULONG(info->data + t + 2);\n         info->svg = t + offset;\n      } else {\n         info->svg = 0;\n      }\n   }\n   return info->svg;\n}\n\nstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)\n{\n   stbtt_uint32 cmap, t;\n   stbtt_int32 i,numTables;\n\n   info->data = data;\n   info->fontstart = fontstart;\n   info->cff = stbtt__new_buf(NULL, 0);\n\n   cmap = stbtt__find_table(data, fontstart, \"cmap\");       // required\n   info->loca = stbtt__find_table(data, fontstart, \"loca\"); // required\n   info->head = stbtt__find_table(data, fontstart, \"head\"); // required\n   info->glyf = stbtt__find_table(data, fontstart, \"glyf\"); // required\n   info->hhea = stbtt__find_table(data, fontstart, \"hhea\"); // required\n   info->hmtx = stbtt__find_table(data, fontstart, \"hmtx\"); // required\n   info->kern = stbtt__find_table(data, fontstart, \"kern\"); // not required\n   info->gpos = stbtt__find_table(data, fontstart, \"GPOS\"); // not required\n\n   if (!cmap || !info->head || !info->hhea || !info->hmtx)\n      return 0;\n   if (info->glyf) {\n      // required for truetype\n      if (!info->loca) return 0;\n   } else {\n      // initialization for CFF / Type2 fonts (OTF)\n      stbtt__buf b, topdict, topdictidx;\n      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;\n      stbtt_uint32 cff;\n\n      cff = stbtt__find_table(data, fontstart, \"CFF \");\n      if (!cff) return 0;\n\n      info->fontdicts = stbtt__new_buf(NULL, 0);\n      info->fdselect = stbtt__new_buf(NULL, 0);\n\n      // @TODO this should use size from table (not 512MB)\n      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);\n      b = info->cff;\n\n      // read the header\n      stbtt__buf_skip(&b, 2);\n      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize\n\n      // @TODO the name INDEX could list multiple fonts,\n      // but we just use the first one.\n      stbtt__cff_get_index(&b);  // name INDEX\n      topdictidx = stbtt__cff_get_index(&b);\n      topdict = stbtt__cff_index_get(topdictidx, 0);\n      stbtt__cff_get_index(&b);  // string INDEX\n      info->gsubrs = stbtt__cff_get_index(&b);\n\n      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);\n      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);\n      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);\n      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);\n      info->subrs = stbtt__get_subrs(b, topdict);\n\n      // we only support Type 2 charstrings\n      if (cstype != 2) return 0;\n      if (charstrings == 0) return 0;\n\n      if (fdarrayoff) {\n         // looks like a CID font\n         if (!fdselectoff) return 0;\n         stbtt__buf_seek(&b, fdarrayoff);\n         info->fontdicts = stbtt__cff_get_index(&b);\n         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);\n      }\n\n      stbtt__buf_seek(&b, charstrings);\n      info->charstrings = stbtt__cff_get_index(&b);\n   }\n\n   t = stbtt__find_table(data, fontstart, \"maxp\");\n   if (t)\n      info->numGlyphs = ttUSHORT(data+t+4);\n   else\n      info->numGlyphs = 0xffff;\n\n   info->svg = -1;\n\n   // find a cmap encoding table we understand *now* to avoid searching\n   // later. (todo: could make this installable)\n   // the same regardless of glyph.\n   numTables = ttUSHORT(data + cmap + 2);\n   info->index_map = 0;\n   for (i=0; i < numTables; ++i) {\n      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;\n      // find an encoding we understand:\n      switch(ttUSHORT(data+encoding_record)) {\n         case STBTT_PLATFORM_ID_MICROSOFT:\n            switch (ttUSHORT(data+encoding_record+2)) {\n               case STBTT_MS_EID_UNICODE_BMP:\n               case STBTT_MS_EID_UNICODE_FULL:\n                  // MS/Unicode\n                  info->index_map = cmap + ttULONG(data+encoding_record+4);\n                  break;\n            }\n            break;\n        case STBTT_PLATFORM_ID_UNICODE:\n            // Mac/iOS has these\n            // all the encodingIDs are unicode, so we don't bother to check it\n            info->index_map = cmap + ttULONG(data+encoding_record+4);\n            break;\n      }\n   }\n   if (info->index_map == 0)\n      return 0;\n\n   info->indexToLocFormat = ttUSHORT(data+info->head + 50);\n   return 1;\n}\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint32 index_map = info->index_map;\n\n   stbtt_uint16 format = ttUSHORT(data + index_map + 0);\n   if (format == 0) { // apple byte encoding\n      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);\n      if (unicode_codepoint < bytes-6)\n         return ttBYTE(data + index_map + 6 + unicode_codepoint);\n      return 0;\n   } else if (format == 6) {\n      stbtt_uint32 first = ttUSHORT(data + index_map + 6);\n      stbtt_uint32 count = ttUSHORT(data + index_map + 8);\n      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)\n         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);\n      return 0;\n   } else if (format == 2) {\n      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean\n      return 0;\n   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges\n      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;\n      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;\n      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);\n      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;\n\n      // do a binary search of the segments\n      stbtt_uint32 endCount = index_map + 14;\n      stbtt_uint32 search = endCount;\n\n      if (unicode_codepoint > 0xffff)\n         return 0;\n\n      // they lie from endCount .. endCount + segCount\n      // but searchRange is the nearest power of two, so...\n      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))\n         search += rangeShift*2;\n\n      // now decrement to bias correctly to find smallest\n      search -= 2;\n      while (entrySelector) {\n         stbtt_uint16 end;\n         searchRange >>= 1;\n         end = ttUSHORT(data + search + searchRange*2);\n         if (unicode_codepoint > end)\n            search += searchRange*2;\n         --entrySelector;\n      }\n      search += 2;\n\n      {\n         stbtt_uint16 offset, start, last;\n         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);\n\n         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);\n         last = ttUSHORT(data + endCount + 2*item);\n         if (unicode_codepoint < start || unicode_codepoint > last)\n            return 0;\n\n         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);\n         if (offset == 0)\n            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));\n\n         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);\n      }\n   } else if (format == 12 || format == 13) {\n      stbtt_uint32 ngroups = ttULONG(data+index_map+12);\n      stbtt_int32 low,high;\n      low = 0; high = (stbtt_int32)ngroups;\n      // Binary search the right group.\n      while (low < high) {\n         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high\n         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);\n         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);\n         if ((stbtt_uint32) unicode_codepoint < start_char)\n            high = mid;\n         else if ((stbtt_uint32) unicode_codepoint > end_char)\n            low = mid+1;\n         else {\n            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);\n            if (format == 12)\n               return start_glyph + unicode_codepoint-start_char;\n            else // format == 13\n               return start_glyph;\n         }\n      }\n      return 0; // not found\n   }\n   // @TODO\n   STBTT_assert(0);\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\n{\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\n}\n\nstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\n{\n   v->type = type;\n   v->x = (stbtt_int16) x;\n   v->y = (stbtt_int16) y;\n   v->cx = (stbtt_int16) cx;\n   v->cy = (stbtt_int16) cy;\n}\n\nstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)\n{\n   int g1,g2;\n\n   STBTT_assert(!info->cff.size);\n\n   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range\n   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format\n\n   if (info->indexToLocFormat == 0) {\n      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;\n      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;\n   } else {\n      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);\n      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);\n   }\n\n   return g1==g2 ? -1 : g1; // if length is 0, return -1\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n\nSTBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   if (info->cff.size) {\n      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);\n   } else {\n      int g = stbtt__GetGlyfOffset(info, glyph_index);\n      if (g < 0) return 0;\n\n      if (x0) *x0 = ttSHORT(info->data + g + 2);\n      if (y0) *y0 = ttSHORT(info->data + g + 4);\n      if (x1) *x1 = ttSHORT(info->data + g + 6);\n      if (y1) *y1 = ttSHORT(info->data + g + 8);\n   }\n   return 1;\n}\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\n{\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\n}\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt_int16 numberOfContours;\n   int g;\n   if (info->cff.size)\n      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;\n   g = stbtt__GetGlyfOffset(info, glyph_index);\n   if (g < 0) return 1;\n   numberOfContours = ttSHORT(info->data + g);\n   return numberOfContours == 0;\n}\n\nstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,\n    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)\n{\n   if (start_off) {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);\n      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);\n   } else {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);\n      else\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);\n   }\n   return num_vertices;\n}\n\nstatic int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   stbtt_int16 numberOfContours;\n   stbtt_uint8 *endPtsOfContours;\n   stbtt_uint8 *data = info->data;\n   stbtt_vertex *vertices=0;\n   int num_vertices=0;\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\n\n   *pvertices = NULL;\n\n   if (g < 0) return 0;\n\n   numberOfContours = ttSHORT(data + g);\n\n   if (numberOfContours > 0) {\n      stbtt_uint8 flags=0,flagcount;\n      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;\n      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;\n      stbtt_uint8 *points;\n      endPtsOfContours = (data + g + 10);\n      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);\n      points = data + g + 10 + numberOfContours * 2 + 2 + ins;\n\n      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);\n\n      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need\n      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);\n      if (vertices == 0)\n         return 0;\n\n      next_move = 0;\n      flagcount=0;\n\n      // in first pass, we load uninterpreted data into the allocated array\n      // above, shifted to the end of the array so we won't overwrite it when\n      // we create our final data starting from the front\n\n      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated\n\n      // first load flags\n\n      for (i=0; i < n; ++i) {\n         if (flagcount == 0) {\n            flags = *points++;\n            if (flags & 8)\n               flagcount = *points++;\n         } else\n            --flagcount;\n         vertices[off+i].type = flags;\n      }\n\n      // now load x coordinates\n      x=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 2) {\n            stbtt_int16 dx = *points++;\n            x += (flags & 16) ? dx : -dx; // ???\n         } else {\n            if (!(flags & 16)) {\n               x = x + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].x = (stbtt_int16) x;\n      }\n\n      // now load y coordinates\n      y=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 4) {\n            stbtt_int16 dy = *points++;\n            y += (flags & 32) ? dy : -dy; // ???\n         } else {\n            if (!(flags & 32)) {\n               y = y + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].y = (stbtt_int16) y;\n      }\n\n      // now convert them to our format\n      num_vertices=0;\n      sx = sy = cx = cy = scx = scy = 0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         x     = (stbtt_int16) vertices[off+i].x;\n         y     = (stbtt_int16) vertices[off+i].y;\n\n         if (next_move == i) {\n            if (i != 0)\n               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n\n            // now start the new one\n            start_off = !(flags & 1);\n            if (start_off) {\n               // if we start off with an off-curve point, then when we need to find a point on the curve\n               // where we can start, and we need to save some state for when we wraparound.\n               scx = x;\n               scy = y;\n               if (!(vertices[off+i+1].type & 1)) {\n                  // next point is also a curve point, so interpolate an on-point curve\n                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n               } else {\n                  // otherwise just use the next point as our start point\n                  sx = (stbtt_int32) vertices[off+i+1].x;\n                  sy = (stbtt_int32) vertices[off+i+1].y;\n                  ++i; // we're using point i+1 as the starting point, so skip it\n               }\n            } else {\n               sx = x;\n               sy = y;\n            }\n            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);\n            was_off = 0;\n            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);\n            ++j;\n         } else {\n            if (!(flags & 1)) { // if it's a curve\n               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n               cx = x;\n               cy = y;\n               was_off = 1;\n            } else {\n               if (was_off)\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);\n               else\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);\n               was_off = 0;\n            }\n         }\n      }\n      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n   } else if (numberOfContours < 0) {\n      // Compound shapes.\n      int more = 1;\n      stbtt_uint8 *comp = data + g + 10;\n      num_vertices = 0;\n      vertices = 0;\n      while (more) {\n         stbtt_uint16 flags, gidx;\n         int comp_num_verts = 0, i;\n         stbtt_vertex *comp_verts = 0, *tmp = 0;\n         float mtx[6] = {1,0,0,1,0,0}, m, n;\n\n         flags = ttSHORT(comp); comp+=2;\n         gidx = ttSHORT(comp); comp+=2;\n\n         if (flags & 2) { // XY values\n            if (flags & 1) { // shorts\n               mtx[4] = ttSHORT(comp); comp+=2;\n               mtx[5] = ttSHORT(comp); comp+=2;\n            } else {\n               mtx[4] = ttCHAR(comp); comp+=1;\n               mtx[5] = ttCHAR(comp); comp+=1;\n            }\n         }\n         else {\n            // @TODO handle matching point\n            STBTT_assert(0);\n         }\n         if (flags & (1<<3)) { // WE_HAVE_A_SCALE\n            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         }\n\n         // Find transformation scales.\n         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);\n         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);\n\n         // Get indexed glyph.\n         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);\n         if (comp_num_verts > 0) {\n            // Transform vertices.\n            for (i = 0; i < comp_num_verts; ++i) {\n               stbtt_vertex* v = &comp_verts[i];\n               stbtt_vertex_type x,y;\n               x=v->x; y=v->y;\n               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n               x=v->cx; y=v->cy;\n               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n            }\n            // Append vertices.\n            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);\n            if (!tmp) {\n               if (vertices) STBTT_free(vertices, info->userdata);\n               if (comp_verts) STBTT_free(comp_verts, info->userdata);\n               return 0;\n            }\n            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));\n            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));\n            if (vertices) STBTT_free(vertices, info->userdata);\n            vertices = tmp;\n            STBTT_free(comp_verts, info->userdata);\n            num_vertices += comp_num_verts;\n         }\n         // More components ?\n         more = flags & (1<<5);\n      }\n   } else {\n      // numberOfCounters == 0, do nothing\n   }\n\n   *pvertices = vertices;\n   return num_vertices;\n}\n\ntypedef struct\n{\n   int bounds;\n   int started;\n   float first_x, first_y;\n   float x, y;\n   stbtt_int32 min_x, max_x, min_y, max_y;\n\n   stbtt_vertex *pvertices;\n   int num_vertices;\n} stbtt__csctx;\n\n#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}\n\nstatic void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)\n{\n   if (x > c->max_x || !c->started) c->max_x = x;\n   if (y > c->max_y || !c->started) c->max_y = y;\n   if (x < c->min_x || !c->started) c->min_x = x;\n   if (y < c->min_y || !c->started) c->min_y = y;\n   c->started = 1;\n}\n\nstatic void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)\n{\n   if (c->bounds) {\n      stbtt__track_vertex(c, x, y);\n      if (type == STBTT_vcubic) {\n         stbtt__track_vertex(c, cx, cy);\n         stbtt__track_vertex(c, cx1, cy1);\n      }\n   } else {\n      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);\n      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;\n      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;\n   }\n   c->num_vertices++;\n}\n\nstatic void stbtt__csctx_close_shape(stbtt__csctx *ctx)\n{\n   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)\n      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   stbtt__csctx_close_shape(ctx);\n   ctx->first_x = ctx->x = ctx->x + dx;\n   ctx->first_y = ctx->y = ctx->y + dy;\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   ctx->x += dx;\n   ctx->y += dy;\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)\n{\n   float cx1 = ctx->x + dx1;\n   float cy1 = ctx->y + dy1;\n   float cx2 = cx1 + dx2;\n   float cy2 = cy1 + dy2;\n   ctx->x = cx2 + dx3;\n   ctx->y = cy2 + dy3;\n   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);\n}\n\nstatic stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)\n{\n   int count = stbtt__cff_index_count(&idx);\n   int bias = 107;\n   if (count >= 33900)\n      bias = 32768;\n   else if (count >= 1240)\n      bias = 1131;\n   n += bias;\n   if (n < 0 || n >= count)\n      return stbtt__new_buf(NULL, 0);\n   return stbtt__cff_index_get(idx, n);\n}\n\nstatic stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt__buf fdselect = info->fdselect;\n   int nranges, start, end, v, fmt, fdselector = -1, i;\n\n   stbtt__buf_seek(&fdselect, 0);\n   fmt = stbtt__buf_get8(&fdselect);\n   if (fmt == 0) {\n      // untested\n      stbtt__buf_skip(&fdselect, glyph_index);\n      fdselector = stbtt__buf_get8(&fdselect);\n   } else if (fmt == 3) {\n      nranges = stbtt__buf_get16(&fdselect);\n      start = stbtt__buf_get16(&fdselect);\n      for (i = 0; i < nranges; i++) {\n         v = stbtt__buf_get8(&fdselect);\n         end = stbtt__buf_get16(&fdselect);\n         if (glyph_index >= start && glyph_index < end) {\n            fdselector = v;\n            break;\n         }\n         start = end;\n      }\n   }\n   if (fdselector == -1) return stbtt__new_buf(NULL, 0); // [DEAR IMGUI] fixed, see #6007 and nothings/stb#1422\n   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));\n}\n\nstatic int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)\n{\n   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;\n   int has_subrs = 0, clear_stack;\n   float s[48];\n   stbtt__buf subr_stack[10], subrs = info->subrs, b;\n   float f;\n\n#define STBTT__CSERR(s) (0)\n\n   // this currently ignores the initial width value, which isn't needed if we have hmtx\n   b = stbtt__cff_index_get(info->charstrings, glyph_index);\n   while (b.cursor < b.size) {\n      i = 0;\n      clear_stack = 1;\n      b0 = stbtt__buf_get8(&b);\n      switch (b0) {\n      // @TODO implement hinting\n      case 0x13: // hintmask\n      case 0x14: // cntrmask\n         if (in_header)\n            maskbits += (sp / 2); // implicit \"vstem\"\n         in_header = 0;\n         stbtt__buf_skip(&b, (maskbits + 7) / 8);\n         break;\n\n      case 0x01: // hstem\n      case 0x03: // vstem\n      case 0x12: // hstemhm\n      case 0x17: // vstemhm\n         maskbits += (sp / 2);\n         break;\n\n      case 0x15: // rmoveto\n         in_header = 0;\n         if (sp < 2) return STBTT__CSERR(\"rmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);\n         break;\n      case 0x04: // vmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"vmoveto stack\");\n         stbtt__csctx_rmove_to(c, 0, s[sp-1]);\n         break;\n      case 0x16: // hmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"hmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-1], 0);\n         break;\n\n      case 0x05: // rlineto\n         if (sp < 2) return STBTT__CSERR(\"rlineto stack\");\n         for (; i + 1 < sp; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical\n      // starting from a different place.\n\n      case 0x07: // vlineto\n         if (sp < 1) return STBTT__CSERR(\"vlineto stack\");\n         goto vlineto;\n      case 0x06: // hlineto\n         if (sp < 1) return STBTT__CSERR(\"hlineto stack\");\n         for (;;) {\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, s[i], 0);\n            i++;\n      vlineto:\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, 0, s[i]);\n            i++;\n         }\n         break;\n\n      case 0x1F: // hvcurveto\n         if (sp < 4) return STBTT__CSERR(\"hvcurveto stack\");\n         goto hvcurveto;\n      case 0x1E: // vhcurveto\n         if (sp < 4) return STBTT__CSERR(\"vhcurveto stack\");\n         for (;;) {\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);\n            i += 4;\n      hvcurveto:\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);\n            i += 4;\n         }\n         break;\n\n      case 0x08: // rrcurveto\n         if (sp < 6) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x18: // rcurveline\n         if (sp < 8) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp - 2; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         if (i + 1 >= sp) return STBTT__CSERR(\"rcurveline stack\");\n         stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      case 0x19: // rlinecurve\n         if (sp < 8) return STBTT__CSERR(\"rlinecurve stack\");\n         for (; i + 1 < sp - 6; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         if (i + 5 >= sp) return STBTT__CSERR(\"rlinecurve stack\");\n         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x1A: // vvcurveto\n      case 0x1B: // hhcurveto\n         if (sp < 4) return STBTT__CSERR(\"(vv|hh)curveto stack\");\n         f = 0.0;\n         if (sp & 1) { f = s[i]; i++; }\n         for (; i + 3 < sp; i += 4) {\n            if (b0 == 0x1B)\n               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);\n            else\n               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);\n            f = 0.0;\n         }\n         break;\n\n      case 0x0A: // callsubr\n         if (!has_subrs) {\n            if (info->fdselect.size)\n               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);\n            has_subrs = 1;\n         }\n         // FALLTHROUGH\n      case 0x1D: // callgsubr\n         if (sp < 1) return STBTT__CSERR(\"call(g|)subr stack\");\n         v = (int) s[--sp];\n         if (subr_stack_height >= 10) return STBTT__CSERR(\"recursion limit\");\n         subr_stack[subr_stack_height++] = b;\n         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);\n         if (b.size == 0) return STBTT__CSERR(\"subr not found\");\n         b.cursor = 0;\n         clear_stack = 0;\n         break;\n\n      case 0x0B: // return\n         if (subr_stack_height <= 0) return STBTT__CSERR(\"return outside subr\");\n         b = subr_stack[--subr_stack_height];\n         clear_stack = 0;\n         break;\n\n      case 0x0E: // endchar\n         stbtt__csctx_close_shape(c);\n         return 1;\n\n      case 0x0C: { // two-byte escape\n         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;\n         float dx, dy;\n         int b1 = stbtt__buf_get8(&b);\n         switch (b1) {\n         // @TODO These \"flex\" implementations ignore the flex-depth and resolution,\n         // and always draw beziers.\n         case 0x22: // hflex\n            if (sp < 7) return STBTT__CSERR(\"hflex stack\");\n            dx1 = s[0];\n            dx2 = s[1];\n            dy2 = s[2];\n            dx3 = s[3];\n            dx4 = s[4];\n            dx5 = s[5];\n            dx6 = s[6];\n            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);\n            break;\n\n         case 0x23: // flex\n            if (sp < 13) return STBTT__CSERR(\"flex stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = s[10];\n            dy6 = s[11];\n            //fd is s[12]\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         case 0x24: // hflex1\n            if (sp < 9) return STBTT__CSERR(\"hflex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dx4 = s[5];\n            dx5 = s[6];\n            dy5 = s[7];\n            dx6 = s[8];\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));\n            break;\n\n         case 0x25: // flex1\n            if (sp < 11) return STBTT__CSERR(\"flex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = dy6 = s[10];\n            dx = dx1+dx2+dx3+dx4+dx5;\n            dy = dy1+dy2+dy3+dy4+dy5;\n            if (STBTT_fabs(dx) > STBTT_fabs(dy))\n               dy6 = -dy;\n            else\n               dx6 = -dx;\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         default:\n            return STBTT__CSERR(\"unimplemented\");\n         }\n      } break;\n\n      default:\n         if (b0 != 255 && b0 != 28 && b0 < 32)\n            return STBTT__CSERR(\"reserved operator\");\n\n         // push immediate\n         if (b0 == 255) {\n            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;\n         } else {\n            stbtt__buf_skip(&b, -1);\n            f = (float)(stbtt_int16)stbtt__cff_int(&b);\n         }\n         if (sp >= 48) return STBTT__CSERR(\"push stack overflow\");\n         s[sp++] = f;\n         clear_stack = 0;\n         break;\n      }\n      if (clear_stack) sp = 0;\n   }\n   return STBTT__CSERR(\"no endchar\");\n\n#undef STBTT__CSERR\n}\n\nstatic int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   // runs the charstring twice, once to count and once to output (to avoid realloc)\n   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);\n   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);\n   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {\n      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);\n      output_ctx.pvertices = *pvertices;\n      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {\n         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);\n         return output_ctx.num_vertices;\n      }\n   }\n   *pvertices = NULL;\n   return 0;\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   stbtt__csctx c = STBTT__CSCTX_INIT(1);\n   int r = stbtt__run_charstring(info, glyph_index, &c);\n   if (x0)  *x0 = r ? c.min_x : 0;\n   if (y0)  *y0 = r ? c.min_y : 0;\n   if (x1)  *x1 = r ? c.max_x : 0;\n   if (y1)  *y1 = r ? c.max_y : 0;\n   return r ? c.num_vertices : 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   if (!info->cff.size)\n      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);\n   else\n      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);\n}\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);\n   if (glyph_index < numOfLongHorMetrics) {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);\n   } else {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));\n   }\n}\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   return ttUSHORT(data+10);\n}\n\nSTBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   int k, length;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   length = ttUSHORT(data+10);\n   if (table_length < length)\n      length = table_length;\n\n   for (k = 0; k < length; k++)\n   {\n      table[k].glyph1 = ttUSHORT(data+18+(k*6));\n      table[k].glyph2 = ttUSHORT(data+20+(k*6));\n      table[k].advance = ttSHORT(data+22+(k*6));\n   }\n\n   return length;\n}\n\nstatic int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   stbtt_uint32 needle, straw;\n   int l, r, m;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   l = 0;\n   r = ttUSHORT(data+10) - 1;\n   needle = glyph1 << 16 | glyph2;\n   while (l <= r) {\n      m = (l + r) >> 1;\n      straw = ttULONG(data+18+(m*6)); // note: unaligned read\n      if (needle < straw)\n         r = m - 1;\n      else if (needle > straw)\n         l = m + 1;\n      else\n         return ttSHORT(data+22+(m*6));\n   }\n   return 0;\n}\n\nstatic stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)\n{\n   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);\n   switch (coverageFormat) {\n      case 1: {\n         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);\n\n         // Binary search.\n         stbtt_int32 l=0, r=glyphCount-1, m;\n         int straw, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *glyphArray = coverageTable + 4;\n            stbtt_uint16 glyphID;\n            m = (l + r) >> 1;\n            glyphID = ttUSHORT(glyphArray + 2 * m);\n            straw = glyphID;\n            if (needle < straw)\n               r = m - 1;\n            else if (needle > straw)\n               l = m + 1;\n            else {\n               return m;\n            }\n         }\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);\n         stbtt_uint8 *rangeArray = coverageTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=rangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *rangeRecord;\n            m = (l + r) >> 1;\n            rangeRecord = rangeArray + 6 * m;\n            strawStart = ttUSHORT(rangeRecord);\n            strawEnd = ttUSHORT(rangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else {\n               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);\n               return startCoverageIndex + glyph - strawStart;\n            }\n         }\n         break;\n      }\n\n      default: return -1; // unsupported\n   }\n\n   return -1;\n}\n\nstatic stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)\n{\n   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);\n   switch (classDefFormat)\n   {\n      case 1: {\n         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);\n         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);\n         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;\n\n         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)\n            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);\n         stbtt_uint8 *classRangeRecords = classDefTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=classRangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *classRangeRecord;\n            m = (l + r) >> 1;\n            classRangeRecord = classRangeRecords + 6 * m;\n            strawStart = ttUSHORT(classRangeRecord);\n            strawEnd = ttUSHORT(classRangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else\n               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);\n         }\n         break;\n      }\n\n      default:\n         return -1; // Unsupported definition type, return an error.\n   }\n\n   // \"All glyphs not assigned to a class fall into class 0\". (OpenType spec)\n   return 0;\n}\n\n// Define to STBTT_assert(x) if you want to break on unimplemented formats.\n#define STBTT_GPOS_TODO_assert(x)\n\nstatic stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint16 lookupListOffset;\n   stbtt_uint8 *lookupList;\n   stbtt_uint16 lookupCount;\n   stbtt_uint8 *data;\n   stbtt_int32 i, sti;\n\n   if (!info->gpos) return 0;\n\n   data = info->data + info->gpos;\n\n   if (ttUSHORT(data+0) != 1) return 0; // Major version 1\n   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0\n\n   lookupListOffset = ttUSHORT(data+8);\n   lookupList = data + lookupListOffset;\n   lookupCount = ttUSHORT(lookupList);\n\n   for (i=0; i<lookupCount; ++i) {\n      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);\n      stbtt_uint8 *lookupTable = lookupList + lookupOffset;\n\n      stbtt_uint16 lookupType = ttUSHORT(lookupTable);\n      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);\n      stbtt_uint8 *subTableOffsets = lookupTable + 6;\n      if (lookupType != 2) // Pair Adjustment Positioning Subtable\n         continue;\n\n      for (sti=0; sti<subTableCount; sti++) {\n         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);\n         stbtt_uint8 *table = lookupTable + subtableOffset;\n         stbtt_uint16 posFormat = ttUSHORT(table);\n         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);\n         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);\n         if (coverageIndex == -1) continue;\n\n         switch (posFormat) {\n            case 1: {\n               stbtt_int32 l, r, m;\n               int straw, needle;\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_int32 valueRecordPairSizeInBytes = 2;\n                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);\n                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);\n                  stbtt_uint8 *pairValueTable = table + pairPosOffset;\n                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);\n                  stbtt_uint8 *pairValueArray = pairValueTable + 2;\n\n                  if (coverageIndex >= pairSetCount) return 0;\n\n                  needle=glyph2;\n                  r=pairValueCount-1;\n                  l=0;\n\n                  // Binary search.\n                  while (l <= r) {\n                     stbtt_uint16 secondGlyph;\n                     stbtt_uint8 *pairValue;\n                     m = (l + r) >> 1;\n                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;\n                     secondGlyph = ttUSHORT(pairValue);\n                     straw = secondGlyph;\n                     if (needle < straw)\n                        r = m - 1;\n                     else if (needle > straw)\n                        l = m + 1;\n                     else {\n                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);\n                        return xAdvance;\n                     }\n                  }\n               } else\n                  return 0;\n               break;\n            }\n\n            case 2: {\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);\n                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);\n                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);\n                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);\n\n                  stbtt_uint16 class1Count = ttUSHORT(table + 12);\n                  stbtt_uint16 class2Count = ttUSHORT(table + 14);\n                  stbtt_uint8 *class1Records, *class2Records;\n                  stbtt_int16 xAdvance;\n\n                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed\n                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed\n\n                  class1Records = table + 16;\n                  class2Records = class1Records + 2 * (glyph1class * class2Count);\n                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);\n                  return xAdvance;\n               } else\n                  return 0;\n               break;\n            }\n\n            default:\n               return 0; // Unsupported position format\n         }\n      }\n   }\n\n   return 0;\n}\n\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\n{\n   int xAdvance = 0;\n\n   if (info->gpos)\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\n   else if (info->kern)\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\n\n   return xAdvance;\n}\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\n{\n   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs\n      return 0;\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\n}\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\n}\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\n{\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\n}\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\n{\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS/2\");\n   if (!tab)\n      return 0;\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\n   return 1;\n}\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)\n{\n   *x0 = ttSHORT(info->data + info->head + 36);\n   *y0 = ttSHORT(info->data + info->head + 38);\n   *x1 = ttSHORT(info->data + info->head + 40);\n   *y1 = ttSHORT(info->data + info->head + 42);\n}\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)\n{\n   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);\n   return (float) height / fheight;\n}\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)\n{\n   int unitsPerEm = ttUSHORT(info->data + info->head + 18);\n   return pixels / unitsPerEm;\n}\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)\n{\n   STBTT_free(v, info->userdata);\n}\n\nSTBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)\n{\n   int i;\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);\n\n   int numEntries = ttUSHORT(svg_doc_list);\n   stbtt_uint8 *svg_docs = svg_doc_list + 2;\n\n   for(i=0; i<numEntries; i++) {\n      stbtt_uint8 *svg_doc = svg_docs + (12 * i);\n      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))\n         return svg_doc;\n   }\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc;\n\n   if (info->svg == 0)\n      return 0;\n\n   svg_doc = stbtt_FindSVGDoc(info, gl);\n   if (svg_doc != NULL) {\n      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);\n      return ttULONG(svg_doc + 8);\n   } else {\n      return 0;\n   }\n}\n\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)\n{\n   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// antialiasing software rasterizer\n//\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning\n   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {\n      // e.g. space character\n      if (ix0) *ix0 = 0;\n      if (iy0) *iy0 = 0;\n      if (ix1) *ix1 = 0;\n      if (iy1) *iy1 = 0;\n   } else {\n      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?\n      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);\n      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);\n      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);\n      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);\n   }\n}\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Rasterizer\n\ntypedef struct stbtt__hheap_chunk\n{\n   struct stbtt__hheap_chunk *next;\n} stbtt__hheap_chunk;\n\ntypedef struct stbtt__hheap\n{\n   struct stbtt__hheap_chunk *head;\n   void   *first_free;\n   int    num_remaining_in_head_chunk;\n} stbtt__hheap;\n\nstatic void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)\n{\n   if (hh->first_free) {\n      void *p = hh->first_free;\n      hh->first_free = * (void **) p;\n      return p;\n   } else {\n      if (hh->num_remaining_in_head_chunk == 0) {\n         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);\n         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);\n         if (c == NULL)\n            return NULL;\n         c->next = hh->head;\n         hh->head = c;\n         hh->num_remaining_in_head_chunk = count;\n      }\n      --hh->num_remaining_in_head_chunk;\n      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;\n   }\n}\n\nstatic void stbtt__hheap_free(stbtt__hheap *hh, void *p)\n{\n   *(void **) p = hh->first_free;\n   hh->first_free = p;\n}\n\nstatic void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\n{\n   stbtt__hheap_chunk *c = hh->head;\n   while (c) {\n      stbtt__hheap_chunk *n = c->next;\n      STBTT_free(c, userdata);\n      c = n;\n   }\n}\n\ntypedef struct stbtt__edge {\n   float x0,y0, x1,y1;\n   int invert;\n} stbtt__edge;\n\n\ntypedef struct stbtt__active_edge\n{\n   struct stbtt__active_edge *next;\n   #if STBTT_RASTERIZER_VERSION==1\n   int x,dx;\n   float ey;\n   int direction;\n   #elif STBTT_RASTERIZER_VERSION==2\n   float fx,fdx,fdy;\n   float direction;\n   float sy;\n   float ey;\n   #else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n   #endif\n} stbtt__active_edge;\n\n#if STBTT_RASTERIZER_VERSION == 1\n#define STBTT_FIXSHIFT   10\n#define STBTT_FIX        (1 << STBTT_FIXSHIFT)\n#define STBTT_FIXMASK    (STBTT_FIX-1)\n\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != NULL);\n   if (!z) return z;\n\n   // round dx down to avoid overshooting\n   if (dxdy < 0)\n      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);\n   else\n      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);\n\n   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount\n   z->x -= off_x * STBTT_FIX;\n\n   z->ey = e->y1;\n   z->next = 0;\n   z->direction = e->invert ? 1 : -1;\n   return z;\n}\n#elif STBTT_RASTERIZER_VERSION == 2\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != NULL);\n   //STBTT_assert(e->y0 <= start_point);\n   if (!z) return z;\n   z->fdx = dxdy;\n   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;\n   z->fx = e->x0 + dxdy * (start_point - e->y0);\n   z->fx -= off_x;\n   z->direction = e->invert ? 1.0f : -1.0f;\n   z->sy = e->y0;\n   z->ey = e->y1;\n   z->next = 0;\n   return z;\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#if STBTT_RASTERIZER_VERSION == 1\n// note: this routine clips fills that extend off the edges... ideally this\n// wouldn't happen, but it could happen if the truetype glyph bounding boxes\n// are wrong, or if the user supplies a too-small bitmap\nstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)\n{\n   // non-zero winding fill\n   int x0=0, w=0;\n\n   while (e) {\n      if (w == 0) {\n         // if we're currently at zero, we need to record the edge start point\n         x0 = e->x; w += e->direction;\n      } else {\n         int x1 = e->x; w += e->direction;\n         // if we went to zero, we need to draw\n         if (w == 0) {\n            int i = x0 >> STBTT_FIXSHIFT;\n            int j = x1 >> STBTT_FIXSHIFT;\n\n            if (i < len && j >= 0) {\n               if (i == j) {\n                  // x0,x1 are the same pixel, so compute combined coverage\n                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);\n               } else {\n                  if (i >= 0) // add antialiasing for x0\n                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     i = -1; // clip\n\n                  if (j < len) // add antialiasing for x1\n                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     j = len; // clip\n\n                  for (++i; i < j; ++i) // fill pixels between x0 and x1\n                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;\n               }\n            }\n         }\n      }\n\n      e = e->next;\n   }\n}\n\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = NULL;\n   int y,j=0;\n   int max_weight = (255 / vsubsample);  // weight per vertical scanline\n   int s; // vertical subsample index\n   unsigned char scanline_data[512], *scanline;\n\n   if (result->w > 512)\n      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);\n   else\n      scanline = scanline_data;\n\n   y = off_y * vsubsample;\n   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;\n\n   while (j < result->h) {\n      STBTT_memset(scanline, 0, result->w);\n      for (s=0; s < vsubsample; ++s) {\n         // find center of pixel for this scanline\n         float scan_y = y + 0.5f;\n         stbtt__active_edge **step = &active;\n\n         // update all active edges;\n         // remove all active edges that terminate before the center of this scanline\n         while (*step) {\n            stbtt__active_edge * z = *step;\n            if (z->ey <= scan_y) {\n               *step = z->next; // delete from list\n               STBTT_assert(z->direction);\n               z->direction = 0;\n               stbtt__hheap_free(&hh, z);\n            } else {\n               z->x += z->dx; // advance to position for current scanline\n               step = &((*step)->next); // advance through list\n            }\n         }\n\n         // resort the list if needed\n         for(;;) {\n            int changed=0;\n            step = &active;\n            while (*step && (*step)->next) {\n               if ((*step)->x > (*step)->next->x) {\n                  stbtt__active_edge *t = *step;\n                  stbtt__active_edge *q = t->next;\n\n                  t->next = q->next;\n                  q->next = t;\n                  *step = q;\n                  changed = 1;\n               }\n               step = &(*step)->next;\n            }\n            if (!changed) break;\n         }\n\n         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline\n         while (e->y0 <= scan_y) {\n            if (e->y1 > scan_y) {\n               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);\n               if (z != NULL) {\n                  // find insertion point\n                  if (active == NULL)\n                     active = z;\n                  else if (z->x < active->x) {\n                     // insert at front\n                     z->next = active;\n                     active = z;\n                  } else {\n                     // find thing to insert AFTER\n                     stbtt__active_edge *p = active;\n                     while (p->next && p->next->x < z->x)\n                        p = p->next;\n                     // at this point, p->next->x is NOT < z->x\n                     z->next = p->next;\n                     p->next = z;\n                  }\n               }\n            }\n            ++e;\n         }\n\n         // now process all active edges in XOR fashion\n         if (active)\n            stbtt__fill_active_edges(scanline, result->w, active, max_weight);\n\n         ++y;\n      }\n      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n\n#elif STBTT_RASTERIZER_VERSION == 2\n\n// the edge passed in here does not cross the vertical line at x or the vertical line at x+1\n// (i.e. it has already been clipped to those)\nstatic void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)\n{\n   if (y0 == y1) return;\n   STBTT_assert(y0 < y1);\n   STBTT_assert(e->sy <= e->ey);\n   if (y0 > e->ey) return;\n   if (y1 < e->sy) return;\n   if (y0 < e->sy) {\n      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);\n      y0 = e->sy;\n   }\n   if (y1 > e->ey) {\n      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);\n      y1 = e->ey;\n   }\n\n   if (x0 == x)\n      STBTT_assert(x1 <= x+1);\n   else if (x0 == x+1)\n      STBTT_assert(x1 >= x);\n   else if (x0 <= x)\n      STBTT_assert(x1 <= x);\n   else if (x0 >= x+1)\n      STBTT_assert(x1 >= x+1);\n   else\n      STBTT_assert(x1 >= x && x1 <= x+1);\n\n   if (x0 <= x && x1 <= x)\n      scanline[x] += e->direction * (y1-y0);\n   else if (x0 >= x+1 && x1 >= x+1)\n      ;\n   else {\n      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);\n      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position\n   }\n}\n\nstatic float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)\n{\n   STBTT_assert(top_width >= 0);\n   STBTT_assert(bottom_width >= 0);\n   return (top_width + bottom_width) / 2.0f * height;\n}\n\nstatic float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)\n{\n   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);\n}\n\nstatic float stbtt__sized_triangle_area(float height, float width)\n{\n   return height * width / 2;\n}\n\nstatic void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)\n{\n   float y_bottom = y_top+1;\n\n   while (e) {\n      // brute force every pixel\n\n      // compute intersection points with top & bottom\n      STBTT_assert(e->ey >= y_top);\n\n      if (e->fdx == 0) {\n         float x0 = e->fx;\n         if (x0 < len) {\n            if (x0 >= 0) {\n               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);\n               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);\n            } else {\n               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);\n            }\n         }\n      } else {\n         float x0 = e->fx;\n         float dx = e->fdx;\n         float xb = x0 + dx;\n         float x_top, x_bottom;\n         float sy0,sy1;\n         float dy = e->fdy;\n         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);\n\n         // compute endpoints of line segment clipped to this scanline (if the\n         // line segment starts on this scanline. x0 is the intersection of the\n         // line with y_top, but that may be off the line segment.\n         if (e->sy > y_top) {\n            x_top = x0 + dx * (e->sy - y_top);\n            sy0 = e->sy;\n         } else {\n            x_top = x0;\n            sy0 = y_top;\n         }\n         if (e->ey < y_bottom) {\n            x_bottom = x0 + dx * (e->ey - y_top);\n            sy1 = e->ey;\n         } else {\n            x_bottom = xb;\n            sy1 = y_bottom;\n         }\n\n         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {\n            // from here on, we don't have to range check x values\n\n            if ((int) x_top == (int) x_bottom) {\n               float height;\n               // simple case, only spans one pixel\n               int x = (int) x_top;\n               height = (sy1 - sy0) * e->direction;\n               STBTT_assert(x >= 0 && x < len);\n               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);\n               scanline_fill[x] += height; // everything right of this pixel is filled\n            } else {\n               int x,x1,x2;\n               float y_crossing, y_final, step, sign, area;\n               // covers 2+ pixels\n               if (x_top > x_bottom) {\n                  // flip scanline vertically; signed area is the same\n                  float t;\n                  sy0 = y_bottom - (sy0 - y_top);\n                  sy1 = y_bottom - (sy1 - y_top);\n                  t = sy0, sy0 = sy1, sy1 = t;\n                  t = x_bottom, x_bottom = x_top, x_top = t;\n                  dx = -dx;\n                  dy = -dy;\n                  t = x0, x0 = xb, xb = t;\n               }\n               STBTT_assert(dy >= 0);\n               STBTT_assert(dx >= 0);\n\n               x1 = (int) x_top;\n               x2 = (int) x_bottom;\n               // compute intersection with y axis at x1+1\n               y_crossing = y_top + dy * (x1+1 - x0);\n\n               // compute intersection with y axis at x2\n               y_final = y_top + dy * (x2 - x0);\n\n               //           x1    x_top                            x2    x_bottom\n               //     y_top  +------|-----+------------+------------+--------|---+------------+\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //       sy0  |      Txxxxx|............|............|............|............|\n               // y_crossing |            *xxxxx.......|............|............|............|\n               //            |            |     xxxxx..|............|............|............|\n               //            |            |     /-   xx*xxxx........|............|............|\n               //            |            | dy <       |    xxxxxx..|............|............|\n               //   y_final  |            |     \\-     |          xx*xxx.........|............|\n               //       sy1  |            |            |            |   xxxxxB...|............|\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //  y_bottom  +------------+------------+------------+------------+------------+\n               //\n               // goal is to measure the area covered by '.' in each pixel\n\n               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057\n               // @TODO: maybe test against sy1 rather than y_bottom?\n               if (y_crossing > y_bottom)\n                  y_crossing = y_bottom;\n\n               sign = e->direction;\n\n               // area of the rectangle covered from sy0..y_crossing\n               area = sign * (y_crossing-sy0);\n\n               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)\n               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);\n\n               // check if final y_crossing is blown up; no test case for this\n               if (y_final > y_bottom) {\n                  int denom = (x2 - (x1+1));\n                  y_final = y_bottom;\n                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)\n                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom\n                  }\n               }\n\n               // in second pixel, area covered by line segment found in first pixel\n               // is always a rectangle 1 wide * the height of that line segment; this\n               // is exactly what the variable 'area' stores. it also gets a contribution\n               // from the line segment within it. the THIRD pixel will get the first\n               // pixel's rectangle contribution, the second pixel's rectangle contribution,\n               // and its own contribution. the 'own contribution' is the same in every pixel except\n               // the leftmost and rightmost, a trapezoid that slides down in each pixel.\n               // the second pixel's contribution to the third pixel will be the\n               // rectangle 1 wide times the height change in the second pixel, which is dy.\n\n               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,\n               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x\n               // so the area advances by 'step' every time\n\n               for (x = x1+1; x < x2; ++x) {\n                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2\n                  area += step;\n               }\n               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down\n               STBTT_assert(sy1 > y_final-0.01f);\n\n               // area covered in the last pixel is the rectangle from all the pixels to the left,\n               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge\n               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);\n\n               // the rest of the line is filled based on the total height of the line segment in this pixel\n               scanline_fill[x2] += sign * (sy1-sy0);\n            }\n         } else {\n            // if edge goes outside of box we're drawing, we require\n            // clipping logic. since this does not match the intended use\n            // of this library, we use a different, very slow brute\n            // force implementation\n            // note though that this does happen some of the time because\n            // x_top and x_bottom can be extrapolated at the top & bottom of\n            // the shape and actually lie outside the bounding box\n            int x;\n            for (x=0; x < len; ++x) {\n               // cases:\n               //\n               // there can be up to two intersections with the pixel. any intersection\n               // with left or right edges can be handled by splitting into two (or three)\n               // regions. intersections with top & bottom do not necessitate case-wise logic.\n               //\n               // the old way of doing this found the intersections with the left & right edges,\n               // then used some simple logic to produce up to three segments in sorted order\n               // from top-to-bottom. however, this had a problem: if an x edge was epsilon\n               // across the x border, then the corresponding y position might not be distinct\n               // from the other y segment, and it might ignored as an empty segment. to avoid\n               // that, we need to explicitly produce segments based on x positions.\n\n               // rename variables to clearly-defined pairs\n               float y0 = y_top;\n               float x1 = (float) (x);\n               float x2 = (float) (x+1);\n               float x3 = xb;\n               float y3 = y_bottom;\n\n               // x = e->x + e->dx * (y-y_top)\n               // (y-y_top) = (x - e->x) / e->dx\n               // y = (x - e->x) / e->dx + y_top\n               float y1 = (x - x0) / dx + y_top;\n               float y2 = (x+1 - x0) / dx + y_top;\n\n               if (x0 < x1 && x3 > x2) {         // three segments descending down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else {  // one segment\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);\n               }\n            }\n         }\n      }\n      e = e->next;\n   }\n}\n\n// directly AA rasterize edges w/o supersampling\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = NULL;\n   int y,j=0, i;\n   float scanline_data[129], *scanline, *scanline2;\n\n   STBTT__NOTUSED(vsubsample);\n\n   if (result->w > 64)\n      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);\n   else\n      scanline = scanline_data;\n\n   scanline2 = scanline + result->w;\n\n   y = off_y;\n   e[n].y0 = (float) (off_y + result->h) + 1;\n\n   while (j < result->h) {\n      // find center of pixel for this scanline\n      float scan_y_top    = y + 0.0f;\n      float scan_y_bottom = y + 1.0f;\n      stbtt__active_edge **step = &active;\n\n      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));\n      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));\n\n      // update all active edges;\n      // remove all active edges that terminate before the top of this scanline\n      while (*step) {\n         stbtt__active_edge * z = *step;\n         if (z->ey <= scan_y_top) {\n            *step = z->next; // delete from list\n            STBTT_assert(z->direction);\n            z->direction = 0;\n            stbtt__hheap_free(&hh, z);\n         } else {\n            step = &((*step)->next); // advance through list\n         }\n      }\n\n      // insert all edges that start before the bottom of this scanline\n      while (e->y0 <= scan_y_bottom) {\n         if (e->y0 != e->y1) {\n            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);\n            if (z != NULL) {\n               if (j == 0 && off_y != 0) {\n                  if (z->ey < scan_y_top) {\n                     // this can happen due to subpixel positioning and some kind of fp rounding error i think\n                     z->ey = scan_y_top;\n                  }\n               }\n               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds\n               // insert at front\n               z->next = active;\n               active = z;\n            }\n         }\n         ++e;\n      }\n\n      // now process all active edges\n      if (active)\n         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);\n\n      {\n         float sum = 0;\n         for (i=0; i < result->w; ++i) {\n            float k;\n            int m;\n            sum += scanline2[i];\n            k = scanline[i] + sum;\n            k = (float) STBTT_fabs(k)*255 + 0.5f;\n            m = (int) k;\n            if (m > 255) m = 255;\n            result->pixels[j*result->stride + i] = (unsigned char) m;\n         }\n      }\n      // advance all the edges\n      step = &active;\n      while (*step) {\n         stbtt__active_edge *z = *step;\n         z->fx += z->fdx; // advance to position for current scanline\n         step = &((*step)->next); // advance through list\n      }\n\n      ++y;\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)\n\nstatic void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)\n{\n   int i,j;\n   for (i=1; i < n; ++i) {\n      stbtt__edge t = p[i], *a = &t;\n      j = i;\n      while (j > 0) {\n         stbtt__edge *b = &p[j-1];\n         int c = STBTT__COMPARE(a,b);\n         if (!c) break;\n         p[j] = p[j-1];\n         --j;\n      }\n      if (i != j)\n         p[j] = t;\n   }\n}\n\nstatic void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)\n{\n   /* threshold for transitioning to insertion sort */\n   while (n > 12) {\n      stbtt__edge t;\n      int c01,c12,c,m,i,j;\n\n      /* compute median of three */\n      m = n >> 1;\n      c01 = STBTT__COMPARE(&p[0],&p[m]);\n      c12 = STBTT__COMPARE(&p[m],&p[n-1]);\n      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */\n      if (c01 != c12) {\n         /* otherwise, we'll need to swap something else to middle */\n         int z;\n         c = STBTT__COMPARE(&p[0],&p[n-1]);\n         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */\n         /* 0<mid && mid>n:  0>n => 0; 0<n => n */\n         z = (c == c12) ? 0 : n-1;\n         t = p[z];\n         p[z] = p[m];\n         p[m] = t;\n      }\n      /* now p[m] is the median-of-three */\n      /* swap it to the beginning so it won't move around */\n      t = p[0];\n      p[0] = p[m];\n      p[m] = t;\n\n      /* partition loop */\n      i=1;\n      j=n-1;\n      for(;;) {\n         /* handling of equality is crucial here */\n         /* for sentinels & efficiency with duplicates */\n         for (;;++i) {\n            if (!STBTT__COMPARE(&p[i], &p[0])) break;\n         }\n         for (;;--j) {\n            if (!STBTT__COMPARE(&p[0], &p[j])) break;\n         }\n         /* make sure we haven't crossed */\n         if (i >= j) break;\n         t = p[i];\n         p[i] = p[j];\n         p[j] = t;\n\n         ++i;\n         --j;\n      }\n      /* recurse on smaller side, iterate on larger */\n      if (j < (n-i)) {\n         stbtt__sort_edges_quicksort(p,j);\n         p = p+i;\n         n = n-i;\n      } else {\n         stbtt__sort_edges_quicksort(p+i, n-i);\n         n = j;\n      }\n   }\n}\n\nstatic void stbtt__sort_edges(stbtt__edge *p, int n)\n{\n   stbtt__sort_edges_quicksort(p, n);\n   stbtt__sort_edges_ins_sort(p, n);\n}\n\ntypedef struct\n{\n   float x,y;\n} stbtt__point;\n\nstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)\n{\n   float y_scale_inv = invert ? -scale_y : scale_y;\n   stbtt__edge *e;\n   int n,i,j,k,m;\n#if STBTT_RASTERIZER_VERSION == 1\n   int vsubsample = result->h < 8 ? 15 : 5;\n#elif STBTT_RASTERIZER_VERSION == 2\n   int vsubsample = 1;\n#else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity\n\n   // now we have to blow out the windings into explicit edge lists\n   n = 0;\n   for (i=0; i < windings; ++i)\n      n += wcount[i];\n\n   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel\n   if (e == 0) return;\n   n = 0;\n\n   m=0;\n   for (i=0; i < windings; ++i) {\n      stbtt__point *p = pts + m;\n      m += wcount[i];\n      j = wcount[i]-1;\n      for (k=0; k < wcount[i]; j=k++) {\n         int a=k,b=j;\n         // skip the edge if horizontal\n         if (p[j].y == p[k].y)\n            continue;\n         // add edge from j to k to the list\n         e[n].invert = 0;\n         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {\n            e[n].invert = 1;\n            a=j,b=k;\n         }\n         e[n].x0 = p[a].x * scale_x + shift_x;\n         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;\n         e[n].x1 = p[b].x * scale_x + shift_x;\n         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;\n         ++n;\n      }\n   }\n\n   // now sort the edges by their highest point (should snap to integer, and then by x)\n   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);\n   stbtt__sort_edges(e, n);\n\n   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule\n   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);\n\n   STBTT_free(e, userdata);\n}\n\nstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)\n{\n   if (!points) return; // during first pass, it's unallocated\n   points[n].x = x;\n   points[n].y = y;\n}\n\n// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching\nstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)\n{\n   // midpoint\n   float mx = (x0 + 2*x1 + x2)/4;\n   float my = (y0 + 2*y1 + y2)/4;\n   // versus directly drawn line\n   float dx = (x0+x2)/2 - mx;\n   float dy = (y0+y2)/2 - my;\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return 1;\n   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA\n      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x2,y2);\n      *num_points = *num_points+1;\n   }\n   return 1;\n}\n\nstatic void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)\n{\n   // @TODO this \"flatness\" calculation is just made-up nonsense that seems to work well enough\n   float dx0 = x1-x0;\n   float dy0 = y1-y0;\n   float dx1 = x2-x1;\n   float dy1 = y2-y1;\n   float dx2 = x3-x2;\n   float dy2 = y3-y2;\n   float dx = x3-x0;\n   float dy = y3-y0;\n   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));\n   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);\n   float flatness_squared = longlen*longlen-shortlen*shortlen;\n\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return;\n\n   if (flatness_squared > objspace_flatness_squared) {\n      float x01 = (x0+x1)/2;\n      float y01 = (y0+y1)/2;\n      float x12 = (x1+x2)/2;\n      float y12 = (y1+y2)/2;\n      float x23 = (x2+x3)/2;\n      float y23 = (y2+y3)/2;\n\n      float xa = (x01+x12)/2;\n      float ya = (y01+y12)/2;\n      float xb = (x12+x23)/2;\n      float yb = (y12+y23)/2;\n\n      float mx = (xa+xb)/2;\n      float my = (ya+yb)/2;\n\n      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x3,y3);\n      *num_points = *num_points+1;\n   }\n}\n\n// returns number of contours\nstatic stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)\n{\n   stbtt__point *points=0;\n   int num_points=0;\n\n   float objspace_flatness_squared = objspace_flatness * objspace_flatness;\n   int i,n=0,start=0, pass;\n\n   // count how many \"moves\" there are to get the contour count\n   for (i=0; i < num_verts; ++i)\n      if (vertices[i].type == STBTT_vmove)\n         ++n;\n\n   *num_contours = n;\n   if (n == 0) return 0;\n\n   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);\n\n   if (*contour_lengths == 0) {\n      *num_contours = 0;\n      return 0;\n   }\n\n   // make two passes through the points so we don't need to realloc\n   for (pass=0; pass < 2; ++pass) {\n      float x=0,y=0;\n      if (pass == 1) {\n         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);\n         if (points == NULL) goto error;\n      }\n      num_points = 0;\n      n= -1;\n      for (i=0; i < num_verts; ++i) {\n         switch (vertices[i].type) {\n            case STBTT_vmove:\n               // start the next contour\n               if (n >= 0)\n                  (*contour_lengths)[n] = num_points - start;\n               ++n;\n               start = num_points;\n\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x,y);\n               break;\n            case STBTT_vline:\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x, y);\n               break;\n            case STBTT_vcurve:\n               stbtt__tesselate_curve(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n            case STBTT_vcubic:\n               stbtt__tesselate_cubic(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].cx1, vertices[i].cy1,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n         }\n      }\n      (*contour_lengths)[n] = num_points - start;\n   }\n\n   return points;\nerror:\n   STBTT_free(points, userdata);\n   STBTT_free(*contour_lengths, userdata);\n   *contour_lengths = 0;\n   *num_contours = 0;\n   return NULL;\n}\n\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)\n{\n   float scale            = scale_x > scale_y ? scale_y : scale_x;\n   int winding_count      = 0;\n   int *winding_lengths   = NULL;\n   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);\n   if (windings) {\n      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);\n      STBTT_free(winding_lengths, userdata);\n      STBTT_free(windings, userdata);\n   }\n}\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   int ix0,iy0,ix1,iy1;\n   stbtt__bitmap gbm;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n\n   if (scale_x == 0) scale_x = scale_y;\n   if (scale_y == 0) {\n      if (scale_x == 0) {\n         STBTT_free(vertices, info->userdata);\n         return NULL;\n      }\n      scale_y = scale_x;\n   }\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);\n\n   // now we get the size\n   gbm.w = (ix1 - ix0);\n   gbm.h = (iy1 - iy0);\n   gbm.pixels = NULL; // in case we error\n\n   if (width ) *width  = gbm.w;\n   if (height) *height = gbm.h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   if (gbm.w && gbm.h) {\n      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);\n      if (gbm.pixels) {\n         gbm.stride = gbm.w;\n\n         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);\n      }\n   }\n   STBTT_free(vertices, info->userdata);\n   return gbm.pixels;\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)\n{\n   int ix0,iy0;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n   stbtt__bitmap gbm;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);\n   gbm.pixels = output;\n   gbm.w = out_w;\n   gbm.h = out_h;\n   gbm.stride = out_stride;\n\n   if (gbm.w && gbm.h)\n      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);\n\n   STBTT_free(vertices, info->userdata);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)\n{\n   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-CRAPPY packing to keep source code small\n\nstatic int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata)\n{\n   float scale;\n   int x,y,bottom_y, i;\n   stbtt_fontinfo f;\n   f.userdata = NULL;\n   if (!stbtt_InitFont(&f, data, offset))\n      return -1;\n   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n   x=y=1;\n   bottom_y = 1;\n\n   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);\n\n   for (i=0; i < num_chars; ++i) {\n      int advance, lsb, x0,y0,x1,y1,gw,gh;\n      int g = stbtt_FindGlyphIndex(&f, first_char + i);\n      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);\n      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);\n      gw = x1-x0;\n      gh = y1-y0;\n      if (x + gw + 1 >= pw)\n         y = bottom_y, x = 1; // advance to next row\n      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row\n         return -i;\n      STBTT_assert(x+gw < pw);\n      STBTT_assert(y+gh < ph);\n      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);\n      chardata[i].x0 = (stbtt_int16) x;\n      chardata[i].y0 = (stbtt_int16) y;\n      chardata[i].x1 = (stbtt_int16) (x + gw);\n      chardata[i].y1 = (stbtt_int16) (y + gh);\n      chardata[i].xadvance = scale * advance;\n      chardata[i].xoff     = (float) x0;\n      chardata[i].yoff     = (float) y0;\n      x = x + gw + 1;\n      if (y+gh+1 > bottom_y)\n         bottom_y = y+gh+1;\n   }\n   return bottom_y;\n}\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)\n{\n   float d3d_bias = opengl_fillrule ? 0 : -0.5f;\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_bakedchar *b = chardata + char_index;\n   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n\n   q->x0 = round_x + d3d_bias;\n   q->y0 = round_y + d3d_bias;\n   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;\n   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// rectangle packing replacement routines if you don't have stb_rect_pack.h\n//\n\n#ifndef STB_RECT_PACK_VERSION\n\ntypedef int stbrp_coord;\n\n////////////////////////////////////////////////////////////////////////////////////\n//                                                                                //\n//                                                                                //\n// COMPILER WARNING ?!?!?                                                         //\n//                                                                                //\n//                                                                                //\n// if you get a compile warning due to these symbols being defined more than      //\n// once, move #include \"stb_rect_pack.h\" before #include \"stb_truetype.h\"         //\n//                                                                                //\n////////////////////////////////////////////////////////////////////////////////////\n\ntypedef struct\n{\n   int width,height;\n   int x,y,bottom_y;\n} stbrp_context;\n\ntypedef struct\n{\n   unsigned char x;\n} stbrp_node;\n\nstruct stbrp_rect\n{\n   stbrp_coord x,y;\n   int id,w,h,was_packed;\n};\n\nstatic void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\n{\n   con->width  = pw;\n   con->height = ph;\n   con->x = 0;\n   con->y = 0;\n   con->bottom_y = 0;\n   STBTT__NOTUSED(nodes);\n   STBTT__NOTUSED(num_nodes);\n}\n\nstatic void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)\n{\n   int i;\n   for (i=0; i < num_rects; ++i) {\n      if (con->x + rects[i].w > con->width) {\n         con->x = 0;\n         con->y = con->bottom_y;\n      }\n      if (con->y + rects[i].h > con->height)\n         break;\n      rects[i].x = con->x;\n      rects[i].y = con->y;\n      rects[i].was_packed = 1;\n      con->x += rects[i].w;\n      if (con->y + rects[i].h > con->bottom_y)\n         con->bottom_y = con->y + rects[i].h;\n   }\n   for (   ; i < num_rects; ++i)\n      rects[i].was_packed = 0;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If\n// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.\n\nSTBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)\n{\n   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);\n   int            num_nodes = pw - padding;\n   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);\n\n   if (context == NULL || nodes == NULL) {\n      if (context != NULL) STBTT_free(context, alloc_context);\n      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);\n      return 0;\n   }\n\n   spc->user_allocator_context = alloc_context;\n   spc->width = pw;\n   spc->height = ph;\n   spc->pixels = pixels;\n   spc->pack_info = context;\n   spc->nodes = nodes;\n   spc->padding = padding;\n   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;\n   spc->h_oversample = 1;\n   spc->v_oversample = 1;\n   spc->skip_missing = 0;\n\n   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);\n\n   if (pixels)\n      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n\n   return 1;\n}\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)\n{\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\n}\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)\n{\n   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);\n   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);\n   if (h_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->h_oversample = h_oversample;\n   if (v_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->v_oversample = v_oversample;\n}\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)\n{\n   spc->skip_missing = skip;\n}\n\n#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)\n\nstatic void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_w = w - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < h; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < w; ++i) {\n         STBTT_assert(pixels[i] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += stride_in_bytes;\n   }\n}\n\nstatic void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_h = h - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < w; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < h; ++i) {\n         STBTT_assert(pixels[i*stride_in_bytes] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += 1;\n   }\n}\n\nstatic float stbtt__oversample_shift(int oversample)\n{\n   if (!oversample)\n      return 0.0f;\n\n   // The prefilter is a box filter of width \"oversample\",\n   // which shifts phase by (oversample - 1)/2 pixels in\n   // oversampled space. We want to shift in the opposite\n   // direction to counter this.\n   return (float)-(oversample - 1) / (2.0f * (float)oversample);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k;\n   int missing_glyph_added = 0;\n\n   k=0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      ranges[i].h_oversample = (unsigned char) spc->h_oversample;\n      ranges[i].v_oversample = (unsigned char) spc->v_oversample;\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         int x0,y0,x1,y1;\n         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n         int glyph = stbtt_FindGlyphIndex(info, codepoint);\n         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {\n            rects[k].w = rects[k].h = 0;\n         } else {\n            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,\n                                            scale * spc->h_oversample,\n                                            scale * spc->v_oversample,\n                                            0,0,\n                                            &x0,&y0,&x1,&y1);\n            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);\n            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);\n            if (glyph == 0)\n               missing_glyph_added = 1;\n         }\n         ++k;\n      }\n   }\n\n   return k;\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info,\n                                 output,\n                                 out_w - (prefilter_x - 1),\n                                 out_h - (prefilter_y - 1),\n                                 out_stride,\n                                 scale_x,\n                                 scale_y,\n                                 shift_x,\n                                 shift_y,\n                                 glyph);\n\n   if (prefilter_x > 1)\n      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);\n\n   if (prefilter_y > 1)\n      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);\n\n   *sub_x = stbtt__oversample_shift(prefilter_x);\n   *sub_y = stbtt__oversample_shift(prefilter_y);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k, missing_glyph = -1, return_value = 1;\n\n   // save current values\n   int old_h_over = spc->h_oversample;\n   int old_v_over = spc->v_oversample;\n\n   k = 0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      float recip_h,recip_v,sub_x,sub_y;\n      spc->h_oversample = ranges[i].h_oversample;\n      spc->v_oversample = ranges[i].v_oversample;\n      recip_h = 1.0f / spc->h_oversample;\n      recip_v = 1.0f / spc->v_oversample;\n      sub_x = stbtt__oversample_shift(spc->h_oversample);\n      sub_y = stbtt__oversample_shift(spc->v_oversample);\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         stbrp_rect *r = &rects[k];\n         if (r->was_packed && r->w != 0 && r->h != 0) {\n            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];\n            int advance, lsb, x0,y0,x1,y1;\n            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n            int glyph = stbtt_FindGlyphIndex(info, codepoint);\n            stbrp_coord pad = (stbrp_coord) spc->padding;\n\n            // pad on left and top\n            r->x += pad;\n            r->y += pad;\n            r->w -= pad;\n            r->h -= pad;\n            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);\n            stbtt_GetGlyphBitmapBox(info, glyph,\n                                    scale * spc->h_oversample,\n                                    scale * spc->v_oversample,\n                                    &x0,&y0,&x1,&y1);\n            stbtt_MakeGlyphBitmapSubpixel(info,\n                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                          r->w - spc->h_oversample+1,\n                                          r->h - spc->v_oversample+1,\n                                          spc->stride_in_bytes,\n                                          scale * spc->h_oversample,\n                                          scale * spc->v_oversample,\n                                          0,0,\n                                          glyph);\n\n            if (spc->h_oversample > 1)\n               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->h_oversample);\n\n            if (spc->v_oversample > 1)\n               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->v_oversample);\n\n            bc->x0       = (stbtt_int16)  r->x;\n            bc->y0       = (stbtt_int16)  r->y;\n            bc->x1       = (stbtt_int16) (r->x + r->w);\n            bc->y1       = (stbtt_int16) (r->y + r->h);\n            bc->xadvance =                scale * advance;\n            bc->xoff     =       (float)  x0 * recip_h + sub_x;\n            bc->yoff     =       (float)  y0 * recip_v + sub_y;\n            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;\n            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;\n\n            if (glyph == 0)\n               missing_glyph = j;\n         } else if (spc->skip_missing) {\n            return_value = 0;\n         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {\n            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];\n         } else {\n            return_value = 0; // if any fail, report failure\n         }\n\n         ++k;\n      }\n   }\n\n   // restore original values\n   spc->h_oversample = old_h_over;\n   spc->v_oversample = old_v_over;\n\n   return return_value;\n}\n\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)\n{\n   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);\n}\n\nSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)\n{\n   stbtt_fontinfo info;\n   int i, j, n, return_value; // [DEAR IMGUI] removed = 1;\n   //stbrp_context *context = (stbrp_context *) spc->pack_info;\n   stbrp_rect    *rects;\n\n   // flag all characters as NOT packed\n   for (i=0; i < num_ranges; ++i)\n      for (j=0; j < ranges[i].num_chars; ++j)\n         ranges[i].chardata_for_range[j].x0 =\n         ranges[i].chardata_for_range[j].y0 =\n         ranges[i].chardata_for_range[j].x1 =\n         ranges[i].chardata_for_range[j].y1 = 0;\n\n   n = 0;\n   for (i=0; i < num_ranges; ++i)\n      n += ranges[i].num_chars;\n\n   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);\n   if (rects == NULL)\n      return 0;\n\n   info.userdata = spc->user_allocator_context;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));\n\n   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);\n\n   stbtt_PackFontRangesPackRects(spc, rects, n);\n\n   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);\n\n   STBTT_free(rects, spc->user_allocator_context);\n   return return_value;\n}\n\nSTBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)\n{\n   stbtt_pack_range range;\n   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;\n   range.array_of_unicode_codepoints = NULL;\n   range.num_chars                   = num_chars_in_range;\n   range.chardata_for_range          = chardata_for_range;\n   range.font_size                   = font_size;\n   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);\n}\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)\n{\n   int i_ascent, i_descent, i_lineGap;\n   float scale;\n   stbtt_fontinfo info;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));\n   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);\n   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);\n   *ascent  = (float) i_ascent  * scale;\n   *descent = (float) i_descent * scale;\n   *lineGap = (float) i_lineGap * scale;\n}\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)\n{\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_packedchar *b = chardata + char_index;\n\n   if (align_to_integer) {\n      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n      q->x0 = x;\n      q->y0 = y;\n      q->x1 = x + b->xoff2 - b->xoff;\n      q->y1 = y + b->yoff2 - b->yoff;\n   } else {\n      q->x0 = *xpos + b->xoff;\n      q->y0 = *ypos + b->yoff;\n      q->x1 = *xpos + b->xoff2;\n      q->y1 = *ypos + b->yoff2;\n   }\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// sdf computation\n//\n\n#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))\n#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))\n\nstatic int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])\n{\n   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];\n   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];\n   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];\n   float roperp = orig[1]*ray[0] - orig[0]*ray[1];\n\n   float a = q0perp - 2*q1perp + q2perp;\n   float b = q1perp - q0perp;\n   float c = q0perp - roperp;\n\n   float s0 = 0., s1 = 0.;\n   int num_s = 0;\n\n   if (a != 0.0) {\n      float discr = b*b - a*c;\n      if (discr > 0.0) {\n         float rcpna = -1 / a;\n         float d = (float) STBTT_sqrt(discr);\n         s0 = (b+d) * rcpna;\n         s1 = (b-d) * rcpna;\n         if (s0 >= 0.0 && s0 <= 1.0)\n            num_s = 1;\n         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {\n            if (num_s == 0) s0 = s1;\n            ++num_s;\n         }\n      }\n   } else {\n      // 2*b*s + c = 0\n      // s = -c / (2*b)\n      s0 = c / (-2 * b);\n      if (s0 >= 0.0 && s0 <= 1.0)\n         num_s = 1;\n   }\n\n   if (num_s == 0)\n      return 0;\n   else {\n      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);\n      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;\n\n      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;\n      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;\n      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;\n      float rod = orig[0]*rayn_x + orig[1]*rayn_y;\n\n      float q10d = q1d - q0d;\n      float q20d = q2d - q0d;\n      float q0rd = q0d - rod;\n\n      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;\n      hits[0][1] = a*s0+b;\n\n      if (num_s > 1) {\n         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;\n         hits[1][1] = a*s1+b;\n         return 2;\n      } else {\n         return 1;\n      }\n   }\n}\n\nstatic int equal(float *a, float *b)\n{\n   return (a[0] == b[0] && a[1] == b[1]);\n}\n\nstatic int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)\n{\n   int i;\n   float orig[2], ray[2] = { 1, 0 };\n   float y_frac;\n   int winding = 0;\n\n   // make sure y never passes through a vertex of the shape\n   y_frac = (float) STBTT_fmod(y, 1.0f);\n   if (y_frac < 0.01f)\n      y += 0.01f;\n   else if (y_frac > 0.99f)\n      y -= 0.01f;\n\n   orig[0] = x;\n   orig[1] = y;\n\n   // test a ray from (-infinity,y) to (x,y)\n   for (i=0; i < nverts; ++i) {\n      if (verts[i].type == STBTT_vline) {\n         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;\n         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;\n         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n            if (x_inter < x)\n               winding += (y0 < y1) ? 1 : -1;\n         }\n      }\n      if (verts[i].type == STBTT_vcurve) {\n         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;\n         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;\n         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;\n         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));\n         int by = STBTT_max(y0,STBTT_max(y1,y2));\n         if (y > ay && y < by && x > ax) {\n            float q0[2],q1[2],q2[2];\n            float hits[2][2];\n            q0[0] = (float)x0;\n            q0[1] = (float)y0;\n            q1[0] = (float)x1;\n            q1[1] = (float)y1;\n            q2[0] = (float)x2;\n            q2[1] = (float)y2;\n            if (equal(q0,q1) || equal(q1,q2)) {\n               x0 = (int)verts[i-1].x;\n               y0 = (int)verts[i-1].y;\n               x1 = (int)verts[i  ].x;\n               y1 = (int)verts[i  ].y;\n               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n                  if (x_inter < x)\n                     winding += (y0 < y1) ? 1 : -1;\n               }\n            } else {\n               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);\n               if (num_hits >= 1)\n                  if (hits[0][0] < 0)\n                     winding += (hits[0][1] < 0 ? -1 : 1);\n               if (num_hits >= 2)\n                  if (hits[1][0] < 0)\n                     winding += (hits[1][1] < 0 ? -1 : 1);\n            }\n         }\n      }\n   }\n   return winding;\n}\n\nstatic float stbtt__cuberoot( float x )\n{\n   if (x<0)\n      return -(float) STBTT_pow(-x,1.0f/3.0f);\n   else\n      return  (float) STBTT_pow( x,1.0f/3.0f);\n}\n\n// x^3 + a*x^2 + b*x + c = 0\nstatic int stbtt__solve_cubic(float a, float b, float c, float* r)\n{\n   float s = -a / 3;\n   float p = b - a*a / 3;\n   float q = a * (2*a*a - 9*b) / 27 + c;\n   float p3 = p*p*p;\n   float d = q*q + 4*p3 / 27;\n   if (d >= 0) {\n      float z = (float) STBTT_sqrt(d);\n      float u = (-q + z) / 2;\n      float v = (-q - z) / 2;\n      u = stbtt__cuberoot(u);\n      v = stbtt__cuberoot(v);\n      r[0] = s + u + v;\n      return 1;\n   } else {\n      float u = (float) STBTT_sqrt(-p/3);\n      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative\n      float m = (float) STBTT_cos(v);\n      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;\n      r[0] = s + u * 2 * m;\n      r[1] = s - u * (m + n);\n      r[2] = s - u * (m - n);\n\n      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?\n      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);\n      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);\n      return 3;\n   }\n}\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   float scale_x = scale, scale_y = scale;\n   int ix0,iy0,ix1,iy1;\n   int w,h;\n   unsigned char *data;\n\n   if (scale == 0) return NULL;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);\n\n   // if empty, return NULL\n   if (ix0 == ix1 || iy0 == iy1)\n      return NULL;\n\n   ix0 -= padding;\n   iy0 -= padding;\n   ix1 += padding;\n   iy1 += padding;\n\n   w = (ix1 - ix0);\n   h = (iy1 - iy0);\n\n   if (width ) *width  = w;\n   if (height) *height = h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   // invert for y-downwards bitmaps\n   scale_y = -scale_y;\n\n   {\n      int x,y,i,j;\n      float *precompute;\n      stbtt_vertex *verts;\n      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);\n      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);\n      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);\n\n      for (i=0,j=num_verts-1; i < num_verts; j=i++) {\n         if (verts[i].type == STBTT_vline) {\n            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;\n            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));\n            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;\n         } else if (verts[i].type == STBTT_vcurve) {\n            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;\n            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;\n            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;\n            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n            float len2 = bx*bx + by*by;\n            if (len2 != 0.0f)\n               precompute[i] = 1.0f / (bx*bx + by*by);\n            else\n               precompute[i] = 0.0f;\n         } else\n            precompute[i] = 0.0f;\n      }\n\n      for (y=iy0; y < iy1; ++y) {\n         for (x=ix0; x < ix1; ++x) {\n            float val;\n            float min_dist = 999999.0f;\n            float sx = (float) x + 0.5f;\n            float sy = (float) y + 0.5f;\n            float x_gspace = (sx / scale_x);\n            float y_gspace = (sy / scale_y);\n\n            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path\n\n            for (i=0; i < num_verts; ++i) {\n               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n\n               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {\n                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;\n\n                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                  if (dist2 < min_dist*min_dist)\n                     min_dist = (float) STBTT_sqrt(dist2);\n\n                  // coarse culling against bbox\n                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&\n                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)\n                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];\n                  STBTT_assert(i != 0);\n                  if (dist < min_dist) {\n                     // check position along line\n                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)\n                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)\n                     float dx = x1-x0, dy = y1-y0;\n                     float px = x0-sx, py = y0-sy;\n                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy\n                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve\n                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);\n                     if (t >= 0.0f && t <= 1.0f)\n                        min_dist = dist;\n                  }\n               } else if (verts[i].type == STBTT_vcurve) {\n                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;\n                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;\n                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);\n                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);\n                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);\n                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);\n                  // coarse culling against bbox to avoid computing cubic unnecessarily\n                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {\n                     int num=0;\n                     float ax = x1-x0, ay = y1-y0;\n                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n                     float mx = x0 - sx, my = y0 - sy;\n                     float res[3] = {0.f,0.f,0.f};\n                     float px,py,t,it,dist2;\n                     float a_inv = precompute[i];\n                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula\n                        float a = 3*(ax*bx + ay*by);\n                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);\n                        float c = mx*ax+my*ay;\n                        if (a == 0.0) { // if a is 0, it's linear\n                           if (b != 0.0) {\n                              res[num++] = -c/b;\n                           }\n                        } else {\n                           float discriminant = b*b - 4*a*c;\n                           if (discriminant < 0)\n                              num = 0;\n                           else {\n                              float root = (float) STBTT_sqrt(discriminant);\n                              res[0] = (-b - root)/(2*a);\n                              res[1] = (-b + root)/(2*a);\n                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work\n                           }\n                        }\n                     } else {\n                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point\n                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;\n                        float d = (mx*ax+my*ay) * a_inv;\n                        num = stbtt__solve_cubic(b, c, d, res);\n                     }\n                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                     if (dist2 < min_dist*min_dist)\n                        min_dist = (float) STBTT_sqrt(dist2);\n\n                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {\n                        t = res[0], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {\n                        t = res[1], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {\n                        t = res[2], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                  }\n               }\n            }\n            if (winding == 0)\n               min_dist = -min_dist;  // if outside the shape, value is negative\n            val = onedge_value + pixel_dist_scale * min_dist;\n            if (val < 0)\n               val = 0;\n            else if (val > 255)\n               val = 255;\n            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;\n         }\n      }\n      STBTT_free(precompute, info->userdata);\n      STBTT_free(verts, info->userdata);\n   }\n   return data;\n}\n\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// font name matching -- recommended not to use this\n//\n\n// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string\nstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)\n{\n   stbtt_int32 i=0;\n\n   // convert utf16 to utf8 and compare the results while converting\n   while (len2) {\n      stbtt_uint16 ch = s2[0]*256 + s2[1];\n      if (ch < 0x80) {\n         if (i >= len1) return -1;\n         if (s1[i++] != ch) return -1;\n      } else if (ch < 0x800) {\n         if (i+1 >= len1) return -1;\n         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;\n         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;\n      } else if (ch >= 0xd800 && ch < 0xdc00) {\n         stbtt_uint32 c;\n         stbtt_uint16 ch2 = s2[2]*256 + s2[3];\n         if (i+3 >= len1) return -1;\n         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;\n         if (s1[i++] != 0xf0 + (c >> 18)) return -1;\n         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;\n         s2 += 2; // plus another 2 below\n         len2 -= 2;\n      } else if (ch >= 0xdc00 && ch < 0xe000) {\n         return -1;\n      } else {\n         if (i+2 >= len1) return -1;\n         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;\n         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;\n      }\n      s2 += 2;\n      len2 -= 2;\n   }\n   return i;\n}\n\nstatic int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)\n{\n   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);\n}\n\n// returns results in whatever encoding you request... but note that 2-byte encodings\n// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)\n{\n   stbtt_int32 i,count,stringOffset;\n   stbtt_uint8 *fc = font->data;\n   stbtt_uint32 offset = font->fontstart;\n   stbtt_uint32 nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return NULL;\n\n   count = ttUSHORT(fc+nm+2);\n   stringOffset = nm + ttUSHORT(fc+nm+4);\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)\n          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {\n         *length = ttUSHORT(fc+loc+8);\n         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));\n      }\n   }\n   return NULL;\n}\n\nstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)\n{\n   stbtt_int32 i;\n   stbtt_int32 count = ttUSHORT(fc+nm+2);\n   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);\n\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      stbtt_int32 id = ttUSHORT(fc+loc+6);\n      if (id == target_id) {\n         // find the encoding\n         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);\n\n         // is this a Unicode encoding?\n         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {\n            stbtt_int32 slen = ttUSHORT(fc+loc+8);\n            stbtt_int32 off = ttUSHORT(fc+loc+10);\n\n            // check if there's a prefix match\n            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);\n            if (matchlen >= 0) {\n               // check for target_id+1 immediately following, with same encoding & language\n               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {\n                  slen = ttUSHORT(fc+loc+12+8);\n                  off = ttUSHORT(fc+loc+12+10);\n                  if (slen == 0) {\n                     if (matchlen == nlen)\n                        return 1;\n                  } else if (matchlen < nlen && name[matchlen] == ' ') {\n                     ++matchlen;\n                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))\n                        return 1;\n                  }\n               } else {\n                  // if nothing immediately following\n                  if (matchlen == nlen)\n                     return 1;\n               }\n            }\n         }\n\n         // @TODO handle other encodings\n      }\n   }\n   return 0;\n}\n\nstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)\n{\n   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);\n   stbtt_uint32 nm,hd;\n   if (!stbtt__isfont(fc+offset)) return 0;\n\n   // check italics/bold/underline flags in macStyle...\n   if (flags) {\n      hd = stbtt__find_table(fc, offset, \"head\");\n      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;\n   }\n\n   nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return 0;\n\n   if (flags) {\n      // if we checked the macStyle flags, then just check the family and ignore the subfamily\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   } else {\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   }\n\n   return 0;\n}\n\nstatic int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)\n{\n   stbtt_int32 i;\n   for (i=0;;++i) {\n      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);\n      if (off < 0) return off;\n      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))\n         return off;\n   }\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,\n                                float pixel_height, unsigned char *pixels, int pw, int ph,\n                                int first_char, int num_chars, stbtt_bakedchar *chardata)\n{\n   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);\n}\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\n{\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);\n}\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)\n{\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\n}\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\n{\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\n}\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)\n{\n   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);\n}\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)\n{\n   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif // STB_TRUETYPE_IMPLEMENTATION\n\n\n// FULL VERSION HISTORY\n//\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) allow user-defined fabs() replacement\n//                     fix memory leak if fontsize=0.0\n//                     fix warning from duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     allow PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)\n//                     also more precise AA rasterizer, except if shapes overlap\n//                     remove need for STBTT_sort\n//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC\n//   1.04 (2015-04-15) typo in example\n//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes\n//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++\n//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match\n//                        non-oversampled; STBTT_POINT_SIZE for packed case only\n//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling\n//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)\n//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID\n//   0.8b (2014-07-07) fix a warning\n//   0.8  (2014-05-25) fix a few more warnings\n//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back\n//   0.6c (2012-07-24) improve documentation\n//   0.6b (2012-07-20) fix a few more warnings\n//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,\n//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty\n//   0.5  (2011-12-09) bugfixes:\n//                        subpixel glyph renderer computed wrong bounding box\n//                        first vertex of shape can be off-curve (FreeSans)\n//   0.4b (2011-12-03) fixed an error in the font baking example\n//   0.4  (2011-12-01) kerning, subpixel rendering (tor)\n//                    bugfixes for:\n//                        codepoint-to-glyph conversion using table fmt=12\n//                        codepoint-to-glyph conversion using table fmt=4\n//                        stbtt_GetBakedQuad with non-square texture (Zer)\n//                    updated Hello World! sample to use kerning and subpixel\n//                    fixed some warnings\n//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)\n//                    userdata, malloc-from-userdata, non-zero fill (stb)\n//   0.2  (2009-03-11) Fix unsigned/signed char warnings\n//   0.1  (2009-03-09) First public release\n//\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}