{
  "metadata": {
    "timestamp": 1736557702486,
    "page": 821,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "spf13/viper",
      "stars": 27599,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.23,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_size = 4\nindent_style = space\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.go]\nindent_style = tab\n\n[{Makefile,*.mk}]\nindent_style = tab\n\n[*.nix]\nindent_size = 2\n"
        },
        {
          "name": ".envrc",
          "type": "blob",
          "size": 0.23,
          "content": "if ! has nix_direnv_version || ! nix_direnv_version 3.0.4; then\n  source_url \"https://raw.githubusercontent.com/nix-community/nix-direnv/3.0.4/direnvrc\" \"sha256-DzlYZ33mWF/Gs8DDeyjr8mnVmQGx7ASYqA5WlxwvBG4=\"\nfi\nuse flake . --impure\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.08,
          "content": "/.devenv/\n/.direnv/\n/.idea/\n/.pre-commit-config.yaml\n/bin/\n/build/\n/var/\n/vendor/\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 2.16,
          "content": "run:\n    timeout: 5m\n\nlinters-settings:\n    gci:\n        sections:\n            - standard\n            - default\n            - prefix(github.com/spf13/viper)\n    gocritic:\n        # Enable multiple checks by tags. See \"Tags\" section in https://github.com/go-critic/go-critic#usage.\n        enabled-tags:\n            - diagnostic\n            - experimental\n            - opinionated\n            - style\n        disabled-checks:\n            - importShadow\n            - unnamedResult\n    golint:\n        min-confidence: 0\n    goimports:\n        local-prefixes: github.com/spf13/viper\n\nlinters:\n    disable-all: true\n    enable:\n        - bodyclose\n        - dogsled\n        - dupl\n        - durationcheck\n        - exhaustive\n        - exportloopref\n        - gci\n        - gocritic\n        - godot\n        - gofmt\n        - gofumpt\n        - goimports\n        - gomoddirectives\n        - goprintffuncname\n        - govet\n        - importas\n        - ineffassign\n        - makezero\n        - misspell\n        - nakedret\n        - nilerr\n        - noctx\n        - nolintlint\n        - prealloc\n        - predeclared\n        - revive\n        - rowserrcheck\n        - sqlclosecheck\n        - staticcheck\n        - stylecheck\n        - tparallel\n        - typecheck\n        - unconvert\n        - unparam\n        - unused\n        - wastedassign\n        - whitespace\n\n        # fixme\n        # - cyclop\n        # - errcheck\n        # - errorlint\n        # - exhaustivestruct\n        # - forbidigo\n        # - forcetypeassert\n        # - gochecknoglobals\n        # - gochecknoinits\n        # - gocognit\n        # - goconst\n        # - gocyclo\n        # - gosec\n        # - gosimple\n        # - ifshort\n        # - lll\n        # - nlreturn\n        # - paralleltest\n        # - scopelint\n        # - thelper\n        # - wrapcheck\n\n        # unused\n        # - depguard\n        # - goheader\n        # - gomodguard\n\n        # deprecated\n        # - deadcode\n        # - structcheck\n        # - varcheck\n\n        # don't enable:\n        # - asciicheck\n        # - funlen\n        # - godox\n        # - goerr113\n        # - gomnd\n        # - interfacer\n        # - maligned\n        # - nestif\n        # - testpackage\n        # - wsl\n"
        },
        {
          "name": ".yamlignore",
          "type": "blob",
          "size": 0.02,
          "content": "# TODO: FIXME\n/.github/\n"
        },
        {
          "name": ".yamllint.yaml",
          "type": "blob",
          "size": 0.09,
          "content": "ignore-from-file: [.gitignore, .yamlignore]\n\nextends: default\n\nrules:\n  line-length: disable\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Steve Francia\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.37,
          "content": "# A Self-Documenting Makefile: http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html\n\nOS = $(shell uname | tr A-Z a-z)\nexport PATH := $(abspath bin/):${PATH}\n\n# Build variables\nBUILD_DIR ?= build\nexport CGO_ENABLED ?= 0\nexport GOOS = $(shell go env GOOS)\nifeq (${VERBOSE}, 1)\nifeq ($(filter -v,${GOARGS}),)\n\tGOARGS += -v\nendif\nTEST_FORMAT = short-verbose\nendif\n\n# Dependency versions\nGOTESTSUM_VERSION = 1.9.0\nGOLANGCI_VERSION = 1.53.3\n\n# Add the ability to override some variables\n# Use with care\n-include override.mk\n\n.PHONY: clear\nclear: ## Clear the working area and the project\n\trm -rf bin/\n\n.PHONY: check\ncheck: test lint ## Run tests and linters\n\n\nTEST_PKGS ?= ./...\n.PHONY: test\ntest: TEST_FORMAT ?= short\ntest: SHELL = /bin/bash\ntest: export CGO_ENABLED=1\ntest: bin/gotestsum ## Run tests\n\t@mkdir -p ${BUILD_DIR}\n\tbin/gotestsum --no-summary=skipped --junitfile ${BUILD_DIR}/coverage.xml --format ${TEST_FORMAT} -- -race -coverprofile=${BUILD_DIR}/coverage.txt -covermode=atomic $(filter-out -v,${GOARGS}) $(if ${TEST_PKGS},${TEST_PKGS},./...)\n\n.PHONY: lint\nlint: lint-go lint-yaml\nlint: ## Run linters\n\n.PHONY: lint-go\nlint-go:\n\tgolangci-lint run $(if ${CI},--out-format github-actions,)\n\n.PHONY: lint-yaml\nlint-yaml:\n\tyamllint $(if ${CI},-f github,) --no-warnings .\n\n.PHONY: fmt\nfmt: ## Format code\n\tgolangci-lint run --fix\n\ndeps: bin/golangci-lint bin/gotestsum yamllint\ndeps: ## Install dependencies\n\nbin/gotestsum:\n\t@mkdir -p bin\n\tcurl -L https://github.com/gotestyourself/gotestsum/releases/download/v${GOTESTSUM_VERSION}/gotestsum_${GOTESTSUM_VERSION}_${OS}_amd64.tar.gz | tar -zOxf - gotestsum > ./bin/gotestsum && chmod +x ./bin/gotestsum\n\nbin/golangci-lint:\n\t@mkdir -p bin\n\tcurl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | bash -s -- v${GOLANGCI_VERSION}\n\n.PHONY: yamllint\nyamllint:\n\tpip3 install --user yamllint\n\n# Add custom targets here\n-include custom.mk\n\n.PHONY: list\nlist: ## List all make targets\n\t@${MAKE} -pRrn : -f $(MAKEFILE_LIST) 2>/dev/null | awk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ \"^[#.]\") {print $$1}}' | egrep -v -e '^[^[:alnum:]]' -e '^$@$$' | sort\n\n.PHONY: help\n.DEFAULT_GOAL := help\nhelp:\n\t@grep -h -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n\n# Variable outputting/exporting rules\nvar-%: ; @echo $($*)\nvarexport-%: ; @echo $*=$($*)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 28.88,
          "content": "> ## Viper v2 feedback\n> Viper is heading towards v2 and we would love to hear what _**you**_ would like to see in it. Share your thoughts here: https://forms.gle/R6faU74qPRPAzchZ9\n>\n> **Thank you!**\n\n![Viper](.github/logo.png?raw=true)\n\n[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge-flat.svg)](https://github.com/avelino/awesome-go#configuration)\n[![run on repl.it](https://repl.it/badge/github/sagikazarmark/Viper-example)](https://repl.it/@sagikazarmark/Viper-example#main.go)\n\n[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/spf13/viper/ci.yaml?branch=master&style=flat-square)](https://github.com/spf13/viper/actions?query=workflow%3ACI)\n[![Join the chat at https://gitter.im/spf13/viper](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/spf13/viper?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Go Report Card](https://goreportcard.com/badge/github.com/spf13/viper?style=flat-square)](https://goreportcard.com/report/github.com/spf13/viper)\n![Go Version](https://img.shields.io/badge/go%20version-%3E=1.21-61CFDD.svg?style=flat-square)\n[![PkgGoDev](https://pkg.go.dev/badge/mod/github.com/spf13/viper)](https://pkg.go.dev/mod/github.com/spf13/viper)\n\n**Go configuration with fangs!**\n\nMany Go projects are built using Viper including:\n\n* [Hugo](http://gohugo.io)\n* [EMC RexRay](http://rexray.readthedocs.org/en/stable/)\n* [Imgur’s Incus](https://github.com/Imgur/incus)\n* [Nanobox](https://github.com/nanobox-io/nanobox)/[Nanopack](https://github.com/nanopack)\n* [Docker Notary](https://github.com/docker/Notary)\n* [BloomApi](https://www.bloomapi.com/)\n* [doctl](https://github.com/digitalocean/doctl)\n* [Clairctl](https://github.com/jgsqware/clairctl)\n* [Mercure](https://mercure.rocks)\n* [Meshery](https://github.com/meshery/meshery)\n* [Bearer](https://github.com/bearer/bearer)\n* [Coder](https://github.com/coder/coder)\n* [Vitess](https://vitess.io/)\n\n\n## Install\n\n```shell\ngo get github.com/spf13/viper\n```\n\n**Note:** Viper uses [Go Modules](https://go.dev/wiki/Modules) to manage dependencies.\n\n\n## What is Viper?\n\nViper is a complete configuration solution for Go applications including [12-Factor apps](https://12factor.net/#the_twelve_factors).\nIt is designed to work within an application, and can handle all types of configuration needs\nand formats. It supports:\n\n* setting defaults\n* reading from JSON, TOML, YAML, HCL, envfile and Java properties config files\n* live watching and re-reading of config files (optional)\n* reading from environment variables\n* reading from remote config systems (etcd or Consul), and watching changes\n* reading from command line flags\n* reading from buffer\n* setting explicit values\n\nViper can be thought of as a registry for all of your applications configuration needs.\n\n\n## Why Viper?\n\nWhen building a modern application, you don’t want to worry about\nconfiguration file formats; you want to focus on building awesome software.\nViper is here to help with that.\n\nViper does the following for you:\n\n1. Find, load, and unmarshal a configuration file in JSON, TOML, YAML, HCL, INI, envfile or Java properties formats.\n2. Provide a mechanism to set default values for your different configuration options.\n3. Provide a mechanism to set override values for options specified through command line flags.\n4. Provide an alias system to easily rename parameters without breaking existing code.\n5. Make it easy to tell the difference between when a user has provided a command line or config file which is the same as the default.\n\nViper uses the following precedence order. Each item takes precedence over the item below it:\n\n * explicit call to `Set`\n * flag\n * env\n * config\n * key/value store\n * default\n\n**Important:** Viper configuration keys are case insensitive.\nThere are ongoing discussions about making that optional.\n\n\n## Putting Values into Viper\n\n### Establishing Defaults\n\nA good configuration system will support default values. A default value is not\nrequired for a key, but it’s useful in the event that a key hasn't been set via\nconfig file, environment variable, remote configuration or flag.\n\nExamples:\n\n```go\nviper.SetDefault(\"ContentDir\", \"content\")\nviper.SetDefault(\"LayoutDir\", \"layouts\")\nviper.SetDefault(\"Taxonomies\", map[string]string{\"tag\": \"tags\", \"category\": \"categories\"})\n```\n\n### Reading Config Files\n\nViper requires minimal configuration so it knows where to look for config files.\nViper supports JSON, TOML, YAML, HCL, INI, envfile and Java Properties files. Viper can search multiple paths, but\ncurrently a single Viper instance only supports a single configuration file.\nViper does not default to any configuration search paths leaving defaults decision\nto an application.\n\nHere is an example of how to use Viper to search for and read a configuration file.\nNone of the specific paths are required, but at least one path should be provided\nwhere a configuration file is expected.\n\n```go\nviper.SetConfigName(\"config\") // name of config file (without extension)\nviper.SetConfigType(\"yaml\") // REQUIRED if the config file does not have the extension in the name\nviper.AddConfigPath(\"/etc/appname/\")   // path to look for the config file in\nviper.AddConfigPath(\"$HOME/.appname\")  // call multiple times to add many search paths\nviper.AddConfigPath(\".\")               // optionally look for config in the working directory\nerr := viper.ReadInConfig() // Find and read the config file\nif err != nil { // Handle errors reading the config file\n\tpanic(fmt.Errorf(\"fatal error config file: %w\", err))\n}\n```\n\nYou can handle the specific case where no config file is found like this:\n\n```go\nif err := viper.ReadInConfig(); err != nil {\n\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n\t\t// Config file not found; ignore error if desired\n\t} else {\n\t\t// Config file was found but another error was produced\n\t}\n}\n\n// Config file found and successfully parsed\n```\n\n*NOTE [since 1.6]:* You can also have a file without an extension and specify the format programmatically. For those configuration files that lie in the home of the user without any extension like `.bashrc`\n\n### Writing Config Files\n\nReading from config files is useful, but at times you want to store all modifications made at run time.\nFor that, a bunch of commands are available, each with its own purpose:\n\n* WriteConfig - writes the current viper configuration to the predefined path, if exists. Errors if no predefined path. Will overwrite the current config file, if it exists.\n* SafeWriteConfig - writes the current viper configuration to the predefined path. Errors if no predefined path. Will not overwrite the current config file, if it exists.\n* WriteConfigAs - writes the current viper configuration to the given filepath. Will overwrite the given file, if it exists.\n* SafeWriteConfigAs - writes the current viper configuration to the given filepath. Will not overwrite the given file, if it exists.\n\nAs a rule of the thumb, everything marked with safe won't overwrite any file, but just create if not existent, whilst the default behavior is to create or truncate.\n\nA small examples section:\n\n```go\nviper.WriteConfig() // writes current config to predefined path set by 'viper.AddConfigPath()' and 'viper.SetConfigName'\nviper.SafeWriteConfig()\nviper.WriteConfigAs(\"/path/to/my/.config\")\nviper.SafeWriteConfigAs(\"/path/to/my/.config\") // will error since it has already been written\nviper.SafeWriteConfigAs(\"/path/to/my/.other_config\")\n```\n\n### Watching and re-reading config files\n\nViper supports the ability to have your application live read a config file while running.\n\nGone are the days of needing to restart a server to have a config take effect,\nviper powered applications can read an update to a config file while running and\nnot miss a beat.\n\nSimply tell the viper instance to watchConfig.\nOptionally you can provide a function for Viper to run each time a change occurs.\n\n**Make sure you add all of the configPaths prior to calling `WatchConfig()`**\n\n```go\nviper.OnConfigChange(func(e fsnotify.Event) {\n\tfmt.Println(\"Config file changed:\", e.Name)\n})\nviper.WatchConfig()\n```\n\n### Reading Config from io.Reader\n\nViper predefines many configuration sources such as files, environment\nvariables, flags, and remote K/V store, but you are not bound to them. You can\nalso implement your own required configuration source and feed it to viper.\n\n```go\nviper.SetConfigType(\"yaml\") // or viper.SetConfigType(\"YAML\")\n\n// any approach to require this configuration into your program.\nvar yamlExample = []byte(`\nHacker: true\nname: steve\nhobbies:\n- skateboarding\n- snowboarding\n- go\nclothing:\n  jacket: leather\n  trousers: denim\nage: 35\neyes : brown\nbeard: true\n`)\n\nviper.ReadConfig(bytes.NewBuffer(yamlExample))\n\nviper.Get(\"name\") // this would be \"steve\"\n```\n\n### Setting Overrides\n\nThese could be from a command line flag, or from your own application logic.\n\n```go\nviper.Set(\"Verbose\", true)\nviper.Set(\"LogFile\", LogFile)\nviper.Set(\"host.port\", 5899)   // set subset\n```\n\n### Registering and Using Aliases\n\nAliases permit a single value to be referenced by multiple keys\n\n```go\nviper.RegisterAlias(\"loud\", \"Verbose\")\n\nviper.Set(\"verbose\", true) // same result as next line\nviper.Set(\"loud\", true)   // same result as prior line\n\nviper.GetBool(\"loud\") // true\nviper.GetBool(\"verbose\") // true\n```\n\n### Working with Environment Variables\n\nViper has full support for environment variables. This enables 12 factor\napplications out of the box. There are five methods that exist to aid working\nwith ENV:\n\n * `AutomaticEnv()`\n * `BindEnv(string...) : error`\n * `SetEnvPrefix(string)`\n * `SetEnvKeyReplacer(string...) *strings.Replacer`\n * `AllowEmptyEnv(bool)`\n\n_When working with ENV variables, it’s important to recognize that Viper\ntreats ENV variables as case sensitive._\n\nViper provides a mechanism to try to ensure that ENV variables are unique. By\nusing `SetEnvPrefix`, you can tell Viper to use a prefix while reading from\nthe environment variables. Both `BindEnv` and `AutomaticEnv` will use this\nprefix.\n\n`BindEnv` takes one or more parameters. The first parameter is the key name, the\nrest are the name of the environment variables to bind to this key. If more than\none are provided, they will take precedence in the specified order. The name of\nthe environment variable is case sensitive. If the ENV variable name is not provided, then\nViper will automatically assume that the ENV variable matches the following format: prefix + \"_\" + the key name in ALL CAPS. When you explicitly provide the ENV variable name (the second parameter),\nit **does not** automatically add the prefix. For example if the second parameter is \"id\",\nViper will look for the ENV variable \"ID\".\n\nOne important thing to recognize when working with ENV variables is that the\nvalue will be read each time it is accessed. Viper does not fix the value when\nthe `BindEnv` is called.\n\n`AutomaticEnv` is a powerful helper especially when combined with\n`SetEnvPrefix`. When called, Viper will check for an environment variable any\ntime a `viper.Get` request is made. It will apply the following rules. It will\ncheck for an environment variable with a name matching the key uppercased and\nprefixed with the `EnvPrefix` if set.\n\n`SetEnvKeyReplacer` allows you to use a `strings.Replacer` object to rewrite Env\nkeys to an extent. This is useful if you want to use `-` or something in your\n`Get()` calls, but want your environmental variables to use `_` delimiters. An\nexample of using it can be found in `viper_test.go`.\n\nAlternatively, you can use `EnvKeyReplacer` with `NewWithOptions` factory function.\nUnlike `SetEnvKeyReplacer`, it accepts a `StringReplacer` interface allowing you to write custom string replacing logic.\n\nBy default empty environment variables are considered unset and will fall back to\nthe next configuration source. To treat empty environment variables as set, use\nthe `AllowEmptyEnv` method.\n\n#### Env example\n\n```go\nSetEnvPrefix(\"spf\") // will be uppercased automatically\nBindEnv(\"id\")\n\nos.Setenv(\"SPF_ID\", \"13\") // typically done outside of the app\n\nid := Get(\"id\") // 13\n```\n\n### Working with Flags\n\nViper has the ability to bind to flags. Specifically, Viper supports `Pflags`\nas used in the [Cobra](https://github.com/spf13/cobra) library.\n\nLike `BindEnv`, the value is not set when the binding method is called, but when\nit is accessed. This means you can bind as early as you want, even in an\n`init()` function.\n\nFor individual flags, the `BindPFlag()` method provides this functionality.\n\nExample:\n\n```go\nserverCmd.Flags().Int(\"port\", 1138, \"Port to run Application server on\")\nviper.BindPFlag(\"port\", serverCmd.Flags().Lookup(\"port\"))\n```\n\nYou can also bind an existing set of pflags (pflag.FlagSet):\n\nExample:\n\n```go\npflag.Int(\"flagname\", 1234, \"help message for flagname\")\n\npflag.Parse()\nviper.BindPFlags(pflag.CommandLine)\n\ni := viper.GetInt(\"flagname\") // retrieve values from viper instead of pflag\n```\n\nThe use of [pflag](https://github.com/spf13/pflag/) in Viper does not preclude\nthe use of other packages that use the [flag](https://golang.org/pkg/flag/)\npackage from the standard library. The pflag package can handle the flags\ndefined for the flag package by importing these flags. This is accomplished\nby a calling a convenience function provided by the pflag package called\nAddGoFlagSet().\n\nExample:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"github.com/spf13/pflag\"\n)\n\nfunc main() {\n\n\t// using standard library \"flag\" package\n\tflag.Int(\"flagname\", 1234, \"help message for flagname\")\n\n\tpflag.CommandLine.AddGoFlagSet(flag.CommandLine)\n\tpflag.Parse()\n\tviper.BindPFlags(pflag.CommandLine)\n\n\ti := viper.GetInt(\"flagname\") // retrieve value from viper\n\n\t// ...\n}\n```\n\n#### Flag interfaces\n\nViper provides two Go interfaces to bind other flag systems if you don’t use `Pflags`.\n\n`FlagValue` represents a single flag. This is a very simple example on how to implement this interface:\n\n```go\ntype myFlag struct {}\nfunc (f myFlag) HasChanged() bool { return false }\nfunc (f myFlag) Name() string { return \"my-flag-name\" }\nfunc (f myFlag) ValueString() string { return \"my-flag-value\" }\nfunc (f myFlag) ValueType() string { return \"string\" }\n```\n\nOnce your flag implements this interface, you can simply tell Viper to bind it:\n\n```go\nviper.BindFlagValue(\"my-flag-name\", myFlag{})\n```\n\n`FlagValueSet` represents a group of flags. This is a very simple example on how to implement this interface:\n\n```go\ntype myFlagSet struct {\n\tflags []myFlag\n}\n\nfunc (f myFlagSet) VisitAll(fn func(FlagValue)) {\n\tfor _, flag := range flags {\n\t\tfn(flag)\n\t}\n}\n```\n\nOnce your flag set implements this interface, you can simply tell Viper to bind it:\n\n```go\nfSet := myFlagSet{\n\tflags: []myFlag{myFlag{}, myFlag{}},\n}\nviper.BindFlagValues(\"my-flags\", fSet)\n```\n\n### Remote Key/Value Store Support\n\nTo enable remote support in Viper, do a blank import of the `viper/remote`\npackage:\n\n`import _ \"github.com/spf13/viper/remote\"`\n\nViper will read a config string (as JSON, TOML, YAML, HCL or envfile) retrieved from a path\nin a Key/Value store such as etcd or Consul.  These values take precedence over\ndefault values, but are overridden by configuration values retrieved from disk,\nflags, or environment variables.\n\nViper supports multiple hosts. To use, pass a list of endpoints separated by `;`. For example `http://127.0.0.1:4001;http://127.0.0.1:4002`.\n\nViper uses [crypt](https://github.com/sagikazarmark/crypt) to retrieve\nconfiguration from the K/V store, which means that you can store your\nconfiguration values encrypted and have them automatically decrypted if you have\nthe correct gpg keyring.  Encryption is optional.\n\nYou can use remote configuration in conjunction with local configuration, or\nindependently of it.\n\n`crypt` has a command-line helper that you can use to put configurations in your\nK/V store. `crypt` defaults to etcd on http://127.0.0.1:4001.\n\n```bash\n$ go get github.com/sagikazarmark/crypt/bin/crypt\n$ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json\n```\n\nConfirm that your value was set:\n\n```bash\n$ crypt get -plaintext /config/hugo.json\n```\n\nSee the `crypt` documentation for examples of how to set encrypted values, or\nhow to use Consul.\n\n### Remote Key/Value Store Example - Unencrypted\n\n#### etcd\n```go\nviper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\",\"/config/hugo.json\")\nviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\nerr := viper.ReadRemoteConfig()\n```\n\n#### etcd3\n```go\nviper.AddRemoteProvider(\"etcd3\", \"http://127.0.0.1:4001\",\"/config/hugo.json\")\nviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\nerr := viper.ReadRemoteConfig()\n```\n\n#### Consul\nYou need to set a key to Consul key/value storage with JSON value containing your desired config.\nFor example, create a Consul key/value store key `MY_CONSUL_KEY` with value:\n\n```json\n{\n    \"port\": 8080,\n    \"hostname\": \"myhostname.com\"\n}\n```\n\n```go\nviper.AddRemoteProvider(\"consul\", \"localhost:8500\", \"MY_CONSUL_KEY\")\nviper.SetConfigType(\"json\") // Need to explicitly set this to json\nerr := viper.ReadRemoteConfig()\n\nfmt.Println(viper.Get(\"port\")) // 8080\nfmt.Println(viper.Get(\"hostname\")) // myhostname.com\n```\n\n#### Firestore\n\n```go\nviper.AddRemoteProvider(\"firestore\", \"google-cloud-project-id\", \"collection/document\")\nviper.SetConfigType(\"json\") // Config's format: \"json\", \"toml\", \"yaml\", \"yml\"\nerr := viper.ReadRemoteConfig()\n```\n\nOf course, you're allowed to use `SecureRemoteProvider` also\n\n\n#### NATS\n\n```go\nviper.AddRemoteProvider(\"nats\", \"nats://127.0.0.1:4222\", \"myapp.config\")\nviper.SetConfigType(\"json\")\nerr := viper.ReadRemoteConfig()\n```\n\n### Remote Key/Value Store Example - Encrypted\n\n```go\nviper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\")\nviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes,  supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\nerr := viper.ReadRemoteConfig()\n```\n\n### Watching Changes in etcd - Unencrypted\n\n```go\n// alternatively, you can create a new viper instance.\nvar runtime_viper = viper.New()\n\nruntime_viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\", \"/config/hugo.yml\")\nruntime_viper.SetConfigType(\"yaml\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\n\n// read from remote config the first time.\nerr := runtime_viper.ReadRemoteConfig()\n\n// unmarshal config\nruntime_viper.Unmarshal(&runtime_conf)\n\n// open a goroutine to watch remote changes forever\ngo func(){\n\tfor {\n\t\ttime.Sleep(time.Second * 5) // delay after each request\n\n\t\t// currently, only tested with etcd support\n\t\terr := runtime_viper.WatchRemoteConfig()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to read remote config: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// unmarshal new config into our runtime config struct. you can also use channel\n\t\t// to implement a signal to notify the system of the changes\n\t\truntime_viper.Unmarshal(&runtime_conf)\n\t}\n}()\n```\n\n## Getting Values From Viper\n\nIn Viper, there are a few ways to get a value depending on the value’s type.\nThe following functions and methods exist:\n\n * `Get(key string) : any`\n * `GetBool(key string) : bool`\n * `GetFloat64(key string) : float64`\n * `GetInt(key string) : int`\n * `GetIntSlice(key string) : []int`\n * `GetString(key string) : string`\n * `GetStringMap(key string) : map[string]any`\n * `GetStringMapString(key string) : map[string]string`\n * `GetStringSlice(key string) : []string`\n * `GetTime(key string) : time.Time`\n * `GetDuration(key string) : time.Duration`\n * `IsSet(key string) : bool`\n * `AllSettings() : map[string]any`\n\nOne important thing to recognize is that each Get function will return a zero\nvalue if it’s not found. To check if a given key exists, the `IsSet()` method\nhas been provided.\n\nThe zero value will also be returned if the value is set, but fails to parse\nas the requested type.\n\nExample:\n```go\nviper.GetString(\"logfile\") // case-insensitive Setting & Getting\nif viper.GetBool(\"verbose\") {\n\tfmt.Println(\"verbose enabled\")\n}\n```\n### Accessing nested keys\n\nThe accessor methods also accept formatted paths to deeply nested keys. For\nexample, if the following JSON file is loaded:\n\n```json\n{\n    \"host\": {\n        \"address\": \"localhost\",\n        \"port\": 5799\n    },\n    \"datastore\": {\n        \"metric\": {\n            \"host\": \"127.0.0.1\",\n            \"port\": 3099\n        },\n        \"warehouse\": {\n            \"host\": \"198.0.0.1\",\n            \"port\": 2112\n        }\n    }\n}\n\n```\n\nViper can access a nested field by passing a `.` delimited path of keys:\n\n```go\nGetString(\"datastore.metric.host\") // (returns \"127.0.0.1\")\n```\n\nThis obeys the precedence rules established above; the search for the path\nwill cascade through the remaining configuration registries until found.\n\nFor example, given this configuration file, both `datastore.metric.host` and\n`datastore.metric.port` are already defined (and may be overridden). If in addition\n`datastore.metric.protocol` was defined in the defaults, Viper would also find it.\n\nHowever, if `datastore.metric` was overridden (by a flag, an environment variable,\nthe `Set()` method, …) with an immediate value, then all sub-keys of\n`datastore.metric` become undefined, they are “shadowed” by the higher-priority\nconfiguration level.\n\nViper can access array indices by using numbers in the path. For example:\n\n```jsonc\n{\n    \"host\": {\n        \"address\": \"localhost\",\n        \"ports\": [\n            5799,\n            6029\n        ]\n    },\n    \"datastore\": {\n        \"metric\": {\n            \"host\": \"127.0.0.1\",\n            \"port\": 3099\n        },\n        \"warehouse\": {\n            \"host\": \"198.0.0.1\",\n            \"port\": 2112\n        }\n    }\n}\n\nGetInt(\"host.ports.1\") // returns 6029\n\n```\n\nLastly, if there exists a key that matches the delimited key path, its value\nwill be returned instead. E.g.\n\n```jsonc\n{\n    \"datastore.metric.host\": \"0.0.0.0\",\n    \"host\": {\n        \"address\": \"localhost\",\n        \"port\": 5799\n    },\n    \"datastore\": {\n        \"metric\": {\n            \"host\": \"127.0.0.1\",\n            \"port\": 3099\n        },\n        \"warehouse\": {\n            \"host\": \"198.0.0.1\",\n            \"port\": 2112\n        }\n    }\n}\n\nGetString(\"datastore.metric.host\") // returns \"0.0.0.0\"\n```\n\n### Extracting a sub-tree\n\nWhen developing reusable modules, it's often useful to extract a subset of the configuration\nand pass it to a module. This way the module can be instantiated more than once, with different configurations.\n\nFor example, an application might use multiple different cache stores for different purposes:\n\n```yaml\ncache:\n  cache1:\n    max-items: 100\n    item-size: 64\n  cache2:\n    max-items: 200\n    item-size: 80\n```\n\nWe could pass the cache name to a module (eg. `NewCache(\"cache1\")`),\nbut it would require weird concatenation for accessing config keys and would be less separated from the global config.\n\nSo instead of doing that let's pass a Viper instance to the constructor that represents a subset of the configuration:\n\n```go\ncache1Config := viper.Sub(\"cache.cache1\")\nif cache1Config == nil { // Sub returns nil if the key cannot be found\n\tpanic(\"cache configuration not found\")\n}\n\ncache1 := NewCache(cache1Config)\n```\n\n**Note:** Always check the return value of `Sub`. It returns `nil` if a key cannot be found.\n\nInternally, the `NewCache` function can address `max-items` and `item-size` keys directly:\n\n```go\nfunc NewCache(v *Viper) *Cache {\n\treturn &Cache{\n\t\tMaxItems: v.GetInt(\"max-items\"),\n\t\tItemSize: v.GetInt(\"item-size\"),\n\t}\n}\n```\n\nThe resulting code is easy to test, since it's decoupled from the main config structure,\nand easier to reuse (for the same reason).\n\n\n### Unmarshaling\n\nYou also have the option of Unmarshaling all or a specific value to a struct, map,\netc.\n\nThere are two methods to do this:\n\n * `Unmarshal(rawVal any) : error`\n * `UnmarshalKey(key string, rawVal any) : error`\n\nExample:\n\n```go\ntype config struct {\n\tPort int\n\tName string\n\tPathMap string `mapstructure:\"path_map\"`\n}\n\nvar C config\n\nerr := viper.Unmarshal(&C)\nif err != nil {\n\tt.Fatalf(\"unable to decode into struct, %v\", err)\n}\n```\n\nIf you want to unmarshal configuration where the keys themselves contain dot (the default key delimiter),\nyou have to change the delimiter:\n\n```go\nv := viper.NewWithOptions(viper.KeyDelimiter(\"::\"))\n\nv.SetDefault(\"chart::values\", map[string]any{\n\t\"ingress\": map[string]any{\n\t\t\"annotations\": map[string]any{\n\t\t\t\"traefik.frontend.rule.type\":                 \"PathPrefix\",\n\t\t\t\"traefik.ingress.kubernetes.io/ssl-redirect\": \"true\",\n\t\t},\n\t},\n})\n\ntype config struct {\n\tChart struct{\n\t\tValues map[string]any\n\t}\n}\n\nvar C config\n\nv.Unmarshal(&C)\n```\n\nViper also supports unmarshaling into embedded structs:\n\n```go\n/*\nExample config:\n\nmodule:\n    enabled: true\n    token: 89h3f98hbwf987h3f98wenf89ehf\n*/\ntype config struct {\n\tModule struct {\n\t\tEnabled bool\n\n\t\tmoduleConfig `mapstructure:\",squash\"`\n\t}\n}\n\n// moduleConfig could be in a module specific package\ntype moduleConfig struct {\n\tToken string\n}\n\nvar C config\n\nerr := viper.Unmarshal(&C)\nif err != nil {\n\tt.Fatalf(\"unable to decode into struct, %v\", err)\n}\n```\n\nViper uses [github.com/go-viper/mapstructure](https://github.com/go-viper/mapstructure) under the hood for unmarshaling values which uses `mapstructure` tags by default.\n\n### Decoding custom formats\n\nA frequently requested feature for Viper is adding more value formats and decoders.\nFor example, parsing character (dot, comma, semicolon, etc) separated strings into slices.\n\nThis is already available in Viper using mapstructure decode hooks.\n\nRead more about the details in [this blog post](https://sagikazarmark.hu/blog/decoding-custom-formats-with-viper/).\n\n### Marshalling to string\n\nYou may need to marshal all the settings held in viper into a string rather than write them to a file.\nYou can use your favorite format's marshaller with the config returned by `AllSettings()`.\n\n```go\nimport (\n\tyaml \"gopkg.in/yaml.v2\"\n\t// ...\n)\n\nfunc yamlStringSettings() string {\n\tc := viper.AllSettings()\n\tbs, err := yaml.Marshal(c)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to marshal config to YAML: %v\", err)\n\t}\n\treturn string(bs)\n}\n```\n\n## Viper or Vipers?\n\nViper comes with a global instance (singleton) out of the box.\n\nAlthough it makes setting up configuration easy,\nusing it is generally discouraged as it makes testing harder and can lead to unexpected behavior.\n\nThe best practice is to initialize a Viper instance and pass that around when necessary.\n\nThe global instance _MAY_ be deprecated in the future.\nSee [#1855](https://github.com/spf13/viper/issues/1855) for more details.\n\n### Working with multiple vipers\n\nYou can also create many different vipers for use in your application. Each will\nhave its own unique set of configurations and values. Each can read from a\ndifferent config file, key value store, etc. All of the functions that viper\npackage supports are mirrored as methods on a viper.\n\nExample:\n\n```go\nx := viper.New()\ny := viper.New()\n\nx.SetDefault(\"ContentDir\", \"content\")\ny.SetDefault(\"ContentDir\", \"foobar\")\n\n//...\n```\n\nWhen working with multiple vipers, it is up to the user to keep track of the\ndifferent vipers.\n\n\n## Q & A\n\n### Why is it called “Viper”?\n\nA: Viper is designed to be a [companion](http://en.wikipedia.org/wiki/Viper_(G.I._Joe))\nto [Cobra](https://github.com/spf13/cobra). While both can operate completely\nindependently, together they make a powerful pair to handle much of your\napplication foundation needs.\n\n### Why is it called “Cobra”?\n\nIs there a better name for a [commander](http://en.wikipedia.org/wiki/Cobra_Commander)?\n\n### Does Viper support case sensitive keys?\n\n**tl;dr:** No.\n\nViper merges configuration from various sources, many of which are either case insensitive or uses different casing than the rest of the sources (eg. env vars).\nIn order to provide the best experience when using multiple sources, the decision has been made to make all keys case insensitive.\n\nThere has been several attempts to implement case sensitivity, but unfortunately it's not that trivial. We might take a stab at implementing it in [Viper v2](https://github.com/spf13/viper/issues/772), but despite the initial noise, it does not seem to be requested that much.\n\nYou can vote for case sensitivity by filling out this feedback form: https://forms.gle/R6faU74qPRPAzchZ9\n\n### Is it safe to concurrently read and write to a viper?\n\nNo, you will need to synchronize access to the viper yourself (for example by using the `sync` package). Concurrent reads and writes can cause a panic.\n\n## Troubleshooting\n\nSee [TROUBLESHOOTING.md](TROUBLESHOOTING.md).\n\n## Development\n\n**For an optimal developer experience, it is recommended to install [Nix](https://nixos.org/download.html) and [direnv](https://direnv.net/docs/installation.html).**\n\n_Alternatively, install [Go](https://go.dev/dl/) on your computer then run `make deps` to install the rest of the dependencies._\n\nRun the test suite:\n\n```shell\nmake test\n```\n\nRun linters:\n\n```shell\nmake lint # pass -j option to run them in parallel\n```\n\nSome linter violations can automatically be fixed:\n\n```shell\nmake fmt\n```\n\n## License\n\nThe project is licensed under the [MIT License](LICENSE).\n"
        },
        {
          "name": "TROUBLESHOOTING.md",
          "type": "blob",
          "size": 1.71,
          "content": "# Troubleshooting\n\n## Unmarshaling doesn't work\n\nThe most common reason for this issue is improper use of struct tags (eg. `yaml` or `json`). Viper uses [github.com/mitchellh/mapstructure](https://github.com/mitchellh/mapstructure) under the hood for unmarshaling values which uses `mapstructure` tags by default. Please refer to the library's documentation for using other struct tags.\n\n## Cannot find package\n\nViper installation seems to fail a lot lately with the following (or a similar) error:\n\n```\ncannot find package \"github.com/hashicorp/hcl/tree/hcl1\" in any of:\n/usr/local/Cellar/go/1.15.7_1/libexec/src/github.com/hashicorp/hcl/tree/hcl1 (from $GOROOT)\n/Users/user/go/src/github.com/hashicorp/hcl/tree/hcl1 (from $GOPATH)\n```\n\nAs the error message suggests, Go tries to look up dependencies in `GOPATH` mode (as it's commonly called) from the `GOPATH`.\nViper opted to use [Go Modules](https://go.dev/wiki/Modules) to manage its dependencies. While in many cases the two methods are interchangeable, once a dependency releases new (major) versions, `GOPATH` mode is no longer able to decide which version to use, so it'll either use one that's already present or pick a version (usually the `master` branch).\n\nThe solution is easy: switch to using Go Modules.\nPlease refer to the [wiki](https://go.dev/wiki/Modules) on how to do that.\n\n**tl;dr* `export GO111MODULE=on`\n\n## Unquoted 'y' and 'n' characters get replaced with _true_ and _false_ when reading a YAML file\n\nThis is a YAML 1.1 feature according to [go-yaml/yaml#740](https://github.com/go-yaml/yaml/issues/740).\n\nPotential solutions are:\n\n1. Quoting values resolved as boolean\n1. Upgrading to YAML v3 (for the time being this is possible by passing the `viper_yaml3` tag to your build)\n"
        },
        {
          "name": "encoding.go",
          "type": "blob",
          "size": 3.92,
          "content": "package viper\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/spf13/viper/internal/encoding/dotenv\"\n\t\"github.com/spf13/viper/internal/encoding/json\"\n\t\"github.com/spf13/viper/internal/encoding/toml\"\n\t\"github.com/spf13/viper/internal/encoding/yaml\"\n)\n\n// Encoder encodes Viper's internal data structures into a byte representation.\n// It's primarily used for encoding a map[string]any into a file format.\ntype Encoder interface {\n\tEncode(v map[string]any) ([]byte, error)\n}\n\n// Decoder decodes the contents of a byte slice into Viper's internal data structures.\n// It's primarily used for decoding contents of a file into a map[string]any.\ntype Decoder interface {\n\tDecode(b []byte, v map[string]any) error\n}\n\n// Codec combines [Encoder] and [Decoder] interfaces.\ntype Codec interface {\n\tEncoder\n\tDecoder\n}\n\n// TODO: consider adding specific errors for not found scenarios\n\n// EncoderRegistry returns an [Encoder] for a given format.\n//\n// Format is case-insensitive.\n//\n// [EncoderRegistry] returns an error if no [Encoder] is registered for the format.\ntype EncoderRegistry interface {\n\tEncoder(format string) (Encoder, error)\n}\n\n// DecoderRegistry returns an [Decoder] for a given format.\n//\n// Format is case-insensitive.\n//\n// [DecoderRegistry] returns an error if no [Decoder] is registered for the format.\ntype DecoderRegistry interface {\n\tDecoder(format string) (Decoder, error)\n}\n\n// [CodecRegistry] combines [EncoderRegistry] and [DecoderRegistry] interfaces.\ntype CodecRegistry interface {\n\tEncoderRegistry\n\tDecoderRegistry\n}\n\n// WithEncoderRegistry sets a custom [EncoderRegistry].\nfunc WithEncoderRegistry(r EncoderRegistry) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tif r == nil {\n\t\t\treturn\n\t\t}\n\n\t\tv.encoderRegistry = r\n\t})\n}\n\n// WithDecoderRegistry sets a custom [DecoderRegistry].\nfunc WithDecoderRegistry(r DecoderRegistry) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tif r == nil {\n\t\t\treturn\n\t\t}\n\n\t\tv.decoderRegistry = r\n\t})\n}\n\n// WithCodecRegistry sets a custom [EncoderRegistry] and [DecoderRegistry].\nfunc WithCodecRegistry(r CodecRegistry) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tif r == nil {\n\t\t\treturn\n\t\t}\n\n\t\tv.encoderRegistry = r\n\t\tv.decoderRegistry = r\n\t})\n}\n\n// DefaultCodecRegistry is a simple implementation of [CodecRegistry] that allows registering custom [Codec]s.\ntype DefaultCodecRegistry struct {\n\tcodecs map[string]Codec\n\n\tmu   sync.RWMutex\n\tonce sync.Once\n}\n\n// NewCodecRegistry returns a new [CodecRegistry], ready to accept custom [Codec]s.\nfunc NewCodecRegistry() *DefaultCodecRegistry {\n\tr := &DefaultCodecRegistry{}\n\n\tr.init()\n\n\treturn r\n}\n\nfunc (r *DefaultCodecRegistry) init() {\n\tr.once.Do(func() {\n\t\tr.codecs = map[string]Codec{}\n\t})\n}\n\n// RegisterCodec registers a custom [Codec].\n//\n// Format is case-insensitive.\nfunc (r *DefaultCodecRegistry) RegisterCodec(format string, codec Codec) error {\n\tr.init()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tr.codecs[strings.ToLower(format)] = codec\n\n\treturn nil\n}\n\n// Encoder implements the [EncoderRegistry] interface.\n//\n// Format is case-insensitive.\nfunc (r *DefaultCodecRegistry) Encoder(format string) (Encoder, error) {\n\tencoder, ok := r.codec(format)\n\tif !ok {\n\t\treturn nil, errors.New(\"encoder not found for this format\")\n\t}\n\n\treturn encoder, nil\n}\n\n// Decoder implements the [DecoderRegistry] interface.\n//\n// Format is case-insensitive.\nfunc (r *DefaultCodecRegistry) Decoder(format string) (Decoder, error) {\n\tdecoder, ok := r.codec(format)\n\tif !ok {\n\t\treturn nil, errors.New(\"decoder not found for this format\")\n\t}\n\n\treturn decoder, nil\n}\n\nfunc (r *DefaultCodecRegistry) codec(format string) (Codec, bool) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tformat = strings.ToLower(format)\n\n\tif r.codecs != nil {\n\t\tcodec, ok := r.codecs[format]\n\t\tif ok {\n\t\t\treturn codec, true\n\t\t}\n\t}\n\n\tswitch format {\n\tcase \"yaml\", \"yml\":\n\t\treturn yaml.Codec{}, true\n\n\tcase \"json\":\n\t\treturn json.Codec{}, true\n\n\tcase \"toml\":\n\t\treturn toml.Codec{}, true\n\n\tcase \"dotenv\", \"env\":\n\t\treturn &dotenv.Codec{}, true\n\t}\n\n\treturn nil, false\n}\n"
        },
        {
          "name": "encoding_test.go",
          "type": "blob",
          "size": 1.89,
          "content": "package viper\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype codec struct{}\n\nfunc (codec) Encode(_ map[string]any) ([]byte, error) {\n\treturn nil, nil\n}\n\nfunc (codec) Decode(_ []byte, _ map[string]any) error {\n\treturn nil\n}\n\nfunc TestDefaultCodecRegistry(t *testing.T) {\n\tt.Run(\"OK\", func(t *testing.T) {\n\t\tregistry := NewCodecRegistry()\n\n\t\tc := codec{}\n\n\t\terr := registry.RegisterCodec(\"myformat\", c)\n\t\trequire.NoError(t, err)\n\n\t\tencoder, err := registry.Encoder(\"myformat\")\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, c, encoder)\n\n\t\tdecoder, err := registry.Decoder(\"myformat\")\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, c, decoder)\n\t})\n\n\tt.Run(\"CodecNotFound\", func(t *testing.T) {\n\t\tregistry := NewCodecRegistry()\n\n\t\t_, err := registry.Encoder(\"myformat\")\n\t\trequire.Error(t, err)\n\n\t\t_, err = registry.Decoder(\"myformat\")\n\t\trequire.Error(t, err)\n\t})\n\n\tt.Run(\"FormatIsCaseInsensitive\", func(t *testing.T) {\n\t\tregistry := NewCodecRegistry()\n\n\t\tc := codec{}\n\n\t\terr := registry.RegisterCodec(\"MYFORMAT\", c)\n\t\trequire.NoError(t, err)\n\n\t\t{\n\t\t\tencoder, err := registry.Encoder(\"myformat\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, c, encoder)\n\t\t}\n\n\t\t{\n\t\t\tencoder, err := registry.Encoder(\"MYFORMAT\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, c, encoder)\n\t\t}\n\n\t\t{\n\t\t\tdecoder, err := registry.Decoder(\"myformat\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, c, decoder)\n\t\t}\n\n\t\t{\n\t\t\tdecoder, err := registry.Decoder(\"MYFORMAT\")\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, c, decoder)\n\t\t}\n\t})\n\n\tt.Run(\"OverrideDefault\", func(t *testing.T) {\n\t\tregistry := NewCodecRegistry()\n\n\t\tc := codec{}\n\n\t\terr := registry.RegisterCodec(\"yaml\", c)\n\t\trequire.NoError(t, err)\n\n\t\tencoder, err := registry.Encoder(\"yaml\")\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, c, encoder)\n\n\t\tdecoder, err := registry.Decoder(\"yaml\")\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, c, decoder)\n\t})\n}\n"
        },
        {
          "name": "experimental.go",
          "type": "blob",
          "size": 0.2,
          "content": "package viper\n\n// ExperimentalBindStruct tells Viper to use the new bind struct feature.\nfunc ExperimentalBindStruct() Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tv.experimentalBindStruct = true\n\t})\n}\n"
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 2.57,
          "content": "package viper\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/sagikazarmark/locafero\"\n\t\"github.com/spf13/afero\"\n)\n\n// ExperimentalFinder tells Viper to use the new Finder interface for finding configuration files.\nfunc ExperimentalFinder() Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tv.experimentalFinder = true\n\t})\n}\n\n// Search for a config file.\nfunc (v *Viper) findConfigFile() (string, error) {\n\tfinder := v.finder\n\n\tif finder == nil && v.experimentalFinder {\n\t\tvar names []string\n\n\t\tif v.configType != \"\" {\n\t\t\tnames = locafero.NameWithOptionalExtensions(v.configName, SupportedExts...)\n\t\t} else {\n\t\t\tnames = locafero.NameWithExtensions(v.configName, SupportedExts...)\n\t\t}\n\n\t\tfinder = locafero.Finder{\n\t\t\tPaths: v.configPaths,\n\t\t\tNames: names,\n\t\t\tType:  locafero.FileTypeFile,\n\t\t}\n\t}\n\n\tif finder != nil {\n\t\treturn v.findConfigFileWithFinder(finder)\n\t}\n\n\treturn v.findConfigFileOld()\n}\n\nfunc (v *Viper) findConfigFileWithFinder(finder Finder) (string, error) {\n\tresults, err := finder.Find(v.fs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(results) == 0 {\n\t\treturn \"\", ConfigFileNotFoundError{v.configName, fmt.Sprintf(\"%s\", v.configPaths)}\n\t}\n\n\t// We call clean on the final result to ensure that the path is in its canonical form.\n\t// This is mostly for consistent path handling and to make sure tests pass.\n\treturn results[0], nil\n}\n\n// Search all configPaths for any config file.\n// Returns the first path that exists (and is a config file).\nfunc (v *Viper) findConfigFileOld() (string, error) {\n\tv.logger.Info(\"searching for config in paths\", \"paths\", v.configPaths)\n\n\tfor _, cp := range v.configPaths {\n\t\tfile := v.searchInPath(cp)\n\t\tif file != \"\" {\n\t\t\treturn file, nil\n\t\t}\n\t}\n\treturn \"\", ConfigFileNotFoundError{v.configName, fmt.Sprintf(\"%s\", v.configPaths)}\n}\n\nfunc (v *Viper) searchInPath(in string) (filename string) {\n\tv.logger.Debug(\"searching for config in path\", \"path\", in)\n\tfor _, ext := range SupportedExts {\n\t\tv.logger.Debug(\"checking if file exists\", \"file\", filepath.Join(in, v.configName+\".\"+ext))\n\t\tif b, _ := exists(v.fs, filepath.Join(in, v.configName+\".\"+ext)); b {\n\t\t\tv.logger.Debug(\"found file\", \"file\", filepath.Join(in, v.configName+\".\"+ext))\n\t\t\treturn filepath.Join(in, v.configName+\".\"+ext)\n\t\t}\n\t}\n\n\tif v.configType != \"\" {\n\t\tif b, _ := exists(v.fs, filepath.Join(in, v.configName)); b {\n\t\t\treturn filepath.Join(in, v.configName)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n// exists checks if file exists.\nfunc exists(fs afero.Fs, path string) (bool, error) {\n\tstat, err := fs.Stat(path)\n\tif err == nil {\n\t\treturn !stat.IsDir(), nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n"
        },
        {
          "name": "finder.go",
          "type": "blob",
          "size": 0.98,
          "content": "package viper\n\nimport (\n\t\"errors\"\n\n\t\"github.com/spf13/afero\"\n)\n\n// WithFinder sets a custom [Finder].\nfunc WithFinder(f Finder) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tif f == nil {\n\t\t\treturn\n\t\t}\n\n\t\tv.finder = f\n\t})\n}\n\n// Finder looks for files and directories in an [afero.Fs] filesystem.\ntype Finder interface {\n\tFind(fsys afero.Fs) ([]string, error)\n}\n\n// Finders combines multiple finders into one.\nfunc Finders(finders ...Finder) Finder {\n\treturn &combinedFinder{finders: finders}\n}\n\n// combinedFinder is a Finder that combines multiple finders.\ntype combinedFinder struct {\n\tfinders []Finder\n}\n\n// Find implements the [Finder] interface.\nfunc (c *combinedFinder) Find(fsys afero.Fs) ([]string, error) {\n\tvar results []string\n\tvar errs []error\n\n\tfor _, finder := range c.finders {\n\t\tif finder == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tr, err := finder.Find(fsys)\n\t\tif err != nil {\n\t\t\terrs = append(errs, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tresults = append(results, r...)\n\t}\n\n\treturn results, errors.Join(errs...)\n}\n"
        },
        {
          "name": "finder_example_test.go",
          "type": "blob",
          "size": 1.58,
          "content": "package viper_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/sagikazarmark/locafero\"\n\t\"github.com/spf13/afero\"\n\n\t\"github.com/spf13/viper\"\n)\n\nfunc ExampleFinder() {\n\tfs := afero.NewMemMapFs()\n\n\tfs.Mkdir(\"/home/user\", 0o777)\n\n\tf, _ := fs.Create(\"/home/user/myapp.yaml\")\n\tf.WriteString(\"foo: bar\")\n\tf.Close()\n\n\t// HCL will have a \"lower\" priority in the search order\n\tfs.Create(\"/home/user/myapp.hcl\")\n\n\tfinder := locafero.Finder{\n\t\tPaths: []string{\"/home/user\"},\n\t\tNames: locafero.NameWithExtensions(\"myapp\", viper.SupportedExts...),\n\t\tType:  locafero.FileTypeFile, // This is important!\n\t}\n\n\tv := viper.NewWithOptions(viper.WithFinder(finder))\n\tv.SetFs(fs)\n\tv.ReadInConfig()\n\n\tfmt.Println(v.GetString(\"foo\"))\n\n\t// Output:\n\t// bar\n}\n\nfunc ExampleFinders() {\n\tfs := afero.NewMemMapFs()\n\n\tfs.Mkdir(\"/home/user\", 0o777)\n\tf, _ := fs.Create(\"/home/user/myapp.yaml\")\n\tf.WriteString(\"foo: bar\")\n\tf.Close()\n\n\tfs.Mkdir(\"/etc/myapp\", 0o777)\n\tfs.Create(\"/etc/myapp/config.yaml\")\n\n\t// Combine multiple finders to search for files in multiple locations with different criteria\n\tfinder := viper.Finders(\n\t\tlocafero.Finder{\n\t\t\tPaths: []string{\"/home/user\"},\n\t\t\tNames: locafero.NameWithExtensions(\"myapp\", viper.SupportedExts...),\n\t\t\tType:  locafero.FileTypeFile, // This is important!\n\t\t},\n\t\tlocafero.Finder{\n\t\t\tPaths: []string{\"/etc/myapp\"},\n\t\t\tNames: []string{\"config.yaml\"}, // Only accept YAML files in the system config directory\n\t\t\tType:  locafero.FileTypeFile,   // This is important!\n\t\t},\n\t)\n\n\tv := viper.NewWithOptions(viper.WithFinder(finder))\n\tv.SetFs(fs)\n\tv.ReadInConfig()\n\n\tfmt.Println(v.GetString(\"foo\"))\n\n\t// Output:\n\t// bar\n}\n"
        },
        {
          "name": "finder_test.go",
          "type": "blob",
          "size": 0.66,
          "content": "package viper\n\nimport (\n\t\"testing\"\n\n\t\"github.com/spf13/afero\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype finderStub struct {\n\tresults []string\n}\n\nfunc (f finderStub) Find(_ afero.Fs) ([]string, error) {\n\treturn f.results, nil\n}\n\nfunc TestFinders(t *testing.T) {\n\tfinder := Finders(\n\t\tfinderStub{\n\t\t\tresults: []string{\n\t\t\t\t\"/home/user/.viper.yaml\",\n\t\t\t},\n\t\t},\n\t\tfinderStub{\n\t\t\tresults: []string{\n\t\t\t\t\"/etc/viper/config.yaml\",\n\t\t\t},\n\t\t},\n\t)\n\n\tresults, err := finder.Find(afero.NewMemMapFs())\n\trequire.NoError(t, err)\n\n\texpected := []string{\n\t\t\"/home/user/.viper.yaml\",\n\t\t\"/etc/viper/config.yaml\",\n\t}\n\n\tassert.Equal(t, expected, results)\n}\n"
        },
        {
          "name": "flags.go",
          "type": "blob",
          "size": 1.31,
          "content": "package viper\n\nimport \"github.com/spf13/pflag\"\n\n// FlagValueSet is an interface that users can implement\n// to bind a set of flags to viper.\ntype FlagValueSet interface {\n\tVisitAll(fn func(FlagValue))\n}\n\n// FlagValue is an interface that users can implement\n// to bind different flags to viper.\ntype FlagValue interface {\n\tHasChanged() bool\n\tName() string\n\tValueString() string\n\tValueType() string\n}\n\n// pflagValueSet is a wrapper around *pflag.ValueSet\n// that implements FlagValueSet.\ntype pflagValueSet struct {\n\tflags *pflag.FlagSet\n}\n\n// VisitAll iterates over all *pflag.Flag inside the *pflag.FlagSet.\nfunc (p pflagValueSet) VisitAll(fn func(flag FlagValue)) {\n\tp.flags.VisitAll(func(flag *pflag.Flag) {\n\t\tfn(pflagValue{flag})\n\t})\n}\n\n// pflagValue is a wrapper around *pflag.flag\n// that implements FlagValue.\ntype pflagValue struct {\n\tflag *pflag.Flag\n}\n\n// HasChanged returns whether the flag has changes or not.\nfunc (p pflagValue) HasChanged() bool {\n\treturn p.flag.Changed\n}\n\n// Name returns the name of the flag.\nfunc (p pflagValue) Name() string {\n\treturn p.flag.Name\n}\n\n// ValueString returns the value of the flag as a string.\nfunc (p pflagValue) ValueString() string {\n\treturn p.flag.Value.String()\n}\n\n// ValueType returns the type of the flag as a string.\nfunc (p pflagValue) ValueType() string {\n\treturn p.flag.Value.Type()\n}\n"
        },
        {
          "name": "flags_test.go",
          "type": "blob",
          "size": 1.33,
          "content": "package viper\n\nimport (\n\t\"testing\"\n\n\t\"github.com/spf13/pflag\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestBindFlagValueSet(t *testing.T) {\n\tReset()\n\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\n\ttestValues := map[string]*string{\n\t\t\"host\":     nil,\n\t\t\"port\":     nil,\n\t\t\"endpoint\": nil,\n\t}\n\n\tmutatedTestValues := map[string]string{\n\t\t\"host\":     \"localhost\",\n\t\t\"port\":     \"6060\",\n\t\t\"endpoint\": \"/public\",\n\t}\n\n\tfor name := range testValues {\n\t\ttestValues[name] = flagSet.String(name, \"\", \"test\")\n\t}\n\n\tflagValueSet := pflagValueSet{flagSet}\n\n\terr := BindFlagValues(flagValueSet)\n\trequire.NoError(t, err, \"error binding flag set\")\n\n\tflagSet.VisitAll(func(flag *pflag.Flag) {\n\t\tflag.Value.Set(mutatedTestValues[flag.Name])\n\t\tflag.Changed = true\n\t})\n\n\tfor name, expected := range mutatedTestValues {\n\t\tassert.Equal(t, expected, Get(name))\n\t}\n}\n\nfunc TestBindFlagValue(t *testing.T) {\n\ttestString := \"testing\"\n\ttestValue := newStringValue(testString, &testString)\n\n\tflag := &pflag.Flag{\n\t\tName:    \"testflag\",\n\t\tValue:   testValue,\n\t\tChanged: false,\n\t}\n\n\tflagValue := pflagValue{flag}\n\tBindFlagValue(\"testvalue\", flagValue)\n\n\tassert.Equal(t, testString, Get(\"testvalue\"))\n\n\tflag.Value.Set(\"testing_mutate\")\n\tflag.Changed = true // hack for pflag usage\n\n\tassert.Equal(t, \"testing_mutate\", Get(\"testvalue\"))\n}\n"
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 12.23,
          "content": "{\n  \"nodes\": {\n    \"cachix\": {\n      \"inputs\": {\n        \"devenv\": \"devenv_2\",\n        \"flake-compat\": [\n          \"devenv\",\n          \"flake-compat\"\n        ],\n        \"nixpkgs\": [\n          \"devenv\",\n          \"nixpkgs\"\n        ],\n        \"pre-commit-hooks\": [\n          \"devenv\",\n          \"pre-commit-hooks\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1712055811,\n        \"narHash\": \"sha256-7FcfMm5A/f02yyzuavJe06zLa9hcMHsagE28ADcmQvk=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"cachix\",\n        \"rev\": \"02e38da89851ec7fec3356a5c04bc8349cae0e30\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"cachix\",\n        \"type\": \"github\"\n      }\n    },\n    \"devenv\": {\n      \"inputs\": {\n        \"cachix\": \"cachix\",\n        \"flake-compat\": \"flake-compat_2\",\n        \"nix\": \"nix_2\",\n        \"nixpkgs\": \"nixpkgs_2\",\n        \"pre-commit-hooks\": \"pre-commit-hooks\"\n      },\n      \"locked\": {\n        \"lastModified\": 1724763216,\n        \"narHash\": \"sha256-oW2bwCrJpIzibCNK6zfIDaIQw765yMAuMSG2gyZfGv0=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"devenv\",\n        \"rev\": \"1e4ef61205b9aa20fe04bf1c468b6a316281c4f1\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"devenv\",\n        \"type\": \"github\"\n      }\n    },\n    \"devenv_2\": {\n      \"inputs\": {\n        \"flake-compat\": [\n          \"devenv\",\n          \"cachix\",\n          \"flake-compat\"\n        ],\n        \"nix\": \"nix\",\n        \"nixpkgs\": \"nixpkgs\",\n        \"poetry2nix\": \"poetry2nix\",\n        \"pre-commit-hooks\": [\n          \"devenv\",\n          \"cachix\",\n          \"pre-commit-hooks\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1708704632,\n        \"narHash\": \"sha256-w+dOIW60FKMaHI1q5714CSibk99JfYxm0CzTinYWr+Q=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"devenv\",\n        \"rev\": \"2ee4450b0f4b95a1b90f2eb5ffea98b90e48c196\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"ref\": \"python-rewrite\",\n        \"repo\": \"devenv\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-compat\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1673956053,\n        \"narHash\": \"sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=\",\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"rev\": \"35bb57c0c8d8b62bbfd284272c928ceb64ddbde9\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-compat_2\": {\n      \"flake\": false,\n      \"locked\": {\n        \"lastModified\": 1696426674,\n        \"narHash\": \"sha256-kvjfFW7WAETZlt09AgDn1MrtKzP7t90Vf7vypd3OL1U=\",\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"rev\": \"0f9255e01c2351cc7d116c072cb317785dd33b33\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"edolstra\",\n        \"repo\": \"flake-compat\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-parts\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib\"\n      },\n      \"locked\": {\n        \"lastModified\": 1722555600,\n        \"narHash\": \"sha256-XOQkdLafnb/p9ij77byFQjDf5m5QYl9b2REiVClC+x4=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"8471fe90ad337a8074e957b69ca4d0089218391d\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils\": {\n      \"inputs\": {\n        \"systems\": \"systems\"\n      },\n      \"locked\": {\n        \"lastModified\": 1689068808,\n        \"narHash\": \"sha256-6ixXo3wt24N/melDWjq70UuHQLxGV8jZvooRanIHXw0=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"919d646de7be200f3bf08cb76ae1f09402b6f9b4\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"flake-utils_2\": {\n      \"inputs\": {\n        \"systems\": \"systems_2\"\n      },\n      \"locked\": {\n        \"lastModified\": 1710146030,\n        \"narHash\": \"sha256-SZ5L6eA7HJ/nmkzGG7/ISclqe6oZdOZTNoesiInkXPQ=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"b1d9ab70662946ef0850d488da1c9019f3a9752a\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"gitignore\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"devenv\",\n          \"pre-commit-hooks\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1709087332,\n        \"narHash\": \"sha256-HG2cCnktfHsKV0s4XW83gU3F57gaTljL9KNSuG6bnQs=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"rev\": \"637db329424fd7e46cf4185293b9cc8c88c95394\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"gitignore.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"nix\": {\n      \"inputs\": {\n        \"flake-compat\": \"flake-compat\",\n        \"nixpkgs\": [\n          \"devenv\",\n          \"cachix\",\n          \"devenv\",\n          \"nixpkgs\"\n        ],\n        \"nixpkgs-regression\": \"nixpkgs-regression\"\n      },\n      \"locked\": {\n        \"lastModified\": 1712911606,\n        \"narHash\": \"sha256-BGvBhepCufsjcUkXnEEXhEVjwdJAwPglCC2+bInc794=\",\n        \"owner\": \"domenkozar\",\n        \"repo\": \"nix\",\n        \"rev\": \"b24a9318ea3f3600c1e24b4a00691ee912d4de12\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"domenkozar\",\n        \"ref\": \"devenv-2.21\",\n        \"repo\": \"nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"nix-github-actions\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"devenv\",\n          \"cachix\",\n          \"devenv\",\n          \"poetry2nix\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1688870561,\n        \"narHash\": \"sha256-4UYkifnPEw1nAzqqPOTL2MvWtm3sNGw1UTYTalkTcGY=\",\n        \"owner\": \"nix-community\",\n        \"repo\": \"nix-github-actions\",\n        \"rev\": \"165b1650b753316aa7f1787f3005a8d2da0f5301\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-community\",\n        \"repo\": \"nix-github-actions\",\n        \"type\": \"github\"\n      }\n    },\n    \"nix_2\": {\n      \"inputs\": {\n        \"flake-compat\": [\n          \"devenv\",\n          \"flake-compat\"\n        ],\n        \"nixpkgs\": [\n          \"devenv\",\n          \"nixpkgs\"\n        ],\n        \"nixpkgs-regression\": \"nixpkgs-regression_2\"\n      },\n      \"locked\": {\n        \"lastModified\": 1712911606,\n        \"narHash\": \"sha256-BGvBhepCufsjcUkXnEEXhEVjwdJAwPglCC2+bInc794=\",\n        \"owner\": \"domenkozar\",\n        \"repo\": \"nix\",\n        \"rev\": \"b24a9318ea3f3600c1e24b4a00691ee912d4de12\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"domenkozar\",\n        \"ref\": \"devenv-2.21\",\n        \"repo\": \"nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1692808169,\n        \"narHash\": \"sha256-x9Opq06rIiwdwGeK2Ykj69dNc2IvUH1fY55Wm7atwrE=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"9201b5ff357e781bf014d0330d18555695df7ba8\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib\": {\n      \"locked\": {\n        \"lastModified\": 1722555339,\n        \"narHash\": \"sha256-uFf2QeW7eAHlYXuDktm9c25OxOyCoUOQmh5SZ9amE5Q=\",\n        \"type\": \"tarball\",\n        \"url\": \"https://github.com/NixOS/nixpkgs/archive/a5d394176e64ab29c852d03346c1fc9b0b7d33eb.tar.gz\"\n      },\n      \"original\": {\n        \"type\": \"tarball\",\n        \"url\": \"https://github.com/NixOS/nixpkgs/archive/a5d394176e64ab29c852d03346c1fc9b0b7d33eb.tar.gz\"\n      }\n    },\n    \"nixpkgs-regression\": {\n      \"locked\": {\n        \"lastModified\": 1643052045,\n        \"narHash\": \"sha256-uGJ0VXIhWKGXxkeNnq4TvV3CIOkUJ3PAoLZ3HMzNVMw=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"215d4d0fd80ca5163643b03a33fde804a29cc1e2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"215d4d0fd80ca5163643b03a33fde804a29cc1e2\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-regression_2\": {\n      \"locked\": {\n        \"lastModified\": 1643052045,\n        \"narHash\": \"sha256-uGJ0VXIhWKGXxkeNnq4TvV3CIOkUJ3PAoLZ3HMzNVMw=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"215d4d0fd80ca5163643b03a33fde804a29cc1e2\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"215d4d0fd80ca5163643b03a33fde804a29cc1e2\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-stable\": {\n      \"locked\": {\n        \"lastModified\": 1710695816,\n        \"narHash\": \"sha256-3Eh7fhEID17pv9ZxrPwCLfqXnYP006RKzSs0JptsN84=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"614b4613980a522ba49f0d194531beddbb7220d3\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-23.11\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_2\": {\n      \"locked\": {\n        \"lastModified\": 1713361204,\n        \"narHash\": \"sha256-TA6EDunWTkc5FvDCqU3W2T3SFn0gRZqh6D/hJnM02MM=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"devenv-nixpkgs\",\n        \"rev\": \"285676e87ad9f0ca23d8714a6ab61e7e027020c6\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"ref\": \"rolling\",\n        \"repo\": \"devenv-nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs_3\": {\n      \"locked\": {\n        \"lastModified\": 1724748588,\n        \"narHash\": \"sha256-NlpGA4+AIf1dKNq76ps90rxowlFXUsV9x7vK/mN37JM=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"a6292e34000dc93d43bccf78338770c1c5ec8a99\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"poetry2nix\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils\",\n        \"nix-github-actions\": \"nix-github-actions\",\n        \"nixpkgs\": [\n          \"devenv\",\n          \"cachix\",\n          \"devenv\",\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1692876271,\n        \"narHash\": \"sha256-IXfZEkI0Mal5y1jr6IRWMqK8GW2/f28xJenZIPQqkY0=\",\n        \"owner\": \"nix-community\",\n        \"repo\": \"poetry2nix\",\n        \"rev\": \"d5006be9c2c2417dafb2e2e5034d83fabd207ee3\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-community\",\n        \"repo\": \"poetry2nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"pre-commit-hooks\": {\n      \"inputs\": {\n        \"flake-compat\": [\n          \"devenv\",\n          \"flake-compat\"\n        ],\n        \"flake-utils\": \"flake-utils_2\",\n        \"gitignore\": \"gitignore\",\n        \"nixpkgs\": [\n          \"devenv\",\n          \"nixpkgs\"\n        ],\n        \"nixpkgs-stable\": \"nixpkgs-stable\"\n      },\n      \"locked\": {\n        \"lastModified\": 1713775815,\n        \"narHash\": \"sha256-Wu9cdYTnGQQwtT20QQMg7jzkANKQjwBD9iccfGKkfls=\",\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"rev\": \"2ac4dcbf55ed43f3be0bae15e181f08a57af24a4\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"cachix\",\n        \"repo\": \"pre-commit-hooks.nix\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"devenv\": \"devenv\",\n        \"flake-parts\": \"flake-parts\",\n        \"nixpkgs\": \"nixpkgs_3\"\n      }\n    },\n    \"systems\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    },\n    \"systems_2\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 1.32,
          "content": "{\n  description = \"Viper\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";\n    flake-parts.url = \"github:hercules-ci/flake-parts\";\n    devenv.url = \"github:cachix/devenv\";\n  };\n\n  outputs = inputs@{ flake-parts, ... }:\n    flake-parts.lib.mkFlake { inherit inputs; } {\n      imports = [\n        inputs.devenv.flakeModule\n      ];\n\n      systems = [ \"x86_64-linux\" \"x86_64-darwin\" \"aarch64-darwin\" ];\n\n      perSystem = { config, self', inputs', pkgs, system, ... }: rec {\n        devenv.shells = {\n          default = {\n            languages = {\n              go.enable = true;\n              go.package = pkgs.go_1_23;\n            };\n\n            pre-commit.hooks = {\n              nixpkgs-fmt.enable = true;\n              yamllint.enable = true;\n            };\n\n            packages = with pkgs; [\n              gnumake\n\n              golangci-lint\n              yamllint\n            ];\n\n            scripts = {\n              versions.exec = ''\n                go version\n                golangci-lint version\n              '';\n            };\n\n            enterShell = ''\n              versions\n            '';\n\n            # https://github.com/cachix/devenv/issues/528#issuecomment-1556108767\n            containers = pkgs.lib.mkForce { };\n          };\n\n          ci = devenv.shells.default;\n        };\n      };\n    };\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.75,
          "content": "module github.com/spf13/viper\n\ngo 1.21.0\n\nrequire (\n\tgithub.com/fsnotify/fsnotify v1.8.0\n\tgithub.com/go-viper/mapstructure/v2 v2.2.1\n\tgithub.com/pelletier/go-toml/v2 v2.2.3\n\tgithub.com/sagikazarmark/locafero v0.7.0\n\tgithub.com/spf13/afero v1.12.0\n\tgithub.com/spf13/cast v1.7.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/subosito/gotenv v1.6.0\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/sourcegraph/conc v0.3.0 // indirect\n\tgo.uber.org/atomic v1.9.0 // indirect\n\tgo.uber.org/multierr v1.9.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.18,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/fsnotify/fsnotify v1.8.0 h1:dAwr6QBTBZIkG8roQaJjGof0pp0EeF+tNV7YBP3F/8M=\ngithub.com/fsnotify/fsnotify v1.8.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=\ngithub.com/go-viper/mapstructure/v2 v2.2.1 h1:ZAaOCxANMuZx5RCeg0mBdEZk7DZasvvZIxtHqx8aGss=\ngithub.com/go-viper/mapstructure/v2 v2.2.1/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=\ngithub.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/sagikazarmark/locafero v0.7.0 h1:5MqpDsTGNDhY8sGp0Aowyf0qKsPrhewaLSsFaodPcyo=\ngithub.com/sagikazarmark/locafero v0.7.0/go.mod h1:2za3Cg5rMaTMoG/2Ulr9AwtFaIppKXTRYnozin4aB5k=\ngithub.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=\ngithub.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=\ngithub.com/spf13/afero v1.12.0 h1:UcOPyRBYczmFn6yvphxkn9ZEOY65cpwGKb5mL36mrqs=\ngithub.com/spf13/afero v1.12.0/go.mod h1:ZTlWwG4/ahT8W7T0WQ5uYmjI9duaLQGy3Q2OAl4sk/4=\ngithub.com/spf13/cast v1.7.1 h1:cuNEagBQEHWN1FnbGEjCXL2szYEXqfJPbP2HNUaca9Y=\ngithub.com/spf13/cast v1.7.1/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=\ngithub.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=\ngo.uber.org/atomic v1.9.0 h1:ECmE8Bn/WFTYwEW/bpKD3M8VtR/zQVbavAoalC1PYyE=\ngo.uber.org/atomic v1.9.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=\ngo.uber.org/multierr v1.9.0 h1:7fIwc/ZtS0q++VgcfqFDxSBZVv/Xo49/SYnDFupUwlI=\ngo.uber.org/multierr v1.9.0/go.mod h1:X2jQV1h+kxSjClGpnseKVIxpmcjrj7MNnI0bnlfKTVQ=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.53,
          "content": "package viper\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n)\n\n// WithLogger sets a custom logger.\nfunc WithLogger(l *slog.Logger) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tv.logger = l\n\t})\n}\n\ntype discardHandler struct{}\n\nfunc (n *discardHandler) Enabled(_ context.Context, _ slog.Level) bool {\n\treturn false\n}\n\nfunc (n *discardHandler) Handle(_ context.Context, _ slog.Record) error {\n\treturn nil\n}\n\nfunc (n *discardHandler) WithAttrs(_ []slog.Attr) slog.Handler {\n\treturn n\n}\n\nfunc (n *discardHandler) WithGroup(_ string) slog.Handler {\n\treturn n\n}\n"
        },
        {
          "name": "overrides_test.go",
          "type": "blob",
          "size": 6.02,
          "content": "package viper\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/spf13/cast\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype layer int\n\nconst (\n\tdefaultLayer layer = iota + 1\n\toverrideLayer\n)\n\nfunc TestNestedOverrides(t *testing.T) {\n\tassert := assert.New(t)\n\tvar v *Viper\n\n\t// Case 0: value overridden by a value\n\toverrideDefault(assert, \"tom\", 10, \"tom\", 20) // \"tom\" is first given 10 as default value, then overridden by 20\n\toverride(assert, \"tom\", 10, \"tom\", 20)        // \"tom\" is first given value 10, then overridden by 20\n\toverrideDefault(assert, \"tom.age\", 10, \"tom.age\", 20)\n\toverride(assert, \"tom.age\", 10, \"tom.age\", 20)\n\toverrideDefault(assert, \"sawyer.tom.age\", 10, \"sawyer.tom.age\", 20)\n\toverride(assert, \"sawyer.tom.age\", 10, \"sawyer.tom.age\", 20)\n\n\t// Case 1: key:value overridden by a value\n\tv = overrideDefault(assert, \"tom.age\", 10, \"tom\", \"boy\") // \"tom.age\" is first given 10 as default value, then \"tom\" is overridden by \"boy\"\n\tassert.Nil(v.Get(\"tom.age\"))                             // \"tom.age\" should not exist anymore\n\tv = override(assert, \"tom.age\", 10, \"tom\", \"boy\")\n\tassert.Nil(v.Get(\"tom.age\"))\n\n\t// Case 2: value overridden by a key:value\n\toverrideDefault(assert, \"tom\", \"boy\", \"tom.age\", 10) // \"tom\" is first given \"boy\" as default value, then \"tom\" is overridden by map{\"age\":10}\n\toverride(assert, \"tom.age\", 10, \"tom\", \"boy\")\n\n\t// Case 3: key:value overridden by a key:value\n\tv = overrideDefault(assert, \"tom.size\", 4, \"tom.age\", 10)\n\tassert.Equal(4, v.Get(\"tom.size\")) // value should still be reachable\n\tv = override(assert, \"tom.size\", 4, \"tom.age\", 10)\n\tassert.Equal(4, v.Get(\"tom.size\"))\n\tdeepCheckValue(assert, v, overrideLayer, []string{\"tom\", \"size\"}, 4)\n\n\t// Case 4: key:value overridden by a map\n\tv = overrideDefault(assert, \"tom.size\", 4, \"tom\", map[string]any{\"age\": 10}) // \"tom.size\" is first given \"4\" as default value, then \"tom\" is overridden by map{\"age\":10}\n\tassert.Equal(4, v.Get(\"tom.size\"))                                           // \"tom.size\" should still be reachable\n\tassert.Equal(10, v.Get(\"tom.age\"))                                           // new value should be there\n\tdeepCheckValue(assert, v, overrideLayer, []string{\"tom\", \"age\"}, 10)         // new value should be there\n\tv = override(assert, \"tom.size\", 4, \"tom\", map[string]any{\"age\": 10})\n\tassert.Nil(v.Get(\"tom.size\"))\n\tassert.Equal(10, v.Get(\"tom.age\"))\n\tdeepCheckValue(assert, v, overrideLayer, []string{\"tom\", \"age\"}, 10)\n\n\t// Case 5: array overridden by a value\n\toverrideDefault(assert, \"tom\", []int{10, 20}, \"tom\", 30)\n\toverride(assert, \"tom\", []int{10, 20}, \"tom\", 30)\n\toverrideDefault(assert, \"tom.age\", []int{10, 20}, \"tom.age\", 30)\n\toverride(assert, \"tom.age\", []int{10, 20}, \"tom.age\", 30)\n\n\t// Case 6: array overridden by an array\n\toverrideDefault(assert, \"tom\", []int{10, 20}, \"tom\", []int{30, 40})\n\toverride(assert, \"tom\", []int{10, 20}, \"tom\", []int{30, 40})\n\toverrideDefault(assert, \"tom.age\", []int{10, 20}, \"tom.age\", []int{30, 40})\n\tv = override(assert, \"tom.age\", []int{10, 20}, \"tom.age\", []int{30, 40})\n\t// explicit array merge:\n\ts, ok := v.Get(\"tom.age\").([]int)\n\tif assert.True(ok, \"tom[\\\"age\\\"] is not a slice\") {\n\t\tv.Set(\"tom.age\", append(s, []int{50, 60}...))\n\t\tassert.Equal([]int{30, 40, 50, 60}, v.Get(\"tom.age\"))\n\t\tdeepCheckValue(assert, v, overrideLayer, []string{\"tom\", \"age\"}, []int{30, 40, 50, 60})\n\t}\n}\n\nfunc overrideDefault(assert *assert.Assertions, firstPath string, firstValue any, secondPath string, secondValue any) *Viper {\n\treturn overrideFromLayer(defaultLayer, assert, firstPath, firstValue, secondPath, secondValue)\n}\n\nfunc override(assert *assert.Assertions, firstPath string, firstValue any, secondPath string, secondValue any) *Viper {\n\treturn overrideFromLayer(overrideLayer, assert, firstPath, firstValue, secondPath, secondValue)\n}\n\n// overrideFromLayer performs the sequential override and low-level checks.\n//\n// First assignment is made on layer l for path firstPath with value firstValue,\n// the second one on the override layer (i.e., with the Set() function)\n// for path secondPath with value secondValue.\n//\n// firstPath and secondPath can include an arbitrary number of dots to indicate\n// a nested element.\n//\n// After each assignment, the value is checked, retrieved both by its full path\n// and by its key sequence (successive maps).\nfunc overrideFromLayer(l layer, assert *assert.Assertions, firstPath string, firstValue any, secondPath string, secondValue any) *Viper {\n\tv := New()\n\tfirstKeys := strings.Split(firstPath, v.keyDelim)\n\tif assert == nil ||\n\t\tlen(firstKeys) == 0 || firstKeys[0] == \"\" {\n\t\treturn v\n\t}\n\n\t// Set and check first value\n\tswitch l {\n\tcase defaultLayer:\n\t\tv.SetDefault(firstPath, firstValue)\n\tcase overrideLayer:\n\t\tv.Set(firstPath, firstValue)\n\tdefault:\n\t\treturn v\n\t}\n\tassert.Equal(firstValue, v.Get(firstPath))\n\tdeepCheckValue(assert, v, l, firstKeys, firstValue)\n\n\t// Override and check new value\n\tsecondKeys := strings.Split(secondPath, v.keyDelim)\n\tif len(secondKeys) == 0 || secondKeys[0] == \"\" {\n\t\treturn v\n\t}\n\tv.Set(secondPath, secondValue)\n\tassert.Equal(secondValue, v.Get(secondPath))\n\tdeepCheckValue(assert, v, overrideLayer, secondKeys, secondValue)\n\n\treturn v\n}\n\n// deepCheckValue checks that all given keys correspond to a valid path in the\n// configuration map of the given layer, and that the final value equals the one given.\nfunc deepCheckValue(assert *assert.Assertions, v *Viper, l layer, keys []string, value any) {\n\tif assert == nil || v == nil ||\n\t\tlen(keys) == 0 || keys[0] == \"\" {\n\t\treturn\n\t}\n\n\t// init\n\tvar val any\n\tvar ms string\n\tswitch l {\n\tcase defaultLayer:\n\t\tval = v.defaults\n\t\tms = \"v.defaults\"\n\tcase overrideLayer:\n\t\tval = v.override\n\t\tms = \"v.override\"\n\t}\n\n\t// loop through map\n\tvar m map[string]any\n\tfor _, k := range keys {\n\t\tif val == nil {\n\t\t\tassert.Failf(\"%s is not a map[string]any\", ms)\n\t\t\treturn\n\t\t}\n\n\t\t// deep scan of the map to get the final value\n\t\tswitch val := val.(type) {\n\t\tcase map[any]any:\n\t\t\tm = cast.ToStringMap(val)\n\t\tcase map[string]any:\n\t\t\tm = val\n\t\tdefault:\n\t\t\tassert.Failf(\"%s is not a map[string]any\", ms)\n\t\t\treturn\n\t\t}\n\t\tms = ms + \"[\\\"\" + k + \"\\\"]\"\n\t\tval = m[k]\n\t}\n\tassert.Equal(value, val)\n}\n"
        },
        {
          "name": "remote.go",
          "type": "blob",
          "size": 7.32,
          "content": "package viper\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"slices\"\n)\n\n// SupportedRemoteProviders are universally supported remote providers.\nvar SupportedRemoteProviders = []string{\"etcd\", \"etcd3\", \"consul\", \"firestore\", \"nats\"}\n\nfunc resetRemote() {\n\tSupportedRemoteProviders = []string{\"etcd\", \"etcd3\", \"consul\", \"firestore\", \"nats\"}\n}\n\ntype remoteConfigFactory interface {\n\tGet(rp RemoteProvider) (io.Reader, error)\n\tWatch(rp RemoteProvider) (io.Reader, error)\n\tWatchChannel(rp RemoteProvider) (<-chan *RemoteResponse, chan bool)\n}\n\ntype RemoteResponse struct {\n\tValue []byte\n\tError error\n}\n\n// RemoteConfig is optional, see the remote package.\nvar RemoteConfig remoteConfigFactory\n\n// UnsupportedRemoteProviderError denotes encountering an unsupported remote\n// provider. Currently only etcd and Consul are supported.\ntype UnsupportedRemoteProviderError string\n\n// Error returns the formatted remote provider error.\nfunc (str UnsupportedRemoteProviderError) Error() string {\n\treturn fmt.Sprintf(\"Unsupported Remote Provider Type %q\", string(str))\n}\n\n// RemoteConfigError denotes encountering an error while trying to\n// pull the configuration from the remote provider.\ntype RemoteConfigError string\n\n// Error returns the formatted remote provider error.\nfunc (rce RemoteConfigError) Error() string {\n\treturn fmt.Sprintf(\"Remote Configurations Error: %s\", string(rce))\n}\n\ntype defaultRemoteProvider struct {\n\tprovider      string\n\tendpoint      string\n\tpath          string\n\tsecretKeyring string\n}\n\nfunc (rp defaultRemoteProvider) Provider() string {\n\treturn rp.provider\n}\n\nfunc (rp defaultRemoteProvider) Endpoint() string {\n\treturn rp.endpoint\n}\n\nfunc (rp defaultRemoteProvider) Path() string {\n\treturn rp.path\n}\n\nfunc (rp defaultRemoteProvider) SecretKeyring() string {\n\treturn rp.secretKeyring\n}\n\n// RemoteProvider stores the configuration necessary\n// to connect to a remote key/value store.\n// Optional secretKeyring to unencrypt encrypted values\n// can be provided.\ntype RemoteProvider interface {\n\tProvider() string\n\tEndpoint() string\n\tPath() string\n\tSecretKeyring() string\n}\n\n// AddRemoteProvider adds a remote configuration source.\n// Remote Providers are searched in the order they are added.\n// provider is a string value: \"etcd\", \"etcd3\", \"consul\", \"firestore\" or \"nats\" are currently supported.\n// endpoint is the url.  etcd requires http://ip:port, consul requires ip:port, nats requires nats://ip:port\n// path is the path in the k/v store to retrieve configuration\n// To retrieve a config file called myapp.json from /configs/myapp.json\n// you should set path to /configs and set config name (SetConfigName()) to\n// \"myapp\".\nfunc AddRemoteProvider(provider, endpoint, path string) error {\n\treturn v.AddRemoteProvider(provider, endpoint, path)\n}\n\nfunc (v *Viper) AddRemoteProvider(provider, endpoint, path string) error {\n\tif !slices.Contains(SupportedRemoteProviders, provider) {\n\t\treturn UnsupportedRemoteProviderError(provider)\n\t}\n\tif provider != \"\" && endpoint != \"\" {\n\t\tv.logger.Info(\"adding remote provider\", \"provider\", provider, \"endpoint\", endpoint)\n\n\t\trp := &defaultRemoteProvider{\n\t\t\tendpoint: endpoint,\n\t\t\tprovider: provider,\n\t\t\tpath:     path,\n\t\t}\n\t\tif !v.providerPathExists(rp) {\n\t\t\tv.remoteProviders = append(v.remoteProviders, rp)\n\t\t}\n\t}\n\treturn nil\n}\n\n// AddSecureRemoteProvider adds a remote configuration source.\n// Secure Remote Providers are searched in the order they are added.\n// provider is a string value: \"etcd\", \"etcd3\", \"consul\", \"firestore\" or \"nats\" are currently supported.\n// endpoint is the url.  etcd requires http://ip:port  consul requires ip:port\n// secretkeyring is the filepath to your openpgp secret keyring.  e.g. /etc/secrets/myring.gpg\n// path is the path in the k/v store to retrieve configuration\n// To retrieve a config file called myapp.json from /configs/myapp.json\n// you should set path to /configs and set config name (SetConfigName()) to\n// \"myapp\".\n// Secure Remote Providers are implemented with github.com/sagikazarmark/crypt.\nfunc AddSecureRemoteProvider(provider, endpoint, path, secretkeyring string) error {\n\treturn v.AddSecureRemoteProvider(provider, endpoint, path, secretkeyring)\n}\n\nfunc (v *Viper) AddSecureRemoteProvider(provider, endpoint, path, secretkeyring string) error {\n\tif !slices.Contains(SupportedRemoteProviders, provider) {\n\t\treturn UnsupportedRemoteProviderError(provider)\n\t}\n\tif provider != \"\" && endpoint != \"\" {\n\t\tv.logger.Info(\"adding remote provider\", \"provider\", provider, \"endpoint\", endpoint)\n\n\t\trp := &defaultRemoteProvider{\n\t\t\tendpoint:      endpoint,\n\t\t\tprovider:      provider,\n\t\t\tpath:          path,\n\t\t\tsecretKeyring: secretkeyring,\n\t\t}\n\t\tif !v.providerPathExists(rp) {\n\t\t\tv.remoteProviders = append(v.remoteProviders, rp)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (v *Viper) providerPathExists(p *defaultRemoteProvider) bool {\n\tfor _, y := range v.remoteProviders {\n\t\tif reflect.DeepEqual(y, p) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ReadRemoteConfig attempts to get configuration from a remote source\n// and read it in the remote configuration registry.\nfunc ReadRemoteConfig() error { return v.ReadRemoteConfig() }\n\nfunc (v *Viper) ReadRemoteConfig() error {\n\treturn v.getKeyValueConfig()\n}\n\nfunc WatchRemoteConfig() error { return v.WatchRemoteConfig() }\nfunc (v *Viper) WatchRemoteConfig() error {\n\treturn v.watchKeyValueConfig()\n}\n\nfunc (v *Viper) WatchRemoteConfigOnChannel() error {\n\treturn v.watchKeyValueConfigOnChannel()\n}\n\n// Retrieve the first found remote configuration.\nfunc (v *Viper) getKeyValueConfig() error {\n\tif RemoteConfig == nil {\n\t\treturn RemoteConfigError(\"Enable the remote features by doing a blank import of the viper/remote package: '_ github.com/spf13/viper/remote'\")\n\t}\n\n\tif len(v.remoteProviders) == 0 {\n\t\treturn RemoteConfigError(\"No Remote Providers\")\n\t}\n\n\tfor _, rp := range v.remoteProviders {\n\t\tval, err := v.getRemoteConfig(rp)\n\t\tif err != nil {\n\t\t\tv.logger.Error(fmt.Errorf(\"get remote config: %w\", err).Error())\n\n\t\t\tcontinue\n\t\t}\n\n\t\tv.kvstore = val\n\n\t\treturn nil\n\t}\n\treturn RemoteConfigError(\"No Files Found\")\n}\n\nfunc (v *Viper) getRemoteConfig(provider RemoteProvider) (map[string]any, error) {\n\treader, err := RemoteConfig.Get(provider)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = v.unmarshalReader(reader, v.kvstore)\n\treturn v.kvstore, err\n}\n\n// Retrieve the first found remote configuration.\nfunc (v *Viper) watchKeyValueConfigOnChannel() error {\n\tif len(v.remoteProviders) == 0 {\n\t\treturn RemoteConfigError(\"No Remote Providers\")\n\t}\n\n\tfor _, rp := range v.remoteProviders {\n\t\trespc, _ := RemoteConfig.WatchChannel(rp)\n\t\t// Todo: Add quit channel\n\t\tgo func(rc <-chan *RemoteResponse) {\n\t\t\tfor {\n\t\t\t\tb := <-rc\n\t\t\t\treader := bytes.NewReader(b.Value)\n\t\t\t\tv.unmarshalReader(reader, v.kvstore)\n\t\t\t}\n\t\t}(respc)\n\t\treturn nil\n\t}\n\treturn RemoteConfigError(\"No Files Found\")\n}\n\n// Retrieve the first found remote configuration.\nfunc (v *Viper) watchKeyValueConfig() error {\n\tif len(v.remoteProviders) == 0 {\n\t\treturn RemoteConfigError(\"No Remote Providers\")\n\t}\n\n\tfor _, rp := range v.remoteProviders {\n\t\tval, err := v.watchRemoteConfig(rp)\n\t\tif err != nil {\n\t\t\tv.logger.Error(fmt.Errorf(\"watch remote config: %w\", err).Error())\n\n\t\t\tcontinue\n\t\t}\n\t\tv.kvstore = val\n\t\treturn nil\n\t}\n\treturn RemoteConfigError(\"No Files Found\")\n}\n\nfunc (v *Viper) watchRemoteConfig(provider RemoteProvider) (map[string]any, error) {\n\treader, err := RemoteConfig.Watch(provider)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = v.unmarshalReader(reader, v.kvstore)\n\treturn v.kvstore, err\n}\n"
        },
        {
          "name": "remote",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 4.91,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n// Viper is a application configuration system.\n// It believes that applications can be configured a variety of ways\n// via flags, ENVIRONMENT variables, configuration files retrieved\n// from the file system, or a remote key/value store.\n\npackage viper\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/spf13/cast\"\n)\n\n// ConfigParseError denotes failing to parse configuration file.\ntype ConfigParseError struct {\n\terr error\n}\n\n// Error returns the formatted configuration error.\nfunc (pe ConfigParseError) Error() string {\n\treturn fmt.Sprintf(\"While parsing config: %s\", pe.err.Error())\n}\n\n// Unwrap returns the wrapped error.\nfunc (pe ConfigParseError) Unwrap() error {\n\treturn pe.err\n}\n\n// toCaseInsensitiveValue checks if the value is a  map;\n// if so, create a copy and lower-case the keys recursively.\nfunc toCaseInsensitiveValue(value any) any {\n\tswitch v := value.(type) {\n\tcase map[any]any:\n\t\tvalue = copyAndInsensitiviseMap(cast.ToStringMap(v))\n\tcase map[string]any:\n\t\tvalue = copyAndInsensitiviseMap(v)\n\t}\n\n\treturn value\n}\n\n// copyAndInsensitiviseMap behaves like insensitiviseMap, but creates a copy of\n// any map it makes case insensitive.\nfunc copyAndInsensitiviseMap(m map[string]any) map[string]any {\n\tnm := make(map[string]any)\n\n\tfor key, val := range m {\n\t\tlkey := strings.ToLower(key)\n\t\tswitch v := val.(type) {\n\t\tcase map[any]any:\n\t\t\tnm[lkey] = copyAndInsensitiviseMap(cast.ToStringMap(v))\n\t\tcase map[string]any:\n\t\t\tnm[lkey] = copyAndInsensitiviseMap(v)\n\t\tdefault:\n\t\t\tnm[lkey] = v\n\t\t}\n\t}\n\n\treturn nm\n}\n\nfunc insensitiviseVal(val any) any {\n\tswitch v := val.(type) {\n\tcase map[any]any:\n\t\t// nested map: cast and recursively insensitivise\n\t\tval = cast.ToStringMap(val)\n\t\tinsensitiviseMap(val.(map[string]any))\n\tcase map[string]any:\n\t\t// nested map: recursively insensitivise\n\t\tinsensitiviseMap(v)\n\tcase []any:\n\t\t// nested array: recursively insensitivise\n\t\tinsensitiveArray(v)\n\t}\n\treturn val\n}\n\nfunc insensitiviseMap(m map[string]any) {\n\tfor key, val := range m {\n\t\tval = insensitiviseVal(val)\n\t\tlower := strings.ToLower(key)\n\t\tif key != lower {\n\t\t\t// remove old key (not lower-cased)\n\t\t\tdelete(m, key)\n\t\t}\n\t\t// update map\n\t\tm[lower] = val\n\t}\n}\n\nfunc insensitiveArray(a []any) {\n\tfor i, val := range a {\n\t\ta[i] = insensitiviseVal(val)\n\t}\n}\n\nfunc absPathify(logger *slog.Logger, inPath string) string {\n\tlogger.Info(\"trying to resolve absolute path\", \"path\", inPath)\n\n\tif inPath == \"$HOME\" || strings.HasPrefix(inPath, \"$HOME\"+string(os.PathSeparator)) {\n\t\tinPath = userHomeDir() + inPath[5:]\n\t}\n\n\tinPath = os.ExpandEnv(inPath)\n\n\tif filepath.IsAbs(inPath) {\n\t\treturn filepath.Clean(inPath)\n\t}\n\n\tp, err := filepath.Abs(inPath)\n\tif err == nil {\n\t\treturn filepath.Clean(p)\n\t}\n\n\tlogger.Error(fmt.Errorf(\"could not discover absolute path: %w\", err).Error())\n\n\treturn \"\"\n}\n\nfunc userHomeDir() string {\n\tif runtime.GOOS == \"windows\" {\n\t\thome := os.Getenv(\"HOMEDRIVE\") + os.Getenv(\"HOMEPATH\")\n\t\tif home == \"\" {\n\t\t\thome = os.Getenv(\"USERPROFILE\")\n\t\t}\n\t\treturn home\n\t}\n\treturn os.Getenv(\"HOME\")\n}\n\nfunc safeMul(a, b uint) uint {\n\tc := a * b\n\tif a > 1 && b > 1 && c/b != a {\n\t\treturn 0\n\t}\n\treturn c\n}\n\n// parseSizeInBytes converts strings like 1GB or 12 mb into an unsigned integer number of bytes.\nfunc parseSizeInBytes(sizeStr string) uint {\n\tsizeStr = strings.TrimSpace(sizeStr)\n\tlastChar := len(sizeStr) - 1\n\tmultiplier := uint(1)\n\n\tif lastChar > 0 {\n\t\tif sizeStr[lastChar] == 'b' || sizeStr[lastChar] == 'B' {\n\t\t\tif lastChar > 1 {\n\t\t\t\tswitch unicode.ToLower(rune(sizeStr[lastChar-1])) {\n\t\t\t\tcase 'k':\n\t\t\t\t\tmultiplier = 1 << 10\n\t\t\t\t\tsizeStr = strings.TrimSpace(sizeStr[:lastChar-1])\n\t\t\t\tcase 'm':\n\t\t\t\t\tmultiplier = 1 << 20\n\t\t\t\t\tsizeStr = strings.TrimSpace(sizeStr[:lastChar-1])\n\t\t\t\tcase 'g':\n\t\t\t\t\tmultiplier = 1 << 30\n\t\t\t\t\tsizeStr = strings.TrimSpace(sizeStr[:lastChar-1])\n\t\t\t\tdefault:\n\t\t\t\t\tmultiplier = 1\n\t\t\t\t\tsizeStr = strings.TrimSpace(sizeStr[:lastChar])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsize := cast.ToInt(sizeStr)\n\tif size < 0 {\n\t\tsize = 0\n\t}\n\n\treturn safeMul(uint(size), multiplier)\n}\n\n// deepSearch scans deep maps, following the key indexes listed in the\n// sequence \"path\".\n// The last value is expected to be another map, and is returned.\n//\n// In case intermediate keys do not exist, or map to a non-map value,\n// a new map is created and inserted, and the search continues from there:\n// the initial map \"m\" may be modified!\nfunc deepSearch(m map[string]any, path []string) map[string]any {\n\tfor _, k := range path {\n\t\tm2, ok := m[k]\n\t\tif !ok {\n\t\t\t// intermediate key does not exist\n\t\t\t// => create it and continue from there\n\t\t\tm3 := make(map[string]any)\n\t\t\tm[k] = m3\n\t\t\tm = m3\n\t\t\tcontinue\n\t\t}\n\t\tm3, ok := m2.(map[string]any)\n\t\tif !ok {\n\t\t\t// intermediate key is a value\n\t\t\t// => replace with a new map\n\t\t\tm3 = make(map[string]any)\n\t\t\tm[k] = m3\n\t\t}\n\t\t// continue search from here\n\t\tm = m3\n\t}\n\treturn m\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 1.9,
          "content": "// Copyright © 2016 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n// Viper is a application configuration system.\n// It believes that applications can be configured a variety of ways\n// via flags, ENVIRONMENT variables, configuration files retrieved\n// from the file system, or a remote key/value store.\n\npackage viper\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCopyAndInsensitiviseMap(t *testing.T) {\n\tvar (\n\t\tgiven = map[string]any{\n\t\t\t\"Foo\": 32,\n\t\t\t\"Bar\": map[any]any{\n\t\t\t\t\"ABc\": \"A\",\n\t\t\t\t\"cDE\": \"B\",\n\t\t\t},\n\t\t}\n\t\texpected = map[string]any{\n\t\t\t\"foo\": 32,\n\t\t\t\"bar\": map[string]any{\n\t\t\t\t\"abc\": \"A\",\n\t\t\t\t\"cde\": \"B\",\n\t\t\t},\n\t\t}\n\t)\n\n\tgot := copyAndInsensitiviseMap(given)\n\n\tassert.Equal(t, expected, got)\n\t_, ok := given[\"foo\"]\n\tassert.False(t, ok)\n\t_, ok = given[\"bar\"]\n\tassert.False(t, ok)\n\n\tm := given[\"Bar\"].(map[any]any)\n\t_, ok = m[\"ABc\"]\n\tassert.True(t, ok)\n}\n\nfunc TestAbsPathify(t *testing.T) {\n\tskipWindows(t)\n\n\thome := userHomeDir()\n\thomer := filepath.Join(home, \"homer\")\n\twd, _ := os.Getwd()\n\n\tt.Setenv(\"HOMER_ABSOLUTE_PATH\", homer)\n\tt.Setenv(\"VAR_WITH_RELATIVE_PATH\", \"relative\")\n\n\ttests := []struct {\n\t\tinput  string\n\t\toutput string\n\t}{\n\t\t{\"\", wd},\n\t\t{\"sub\", filepath.Join(wd, \"sub\")},\n\t\t{\"./\", wd},\n\t\t{\"./sub\", filepath.Join(wd, \"sub\")},\n\t\t{\"$HOME\", home},\n\t\t{\"$HOME/\", home},\n\t\t{\"$HOME/sub\", filepath.Join(home, \"sub\")},\n\t\t{\"$HOMER_ABSOLUTE_PATH\", homer},\n\t\t{\"$HOMER_ABSOLUTE_PATH/\", homer},\n\t\t{\"$HOMER_ABSOLUTE_PATH/sub\", filepath.Join(homer, \"sub\")},\n\t\t{\"$VAR_WITH_RELATIVE_PATH\", filepath.Join(wd, \"relative\")},\n\t\t{\"$VAR_WITH_RELATIVE_PATH/\", filepath.Join(wd, \"relative\")},\n\t\t{\"$VAR_WITH_RELATIVE_PATH/sub\", filepath.Join(wd, \"relative\", \"sub\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := absPathify(slog.Default(), test.input)\n\t\tassert.Equal(t, test.output, got)\n\t}\n}\n"
        },
        {
          "name": "viper.go",
          "type": "blob",
          "size": 55.28,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n// Viper is an application configuration system.\n// It believes that applications can be configured a variety of ways\n// via flags, ENVIRONMENT variables, configuration files retrieved\n// from the file system, or a remote key/value store.\n\n// Each item takes precedence over the item below it:\n\n// overrides\n// flag\n// env\n// config\n// key/value store\n// default\n\npackage viper\n\nimport (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/go-viper/mapstructure/v2\"\n\t\"github.com/spf13/afero\"\n\t\"github.com/spf13/cast\"\n\t\"github.com/spf13/pflag\"\n\n\t\"github.com/spf13/viper/internal/features\"\n)\n\n// ConfigMarshalError happens when failing to marshal the configuration.\ntype ConfigMarshalError struct {\n\terr error\n}\n\n// Error returns the formatted configuration error.\nfunc (e ConfigMarshalError) Error() string {\n\treturn fmt.Sprintf(\"While marshaling config: %s\", e.err.Error())\n}\n\nvar v *Viper\n\nfunc init() {\n\tv = New()\n}\n\n// UnsupportedConfigError denotes encountering an unsupported\n// configuration filetype.\ntype UnsupportedConfigError string\n\n// Error returns the formatted configuration error.\nfunc (str UnsupportedConfigError) Error() string {\n\treturn fmt.Sprintf(\"Unsupported Config Type %q\", string(str))\n}\n\n// ConfigFileNotFoundError denotes failing to find configuration file.\ntype ConfigFileNotFoundError struct {\n\tname, locations string\n}\n\n// Error returns the formatted configuration error.\nfunc (fnfe ConfigFileNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"Config File %q Not Found in %q\", fnfe.name, fnfe.locations)\n}\n\n// ConfigFileAlreadyExistsError denotes failure to write new configuration file.\ntype ConfigFileAlreadyExistsError string\n\n// Error returns the formatted error when configuration already exists.\nfunc (faee ConfigFileAlreadyExistsError) Error() string {\n\treturn fmt.Sprintf(\"Config File %q Already Exists\", string(faee))\n}\n\n// A DecoderConfigOption can be passed to viper.Unmarshal to configure\n// mapstructure.DecoderConfig options.\ntype DecoderConfigOption func(*mapstructure.DecoderConfig)\n\n// DecodeHook returns a DecoderConfigOption which overrides the default\n// DecoderConfig.DecodeHook value, the default is:\n//\n//\t mapstructure.ComposeDecodeHookFunc(\n//\t\t\tmapstructure.StringToTimeDurationHookFunc(),\n//\t\t\tmapstructure.StringToSliceHookFunc(\",\"),\n//\t\t)\nfunc DecodeHook(hook mapstructure.DecodeHookFunc) DecoderConfigOption {\n\treturn func(c *mapstructure.DecoderConfig) {\n\t\tc.DecodeHook = hook\n\t}\n}\n\n// Viper is a prioritized configuration registry. It\n// maintains a set of configuration sources, fetches\n// values to populate those, and provides them according\n// to the source's priority.\n// The priority of the sources is the following:\n// 1. overrides\n// 2. flags\n// 3. env. variables\n// 4. config file\n// 5. key/value store\n// 6. defaults\n//\n// For example, if values from the following sources were loaded:\n//\n//\tDefaults : {\n//\t\t\"secret\": \"\",\n//\t\t\"user\": \"default\",\n//\t\t\"endpoint\": \"https://localhost\"\n//\t}\n//\tConfig : {\n//\t\t\"user\": \"root\"\n//\t\t\"secret\": \"defaultsecret\"\n//\t}\n//\tEnv : {\n//\t\t\"secret\": \"somesecretkey\"\n//\t}\n//\n// The resulting config will have the following values:\n//\n//\t{\n//\t\t\"secret\": \"somesecretkey\",\n//\t\t\"user\": \"root\",\n//\t\t\"endpoint\": \"https://localhost\"\n//\t}\n//\n// Note: Vipers are not safe for concurrent Get() and Set() operations.\ntype Viper struct {\n\t// Delimiter that separates a list of keys\n\t// used to access a nested value in one go\n\tkeyDelim string\n\n\t// A set of paths to look for the config file in\n\tconfigPaths []string\n\n\t// The filesystem to read config from.\n\tfs afero.Fs\n\n\tfinder Finder\n\n\t// A set of remote providers to search for the configuration\n\tremoteProviders []*defaultRemoteProvider\n\n\t// Name of file to look for inside the path\n\tconfigName        string\n\tconfigFile        string\n\tconfigType        string\n\tconfigPermissions os.FileMode\n\tenvPrefix         string\n\n\tautomaticEnvApplied bool\n\tenvKeyReplacer      StringReplacer\n\tallowEmptyEnv       bool\n\n\tparents        []string\n\tconfig         map[string]any\n\toverride       map[string]any\n\tdefaults       map[string]any\n\tkvstore        map[string]any\n\tpflags         map[string]FlagValue\n\tenv            map[string][]string\n\taliases        map[string]string\n\ttypeByDefValue bool\n\n\tonConfigChange func(fsnotify.Event)\n\n\tlogger *slog.Logger\n\n\tencoderRegistry EncoderRegistry\n\tdecoderRegistry DecoderRegistry\n\n\tdecodeHook mapstructure.DecodeHookFunc\n\n\texperimentalFinder     bool\n\texperimentalBindStruct bool\n}\n\n// New returns an initialized Viper instance.\nfunc New() *Viper {\n\tv := new(Viper)\n\tv.keyDelim = \".\"\n\tv.configName = \"config\"\n\tv.configPermissions = os.FileMode(0o644)\n\tv.fs = afero.NewOsFs()\n\tv.config = make(map[string]any)\n\tv.parents = []string{}\n\tv.override = make(map[string]any)\n\tv.defaults = make(map[string]any)\n\tv.kvstore = make(map[string]any)\n\tv.pflags = make(map[string]FlagValue)\n\tv.env = make(map[string][]string)\n\tv.aliases = make(map[string]string)\n\tv.typeByDefValue = false\n\tv.logger = slog.New(&discardHandler{})\n\n\tcodecRegistry := NewCodecRegistry()\n\n\tv.encoderRegistry = codecRegistry\n\tv.decoderRegistry = codecRegistry\n\n\tv.experimentalFinder = features.Finder\n\tv.experimentalBindStruct = features.BindStruct\n\n\treturn v\n}\n\n// Option configures Viper using the functional options paradigm popularized by Rob Pike and Dave Cheney.\n// If you're unfamiliar with this style,\n// see https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html and\n// https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis.\ntype Option interface {\n\tapply(v *Viper)\n}\n\ntype optionFunc func(v *Viper)\n\nfunc (fn optionFunc) apply(v *Viper) {\n\tfn(v)\n}\n\n// KeyDelimiter sets the delimiter used for determining key parts.\n// By default it's value is \".\".\nfunc KeyDelimiter(d string) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tv.keyDelim = d\n\t})\n}\n\n// StringReplacer applies a set of replacements to a string.\ntype StringReplacer interface {\n\t// Replace returns a copy of s with all replacements performed.\n\tReplace(s string) string\n}\n\n// EnvKeyReplacer sets a replacer used for mapping environment variables to internal keys.\nfunc EnvKeyReplacer(r StringReplacer) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tif r == nil {\n\t\t\treturn\n\t\t}\n\n\t\tv.envKeyReplacer = r\n\t})\n}\n\n// WithDecodeHook sets a default decode hook for mapstructure.\nfunc WithDecodeHook(h mapstructure.DecodeHookFunc) Option {\n\treturn optionFunc(func(v *Viper) {\n\t\tif h == nil {\n\t\t\treturn\n\t\t}\n\n\t\tv.decodeHook = h\n\t})\n}\n\n// NewWithOptions creates a new Viper instance.\nfunc NewWithOptions(opts ...Option) *Viper {\n\tv := New()\n\n\tfor _, opt := range opts {\n\t\topt.apply(v)\n\t}\n\n\treturn v\n}\n\n// SetOptions sets the options on the global Viper instance.\n//\n// Be careful when using this function: subsequent calls may override options you set.\n// It's always better to use a local Viper instance.\nfunc SetOptions(opts ...Option) {\n\tfor _, opt := range opts {\n\t\topt.apply(v)\n\t}\n}\n\n// Reset is intended for testing, will reset all to default settings.\n// In the public interface for the viper package so applications\n// can use it in their testing as well.\nfunc Reset() {\n\tv = New()\n\tSupportedExts = []string{\"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"hcl\", \"tfvars\", \"dotenv\", \"env\", \"ini\"}\n\n\tresetRemote()\n}\n\n// SupportedExts are universally supported extensions.\nvar SupportedExts = []string{\"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"hcl\", \"tfvars\", \"dotenv\", \"env\", \"ini\"}\n\n// OnConfigChange sets the event handler that is called when a config file changes.\nfunc OnConfigChange(run func(in fsnotify.Event)) { v.OnConfigChange(run) }\n\n// OnConfigChange sets the event handler that is called when a config file changes.\nfunc (v *Viper) OnConfigChange(run func(in fsnotify.Event)) {\n\tv.onConfigChange = run\n}\n\n// WatchConfig starts watching a config file for changes.\nfunc WatchConfig() { v.WatchConfig() }\n\n// WatchConfig starts watching a config file for changes.\nfunc (v *Viper) WatchConfig() {\n\tinitWG := sync.WaitGroup{}\n\tinitWG.Add(1)\n\tgo func() {\n\t\twatcher, err := fsnotify.NewWatcher()\n\t\tif err != nil {\n\t\t\tv.logger.Error(fmt.Sprintf(\"failed to create watcher: %s\", err))\n\t\t\tos.Exit(1)\n\t\t}\n\t\tdefer watcher.Close()\n\t\t// we have to watch the entire directory to pick up renames/atomic saves in a cross-platform way\n\t\tfilename, err := v.getConfigFile()\n\t\tif err != nil {\n\t\t\tv.logger.Error(fmt.Sprintf(\"get config file: %s\", err))\n\t\t\tinitWG.Done()\n\t\t\treturn\n\t\t}\n\n\t\tconfigFile := filepath.Clean(filename)\n\t\tconfigDir, _ := filepath.Split(configFile)\n\t\trealConfigFile, _ := filepath.EvalSymlinks(filename)\n\n\t\teventsWG := sync.WaitGroup{}\n\t\teventsWG.Add(1)\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase event, ok := <-watcher.Events:\n\t\t\t\t\tif !ok { // 'Events' channel is closed\n\t\t\t\t\t\teventsWG.Done()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcurrentConfigFile, _ := filepath.EvalSymlinks(filename)\n\t\t\t\t\t// we only care about the config file with the following cases:\n\t\t\t\t\t// 1 - if the config file was modified or created\n\t\t\t\t\t// 2 - if the real path to the config file changed (eg: k8s ConfigMap replacement)\n\t\t\t\t\tif (filepath.Clean(event.Name) == configFile &&\n\t\t\t\t\t\t(event.Has(fsnotify.Write) || event.Has(fsnotify.Create))) ||\n\t\t\t\t\t\t(currentConfigFile != \"\" && currentConfigFile != realConfigFile) {\n\t\t\t\t\t\trealConfigFile = currentConfigFile\n\t\t\t\t\t\terr := v.ReadInConfig()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tv.logger.Error(fmt.Sprintf(\"read config file: %s\", err))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif v.onConfigChange != nil {\n\t\t\t\t\t\t\tv.onConfigChange(event)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if filepath.Clean(event.Name) == configFile && event.Has(fsnotify.Remove) {\n\t\t\t\t\t\teventsWG.Done()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\tcase err, ok := <-watcher.Errors:\n\t\t\t\t\tif ok { // 'Errors' channel is not closed\n\t\t\t\t\t\tv.logger.Error(fmt.Sprintf(\"watcher error: %s\", err))\n\t\t\t\t\t}\n\t\t\t\t\teventsWG.Done()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\twatcher.Add(configDir)\n\t\tinitWG.Done()   // done initializing the watch in this go routine, so the parent routine can move on...\n\t\teventsWG.Wait() // now, wait for event loop to end in this go-routine...\n\t}()\n\tinitWG.Wait() // make sure that the go routine above fully ended before returning\n}\n\n// SetConfigFile explicitly defines the path, name and extension of the config file.\n// Viper will use this and not check any of the config paths.\nfunc SetConfigFile(in string) { v.SetConfigFile(in) }\n\nfunc (v *Viper) SetConfigFile(in string) {\n\tif in != \"\" {\n\t\tv.configFile = in\n\t}\n}\n\n// SetEnvPrefix defines a prefix that ENVIRONMENT variables will use.\n// E.g. if your prefix is \"spf\", the env registry will look for env\n// variables that start with \"SPF_\".\nfunc SetEnvPrefix(in string) { v.SetEnvPrefix(in) }\n\nfunc (v *Viper) SetEnvPrefix(in string) {\n\tif in != \"\" {\n\t\tv.envPrefix = in\n\t}\n}\n\nfunc GetEnvPrefix() string { return v.GetEnvPrefix() }\n\nfunc (v *Viper) GetEnvPrefix() string {\n\treturn v.envPrefix\n}\n\nfunc (v *Viper) mergeWithEnvPrefix(in string) string {\n\tif v.envPrefix != \"\" {\n\t\treturn strings.ToUpper(v.envPrefix + \"_\" + in)\n\t}\n\n\treturn strings.ToUpper(in)\n}\n\n// AllowEmptyEnv tells Viper to consider set,\n// but empty environment variables as valid values instead of falling back.\n// For backward compatibility reasons this is false by default.\nfunc AllowEmptyEnv(allowEmptyEnv bool) { v.AllowEmptyEnv(allowEmptyEnv) }\n\nfunc (v *Viper) AllowEmptyEnv(allowEmptyEnv bool) {\n\tv.allowEmptyEnv = allowEmptyEnv\n}\n\n// TODO: should getEnv logic be moved into find(). Can generalize the use of\n// rewriting keys many things, Ex: Get('someKey') -> some_key\n// (camel case to snake case for JSON keys perhaps)\n\n// getEnv is a wrapper around os.Getenv which replaces characters in the original\n// key. This allows env vars which have different keys than the config object\n// keys.\nfunc (v *Viper) getEnv(key string) (string, bool) {\n\tif v.envKeyReplacer != nil {\n\t\tkey = v.envKeyReplacer.Replace(key)\n\t}\n\n\tval, ok := os.LookupEnv(key)\n\n\treturn val, ok && (v.allowEmptyEnv || val != \"\")\n}\n\n// ConfigFileUsed returns the file used to populate the config registry.\nfunc ConfigFileUsed() string            { return v.ConfigFileUsed() }\nfunc (v *Viper) ConfigFileUsed() string { return v.configFile }\n\n// AddConfigPath adds a path for Viper to search for the config file in.\n// Can be called multiple times to define multiple search paths.\nfunc AddConfigPath(in string) { v.AddConfigPath(in) }\n\nfunc (v *Viper) AddConfigPath(in string) {\n\tif v.finder != nil {\n\t\tv.logger.Warn(\"ineffective call to function: custom finder takes precedence\", slog.String(\"function\", \"AddConfigPath\"))\n\t}\n\n\tif in != \"\" {\n\t\tabsin := absPathify(v.logger, in)\n\n\t\tv.logger.Info(\"adding path to search paths\", \"path\", absin)\n\t\tif !slices.Contains(v.configPaths, absin) {\n\t\t\tv.configPaths = append(v.configPaths, absin)\n\t\t}\n\t}\n}\n\n// searchMap recursively searches for a value for path in source map.\n// Returns nil if not found.\n// Note: This assumes that the path entries and map keys are lower cased.\nfunc (v *Viper) searchMap(source map[string]any, path []string) any {\n\tif len(path) == 0 {\n\t\treturn source\n\t}\n\n\tnext, ok := source[path[0]]\n\tif ok {\n\t\t// Fast path\n\t\tif len(path) == 1 {\n\t\t\treturn next\n\t\t}\n\n\t\t// Nested case\n\t\tswitch next := next.(type) {\n\t\tcase map[any]any:\n\t\t\treturn v.searchMap(cast.ToStringMap(next), path[1:])\n\t\tcase map[string]any:\n\t\t\t// Type assertion is safe here since it is only reached\n\t\t\t// if the type of `next` is the same as the type being asserted\n\t\t\treturn v.searchMap(next, path[1:])\n\t\tdefault:\n\t\t\t// got a value but nested key expected, return \"nil\" for not found\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\n// searchIndexableWithPathPrefixes recursively searches for a value for path in source map/slice.\n//\n// While searchMap() considers each path element as a single map key or slice index, this\n// function searches for, and prioritizes, merged path elements.\n// e.g., if in the source, \"foo\" is defined with a sub-key \"bar\", and \"foo.bar\"\n// is also defined, this latter value is returned for path [\"foo\", \"bar\"].\n//\n// This should be useful only at config level (other maps may not contain dots\n// in their keys).\n//\n// Note: This assumes that the path entries and map keys are lower cased.\nfunc (v *Viper) searchIndexableWithPathPrefixes(source any, path []string) any {\n\tif len(path) == 0 {\n\t\treturn source\n\t}\n\n\t// search for path prefixes, starting from the longest one\n\tfor i := len(path); i > 0; i-- {\n\t\tprefixKey := strings.ToLower(strings.Join(path[0:i], v.keyDelim))\n\n\t\tvar val any\n\t\tswitch sourceIndexable := source.(type) {\n\t\tcase []any:\n\t\t\tval = v.searchSliceWithPathPrefixes(sourceIndexable, prefixKey, i, path)\n\t\tcase map[string]any:\n\t\t\tval = v.searchMapWithPathPrefixes(sourceIndexable, prefixKey, i, path)\n\t\t}\n\t\tif val != nil {\n\t\t\treturn val\n\t\t}\n\t}\n\n\t// not found\n\treturn nil\n}\n\n// searchSliceWithPathPrefixes searches for a value for path in sourceSlice\n//\n// This function is part of the searchIndexableWithPathPrefixes recurring search and\n// should not be called directly from functions other than searchIndexableWithPathPrefixes.\nfunc (v *Viper) searchSliceWithPathPrefixes(\n\tsourceSlice []any,\n\tprefixKey string,\n\tpathIndex int,\n\tpath []string,\n) any {\n\t// if the prefixKey is not a number or it is out of bounds of the slice\n\tindex, err := strconv.Atoi(prefixKey)\n\tif err != nil || len(sourceSlice) <= index {\n\t\treturn nil\n\t}\n\n\tnext := sourceSlice[index]\n\n\t// Fast path\n\tif pathIndex == len(path) {\n\t\treturn next\n\t}\n\n\tswitch n := next.(type) {\n\tcase map[any]any:\n\t\treturn v.searchIndexableWithPathPrefixes(cast.ToStringMap(n), path[pathIndex:])\n\tcase map[string]any, []any:\n\t\treturn v.searchIndexableWithPathPrefixes(n, path[pathIndex:])\n\tdefault:\n\t\t// got a value but nested key expected, do nothing and look for next prefix\n\t}\n\n\t// not found\n\treturn nil\n}\n\n// searchMapWithPathPrefixes searches for a value for path in sourceMap\n//\n// This function is part of the searchIndexableWithPathPrefixes recurring search and\n// should not be called directly from functions other than searchIndexableWithPathPrefixes.\nfunc (v *Viper) searchMapWithPathPrefixes(\n\tsourceMap map[string]any,\n\tprefixKey string,\n\tpathIndex int,\n\tpath []string,\n) any {\n\tnext, ok := sourceMap[prefixKey]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t// Fast path\n\tif pathIndex == len(path) {\n\t\treturn next\n\t}\n\n\t// Nested case\n\tswitch n := next.(type) {\n\tcase map[any]any:\n\t\treturn v.searchIndexableWithPathPrefixes(cast.ToStringMap(n), path[pathIndex:])\n\tcase map[string]any, []any:\n\t\treturn v.searchIndexableWithPathPrefixes(n, path[pathIndex:])\n\tdefault:\n\t\t// got a value but nested key expected, do nothing and look for next prefix\n\t}\n\n\t// not found\n\treturn nil\n}\n\n// isPathShadowedInDeepMap makes sure the given path is not shadowed somewhere\n// on its path in the map.\n// e.g., if \"foo.bar\" has a value in the given map, it “shadows”\n//\n//\t\"foo.bar.baz\" in a lower-priority map\nfunc (v *Viper) isPathShadowedInDeepMap(path []string, m map[string]any) string {\n\tvar parentVal any\n\tfor i := 1; i < len(path); i++ {\n\t\tparentVal = v.searchMap(m, path[0:i])\n\t\tif parentVal == nil {\n\t\t\t// not found, no need to add more path elements\n\t\t\treturn \"\"\n\t\t}\n\t\tswitch parentVal.(type) {\n\t\tcase map[any]any:\n\t\t\tcontinue\n\t\tcase map[string]any:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\t// parentVal is a regular value which shadows \"path\"\n\t\t\treturn strings.Join(path[0:i], v.keyDelim)\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// isPathShadowedInFlatMap makes sure the given path is not shadowed somewhere\n// in a sub-path of the map.\n// e.g., if \"foo.bar\" has a value in the given map, it “shadows”\n//\n//\t\"foo.bar.baz\" in a lower-priority map\nfunc (v *Viper) isPathShadowedInFlatMap(path []string, mi any) string {\n\t// unify input map\n\tvar m map[string]interface{}\n\tswitch miv := mi.(type) {\n\tcase map[string]string:\n\t\tm = castMapStringToMapInterface(miv)\n\tcase map[string]FlagValue:\n\t\tm = castMapFlagToMapInterface(miv)\n\tdefault:\n\t\treturn \"\"\n\t}\n\n\t// scan paths\n\tvar parentKey string\n\tfor i := 1; i < len(path); i++ {\n\t\tparentKey = strings.Join(path[0:i], v.keyDelim)\n\t\tif _, ok := m[parentKey]; ok {\n\t\t\treturn parentKey\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// isPathShadowedInAutoEnv makes sure the given path is not shadowed somewhere\n// in the environment, when automatic env is on.\n// e.g., if \"foo.bar\" has a value in the environment, it “shadows”\n//\n//\t\"foo.bar.baz\" in a lower-priority map\nfunc (v *Viper) isPathShadowedInAutoEnv(path []string) string {\n\tvar parentKey string\n\tfor i := 1; i < len(path); i++ {\n\t\tparentKey = strings.Join(path[0:i], v.keyDelim)\n\t\tif _, ok := v.getEnv(v.mergeWithEnvPrefix(parentKey)); ok {\n\t\t\treturn parentKey\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// SetTypeByDefaultValue enables or disables the inference of a key value's\n// type when the Get function is used based upon a key's default value as\n// opposed to the value returned based on the normal fetch logic.\n//\n// For example, if a key has a default value of []string{} and the same key\n// is set via an environment variable to \"a b c\", a call to the Get function\n// would return a string slice for the key if the key's type is inferred by\n// the default value and the Get function would return:\n//\n//\t[]string {\"a\", \"b\", \"c\"}\n//\n// Otherwise the Get function would return:\n//\n//\t\"a b c\"\nfunc SetTypeByDefaultValue(enable bool) { v.SetTypeByDefaultValue(enable) }\n\nfunc (v *Viper) SetTypeByDefaultValue(enable bool) {\n\tv.typeByDefValue = enable\n}\n\n// GetViper gets the global Viper instance.\nfunc GetViper() *Viper {\n\treturn v\n}\n\n// Get can retrieve any value given the key to use.\n// Get is case-insensitive for a key.\n// Get has the behavior of returning the value associated with the first\n// place from where it is set. Viper will check in the following order:\n// override, flag, env, config file, key/value store, default\n//\n// Get returns an interface. For a specific value use one of the Get____ methods.\nfunc Get(key string) any { return v.Get(key) }\n\nfunc (v *Viper) Get(key string) any {\n\tlcaseKey := strings.ToLower(key)\n\tval := v.find(lcaseKey, true)\n\tif val == nil {\n\t\treturn nil\n\t}\n\n\tif v.typeByDefValue {\n\t\t// TODO(bep) this branch isn't covered by a single test.\n\t\tvalType := val\n\t\tpath := strings.Split(lcaseKey, v.keyDelim)\n\t\tdefVal := v.searchMap(v.defaults, path)\n\t\tif defVal != nil {\n\t\t\tvalType = defVal\n\t\t}\n\n\t\tswitch valType.(type) {\n\t\tcase bool:\n\t\t\treturn cast.ToBool(val)\n\t\tcase string:\n\t\t\treturn cast.ToString(val)\n\t\tcase int32, int16, int8, int:\n\t\t\treturn cast.ToInt(val)\n\t\tcase uint:\n\t\t\treturn cast.ToUint(val)\n\t\tcase uint32:\n\t\t\treturn cast.ToUint32(val)\n\t\tcase uint64:\n\t\t\treturn cast.ToUint64(val)\n\t\tcase int64:\n\t\t\treturn cast.ToInt64(val)\n\t\tcase float64, float32:\n\t\t\treturn cast.ToFloat64(val)\n\t\tcase time.Time:\n\t\t\treturn cast.ToTime(val)\n\t\tcase time.Duration:\n\t\t\treturn cast.ToDuration(val)\n\t\tcase []string:\n\t\t\treturn cast.ToStringSlice(val)\n\t\tcase []int:\n\t\t\treturn cast.ToIntSlice(val)\n\t\tcase []time.Duration:\n\t\t\treturn cast.ToDurationSlice(val)\n\t\t}\n\t}\n\n\treturn val\n}\n\n// Sub returns new Viper instance representing a sub tree of this instance.\n// Sub is case-insensitive for a key.\nfunc Sub(key string) *Viper { return v.Sub(key) }\n\nfunc (v *Viper) Sub(key string) *Viper {\n\tsubv := New()\n\tdata := v.Get(key)\n\tif data == nil {\n\t\treturn nil\n\t}\n\n\tif reflect.TypeOf(data).Kind() == reflect.Map {\n\t\tsubv.parents = append([]string(nil), v.parents...)\n\t\tsubv.parents = append(subv.parents, strings.ToLower(key))\n\t\tsubv.automaticEnvApplied = v.automaticEnvApplied\n\t\tsubv.envPrefix = v.envPrefix\n\t\tsubv.envKeyReplacer = v.envKeyReplacer\n\t\tsubv.keyDelim = v.keyDelim\n\t\tsubv.config = cast.ToStringMap(data)\n\t\treturn subv\n\t}\n\treturn nil\n}\n\n// GetString returns the value associated with the key as a string.\nfunc GetString(key string) string { return v.GetString(key) }\n\nfunc (v *Viper) GetString(key string) string {\n\treturn cast.ToString(v.Get(key))\n}\n\n// GetBool returns the value associated with the key as a boolean.\nfunc GetBool(key string) bool { return v.GetBool(key) }\n\nfunc (v *Viper) GetBool(key string) bool {\n\treturn cast.ToBool(v.Get(key))\n}\n\n// GetInt returns the value associated with the key as an integer.\nfunc GetInt(key string) int { return v.GetInt(key) }\n\nfunc (v *Viper) GetInt(key string) int {\n\treturn cast.ToInt(v.Get(key))\n}\n\n// GetInt32 returns the value associated with the key as an integer.\nfunc GetInt32(key string) int32 { return v.GetInt32(key) }\n\nfunc (v *Viper) GetInt32(key string) int32 {\n\treturn cast.ToInt32(v.Get(key))\n}\n\n// GetInt64 returns the value associated with the key as an integer.\nfunc GetInt64(key string) int64 { return v.GetInt64(key) }\n\nfunc (v *Viper) GetInt64(key string) int64 {\n\treturn cast.ToInt64(v.Get(key))\n}\n\n// GetUint8 returns the value associated with the key as an unsigned integer.\nfunc GetUint8(key string) uint8 { return v.GetUint8(key) }\n\nfunc (v *Viper) GetUint8(key string) uint8 {\n\treturn cast.ToUint8(v.Get(key))\n}\n\n// GetUint returns the value associated with the key as an unsigned integer.\nfunc GetUint(key string) uint { return v.GetUint(key) }\n\nfunc (v *Viper) GetUint(key string) uint {\n\treturn cast.ToUint(v.Get(key))\n}\n\n// GetUint16 returns the value associated with the key as an unsigned integer.\nfunc GetUint16(key string) uint16 { return v.GetUint16(key) }\n\nfunc (v *Viper) GetUint16(key string) uint16 {\n\treturn cast.ToUint16(v.Get(key))\n}\n\n// GetUint32 returns the value associated with the key as an unsigned integer.\nfunc GetUint32(key string) uint32 { return v.GetUint32(key) }\n\nfunc (v *Viper) GetUint32(key string) uint32 {\n\treturn cast.ToUint32(v.Get(key))\n}\n\n// GetUint64 returns the value associated with the key as an unsigned integer.\nfunc GetUint64(key string) uint64 { return v.GetUint64(key) }\n\nfunc (v *Viper) GetUint64(key string) uint64 {\n\treturn cast.ToUint64(v.Get(key))\n}\n\n// GetFloat64 returns the value associated with the key as a float64.\nfunc GetFloat64(key string) float64 { return v.GetFloat64(key) }\n\nfunc (v *Viper) GetFloat64(key string) float64 {\n\treturn cast.ToFloat64(v.Get(key))\n}\n\n// GetTime returns the value associated with the key as time.\nfunc GetTime(key string) time.Time { return v.GetTime(key) }\n\nfunc (v *Viper) GetTime(key string) time.Time {\n\treturn cast.ToTime(v.Get(key))\n}\n\n// GetDuration returns the value associated with the key as a duration.\nfunc GetDuration(key string) time.Duration { return v.GetDuration(key) }\n\nfunc (v *Viper) GetDuration(key string) time.Duration {\n\treturn cast.ToDuration(v.Get(key))\n}\n\n// GetIntSlice returns the value associated with the key as a slice of int values.\nfunc GetIntSlice(key string) []int { return v.GetIntSlice(key) }\n\nfunc (v *Viper) GetIntSlice(key string) []int {\n\treturn cast.ToIntSlice(v.Get(key))\n}\n\n// GetStringSlice returns the value associated with the key as a slice of strings.\nfunc GetStringSlice(key string) []string { return v.GetStringSlice(key) }\n\nfunc (v *Viper) GetStringSlice(key string) []string {\n\treturn cast.ToStringSlice(v.Get(key))\n}\n\n// GetStringMap returns the value associated with the key as a map of interfaces.\nfunc GetStringMap(key string) map[string]any { return v.GetStringMap(key) }\n\nfunc (v *Viper) GetStringMap(key string) map[string]any {\n\treturn cast.ToStringMap(v.Get(key))\n}\n\n// GetStringMapString returns the value associated with the key as a map of strings.\nfunc GetStringMapString(key string) map[string]string { return v.GetStringMapString(key) }\n\nfunc (v *Viper) GetStringMapString(key string) map[string]string {\n\treturn cast.ToStringMapString(v.Get(key))\n}\n\n// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.\nfunc GetStringMapStringSlice(key string) map[string][]string { return v.GetStringMapStringSlice(key) }\n\nfunc (v *Viper) GetStringMapStringSlice(key string) map[string][]string {\n\treturn cast.ToStringMapStringSlice(v.Get(key))\n}\n\n// GetSizeInBytes returns the size of the value associated with the given key\n// in bytes.\nfunc GetSizeInBytes(key string) uint { return v.GetSizeInBytes(key) }\n\nfunc (v *Viper) GetSizeInBytes(key string) uint {\n\tsizeStr := cast.ToString(v.Get(key))\n\treturn parseSizeInBytes(sizeStr)\n}\n\n// UnmarshalKey takes a single key and unmarshals it into a Struct.\nfunc UnmarshalKey(key string, rawVal any, opts ...DecoderConfigOption) error {\n\treturn v.UnmarshalKey(key, rawVal, opts...)\n}\n\nfunc (v *Viper) UnmarshalKey(key string, rawVal any, opts ...DecoderConfigOption) error {\n\treturn decode(v.Get(key), v.defaultDecoderConfig(rawVal, opts...))\n}\n\n// Unmarshal unmarshals the config into a Struct. Make sure that the tags\n// on the fields of the structure are properly set.\nfunc Unmarshal(rawVal any, opts ...DecoderConfigOption) error {\n\treturn v.Unmarshal(rawVal, opts...)\n}\n\nfunc (v *Viper) Unmarshal(rawVal any, opts ...DecoderConfigOption) error {\n\tkeys := v.AllKeys()\n\n\tif v.experimentalBindStruct {\n\t\t// TODO: make this optional?\n\t\tstructKeys, err := v.decodeStructKeys(rawVal, opts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tkeys = append(keys, structKeys...)\n\t}\n\n\t// TODO: struct keys should be enough?\n\treturn decode(v.getSettings(keys), v.defaultDecoderConfig(rawVal, opts...))\n}\n\nfunc (v *Viper) decodeStructKeys(input any, opts ...DecoderConfigOption) ([]string, error) {\n\tvar structKeyMap map[string]any\n\n\terr := decode(input, v.defaultDecoderConfig(&structKeyMap, opts...))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tflattenedStructKeyMap := v.flattenAndMergeMap(map[string]bool{}, structKeyMap, \"\")\n\n\tr := make([]string, 0, len(flattenedStructKeyMap))\n\tfor v := range flattenedStructKeyMap {\n\t\tr = append(r, v)\n\t}\n\n\treturn r, nil\n}\n\n// defaultDecoderConfig returns default mapstructure.DecoderConfig with support\n// of time.Duration values & string slices.\nfunc (v *Viper) defaultDecoderConfig(output any, opts ...DecoderConfigOption) *mapstructure.DecoderConfig {\n\tdecodeHook := v.decodeHook\n\tif decodeHook == nil {\n\t\tdecodeHook = mapstructure.ComposeDecodeHookFunc(\n\t\t\tmapstructure.StringToTimeDurationHookFunc(),\n\t\t\t// mapstructure.StringToSliceHookFunc(\",\"),\n\t\t\tstringToWeakSliceHookFunc(\",\"),\n\t\t)\n\t}\n\n\tc := &mapstructure.DecoderConfig{\n\t\tMetadata:         nil,\n\t\tWeaklyTypedInput: true,\n\t\tDecodeHook:       decodeHook,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\n\t// Do not allow overwriting the output\n\tc.Result = output\n\n\treturn c\n}\n\n// As of mapstructure v2.0.0 StringToSliceHookFunc checks if the return type is a string slice.\n// This function removes that check.\n// TODO: implement a function that checks if the value can be converted to the return type and use it instead.\nfunc stringToWeakSliceHookFunc(sep string) mapstructure.DecodeHookFunc {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{},\n\t) (interface{}, error) {\n\t\tif f.Kind() != reflect.String || t.Kind() != reflect.Slice {\n\t\t\treturn data, nil\n\t\t}\n\n\t\traw := data.(string)\n\t\tif raw == \"\" {\n\t\t\treturn []string{}, nil\n\t\t}\n\n\t\treturn strings.Split(raw, sep), nil\n\t}\n}\n\n// decode is a wrapper around mapstructure.Decode that mimics the WeakDecode functionality.\nfunc decode(input any, config *mapstructure.DecoderConfig) error {\n\tdecoder, err := mapstructure.NewDecoder(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn decoder.Decode(input)\n}\n\n// UnmarshalExact unmarshals the config into a Struct, erroring if a field is nonexistent\n// in the destination struct.\nfunc UnmarshalExact(rawVal any, opts ...DecoderConfigOption) error {\n\treturn v.UnmarshalExact(rawVal, opts...)\n}\n\nfunc (v *Viper) UnmarshalExact(rawVal any, opts ...DecoderConfigOption) error {\n\tconfig := v.defaultDecoderConfig(rawVal, opts...)\n\tconfig.ErrorUnused = true\n\n\tkeys := v.AllKeys()\n\n\tif v.experimentalBindStruct {\n\t\t// TODO: make this optional?\n\t\tstructKeys, err := v.decodeStructKeys(rawVal, opts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tkeys = append(keys, structKeys...)\n\t}\n\n\t// TODO: struct keys should be enough?\n\treturn decode(v.getSettings(keys), config)\n}\n\n// BindPFlags binds a full flag set to the configuration, using each flag's long\n// name as the config key.\nfunc BindPFlags(flags *pflag.FlagSet) error { return v.BindPFlags(flags) }\n\nfunc (v *Viper) BindPFlags(flags *pflag.FlagSet) error {\n\treturn v.BindFlagValues(pflagValueSet{flags})\n}\n\n// BindPFlag binds a specific key to a pflag (as used by cobra).\n// Example (where serverCmd is a Cobra instance):\n//\n//\tserverCmd.Flags().Int(\"port\", 1138, \"Port to run Application server on\")\n//\tViper.BindPFlag(\"port\", serverCmd.Flags().Lookup(\"port\"))\nfunc BindPFlag(key string, flag *pflag.Flag) error { return v.BindPFlag(key, flag) }\n\nfunc (v *Viper) BindPFlag(key string, flag *pflag.Flag) error {\n\tif flag == nil {\n\t\treturn fmt.Errorf(\"flag for %q is nil\", key)\n\t}\n\treturn v.BindFlagValue(key, pflagValue{flag})\n}\n\n// BindFlagValues binds a full FlagValue set to the configuration, using each flag's long\n// name as the config key.\nfunc BindFlagValues(flags FlagValueSet) error { return v.BindFlagValues(flags) }\n\nfunc (v *Viper) BindFlagValues(flags FlagValueSet) (err error) {\n\tflags.VisitAll(func(flag FlagValue) {\n\t\tif err = v.BindFlagValue(flag.Name(), flag); err != nil {\n\t\t\treturn\n\t\t}\n\t})\n\treturn nil\n}\n\n// BindFlagValue binds a specific key to a FlagValue.\nfunc BindFlagValue(key string, flag FlagValue) error { return v.BindFlagValue(key, flag) }\n\nfunc (v *Viper) BindFlagValue(key string, flag FlagValue) error {\n\tif flag == nil {\n\t\treturn fmt.Errorf(\"flag for %q is nil\", key)\n\t}\n\tv.pflags[strings.ToLower(key)] = flag\n\treturn nil\n}\n\n// BindEnv binds a Viper key to a ENV variable.\n// ENV variables are case sensitive.\n// If only a key is provided, it will use the env key matching the key, uppercased.\n// If more arguments are provided, they will represent the env variable names that\n// should bind to this key and will be taken in the specified order.\n// EnvPrefix will be used when set when env name is not provided.\nfunc BindEnv(input ...string) error { return v.BindEnv(input...) }\n\nfunc (v *Viper) BindEnv(input ...string) error {\n\tif len(input) == 0 {\n\t\treturn fmt.Errorf(\"missing key to bind to\")\n\t}\n\n\tkey := strings.ToLower(input[0])\n\n\tif len(input) == 1 {\n\t\tv.env[key] = append(v.env[key], v.mergeWithEnvPrefix(key))\n\t} else {\n\t\tv.env[key] = append(v.env[key], input[1:]...)\n\t}\n\n\treturn nil\n}\n\n// MustBindEnv wraps BindEnv in a panic.\n// If there is an error binding an environment variable, MustBindEnv will\n// panic.\nfunc MustBindEnv(input ...string) { v.MustBindEnv(input...) }\n\nfunc (v *Viper) MustBindEnv(input ...string) {\n\tif err := v.BindEnv(input...); err != nil {\n\t\tpanic(fmt.Sprintf(\"error while binding environment variable: %v\", err))\n\t}\n}\n\n// Given a key, find the value.\n//\n// Viper will check to see if an alias exists first.\n// Viper will then check in the following order:\n// flag, env, config file, key/value store.\n// Lastly, if no value was found and flagDefault is true, and if the key\n// corresponds to a flag, the flag's default value is returned.\n//\n// Note: this assumes a lower-cased key given.\nfunc (v *Viper) find(lcaseKey string, flagDefault bool) any {\n\tvar (\n\t\tval    any\n\t\texists bool\n\t\tpath   = strings.Split(lcaseKey, v.keyDelim)\n\t\tnested = len(path) > 1\n\t)\n\n\t// compute the path through the nested maps to the nested value\n\tif nested && v.isPathShadowedInDeepMap(path, castMapStringToMapInterface(v.aliases)) != \"\" {\n\t\treturn nil\n\t}\n\n\t// if the requested key is an alias, then return the proper key\n\tlcaseKey = v.realKey(lcaseKey)\n\tpath = strings.Split(lcaseKey, v.keyDelim)\n\tnested = len(path) > 1\n\n\t// Set() override first\n\tval = v.searchMap(v.override, path)\n\tif val != nil {\n\t\treturn val\n\t}\n\tif nested && v.isPathShadowedInDeepMap(path, v.override) != \"\" {\n\t\treturn nil\n\t}\n\n\t// PFlag override next\n\tflag, exists := v.pflags[lcaseKey]\n\tif exists && flag.HasChanged() {\n\t\tswitch flag.ValueType() {\n\t\tcase \"int\", \"int8\", \"int16\", \"int32\", \"int64\":\n\t\t\treturn cast.ToInt(flag.ValueString())\n\t\tcase \"bool\":\n\t\t\treturn cast.ToBool(flag.ValueString())\n\t\tcase \"stringSlice\", \"stringArray\":\n\t\t\ts := strings.TrimPrefix(flag.ValueString(), \"[\")\n\t\t\ts = strings.TrimSuffix(s, \"]\")\n\t\t\tres, _ := readAsCSV(s)\n\t\t\treturn res\n\t\tcase \"intSlice\":\n\t\t\ts := strings.TrimPrefix(flag.ValueString(), \"[\")\n\t\t\ts = strings.TrimSuffix(s, \"]\")\n\t\t\tres, _ := readAsCSV(s)\n\t\t\treturn cast.ToIntSlice(res)\n\t\tcase \"durationSlice\":\n\t\t\ts := strings.TrimPrefix(flag.ValueString(), \"[\")\n\t\t\ts = strings.TrimSuffix(s, \"]\")\n\t\t\tslice := strings.Split(s, \",\")\n\t\t\treturn cast.ToDurationSlice(slice)\n\t\tcase \"stringToString\":\n\t\t\treturn stringToStringConv(flag.ValueString())\n\t\tcase \"stringToInt\":\n\t\t\treturn stringToIntConv(flag.ValueString())\n\t\tdefault:\n\t\t\treturn flag.ValueString()\n\t\t}\n\t}\n\tif nested && v.isPathShadowedInFlatMap(path, v.pflags) != \"\" {\n\t\treturn nil\n\t}\n\n\t// Env override next\n\tif v.automaticEnvApplied {\n\t\tenvKey := strings.Join(append(v.parents, lcaseKey), \".\")\n\t\t// even if it hasn't been registered, if automaticEnv is used,\n\t\t// check any Get request\n\t\tif val, ok := v.getEnv(v.mergeWithEnvPrefix(envKey)); ok {\n\t\t\treturn val\n\t\t}\n\t\tif nested && v.isPathShadowedInAutoEnv(path) != \"\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\tenvkeys, exists := v.env[lcaseKey]\n\tif exists {\n\t\tfor _, envkey := range envkeys {\n\t\t\tif val, ok := v.getEnv(envkey); ok {\n\t\t\t\treturn val\n\t\t\t}\n\t\t}\n\t}\n\tif nested && v.isPathShadowedInFlatMap(path, v.env) != \"\" {\n\t\treturn nil\n\t}\n\n\t// Config file next\n\tval = v.searchIndexableWithPathPrefixes(v.config, path)\n\tif val != nil {\n\t\treturn val\n\t}\n\tif nested && v.isPathShadowedInDeepMap(path, v.config) != \"\" {\n\t\treturn nil\n\t}\n\n\t// K/V store next\n\tval = v.searchMap(v.kvstore, path)\n\tif val != nil {\n\t\treturn val\n\t}\n\tif nested && v.isPathShadowedInDeepMap(path, v.kvstore) != \"\" {\n\t\treturn nil\n\t}\n\n\t// Default next\n\tval = v.searchMap(v.defaults, path)\n\tif val != nil {\n\t\treturn val\n\t}\n\tif nested && v.isPathShadowedInDeepMap(path, v.defaults) != \"\" {\n\t\treturn nil\n\t}\n\n\tif flagDefault {\n\t\t// last chance: if no value is found and a flag does exist for the key,\n\t\t// get the flag's default value even if the flag's value has not been set.\n\t\tif flag, exists := v.pflags[lcaseKey]; exists {\n\t\t\tswitch flag.ValueType() {\n\t\t\tcase \"int\", \"int8\", \"int16\", \"int32\", \"int64\":\n\t\t\t\treturn cast.ToInt(flag.ValueString())\n\t\t\tcase \"bool\":\n\t\t\t\treturn cast.ToBool(flag.ValueString())\n\t\t\tcase \"stringSlice\", \"stringArray\":\n\t\t\t\ts := strings.TrimPrefix(flag.ValueString(), \"[\")\n\t\t\t\ts = strings.TrimSuffix(s, \"]\")\n\t\t\t\tres, _ := readAsCSV(s)\n\t\t\t\treturn res\n\t\t\tcase \"intSlice\":\n\t\t\t\ts := strings.TrimPrefix(flag.ValueString(), \"[\")\n\t\t\t\ts = strings.TrimSuffix(s, \"]\")\n\t\t\t\tres, _ := readAsCSV(s)\n\t\t\t\treturn cast.ToIntSlice(res)\n\t\t\tcase \"stringToString\":\n\t\t\t\treturn stringToStringConv(flag.ValueString())\n\t\t\tcase \"stringToInt\":\n\t\t\t\treturn stringToIntConv(flag.ValueString())\n\t\t\tcase \"durationSlice\":\n\t\t\t\ts := strings.TrimPrefix(flag.ValueString(), \"[\")\n\t\t\t\ts = strings.TrimSuffix(s, \"]\")\n\t\t\t\tslice := strings.Split(s, \",\")\n\t\t\t\treturn cast.ToDurationSlice(slice)\n\t\t\tdefault:\n\t\t\t\treturn flag.ValueString()\n\t\t\t}\n\t\t}\n\t\t// last item, no need to check shadowing\n\t}\n\n\treturn nil\n}\n\nfunc readAsCSV(val string) ([]string, error) {\n\tif val == \"\" {\n\t\treturn []string{}, nil\n\t}\n\tstringReader := strings.NewReader(val)\n\tcsvReader := csv.NewReader(stringReader)\n\treturn csvReader.Read()\n}\n\n// mostly copied from pflag's implementation of this operation here https://github.com/spf13/pflag/blob/master/string_to_string.go#L79\n// alterations are: errors are swallowed, map[string]any is returned in order to enable cast.ToStringMap.\nfunc stringToStringConv(val string) any {\n\tval = strings.Trim(val, \"[]\")\n\t// An empty string would cause an empty map\n\tif val == \"\" {\n\t\treturn map[string]any{}\n\t}\n\tr := csv.NewReader(strings.NewReader(val))\n\tss, err := r.Read()\n\tif err != nil {\n\t\treturn nil\n\t}\n\tout := make(map[string]any, len(ss))\n\tfor _, pair := range ss {\n\t\tk, vv, found := strings.Cut(pair, \"=\")\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t\tout[k] = vv\n\t}\n\treturn out\n}\n\n// mostly copied from pflag's implementation of this operation here https://github.com/spf13/pflag/blob/d5e0c0615acee7028e1e2740a11102313be88de1/string_to_int.go#L68\n// alterations are: errors are swallowed, map[string]any is returned in order to enable cast.ToStringMap.\nfunc stringToIntConv(val string) any {\n\tval = strings.Trim(val, \"[]\")\n\t// An empty string would cause an empty map\n\tif val == \"\" {\n\t\treturn map[string]any{}\n\t}\n\tss := strings.Split(val, \",\")\n\tout := make(map[string]any, len(ss))\n\tfor _, pair := range ss {\n\t\tk, vv, found := strings.Cut(pair, \"=\")\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t\tvar err error\n\t\tout[k], err = strconv.Atoi(vv)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn out\n}\n\n// IsSet checks to see if the key has been set in any of the data locations.\n// IsSet is case-insensitive for a key.\nfunc IsSet(key string) bool { return v.IsSet(key) }\n\nfunc (v *Viper) IsSet(key string) bool {\n\tlcaseKey := strings.ToLower(key)\n\tval := v.find(lcaseKey, false)\n\treturn val != nil\n}\n\n// AutomaticEnv makes Viper check if environment variables match any of the existing keys\n// (config, default or flags). If matching env vars are found, they are loaded into Viper.\nfunc AutomaticEnv() { v.AutomaticEnv() }\n\nfunc (v *Viper) AutomaticEnv() {\n\tv.automaticEnvApplied = true\n}\n\n// SetEnvKeyReplacer sets the strings.Replacer on the viper object\n// Useful for mapping an environmental variable to a key that does\n// not match it.\nfunc SetEnvKeyReplacer(r *strings.Replacer) { v.SetEnvKeyReplacer(r) }\n\nfunc (v *Viper) SetEnvKeyReplacer(r *strings.Replacer) {\n\tv.envKeyReplacer = r\n}\n\n// RegisterAlias creates an alias that provides another accessor for the same key.\n// This enables one to change a name without breaking the application.\nfunc RegisterAlias(alias, key string) { v.RegisterAlias(alias, key) }\n\nfunc (v *Viper) RegisterAlias(alias, key string) {\n\tv.registerAlias(alias, strings.ToLower(key))\n}\n\nfunc (v *Viper) registerAlias(alias, key string) {\n\talias = strings.ToLower(alias)\n\tif alias != key && alias != v.realKey(key) {\n\t\t_, exists := v.aliases[alias]\n\n\t\tif !exists {\n\t\t\t// if we alias something that exists in one of the maps to another\n\t\t\t// name, we'll never be able to get that value using the original\n\t\t\t// name, so move the config value to the new realkey.\n\t\t\tif val, ok := v.config[alias]; ok {\n\t\t\t\tdelete(v.config, alias)\n\t\t\t\tv.config[key] = val\n\t\t\t}\n\t\t\tif val, ok := v.kvstore[alias]; ok {\n\t\t\t\tdelete(v.kvstore, alias)\n\t\t\t\tv.kvstore[key] = val\n\t\t\t}\n\t\t\tif val, ok := v.defaults[alias]; ok {\n\t\t\t\tdelete(v.defaults, alias)\n\t\t\t\tv.defaults[key] = val\n\t\t\t}\n\t\t\tif val, ok := v.override[alias]; ok {\n\t\t\t\tdelete(v.override, alias)\n\t\t\t\tv.override[key] = val\n\t\t\t}\n\t\t\tv.aliases[alias] = key\n\t\t}\n\t} else {\n\t\tv.logger.Warn(\"creating circular reference alias\", \"alias\", alias, \"key\", key, \"real_key\", v.realKey(key))\n\t}\n}\n\nfunc (v *Viper) realKey(key string) string {\n\tnewkey, exists := v.aliases[key]\n\tif exists {\n\t\tv.logger.Debug(\"key is an alias\", \"alias\", key, \"to\", newkey)\n\n\t\treturn v.realKey(newkey)\n\t}\n\treturn key\n}\n\n// InConfig checks to see if the given key (or an alias) is in the config file.\nfunc InConfig(key string) bool { return v.InConfig(key) }\n\nfunc (v *Viper) InConfig(key string) bool {\n\tlcaseKey := strings.ToLower(key)\n\n\t// if the requested key is an alias, then return the proper key\n\tlcaseKey = v.realKey(lcaseKey)\n\tpath := strings.Split(lcaseKey, v.keyDelim)\n\n\treturn v.searchIndexableWithPathPrefixes(v.config, path) != nil\n}\n\n// SetDefault sets the default value for this key.\n// SetDefault is case-insensitive for a key.\n// Default only used when no value is provided by the user via flag, config or ENV.\nfunc SetDefault(key string, value any) { v.SetDefault(key, value) }\n\nfunc (v *Viper) SetDefault(key string, value any) {\n\t// If alias passed in, then set the proper default\n\tkey = v.realKey(strings.ToLower(key))\n\tvalue = toCaseInsensitiveValue(value)\n\n\tpath := strings.Split(key, v.keyDelim)\n\tlastKey := strings.ToLower(path[len(path)-1])\n\tdeepestMap := deepSearch(v.defaults, path[0:len(path)-1])\n\n\t// set innermost value\n\tdeepestMap[lastKey] = value\n}\n\n// Set sets the value for the key in the override register.\n// Set is case-insensitive for a key.\n// Will be used instead of values obtained via\n// flags, config file, ENV, default, or key/value store.\nfunc Set(key string, value any) { v.Set(key, value) }\n\nfunc (v *Viper) Set(key string, value any) {\n\t// If alias passed in, then set the proper override\n\tkey = v.realKey(strings.ToLower(key))\n\tvalue = toCaseInsensitiveValue(value)\n\n\tpath := strings.Split(key, v.keyDelim)\n\tlastKey := strings.ToLower(path[len(path)-1])\n\tdeepestMap := deepSearch(v.override, path[0:len(path)-1])\n\n\t// set innermost value\n\tdeepestMap[lastKey] = value\n}\n\n// ReadInConfig will discover and load the configuration file from disk\n// and key/value stores, searching in one of the defined paths.\nfunc ReadInConfig() error { return v.ReadInConfig() }\n\nfunc (v *Viper) ReadInConfig() error {\n\tv.logger.Info(\"attempting to read in config file\")\n\tfilename, err := v.getConfigFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !slices.Contains(SupportedExts, v.getConfigType()) {\n\t\treturn UnsupportedConfigError(v.getConfigType())\n\t}\n\n\tv.logger.Debug(\"reading file\", \"file\", filename)\n\tfile, err := afero.ReadFile(v.fs, filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig := make(map[string]any)\n\n\terr = v.unmarshalReader(bytes.NewReader(file), config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tv.config = config\n\treturn nil\n}\n\n// MergeInConfig merges a new configuration with an existing config.\nfunc MergeInConfig() error { return v.MergeInConfig() }\n\nfunc (v *Viper) MergeInConfig() error {\n\tv.logger.Info(\"attempting to merge in config file\")\n\tfilename, err := v.getConfigFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !slices.Contains(SupportedExts, v.getConfigType()) {\n\t\treturn UnsupportedConfigError(v.getConfigType())\n\t}\n\n\tfile, err := afero.ReadFile(v.fs, filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn v.MergeConfig(bytes.NewReader(file))\n}\n\n// ReadConfig will read a configuration file, setting existing keys to nil if the\n// key does not exist in the file.\nfunc ReadConfig(in io.Reader) error { return v.ReadConfig(in) }\n\nfunc (v *Viper) ReadConfig(in io.Reader) error {\n\tif v.configType == \"\" {\n\t\treturn errors.New(\"cannot decode configuration: config type is not set\")\n\t}\n\n\tv.config = make(map[string]any)\n\treturn v.unmarshalReader(in, v.config)\n}\n\n// MergeConfig merges a new configuration with an existing config.\nfunc MergeConfig(in io.Reader) error { return v.MergeConfig(in) }\n\nfunc (v *Viper) MergeConfig(in io.Reader) error {\n\tif v.configType == \"\" {\n\t\treturn errors.New(\"cannot decode configuration: config type is not set\")\n\t}\n\n\tcfg := make(map[string]any)\n\tif err := v.unmarshalReader(in, cfg); err != nil {\n\t\treturn err\n\t}\n\treturn v.MergeConfigMap(cfg)\n}\n\n// MergeConfigMap merges the configuration from the map given with an existing config.\n// Note that the map given may be modified.\nfunc MergeConfigMap(cfg map[string]any) error { return v.MergeConfigMap(cfg) }\n\nfunc (v *Viper) MergeConfigMap(cfg map[string]any) error {\n\tif v.config == nil {\n\t\tv.config = make(map[string]any)\n\t}\n\tinsensitiviseMap(cfg)\n\tmergeMaps(cfg, v.config, nil)\n\treturn nil\n}\n\n// WriteConfig writes the current configuration to a file.\nfunc WriteConfig() error { return v.WriteConfig() }\n\nfunc (v *Viper) WriteConfig() error {\n\tfilename, err := v.getConfigFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn v.writeConfig(filename, true)\n}\n\n// SafeWriteConfig writes current configuration to file only if the file does not exist.\nfunc SafeWriteConfig() error { return v.SafeWriteConfig() }\n\nfunc (v *Viper) SafeWriteConfig() error {\n\tif len(v.configPaths) < 1 {\n\t\treturn errors.New(\"missing configuration for 'configPath'\")\n\t}\n\treturn v.SafeWriteConfigAs(filepath.Join(v.configPaths[0], v.configName+\".\"+v.configType))\n}\n\n// WriteConfigAs writes current configuration to a given filename.\nfunc WriteConfigAs(filename string) error { return v.WriteConfigAs(filename) }\n\nfunc (v *Viper) WriteConfigAs(filename string) error {\n\treturn v.writeConfig(filename, true)\n}\n\n// WriteConfigTo writes current configuration to an [io.Writer].\nfunc WriteConfigTo(w io.Writer) error { return v.WriteConfigTo(w) }\n\nfunc (v *Viper) WriteConfigTo(w io.Writer) error {\n\tformat := strings.ToLower(v.getConfigType())\n\n\tif !slices.Contains(SupportedExts, format) {\n\t\treturn UnsupportedConfigError(format)\n\t}\n\n\treturn v.marshalWriter(w, format)\n}\n\n// SafeWriteConfigAs writes current configuration to a given filename if it does not exist.\nfunc SafeWriteConfigAs(filename string) error { return v.SafeWriteConfigAs(filename) }\n\nfunc (v *Viper) SafeWriteConfigAs(filename string) error {\n\talreadyExists, err := afero.Exists(v.fs, filename)\n\tif alreadyExists && err == nil {\n\t\treturn ConfigFileAlreadyExistsError(filename)\n\t}\n\treturn v.writeConfig(filename, false)\n}\n\nfunc (v *Viper) writeConfig(filename string, force bool) error {\n\tv.logger.Info(\"attempting to write configuration to file\")\n\n\tvar configType string\n\n\text := filepath.Ext(filename)\n\tif ext != \"\" && ext != filepath.Base(filename) {\n\t\tconfigType = ext[1:]\n\t} else {\n\t\tconfigType = v.configType\n\t}\n\tif configType == \"\" {\n\t\treturn fmt.Errorf(\"config type could not be determined for %s\", filename)\n\t}\n\n\tif !slices.Contains(SupportedExts, configType) {\n\t\treturn UnsupportedConfigError(configType)\n\t}\n\tif v.config == nil {\n\t\tv.config = make(map[string]any)\n\t}\n\tflags := os.O_CREATE | os.O_TRUNC | os.O_WRONLY\n\tif !force {\n\t\tflags |= os.O_EXCL\n\t}\n\tf, err := v.fs.OpenFile(filename, flags, v.configPermissions)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tif err := v.marshalWriter(f, configType); err != nil {\n\t\treturn err\n\t}\n\n\treturn f.Sync()\n}\n\nfunc (v *Viper) unmarshalReader(in io.Reader, c map[string]any) error {\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(in)\n\n\tformat := strings.ToLower(v.getConfigType())\n\n\tif !slices.Contains(SupportedExts, format) {\n\t\treturn UnsupportedConfigError(format)\n\t}\n\n\tdecoder, err := v.decoderRegistry.Decoder(format)\n\tif err != nil {\n\t\treturn ConfigParseError{err}\n\t}\n\n\terr = decoder.Decode(buf.Bytes(), c)\n\tif err != nil {\n\t\treturn ConfigParseError{err}\n\t}\n\n\tinsensitiviseMap(c)\n\treturn nil\n}\n\n// Marshal a map into Writer.\nfunc (v *Viper) marshalWriter(w io.Writer, configType string) error {\n\tc := v.AllSettings()\n\n\tencoder, err := v.encoderRegistry.Encoder(configType)\n\tif err != nil {\n\t\treturn ConfigMarshalError{err}\n\t}\n\n\tb, err := encoder.Encode(c)\n\tif err != nil {\n\t\treturn ConfigMarshalError{err}\n\t}\n\n\t_, err = w.Write(b)\n\tif err != nil {\n\t\treturn ConfigMarshalError{err}\n\t}\n\n\treturn nil\n}\n\nfunc keyExists(k string, m map[string]any) string {\n\tlk := strings.ToLower(k)\n\tfor mk := range m {\n\t\tlmk := strings.ToLower(mk)\n\t\tif lmk == lk {\n\t\t\treturn mk\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc castToMapStringInterface(\n\tsrc map[any]any,\n) map[string]any {\n\ttgt := map[string]any{}\n\tfor k, v := range src {\n\t\ttgt[fmt.Sprintf(\"%v\", k)] = v\n\t}\n\treturn tgt\n}\n\nfunc castMapStringSliceToMapInterface(src map[string][]string) map[string]any {\n\ttgt := map[string]any{}\n\tfor k, v := range src {\n\t\ttgt[k] = v\n\t}\n\treturn tgt\n}\n\nfunc castMapStringToMapInterface(src map[string]string) map[string]any {\n\ttgt := map[string]any{}\n\tfor k, v := range src {\n\t\ttgt[k] = v\n\t}\n\treturn tgt\n}\n\nfunc castMapFlagToMapInterface(src map[string]FlagValue) map[string]any {\n\ttgt := map[string]any{}\n\tfor k, v := range src {\n\t\ttgt[k] = v\n\t}\n\treturn tgt\n}\n\n// mergeMaps merges two maps. The `itgt` parameter is for handling go-yaml's\n// insistence on parsing nested structures as `map[any]any`\n// instead of using a `string` as the key for nest structures beyond one level\n// deep. Both map types are supported as there is a go-yaml fork that uses\n// `map[string]any` instead.\nfunc mergeMaps(src, tgt map[string]any, itgt map[any]any) {\n\tfor sk, sv := range src {\n\t\ttk := keyExists(sk, tgt)\n\t\tif tk == \"\" {\n\t\t\tv.logger.Debug(\"\", \"tk\", \"\\\"\\\"\", fmt.Sprintf(\"tgt[%s]\", sk), sv)\n\t\t\ttgt[sk] = sv\n\t\t\tif itgt != nil {\n\t\t\t\titgt[sk] = sv\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\ttv, ok := tgt[tk]\n\t\tif !ok {\n\t\t\tv.logger.Debug(\"\", fmt.Sprintf(\"ok[%s]\", tk), false, fmt.Sprintf(\"tgt[%s]\", sk), sv)\n\t\t\ttgt[sk] = sv\n\t\t\tif itgt != nil {\n\t\t\t\titgt[sk] = sv\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tsvType := reflect.TypeOf(sv)\n\t\ttvType := reflect.TypeOf(tv)\n\n\t\tv.logger.Debug(\n\t\t\t\"processing\",\n\t\t\t\"key\", sk,\n\t\t\t\"st\", svType,\n\t\t\t\"tt\", tvType,\n\t\t\t\"sv\", sv,\n\t\t\t\"tv\", tv,\n\t\t)\n\n\t\tswitch ttv := tv.(type) {\n\t\tcase map[any]any:\n\t\t\tv.logger.Debug(\"merging maps (must convert)\")\n\t\t\ttsv, ok := sv.(map[any]any)\n\t\t\tif !ok {\n\t\t\t\tv.logger.Error(\n\t\t\t\t\t\"Could not cast sv to map[any]any\",\n\t\t\t\t\t\"key\", sk,\n\t\t\t\t\t\"st\", svType,\n\t\t\t\t\t\"tt\", tvType,\n\t\t\t\t\t\"sv\", sv,\n\t\t\t\t\t\"tv\", tv,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tssv := castToMapStringInterface(tsv)\n\t\t\tstv := castToMapStringInterface(ttv)\n\t\t\tmergeMaps(ssv, stv, ttv)\n\t\tcase map[string]any:\n\t\t\tv.logger.Debug(\"merging maps\")\n\t\t\ttsv, ok := sv.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\tv.logger.Error(\n\t\t\t\t\t\"Could not cast sv to map[string]any\",\n\t\t\t\t\t\"key\", sk,\n\t\t\t\t\t\"st\", svType,\n\t\t\t\t\t\"tt\", tvType,\n\t\t\t\t\t\"sv\", sv,\n\t\t\t\t\t\"tv\", tv,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmergeMaps(tsv, ttv, nil)\n\t\tdefault:\n\t\t\tv.logger.Debug(\"setting value\")\n\t\t\ttgt[tk] = sv\n\t\t\tif itgt != nil {\n\t\t\t\titgt[tk] = sv\n\t\t\t}\n\t\t}\n\t}\n}\n\n// AllKeys returns all keys holding a value, regardless of where they are set.\n// Nested keys are returned with a v.keyDelim separator.\nfunc AllKeys() []string { return v.AllKeys() }\n\nfunc (v *Viper) AllKeys() []string {\n\tm := map[string]bool{}\n\t// add all paths, by order of descending priority to ensure correct shadowing\n\tm = v.flattenAndMergeMap(m, castMapStringToMapInterface(v.aliases), \"\")\n\tm = v.flattenAndMergeMap(m, v.override, \"\")\n\tm = v.mergeFlatMap(m, castMapFlagToMapInterface(v.pflags))\n\tm = v.mergeFlatMap(m, castMapStringSliceToMapInterface(v.env))\n\tm = v.flattenAndMergeMap(m, v.config, \"\")\n\tm = v.flattenAndMergeMap(m, v.kvstore, \"\")\n\tm = v.flattenAndMergeMap(m, v.defaults, \"\")\n\n\t// convert set of paths to list\n\ta := make([]string, 0, len(m))\n\tfor x := range m {\n\t\ta = append(a, x)\n\t}\n\treturn a\n}\n\n// flattenAndMergeMap recursively flattens the given map into a map[string]bool\n// of key paths (used as a set, easier to manipulate than a []string):\n//   - each path is merged into a single key string, delimited with v.keyDelim\n//   - if a path is shadowed by an earlier value in the initial shadow map,\n//     it is skipped.\n//\n// The resulting set of paths is merged to the given shadow set at the same time.\nfunc (v *Viper) flattenAndMergeMap(shadow map[string]bool, m map[string]any, prefix string) map[string]bool {\n\tif shadow != nil && prefix != \"\" && shadow[prefix] {\n\t\t// prefix is shadowed => nothing more to flatten\n\t\treturn shadow\n\t}\n\tif shadow == nil {\n\t\tshadow = make(map[string]bool)\n\t}\n\n\tvar m2 map[string]any\n\tif prefix != \"\" {\n\t\tprefix += v.keyDelim\n\t}\n\tfor k, val := range m {\n\t\tfullKey := prefix + k\n\t\tswitch val := val.(type) {\n\t\tcase map[string]any:\n\t\t\tm2 = val\n\t\tcase map[any]any:\n\t\t\tm2 = cast.ToStringMap(val)\n\t\tdefault:\n\t\t\t// immediate value\n\t\t\tshadow[strings.ToLower(fullKey)] = true\n\t\t\tcontinue\n\t\t}\n\t\t// recursively merge to shadow map\n\t\tshadow = v.flattenAndMergeMap(shadow, m2, fullKey)\n\t}\n\treturn shadow\n}\n\n// mergeFlatMap merges the given maps, excluding values of the second map\n// shadowed by values from the first map.\nfunc (v *Viper) mergeFlatMap(shadow map[string]bool, m map[string]any) map[string]bool {\n\t// scan keys\nouter:\n\tfor k := range m {\n\t\tpath := strings.Split(k, v.keyDelim)\n\t\t// scan intermediate paths\n\t\tvar parentKey string\n\t\tfor i := 1; i < len(path); i++ {\n\t\t\tparentKey = strings.Join(path[0:i], v.keyDelim)\n\t\t\tif shadow[parentKey] {\n\t\t\t\t// path is shadowed, continue\n\t\t\t\tcontinue outer\n\t\t\t}\n\t\t}\n\t\t// add key\n\t\tshadow[strings.ToLower(k)] = true\n\t}\n\treturn shadow\n}\n\n// AllSettings merges all settings and returns them as a map[string]any.\nfunc AllSettings() map[string]any { return v.AllSettings() }\n\nfunc (v *Viper) AllSettings() map[string]any {\n\treturn v.getSettings(v.AllKeys())\n}\n\nfunc (v *Viper) getSettings(keys []string) map[string]any {\n\tm := map[string]any{}\n\t// start from the list of keys, and construct the map one value at a time\n\tfor _, k := range keys {\n\t\tvalue := v.Get(k)\n\t\tif value == nil {\n\t\t\t// should not happen, since AllKeys() returns only keys holding a value,\n\t\t\t// check just in case anything changes\n\t\t\tcontinue\n\t\t}\n\t\tpath := strings.Split(k, v.keyDelim)\n\t\tlastKey := strings.ToLower(path[len(path)-1])\n\t\tdeepestMap := deepSearch(m, path[0:len(path)-1])\n\t\t// set innermost value\n\t\tdeepestMap[lastKey] = value\n\t}\n\treturn m\n}\n\n// SetFs sets the filesystem to use to read configuration.\nfunc SetFs(fs afero.Fs) { v.SetFs(fs) }\n\nfunc (v *Viper) SetFs(fs afero.Fs) {\n\tv.fs = fs\n}\n\n// SetConfigName sets name for the config file.\n// Does not include extension.\nfunc SetConfigName(in string) { v.SetConfigName(in) }\n\nfunc (v *Viper) SetConfigName(in string) {\n\tif v.finder != nil {\n\t\tv.logger.Warn(\"ineffective call to function: custom finder takes precedence\", slog.String(\"function\", \"SetConfigName\"))\n\t}\n\n\tif in != \"\" {\n\t\tv.configName = in\n\t\tv.configFile = \"\"\n\t}\n}\n\n// SetConfigType sets the type of the configuration returned by the\n// remote source, e.g. \"json\".\nfunc SetConfigType(in string) { v.SetConfigType(in) }\n\nfunc (v *Viper) SetConfigType(in string) {\n\tif in != \"\" {\n\t\tv.configType = in\n\t}\n}\n\n// SetConfigPermissions sets the permissions for the config file.\nfunc SetConfigPermissions(perm os.FileMode) { v.SetConfigPermissions(perm) }\n\nfunc (v *Viper) SetConfigPermissions(perm os.FileMode) {\n\tv.configPermissions = perm.Perm()\n}\n\nfunc (v *Viper) getConfigType() string {\n\tif v.configType != \"\" {\n\t\treturn v.configType\n\t}\n\n\tcf, err := v.getConfigFile()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\text := filepath.Ext(cf)\n\n\tif len(ext) > 1 {\n\t\treturn ext[1:]\n\t}\n\n\treturn \"\"\n}\n\nfunc (v *Viper) getConfigFile() (string, error) {\n\tif v.configFile == \"\" {\n\t\tcf, err := v.findConfigFile()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tv.configFile = cf\n\t}\n\treturn v.configFile, nil\n}\n\n// Debug prints all configuration registries for debugging\n// purposes.\nfunc Debug()              { v.Debug() }\nfunc DebugTo(w io.Writer) { v.DebugTo(w) }\n\nfunc (v *Viper) Debug() { v.DebugTo(os.Stdout) }\n\nfunc (v *Viper) DebugTo(w io.Writer) {\n\tfmt.Fprintf(w, \"Aliases:\\n%#v\\n\", v.aliases)\n\tfmt.Fprintf(w, \"Override:\\n%#v\\n\", v.override)\n\tfmt.Fprintf(w, \"PFlags:\\n%#v\\n\", v.pflags)\n\tfmt.Fprintf(w, \"Env:\\n%#v\\n\", v.env)\n\tfmt.Fprintf(w, \"Key/Value Store:\\n%#v\\n\", v.kvstore)\n\tfmt.Fprintf(w, \"Config:\\n%#v\\n\", v.config)\n\tfmt.Fprintf(w, \"Defaults:\\n%#v\\n\", v.defaults)\n}\n"
        },
        {
          "name": "viper_test.go",
          "type": "blob",
          "size": 62.91,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage viper\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n\t\"github.com/go-viper/mapstructure/v2\"\n\t\"github.com/sagikazarmark/locafero\"\n\t\"github.com/spf13/afero\"\n\t\"github.com/spf13/cast\"\n\t\"github.com/spf13/pflag\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/spf13/viper/internal/testutil\"\n)\n\n// var yamlExample = []byte(`Hacker: true\n// name: steve\n// hobbies:\n//     - skateboarding\n//     - snowboarding\n//     - go\n// clothing:\n//     jacket: leather\n//     trousers: denim\n//     pants:\n//         size: large\n// age: 35\n// eyes : brown\n// beard: true\n// `)\n\nvar yamlExampleWithExtras = []byte(`Existing: true\nBogus: true\n`)\n\ntype testUnmarshalExtra struct {\n\tExisting bool\n}\n\nvar tomlExample = []byte(`\ntitle = \"TOML Example\"\n\n[owner]\norganization = \"MongoDB\"\nBio = \"MongoDB Chief Developer Advocate & Hacker at Large\"\ndob = 1979-05-27T07:32:00Z # First class dates? Why not?`)\n\nvar dotenvExample = []byte(`\nTITLE_DOTENV=\"DotEnv Example\"\nTYPE_DOTENV=donut\nNAME_DOTENV=Cake`)\n\nvar jsonExample = []byte(`{\n\"id\": \"0001\",\n\"type\": \"donut\",\n\"name\": \"Cake\",\n\"ppu\": 0.55,\n\"batters\": {\n        \"batter\": [\n                { \"type\": \"Regular\" },\n                { \"type\": \"Chocolate\" },\n                { \"type\": \"Blueberry\" },\n                { \"type\": \"Devil's Food\" }\n            ]\n    }\n}`)\n\nvar remoteExample = []byte(`{\n\"id\":\"0002\",\n\"type\":\"cronut\",\n\"newkey\":\"remote\"\n}`)\n\nfunc initConfigs(v *Viper) {\n\tvar r io.Reader\n\tv.SetConfigType(\"yaml\")\n\tr = bytes.NewReader(yamlExample)\n\tv.unmarshalReader(r, v.config)\n\n\tv.SetConfigType(\"json\")\n\tr = bytes.NewReader(jsonExample)\n\tv.unmarshalReader(r, v.config)\n\n\tv.SetConfigType(\"toml\")\n\tr = bytes.NewReader(tomlExample)\n\tv.unmarshalReader(r, v.config)\n\n\tv.SetConfigType(\"env\")\n\tr = bytes.NewReader(dotenvExample)\n\tv.unmarshalReader(r, v.config)\n\n\tv.SetConfigType(\"json\")\n\tremote := bytes.NewReader(remoteExample)\n\tv.unmarshalReader(remote, v.kvstore)\n}\n\nfunc initConfig(typ, config string, v *Viper) {\n\tv.SetConfigType(typ)\n\tr := strings.NewReader(config)\n\n\tif err := v.unmarshalReader(r, v.config); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// initDirs makes directories for testing.\nfunc initDirs(t *testing.T) (string, string) {\n\tvar (\n\t\ttestDirs = []string{`a a`, `b`, `C_`}\n\t\tconfig   = `improbable`\n\t)\n\n\tif runtime.GOOS != \"windows\" {\n\t\ttestDirs = append(testDirs, `d\\d`)\n\t}\n\n\troot := t.TempDir()\n\n\tfor _, dir := range testDirs {\n\t\tinnerDir := filepath.Join(root, dir)\n\t\terr := os.Mkdir(innerDir, 0o750)\n\t\trequire.NoError(t, err)\n\n\t\terr = os.WriteFile(\n\t\t\tfilepath.Join(innerDir, config+\".toml\"),\n\t\t\t[]byte(`key = \"value is `+dir+`\"`+\"\\n\"),\n\t\t\t0o640)\n\t\trequire.NoError(t, err)\n\t}\n\n\treturn root, config\n}\n\n// stubs for PFlag Values.\ntype stringValue string\n\nfunc newStringValue(val string, p *string) *stringValue {\n\t*p = val\n\treturn (*stringValue)(p)\n}\n\nfunc (s *stringValue) Set(val string) error {\n\t*s = stringValue(val)\n\treturn nil\n}\n\nfunc (s *stringValue) Type() string {\n\treturn \"string\"\n}\n\nfunc (s *stringValue) String() string {\n\treturn string(*s)\n}\n\nfunc TestGetConfigFile(t *testing.T) {\n\tt.Run(\"config file set\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc/viper\")\n\t\tv.SetConfigFile(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"), filename)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"find file\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc/viper\")\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"), filename)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"find files only\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/config\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/config/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc\")\n\t\tv.AddConfigPath(\"/etc/config\")\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/etc/config/config.yaml\"), filename)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"precedence\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/home/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/home/viper/config.zml\"))\n\t\trequire.NoError(t, err)\n\n\t\terr = fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.bml\"))\n\t\trequire.NoError(t, err)\n\n\t\terr = fs.Mkdir(testutil.AbsFilePath(t, \"/var/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/var/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/home/viper\")\n\t\tv.AddConfigPath(\"/etc/viper\")\n\t\tv.AddConfigPath(\"/var/viper\")\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/var/viper/config.yaml\"), filename)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"without extension\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/.dotfilenoext\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc/viper\")\n\t\tv.SetConfigName(\".dotfilenoext\")\n\t\tv.SetConfigType(\"yaml\")\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/etc/viper/.dotfilenoext\"), filename)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"without extension and config type\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/.dotfilenoext\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc/viper\")\n\t\tv.SetConfigName(\".dotfilenoext\")\n\n\t\t_, err = v.getConfigFile()\n\t\t// unless config type is set, files without extension\n\t\t// are not considered\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"experimental finder\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\tv := NewWithOptions(ExperimentalFinder())\n\n\t\tv.SetFs(fs)\n\n\t\tv.AddConfigPath(\"/etc/viper\")\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"), testutil.AbsFilePath(t, filename))\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"finder\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\t_, err = fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\tfinder := locafero.Finder{\n\t\t\tPaths: []string{testutil.AbsFilePath(t, \"/etc/viper\")},\n\t\t\tNames: locafero.NameWithExtensions(\"config\", SupportedExts...),\n\t\t\tType:  locafero.FileTypeFile,\n\t\t}\n\n\t\tv := NewWithOptions(WithFinder(finder))\n\n\t\tv.SetFs(fs)\n\n\t\t// These should be ineffective\n\t\tv.AddConfigPath(\"/etc/something_else\")\n\t\tv.SetConfigName(\"not-config\")\n\n\t\tfilename, err := v.getConfigFile()\n\t\tassert.Equal(t, testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"), testutil.AbsFilePath(t, filename))\n\t\tassert.NoError(t, err)\n\t})\n}\n\nfunc TestReadInConfig(t *testing.T) {\n\tt.Run(\"config file set\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(\"/etc/viper\", 0o777)\n\t\trequire.NoError(t, err)\n\n\t\tfile, err := fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\t_, err = file.WriteString(`key: value`)\n\t\trequire.NoError(t, err)\n\n\t\tfile.Close()\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.SetConfigFile(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\n\t\terr = v.ReadInConfig()\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"value\", v.Get(\"key\"))\n\t})\n\n\tt.Run(\"find file\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\tfile, err := fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\t_, err = file.WriteString(`key: value`)\n\t\trequire.NoError(t, err)\n\n\t\tfile.Close()\n\n\t\tv := New()\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc/viper\")\n\n\t\terr = v.ReadInConfig()\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"value\", v.Get(\"key\"))\n\t})\n\n\tt.Run(\"find file with experimental finder\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\tfile, err := fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\t_, err = file.WriteString(`key: value`)\n\t\trequire.NoError(t, err)\n\n\t\tfile.Close()\n\n\t\tv := NewWithOptions(ExperimentalFinder())\n\n\t\tv.SetFs(fs)\n\t\tv.AddConfigPath(\"/etc/viper\")\n\n\t\terr = v.ReadInConfig()\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"value\", v.Get(\"key\"))\n\t})\n\n\tt.Run(\"find file using a finder\", func(t *testing.T) {\n\t\tfs := afero.NewMemMapFs()\n\n\t\terr := fs.Mkdir(testutil.AbsFilePath(t, \"/etc/viper\"), 0o777)\n\t\trequire.NoError(t, err)\n\n\t\tfile, err := fs.Create(testutil.AbsFilePath(t, \"/etc/viper/config.yaml\"))\n\t\trequire.NoError(t, err)\n\n\t\t_, err = file.WriteString(`key: value`)\n\t\trequire.NoError(t, err)\n\n\t\tfile.Close()\n\n\t\tfinder := locafero.Finder{\n\t\t\tPaths: []string{testutil.AbsFilePath(t, \"/etc/viper\")},\n\t\t\tNames: locafero.NameWithExtensions(\"config\", SupportedExts...),\n\t\t\tType:  locafero.FileTypeFile,\n\t\t}\n\n\t\tv := NewWithOptions(WithFinder(finder))\n\n\t\tv.SetFs(fs)\n\n\t\t// These should be ineffective\n\t\tv.AddConfigPath(\"/etc/something_else\")\n\t\tv.SetConfigName(\"not-config\")\n\n\t\terr = v.ReadInConfig()\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"value\", v.Get(\"key\"))\n\t})\n}\n\nfunc TestDefault(t *testing.T) {\n\tv := New()\n\tv.SetDefault(\"age\", 45)\n\tassert.Equal(t, 45, v.Get(\"age\"))\n\n\tv.SetDefault(\"clothing.jacket\", \"slacks\")\n\tassert.Equal(t, \"slacks\", v.Get(\"clothing.jacket\"))\n\n\tv.SetConfigType(\"yaml\")\n\terr := v.ReadConfig(bytes.NewBuffer(yamlExample))\n\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"leather\", v.Get(\"clothing.jacket\"))\n}\n\nfunc TestUnmarshaling(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\tr := bytes.NewReader(yamlExample)\n\n\tv.unmarshalReader(r, v.config)\n\tassert.True(t, v.InConfig(\"name\"))\n\tassert.True(t, v.InConfig(\"clothing.jacket\"))\n\tassert.False(t, v.InConfig(\"state\"))\n\tassert.False(t, v.InConfig(\"clothing.hat\"))\n\tassert.Equal(t, \"steve\", v.Get(\"name\"))\n\tassert.Equal(t, []any{\"skateboarding\", \"snowboarding\", \"go\"}, v.Get(\"hobbies\"))\n\tassert.Equal(t, map[string]any{\"jacket\": \"leather\", \"trousers\": \"denim\", \"pants\": map[string]any{\"size\": \"large\"}}, v.Get(\"clothing\"))\n\tassert.Equal(t, 35, v.Get(\"age\"))\n}\n\nfunc TestUnmarshalExact(t *testing.T) {\n\tv := New()\n\ttarget := &testUnmarshalExtra{}\n\tv.SetConfigType(\"yaml\")\n\tr := bytes.NewReader(yamlExampleWithExtras)\n\tv.ReadConfig(r)\n\terr := v.UnmarshalExact(target)\n\tassert.Error(t, err, \"UnmarshalExact should error when populating a struct from a conf that contains unused fields\")\n}\n\nfunc TestOverrides(t *testing.T) {\n\tv := New()\n\tv.Set(\"age\", 40)\n\tassert.Equal(t, 40, v.Get(\"age\"))\n}\n\nfunc TestDefaultPost(t *testing.T) {\n\tv := New()\n\tassert.NotEqual(t, \"NYC\", v.Get(\"state\"))\n\tv.SetDefault(\"state\", \"NYC\")\n\tassert.Equal(t, \"NYC\", v.Get(\"state\"))\n}\n\nfunc TestAliases(t *testing.T) {\n\tv := New()\n\tv.Set(\"age\", 40)\n\tv.RegisterAlias(\"years\", \"age\")\n\tassert.Equal(t, 40, v.Get(\"years\"))\n\tv.Set(\"years\", 45)\n\tassert.Equal(t, 45, v.Get(\"age\"))\n}\n\nfunc TestAliasInConfigFile(t *testing.T) {\n\tv := New()\n\n\tv.SetConfigType(\"yaml\")\n\n\t// Read the YAML data into Viper configuration\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(yamlExample)), \"Error reading YAML data\")\n\n\tv.RegisterAlias(\"beard\", \"hasbeard\")\n\tassert.Equal(t, true, v.Get(\"hasbeard\"))\n\n\tv.Set(\"hasbeard\", false)\n\tassert.Equal(t, false, v.Get(\"beard\"))\n}\n\nfunc TestYML(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\n\t// Read the YAML data into Viper configuration\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(yamlExample)), \"Error reading YAML data\")\n\n\tassert.Equal(t, \"steve\", v.Get(\"name\"))\n}\n\nfunc TestJSON(t *testing.T) {\n\tv := New()\n\n\tv.SetConfigType(\"json\")\n\t// Read the JSON data into Viper configuration\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading JSON data\")\n\n\tassert.Equal(t, \"0001\", v.Get(\"id\"))\n}\n\nfunc TestTOML(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"toml\")\n\n\t// Read the TOML data into Viper configuration\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(tomlExample)), \"Error reading toml data\")\n\n\tassert.Equal(t, \"TOML Example\", v.Get(\"title\"))\n}\n\nfunc TestDotEnv(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"env\")\n\t// Read the dotenv data into Viper configuration\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(dotenvExample)), \"Error reading env data\")\n\n\tassert.Equal(t, \"DotEnv Example\", v.Get(\"title_dotenv\"))\n}\n\nfunc TestRemotePrecedence(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\t// Read the remote data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading json data\")\n\n\tassert.Equal(t, \"0001\", v.Get(\"id\"))\n\n\t// update the kvstore with the remoteExample which should overite the key in v.config\n\tremote := bytes.NewReader(remoteExample)\n\trequire.NoError(t, v.unmarshalReader(remote, v.kvstore), \"Error reading json data in to kvstore\")\n\n\tassert.Equal(t, \"0001\", v.Get(\"id\"))\n\tassert.NotEqual(t, \"cronut\", v.Get(\"type\"))\n\tassert.Equal(t, \"remote\", v.Get(\"newkey\"))\n\tv.Set(\"newkey\", \"newvalue\")\n\tassert.NotEqual(t, \"remote\", v.Get(\"newkey\"))\n\tassert.Equal(t, \"newvalue\", v.Get(\"newkey\"))\n}\n\nfunc TestEnv(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\t// Read the JSON data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading json data\")\n\n\tv.BindEnv(\"id\")\n\tv.BindEnv(\"f\", \"FOOD\", \"OLD_FOOD\")\n\n\tt.Setenv(\"ID\", \"13\")\n\tt.Setenv(\"FOOD\", \"apple\")\n\tt.Setenv(\"OLD_FOOD\", \"banana\")\n\tt.Setenv(\"NAME\", \"crunk\")\n\n\tassert.Equal(t, \"13\", v.Get(\"id\"))\n\tassert.Equal(t, \"apple\", v.Get(\"f\"))\n\tassert.Equal(t, \"Cake\", v.Get(\"name\"))\n\n\tv.AutomaticEnv()\n\n\tassert.Equal(t, \"crunk\", v.Get(\"name\"))\n}\n\nfunc TestMultipleEnv(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\t// Read the JSON data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading json data\")\n\n\tv.BindEnv(\"f\", \"FOOD\", \"OLD_FOOD\")\n\n\tt.Setenv(\"OLD_FOOD\", \"banana\")\n\n\tassert.Equal(t, \"banana\", v.Get(\"f\"))\n}\n\nfunc TestEmptyEnv(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\t// Read the JSON data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading json data\")\n\n\tv.BindEnv(\"type\") // Empty environment variable\n\tv.BindEnv(\"name\") // Bound, but not set environment variable\n\n\tt.Setenv(\"TYPE\", \"\")\n\n\tassert.Equal(t, \"donut\", v.Get(\"type\"))\n\tassert.Equal(t, \"Cake\", v.Get(\"name\"))\n}\n\nfunc TestEmptyEnv_Allowed(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\t// Read the JSON data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading json data\")\n\n\tv.AllowEmptyEnv(true)\n\n\tv.BindEnv(\"type\") // Empty environment variable\n\tv.BindEnv(\"name\") // Bound, but not set environment variable\n\n\tt.Setenv(\"TYPE\", \"\")\n\n\tassert.Equal(t, \"\", v.Get(\"type\"))\n\tassert.Equal(t, \"Cake\", v.Get(\"name\"))\n}\n\nfunc TestEnvPrefix(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\t// Read the JSON data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading json data\")\n\n\tv.SetEnvPrefix(\"foo\") // will be uppercased automatically\n\tv.BindEnv(\"id\")\n\tv.BindEnv(\"f\", \"FOOD\") // not using prefix\n\n\tt.Setenv(\"FOO_ID\", \"13\")\n\tt.Setenv(\"FOOD\", \"apple\")\n\tt.Setenv(\"FOO_NAME\", \"crunk\")\n\n\tassert.Equal(t, \"13\", v.Get(\"id\"))\n\tassert.Equal(t, \"apple\", v.Get(\"f\"))\n\tassert.Equal(t, \"Cake\", v.Get(\"name\"))\n\n\tv.AutomaticEnv()\n\n\tassert.Equal(t, \"crunk\", v.Get(\"name\"))\n}\n\nfunc TestAutoEnv(t *testing.T) {\n\tv := New()\n\n\tv.AutomaticEnv()\n\n\tt.Setenv(\"FOO_BAR\", \"13\")\n\n\tassert.Equal(t, \"13\", v.Get(\"foo_bar\"))\n}\n\nfunc TestAutoEnvWithPrefix(t *testing.T) {\n\tv := New()\n\tv.AutomaticEnv()\n\tv.SetEnvPrefix(\"Baz\")\n\tt.Setenv(\"BAZ_BAR\", \"13\")\n\tassert.Equal(t, \"13\", v.Get(\"bar\"))\n}\n\nfunc TestSetEnvKeyReplacer(t *testing.T) {\n\tv := New()\n\tv.AutomaticEnv()\n\n\tt.Setenv(\"REFRESH_INTERVAL\", \"30s\")\n\n\treplacer := strings.NewReplacer(\"-\", \"_\")\n\tv.SetEnvKeyReplacer(replacer)\n\n\tassert.Equal(t, \"30s\", v.Get(\"refresh-interval\"))\n}\n\nfunc TestEnvKeyReplacer(t *testing.T) {\n\tv := NewWithOptions(EnvKeyReplacer(strings.NewReplacer(\"-\", \"_\")))\n\tv.AutomaticEnv()\n\tt.Setenv(\"REFRESH_INTERVAL\", \"30s\")\n\tassert.Equal(t, \"30s\", v.Get(\"refresh-interval\"))\n}\n\nfunc TestEnvSubConfig(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\t// Read the YAML data into Viper configuration v.config\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(yamlExample)), \"Error reading json data\")\n\tv.AutomaticEnv()\n\tv.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\n\tt.Setenv(\"CLOTHING_PANTS_SIZE\", \"small\")\n\tsubv := v.Sub(\"clothing\").Sub(\"pants\")\n\tassert.Equal(t, \"small\", subv.Get(\"size\"))\n\n\t// again with EnvPrefix\n\tv.SetEnvPrefix(\"foo\") // will be uppercased automatically\n\tsubWithPrefix := v.Sub(\"clothing\").Sub(\"pants\")\n\tt.Setenv(\"FOO_CLOTHING_PANTS_SIZE\", \"large\")\n\tassert.Equal(t, \"large\", subWithPrefix.Get(\"size\"))\n}\n\nfunc TestAllKeys(t *testing.T) {\n\tv := New()\n\tinitConfigs(v)\n\n\tks := []string{\n\t\t\"title\",\n\t\t\"newkey\",\n\t\t\"owner.organization\",\n\t\t\"owner.dob\",\n\t\t\"owner.bio\",\n\t\t\"name\",\n\t\t\"beard\",\n\t\t\"ppu\",\n\t\t\"batters.batter\",\n\t\t\"hobbies\",\n\t\t\"clothing.jacket\",\n\t\t\"clothing.trousers\",\n\t\t\"clothing.pants.size\",\n\t\t\"age\",\n\t\t\"hacker\",\n\t\t\"id\",\n\t\t\"type\",\n\t\t\"eyes\",\n\t\t\"title_dotenv\",\n\t\t\"type_dotenv\",\n\t\t\"name_dotenv\",\n\t}\n\tdob, _ := time.Parse(time.RFC3339, \"1979-05-27T07:32:00Z\")\n\tall := map[string]any{\n\t\t\"owner\": map[string]any{\n\t\t\t\"organization\": \"MongoDB\",\n\t\t\t\"bio\":          \"MongoDB Chief Developer Advocate & Hacker at Large\",\n\t\t\t\"dob\":          dob,\n\t\t},\n\t\t\"title\": \"TOML Example\",\n\t\t\"ppu\":   0.55,\n\t\t\"eyes\":  \"brown\",\n\t\t\"clothing\": map[string]any{\n\t\t\t\"trousers\": \"denim\",\n\t\t\t\"jacket\":   \"leather\",\n\t\t\t\"pants\":    map[string]any{\"size\": \"large\"},\n\t\t},\n\t\t\"id\": \"0001\",\n\t\t\"batters\": map[string]any{\n\t\t\t\"batter\": []any{\n\t\t\t\tmap[string]any{\"type\": \"Regular\"},\n\t\t\t\tmap[string]any{\"type\": \"Chocolate\"},\n\t\t\t\tmap[string]any{\"type\": \"Blueberry\"},\n\t\t\t\tmap[string]any{\"type\": \"Devil's Food\"},\n\t\t\t},\n\t\t},\n\t\t\"hacker\": true,\n\t\t\"beard\":  true,\n\t\t\"hobbies\": []any{\n\t\t\t\"skateboarding\",\n\t\t\t\"snowboarding\",\n\t\t\t\"go\",\n\t\t},\n\t\t\"age\":          35,\n\t\t\"type\":         \"donut\",\n\t\t\"newkey\":       \"remote\",\n\t\t\"name\":         \"Cake\",\n\t\t\"title_dotenv\": \"DotEnv Example\",\n\t\t\"type_dotenv\":  \"donut\",\n\t\t\"name_dotenv\":  \"Cake\",\n\t}\n\n\tassert.ElementsMatch(t, ks, v.AllKeys())\n\tassert.Equal(t, all, v.AllSettings())\n}\n\nfunc TestAllKeysWithEnv(t *testing.T) {\n\tv := New()\n\n\t// bind and define environment variables (including a nested one)\n\tv.BindEnv(\"id\")\n\tv.BindEnv(\"foo.bar\")\n\tv.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\n\tt.Setenv(\"ID\", \"13\")\n\tt.Setenv(\"FOO_BAR\", \"baz\")\n\n\tassert.ElementsMatch(t, []string{\"id\", \"foo.bar\"}, v.AllKeys())\n}\n\nfunc TestAliasesOfAliases(t *testing.T) {\n\tv := New()\n\tv.Set(\"Title\", \"Checking Case\")\n\tv.RegisterAlias(\"Foo\", \"Bar\")\n\tv.RegisterAlias(\"Bar\", \"Title\")\n\tassert.Equal(t, \"Checking Case\", v.Get(\"FOO\"))\n}\n\nfunc TestRecursiveAliases(t *testing.T) {\n\tv := New()\n\tv.Set(\"baz\", \"bat\")\n\tv.RegisterAlias(\"Baz\", \"Roo\")\n\tv.RegisterAlias(\"Roo\", \"baz\")\n\tassert.Equal(t, \"bat\", v.Get(\"Baz\"))\n}\n\nfunc TestUnmarshal(t *testing.T) {\n\tv := New()\n\tv.SetDefault(\"port\", 1313)\n\tv.Set(\"name\", \"Steve\")\n\tv.Set(\"duration\", \"1s1ms\")\n\tv.Set(\"modes\", []int{1, 2, 3})\n\n\ttype config struct {\n\t\tPort     int\n\t\tName     string\n\t\tDuration time.Duration\n\t\tModes    []int\n\t}\n\n\tvar C config\n\trequire.NoError(t, v.Unmarshal(&C), \"unable to decode into struct\")\n\n\tassert.Equal(\n\t\tt,\n\t\t&config{\n\t\t\tName:     \"Steve\",\n\t\t\tPort:     1313,\n\t\t\tDuration: time.Second + time.Millisecond,\n\t\t\tModes:    []int{1, 2, 3},\n\t\t},\n\t\t&C,\n\t)\n\n\tv.Set(\"port\", 1234)\n\trequire.NoError(t, v.Unmarshal(&C), \"unable to decode into struct\")\n\n\tassert.Equal(\n\t\tt,\n\t\t&config{\n\t\t\tName:     \"Steve\",\n\t\t\tPort:     1234,\n\t\t\tDuration: time.Second + time.Millisecond,\n\t\t\tModes:    []int{1, 2, 3},\n\t\t},\n\t\t&C,\n\t)\n}\n\nfunc TestUnmarshalWithDefaultDecodeHook(t *testing.T) {\n\topt := mapstructure.ComposeDecodeHookFunc(\n\t\tmapstructure.StringToTimeDurationHookFunc(),\n\t\tmapstructure.StringToSliceHookFunc(\",\"),\n\t\t// Custom Decode Hook Function\n\t\tfunc(rf reflect.Kind, rt reflect.Kind, data any) (any, error) {\n\t\t\tif rf != reflect.String || rt != reflect.Map {\n\t\t\t\treturn data, nil\n\t\t\t}\n\t\t\tm := map[string]string{}\n\t\t\traw := data.(string)\n\t\t\tif raw == \"\" {\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t\terr := json.Unmarshal([]byte(raw), &m)\n\t\t\treturn m, err\n\t\t},\n\t)\n\n\tv := NewWithOptions(WithDecodeHook(opt))\n\tv.Set(\"credentials\", \"{\\\"foo\\\":\\\"bar\\\"}\")\n\n\ttype config struct {\n\t\tCredentials map[string]string\n\t}\n\n\tvar C config\n\n\trequire.NoError(t, v.Unmarshal(&C), \"unable to decode into struct\")\n\n\tassert.Equal(t, &config{\n\t\tCredentials: map[string]string{\"foo\": \"bar\"},\n\t}, &C)\n}\n\nfunc TestUnmarshalWithDecoderOptions(t *testing.T) {\n\tv := New()\n\tv.Set(\"credentials\", \"{\\\"foo\\\":\\\"bar\\\"}\")\n\n\topt := DecodeHook(mapstructure.ComposeDecodeHookFunc(\n\t\tmapstructure.StringToTimeDurationHookFunc(),\n\t\tmapstructure.StringToSliceHookFunc(\",\"),\n\t\t// Custom Decode Hook Function\n\t\tfunc(rf reflect.Kind, rt reflect.Kind, data any) (any, error) {\n\t\t\tif rf != reflect.String || rt != reflect.Map {\n\t\t\t\treturn data, nil\n\t\t\t}\n\t\t\tm := map[string]string{}\n\t\t\traw := data.(string)\n\t\t\tif raw == \"\" {\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t\terr := json.Unmarshal([]byte(raw), &m)\n\t\t\treturn m, err\n\t\t},\n\t))\n\n\ttype config struct {\n\t\tCredentials map[string]string\n\t}\n\n\tvar C config\n\n\trequire.NoError(t, v.Unmarshal(&C, opt), \"unable to decode into struct\")\n\n\tassert.Equal(t, &config{\n\t\tCredentials: map[string]string{\"foo\": \"bar\"},\n\t}, &C)\n}\n\nfunc TestUnmarshalWithAutomaticEnv(t *testing.T) {\n\tt.Setenv(\"PORT\", \"1313\")\n\tt.Setenv(\"NAME\", \"Steve\")\n\tt.Setenv(\"DURATION\", \"1s1ms\")\n\tt.Setenv(\"MODES\", \"1,2,3\")\n\tt.Setenv(\"SECRET\", \"42\")\n\tt.Setenv(\"FILESYSTEM_SIZE\", \"4096\")\n\n\ttype AuthConfig struct {\n\t\tSecret string `mapstructure:\"secret\"`\n\t}\n\n\ttype StorageConfig struct {\n\t\tSize int `mapstructure:\"size\"`\n\t}\n\n\ttype Configuration struct {\n\t\tPort     int           `mapstructure:\"port\"`\n\t\tName     string        `mapstructure:\"name\"`\n\t\tDuration time.Duration `mapstructure:\"duration\"`\n\n\t\t// Infer name from struct\n\t\tModes []int\n\n\t\t// Squash nested struct (omit prefix)\n\t\tAuthentication AuthConfig `mapstructure:\",squash\"`\n\n\t\t// Different key\n\t\tStorage StorageConfig `mapstructure:\"filesystem\"`\n\n\t\t// Omitted field\n\t\tFlag bool `mapstructure:\"flag\"`\n\t}\n\n\tv := NewWithOptions(ExperimentalBindStruct())\n\tv.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\tv.AutomaticEnv()\n\n\tt.Run(\"OK\", func(t *testing.T) {\n\t\tvar config Configuration\n\t\tif err := v.Unmarshal(&config); err != nil {\n\t\t\tt.Fatalf(\"unable to decode into struct, %v\", err)\n\t\t}\n\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tConfiguration{\n\t\t\t\tName:     \"Steve\",\n\t\t\t\tPort:     1313,\n\t\t\t\tDuration: time.Second + time.Millisecond,\n\t\t\t\tModes:    []int{1, 2, 3},\n\t\t\t\tAuthentication: AuthConfig{\n\t\t\t\t\tSecret: \"42\",\n\t\t\t\t},\n\t\t\t\tStorage: StorageConfig{\n\t\t\t\t\tSize: 4096,\n\t\t\t\t},\n\t\t\t},\n\t\t\tconfig,\n\t\t)\n\t})\n\n\tt.Run(\"Precedence\", func(t *testing.T) {\n\t\tvar config Configuration\n\n\t\tv.Set(\"port\", 1234)\n\t\tif err := v.Unmarshal(&config); err != nil {\n\t\t\tt.Fatalf(\"unable to decode into struct, %v\", err)\n\t\t}\n\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tConfiguration{\n\t\t\t\tName:     \"Steve\",\n\t\t\t\tPort:     1234,\n\t\t\t\tDuration: time.Second + time.Millisecond,\n\t\t\t\tModes:    []int{1, 2, 3},\n\t\t\t\tAuthentication: AuthConfig{\n\t\t\t\t\tSecret: \"42\",\n\t\t\t\t},\n\t\t\t\tStorage: StorageConfig{\n\t\t\t\t\tSize: 4096,\n\t\t\t\t},\n\t\t\t},\n\t\t\tconfig,\n\t\t)\n\t})\n\n\tt.Run(\"Unset\", func(t *testing.T) {\n\t\tvar config Configuration\n\n\t\terr := v.Unmarshal(&config, func(config *mapstructure.DecoderConfig) {\n\t\t\tconfig.ErrorUnset = true\n\t\t})\n\n\t\tassert.Error(t, err, \"expected viper.Unmarshal to return error due to unset field 'FLAG'\")\n\t})\n\n\tt.Run(\"Exact\", func(t *testing.T) {\n\t\tvar config Configuration\n\n\t\tv.Set(\"port\", 1234)\n\t\tif err := v.UnmarshalExact(&config); err != nil {\n\t\t\tt.Fatalf(\"unable to decode into struct, %v\", err)\n\t\t}\n\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tConfiguration{\n\t\t\t\tName:     \"Steve\",\n\t\t\t\tPort:     1234,\n\t\t\t\tDuration: time.Second + time.Millisecond,\n\t\t\t\tModes:    []int{1, 2, 3},\n\t\t\t\tAuthentication: AuthConfig{\n\t\t\t\t\tSecret: \"42\",\n\t\t\t\t},\n\t\t\t\tStorage: StorageConfig{\n\t\t\t\t\tSize: 4096,\n\t\t\t\t},\n\t\t\t},\n\t\t\tconfig,\n\t\t)\n\t})\n}\n\nfunc TestBindPFlags(t *testing.T) {\n\tv := New() // create independent Viper object\n\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\n\ttestValues := map[string]*string{\n\t\t\"host\":     nil,\n\t\t\"port\":     nil,\n\t\t\"endpoint\": nil,\n\t}\n\n\tmutatedTestValues := map[string]string{\n\t\t\"host\":     \"localhost\",\n\t\t\"port\":     \"6060\",\n\t\t\"endpoint\": \"/public\",\n\t}\n\n\tfor name := range testValues {\n\t\ttestValues[name] = flagSet.String(name, \"\", \"test\")\n\t}\n\n\terr := v.BindPFlags(flagSet)\n\trequire.NoError(t, err, \"error binding flag set\")\n\n\tflagSet.VisitAll(func(flag *pflag.Flag) {\n\t\tflag.Value.Set(mutatedTestValues[flag.Name])\n\t\tflag.Changed = true\n\t})\n\n\tfor name, expected := range mutatedTestValues {\n\t\tassert.Equal(t, expected, v.Get(name))\n\t}\n}\n\nfunc TestBindPFlagsStringSlice(t *testing.T) {\n\ttests := []struct {\n\t\tExpected []string\n\t\tValue    string\n\t}{\n\t\t{[]string{}, \"\"},\n\t\t{[]string{\"jeden\"}, \"jeden\"},\n\t\t{[]string{\"dwa\", \"trzy\"}, \"dwa,trzy\"},\n\t\t{[]string{\"cztery\", \"piec , szesc\"}, \"cztery,\\\"piec , szesc\\\"\"},\n\t}\n\n\tv := New() // create independent Viper object\n\tdefaultVal := []string{\"default\"}\n\tv.SetDefault(\"stringslice\", defaultVal)\n\n\tfor _, testValue := range tests {\n\t\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\t\tflagSet.StringSlice(\"stringslice\", testValue.Expected, \"test\")\n\n\t\tfor _, changed := range []bool{true, false} {\n\t\t\tflagSet.VisitAll(func(f *pflag.Flag) {\n\t\t\t\tf.Value.Set(testValue.Value)\n\t\t\t\tf.Changed = changed\n\t\t\t})\n\n\t\t\terr := v.BindPFlags(flagSet)\n\t\t\trequire.NoError(t, err, \"error binding flag set\")\n\n\t\t\ttype TestStr struct {\n\t\t\t\tStringSlice []string\n\t\t\t}\n\t\t\tval := &TestStr{}\n\t\t\terr = v.Unmarshal(val)\n\t\t\trequire.NoError(t, err, \"cannot unmarshal\")\n\t\t\tif changed {\n\t\t\t\tassert.Equal(t, testValue.Expected, val.StringSlice)\n\t\t\t\tassert.Equal(t, testValue.Expected, v.Get(\"stringslice\"))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, defaultVal, val.StringSlice)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBindPFlagsStringArray(t *testing.T) {\n\ttests := []struct {\n\t\tExpected []string\n\t\tValue    string\n\t}{\n\t\t{[]string{}, \"\"},\n\t\t{[]string{\"jeden\"}, \"jeden\"},\n\t\t{[]string{\"dwa,trzy\"}, \"dwa,trzy\"},\n\t\t{[]string{\"cztery,\\\"piec , szesc\\\"\"}, \"cztery,\\\"piec , szesc\\\"\"},\n\t}\n\n\tv := New() // create independent Viper object\n\tdefaultVal := []string{\"default\"}\n\tv.SetDefault(\"stringarray\", defaultVal)\n\n\tfor _, testValue := range tests {\n\t\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\t\tflagSet.StringArray(\"stringarray\", testValue.Expected, \"test\")\n\n\t\tfor _, changed := range []bool{true, false} {\n\t\t\tflagSet.VisitAll(func(f *pflag.Flag) {\n\t\t\t\tf.Value.Set(testValue.Value)\n\t\t\t\tf.Changed = changed\n\t\t\t})\n\n\t\t\terr := v.BindPFlags(flagSet)\n\t\t\trequire.NoError(t, err, \"error binding flag set\")\n\n\t\t\ttype TestStr struct {\n\t\t\t\tStringArray []string\n\t\t\t}\n\t\t\tval := &TestStr{}\n\t\t\terr = v.Unmarshal(val)\n\t\t\trequire.NoError(t, err, \"cannot unmarshal\")\n\t\t\tif changed {\n\t\t\t\tassert.Equal(t, testValue.Expected, val.StringArray)\n\t\t\t\tassert.Equal(t, testValue.Expected, v.Get(\"stringarray\"))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, defaultVal, val.StringArray)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSliceFlagsReturnCorrectType(t *testing.T) {\n\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\tflagSet.IntSlice(\"int\", []int{1, 2}, \"\")\n\tflagSet.StringSlice(\"str\", []string{\"3\", \"4\"}, \"\")\n\tflagSet.DurationSlice(\"duration\", []time.Duration{5 * time.Second}, \"\")\n\n\tv := New()\n\tv.BindPFlags(flagSet)\n\n\tall := v.AllSettings()\n\n\tassert.IsType(t, []int{}, all[\"int\"])\n\tassert.IsType(t, []string{}, all[\"str\"])\n\tassert.IsType(t, []time.Duration{}, all[\"duration\"])\n}\n\nfunc TestBindPFlagsIntSlice(t *testing.T) {\n\ttests := []struct {\n\t\tExpected []int\n\t\tValue    string\n\t}{\n\t\t{[]int{}, \"\"},\n\t\t{[]int{1}, \"1\"},\n\t\t{[]int{2, 3}, \"2,3\"},\n\t}\n\n\tv := New() // create independent Viper object\n\tdefaultVal := []int{0}\n\tv.SetDefault(\"intslice\", defaultVal)\n\n\tfor _, testValue := range tests {\n\t\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\t\tflagSet.IntSlice(\"intslice\", testValue.Expected, \"test\")\n\n\t\tfor _, changed := range []bool{true, false} {\n\t\t\tflagSet.VisitAll(func(f *pflag.Flag) {\n\t\t\t\tf.Value.Set(testValue.Value)\n\t\t\t\tf.Changed = changed\n\t\t\t})\n\n\t\t\terr := v.BindPFlags(flagSet)\n\t\t\trequire.NoError(t, err, \"error binding flag set\")\n\n\t\t\ttype TestInt struct {\n\t\t\t\tIntSlice []int\n\t\t\t}\n\t\t\tval := &TestInt{}\n\t\t\terr = v.Unmarshal(val)\n\t\t\trequire.NoError(t, err, \"cannot unmarshal\")\n\t\t\tif changed {\n\t\t\t\tassert.Equal(t, testValue.Expected, val.IntSlice)\n\t\t\t\tassert.Equal(t, testValue.Expected, v.Get(\"intslice\"))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, defaultVal, val.IntSlice)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBindPFlag(t *testing.T) {\n\tv := New()\n\ttestString := \"testing\"\n\ttestValue := newStringValue(testString, &testString)\n\n\tflag := &pflag.Flag{\n\t\tName:    \"testflag\",\n\t\tValue:   testValue,\n\t\tChanged: false,\n\t}\n\n\tv.BindPFlag(\"testvalue\", flag)\n\n\tassert.Equal(t, testString, v.Get(\"testvalue\"))\n\n\tflag.Value.Set(\"testing_mutate\")\n\tflag.Changed = true // hack for pflag usage\n\n\tassert.Equal(t, \"testing_mutate\", v.Get(\"testvalue\"))\n}\n\nfunc TestBindPFlagDetectNilFlag(t *testing.T) {\n\tv := New()\n\tresult := v.BindPFlag(\"testvalue\", nil)\n\tassert.Error(t, result)\n}\n\nfunc TestBindPFlagStringToString(t *testing.T) {\n\ttests := []struct {\n\t\tExpected map[string]string\n\t\tValue    string\n\t}{\n\t\t{map[string]string{}, \"\"},\n\t\t{map[string]string{\"yo\": \"hi\"}, \"yo=hi\"},\n\t\t{map[string]string{\"yo\": \"hi\", \"oh\": \"hi=there\"}, \"yo=hi,oh=hi=there\"},\n\t\t{map[string]string{\"yo\": \"\"}, \"yo=\"},\n\t\t{map[string]string{\"yo\": \"\", \"oh\": \"hi=there\"}, \"yo=,oh=hi=there\"},\n\t}\n\n\tv := New() // create independent Viper object\n\tdefaultVal := map[string]string{}\n\tv.SetDefault(\"stringtostring\", defaultVal)\n\n\tfor _, testValue := range tests {\n\t\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\t\tflagSet.StringToString(\"stringtostring\", testValue.Expected, \"test\")\n\n\t\tfor _, changed := range []bool{true, false} {\n\t\t\tflagSet.VisitAll(func(f *pflag.Flag) {\n\t\t\t\tf.Value.Set(testValue.Value)\n\t\t\t\tf.Changed = changed\n\t\t\t})\n\n\t\t\terr := v.BindPFlags(flagSet)\n\t\t\trequire.NoError(t, err, \"error binding flag set\")\n\n\t\t\ttype TestMap struct {\n\t\t\t\tStringToString map[string]string\n\t\t\t}\n\t\t\tval := &TestMap{}\n\t\t\terr = v.Unmarshal(val)\n\t\t\trequire.NoError(t, err, \"cannot unmarshal\")\n\t\t\tif changed {\n\t\t\t\tassert.Equal(t, testValue.Expected, val.StringToString)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, defaultVal, val.StringToString)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBindPFlagStringToInt(t *testing.T) {\n\ttests := []struct {\n\t\tExpected map[string]int\n\t\tValue    string\n\t}{\n\t\t{map[string]int{\"yo\": 1, \"oh\": 21}, \"yo=1,oh=21\"},\n\t\t{map[string]int{\"yo\": 100000000, \"oh\": 0}, \"yo=100000000,oh=0\"},\n\t\t{map[string]int{}, \"yo=2,oh=21.0\"},\n\t\t{map[string]int{}, \"yo=,oh=20.99\"},\n\t\t{map[string]int{}, \"yo=,oh=\"},\n\t}\n\n\tv := New() // create independent Viper object\n\tdefaultVal := map[string]int{}\n\tv.SetDefault(\"stringtoint\", defaultVal)\n\n\tfor _, testValue := range tests {\n\t\tflagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\t\tflagSet.StringToInt(\"stringtoint\", testValue.Expected, \"test\")\n\n\t\tfor _, changed := range []bool{true, false} {\n\t\t\tflagSet.VisitAll(func(f *pflag.Flag) {\n\t\t\t\tf.Value.Set(testValue.Value)\n\t\t\t\tf.Changed = changed\n\t\t\t})\n\n\t\t\terr := v.BindPFlags(flagSet)\n\t\t\trequire.NoError(t, err, \"error binding flag set\")\n\n\t\t\ttype TestMap struct {\n\t\t\t\tStringToInt map[string]int\n\t\t\t}\n\t\t\tval := &TestMap{}\n\t\t\terr = v.Unmarshal(val)\n\t\t\trequire.NoError(t, err, \"cannot unmarshal\")\n\t\t\tif changed {\n\t\t\t\tassert.Equal(t, testValue.Expected, val.StringToInt)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, defaultVal, val.StringToInt)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBoundCaseSensitivity(t *testing.T) {\n\tv := New()\n\tinitConfigs(v)\n\tassert.Equal(t, \"brown\", v.Get(\"eyes\"))\n\n\tv.BindEnv(\"eYEs\", \"TURTLE_EYES\")\n\n\tt.Setenv(\"TURTLE_EYES\", \"blue\")\n\n\tassert.Equal(t, \"blue\", v.Get(\"eyes\"))\n\n\ttestString := \"green\"\n\ttestValue := newStringValue(testString, &testString)\n\n\tflag := &pflag.Flag{\n\t\tName:    \"eyeballs\",\n\t\tValue:   testValue,\n\t\tChanged: true,\n\t}\n\n\tv.BindPFlag(\"eYEs\", flag)\n\tassert.Equal(t, \"green\", v.Get(\"eyes\"))\n}\n\nfunc TestSizeInBytes(t *testing.T) {\n\tinput := map[string]uint{\n\t\t\"\":               0,\n\t\t\"b\":              0,\n\t\t\"12 bytes\":       0,\n\t\t\"200000000000gb\": 0,\n\t\t\"12 b\":           12,\n\t\t\"43 MB\":          43 * (1 << 20),\n\t\t\"10mb\":           10 * (1 << 20),\n\t\t\"1gb\":            1 << 30,\n\t}\n\n\tfor str, expected := range input {\n\t\tassert.Equal(t, expected, parseSizeInBytes(str), str)\n\t}\n}\n\nfunc TestFindsNestedKeys(t *testing.T) {\n\tv := New()\n\tinitConfigs(v)\n\tdob, _ := time.Parse(time.RFC3339, \"1979-05-27T07:32:00Z\")\n\n\tv.Set(\"super\", map[string]any{\n\t\t\"deep\": map[string]any{\n\t\t\t\"nested\": \"value\",\n\t\t},\n\t})\n\n\texpected := map[string]any{\n\t\t\"super\": map[string]any{\n\t\t\t\"deep\": map[string]any{\n\t\t\t\t\"nested\": \"value\",\n\t\t\t},\n\t\t},\n\t\t\"super.deep\": map[string]any{\n\t\t\t\"nested\": \"value\",\n\t\t},\n\t\t\"super.deep.nested\":  \"value\",\n\t\t\"owner.organization\": \"MongoDB\",\n\t\t\"batters.batter\": []any{\n\t\t\tmap[string]any{\n\t\t\t\t\"type\": \"Regular\",\n\t\t\t},\n\t\t\tmap[string]any{\n\t\t\t\t\"type\": \"Chocolate\",\n\t\t\t},\n\t\t\tmap[string]any{\n\t\t\t\t\"type\": \"Blueberry\",\n\t\t\t},\n\t\t\tmap[string]any{\n\t\t\t\t\"type\": \"Devil's Food\",\n\t\t\t},\n\t\t},\n\t\t\"hobbies\": []any{\n\t\t\t\"skateboarding\", \"snowboarding\", \"go\",\n\t\t},\n\t\t\"TITLE_DOTENV\": \"DotEnv Example\",\n\t\t\"TYPE_DOTENV\":  \"donut\",\n\t\t\"NAME_DOTENV\":  \"Cake\",\n\t\t\"title\":        \"TOML Example\",\n\t\t\"newkey\":       \"remote\",\n\t\t\"batters\": map[string]any{\n\t\t\t\"batter\": []any{\n\t\t\t\tmap[string]any{\n\t\t\t\t\t\"type\": \"Regular\",\n\t\t\t\t},\n\t\t\t\tmap[string]any{\n\t\t\t\t\t\"type\": \"Chocolate\",\n\t\t\t\t},\n\t\t\t\tmap[string]any{\n\t\t\t\t\t\"type\": \"Blueberry\",\n\t\t\t\t},\n\t\t\t\tmap[string]any{\n\t\t\t\t\t\"type\": \"Devil's Food\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"eyes\": \"brown\",\n\t\t\"age\":  35,\n\t\t\"owner\": map[string]any{\n\t\t\t\"organization\": \"MongoDB\",\n\t\t\t\"bio\":          \"MongoDB Chief Developer Advocate & Hacker at Large\",\n\t\t\t\"dob\":          dob,\n\t\t},\n\t\t\"owner.bio\": \"MongoDB Chief Developer Advocate & Hacker at Large\",\n\t\t\"type\":      \"donut\",\n\t\t\"id\":        \"0001\",\n\t\t\"name\":      \"Cake\",\n\t\t\"hacker\":    true,\n\t\t\"ppu\":       0.55,\n\t\t\"clothing\": map[string]any{\n\t\t\t\"jacket\":   \"leather\",\n\t\t\t\"trousers\": \"denim\",\n\t\t\t\"pants\": map[string]any{\n\t\t\t\t\"size\": \"large\",\n\t\t\t},\n\t\t},\n\t\t\"clothing.jacket\":     \"leather\",\n\t\t\"clothing.pants.size\": \"large\",\n\t\t\"clothing.trousers\":   \"denim\",\n\t\t\"owner.dob\":           dob,\n\t\t\"beard\":               true,\n\t}\n\n\tfor key, expectedValue := range expected {\n\t\tassert.Equal(t, expectedValue, v.Get(key))\n\t}\n}\n\nfunc TestReadConfig(t *testing.T) {\n\tt.Run(\"ok\", func(t *testing.T) {\n\t\tv := New()\n\t\tv.SetConfigType(\"yaml\")\n\t\terr := v.ReadConfig(bytes.NewBuffer(yamlExample))\n\t\trequire.NoError(t, err)\n\t\tt.Log(v.AllKeys())\n\n\t\tassert.True(t, v.InConfig(\"name\"))\n\t\tassert.True(t, v.InConfig(\"clothing.jacket\"))\n\t\tassert.False(t, v.InConfig(\"state\"))\n\t\tassert.False(t, v.InConfig(\"clothing.hat\"))\n\t\tassert.Equal(t, \"steve\", v.Get(\"name\"))\n\t\tassert.Equal(t, []any{\"skateboarding\", \"snowboarding\", \"go\"}, v.Get(\"hobbies\"))\n\t\tassert.Equal(t, map[string]any{\"jacket\": \"leather\", \"trousers\": \"denim\", \"pants\": map[string]any{\"size\": \"large\"}}, v.Get(\"clothing\"))\n\t\tassert.Equal(t, 35, v.Get(\"age\"))\n\t})\n\n\tt.Run(\"missing config type\", func(t *testing.T) {\n\t\tv := New()\n\t\terr := v.ReadConfig(bytes.NewBuffer(yamlExample))\n\t\trequire.Error(t, err)\n\t})\n}\n\nfunc TestIsSet(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\n\t/* config and defaults */\n\tv.ReadConfig(bytes.NewBuffer(yamlExample))\n\tv.SetDefault(\"clothing.shoes\", \"sneakers\")\n\n\tassert.True(t, v.IsSet(\"clothing\"))\n\tassert.True(t, v.IsSet(\"clothing.jacket\"))\n\tassert.False(t, v.IsSet(\"clothing.jackets\"))\n\tassert.True(t, v.IsSet(\"clothing.shoes\"))\n\n\t/* state change */\n\tassert.False(t, v.IsSet(\"helloworld\"))\n\tv.Set(\"helloworld\", \"fubar\")\n\tassert.True(t, v.IsSet(\"helloworld\"))\n\n\t/* env */\n\tv.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\tv.BindEnv(\"eyes\")\n\tv.BindEnv(\"foo\")\n\tv.BindEnv(\"clothing.hat\")\n\tv.BindEnv(\"clothing.hats\")\n\n\tt.Setenv(\"FOO\", \"bar\")\n\tt.Setenv(\"CLOTHING_HAT\", \"bowler\")\n\n\tassert.True(t, v.IsSet(\"eyes\"))           // in the config file\n\tassert.True(t, v.IsSet(\"foo\"))            // in the environment\n\tassert.True(t, v.IsSet(\"clothing.hat\"))   // in the environment\n\tassert.False(t, v.IsSet(\"clothing.hats\")) // not defined\n\n\t/* flags */\n\tflagset := pflag.NewFlagSet(\"testisset\", pflag.ContinueOnError)\n\tflagset.Bool(\"foobaz\", false, \"foobaz\")\n\tflagset.Bool(\"barbaz\", false, \"barbaz\")\n\tfoobaz, barbaz := flagset.Lookup(\"foobaz\"), flagset.Lookup(\"barbaz\")\n\tv.BindPFlag(\"foobaz\", foobaz)\n\tv.BindPFlag(\"barbaz\", barbaz)\n\tbarbaz.Value.Set(\"true\")\n\tbarbaz.Changed = true // hack for pflag usage\n\n\tassert.False(t, v.IsSet(\"foobaz\"))\n\tassert.True(t, v.IsSet(\"barbaz\"))\n}\n\nfunc TestDirsSearch(t *testing.T) {\n\troot, config := initDirs(t)\n\n\tv := New()\n\tv.SetConfigName(config)\n\tv.SetDefault(`key`, `default`)\n\n\tentries, err := os.ReadDir(root)\n\trequire.NoError(t, err)\n\tfor _, e := range entries {\n\t\tif e.IsDir() {\n\t\t\tv.AddConfigPath(filepath.Join(root, e.Name()))\n\t\t}\n\t}\n\n\terr = v.ReadInConfig()\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, `value is `+filepath.Base(v.configPaths[0]), v.GetString(`key`))\n}\n\nfunc TestWrongDirsSearchNotFound(t *testing.T) {\n\t_, config := initDirs(t)\n\n\tv := New()\n\tv.SetConfigName(config)\n\tv.SetDefault(`key`, `default`)\n\n\tv.AddConfigPath(`whattayoutalkingbout`)\n\tv.AddConfigPath(`thispathaintthere`)\n\n\terr := v.ReadInConfig()\n\tassert.IsType(t, ConfigFileNotFoundError{\"\", \"\"}, err)\n\n\t// Even though config did not load and the error might have\n\t// been ignored by the client, the default still loads\n\tassert.Equal(t, `default`, v.GetString(`key`))\n}\n\nfunc TestWrongDirsSearchNotFoundForMerge(t *testing.T) {\n\t_, config := initDirs(t)\n\n\tv := New()\n\tv.SetConfigName(config)\n\tv.SetDefault(`key`, `default`)\n\n\tv.AddConfigPath(`whattayoutalkingbout`)\n\tv.AddConfigPath(`thispathaintthere`)\n\n\terr := v.MergeInConfig()\n\tassert.Equal(t, reflect.TypeOf(ConfigFileNotFoundError{\"\", \"\"}), reflect.TypeOf(err))\n\n\t// Even though config did not load and the error might have\n\t// been ignored by the client, the default still loads\n\tassert.Equal(t, `default`, v.GetString(`key`))\n}\n\nvar yamlInvalid = []byte(`hash: map\n- foo\n- bar\n`)\n\nfunc TestUnwrapParseErrors(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\tassert.ErrorAs(t, v.ReadConfig(bytes.NewBuffer(yamlInvalid)), &ConfigParseError{})\n}\n\nfunc TestSub(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\tv.ReadConfig(bytes.NewBuffer(yamlExample))\n\n\tsubv := v.Sub(\"clothing\")\n\tassert.Equal(t, v.Get(\"clothing.pants.size\"), subv.Get(\"pants.size\"))\n\n\tsubv = v.Sub(\"clothing.pants\")\n\tassert.Equal(t, v.Get(\"clothing.pants.size\"), subv.Get(\"size\"))\n\n\tsubv = v.Sub(\"clothing.pants.size\")\n\tassert.Equal(t, (*Viper)(nil), subv)\n\n\tsubv = v.Sub(\"missing.key\")\n\tassert.Equal(t, (*Viper)(nil), subv)\n\n\tsubv = v.Sub(\"clothing\")\n\tassert.Equal(t, []string{\"clothing\"}, subv.parents)\n\n\tsubv = v.Sub(\"clothing\").Sub(\"pants\")\n\tassert.Equal(t, []string{\"clothing\", \"pants\"}, subv.parents)\n}\n\nfunc TestSubWithKeyDelimiter(t *testing.T) {\n\tv := NewWithOptions(KeyDelimiter(\"::\"))\n\tv.SetConfigType(\"yaml\")\n\tr := strings.NewReader(string(yamlExampleWithDot))\n\terr := v.unmarshalReader(r, v.config)\n\trequire.NoError(t, err)\n\n\tsubv := v.Sub(\"emails\")\n\tassert.Equal(t, \"01/02/03\", subv.Get(\"steve@hacker.com::created\"))\n}\n\nvar jsonWriteExpected = []byte(`{\n  \"batters\": {\n    \"batter\": [\n      {\n        \"type\": \"Regular\"\n      },\n      {\n        \"type\": \"Chocolate\"\n      },\n      {\n        \"type\": \"Blueberry\"\n      },\n      {\n        \"type\": \"Devil's Food\"\n      }\n    ]\n  },\n  \"id\": \"0001\",\n  \"name\": \"Cake\",\n  \"ppu\": 0.55,\n  \"type\": \"donut\"\n}`)\n\n// var yamlWriteExpected = []byte(`age: 35\n// beard: true\n// clothing:\n//     jacket: leather\n//     pants:\n//         size: large\n//     trousers: denim\n// eyes: brown\n// hacker: true\n// hobbies:\n//     - skateboarding\n//     - snowboarding\n//     - go\n// name: steve\n// `)\n\nfunc TestWriteConfig(t *testing.T) {\n\tfs := afero.NewMemMapFs()\n\ttestCases := map[string]struct {\n\t\tconfigName      string\n\t\tinConfigType    string\n\t\toutConfigType   string\n\t\tfileName        string\n\t\tinput           []byte\n\t\texpectedContent []byte\n\t}{\n\t\t\"json with file extension\": {\n\t\t\tconfigName:      \"c\",\n\t\t\tinConfigType:    \"json\",\n\t\t\toutConfigType:   \"json\",\n\t\t\tfileName:        \"c.json\",\n\t\t\tinput:           jsonExample,\n\t\t\texpectedContent: jsonWriteExpected,\n\t\t},\n\t\t\"json without file extension\": {\n\t\t\tconfigName:      \"c\",\n\t\t\tinConfigType:    \"json\",\n\t\t\toutConfigType:   \"json\",\n\t\t\tfileName:        \"c\",\n\t\t\tinput:           jsonExample,\n\t\t\texpectedContent: jsonWriteExpected,\n\t\t},\n\t\t\"json with file extension and mismatch type\": {\n\t\t\tconfigName:      \"c\",\n\t\t\tinConfigType:    \"json\",\n\t\t\toutConfigType:   \"hcl\",\n\t\t\tfileName:        \"c.json\",\n\t\t\tinput:           jsonExample,\n\t\t\texpectedContent: jsonWriteExpected,\n\t\t},\n\t\t\"yaml with file extension\": {\n\t\t\tconfigName:      \"c\",\n\t\t\tinConfigType:    \"yaml\",\n\t\t\toutConfigType:   \"yaml\",\n\t\t\tfileName:        \"c.yaml\",\n\t\t\tinput:           yamlExample,\n\t\t\texpectedContent: yamlWriteExpected,\n\t\t},\n\t\t\"yaml without file extension\": {\n\t\t\tconfigName:      \"c\",\n\t\t\tinConfigType:    \"yaml\",\n\t\t\toutConfigType:   \"yaml\",\n\t\t\tfileName:        \"c\",\n\t\t\tinput:           yamlExample,\n\t\t\texpectedContent: yamlWriteExpected,\n\t\t},\n\t\t\"yaml with file extension and mismatch type\": {\n\t\t\tconfigName:      \"c\",\n\t\t\tinConfigType:    \"yaml\",\n\t\t\toutConfigType:   \"json\",\n\t\t\tfileName:        \"c.yaml\",\n\t\t\tinput:           yamlExample,\n\t\t\texpectedContent: yamlWriteExpected,\n\t\t},\n\t}\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tv := New()\n\t\t\tv.SetFs(fs)\n\t\t\tv.SetConfigName(tc.fileName)\n\t\t\tv.SetConfigType(tc.inConfigType)\n\n\t\t\terr := v.ReadConfig(bytes.NewBuffer(tc.input))\n\t\t\trequire.NoError(t, err)\n\t\t\tv.SetConfigType(tc.outConfigType)\n\t\t\terr = v.WriteConfigAs(tc.fileName)\n\t\t\trequire.NoError(t, err)\n\t\t\tread, err := afero.ReadFile(fs, tc.fileName)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectedContent, read)\n\t\t})\n\t}\n}\n\nfunc TestWriteConfigTOML(t *testing.T) {\n\tfs := afero.NewMemMapFs()\n\n\ttestCases := map[string]struct {\n\t\tconfigName string\n\t\tconfigType string\n\t\tfileName   string\n\t\tinput      []byte\n\t}{\n\t\t\"with file extension\": {\n\t\t\tconfigName: \"c\",\n\t\t\tconfigType: \"toml\",\n\t\t\tfileName:   \"c.toml\",\n\t\t\tinput:      tomlExample,\n\t\t},\n\t\t\"without file extension\": {\n\t\t\tconfigName: \"c\",\n\t\t\tconfigType: \"toml\",\n\t\t\tfileName:   \"c\",\n\t\t\tinput:      tomlExample,\n\t\t},\n\t}\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tv := New()\n\t\t\tv.SetFs(fs)\n\t\t\tv.SetConfigName(tc.configName)\n\t\t\tv.SetConfigType(tc.configType)\n\t\t\terr := v.ReadConfig(bytes.NewBuffer(tc.input))\n\t\t\trequire.NoError(t, err)\n\t\t\terr = v.WriteConfigAs(tc.fileName)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// The TOML String method does not order the contents.\n\t\t\t// Therefore, we must read the generated file and compare the data.\n\t\t\tv2 := New()\n\t\t\tv2.SetFs(fs)\n\t\t\tv2.SetConfigName(tc.configName)\n\t\t\tv2.SetConfigType(tc.configType)\n\t\t\tv2.SetConfigFile(tc.fileName)\n\t\t\terr = v2.ReadInConfig()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, v.GetString(\"title\"), v2.GetString(\"title\"))\n\t\t\tassert.Equal(t, v.GetString(\"owner.bio\"), v2.GetString(\"owner.bio\"))\n\t\t\tassert.Equal(t, v.GetString(\"owner.dob\"), v2.GetString(\"owner.dob\"))\n\t\t\tassert.Equal(t, v.GetString(\"owner.organization\"), v2.GetString(\"owner.organization\"))\n\t\t})\n\t}\n}\n\nfunc TestWriteConfigDotEnv(t *testing.T) {\n\tfs := afero.NewMemMapFs()\n\ttestCases := map[string]struct {\n\t\tconfigName string\n\t\tconfigType string\n\t\tfileName   string\n\t\tinput      []byte\n\t}{\n\t\t\"with file extension\": {\n\t\t\tconfigName: \"c\",\n\t\t\tconfigType: \"env\",\n\t\t\tfileName:   \"c.env\",\n\t\t\tinput:      dotenvExample,\n\t\t},\n\t\t\"without file extension\": {\n\t\t\tconfigName: \"c\",\n\t\t\tconfigType: \"env\",\n\t\t\tfileName:   \"c\",\n\t\t\tinput:      dotenvExample,\n\t\t},\n\t}\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tv := New()\n\t\t\tv.SetFs(fs)\n\t\t\tv.SetConfigName(tc.configName)\n\t\t\tv.SetConfigType(tc.configType)\n\t\t\terr := v.ReadConfig(bytes.NewBuffer(tc.input))\n\t\t\trequire.NoError(t, err)\n\t\t\terr = v.WriteConfigAs(tc.fileName)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// The TOML String method does not order the contents.\n\t\t\t// Therefore, we must read the generated file and compare the data.\n\t\t\tv2 := New()\n\t\t\tv2.SetFs(fs)\n\t\t\tv2.SetConfigName(tc.configName)\n\t\t\tv2.SetConfigType(tc.configType)\n\t\t\tv2.SetConfigFile(tc.fileName)\n\t\t\terr = v2.ReadInConfig()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, v.GetString(\"title_dotenv\"), v2.GetString(\"title_dotenv\"))\n\t\t\tassert.Equal(t, v.GetString(\"type_dotenv\"), v2.GetString(\"type_dotenv\"))\n\t\t\tassert.Equal(t, v.GetString(\"kind_dotenv\"), v2.GetString(\"kind_dotenv\"))\n\t\t})\n\t}\n}\n\nfunc TestSafeWriteConfig(t *testing.T) {\n\tv := New()\n\tfs := afero.NewMemMapFs()\n\tv.SetFs(fs)\n\tv.AddConfigPath(\"/test\")\n\tv.SetConfigName(\"c\")\n\tv.SetConfigType(\"yaml\")\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(yamlExample)))\n\trequire.NoError(t, v.SafeWriteConfig())\n\tread, err := afero.ReadFile(fs, testutil.AbsFilePath(t, \"/test/c.yaml\"))\n\trequire.NoError(t, err)\n\tassert.YAMLEq(t, string(yamlWriteExpected), string(read))\n}\n\nfunc TestSafeWriteConfigWithMissingConfigPath(t *testing.T) {\n\tv := New()\n\tfs := afero.NewMemMapFs()\n\tv.SetFs(fs)\n\tv.SetConfigName(\"c\")\n\tv.SetConfigType(\"yaml\")\n\trequire.EqualError(t, v.SafeWriteConfig(), \"missing configuration for 'configPath'\")\n}\n\nfunc TestSafeWriteConfigWithExistingFile(t *testing.T) {\n\tv := New()\n\tfs := afero.NewMemMapFs()\n\tfs.Create(testutil.AbsFilePath(t, \"/test/c.yaml\"))\n\tv.SetFs(fs)\n\tv.AddConfigPath(\"/test\")\n\tv.SetConfigName(\"c\")\n\tv.SetConfigType(\"yaml\")\n\terr := v.SafeWriteConfig()\n\trequire.Error(t, err)\n\t_, ok := err.(ConfigFileAlreadyExistsError)\n\tassert.True(t, ok, \"Expected ConfigFileAlreadyExistsError\")\n}\n\nfunc TestSafeWriteAsConfig(t *testing.T) {\n\tv := New()\n\tfs := afero.NewMemMapFs()\n\tv.SetFs(fs)\n\tv.SetConfigType(\"yaml\")\n\terr := v.ReadConfig(bytes.NewBuffer(yamlExample))\n\trequire.NoError(t, err)\n\trequire.NoError(t, v.SafeWriteConfigAs(\"/test/c.yaml\"))\n\t_, err = afero.ReadFile(fs, \"/test/c.yaml\")\n\trequire.NoError(t, err)\n}\n\nfunc TestSafeWriteConfigAsWithExistingFile(t *testing.T) {\n\tv := New()\n\tfs := afero.NewMemMapFs()\n\tfs.Create(\"/test/c.yaml\")\n\tv.SetFs(fs)\n\terr := v.SafeWriteConfigAs(\"/test/c.yaml\")\n\trequire.Error(t, err)\n\t_, ok := err.(ConfigFileAlreadyExistsError)\n\tassert.True(t, ok, \"Expected ConfigFileAlreadyExistsError\")\n}\n\nfunc TestWriteHiddenFile(t *testing.T) {\n\tv := New()\n\tfs := afero.NewMemMapFs()\n\tfs.Create(testutil.AbsFilePath(t, \"/test/.config\"))\n\tv.SetFs(fs)\n\n\tv.SetConfigName(\".config\")\n\tv.SetConfigType(\"yaml\")\n\tv.AddConfigPath(\"/test\")\n\n\terr := v.ReadInConfig()\n\trequire.NoError(t, err)\n\n\terr = v.WriteConfig()\n\trequire.NoError(t, err)\n}\n\nvar yamlMergeExampleTgt = []byte(`\nhello:\n    pop: 37890\n    largenum: 765432101234567\n    num2pow63: 9223372036854775808\n    universe: null\n    world:\n    - us\n    - uk\n    - fr\n    - de\n`)\n\nvar yamlMergeExampleSrc = []byte(`\nhello:\n    pop: 45000\n    largenum: 7654321001234567\n    universe:\n    - mw\n    - ad\n    ints:\n    - 1\n    - 2\nfu: bar\n`)\n\nvar jsonMergeExampleTgt = []byte(`\n{\n\t\"hello\": {\n\t\t\"foo\": null,\n\t\t\"pop\": 123456\n\t}\n}\n`)\n\nvar jsonMergeExampleSrc = []byte(`\n{\n\t\"hello\": {\n\t\t\"foo\": \"foo str\",\n\t\t\"pop\": \"pop str\"\n\t}\n}\n`)\n\nfunc TestMergeConfig(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yml\")\n\terr := v.ReadConfig(bytes.NewBuffer(yamlMergeExampleTgt))\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 37890, v.GetInt(\"hello.pop\"))\n\tassert.Equal(t, int32(37890), v.GetInt32(\"hello.pop\"))\n\tassert.Equal(t, int64(765432101234567), v.GetInt64(\"hello.largenum\"))\n\tassert.Equal(t, uint8(2), v.GetUint8(\"hello.pop\"))\n\tassert.Equal(t, uint(37890), v.GetUint(\"hello.pop\"))\n\tassert.Equal(t, uint16(37890), v.GetUint16(\"hello.pop\"))\n\tassert.Equal(t, uint32(37890), v.GetUint32(\"hello.pop\"))\n\tassert.Equal(t, uint64(9223372036854775808), v.GetUint64(\"hello.num2pow63\"))\n\tassert.Len(t, v.GetStringSlice(\"hello.world\"), 4)\n\tassert.Empty(t, v.GetString(\"fu\"))\n\n\terr = v.MergeConfig(bytes.NewBuffer(yamlMergeExampleSrc))\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 45000, v.GetInt(\"hello.pop\"))\n\tassert.Equal(t, int32(45000), v.GetInt32(\"hello.pop\"))\n\tassert.Equal(t, int64(7654321001234567), v.GetInt64(\"hello.largenum\"))\n\tassert.Len(t, v.GetStringSlice(\"hello.world\"), 4)\n\tassert.Len(t, v.GetStringSlice(\"hello.universe\"), 2)\n\tassert.Len(t, v.GetIntSlice(\"hello.ints\"), 2)\n\tassert.Equal(t, \"bar\", v.GetString(\"fu\"))\n}\n\nfunc TestMergeConfigOverrideType(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"json\")\n\terr := v.ReadConfig(bytes.NewBuffer(jsonMergeExampleTgt))\n\trequire.NoError(t, err)\n\n\terr = v.MergeConfig(bytes.NewBuffer(jsonMergeExampleSrc))\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, \"pop str\", v.GetString(\"hello.pop\"))\n\tassert.Equal(t, \"foo str\", v.GetString(\"hello.foo\"))\n}\n\nfunc TestMergeConfigNoMerge(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yml\")\n\terr := v.ReadConfig(bytes.NewBuffer(yamlMergeExampleTgt))\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 37890, v.GetInt(\"hello.pop\"))\n\tassert.Len(t, v.GetStringSlice(\"hello.world\"), 4)\n\tassert.Empty(t, v.GetString(\"fu\"))\n\n\terr = v.ReadConfig(bytes.NewBuffer(yamlMergeExampleSrc))\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 45000, v.GetInt(\"hello.pop\"))\n\tassert.Empty(t, v.GetStringSlice(\"hello.world\"))\n\tassert.Len(t, v.GetStringSlice(\"hello.universe\"), 2)\n\tassert.Len(t, v.GetIntSlice(\"hello.ints\"), 2)\n\tassert.Equal(t, \"bar\", v.GetString(\"fu\"))\n}\n\nfunc TestMergeConfigMap(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yml\")\n\terr := v.ReadConfig(bytes.NewBuffer(yamlMergeExampleTgt))\n\trequire.NoError(t, err)\n\n\tassertFn := func(i int) {\n\t\tlarge := v.GetInt64(\"hello.largenum\")\n\t\tpop := v.GetInt(\"hello.pop\")\n\t\tassert.Equal(t, int64(765432101234567), large)\n\t\tassert.Equal(t, i, pop)\n\t}\n\n\tassertFn(37890)\n\n\tupdate := map[string]any{\n\t\t\"Hello\": map[string]any{\n\t\t\t\"Pop\": 1234,\n\t\t},\n\t\t\"World\": map[any]any{\n\t\t\t\"Rock\": 345,\n\t\t},\n\t}\n\n\terr = v.MergeConfigMap(update)\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 345, v.GetInt(\"world.rock\"))\n\n\tassertFn(1234)\n}\n\nfunc TestUnmarshalingWithAliases(t *testing.T) {\n\tv := New()\n\tv.SetDefault(\"ID\", 1)\n\tv.Set(\"name\", \"Steve\")\n\tv.Set(\"lastname\", \"Owen\")\n\n\tv.RegisterAlias(\"UserID\", \"ID\")\n\tv.RegisterAlias(\"Firstname\", \"name\")\n\tv.RegisterAlias(\"Surname\", \"lastname\")\n\n\ttype config struct {\n\t\tID        int\n\t\tFirstName string\n\t\tSurname   string\n\t}\n\n\tvar C config\n\terr := v.Unmarshal(&C)\n\trequire.NoError(t, err, \"unable to decode into struct\")\n\n\tassert.Equal(t, &config{ID: 1, FirstName: \"Steve\", Surname: \"Owen\"}, &C)\n}\n\nfunc TestSetConfigNameClearsFileCache(t *testing.T) {\n\tv := New()\n\tv.SetConfigFile(\"/tmp/config.yaml\")\n\tv.SetConfigName(\"default\")\n\tf, err := v.getConfigFile()\n\trequire.Error(t, err, \"config file cache should have been cleared\")\n\tassert.Empty(t, f)\n}\n\nfunc TestShadowedNestedValue(t *testing.T) {\n\tv := New()\n\tconfig := `name: steve\nclothing:\n  jacket: leather\n  trousers: denim\n  pants:\n    size: large\n`\n\tinitConfig(\"yaml\", config, v)\n\n\tassert.Equal(t, \"steve\", v.GetString(\"name\"))\n\n\tpolyester := \"polyester\"\n\tv.SetDefault(\"clothing.shirt\", polyester)\n\tv.SetDefault(\"clothing.jacket.price\", 100)\n\n\tassert.Equal(t, \"leather\", v.GetString(\"clothing.jacket\"))\n\tassert.Nil(t, v.Get(\"clothing.jacket.price\"))\n\tassert.Equal(t, polyester, v.GetString(\"clothing.shirt\"))\n\n\tclothingSettings := v.AllSettings()[\"clothing\"].(map[string]any)\n\tassert.Equal(t, \"leather\", clothingSettings[\"jacket\"])\n\tassert.Equal(t, polyester, clothingSettings[\"shirt\"])\n}\n\nfunc TestDotParameter(t *testing.T) {\n\tv := New()\n\n\tv.SetConfigType(\"json\")\n\n\t// Read the YAML data into Viper configuration\n\trequire.NoError(t, v.ReadConfig(bytes.NewBuffer(jsonExample)), \"Error reading YAML data\")\n\n\t// should take precedence over batters defined in jsonExample\n\tr := bytes.NewReader([]byte(`{ \"batters.batter\": [ { \"type\": \"Small\" } ] }`))\n\tv.unmarshalReader(r, v.config)\n\n\tactual := v.Get(\"batters.batter\")\n\texpected := []any{map[string]any{\"type\": \"Small\"}}\n\tassert.Equal(t, expected, actual)\n}\n\nfunc TestCaseInsensitive(t *testing.T) {\n\tfor _, config := range []struct {\n\t\ttyp     string\n\t\tcontent string\n\t}{\n\t\t{\"yaml\", `\naBcD: 1\neF:\n  gH: 2\n  iJk: 3\n  Lm:\n    nO: 4\n    P:\n      Q: 5\n      R: 6\n`},\n\t\t{\"json\", `{\n  \"aBcD\": 1,\n  \"eF\": {\n    \"iJk\": 3,\n    \"Lm\": {\n      \"P\": {\n        \"Q\": 5,\n        \"R\": 6\n      },\n      \"nO\": 4\n    },\n    \"gH\": 2\n  }\n}`},\n\t\t{\"toml\", `aBcD = 1\n[eF]\ngH = 2\niJk = 3\n[eF.Lm]\nnO = 4\n[eF.Lm.P]\nQ = 5\nR = 6\n`},\n\t} {\n\t\tdoTestCaseInsensitive(t, config.typ, config.content)\n\t}\n}\n\nfunc TestCaseInsensitiveSet(t *testing.T) {\n\tv := New()\n\tm1 := map[string]any{\n\t\t\"Foo\": 32,\n\t\t\"Bar\": map[any]any{\n\t\t\t\"ABc\": \"A\",\n\t\t\t\"cDE\": \"B\",\n\t\t},\n\t}\n\n\tm2 := map[string]any{\n\t\t\"Foo\": 52,\n\t\t\"Bar\": map[any]any{\n\t\t\t\"bCd\": \"A\",\n\t\t\t\"eFG\": \"B\",\n\t\t},\n\t}\n\n\tv.Set(\"Given1\", m1)\n\tv.Set(\"Number1\", 42)\n\n\tv.SetDefault(\"Given2\", m2)\n\tv.SetDefault(\"Number2\", 52)\n\n\t// Verify SetDefault\n\tassert.Equal(t, 52, v.Get(\"number2\"))\n\tassert.Equal(t, 52, v.Get(\"given2.foo\"))\n\tassert.Equal(t, \"A\", v.Get(\"given2.bar.bcd\"))\n\t_, ok := m2[\"Foo\"]\n\tassert.True(t, ok)\n\n\t// Verify Set\n\tassert.Equal(t, 42, v.Get(\"number1\"))\n\tassert.Equal(t, 32, v.Get(\"given1.foo\"))\n\tassert.Equal(t, \"A\", v.Get(\"given1.bar.abc\"))\n\t_, ok = m1[\"Foo\"]\n\tassert.True(t, ok)\n}\n\nfunc TestParseNested(t *testing.T) {\n\tv := New()\n\ttype duration struct {\n\t\tDelay time.Duration\n\t}\n\n\ttype item struct {\n\t\tName   string\n\t\tDelay  time.Duration\n\t\tNested duration\n\t}\n\n\tconfig := `[[parent]]\n\tdelay=\"100ms\"\n\t[parent.nested]\n\tdelay=\"200ms\"\n`\n\tinitConfig(\"toml\", config, v)\n\n\tvar items []item\n\terr := v.UnmarshalKey(\"parent\", &items)\n\trequire.NoError(t, err, \"unable to decode into struct\")\n\n\tassert.Len(t, items, 1)\n\tassert.Equal(t, 100*time.Millisecond, items[0].Delay)\n\tassert.Equal(t, 200*time.Millisecond, items[0].Nested.Delay)\n}\n\nfunc doTestCaseInsensitive(t *testing.T, typ, config string) {\n\tv := New()\n\tinitConfig(typ, config, v)\n\tv.Set(\"RfD\", true)\n\tassert.Equal(t, true, v.Get(\"rfd\"))\n\tassert.Equal(t, true, v.Get(\"rFD\"))\n\tassert.Equal(t, 1, cast.ToInt(v.Get(\"abcd\")))\n\tassert.Equal(t, 1, cast.ToInt(v.Get(\"Abcd\")))\n\tassert.Equal(t, 2, cast.ToInt(v.Get(\"ef.gh\")))\n\tassert.Equal(t, 3, cast.ToInt(v.Get(\"ef.ijk\")))\n\tassert.Equal(t, 4, cast.ToInt(v.Get(\"ef.lm.no\")))\n\tassert.Equal(t, 5, cast.ToInt(v.Get(\"ef.lm.p.q\")))\n}\n\nfunc newViperWithConfigFile(t *testing.T) (*Viper, string) {\n\twatchDir := t.TempDir()\n\tconfigFile := path.Join(watchDir, \"config.yaml\")\n\terr := os.WriteFile(configFile, []byte(\"foo: bar\\n\"), 0o640)\n\trequire.NoError(t, err)\n\tv := New()\n\tv.SetConfigFile(configFile)\n\terr = v.ReadInConfig()\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"bar\", v.Get(\"foo\"))\n\treturn v, configFile\n}\n\nfunc newViperWithSymlinkedConfigFile(t *testing.T) (*Viper, string, string) {\n\twatchDir := t.TempDir()\n\tdataDir1 := path.Join(watchDir, \"data1\")\n\terr := os.Mkdir(dataDir1, 0o777)\n\trequire.NoError(t, err)\n\trealConfigFile := path.Join(dataDir1, \"config.yaml\")\n\tt.Logf(\"Real config file location: %s\\n\", realConfigFile)\n\terr = os.WriteFile(realConfigFile, []byte(\"foo: bar\\n\"), 0o640)\n\trequire.NoError(t, err)\n\t// now, symlink the tm `data1` dir to `data` in the baseDir\n\tos.Symlink(dataDir1, path.Join(watchDir, \"data\"))\n\t// and link the `<watchdir>/datadir1/config.yaml` to `<watchdir>/config.yaml`\n\tconfigFile := path.Join(watchDir, \"config.yaml\")\n\tos.Symlink(path.Join(watchDir, \"data\", \"config.yaml\"), configFile)\n\tt.Logf(\"Config file location: %s\\n\", path.Join(watchDir, \"config.yaml\"))\n\t// init Viper\n\tv := New()\n\tv.SetConfigFile(configFile)\n\terr = v.ReadInConfig()\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"bar\", v.Get(\"foo\"))\n\treturn v, watchDir, configFile\n}\n\nfunc TestWatchFile(t *testing.T) {\n\tif runtime.GOOS == \"linux\" {\n\t\t// TODO(bep) FIX ME\n\t\tt.Skip(\"Skip test on Linux ...\")\n\t}\n\n\tt.Run(\"file content changed\", func(t *testing.T) {\n\t\t// given a `config.yaml` file being watched\n\t\tv, configFile := newViperWithConfigFile(t)\n\t\t_, err := os.Stat(configFile)\n\t\trequire.NoError(t, err)\n\t\tt.Logf(\"test config file: %s\\n\", configFile)\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(1)\n\t\tvar wgDoneOnce sync.Once // OnConfigChange is called twice on Windows\n\t\tv.OnConfigChange(func(_ fsnotify.Event) {\n\t\t\tt.Logf(\"config file changed\")\n\t\t\twgDoneOnce.Do(func() {\n\t\t\t\twg.Done()\n\t\t\t})\n\t\t})\n\t\tv.WatchConfig()\n\t\t// when overwriting the file and waiting for the custom change notification handler to be triggered\n\t\terr = os.WriteFile(configFile, []byte(\"foo: baz\\n\"), 0o640)\n\t\twg.Wait()\n\t\t// then the config value should have changed\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"baz\", v.Get(\"foo\"))\n\t})\n\n\tt.Run(\"link to real file changed (à la Kubernetes)\", func(t *testing.T) {\n\t\t// skip if not executed on Linux\n\t\tif runtime.GOOS != \"linux\" {\n\t\t\tt.Skipf(\"Skipping test as symlink replacements don't work on non-linux environment...\")\n\t\t}\n\t\tv, watchDir, _ := newViperWithSymlinkedConfigFile(t)\n\t\twg := sync.WaitGroup{}\n\t\tv.WatchConfig()\n\t\tv.OnConfigChange(func(_ fsnotify.Event) {\n\t\t\tt.Logf(\"config file changed\")\n\t\t\twg.Done()\n\t\t})\n\t\twg.Add(1)\n\t\t// when link to another `config.yaml` file\n\t\tdataDir2 := path.Join(watchDir, \"data2\")\n\t\terr := os.Mkdir(dataDir2, 0o777)\n\t\trequire.NoError(t, err)\n\t\tconfigFile2 := path.Join(dataDir2, \"config.yaml\")\n\t\terr = os.WriteFile(configFile2, []byte(\"foo: baz\\n\"), 0o640)\n\t\trequire.NoError(t, err)\n\t\t// change the symlink using the `ln -sfn` command\n\t\terr = exec.Command(\"ln\", \"-sfn\", dataDir2, path.Join(watchDir, \"data\")).Run()\n\t\trequire.NoError(t, err)\n\t\twg.Wait()\n\t\t// then\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"baz\", v.Get(\"foo\"))\n\t})\n}\n\nfunc TestUnmarshal_DotSeparatorBackwardCompatibility(t *testing.T) {\n\tflags := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\tflags.String(\"foo.bar\", \"cobra_flag\", \"\")\n\n\tv := New()\n\tassert.NoError(t, v.BindPFlags(flags))\n\n\tconfig := &struct {\n\t\tFoo struct {\n\t\t\tBar string\n\t\t}\n\t}{}\n\n\tassert.NoError(t, v.Unmarshal(config))\n\tassert.Equal(t, \"cobra_flag\", config.Foo.Bar)\n}\n\n// var yamlExampleWithDot = []byte(`Hacker: true\n// name: steve\n// hobbies:\n//     - skateboarding\n//     - snowboarding\n//     - go\n// clothing:\n//     jacket: leather\n//     trousers: denim\n//     pants:\n//         size: large\n// age: 35\n// eyes : brown\n// beard: true\n// emails:\n//     steve@hacker.com:\n//         created: 01/02/03\n//         active: true\n// `)\n\nfunc TestKeyDelimiter(t *testing.T) {\n\tv := NewWithOptions(KeyDelimiter(\"::\"))\n\tv.SetConfigType(\"yaml\")\n\tr := strings.NewReader(string(yamlExampleWithDot))\n\n\terr := v.unmarshalReader(r, v.config)\n\trequire.NoError(t, err)\n\n\tvalues := map[string]any{\n\t\t\"image\": map[string]any{\n\t\t\t\"repository\": \"someImage\",\n\t\t\t\"tag\":        \"1.0.0\",\n\t\t},\n\t\t\"ingress\": map[string]any{\n\t\t\t\"annotations\": map[string]any{\n\t\t\t\t\"traefik.frontend.rule.type\":                 \"PathPrefix\",\n\t\t\t\t\"traefik.ingress.kubernetes.io/ssl-redirect\": \"true\",\n\t\t\t},\n\t\t},\n\t}\n\n\tv.SetDefault(\"charts::values\", values)\n\n\tassert.Equal(t, \"leather\", v.GetString(\"clothing::jacket\"))\n\tassert.Equal(t, \"01/02/03\", v.GetString(\"emails::steve@hacker.com::created\"))\n\n\ttype config struct {\n\t\tCharts struct {\n\t\t\tValues map[string]any\n\t\t}\n\t}\n\n\texpected := config{\n\t\tCharts: struct {\n\t\t\tValues map[string]any\n\t\t}{\n\t\t\tValues: values,\n\t\t},\n\t}\n\n\tvar actual config\n\n\trequire.NoError(t, v.Unmarshal(&actual))\n\n\tassert.Equal(t, expected, actual)\n}\n\nvar yamlDeepNestedSlices = []byte(`TV:\n- title: \"The Expanse\"\n  title_i18n:\n    USA: \"The Expanse\"\n    Japan: \"エクスパンス -巨獣めざめる-\"\n  seasons:\n  - first_released: \"December 14, 2015\"\n    episodes:\n    - title: \"Dulcinea\"\n      air_date: \"December 14, 2015\"\n    - title: \"The Big Empty\"\n      air_date: \"December 15, 2015\"\n    - title: \"Remember the Cant\"\n      air_date: \"December 22, 2015\"\n  - first_released: \"February 1, 2017\"\n    episodes:\n    - title: \"Safe\"\n      air_date: \"February 1, 2017\"\n    - title: \"Doors & Corners\"\n      air_date: \"February 1, 2017\"\n    - title: \"Static\"\n      air_date: \"February 8, 2017\"\n  episodes:\n    - [\"Dulcinea\", \"The Big Empty\", \"Remember the Cant\"]\n    - [\"Safe\", \"Doors & Corners\", \"Static\"]\n`)\n\nfunc TestSliceIndexAccess(t *testing.T) {\n\tv := New()\n\tv.SetConfigType(\"yaml\")\n\tr := strings.NewReader(string(yamlDeepNestedSlices))\n\n\terr := v.unmarshalReader(r, v.config)\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, \"The Expanse\", v.GetString(\"tv.0.title\"))\n\tassert.Equal(t, \"February 1, 2017\", v.GetString(\"tv.0.seasons.1.first_released\"))\n\tassert.Equal(t, \"Static\", v.GetString(\"tv.0.seasons.1.episodes.2.title\"))\n\tassert.Equal(t, \"December 15, 2015\", v.GetString(\"tv.0.seasons.0.episodes.1.air_date\"))\n\n\t// Test nested keys with capital letters\n\tassert.Equal(t, \"The Expanse\", v.GetString(\"tv.0.title_i18n.USA\"))\n\tassert.Equal(t, \"エクスパンス -巨獣めざめる-\", v.GetString(\"tv.0.title_i18n.Japan\"))\n\n\t// Test for index out of bounds\n\tassert.Equal(t, \"\", v.GetString(\"tv.0.seasons.2.first_released\"))\n\n\t// Accessing multidimensional arrays\n\tassert.Equal(t, \"Static\", v.GetString(\"tv.0.episodes.1.2\"))\n}\n\nfunc TestIsPathShadowedInFlatMap(t *testing.T) {\n\tv := New()\n\n\tstringMap := map[string]string{\n\t\t\"foo\": \"value\",\n\t}\n\n\tflagMap := map[string]FlagValue{\n\t\t\"foo\": pflagValue{},\n\t}\n\n\tpath1 := []string{\"foo\", \"bar\"}\n\texpected1 := \"foo\"\n\n\t// \"foo.bar\" should shadowed by \"foo\"\n\tassert.Equal(t, expected1, v.isPathShadowedInFlatMap(path1, stringMap))\n\tassert.Equal(t, expected1, v.isPathShadowedInFlatMap(path1, flagMap))\n\n\tpath2 := []string{\"bar\", \"foo\"}\n\texpected2 := \"\"\n\n\t// \"bar.foo\" should not shadowed by \"foo\"\n\tassert.Equal(t, expected2, v.isPathShadowedInFlatMap(path2, stringMap))\n\tassert.Equal(t, expected2, v.isPathShadowedInFlatMap(path2, flagMap))\n}\n\nfunc TestFlagShadow(t *testing.T) {\n\tv := New()\n\n\tv.SetDefault(\"foo.bar1.bar2\", \"default\")\n\n\tflags := pflag.NewFlagSet(\"test\", pflag.ContinueOnError)\n\tflags.String(\"foo.bar1\", \"shadowed\", \"\")\n\tflags.VisitAll(func(flag *pflag.Flag) {\n\t\tflag.Changed = true\n\t})\n\n\tv.BindPFlags(flags)\n\n\tassert.Equal(t, \"shadowed\", v.GetString(\"foo.bar1\"))\n\t// the default \"foo.bar1.bar2\" value should shadowed by flag \"foo.bar1\" value\n\t// and should return an empty string\n\tassert.Equal(t, \"\", v.GetString(\"foo.bar1.bar2\"))\n}\n\nfunc BenchmarkGetBool(b *testing.B) {\n\tkey := \"BenchmarkGetBool\"\n\tv = New()\n\tv.Set(key, true)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif !v.GetBool(key) {\n\t\t\tb.Fatal(\"GetBool returned false\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkGet(b *testing.B) {\n\tkey := \"BenchmarkGet\"\n\tv = New()\n\tv.Set(key, true)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif !v.Get(key).(bool) {\n\t\t\tb.Fatal(\"Get returned false\")\n\t\t}\n\t}\n}\n\n// BenchmarkGetBoolFromMap is the \"perfect result\" for the above.\nfunc BenchmarkGetBoolFromMap(b *testing.B) {\n\tm := make(map[string]bool)\n\tkey := \"BenchmarkGetBool\"\n\tm[key] = true\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif !m[key] {\n\t\t\tb.Fatal(\"Map value was false\")\n\t\t}\n\t}\n}\n\n// Skip some tests on Windows that kept failing when Windows was added to the CI as a target.\nfunc skipWindows(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Skip test on Windows\")\n\t}\n}\n"
        },
        {
          "name": "viper_yaml_test.go",
          "type": "blob",
          "size": 0.76,
          "content": "package viper\n\nvar yamlExample = []byte(`Hacker: true\nname: steve\nhobbies:\n    - skateboarding\n    - snowboarding\n    - go\nclothing:\n    jacket: leather\n    trousers: denim\n    pants:\n        size: large\nage: 35\neyes : brown\nbeard: true\n`)\n\nvar yamlWriteExpected = []byte(`age: 35\nbeard: true\nclothing:\n    jacket: leather\n    pants:\n        size: large\n    trousers: denim\neyes: brown\nhacker: true\nhobbies:\n    - skateboarding\n    - snowboarding\n    - go\nname: steve\n`)\n\nvar yamlExampleWithDot = []byte(`Hacker: true\nname: steve\nhobbies:\n    - skateboarding\n    - snowboarding\n    - go\nclothing:\n    jacket: leather\n    trousers: denim\n    pants:\n        size: large\nage: 35\neyes : brown\nbeard: true\nemails:\n    steve@hacker.com:\n        created: 01/02/03\n        active: true\n`)\n"
        }
      ]
    }
  ]
}