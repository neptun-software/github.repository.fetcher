{
  "metadata": {
    "timestamp": 1736711885081,
    "page": 246,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/property-access",
      "stars": 2800,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.8701171875,
          "content": "CHANGELOG\n=========\n\n7.0\n---\n\n * Add method `isNullSafe()` to `PropertyPathInterface`\n * Require explicit argument when calling `PropertyAccessorBuilder::setCacheItemPool()`\n\n6.3\n---\n\n * Allow escaping `.` and `[` with `\\` in `PropertyPath`\n\n6.2\n---\n\n * Deprecate calling `PropertyAccessorBuilder::setCacheItemPool()` without arguments\n * Added method `isNullSafe()` to `PropertyPathInterface`, implementing the interface without implementing this method\n   is deprecated\n * Add support for the null-coalesce operator in property paths\n\n6.0\n---\n\n * make `PropertyAccessor::__construct()` accept a combination of bitwise flags as first and second arguments\n\n5.3.0\n-----\n\n * deprecate passing a boolean as the second argument of `PropertyAccessor::__construct()`, expecting a combination of bitwise flags instead\n\n5.2.0\n-----\n\n * deprecated passing a boolean as the first argument of `PropertyAccessor::__construct()`, expecting a combination of bitwise flags instead\n * added the ability to disable usage of the magic `__get` & `__set` methods\n\n5.1.0\n-----\n\n * Added an `UninitializedPropertyException`\n * Linking to PropertyInfo extractor to remove a lot of duplicate code\n\n4.4.0\n-----\n\n * deprecated passing `null` as `$defaultLifetime` 2nd argument of `PropertyAccessor::createCache()` method,\n   pass `0` instead\n\n4.3.0\n-----\n\n * added a `$throwExceptionOnInvalidPropertyPath` argument to the PropertyAccessor constructor.\n * added `enableExceptionOnInvalidPropertyPath()`, `disableExceptionOnInvalidPropertyPath()` and\n   `isExceptionOnInvalidPropertyPath()` methods to `PropertyAccessorBuilder`\n\n4.0.0\n-----\n\n * removed the `StringUtil` class, use `Symfony\\Component\\Inflector\\Inflector`\n\n3.1.0\n-----\n\n * deprecated the `StringUtil` class, use `Symfony\\Component\\Inflector\\Inflector`\n   instead\n\n2.7.0\n------\n\n * `UnexpectedTypeException` now expects three constructor arguments: The invalid property value,\n   the `PropertyPathInterface` object and the current index of the property path.\n\n2.5.0\n------\n\n * allowed non alpha numeric characters in second level and deeper object properties names\n * [BC BREAK] when accessing an index on an object that does not implement\n   ArrayAccess, a NoSuchIndexException is now thrown instead of the\n   semantically wrong NoSuchPropertyException\n * [BC BREAK] added isReadable() and isWritable() to PropertyAccessorInterface\n\n2.3.0\n------\n\n * added PropertyAccessorBuilder, to enable or disable the support of \"__call\"\n * added support for \"__call\" in the PropertyAccessor (disabled by default)\n * [BC BREAK] changed PropertyAccessor to continue its search for a property or\n   method even if a non-public match was found. Before, a PropertyAccessDeniedException\n   was thrown in this case. Class PropertyAccessDeniedException was removed\n   now.\n * deprecated PropertyAccess::getPropertyAccessor\n * added PropertyAccess::createPropertyAccessor and PropertyAccess::createPropertyAccessorBuilder\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "PropertyAccess.php",
          "type": "blob",
          "size": 0.8935546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\n/**\n * Entry point of the PropertyAccess component.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nfinal class PropertyAccess\n{\n    /**\n     * Creates a property accessor with the default configuration.\n     */\n    public static function createPropertyAccessor(): PropertyAccessor\n    {\n        return self::createPropertyAccessorBuilder()->getPropertyAccessor();\n    }\n\n    public static function createPropertyAccessorBuilder(): PropertyAccessorBuilder\n    {\n        return new PropertyAccessorBuilder();\n    }\n\n    /**\n     * This class cannot be instantiated.\n     */\n    private function __construct()\n    {\n    }\n}\n"
        },
        {
          "name": "PropertyAccessor.php",
          "type": "blob",
          "size": 30.1005859375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\NullLogger;\nuse Symfony\\Component\\Cache\\Adapter\\AdapterInterface;\nuse Symfony\\Component\\Cache\\Adapter\\ApcuAdapter;\nuse Symfony\\Component\\Cache\\Adapter\\NullAdapter;\nuse Symfony\\Component\\PropertyAccess\\Exception\\AccessException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\InvalidTypeException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\NoSuchIndexException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\NoSuchPropertyException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\UnexpectedTypeException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\UninitializedPropertyException;\nuse Symfony\\Component\\PropertyInfo\\Extractor\\ReflectionExtractor;\nuse Symfony\\Component\\PropertyInfo\\PropertyReadInfo;\nuse Symfony\\Component\\PropertyInfo\\PropertyReadInfoExtractorInterface;\nuse Symfony\\Component\\PropertyInfo\\PropertyWriteInfo;\nuse Symfony\\Component\\PropertyInfo\\PropertyWriteInfoExtractorInterface;\n\n/**\n * Default implementation of {@link PropertyAccessorInterface}.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n * @author KÃ©vin Dunglas <dunglas@gmail.com>\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass PropertyAccessor implements PropertyAccessorInterface\n{\n    /** @var int Allow none of the magic methods */\n    public const DISALLOW_MAGIC_METHODS = ReflectionExtractor::DISALLOW_MAGIC_METHODS;\n    /** @var int Allow magic __get methods */\n    public const MAGIC_GET = ReflectionExtractor::ALLOW_MAGIC_GET;\n    /** @var int Allow magic __set methods */\n    public const MAGIC_SET = ReflectionExtractor::ALLOW_MAGIC_SET;\n    /** @var int Allow magic __call methods */\n    public const MAGIC_CALL = ReflectionExtractor::ALLOW_MAGIC_CALL;\n\n    public const DO_NOT_THROW = 0;\n    public const THROW_ON_INVALID_INDEX = 1;\n    public const THROW_ON_INVALID_PROPERTY_PATH = 2;\n\n    private const VALUE = 0;\n    private const REF = 1;\n    private const IS_REF_CHAINED = 2;\n    private const CACHE_PREFIX_READ = 'r';\n    private const CACHE_PREFIX_WRITE = 'w';\n    private const CACHE_PREFIX_PROPERTY_PATH = 'p';\n    private const RESULT_PROTO = [self::VALUE => null];\n\n    private bool $ignoreInvalidIndices;\n    private bool $ignoreInvalidProperty;\n    private ?CacheItemPoolInterface $cacheItemPool;\n    private array $propertyPathCache = [];\n    private PropertyReadInfoExtractorInterface $readInfoExtractor;\n    private PropertyWriteInfoExtractorInterface $writeInfoExtractor;\n    private array $readPropertyCache = [];\n    private array $writePropertyCache = [];\n\n    /**\n     * Should not be used by application code. Use\n     * {@link PropertyAccess::createPropertyAccessor()} instead.\n     *\n     * @param int $magicMethods A bitwise combination of the MAGIC_* constants\n     *                          to specify the allowed magic methods (__get, __set, __call)\n     *                          or self::DISALLOW_MAGIC_METHODS for none\n     * @param int $throw        A bitwise combination of the THROW_* constants\n     *                          to specify when exceptions should be thrown\n     */\n    public function __construct(\n        private int $magicMethodsFlags = self::MAGIC_GET | self::MAGIC_SET,\n        int $throw = self::THROW_ON_INVALID_PROPERTY_PATH,\n        ?CacheItemPoolInterface $cacheItemPool = null,\n        ?PropertyReadInfoExtractorInterface $readInfoExtractor = null,\n        ?PropertyWriteInfoExtractorInterface $writeInfoExtractor = null,\n    ) {\n        $this->ignoreInvalidIndices = 0 === ($throw & self::THROW_ON_INVALID_INDEX);\n        $this->cacheItemPool = $cacheItemPool instanceof NullAdapter ? null : $cacheItemPool; // Replace the NullAdapter by the null value\n        $this->ignoreInvalidProperty = 0 === ($throw & self::THROW_ON_INVALID_PROPERTY_PATH);\n        $this->readInfoExtractor = $readInfoExtractor ?? new ReflectionExtractor([], null, null, false);\n        $this->writeInfoExtractor = $writeInfoExtractor ?? new ReflectionExtractor(['set'], null, null, false);\n    }\n\n    public function getValue(object|array $objectOrArray, string|PropertyPathInterface $propertyPath): mixed\n    {\n        $zval = [\n            self::VALUE => $objectOrArray,\n        ];\n\n        if (\\is_object($objectOrArray) && (false === strpbrk((string) $propertyPath, '.[?') || $objectOrArray instanceof \\stdClass && property_exists($objectOrArray, $propertyPath))) {\n            return $this->readProperty($zval, $propertyPath, $this->ignoreInvalidProperty)[self::VALUE];\n        }\n\n        $propertyPath = $this->getPropertyPath($propertyPath);\n\n        $propertyValues = $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength(), $this->ignoreInvalidIndices);\n\n        return $propertyValues[\\count($propertyValues) - 1][self::VALUE];\n    }\n\n    public function setValue(object|array &$objectOrArray, string|PropertyPathInterface $propertyPath, mixed $value): void\n    {\n        if (\\is_object($objectOrArray) && (false === strpbrk((string) $propertyPath, '.[') || $objectOrArray instanceof \\stdClass && property_exists($objectOrArray, $propertyPath))) {\n            $zval = [\n                self::VALUE => $objectOrArray,\n            ];\n\n            try {\n                $this->writeProperty($zval, $propertyPath, $value);\n\n                return;\n            } catch (\\TypeError $e) {\n                self::throwInvalidArgumentException($e->getMessage(), $e->getTrace(), 0, $propertyPath, $e);\n                // It wasn't thrown in this class so rethrow it\n                throw $e;\n            }\n        }\n\n        $propertyPath = $this->getPropertyPath($propertyPath);\n\n        $zval = [\n            self::VALUE => $objectOrArray,\n            self::REF => &$objectOrArray,\n        ];\n        $propertyValues = $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength() - 1);\n        $overwrite = true;\n\n        try {\n            for ($i = \\count($propertyValues) - 1; 0 <= $i; --$i) {\n                $zval = $propertyValues[$i];\n                unset($propertyValues[$i]);\n\n                // You only need set value for current element if:\n                // 1. it's the parent of the last index element\n                // OR\n                // 2. its child is not passed by reference\n                //\n                // This may avoid unnecessary value setting process for array elements.\n                // For example:\n                // '[a][b][c]' => 'old-value'\n                // If you want to change its value to 'new-value',\n                // you only need set value for '[a][b][c]' and it's safe to ignore '[a][b]' and '[a]'\n                if ($overwrite) {\n                    $property = $propertyPath->getElement($i);\n\n                    if ($propertyPath->isIndex($i)) {\n                        if ($overwrite = !isset($zval[self::REF])) {\n                            $ref = &$zval[self::REF];\n                            $ref = $zval[self::VALUE];\n                        }\n                        $this->writeIndex($zval, $property, $value);\n                        if ($overwrite) {\n                            $zval[self::VALUE] = $zval[self::REF];\n                        }\n                    } else {\n                        $this->writeProperty($zval, $property, $value);\n                    }\n\n                    // if current element is an object\n                    // OR\n                    // if current element's reference chain is not broken - current element\n                    // as well as all its ancients in the property path are all passed by reference,\n                    // then there is no need to continue the value setting process\n                    if (\\is_object($zval[self::VALUE]) || isset($zval[self::IS_REF_CHAINED])) {\n                        break;\n                    }\n                }\n\n                $value = $zval[self::VALUE];\n            }\n        } catch (\\TypeError $e) {\n            self::throwInvalidArgumentException($e->getMessage(), $e->getTrace(), 0, $propertyPath, $e);\n\n            // It wasn't thrown in this class so rethrow it\n            throw $e;\n        }\n    }\n\n    private static function throwInvalidArgumentException(string $message, array $trace, int $i, string $propertyPath, ?\\Throwable $previous = null): void\n    {\n        if (!isset($trace[$i]['file']) || __FILE__ !== $trace[$i]['file']) {\n            return;\n        }\n        if (preg_match('/^\\S+::\\S+\\(\\): Argument #\\d+ \\(\\$\\S+\\) must be of type (\\S+), (\\S+) given/', $message, $matches)) {\n            [, $expectedType, $actualType] = $matches;\n\n            throw new InvalidTypeException($expectedType, $actualType, $propertyPath, $previous);\n        }\n        if (preg_match('/^Cannot assign (\\S+) to property \\S+::\\$\\S+ of type (\\S+)$/', $message, $matches)) {\n            [, $actualType, $expectedType] = $matches;\n\n            throw new InvalidTypeException($expectedType, $actualType, $propertyPath, $previous);\n        }\n    }\n\n    public function isReadable(object|array $objectOrArray, string|PropertyPathInterface $propertyPath): bool\n    {\n        if (!$propertyPath instanceof PropertyPathInterface) {\n            $propertyPath = new PropertyPath($propertyPath);\n        }\n\n        try {\n            $zval = [\n                self::VALUE => $objectOrArray,\n            ];\n\n            // handle stdClass with properties with a dot in the name\n            if ($objectOrArray instanceof \\stdClass && str_contains($propertyPath, '.')  && property_exists($objectOrArray, $propertyPath)) {\n                $this->readProperty($zval, $propertyPath, $this->ignoreInvalidProperty);\n            } else {\n                $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength(), $this->ignoreInvalidIndices);\n            }\n\n            return true;\n        } catch (AccessException|UnexpectedTypeException) {\n            return false;\n        }\n    }\n\n    public function isWritable(object|array $objectOrArray, string|PropertyPathInterface $propertyPath): bool\n    {\n        $propertyPath = $this->getPropertyPath($propertyPath);\n\n        try {\n            $zval = [\n                self::VALUE => $objectOrArray,\n            ];\n\n            // handle stdClass with properties with a dot in the name\n            if ($objectOrArray instanceof \\stdClass && str_contains($propertyPath, '.') && property_exists($objectOrArray, $propertyPath)) {\n                $this->readProperty($zval, $propertyPath, $this->ignoreInvalidProperty);\n\n                return true;\n            }\n\n            $propertyValues = $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength() - 1);\n\n            for ($i = \\count($propertyValues) - 1; 0 <= $i; --$i) {\n                $zval = $propertyValues[$i];\n                unset($propertyValues[$i]);\n\n                if ($propertyPath->isIndex($i)) {\n                    if (!$zval[self::VALUE] instanceof \\ArrayAccess && !\\is_array($zval[self::VALUE])) {\n                        return false;\n                    }\n                } elseif (!\\is_object($zval[self::VALUE]) || !$this->isPropertyWritable($zval[self::VALUE], $propertyPath->getElement($i))) {\n                    return false;\n                }\n\n                if (\\is_object($zval[self::VALUE])) {\n                    return true;\n                }\n            }\n\n            return true;\n        } catch (AccessException|UnexpectedTypeException) {\n            return false;\n        }\n    }\n\n    /**\n     * Reads the path from an object up to a given path index.\n     *\n     * @throws UnexpectedTypeException if a value within the path is neither object nor array\n     * @throws NoSuchIndexException    If a non-existing index is accessed\n     */\n    private function readPropertiesUntil(array $zval, PropertyPathInterface $propertyPath, int $lastIndex, bool $ignoreInvalidIndices = true): array\n    {\n        if (!\\is_object($zval[self::VALUE]) && !\\is_array($zval[self::VALUE])) {\n            throw new UnexpectedTypeException($zval[self::VALUE], $propertyPath, 0);\n        }\n\n        // Add the root object to the list\n        $propertyValues = [$zval];\n\n        for ($i = 0; $i < $lastIndex; ++$i) {\n            $property = $propertyPath->getElement($i);\n            $isIndex = $propertyPath->isIndex($i);\n            $isNullSafe = $propertyPath->isNullSafe($i);\n\n            if ($isIndex) {\n                // Create missing nested arrays on demand\n                if (($zval[self::VALUE] instanceof \\ArrayAccess && !$zval[self::VALUE]->offsetExists($property))\n                    || (\\is_array($zval[self::VALUE]) && !isset($zval[self::VALUE][$property]) && !\\array_key_exists($property, $zval[self::VALUE]))\n                ) {\n                    if (!$ignoreInvalidIndices && !$isNullSafe) {\n                        if (!\\is_array($zval[self::VALUE])) {\n                            if (!$zval[self::VALUE] instanceof \\Traversable) {\n                                throw new NoSuchIndexException(\\sprintf('Cannot read index \"%s\" while trying to traverse path \"%s\".', $property, (string) $propertyPath));\n                            }\n\n                            $zval[self::VALUE] = iterator_to_array($zval[self::VALUE]);\n                        }\n\n                        throw new NoSuchIndexException(\\sprintf('Cannot read index \"%s\" while trying to traverse path \"%s\". Available indices are \"%s\".', $property, (string) $propertyPath, print_r(array_keys($zval[self::VALUE]), true)));\n                    }\n\n                    if ($i + 1 < $propertyPath->getLength()) {\n                        if (isset($zval[self::REF])) {\n                            $zval[self::VALUE][$property] = [];\n                            $zval[self::REF] = $zval[self::VALUE];\n                        } else {\n                            $zval[self::VALUE] = [$property => []];\n                        }\n                    }\n                }\n\n                $zval = $this->readIndex($zval, $property);\n            } elseif ($isNullSafe && !\\is_object($zval[self::VALUE])) {\n                $zval[self::VALUE] = null;\n            } else {\n                $zval = $this->readProperty($zval, $property, $this->ignoreInvalidProperty, $isNullSafe);\n            }\n\n            // the final value of the path must not be validated\n            if ($i + 1 < $propertyPath->getLength() && !\\is_object($zval[self::VALUE]) && !\\is_array($zval[self::VALUE]) && !$isNullSafe) {\n                throw new UnexpectedTypeException($zval[self::VALUE], $propertyPath, $i + 1);\n            }\n\n            if (isset($zval[self::REF]) && (0 === $i || isset($propertyValues[$i - 1][self::IS_REF_CHAINED]))) {\n                // Set the IS_REF_CHAINED flag to true if:\n                // current property is passed by reference and\n                // it is the first element in the property path or\n                // the IS_REF_CHAINED flag of its parent element is true\n                // Basically, this flag is true only when the reference chain from the top element to current element is not broken\n                $zval[self::IS_REF_CHAINED] = true;\n            }\n\n            $propertyValues[] = $zval;\n\n            if ($isNullSafe && null === $zval[self::VALUE]) {\n                break;\n            }\n        }\n\n        return $propertyValues;\n    }\n\n    /**\n     * Reads a key from an array-like structure.\n     *\n     * @throws NoSuchIndexException If the array does not implement \\ArrayAccess or it is not an array\n     */\n    private function readIndex(array $zval, string|int $index): array\n    {\n        if (!$zval[self::VALUE] instanceof \\ArrayAccess && !\\is_array($zval[self::VALUE])) {\n            throw new NoSuchIndexException(\\sprintf('Cannot read index \"%s\" from object of type \"%s\" because it doesn\\'t implement \\ArrayAccess.', $index, get_debug_type($zval[self::VALUE])));\n        }\n\n        $result = self::RESULT_PROTO;\n\n        if (isset($zval[self::VALUE][$index])) {\n            $result[self::VALUE] = $zval[self::VALUE][$index];\n\n            if (!isset($zval[self::REF])) {\n                // Save creating references when doing read-only lookups\n            } elseif (\\is_array($zval[self::VALUE])) {\n                $result[self::REF] = &$zval[self::REF][$index];\n            } elseif (\\is_object($result[self::VALUE])) {\n                $result[self::REF] = $result[self::VALUE];\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Reads the value of a property from an object.\n     *\n     * @throws NoSuchPropertyException If $ignoreInvalidProperty is false and the property does not exist or is not public\n     */\n    private function readProperty(array $zval, string $property, bool $ignoreInvalidProperty = false, bool $isNullSafe = false): array\n    {\n        if (!\\is_object($zval[self::VALUE])) {\n            throw new NoSuchPropertyException(\\sprintf('Cannot read property \"%s\" from an array. Maybe you intended to write the property path as \"[%1$s]\" instead.', $property));\n        }\n\n        $result = self::RESULT_PROTO;\n        $object = $zval[self::VALUE];\n        $class = $object::class;\n        $access = $this->getReadInfo($class, $property);\n\n        if (null !== $access) {\n            $name = $access->getName();\n            $type = $access->getType();\n\n            try {\n                if (PropertyReadInfo::TYPE_METHOD === $type) {\n                    try {\n                        $result[self::VALUE] = $object->$name();\n                    } catch (\\TypeError $e) {\n                        [$trace] = $e->getTrace();\n\n                        // handle uninitialized properties in PHP >= 7\n                        if (__FILE__ === ($trace['file'] ?? null)\n                            && $name === $trace['function']\n                            && $object instanceof $trace['class']\n                            && preg_match('/Return value (?:of .*::\\w+\\(\\) )?must be of (?:the )?type (\\w+), null returned$/', $e->getMessage(), $matches)\n                        ) {\n                            throw new UninitializedPropertyException(\\sprintf('The method \"%s::%s()\" returned \"null\", but expected type \"%3$s\". Did you forget to initialize a property or to make the return type nullable using \"?%3$s\"?', get_debug_type($object), $name, $matches[1]), 0, $e);\n                        }\n\n                        throw $e;\n                    }\n                } elseif (PropertyReadInfo::TYPE_PROPERTY === $type) {\n                    if (!isset($object->$name) && !\\array_key_exists($name, (array) $object)) {\n                        try {\n                            $r = new \\ReflectionProperty($class, $name);\n\n                            if ($r->isPublic() && !$r->hasType()) {\n                                throw new UninitializedPropertyException(\\sprintf('The property \"%s::$%s\" is not initialized.', $class, $name));\n                            }\n                        } catch (\\ReflectionException $e) {\n                            if (!$ignoreInvalidProperty) {\n                                throw new NoSuchPropertyException(\\sprintf('Can\\'t get a way to read the property \"%s\" in class \"%s\".', $property, $class));\n                            }\n                        }\n                    }\n\n                    $result[self::VALUE] = $object->$name;\n\n                    if (isset($zval[self::REF]) && $access->canBeReference()) {\n                        $result[self::REF] = &$object->$name;\n                    }\n                }\n            } catch (\\Error $e) {\n                // handle uninitialized properties in PHP >= 7.4\n                if (preg_match('/^Typed property ([\\w\\\\\\\\@]+)::\\$(\\w+) must not be accessed before initialization$/', $e->getMessage(), $matches) || preg_match('/^Cannot access uninitialized non-nullable property ([\\w\\\\\\\\@]+)::\\$(\\w+) by reference$/', $e->getMessage(), $matches)) {\n                    $r = new \\ReflectionProperty(str_contains($matches[1], '@anonymous') ? $class : $matches[1], $matches[2]);\n                    $type = ($type = $r->getType()) instanceof \\ReflectionNamedType ? $type->getName() : (string) $type;\n\n                    throw new UninitializedPropertyException(\\sprintf('The property \"%s::$%s\" is not readable because it is typed \"%s\". You should initialize it or declare a default value instead.', $matches[1], $r->getName(), $type), 0, $e);\n                }\n\n                throw $e;\n            }\n        } elseif (property_exists($object, $property) && \\array_key_exists($property, (array) $object)) {\n            $result[self::VALUE] = $object->$property;\n            if (isset($zval[self::REF])) {\n                $result[self::REF] = &$object->$property;\n            }\n        } elseif ($isNullSafe) {\n            $result[self::VALUE] = null;\n        } elseif (!$ignoreInvalidProperty) {\n            throw new NoSuchPropertyException(\\sprintf('Can\\'t get a way to read the property \"%s\" in class \"%s\".', $property, $class));\n        }\n\n        // Objects are always passed around by reference\n        if (isset($zval[self::REF]) && \\is_object($result[self::VALUE])) {\n            $result[self::REF] = $result[self::VALUE];\n        }\n\n        return $result;\n    }\n\n    /**\n     * Guesses how to read the property value.\n     */\n    private function getReadInfo(string $class, string $property): ?PropertyReadInfo\n    {\n        $key = str_replace('\\\\', '.', $class).'..'.$property;\n\n        if (isset($this->readPropertyCache[$key])) {\n            return $this->readPropertyCache[$key];\n        }\n\n        if ($this->cacheItemPool) {\n            $item = $this->cacheItemPool->getItem(self::CACHE_PREFIX_READ.rawurlencode($key));\n            if ($item->isHit()) {\n                return $this->readPropertyCache[$key] = $item->get();\n            }\n        }\n\n        $accessor = $this->readInfoExtractor->getReadInfo($class, $property, [\n            'enable_getter_setter_extraction' => true,\n            'enable_magic_methods_extraction' => $this->magicMethodsFlags,\n            'enable_constructor_extraction' => false,\n        ]);\n\n        if (isset($item)) {\n            $this->cacheItemPool->save($item->set($accessor));\n        }\n\n        return $this->readPropertyCache[$key] = $accessor;\n    }\n\n    /**\n     * Sets the value of an index in a given array-accessible value.\n     *\n     * @throws NoSuchIndexException If the array does not implement \\ArrayAccess or it is not an array\n     */\n    private function writeIndex(array $zval, string|int $index, mixed $value): void\n    {\n        if (!$zval[self::VALUE] instanceof \\ArrayAccess && !\\is_array($zval[self::VALUE])) {\n            throw new NoSuchIndexException(\\sprintf('Cannot modify index \"%s\" in object of type \"%s\" because it doesn\\'t implement \\ArrayAccess.', $index, get_debug_type($zval[self::VALUE])));\n        }\n\n        $zval[self::REF][$index] = $value;\n    }\n\n    /**\n     * Sets the value of a property in the given object.\n     *\n     * @throws NoSuchPropertyException if the property does not exist or is not public\n     */\n    private function writeProperty(array $zval, string $property, mixed $value, bool $recursive = false): void\n    {\n        if (!\\is_object($zval[self::VALUE])) {\n            throw new NoSuchPropertyException(\\sprintf('Cannot write property \"%s\" to an array. Maybe you should write the property path as \"[%1$s]\" instead?', $property));\n        }\n\n        $object = $zval[self::VALUE];\n        $class = $object::class;\n        $mutator = $this->getWriteInfo($class, $property, $value);\n\n        try {\n            if (PropertyWriteInfo::TYPE_NONE !== $mutator->getType()) {\n                $type = $mutator->getType();\n\n                if (PropertyWriteInfo::TYPE_METHOD === $type) {\n                    $object->{$mutator->getName()}($value);\n                } elseif (PropertyWriteInfo::TYPE_PROPERTY === $type) {\n                    $object->{$mutator->getName()} = $value;\n                } elseif (PropertyWriteInfo::TYPE_ADDER_AND_REMOVER === $type) {\n                    $this->writeCollection($zval, $property, $value, $mutator->getAdderInfo(), $mutator->getRemoverInfo());\n                }\n            } elseif ($object instanceof \\stdClass && property_exists($object, $property)) {\n                $object->$property = $value;\n            } elseif (!$this->ignoreInvalidProperty) {\n                if ($mutator->hasErrors()) {\n                    throw new NoSuchPropertyException(implode('. ', $mutator->getErrors()).'.');\n                }\n\n                throw new NoSuchPropertyException(\\sprintf('Could not determine access type for property \"%s\" in class \"%s\".', $property, get_debug_type($object)));\n            }\n        } catch (\\TypeError $e) {\n            if ($recursive || !$value instanceof \\DateTimeInterface || !\\in_array($value::class, ['DateTime', 'DateTimeImmutable'], true) || __FILE__ !== ($e->getTrace()[0]['file'] ?? null)) {\n                throw $e;\n            }\n\n            $value = $value instanceof \\DateTimeImmutable ? \\DateTime::createFromImmutable($value) : \\DateTimeImmutable::createFromMutable($value);\n            try {\n                $this->writeProperty($zval, $property, $value, true);\n            } catch (\\TypeError) {\n                throw $e; // throw the previous error\n            }\n        }\n    }\n\n    /**\n     * Adjusts a collection-valued property by calling add*() and remove*() methods.\n     */\n    private function writeCollection(array $zval, string $property, iterable $collection, PropertyWriteInfo $addMethod, PropertyWriteInfo $removeMethod): void\n    {\n        // At this point the add and remove methods have been found\n        $previousValue = $this->readProperty($zval, $property);\n        $previousValue = $previousValue[self::VALUE];\n\n        $removeMethodName = $removeMethod->getName();\n        $addMethodName = $addMethod->getName();\n\n        if ($previousValue instanceof \\Traversable) {\n            $previousValue = iterator_to_array($previousValue);\n        }\n        if ($previousValue && \\is_array($previousValue)) {\n            if (\\is_object($collection)) {\n                $collection = iterator_to_array($collection);\n            }\n            foreach ($previousValue as $key => $item) {\n                if (!\\in_array($item, $collection, true)) {\n                    unset($previousValue[$key]);\n                    $zval[self::VALUE]->$removeMethodName($item);\n                }\n            }\n        } else {\n            $previousValue = false;\n        }\n\n        foreach ($collection as $item) {\n            if (!$previousValue || !\\in_array($item, $previousValue, true)) {\n                $zval[self::VALUE]->$addMethodName($item);\n            }\n        }\n    }\n\n    private function getWriteInfo(string $class, string $property, mixed $value): PropertyWriteInfo\n    {\n        $useAdderAndRemover = is_iterable($value);\n        $key = str_replace('\\\\', '.', $class).'..'.$property.'..'.(int) $useAdderAndRemover;\n\n        if (isset($this->writePropertyCache[$key])) {\n            return $this->writePropertyCache[$key];\n        }\n\n        if ($this->cacheItemPool) {\n            $item = $this->cacheItemPool->getItem(self::CACHE_PREFIX_WRITE.rawurlencode($key));\n            if ($item->isHit()) {\n                return $this->writePropertyCache[$key] = $item->get();\n            }\n        }\n\n        $mutator = $this->writeInfoExtractor->getWriteInfo($class, $property, [\n            'enable_getter_setter_extraction' => true,\n            'enable_magic_methods_extraction' => $this->magicMethodsFlags,\n            'enable_constructor_extraction' => false,\n            'enable_adder_remover_extraction' => $useAdderAndRemover,\n        ]);\n\n        if (isset($item)) {\n            $this->cacheItemPool->save($item->set($mutator));\n        }\n\n        return $this->writePropertyCache[$key] = $mutator;\n    }\n\n    /**\n     * Returns whether a property is writable in the given object.\n     */\n    private function isPropertyWritable(object $object, string $property): bool\n    {\n        if ($object instanceof \\stdClass && property_exists($object, $property)) {\n            return true;\n        }\n\n        $mutatorForArray = $this->getWriteInfo($object::class, $property, []);\n        if (PropertyWriteInfo::TYPE_PROPERTY === $mutatorForArray->getType()) {\n            return $mutatorForArray->getVisibility() === 'public';\n        }\n\n        if (PropertyWriteInfo::TYPE_NONE !== $mutatorForArray->getType()) {\n            return true;\n        }\n\n        $mutator = $this->getWriteInfo($object::class, $property, '');\n\n        return PropertyWriteInfo::TYPE_NONE !== $mutator->getType();\n    }\n\n    /**\n     * Gets a PropertyPath instance and caches it.\n     */\n    private function getPropertyPath(string|PropertyPath $propertyPath): PropertyPath\n    {\n        if ($propertyPath instanceof PropertyPathInterface) {\n            // Don't call the copy constructor has it is not needed here\n            return $propertyPath;\n        }\n\n        if (isset($this->propertyPathCache[$propertyPath])) {\n            return $this->propertyPathCache[$propertyPath];\n        }\n\n        if ($this->cacheItemPool) {\n            $item = $this->cacheItemPool->getItem(self::CACHE_PREFIX_PROPERTY_PATH.rawurlencode($propertyPath));\n            if ($item->isHit()) {\n                return $this->propertyPathCache[$propertyPath] = $item->get();\n            }\n        }\n\n        $propertyPathInstance = new PropertyPath($propertyPath);\n        if (isset($item)) {\n            $item->set($propertyPathInstance);\n            $this->cacheItemPool->save($item);\n        }\n\n        return $this->propertyPathCache[$propertyPath] = $propertyPathInstance;\n    }\n\n    /**\n     * Creates the APCu adapter if applicable.\n     *\n     * @throws \\LogicException When the Cache Component isn't available\n     */\n    public static function createCache(string $namespace, int $defaultLifetime, string $version, ?LoggerInterface $logger = null): AdapterInterface\n    {\n        if (!class_exists(ApcuAdapter::class)) {\n            throw new \\LogicException(\\sprintf('The Symfony Cache component must be installed to use \"%s()\".', __METHOD__));\n        }\n\n        if (!ApcuAdapter::isSupported()) {\n            return new NullAdapter();\n        }\n\n        $apcu = new ApcuAdapter($namespace, $defaultLifetime / 5, $version);\n        if ('cli' === \\PHP_SAPI && !filter_var(\\ini_get('apc.enable_cli'), \\FILTER_VALIDATE_BOOL)) {\n            $apcu->setLogger(new NullLogger());\n        } elseif (null !== $logger) {\n            $apcu->setLogger($logger);\n        }\n\n        return $apcu;\n    }\n}\n"
        },
        {
          "name": "PropertyAccessorBuilder.php",
          "type": "blob",
          "size": 7.4482421875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse Symfony\\Component\\PropertyInfo\\PropertyReadInfoExtractorInterface;\nuse Symfony\\Component\\PropertyInfo\\PropertyWriteInfoExtractorInterface;\n\n/**\n * A configurable builder to create a PropertyAccessor.\n *\n * @author JÃ©rÃ©mie Augustin <jeremie.augustin@pixel-cookers.com>\n */\nclass PropertyAccessorBuilder\n{\n    private int $magicMethods = PropertyAccessor::MAGIC_GET | PropertyAccessor::MAGIC_SET;\n    private bool $throwExceptionOnInvalidIndex = false;\n    private bool $throwExceptionOnInvalidPropertyPath = true;\n    private ?CacheItemPoolInterface $cacheItemPool = null;\n    private ?PropertyReadInfoExtractorInterface $readInfoExtractor = null;\n    private ?PropertyWriteInfoExtractorInterface $writeInfoExtractor = null;\n\n    /**\n     * Enables the use of all magic methods by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function enableMagicMethods(): static\n    {\n        $this->magicMethods = PropertyAccessor::MAGIC_GET | PropertyAccessor::MAGIC_SET | PropertyAccessor::MAGIC_CALL;\n\n        return $this;\n    }\n\n    /**\n     * Disable the use of all magic methods by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function disableMagicMethods(): static\n    {\n        $this->magicMethods = PropertyAccessor::DISALLOW_MAGIC_METHODS;\n\n        return $this;\n    }\n\n    /**\n     * Enables the use of \"__call\" by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function enableMagicCall(): static\n    {\n        $this->magicMethods |= PropertyAccessor::MAGIC_CALL;\n\n        return $this;\n    }\n\n    /**\n     * Enables the use of \"__get\" by the PropertyAccessor.\n     */\n    public function enableMagicGet(): self\n    {\n        $this->magicMethods |= PropertyAccessor::MAGIC_GET;\n\n        return $this;\n    }\n\n    /**\n     * Enables the use of \"__set\" by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function enableMagicSet(): static\n    {\n        $this->magicMethods |= PropertyAccessor::MAGIC_SET;\n\n        return $this;\n    }\n\n    /**\n     * Disables the use of \"__call\" by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function disableMagicCall(): static\n    {\n        $this->magicMethods &= ~PropertyAccessor::MAGIC_CALL;\n\n        return $this;\n    }\n\n    /**\n     * Disables the use of \"__get\" by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function disableMagicGet(): static\n    {\n        $this->magicMethods &= ~PropertyAccessor::MAGIC_GET;\n\n        return $this;\n    }\n\n    /**\n     * Disables the use of \"__set\" by the PropertyAccessor.\n     *\n     * @return $this\n     */\n    public function disableMagicSet(): static\n    {\n        $this->magicMethods &= ~PropertyAccessor::MAGIC_SET;\n\n        return $this;\n    }\n\n    /**\n     * @return bool whether the use of \"__call\" by the PropertyAccessor is enabled\n     */\n    public function isMagicCallEnabled(): bool\n    {\n        return (bool) ($this->magicMethods & PropertyAccessor::MAGIC_CALL);\n    }\n\n    /**\n     * @return bool whether the use of \"__get\" by the PropertyAccessor is enabled\n     */\n    public function isMagicGetEnabled(): bool\n    {\n        return $this->magicMethods & PropertyAccessor::MAGIC_GET;\n    }\n\n    /**\n     * @return bool whether the use of \"__set\" by the PropertyAccessor is enabled\n     */\n    public function isMagicSetEnabled(): bool\n    {\n        return $this->magicMethods & PropertyAccessor::MAGIC_SET;\n    }\n\n    /**\n     * Enables exceptions when reading a non-existing index.\n     *\n     * This has no influence on writing non-existing indices with PropertyAccessorInterface::setValue()\n     * which are always created on-the-fly.\n     *\n     * @return $this\n     */\n    public function enableExceptionOnInvalidIndex(): static\n    {\n        $this->throwExceptionOnInvalidIndex = true;\n\n        return $this;\n    }\n\n    /**\n     * Disables exceptions when reading a non-existing index.\n     *\n     * Instead, null is returned when calling PropertyAccessorInterface::getValue() on a non-existing index.\n     *\n     * @return $this\n     */\n    public function disableExceptionOnInvalidIndex(): static\n    {\n        $this->throwExceptionOnInvalidIndex = false;\n\n        return $this;\n    }\n\n    /**\n     * @return bool whether an exception is thrown or null is returned when reading a non-existing index\n     */\n    public function isExceptionOnInvalidIndexEnabled(): bool\n    {\n        return $this->throwExceptionOnInvalidIndex;\n    }\n\n    /**\n     * Enables exceptions when reading a non-existing property.\n     *\n     * This has no influence on writing non-existing indices with PropertyAccessorInterface::setValue()\n     * which are always created on-the-fly.\n     *\n     * @return $this\n     */\n    public function enableExceptionOnInvalidPropertyPath(): static\n    {\n        $this->throwExceptionOnInvalidPropertyPath = true;\n\n        return $this;\n    }\n\n    /**\n     * Disables exceptions when reading a non-existing index.\n     *\n     * Instead, null is returned when calling PropertyAccessorInterface::getValue() on a non-existing index.\n     *\n     * @return $this\n     */\n    public function disableExceptionOnInvalidPropertyPath(): static\n    {\n        $this->throwExceptionOnInvalidPropertyPath = false;\n\n        return $this;\n    }\n\n    /**\n     * @return bool whether an exception is thrown or null is returned when reading a non-existing property\n     */\n    public function isExceptionOnInvalidPropertyPath(): bool\n    {\n        return $this->throwExceptionOnInvalidPropertyPath;\n    }\n\n    /**\n     * Sets a cache system.\n     *\n     * @return $this\n     */\n    public function setCacheItemPool(?CacheItemPoolInterface $cacheItemPool): static\n    {\n        $this->cacheItemPool = $cacheItemPool;\n\n        return $this;\n    }\n\n    /**\n     * Gets the used cache system.\n     */\n    public function getCacheItemPool(): ?CacheItemPoolInterface\n    {\n        return $this->cacheItemPool;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setReadInfoExtractor(?PropertyReadInfoExtractorInterface $readInfoExtractor): static\n    {\n        $this->readInfoExtractor = $readInfoExtractor;\n\n        return $this;\n    }\n\n    public function getReadInfoExtractor(): ?PropertyReadInfoExtractorInterface\n    {\n        return $this->readInfoExtractor;\n    }\n\n    /**\n     * @return $this\n     */\n    public function setWriteInfoExtractor(?PropertyWriteInfoExtractorInterface $writeInfoExtractor): static\n    {\n        $this->writeInfoExtractor = $writeInfoExtractor;\n\n        return $this;\n    }\n\n    public function getWriteInfoExtractor(): ?PropertyWriteInfoExtractorInterface\n    {\n        return $this->writeInfoExtractor;\n    }\n\n    /**\n     * Builds and returns a new PropertyAccessor object.\n     */\n    public function getPropertyAccessor(): PropertyAccessorInterface\n    {\n        $throw = PropertyAccessor::DO_NOT_THROW;\n\n        if ($this->throwExceptionOnInvalidIndex) {\n            $throw |= PropertyAccessor::THROW_ON_INVALID_INDEX;\n        }\n\n        if ($this->throwExceptionOnInvalidPropertyPath) {\n            $throw |= PropertyAccessor::THROW_ON_INVALID_PROPERTY_PATH;\n        }\n\n        return new PropertyAccessor($this->magicMethods, $throw, $this->cacheItemPool, $this->readInfoExtractor, $this->writeInfoExtractor);\n    }\n}\n"
        },
        {
          "name": "PropertyAccessorInterface.php",
          "type": "blob",
          "size": 3.7275390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\n/**\n * Writes and reads values to/from an object/array graph.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface PropertyAccessorInterface\n{\n    /**\n     * Sets the value at the end of the property path of the object graph.\n     *\n     * Example:\n     *\n     *     use Symfony\\Component\\PropertyAccess\\PropertyAccess;\n     *\n     *     $propertyAccessor = PropertyAccess::createPropertyAccessor();\n     *\n     *     echo $propertyAccessor->setValue($object, 'child.name', 'Fabien');\n     *     // equals echo $object->getChild()->setName('Fabien');\n     *\n     * This method first tries to find a public setter for each property in the\n     * path. The name of the setter must be the camel-cased property name\n     * prefixed with \"set\".\n     *\n     * If the setter does not exist, this method tries to find a public\n     * property. The value of the property is then changed.\n     *\n     * If neither is found, an exception is thrown.\n     *\n     * @throws Exception\\InvalidArgumentException If the property path is invalid\n     * @throws Exception\\AccessException          If a property/index does not exist or is not public\n     * @throws Exception\\UnexpectedTypeException  If a value within the path is neither object nor array\n     */\n    public function setValue(object|array &$objectOrArray, string|PropertyPathInterface $propertyPath, mixed $value): void;\n\n    /**\n     * Returns the value at the end of the property path of the object graph.\n     *\n     * Example:\n     *\n     *     use Symfony\\Component\\PropertyAccess\\PropertyAccess;\n     *\n     *     $propertyAccessor = PropertyAccess::createPropertyAccessor();\n     *\n     *     echo $propertyAccessor->getValue($object, 'child.name');\n     *     // equals echo $object->getChild()->getName();\n     *\n     * This method first tries to find a public getter for each property in the\n     * path. The name of the getter must be the camel-cased property name\n     * prefixed with \"get\", \"is\", or \"has\".\n     *\n     * If the getter does not exist, this method tries to find a public\n     * property. The value of the property is then returned.\n     *\n     * If none of them are found, an exception is thrown.\n     *\n     * @throws Exception\\InvalidArgumentException If the property path is invalid\n     * @throws Exception\\AccessException          If a property/index does not exist or is not public\n     * @throws Exception\\UnexpectedTypeException  If a value within the path is neither object\n     *                                            nor array\n     */\n    public function getValue(object|array $objectOrArray, string|PropertyPathInterface $propertyPath): mixed;\n\n    /**\n     * Returns whether a value can be written at a given property path.\n     *\n     * Whenever this method returns true, {@link setValue()} is guaranteed not\n     * to throw an exception when called with the same arguments.\n     *\n     * @throws Exception\\InvalidArgumentException If the property path is invalid\n     */\n    public function isWritable(object|array $objectOrArray, string|PropertyPathInterface $propertyPath): bool;\n\n    /**\n     * Returns whether a property path can be read from an object graph.\n     *\n     * Whenever this method returns true, {@link getValue()} is guaranteed not\n     * to throw an exception when called with the same arguments.\n     *\n     * @throws Exception\\InvalidArgumentException If the property path is invalid\n     */\n    public function isReadable(object|array $objectOrArray, string|PropertyPathInterface $propertyPath): bool;\n}\n"
        },
        {
          "name": "PropertyPath.php",
          "type": "blob",
          "size": 5.912109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\nuse Symfony\\Component\\PropertyAccess\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\InvalidPropertyPathException;\nuse Symfony\\Component\\PropertyAccess\\Exception\\OutOfBoundsException;\n\n/**\n * Default implementation of {@link PropertyPathInterface}.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @implements \\IteratorAggregate<int, string>\n */\nclass PropertyPath implements \\IteratorAggregate, PropertyPathInterface\n{\n    /**\n     * Character used for separating between plural and singular of an element.\n     */\n    public const SINGULAR_SEPARATOR = '|';\n\n    /**\n     * The elements of the property path.\n     *\n     * @var list<string>\n     */\n    private array $elements = [];\n\n    /**\n     * The number of elements in the property path.\n     */\n    private int $length;\n\n    /**\n     * Contains a Boolean for each property in $elements denoting whether this\n     * element is an index. It is a property otherwise.\n     *\n     * @var array<bool>\n     */\n    private array $isIndex = [];\n\n    /**\n     * Contains a Boolean for each property in $elements denoting whether this\n     * element is optional or not.\n     *\n     * @var array<bool>\n     */\n    private array $isNullSafe = [];\n\n    /**\n     * String representation of the path.\n     */\n    private string $pathAsString;\n\n    /**\n     * Constructs a property path from a string.\n     *\n     * @throws InvalidArgumentException     If the given path is not a string\n     * @throws InvalidPropertyPathException If the syntax of the property path is not valid\n     */\n    public function __construct(self|string $propertyPath)\n    {\n        // Can be used as copy constructor\n        if ($propertyPath instanceof self) {\n            /* @var PropertyPath $propertyPath */\n            $this->elements = $propertyPath->elements;\n            $this->length = $propertyPath->length;\n            $this->isIndex = $propertyPath->isIndex;\n            $this->isNullSafe = $propertyPath->isNullSafe;\n            $this->pathAsString = $propertyPath->pathAsString;\n\n            return;\n        }\n\n        if ('' === $propertyPath) {\n            throw new InvalidPropertyPathException('The property path should not be empty.');\n        }\n\n        $this->pathAsString = $propertyPath;\n        $position = 0;\n        $remaining = $propertyPath;\n\n        // first element is evaluated differently - no leading dot for properties\n        $pattern = '/^(((?:[^\\\\\\\\.\\[]|\\\\\\\\.)++)|\\[([^\\]]++)\\])(.*)/';\n\n        while (preg_match($pattern, $remaining, $matches)) {\n            if ('' !== $matches[2]) {\n                $element = $matches[2];\n                $this->isIndex[] = false;\n            } else {\n                $element = $matches[3];\n                $this->isIndex[] = true;\n            }\n\n            // Mark as optional when last character is \"?\".\n            if (str_ends_with($element, '?')) {\n                $this->isNullSafe[] = true;\n                $element = substr($element, 0, -1);\n            } else {\n                $this->isNullSafe[] = false;\n            }\n\n            $element = preg_replace('/\\\\\\([.[])/', '$1', $element);\n            if (str_ends_with($element, '\\\\\\\\')) {\n                $element = substr($element, 0, -1);\n            }\n            $this->elements[] = $element;\n\n            $position += \\strlen($matches[1]);\n            $remaining = $matches[4];\n            $pattern = '/^(\\.((?:[^\\\\\\\\.\\[]|\\\\\\\\.)++)|\\[([^\\]]++)\\])(.*)/';\n        }\n\n        if ('' !== $remaining) {\n            throw new InvalidPropertyPathException(\\sprintf('Could not parse property path \"%s\". Unexpected token \"%s\" at position %d.', $propertyPath, $remaining[0], $position));\n        }\n\n        $this->length = \\count($this->elements);\n    }\n\n    public function __toString(): string\n    {\n        return $this->pathAsString;\n    }\n\n    public function getLength(): int\n    {\n        return $this->length;\n    }\n\n    public function getParent(): ?PropertyPathInterface\n    {\n        if ($this->length <= 1) {\n            return null;\n        }\n\n        $parent = clone $this;\n\n        --$parent->length;\n        $parent->pathAsString = substr($parent->pathAsString, 0, max(strrpos($parent->pathAsString, '.'), strrpos($parent->pathAsString, '[')));\n        array_pop($parent->elements);\n        array_pop($parent->isIndex);\n        array_pop($parent->isNullSafe);\n\n        return $parent;\n    }\n\n    /**\n     * Returns a new iterator for this path.\n     */\n    public function getIterator(): PropertyPathIteratorInterface\n    {\n        return new PropertyPathIterator($this);\n    }\n\n    public function getElements(): array\n    {\n        return $this->elements;\n    }\n\n    public function getElement(int $index): string\n    {\n        if (!isset($this->elements[$index])) {\n            throw new OutOfBoundsException(\\sprintf('The index \"%s\" is not within the property path.', $index));\n        }\n\n        return $this->elements[$index];\n    }\n\n    public function isProperty(int $index): bool\n    {\n        if (!isset($this->isIndex[$index])) {\n            throw new OutOfBoundsException(\\sprintf('The index \"%s\" is not within the property path.', $index));\n        }\n\n        return !$this->isIndex[$index];\n    }\n\n    public function isIndex(int $index): bool\n    {\n        if (!isset($this->isIndex[$index])) {\n            throw new OutOfBoundsException(\\sprintf('The index \"%s\" is not within the property path.', $index));\n        }\n\n        return $this->isIndex[$index];\n    }\n\n    public function isNullSafe(int $index): bool\n    {\n        if (!isset($this->isNullSafe[$index])) {\n            throw new OutOfBoundsException(\\sprintf('The index \"%s\" is not within the property path.', $index));\n        }\n\n        return $this->isNullSafe[$index];\n    }\n}\n"
        },
        {
          "name": "PropertyPathBuilder.php",
          "type": "blob",
          "size": 8.234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\nuse Symfony\\Component\\PropertyAccess\\Exception\\OutOfBoundsException;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass PropertyPathBuilder\n{\n    private array $elements = [];\n    private array $isIndex = [];\n\n    public function __construct(PropertyPathInterface|string|null $path = null)\n    {\n        if (null !== $path) {\n            $this->append($path);\n        }\n    }\n\n    /**\n     * Appends a (sub-) path to the current path.\n     *\n     * @param int $offset The offset where the appended piece starts in $path\n     * @param int $length The length of the appended piece; if 0, the full path is appended\n     */\n    public function append(PropertyPathInterface|string $path, int $offset = 0, int $length = 0): void\n    {\n        if (\\is_string($path)) {\n            $path = new PropertyPath($path);\n        }\n\n        if (0 === $length) {\n            $end = $path->getLength();\n        } else {\n            $end = $offset + $length;\n        }\n\n        for (; $offset < $end; ++$offset) {\n            $this->elements[] = $path->getElement($offset);\n            $this->isIndex[] = $path->isIndex($offset);\n        }\n    }\n\n    /**\n     * Appends an index element to the current path.\n     */\n    public function appendIndex(string $name): void\n    {\n        $this->elements[] = $name;\n        $this->isIndex[] = true;\n    }\n\n    /**\n     * Appends a property element to the current path.\n     */\n    public function appendProperty(string $name): void\n    {\n        $this->elements[] = $name;\n        $this->isIndex[] = false;\n    }\n\n    /**\n     * Removes elements from the current path.\n     *\n     * @throws OutOfBoundsException if offset is invalid\n     */\n    public function remove(int $offset, int $length = 1): void\n    {\n        if (!isset($this->elements[$offset])) {\n            throw new OutOfBoundsException(\\sprintf('The offset \"%s\" is not within the property path.', $offset));\n        }\n\n        $this->resize($offset, $length, 0);\n    }\n\n    /**\n     * Replaces a sub-path by a different (sub-) path.\n     *\n     * @param int $pathOffset The offset where the inserted piece starts in $path\n     * @param int $pathLength The length of the inserted piece; if 0, the full path is inserted\n     *\n     * @throws OutOfBoundsException If the offset is invalid\n     */\n    public function replace(int $offset, int $length, PropertyPathInterface|string $path, int $pathOffset = 0, int $pathLength = 0): void\n    {\n        if (\\is_string($path)) {\n            $path = new PropertyPath($path);\n        }\n\n        if ($offset < 0 && abs($offset) <= $this->getLength()) {\n            $offset = $this->getLength() + $offset;\n        } elseif (!isset($this->elements[$offset])) {\n            throw new OutOfBoundsException('The offset '.$offset.' is not within the property path');\n        }\n\n        if (0 === $pathLength) {\n            $pathLength = $path->getLength() - $pathOffset;\n        }\n\n        $this->resize($offset, $length, $pathLength);\n\n        for ($i = 0; $i < $pathLength; ++$i) {\n            $this->elements[$offset + $i] = $path->getElement($pathOffset + $i);\n            $this->isIndex[$offset + $i] = $path->isIndex($pathOffset + $i);\n        }\n        ksort($this->elements);\n    }\n\n    /**\n     * Replaces a property element by an index element.\n     *\n     * @throws OutOfBoundsException If the offset is invalid\n     */\n    public function replaceByIndex(int $offset, ?string $name = null): void\n    {\n        if (!isset($this->elements[$offset])) {\n            throw new OutOfBoundsException(\\sprintf('The offset \"%s\" is not within the property path.', $offset));\n        }\n\n        if (null !== $name) {\n            $this->elements[$offset] = $name;\n        }\n\n        $this->isIndex[$offset] = true;\n    }\n\n    /**\n     * Replaces an index element by a property element.\n     *\n     * @throws OutOfBoundsException If the offset is invalid\n     */\n    public function replaceByProperty(int $offset, ?string $name = null): void\n    {\n        if (!isset($this->elements[$offset])) {\n            throw new OutOfBoundsException(\\sprintf('The offset \"%s\" is not within the property path.', $offset));\n        }\n\n        if (null !== $name) {\n            $this->elements[$offset] = $name;\n        }\n\n        $this->isIndex[$offset] = false;\n    }\n\n    /**\n     * Returns the length of the current path.\n     */\n    public function getLength(): int\n    {\n        return \\count($this->elements);\n    }\n\n    /**\n     * Returns the current property path.\n     */\n    public function getPropertyPath(): ?PropertyPathInterface\n    {\n        $pathAsString = $this->__toString();\n\n        return '' !== $pathAsString ? new PropertyPath($pathAsString) : null;\n    }\n\n    /**\n     * Returns the current property path as string.\n     */\n    public function __toString(): string\n    {\n        $string = '';\n\n        foreach ($this->elements as $offset => $element) {\n            if ($this->isIndex[$offset]) {\n                $element = '['.$element.']';\n            } elseif ('' !== $string) {\n                $string .= '.';\n            }\n\n            $string .= $element;\n        }\n\n        return $string;\n    }\n\n    /**\n     * Resizes the path so that a chunk of length $cutLength is\n     * removed at $offset and another chunk of length $insertionLength\n     * can be inserted.\n     */\n    private function resize(int $offset, int $cutLength, int $insertionLength): void\n    {\n        // Nothing else to do in this case\n        if ($insertionLength === $cutLength) {\n            return;\n        }\n\n        $length = \\count($this->elements);\n\n        if ($cutLength > $insertionLength) {\n            // More elements should be removed than inserted\n            $diff = $cutLength - $insertionLength;\n            $newLength = $length - $diff;\n\n            // Shift elements to the left (left-to-right until the new end)\n            // Max allowed offset to be shifted is such that\n            // $offset + $diff < $length (otherwise invalid index access)\n            // i.e. $offset < $length - $diff = $newLength\n            for ($i = $offset; $i < $newLength; ++$i) {\n                $this->elements[$i] = $this->elements[$i + $diff];\n                $this->isIndex[$i] = $this->isIndex[$i + $diff];\n            }\n\n            // All remaining elements should be removed\n            $this->elements = \\array_slice($this->elements, 0, $i);\n            $this->isIndex = \\array_slice($this->isIndex, 0, $i);\n        } else {\n            $diff = $insertionLength - $cutLength;\n\n            $newLength = $length + $diff;\n            $indexAfterInsertion = $offset + $insertionLength;\n\n            // $diff <= $insertionLength\n            // $indexAfterInsertion >= $insertionLength\n            // => $diff <= $indexAfterInsertion\n\n            // In each of the following loops, $i >= $diff must hold,\n            // otherwise ($i - $diff) becomes negative.\n\n            // Shift old elements to the right to make up space for the\n            // inserted elements. This needs to be done left-to-right in\n            // order to preserve an ascending array index order\n            // Since $i = max($length, $indexAfterInsertion) and $indexAfterInsertion >= $diff,\n            // $i >= $diff is guaranteed.\n            for ($i = max($length, $indexAfterInsertion); $i < $newLength; ++$i) {\n                $this->elements[$i] = $this->elements[$i - $diff];\n                $this->isIndex[$i] = $this->isIndex[$i - $diff];\n            }\n\n            // Shift remaining elements to the right. Do this right-to-left\n            // so we don't overwrite elements before copying them\n            // The last written index is the immediate index after the inserted\n            // string, because the indices before that will be overwritten\n            // anyway.\n            // Since $i >= $indexAfterInsertion and $indexAfterInsertion >= $diff,\n            // $i >= $diff is guaranteed.\n            for ($i = $length - 1; $i >= $indexAfterInsertion; --$i) {\n                $this->elements[$i] = $this->elements[$i - $diff];\n                $this->isIndex[$i] = $this->isIndex[$i - $diff];\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "PropertyPathInterface.php",
          "type": "blob",
          "size": 2.111328125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\n/**\n * A sequence of property names or array indices.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @extends \\Traversable<int, string>\n */\ninterface PropertyPathInterface extends \\Traversable, \\Stringable\n{\n    /**\n     * Returns the string representation of the property path.\n     */\n    public function __toString(): string;\n\n    /**\n     * Returns the length of the property path, i.e. the number of elements.\n     */\n    public function getLength(): int;\n\n    /**\n     * Returns the parent property path.\n     *\n     * The parent property path is the one that contains the same items as\n     * this one except for the last one.\n     *\n     * If this property path only contains one item, null is returned.\n     */\n    public function getParent(): ?self;\n\n    /**\n     * Returns the elements of the property path as array.\n     *\n     * @return list<string>\n     */\n    public function getElements(): array;\n\n    /**\n     * Returns the element at the given index in the property path.\n     *\n     * @param int $index The index key\n     *\n     * @throws Exception\\OutOfBoundsException If the offset is invalid\n     */\n    public function getElement(int $index): string;\n\n    /**\n     * Returns whether the element at the given index is a property.\n     *\n     * @param int $index The index in the property path\n     *\n     * @throws Exception\\OutOfBoundsException If the offset is invalid\n     */\n    public function isProperty(int $index): bool;\n\n    /**\n     * Returns whether the element at the given index is an array index.\n     *\n     * @param int $index The index in the property path\n     *\n     * @throws Exception\\OutOfBoundsException If the offset is invalid\n     */\n    public function isIndex(int $index): bool;\n\n    /**\n     * Returns whether the element at the given index is null safe.\n     */\n    public function isNullSafe(int $index): bool;\n}\n"
        },
        {
          "name": "PropertyPathIterator.php",
          "type": "blob",
          "size": 0.9267578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\n/**\n * Traverses a property path and provides additional methods to find out\n * information about the current element.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @extends \\ArrayIterator<int, string>\n */\nclass PropertyPathIterator extends \\ArrayIterator implements PropertyPathIteratorInterface\n{\n    public function __construct(\n        protected PropertyPathInterface $path,\n    ) {\n        parent::__construct($path->getElements());\n    }\n\n    public function isIndex(): bool\n    {\n        return $this->path->isIndex($this->key());\n    }\n\n    public function isProperty(): bool\n    {\n        return $this->path->isProperty($this->key());\n    }\n}\n"
        },
        {
          "name": "PropertyPathIteratorInterface.php",
          "type": "blob",
          "size": 0.7314453125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\PropertyAccess;\n\n/**\n * @author Bernhard Schussek <bschussek@gmail.com>\n *\n * @extends \\SeekableIterator<int, string>\n */\ninterface PropertyPathIteratorInterface extends \\SeekableIterator\n{\n    /**\n     * Returns whether the current element in the property path is an array\n     * index.\n     */\n    public function isIndex(): bool;\n\n    /**\n     * Returns whether the current element in the property path is a property\n     * name.\n     */\n    public function isProperty(): bool;\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5478515625,
          "content": "PropertyAccess Component\n========================\n\nThe PropertyAccess component provides functions to read and write from/to an\nobject or array using a simple string notation.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/property_access.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.9404296875,
          "content": "{\n    \"name\": \"symfony/property-access\",\n    \"type\": \"library\",\n    \"description\": \"Provides functions to read and write from/to an object or array using a simple string notation\",\n    \"keywords\": [\"property\", \"index\", \"access\", \"object\", \"array\", \"extraction\", \"injection\", \"reflection\", \"property-path\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/property-info\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"symfony/cache\": \"^6.4|^7.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\PropertyAccess\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony PropertyAccess Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}