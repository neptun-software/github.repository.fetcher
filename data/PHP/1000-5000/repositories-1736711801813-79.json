{
  "metadata": {
    "timestamp": 1736711801813,
    "page": 79,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/dom-crawler",
      "stars": 3982,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "AbstractUriElement.php",
          "type": "blob",
          "size": 3.0400390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\n/**\n * Any HTML element that can link to an URI.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nabstract class AbstractUriElement\n{\n    protected \\DOMElement $node;\n    protected ?string $method;\n\n    /**\n     * @param \\DOMElement $node       A \\DOMElement instance\n     * @param string|null $currentUri The URI of the page where the link is embedded (or the base href)\n     * @param string|null $method     The method to use for the link (GET by default)\n     *\n     * @throws \\InvalidArgumentException if the node is not a link\n     */\n    public function __construct(\n        \\DOMElement $node,\n        protected ?string $currentUri = null,\n        ?string $method = 'GET',\n    ) {\n        $this->setNode($node);\n        $this->method = $method ? strtoupper($method) : null;\n\n        $elementUriIsRelative = !parse_url(trim($this->getRawUri()), \\PHP_URL_SCHEME);\n        $baseUriIsAbsolute = null !== $this->currentUri && \\in_array(strtolower(substr($this->currentUri, 0, 4)), ['http', 'file']);\n        if ($elementUriIsRelative && !$baseUriIsAbsolute) {\n            throw new \\InvalidArgumentException(\\sprintf('The URL of the element is relative, so you must define its base URI passing an absolute URL to the constructor of the \"%s\" class (\"%s\" was passed).', __CLASS__, $this->currentUri));\n        }\n    }\n\n    /**\n     * Gets the node associated with this link.\n     */\n    public function getNode(): \\DOMElement\n    {\n        return $this->node;\n    }\n\n    /**\n     * Gets the method associated with this link.\n     */\n    public function getMethod(): string\n    {\n        return $this->method ?? 'GET';\n    }\n\n    /**\n     * Gets the URI associated with this link.\n     */\n    public function getUri(): string\n    {\n        return UriResolver::resolve($this->getRawUri(), $this->currentUri);\n    }\n\n    /**\n     * Returns raw URI data.\n     */\n    abstract protected function getRawUri(): string;\n\n    /**\n     * Returns the canonicalized URI path (see RFC 3986, section 5.2.4).\n     *\n     * @param string $path URI path\n     */\n    protected function canonicalizePath(string $path): string\n    {\n        if ('' === $path || '/' === $path) {\n            return $path;\n        }\n\n        if (str_ends_with($path, '.')) {\n            $path .= '/';\n        }\n\n        $output = [];\n\n        foreach (explode('/', $path) as $segment) {\n            if ('..' === $segment) {\n                array_pop($output);\n            } elseif ('.' !== $segment) {\n                $output[] = $segment;\n            }\n        }\n\n        return implode('/', $output);\n    }\n\n    /**\n     * Sets current \\DOMElement instance.\n     *\n     * @param \\DOMElement $node A \\DOMElement instance\n     *\n     * @throws \\LogicException If given node is not an anchor\n     */\n    abstract protected function setNode(\\DOMElement $node): void;\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.052734375,
          "content": "CHANGELOG\n=========\n\n7.0\n---\n\n * Add argument `$normalizeWhitespace` to `Crawler::innerText()`\n * Add argument `$default` to `Crawler::attr()`\n\n6.4\n---\n\n * Add `CrawlerAnySelectorTextContains` test constraint\n * Add `CrawlerAnySelectorTextSame` test constraint\n * Add argument `$default` to `Crawler::attr()`\n\n6.3\n---\n\n * Add `$useHtml5Parser` argument to `Crawler`\n * Add `CrawlerSelectorCount` test constraint\n * Add argument `$normalizeWhitespace` to `Crawler::innerText()`\n * Make `Crawler::innerText()` return the first non-empty text\n\n6.0\n---\n\n * Remove `Crawler::parents()` method, use `ancestors()` instead\n\n5.4\n---\n\n * Add `Crawler::innerText` method.\n\n5.3\n---\n\n * The `parents()` method is deprecated. Use `ancestors()` instead.\n * Marked the `containsOption()`, `availableOptionValues()`, and `disableValidation()` methods of the\n   `ChoiceFormField` class as internal\n\n5.1.0\n-----\n\n * Added an internal cache layer on top of the CssSelectorConverter\n * Added `UriResolver` to resolve an URI according to a base URI\n\n5.0.0\n-----\n\n * Added argument `$selector` to `Crawler::children()`\n * Added argument `$default` to `Crawler::text()` and `html()`\n\n4.4.0\n-----\n\n * Added `Form::getName()` method.\n * Added `Crawler::matches()` method.\n * Added `Crawler::closest()` method.\n * Added `Crawler::outerHtml()` method.\n * Added an argument to the `Crawler::text()` method to opt-in normalizing whitespaces.\n\n4.3.0\n-----\n\n * Added PHPUnit constraints: `CrawlerSelectorAttributeValueSame`, `CrawlerSelectorExists`, `CrawlerSelectorTextContains`\n   and `CrawlerSelectorTextSame`\n * Added return of element name (`_name`) in `extract()` method.\n * Added ability to return a default value in `text()` and `html()` instead of throwing an exception when node is empty.\n * When available, the [html5-php library](https://github.com/Masterminds/html5-php) is used to\n   parse HTML added to a Crawler for better support of HTML5 tags.\n\n4.2.0\n-----\n\n * The `$currentUri` constructor argument of the `AbstractUriElement`, `Link` and\n   `Image` classes is now optional.\n * The `Crawler::children()` method will have a new `$selector` argument in version 5.0,\n   not defining it is deprecated.\n\n3.1.0\n-----\n\n * All the URI parsing logic have been abstracted in the `AbstractUriElement` class.\n   The `Link` class is now a child of `AbstractUriElement`.\n * Added an `Image` class to crawl images and parse their `src` attribute,\n   and `selectImage`, `image`, `images` methods in the `Crawler` (the image version of the equivalent `link` methods).\n\n2.5.0\n-----\n\n * [BC BREAK] The default value for checkbox and radio inputs without a value attribute have changed\n   from '1' to 'on' to match the HTML specification.\n * [BC BREAK] The typehints on the `Link`, `Form` and `FormField` classes have been changed from\n   `\\DOMNode` to `DOMElement`. Using any other type of `DOMNode` was triggering fatal errors in previous\n   versions. Code extending these classes will need to update the typehints when overwriting these methods.\n\n2.4.0\n-----\n\n * `Crawler::addXmlContent()` removes the default document namespace again if it's an only namespace.\n * added support for automatic discovery and explicit registration of document\n   namespaces for `Crawler::filterXPath()` and `Crawler::filter()`\n * improved content type guessing in `Crawler::addContent()`\n * [BC BREAK] `Crawler::addXmlContent()` no longer removes the default document\n   namespace\n\n2.3.0\n-----\n\n * added Crawler::html()\n * [BC BREAK] Crawler::each() and Crawler::reduce() now return Crawler instances instead of DomElement instances\n * added schema relative URL support to links\n * added support for HTML5 'form' attribute\n\n2.2.0\n-----\n\n * added a way to set raw path to the file in FileFormField - necessary for\n   simulating HTTP requests\n\n2.1.0\n-----\n\n * added support for the HTTP PATCH method\n * refactored the Form class internals to support multi-dimensional fields\n   (the public API is backward compatible)\n * added a way to get parsing errors for Crawler::addHtmlContent() and\n   Crawler::addXmlContent() via libxml functions\n * added support for submitting a form without a submit button\n"
        },
        {
          "name": "Crawler.php",
          "type": "blob",
          "size": 38.3037109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\nuse Masterminds\\HTML5;\nuse Symfony\\Component\\CssSelector\\CssSelectorConverter;\n\n/**\n * Crawler eases navigation of a list of \\DOMNode objects.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @implements \\IteratorAggregate<int, \\DOMNode>\n */\nclass Crawler implements \\Countable, \\IteratorAggregate\n{\n    /**\n     * The default namespace prefix to be used with XPath and CSS expressions.\n     */\n    private string $defaultNamespacePrefix = 'default';\n\n    /**\n     * A map of manually registered namespaces.\n     *\n     * @var array<string, string>\n     */\n    private array $namespaces = [];\n\n    /**\n     * A map of cached namespaces.\n     */\n    private \\ArrayObject $cachedNamespaces;\n\n    private ?string $baseHref;\n    private ?\\DOMDocument $document = null;\n\n    /**\n     * @var list<\\DOMNode>\n     */\n    private array $nodes = [];\n\n    /**\n     * Whether the Crawler contains HTML or XML content (used when converting CSS to XPath).\n     */\n    private bool $isHtml = true;\n\n    private ?HTML5 $html5Parser = null;\n\n    /**\n     * @param \\DOMNodeList|\\DOMNode|\\DOMNode[]|string|null $node A Node to use as the base for the crawling\n     */\n    public function __construct(\n        \\DOMNodeList|\\DOMNode|array|string|null $node = null,\n        protected ?string $uri = null,\n        ?string $baseHref = null,\n        bool $useHtml5Parser = true,\n    ) {\n        $this->baseHref = $baseHref ?: $uri;\n        $this->html5Parser = $useHtml5Parser ? new HTML5(['disable_html_ns' => true]) : null;\n        $this->cachedNamespaces = new \\ArrayObject();\n\n        $this->add($node);\n    }\n\n    /**\n     * Returns the current URI.\n     */\n    public function getUri(): ?string\n    {\n        return $this->uri;\n    }\n\n    /**\n     * Returns base href.\n     */\n    public function getBaseHref(): ?string\n    {\n        return $this->baseHref;\n    }\n\n    /**\n     * Removes all the nodes.\n     */\n    public function clear(): void\n    {\n        $this->nodes = [];\n        $this->document = null;\n        $this->cachedNamespaces = new \\ArrayObject();\n    }\n\n    /**\n     * Adds a node to the current list of nodes.\n     *\n     * This method uses the appropriate specialized add*() method based\n     * on the type of the argument.\n     *\n     * @param \\DOMNodeList|\\DOMNode|\\DOMNode[]|string|null $node A node\n     *\n     * @throws \\InvalidArgumentException when node is not the expected type\n     */\n    public function add(\\DOMNodeList|\\DOMNode|array|string|null $node): void\n    {\n        if ($node instanceof \\DOMNodeList) {\n            $this->addNodeList($node);\n        } elseif ($node instanceof \\DOMNode) {\n            $this->addNode($node);\n        } elseif (\\is_array($node)) {\n            $this->addNodes($node);\n        } elseif (\\is_string($node)) {\n            $this->addContent($node);\n        } elseif (null !== $node) {\n            throw new \\InvalidArgumentException(\\sprintf('Expecting a DOMNodeList or DOMNode instance, an array, a string, or null, but got \"%s\".', get_debug_type($node)));\n        }\n    }\n\n    /**\n     * Adds HTML/XML content.\n     *\n     * If the charset is not set via the content type, it is assumed to be UTF-8,\n     * or ISO-8859-1 as a fallback, which is the default charset defined by the\n     * HTTP 1.1 specification.\n     */\n    public function addContent(string $content, ?string $type = null): void\n    {\n        if (!$type) {\n            $type = str_starts_with($content, '<?xml') ? 'application/xml' : 'text/html';\n        }\n\n        // DOM only for HTML/XML content\n        if (!preg_match('/(x|ht)ml/i', $type, $xmlMatches)) {\n            return;\n        }\n\n        $charset = preg_match('//u', $content) ? 'UTF-8' : 'ISO-8859-1';\n\n        // http://www.w3.org/TR/encoding/#encodings\n        // http://www.w3.org/TR/REC-xml/#NT-EncName\n        $content = preg_replace_callback('/(charset *= *[\"\\']?)([a-zA-Z\\-0-9_:.]+)/i', function ($m) use (&$charset) {\n            if ('charset=' === $this->convertToHtmlEntities('charset=', $m[2])) {\n                $charset = $m[2];\n            }\n\n            return $m[1].$charset;\n        }, $content, 1);\n\n        if ('x' === $xmlMatches[1]) {\n            $this->addXmlContent($content, $charset);\n        } else {\n            $this->addHtmlContent($content, $charset);\n        }\n    }\n\n    /**\n     * Adds an HTML content to the list of nodes.\n     *\n     * The libxml errors are disabled when the content is parsed.\n     *\n     * If you want to get parsing errors, be sure to enable\n     * internal errors via libxml_use_internal_errors(true)\n     * and then, get the errors via libxml_get_errors(). Be\n     * sure to clear errors with libxml_clear_errors() afterward.\n     */\n    public function addHtmlContent(string $content, string $charset = 'UTF-8'): void\n    {\n        $dom = $this->parseHtmlString($content, $charset);\n        $this->addDocument($dom);\n\n        $base = $this->filterRelativeXPath('descendant-or-self::base')->extract(['href']);\n\n        $baseHref = current($base);\n        if (\\count($base) && $baseHref) {\n            if ($this->baseHref) {\n                $linkNode = $dom->createElement('a');\n                $linkNode->setAttribute('href', $baseHref);\n                $link = new Link($linkNode, $this->baseHref);\n                $this->baseHref = $link->getUri();\n            } else {\n                $this->baseHref = $baseHref;\n            }\n        }\n    }\n\n    /**\n     * Adds an XML content to the list of nodes.\n     *\n     * The libxml errors are disabled when the content is parsed.\n     *\n     * If you want to get parsing errors, be sure to enable\n     * internal errors via libxml_use_internal_errors(true)\n     * and then, get the errors via libxml_get_errors(). Be\n     * sure to clear errors with libxml_clear_errors() afterward.\n     *\n     * @param int $options Bitwise OR of the libxml option constants\n     *                     LIBXML_PARSEHUGE is dangerous, see\n     *                     http://symfony.com/blog/security-release-symfony-2-0-17-released\n     */\n    public function addXmlContent(string $content, string $charset = 'UTF-8', int $options = \\LIBXML_NONET): void\n    {\n        // remove the default namespace if it's the only namespace to make XPath expressions simpler\n        if (!str_contains($content, 'xmlns:')) {\n            $content = str_replace('xmlns', 'ns', $content);\n        }\n\n        $internalErrors = libxml_use_internal_errors(true);\n\n        $dom = new \\DOMDocument('1.0', $charset);\n        $dom->validateOnParse = true;\n\n        if ('' !== trim($content)) {\n            @$dom->loadXML($content, $options);\n        }\n\n        libxml_use_internal_errors($internalErrors);\n\n        $this->addDocument($dom);\n\n        $this->isHtml = false;\n    }\n\n    /**\n     * Adds a \\DOMDocument to the list of nodes.\n     *\n     * @param \\DOMDocument $dom A \\DOMDocument instance\n     */\n    public function addDocument(\\DOMDocument $dom): void\n    {\n        if ($dom->documentElement) {\n            $this->addNode($dom->documentElement);\n        }\n    }\n\n    /**\n     * Adds a \\DOMNodeList to the list of nodes.\n     *\n     * @param \\DOMNodeList $nodes A \\DOMNodeList instance\n     */\n    public function addNodeList(\\DOMNodeList $nodes): void\n    {\n        foreach ($nodes as $node) {\n            if ($node instanceof \\DOMNode) {\n                $this->addNode($node);\n            }\n        }\n    }\n\n    /**\n     * Adds an array of \\DOMNode instances to the list of nodes.\n     *\n     * @param \\DOMNode[] $nodes An array of \\DOMNode instances\n     */\n    public function addNodes(array $nodes): void\n    {\n        foreach ($nodes as $node) {\n            $this->add($node);\n        }\n    }\n\n    /**\n     * Adds a \\DOMNode instance to the list of nodes.\n     *\n     * @param \\DOMNode $node A \\DOMNode instance\n     */\n    public function addNode(\\DOMNode $node): void\n    {\n        if ($node instanceof \\DOMDocument) {\n            $node = $node->documentElement;\n        }\n\n        if (null !== $this->document && $this->document !== $node->ownerDocument) {\n            throw new \\InvalidArgumentException('Attaching DOM nodes from multiple documents in the same crawler is forbidden.');\n        }\n\n        $this->document ??= $node->ownerDocument;\n\n        // Don't add duplicate nodes in the Crawler\n        if (\\in_array($node, $this->nodes, true)) {\n            return;\n        }\n\n        $this->nodes[] = $node;\n    }\n\n    /**\n     * Returns a node given its position in the node list.\n     */\n    public function eq(int $position): static\n    {\n        if (isset($this->nodes[$position])) {\n            return $this->createSubCrawler($this->nodes[$position]);\n        }\n\n        return $this->createSubCrawler(null);\n    }\n\n    /**\n     * Calls an anonymous function on each node of the list.\n     *\n     * The anonymous function receives the position and the node wrapped\n     * in a Crawler instance as arguments.\n     *\n     * Example:\n     *\n     *     $crawler->filter('h1')->each(function ($node, $i) {\n     *         return $node->text();\n     *     });\n     *\n     * @param \\Closure $closure An anonymous function\n     *\n     * @return array An array of values returned by the anonymous function\n     */\n    public function each(\\Closure $closure): array\n    {\n        $data = [];\n        foreach ($this->nodes as $i => $node) {\n            $data[] = $closure($this->createSubCrawler($node), $i);\n        }\n\n        return $data;\n    }\n\n    /**\n     * Slices the list of nodes by $offset and $length.\n     */\n    public function slice(int $offset = 0, ?int $length = null): static\n    {\n        return $this->createSubCrawler(\\array_slice($this->nodes, $offset, $length));\n    }\n\n    /**\n     * Reduces the list of nodes by calling an anonymous function.\n     *\n     * To remove a node from the list, the anonymous function must return false.\n     *\n     * @param \\Closure $closure An anonymous function\n     */\n    public function reduce(\\Closure $closure): static\n    {\n        $nodes = [];\n        foreach ($this->nodes as $i => $node) {\n            if (false !== $closure($this->createSubCrawler($node), $i)) {\n                $nodes[] = $node;\n            }\n        }\n\n        return $this->createSubCrawler($nodes);\n    }\n\n    /**\n     * Returns the first node of the current selection.\n     */\n    public function first(): static\n    {\n        return $this->eq(0);\n    }\n\n    /**\n     * Returns the last node of the current selection.\n     */\n    public function last(): static\n    {\n        return $this->eq(\\count($this->nodes) - 1);\n    }\n\n    /**\n     * Returns the siblings nodes of the current selection.\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function siblings(): static\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        return $this->createSubCrawler($this->sibling($this->getNode(0)->parentNode->firstChild));\n    }\n\n    public function matches(string $selector): bool\n    {\n        if (!$this->nodes) {\n            return false;\n        }\n\n        $converter = $this->createCssSelectorConverter();\n        $xpath = $converter->toXPath($selector, 'self::');\n\n        return 0 !== $this->filterRelativeXPath($xpath)->count();\n    }\n\n    /**\n     * Return first parents (heading toward the document root) of the Element that matches the provided selector.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function closest(string $selector): ?self\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $domNode = $this->getNode(0);\n\n        while (\\XML_ELEMENT_NODE === $domNode->nodeType) {\n            $node = $this->createSubCrawler($domNode);\n            if ($node->matches($selector)) {\n                return $node;\n            }\n\n            $domNode = $node->getNode(0)->parentNode;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the next siblings nodes of the current selection.\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function nextAll(): static\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        return $this->createSubCrawler($this->sibling($this->getNode(0)));\n    }\n\n    /**\n     * Returns the previous sibling nodes of the current selection.\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function previousAll(): static\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        return $this->createSubCrawler($this->sibling($this->getNode(0), 'previousSibling'));\n    }\n\n    /**\n     * Returns the ancestors of the current selection.\n     *\n     * @throws \\InvalidArgumentException When the current node is empty\n     */\n    public function ancestors(): static\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n        $nodes = [];\n\n        while ($node = $node->parentNode) {\n            if (\\XML_ELEMENT_NODE === $node->nodeType) {\n                $nodes[] = $node;\n            }\n        }\n\n        return $this->createSubCrawler($nodes);\n    }\n\n    /**\n     * Returns the children nodes of the current selection.\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     * @throws \\RuntimeException         If the CssSelector Component is not available and $selector is provided\n     */\n    public function children(?string $selector = null): static\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        if (null !== $selector) {\n            $converter = $this->createCssSelectorConverter();\n            $xpath = $converter->toXPath($selector, 'child::');\n\n            return $this->filterRelativeXPath($xpath);\n        }\n\n        $node = $this->getNode(0)->firstChild;\n\n        return $this->createSubCrawler($node ? $this->sibling($node) : []);\n    }\n\n    /**\n     * Returns the attribute value of the first node of the list.\n     *\n     * @param string|null $default When not null: the value to return when the node or attribute is empty\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function attr(string $attribute, ?string $default = null): ?string\n    {\n        if (!$this->nodes) {\n            if (null !== $default) {\n                return $default;\n            }\n\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n\n        return $node->hasAttribute($attribute) ? $node->getAttribute($attribute) : $default;\n    }\n\n    /**\n     * Returns the node name of the first node of the list.\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function nodeName(): string\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        return $this->getNode(0)->nodeName;\n    }\n\n    /**\n     * Returns the text of the first node of the list.\n     *\n     * Pass true as the second argument to normalize whitespaces.\n     *\n     * @param string|null $default             When not null: the value to return when the current node is empty\n     * @param bool        $normalizeWhitespace Whether whitespaces should be trimmed and normalized to single spaces\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function text(?string $default = null, bool $normalizeWhitespace = true): string\n    {\n        if (!$this->nodes) {\n            if (null !== $default) {\n                return $default;\n            }\n\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $text = $this->getNode(0)->nodeValue;\n\n        if ($normalizeWhitespace) {\n            return $this->normalizeWhitespace($text);\n        }\n\n        return $text;\n    }\n\n    /**\n     * Returns only the inner text that is the direct descendent of the current node, excluding any child nodes.\n     *\n     * @param bool $normalizeWhitespace Whether whitespaces should be trimmed and normalized to single spaces\n     */\n    public function innerText(bool $normalizeWhitespace = true): string\n    {\n        foreach ($this->getNode(0)->childNodes as $childNode) {\n            if (\\XML_TEXT_NODE !== $childNode->nodeType && \\XML_CDATA_SECTION_NODE !== $childNode->nodeType) {\n                continue;\n            }\n            if (!$normalizeWhitespace) {\n                return $childNode->nodeValue;\n            }\n            if ('' !== trim($childNode->nodeValue)) {\n                return $this->normalizeWhitespace($childNode->nodeValue);\n            }\n        }\n\n        return '';\n    }\n\n    /**\n     * Returns the first node of the list as HTML.\n     *\n     * @param string|null $default When not null: the value to return when the current node is empty\n     *\n     * @throws \\InvalidArgumentException When current node is empty\n     */\n    public function html(?string $default = null): string\n    {\n        if (!$this->nodes) {\n            if (null !== $default) {\n                return $default;\n            }\n\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n        $owner = $node->ownerDocument;\n\n        if ($this->html5Parser && '<!DOCTYPE html>' === $owner->saveXML($owner->childNodes[0])) {\n            $owner = $this->html5Parser;\n        }\n\n        $html = '';\n        foreach ($node->childNodes as $child) {\n            $html .= $owner->saveHTML($child);\n        }\n\n        return $html;\n    }\n\n    public function outerHtml(): string\n    {\n        if (!\\count($this)) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n        $owner = $node->ownerDocument;\n\n        if ($this->html5Parser && '<!DOCTYPE html>' === $owner->saveXML($owner->childNodes[0])) {\n            $owner = $this->html5Parser;\n        }\n\n        return $owner->saveHTML($node);\n    }\n\n    /**\n     * Evaluates an XPath expression.\n     *\n     * Since an XPath expression might evaluate to either a simple type or a \\DOMNodeList,\n     * this method will return either an array of simple types or a new Crawler instance.\n     */\n    public function evaluate(string $xpath): array|self\n    {\n        if (null === $this->document) {\n            throw new \\LogicException('Cannot evaluate the expression on an uninitialized crawler.');\n        }\n\n        $data = [];\n        $domxpath = $this->createDOMXPath($this->document, $this->findNamespacePrefixes($xpath));\n\n        foreach ($this->nodes as $node) {\n            $data[] = $domxpath->evaluate($xpath, $node);\n        }\n\n        if (isset($data[0]) && $data[0] instanceof \\DOMNodeList) {\n            return $this->createSubCrawler($data);\n        }\n\n        return $data;\n    }\n\n    /**\n     * Extracts information from the list of nodes.\n     *\n     * You can extract attributes or/and the node value (_text).\n     *\n     * Example:\n     *\n     *     $crawler->filter('h1 a')->extract(['_text', 'href']);\n     */\n    public function extract(array $attributes): array\n    {\n        $count = \\count($attributes);\n\n        $data = [];\n        foreach ($this->nodes as $node) {\n            $elements = [];\n            foreach ($attributes as $attribute) {\n                if ('_text' === $attribute) {\n                    $elements[] = $node->nodeValue;\n                } elseif ('_name' === $attribute) {\n                    $elements[] = $node->nodeName;\n                } else {\n                    $elements[] = $node->getAttribute($attribute);\n                }\n            }\n\n            $data[] = 1 === $count ? $elements[0] : $elements;\n        }\n\n        return $data;\n    }\n\n    /**\n     * Filters the list of nodes with an XPath expression.\n     *\n     * The XPath expression is evaluated in the context of the crawler, which\n     * is considered as a fake parent of the elements inside it.\n     * This means that a child selector \"div\" or \"./div\" will match only\n     * the div elements of the current crawler, not their children.\n     */\n    public function filterXPath(string $xpath): static\n    {\n        $xpath = $this->relativize($xpath);\n\n        // If we dropped all expressions in the XPath while preparing it, there would be no match\n        if ('' === $xpath) {\n            return $this->createSubCrawler(null);\n        }\n\n        return $this->filterRelativeXPath($xpath);\n    }\n\n    /**\n     * Filters the list of nodes with a CSS selector.\n     *\n     * This method only works if you have installed the CssSelector Symfony Component.\n     *\n     * @throws \\LogicException if the CssSelector Component is not available\n     */\n    public function filter(string $selector): static\n    {\n        $converter = $this->createCssSelectorConverter();\n\n        // The CssSelector already prefixes the selector with descendant-or-self::\n        return $this->filterRelativeXPath($converter->toXPath($selector));\n    }\n\n    /**\n     * Selects links by name or alt value for clickable images.\n     */\n    public function selectLink(string $value): static\n    {\n        return $this->filterRelativeXPath(\n            \\sprintf('descendant-or-self::a[contains(concat(\\' \\', normalize-space(string(.)), \\' \\'), %1$s) or ./img[contains(concat(\\' \\', normalize-space(string(@alt)), \\' \\'), %1$s)]]', static::xpathLiteral(' '.$value.' '))\n        );\n    }\n\n    /**\n     * Selects images by alt value.\n     */\n    public function selectImage(string $value): static\n    {\n        $xpath = \\sprintf('descendant-or-self::img[contains(normalize-space(string(@alt)), %s)]', static::xpathLiteral($value));\n\n        return $this->filterRelativeXPath($xpath);\n    }\n\n    /**\n     * Selects a button by name or alt value for images.\n     */\n    public function selectButton(string $value): static\n    {\n        return $this->filterRelativeXPath(\n            \\sprintf('descendant-or-self::input[((contains(%1$s, \"submit\") or contains(%1$s, \"button\")) and contains(concat(\\' \\', normalize-space(string(@value)), \\' \\'), %2$s)) or (contains(%1$s, \"image\") and contains(concat(\\' \\', normalize-space(string(@alt)), \\' \\'), %2$s)) or @id=%3$s or @name=%3$s] | descendant-or-self::button[contains(concat(\\' \\', normalize-space(string(.)), \\' \\'), %2$s) or @id=%3$s or @name=%3$s]', 'translate(@type, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\")', static::xpathLiteral(' '.$value.' '), static::xpathLiteral($value))\n        );\n    }\n\n    /**\n     * Returns a Link object for the first node in the list.\n     *\n     * @throws \\InvalidArgumentException If the current node list is empty or the selected node is not instance of DOMElement\n     */\n    public function link(string $method = 'get'): Link\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n\n        if (!$node instanceof \\DOMElement) {\n            throw new \\InvalidArgumentException(\\sprintf('The selected node should be instance of DOMElement, got \"%s\".', get_debug_type($node)));\n        }\n\n        return new Link($node, $this->baseHref, $method);\n    }\n\n    /**\n     * Returns an array of Link objects for the nodes in the list.\n     *\n     * @return Link[]\n     *\n     * @throws \\InvalidArgumentException If the current node list contains non-DOMElement instances\n     */\n    public function links(): array\n    {\n        $links = [];\n        foreach ($this->nodes as $node) {\n            if (!$node instanceof \\DOMElement) {\n                throw new \\InvalidArgumentException(\\sprintf('The current node list should contain only DOMElement instances, \"%s\" found.', get_debug_type($node)));\n            }\n\n            $links[] = new Link($node, $this->baseHref, 'get');\n        }\n\n        return $links;\n    }\n\n    /**\n     * Returns an Image object for the first node in the list.\n     *\n     * @throws \\InvalidArgumentException If the current node list is empty\n     */\n    public function image(): Image\n    {\n        if (!\\count($this)) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n\n        if (!$node instanceof \\DOMElement) {\n            throw new \\InvalidArgumentException(\\sprintf('The selected node should be instance of DOMElement, got \"%s\".', get_debug_type($node)));\n        }\n\n        return new Image($node, $this->baseHref);\n    }\n\n    /**\n     * Returns an array of Image objects for the nodes in the list.\n     *\n     * @return Image[]\n     */\n    public function images(): array\n    {\n        $images = [];\n        foreach ($this as $node) {\n            if (!$node instanceof \\DOMElement) {\n                throw new \\InvalidArgumentException(\\sprintf('The current node list should contain only DOMElement instances, \"%s\" found.', get_debug_type($node)));\n            }\n\n            $images[] = new Image($node, $this->baseHref);\n        }\n\n        return $images;\n    }\n\n    /**\n     * Returns a Form object for the first node in the list.\n     *\n     * @throws \\InvalidArgumentException If the current node list is empty or the selected node is not instance of DOMElement\n     */\n    public function form(?array $values = null, ?string $method = null): Form\n    {\n        if (!$this->nodes) {\n            throw new \\InvalidArgumentException('The current node list is empty.');\n        }\n\n        $node = $this->getNode(0);\n\n        if (!$node instanceof \\DOMElement) {\n            throw new \\InvalidArgumentException(\\sprintf('The selected node should be instance of DOMElement, got \"%s\".', get_debug_type($node)));\n        }\n\n        $form = new Form($node, $this->uri, $method, $this->baseHref);\n\n        if (null !== $values) {\n            $form->setValues($values);\n        }\n\n        return $form;\n    }\n\n    /**\n     * Overloads a default namespace prefix to be used with XPath and CSS expressions.\n     */\n    public function setDefaultNamespacePrefix(string $prefix): void\n    {\n        $this->defaultNamespacePrefix = $prefix;\n    }\n\n    public function registerNamespace(string $prefix, string $namespace): void\n    {\n        $this->namespaces[$prefix] = $namespace;\n    }\n\n    /**\n     * Converts string for XPath expressions.\n     *\n     * Escaped characters are: quotes (\") and apostrophe (').\n     *\n     *  Examples:\n     *\n     *     echo Crawler::xpathLiteral('foo \" bar');\n     *     //prints 'foo \" bar'\n     *\n     *     echo Crawler::xpathLiteral(\"foo ' bar\");\n     *     //prints \"foo ' bar\"\n     *\n     *     echo Crawler::xpathLiteral('a\\'b\"c');\n     *     //prints concat('a', \"'\", 'b\"c')\n     */\n    public static function xpathLiteral(string $s): string\n    {\n        if (!str_contains($s, \"'\")) {\n            return \\sprintf(\"'%s'\", $s);\n        }\n\n        if (!str_contains($s, '\"')) {\n            return \\sprintf('\"%s\"', $s);\n        }\n\n        $string = $s;\n        $parts = [];\n        while (true) {\n            if (false !== $pos = strpos($string, \"'\")) {\n                $parts[] = \\sprintf(\"'%s'\", substr($string, 0, $pos));\n                $parts[] = \"\\\"'\\\"\";\n                $string = substr($string, $pos + 1);\n            } else {\n                $parts[] = \"'$string'\";\n                break;\n            }\n        }\n\n        return \\sprintf('concat(%s)', implode(', ', $parts));\n    }\n\n    /**\n     * Filters the list of nodes with an XPath expression.\n     *\n     * The XPath expression should already be processed to apply it in the context of each node.\n     */\n    private function filterRelativeXPath(string $xpath): static\n    {\n        $crawler = $this->createSubCrawler(null);\n        if (null === $this->document) {\n            return $crawler;\n        }\n\n        $domxpath = $this->createDOMXPath($this->document, $this->findNamespacePrefixes($xpath));\n\n        foreach ($this->nodes as $node) {\n            $crawler->add($domxpath->query($xpath, $node));\n        }\n\n        return $crawler;\n    }\n\n    /**\n     * Make the XPath relative to the current context.\n     *\n     * The returned XPath will match elements matching the XPath inside the current crawler\n     * when running in the context of a node of the crawler.\n     */\n    private function relativize(string $xpath): string\n    {\n        $expressions = [];\n\n        // An expression which will never match to replace expressions which cannot match in the crawler\n        // We cannot drop\n        $nonMatchingExpression = 'a[name() = \"b\"]';\n\n        $xpathLen = \\strlen($xpath);\n        $openedBrackets = 0;\n        $startPosition = strspn($xpath, \" \\t\\n\\r\\0\\x0B\");\n\n        for ($i = $startPosition; $i <= $xpathLen; ++$i) {\n            $i += strcspn($xpath, '\"\\'[]|', $i);\n\n            if ($i < $xpathLen) {\n                switch ($xpath[$i]) {\n                    case '\"':\n                    case \"'\":\n                        if (false === $i = strpos($xpath, $xpath[$i], $i + 1)) {\n                            return $xpath; // The XPath expression is invalid\n                        }\n                        continue 2;\n                    case '[':\n                        ++$openedBrackets;\n                        continue 2;\n                    case ']':\n                        --$openedBrackets;\n                        continue 2;\n                }\n            }\n            if ($openedBrackets) {\n                continue;\n            }\n\n            if ($startPosition < $xpathLen && '(' === $xpath[$startPosition]) {\n                // If the union is inside some braces, we need to preserve the opening braces and apply\n                // the change only inside it.\n                $j = 1 + strspn($xpath, \"( \\t\\n\\r\\0\\x0B\", $startPosition + 1);\n                $parenthesis = substr($xpath, $startPosition, $j);\n                $startPosition += $j;\n            } else {\n                $parenthesis = '';\n            }\n            $expression = rtrim(substr($xpath, $startPosition, $i - $startPosition));\n\n            if (str_starts_with($expression, 'self::*/')) {\n                $expression = './'.substr($expression, 8);\n            }\n\n            // add prefix before absolute element selector\n            if ('' === $expression) {\n                $expression = $nonMatchingExpression;\n            } elseif (str_starts_with($expression, '//')) {\n                $expression = 'descendant-or-self::'.substr($expression, 2);\n            } elseif (str_starts_with($expression, './/')) {\n                $expression = 'descendant-or-self::'.substr($expression, 3);\n            } elseif (str_starts_with($expression, './')) {\n                $expression = 'self::'.substr($expression, 2);\n            } elseif (str_starts_with($expression, 'child::')) {\n                $expression = 'self::'.substr($expression, 7);\n            } elseif ('/' === $expression[0] || '.' === $expression[0] || str_starts_with($expression, 'self::')) {\n                $expression = $nonMatchingExpression;\n            } elseif (str_starts_with($expression, 'descendant::')) {\n                $expression = 'descendant-or-self::'.substr($expression, 12);\n            } elseif (preg_match('/^(ancestor|ancestor-or-self|attribute|following|following-sibling|namespace|parent|preceding|preceding-sibling)::/', $expression)) {\n                // the fake root has no parent, preceding or following nodes and also no attributes (even no namespace attributes)\n                $expression = $nonMatchingExpression;\n            } elseif (!str_starts_with($expression, 'descendant-or-self::')) {\n                $expression = 'self::'.$expression;\n            }\n            $expressions[] = $parenthesis.$expression;\n\n            if ($i === $xpathLen) {\n                return implode(' | ', $expressions);\n            }\n\n            $i += strspn($xpath, \" \\t\\n\\r\\0\\x0B\", $i + 1);\n            $startPosition = $i + 1;\n        }\n\n        return $xpath; // The XPath expression is invalid\n    }\n\n    public function getNode(int $position): ?\\DOMNode\n    {\n        return $this->nodes[$position] ?? null;\n    }\n\n    public function count(): int\n    {\n        return \\count($this->nodes);\n    }\n\n    /**\n     * @return \\ArrayIterator<int, \\DOMNode>\n     */\n    public function getIterator(): \\ArrayIterator\n    {\n        return new \\ArrayIterator($this->nodes);\n    }\n\n    protected function sibling(\\DOMNode $node, string $siblingDir = 'nextSibling'): array\n    {\n        $nodes = [];\n\n        $currentNode = $this->getNode(0);\n        do {\n            if ($node !== $currentNode && \\XML_ELEMENT_NODE === $node->nodeType) {\n                $nodes[] = $node;\n            }\n        } while ($node = $node->$siblingDir);\n\n        return $nodes;\n    }\n\n    private function parseHtml5(string $htmlContent, string $charset = 'UTF-8'): \\DOMDocument\n    {\n        if (!$this->supportsEncoding($charset)) {\n            $htmlContent = $this->convertToHtmlEntities($htmlContent, $charset);\n            $charset = 'UTF-8';\n        }\n\n        return $this->html5Parser->parse($htmlContent, ['encoding' => $charset]);\n    }\n\n    private function supportsEncoding(string $encoding): bool\n    {\n        try {\n            return '' === @mb_convert_encoding('', $encoding, 'UTF-8');\n        } catch (\\Throwable $e) {\n            return false;\n        }\n    }\n\n    private function parseXhtml(string $htmlContent, string $charset = 'UTF-8'): \\DOMDocument\n    {\n        if ('UTF-8' === $charset && preg_match('//u', $htmlContent)) {\n            $htmlContent = '<?xml encoding=\"UTF-8\">'.$htmlContent;\n        } else {\n            $htmlContent = $this->convertToHtmlEntities($htmlContent, $charset);\n        }\n\n        $internalErrors = libxml_use_internal_errors(true);\n\n        $dom = new \\DOMDocument('1.0', $charset);\n        $dom->validateOnParse = true;\n\n        if ('' !== trim($htmlContent)) {\n            @$dom->loadHTML($htmlContent);\n        }\n\n        libxml_use_internal_errors($internalErrors);\n\n        return $dom;\n    }\n\n    /**\n     * Converts charset to HTML-entities to ensure valid parsing.\n     */\n    private function convertToHtmlEntities(string $htmlContent, string $charset = 'UTF-8'): string\n    {\n        set_error_handler(static fn () => throw new \\Exception());\n\n        try {\n            return mb_encode_numericentity($htmlContent, [0x80, 0x10FFFF, 0, 0x1FFFFF], $charset);\n        } catch (\\Exception|\\ValueError) {\n            try {\n                $htmlContent = iconv($charset, 'UTF-8', $htmlContent);\n                $htmlContent = mb_encode_numericentity($htmlContent, [0x80, 0x10FFFF, 0, 0x1FFFFF], 'UTF-8');\n            } catch (\\Exception|\\ValueError) {\n            }\n\n            return $htmlContent;\n        } finally {\n            restore_error_handler();\n        }\n    }\n\n    /**\n     * @throws \\InvalidArgumentException\n     */\n    private function createDOMXPath(\\DOMDocument $document, array $prefixes = []): \\DOMXPath\n    {\n        $domxpath = new \\DOMXPath($document);\n\n        foreach ($prefixes as $prefix) {\n            $namespace = $this->discoverNamespace($domxpath, $prefix);\n            if (null !== $namespace) {\n                $domxpath->registerNamespace($prefix, $namespace);\n            }\n        }\n\n        return $domxpath;\n    }\n\n    /**\n     * @throws \\InvalidArgumentException\n     */\n    private function discoverNamespace(\\DOMXPath $domxpath, string $prefix): ?string\n    {\n        if (\\array_key_exists($prefix, $this->namespaces)) {\n            return $this->namespaces[$prefix];\n        }\n\n        if ($this->cachedNamespaces->offsetExists($prefix)) {\n            return $this->cachedNamespaces[$prefix];\n        }\n\n        // ask for one namespace, otherwise we'd get a collection with an item for each node\n        $namespaces = $domxpath->query(\\sprintf('(//namespace::*[name()=\"%s\"])[last()]', $this->defaultNamespacePrefix === $prefix ? '' : $prefix));\n\n        return $this->cachedNamespaces[$prefix] = ($node = $namespaces->item(0)) ? $node->nodeValue : null;\n    }\n\n    private function findNamespacePrefixes(string $xpath): array\n    {\n        if (preg_match_all('/(?P<prefix>[a-z_][a-z_0-9\\-\\.]*+):[^\"\\/:]/i', $xpath, $matches)) {\n            return array_unique($matches['prefix']);\n        }\n\n        return [];\n    }\n\n    /**\n     * Creates a crawler for some subnodes.\n     *\n     * @param \\DOMNodeList|\\DOMNode|\\DOMNode[]|string|null $nodes\n     */\n    private function createSubCrawler(\\DOMNodeList|\\DOMNode|array|string|null $nodes): static\n    {\n        $crawler = new static($nodes, $this->uri, $this->baseHref);\n        $crawler->isHtml = $this->isHtml;\n        $crawler->document = $this->document;\n        $crawler->namespaces = $this->namespaces;\n        $crawler->cachedNamespaces = $this->cachedNamespaces;\n        $crawler->html5Parser = $this->html5Parser;\n\n        return $crawler;\n    }\n\n    /**\n     * @throws \\LogicException If the CssSelector Component is not available\n     */\n    private function createCssSelectorConverter(): CssSelectorConverter\n    {\n        if (!class_exists(CssSelectorConverter::class)) {\n            throw new \\LogicException('To filter with a CSS selector, install the CssSelector component (\"composer require symfony/css-selector\"). Or use filterXpath instead.');\n        }\n\n        return new CssSelectorConverter($this->isHtml);\n    }\n\n    /**\n     * Parse string into DOMDocument object using HTML5 parser if the content is HTML5 and the library is available.\n     * Use libxml parser otherwise.\n     */\n    private function parseHtmlString(string $content, string $charset): \\DOMDocument\n    {\n        if ($this->canParseHtml5String($content)) {\n            return $this->parseHtml5($content, $charset);\n        }\n\n        return $this->parseXhtml($content, $charset);\n    }\n\n    private function canParseHtml5String(string $content): bool\n    {\n        if (!$this->html5Parser) {\n            return false;\n        }\n\n        if (false === ($pos = stripos($content, '<!doctype html>'))) {\n            return false;\n        }\n\n        $header = substr($content, 0, $pos);\n\n        return '' === $header || $this->isValidHtml5Heading($header);\n    }\n\n    private function isValidHtml5Heading(string $heading): bool\n    {\n        return 1 === preg_match('/^\\x{FEFF}?\\s*(<!--[^>]*?-->\\s*)*$/u', $heading);\n    }\n\n    private function normalizeWhitespace(string $string): string\n    {\n        return trim(preg_replace(\"/(?:[ \\n\\r\\t\\x0C]{2,}+|[\\n\\r\\t\\x0C])/\", ' ', $string), \" \\n\\r\\t\\x0C\");\n    }\n}\n"
        },
        {
          "name": "Field",
          "type": "tree",
          "content": null
        },
        {
          "name": "Form.php",
          "type": "blob",
          "size": 14.8662109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\nuse Symfony\\Component\\DomCrawler\\Field\\ChoiceFormField;\nuse Symfony\\Component\\DomCrawler\\Field\\FormField;\n\n/**\n * Form represents an HTML form.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Form extends Link implements \\ArrayAccess\n{\n    private \\DOMElement $button;\n    private FormFieldRegistry $fields;\n\n    /**\n     * @param \\DOMElement $node       A \\DOMElement instance\n     * @param string|null $currentUri The URI of the page where the form is embedded\n     * @param string|null $method     The method to use for the link (if null, it defaults to the method defined by the form)\n     * @param string|null $baseHref   The URI of the <base> used for relative links, but not for empty action\n     *\n     * @throws \\LogicException if the node is not a button inside a form tag\n     */\n    public function __construct(\n        \\DOMElement $node,\n        ?string $currentUri = null,\n        ?string $method = null,\n        private ?string $baseHref = null,\n    ) {\n        parent::__construct($node, $currentUri, $method);\n\n        $this->initialize();\n    }\n\n    /**\n     * Gets the form node associated with this form.\n     */\n    public function getFormNode(): \\DOMElement\n    {\n        return $this->node;\n    }\n\n    /**\n     * Sets the value of the fields.\n     *\n     * @param array $values An array of field values\n     *\n     * @return $this\n     */\n    public function setValues(array $values): static\n    {\n        foreach ($values as $name => $value) {\n            $this->fields->set($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Gets the field values.\n     *\n     * The returned array does not include file fields (@see getFiles).\n     */\n    public function getValues(): array\n    {\n        $values = [];\n        foreach ($this->fields->all() as $name => $field) {\n            if ($field->isDisabled()) {\n                continue;\n            }\n\n            if (!$field instanceof Field\\FileFormField && $field->hasValue()) {\n                $values[$name] = $field->getValue();\n            }\n        }\n\n        return $values;\n    }\n\n    /**\n     * Gets the file field values.\n     */\n    public function getFiles(): array\n    {\n        if (!\\in_array($this->getMethod(), ['POST', 'PUT', 'DELETE', 'PATCH'])) {\n            return [];\n        }\n\n        $files = [];\n\n        foreach ($this->fields->all() as $name => $field) {\n            if ($field->isDisabled()) {\n                continue;\n            }\n\n            if ($field instanceof Field\\FileFormField) {\n                $files[$name] = $field->getValue();\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Gets the field values as PHP.\n     *\n     * This method converts fields with the array notation\n     * (like foo[bar] to arrays) like PHP does.\n     */\n    public function getPhpValues(): array\n    {\n        $values = [];\n        foreach ($this->getValues() as $name => $value) {\n            $qs = http_build_query([$name => $value], '', '&');\n            if ($qs) {\n                parse_str($qs, $expandedValue);\n                $varName = substr($name, 0, \\strlen(key($expandedValue)));\n                $values[] = [$varName => current($expandedValue)];\n            }\n        }\n\n        return array_replace_recursive([], ...$values);\n    }\n\n    /**\n     * Gets the file field values as PHP.\n     *\n     * This method converts fields with the array notation\n     * (like foo[bar] to arrays) like PHP does.\n     * The returned array is consistent with the array for field values\n     * (@see getPhpValues), rather than uploaded files found in $_FILES.\n     * For a compound file field foo[bar] it will create foo[bar][name],\n     * instead of foo[name][bar] which would be found in $_FILES.\n     */\n    public function getPhpFiles(): array\n    {\n        $values = [];\n        foreach ($this->getFiles() as $name => $value) {\n            $qs = http_build_query([$name => $value], '', '&');\n            if ($qs) {\n                parse_str($qs, $expandedValue);\n                $varName = substr($name, 0, \\strlen(key($expandedValue)));\n\n                array_walk_recursive(\n                    $expandedValue,\n                    function (&$value, $key) {\n                        if (ctype_digit($value) && ('size' === $key || 'error' === $key)) {\n                            $value = (int) $value;\n                        }\n                    }\n                );\n\n                reset($expandedValue);\n\n                $values[] = [$varName => current($expandedValue)];\n            }\n        }\n\n        return array_replace_recursive([], ...$values);\n    }\n\n    /**\n     * Gets the URI of the form.\n     *\n     * The returned URI is not the same as the form \"action\" attribute.\n     * This method merges the value if the method is GET to mimics\n     * browser behavior.\n     */\n    public function getUri(): string\n    {\n        $uri = parent::getUri();\n\n        if (!\\in_array($this->getMethod(), ['POST', 'PUT', 'DELETE', 'PATCH'])) {\n            $currentParameters = [];\n            if ($query = parse_url($uri, \\PHP_URL_QUERY)) {\n                parse_str($query, $currentParameters);\n            }\n\n            $queryString = http_build_query(array_merge($currentParameters, $this->getValues()), '', '&');\n\n            $pos = strpos($uri, '?');\n            $base = false === $pos ? $uri : substr($uri, 0, $pos);\n            $uri = rtrim($base.'?'.$queryString, '?');\n        }\n\n        return $uri;\n    }\n\n    protected function getRawUri(): string\n    {\n        // If the form was created from a button rather than the form node, check for HTML5 action overrides\n        if ($this->button !== $this->node && $this->button->getAttribute('formaction')) {\n            return $this->button->getAttribute('formaction');\n        }\n\n        return $this->node->getAttribute('action');\n    }\n\n    /**\n     * Gets the form method.\n     *\n     * If no method is defined in the form, GET is returned.\n     */\n    public function getMethod(): string\n    {\n        if (null !== $this->method) {\n            return $this->method;\n        }\n\n        // If the form was created from a button rather than the form node, check for HTML5 method override\n        if ($this->button !== $this->node && $this->button->getAttribute('formmethod')) {\n            return strtoupper($this->button->getAttribute('formmethod'));\n        }\n\n        return $this->node->getAttribute('method') ? strtoupper($this->node->getAttribute('method')) : 'GET';\n    }\n\n    /**\n     * Gets the form name.\n     *\n     * If no name is defined on the form, an empty string is returned.\n     */\n    public function getName(): string\n    {\n        return $this->node->getAttribute('name');\n    }\n\n    /**\n     * Returns true if the named field exists.\n     */\n    public function has(string $name): bool\n    {\n        return $this->fields->has($name);\n    }\n\n    /**\n     * Removes a field from the form.\n     */\n    public function remove(string $name): void\n    {\n        $this->fields->remove($name);\n    }\n\n    /**\n     * Gets a named field.\n     *\n     * @return FormField|FormField[]|FormField[][]\n     *\n     * @throws \\InvalidArgumentException When field is not present in this form\n     */\n    public function get(string $name): FormField|array\n    {\n        return $this->fields->get($name);\n    }\n\n    /**\n     * Sets a named field.\n     */\n    public function set(FormField $field): void\n    {\n        $this->fields->add($field);\n    }\n\n    /**\n     * Gets all fields.\n     *\n     * @return FormField[]\n     */\n    public function all(): array\n    {\n        return $this->fields->all();\n    }\n\n    /**\n     * Returns true if the named field exists.\n     *\n     * @param string $name The field name\n     */\n    public function offsetExists(mixed $name): bool\n    {\n        return $this->has($name);\n    }\n\n    /**\n     * Gets the value of a field.\n     *\n     * @param string $name The field name\n     *\n     * @return FormField|FormField[]|FormField[][]\n     *\n     * @throws \\InvalidArgumentException if the field does not exist\n     */\n    public function offsetGet(mixed $name): FormField|array\n    {\n        return $this->fields->get($name);\n    }\n\n    /**\n     * Sets the value of a field.\n     *\n     * @param string       $name  The field name\n     * @param string|array $value The value of the field\n     *\n     * @throws \\InvalidArgumentException if the field does not exist\n     */\n    public function offsetSet(mixed $name, mixed $value): void\n    {\n        $this->fields->set($name, $value);\n    }\n\n    /**\n     * Removes a field from the form.\n     *\n     * @param string $name The field name\n     */\n    public function offsetUnset(mixed $name): void\n    {\n        $this->fields->remove($name);\n    }\n\n    /**\n     * Disables validation.\n     *\n     * @return $this\n     */\n    public function disableValidation(): static\n    {\n        foreach ($this->fields->all() as $field) {\n            if ($field instanceof ChoiceFormField) {\n                $field->disableValidation();\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the node for the form.\n     *\n     * Expects a 'submit' button \\DOMElement and finds the corresponding form element, or the form element itself.\n     *\n     * @throws \\LogicException If given node is not a button or input or does not have a form ancestor\n     */\n    protected function setNode(\\DOMElement $node): void\n    {\n        $this->button = $node;\n        if ('button' === $node->nodeName || ('input' === $node->nodeName && \\in_array(strtolower($node->getAttribute('type')), ['submit', 'button', 'image']))) {\n            if ($node->hasAttribute('form')) {\n                // if the node has the HTML5-compliant 'form' attribute, use it\n                $formId = $node->getAttribute('form');\n                $form = $node->ownerDocument->getElementById($formId);\n                if (null === $form) {\n                    throw new \\LogicException(\\sprintf('The selected node has an invalid form attribute (%s).', $formId));\n                }\n                $this->node = $form;\n\n                return;\n            }\n            // we loop until we find a form ancestor\n            do {\n                if (null === $node = $node->parentNode) {\n                    throw new \\LogicException('The selected node does not have a form ancestor.');\n                }\n            } while ('form' !== $node->nodeName);\n        } elseif ('form' !== $node->nodeName) {\n            throw new \\LogicException(\\sprintf('Unable to submit on a \"%s\" tag.', $node->nodeName));\n        }\n\n        $this->node = $node;\n    }\n\n    /**\n     * Adds form elements related to this form.\n     *\n     * Creates an internal copy of the submitted 'button' element and\n     * the form node or the entire document depending on whether we need\n     * to find non-descendant elements through HTML5 'form' attribute.\n     */\n    private function initialize(): void\n    {\n        $this->fields = new FormFieldRegistry();\n\n        $xpath = new \\DOMXPath($this->node->ownerDocument);\n\n        // add submitted button if it has a valid name\n        if ('form' !== $this->button->nodeName && $this->button->hasAttribute('name') && $this->button->getAttribute('name')) {\n            if ('input' == $this->button->nodeName && 'image' == strtolower($this->button->getAttribute('type'))) {\n                $name = $this->button->getAttribute('name');\n                $this->button->setAttribute('value', '0');\n\n                // temporarily change the name of the input node for the x coordinate\n                $this->button->setAttribute('name', $name.'.x');\n                $this->set(new Field\\InputFormField($this->button));\n\n                // temporarily change the name of the input node for the y coordinate\n                $this->button->setAttribute('name', $name.'.y');\n                $this->set(new Field\\InputFormField($this->button));\n\n                // restore the original name of the input node\n                $this->button->setAttribute('name', $name);\n            } else {\n                $this->set(new Field\\InputFormField($this->button));\n            }\n        }\n\n        // find form elements corresponding to the current form\n        if ($this->node->hasAttribute('id')) {\n            // corresponding elements are either descendants or have a matching HTML5 form attribute\n            $formId = Crawler::xpathLiteral($this->node->getAttribute('id'));\n\n            $fieldNodes = $xpath->query(\\sprintf('( descendant::input[@form=%s] | descendant::button[@form=%1$s] | descendant::textarea[@form=%1$s] | descendant::select[@form=%1$s] | //form[@id=%1$s]//input[not(@form)] | //form[@id=%1$s]//button[not(@form)] | //form[@id=%1$s]//textarea[not(@form)] | //form[@id=%1$s]//select[not(@form)] )[( not(ancestor::template) or ancestor::turbo-stream )]', $formId));\n        } else {\n            // do the xpath query with $this->node as the context node, to only find descendant elements\n            // however, descendant elements with form attribute are not part of this form\n            $fieldNodes = $xpath->query('( descendant::input[not(@form)] | descendant::button[not(@form)] | descendant::textarea[not(@form)] | descendant::select[not(@form)] )[( not(ancestor::template) or ancestor::turbo-stream )]', $this->node);\n        }\n\n        foreach ($fieldNodes as $node) {\n            $this->addField($node);\n        }\n\n        if ($this->baseHref && '' !== $this->node->getAttribute('action')) {\n            $this->currentUri = $this->baseHref;\n        }\n    }\n\n    private function addField(\\DOMElement $node): void\n    {\n        if (!$node->hasAttribute('name') || !$node->getAttribute('name')) {\n            return;\n        }\n\n        $nodeName = $node->nodeName;\n        if ('select' == $nodeName || 'input' == $nodeName && 'checkbox' == strtolower($node->getAttribute('type'))) {\n            $this->set(new ChoiceFormField($node));\n        } elseif ('input' == $nodeName && 'radio' == strtolower($node->getAttribute('type'))) {\n            // there may be other fields with the same name that are no choice\n            // fields already registered (see https://github.com/symfony/symfony/issues/11689)\n            if ($this->has($node->getAttribute('name')) && $this->get($node->getAttribute('name')) instanceof ChoiceFormField) {\n                $this->get($node->getAttribute('name'))->addChoice($node);\n            } else {\n                $this->set(new ChoiceFormField($node));\n            }\n        } elseif ('input' == $nodeName && 'file' == strtolower($node->getAttribute('type'))) {\n            $this->set(new Field\\FileFormField($node));\n        } elseif ('input' == $nodeName && !\\in_array(strtolower($node->getAttribute('type')), ['submit', 'button', 'image'])) {\n            $this->set(new Field\\InputFormField($node));\n        } elseif ('textarea' == $nodeName) {\n            $this->set(new Field\\TextareaFormField($node));\n        }\n    }\n}\n"
        },
        {
          "name": "FormFieldRegistry.php",
          "type": "blob",
          "size": 4.8583984375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\nuse Symfony\\Component\\DomCrawler\\Field\\FormField;\n\n/**\n * This is an internal class that must not be used directly.\n *\n * @internal\n */\nclass FormFieldRegistry\n{\n    private array $fields = [];\n    private string $base = '';\n\n    /**\n     * Adds a field to the registry.\n     */\n    public function add(FormField $field): void\n    {\n        $segments = $this->getSegments($field->getName());\n\n        $target = &$this->fields;\n        while ($segments) {\n            if (!\\is_array($target)) {\n                $target = [];\n            }\n            $path = array_shift($segments);\n            if ('' === $path) {\n                $target = &$target[];\n            } else {\n                $target = &$target[$path];\n            }\n        }\n        $target = $field;\n    }\n\n    /**\n     * Removes a field based on the fully qualified name and its children from the registry.\n     */\n    public function remove(string $name): void\n    {\n        $segments = $this->getSegments($name);\n        $target = &$this->fields;\n        while (\\count($segments) > 1) {\n            $path = array_shift($segments);\n            if (!\\is_array($target) || !\\array_key_exists($path, $target)) {\n                return;\n            }\n            $target = &$target[$path];\n        }\n        unset($target[array_shift($segments)]);\n    }\n\n    /**\n     * Returns the value of the field based on the fully qualified name and its children.\n     *\n     * @return FormField|FormField[]|FormField[][]\n     *\n     * @throws \\InvalidArgumentException if the field does not exist\n     */\n    public function &get(string $name): FormField|array\n    {\n        $segments = $this->getSegments($name);\n        $target = &$this->fields;\n        while ($segments) {\n            $path = array_shift($segments);\n            if (!\\is_array($target) || !\\array_key_exists($path, $target)) {\n                throw new \\InvalidArgumentException(\\sprintf('Unreachable field \"%s\".', $path));\n            }\n            $target = &$target[$path];\n        }\n\n        return $target;\n    }\n\n    /**\n     * Tests whether the form has the given field based on the fully qualified name.\n     */\n    public function has(string $name): bool\n    {\n        try {\n            $this->get($name);\n\n            return true;\n        } catch (\\InvalidArgumentException) {\n            return false;\n        }\n    }\n\n    /**\n     * Set the value of a field based on the fully qualified name and its children.\n     *\n     * @throws \\InvalidArgumentException if the field does not exist\n     */\n    public function set(string $name, mixed $value): void\n    {\n        $target = &$this->get($name);\n        if ((!\\is_array($value) && $target instanceof FormField) || $target instanceof Field\\ChoiceFormField) {\n            $target->setValue($value);\n        } elseif (\\is_array($value)) {\n            $registry = new static();\n            $registry->base = $name;\n            $registry->fields = $value;\n            foreach ($registry->all() as $k => $v) {\n                $this->set($k, $v);\n            }\n        } else {\n            throw new \\InvalidArgumentException(\\sprintf('Cannot set value on a compound field \"%s\".', $name));\n        }\n    }\n\n    /**\n     * Returns the list of field with their value.\n     *\n     * @return FormField[] The list of fields as [string] Fully qualified name => (mixed) value)\n     */\n    public function all(): array\n    {\n        return $this->walk($this->fields, $this->base);\n    }\n\n    /**\n     * Transforms a PHP array in a list of fully qualified name / value.\n     */\n    private function walk(array $array, ?string $base = '', array &$output = []): array\n    {\n        foreach ($array as $k => $v) {\n            $path = $base ? \\sprintf('%s[%s]', $base, $k) : $k;\n            if (\\is_array($v)) {\n                $this->walk($v, $path, $output);\n            } else {\n                $output[$path] = $v;\n            }\n        }\n\n        return $output;\n    }\n\n    /**\n     * Splits a field name into segments as a web browser would do.\n     *\n     *     getSegments('base[foo][3][]') = ['base', 'foo, '3', ''];\n     *\n     * @return string[]\n     */\n    private function getSegments(string $name): array\n    {\n        if (preg_match('/^(?P<base>[^[]+)(?P<extra>(\\[.*)|$)/', $name, $m)) {\n            $segments = [$m['base']];\n            while (!empty($m['extra'])) {\n                $extra = $m['extra'];\n                if (preg_match('/^\\[(?P<segment>.*?)\\](?P<extra>.*)$/', $extra, $m)) {\n                    $segments[] = $m['segment'];\n                } else {\n                    $segments[] = $extra;\n                }\n            }\n\n            return $segments;\n        }\n\n        return [$name];\n    }\n}\n"
        },
        {
          "name": "Image.php",
          "type": "blob",
          "size": 0.865234375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\n/**\n * Image represents an HTML image (an HTML img tag).\n */\nclass Image extends AbstractUriElement\n{\n    public function __construct(\\DOMElement $node, ?string $currentUri = null)\n    {\n        parent::__construct($node, $currentUri, 'GET');\n    }\n\n    protected function getRawUri(): string\n    {\n        return $this->node->getAttribute('src');\n    }\n\n    protected function setNode(\\DOMElement $node): void\n    {\n        if ('img' !== $node->nodeName) {\n            throw new \\LogicException(\\sprintf('Unable to visualize a \"%s\" tag.', $node->nodeName));\n        }\n\n        $this->node = $node;\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Link.php",
          "type": "blob",
          "size": 0.841796875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\n/**\n * Link represents an HTML link (an HTML a, area or link tag).\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Link extends AbstractUriElement\n{\n    protected function getRawUri(): string\n    {\n        return $this->node->getAttribute('href');\n    }\n\n    protected function setNode(\\DOMElement $node): void\n    {\n        if ('a' !== $node->nodeName && 'area' !== $node->nodeName && 'link' !== $node->nodeName) {\n            throw new \\LogicException(\\sprintf('Unable to navigate from a \"%s\" tag.', $node->nodeName));\n        }\n\n        $this->node = $node;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.486328125,
          "content": "DomCrawler Component\n====================\n\nThe DomCrawler component eases DOM navigation for HTML and XML documents.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/dom_crawler.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "UriResolver.php",
          "type": "blob",
          "size": 3.5546875,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\DomCrawler;\n\n/**\n * The UriResolver class takes an URI (relative, absolute, fragment, etc.)\n * and turns it into an absolute URI against another given base URI.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n * @author Grgoire Pineau <lyrixx@lyrixx.info>\n */\nclass UriResolver\n{\n    /**\n     * Resolves a URI according to a base URI.\n     *\n     * For example if $uri=/foo/bar and $baseUri=https://symfony.com it will\n     * return https://symfony.com/foo/bar\n     *\n     * If the $uri is not absolute you must pass an absolute $baseUri\n     */\n    public static function resolve(string $uri, ?string $baseUri): string\n    {\n        $uri = trim($uri);\n\n        // absolute URL?\n        if (null !== parse_url(\\strlen($uri) !== strcspn($uri, '?#') ? $uri : $uri.'#', \\PHP_URL_SCHEME)) {\n            return $uri;\n        }\n\n        if (null === $baseUri) {\n            throw new \\InvalidArgumentException('The URI is relative, so you must define its base URI passing an absolute URL.');\n        }\n\n        // empty URI\n        if (!$uri) {\n            return $baseUri;\n        }\n\n        // an anchor\n        if ('#' === $uri[0]) {\n            return self::cleanupAnchor($baseUri).$uri;\n        }\n\n        $baseUriCleaned = self::cleanupUri($baseUri);\n\n        if ('?' === $uri[0]) {\n            return $baseUriCleaned.$uri;\n        }\n\n        // absolute URL with relative schema\n        if (str_starts_with($uri, '//')) {\n            return preg_replace('#^([^/]*)//.*$#', '$1', $baseUriCleaned).$uri;\n        }\n\n        $baseUriCleaned = preg_replace('#^(.*?//[^/]*)(?:\\/.*)?$#', '$1', $baseUriCleaned);\n\n        // absolute path\n        if ('/' === $uri[0]) {\n            return $baseUriCleaned.$uri;\n        }\n\n        // relative path\n        $path = parse_url(substr($baseUri, \\strlen($baseUriCleaned)), \\PHP_URL_PATH) ?? '';\n        $path = self::canonicalizePath(substr($path, 0, strrpos($path, '/')).'/'.$uri);\n\n        return $baseUriCleaned.('' === $path || '/' !== $path[0] ? '/' : '').$path;\n    }\n\n    /**\n     * Returns the canonicalized URI path (see RFC 3986, section 5.2.4).\n     */\n    private static function canonicalizePath(string $path): string\n    {\n        if ('' === $path || '/' === $path) {\n            return $path;\n        }\n\n        if (str_ends_with($path, '.')) {\n            $path .= '/';\n        }\n\n        $output = [];\n\n        foreach (explode('/', $path) as $segment) {\n            if ('..' === $segment) {\n                array_pop($output);\n            } elseif ('.' !== $segment) {\n                $output[] = $segment;\n            }\n        }\n\n        return implode('/', $output);\n    }\n\n    /**\n     * Removes the query string and the anchor from the given uri.\n     */\n    private static function cleanupUri(string $uri): string\n    {\n        return self::cleanupQuery(self::cleanupAnchor($uri));\n    }\n\n    /**\n     * Removes the query string from the uri.\n     */\n    private static function cleanupQuery(string $uri): string\n    {\n        if (false !== $pos = strpos($uri, '?')) {\n            return substr($uri, 0, $pos);\n        }\n\n        return $uri;\n    }\n\n    /**\n     * Removes the anchor from the uri.\n     */\n    private static function cleanupAnchor(string $uri): string\n    {\n        if (false !== $pos = strpos($uri, '#')) {\n            return substr($uri, 0, $pos);\n        }\n\n        return $uri;\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.8662109375,
          "content": "{\n    \"name\": \"symfony/dom-crawler\",\n    \"type\": \"library\",\n    \"description\": \"Eases DOM navigation for HTML and XML documents\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/polyfill-ctype\": \"~1.8\",\n        \"symfony/polyfill-mbstring\": \"~1.0\",\n        \"masterminds/html5\": \"^2.6\"\n    },\n    \"require-dev\": {\n        \"symfony/css-selector\": \"^6.4|^7.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\DomCrawler\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.84765625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony DomCrawler Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Resources</directory>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}