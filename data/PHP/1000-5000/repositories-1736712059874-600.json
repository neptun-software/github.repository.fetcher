{
  "metadata": {
    "timestamp": 1736712059874,
    "page": 600,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/string",
      "stars": 1727,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.166015625,
          "content": "/Resources/bin/update-data.php export-ignore\n/Resources/WcswidthDataGenerator.php export-ignore\n/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "composer.lock\nphpunit.xml\nvendor/\n"
        },
        {
          "name": "AbstractString.php",
          "type": "blob",
          "size": 19.0927734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\nuse Symfony\\Component\\String\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\String\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\String\\Exception\\RuntimeException;\n\n/**\n * Represents a string of abstract characters.\n *\n * Unicode defines 3 types of \"characters\" (bytes, code points and grapheme clusters).\n * This class is the abstract type to use as a type-hint when the logic you want to\n * implement doesn't care about the exact variant it deals with.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Hugo Hamon <hugohamon@neuf.fr>\n *\n * @throws ExceptionInterface\n */\nabstract class AbstractString implements \\Stringable, \\JsonSerializable\n{\n    public const PREG_PATTERN_ORDER = \\PREG_PATTERN_ORDER;\n    public const PREG_SET_ORDER = \\PREG_SET_ORDER;\n    public const PREG_OFFSET_CAPTURE = \\PREG_OFFSET_CAPTURE;\n    public const PREG_UNMATCHED_AS_NULL = \\PREG_UNMATCHED_AS_NULL;\n\n    public const PREG_SPLIT = 0;\n    public const PREG_SPLIT_NO_EMPTY = \\PREG_SPLIT_NO_EMPTY;\n    public const PREG_SPLIT_DELIM_CAPTURE = \\PREG_SPLIT_DELIM_CAPTURE;\n    public const PREG_SPLIT_OFFSET_CAPTURE = \\PREG_SPLIT_OFFSET_CAPTURE;\n\n    protected string $string = '';\n    protected ?bool $ignoreCase = false;\n\n    abstract public function __construct(string $string = '');\n\n    /**\n     * Unwraps instances of AbstractString back to strings.\n     *\n     * @return string[]|array\n     */\n    public static function unwrap(array $values): array\n    {\n        foreach ($values as $k => $v) {\n            if ($v instanceof self) {\n                $values[$k] = $v->__toString();\n            } elseif (\\is_array($v) && $values[$k] !== $v = static::unwrap($v)) {\n                $values[$k] = $v;\n            }\n        }\n\n        return $values;\n    }\n\n    /**\n     * Wraps (and normalizes) strings in instances of AbstractString.\n     *\n     * @return static[]|array\n     */\n    public static function wrap(array $values): array\n    {\n        $i = 0;\n        $keys = null;\n\n        foreach ($values as $k => $v) {\n            if (\\is_string($k) && '' !== $k && $k !== $j = (string) new static($k)) {\n                $keys ??= array_keys($values);\n                $keys[$i] = $j;\n            }\n\n            if (\\is_string($v)) {\n                $values[$k] = new static($v);\n            } elseif (\\is_array($v) && $values[$k] !== $v = static::wrap($v)) {\n                $values[$k] = $v;\n            }\n\n            ++$i;\n        }\n\n        return null !== $keys ? array_combine($keys, $values) : $values;\n    }\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function after(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static\n    {\n        $str = clone $this;\n        $i = \\PHP_INT_MAX;\n\n        if (\\is_string($needle)) {\n            $needle = [$needle];\n        }\n\n        foreach ($needle as $n) {\n            $n = (string) $n;\n            $j = $this->indexOf($n, $offset);\n\n            if (null !== $j && $j < $i) {\n                $i = $j;\n                $str->string = $n;\n            }\n        }\n\n        if (\\PHP_INT_MAX === $i) {\n            return $str;\n        }\n\n        if (!$includeNeedle) {\n            $i += $str->length();\n        }\n\n        return $this->slice($i);\n    }\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function afterLast(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static\n    {\n        $str = clone $this;\n        $i = null;\n\n        if (\\is_string($needle)) {\n            $needle = [$needle];\n        }\n\n        foreach ($needle as $n) {\n            $n = (string) $n;\n            $j = $this->indexOfLast($n, $offset);\n\n            if (null !== $j && $j >= $i) {\n                $i = $offset = $j;\n                $str->string = $n;\n            }\n        }\n\n        if (null === $i) {\n            return $str;\n        }\n\n        if (!$includeNeedle) {\n            $i += $str->length();\n        }\n\n        return $this->slice($i);\n    }\n\n    abstract public function append(string ...$suffix): static;\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function before(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static\n    {\n        $str = clone $this;\n        $i = \\PHP_INT_MAX;\n\n        if (\\is_string($needle)) {\n            $needle = [$needle];\n        }\n\n        foreach ($needle as $n) {\n            $n = (string) $n;\n            $j = $this->indexOf($n, $offset);\n\n            if (null !== $j && $j < $i) {\n                $i = $j;\n                $str->string = $n;\n            }\n        }\n\n        if (\\PHP_INT_MAX === $i) {\n            return $str;\n        }\n\n        if ($includeNeedle) {\n            $i += $str->length();\n        }\n\n        return $this->slice(0, $i);\n    }\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function beforeLast(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static\n    {\n        $str = clone $this;\n        $i = null;\n\n        if (\\is_string($needle)) {\n            $needle = [$needle];\n        }\n\n        foreach ($needle as $n) {\n            $n = (string) $n;\n            $j = $this->indexOfLast($n, $offset);\n\n            if (null !== $j && $j >= $i) {\n                $i = $offset = $j;\n                $str->string = $n;\n            }\n        }\n\n        if (null === $i) {\n            return $str;\n        }\n\n        if ($includeNeedle) {\n            $i += $str->length();\n        }\n\n        return $this->slice(0, $i);\n    }\n\n    /**\n     * @return int[]\n     */\n    public function bytesAt(int $offset): array\n    {\n        $str = $this->slice($offset, 1);\n\n        return '' === $str->string ? [] : array_values(unpack('C*', $str->string));\n    }\n\n    abstract public function camel(): static;\n\n    /**\n     * @return static[]\n     */\n    abstract public function chunk(int $length = 1): array;\n\n    public function collapseWhitespace(): static\n    {\n        $str = clone $this;\n        $str->string = trim(preg_replace(\"/(?:[ \\n\\r\\t\\x0C]{2,}+|[\\n\\r\\t\\x0C])/\", ' ', $str->string), \" \\n\\r\\t\\x0C\");\n\n        return $str;\n    }\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function containsAny(string|iterable $needle): bool\n    {\n        return null !== $this->indexOf($needle);\n    }\n\n    /**\n     * @param string|string[] $suffix\n     */\n    public function endsWith(string|iterable $suffix): bool\n    {\n        if (\\is_string($suffix)) {\n            throw new \\TypeError(\\sprintf('Method \"%s()\" must be overridden by class \"%s\" to deal with non-iterable values.', __FUNCTION__, static::class));\n        }\n\n        foreach ($suffix as $s) {\n            if ($this->endsWith((string) $s)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function ensureEnd(string $suffix): static\n    {\n        if (!$this->endsWith($suffix)) {\n            return $this->append($suffix);\n        }\n\n        $suffix = preg_quote($suffix);\n        $regex = '{('.$suffix.')(?:'.$suffix.')++$}D';\n\n        return $this->replaceMatches($regex.($this->ignoreCase ? 'i' : ''), '$1');\n    }\n\n    public function ensureStart(string $prefix): static\n    {\n        $prefix = new static($prefix);\n\n        if (!$this->startsWith($prefix)) {\n            return $this->prepend($prefix);\n        }\n\n        $str = clone $this;\n        $i = $prefixLen = $prefix->length();\n\n        while ($this->indexOf($prefix, $i) === $i) {\n            $str = $str->slice($prefixLen);\n            $i += $prefixLen;\n        }\n\n        return $str;\n    }\n\n    /**\n     * @param string|string[] $string\n     */\n    public function equalsTo(string|iterable $string): bool\n    {\n        if (\\is_string($string)) {\n            throw new \\TypeError(\\sprintf('Method \"%s()\" must be overridden by class \"%s\" to deal with non-iterable values.', __FUNCTION__, static::class));\n        }\n\n        foreach ($string as $s) {\n            if ($this->equalsTo((string) $s)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    abstract public function folded(): static;\n\n    public function ignoreCase(): static\n    {\n        $str = clone $this;\n        $str->ignoreCase = true;\n\n        return $str;\n    }\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function indexOf(string|iterable $needle, int $offset = 0): ?int\n    {\n        if (\\is_string($needle)) {\n            throw new \\TypeError(\\sprintf('Method \"%s()\" must be overridden by class \"%s\" to deal with non-iterable values.', __FUNCTION__, static::class));\n        }\n\n        $i = \\PHP_INT_MAX;\n\n        foreach ($needle as $n) {\n            $j = $this->indexOf((string) $n, $offset);\n\n            if (null !== $j && $j < $i) {\n                $i = $j;\n            }\n        }\n\n        return \\PHP_INT_MAX === $i ? null : $i;\n    }\n\n    /**\n     * @param string|string[] $needle\n     */\n    public function indexOfLast(string|iterable $needle, int $offset = 0): ?int\n    {\n        if (\\is_string($needle)) {\n            throw new \\TypeError(\\sprintf('Method \"%s()\" must be overridden by class \"%s\" to deal with non-iterable values.', __FUNCTION__, static::class));\n        }\n\n        $i = null;\n\n        foreach ($needle as $n) {\n            $j = $this->indexOfLast((string) $n, $offset);\n\n            if (null !== $j && $j >= $i) {\n                $i = $offset = $j;\n            }\n        }\n\n        return $i;\n    }\n\n    public function isEmpty(): bool\n    {\n        return '' === $this->string;\n    }\n\n    abstract public function join(array $strings, ?string $lastGlue = null): static;\n\n    public function jsonSerialize(): string\n    {\n        return $this->string;\n    }\n\n    abstract public function length(): int;\n\n    abstract public function lower(): static;\n\n    /**\n     * Matches the string using a regular expression.\n     *\n     * Pass PREG_PATTERN_ORDER or PREG_SET_ORDER as $flags to get all occurrences matching the regular expression.\n     *\n     * @return array All matches in a multi-dimensional array ordered according to flags\n     */\n    abstract public function match(string $regexp, int $flags = 0, int $offset = 0): array;\n\n    abstract public function padBoth(int $length, string $padStr = ' '): static;\n\n    abstract public function padEnd(int $length, string $padStr = ' '): static;\n\n    abstract public function padStart(int $length, string $padStr = ' '): static;\n\n    abstract public function prepend(string ...$prefix): static;\n\n    public function repeat(int $multiplier): static\n    {\n        if (0 > $multiplier) {\n            throw new InvalidArgumentException(\\sprintf('Multiplier must be positive, %d given.', $multiplier));\n        }\n\n        $str = clone $this;\n        $str->string = str_repeat($str->string, $multiplier);\n\n        return $str;\n    }\n\n    abstract public function replace(string $from, string $to): static;\n\n    abstract public function replaceMatches(string $fromRegexp, string|callable $to): static;\n\n    abstract public function reverse(): static;\n\n    abstract public function slice(int $start = 0, ?int $length = null): static;\n\n    abstract public function snake(): static;\n\n    public function kebab(): static\n    {\n        return $this->snake()->replace('_', '-');\n    }\n\n    abstract public function splice(string $replacement, int $start = 0, ?int $length = null): static;\n\n    /**\n     * @return static[]\n     */\n    public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array\n    {\n        if (null === $flags) {\n            throw new \\TypeError('Split behavior when $flags is null must be implemented by child classes.');\n        }\n\n        if ($this->ignoreCase) {\n            $delimiter .= 'i';\n        }\n\n        set_error_handler(static fn ($t, $m) => throw new InvalidArgumentException($m));\n\n        try {\n            if (false === $chunks = preg_split($delimiter, $this->string, $limit, $flags)) {\n                throw new RuntimeException('Splitting failed with error: '.preg_last_error_msg());\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        $str = clone $this;\n\n        if (self::PREG_SPLIT_OFFSET_CAPTURE & $flags) {\n            foreach ($chunks as &$chunk) {\n                $str->string = $chunk[0];\n                $chunk[0] = clone $str;\n            }\n        } else {\n            foreach ($chunks as &$chunk) {\n                $str->string = $chunk;\n                $chunk = clone $str;\n            }\n        }\n\n        return $chunks;\n    }\n\n    /**\n     * @param string|string[] $prefix\n     */\n    public function startsWith(string|iterable $prefix): bool\n    {\n        if (\\is_string($prefix)) {\n            throw new \\TypeError(\\sprintf('Method \"%s()\" must be overridden by class \"%s\" to deal with non-iterable values.', __FUNCTION__, static::class));\n        }\n\n        foreach ($prefix as $prefix) {\n            if ($this->startsWith((string) $prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    abstract public function title(bool $allWords = false): static;\n\n    public function toByteString(?string $toEncoding = null): ByteString\n    {\n        $b = new ByteString();\n\n        $toEncoding = \\in_array($toEncoding, ['utf8', 'utf-8', 'UTF8'], true) ? 'UTF-8' : $toEncoding;\n\n        if (null === $toEncoding || $toEncoding === $fromEncoding = $this instanceof AbstractUnicodeString || preg_match('//u', $b->string) ? 'UTF-8' : 'Windows-1252') {\n            $b->string = $this->string;\n\n            return $b;\n        }\n\n        try {\n            $b->string = mb_convert_encoding($this->string, $toEncoding, 'UTF-8');\n        } catch (\\ValueError $e) {\n            if (!\\function_exists('iconv')) {\n                throw new InvalidArgumentException($e->getMessage(), $e->getCode(), $e);\n            }\n\n            $b->string = iconv('UTF-8', $toEncoding, $this->string);\n        }\n\n        return $b;\n    }\n\n    public function toCodePointString(): CodePointString\n    {\n        return new CodePointString($this->string);\n    }\n\n    public function toString(): string\n    {\n        return $this->string;\n    }\n\n    public function toUnicodeString(): UnicodeString\n    {\n        return new UnicodeString($this->string);\n    }\n\n    abstract public function trim(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\"): static;\n\n    abstract public function trimEnd(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\"): static;\n\n    /**\n     * @param string|string[] $prefix\n     */\n    public function trimPrefix($prefix): static\n    {\n        if (\\is_array($prefix) || $prefix instanceof \\Traversable) { // don't use is_iterable(), it's slow\n            foreach ($prefix as $s) {\n                $t = $this->trimPrefix($s);\n\n                if ($t->string !== $this->string) {\n                    return $t;\n                }\n            }\n\n            return clone $this;\n        }\n\n        $str = clone $this;\n\n        if ($prefix instanceof self) {\n            $prefix = $prefix->string;\n        } else {\n            $prefix = (string) $prefix;\n        }\n\n        if ('' !== $prefix && \\strlen($this->string) >= \\strlen($prefix) && 0 === substr_compare($this->string, $prefix, 0, \\strlen($prefix), $this->ignoreCase)) {\n            $str->string = substr($this->string, \\strlen($prefix));\n        }\n\n        return $str;\n    }\n\n    abstract public function trimStart(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\"): static;\n\n    /**\n     * @param string|string[] $suffix\n     */\n    public function trimSuffix($suffix): static\n    {\n        if (\\is_array($suffix) || $suffix instanceof \\Traversable) { // don't use is_iterable(), it's slow\n            foreach ($suffix as $s) {\n                $t = $this->trimSuffix($s);\n\n                if ($t->string !== $this->string) {\n                    return $t;\n                }\n            }\n\n            return clone $this;\n        }\n\n        $str = clone $this;\n\n        if ($suffix instanceof self) {\n            $suffix = $suffix->string;\n        } else {\n            $suffix = (string) $suffix;\n        }\n\n        if ('' !== $suffix && \\strlen($this->string) >= \\strlen($suffix) && 0 === substr_compare($this->string, $suffix, -\\strlen($suffix), null, $this->ignoreCase)) {\n            $str->string = substr($this->string, 0, -\\strlen($suffix));\n        }\n\n        return $str;\n    }\n\n    public function truncate(int $length, string $ellipsis = '', bool|TruncateMode $cut = TruncateMode::Char): static\n    {\n        $stringLength = $this->length();\n\n        if ($stringLength <= $length) {\n            return clone $this;\n        }\n\n        $ellipsisLength = '' !== $ellipsis ? (new static($ellipsis))->length() : 0;\n\n        if ($length < $ellipsisLength) {\n            $ellipsisLength = 0;\n        }\n\n        $desiredLength = $length;\n        if (TruncateMode::WordAfter === $cut || !$cut) {\n            if (null === $length = $this->indexOf([' ', \"\\r\", \"\\n\", \"\\t\"], ($length ?: 1) - 1)) {\n                return clone $this;\n            }\n\n            $length += $ellipsisLength;\n        } elseif (TruncateMode::WordBefore === $cut && null !== $this->indexOf([' ', \"\\r\", \"\\n\", \"\\t\"], ($length ?: 1) - 1)) {\n            $length += $ellipsisLength;\n        }\n\n        $str = $this->slice(0, $length - $ellipsisLength);\n\n        if (TruncateMode::WordBefore === $cut) {\n            if (0 === $ellipsisLength && $desiredLength === $this->indexOf([' ', \"\\r\", \"\\n\", \"\\t\"], $length)) {\n                return $str;\n            }\n\n            $str = $str->beforeLast([' ', \"\\r\", \"\\n\", \"\\t\"]);\n        }\n\n        return $ellipsisLength ? $str->trimEnd()->append($ellipsis) : $str;\n    }\n\n    abstract public function upper(): static;\n\n    /**\n     * Returns the printable length on a terminal.\n     */\n    abstract public function width(bool $ignoreAnsiDecoration = true): int;\n\n    public function wordwrap(int $width = 75, string $break = \"\\n\", bool $cut = false): static\n    {\n        $lines = '' !== $break ? $this->split($break) : [clone $this];\n        $chars = [];\n        $mask = '';\n\n        if (1 === \\count($lines) && '' === $lines[0]->string) {\n            return $lines[0];\n        }\n\n        foreach ($lines as $i => $line) {\n            if ($i) {\n                $chars[] = $break;\n                $mask .= '#';\n            }\n\n            foreach ($line->chunk() as $char) {\n                $chars[] = $char->string;\n                $mask .= ' ' === $char->string ? ' ' : '?';\n            }\n        }\n\n        $string = '';\n        $j = 0;\n        $b = $i = -1;\n        $mask = wordwrap($mask, $width, '#', $cut);\n\n        while (false !== $b = strpos($mask, '#', $b + 1)) {\n            for (++$i; $i < $b; ++$i) {\n                $string .= $chars[$j];\n                unset($chars[$j++]);\n            }\n\n            if ($break === $chars[$j] || ' ' === $chars[$j]) {\n                unset($chars[$j++]);\n            }\n\n            $string .= $break;\n        }\n\n        $str = clone $this;\n        $str->string = $string.implode('', $chars);\n\n        return $str;\n    }\n\n    public function __sleep(): array\n    {\n        return ['string'];\n    }\n\n    public function __clone()\n    {\n        $this->ignoreCase = false;\n    }\n\n    public function __toString(): string\n    {\n        return $this->string;\n    }\n}\n"
        },
        {
          "name": "AbstractUnicodeString.php",
          "type": "blob",
          "size": 27.5927734375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\nuse Symfony\\Component\\String\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\String\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\String\\Exception\\RuntimeException;\n\n/**\n * Represents a string of abstract Unicode characters.\n *\n * Unicode defines 3 types of \"characters\" (bytes, code points and grapheme clusters).\n * This class is the abstract type to use as a type-hint when the logic you want to\n * implement is Unicode-aware but doesn't care about code points vs grapheme clusters.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @throws ExceptionInterface\n */\nabstract class AbstractUnicodeString extends AbstractString\n{\n    public const NFC = \\Normalizer::NFC;\n    public const NFD = \\Normalizer::NFD;\n    public const NFKC = \\Normalizer::NFKC;\n    public const NFKD = \\Normalizer::NFKD;\n\n    // all ASCII letters sorted by typical frequency of occurrence\n    private const ASCII = \"\\x20\\x65\\x69\\x61\\x73\\x6E\\x74\\x72\\x6F\\x6C\\x75\\x64\\x5D\\x5B\\x63\\x6D\\x70\\x27\\x0A\\x67\\x7C\\x68\\x76\\x2E\\x66\\x62\\x2C\\x3A\\x3D\\x2D\\x71\\x31\\x30\\x43\\x32\\x2A\\x79\\x78\\x29\\x28\\x4C\\x39\\x41\\x53\\x2F\\x50\\x22\\x45\\x6A\\x4D\\x49\\x6B\\x33\\x3E\\x35\\x54\\x3C\\x44\\x34\\x7D\\x42\\x7B\\x38\\x46\\x77\\x52\\x36\\x37\\x55\\x47\\x4E\\x3B\\x4A\\x7A\\x56\\x23\\x48\\x4F\\x57\\x5F\\x26\\x21\\x4B\\x3F\\x58\\x51\\x25\\x59\\x5C\\x09\\x5A\\x2B\\x7E\\x5E\\x24\\x40\\x60\\x7F\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x0B\\x0C\\x0D\\x0E\\x0F\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\";\n\n    // the subset of folded case mappings that is not in lower case mappings\n    private const FOLD_FROM = ['İ', 'µ', 'ſ', \"\\xCD\\x85\", 'ς', 'ϐ', 'ϑ', 'ϕ', 'ϖ', 'ϰ', 'ϱ', 'ϵ', 'ẛ', \"\\xE1\\xBE\\xBE\", 'ß', 'ŉ', 'ǰ', 'ΐ', 'ΰ', 'և', 'ẖ', 'ẗ', 'ẘ', 'ẙ', 'ẚ', 'ẞ', 'ὐ', 'ὒ', 'ὔ', 'ὖ', 'ᾀ', 'ᾁ', 'ᾂ', 'ᾃ', 'ᾄ', 'ᾅ', 'ᾆ', 'ᾇ', 'ᾈ', 'ᾉ', 'ᾊ', 'ᾋ', 'ᾌ', 'ᾍ', 'ᾎ', 'ᾏ', 'ᾐ', 'ᾑ', 'ᾒ', 'ᾓ', 'ᾔ', 'ᾕ', 'ᾖ', 'ᾗ', 'ᾘ', 'ᾙ', 'ᾚ', 'ᾛ', 'ᾜ', 'ᾝ', 'ᾞ', 'ᾟ', 'ᾠ', 'ᾡ', 'ᾢ', 'ᾣ', 'ᾤ', 'ᾥ', 'ᾦ', 'ᾧ', 'ᾨ', 'ᾩ', 'ᾪ', 'ᾫ', 'ᾬ', 'ᾭ', 'ᾮ', 'ᾯ', 'ᾲ', 'ᾳ', 'ᾴ', 'ᾶ', 'ᾷ', 'ᾼ', 'ῂ', 'ῃ', 'ῄ', 'ῆ', 'ῇ', 'ῌ', 'ῒ', 'ῖ', 'ῗ', 'ῢ', 'ῤ', 'ῦ', 'ῧ', 'ῲ', 'ῳ', 'ῴ', 'ῶ', 'ῷ', 'ῼ', 'ﬀ', 'ﬁ', 'ﬂ', 'ﬃ', 'ﬄ', 'ﬅ', 'ﬆ', 'ﬓ', 'ﬔ', 'ﬕ', 'ﬖ', 'ﬗ'];\n    private const FOLD_TO = ['i̇', 'μ', 's', 'ι', 'σ', 'β', 'θ', 'φ', 'π', 'κ', 'ρ', 'ε', 'ṡ', 'ι', 'ss', 'ʼn', 'ǰ', 'ΐ', 'ΰ', 'եւ', 'ẖ', 'ẗ', 'ẘ', 'ẙ', 'aʾ', 'ss', 'ὐ', 'ὒ', 'ὔ', 'ὖ', 'ἀι', 'ἁι', 'ἂι', 'ἃι', 'ἄι', 'ἅι', 'ἆι', 'ἇι', 'ἀι', 'ἁι', 'ἂι', 'ἃι', 'ἄι', 'ἅι', 'ἆι', 'ἇι', 'ἠι', 'ἡι', 'ἢι', 'ἣι', 'ἤι', 'ἥι', 'ἦι', 'ἧι', 'ἠι', 'ἡι', 'ἢι', 'ἣι', 'ἤι', 'ἥι', 'ἦι', 'ἧι', 'ὠι', 'ὡι', 'ὢι', 'ὣι', 'ὤι', 'ὥι', 'ὦι', 'ὧι', 'ὠι', 'ὡι', 'ὢι', 'ὣι', 'ὤι', 'ὥι', 'ὦι', 'ὧι', 'ὰι', 'αι', 'άι', 'ᾶ', 'ᾶι', 'αι', 'ὴι', 'ηι', 'ήι', 'ῆ', 'ῆι', 'ηι', 'ῒ', 'ῖ', 'ῗ', 'ῢ', 'ῤ', 'ῦ', 'ῧ', 'ὼι', 'ωι', 'ώι', 'ῶ', 'ῶι', 'ωι', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'st', 'st', 'մն', 'մե', 'մի', 'վն', 'մխ'];\n\n    // the subset of https://github.com/unicode-org/cldr/blob/master/common/transforms/Latin-ASCII.xml that is not in NFKD\n    private const TRANSLIT_FROM = ['Æ', 'Ð', 'Ø', 'Þ', 'ß', 'æ', 'ð', 'ø', 'þ', 'Đ', 'đ', 'Ħ', 'ħ', 'ı', 'ĸ', 'Ŀ', 'ŀ', 'Ł', 'ł', 'ŉ', 'Ŋ', 'ŋ', 'Œ', 'œ', 'Ŧ', 'ŧ', 'ƀ', 'Ɓ', 'Ƃ', 'ƃ', 'Ƈ', 'ƈ', 'Ɖ', 'Ɗ', 'Ƌ', 'ƌ', 'Ɛ', 'Ƒ', 'ƒ', 'Ɠ', 'ƕ', 'Ɩ', 'Ɨ', 'Ƙ', 'ƙ', 'ƚ', 'Ɲ', 'ƞ', 'Ƣ', 'ƣ', 'Ƥ', 'ƥ', 'ƫ', 'Ƭ', 'ƭ', 'Ʈ', 'Ʋ', 'Ƴ', 'ƴ', 'Ƶ', 'ƶ', 'Ǆ', 'ǅ', 'ǆ', 'Ǥ', 'ǥ', 'ȡ', 'Ȥ', 'ȥ', 'ȴ', 'ȵ', 'ȶ', 'ȷ', 'ȸ', 'ȹ', 'Ⱥ', 'Ȼ', 'ȼ', 'Ƚ', 'Ⱦ', 'ȿ', 'ɀ', 'Ƀ', 'Ʉ', 'Ɇ', 'ɇ', 'Ɉ', 'ɉ', 'Ɍ', 'ɍ', 'Ɏ', 'ɏ', 'ɓ', 'ɕ', 'ɖ', 'ɗ', 'ɛ', 'ɟ', 'ɠ', 'ɡ', 'ɢ', 'ɦ', 'ɧ', 'ɨ', 'ɪ', 'ɫ', 'ɬ', 'ɭ', 'ɱ', 'ɲ', 'ɳ', 'ɴ', 'ɶ', 'ɼ', 'ɽ', 'ɾ', 'ʀ', 'ʂ', 'ʈ', 'ʉ', 'ʋ', 'ʏ', 'ʐ', 'ʑ', 'ʙ', 'ʛ', 'ʜ', 'ʝ', 'ʟ', 'ʠ', 'ʣ', 'ʥ', 'ʦ', 'ʪ', 'ʫ', 'ᴀ', 'ᴁ', 'ᴃ', 'ᴄ', 'ᴅ', 'ᴆ', 'ᴇ', 'ᴊ', 'ᴋ', 'ᴌ', 'ᴍ', 'ᴏ', 'ᴘ', 'ᴛ', 'ᴜ', 'ᴠ', 'ᴡ', 'ᴢ', 'ᵫ', 'ᵬ', 'ᵭ', 'ᵮ', 'ᵯ', 'ᵰ', 'ᵱ', 'ᵲ', 'ᵳ', 'ᵴ', 'ᵵ', 'ᵶ', 'ᵺ', 'ᵻ', 'ᵽ', 'ᵾ', 'ᶀ', 'ᶁ', 'ᶂ', 'ᶃ', 'ᶄ', 'ᶅ', 'ᶆ', 'ᶇ', 'ᶈ', 'ᶉ', 'ᶊ', 'ᶌ', 'ᶍ', 'ᶎ', 'ᶏ', 'ᶑ', 'ᶒ', 'ᶓ', 'ᶖ', 'ᶙ', 'ẚ', 'ẜ', 'ẝ', 'ẞ', 'Ỻ', 'ỻ', 'Ỽ', 'ỽ', 'Ỿ', 'ỿ', '©', '®', '₠', '₢', '₣', '₤', '₧', '₺', '₹', 'ℌ', '℞', '㎧', '㎮', '㏆', '㏗', '㏞', '㏟', '¼', '½', '¾', '⅓', '⅔', '⅕', '⅖', '⅗', '⅘', '⅙', '⅚', '⅛', '⅜', '⅝', '⅞', '⅟', '〇', '‘', '’', '‚', '‛', '“', '”', '„', '‟', '′', '″', '〝', '〞', '«', '»', '‹', '›', '‐', '‑', '‒', '–', '—', '―', '︱', '︲', '﹘', '‖', '⁄', '⁅', '⁆', '⁎', '、', '。', '〈', '〉', '《', '》', '〔', '〕', '〘', '〙', '〚', '〛', '︑', '︒', '︹', '︺', '︽', '︾', '︿', '﹀', '﹑', '﹝', '﹞', '｟', '｠', '｡', '､', '×', '÷', '−', '∕', '∖', '∣', '∥', '≪', '≫', '⦅', '⦆'];\n    private const TRANSLIT_TO = ['AE', 'D', 'O', 'TH', 'ss', 'ae', 'd', 'o', 'th', 'D', 'd', 'H', 'h', 'i', 'q', 'L', 'l', 'L', 'l', '\\'n', 'N', 'n', 'OE', 'oe', 'T', 't', 'b', 'B', 'B', 'b', 'C', 'c', 'D', 'D', 'D', 'd', 'E', 'F', 'f', 'G', 'hv', 'I', 'I', 'K', 'k', 'l', 'N', 'n', 'OI', 'oi', 'P', 'p', 't', 'T', 't', 'T', 'V', 'Y', 'y', 'Z', 'z', 'DZ', 'Dz', 'dz', 'G', 'g', 'd', 'Z', 'z', 'l', 'n', 't', 'j', 'db', 'qp', 'A', 'C', 'c', 'L', 'T', 's', 'z', 'B', 'U', 'E', 'e', 'J', 'j', 'R', 'r', 'Y', 'y', 'b', 'c', 'd', 'd', 'e', 'j', 'g', 'g', 'G', 'h', 'h', 'i', 'I', 'l', 'l', 'l', 'm', 'n', 'n', 'N', 'OE', 'r', 'r', 'r', 'R', 's', 't', 'u', 'v', 'Y', 'z', 'z', 'B', 'G', 'H', 'j', 'L', 'q', 'dz', 'dz', 'ts', 'ls', 'lz', 'A', 'AE', 'B', 'C', 'D', 'D', 'E', 'J', 'K', 'L', 'M', 'O', 'P', 'T', 'U', 'V', 'W', 'Z', 'ue', 'b', 'd', 'f', 'm', 'n', 'p', 'r', 'r', 's', 't', 'z', 'th', 'I', 'p', 'U', 'b', 'd', 'f', 'g', 'k', 'l', 'm', 'n', 'p', 'r', 's', 'v', 'x', 'z', 'a', 'd', 'e', 'e', 'i', 'u', 'a', 's', 's', 'SS', 'LL', 'll', 'V', 'v', 'Y', 'y', '(C)', '(R)', 'CE', 'Cr', 'Fr.', 'L.', 'Pts', 'TL', 'Rs', 'x', 'Rx', 'm/s', 'rad/s', 'C/kg', 'pH', 'V/m', 'A/m', ' 1/4', ' 1/2', ' 3/4', ' 1/3', ' 2/3', ' 1/5', ' 2/5', ' 3/5', ' 4/5', ' 1/6', ' 5/6', ' 1/8', ' 3/8', ' 5/8', ' 7/8', ' 1/', '0', '\\'', '\\'', ',', '\\'', '\"', '\"', ',,', '\"', '\\'', '\"', '\"', '\"', '<<', '>>', '<', '>', '-', '-', '-', '-', '-', '-', '-', '-', '-', '||', '/', '[', ']', '*', ',', '.', '<', '>', '<<', '>>', '[', ']', '[', ']', '[', ']', ',', '.', '[', ']', '<<', '>>', '<', '>', ',', '[', ']', '((', '))', '.', ',', '*', '/', '-', '/', '\\\\', '|', '||', '<<', '>>', '((', '))'];\n\n    private static array $transliterators = [];\n    private static array $tableZero;\n    private static array $tableWide;\n\n    public static function fromCodePoints(int ...$codes): static\n    {\n        $string = '';\n\n        foreach ($codes as $code) {\n            if (0x80 > $code %= 0x200000) {\n                $string .= \\chr($code);\n            } elseif (0x800 > $code) {\n                $string .= \\chr(0xC0 | $code >> 6).\\chr(0x80 | $code & 0x3F);\n            } elseif (0x10000 > $code) {\n                $string .= \\chr(0xE0 | $code >> 12).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n            } else {\n                $string .= \\chr(0xF0 | $code >> 18).\\chr(0x80 | $code >> 12 & 0x3F).\\chr(0x80 | $code >> 6 & 0x3F).\\chr(0x80 | $code & 0x3F);\n            }\n        }\n\n        return new static($string);\n    }\n\n    /**\n     * Generic UTF-8 to ASCII transliteration.\n     *\n     * Install the intl extension for best results.\n     *\n     * @param string[]|\\Transliterator[]|\\Closure[] $rules See \"*-Latin\" rules from Transliterator::listIDs()\n     */\n    public function ascii(array $rules = []): self\n    {\n        $str = clone $this;\n        $s = $str->string;\n        $str->string = '';\n\n        array_unshift($rules, 'nfd');\n        $rules[] = 'latin-ascii';\n\n        if (\\function_exists('transliterator_transliterate')) {\n            $rules[] = 'any-latin/bgn';\n        }\n\n        $rules[] = 'nfkd';\n        $rules[] = '[:nonspacing mark:] remove';\n\n        while (\\strlen($s) - 1 > $i = strspn($s, self::ASCII)) {\n            if (0 < --$i) {\n                $str->string .= substr($s, 0, $i);\n                $s = substr($s, $i);\n            }\n\n            if (!$rule = array_shift($rules)) {\n                $rules = []; // An empty rule interrupts the next ones\n            }\n\n            if ($rule instanceof \\Transliterator) {\n                $s = $rule->transliterate($s);\n            } elseif ($rule instanceof \\Closure) {\n                $s = $rule($s);\n            } elseif ($rule) {\n                if ('nfd' === $rule = strtolower($rule)) {\n                    normalizer_is_normalized($s, self::NFD) ?: $s = normalizer_normalize($s, self::NFD);\n                } elseif ('nfkd' === $rule) {\n                    normalizer_is_normalized($s, self::NFKD) ?: $s = normalizer_normalize($s, self::NFKD);\n                } elseif ('[:nonspacing mark:] remove' === $rule) {\n                    $s = preg_replace('/\\p{Mn}++/u', '', $s);\n                } elseif ('latin-ascii' === $rule) {\n                    $s = str_replace(self::TRANSLIT_FROM, self::TRANSLIT_TO, $s);\n                } elseif ('de-ascii' === $rule) {\n                    $s = preg_replace(\"/([AUO])\\u{0308}(?=\\p{Ll})/u\", '$1e', $s);\n                    $s = str_replace([\"a\\u{0308}\", \"o\\u{0308}\", \"u\\u{0308}\", \"A\\u{0308}\", \"O\\u{0308}\", \"U\\u{0308}\"], ['ae', 'oe', 'ue', 'AE', 'OE', 'UE'], $s);\n                } elseif (\\function_exists('transliterator_transliterate')) {\n                    if (null === $transliterator = self::$transliterators[$rule] ??= \\Transliterator::create($rule)) {\n                        if ('any-latin/bgn' === $rule) {\n                            $rule = 'any-latin';\n                            $transliterator = self::$transliterators[$rule] ??= \\Transliterator::create($rule);\n                        }\n\n                        if (null === $transliterator) {\n                            throw new InvalidArgumentException(\\sprintf('Unknown transliteration rule \"%s\".', $rule));\n                        }\n\n                        self::$transliterators['any-latin/bgn'] = $transliterator;\n                    }\n\n                    $s = $transliterator->transliterate($s);\n                }\n            } elseif (!\\function_exists('iconv')) {\n                $s = preg_replace('/[^\\x00-\\x7F]/u', '?', $s);\n            } else {\n                $s = @preg_replace_callback('/[^\\x00-\\x7F]/u', static function ($c) {\n                    $c = (string) iconv('UTF-8', 'ASCII//TRANSLIT', $c[0]);\n\n                    if ('' === $c && '' === iconv('UTF-8', 'ASCII//TRANSLIT', '²')) {\n                        throw new \\LogicException(\\sprintf('\"%s\" requires a translit-able iconv implementation, try installing \"gnu-libiconv\" if you\\'re using Alpine Linux.', static::class));\n                    }\n\n                    return 1 < \\strlen($c) ? ltrim($c, '\\'`\"^~') : ('' !== $c ? $c : '?');\n                }, $s);\n            }\n        }\n\n        $str->string .= $s;\n\n        return $str;\n    }\n\n    public function camel(): static\n    {\n        $str = clone $this;\n        $str->string = str_replace(' ', '', preg_replace_callback('/\\b.(?!\\p{Lu})/u', static function ($m) {\n            static $i = 0;\n\n            return 1 === ++$i ? ('İ' === $m[0] ? 'i̇' : mb_strtolower($m[0], 'UTF-8')) : mb_convert_case($m[0], \\MB_CASE_TITLE, 'UTF-8');\n        }, preg_replace('/[^\\pL0-9]++/u', ' ', $this->string)));\n\n        return $str;\n    }\n\n    /**\n     * @return int[]\n     */\n    public function codePointsAt(int $offset): array\n    {\n        $str = $this->slice($offset, 1);\n\n        if ('' === $str->string) {\n            return [];\n        }\n\n        $codePoints = [];\n\n        foreach (preg_split('//u', $str->string, -1, \\PREG_SPLIT_NO_EMPTY) as $c) {\n            $codePoints[] = mb_ord($c, 'UTF-8');\n        }\n\n        return $codePoints;\n    }\n\n    public function folded(bool $compat = true): static\n    {\n        $str = clone $this;\n\n        if (!$compat || !\\defined('Normalizer::NFKC_CF')) {\n            $str->string = normalizer_normalize($str->string, $compat ? \\Normalizer::NFKC : \\Normalizer::NFC);\n            $str->string = mb_strtolower(str_replace(self::FOLD_FROM, self::FOLD_TO, $str->string), 'UTF-8');\n        } else {\n            $str->string = normalizer_normalize($str->string, \\Normalizer::NFKC_CF);\n        }\n\n        return $str;\n    }\n\n    public function join(array $strings, ?string $lastGlue = null): static\n    {\n        $str = clone $this;\n\n        $tail = null !== $lastGlue && 1 < \\count($strings) ? $lastGlue.array_pop($strings) : '';\n        $str->string = implode($this->string, $strings).$tail;\n\n        if (!preg_match('//u', $str->string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        return $str;\n    }\n\n    public function lower(): static\n    {\n        $str = clone $this;\n        $str->string = mb_strtolower(str_replace('İ', 'i̇', $str->string), 'UTF-8');\n\n        return $str;\n    }\n\n    /**\n     * @param string $locale In the format language_region (e.g. tr_TR)\n     */\n    public function localeLower(string $locale): static\n    {\n        if (null !== $transliterator = $this->getLocaleTransliterator($locale, 'Lower')) {\n            $str = clone $this;\n            $str->string = $transliterator->transliterate($str->string);\n\n            return $str;\n        }\n\n        return $this->lower();\n    }\n\n    public function match(string $regexp, int $flags = 0, int $offset = 0): array\n    {\n        $match = ((\\PREG_PATTERN_ORDER | \\PREG_SET_ORDER) & $flags) ? 'preg_match_all' : 'preg_match';\n\n        if ($this->ignoreCase) {\n            $regexp .= 'i';\n        }\n\n        set_error_handler(static fn ($t, $m) => throw new InvalidArgumentException($m));\n\n        try {\n            if (false === $match($regexp.'u', $this->string, $matches, $flags | \\PREG_UNMATCHED_AS_NULL, $offset)) {\n                throw new RuntimeException('Matching failed with error: '.preg_last_error_msg());\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        return $matches;\n    }\n\n    public function normalize(int $form = self::NFC): static\n    {\n        if (!\\in_array($form, [self::NFC, self::NFD, self::NFKC, self::NFKD])) {\n            throw new InvalidArgumentException('Unsupported normalization form.');\n        }\n\n        $str = clone $this;\n        normalizer_is_normalized($str->string, $form) ?: $str->string = normalizer_normalize($str->string, $form);\n\n        return $str;\n    }\n\n    public function padBoth(int $length, string $padStr = ' '): static\n    {\n        if ('' === $padStr || !preg_match('//u', $padStr)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $pad = clone $this;\n        $pad->string = $padStr;\n\n        return $this->pad($length, $pad, \\STR_PAD_BOTH);\n    }\n\n    public function padEnd(int $length, string $padStr = ' '): static\n    {\n        if ('' === $padStr || !preg_match('//u', $padStr)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $pad = clone $this;\n        $pad->string = $padStr;\n\n        return $this->pad($length, $pad, \\STR_PAD_RIGHT);\n    }\n\n    public function padStart(int $length, string $padStr = ' '): static\n    {\n        if ('' === $padStr || !preg_match('//u', $padStr)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $pad = clone $this;\n        $pad->string = $padStr;\n\n        return $this->pad($length, $pad, \\STR_PAD_LEFT);\n    }\n\n    public function replaceMatches(string $fromRegexp, string|callable $to): static\n    {\n        if ($this->ignoreCase) {\n            $fromRegexp .= 'i';\n        }\n\n        if (\\is_array($to) || $to instanceof \\Closure) {\n            $replace = 'preg_replace_callback';\n            $to = static function (array $m) use ($to): string {\n                $to = $to($m);\n\n                if ('' !== $to && (!\\is_string($to) || !preg_match('//u', $to))) {\n                    throw new InvalidArgumentException('Replace callback must return a valid UTF-8 string.');\n                }\n\n                return $to;\n            };\n        } elseif ('' !== $to && !preg_match('//u', $to)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        } else {\n            $replace = 'preg_replace';\n        }\n\n        set_error_handler(static fn ($t, $m) => throw new InvalidArgumentException($m));\n\n        try {\n            if (null === $string = $replace($fromRegexp.'u', $to, $this->string)) {\n                $lastError = preg_last_error();\n\n                foreach (get_defined_constants(true)['pcre'] as $k => $v) {\n                    if ($lastError === $v && str_ends_with($k, '_ERROR')) {\n                        throw new RuntimeException('Matching failed with '.$k.'.');\n                    }\n                }\n\n                throw new RuntimeException('Matching failed with unknown error code.');\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        $str = clone $this;\n        $str->string = $string;\n\n        return $str;\n    }\n\n    public function reverse(): static\n    {\n        $str = clone $this;\n        $str->string = implode('', array_reverse(preg_split('/(\\X)/u', $str->string, -1, \\PREG_SPLIT_DELIM_CAPTURE | \\PREG_SPLIT_NO_EMPTY)));\n\n        return $str;\n    }\n\n    public function snake(): static\n    {\n        $str = $this->camel();\n        $str->string = mb_strtolower(preg_replace(['/(\\p{Lu}+)(\\p{Lu}\\p{Ll})/u', '/([\\p{Ll}0-9])(\\p{Lu})/u'], '\\1_\\2', $str->string), 'UTF-8');\n\n        return $str;\n    }\n\n    public function title(bool $allWords = false): static\n    {\n        $str = clone $this;\n\n        $limit = $allWords ? -1 : 1;\n\n        $str->string = preg_replace_callback('/\\b./u', static fn (array $m): string => mb_convert_case($m[0], \\MB_CASE_TITLE, 'UTF-8'), $str->string, $limit);\n\n        return $str;\n    }\n\n    /**\n     * @param string $locale In the format language_region (e.g. tr_TR)\n     */\n    public function localeTitle(string $locale): static\n    {\n        if (null !== $transliterator = $this->getLocaleTransliterator($locale, 'Title')) {\n            $str = clone $this;\n            $str->string = $transliterator->transliterate($str->string);\n\n            return $str;\n        }\n\n        return $this->title();\n    }\n\n    public function trim(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\"): static\n    {\n        if (\" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\" !== $chars && !preg_match('//u', $chars)) {\n            throw new InvalidArgumentException('Invalid UTF-8 chars.');\n        }\n        $chars = preg_quote($chars);\n\n        $str = clone $this;\n        $str->string = preg_replace(\"{^[$chars]++|[$chars]++$}uD\", '', $str->string);\n\n        return $str;\n    }\n\n    public function trimEnd(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\"): static\n    {\n        if (\" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\" !== $chars && !preg_match('//u', $chars)) {\n            throw new InvalidArgumentException('Invalid UTF-8 chars.');\n        }\n        $chars = preg_quote($chars);\n\n        $str = clone $this;\n        $str->string = preg_replace(\"{[$chars]++$}uD\", '', $str->string);\n\n        return $str;\n    }\n\n    public function trimPrefix($prefix): static\n    {\n        if (!$this->ignoreCase) {\n            return parent::trimPrefix($prefix);\n        }\n\n        $str = clone $this;\n\n        if ($prefix instanceof \\Traversable) {\n            $prefix = iterator_to_array($prefix, false);\n        } elseif ($prefix instanceof parent) {\n            $prefix = $prefix->string;\n        }\n\n        $prefix = implode('|', array_map('preg_quote', (array) $prefix));\n        $str->string = preg_replace(\"{^(?:$prefix)}iuD\", '', $this->string);\n\n        return $str;\n    }\n\n    public function trimStart(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\"): static\n    {\n        if (\" \\t\\n\\r\\0\\x0B\\x0C\\u{A0}\\u{FEFF}\" !== $chars && !preg_match('//u', $chars)) {\n            throw new InvalidArgumentException('Invalid UTF-8 chars.');\n        }\n        $chars = preg_quote($chars);\n\n        $str = clone $this;\n        $str->string = preg_replace(\"{^[$chars]++}uD\", '', $str->string);\n\n        return $str;\n    }\n\n    public function trimSuffix($suffix): static\n    {\n        if (!$this->ignoreCase) {\n            return parent::trimSuffix($suffix);\n        }\n\n        $str = clone $this;\n\n        if ($suffix instanceof \\Traversable) {\n            $suffix = iterator_to_array($suffix, false);\n        } elseif ($suffix instanceof parent) {\n            $suffix = $suffix->string;\n        }\n\n        $suffix = implode('|', array_map('preg_quote', (array) $suffix));\n        $str->string = preg_replace(\"{(?:$suffix)$}iuD\", '', $this->string);\n\n        return $str;\n    }\n\n    public function upper(): static\n    {\n        $str = clone $this;\n        $str->string = mb_strtoupper($str->string, 'UTF-8');\n\n        return $str;\n    }\n\n    /**\n     * @param string $locale In the format language_region (e.g. tr_TR)\n     */\n    public function localeUpper(string $locale): static\n    {\n        if (null !== $transliterator = $this->getLocaleTransliterator($locale, 'Upper')) {\n            $str = clone $this;\n            $str->string = $transliterator->transliterate($str->string);\n\n            return $str;\n        }\n\n        return $this->upper();\n    }\n\n    public function width(bool $ignoreAnsiDecoration = true): int\n    {\n        $width = 0;\n        $s = str_replace([\"\\x00\", \"\\x05\", \"\\x07\"], '', $this->string);\n\n        if (str_contains($s, \"\\r\")) {\n            $s = str_replace([\"\\r\\n\", \"\\r\"], \"\\n\", $s);\n        }\n\n        if (!$ignoreAnsiDecoration) {\n            $s = preg_replace('/[\\p{Cc}\\x7F]++/u', '', $s);\n        }\n\n        foreach (explode(\"\\n\", $s) as $s) {\n            if ($ignoreAnsiDecoration) {\n                $s = preg_replace('/(?:\\x1B(?:\n                    \\[ [\\x30-\\x3F]*+ [\\x20-\\x2F]*+ [\\x40-\\x7E]\n                    | [P\\]X^_] .*? \\x1B\\\\\\\\\n                    | [\\x41-\\x7E]\n                )|[\\p{Cc}\\x7F]++)/xu', '', $s);\n            }\n\n            $lineWidth = $this->wcswidth($s);\n\n            if ($lineWidth > $width) {\n                $width = $lineWidth;\n            }\n        }\n\n        return $width;\n    }\n\n    private function pad(int $len, self $pad, int $type): static\n    {\n        $sLen = $this->length();\n\n        if ($len <= $sLen) {\n            return clone $this;\n        }\n\n        $padLen = $pad->length();\n        $freeLen = $len - $sLen;\n        $len = $freeLen % $padLen;\n\n        switch ($type) {\n            case \\STR_PAD_RIGHT:\n                return $this->append(str_repeat($pad->string, intdiv($freeLen, $padLen)).($len ? $pad->slice(0, $len) : ''));\n\n            case \\STR_PAD_LEFT:\n                return $this->prepend(str_repeat($pad->string, intdiv($freeLen, $padLen)).($len ? $pad->slice(0, $len) : ''));\n\n            case \\STR_PAD_BOTH:\n                $freeLen /= 2;\n\n                $rightLen = ceil($freeLen);\n                $len = $rightLen % $padLen;\n                $str = $this->append(str_repeat($pad->string, intdiv($rightLen, $padLen)).($len ? $pad->slice(0, $len) : ''));\n\n                $leftLen = floor($freeLen);\n                $len = $leftLen % $padLen;\n\n                return $str->prepend(str_repeat($pad->string, intdiv($leftLen, $padLen)).($len ? $pad->slice(0, $len) : ''));\n\n            default:\n                throw new InvalidArgumentException('Invalid padding type.');\n        }\n    }\n\n    /**\n     * Based on https://github.com/jquast/wcwidth, a Python implementation of https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c.\n     */\n    private function wcswidth(string $string): int\n    {\n        $width = 0;\n\n        foreach (preg_split('//u', $string, -1, \\PREG_SPLIT_NO_EMPTY) as $c) {\n            $codePoint = mb_ord($c, 'UTF-8');\n\n            if (0 === $codePoint // NULL\n                || 0x034F === $codePoint // COMBINING GRAPHEME JOINER\n                || (0x200B <= $codePoint && 0x200F >= $codePoint) // ZERO WIDTH SPACE to RIGHT-TO-LEFT MARK\n                || 0x2028 === $codePoint // LINE SEPARATOR\n                || 0x2029 === $codePoint // PARAGRAPH SEPARATOR\n                || (0x202A <= $codePoint && 0x202E >= $codePoint) // LEFT-TO-RIGHT EMBEDDING to RIGHT-TO-LEFT OVERRIDE\n                || (0x2060 <= $codePoint && 0x2063 >= $codePoint) // WORD JOINER to INVISIBLE SEPARATOR\n            ) {\n                continue;\n            }\n\n            // Non printable characters\n            if (32 > $codePoint // C0 control characters\n                || (0x07F <= $codePoint && 0x0A0 > $codePoint) // C1 control characters and DEL\n            ) {\n                return -1;\n            }\n\n            self::$tableZero ??= require __DIR__.'/Resources/data/wcswidth_table_zero.php';\n\n            if ($codePoint >= self::$tableZero[0][0] && $codePoint <= self::$tableZero[$ubound = \\count(self::$tableZero) - 1][1]) {\n                $lbound = 0;\n                while ($ubound >= $lbound) {\n                    $mid = floor(($lbound + $ubound) / 2);\n\n                    if ($codePoint > self::$tableZero[$mid][1]) {\n                        $lbound = $mid + 1;\n                    } elseif ($codePoint < self::$tableZero[$mid][0]) {\n                        $ubound = $mid - 1;\n                    } else {\n                        continue 2;\n                    }\n                }\n            }\n\n            self::$tableWide ??= require __DIR__.'/Resources/data/wcswidth_table_wide.php';\n\n            if ($codePoint >= self::$tableWide[0][0] && $codePoint <= self::$tableWide[$ubound = \\count(self::$tableWide) - 1][1]) {\n                $lbound = 0;\n                while ($ubound >= $lbound) {\n                    $mid = floor(($lbound + $ubound) / 2);\n\n                    if ($codePoint > self::$tableWide[$mid][1]) {\n                        $lbound = $mid + 1;\n                    } elseif ($codePoint < self::$tableWide[$mid][0]) {\n                        $ubound = $mid - 1;\n                    } else {\n                        $width += 2;\n\n                        continue 2;\n                    }\n                }\n            }\n\n            ++$width;\n        }\n\n        return $width;\n    }\n\n    private function getLocaleTransliterator(string $locale, string $id): ?\\Transliterator\n    {\n        $rule = $locale.'-'.$id;\n        if (\\array_key_exists($rule, self::$transliterators)) {\n            return self::$transliterators[$rule];\n        }\n\n        if (null !== $transliterator = self::$transliterators[$rule] = \\Transliterator::create($rule)) {\n            return $transliterator;\n        }\n\n        // Try to find a parent locale (nl_BE -> nl)\n        if (false === $i = strpos($locale, '_')) {\n            return null;\n        }\n\n        $parentRule = substr_replace($locale, '-'.$id, $i);\n\n        // Parent locale was already cached, return and store as current locale\n        if (\\array_key_exists($parentRule, self::$transliterators)) {\n            return self::$transliterators[$rule] = self::$transliterators[$parentRule];\n        }\n\n        // Create transliterator based on parent locale and cache the result on both initial and parent locale values\n        $transliterator = \\Transliterator::create($parentRule);\n\n        return self::$transliterators[$rule] = self::$transliterators[$parentRule] = $transliterator;\n    }\n}\n"
        },
        {
          "name": "ByteString.php",
          "type": "blob",
          "size": 14.462890625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\nuse Random\\Randomizer;\nuse Symfony\\Component\\String\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\String\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\String\\Exception\\RuntimeException;\n\n/**\n * Represents a binary-safe string of bytes.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Hugo Hamon <hugohamon@neuf.fr>\n *\n * @throws ExceptionInterface\n */\nclass ByteString extends AbstractString\n{\n    private const ALPHABET_ALPHANUMERIC = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n    public function __construct(string $string = '')\n    {\n        $this->string = $string;\n    }\n\n    /*\n     * The following method was derived from code of the Hack Standard Library (v4.40 - 2020-05-03)\n     *\n     * https://github.com/hhvm/hsl/blob/80a42c02f036f72a42f0415e80d6b847f4bf62d5/src/random/private.php#L16\n     *\n     * Code subject to the MIT license (https://github.com/hhvm/hsl/blob/master/LICENSE).\n     *\n     * Copyright (c) 2004-2020, Facebook, Inc. (https://www.facebook.com/)\n     */\n\n    public static function fromRandom(int $length = 16, ?string $alphabet = null): self\n    {\n        if ($length <= 0) {\n            throw new InvalidArgumentException(\\sprintf('A strictly positive length is expected, \"%d\" given.', $length));\n        }\n\n        $alphabet ??= self::ALPHABET_ALPHANUMERIC;\n        $alphabetSize = \\strlen($alphabet);\n        $bits = (int) ceil(log($alphabetSize, 2.0));\n        if ($bits <= 0 || $bits > 56) {\n            throw new InvalidArgumentException('The length of the alphabet must in the [2^1, 2^56] range.');\n        }\n\n        if (\\PHP_VERSION_ID >= 80300) {\n            return new static((new Randomizer())->getBytesFromString($alphabet, $length));\n        }\n\n        $ret = '';\n        while ($length > 0) {\n            $urandomLength = (int) ceil(2 * $length * $bits / 8.0);\n            $data = random_bytes($urandomLength);\n            $unpackedData = 0;\n            $unpackedBits = 0;\n            for ($i = 0; $i < $urandomLength && $length > 0; ++$i) {\n                // Unpack 8 bits\n                $unpackedData = ($unpackedData << 8) | \\ord($data[$i]);\n                $unpackedBits += 8;\n\n                // While we have enough bits to select a character from the alphabet, keep\n                // consuming the random data\n                for (; $unpackedBits >= $bits && $length > 0; $unpackedBits -= $bits) {\n                    $index = ($unpackedData & ((1 << $bits) - 1));\n                    $unpackedData >>= $bits;\n                    // Unfortunately, the alphabet size is not necessarily a power of two.\n                    // Worst case, it is 2^k + 1, which means we need (k+1) bits and we\n                    // have around a 50% chance of missing as k gets larger\n                    if ($index < $alphabetSize) {\n                        $ret .= $alphabet[$index];\n                        --$length;\n                    }\n                }\n            }\n        }\n\n        return new static($ret);\n    }\n\n    public function bytesAt(int $offset): array\n    {\n        $str = $this->string[$offset] ?? '';\n\n        return '' === $str ? [] : [\\ord($str)];\n    }\n\n    public function append(string ...$suffix): static\n    {\n        $str = clone $this;\n        $str->string .= 1 >= \\count($suffix) ? ($suffix[0] ?? '') : implode('', $suffix);\n\n        return $str;\n    }\n\n    public function camel(): static\n    {\n        $str = clone $this;\n\n        $parts = explode(' ', trim(ucwords(preg_replace('/[^a-zA-Z0-9\\x7f-\\xff]++/', ' ', $this->string))));\n        $parts[0] = 1 !== \\strlen($parts[0]) && ctype_upper($parts[0]) ? $parts[0] : lcfirst($parts[0]);\n        $str->string = implode('', $parts);\n\n        return $str;\n    }\n\n    public function chunk(int $length = 1): array\n    {\n        if (1 > $length) {\n            throw new InvalidArgumentException('The chunk length must be greater than zero.');\n        }\n\n        if ('' === $this->string) {\n            return [];\n        }\n\n        $str = clone $this;\n        $chunks = [];\n\n        foreach (str_split($this->string, $length) as $chunk) {\n            $str->string = $chunk;\n            $chunks[] = clone $str;\n        }\n\n        return $chunks;\n    }\n\n    public function endsWith(string|iterable|AbstractString $suffix): bool\n    {\n        if ($suffix instanceof AbstractString) {\n            $suffix = $suffix->string;\n        } elseif (!\\is_string($suffix)) {\n            return parent::endsWith($suffix);\n        }\n\n        return '' !== $suffix && \\strlen($this->string) >= \\strlen($suffix) && 0 === substr_compare($this->string, $suffix, -\\strlen($suffix), null, $this->ignoreCase);\n    }\n\n    public function equalsTo(string|iterable|AbstractString $string): bool\n    {\n        if ($string instanceof AbstractString) {\n            $string = $string->string;\n        } elseif (!\\is_string($string)) {\n            return parent::equalsTo($string);\n        }\n\n        if ('' !== $string && $this->ignoreCase) {\n            return 0 === strcasecmp($string, $this->string);\n        }\n\n        return $string === $this->string;\n    }\n\n    public function folded(): static\n    {\n        $str = clone $this;\n        $str->string = strtolower($str->string);\n\n        return $str;\n    }\n\n    public function indexOf(string|iterable|AbstractString $needle, int $offset = 0): ?int\n    {\n        if ($needle instanceof AbstractString) {\n            $needle = $needle->string;\n        } elseif (!\\is_string($needle)) {\n            return parent::indexOf($needle, $offset);\n        }\n\n        if ('' === $needle) {\n            return null;\n        }\n\n        $i = $this->ignoreCase ? stripos($this->string, $needle, $offset) : strpos($this->string, $needle, $offset);\n\n        return false === $i ? null : $i;\n    }\n\n    public function indexOfLast(string|iterable|AbstractString $needle, int $offset = 0): ?int\n    {\n        if ($needle instanceof AbstractString) {\n            $needle = $needle->string;\n        } elseif (!\\is_string($needle)) {\n            return parent::indexOfLast($needle, $offset);\n        }\n\n        if ('' === $needle) {\n            return null;\n        }\n\n        $i = $this->ignoreCase ? strripos($this->string, $needle, $offset) : strrpos($this->string, $needle, $offset);\n\n        return false === $i ? null : $i;\n    }\n\n    public function isUtf8(): bool\n    {\n        return '' === $this->string || preg_match('//u', $this->string);\n    }\n\n    public function join(array $strings, ?string $lastGlue = null): static\n    {\n        $str = clone $this;\n\n        $tail = null !== $lastGlue && 1 < \\count($strings) ? $lastGlue.array_pop($strings) : '';\n        $str->string = implode($this->string, $strings).$tail;\n\n        return $str;\n    }\n\n    public function length(): int\n    {\n        return \\strlen($this->string);\n    }\n\n    public function lower(): static\n    {\n        $str = clone $this;\n        $str->string = strtolower($str->string);\n\n        return $str;\n    }\n\n    public function match(string $regexp, int $flags = 0, int $offset = 0): array\n    {\n        $match = ((\\PREG_PATTERN_ORDER | \\PREG_SET_ORDER) & $flags) ? 'preg_match_all' : 'preg_match';\n\n        if ($this->ignoreCase) {\n            $regexp .= 'i';\n        }\n\n        set_error_handler(static fn ($t, $m) => throw new InvalidArgumentException($m));\n\n        try {\n            if (false === $match($regexp, $this->string, $matches, $flags | \\PREG_UNMATCHED_AS_NULL, $offset)) {\n                throw new RuntimeException('Matching failed with error: '.preg_last_error_msg());\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        return $matches;\n    }\n\n    public function padBoth(int $length, string $padStr = ' '): static\n    {\n        $str = clone $this;\n        $str->string = str_pad($this->string, $length, $padStr, \\STR_PAD_BOTH);\n\n        return $str;\n    }\n\n    public function padEnd(int $length, string $padStr = ' '): static\n    {\n        $str = clone $this;\n        $str->string = str_pad($this->string, $length, $padStr, \\STR_PAD_RIGHT);\n\n        return $str;\n    }\n\n    public function padStart(int $length, string $padStr = ' '): static\n    {\n        $str = clone $this;\n        $str->string = str_pad($this->string, $length, $padStr, \\STR_PAD_LEFT);\n\n        return $str;\n    }\n\n    public function prepend(string ...$prefix): static\n    {\n        $str = clone $this;\n        $str->string = (1 >= \\count($prefix) ? ($prefix[0] ?? '') : implode('', $prefix)).$str->string;\n\n        return $str;\n    }\n\n    public function replace(string $from, string $to): static\n    {\n        $str = clone $this;\n\n        if ('' !== $from) {\n            $str->string = $this->ignoreCase ? str_ireplace($from, $to, $this->string) : str_replace($from, $to, $this->string);\n        }\n\n        return $str;\n    }\n\n    public function replaceMatches(string $fromRegexp, string|callable $to): static\n    {\n        if ($this->ignoreCase) {\n            $fromRegexp .= 'i';\n        }\n\n        $replace = \\is_array($to) || $to instanceof \\Closure ? 'preg_replace_callback' : 'preg_replace';\n\n        set_error_handler(static fn ($t, $m) => throw new InvalidArgumentException($m));\n\n        try {\n            if (null === $string = $replace($fromRegexp, $to, $this->string)) {\n                $lastError = preg_last_error();\n\n                foreach (get_defined_constants(true)['pcre'] as $k => $v) {\n                    if ($lastError === $v && str_ends_with($k, '_ERROR')) {\n                        throw new RuntimeException('Matching failed with '.$k.'.');\n                    }\n                }\n\n                throw new RuntimeException('Matching failed with unknown error code.');\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        $str = clone $this;\n        $str->string = $string;\n\n        return $str;\n    }\n\n    public function reverse(): static\n    {\n        $str = clone $this;\n        $str->string = strrev($str->string);\n\n        return $str;\n    }\n\n    public function slice(int $start = 0, ?int $length = null): static\n    {\n        $str = clone $this;\n        $str->string = substr($this->string, $start, $length ?? \\PHP_INT_MAX);\n\n        return $str;\n    }\n\n    public function snake(): static\n    {\n        $str = $this->camel();\n        $str->string = strtolower(preg_replace(['/([A-Z]+)([A-Z][a-z])/', '/([a-z\\d])([A-Z])/'], '\\1_\\2', $str->string));\n\n        return $str;\n    }\n\n    public function splice(string $replacement, int $start = 0, ?int $length = null): static\n    {\n        $str = clone $this;\n        $str->string = substr_replace($this->string, $replacement, $start, $length ?? \\PHP_INT_MAX);\n\n        return $str;\n    }\n\n    public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array\n    {\n        if (1 > $limit ??= \\PHP_INT_MAX) {\n            throw new InvalidArgumentException('Split limit must be a positive integer.');\n        }\n\n        if ('' === $delimiter) {\n            throw new InvalidArgumentException('Split delimiter is empty.');\n        }\n\n        if (null !== $flags) {\n            return parent::split($delimiter, $limit, $flags);\n        }\n\n        $str = clone $this;\n        $chunks = $this->ignoreCase\n            ? preg_split('{'.preg_quote($delimiter).'}iD', $this->string, $limit)\n            : explode($delimiter, $this->string, $limit);\n\n        foreach ($chunks as &$chunk) {\n            $str->string = $chunk;\n            $chunk = clone $str;\n        }\n\n        return $chunks;\n    }\n\n    public function startsWith(string|iterable|AbstractString $prefix): bool\n    {\n        if ($prefix instanceof AbstractString) {\n            $prefix = $prefix->string;\n        } elseif (!\\is_string($prefix)) {\n            return parent::startsWith($prefix);\n        }\n\n        return '' !== $prefix && 0 === ($this->ignoreCase ? strncasecmp($this->string, $prefix, \\strlen($prefix)) : strncmp($this->string, $prefix, \\strlen($prefix)));\n    }\n\n    public function title(bool $allWords = false): static\n    {\n        $str = clone $this;\n        $str->string = $allWords ? ucwords($str->string) : ucfirst($str->string);\n\n        return $str;\n    }\n\n    public function toUnicodeString(?string $fromEncoding = null): UnicodeString\n    {\n        return new UnicodeString($this->toCodePointString($fromEncoding)->string);\n    }\n\n    public function toCodePointString(?string $fromEncoding = null): CodePointString\n    {\n        $u = new CodePointString();\n\n        if (\\in_array($fromEncoding, [null, 'utf8', 'utf-8', 'UTF8', 'UTF-8'], true) && preg_match('//u', $this->string)) {\n            $u->string = $this->string;\n\n            return $u;\n        }\n\n        set_error_handler(static fn ($t, $m) => throw new InvalidArgumentException($m));\n\n        try {\n            try {\n                $validEncoding = false !== mb_detect_encoding($this->string, $fromEncoding ?? 'Windows-1252', true);\n            } catch (InvalidArgumentException $e) {\n                if (!\\function_exists('iconv')) {\n                    throw $e;\n                }\n\n                $u->string = iconv($fromEncoding ?? 'Windows-1252', 'UTF-8', $this->string);\n\n                return $u;\n            }\n        } finally {\n            restore_error_handler();\n        }\n\n        if (!$validEncoding) {\n            throw new InvalidArgumentException(\\sprintf('Invalid \"%s\" string.', $fromEncoding ?? 'Windows-1252'));\n        }\n\n        $u->string = mb_convert_encoding($this->string, 'UTF-8', $fromEncoding ?? 'Windows-1252');\n\n        return $u;\n    }\n\n    public function trim(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\"): static\n    {\n        $str = clone $this;\n        $str->string = trim($str->string, $chars);\n\n        return $str;\n    }\n\n    public function trimEnd(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\"): static\n    {\n        $str = clone $this;\n        $str->string = rtrim($str->string, $chars);\n\n        return $str;\n    }\n\n    public function trimStart(string $chars = \" \\t\\n\\r\\0\\x0B\\x0C\"): static\n    {\n        $str = clone $this;\n        $str->string = ltrim($str->string, $chars);\n\n        return $str;\n    }\n\n    public function upper(): static\n    {\n        $str = clone $this;\n        $str->string = strtoupper($str->string);\n\n        return $str;\n    }\n\n    public function width(bool $ignoreAnsiDecoration = true): int\n    {\n        $string = preg_match('//u', $this->string) ? $this->string : preg_replace('/[\\x80-\\xFF]/', '?', $this->string);\n\n        return (new CodePointString($string))->width($ignoreAnsiDecoration);\n    }\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.0791015625,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add `TruncateMode` enum to handle more truncate methods\n * Add the `AbstractString::kebab()` method\n\n7.1\n---\n\n * Add `localeLower()`, `localeUpper()`, `localeTitle()` methods to `AbstractUnicodeString`\n\n6.2\n---\n\n  * Add support for emoji in `AsciiSlugger`\n\n5.4\n---\n\n * Add `trimSuffix()` and `trimPrefix()` methods\n\n5.3\n---\n\n * Made `AsciiSlugger` fallback to parent locale's symbolsMap\n\n5.2.0\n-----\n\n * added a `FrenchInflector` class\n\n5.1.0\n-----\n\n * added the `AbstractString::reverse()` method\n * made `AbstractString::width()` follow POSIX.1-2001\n * added `LazyString` which provides memoizing stringable objects\n * The component is not marked as `@experimental` anymore\n * added the `s()` helper method to get either an `UnicodeString` or `ByteString` instance,\n   depending of the input string UTF-8 compliancy\n * added `$cut` parameter to `Symfony\\Component\\String\\AbstractString::truncate()`\n * added `AbstractString::containsAny()`\n * allow passing a string of custom characters to `ByteString::fromRandom()`\n\n5.0.0\n-----\n\n * added the component as experimental\n"
        },
        {
          "name": "CodePointString.php",
          "type": "blob",
          "size": 7.5390625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\nuse Symfony\\Component\\String\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\String\\Exception\\InvalidArgumentException;\n\n/**\n * Represents a string of Unicode code points encoded as UTF-8.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Hugo Hamon <hugohamon@neuf.fr>\n *\n * @throws ExceptionInterface\n */\nclass CodePointString extends AbstractUnicodeString\n{\n    public function __construct(string $string = '')\n    {\n        if ('' !== $string && !preg_match('//u', $string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $this->string = $string;\n    }\n\n    public function append(string ...$suffix): static\n    {\n        $str = clone $this;\n        $str->string .= 1 >= \\count($suffix) ? ($suffix[0] ?? '') : implode('', $suffix);\n\n        if (!preg_match('//u', $str->string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        return $str;\n    }\n\n    public function chunk(int $length = 1): array\n    {\n        if (1 > $length) {\n            throw new InvalidArgumentException('The chunk length must be greater than zero.');\n        }\n\n        if ('' === $this->string) {\n            return [];\n        }\n\n        $rx = '/(';\n        while (65535 < $length) {\n            $rx .= '.{65535}';\n            $length -= 65535;\n        }\n        $rx .= '.{'.$length.'})/us';\n\n        $str = clone $this;\n        $chunks = [];\n\n        foreach (preg_split($rx, $this->string, -1, \\PREG_SPLIT_DELIM_CAPTURE | \\PREG_SPLIT_NO_EMPTY) as $chunk) {\n            $str->string = $chunk;\n            $chunks[] = clone $str;\n        }\n\n        return $chunks;\n    }\n\n    public function codePointsAt(int $offset): array\n    {\n        $str = $offset ? $this->slice($offset, 1) : $this;\n\n        return '' === $str->string ? [] : [mb_ord($str->string, 'UTF-8')];\n    }\n\n    public function endsWith(string|iterable|AbstractString $suffix): bool\n    {\n        if ($suffix instanceof AbstractString) {\n            $suffix = $suffix->string;\n        } elseif (!\\is_string($suffix)) {\n            return parent::endsWith($suffix);\n        }\n\n        if ('' === $suffix || !preg_match('//u', $suffix)) {\n            return false;\n        }\n\n        if ($this->ignoreCase) {\n            return preg_match('{'.preg_quote($suffix).'$}iuD', $this->string);\n        }\n\n        return \\strlen($this->string) >= \\strlen($suffix) && 0 === substr_compare($this->string, $suffix, -\\strlen($suffix));\n    }\n\n    public function equalsTo(string|iterable|AbstractString $string): bool\n    {\n        if ($string instanceof AbstractString) {\n            $string = $string->string;\n        } elseif (!\\is_string($string)) {\n            return parent::equalsTo($string);\n        }\n\n        if ('' !== $string && $this->ignoreCase) {\n            return \\strlen($string) === \\strlen($this->string) && 0 === mb_stripos($this->string, $string, 0, 'UTF-8');\n        }\n\n        return $string === $this->string;\n    }\n\n    public function indexOf(string|iterable|AbstractString $needle, int $offset = 0): ?int\n    {\n        if ($needle instanceof AbstractString) {\n            $needle = $needle->string;\n        } elseif (!\\is_string($needle)) {\n            return parent::indexOf($needle, $offset);\n        }\n\n        if ('' === $needle) {\n            return null;\n        }\n\n        $i = $this->ignoreCase ? mb_stripos($this->string, $needle, $offset, 'UTF-8') : mb_strpos($this->string, $needle, $offset, 'UTF-8');\n\n        return false === $i ? null : $i;\n    }\n\n    public function indexOfLast(string|iterable|AbstractString $needle, int $offset = 0): ?int\n    {\n        if ($needle instanceof AbstractString) {\n            $needle = $needle->string;\n        } elseif (!\\is_string($needle)) {\n            return parent::indexOfLast($needle, $offset);\n        }\n\n        if ('' === $needle) {\n            return null;\n        }\n\n        $i = $this->ignoreCase ? mb_strripos($this->string, $needle, $offset, 'UTF-8') : mb_strrpos($this->string, $needle, $offset, 'UTF-8');\n\n        return false === $i ? null : $i;\n    }\n\n    public function length(): int\n    {\n        return mb_strlen($this->string, 'UTF-8');\n    }\n\n    public function prepend(string ...$prefix): static\n    {\n        $str = clone $this;\n        $str->string = (1 >= \\count($prefix) ? ($prefix[0] ?? '') : implode('', $prefix)).$this->string;\n\n        if (!preg_match('//u', $str->string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        return $str;\n    }\n\n    public function replace(string $from, string $to): static\n    {\n        $str = clone $this;\n\n        if ('' === $from || !preg_match('//u', $from)) {\n            return $str;\n        }\n\n        if ('' !== $to && !preg_match('//u', $to)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        if ($this->ignoreCase) {\n            $str->string = implode($to, preg_split('{'.preg_quote($from).'}iuD', $this->string));\n        } else {\n            $str->string = str_replace($from, $to, $this->string);\n        }\n\n        return $str;\n    }\n\n    public function slice(int $start = 0, ?int $length = null): static\n    {\n        $str = clone $this;\n        $str->string = mb_substr($this->string, $start, $length, 'UTF-8');\n\n        return $str;\n    }\n\n    public function splice(string $replacement, int $start = 0, ?int $length = null): static\n    {\n        if (!preg_match('//u', $replacement)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $str = clone $this;\n        $start = $start ? \\strlen(mb_substr($this->string, 0, $start, 'UTF-8')) : 0;\n        $length = $length ? \\strlen(mb_substr($this->string, $start, $length, 'UTF-8')) : $length;\n        $str->string = substr_replace($this->string, $replacement, $start, $length ?? \\PHP_INT_MAX);\n\n        return $str;\n    }\n\n    public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array\n    {\n        if (1 > $limit ??= \\PHP_INT_MAX) {\n            throw new InvalidArgumentException('Split limit must be a positive integer.');\n        }\n\n        if ('' === $delimiter) {\n            throw new InvalidArgumentException('Split delimiter is empty.');\n        }\n\n        if (null !== $flags) {\n            return parent::split($delimiter.'u', $limit, $flags);\n        }\n\n        if (!preg_match('//u', $delimiter)) {\n            throw new InvalidArgumentException('Split delimiter is not a valid UTF-8 string.');\n        }\n\n        $str = clone $this;\n        $chunks = $this->ignoreCase\n            ? preg_split('{'.preg_quote($delimiter).'}iuD', $this->string, $limit)\n            : explode($delimiter, $this->string, $limit);\n\n        foreach ($chunks as &$chunk) {\n            $str->string = $chunk;\n            $chunk = clone $str;\n        }\n\n        return $chunks;\n    }\n\n    public function startsWith(string|iterable|AbstractString $prefix): bool\n    {\n        if ($prefix instanceof AbstractString) {\n            $prefix = $prefix->string;\n        } elseif (!\\is_string($prefix)) {\n            return parent::startsWith($prefix);\n        }\n\n        if ('' === $prefix || !preg_match('//u', $prefix)) {\n            return false;\n        }\n\n        if ($this->ignoreCase) {\n            return 0 === mb_stripos($this->string, $prefix, 0, 'UTF-8');\n        }\n\n        return 0 === strncmp($this->string, $prefix, \\strlen($prefix));\n    }\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "Inflector",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2019-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "LazyString.php",
          "type": "blob",
          "size": 4.287109375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\n/**\n * A string whose value is computed lazily by a callback.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass LazyString implements \\Stringable, \\JsonSerializable\n{\n    private \\Closure|string $value;\n\n    /**\n     * @param callable|array $callback A callable or a [Closure, method] lazy-callable\n     */\n    public static function fromCallable(callable|array $callback, mixed ...$arguments): static\n    {\n        if (\\is_array($callback) && !\\is_callable($callback) && !(($callback[0] ?? null) instanceof \\Closure || 2 < \\count($callback))) {\n            throw new \\TypeError(\\sprintf('Argument 1 passed to \"%s()\" must be a callable or a [Closure, method] lazy-callable, \"%s\" given.', __METHOD__, '['.implode(', ', array_map('get_debug_type', $callback)).']'));\n        }\n\n        $lazyString = new static();\n        $lazyString->value = static function () use (&$callback, &$arguments): string {\n            static $value;\n\n            if (null !== $arguments) {\n                if (!\\is_callable($callback)) {\n                    $callback[0] = $callback[0]();\n                    $callback[1] ??= '__invoke';\n                }\n                $value = $callback(...$arguments);\n                $callback = !\\is_scalar($value) && !$value instanceof \\Stringable ? self::getPrettyName($callback) : 'callable';\n                $arguments = null;\n            }\n\n            return $value ?? '';\n        };\n\n        return $lazyString;\n    }\n\n    public static function fromStringable(string|int|float|bool|\\Stringable $value): static\n    {\n        if (\\is_object($value)) {\n            return static::fromCallable($value->__toString(...));\n        }\n\n        $lazyString = new static();\n        $lazyString->value = (string) $value;\n\n        return $lazyString;\n    }\n\n    /**\n     * Tells whether the provided value can be cast to string.\n     */\n    final public static function isStringable(mixed $value): bool\n    {\n        return \\is_string($value) || $value instanceof \\Stringable || \\is_scalar($value);\n    }\n\n    /**\n     * Casts scalars and stringable objects to strings.\n     *\n     * @throws \\TypeError When the provided value is not stringable\n     */\n    final public static function resolve(\\Stringable|string|int|float|bool $value): string\n    {\n        return $value;\n    }\n\n    public function __toString(): string\n    {\n        if (\\is_string($this->value)) {\n            return $this->value;\n        }\n\n        try {\n            return $this->value = ($this->value)();\n        } catch (\\Throwable $e) {\n            if (\\TypeError::class === $e::class && __FILE__ === $e->getFile()) {\n                $type = explode(', ', $e->getMessage());\n                $type = substr(array_pop($type), 0, -\\strlen(' returned'));\n                $r = new \\ReflectionFunction($this->value);\n                $callback = $r->getStaticVariables()['callback'];\n\n                $e = new \\TypeError(\\sprintf('Return value of %s() passed to %s::fromCallable() must be of the type string, %s returned.', $callback, static::class, $type));\n            }\n\n            throw $e;\n        }\n    }\n\n    public function __sleep(): array\n    {\n        $this->__toString();\n\n        return ['value'];\n    }\n\n    public function jsonSerialize(): string\n    {\n        return $this->__toString();\n    }\n\n    private function __construct()\n    {\n    }\n\n    private static function getPrettyName(callable $callback): string\n    {\n        if (\\is_string($callback)) {\n            return $callback;\n        }\n\n        if (\\is_array($callback)) {\n            $class = \\is_object($callback[0]) ? get_debug_type($callback[0]) : $callback[0];\n            $method = $callback[1];\n        } elseif ($callback instanceof \\Closure) {\n            $r = new \\ReflectionFunction($callback);\n\n            if ($r->isAnonymous() || !$class = $r->getClosureCalledClass()) {\n                return $r->name;\n            }\n\n            $class = $class->name;\n            $method = $r->name;\n        } else {\n            $class = get_debug_type($callback);\n            $method = '__invoke';\n        }\n\n        return $class.'::'.$method;\n    }\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5419921875,
          "content": "String Component\n================\n\nThe String component provides an object-oriented API to strings and deals\nwith bytes, UTF-8 code points and grapheme clusters in a unified way.\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/string.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n"
        },
        {
          "name": "Resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "Slugger",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "TruncateMode.php",
          "type": "blob",
          "size": 0.8818359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\nenum TruncateMode\n{\n    /**\n     * Will cut exactly at given length.\n     *\n     * Length: 14\n     * Source: Lorem ipsum dolor sit amet\n     * Output: Lorem ipsum do\n     */\n    case Char;\n\n    /**\n     * Returns the string up to the last complete word containing the specified length.\n     *\n     * Length: 14\n     * Source: Lorem ipsum dolor sit amet\n     * Output: Lorem ipsum\n     */\n    case WordBefore;\n\n    /**\n     * Returns the string up to the complete word after or at the given length.\n     *\n     * Length: 14\n     * Source: Lorem ipsum dolor sit amet\n     * Output: Lorem ipsum dolor\n     */\n    case WordAfter;\n}\n"
        },
        {
          "name": "UnicodeString.php",
          "type": "blob",
          "size": 12.224609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\String;\n\nuse Symfony\\Component\\String\\Exception\\ExceptionInterface;\nuse Symfony\\Component\\String\\Exception\\InvalidArgumentException;\n\n/**\n * Represents a string of Unicode grapheme clusters encoded as UTF-8.\n *\n * A letter followed by combining characters (accents typically) form what Unicode defines\n * as a grapheme cluster: a character as humans mean it in written texts. This class knows\n * about the concept and won't split a letter apart from its combining accents. It also\n * ensures all string comparisons happen on their canonically-composed representation,\n * ignoring e.g. the order in which accents are listed when a letter has many of them.\n *\n * @see https://unicode.org/reports/tr15/\n *\n * @author Nicolas Grekas <p@tchwork.com>\n * @author Hugo Hamon <hugohamon@neuf.fr>\n *\n * @throws ExceptionInterface\n */\nclass UnicodeString extends AbstractUnicodeString\n{\n    public function __construct(string $string = '')\n    {\n        if ('' === $string || normalizer_is_normalized($this->string = $string)) {\n            return;\n        }\n\n        if (false === $string = normalizer_normalize($string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $this->string = $string;\n    }\n\n    public function append(string ...$suffix): static\n    {\n        $str = clone $this;\n        $str->string = $this->string.(1 >= \\count($suffix) ? ($suffix[0] ?? '') : implode('', $suffix));\n\n        if (normalizer_is_normalized($str->string)) {\n            return $str;\n        }\n\n        if (false === $string = normalizer_normalize($str->string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $str->string = $string;\n\n        return $str;\n    }\n\n    public function chunk(int $length = 1): array\n    {\n        if (1 > $length) {\n            throw new InvalidArgumentException('The chunk length must be greater than zero.');\n        }\n\n        if ('' === $this->string) {\n            return [];\n        }\n\n        $rx = '/(';\n        while (65535 < $length) {\n            $rx .= '\\X{65535}';\n            $length -= 65535;\n        }\n        $rx .= '\\X{'.$length.'})/u';\n\n        $str = clone $this;\n        $chunks = [];\n\n        foreach (preg_split($rx, $this->string, -1, \\PREG_SPLIT_DELIM_CAPTURE | \\PREG_SPLIT_NO_EMPTY) as $chunk) {\n            $str->string = $chunk;\n            $chunks[] = clone $str;\n        }\n\n        return $chunks;\n    }\n\n    public function endsWith(string|iterable|AbstractString $suffix): bool\n    {\n        if ($suffix instanceof AbstractString) {\n            $suffix = $suffix->string;\n        } elseif (!\\is_string($suffix)) {\n            return parent::endsWith($suffix);\n        }\n\n        $form = null === $this->ignoreCase ? \\Normalizer::NFD : \\Normalizer::NFC;\n        normalizer_is_normalized($suffix, $form) ?: $suffix = normalizer_normalize($suffix, $form);\n\n        if ('' === $suffix || false === $suffix) {\n            return false;\n        }\n\n        if ($this->ignoreCase) {\n            return 0 === mb_stripos(grapheme_extract($this->string, \\strlen($suffix), \\GRAPHEME_EXTR_MAXBYTES, \\strlen($this->string) - \\strlen($suffix)), $suffix, 0, 'UTF-8');\n        }\n\n        return $suffix === grapheme_extract($this->string, \\strlen($suffix), \\GRAPHEME_EXTR_MAXBYTES, \\strlen($this->string) - \\strlen($suffix));\n    }\n\n    public function equalsTo(string|iterable|AbstractString $string): bool\n    {\n        if ($string instanceof AbstractString) {\n            $string = $string->string;\n        } elseif (!\\is_string($string)) {\n            return parent::equalsTo($string);\n        }\n\n        $form = null === $this->ignoreCase ? \\Normalizer::NFD : \\Normalizer::NFC;\n        normalizer_is_normalized($string, $form) ?: $string = normalizer_normalize($string, $form);\n\n        if ('' !== $string && false !== $string && $this->ignoreCase) {\n            return \\strlen($string) === \\strlen($this->string) && 0 === mb_stripos($this->string, $string, 0, 'UTF-8');\n        }\n\n        return $string === $this->string;\n    }\n\n    public function indexOf(string|iterable|AbstractString $needle, int $offset = 0): ?int\n    {\n        if ($needle instanceof AbstractString) {\n            $needle = $needle->string;\n        } elseif (!\\is_string($needle)) {\n            return parent::indexOf($needle, $offset);\n        }\n\n        $form = null === $this->ignoreCase ? \\Normalizer::NFD : \\Normalizer::NFC;\n        normalizer_is_normalized($needle, $form) ?: $needle = normalizer_normalize($needle, $form);\n\n        if ('' === $needle || false === $needle) {\n            return null;\n        }\n\n        try {\n            $i = $this->ignoreCase ? grapheme_stripos($this->string, $needle, $offset) : grapheme_strpos($this->string, $needle, $offset);\n        } catch (\\ValueError) {\n            return null;\n        }\n\n        return false === $i ? null : $i;\n    }\n\n    public function indexOfLast(string|iterable|AbstractString $needle, int $offset = 0): ?int\n    {\n        if ($needle instanceof AbstractString) {\n            $needle = $needle->string;\n        } elseif (!\\is_string($needle)) {\n            return parent::indexOfLast($needle, $offset);\n        }\n\n        $form = null === $this->ignoreCase ? \\Normalizer::NFD : \\Normalizer::NFC;\n        normalizer_is_normalized($needle, $form) ?: $needle = normalizer_normalize($needle, $form);\n\n        if ('' === $needle || false === $needle) {\n            return null;\n        }\n\n        $string = $this->string;\n\n        if (0 > $offset) {\n            // workaround https://bugs.php.net/74264\n            if (0 > $offset += grapheme_strlen($needle)) {\n                $string = grapheme_substr($string, 0, $offset);\n            }\n            $offset = 0;\n        }\n\n        $i = $this->ignoreCase ? grapheme_strripos($string, $needle, $offset) : grapheme_strrpos($string, $needle, $offset);\n\n        return false === $i ? null : $i;\n    }\n\n    public function join(array $strings, ?string $lastGlue = null): static\n    {\n        $str = parent::join($strings, $lastGlue);\n        normalizer_is_normalized($str->string) ?: $str->string = normalizer_normalize($str->string);\n\n        return $str;\n    }\n\n    public function length(): int\n    {\n        return grapheme_strlen($this->string);\n    }\n\n    public function normalize(int $form = self::NFC): static\n    {\n        $str = clone $this;\n\n        if (\\in_array($form, [self::NFC, self::NFKC], true)) {\n            normalizer_is_normalized($str->string, $form) ?: $str->string = normalizer_normalize($str->string, $form);\n        } elseif (!\\in_array($form, [self::NFD, self::NFKD], true)) {\n            throw new InvalidArgumentException('Unsupported normalization form.');\n        } elseif (!normalizer_is_normalized($str->string, $form)) {\n            $str->string = normalizer_normalize($str->string, $form);\n            $str->ignoreCase = null;\n        }\n\n        return $str;\n    }\n\n    public function prepend(string ...$prefix): static\n    {\n        $str = clone $this;\n        $str->string = (1 >= \\count($prefix) ? ($prefix[0] ?? '') : implode('', $prefix)).$this->string;\n\n        if (normalizer_is_normalized($str->string)) {\n            return $str;\n        }\n\n        if (false === $string = normalizer_normalize($str->string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $str->string = $string;\n\n        return $str;\n    }\n\n    public function replace(string $from, string $to): static\n    {\n        $str = clone $this;\n        normalizer_is_normalized($from) ?: $from = normalizer_normalize($from);\n\n        if ('' !== $from && false !== $from) {\n            $tail = $str->string;\n            $result = '';\n            $indexOf = $this->ignoreCase ? 'grapheme_stripos' : 'grapheme_strpos';\n\n            while ('' !== $tail && false !== $i = $indexOf($tail, $from)) {\n                $slice = grapheme_substr($tail, 0, $i);\n                $result .= $slice.$to;\n                $tail = substr($tail, \\strlen($slice) + \\strlen($from));\n            }\n\n            $str->string = $result.$tail;\n\n            if (normalizer_is_normalized($str->string)) {\n                return $str;\n            }\n\n            if (false === $string = normalizer_normalize($str->string)) {\n                throw new InvalidArgumentException('Invalid UTF-8 string.');\n            }\n\n            $str->string = $string;\n        }\n\n        return $str;\n    }\n\n    public function replaceMatches(string $fromRegexp, string|callable $to): static\n    {\n        $str = parent::replaceMatches($fromRegexp, $to);\n        normalizer_is_normalized($str->string) ?: $str->string = normalizer_normalize($str->string);\n\n        return $str;\n    }\n\n    public function slice(int $start = 0, ?int $length = null): static\n    {\n        $str = clone $this;\n\n        $str->string = (string) grapheme_substr($this->string, $start, $length ?? 2147483647);\n\n        return $str;\n    }\n\n    public function splice(string $replacement, int $start = 0, ?int $length = null): static\n    {\n        $str = clone $this;\n\n        $start = $start ? \\strlen(grapheme_substr($this->string, 0, $start)) : 0;\n        $length = $length ? \\strlen(grapheme_substr($this->string, $start, $length)) : $length;\n        $str->string = substr_replace($this->string, $replacement, $start, $length ?? 2147483647);\n\n        if (normalizer_is_normalized($str->string)) {\n            return $str;\n        }\n\n        if (false === $string = normalizer_normalize($str->string)) {\n            throw new InvalidArgumentException('Invalid UTF-8 string.');\n        }\n\n        $str->string = $string;\n\n        return $str;\n    }\n\n    public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array\n    {\n        if (1 > $limit ??= 2147483647) {\n            throw new InvalidArgumentException('Split limit must be a positive integer.');\n        }\n\n        if ('' === $delimiter) {\n            throw new InvalidArgumentException('Split delimiter is empty.');\n        }\n\n        if (null !== $flags) {\n            return parent::split($delimiter.'u', $limit, $flags);\n        }\n\n        normalizer_is_normalized($delimiter) ?: $delimiter = normalizer_normalize($delimiter);\n\n        if (false === $delimiter) {\n            throw new InvalidArgumentException('Split delimiter is not a valid UTF-8 string.');\n        }\n\n        $str = clone $this;\n        $tail = $this->string;\n        $chunks = [];\n        $indexOf = $this->ignoreCase ? 'grapheme_stripos' : 'grapheme_strpos';\n\n        while (1 < $limit && false !== $i = $indexOf($tail, $delimiter)) {\n            $str->string = grapheme_substr($tail, 0, $i);\n            $chunks[] = clone $str;\n            $tail = substr($tail, \\strlen($str->string) + \\strlen($delimiter));\n            --$limit;\n        }\n\n        $str->string = $tail;\n        $chunks[] = clone $str;\n\n        return $chunks;\n    }\n\n    public function startsWith(string|iterable|AbstractString $prefix): bool\n    {\n        if ($prefix instanceof AbstractString) {\n            $prefix = $prefix->string;\n        } elseif (!\\is_string($prefix)) {\n            return parent::startsWith($prefix);\n        }\n\n        $form = null === $this->ignoreCase ? \\Normalizer::NFD : \\Normalizer::NFC;\n        normalizer_is_normalized($prefix, $form) ?: $prefix = normalizer_normalize($prefix, $form);\n\n        if ('' === $prefix || false === $prefix) {\n            return false;\n        }\n\n        if ($this->ignoreCase) {\n            return 0 === mb_stripos(grapheme_extract($this->string, \\strlen($prefix), \\GRAPHEME_EXTR_MAXBYTES), $prefix, 0, 'UTF-8');\n        }\n\n        return $prefix === grapheme_extract($this->string, \\strlen($prefix), \\GRAPHEME_EXTR_MAXBYTES);\n    }\n\n    public function __wakeup(): void\n    {\n        if (!\\is_string($this->string)) {\n            throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n        }\n\n        normalizer_is_normalized($this->string) ?: $this->string = normalizer_normalize($this->string);\n    }\n\n    public function __clone()\n    {\n        if (null === $this->ignoreCase) {\n            normalizer_is_normalized($this->string) ?: $this->string = normalizer_normalize($this->string);\n        }\n\n        $this->ignoreCase = false;\n    }\n}\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.3681640625,
          "content": "{\n    \"name\": \"symfony/string\",\n    \"type\": \"library\",\n    \"description\": \"Provides an object-oriented API to strings and deals with bytes, UTF-8 code points and grapheme clusters in a unified way\",\n    \"keywords\": [\"string\", \"utf8\", \"utf-8\", \"grapheme\", \"i18n\", \"unicode\"],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Nicolas Grekas\",\n            \"email\": \"p@tchwork.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/polyfill-ctype\": \"~1.8\",\n        \"symfony/polyfill-intl-grapheme\": \"~1.0\",\n        \"symfony/polyfill-intl-normalizer\": \"~1.0\",\n        \"symfony/polyfill-mbstring\": \"~1.0\"\n    },\n    \"require-dev\": {\n        \"symfony/error-handler\": \"^6.4|^7.0\",\n        \"symfony/emoji\": \"^7.1\",\n        \"symfony/http-client\": \"^6.4|^7.0\",\n        \"symfony/intl\": \"^6.4|^7.0\",\n        \"symfony/translation-contracts\": \"^2.5|^3.0\",\n        \"symfony/var-exporter\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"symfony/translation-contracts\": \"<2.5\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\String\\\\\": \"\" },\n        \"files\": [ \"Resources/functions.php\" ],\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.7978515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony String Component Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}