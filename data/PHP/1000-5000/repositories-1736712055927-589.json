{
  "metadata": {
    "timestamp": 1736712055927,
    "page": 589,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symfony/security-csrf",
      "stars": 1745,
      "defaultBranch": "7.2",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "/Tests export-ignore\n/phpunit.xml.dist export-ignore\n/.git* export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor/\ncomposer.lock\nphpunit.xml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.482421875,
          "content": "CHANGELOG\n=========\n\n7.2\n---\n\n * Add `SameOriginCsrfTokenManager`\n\n6.0\n---\n\n * Remove the `SessionInterface $session` constructor argument of `SessionTokenStorage`, inject a `\\Symfony\\Component\\HttpFoundation\\RequestStack $requestStack` instead\n * Using `SessionTokenStorage` outside a request context throws a `SessionNotFoundException`\n\n5.3\n---\n\nThe CHANGELOG for version 5.3 and earlier can be found at https://github.com/symfony/symfony/blob/5.3/src/Symfony/Component/Security/CHANGELOG.md\n"
        },
        {
          "name": "CsrfToken.php",
          "type": "blob",
          "size": 0.9609375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Csrf;\n\n/**\n * A CSRF token.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\nclass CsrfToken\n{\n    private string $value;\n\n    public function __construct(\n        private string $id,\n        #[\\SensitiveParameter] ?string $value,\n    ) {\n        $this->value = $value ?? '';\n    }\n\n    /**\n     * Returns the ID of the CSRF token.\n     */\n    public function getId(): string\n    {\n        return $this->id;\n    }\n\n    /**\n     * Returns the value of the CSRF token.\n     */\n    public function getValue(): string\n    {\n        return $this->value;\n    }\n\n    /**\n     * Returns the value of the CSRF token.\n     */\n    public function __toString(): string\n    {\n        return $this->value;\n    }\n}\n"
        },
        {
          "name": "CsrfTokenManager.php",
          "type": "blob",
          "size": 5.0693359375,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Csrf;\n\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\Security\\Core\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Security\\Csrf\\TokenGenerator\\TokenGeneratorInterface;\nuse Symfony\\Component\\Security\\Csrf\\TokenGenerator\\UriSafeTokenGenerator;\nuse Symfony\\Component\\Security\\Csrf\\TokenStorage\\NativeSessionTokenStorage;\nuse Symfony\\Component\\Security\\Csrf\\TokenStorage\\TokenStorageInterface;\n\n/**\n * Default implementation of {@link CsrfTokenManagerInterface}.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n * @author KÃ©vin Dunglas <dunglas@gmail.com>\n */\nclass CsrfTokenManager implements CsrfTokenManagerInterface\n{\n    private TokenGeneratorInterface $generator;\n    private TokenStorageInterface $storage;\n    private \\Closure|string $namespace;\n\n    /**\n     * @param $namespace\n     *                   * null: generates a namespace using $_SERVER['HTTPS']\n     *                   * string: uses the given string\n     *                   * RequestStack: generates a namespace using the current main request\n     *                   * callable: uses the result of this callable (must return a string)\n     */\n    public function __construct(?TokenGeneratorInterface $generator = null, ?TokenStorageInterface $storage = null, string|RequestStack|callable|null $namespace = null)\n    {\n        $this->generator = $generator ?? new UriSafeTokenGenerator();\n        $this->storage = $storage ?? new NativeSessionTokenStorage();\n\n        $superGlobalNamespaceGenerator = fn () => !empty($_SERVER['HTTPS']) && 'off' !== strtolower($_SERVER['HTTPS']) ? 'https-' : '';\n\n        if (null === $namespace) {\n            $this->namespace = $superGlobalNamespaceGenerator;\n        } elseif ($namespace instanceof RequestStack) {\n            $this->namespace = static function () use ($namespace, $superGlobalNamespaceGenerator) {\n                if ($request = $namespace->getMainRequest()) {\n                    return $request->isSecure() ? 'https-' : '';\n                }\n\n                return $superGlobalNamespaceGenerator();\n            };\n        } elseif ($namespace instanceof \\Closure || \\is_string($namespace)) {\n            $this->namespace = $namespace;\n        } elseif (\\is_callable($namespace)) {\n            $this->namespace = $namespace(...);\n        } else {\n            throw new InvalidArgumentException(\\sprintf('$namespace must be a string, a callable returning a string, null or an instance of \"RequestStack\". \"%s\" given.', get_debug_type($namespace)));\n        }\n    }\n\n    public function getToken(string $tokenId): CsrfToken\n    {\n        $namespacedId = $this->getNamespace().$tokenId;\n        if ($this->storage->hasToken($namespacedId)) {\n            $value = $this->storage->getToken($namespacedId);\n        } else {\n            $value = $this->generator->generateToken();\n\n            $this->storage->setToken($namespacedId, $value);\n        }\n\n        return new CsrfToken($tokenId, $this->randomize($value));\n    }\n\n    public function refreshToken(string $tokenId): CsrfToken\n    {\n        $namespacedId = $this->getNamespace().$tokenId;\n        $value = $this->generator->generateToken();\n\n        $this->storage->setToken($namespacedId, $value);\n\n        return new CsrfToken($tokenId, $this->randomize($value));\n    }\n\n    public function removeToken(string $tokenId): ?string\n    {\n        return $this->storage->removeToken($this->getNamespace().$tokenId);\n    }\n\n    public function isTokenValid(CsrfToken $token): bool\n    {\n        $namespacedId = $this->getNamespace().$token->getId();\n        if (!$this->storage->hasToken($namespacedId)) {\n            return false;\n        }\n\n        return hash_equals($this->storage->getToken($namespacedId), $this->derandomize($token->getValue()));\n    }\n\n    private function getNamespace(): string\n    {\n        return \\is_callable($ns = $this->namespace) ? $ns() : $ns;\n    }\n\n    private function randomize(string $value): string\n    {\n        $key = random_bytes(32);\n        $value = $this->xor($value, $key);\n\n        return \\sprintf('%s.%s.%s', substr(hash('xxh128', $key), 0, 1 + (\\ord($key[0]) % 32)), rtrim(strtr(base64_encode($key), '+/', '-_'), '='), rtrim(strtr(base64_encode($value), '+/', '-_'), '='));\n    }\n\n    private function derandomize(string $value): string\n    {\n        $parts = explode('.', $value);\n        if (3 !== \\count($parts)) {\n            return $value;\n        }\n        $key = base64_decode(strtr($parts[1], '-_', '+/'));\n        if ('' === $key || false === $key) {\n            return $value;\n        }\n        $value = base64_decode(strtr($parts[2], '-_', '+/'));\n\n        return $this->xor($value, $key);\n    }\n\n    private function xor(string $value, string $key): string\n    {\n        if (\\strlen($value) > \\strlen($key)) {\n            $key = str_repeat($key, ceil(\\strlen($value) / \\strlen($key)));\n        }\n\n        return $value ^ $key;\n    }\n}\n"
        },
        {
          "name": "CsrfTokenManagerInterface.php",
          "type": "blob",
          "size": 1.697265625,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Csrf;\n\n/**\n * Manages CSRF tokens.\n *\n * @author Bernhard Schussek <bschussek@gmail.com>\n */\ninterface CsrfTokenManagerInterface\n{\n    /**\n     * Returns a CSRF token for the given ID.\n     *\n     * If previously no token existed for the given ID, a new token is\n     * generated. Otherwise the existing token is returned (with the same value,\n     * not the same instance).\n     *\n     * @param string $tokenId The token ID. You may choose an arbitrary value\n     *                        for the ID\n     */\n    public function getToken(string $tokenId): CsrfToken;\n\n    /**\n     * Generates a new token value for the given ID.\n     *\n     * This method will generate a new token for the given token ID, independent\n     * of whether a token value previously existed or not. It can be used to\n     * enforce once-only tokens in environments with high security needs.\n     *\n     * @param string $tokenId The token ID. You may choose an arbitrary value\n     *                        for the ID\n     */\n    public function refreshToken(string $tokenId): CsrfToken;\n\n    /**\n     * Invalidates the CSRF token with the given ID, if one exists.\n     *\n     * @return string|null Returns the removed token value if one existed, NULL\n     *                     otherwise\n     */\n    public function removeToken(string $tokenId): ?string;\n\n    /**\n     * Returns whether the given CSRF token is valid.\n     */\n    public function isTokenValid(CsrfToken $token): bool;\n}\n"
        },
        {
          "name": "Exception",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "Copyright (c) 2004-present Fabien Potencier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.982421875,
          "content": "Security Component - CSRF\n=========================\n\nThe Security CSRF (cross-site request forgery) component provides a class\n`CsrfTokenManager` for generating and validating CSRF tokens.\n\nSponsor\n-------\n\nThe Security component for Symfony 7.1 is [backed][1] by [SymfonyCasts][2].\n\nLearn Symfony faster by watching real projects being built and actively coding\nalong with them. SymfonyCasts bridges that learning gap, bringing you video\ntutorials and coding challenges. Code on!\n\nHelp Symfony by [sponsoring][3] its development!\n\nResources\n---------\n\n * [Documentation](https://symfony.com/doc/current/components/security.html)\n * [Contributing](https://symfony.com/doc/current/contributing/index.html)\n * [Report issues](https://github.com/symfony/symfony/issues) and\n   [send Pull Requests](https://github.com/symfony/symfony/pulls)\n   in the [main Symfony repository](https://github.com/symfony/symfony)\n\n[1]: https://symfony.com/backers\n[2]: https://symfonycasts.com\n[3]: https://symfony.com/sponsor\n"
        },
        {
          "name": "SameOriginCsrfTokenManager.php",
          "type": "blob",
          "size": 10.7578125,
          "content": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Csrf;\n\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpKernel\\Event\\ResponseEvent;\n\n/**\n * This CSRF token manager uses a combination of cookie and headers to validate non-persistent tokens.\n *\n * This manager is designed to be stateless and compatible with HTTP-caching.\n *\n * First, we validate the source of the request using the Origin/Referer headers. This relies\n * on the app being able to know its own target origin. Don't miss configuring your reverse proxy to\n * send the X-Forwarded-* / Forwarded headers if you're behind one.\n *\n * Then, we validate the request using a cookie and a CsrfToken. If the cookie is found, it should\n * contain the same value as the CsrfToken. A JavaScript snippet on the client side is responsible\n * for performing this double-submission. The token value should be regenerated on every request\n * using a cryptographically secure random generator.\n *\n * If either double-submit or Origin/Referer headers are missing, it typically indicates that\n * JavaScript is disabled on the client side, or that the JavaScript snippet was not properly\n * implemented, or that the Origin/Referer headers were filtered out.\n *\n * Requests lacking both double-submit and origin information are deemed insecure.\n *\n * When a session is found, a behavioral check is added to ensure that the validation method does not\n * downgrade from double-submit to origin checks. This prevents attackers from exploiting potentially\n * less secure validation methods once a more secure method has been confirmed as functional.\n *\n * On HTTPS connections, the cookie is prefixed with \"__Host-\" to prevent it from being forged on an\n * HTTP channel. On the JS side, the cookie should be set with samesite=strict to strengthen the CSRF\n * protection. The cookie is always cleared on the response to prevent any further use of the token.\n *\n * The $checkHeader argument allows the token to be checked in a header instead of or in addition to a\n * cookie. This makes it harder for an attacker to forge a request, though it may also pose challenges\n * when setting the header depending on the client-side framework in use.\n *\n * When a fallback CSRF token manager is provided, only tokens listed in the $tokenIds argument will be\n * managed by this manager. All other tokens will be delegated to the fallback manager.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nfinal class SameOriginCsrfTokenManager implements CsrfTokenManagerInterface\n{\n    public const TOKEN_MIN_LENGTH = 24;\n\n    public const CHECK_NO_HEADER = 0;\n    public const CHECK_HEADER = 1;\n    public const CHECK_ONLY_HEADER = 2;\n\n    /**\n     * @param self::CHECK_* $checkHeader\n     * @param string[]      $tokenIds\n     */\n    public function __construct(\n        private RequestStack $requestStack,\n        private ?LoggerInterface $logger = null,\n        private ?CsrfTokenManagerInterface $fallbackCsrfTokenManager = null,\n        private array $tokenIds = [],\n        private int $checkHeader = self::CHECK_NO_HEADER,\n        private string $cookieName = 'csrf-token',\n    ) {\n        if (!$cookieName) {\n            throw new \\InvalidArgumentException('The cookie name cannot be empty.');\n        }\n\n        if (!preg_match('/^[-a-zA-Z0-9_]+$/D', $cookieName)) {\n            throw new \\InvalidArgumentException('The cookie name contains invalid characters.');\n        }\n\n        $this->tokenIds = array_flip($tokenIds);\n    }\n\n    public function getToken(string $tokenId): CsrfToken\n    {\n        if (!isset($this->tokenIds[$tokenId]) && $this->fallbackCsrfTokenManager) {\n            return $this->fallbackCsrfTokenManager->getToken($tokenId);\n        }\n\n        return new CsrfToken($tokenId, $this->cookieName);\n    }\n\n    public function refreshToken(string $tokenId): CsrfToken\n    {\n        if (!isset($this->tokenIds[$tokenId]) && $this->fallbackCsrfTokenManager) {\n            return $this->fallbackCsrfTokenManager->refreshToken($tokenId);\n        }\n\n        return new CsrfToken($tokenId, $this->cookieName);\n    }\n\n    public function removeToken(string $tokenId): ?string\n    {\n        if (!isset($this->tokenIds[$tokenId]) && $this->fallbackCsrfTokenManager) {\n            return $this->fallbackCsrfTokenManager->removeToken($tokenId);\n        }\n\n        return null;\n    }\n\n    public function isTokenValid(CsrfToken $token): bool\n    {\n        if (!isset($this->tokenIds[$token->getId()]) && $this->fallbackCsrfTokenManager) {\n            return $this->fallbackCsrfTokenManager->isTokenValid($token);\n        }\n\n        if (!$request = $this->requestStack->getCurrentRequest()) {\n            $this->logger?->error('CSRF validation failed: No request found.');\n\n            return false;\n        }\n\n        if (\\strlen($token->getValue()) < self::TOKEN_MIN_LENGTH && $token->getValue() !== $this->cookieName) {\n            $this->logger?->warning('Invalid double-submit CSRF token.');\n\n            return false;\n        }\n\n        if (false === $isValidOrigin = $this->isValidOrigin($request)) {\n            $this->logger?->warning('CSRF validation failed: origin info doesn\\'t match.');\n\n            return false;\n        }\n\n        if (false === $isValidDoubleSubmit = $this->isValidDoubleSubmit($request, $token->getValue())) {\n            return false;\n        }\n\n        if (null === $isValidOrigin && null === $isValidDoubleSubmit) {\n            $this->logger?->warning('CSRF validation failed: double-submit and origin info not found.');\n\n            return false;\n        }\n\n        // Opportunistically lookup at the session for a previous CSRF validation strategy\n        $session = $request->hasPreviousSession() ? $request->getSession() : null;\n        $usageIndexValue = $session instanceof Session ? $usageIndexReference = &$session->getUsageIndex() : 0;\n        $usageIndexReference = \\PHP_INT_MIN;\n        $previousCsrfProtection = (int) $session?->get($this->cookieName);\n        $usageIndexReference = $usageIndexValue;\n        $shift = $request->isMethodSafe() ? 8 : 0;\n\n        if ($previousCsrfProtection) {\n            if (!$isValidOrigin && (1 & ($previousCsrfProtection >> $shift))) {\n                $this->logger?->warning('CSRF validation failed: origin info was used in a previous request but is now missing.');\n\n                return false;\n            }\n\n            if (!$isValidDoubleSubmit && (2 & ($previousCsrfProtection >> $shift))) {\n                $this->logger?->warning('CSRF validation failed: double-submit info was used in a previous request but is now missing.');\n\n                return false;\n            }\n        }\n\n        if ($isValidOrigin && $isValidDoubleSubmit) {\n            $csrfProtection = 3;\n            $this->logger?->debug('CSRF validation accepted using both origin and double-submit info.');\n        } elseif ($isValidOrigin) {\n            $csrfProtection = 1;\n            $this->logger?->debug('CSRF validation accepted using origin info.');\n        } else {\n            $csrfProtection = 2;\n            $this->logger?->debug('CSRF validation accepted using double-submit info.');\n        }\n\n        if (1 & $csrfProtection) {\n            // Persist valid origin for both safe and non-safe requests\n            $previousCsrfProtection |= 1 & (1 << 8);\n        }\n\n        $request->attributes->set($this->cookieName, ($csrfProtection << $shift) | $previousCsrfProtection);\n\n        return true;\n    }\n\n    public function clearCookies(Request $request, Response $response): void\n    {\n        if (!$request->attributes->has($this->cookieName)) {\n            return;\n        }\n\n        $cookieName = ($request->isSecure() ? '__Host-' : '').$this->cookieName;\n\n        foreach ($request->cookies->all() as $name => $value) {\n            if ($this->cookieName === $value && str_starts_with($name, $cookieName.'_')) {\n                $response->headers->clearCookie($name, '/', null, $request->isSecure(), false, 'strict');\n            }\n        }\n    }\n\n    public function persistStrategy(Request $request): void\n    {\n        if (!$request->attributes->has($this->cookieName)\n            || !$request->hasSession(true)\n            || !($session = $request->getSession())->isStarted()\n        ) {\n            return;\n        }\n\n        $usageIndexValue = $session instanceof Session ? $usageIndexReference = &$session->getUsageIndex() : 0;\n        $usageIndexReference = \\PHP_INT_MIN;\n        $session->set($this->cookieName, $request->attributes->get($this->cookieName));\n        $usageIndexReference = $usageIndexValue;\n    }\n\n    public function onKernelResponse(ResponseEvent $event): void\n    {\n        if (!$event->isMainRequest()) {\n            return;\n        }\n\n        $this->clearCookies($event->getRequest(), $event->getResponse());\n        $this->persistStrategy($event->getRequest());\n    }\n\n    /**\n     * @return bool|null Whether the origin is valid, null if missing\n     */\n    private function isValidOrigin(Request $request): ?bool\n    {\n        $target = $request->getSchemeAndHttpHost().'/';\n        $source = 'null';\n\n        foreach (['Origin', 'Referer'] as $header) {\n            if (!$request->headers->has($header)) {\n                continue;\n            }\n            $source = $request->headers->get($header);\n\n            if (str_starts_with($source.'/', $target)) {\n                return true;\n            }\n        }\n\n        return 'null' === $source ? null : false;\n    }\n\n    /**\n     * @return bool|null Whether the double-submit is valid, null if missing\n     */\n    private function isValidDoubleSubmit(Request $request, string $token): ?bool\n    {\n        if ($this->cookieName === $token) {\n            return null;\n        }\n\n        if ($this->checkHeader && $request->headers->get($this->cookieName, $token) !== $token) {\n            $this->logger?->warning('CSRF validation failed: wrong token found in header info.');\n\n            return false;\n        }\n\n        $cookieName = ($request->isSecure() ? '__Host-' : '').$this->cookieName;\n\n        if (self::CHECK_ONLY_HEADER === $this->checkHeader) {\n            if (!$request->headers->has($this->cookieName)) {\n                return null;\n            }\n\n            $request->cookies->set($cookieName.'_'.$token, $this->cookieName); // Ensure clearCookie() can remove any cookie filtered by a reverse-proxy\n\n            return true;\n        }\n\n        if (($request->cookies->all()[$cookieName.'_'.$token] ?? null) !== $this->cookieName && !($this->checkHeader && $request->headers->has($this->cookieName))) {\n            return null;\n        }\n\n        return true;\n    }\n}\n"
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "TokenGenerator",
          "type": "tree",
          "content": null
        },
        {
          "name": "TokenStorage",
          "type": "tree",
          "content": null
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 0.931640625,
          "content": "{\n    \"name\": \"symfony/security-csrf\",\n    \"type\": \"library\",\n    \"description\": \"Symfony Security Component - CSRF Library\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=8.2\",\n        \"symfony/security-core\": \"^6.4|^7.0\"\n    },\n    \"require-dev\": {\n        \"psr/log\": \"^1|^2|^3\",\n        \"symfony/http-foundation\": \"^6.4|^7.0\",\n        \"symfony/http-kernel\": \"^6.4|^7.0\"\n    },\n    \"conflict\": {\n        \"symfony/http-foundation\": \"<6.4\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Security\\\\Csrf\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\"\n}\n"
        },
        {
          "name": "phpunit.xml.dist",
          "type": "blob",
          "size": 0.8046875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/9.3/phpunit.xsd\"\n         backupGlobals=\"false\"\n         colors=\"true\"\n         bootstrap=\"vendor/autoload.php\"\n         failOnRisky=\"true\"\n         failOnWarning=\"true\"\n>\n    <php>\n        <ini name=\"error_reporting\" value=\"-1\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"Symfony Security Component CSRF Test Suite\">\n            <directory>./Tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <coverage>\n        <include>\n            <directory>./</directory>\n        </include>\n        <exclude>\n            <directory>./Tests</directory>\n            <directory>./vendor</directory>\n        </exclude>\n    </coverage>\n</phpunit>\n"
        }
      ]
    }
  ]
}