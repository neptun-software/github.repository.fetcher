{
  "metadata": {
    "timestamp": 1736712096912,
    "page": 665,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "LinkedDestiny/swoole-doc",
      "stars": 1602,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": "01-环境搭建及扩展安装.md",
          "type": "blob",
          "size": 7.201171875,
          "content": "###写在前面的废话\n《swoole源码分析》已经写了13章，整个swoole的核心架构基本都分析的差不多了。于是心里一直以来想整理swoole的文档并写一份教程的想法就再度浮了出来。实话说，我接触swoole乃至接触PHP都仅有9个月的时间，而自7月份以来一直在公司做Android开发，也就没有了使用swoole的机会。所以，现在我只能写出一份入门级教程，帮助刚刚接触swoole的人理解和使用swoole写一些简单的例子，从而初步掌握swoole的用法。\n\n---------------------------\n\nGit地址：https://github.com/LinkedDestiny/swoole-doc\n\n###第一章 环境搭建及扩展安装\n环境说明：\n系统：Ubuntu14.04 （安装教程包括CentOS6.5）\nPHP版本：PHP-5.5.10\nswoole版本：1.7.6-stable\n\n####PHP安装\n要用swoole，首先需要有PHP环境。由于swoole的某些特性，最好是能够从源码编译安装PHP，这样在使用过程中可以避免很多不必要的错误。\nPHP下载地址：http://php.net/\n在这里挑选你想用的版本即可。下载源码包后，解压至本地任意目录（保证读写权限），留待使用。\n安装PHP前，需要安装编译环境和PHP的相关依赖。下面是相关命令：\nUbuntu环境下：\n```bash\nsudo apt-get install build-essential gcc g++ autoconf libiconv-hook-dev libmcrypt-dev libxml2-dev libmysqlclient-dev libcurl4-openssl-dev libjpeg8-dev libpng12-dev libfreetype6-dev\n```\nCentOS环境下：\n```bash\nyum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers gd gd2 gd-devel gd2-devel perl-CPAN pcre-devel\n```\n（注：以上命令是我在实际使用中验证过的可以使用的，可能会和其他教程提供的命令不同）\n当上述命令执行后，即可开始安装PHP。命令如下：\n```bash\ncd php-5.5.10/\n./configure --prefix=/usr/local/php --with-config-file-path=/etc/php --enable-fpm --enable-pcntl --enable-mysqlnd --enable-opcache --enable-sockets --enable-sysvmsg --enable-sysvsem  --enable-sysvshm --enable-shmop --enable-zip --enable-ftp --enable-soap --enable-xml --enable-mbstring --disable-rpath --disable-debug --disable-fileinfo --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-pcre-regex --with-iconv --with-zlib --with-mcrypt --with-gd --with-openssl --with-mhash --with-xmlrpc --with-curl --with-imap-ssl\nsudo make\nsudo make install\nsudo cp php.ini-development /etc/php/\n```\n至此，PHP已经成功安装，但是此时在终端里是无法直接通过php --version查看php版本的还需要将PHP的可执行目录添加到环境变量中。\n使用Vim/Sublime打开~/.bashrc，在末尾添加如下内容：\n```shell\nexport PATH=/usr/local/php/bin:$PATH\nexport PATH=/usr/local/php/sbin:$PATH\n```\n保存后，终端输入命令：\n```bash\nsource ~/.bashrc\n```\n此时即可通过php --version查看php版本，看到如下内容：\n```shell\nPHP 5.5.10 (cli) (built: Apr 26 2014 09:46:14) \nCopyright (c) 1997-2014 The PHP Group\nZend Engine v2.5.0, Copyright (c) 1998-2014 Zend Technologies\n```\n即说明安装成功。\n####Swoole安装\n安装完PHP后，即可安装swoole扩展。\nswoole扩展下载地址：https://github.com/swoole/swoole-src/releases\n尽量选择stable版本，alpha版本最好仅用于实验新特性。\n解压源码至任意目录，执行如下命令：\n```bash\ncd swoole-src-swoole-1.7.6-stable/\nphpize\n./configure --enable-async-mysql\nsudo make\nsudo make install\n```\n(注：swoole的./configure有很多额外参数，可以通过./configure --help命令查看，这里仅开启其中async-mysql项，其他均选择默认项)\n安装完成后，进入/etc/php目录下，打开php.ini文件，在其中加上如下一句：\n```shell\nextension=swoole.so\n```\n随后在终端中输入命令\n```bash\nphp -m\n```\n查看扩展安装情况。如果在列出的扩展中看到了swoole，则说明安装成功。\n\n####基本实例\n下面贴一个基本的基于swoole的echo服务器\n```php\n// Server\nclass Server\n{\n    private $serv;\n\n    public function __construct() {\n        $this->serv = new swoole_server(\"0.0.0.0\", 9501);\n        $this->serv->set(array(\n            'worker_num' => 8,\n            'daemonize' => false,\n            'max_request' => 10000,\n            'dispatch_mode' => 2,\n            'debug_mode'=> 1\n        ));\n\n        $this->serv->on('Start', array($this, 'onStart'));\n        $this->serv->on('Connect', array($this, 'onConnect'));\n        $this->serv->on('Receive', array($this, 'onReceive'));\n        $this->serv->on('Close', array($this, 'onClose'));\n\n        $this->serv->start();\n    }\n\n    public function onStart( $serv ) {\n        echo \"Start\\n\";\n    }\n\n    public function onConnect( $serv, $fd, $from_id ) {\n        $serv->send( $fd, \"Hello {$fd}!\" );\n    }\n\n    public function onReceive( swoole_server $serv, $fd, $from_id, $data ) {\n        echo \"Get Message From Client {$fd}:{$data}\\n\";\n    }\n\n    public function onClose( $serv, $fd, $from_id ) {\n        echo \"Client {$fd} close connection\\n\";\n    }\n}\n// 启动服务器\n$server = new Server();\n```\n从代码中可以看出，创建一个swoole_server基本分三步：\n1. 通过构造函数创建swoole_server对象\n2. 调用**set**函数设置swoole_server的相关配置选项\n3. 调用**on**函数设置相关回调函数\n关于set配置选项以及on回调函数的具体说明，请参考我整理的swoole文档(\n[配置选项](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md))\n\n这里只给出简单介绍。onStart回调在server运行前被调用，onConnect在有新客户端连接过来时被调用，onReceive函数在有数据发送到server时被调用，onClose在有客户端断开连接时被调用。\n这里就可以大概看出如何使用swoole：在onConnect处监听新的连接;在onReceive处接收数据并处理，然后可以调用send函数将处理结果发送出去;在onClose处处理客户端下线的事件。\n\n下面贴出客户端的代码：\n```php\n<?php\nclass Client\n{\n\tprivate $client;\n\n\tpublic function __construct() {\n\t\t$this->client = new swoole_client(SWOOLE_SOCK_TCP);\n\t}\n\t\n\tpublic function connect() {\n\t\tif( !$this->client->connect(\"127.0.0.1\", 9501 , 1) ) {\n\t\t\techo \"Error: {$fp->errMsg}[{$fp->errCode}]\\n\";\n\t\t}\n\t\t$message = $this->client->recv();\n\t\techo \"Get Message From Server:{$message}\\n\";\n\n\t\tfwrite(STDOUT, \"请输入消息：\");  \n\t\t$msg = trim(fgets(STDIN));\n\t\t$this->client->send( $msg );\n\t}\n}\n\n$client = new Client();\n$client->connect();\n```\n\n这里，通过swoole_client创建一个基于TCP的客户端实例，并调用connect函数向指定的IP及端口发起连接请求。随后即可通过recv()和send()两个函数来接收和发送请求。需要注意的是，这里我使用了默认的同步阻塞客户端，因此recv和send操作都会产生网络阻塞。\n\n（以上两段代码均以上传git，地址：https://github.com/LinkedDestiny/swoole-doc/tree/master/src/01）\n\n下章预告：swoole的task使用以及实例：简单聊天室\n"
        },
        {
          "name": "02-Swoole的Task使用以及swoole_client.md",
          "type": "blob",
          "size": 5.830078125,
          "content": "###第二章 Swoole的task使用以及swoole_client\n环境说明：\n系统：Ubuntu14.04 （安装教程包括CentOS6.5）<br>\nPHP版本：PHP-5.5.10<br>\nswoole版本：1.7.6-stable<br>\n\n上一章已经简单介绍了如何写一个简单的Echo服务器，并了解了onReceive等几个核心回调函数的使用方法。这一章，我将介绍如何使用Swoole的异步任务Task。\n\n####**1.Task简介**\nSwoole的业务逻辑部分是同步阻塞运行的，如果遇到一些耗时较大的操作，例如访问数据库、广播消息等，就会影响服务器的响应速度。因此Swoole提供了Task功能，将这些耗时操作放到另外的进程去处理，当前进程继续执行后面的逻辑。\n\n####**2.开启Task功能**\n开启Task功能只需要在swoole_server的配置项中添加[task_worker_num](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#6task_worker_num)一项即可，如下：\n```php\n$serv->set(array(\n    'task_worker_num' => 8\n));\n```\n即可开启task功能。此外，必须给swoole_server绑定两个回调函数：[onTask](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#6ontask)和[onFinish](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#7onfinish)。这两个回调函数分别用于执行Task任务和处理Task任务的返回结果。\n\n####**3.使用Task**\n首先是发起一个Task，代码如下：\n```php\n    public function onReceive( swoole_server $serv, $fd, $from_id, $data ) {\n        echo \"Get Message From Client {$fd}:{$data}\\n\";\n        // send a task to task worker.\n        $param = array(\n            'fd' => $fd\n        );\n        // start a task\n        $serv->task( json_encode( $param ) );\n        \n        echo \"Continue Handle Worker\\n\";\n    }\n```\n可以看到，发起一个任务时，只需通过swoole_server对象调用task函数即可发起一个任务。swoole内部会将这个请求投递给task_worker，而当前Worker进程会继续执行。\n\n当一个任务发起后，task_worker进程会响应[onTask](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#6ontask)回调函数，如下：\n```php\n    public function onTask($serv,$task_id,$from_id, $data) {\n        echo \"This Task {$task_id} from Worker {$from_id}\\n\";\n        echo \"Data: {$data}\\n\";\n        for($i = 0 ; $i < 10 ; $i ++ ) {\n            sleep(1);\n            echo \"Task {$task_id} Handle {$i} times...\\n\";\n        }\n        $fd = json_decode( $data , true )['fd'];\n        $serv->send( $fd , \"Data in Task {$task_id}\");\n        return \"Task {$task_id}'s result\";\n    }\n```\n这里我用sleep函数和循环模拟了一个长耗时任务。在onTask回调中，我们通过task_id和from_id(也就是worker_id)来区分不同进程投递的不同task。当一个task执行结束后，通过return一个字符串将执行结果返回给Worker进程。Worker进程将通过[onFinish](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#7onfinish)回调函数接收这个处理结果。\n\n下面来看onFinish回调：\n```php\n    public function onFinish($serv,$task_id, $data) {\n        echo \"Task {$task_id} finish\\n\";\n        echo \"Result: {$data}\\n\";\n    }\n```\n在[onFinish](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#7onfinish)回调中，会接收到Task任务的处理结果$data。在这里处理这个返回结果即可。\n（**Tip:** 可以通过在传递的data中存放fd、buff等数据，来延续投递Task之前的工作）\n\n[点此查看完整示例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/02/swoole_task_server.php)\n\n####**4.swoole_client**\n之所以在这里讲解如何使用swoole_client是因为，在写服务端代码的时候，不可避免的需要用到客户端来进行测试。swoole提供了swoole_client用于编写测试客户端，下面我将讲解如何使用这个工具。\n\nswoole_client有两种工作模式：同步阻塞模式和异步回调模式。其中，同步阻塞模式在上一章中已经给出示例，其使用和一般的socket基本无异。因此，我将重点讲解swoole_client的异步回调模式。\n\n创建一个异步client的代码如下：\n```php\n$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);\n```\n其中，**SWOOLE_SOCK_ASYNC**选项即表明创建一个异步client。\n\n既然是异步，那当然需要回调函数。swoole_client一共有四个回调函数，如下：\n```php\n$client->on(\"connect\", function($cli) {\n    $cli->send(\"hello world\\n\");\n});\n$client->on(\"receive\", function($cli, $data){\n    echo \"Received: \".$data.\"\\n\";\n});\n$client->on(\"error\", function($cli){\n    echo \"Connect failed\\n\";\n});\n$client->on(\"close\", function($cli){\n    echo \"Connection close\\n\";\n});\n```\n这几个回调函数的作用基本和swoole_server类似，只有参数不同，因此不再赘述。\n[点此查看完整示例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/02/swoole_async_client.php)\n\n\n###**进阶：简易聊天室**\n我用swoole扩展写了一个简单的聊天室Demo（[点此查看](https://github.com/LinkedDestiny/swoole-doc/tree/master/src/Chatroom)）\n这个Demo虽然用到了一些其他的架构，但是核心功能仍然是依托swoole扩展实现的。\n\n- 通过onReceive回调接收数据，根据预先规定的字段找到对应的处理函数。 \n-  通过onTask处理发送数据、广播这样的耗时内容。\n\n[Server.php](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/Chatroom/Server/app/socket/Server.php)是全部的Swoole回调函数实现的类。\n\n\n下章预告：Timer计时器、心跳检测及Task进阶实例：mysql连接池。\n\n\n\n\n"
        },
        {
          "name": "03.Timer定时器、心跳检测及Task进阶实例：mysql连接池.md",
          "type": "blob",
          "size": 9.333984375,
          "content": "# 03.Timer定时器、心跳检测及Task进阶实例：mysql连接池\n\n#Table of Contents\n- [1.Timer定时器](#1timer%E5%AE%9A%E6%97%B6%E5%99%A8)\n- [2.心跳检测](#2%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B)\n- [3.Task进阶：MySQL连接池](#3task%E8%BF%9B%E9%98%B6mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0)\n\n---\n\n环境说明：\n系统：Ubuntu14.04 （安装教程包括CentOS6.5）<br>\nPHP版本：PHP-5.5.10<br>\nswoole版本：1.7.7-stable<br>\n\n---\n\n##**1.Timer定时器**\n在实际应用中，往往会遇到需要每隔一段时间重复做一件事，比如心跳检测、订阅消息、数据库备份等工作。通常，我们会借助PHP的time()以及相关函数自己实现一个定时器，或者使用crontab工具来实现。但是，自定义的定时器容易出错，而使用crontab则需要编写额外的脚本文件，无论是迁移还是调试都比较麻烦。<br>\n因此，Swoole提供了一个内置的Timer定时器功能,通过函数[addtimer](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/03.swoole_server%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md#swoole_serveraddtimer)即可在Swoole中添加一个定时器，该定时器会在建立之后，按照预先设定好的时间间隔，每到对应的时间就会调用一次回调函数[onTimer](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#8ontimer)通知Server。<br>\n简单示例如下：\n```php\n    $this->serv->on('Timer', array($this, 'onTimer'));\n\n    public function onWorkerStart( $serv , $worker_id) {\n\t\t// 在Worker进程开启时绑定定时器\n        // 只有当worker_id为0时才添加定时器,避免重复添加\n        if( $worker_id == 0 ) {\n        \t$serv->addtimer(500);\n        \t$serv->addtimer(1000);\n\t        $serv->addtimer(1500);\n        }\n    }\n    \n    public function onTimer($serv, $interval) {\n    \tswitch( $interval ) {\n    \t\tcase 500: {\t// \n    \t\t\techo \"Do Thing A at interval 500\\n\";\n    \t\t\tbreak;\n    \t\t}\n    \t\tcase 1000:{\n    \t\t\techo \"Do Thing B at interval 1000\\n\";\n    \t\t\tbreak;\n    \t\t}\n    \t\tcase 1500:{\n    \t\t\techo \"Do Thing C at interval 1500\\n\";\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    }\n```\n可以看到，在[onWorkerStart](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#3onworkerstart)回调函数中，通过addtimer添加了三个定时器，时间间隔分别为500、1000、1500。而在onTimer回调中，正好通过间隔的不同来区分不同的定时器回调，从而执行不同的操作。<br>\n需要注意的是，在上述示例中，当1000ms的定时器被触发时，500ms的定时器同样会被触发，但是不能保证会在1000ms定时器前触发还是后触发，因此需要注意，定时器中的操作不能依赖其他定时器的执行结果。\n\n[点此查看完整示例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/03/swoole_timer_server.php)\n\n(PS:在Swoole-1.7.7版本，新提供了一个[after](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/03.swoole_server%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md#swoole_serverafter)函数, 这个功能的用法会在以后的教程中给出。)\n\n##**2.心跳检测**\n上文提到过，使用Timer定时器功能可以实现发送心跳包的功能。事实上，Swoole已经内置了心跳检测功能，能自动close掉长时间没有数据来往的连接。而开启心跳检测功能，只需要设置[heartbeat_check_interval](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#11heartbeat_check_interval)和[heartbeat_idle_time](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#12heartbeat_idle_time)即可。如下：\n```php\n$this->serv->set(\n    array(\n        'heartbeat_check_interval' => 60,\n        'heartbeat_idle_time' => 600,\n    )\n);\n```\n其中heartbeat_idle_time的默认值是heartbeat_check_interval的两倍。\n在设置这两个选项后，swoole会在内部启动一个线程，每隔heartbeat_check_interval秒后遍历一次全部连接，检查最近一次发送数据的时间和当前时间的差，如果这个差值大于heartbeat_idle_time，则会强制关闭这个连接，并通过回调onClose通知Server进程。\n[点此查看完整示例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/03/swoole_heartbeat_server.php)\n**小技巧**：\n结合之前的Timer功能，如果我们想维持连接，就设置一个略小于如果这个差值大于heartbeat_idle_time的定时器，在定时器内向所有连接发送一个心跳包。如果收到心跳回应，则判断连接正常，如果没有收到，则关闭这个连接或者再次尝试发送。\n\n##**3.Task进阶：MySQL连接池**\n上一章中我简单讲解了如何开启和使用Task功能。这一节，我将提供一个Task的高级用法。<br>\n\n在PHP中，访问MySQL数据库往往是性能提升的瓶颈。而MySQL连接池我想大家都不陌生，这是一个很好的提升数据库访问性能的方式。传统的MySQL连接池，是预先申请一定数量的连接，每一个新的请求都会占用其中一个连接，请求结束后再将连接放回池中，如果所有连接都被占用，新来的连接则会进入等待状态。<br>\n知道了MySQL连接池的实现原理，那我们来看如何使用Swoole实现一个连接池。<br>\n首先，Swoole允许开启一定量的Task Worker进程，我们可以让每个进程都拥有一个MySQL连接，并保持这个连接，这样，我们就创建了一个连接池。<br>\n其次，设置swoole的[dispatch_mode](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#5dispatch_mode)为抢占模式(主进程会根据Worker的忙闲状态选择投递，只会投递给处于闲置状态的Worker)。这样，每个task都会被投递给闲置的Task Worker。这样，我们保证了每个新的task都会被闲置的Task Worker处理，如果全部Task Worker都被占用，则会进入等待队列。<br>\n\n下面直接上关键代码：<br>\n```php\npublic function onWorkerStart( $serv , $worker_id) {\n    echo \"onWorkerStart\\n\";\n    // 判定是否为Task Worker进程\n    if( $worker_id >= $serv->setting['worker_num'] ) {\n    \t$this->pdo = new PDO(\n    \t\t\"mysql:host=localhost;port=3306;dbname=Test\", \n    \t\t\"root\", \n    \t\t\"123456\", \n    \t\tarray(\n                PDO::MYSQL_ATTR_INIT_COMMAND => \"SET NAMES 'UTF8';\",\n                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,\n                PDO::ATTR_PERSISTENT => true\n        \t)\n        );\n    }\n}\n```\n首先，在每个Task Worker进程中，创建一个MySQL连接。这里我选用了PDO扩展。<br>\n\n```php\npublic function onReceive( swoole_server $serv, $fd, $from_id, $data ) {\n    $sql = array(\n    \t'sql'=>'select * from Test where pid > ?',\n    \t'param' => array(\n    \t\t0\n    \t),\n    \t'fd' => $fd\n    );\n    $serv->task( json_encode($sql) );\n}\n```\n其次，在需要的时候，通过[task]()函数投递一个任务（也就是发起一次SQL请求）<br>\n```php\npublic function onTask($serv,$task_id,$from_id, $data) {\n   \t$sql = json_decode( $data , true );\n\t\n\t$statement = $this->pdo->prepare($sql['sql']);\n    $statement->execute($sql['param']);    \t\n\n    $result = $statement->fetchAll(PDO::FETCH_ASSOC);\n    $serv->send( $sql['fd'],json_encode($result));\n\treturn true;\n}\n```\n最后，在onTask回调中，根据请求过来的SQL语句以及相应的参数，发起一次MySQL请求，并将获取到的结果通过send发送给客户端（或者通过return返回给Worker进程）。而且，这样的一次MySQL请求还不会阻塞Worker进程，Worker进程可以继续处理其他的逻辑。<br>\n\n可以看到，简单十几行代码，就实现了一个高效的异步MySQL连接池。<br>\n通过测试，单个客户端一共发起1W次select请求，共耗时9s;<br> 1W次insert请求，共耗时21s。<br>\n(客户端会在每次收到前一个请求的结果后才会发起下一次请求，而不是并发)。\n\n[点此查看完整服务端代码](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/03/swoole_mysql_pool_server.php)<br>\n[点此查看完整客户端代码](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/03/swoole_mysql_pool_client.php)<br>\n\n##**4.Task实战：yii中应用task**\n在YII框架中结合了swoole 的task 做了异步处理。\n本例中 主要用到\n1、protected/commands/ServerCommand.php 用来做server。\n2、protected/event/下的文件 这里是在异步中的具体实现。\n\n客户端调用参照 TestController\n```php\n<?php\nclass TestController extends Controller{\n    public function actionTT(){\n        $message['uid'] = 2;\n        $message['email'] = '83212019@qq.com';\n        $message['title'] = '接口报警邮件';\n        $message['contents'] = \"'EmailEvent'接口请求过程出错！ 错误信息如下：err_no:'00000' err_msg:'测试队列' 请求参数为:'[]'\";\n        $message['type'] = 2;\n\n        $data['param'] = $message;\n        $data['class'] = 'Email';\n        $client = new EventClient();\n        $data = $client->send($data);\n    }\n}\n?>\n```\n\n有个task表是用来记录异步任务的。如果失败重试3次。sql在protected/data/sql.sql里。  \n[点此查看完整客户端代码](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/03/swoole_mysql_pool_client.php)<br>\n\n下章预告：Swoole多端口监听、热重启以及Timer进阶：简单crontab\n"
        },
        {
          "name": "04.Swoole多端口监听、热重启以及Timer进阶：简单crontab.md",
          "type": "blob",
          "size": 5.0556640625,
          "content": "# 04.Swoole多端口监听、热重启以及Timer进阶：简单crontab\n---\n#Table of Contents\n- [1.多端口监听](#1%E5%A4%9A%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC)\n- [2.服务器热重启](#2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%83%AD%E9%87%8D%E5%90%AF)\n- [3.Timer补充：after函数](#3timer%E8%A1%A5%E5%85%85after%E5%87%BD%E6%95%B0)\n- [4.Timer进阶：简易crontab](#4timer%E8%BF%9B%E9%98%B6%E7%AE%80%E6%98%93crontab)\n\n---\n\n环境说明：\n系统：Ubuntu14.04 （安装教程包括CentOS6.5）<br>\nPHP版本：PHP-5.5.10<br>\nswoole版本：1.7.7-stable<br>\n\n---\n\n##**1.多端口监听**\n在实际运用场景中，服务器可能需要监听不同host下的不同端口。比如，一个应用服务器，可能需要监听外网的服务端口，同时也需要监听内网的管理端口。在Swoole中，可以轻松的实现这样的功能。\nSwoole提供了[addlistener](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/03.swoole_server%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md#swoole_serveraddlistener)函数用于给服务器添加一个需要监听的host及port，并指定对应的Socket类型（TCP，UDP，Unix Socket以及对应的IPv4和IPv6版本）。\n代码如下：\n```php\n$serv = new swoole_server(\"192.168.1.1\", 9501); // 监听外网的9501端口\n$serv->addlistener(\"127.0.0.1\", 9502 , SWOOLE_TCP); // 监听本地的9502端口\n$serv->start(); // addlistener必须在start前调用\n```\n此时，swoole_server就会同时监听两个host下的两个端口。这里要注意的是，来自两个端口的数据会在同一个onReceive中获取到，这时就要用到swoole的另一个成员函数[connection_info](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/03.swoole_server%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md#swoole_serverconnection_info)，通过这个函数获取到fd的from_port，就可以判定消息的类型。\n```php\n$info = $serv->connection_info($fd, $from_id);\n//来自9502的内网管理端口\nif($info['from_port'] == 9502) {\n    $serv->send($fd, \"welcome admin\\n\");\n}\n//来自外网\nelse {\n    $serv->send($fd, 'Swoole: '.$data);\n}\n```\n[点此查看完整源码](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/04/swoole_multi_port_server.php)\n\n##**2.服务器热重启**\n所谓热重启，就是当服务器相关代码有所变动之后，无需停止服务，而是在服务器仍然运行的状态下更新文件。Swoole通过内置的reload函数以及两个自定义信号量实现了这一功能。\n首先我讲解一下Swoole可用的三个信号：SIGTERM，SIGUSR1，SIGUSR2。SIGTERM用于停止服务器，SIGUSR1用于重启全部的Worker进程，SIGUSR2用于重启全部的Task Worker进程。\n那要如何实现热更新代码文件呢？Swoole的回调函数中有这个一个回调[onWorkerStart](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#3onworkerstart);该回调会在Worker进程启动时被调用。因此，当swoole_server收到SIGUSR1信号并重启全部Worker进程后，onWorkerStart就会被调用。如果在onWorkerStart中require全部的代码文件，每次onWorkerStart后都会重新require一次php文件，这样就能实现代码文件的热更新。\n来看下代码实现：\n```php\n    public function onStart( $serv ) {\n        cli_set_process_title(\"reload_master\");\n    }\n    public function onWorkerStart( $serv , $worker_id) {\n        require_once \"reload_page.php\";\n        Test(); // reload_page.php中定义的一个函数\n    }\n```\n首先，在[onStart](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#2onstart)回调函数中通过php的cli_set_process_title函数设置进程名。\n在[onWorkerStart](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/02.%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.md#3onworkerstart)中，require相关的php文件。\n然后，新建一个reload.sh文件，输入如下内容：\n```shell\necho \"Reloading...\"\ncmd=$(pidof reload_master)\n\nkill -USR1 \"$cmd\"\necho \"Reloaded\"\n```\n这样，就可以通过执行这个脚本重启服务器了。\n[点此查看完整源码](https://github.com/LinkedDestiny/swoole-doc/tree/master/src/04/reload)\n\n##**3.Timer补充：after函数**\n在swoole-1.7.7stable版本中，Timer新增了一个函数[after](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/03.swoole_server%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md#swoole_serverafter)。该函数的作用是在指定的时间间隔后执行回调函数，并且只执行一次。\n这个函数可以弥补Timer本身做不到或者做起来很难的一些定时工作。\n代码如下：\n```php\n$serv->after( 1000 , array($this, 'onAfter') , $str );\n```\n这里指定在1000ms后，执行onAfter回调函数，函数参数为$str。\n举个例子，比如服务器要求在收到某个请求后，在30S后向所有用户发起推送。这样的需求就可以直接用after函数来实现。\n[点此查看完整源码](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/04/swoole_after_server.php)\n\n##**4.Timer进阶：简易crontab**\n未完成\n"
        },
        {
          "name": "05.Swoole的自定义协议功能的使用.md",
          "type": "blob",
          "size": 9.7373046875,
          "content": "# 05.Swoole的自定义协议功能的使用\n---\n#Table of Contents\n\n- [1.为什么要提供自定义协议](#1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE)\n- [2.EOF标记型协议](#2eof%E6%A0%87%E8%AE%B0%E5%9E%8B%E5%8D%8F%E8%AE%AE)\n- [3.固定包头类型协议](#3%E5%9B%BA%E5%AE%9A%E5%8C%85%E5%A4%B4%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE)\n- [4.特别篇：Http协议-Swoole内置的http_server](#4%E7%89%B9%E5%88%AB%E7%AF%87http%E5%8D%8F%E8%AE%AE-swoole%E5%86%85%E7%BD%AE%E7%9A%84http_server)\n\n---\n\n环境说明：\n系统：Ubuntu14.04 （安装教程包括CentOS6.5）<br>\nPHP版本：PHP-5.5.10<br>\nswoole版本：1.7.8-alpha<br>\n\n---\n###**1.为什么要提供自定义协议**\n熟悉TCP通信的朋友都会知道，TCP是一个流式协议。客户端向服务器发送的一段数据，可能并不会被服务器一次就完整的收到;客户端向服务器发送的多段数据，可能服务器一次就收到了全部的数据。而实际应用中，我们希望在服务器端能一次接收**一段完整的**数据，不多也不少。传统的TCP服务器中，往往需要由程序员维护一个缓存区，先将读到的数据放进缓存区中，然后再通过预先设定好的协议内容，来区分一段完整数据的开头、长度和结尾，并将一段完整的数据交给逻辑部分处理。这就是自定义协议的功能。<br>\n而在Swoole中，已经在底层实现了一个数据缓存区，并内置好了几个常用的协议类型，直接在底层做好了数据的拆分，保证了在onReceive回调函数中，一定能收到一个（或数个）完整的数据段。数据缓存区的大小可以通过配置选项[package_max_length](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#19package_max_length)来控制。下面我就将讲解如何使用这些内置协议。<br>\n\n###**2.EOF标记型协议**\n第一个比较常用的协议就是EOF标记协议。协议的内容是通过规定一个一定不会出现在正常数据中的字符或者字符串，用这个来标记一段完整数据的结尾。这样，只要发现这个结尾，就可以认定之前的数据已经结束，可以开始接收一个新的数据段了。<br>\n在Swoole中，可以通过[open_eof_check](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#13open_eof_check)和[package_eof](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#14package_eof)两个配置项来开启。其中，[open_eof_check](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#13open_eof_check)指定开启了EOF检测，[package_eof](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#14package_eof)指定了具体的EOF标记。通过这两个选项，Swoole底层就会自动根据EOF标记来缓存和拆分收到的数据包。示例如下：<br>\n```php\n$this->serv->set(array(\n    'package_max_length' => 8192,\n    'open_eof_check'=> true,\n    'package_eof' => \"\\r\\n\"\n));\n```\n就这样，swoole就已经开启了EOF标记协议的解析。那么让我们来测试一下效果：<br>\n服务器这边：<br>\n```php\n// Server\npublic function onReceive( swoole_server $serv, $fd, $from_id, $data ) {\n    echo \"Get Message From Client {$fd}:{$data}\\n\";\n}\n```\n客户端这边：<br>\n```php\n$msg_eof = \"This is a Msg\\r\\n\";\n\n$i = 0;\nwhile( $i < 100 ) {\n\t$this->client->send( $msg_eof );\n\t$i ++;\n}\n```\n然后运行一下，你会发现：哎不对啊，为什么还是一次收到了好多数据啊！<br>\n这是因为，在Swoole中，采用的不是遍历识别的方法，而只是简单的检查每一次接收到的数据的末尾是不是定义好的EOF标记。因此，在开启EOF检测后，onReceive回调中还是可能会一次收到多个数据包。<br>\n这要怎么办？你会发现，虽然是多个数据包，但是实际上收到的是N个完整的数据片段，那就只需要根据EOF把每个包再拆出来，一个个处理就好啦。<br>\n修改后的服务器端代码如下：<br>\n```php\npublic function onReceive( swoole_server $serv, $fd, $from_id, $data ) {\n\t$data_list = explode(\"\\r\\n\", $data);\n\tforeach ($data_list as $msg) {\n\t\tif( !empty($msg) ) {\n\t\t\techo \"Get Message From Client {$fd}:{$msg}\\n\";\n\t\t}\n\t\t\n\t}\n}\n```\n再次运行，妥了～<br>\n[点此查看完整实例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/05/swoole_eof_server.php)<br>\n另外，如果担心这样运行多段数据会长时间占用Worker，可以采用把数据+fd转发给Task进程的做法。如何转发请读者自己尝试实现。<br>\n\n\n\n###**3.固定包头类型协议**\n固定包头协议是在实际应用中最常用的协议。该协议的内容是规定一个固定长度的包头，在包头的固定位置有一个指定好的字段存放了后续数据的实际长度。这样，服务器端可以先读取固定长度的数据，从中提取出长度，然后再读取指定长度的数据，即可获取一段完整的数据。<br>\n在Swoole中，同样提供了固定包头的协议格式。需要注意的是，Swoole只允许二进制形式的包头，因此，需要使用pack、unpack来打包、解包。<br>\n通过设置[open_length_check](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#15open_length_check)选项，即可打开固定包头协议解析功能。此外还有[package_length_offset](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#16package_length_offset)，[package_body_offset](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#17package_body_offset)和[package_length_type](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#18package_length_type)三个配置项用于控制解析功能。[package_length_offset](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#16package_length_offset)规定了包头中第几个字节开始是长度字段，[package_body_offset](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#17package_body_offset)规定了包头的长度，[package_length_type](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.md#18package_length_type)规定了长度字段的类型。<br>\n具体设置如下：<br>\n```php\n$this->serv->set(array(\n    'package_max_length' => 8192,\n    'open_length_check'=> true,\n    'package_length_offset' => 0,\n    'package_body_offset' => 4,\n    'package_length_type' => 'N'\n));\n```\n具体如何设置这些参数请参考[文档](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/01.swoole_server配置选项.md)<br>\nOK，废话不多讲，直接上实例：<br>\n服务器端：<br>\n```php\npublic function onReceive( swoole_server $serv, $fd, $from_id, $data ) {\n    $length = unpack(\"N\" , $data)[1];\n    echo \"Length = {$length}\\n\";\n    $msg = substr($data,-$length);\n\techo \"Get Message From Client {$fd}:{$msg}\\n\";\n}\n```\n客户端：<br>\n```php\n$msg_length = pack(\"N\" , strlen($msg_normal) ). $msg_normal;\n\n$i = 0;\nwhile( $i < 100 ) {\n\t$this->client->send( $msg_length );\n\t$i ++;\n}\n```\n直接运行，Perfect！<br>\n[点此查看完整实例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/05/swoole_length_check_server.php)<br>\n\n[点此查看其他相关源码](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/05)<br>\n\n###**4.特别篇：Http协议-Swoole内置的http_server**\n从Swoole-1.7.7-stable开始，Swoole在内部封装并实现了一个Http服务器。是的，没错，再也不用在PHP层缓存和解析http协议了，Swoole直接内置Http服务器了。<br>\n创建一个swoole_http_server的代码如下：<br>\n```php\n$http = new swoole_http_server(\"127.0.0.1\", 9501);\n$http->on('request', function (swoole_http_request $request, swoole_http_response $response) {\n    $response->end(\"<h1>Hello Swoole.</h1>\");\n});\n$http->start();\n```\n只需创建一个swoole_http_server对象并设置onRequest回调函数，即可实现一个http服务器。<br>\n在onRequest回调中，共有两个参数。参数`$request`存放了来自客户端的请求，包括Http请求的头部信息、Http请求相关的服务器信息、Http请求的GET和POST参数以及HTTP请求携带的COOKIE信息。参数`$response`用于发送数据给客户端，可以通过该参数设置HTTP响应的Header信息、cookie信息和状态码。<br>\n\n此外，swoole_http_server还提供WebSocket功能，使用此功能需要设置onMessage回调函数，如下：<br>\n```php\n$http_server->on('message', function(swoole_http_request $request, swoole_http_response $response) {\n    echo $request->message;\n    $response->message(json_encode(array(\"data1\", \"data2\")));\n})\n```\n通过`$request->message`获取WebSocket发送来的消息，再通过`$response->message()`回复消息即可。<br>\n[点此查看完整实例](https://github.com/LinkedDestiny/swoole-doc/blob/master/src/05/swoole_http_server.php)<br>\n[点此查看swoole_http_server相关文档](https://github.com/LinkedDestiny/swoole-doc/blob/master/doc/14.swoole_http_server.md)<br>\n\n(最后做个小广告，经过尝试，已经初步将php的Yaf框架移植到了swoole_http_server上，经过测试，swoole-yaf的性能远远超过了nginx+php-fpm+yaf的性能。<br>\n项目地址：https://github.com/LinkedDestiny/swoole-yaf<br>\n我将继续不断完善这个项目，力争能够真正用于线上项目)"
        },
        {
          "name": "06.Swoole的文件操作及文件上传下载服务器.md",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.224609375,
          "content": "Swoole入门教程及文档\n===================\n\n本教程永久停更。\n新教程Gitbook地址：https://www.gitbook.com/book/linkeddestiny/easy-swoole/details\nGithub地址：https://github.com/LinkedDestiny/swoole-concise-guide"
        },
        {
          "name": "SUMMARY.md",
          "type": "blob",
          "size": 0.228515625,
          "content": "* [**1.环境搭建及扩展安装**](01-环境搭建及扩展安装.md)\n* [**2.基础功能入门**](c2.md)\n * [**2.1 Worker**](.md)\n * [**2.2 Task**](c1s2.md)\n * [**2.3 Timer定时器**](c1s2.md)\n * [**2.4 Timer定时器**](c1s2.md)"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}